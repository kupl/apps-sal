["class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        \n        A.sort()\n        prev = A[0]\n        res = 0\n        for num in A[1:]:\n            if num <= prev:\n                prev += 1\n                res += prev-num\n\n            else:\n                prev = num\n        \n        return res\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n\n        n = len(A)\n        A.sort()\n\n        tail_num = A[0]\n        result = 0\n        for i in range(1, n):\n            if A[i] > tail_num:\n                tail_num = A[i]\n            else:\n                tail_num += 1\n\n            # result = result + (tail_num - A[i])\n            result += tail_num - A[i]\n\n        return result\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # Need to have a count\n        # Sort the array.\n        result = 0\n        A.sort()\n        \n        # Start from position 1 and traverse to end. \n        for i in range(1, len(A)):\n            # Check previous value >= current value \n            # If so, increment A[i] by A[i-1] + 1\n            if (A[i-1] >= A[i]):\n                result += A[i-1] - A[i] + 1\n                A[i] = A[i-1] + 1\n        \n        # Return count\n        return result", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(60000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n        \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A: return 0\n        min_num = min(A)\n        max_num = max(A)\n        count = collections.Counter(A)\n        taken = []\n        \n        ans = 0\n        for x in range(100000):\n            if x> max_num and (not taken): break\n            if count[x] >= 2:\n                # taken.extend([x] * (count[x] - 1))\n                taken = taken + [x] * (count[x] - 1)\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n                \n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        \n        taken = []\n        \n        mv = 0\n        \n        for i in range(80000):\n            if count[i] > 1:\n                taken.extend([i] * (count[i] - 1))\n            elif taken and count[i] == 0:\n                mv += (i - taken.pop())\n        return mv", "import collections\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counter = collections.Counter(A)\n        res = 0\n        for i in range(80000):\n            if counter[i] > 1:\n                res += counter[i] - 1\n                counter[i+1] += counter[i] - 1\n        return res", "from collections import Counter\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        hm = dict(Counter(A))\n        stack = [k for k, v in list(hm.items()) if v > 1]\n        ans = 0\n        while stack:\n            k = stack.pop()\n            hm[k + 1] = hm.get(k + 1, 0) + hm[k] - 1\n            ans += hm[k] - 1            \n            hm[k] = 1\n            if hm[k + 1] > 1:\n                stack.append(k + 1)\n                \n        return ans\n        \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A: return 0\n        min_num = min(A)\n        max_num = max(A)\n        count = collections.Counter(A)\n        taken = []\n        \n        ans = 0\n        for x in range(100000):\n            if x > max_num and (not taken): break\n            if count[x] >= 2:\n                # taken.extend([x] * (count[x] - 1))\n                taken = taken + [x] * (count[x] - 1)\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n                \n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(80001):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n        \n", "class Solution:\n    def minIncrementForUnique(self, A):\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(80000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        N, ans = 40000, 0\n        freq, free_slot = [0]*N, 0\n        for n in A:\n            freq[n] += 1\n        for i, r in enumerate(freq):\n            if r:\n                ans += (r*(r-1))//2 + (free_slot - i)*r\n                free_slot += r\n            else:\n                free_slot = max(free_slot, i+1)\n        return ans\n                \n            \n            \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count=collections.Counter(A)\n        used=[]\n        ans=0\n        for x in range(90001):\n            if count[x] >= 2:\n                used.extend([x] * (count[x]-1))\n            elif used and count[x]==0:\n                ans+=x-used.pop()\n        return ans\n\n#         count = collections.Counter(A)\n#         taken = []\n\n#         ans = 0\n#         for x in range(100000):\n#             if count[x] >= 2:\n#                 taken.extend([x] * (count[x] - 1))\n#             elif taken and count[x] == 0:\n#                 ans += x - taken.pop()\n#         return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        n = len(A)\n        A.sort()\n        stack = []\n        ans = 0\n        A.append(A[-1] + n)\n        for i in range(1, n+1):\n            if A[i] == A[i-1]:\n                stack.append(A[i])\n            else:\n                for r in range(1, A[i] - A[i-1]):\n                    if stack:\n                        ans += A[i-1] + r - stack.pop()\n                    else:\n                        break            \n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        ans = 0\n        waiting = 0\n        for x in range(80000):\n            if count[x]>=2:\n                # waiting.extend([x]*(count[x]-1))\n                waiting += count[x]-1;\n                ans -= x * (count[x]-1);\n            elif waiting>0 and count[x]==0:\n                # ans += x - waiting.pop()\n                waiting-=1;\n                ans+=x;\n        return ans\n", "class Solution(object):\n    def minIncrementForUnique(self, A):\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans", "class Solution(object):\n    def minIncrementForUnique(self, A):\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        seen = []\n        \n        res = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                seen.extend([x] * (count[x] - 1))\n            elif seen and count[x] == 0:\n                res += x - seen.pop()\n        \n        return res", "from collections import Counter\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counts = Counter(A)\n        taken = []\n        ans = 0\n        \n        for num in range(90001):\n            num_count = counts[num]\n            if num_count >= 2:\n                taken.extend([num] * (num_count - 1))\n            elif taken and num_count == 0:\n                ans += num - taken.pop()\n                \n        return ans\n", "# https://leetcode.com/problems/minimum-increment-to-make-array-unique/\n\nfrom typing import List\nfrom collections import Counter\n\n\nclass Solution:\n    def minIncrementForUnique_bruteforce(self, A: List[int]) -> int:\n        counts = Counter(A)\n        tot_count = 0\n\n        for n in A:\n            while counts[n] > 1:\n                counts[n] -= 1\n                n += 1\n                counts[n] += 1\n                tot_count += 1\n\n        return tot_count\n\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        counts = Counter(A)\n\n        count = 0\n\n        taken = []\n\n        for i in range(100000):\n            if counts[i] >= 2:\n                taken.extend([i for _ in range(counts[i] - 1)])\n\n            elif taken and counts[i] == 0:\n                count += i - taken.pop()\n\n        return count\n", "class Solution(object):\n    def minIncrementForUnique(self, A):\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n    \n    \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        result = 0\n\n        for i in range(1, len(A)):\n            if A[i] > A[i-1]:\n                continue\n            result += A[i-1]-A[i]+1\n            A[i] = A[i-1]+1\n\n        return result\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        f = 80001 * [0]\n        \n        max_ = -1\n        \n        for i in A:\n            f[i] += 1\n            max_ = max(max_, i)\n        \n        hold = []\n        \n        res = 0\n        \n        for i in range(max_ + len(A) + 1):\n            if hold and f[i] == 0:\n                res += i - hold.pop()\n                \n            elif f[i] > 1:\n                hold = (f[i] - 1) * [i] + hold\n                \n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        f = 80001 * [0]\n        \n        max_ = -1\n        \n        for i in A:\n            f[i] += 1\n            max_ = max(max_, i)\n        \n        hold = []\n        \n        res = 0\n        \n        for i in range(max_ + len(A) + 1):\n            if f[i] == 0 and hold:\n                res += i - hold.pop()\n                \n            elif f[i] > 1:\n                hold = (f[i] - 1) * [i] + hold\n                \n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # [1, 2, 2, 2, 4, 4, 5]\n        #     ^\n        # [1, 2, 2, 2, 4, 4, 5]\n        #        ^\n        # [1, 2, 3, 4, 5, 6, 7] = 8\n        \n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            # print(taken)\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0 \n\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count=collections.Counter(A)\n        #print(count)\n        taken=[]\n        ans=0\n        for x in range(100000):\n            if count[x]>=2:\n                taken.extend([x]*(count[x]-1))\n            elif taken and count[x]==0:\n                ans+=x-taken.pop()\n        return ans", "from collections import Counter\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        cnt, ans = Counter(A), 0\n        \n        for i in range(100000):\n            if cnt[i] > 1:\n                ans += cnt[i] - 1\n                cnt[i + 1] += cnt[i] - 1\n                \n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counter = collections.Counter(A)\n        taken = []\n        result = 0\n        \n        for i in range(100000):\n            if counter[i] > 1:\n                taken.extend([i]*(counter[i]-1))\n            elif taken and counter[i] == 0:\n                result += (i-taken.pop())\n        return result", "from collections import Counter\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # Counting\n        # If there are 2 or more values x in A, save the extra duplicated values to increment later.\n        # If there are 0 values x in A, then a saved value v gets incremented to x.\n        count = Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n\n        return ans\n\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        \n        taken = []\n        \n        ans = 0\n        \n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x]*(count[x] - 1))\n            elif taken and count[x] == 0 :\n                ans += x - taken.pop()\n        return ans\n                \n        \n        \n", "from collections import Counter\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        c=Counter(A)\n        prev=-1\n        ans=0\n        for key in sorted(c):\n            if key<=prev:\n                ans+=(0+c[key]-1)*c[key]//2+c[key]*(prev-key+1)\n                prev=key+c[key]-1+prev-key+1\n            else:\n                ans+=(0+c[key]-1)*c[key]//2\n                prev=key+c[key]-1\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        taken =[]\n        \n        count = collections.Counter(A)\n        moves = 0\n        for i in range(100000):\n            if count[i]>=2:\n                taken.extend([i]*(count[i]-1))\n            elif taken and count[i]==0:\n                moves+=i-taken.pop()\n        return moves\n", "class Solution(object):\n    def minIncrementForUnique(self, A):\n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans\n            \n        \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n        \n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x]-1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n                \n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counts = Counter(A)\n        increments = 0\n\n        # upper bound of the problem\n        for num in range(100000):\n            count = counts[num]\n            if count > 1:\n                increments += count - 1\n                counts[num] = 1\n                if not counts[num + 1]:\n                    counts[num + 1] = 0\n                counts[num + 1] += count - 1\n        \n        return increments", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        \n        count = collections.Counter(A)\n        taken = []\n\n        ans = 0\n        for x in range(100000):\n            if count[x] >= 2:\n                taken.extend([x] * (count[x] - 1))\n            elif taken and count[x] == 0:\n                ans += x - taken.pop()\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        c = collections.Counter(A)\n        mv = 0\n        need = 0\n        for i in sorted(c):\n            \n            mv += max(need - i, 0) * c[i] + c[i] * (c[i] - 1) // 2\n            need = max(need, i) + c[i]\n        return mv", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # if len(A) < 2:\n        #     return 0\n        # index = []\n        # count = 0\n        # init = A[0]\n        # for a in A:\n        #     if a not in index:\n        #         index.append(a)\n        #     else:\n        #         while a in index:\n        #             count+=1\n        #             a += 1\n        #         index.append(a)\n        # return count\n        A.sort()\n        ans = 0\n        for i in range(1,len(A)):\n            if A[i-1] >= A[i]:\n                ans += A[i-1] - A[i] + 1\n                A[i] += A[i-1] - A[i] + 1\n                \n        return ans", "from collections import Counter\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        c=Counter(A)\n        ans=0\n        prev=-1\n        for num in sorted(c):\n            ans+=max(0,(prev-num+1))*c[num]+(c[num]-1)*c[num]//2\n            prev=num+max(0,(prev-num+1))+(c[num]-1)\n            \n        return ans\n                \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        a = sorted(A)\n        \n        res = 0\n        \n        for i in range(0, len(a)-1):\n            if a[i+1] == a[i]:\n                a[i+1] += 1\n                res += 1\n            elif a[i+1] < a[i]:\n                k = a[i] - a[i+1] + 1\n                a[i+1] += k\n                res += k\n\n        return res", "class Solution:\n    def minIncrementForUnique(self, A):\n        bar = -1\n        res = 0\n        for a in sorted(A):\n            if a < bar:\n                res += bar - a\n            bar = max(bar + 1, a + 1)\n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:        \n        # Solution 1\n        A.sort()\n        A.append(100000)\n        result = taken = 0\n        \n        for i in range(1, len(A)):\n            if A[i-1] == A[i]:\n                taken += 1\n                result -= A[i]\n            else:\n                give = min(taken, A[i]-A[i-1]-1)\n                result += give*(give+1)//2 + give*A[i-1]\n                taken -= give\n        return result\n        \n        # Solution 2\n        counter = collections.Counter(A)\n        taken = []\n        result = 0\n        \n        for i in range(100000):\n            if counter[i] > 1:\n                taken.extend([i]*(counter[i]-1))\n            elif taken and counter[i] == 0:\n                result += (i-taken.pop())\n        return result", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        #18:31\n        if not A:\n            return 0\n        A.sort()\n        next_available = A[0]\n        res = 0\n        for a in A:\n            if a >= next_available:\n                next_available = a + 1\n            else:\n                res += next_available - a\n                next_available += 1\n        return res\n            \n", "class Solution:\n    def minIncrementForUnique(self, A):\n        A.sort()\n        ans = 0\n        for i in range(1, len(A)):\n            if A[i] > A[i - 1]: continue\n            ans += A[i - 1] - A[i] + 1\n            A[i] = A[i - 1] + 1\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A):\n        res = need = 0\n        for i in sorted(A):\n            res += max(need - i, 0)\n            need = max(need + 1, i + 1)\n\n        return res\n        \n        \n        \n        \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        res = 0\n        for i in range(1, len(A)):\n            if A[i] <= A[i-1]:\n                res += A[i-1] + 1 - A[i]\n                A[i] = A[i-1] + 1\n        \n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counter = Counter(A)\n        to_place = []\n        \n        min_key = float('inf')\n        for key in counter:\n            min_key = min(min_key, key)\n            if counter[key] > 1:\n                for i in range(counter[key] - 1):\n                    to_place.append(key)\n                counter[key] = 1\n        \n        i = min_key\n        moves = 0 \n        to_place.sort(reverse=True)\n        \n        while to_place:\n            if i not in counter and i > to_place[-1]:\n                moves += i - to_place.pop()\n            i += 1\n        return moves\n    \n    # [3,2,1,2,1,7]\n    \n    # counter:{1:1, 2:1, 5:1, 7:1}\n    # to_place =[5, 1]\n    # i = 6\n    # moves =  \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        A.append(100000)\n        ans = taken = 0\n\n        for i in range(1, len(A)):\n            if A[i-1] == A[i]:\n                taken += 1\n                ans -= A[i]\n            else:\n\n                give = min(taken, A[i] - A[i-1] - 1)\n                #print(give)\n                ans += give * (give + 1) / 2 + give * A[i-1]\n                taken -= give\n\n        return int(ans)", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        A.sort()\n        i = 1\n        stack = []\n        current = A[0]\n        moves = 0\n        while i < len(A):\n            if A[i] == A[i-1]:\n                stack.append(A[i])\n            elif len(stack) > 0:\n                for num in range(current + 1, A[i]):\n                    moves += num - stack.pop()\n                    if not stack:\n                        break\n            current = A[i]\n            i += 1\n        \n        while stack:\n            moves += current + 1 - stack.pop()\n            current += 1\n        return moves\n                \n", "import collections\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        res, need = 0, 0\n        numCnt = collections.OrderedDict()\n        for a in A:\n            if a not in numCnt:\n                numCnt[a] = 1\n            else:\n                numCnt[a] += 1\n        while numCnt:\n            num, count = numCnt.popitem(last=False)\n            res += max((need - num)*count, 0) + count*(count-1)//2\n            need = max(num, need) + count\n            \n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        ans = 0\n        for i in range(1, len(A)):\n            if i > 0 and A[i] <= A[i-1]:\n                target = A[i-1] + 1\n                ans += target - A[i]\n                A[i] = target\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = 0\n        A = sorted(A)\n\n        for i in range(len(A) - 1):\n            increment = max(0, A[i] - A[i + 1] + 1)\n            A[i + 1] += increment\n            count += increment\n\n        return count", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if len(A) == 0:\n            return 0\n        A.sort()\n        result = 0\n        for i in range(1,len(A)):\n            result += max(0, A[i-1] - A[i] + 1)\n            A[i] += max(0, A[i-1] - A[i] + 1)\n        return result", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if len(A) < 2:\n            return 0\n        A.sort()\n        N = len(A)\n        res = 0\n        start = 0\n        for i in range(1,N):\n            if A[i] - A[start] >= i - start:\n                start = i\n            else:\n                res += i-start-(A[i]-A[start])\n        return res            \n                \n", "from typing import List\nfrom collections import deque, Counter\n\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # print('-----')\n        # print(f'A: {A}')\n\n        cs = sorted([n, count] for n, count in list(Counter(A).items()))\n        stack = deque(cs[::-1])\n        # print(f'stack: {stack}')\n\n        numOps = 0\n\n        while stack:\n            n, count = stack.pop()\n            # print(f'n={n} count={count} numOps={numOps}', end=' ')\n            numOps += count - 1\n            if count > 1 and stack and stack[-1][0] == n + 1:\n                stack[-1][1] += count - 1\n                # print(f'move to {n+1, stack[-1][1]} stack={stack}')\n            elif count > 1:\n                stack.append([n+1, count-1])\n                # print(f'upgrade to {n+1, count-1} stack={stack}')\n            # else:\n            #     print('')\n\n        return numOps\n\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        ans = 0\n        hp, hp2 = [], []\n        n, mina,maxa = len(A), min(A), max(A)\n        seen = set()\n        for a in A:\n            if a not in seen:\n                seen.add(a)\n            else:\n                heapq.heappush(hp, a)\n        for i in range(mina + 1, maxa + n):\n            if i not in seen:\n                heapq.heappush(hp2, i)\n        while hp:\n            while hp2[0] <= hp[0]:\n                heapq.heappop(hp2)\n            ans += heapq.heappop(hp2) - heapq.heappop(hp)\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        A.sort()\n        temp = A[0] \n        res = 0\n        for i in range(1, len(A)):\n            if A[i] > temp:\n                temp = A[i]\n            else:\n                res += (temp+1-A[i])\n                temp += 1\n        return res\n                \n            \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        A_sum = sum(A)\n        cnt = 0\n        for i in range(1, len(A)):\n            if A[i] <= A[i - 1]:\n                cnt += (A[i] - A[i - 1] + 1)\n                \n                A[i] = A[i - 1] + 1\n        return sum(A) - A_sum", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        A.sort()\n        B=[A[0]]\n        move=0\n        for a in A[1:]:\n            if a<=B[-1]:\n                step=B[-1]-a+1\n                move+=step\n                a=a+step\n            B.append(a)\n                \n        return move\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        ans = 0\n        c = Counter(A)\n        backlog = 0\n        for i in range(min(A), max(A)+1):\n            if i in c:\n                backlog += c[i] - 1\n            elif i not in c and backlog:\n                ans += i\n                backlog -= 1\n        ans += sum(range(i+1, i+1+backlog))       \n        return sum(c.keys()) + ans - sum(A)\n        \n        \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # A[i] is non negative \n        seen = set()\n        replicates = []\n        for i in A: #O(n)\n            if i not in seen:\n                seen.add(i)\n            else:\n                replicates.append(i)\n        replicates.sort() #O(nlogn)\n        res = 0\n        next_candidates = 0\n        while replicates: #O(n)\n            num = replicates.pop(0)\n            next_candidates = max(next_candidates, num)\n            while next_candidates in seen:\n                next_candidates += 1 \n            seen.add(next_candidates)\n            res += next_candidates - num \n        return res ", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A=sorted(A)\n        ans=0\n        if len(A)==0:\n            return 0\n        prev=A[0]\n        i=1\n        while i< len(A):\n            if A[i]<=prev:\n                ans+=prev-A[i]+1\n                prev+=1\n            else:\n                prev=A[i]\n            i+=1\n        return ans\n                \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        res = 0\n        expect = 0\n        for i in sorted(A):\n            res += max(expect-i, 0)\n            expect = max(i+1, expect+1)\n        return res\n        \n        \n        \n        # import collections\n        # cnt = collections.Counter(A)\n        \n", "import collections\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        res, need = 0, 0\n        numCnt = collections.OrderedDict()\n        for a in A:\n            if a not in numCnt:\n                numCnt[a] = 1\n            else:\n                numCnt[a] += 1\n        print(numCnt, type(numCnt))\n        while numCnt:\n            num, count = numCnt.popitem(last=False)\n            res += max((need - num)*count, 0) + count*(count-1)//2\n            need = max(num, need) + count\n            \n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        dup = []\n        seen = set()\n        for i in A:\n            if i not in seen:\n                seen.add(i)\n            else:\n                dup.append(i)\n        curr = 0\n        j = 0\n        i = -1\n        ans = 0\n        \n        print(seen)\n        while j < len(dup):\n            if i ==dup[j]:\n                curr = max(curr, i)\n                while curr in seen:\n                    curr +=1\n                seen.add(curr)\n                ans += curr - dup[j]\n                j+=1\n                \n            else:\n                i+=1\n        return ans\n", "from heapq import heappop, heappush, heapify\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        li=[]\n        A.sort()\n        n=len(A)\n        if n==0:\n            return 0\n        used={}\n        used[A[0]]=1\n        for i in range(1,n):\n            if A[i]==A[i-1]:\n                li.append(A[i])\n            else:\n                used[A[i]]=1\n        res=0\n        t=A[0]\n        for x in li:\n            while used.get(t,0)!=0 or t<x:\n                t+=1\n            used[t]=1\n            res+=t-x\n        return res\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        dup = []\n        seen = set()\n        for i in A:\n            if i not in seen:\n                seen.add(i)\n            else:\n                dup.append(i)\n        curr = 0\n        j = 0\n        i = -1\n        ans = 0\n        while j < len(dup):\n            if i ==dup[j]:\n                curr = max(curr, i)\n                while curr in seen:\n                    curr +=1\n                seen.add(curr)\n                ans += curr - dup[j]\n                j+=1\n                \n            else:\n                i+=1\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        def find(x):\n            root[x] = find(root[x]+1) if x in root else x\n            return root[x]\n        root = {}\n        return sum(find(i) - i for i in A)\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        res = 0\n\n        for i in range(len(A)):\n            if i > 0 and A[i] <= A[i-1]:\n                res += ((A[i-1] + 1) - A[i])\n                A[i] += ((A[i-1] + 1) - A[i])\n        return res\n        \n            \n                \n            \n            \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        roots = {}\n        def find(k):\n            roots[k] = k if k not in roots else find(roots[k] + 1)\n            return roots[k]\n        return sum(find(a) - a for a in A)", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        a = sorted(A)\n        b = []\n        \n        if a == sorted(set(a)):\n            return 0\n        \n        res = 0\n        \n        for i in range(0, len(a)-1):\n            print('now: ', a[i], a[i+1])\n            if a[i+1] == a[i]:\n                a[i+1] += 1\n                res += 1\n            else:\n                if a[i+1] < a[i]:\n                    k = a[i] - a[i+1] + 1\n                    a[i+1] += k\n                    res += k\n                    \n\n        \n        print(b)\n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        diff = 0\n        stack = []\n        c = Counter(A)\n        for i in range(min(c.keys()), max(c.keys())+1):\n            if i in c:\n                stack += [i] * (c[i] - 1)\n            elif i not in c and stack:\n                diff += i - stack.pop()\n        return diff + sum(range(i+1, i+1+len(stack))) - sum(stack)\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        ans = 0\n        for i, x in enumerate(A):\n            if i >= 1:\n                if A[i] <= A[i - 1]:\n                    ans += A[i - 1] - A[i] + 1\n                    A[i] = A[i - 1] + 1\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if len(A) < 2:\n            return 0\n        A.sort()\n        ans, last = 0, A[0]-1\n        for n in A:\n            if n > last:\n                last = n\n            else:\n                ans += (last-n+1)\n                last += 1\n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A or len(A) == 1:\n            return 0\n        \n        ans = 0\n        A.sort()\n        for i in range(1,len(A)):\n            if A[i-1] >= A[i]:\n                gap = abs(A[i-1]-A[i]) + 1\n                A[i] += gap\n                ans += gap\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        n = len(A)\n        if n < 2: return 0\n        A.sort()\n        avails = deque()\n        for i in range(1, n):\n            if A[i] > A[i - 1] + 1:\n                avails.append([A[i - 1] + 1, A[i]])\n            if i == n - 1:\n                avails.append([A[i] + 1, A[i] + 2])\n        l, r = avails.popleft()\n        nexts = deque(range(l, r))\n        r = nexts.popleft()\n        pre = A[0]\n        res = 0\n        for i in range(1, n):\n            if A[i] == pre:\n                while r <= A[i]:\n                    if nexts:\n                        r = nexts.popleft()\n                    elif avails:\n                        l, r = avails.popleft()\n                        nexts = deque(range(l, r))\n                        r = nexts.popleft()\n                    else:\n                        r += 1\n                res += r - A[i]\n                A[i] = r\n                if nexts:\n                    r = nexts.popleft()\n                elif avails:\n                    l, r = avails.popleft()\n                    nexts = deque(range(l, r))\n                    r = nexts.popleft()\n                else:\n                    r += 1\n            else:\n                pre = A[i]\n        return res", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n\n    \n        n = {}\n        def find(x):\n            n[x] = find(n[x] + 1) if x in n else x\n            return n[x]\n        return sum(find(a) - a for a in A)", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        n = {}\n        ans = 0\n        \n        def find(j):\n            n[j] = find(n[j]+1) if j in n else j\n            return n[j]\n        \n        for i in A:         \n            ans += find(i) - i\n            #print (n[i])\n        return ans\n        \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n\n    \n        n = {}\n        def find(x):\n            if x in n:\n                n[x] = find(n[x] + 1) \n            else:\n                n[x] = x\n            return n[x]\n        ans = 0\n        for a in A:\n            ans += find(a) - a\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A):\n        root = {}\n        def find(x):\n            root[x] = find(root[x] + 1) if x in root else x\n            return root[x]\n        return sum(find(a) - a for a in A)", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A = sorted(A)\n        if not A:\n            return 0\n        \n        k = A[0]\n        moves = 0\n        for i in range(1, len(A)):\n            if A[i] <= k:\n                moves += k + 1 - A[i]\n                A[i] = k + 1\n            k = A[i]\n        return moves", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        answer = 0\n        \n        for i in range(1, len(A)):\n            if A[i - 1] >= A[i]:\n                answer += A[i - 1] - A[i] + 1\n                A[i] += A[i - 1] - A[i] + 1\n        \n        return answer", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        res = need = 0\n        for i in sorted(A):\n            res += max(need - i, 0)\n            need = max(need + 1, i + 1)\n        return res", "class Solution:\n    def minIncrementForUnique(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        arr.sort()\n        s, ans = arr[0], 0\n        for i in arr:\n            ans += max(0, s - i)\n            s = max(s + 1, i + 1)\n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if len(A)==0 or len(A)==1:\n            return 0\n        A.sort()\n        cnt=0\n        for i in range(1,len(A)):\n            if A[i-1]>=A[i]:\n                temp=A[i]\n                A[i]=A[i-1]+1\n                cnt+=A[i]-temp\n        #print(A)\n        return cnt", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        ret = 0\n        for i in range(1, len(A)):\n            p = A[i - 1]\n            c = A[i]\n            if p >= c:\n                ret += p - c + 1\n                A[i] = p + 1\n        return ret", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if len(A)==0 or len(A)==1:\n            return 0\n        A.sort()\n        cnt=0\n        for i in range(1,len(A)):\n            if A[i-1]>=A[i]:\n                temp=A[i]\n                A[i]=A[i-1]+1\n                cnt+=A[i]-temp\n        print(A)\n        return cnt", "from collections import defaultdict\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        H = defaultdict(int)\n        for a in A:\n            H[a] += 1\n            \n        V = sorted(H.keys())\n        \n        ans = 0\n        while True:\n            if len(H) == 0:\n                return ans\n            elif len(H) == 1:\n                v = min(H.keys())\n                ans += (H[v] - 1) * H[v] // 2\n                del H[v]\n                del V[0]\n            else:\n                v1, v2 = V[0], V[1]\n                if v1 + H[v1] - 1 < v2:\n                    ans += (H[v1] - 1) * H[v1] // 2\n                    del H[v1]\n                    del V[0]\n                else:\n                    ans += (v2 - v1 - 1) * (v2 - v1) // 2\n                    ans += (H[v1] - v2 + v1) * (v2 - v1)\n                    H[v2] += (H[v1] - v2 + v1)\n                    del H[v1]\n                    del V[0]\n                    \n\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        A.sort()\n        results = 0\n        prev = None\n        for num in A:\n            if prev != None and num <= prev:\n                results += (prev + 1) - num\n                prev = prev + 1\n            else:\n                prev = num\n        return results", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A = sorted(A)\n        \n        nums = set()\n        move = 0\n        prev = -1\n        for i in range(len(A)):\n            cur_num = A[i]\n            if cur_num <= prev:\n                cur_num = prev + 1\n            while cur_num in nums:\n                cur_num += 1\n            nums.add(cur_num)\n            move += (cur_num - A[i])\n            prev = cur_num\n            \n            \n        return move", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        current=0\n        res=0\n        for i in range(len(A)):\n            if A[i]<=current:\n                res+=current-A[i]\n                current=current+1\n            else:\n                current=A[i]+1\n        return res\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        # sort and traverse 93.88%\n        A.sort()\n        count = 0\n        \n        for i in range(1, len(A)):\n            if A[i] <= A[i - 1]:\n                residual = A[i - 1] - A[i] + 1\n                A[i] += residual\n                count += residual\n        \n        return count\n                \n        \n        # naive solution TLE O(n^2)\n#         visited = set()\n#         count = 0\n        \n#         for num in A:\n#             if num in visited:\n#                 while num in visited:\n#                     num += 1\n#                     count += 1\n#             visited.add(num)\n        \n#         return count\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        count = 0\n        \n        for i in range(1, len(A)):\n            if A[i] <= A[i - 1]:\n                residual = A[i - 1] - A[i] + 1\n                A[i] += residual\n                count += residual\n        \n        return count\n                \n        \n        # naive solution TLE O(n^2)\n#         visited = set()\n#         count = 0\n        \n#         for num in A:\n#             if num in visited:\n#                 while num in visited:\n#                     num += 1\n#                     count += 1\n#             visited.add(num)\n        \n#         return count\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        moves = 0\n        for i in range(1, len(A)):\n            if A[i] <= A[i-1]:\n                moves += A[i-1]+1 - A[i]\n                A[i] = A[i-1]+1\n            prev = A[i]\n        return moves\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n      \n        # while nums:\n        #     for i in range(1,len(nums)+1):\n        #         if i == len(nums): return step\n        #         if nums[i] <= nums[i-1]:\n        #             step += nums[i-1] - nums[i] + 1\n        #             nums[i] += nums[i-1] - nums[i] + 1\n        #             nums = nums[i:]\n        #             break\n        # return step\n        step = curr = 0\n        \n        for e in sorted(A):\n           \n            step += max(curr-e, 0)\n            curr = max(curr, e)+1\n        return step\n            \n                \n", "from collections import defaultdict\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        \n        histogram = defaultdict(int)\n        for num in A:\n            histogram[num] += 1\n        \n        count = 0\n        taken = []\n        for num in range(0, 100000):\n            if num in histogram and histogram[num] > 1:\n                taken += [num] * (histogram[num] - 1)\n            elif taken and num not in histogram:\n                count += num - taken.pop()\n        return count\n", "from collections import defaultdict\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n\n        A.sort()\n        to_merge = []\n        moves = 0\n        for i in range(1, len(A)):\n            if A[i] == A[i-1]:\n                to_merge.append(A[i])\n            elif to_merge:\n                j = A[i-1]\n                for j in range(A[i-1] + 1, A[i]):\n                    m = to_merge.pop(0)\n                    moves += (j - m)\n                    if not to_merge:\n                        break\n        if to_merge:\n            j = A[-1] + 1        \n            while to_merge:\n                m = to_merge.pop(0)\n                moves += (j - m)\n                j += 1\n            \n        return moves\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        \n        if A == []:\n            return 0\n        else:\n            A.sort()\n            pre_item = A[0]\n            moves = 0\n            for i in range(1, len(A)):\n                cur_item = A[i]\n                if (A[i] < pre_item) or (A[i] == pre_item):\n\n                    moves = moves + pre_item + 1 - A[i]\n                    A[i] = pre_item + 1\n                pre_item = A[i]\n            return moves", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        rez = 0\n\n        for index in range(1, len(A)):\n            if A[index - 1] >= A[index]:\n                rez += A[index - 1] - A[index] + 1\n                A[index] = A[index - 1] + 1\n\n        return rez\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A: return 0\n        repeat = collections.deque()\n        A = sorted(A)\n        for i,v in enumerate(A):\n            if i and v == A[i-1]:\n                repeat.append(v)\n        slots = sorted(list(set(list(range(A[0],A[-1] + 1))) - set(A)))\n        res = 0\n        for i in slots:\n            if repeat and i > repeat[0]:\n                res += i - repeat[0]\n                repeat.popleft()\n        return res - sum(repeat) + sum([i for i in range(A[-1]+1,A[-1]+1+len(repeat))])", "class Solution:\n    def minIncrementForUnique(self, A):\n        res = need = 0\n        for i in sorted(A):\n            res += max(need - i, 0)\n            need = max(need + 1, i + 1)\n            print((res , need))\n        return res\n        \n        \n        \n        \n", "from collections import defaultdict\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count_for_val = defaultdict(lambda:0)\n        dups = set()\n        for i in A:\n            count_for_val[i] += 1\n            if count_for_val[i] > 1:\n                dups.add(i)\n        output = 0\n        dups = sorted(dups)\n        if not len(dups):\n            return 0\n        orig = dups[0]\n        for dup in dups:\n            count = count_for_val[dup] - 1\n            while count > 0:\n                orig += 1\n                if orig > dup and orig not in count_for_val:\n                    count_for_val[orig] = 1\n                    output = output + (orig - dup)\n                    count -= 1\n        return output\n        \n                \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        A.sort()\n        ans = 0\n        for i in range(1,len(A)):\n            if(A[i-1]>=A[i]):\n                ans += A[i-1]-A[i]+1\n                A[i] += A[i-1]-A[i]+1\n                \n        return ans", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        root = {}\n        def find(x):\n            root[x] = find(root[x] + 1) if x in root else x\n            return root[x]\n        return sum(find(a) - a for a in A)", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count=collections.Counter(A)\n        used=[]\n        ans=0\n        for x in range(41000):\n            if count[x] >= 2:\n                used.extend([x] * (count[x]-1))\n            elif used and count[x]==0:\n                ans+=x-used.pop()\n        return ans\n\n#         count = collections.Counter(A)\n#         taken = []\n\n#         ans = 0\n#         for x in range(100000):\n#             if count[x] >= 2:\n#                 taken.extend([x] * (count[x] - 1))\n#             elif taken and count[x] == 0:\n#                 ans += x - taken.pop()\n#         return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count=collections.Counter(A)\n        used=[]\n        ans=0\n        for x in range(40500):\n            if count[x] >= 2:\n                used.extend([x] * (count[x]-1))\n            elif used and count[x]==0:\n                ans+=x-used.pop()\n        return ans\n\n#         count = collections.Counter(A)\n#         taken = []\n\n#         ans = 0\n#         for x in range(100000):\n#             if count[x] >= 2:\n#                 taken.extend([x] * (count[x] - 1))\n#             elif taken and count[x] == 0:\n#                 ans += x - taken.pop()\n#         return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n      \n        # while nums:\n        #     for i in range(1,len(nums)+1):\n        #         if i == len(nums): return step\n        #         if nums[i] <= nums[i-1]:\n        #             step += nums[i-1] - nums[i] + 1\n        #             nums[i] += nums[i-1] - nums[i] + 1\n        #             nums = nums[i:]\n        #             break\n        # return step\n        step = 0\n        if not A or len(A) ==1: return step\n        prev = float('-inf')\n        nums = sorted(A)\n        for e in nums:\n            if e <= prev:\n                step += prev-e + 1\n                prev += 1\n            else: prev = e\n        return step\n            \n                \n", "from collections import Counter\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        c=Counter(A)\n        ans=0\n        prev=-1\n        for num in sorted(c):\n            if num<=prev:\n                ans+=(prev-num+1)*c[num]+(c[num]-1)*c[num]//2\n                prev=num+(prev-num+1)+(c[num]-1)\n            else:\n                ans+=((c[num]-1)*c[num]//2)\n                prev=num+(c[num]-1)\n        return ans\n                \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        c = Counter(A)\n        print(c)\n        res = need = 0\n        for i in sorted(A):\n            res += max(need - i, 0)\n            need = max(need + 1, i + 1)\n        return res", "from collections import Counter\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counts = Counter(A)\n        taken = []\n        ans = 0\n        \n        for num in range(41000):\n            num_count = counts[num]\n            if num_count >= 2:\n                taken.extend([num] * (num_count - 1))\n            elif taken and num_count == 0:\n                ans += num - taken.pop()\n                \n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        dic = dict(collections.Counter(A))\n        sortedDic = sorted(list(dic.items()), key=lambda x: x[0])\n        \n        result = 0\n        \n        while sortedDic:\n            num, freq = sortedDic.pop(0)\n            if freq > 1:\n                diff = freq - 1\n                \n                if sortedDic and sortedDic[0][0] == num + 1:\n                    sortedDic[0] = (num + 1, diff + sortedDic[0][1])\n                else:\n                    sortedDic.insert(0, (num + 1, diff))\n                \n                result += diff\n        \n        return result\n                \n                \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        #\n        count = collections.Counter(A)\n        to_move = []\n        num_moves = 0\n        end = 50000\n        \n        for i in range(end):\n            if count[i] >= 2:\n                to_move.extend([i] * (count[i] - 1))\n            elif to_move and count[i] == 0:\n                num_moves += i - to_move.pop()\n        \n        return num_moves\n            \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        #O(n) T | O(n) S\n        count = collections.Counter(A)\n        to_move = []\n        num_moves = 0\n        end = 50000\n        \n        for i in range(end):\n            if count[i] >= 2:\n                to_move.extend([i] * (count[i] - 1))\n            elif to_move and count[i] == 0:\n                num_moves += i - to_move.pop()\n        \n        return num_moves\n            \n", "from collections import Counter\n\nclass Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        counts = Counter(A)\n        taken = []\n        ans = 0\n        \n        for num in range(50001):\n            num_count = counts[num]\n            if num_count >= 2:\n                taken.extend([num] * (num_count - 1))\n            elif taken and num_count == 0:\n                ans += num - taken.pop()\n                \n        return ans\n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        count = collections.Counter(A)\n        taken = []\n        moves = 0\n        \n        for i in range(45000):\n            c = count[i]\n            if c >= 2:\n                taken += (c-1) * [i]\n            elif len(taken) > 0 and c == 0:\n                moves += i - taken.pop()\n        \n        return moves\n        \n            \n            \n", "class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        cnt = [0 for i in range(80001)]\n        minv, ans, n = 40001, 0, len(A)\n        for i in A:\n            cnt[i] += 1\n            minv = min(minv, i)\n        for i in range(minv, 80001):\n            if not n:\n                break\n            if cnt[i] > 1:\n                cnt[i + 1] += cnt[i] - 1\n                ans += cnt[i] - 1\n            if cnt[i] == 1:\n                n -= 1\n        return ans"]
["def possible(a):\n    ans = set()\n    s = set()\n    lmax = 0\n    for i in range(len(a)):\n        lmax = max(lmax, a[i])\n        s.add(a[i])\n        if lmax == i + 1 and len(s) == i + 1:\n            ans.add(i + 1)\n    return ans\n\n\nt = int(input())\nfor case_num in range(t):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    left = possible(a)\n    a.reverse()\n    right = possible(a)\n    ans = []\n    for l in left:\n        if n - l in right:\n            ans.append(l)\n    print(len(ans))\n    for l in ans:\n        print(l, n - l)\n", "import sys\ninput=sys.stdin.readline\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    aa=list(map(int,input().split()))\n    ss=set()\n    \n    st=0\n    ind=1\n    pre=[0 for i in range(n)]\n    for i in range(n):\n        if aa[i] in ss:\n            break\n        ss.add(aa[i])\n        while ind<=len(ss):\n            if ind in ss:\n                ind+=1\n            else:\n                break\n        if len(ss)!=ind-1:\n            pre[i]=0\n        else:\n            pre[i]=ind\n    ind=1\n   # print(pre)\n    ss=set()\n    suff=[0 for i in range(n)]\n    for i in range(n-1,-1,-1):\n        if aa[i] in ss:\n            break\n        ss.add(aa[i])\n        while ind<=len(ss):\n            if ind in ss:\n                ind+=1\n            else:\n                break\n        if len(ss)!=ind-1:\n            suff[i]=0\n        else:\n            suff[i]=ind\n    tot=0\n    ans=[]\n    for i in range(n-1):\n        if pre[i]>0 and suff[i+1]>0:\n            tot+=1\n            ans.append([i+1,n-i-1])\n    print(tot)\n    for i in ans:\n        print(i[0],i[1])\n        \n\n", "# @author \n\nimport sys\n\nclass BDreamoonLikesPermutations:\n    def solve(self):\n        for _ in range(int(input())):\n            \n            def is_perm(a):\n                return len(set(a)) == len(a) and min(a) == 1 and max(a) == len(a)\n            \n            n = int(input())\n            a = [int(_) for _ in input().split()]\n            done = set()\n            ans = set()\n            i = 0\n            for i in range(n):\n                if a[i] in done:\n                    break\n                done.add(a[i])\n            \n            if is_perm(a[:i]) and is_perm(a[i:]):\n                ans.add((i, n - i))\n\n            done = set()\n            for i in range(n - 1, -1, -1):\n                if a[i] in done:\n                    break\n                done.add(a[i])\n\n            if is_perm(a[:i + 1]) and is_perm(a[i + 1:]):\n                ans.add((i + 1, n - i - 1))\n\n            print(len(ans))\n            for sol in ans:\n                print(*sol)\n\nsolver = BDreamoonLikesPermutations()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "def readIntArray():\n    return list(map(int,input().split()))\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = readIntArray()\n    mp = {}\n    for val in a:\n        if val not in mp:\n            mp[val] = 0\n        mp[val] += 1\n    l1 = max(a)\n    l2 = n - l1\n    if l2 <= 0:\n        print(0)\n        continue\n    good = True\n    for i in range(1, l2 + 1):\n        if i not in mp or mp[i] != 2:\n            good = False\n            break\n    for i in range(l2 + 1, l1 + 1):\n        if i not in mp or mp[i] != 1:\n            good = False\n            break\n    if not good:\n        print(0)\n        continue\n    mp = {}\n    ans = set()\n    cur = 0\n    st = set()\n    used = set()\n    for i in range(n):\n        if a[i] in used:\n            break\n        st.add(a[i])\n        used.add(a[i])\n        while cur + 1 in st:\n            st.remove(cur + 1)\n            cur += 1\n        if cur == l1 or cur == l2 and len(st) == 0:\n            ans.add((cur, n - cur))\n    print(len(ans))\n    for val in ans:\n        print(val[0], val[1])\n", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    mx = max(a)\n    sols = []\n    if mx < n:\n        l1 = list(sorted(a[:mx]))\n        l2 = list(sorted(a[mx:]))\n        rl1 = list(range(1, mx+1))\n        rl2 = list(range(1, n-mx+1))\n        if l1 == rl1 and l2 == rl2:\n            sols.append((mx, n - mx))\n        l1 = list(sorted(a[:n-mx]))\n        l2 = list(sorted(a[n-mx:]))\n        if mx*2 != n and l1 == rl2 and l2 == rl1:\n            sols.append((n-mx, mx))\n    print(len(sols))\n    for p in sols:\n        print(*p)\n", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    liste = list(map(int, input().split()))\n    vis = [0 for i in range(n)]\n    can = [0 for i in range(n)]\n    can2 = [0 for i in range(n)]\n    maxi = 0\n    for i in range(1, n):\n        if (vis[liste[i-1]]):\n            break\n        vis[liste[i-1]] = 1\n        maxi = max(maxi, liste[i-1])\n        if (maxi == i):\n            can[maxi] = 1\n    liste = liste[::-1]\n    maxi = 0\n    vis = [0 for i in range(n)]\n    for i in range(1, n):\n        if (vis[liste[i-1]]):\n            break\n        vis[liste[i-1]] = 1\n        maxi = max(maxi, liste[i-1])\n        if (maxi == i):\n            can2[maxi] = 1\n    count = 0\n    for i in range(1, n):\n        if (can[i] and can2[n-i]):\n            count += 1\n    print(count)\n    for i in range(1, n):\n        if (can[i] and can2[n-i]):\n            print(i, n-i)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dpF = [0 for i in range(n)]\n    dpB = [0 for i in range(n)]\n    noRep = 1\n    r = {}\n    m = 0\n    for i in range(n):\n        if r.get(a[i]) == None:\n            r[a[i]] = 1\n            m = max(m, a[i])\n            if m == i + 1:\n                dpF[i] = 1\n        else:\n            break\n    r = {}\n    m = 0\n    for i in range(n - 1, -1, -1):\n        if r.get(a[i]) == None:\n            r[a[i]] = 1\n            m = max(m, a[i])\n            if m == n - i:\n                dpB[i] = 1\n        else:\n            break\n    # print(dpF)\n    # print(dpB)\n    ans = 0\n    ansList = []\n    for i in range(n - 1):\n        if dpF[i] == 1 and dpB[i + 1] == 1:\n            ans += 1\n            ansList.append([i + 1, n - i - 1])\n    print(ans)\n    for i in ansList:\n        print(i[0], i[1])", "from math import *\n\nmod = 1000000007\n\nfor zz in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    ans = []\n    cs = set()\n    d = {}\n    c = 0\n    for i in range(n):\n        if a[i] not in d:\n            c += 1\n            d[a[i]] = 0\n        d[a[i]] += 1\n    mv = 0\n    m = [0] * n\n    m[-1] = a[-1]\n    for i in range(n - 2, -1, -1):\n        m[i] = max(m[i + 1], a[i])\n\n    for i in range(n):\n        mv = max(a[i], mv)\n        if a[i] in cs:\n            break\n        cs.add(a[i])\n        d[a[i]] -= 1\n        if d[a[i]] <= 0:\n            c -= 1\n        if mv == i + 1 and c == n - i - 1 and m[i + 1] == n - i - 1:\n            ans.append(i)\n    print(len(ans))\n    for i in ans:\n        print(i + 1, n - i - 1)\n", "def per(X):\n    S=set(X)\n    if not len(X)==len(S):\n        return False\n    for i in range(1,len(X)+1):\n        if i not in S: return False\n    return True\nfor y in range(int(input())):\n    n=int(input())\n    L=list(map(int,input().split()))\n    m=max(L)\n    r=[]\n    if n!=m:\n        if per(L[:m]) and per(L[m:]):\n            r.append((m,n-m))\n        if per(L[-m:]) and per(L[:-m]):\n            r.append((n-m,m))\n    r=list(set(r))\n    print(len(r))\n    for a,b in r:\n        print(a,b)", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    seen = [False] * (n+1)\n    ans = set()\n    for i, x in enumerate(a):\n        if seen[x]:\n            if sorted(a[:i]) == list(range(1, i+1)) and sorted(a[i:]) == list(range(1, n-i+1)):\n                ans.add((i, n-i))\n            break\n        seen[x] = True\n    seen = [False] * (n+1)\n    for i, x in list(enumerate(a))[::-1]:\n        if seen[x]:\n            if sorted(a[:i+1]) == list(range(1, i+2)) and sorted(a[i+1:]) == list(range(1, n-i)):\n                ans.add((i+1, n-i-1))\n            break\n        seen[x] = True\n    print(len(ans))\n    for l1, l2 in ans:\n        print(l1, l2)\n\n", "import sys\ninput=sys.stdin.readline\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    d=dict()\n    demand=1\n    pre=[0]*n\n    post=[0]*n\n    for i in range(n):\n        d[arr[i]]=1\n        if(demand in d):\n            while(demand in d):\n                demand+=1\n            pre[i]=demand-1\n    d2=dict()\n    #print(pre)\n    demand=1\n    for i in range(n-1,-1,-1):\n        d2[arr[i]]=1\n        if(demand in d2):\n            while(demand in d2):\n                demand+=1\n            post[i]=demand-1\n    #print(post)\n    l=[]\n    for i in range(1,n):\n        if(post[i]+pre[i-1]==n):\n            l+=[[pre[i-1],post[i]]]\n    print(len(l))\n    for i in l:\n        print(*i)\n    \n            \n", "import heapq, sys\n\n\ndef ps(l):\n    n = len(l)\n    nxt = 1\n    heap = []\n    ans = []\n    for i in range(n):\n        heapq.heappush(heap, l[i])\n        while heap and heap[0] == nxt:\n            nxt += 1\n            heapq.heappop(heap)\n        if not heap:\n            ans.append(i)\n    return ans\n\n\nfor q in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [int(i) for i in sys.stdin.readline().split()]\n    st = set(ps(d))\n    # print(st)\n    d.reverse()\n    anss = []\n    ap = ps(d)\n    # print(ap)\n    for a in ap:\n        b = n-2-a\n        if b in st:\n            anss.append(str(b+1)+' '+ str(n - b - 1) + '\\n')\n    sys.stdout.write(str(len(anss)) + '\\n')\n    sys.stdout.write(''.join(anss))\n\n\n"]
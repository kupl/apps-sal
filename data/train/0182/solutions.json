["class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         if not height:\n             return 0\n         result = 0\n         left = 0\n         right = len(height) - 1\n         while left < right:\n             if height[left] <= height[right]:\n                 tmp = height[left]\n                 left += 1\n                 while left < right and height[left] <= tmp:\n                     result += tmp - height[left]\n                     left += 1\n             else:\n                 tmp = height[right]\n                 right -= 1\n                 while left < right and height[right] <= tmp:\n                     result += tmp - height[right]\n                     right -=1 \n         return result\n", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         # if len(height) < 3 :\n         #     return 0\n         # maxTrap = 0\n         # stack=[]\n         # i = 0\n         # while i < len(height):\n         #     if not stack or height[i] <= height[stack[-1]]:\n         #         stack.append(i)\n         #         i += 1\n         #     else :\n         #         bot = stack.pop()\n         #         trap = 0 if not stack else (min(height[i],height[stack[-1]]) - height[bot] ) * (i-stack[-1]-1)\n         #         maxTrap += trap\n         #     # print(stack)\n         # return maxTrap\n         if not height :\n             return 0\n         left , right = 0 , len(height)-1\n         maxLeft,maxRight = height[left],height[right]\n         maxTrap = 0\n         while left <= right :\n             if height[left] <= height[right]:\n                 if height[left] > maxLeft :\n                     maxLeft = height[left]\n                 else :\n                     maxTrap += (maxLeft - height[left])\n                 left += 1\n             else :\n                 if height[right] > maxRight:\n                     maxRight = height[right]\n                 else :\n                     maxTrap += (maxRight -height[right])\n                 right -= 1\n         return maxTrap", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         maxRight = 0\n         maxLeft = 0\n         left = 0\n         right = len(height) - 1\n         ret = 0\n         while left < right:\n             maxRight = max(maxRight, height[right])\n             maxLeft = max(maxLeft, height[left])\n             if maxLeft > maxRight:\n                 ret += maxRight - height[right]\n                 right -= 1\n             else:\n                 ret += maxLeft - height[left]\n                 left += 1\n         return ret", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         \n         # sol1: mono stack\n         \n         # sol2: heap\n         \n         l_bounds = []\n         lb = float('-inf')\n         for h in height:\n             lb = max(lb, h)\n             l_bounds.append(lb)\n             \n         water = 0\n         rb = float('-inf')\n         for lb, h in zip(reversed(l_bounds), reversed(height)):\n             rb = max(rb, h)\n             water += min(lb, rb) - h\n         return water\n", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         ans = 0\n         max_left, max_right = [0]*len(height), [0]*len(height)\n         for i in range(1,len(height)):\n             max_left[i] = max(max_left[i-1], height[i-1])\n         for i in range(len(height)-2,-1,-1):  \n             max_right[i] = max(max_right[i+1], height[i+1])\n         # 0 added to take care of negative case i.e current step is greater than both max_left and max_right for that step\n         for i in range(1,len(height)-1):\n             ans += max(min(max_left[i], max_right[i]) - height[i], 0) \n         return ans\n                 \n             \n", "class Solution:\n     def trap(self, barHeights):\n         if barHeights == []:\n             return 0\n         \n         numberOfBars = len(barHeights)\n \n         leftMaxima = [0 for counter in range(numberOfBars)]\n         rightMaxima = [0 for counter in range(numberOfBars)]\n \n         leftMaxima[0] = barHeights[0]\n         for counter in range(1, numberOfBars):\n             leftMaxima[counter] = max(leftMaxima[counter-1], barHeights[counter])\n \n         rightMaxima[numberOfBars-1] = barHeights[numberOfBars-1]\n         for counter in range(numberOfBars-2, -1, -1):\n             rightMaxima[counter] = max(rightMaxima[counter+1], barHeights[counter])\n \n         waterTrapped = 0\n         for counter in range(0, numberOfBars):\n             waterTrapped += (min(leftMaxima[counter], rightMaxima[counter]) - barHeights[counter])\n \n         return waterTrapped\n", "class Solution:\n     '''Complexity O(n)'''\n \n     def trap(self, height):\n         n = len(height)\n         l, r, water, minHeight = 0, n - 1, 0, 0\n \n         while l < r:\n             while l < r and height[l] <= minHeight:\n                 water += minHeight - height[l]\n                 l += 1\n \n             while r > l and height[r] <= minHeight:\n                 water += minHeight - height[r]\n                 r -= 1\n \n             minHeight = min(height[l], height[r])\n \n         return water", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         left, right = 0, len(height) - 1\n         result = 0\n         while left < right:\n             mh = min(height[left], height[right])\n             if height[left]< height[right]:\n                 left = left + 1\n                 while height[left] <= mh and left < right:\n                     result = result + mh - height[left]\n                     left = left + 1\n             else:\n                 right = right - 1\n                 while height[right] <= mh and left < right:\n                     result = result + mh - height[right]\n                     right = right - 1\n                     \n         return result", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         ans = 0\n         max_left, max_right = [0]*len(height), [0]*len(height)\n         for i in range(1,len(height)):\n             max_left[i] = max(max_left[i-1], height[i-1])\n         for i in range(len(height)-2,-1,-1):  \n             max_right[i] = max(max_right[i+1], height[i+1])\n         # 0 added to take care of negative case i.e current step is greater than both max_left and max_right for that step\n         for i in range(1,len(height)-1):\n             ans += max(min(max_left[i], max_right[i]) - height[i], 0) \n         return ans\n                 \n             \n", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         leftmaxes = []\n         rightmaxes = []\n         \n         maximum = 0\n         for i in range(len(height)):\n             maximum = max(maximum, height[i])\n             leftmaxes.append(maximum)\n             \n             \n         maximum = 0\n         for i in range(len(height)):\n             maximum = max(maximum, height[len(height) - i - 1])\n             rightmaxes.append(maximum)\n         \n         water = 0\n         \n         print(leftmaxes)\n         print(rightmaxes)\n         \n         for i in range(len(height)):\n             trappable = min(leftmaxes[i], rightmaxes[-i-1])\n             if(trappable > height[i]):\n                 water += trappable - height[i]\n         \n         return water\n", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         \n         length = len(height)\n         if(length == 0):\n             return 0\n         maxLeft = [0] * length\n         maxRight = [0] * length\n         result = 0\n         maxLeft[0] = height[0]\n         maxRight[length - 1] = height[length - 1]\n         for i in range(1,length):\n             maxLeft[i] = max(maxLeft[i - 1], height[i])\n         for i in reversed(list(range(0, length - 1))):\n             maxRight[i] = max(maxRight[i + 1], height[i])\n         for i in range(length):\n             result += min(maxLeft[i], maxRight[i]) - height[i]\n         return result\n \n                     \n             \n             \n", "class Solution:\n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         # find valleys\n         N = len(height)\n         valleys = [] # a list of [left, right] (not inclusive) bounds of local minimum\n         i = 0\n         while i < N-1:\n             # first go uphills and then down hills until flat or up hills, this is a potential left bound of a valley\n             while i < N-1 and height[i] <= height[i+1]: i += 1\n             while i < N-1 and height[i] > height[i+1]: i += 1 # ensures height[i] <= height[i+1] unless out of bounds\n             j = i\n             while j < N-1 and height[j] == height[j+1]: j += 1 # go through the range of the potential bottom of the valley\n             if j < N-1 and height[j] < height[j+1]: valleys.append([i-1,j+1]) # store a confirmed valley with bottom [i:j+1]\n             i = j\n         \n         # fill water into each valley\n         total_water = 0\n         further_valleys = [] # list of potential valley to merge as those whose left side is higher after water filll\n         k = 0\n         if valleys: # initialize\n             l = valleys[k][0]\n             r = valleys[k][1]\n             old_level = height[l+1]\n         while k < len(valleys):\n             # record bottom level\n             water = 0\n             while l >= 0 and r < N and height[l] >= height[l+1] and height[r-1] <= height[r]: # both sides rising\n                 # fill water at [l+1:r]\n                 new_level = min(height[l], height[r])\n                 water += (new_level - old_level) * (r - l - 1)\n                 old_level = new_level\n                 # advance to the next level in the valley\n                 if l >= 0 and r < N:\n                     # rise only the lower side\n                     if height[l] == height[r]:\n                         l -= 1\n                         r += 1\n                     elif height[l] < height[r]: l -= 1\n                     else: r += 1\n                     # make sure level rises\n                     while l >= 0 and height[l] == height[l+1]: l -= 1\n                     while r < N and height[r-1] == height[r]: r += 1\n             total_water += water\n             \n             # l == -1 or r == N or height[l] < height[l+1] or height[r-1] > height[r]\n             if l >= 0 and r < N:\n                 if height[l] > height[l+1]: # further rise is possible after the next valley is filled\n                     further_valleys.append([l,r])\n                 elif further_valleys and height[further_valleys[-1][1]-1] == height[l+1]: # merge two valleys\n                     old_level = height[l+1] # water already filled to this level\n                     l = further_valleys[-1][0]\n                     further_valleys.pop()\n                     continue # fill the merged valley before moving on\n             \n             # fill the next valley\n             k += 1\n             if k < len(valleys):\n                 l = valleys[k][0]\n                 r = valleys[k][1]\n                 old_level = height[l+1]\n             \n         return total_water", "class Solution:\n     \n     def get_empty_per_level(self, height, level):\n         print((\"Level: \", level))\n         block_start = 0\n         n = len(height)\n         while block_start < n and height[block_start] < level:\n             block_start += 1\n             \n         if block_start == n:   \n             print(\"No start\")\n             return n\n         \n         block_end = n - 1\n         while block_end > block_start and height[block_end] < level:\n             block_end -= 1\n             \n         if block_end == block_start:\n             print(\"No end\")\n             return n - 1\n         \n         print(\"Some value\")\n         return n - (block_end - block_start + 1)\n     \n     def trap(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         \n         if not height or len(height) == 0:\n             return 0\n         \n         levels = set(height)              \n         levels = list(levels)\n         \n         if 0 in levels:\n             levels.remove(0)\n             \n         levels.sort()\n         \n         if len(levels) == 0:\n             return 0\n                 \n         max_level = max(height)\n         total_count = sum([max_level - item for item in height])                \n             \n         prev_level = levels.pop(0)\n         missing_water_per_level = self.get_empty_per_level(height, prev_level)                \n         total_count -= prev_level * missing_water_per_level                                \n         for level in levels:\n             missing_water_per_level = self.get_empty_per_level(height, level)                                \n             multi_level_count = (level - prev_level) * missing_water_per_level\n             total_count -= multi_level_count                        \n             #print(\"Level: \", level, \" count after: \", total_count, \"missing water: \", missing_water_per_level)\n             \n             prev_level = level\n             \n         return total_count\n             \n"]
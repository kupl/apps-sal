["'''\nChallenge Fun #20: Edge Detection\nhttps://www.codewars.com/kata/58bfa40c43fadb4edb0000b5/train/python\n\nFor a rectangular image given in run-length encoding (RLE) as\ndescribed below, return a RLE of the image processed by replacing\neach pixel by the maximum absolute value of the difference between\nit and each neighboring pixel (a simple form of edge detection).\n\nFor a RLE encoding string \"7 15 4 100 15 25 2 ...\",\n    7      ----> image width\n    15 4   ----> a pair(color value + pixel count)\n    100 15 ----> a pair(color value + pixel count)\n    25 2   ----> a pair(color value + pixel count)\n    ...          ...\nwhere the image width is > 0 and the sum of all the pixel counts\nis a multiple of the width.\n\n--------------------\nDesign of solution\n\nRead the rle-encoded values into a buffer of rows of the given width,\nwith an important optimization trick. In the case of long runs of the\nsame value, where three or more rows would be filled with identical\ndata, store just three rows of data, and remember (using another data\nstructure) which is the middle of the three rows, and how many copies\nof it (the \"row count\") were in the original image. For example,\nsuppose the image width is 10, and the image has a run of 73 copies\nof the value 7, and the run starts with the last two values in row 34.\nThe buffer would look like this:\n\n        ...\n    34  [ some previous data ...  7, 7 ]\n    35  [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\n    36  [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\n    37  [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\n    38  [ 7, ... start of new data ... ]\n        ...\n\nand elsewhere a note is made that row 36 has a row count of 5.\n\nWith long runs arranged this way, the edge-detection transformation\ncan be run on the buffer without having to worry about row counts.\nRow counts are used later, when encoding the transformed values back\ninto a run-length encoding.\n'''\nimport itertools\n\ndef edge_detection(image):\n    data = [int(datum) for datum in image.split(' ')]\n    width = data.pop(0)\n\n    (inbuf, rowcounts) = fill_buffer(width, data)\n    outbuf = detect_edges(inbuf)\n\n    outdata_list = encode(outbuf, rowcounts)\n    outdata = [str(datum) for datum in outdata_list]\n    return str(width) + ' ' + ' '.join(outdata)\n\n\ndef fill_buffer(width, data):\n    buf = []\n    rowcounts = dict()      # row: rowcount\n\n    row, row_ndx = [], 0\n    while data:\n        val, runlen = data.pop(0), data.pop(0)\n        if row == [] and runlen > 3 * width:\n            buf += [[val] * width] * 3\n            # There's a top, middle, and bottom row; middle has a row count\n            rowcounts[row_ndx + 1] = (runlen // width) - 2\n            row_ndx += 3\n            # Values from run that didn't fit in the above rows.\n            row = [val] * (runlen % width)\n            continue\n\n        take = min(runlen, width - len(row))\n        runlen -= take\n        row += [val] * take\n        if len(row) < width:\n            continue\n\n        # Here, row is full, with mixed values, and there may be some\n        # (many!) values left over from the last (val, runlen) pair that\n        # was read from data.\n        buf.append(row)\n        row_ndx += 1\n        row = []\n\n        if row == [] and runlen > 3 * width:\n            buf += [[val] * width] * 3\n            # There's a top, middle, and bottom row; middle has a row count\n            rowcounts[row_ndx + 1] = (runlen // width) - 2\n            row_ndx += 3\n            # Values from run that didn't fit in the above rows.\n            row = [val] * (runlen % width)\n            continue\n\n        while runlen > 0:\n            take = min(runlen, width - len(row))\n            runlen -= take\n            row += [val] * take\n            if len(row) == width:\n                buf.append(row)\n                row_ndx += 1\n                row = []\n\n    return buf, rowcounts\n\n\ndef pairs_from(iterable, fillvalue=None):\n    '''\n    Yields iterable's elements in pairs. If iterable is exhausted after\n    an odd number of elements, completes the last pair with fillvalue.\n    '''\n    # This is the 'grouper' recipe from the itertools documentation.\n    args = [iter(iterable)] * 2\n    return itertools.zip_longest(*args, fillvalue=fillvalue)\n\n\ndef detect_edges(inbuf):\n    length = len(inbuf)\n    width = len(inbuf[0])\n\n    outbuf = [([-1] * width).copy() for _ in range(length)]\n\n    # Single pixel\n    if 1 == width == length:\n        return [[0]]\n\n    # Single row\n    if 1 == length:\n        outbuf[0][0] = abs(inbuf[0][0] - inbuf[0][1])\n        outbuf[0][width - 1] = abs(inbuf[0][width - 2] - inbuf[0][width - 1])\n        for col in range(1, width - 1):\n            val = inbuf[0][col]\n            outbuf[0][col] = max(abs(val - inbuf[0][col - 1]),\n                                 abs(val - inbuf[0][col + 1]))\n        return outbuf\n\n    # Single column\n    if 1 == width:\n        outbuf[0][0] = abs(inbuf[0][0] - inbuf[1][0])\n        outbuf[length - 1][0] = abs(inbuf[length - 2][0] -\n                                    inbuf[length - 1][0])\n        for row in range(1, length - 1):\n            val - inbuf[row][0]\n            outbuf[row][0] = max(abs(val - inbuf[row - 1][0]),\n                                 abs(val - inbuf[row + 1][0]))\n        return outbuf\n\n    # At least a 2 x 2 image. Unroll what we'd rather do in loops and\n    # list comprehensions.\n\n    BOT = length - 1        # convenience; last data row\n    RT = width - 1          # convenience; last data column\n\n    # Corners\n    top_lf, top_rt = inbuf[0][0], inbuf[0][RT]\n    bot_lf, bot_rt = inbuf[BOT][0], inbuf[BOT][RT]\n    outbuf[0][0] = max(abs(top_lf - inbuf[0][1]),\n                       abs(top_lf - inbuf[1][0]),\n                       abs(top_lf - inbuf[1][1]))\n    outbuf[0][RT] = max(abs(top_rt - inbuf[0][RT - 1]),\n                        abs(top_rt - inbuf[1][RT - 1]),\n                        abs(top_rt - inbuf[1][RT]))\n    outbuf[BOT][0] = max(abs(bot_lf - inbuf[BOT - 1][0]),\n                         abs(bot_lf - inbuf[BOT - 1][1]),\n                         abs(bot_lf - inbuf[BOT][1]))\n    outbuf[BOT][RT] = max(abs(bot_rt - inbuf[BOT - 1][RT - 1]),\n                          abs(bot_rt - inbuf[BOT - 1][RT]),\n                          abs(bot_rt - inbuf[BOT][RT]))\n\n    # Top and bottom (except corners)\n    for col in range(1, RT):\n        val = inbuf[0][col]\n        outbuf[0][col] = max(abs(val - inbuf[0][col - 1]),\n                             abs(val - inbuf[0][col + 1]),\n                             abs(val - inbuf[1][col - 1]),\n                             abs(val - inbuf[1][col]),\n                             abs(val - inbuf[1][col + 1]))\n        val = inbuf[BOT][col]\n        outbuf[BOT][col] = max(abs(val - inbuf[BOT - 1][col - 1]),\n                               abs(val - inbuf[BOT - 1][col]),\n                               abs(val - inbuf[BOT - 1][col + 1]),\n                               abs(val - inbuf[BOT][col - 1]),\n                               abs(val - inbuf[BOT][col + 1]))\n\n    # Left edge (except corners)\n    for row in range(1, BOT):\n        val = inbuf[row][0]\n        outbuf[row][0] = max(abs(val - inbuf[row - 1][0]),\n                             abs(val - inbuf[row - 1][1]),\n                             abs(val - inbuf[row][1]),\n                             abs(val - inbuf[row + 1][0]),\n                             abs(val - inbuf[row + 1][1]))\n        val = inbuf[row][RT]\n        outbuf[row][RT] = max(abs(val - inbuf[row - 1][RT - 1]),\n                              abs(val - inbuf[row - 1][RT]),\n                              abs(val - inbuf[row][RT - 1]),\n                              abs(val - inbuf[row + 1][RT -1]),\n                              abs(val - inbuf[row + 1][RT]))\n\n    # Finallly! The interior\n    for row in range(1, BOT):\n        for col in range(1, RT):\n            val = inbuf[row][col]\n            outbuf[row][col] = max(abs(val - inbuf[row - 1][col - 1]),\n                                   abs(val - inbuf[row - 1][col]),\n                                   abs(val - inbuf[row - 1][col + 1]),\n                                   abs(val - inbuf[row][col - 1]),\n                                   abs(val - inbuf[row][col + 1]),\n                                   abs(val - inbuf[row + 1][col - 1]),\n                                   abs(val - inbuf[row + 1][col]),\n                                   abs(val - inbuf[row + 1][col + 1]),\n                                   )\n    # Now wasn't that fun?\n    return outbuf\n\n\ndef encode(buf, rowcounts):\n    width = len(buf[0])\n\n    # Initial list of (value, runlength) pairs. Not necessarily a\n    # run-length encoding, as successive values might be equal.\n    val_rl = list()\n\n    for row_ndx in range(len(buf)):\n        encoded_row = [(val, len(list(grp))) for\n               (val, grp) in itertools.groupby(buf[row_ndx])]\n        if row_ndx in rowcounts:\n            val_rl.append((encoded_row[0][0], width * rowcounts[row_ndx]))\n        else:\n            for (val, count) in encoded_row:\n                val_rl.append((val, count))\n\n    encoding = list()\n    # Now condense val_rl into a true run-length encoding.\n    (old_val, old_rl) = val_rl.pop(0)\n    for (val, rl) in val_rl:\n        if val == old_val:\n            old_rl += rl\n        else:\n            encoding += (old_val, old_rl)\n            (old_val, old_rl) = val, rl\n    encoding += (old_val, old_rl)\n\n    return encoding\n", "rle = []\none_color_flag = 0\n#@profile\ndef getline(w):\n    nonlocal rle, one_color_flag\n    rezl = []\n    while w > 0:\n        rle0 = rle[0]\n        rle1 = rle[1]\n        if rle1 > w:\n            rle[1] -= w\n            rezl.extend([rle0 for i in range(w)])\n            one_color_flag += 1\n            return rezl\n        else:\n            rezl.extend([rle0 for i in range(rle1)])\n            one_color_flag = 0\n            w -= rle1\n            rle.pop(0)\n            rle.pop(0)\n    return rezl\n\n        \n#@profile\ndef edge_detection(rle_str):\n    nonlocal rle, one_color_flag\n    rle = [int(x) for x in rle_str.split(' ')]\n    width = rle.pop(0)\n    data_length = sum(rle[1::2])\n    height = data_length//width\n    width3 = width * 3\n    rez = [width]\n    width_bound = width - 1\n    height_bound = height - 1\n    l2 = getline(width) #fill all window lines first line from image\n    l1 = l2\n    #print(l2)\n    curr_dev = -99999\n    y = 0\n    while y < height:\n        l0 = l1\n        l1 = l2\n        if y < height_bound:\n            l2 = getline(width) \n        #print(l2)\n        x = 1\n\n        # +++ first elem in line\n        t = [l1[1], l0[0], l0[1], l2[0], l2[1]]\n        #t.sort()\n        #c = max(abs(t[0] - l1[0]),abs(t[-1] - l1[0]))\n        c = max(abs(min(t) - l1[0]),abs(max(t) - l1[0]))\n        if curr_dev == c :\n            rez[-1] += 1\n        else:\n            rez.append(c)\n            rez.append(1)\n            curr_dev = c\n        # --- first elem in line\n\n        while x<width_bound:\n            t = [l1[x-1], l1[x+1], l0[x-1], l0[x], l0[x+1],l2[x-1], l2[x], l2[x+1]]\n            #t.sort()\n            #c = max(abs(t[0] - l1[x]),abs(t[-1] - l1[x]))\n            c = max(abs(min(t) - l1[x]),abs(max(t) - l1[x]))\n            if curr_dev == c :\n                rez[-1] += 1\n            else:\n                rez.append(c)\n                rez.append(1)\n                curr_dev = c            \n            x += 1\n        # +++ end elem in line\n        t = [l1[-2], l0[-2], l0[-1], l2[-2], l2[-1]]\n        #t.sort()\n        #c = max(abs(t[0] - l1[-1]),abs(t[-1] - l1[-1]))\n        c = max(abs(min(t) - l1[-1]),abs(max(t) - l1[-1]))\n        if curr_dev == c :\n            rez[-1] += 1\n        else:\n            rez.append(c)\n            rez.append(1)\n            curr_dev = c\n        # --- end elem in line\n        y += 1\n\n        #if rez[-1] > width3 and y < height_bound and l1[0] == rle[0] :\n        if  one_color_flag > 2:\n            n_str = (rle[1]//width) - 1\n            one_color_flag = 0\n            if n_str > 0:\n                ls = n_str * width\n                #rez[-1] += ls\n                if curr_dev == 0 :\n                    rez[-1] += ls\n                else:\n                    rez.append(0)\n                    rez.append(ls)\n                    curr_dev = 0\n                rle[1]  -= ls\n                y += n_str\n\n    return str(rez).replace(',','').replace('[','').replace(']','')", "# Todo: performance boost for the special case: same number for many lines\n\nDEBUG = False\n\nclass RLE:\n    def __init__(self):\n        self.c = 0\n        self.count = 0\n        self.result = \"\"\n\n    def add(self, c, count):\n        if self.count > 0 and self.c == c:\n            self.count += count\n        else:\n            if self.count > 0:\n                self.result += \" \" + str(self.c) + \" \" + str(self.count)\n            self.c = c\n            self.count = count\n\n    def display(self):\n        if self.count > 0:\n            self.result += \" \" + str(self.c) + \" \" + str(self.count)\n            self.count = 0\n            self.c = 0\n        return self.result[1:]\n\n# get next line iterator, extra one 'None' after last line\n## Todo: special lines mark (same number for many lines)\n# (None (normal), line) or ((Special line nums), line)\n# special lines are     xxx, ooo, ooo2, ooo3, ooo(last), xxx,   ooo2~last-1 are special\ndef get_line(w, src):\n    nums = src\n\n    r, c = 0, 0 # index\n    line = []\n    i = 0\n    while i < len(nums) > 0:\n        n, count = nums[i], nums[i + 1]\n        i += 2\n        while c + count > w: # across line, split it\n            # special case\n            if c == 0 and count > 3 * w:\n                yield(None, [(n, w)])\n                yield((count // w) - 2, [(n, w)])\n                yield(None, [(n, w)])\n                r, c = r + (count //w), 0\n                count -= w * (count //w)\n                line = []\n                continue\n            count -= w - c \n            line.append((n, w - c))\n            yield (None, line)\n            r, c = r + 1, 0\n            line = []\n        if count > 0:\n            line.append((n, count))\n            c += count\n            if c == w: # could not be > w\n                yield (None, line)\n                r, c = r + 1, 0\n                line = []\n    # valid input should yields line and ends here\n    # one None after last line\n    yield (None, None)\n\n# return RLE edge in one line (left/right)\ndef edge_inline(w, line):\n    # patch on the left and right\n    extended_line = [(line[0][0], 1)] + line + [(line[-1][0], 1)]\n\n    n_prev = line[0][0]\n    r = []\n    # middle\n    for i in range(1, len(extended_line) - 1):\n        (n, count) = extended_line[i]\n        n_next = extended_line[i + 1][0]\n\n        d_l = abs(n - n_prev)\n        d_r = abs(n - n_next)\n\n        if count > 1:\n            r.append((d_l, 1))\n            if count > 2:\n                r.append((0, count - 2))\n            r.append((d_r, 1))\n        else:\n            r.append((max(d_l, d_r), 1))\n\n        n_prev = n\n    return r\n\n# return RLE edge compared from line to other line\ndef edge_twolines(w, line, other):\n    if DEBUG: print((\"twolines: \", line, other))\n    # 2 pass, split this line in the shape of other\n    def aa(line, other):\n        current, left, i, j, si, sj = 0, 0, 0, 0, line[0][1], other[0][1]\n        while left < w:\n            # print(current, left, i, j, si, sj)\n            while si <= left and i < len(line):\n                i += 1\n                si += line[i][1]\n                current += 1\n            while sj <= left and j < len(other):\n                j += 1\n                sj += other[j][1]\n            right = min(si, sj)\n            yield (line[current][0], right - left)\n            left += right - left\n    def bb(line, other):\n        # patch other line on the left and right\n        return [(line[0][0], 1)] + other + [(line[-1][0], 1)]\n\n    # line_splits = aa(line, other)\n    # extended_line = bb(line, other)\n    extended_line = [(line[0][0], 1)] + other + [(line[-1][0], 1)]\n\n    r = []\n    m_prev = extended_line[0][0]\n    j, right, sj = 1, 0, extended_line[1][1]\n    for n, count in aa(line, other):\n    # for i in range(len(line_splits)):\n        # (n, count) = line_splits[i]\n\n        dl = abs(n - m_prev)\n        m = extended_line[j][0]\n        dc = abs(n - m)\n\n        if count > 1:\n            r.append((max(dl, dc), 1))\n            if count > 2:\n                r.append((dc, count - 2))\n            mr = m\n            right += count\n            if right >= sj:\n                j += 1\n                sj += extended_line[j][1]\n                mr = extended_line[j][0]\n            r.append((max(dc, abs(n - mr)), 1))\n        else:\n            mr = m\n            right += 1\n            if right >= sj:\n                j += 1\n                sj += extended_line[j][1]\n                mr = extended_line[j][0]\n            r.append((max(dl, dc, abs(n - mr)), 1))\n        m_prev = m\n        # print(i, n, count, j, right, sj, m_prev, m, mr, dl, dc)\n    return r\n\n\n# merge RLE edges into one\ndef merge_edge_lines(w, line1, line2):\n    i, j, si, sj = 0, 0, line1[0][1], line2[0][1]\n    left = 0\n    r = []\n    while left < w:\n        while si <= left and i < len(line1):\n            i += 1\n            si += line1[i][1]\n        while sj <= left and j < len(line2):\n            j += 1\n            sj += line2[j][1]\n        n = max(line1[i][0], line2[j][0])\n        right = min(si, sj)\n        r.append((n, right - left))\n        left = right\n    return r\n\n\nimport time\ndef edge_detection(image):\n    imgs = [int(i) for i in image.split(' ')]\n    w, line = imgs[0], imgs[1:]\n    line_iter = get_line(w, line)\n\n    rle = RLE()\n\n    prev_line_info, cur_line_info, next_line_info = (None, None), (None, None), next(line_iter)\n    while True:\n        prev_line_info, cur_line_info, next_line_info = cur_line_info, next_line_info, next(line_iter)\n        prev_line, cur_line, next_line, is_special = prev_line_info[1], cur_line_info[1], next_line_info[1], cur_line_info[0]\n\n        # special case, same number across many lines\n        if not is_special is None:\n            rle.add(0, is_special * cur_line[0][1])\n            continue\n\n        cur_edge = edge_inline(w, cur_line)\n        if not prev_line is None:\n            prev_edge = edge_twolines(w, cur_line, prev_line)\n            cur_edge = merge_edge_lines(w, prev_edge, cur_edge)\n        if next_line is not None:\n            next_edge = edge_twolines(w, cur_line, next_line)\n            cur_edge = merge_edge_lines(w, cur_edge, next_edge)\n        # Todo: send cur_edge\n        # print(\"cur edge: \", cur_edge, prev_line, cur_line, next_line)\n        for en, ec in cur_edge:\n            rle.add(en, ec)\n\n        if next_line is None: # finishes\n            break\n\n    # Todo: send last edge line\n    # print(cur_edge)\n    # returns edges\n    return ' '.join([str(w), rle.display()])\n\n\n\n", "from itertools import chain\n\n\ndef parse_ascii(image_ascii):\n    \"\"\" Parses the input string\n\n    Returns a 3-tuple:\n        - :width: - the width in pixels of the image\n        - :height: - the height in pixels of the image\n        - List of pairs (pixel_value, run_length)\n            run_length is the number of successive pixels with the same value when scanning\n            the row, including the following rows\n\n    Assumes with no check:\n        :run_length: > 0 for all cases\n        Successive pairs have different :pixel_value:\n        The sum of all pixels is a multiple of :width:\n\n    >>> parse_ascii(\"3 43 4 24 2\")\n    (3, 2, [(43, 4), (24, 2)])\n    \"\"\"\n    values = [int(v) for v in image_ascii.split()]\n    width = values[0]\n    pixel_runs = list(zip(values[1::2], values[2::2]))\n    height = sum(values[2::2]) // width\n    return width, height, pixel_runs\n\n\ndef get_intervals(pixel_runs):\n    \"\"\" Denominates the pixel runs with an absolute position\n\n    Given the pairs (pixel_value, run_length), returns triplets (start, end, pixel_value)\n\n    The pixel positions are numbered successively starting with the first row from left\n    to right and then the following rows. :start: and :end: are given as such positions.\n    :start: points to the first pixel of the run with :pixel_value:\n    :end: points to the position after the the pixel ending the run\n\n    >>> list(get_intervals([(34,4),(98,5),(12,40)]))\n    [(0, 4, 34), (4, 9, 98), (9, 49, 12)]\n    \"\"\"\n    pos = 0\n    for (pixel_value, run_length) in pixel_runs:\n        yield (pos, pos + run_length, pixel_value)\n        pos += run_length\n\n\ndef get_shifted_intervals(intervals, offset, width, height):\n    \"\"\" Shifts the intervals, and corrects for end of row\n\n    Returns the intervals (start, end, pixel_value) with the variables :start: and :end:\n    shifted :offset: positions.\n\n    If :offset: is positive, fills the first positions with a new (0, :offset:, None) interval,\n    and removes the intervals and interval parts correspoding to the last :offset: positions.\n    Conversely for negative :offset:.\n\n    If :offset: is positive, all endings and beginnings of interval falling in the first column\n    past the end of a row are back-shifted one position, extending or contracting the interval as\n    necessary. This is so to prevent an offset pixel to be neighbour of a pixel in a different row,\n    as the use for this will be to assess neighbouring pixels. Conversely for negative :offset: and\n    interval boundaries falling in the last column of a row.\n\n    >>> list(get_shifted_intervals([(0, 3, 55), (3, 5, 78), (5, 11, 23), (11, 15, 99)], 6, 5, 3))\n    [(0, 5, None), (5, 9, 55), (9, 10, 78), (10, 15, 23)]\n    >>> list(get_shifted_intervals([(0, 3, 55), (3, 5, 78), (5, 11, 23), (11, 15, 99)], -6, 5, 3))\n    [(0, 5, 23), (5, 10, 99), (10, 15, None)]\n    \"\"\"\n    # Add empty interval at the beginning if shifted right\n    if offset > 0:\n        if offset % width == 1:\n            yield (0, offset - 1, None)\n        elif offset % width == width - 1:\n            yield (0, offset + 1, None)\n        else:\n            yield (0, offset, None)\n\n    for (start, end, pixel_value) in intervals:\n        start += offset\n        end += offset\n\n        # Remove or contract an interval if shifted past the beginning\n        if end <= 0:\n            continue\n        if start < 0:\n            start = 0\n\n        # Remove or contract and interval if shifted past the end\n        if start >= width * height:\n            continue\n        if end > width * height:\n            end = width * height\n\n        # Correct for proximity of a row jump\n        if offset % width == 1 and start % width == 1:\n            start -= 1\n        if offset % width == 1 and end % width == 1:\n            end -= 1\n        if offset % width == width - 1 and start % width == width - 1:\n            start += 1\n        if offset % width == width - 1 and end % width == width - 1:\n            end += 1\n\n        # Remove if because of a contraction the length of the interval is zero\n        if start == end:\n            continue\n\n        yield (start, end, pixel_value)\n\n    # Add empty interval at the end if shifted left\n    if offset < 0:\n        if (width * height + offset) % width == width - 1:\n            yield (width * height + offset + 1, width * height, None)\n        elif (width * height - offset) % width == 1:\n            yield (width * height + offset - 1, width * height, None)\n        else:\n            yield (width * height + offset, width * height, None)\n\n\ndef intersect_intervals(interval_lists, width, height):\n    \"\"\" Fuse many lists of intervals into one\n\n    Given many lists of intervals, returns a single list of intersected intervals.\n    The intervals of the output list are of the form\n    (start, end, [pixel_value_1, pixel_value_2, ...])\n    Pixel values containing None are not included.\n\n    >>> list(intersect_intervals([\n    ...     [(0,4,23),(4,6,14),(6,25,88),(25,45,99)],\n    ...     [(0,3,66),(3,9,33),(9,10,77),(10,25,43),(25,45,None)]\n    ...     ], 9, 5))\n    [(0, 3, [23, 66]), (3, 4, [23, 33]), (4, 6, [14, 33]), (6, 9, [88, 33]), (9, 10, [88, 77]), (10, 25, [88, 43]), (25, 45, [99])]\n    \"\"\"\n    # List of pairs [iterator, interval], each iterator yields from a list of intervals\n    # and the interval will be updated as the algorithm runs\n    ilists = [[iter(ilist), (0, 0, None)] for ilist in interval_lists]\n    pos = 0\n    while pos < width * height:\n        # Advance the iterators so that the associated interval contains :pos:\n        for ilist in ilists:\n            iterator, current_interval = ilist\n            _, end, _ = current_interval\n            while end <= pos:\n                ilist[1] = next(iterator)\n                _, end, _ = ilist[1]\n\n        # Take the interval from :pos: to the closest end\n        min_end = min(end for _, (_, end, _) in ilists)\n        values = [value for _, (_, _, value) in ilists if value is not None]\n\n        yield (pos, min_end, values)\n        pos = min_end\n\n\ndef compose_intervals(intervals):\n    \"\"\" Merge successive intervals if they have the same value\n\n    Input and output are lists of intervals (start, end, value)\n\n    >>> list(compose_intervals([(0, 3, 7), (3, 5, 7), (5, 8, 7), (8, 9, 12), (9, 13, 7)]))\n    [(0, 8, 7), (8, 9, 12), (9, 13, 7)]\n    \"\"\"\n    cur_value = None\n    cur_start = None\n    cur_end = None\n    for (start, end, value) in intervals:\n        if value == cur_value:\n            cur_end = end\n            continue\n        if cur_end is not None:\n            yield (cur_start, cur_end, cur_value)\n        cur_start, cur_end, cur_value = (start, end, value)\n    yield (cur_start, cur_end, cur_value)\n\n\ndef get_lengths(intervals):\n    \"\"\" Converts intervals to (value, length) format \"\"\"\n    return ((value, end - start) for (start, end, value) in intervals)\n\n\ndef generate_ascii(pairs, width):\n    \"\"\" Converts to the required output format as a string \"\"\"\n    return \" \".join(str(n) for n in chain([width], *pairs))\n\n\ndef edge_detection(image):\n    width, height, pixel_runs = parse_ascii(image)\n    intervals = list(get_intervals(pixel_runs))\n    offsets = [-width - 1, -width, -width + 1, -1, 1, width - 1, width, width + 1]\n    neighbours = [get_shifted_intervals(intervals, offset, width, height) for offset in offsets]\n    intersected_neighbours = intersect_intervals(neighbours, width, height)\n    intersected_all = intersect_intervals([intervals, intersected_neighbours], width, height)\n\n    result = []\n    for (start, end, (base_cell, neighbour_cells)) in intersected_all:\n        result_cell = max(abs(base_cell - n) for n in neighbour_cells)\n        result.append((start, end, result_cell))\n\n    out_intervals = compose_intervals(result)\n    out_lengths = get_lengths(out_intervals)\n    return generate_ascii(out_lengths, width)\n", "def edge_detection(image):\n    image = [int(v) for v in image.split(' ')]\n    width = image[0]\n    map,line,flat = [],[],[]\n    rest,f = width,1\n    current,result = ['',width],['']\n    def apply(value):\n        if current[0] == value:\n            current[1] += 1\n        else:\n            result[0] += ' ' + str(current[0]) + ' ' + str(current[1])\n            current[0] = value\n            current[1] = 1\n    def diff(R,C,r,c):\n        r += R\n        c += C\n        return abs(flat[R][C] - flat[r][c]) if 0 <= r < len(flat) and 0 <= c < width else 0\n    while f < len(image):\n        line.append([image[f],min(rest,image[1 + f])])\n        if image[1 + f] < rest:\n            rest -= image[1 + f]\n            f += 2\n        else:\n            image[1 + f] -= rest\n            if image[1 + f] < 3 * width:\n                if image[1 + f] < 1: f += 2\n                map.append(line)\n                line = []\n                rest = width\n            else:\n                map.append(line)\n                map.append([[image[f],width]])\n                map.append([[image[f],width,image[1 + f] // width - 2]])\n                map.append([[image[f],width]])\n                line = []\n                image[1 + f] %= width\n                rest = width - image[1 + f]\n                if image[1 + f]: line.append(image[f:2 + f])\n                f += 2\n    for v in map:\n        t = f = 0\n        line = []\n        flat.append(line)\n        for _ in range(width):\n            line.append(v[f][0])\n            t += 1\n            if v[f][1] <= t: t,f = 0,1 + f\n    for r,row in enumerate(map):\n        if 2 < len(row[0]):\n            apply(0)\n            current[1] += width * row[0][2] - 1\n        else:\n            for f in range(width): apply(max(diff(r,f,-1,0),diff(r,f,-1,1),diff(r,f,0,1),diff(r,f,1,1),\n                diff(r,f,1,0),diff(r,f,1,-1),diff(r,f,0,-1),diff(r,f,-1,-1)))\n    apply(None)\n    return result[0][2:]"]
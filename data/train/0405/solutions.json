["class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [0] * (N + W)\n        for i in range(K, N + 1):\n            dp[i] = 1\n        \n        S = min(W, N - K + 1)\n        for i in range(K - 1, -1, -1):\n            dp[i] = S / W\n            S += dp[i] - dp[i + W]\n        return dp[0]", "class Solution(object):\n    def new21Game(self, N, K, W):\n        dp = [0.0] * (N + W + 1)\n        # dp[x] = the answer when Alice has x points\n        for k in range(K, N + 1):\n            dp[k] = 1.0\n\n        S = min(N - K + 1, W)\n        # S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for k in range(K - 1, -1, -1):\n            dp[k] = S/W\n            S += dp[k] - dp[k + W]\n\n        return dp[0]", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        \n        # solution 1: Time and Space both O(N+W)\n        # # pseudocode: let dp[x] be the answer when\n        # #             Alice already has x points\n        # dp[k] = 1.0 when K <= k <= N, else 0.0\n        # for k from K-1 to 0:\n        #     dp[k] = (dp[k+1] + ... + dp[k+W]) / W\n        # return dp[0]\n        \n        # dp[x] = the answer when Alice has x points\n        dp = [0.0] * (N + W + 1)\n        for k in range(K, N + 1):\n            # Alice wins if has between K and N points\n            dp[k] = 1.0\n\n        S = sum(dp[i] for i in range(K, K+W+1))#min(N - K + 1, W) # = dp[K+1] + ... + dp[K+W]\n        # S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for k in reversed(list(range(K))):\n            dp[k] = S / float(W)\n            S += dp[k] - dp[k + W]\n\n        return dp[0]\n        \n#         # solution 2: time and space limit exceeded\n#         # dp(n, k) = 1 / W * ( sum pt in range(1, W+1) over dp(n-pt, k-pt) )\n        \n#         memo = {}\n#         def dp(n, k):\n#             if (n, k) not in memo:\n#                 if k <= 0:\n#                     ans = int(n >= 0)\n#                 else:\n#                     ans = 0\n#                     for pt in range(1, W+1):\n#                         ans += dp(n-pt, k-pt)\n#                     ans *= 1. / W\n#                 memo[n, k] = ans\n#             return memo[n, k]\n#         return dp(N, K)\n", "\n# 837. New 21 Game \n\nclass Solution1:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n\n        dp = [None] * (K + W)\n        s = 0\n        for i in range(K, K + W):          # \u586b\u84dd\u8272\u7684\u683c\u5b50\n            dp[i] = 1 if i <= N else 0\n            s += dp[i]\n        for i in range(K - 1, -1, -1):      # \u586b\u6a58\u9ec4\u8272\u683c\u5b50\n            dp[i] = s / W\n            s = s - dp[i + W] + dp[i]\n        return dp[0]\n\n# \u4f5c\u8005\uff1aMcdull0921\n# \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/\n\n\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [1 if i <= N else 0 for i in range(K + W)]\n        s = sum(dp[K : K + W])\n        for i in range(K-1, -1, -1):\n            dp[i] = s / W\n            s = s - dp[i + W] + dp[i]\n        return dp[0]", "class Solution:\n    def new21Game(self, N, K, W):\n        dp = [0.0] * (N + W + 1)\n        # dp[x] = the answer when Alice has x points\n        for k in range(K, N + 1):\n            dp[k] = 1.0\n\n        S = min(N - K + 1, W)\n        # S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for k in range(K - 1, -1, -1):\n            dp[k] = S / float(W)\n            S += dp[k] - dp[k + W]\n\n        return dp[0]", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        if K == 0:\n            return 1\n        dp = [0] * (W + K)\n        dp[0] = 1\n        sliding_sum = 1\n        for i in range(1, K+W):\n            # print(sliding_sum)\n            # constant = dp[i] / W\n            # for j in range(i+1, i+W+1):\n            #     dp[j] += constant\n            # dp[i] = 0\n            dp[i] = sliding_sum / W\n            if i < K:\n                sliding_sum += dp[i]\n            if i-W >= 0:\n                sliding_sum -= dp[i-W]\n                dp[i-W] = 0\n        # print(dp)\n        return sum(dp[K:N+1])/ sum(dp)\n                \n", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        if K == 0:\n            return 1\n        \n        dp = [0]\n        cur, temp = 1, 1/W\n        for i in range(1, W+1):\n            dp.append(cur/W)\n            if i < K:\n                cur += dp[-1]\n            \n        # print(dp)\n        total = sum(dp[1:min(W+1, K)])\n        left = 1\n        for i in range(W+1, W+K):\n            dp.append(total/W)\n            total -=  dp[left]\n            left += 1\n            if i < K:\n                total += dp[-1]\n        # print(dp)\n        end = sum(dp[K:])\n        good_end = sum(dp[K:N+1])\n        return good_end/end\n", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        if K==0 or K-1+W<=N:\n            return 1\n        dp=[1]+[0]*N\n        cursum=1\n        for i in range(1,N+1):\n            # dp[i]=sum(dp[max(0,i-W):min(i,K)])*(1/W)\n            dp[i]=cursum*(1/W)\n            if i<K:\n                cursum+=dp[i]\n            if i>=W:\n                cursum-=dp[i-W]\n        return sum(dp[K:])", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        # O(N + W), https://www.youtube.com/watch?v=bd0t6cj7_4E\n        # Let dp(x) be the answer when we already have x points.\n        dp = [0] * (N + W + 1)\n        \n        for i in range(K, N + 1):\n            dp[i] = 1.0\n        \n        s = N - K + 1 # How many 1.0s\n        # dp[k] = 1 / W * (dp[k+1] + dp[k+2] + ... + dp[k+W])\n        for i in range(K - 1, -1, -1):\n            dp[i] = s / W\n            # s = 0\n            # for j in range(W):\n                # s += dp[i + j + 1]\n            # dp[i] = s / W\n            s += dp[i] - dp[i + W]\n        \n        return dp[0]", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [0.0] * (N + W + 1)\n        # dp[x] = the answer when Alice has x points\n        for k in range(K, N + 1):\n            dp[k] = 1.0\n\n        S = min(N - K + 1, W)\n        # S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for k in range(K - 1, -1, -1):\n            dp[k] = S / float(W)\n            S += dp[k] - dp[k + W]\n\n        return dp[0]", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        #probability of falling into [K, K + 1, ..., N]\n        #P[i] = 1/W*(P[i - 1] + ... + P[i - W])\n        #running_sum: P[i - 1] + ... + P[i - W]\n        if K == 0:\n            return 1\n        running_sum = 1\n        P = [1]\n        for i in range(1, W):\n            P.append(1/W * running_sum)\n            running_sum += P[-1]\n        # print(P)\n        for i in range(W, K):\n            P.append(1/W * running_sum)\n            running_sum += (P[-1] - P[i-W])\n        # print(P)\n        res = 0\n        #17: = 1/W*(P[7] + ... + P[16])\n        #18: = 1/W*(P[8] + ... + P[16])\n        #19: = 1/W*(P[9] + ... + P[16])\n        \n        #At 7: 1/W chance (7 + 10)\n        #8: 2/W chance (8 + 9, 8 + 10)\n        #9: 3/W (9 + 8, 9 + 9, 9 + 10)\n        #15: 5/W (15 + 2, ..., 15 + 6)\n        #16: 5/W   (16 + 1, ..., 16 + 5)\n        running_sum = sum(P[max(0, K - W): K])\n        # print(sum(P[0:1]))\n        # print(\\\"running_sum = {0}\\\".format(running_sum))\n        # print(sum(P[7:17]) + sum(P[8:17]) + sum(P[9:17]) + sum(P[10:17]) + sum(P[11:17]))\n        # print(1*P[7] + 2*P[8] + 3*P[9] + 4*P[10] + 5*sum(P[11:17]))\n        \n        #12: (P[2] + ... + P[11])*1/W\n        #13: (P[3] + ... + P[11])*1/W\n        #14: (P[4] + ... + P[11])*1/W\n        print(sum(P[2:12]) + sum(P[3:12]) + sum(P[4:12])+  sum(P[5:12]) + sum(P[6:12]) + sum(P[7:12]) + sum(P[8:12]) + sum(P[9:12]) + sum(P[10:12]) + sum(P[11:12]))\n        #From 2: 2 + 10\n        #From 3: 3 + 9, 3 + 10\n        #From 4: 4 + 8, 4 + 9, 4 + 10\n        #From 11: 11 + 1, ..., 11 + 10\n        for i in range(max(0, K - W), K):\n            #from i: can go from max(i + 1, K) to min(i + 10, N)\n            res += P[i]/W * max((min(i + W, N) - max(i + 1, K) + 1), 0)\n            # print(res)\n        # for i in range(K, min(N + 1, K + W)):\n        #     res += (1/W * running_sum)\n        #     if i >= W:\n        #         running_sum -= P[i - W]\n        # # print(sum(P[1:11]))\n        return res", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        #probability of falling into [K, K + 1, ..., N]\n        #P[i] = 1/W*(P[i - 1] + ... + P[i - W])\n        #running_sum: P[i - 1] + ... + P[i - W]\n        if K == 0:\n            return 1\n        running_sum = 1\n        P = [1]\n        for i in range(1, W):\n            P.append(1/W * running_sum)\n            running_sum += P[-1]\n        # print(P)\n        for i in range(W, K):\n            P.append(1/W * running_sum)\n            running_sum += (P[-1] - P[i-W])\n        # print(P)\n        res = 0\n        #17: = 1/W*(P[7] + ... + P[16])\n        #18: = 1/W*(P[8] + ... + P[16])\n        #19: = 1/W*(P[9] + ... + P[16])\n        \n        #At 7: 1/W chance (7 + 10)\n        #8: 2/W chance (8 + 9, 8 + 10)\n        #9: 3/W (9 + 8, 9 + 9, 9 + 10)\n        #15: 5/W (15 + 2, ..., 15 + 6)\n        #16: 5/W   (16 + 1, ..., 16 + 5)\n        running_sum = sum(P[max(0, K - W): K])\n        # print(sum(P[0:1]))\n        # print(\\\"running_sum = {0}\\\".format(running_sum))\n        # print(sum(P[7:17]) + sum(P[8:17]) + sum(P[9:17]) + sum(P[10:17]) + sum(P[11:17]))\n        # print(1*P[7] + 2*P[8] + 3*P[9] + 4*P[10] + 5*sum(P[11:17]))\n        \n        #12: (P[2] + ... + P[11])*1/W\n        #13: (P[3] + ... + P[11])*1/W\n        #14: (P[4] + ... + P[11])*1/W\n        print(sum(P[2:12]) + sum(P[3:12]) + sum(P[4:12])+  sum(P[5:12]) + sum(P[6:12]) + sum(P[7:12]) + sum(P[8:12]) + sum(P[9:12]) + sum(P[10:12]) + sum(P[11:12]))\n        #From 2: 2 + 10\n        #From 3: 3 + 9, 3 + 10\n        #From 4: 4 + 8, 4 + 9, 4 + 10\n        #From 11: 11 + 1, ..., 11 + 10\n        \n        \n        #Last number candidates: From max(0, K - W) to K - 1\n        #From candidate i, we can go from max(i + 1, K) to min(i + W, N) \n        #so there are min(i + W, N) - max(i + 1, K) + 1 options\n        for i in range(max(0, K - W), K):\n            #from i: can go from max(i + 1, K) to min(i + 10, N)\n            res += P[i]/W * max((min(i + W, N) - max(i + 1, K) + 1), 0)\n            # print(res)\n        # for i in range(K, min(N + 1, K + W)):\n        #     res += (1/W * running_sum)\n        #     if i >= W:\n        #         running_sum -= P[i - W]\n        # # print(sum(P[1:11]))\n        return res", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        if N > K + W - 1 or K == 0: return 1\n        \n        dp = [0] * (K + W)\n        dp[1] = 1 / W\n        for i in range(2, K + 1):\n            if i == W + 1:\n                dp[i] = dp[i - 1] + (dp[W] - 1) / W\n            else:\n                dp[i] = ((W + 1) * dp[i - 1] - (dp[i - 1 - W] if i >= W + 1 else 0)) / W\n        for i in range(K + 1, K + W):\n            dp[i] = dp[i - 1] - (dp[i - W - 1] if i - W >= 2 else 0) / W\n            if i == W + 1: dp[i] -= 1 / W\n        res = sum(dp[i] for i in range(K, N + 1)) / sum(dp[i] for i in range(K, K + W))\n        return res", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        if N >= K + W - 1:\n            return 1\n        if N < K:\n            return 0\n        if K == 0:\n            return 1\n            \n        probs = [0]*(W+2)\n        probs[0] = 1\n        probs[1] = 1/W\n        for i in range(1,K):\n            probs[(i+1)%(W+2)] = probs[i%(W+2)]*(W+1)/W - probs[(i+2)%(W+2)]/W\n        for i in range(W):\n            probs[(K+i+1)%(W+2)] = probs[(K+i)%(W+2)] - probs[(K+i+2)%(W+2)]/W\n        \n        if K%(W+2) < (N+1)%(W+2):\n            return sum(probs[K%(W+2):(N+1)%(W+2)])\n        else:\n            return sum(probs[K%(W+2):]) + sum(probs[:(N+1)%(W+2)])", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        if N < K:\n            return 0\n        if N > K - 1 + W:\n            return 1\n        dp = [0] * (K + W)\n        for k in range(K, N + 1):\n            dp[k] = 1\n        \n        S = N - K + 1\n        for k in range(K - 1, -1, -1):\n            dp[k] = S/W\n            S += dp[k] - dp[k + W]\n        return dp[0]\n        \n", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        \n        if K == 0:\n            return 1.0\n        \n        if K-1+W <= N:\n            return 1.0\n        \n        prob = [0.0] * (K+W)\n        avg = 0\n        for i in range(W):\n            prob[K+i] = float(K+i <= N)\n            avg += prob[K+i] / W\n            \n        for i in range(K)[::-1]:\n            prob[i] += avg\n            avg += (prob[i] - prob[i+W]) / W\n            \n        return prob[0]", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n#         probs = [0] * (n + 1)\n#         probs[0] = 1\n        \n#         prob = 1 / w\n        \n            \n#         for i in range(k):\n#             for j in range(1, w + 1):\n#                 if i + j <= n:\n#                     probs[i + j] += probs[i] * prob\n        \n#         return sum(probs[k : n + 1])\n        \n        dp = [0.0] * (N + W + 1)\n        # dp[x] = the answer when Alice has x points\n        for k in range(K, N + 1):\n            dp[k] = 1.0\n\n        S = min(N - K + 1, W)\n        # S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for k in range(K - 1, -1, -1):\n            dp[k] = S / float(W)\n            S += dp[k] - dp[k + W]\n\n        return dp[0]", "class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [0.0] * (N + W + 1)\n        # dp[x] = the answer when Alice has x points\n        for k in range(K, N + 1):\n            dp[k] = 1.0\n\n        S = min(N - K + 1, W)\n        # # S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for k in range(K - 1, -1, -1):\n            dp[k] = S/float(W)\n            S = S + dp[k] - dp[k+W]\n            \n\n        return dp[0]"]
["def knights_tour(start, size):\n    \n    MOVES = [(-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1), (2,1), (1,2), (-1,2)]\n    \n    def genNeighs(pos): return ((pos[0]+dx, pos[1]+dy) for dx,dy in MOVES if (pos[0]+dx, pos[1]+dy) in Warnsdorf_DP)\n        \n    def travel(pos):\n        neighs = sorted( (Warnsdorf_DP[n], n) for n in genNeighs(pos) )\n        for nSubNeighs,neigh in neighs:\n            del Warnsdorf_DP[neigh]\n            path.append(neigh)\n            subNeighs = list(genNeighs(neigh))\n            for n in subNeighs: Warnsdorf_DP[n] -= 1\n            travel(neigh)\n            if not Warnsdorf_DP:\n                break\n            else:\n                for n in subNeighs: Warnsdorf_DP[n] += 1\n                Warnsdorf_DP[path.pop()] = nSubNeighs\n    \n    \n    path, Warnsdorf_DP = [start], {(x,y): 0 for x in range(size) for y in range(size) if (x,y) != start}\n    for pos in Warnsdorf_DP: Warnsdorf_DP[pos] = sum(1 for _ in genNeighs(pos))\n    travel(start)\n    \n    return path", "def knights_tour(start, size):\n    \"\"\"\n    Finds a knight's tour from start position visiting every\n    board position exactly once.\n    \n    A knight may make any \"L\" move which is valid in chess. That is:\n    any rotation of \"up 1 over 2\" or \"up 2 over 1\". The problem\n    description has a full explanation of valid moves.\n    \n    Arguments:\n        start - (row, col) starting position on board.\n        size - number of rows in the square board.\n        \n    Returns:\n        List of positions beginning with the start position\n        which constitutes a valid tour of the board; visiting\n        each position exactly once.\n    \"\"\"\n    def next_moves(pos):\n        eight_moves = ((pos[0] + i, pos[1] + j) for (i, j) in ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (2, -1), (2, 1), (1, -2), (1, 2)))\n        return [(r, c) for (r, c) in eight_moves if 0 <= r and r < size and 0 <= c and c < size and board[r][c]]\n        \n\n    def solve(pos):\n        if len(moves) == size * size: return moves\n        for r, c in sorted(next_moves(pos), key=lambda m: len(next_moves(m))):\n            board[r][c] = False\n            moves.append((r, c))\n            try:\n                return solve((r, c))\n            except ValueError:\n                board[r][c] = True\n                moves.pop()\n        raise ValueError('Not possible')\n    \n    board = [[True] * size for _ in xrange(size)]\n    board[start[0]][start[1]] = False\n    moves = [start]\n\n    return solve(start)", "from heapq import *\nMOVES = [(-1,-2), (-1, 2), (-2, -1), (-2, 1), (1, -2),(1, 2), (2, -1), (2, 1)]\ndef knights_tour(start, size):\n    \n    seen = set([start])\n    path = [start]\n\n\n    for i in range(size*size):\n        q = []\n        x,y = start\n        for dx, dy in MOVES:\n            xx = x + dx\n            yy = y + dy\n            if (xx,yy) not in seen and (0<=xx<size and 0<=yy<size):\n                c = 0\n                for a, b in MOVES:\n                    xxx = xx + a\n                    yyy = yy + b\n                    if (xxx,yyy) not in seen and (0<=xxx<size and 0<=yyy<size):\n                        c += 1\n                heappush(q,(c,(xx,yy)))\n                \n        if q:\n            start = heappop(q)[1]\n            path.append(start)\n            seen.add(start)\n        \n    return path", "def knights_tour(p, n):\n    (x, y), b, r = p, [[0] * n for _ in range(n)], [None] * n**2\n    b[x][y], r[0] = 1, p\n    d = ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1))\n    f = lambda x, y: ((X, Y) for dx, dy in d for X, Y in ((x + dx, y + dy),) if 0 <= X < n and 0 <= Y < n and not b[X][Y])\n    for i in range(2, n**2 + 1):\n        x, y = min(f(x, y), key=lambda x: sum(1 for _ in f(x[0], x[1])))\n        b[x][y], r[i-1] = i, (x, y)\n    return r", "import heapq\nclass Knight:\n    def __init__(self, start, size):\n        self.i, self.j = start\n        self.size = size\n        self.board = [[0 for _ in range(size)] for _ in range(size)]\n        self.moves = [(2, 1), (2, -1), (1, -2), (1, 2), (-2, 1), (-2, -1), (-1, 2), (-1, -2)]\n    \n    def valid(self,x,y):\n        return 0 <= x < self.size and 0 <= y < self.size and not self.board[x][y]\n        \n    def find_neighbour(self, x, y):\n        heap = []\n        for i, j in self.moves:\n            ni, nj = x + i, y + j\n            if self.valid(ni, nj):\n                neighbours = self.find_neighbour_of_neighbour(ni, nj)\n                heapq.heappush(heap, (neighbours, (i, j)))\n        return heap\n    \n    def find_neighbour_of_neighbour(self, x, y):\n        return sum(self.valid(x+i, y+j) for i, j in self.moves)\n    \n    def get_path(self):\n        i, j = self.i, self.j\n        path = [(i, j)]\n        for n in range(self.size * self.size):\n            self.board[i][j] = n + 1\n            avl = self.find_neighbour(i, j)\n            if not avl : break\n            _, (ni, nj) = heapq.heappop(avl)\n            i += ni\n            j += nj\n            path.append((i, j))\n        return path\n    \ndef knights_tour(start, size):\n    return Knight(start,size).get_path()", "import copy\n\n\ndef knights_tour(start, size):\n    print(start, size)\n    \"\"\"\n    Finds a knight's tour from start position visiting every\n    board position exactly once.\n\n    A knight may make any \"L\" move which is valid in chess. That is:\n    any rotation of \"up 1 over 2\" or \"up 2 over 1\". The problem\n    description has a full explanation of valid moves.\n\n    Arguments:\n        start - (row, col) starting position on board.\n        size - number of rows in the square board.\n\n    Returns:\n        List of positions beginning with the start position\n        which constitutes a valid tour of the board; visiting\n        each position exactly once.\n    \"\"\"\n    board = []\n    for i in range(size):\n        board.append([0 for _ in range(size)])\n    board[start[0]][start[1]] = 1\n    _, result = tour(board, start[0], start[1], 2)\n    return list(reversed(result))\n\n\ndef tour(board, last_x, last_y, move_number):\n    if move_number == len(board) ** 2 + 1:\n        return True, [(last_x, last_y)]\n    x = [2, 1, -1, -2, -2, -1, 1, 2]\n    y = [1, 2, 2, 1, -1, -2, -2, -1]\n    moves = list(zip(x, y))\n    legal_moves = [(x, y) for (x, y) in moves if is_move_legal(board, len(board), last_x + x, last_y + y)]\n\n    priorities = dict()\n\n    for move in legal_moves:\n        priorities[move] = count_possible_moves(board, last_x + move[0], last_y + move[1])\n\n    for move, _ in sorted(list(priorities.items()), key=by_value):\n\n\n    # for move in legal_moves:\n        board_copy = copy.deepcopy(board)\n        board_copy[last_x][last_y] = move\n        result, trace = tour(board_copy, last_x + move[0], last_y + move[1], move_number + 1)\n        if result:\n            return True, trace + [(last_x, last_y)]\n    return False, None\n\n\ndef is_move_legal(board, size, new_x, new_y):\n    return size > new_x >= 0 and size > new_y >= 0 and board[new_x][new_y] == 0\n\n\ndef count_possible_moves(board, cx, cy):\n    x = [2, 1, -1, -2, -2, -1, 1, 2]\n    y = [1, 2, 2, 1, -1, -2, -2, -1]\n    moves = list(zip(x, y))\n\n    return sum([1 for (nx, ny) in moves if is_move_legal(board, len(board), cx + nx, cy + ny)])\n\ndef by_value(item):\n    return item[1]\n\ndef __starting_point():\n    print((knights_tour((0, 2), 6)))\n\n__starting_point()", "from itertools import product\ndef knights_tour(start, size):\n    m = [[0]*size for i in range(size)]\n    d = [[0]*size for i in range(size)]\n    directions = [1,2,-1,-2]\n    directions = [(y,x) for y,x in product(directions,directions) if abs(y)!=abs(x)]\n    def inside(y,x): return not (y<0 or x<0 or y>=size or x>=size) and m[y][x] == 0\n    def search(start,step):\n        if step>size**2: return []\n        y,x=start\n        m[y][x] = 1\n        for yy,xx in product(range(size),range(size)):\n           d[yy][xx] = [(yy+dy,xx+dx) for dx,dy in directions if inside(yy+dy,xx+dx)]\n        s,nxt = min([(len(d[ny][nx]),(ny,nx)) for ny,nx in d[y][x]]+[(int(1e9),start)])\n        return [start]+search(nxt,step+1)\n    return search(start,1)", "def knights_tour(start, size):\n    \"\"\"\n    Finds a knight's tour from start position visiting every\n    board position exactly once.\n\n    A knight may make any \"L\" move which is valid in chess. That is:\n    any rotation of \"up 1 over 2\" or \"up 2 over 1\". The problem\n    description has a full explanation of valid moves.\n\n    Arguments:\n        start - (row, col) starting position on board.\n        size - number of rows in the square board.\n\n    Returns:\n        List of positions beginning with the start position\n        which constitutes a valid tour of the board; visiting\n        each position exactly once.\n    \"\"\"\n    def degree(p):\n        adj = [(p[0] + x, p[1] + y) for x, y in directions]\n        return sum([1 for x, y in adj if 0 <= x < size and 0 <= y < size and board[x][y] == -1])\n\n    def check_board():\n        return all([sq != -1 for row in board for sq in row])\n\n    def knight_dfs(pos, cnt):\n        if check_board():\n            return True\n        moves = filter(lambda m: 0 <= m[0] < size and 0 <= m[1] < size and board[m[0]][m[1]] == -1,\n                       [(pos[0] + x, pos[1] + y) for x, y in directions])\n        moves = sorted(moves, key=degree)\n        for move in moves:\n            board[move[0]][move[1]] = cnt\n            if knight_dfs(move, cnt + 1):\n                return True\n            else:\n                board[move[0]][move[1]] = -1\n\n    def print_board():\n        for row in board:\n            print row\n\n    directions = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    board = [[-1] * size for _ in range(size)]\n    board[start[0]][start[1]] = 0\n    knight_dfs(start, 1)\n    print_board()\n    return sorted([(i, j) for i in range(size) for j in range(size)], key=lambda x: board[x[0]][x[1]])", "from typing import Tuple, Iterable, List\n\nPosition = Tuple[int, int]\nPositions = List[Position]\n\nMOVES: Tuple[Position, ...] = ((-1, -2), (1, -2), (-2, -1), (2, -1), (-2, 1), (2, 1), (-1, 2), (1, 2))\n\n\ndef knights_tour(start: Position, size: int) -> Positions:\n    board = [[False] * size for _ in range(size)]\n\n    def moves(x: int, y: int) -> Iterable[Position]:\n        for xd, yd in MOVES:\n            xx, yy = x + xd, y + yd\n\n            if 0 <= xx < size and 0 <= yy < size and not board[xx][yy]:\n                yield xx, yy\n\n    def dfs(path: Positions) -> Iterable[Positions]:\n        if len(path) == size ** 2:\n            yield path\n            return\n\n        x, y = path[-1]\n        board[x][y] = True\n\n        for vv in sorted(moves(x, y), key=lambda n: len([*moves(*n)])):\n            path.append(vv)\n            yield from dfs(path)\n            path.pop()\n\n        board[x][y] = False\n\n    return next(dfs([start]), [])", "Offsets = ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2))\n\ndef knights_tour(start, size):\n    visited = {}\n    peers = {}\n    path = [start]\n\n    for y in range(size):\n        for x in range(size):\n            visited[(y, x)] = 0\n            peers[(y, x)] = [(oy + y, ox + x) for oy, ox in Offsets if 0 <= oy + y < size and 0 <= ox + x < size]\n\n    size **= 2\n    visited[start] = 1\n\n    def find(curr):\n        if len(path) == size: return path\n\n        for peer in sorted((p for p in peers[curr] if not visited[p]),\n                            key = lambda p: sum(not visited[p2] for p2 in peers[p])):\n            visited[peer] = 1\n            path.append(peer)\n            if find(peer): return path\n            visited[peer] = 0\n            path.pop()\n\n    return find(start)"]
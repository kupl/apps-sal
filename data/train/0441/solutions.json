["class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 1\n        \n        # Remove all even factors\n        while N % 2 == 0:\n            N //= 2\n        \n        # Count all odd factors\n        idx = 3        \n        while idx * idx <= N:\n            count = 0\n            \n            # found an odd factor\n            while N % idx == 0:\n                N //= idx\n                count += 1\n            \n            res *= count + 1\n            idx += 2\n        \n        return res if N == 1 else res * 2", "import math\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        num = N\n        if num == 1:\n            return 1\n        counter = 1\n        for i in range(2, math.floor(math.sqrt(num) + 1)):\n            if num % i == 0:\n                if i % 2 == 1:\n                    counter += 1\n                c = num // i\n                if i != c and c % 2 == 1:\n                    counter += 1\n        if num % 2 == 1:\n            counter += 1\n\n        return counter", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        \n        k = 1\n        count = 0\n        while N / k - (k / 2) > 0:\n            print(k)\n            if k % 2 != 0 and N % k == 0:\n                count += 1\n            elif N / k == N // k + 0.5:\n                count += 1\n            k += 1\n        return count\n        \n        #15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n        # 15 / 1 = 15\n        # 15 / 2 = 7.5 = 8 + 7\n        # 15 / 3 = 5 = 4+5+6\n        # 15 / 4 = 3. 75 not use\n        # 15 / 5 = 3    ( 3 - 5 / 2) > 0\n        # 15 / 6 = 2.5    (2.5 - 6 / 2) < 0  not use\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        # number of ways to write N as a sum of consecutive posititive integers\n        # with k consecutive integers, you can have\n        # 1, 2, ..., k or 2, 3, ..., k + 1 or 3, 4, ..., k + 2\n        # 1, 2, ..., k or 1, 2, ..., k, k or 1, 2, ..., k, k, k\n        # => N can be written as a sum of k consecutive integers if (N - (1 + 2 + ... k)) mod k == 0\n        # (1 + 2 + ... k) = k (k + 1) / 2\n        num_ways = 1\n        n = 2\n        while (n * (n + 1) / 2) <= N:\n            if (N - (n * (n + 1) / 2)) % n == 0:\n                num_ways += 1\n            n += 1\n        return num_ways", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans = 0\n        for i in range(1, N+1):\n            x = (2*N/i-i+1)/2\n            if x <= 0: break\n            if x == int(x):\n                # print(i,x)\n                ans += 1\n        return ans", "#math\n#time:O(sqr(N))\n'''\nx + (x+1) + (x+2)+...+ k terms = N\nkx + k*(k-1)/2 = N ->\nkx = N - k*(k-1)/2 ->\nN-k*(k-1)/2>0\n'''\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        k,count = 1,0\n        while N > k*(k-1)/2:\n            if (N - k*(k-1)/2)%k == 0:\n                count += 1\n            k += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        # res = 0\n        # # explain math\n        # upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5)\n        # for k in range(upper_limit):\n        #     N -= k\n        #     if N % k == 0:\n        #         res += 1\n        # return res\n        res, k = 0, 1\n       \n        while (k*(k+1) <= 2*N):\n            x = float(N)/k-(k+1)/2.0\n            if ((2*N)%k == 0 and x.is_integer() ):\n                res += 1\n                #print(k,x)\n            k+=1\n        return res", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        counter = 0\n        i = 0\n\n        while N - (i * (i + 1) // 2) > 0:\n            if (N - (i * (i + 1) // 2)) % (i + 1) == 0:\n                counter += 1\n\n            i += 1\n\n        return counter", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        B = (2 * N + 0.25) ** 0.5 + 0.5\n        B = ceil(B)\n        ans = 0\n        for k in range(1, B+1):\n            a = 2*N - k ** 2\n            b = (2*N - k ** 2) // k\n            c = b + 1\n            if a % k == 0 and c % 2 == 0:\n                m = c // 2\n                if m > 0:\n                    ans += 1\n                    #print(m, k)\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 1\n        n = 2\n        while((2*N + n - n*n) > 0):\n            start = (2*N + n - n**2)/(2*n)\n            if(start - int(start) == 0):\n                count += 1\n            n+=1\n        return count\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        num = N\n        if num == 1:\n            return 1\n        counter = 1\n        for i in range(2, int(num ** 0.5 + 1)):\n            if num % i == 0:\n                if i % 2 == 1:\n                    counter += 1\n                c = num // i\n                if i != c and c % 2 == 1:\n                    counter += 1\n        if num % 2 == 1:\n            counter += 1\n\n        return counter", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        n = int((1 + math.sqrt(1+8*N))/2)\n        print(n)\n        ans = 0\n        for i in range(1, n):\n            if (2*N + i - i**2) != 0 and (2*N + i - i**2) % (2*i) == 0:\n                ans += 1\n        \n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        l = 1\n        out = 0\n        # range start a, end b\n        # l = b - a + 1\n        while (1 + l) * l / 2 <= N:\n            b = (2*N + l**2 - l) / (2*l)\n            a = b + 1 - l\n            if a == int(a) and b == int(b):\n                out += 1\n            l += 1\n        return out", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        n = 1\n        ans = 0\n        \n        def helper(n):\n            return n * (n + 1) / 2\n        \n        while helper(n) <= N:\n            ans += int((N - helper(n)) % n == 0)\n            n += 1\n        \n        return ans\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        \n        total = 1 # no need to for N\n        \n        N = 2*N\n        \n        for i in range(2, int(N**.5) + 1): # from 2 to sqrt of N\n            if N % i == 0 and ((i + (N/i)) % 2 == 1):\n                total += 1\n                \n            \n        return total", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        target = 2 * N \n        results = 0\n        for k in range(1, int(sqrt(target))+1): \n            if target % k == 0:\n                num = (target / k) - k - 1 \n                if num >= 0 and num % 2 == 0:\n                    results += 1\n        return results", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count, upper_limit = 0, int(math.sqrt(2*N + 1/4) - 1/2)\n        for i in range(1,upper_limit + 1):\n            N -= i\n            if not N % i:\n                count+=1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n        for k in range(1, upper_limit):\n            N -= k\n            if N % k == 0:\n                count += 1\n        return count\n                \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 0\n        m = int(sqrt(2*N)+1)\n        for i in range(1,m):\n            N -= i\n            if N % i == 0:\n                res += 1\n        return res", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        def canwrite(N, n):\n            x = (N -  n * (n+1) / 2)\n            return  x >=0 and x% n == 0\n        res = 0\n        m = int(sqrt(2*N)+1)\n        for i in range(1,m):\n            N -= i\n            if N % i == 0:\n                res += 1\n        return res", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans = 0\n        for k in range (1, int(sqrt(2 * N)) + 1):\n            if 2 * N % k == 0:\n                x = 2 *N // k - k - 1\n                if x % 2 == 0 and x >= 0:\n                    ans += 1\n        return ans ", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 1\n        i = 3\n        while N % 2 == 0:\n            N /= 2\n        while i * i <= N:\n            count = 0\n            while N % i == 0:\n                N /= i\n                count += 1\n            res *= count + 1\n            i += 2\n        return res if N == 1 else res * 2", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        last_check = ceil(sqrt(2*N))\n        num_ways = 0\n        for i in range(1,last_check):\n            if (N*2) % i == 0 and (i % 2 == 1 or (N*2/i) % 2 == 1):\n                num_ways += 1\n        return num_ways\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        \n        res = 1\n        n=N\n        for i in range(2, math.floor((1 + (1+8*n)**0.5) / 2)):\n            \n            if ((n/i) - (i-1)/2).is_integer():\n                res += 1\n\n        return res", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0 \n        limit = ceil(((2*N + 0.25)**0.5) - 0.5) + 1\n        for k in range(1, limit):\n            if ((N/k) - (k+1)/2).is_integer():\n              count = count + 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n#         (2S + C - 1) * C / 2 = N\n#         (2S + C - 1) C =  2N\n        cnt = 0\n        for c in range(1, floor(sqrt(2 * N)) + 1):\n            if (2 * N) % c == 0:\n                if ((2 * N / c) - c) % 2 == 1:\n                    cnt += 1\n                print(c)\n        return cnt\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        \n        res = 1\n        n=N\n        for i in range(2, int((1 + (1+8*n)**0.5) / 2)):\n            \n            if ((n/i) - (i-1)/2).is_integer():\n                res += 1\n\n        return res", "# N = (x + 1) + ... + (x + k)\n# N = x k + k(k + 1)/2\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        # x > 0 --> N/k - (k + 1)/2 > 0\n        upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n        for k in range(1, upper_limit):\n            # x should be integer\n            if (N - k * (k + 1) // 2) % k == 0:\n                count += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        # 2N = 2xk + k(k + 1) => 2N = k(2x + k + 1) => x = N/k - (k + 1)/2 => 2N >= k(k + 1)\n        # => 2N + 1/2 >= (k + 1/4)^2 => k <= sqrt(2N + 1/4) - 1/2\n        count = 0\n        limit = ceil(sqrt(2 * N + 0.25) - 0.5)\n        for k in range(1, limit + 1):\n            if (N - k * (k + 1) // 2) % k == 0:\n                count += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        # x > 0 --> N/k - (k + 1)/2 > 0\n        upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n        for k in range(1, upper_limit):\n            # x should be integer\n            if (N - k * (k + 1) // 2) % k == 0:\n                count += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 1\n        upper_limit = ceil((2*N + 1)**0.5)\n        for k in range(2, upper_limit):\n            if (N - k * (k - 1) // 2) % k == 0:\n                count += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        upper_limit = ceil((2*N + 0.25)**0.5-0.5)+1\n        for k in range(1, upper_limit):\n            if (N-k*(k+1)//2)% k==0:\n                count +=1\n        return count\n", "class Solution:\n    def consecutiveNumbersSum(self, N):\n        res = 1\n        i = 3\n        while N % 2 == 0:\n            N /= 2\n        while i * i <= N:\n            count = 0\n            while N % i == 0:\n                N /= i\n                count += 1\n            res *= count + 1\n            i += 2\n        return res if N == 1 else res * 2", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        bound = int((2*N + 0.25)**0.5 - 0.5) + 1\n        for k in range(1, bound):\n            if (N - k*(k + 1) // 2) % k == 0:\n                count += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans = 0\n        upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n        for x in range(1,upper_limit):\n            if (2*N - x*x + x) % (2*x) == 0:\n                ans += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans = 1\n        cur_iter = 1\n        while True:\n            N -= cur_iter\n            res = N / (cur_iter+1)\n            if res < 1:\n                break\n            if res.is_integer():\n                ans += 1\n            cur_iter += 1\n        return ans\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans = 0\n        upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n        for x in range(1,upper_limit):\n            if (2*N - x*x + x) % (2*x) == 0 and (2*N - x*x + x) / (2*x) > 0:\n                ans += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        counter = 0\n        \n        for num_terms in range(1, N+1):\n            difference = num_terms*(num_terms-1)//2\n            remainder = N - difference\n            if remainder <= 0: break\n            if remainder%num_terms==0:\n                counter += 1\n\n        return counter", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 1;\n        for k in range(2, int((2*N)**0.5)+1):\n            if ( ( N - ( k * ( k - 1 )/2) ) % k == 0):\n                count += 1\n        return count\n", "class Solution:\n    def consecutiveNumbersSum(self, x: int) -> int:\n        ans = 1\n        for n in range(2, 100000):\n            # if n % 2 == 0:\n                \n            a = x - n * (n - 1) // 2\n            b = n\n            if a < b:\n                break\n            if a % b == 0:\n                ans += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        \n        ini = 2\n        re = 0\n        \n        while True:\n            \n            m = (N/ini) - (ini-1)/2\n            \n            if m <= 0:\n                break\n            \n            elif m%1 == 0:\n                re += 1\n            \n            ini += 1\n        \n        return re+1\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        max_k = ceil((2 * N + 1/4) ** 0.5 - 0.5) + 1\n        for k in range(1, max_k):\n            if (N - k * (k + 1) / 2) % k == 0:\n                count += 1\n        return count\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans, constants, div = 0, 0, 0\n        for i in range(N):\n            div += 1\n            constants = constants + i\n            quotient, remainder = divmod((N-constants), div)\n            if quotient <= 0:\n                return ans\n            if not remainder:\n                ans += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n\n        res = 1\n        i = 3\n        while N % 2 == 0:\n            N /= 2\n        while i * i <= N:\n            count = 0\n            while N % i == 0:\n                N /= i\n                count += 1\n            res *= count + 1\n            i += 2\n        return res if N == 1 else res * 2", "# N = (x + 1) + ... + (x + k)\n# N = x k + k(k + 1)/2\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        # x > 0 --> N/k - (k + 1)/2 > 0\n        upper_limit = ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n        for k in range(1, upper_limit):\n            # x should be integer\n            if ((N - k * (k + 1) // 2) / k)%1 == 0:\n                count += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, x: int) -> int:\n        ans = 1\n        for n in range(2, 100000):\n            a = 2 * x - n * (n - 1)\n            b = 2 * n\n            if a < b:\n                break\n            if a % b == 0:\n                ans += 1\n        return ans", "'''\n\u53ef\u80fd\u6027\uff1a\n1\u500b\u6578\u5b57\uff1as\n2\u500b\u6578\u5b57\uff1as + s+1\n3\u500b\u6578\u5b57\uff1as + s+1 + s+2\n...\nn\u500b\u6578\u5b57\uff1as + ...\n\n=>\nn\n2n+1\n3n+1+2\n4n+1+2+3\n...\n=>\nN = kn + (k-1 + 1)*(k-1)/2\n=>\nN = kn + (k**2-k)/2\n=>\nn = (N-(k**2-k)/2)/k\nn>0\u4e14n\u70ba\u6574\u6578\u5247\u7b26\u5408\n\n'''\nclass Solution1:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 0\n        \n        for k in range(1, 10**9):\n            t = (k**2-k)/2\n            s = (N-t)/k\n\n            if s <= 0:\n                break\n            \n            if s.is_integer():\n                res += 1\n        \n        return res\n# refactor\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 0\n        \n        for k in range(1, 10**9):\n            s = N - (k*k-k)/2\n            if s <= 0:\n                break\n\n            if s % k == 0:\n                res += 1\n                continue\n\n        \n        return res", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        ans, constants, div = 0, 0, 0\n        for i in range(N):\n            div = i + 1\n            constants = constants + i\n            quotient, remainder = divmod((N-constants), div)\n            if quotient <= 0:\n                return ans\n            if not remainder:\n                ans += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        counts = 0\n        i = 1\n        while True:\n            calc = (i*i - i) / 2\n            if calc >= n:\n                break\n            if (n - calc) % i == 0:\n                counts += 1\n            i += 1\n        print((2.2222 % 1))\n        return counts\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        #Look like start with some number, add up til sum = N\n        #k + (k+1) + (k+2) + (k+i) = N\n        #k*i + (0+1+2+..+i) = N\n        #k*i + (i(i+1)/2) = N\n        #k * i = (N - (i(i+1)/2)) -> full chunk % i == 0 -> k is start point\n        \n        i, ans = 1, 0\n        while N > i * (i - 1) // 2:\n            if (N - i * (i + 1) // 2) % i == 0:\n                ans += 1\n            i += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n#         if N < 3: return 1\n#         l = 1\n#         r = 0\n#         s = 0\n#         ret = 0\n#         while r < (N + 1) // 2:\n#             r += 1\n#             s += r\n            \n#             while s > N:\n#                 s -= l\n#                 l += 1\n#             if s == N:\n#                 ret += 1\n#         return ret + 1\n        ans = 0\n        k = 1\n        while True:\n            a, b = divmod(N, 2 * k)\n            if a >= k and b == k:\n                ans += 1\n            elif a < k:\n                break\n            a, b = divmod(N, 2 * k + 1)\n            if a >= k + 1 and b == 0:\n                ans += 1\n            elif a < k + 1:\n                break\n            k += 1\n        return ans + 1", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        if not N:\n            return 0\n        \n        count = 0\n        idx = 1\n        while (idx*(idx+1)//2 <= N):\n            if (N - idx*(idx+1)//2) % idx == 0:\n                count += 1\n            idx += 1\n        return count\n        \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        i = 1\n        res = 0\n        while N > i*(i-1)//2:\n            if (N - i*(i-1)//2) % i == 0:\n                res += 1\n            i += 1\n        return res\n            \n            \n# N = k + k+1 + ... k+i-1\n# N = k*i + (0+i-1)*i/2\n# N - i*(i-1)/2 = k*i\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        k = 1\n        num_ways = 0\n        while k * (k - 1) // 2 < N:\n            if  (N - k * (k - 1) // 2) % k == 0:\n                num_ways += 1\n            k += 1\n        return num_ways", "import math\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        a=N\n        while a%2==0:\n            a=a//2\n        s=math.sqrt(a)\n        i=1\n        ans=0\n        while i<s:\n            if a%i==0:\n                ans+=1\n            i+=2\n        if i*i==a:\n            return 2*ans+1\n        else:\n            return 2*ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 0\n        k = 1\n        while N - k * (k + 1) // 2 >= 0:\n            if (N - k * (k + 1) // 2) % k == 0:\n                res += 1\n            k += 1\n        \n        return res", "import math\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        for n in range(1,math.ceil(-0.5+math.sqrt(0.25+2*N))):\n            start = N/(n+1) - n/2\n            if math.isclose(0, start - math.floor(start)):\n                count += 1\n        return count+1", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        def verify_even(k):\n            return N % k != 0 and (2 * N) % k == 0\n        \n        def verify_odd(k):\n            return N % k == 0\n        \n        count = 0\n        \n        # Find all odd factors\n        for i in range(1, int(math.sqrt(2 * N)) + 1, 1):\n            if i % 2 == 0 and verify_even(i):\n                count += 1\n            elif i % 2 == 1 and verify_odd(i):\n                count += 1\n                \n                \n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        n = 0\n        ans = 0\n        while (N - n*(n+1)//2) > 0:\n            if (N - n*(n+1)//2)%(n+1) == 0:\n                ans +=1\n            n +=1\n        return ans\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        def canwrite(N, n):\n            x = (N -  n * (n+1) / 2)\n            return  x >=0 and x% n == 0\n        res = 0\n        for i in range(1,int(sqrt(2*N)+1)):\n            if canwrite(N,i):\n                res += 1\n        return res", "import math\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        k = 1.0\n        count = 0\n        while k <= math.sqrt(2*N + 1/4) - 1/2:\n            x = N/k - (k +1)/2\n            if x.is_integer():\n                count += 1\n                print(k, x)\n            k += 1\n        return count", "import math\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        k = 1.0\n        count = 0\n        while k <= math.sqrt(2*N + 1/4) - 1/2:\n            x = N/k - (k +1)/2\n            if x.is_integer():\n                count += 1\n            k += 1\n        return count", "class Solution:\n    # Backtrack\n    def consecutiveNumbersSum(self, num: int) -> int:\n        count = 1\n\n        queue = collections.deque()\n        for i in range(1, num):\n            queue.append((i, i))  # cur, sum\n\n        while queue:\n            cur, total = queue.popleft()\n            # add the next number\n            if total + cur + 1 == num:\n                count += 1\n            elif total + cur + 1 < num:\n                queue.append((cur + 1, total + cur + 1))\n        return count\n    \n    # N = (x + 0) + (x + 2) + ... + (x + k - 1)\n    # N = x * k + (k - 1) * k / 2 -> N - (k - 1) * k / 2 = x * k.\n    # So as long as N - (k - 1) * k / 2 is x times of k, there is a solution.\n    # Iterate all possible values of k in the rage [1, k * (k - 1) / 2 < N]\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        k = 1\n        while k * (k - 1) / 2 < N:\n            if (N - k * (k - 1) / 2) % k == 0:\n                count += 1\n            k += 1\n        return count\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        # up till N // 2 + 1\n        # output is at least 1\n        # if N == 1 or N == 2:\n        #     return 1\n        # start = N // 2 + 1\n        # result = 1\n        # candidates = [i for i in range(start,0,-1)]\n        # n = 2\n        # i = 0\n        # while True:\n        #     if i+n > start:\n        #         return result\n        #     # print(candidates[i:i+n])\n        #     temp_sum = (candidates[i] + candidates[i+n-1]) * n / 2\n        #     if temp_sum == N:\n        #         result += 1\n        #         i += 1\n        #         n += 1\n        #     elif temp_sum > N:\n        #         i += 1\n        #     else:\n        #         n += 1\n        res = 1\n        i = 3\n        while N % 2 == 0:\n            N /= 2\n        while i * i <= N:\n            count = 0\n            while N % i == 0:\n                N /= i\n                count += 1\n            res *= count + 1\n            i += 2\n        return res if N == 1 else res * 2\n            \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        i = 1\n        res = 0\n        while N > i*(i-1)/2:\n            if (N - i*(i-1)/2) % i == 0:\n                res += 1\n            i += 1\n        return res\n            \n            \n# N = k + k+1 + ... k+i-1\n# N = k*i + (0+i-1)*i/2\n# N - i*(i-1)/2 = k*i\n", "def sum_up_to(n):\n    return n * (n + 1) // 2\n\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        k = 1\n        num_ways = 0\n        while k * (k - 1) // 2 < N:\n            if  (N - sum_up_to(k - 1)) % k == 0:\n                num_ways += 1\n            k += 1\n        #def compute_floor():\n        #    return (N - sum_up_to(k - 1)) // k\n        #floor = compute_floor()\n        #while floor > 0:\n        #    this_sum = sum_up_to(floor + k - 1) - sum_up_to(floor - 1)\n        #    if this_sum == N:\n        #        num_ways += 1\n        #    floor = compute_floor()\n        return num_ways\n\n#x + (x+1) + (x+2) + ... + (x+k-1) = N\n#k * (k - 1) / 2 = (k**2 - k) / 2 < k**2\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n#         if N == 1: \n#             return 1\n#         res = 1\n#         for i in range(2, floor(1 + N ** (0.5))):   \n#             if N % i == 0:\n#                 if i % 2 == 1: # If i is odd, then we can form a sum of length i\n#                     res += 1\n#                 j = (N // i) # Check the corresponding N // i\n#                 if i != j and j % 2 == 1:\n#                     res += 1\n#         if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\n#             res += 1\n        \n#         return res\n        \n#         if N == 1:\n#             return 1\n#         total = 1\n        \n#         start = 1\n#         end = 1\n        \n#         curr = 1\n#         while end <= ceil(N / 2):\n#             if curr == N:\n#                 total += 1\n#                 curr -= start\n#                 start += 1\n#             if curr < N:\n#                 end += 1\n#                 curr += end\n#             elif curr > N:\n#                 curr -= start\n#                 start += 1\n        \n#         return total\n                \n        \n        c,k = 0,0\n        while( k * (k+1) / 2 < N):\n            r = N- k * (k + 1) / 2\n            if  r % (k+1) == 0: c+=1\n            k +=1\n            \n        return c", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 1\n        L = 1\n        while( L * (L + 1) < 2 * N): \n            a = (1.0 * N - (L * (L + 1) ) / 2) / (L + 1) \n            if (a ==int(a) ): \n                count += 1\n            L += 1\n        return count\n", "import math\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 1\n        maxK = int(math.sqrt(N)) * 2\n        for k in range(2, maxK+1):\n            if (k*(k - 1 )/2) >= N:\n                continue\n            if (N - (k*(k - 1 )/2)) % k == 0:\n                print(k)\n                res += 1\n        \n\n        return res", "'''\n\u53ef\u80fd\u6027\uff1a\n1\u500b\u6578\u5b57\uff1as\n2\u500b\u6578\u5b57\uff1as + s+1\n3\u500b\u6578\u5b57\uff1as + s+1 + s+2\n...\nn\u500b\u6578\u5b57\uff1as + ...\n\n=>\nn\n2n+1\n3n+1+2\n4n+1+2+3\n...\n=>\nN = kn + (k-1 + 1)*(k-1)/2\n=>\nN = kn + (k**2-k)/2\n=>\nn = (N-(k**2-k)/2)/k\nn>0\u4e14n\u70ba\u6574\u6578\u5247\u7b26\u5408\n\n'''\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 0\n        \n        for k in range(1, 10**9):\n            t = (k**2-k)/2\n            s = (N-t)/k\n\n            if s <= 0:\n                break\n            \n            if s.is_integer():\n                res += 1\n        \n        return res", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        L = 1\n        while( L * (L + 1) < 2 * N): \n            a = (1.0 * N - (L * (L + 1) ) / 2) / (L + 1) \n            if (a - int(a) == 0.0): \n                count += 1\n            L += 1\n        return count + 1", "class Solution:\n    def consecSumIncludeA(self, N: int, A: int) -> List[int]:\n        csum = A\n        c = A\n        while csum < N:\n            c += 1\n            csum += c\n        if csum == N:\n            return 1\n        return 0\n    \n    def consecutiveNumbersSumtimeout(self, N: int) -> int:\n        if N == 1:\n            return 1\n        uplim = int(N/2)\n        if N%2==1:\n            uplim = int((N//2)+1)\n        fin = 1\n        for ii in range(1,uplim+1):\n            # print(\\\"ii now: {}; fin now: {}\\\".format(ii,fin))\n            fin += self.consecSumIncludeA(N-ii,ii+1)\n        return fin\n    \n    def consecutiveNumbersSum(self, N: int) -> int:\n        # if N = sum([1,...,x])+x.a, then N can be expressed as a sum of x consecutive numbers\n        if N == 1:\n            return 1\n        combo = 1 \n        fin = 1\n        form = 2\n        sumsf = 1\n        while form < 2*N:\n            # print(\\\"form: {}, fin: {}\\\".format(form, fin))\n            combo += 1\n            if (N-sumsf)%combo == 0:\n                fin += 1\n            form = combo+combo**2\n            sumsf += combo\n        return fin\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        if N == 1: \n            return 1\n        res = 1\n        for i in range(2, int(N ** .5 + 1)):   \n            if N % i == 0:\n                if i % 2 == 1: # If i is odd, then we can form a sum of length i\n                    res += 1\n                j = (N // i) # Check the corresponding N // i\n                if i != j and j % 2 == 1:\n                    res += 1\n        if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\n            res += 1\n        \n        return res\n        \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        l = 0\n        \n        ans = 0\n        \n        while l*(l+1)/2 < N:\n            a = (N-l*(l+1)/2) / (l+1)\n            if int(a) - a == 0:\n                ans += 1\n            l += 1\n        \n        return ans\n    \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        i, ans = 1, 0\n        while N > i * (i - 1) // 2:\n            if (N - i * (i - 1) // 2) / i == (N - i * (i - 1) // 2) // i:\n                ans += 1\n            i += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        counter = 0\n        n = 2\n        cnum = []\n\n        while n * (n + 1) / 2 <= N:\n            conditionNo = int(N - n * (n + 1) / 2)\n            if conditionNo % n == 0:\n                counter = counter + 1\n            n = n + 1\n        return counter+1", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        k = 1\n        num_ways = 0\n        floor = (N - k * (k - 1) // 2) // k\n        while floor > 0:\n            this_sum = (floor + k - 1) * (floor + k) // 2 - floor * (floor - 1) // 2\n            if this_sum == N:\n                num_ways += 1\n            k += 1\n            floor = (N - k * (k - 1) // 2) // k\n        return num_ways\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        cnt = 0\n        upper_limit = ceil((2*N + 1/4)**0.5 - 0.5 + 1)\n        for k in range(1, upper_limit):\n            x = (2*N - k**2 - k)/(2*k)\n            if int(x) == x and x >= 0:\n                cnt += 1\n        return cnt", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 1\n        L = 1\n        while( L * (L + 1) < 2 * N): \n            a = (1.0 * N - (L * (L + 1) ) / 2) / (L + 1) \n            if (a ==int(a) ): \n                count += 1\n            L += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        self.primes=[2,3,5,7,11]\n        self.get_primes(N)\n        # print(self.primes)\n        self.get_factors(2*N)\n        # print(self.factor_arr)\n        ans=0\n        for factor in self.factor_arr:\n            x=((2*N)/factor-factor-1)/2\n            # print(x)\n            if x<0:\n                continue#break\n            if x%1==0:\n                # print(x)\n                ans+=1\n        return ans\n            \n            \n        \n    \n    def get_factors(self,n):\n        self.factors={1: 1}\n        self.factor_arr=[1]\n        i=0\n        while(n>1 and i<len(self.primes)):\n            prime=self.primes[i]\n            pw=0\n            # print(n,prime)\n            while(n%prime==0):\n                n=n/prime\n                pw+=1\n            while(pw):\n                    length=len(self.factor_arr)\n                    for fi in range(length):\n                        nf=self.factor_arr[fi]*prime\n                        if nf not in self.factors:\n                            self.factors[nf]=1\n                            self.factor_arr+=[nf]\n                    pw-=1\n            # print(\\\"p-f_arr\\\",prime,self.factor_arr)\n            i+=1\n        if n>1:\n                length=len(self.factor_arr)\n                for i in range(length):\n                    nf=self.factor_arr[i]*n\n                    if nf not in self.factors:\n                        self.factors[nf]=1\n                        self.factor_arr+=[nf]\n        return\n                        \n                \n    def get_primes(self,n):\n        last_prime=self.primes[-1]\n        k=last_prime//6\n        adds=[1,5]\n        i=adds.index(last_prime%6)\n        i+=1\n        if i==2:\n                k+=1\n                i=0\n        num=6*k+adds[i]\n        \n        while(num*num<n):\n            if self.is_prime(num):\n                self.primes+=[num]\n            i=i+1\n            if i==2:\n                k+=1\n                i=0\n            num=6*k+adds[i]\n    \n    def is_prime(self,n):\n        for prime in self.primes:\n            if prime*prime>n:\n                break\n            if n%prime==0:\n                return False\n        return True", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        i = 1\n        while(i**2 + i <= 2*N ):\n            temp = N/i - (i-1)/2\n            if int(temp) == temp:\n                count += 1\n            i += 1\n        return count\n", "class Solution:\n    def formulaSum(self, N, L):\n        return N/L - (L+1)/2\n    \n    def consecutiveNumbersSum(self, N: int) -> int:\n        total = 0\n        L = 1\n        while L*(L+1)/2 <= N:\n            a = self.formulaSum(N, L)\n            if a - int(a) == 0.0:\n                total += 1\n            L += 1\n        return total", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count = 0\n        for i in range(1, int(math.sqrt(N))+1):\n            if N%i == 0:\n                if i%2:\n                    count += 1\n                if (N/i)%2 != 0 and N/i != i:\n                    count += 1\n        return count\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 0\n        n = 1\n        \n        while N > self.math(n):\n            if (N-self.math(n)) % n == 0:\n                res += 1\n            n += 1\n        \n        return res\n    \n    def math(self, n):\n        return (n-1)*n//2", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n#         if N == 1: \n#             return 1\n#         res = 1\n#         for i in range(2, floor(1 + N ** (0.5))):   \n#             if N % i == 0:\n#                 if i % 2 == 1: # If i is odd, then we can form a sum of length i\n#                     res += 1\n#                 j = (N // i) # Check the corresponding N // i\n#                 if i != j and j % 2 == 1:\n#                     res += 1\n#         if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\n#             res += 1\n        \n#         return res\n        \n\n    \n        def summer(x):\n            return x * (x - 1) / 2\n        count = 0\n        i = 1\n        \n        while summer(i) < N:\n            if ((N - summer(i)) %i == 0):\n                count += 1\n            i += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n#         if N == 1: \n#             return 1\n#         res = 1\n#         for i in range(2, floor(1 + N ** (0.5))):   \n#             if N % i == 0:\n#                 if i % 2 == 1: # If i is odd, then we can form a sum of length i\n#                     res += 1\n#                 j = (N // i) # Check the corresponding N // i\n#                 if i != j and j % 2 == 1:\n#                     res += 1\n#         if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\n#             res += 1\n        \n#         return res\n        \n#         if N == 1:\n#             return 1\n#         total = 1\n        \n#         start = 1\n#         end = 1\n        \n#         curr = 1\n#         while end <= ceil(N / 2):\n#             if curr == N:\n#                 total += 1\n#                 curr -= start\n#                 start += 1\n#             if curr < N:\n#                 end += 1\n#                 curr += end\n#             elif curr > N:\n#                 curr -= start\n#                 start += 1\n        \n#         return total\n    \n        def summer(x):\n            return x * (x - 1) / 2\n        count = 0\n        i = 1\n        \n        while summer(i) < N:\n            if ((N - summer(i)) %i == 0):\n                count += 1\n            i += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        #include itself\n        result = 0\n        \n        for i in range(0, N):\n            x = (N - i*(i+1)/2)/(i+1)\n            if x <= 0:\n                break\n            \n            if x%1 == 0:\n                result+=1\n            \n                \n        return result\n", "\n\nclass Solution:\n    # (x+x+m)*m/2 = N\n    def consecutiveNumbersSum(self, N: int) -> int:\n\n        count = 0\n\n        for i in range(1, int(math.sqrt(2*N))+1):\n\n            # temp = (N*2/i - i+1) / 2\n            temp = (2*N - i**2 + i)/2/i\n            if temp > 0 and temp == int(temp):\n                count += 1\n\n        return count\n\n", "# Idea1 - Brute force\n# - start going down from N\n# - ...\n# \n# Idea2 - Recursion\n# - start with N\n# - then find two consequetive number that add to N\n# - then try to break down each number\n# \n# - may not work; see Example 2 & 3\n# - need to find a way to divide (recursively or not) in different ways\n# \n# Idea3 - Lower (2) and upper (N-1?)?\n# - consider N combination as in\n#   - divide N by 2, by 3, ..., M then somehow adjust each number\n#     - whats the biggest number M can be\n# \n# Idea4\n\n\nclass Solution:\n    # def consecutiveNumbersSum(self, N: int) -> int:\n    #     ret = 1\n    #     m = 2\n    #     while (N/m - floor(m/2) > 0):\n    #         l = ceil(N/m) - floor(m/2)\n    #         cur = [l + i for i in range(m)]\n    #         print(cur)\n    #         if (sum(cur) == N):\n    #             ret += 1\n    #         m += 1\n    #     return ret\n    \n    def consecutiveNumbersSum(self, N: int) -> int:\n        def consum(p):\n            return p*(p+1)/2\n        \n        count = 0\n        i = 1\n        while consum(i) <= N:\n            if (N - consum(i)) % i == 0:\n                count += 1\n            i += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        i = 1\n        num_sums = 0\n        while (N//i - i//2 +(i%2==0)> 0):\n            first = N//i - i//2\n            if (i%2 == 0):\n                first += 1\n            last = N//i + i//2\n\n            s = (first + last)*i//2\n            \n            if (s == N):\n                num_sums += 1\n            \n            # print(\\\"{} - {} = {}\\\".format(first, last, s))\n            i += 1\n        return num_sums", "import math\n\nclass Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        i = 1\n        count = 0\n        while i < math.ceil((math.sqrt(1 + 8 * N) + 1) / 2):\n            if ((2 * N - i * i + i) % (2 * i) == 0):\n                # print(i)\n                count += 1\n            i += 1\n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        if N == 1: \n            return 1\n        res = 1\n        for i in range(2, floor(1 + N ** (0.5))):   \n            if N % i == 0:\n                if i % 2 == 1: # If i is odd, then we can form a sum of length i\n                    res += 1\n                j = (N // i) # Check the corresponding N // i\n                if i != j and j % 2 == 1:\n                    res += 1\n        if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\n            res += 1\n        \n        return res\n        \n#         if N == 1:\n#             return 1\n#         total = 1\n        \n#         start = 1\n#         end = 1\n        \n#         curr = 1\n#         while end <= ceil(N / 2):\n#             if curr == N:\n#                 total += 1\n#                 curr -= start\n#                 start += 1\n#             if curr < N:\n#                 end += 1\n#                 curr += end\n#             elif curr > N:\n#                 curr -= start\n#                 start += 1\n        \n#         return total\n                \n        \n", "\n\nclass Solution:\n    # (x+x+m)*m/2 = N\n    def consecutiveNumbersSum(self, N: int) -> int:\n\n        count = 0\n\n        for i in range(1, int(math.sqrt(2*N))+1):\n\n            # temp = (N*2/i - i+1) / 2\n            temp = (2*N - i**2 +i)/2/i\n            if temp > 0 and temp == int(temp):\n                count += 1\n\n        return count\n\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        # N = sum(x + (x + 1) + (x + 2) + ... + (x + n - 1))\n        # N = nx + n(n-1) / 2\n        # N - n(n-1) / 2 = nx\n        \n        n = 1\n        count = 0\n        while N > n * (n-1) // 2:\n            if (N - n * (n-1) // 2) % n == 0:\n                count += 1\n            n += 1\n            \n        return count", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        i, ans = 1, 0\n        while N > i * (i - 1) // 2:\n            if (N - i * (i - 1) // 2) % i == 0:\n                ans += 1\n            i += 1\n        return ans", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        count, i = 1, 2\n        while i < sqrt(2 * N):\n            if (N - (i ** 2 - i) / 2) % i == 0:\n                count += 1\n            i += 1\n        return count\n    \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        sol = 0\n        \n        m = 1\n        while( m * (m + 1) < 2 * N): \n            a = (1.0 * N - (m * (m + 1) ) / 2) / (m + 1) \n            if (a - int(a) == 0.0): \n               sol += 1\n            m += 1\n        return sol + 1\n      \n            \n            \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        def triangle(n):\n            return int(n * (n+1) / 2)\n\n        def consecutive_sums(k):\n            counter = 0\n            n = 1\n            while triangle(n) <= k:\n                if (k - triangle(n)) % n == 0:\n                    X = int((k - triangle(n)) // n)\n                    if n != 1:\n                        counter += 1\n                n += 1\n            return counter + 1\n        \n        return consecutive_sums(N)\n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        maxLen = int(((1+8*N)**0.5-1)/2)\n        nWays = 1           # at least 1 way: N = N\n        for n in range(2, maxLen+1):\n            nWays += (2*N+n-n**2)%(2*n) == 0\n        return nWays\n        \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        num_solutions = 0\n        for i in range(1,ceil(sqrt(2*N))):\n            if(N-(i*(i-1))/2)/i > 0 and  (N-(i*(i-1))/2)/i == floor((N-(i*(i-1))/2)/i):\n                print(i)\n                num_solutions += 1\n            \n        return num_solutions\n                \n        \n        \n       \n        \n        \n        \n", "class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        answer, k = 0, 1\n        while N - (k*(k-1)) // 2 > 0:\n             if  (N - (k*(k-1)) // 2) % k == 0:\n                     answer += 1\n             k += 1\n        return answer\n            \n"]
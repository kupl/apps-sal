["#THanks to easter eggs kata ;*\n\ndef height(n, m):\n    if n >= m:\n        return (2 ** (min(n, m)) - 1)\n    f = 1\n    res = 0\n    for i in range(n):\n        f = f * (m - i) // (i + 1)\n        res += f\n    return res\n\ndef solve(emulator):\n    m = emulator.drops\n    n = emulator.eggs\n    h = 0\n    tryh = 0\n    while n and m:\n        tryh = height(n - 1, m - 1) + 1\n        if emulator.drop(h + tryh):\n            n -= 1\n        else:\n            h += tryh\n        m -= 1\n    return(h + 1)\n    # continue here\n", "def solve(emulator):\n\n    def max_height(eggs, drops):\n        if eggs == 0 or drops == 0: return 0\n        return max_height(eggs - 1, drops - 1) + 1 + max_height(eggs, drops - 1)\n\n    low = 1\n    high = max_height(emulator.eggs, emulator.drops)\n    while low <= high:\n        n = min(low + max_height(emulator.eggs - 1, emulator.drops - 1), high)\n        if emulator.drop(n): high = n - 1\n        else: low = n + 1\n    return low\n", "def max_floor(eggs, drops):\n    return sum(max_floor(eggs-1, d) + 1 for d in range(drops)) if eggs else 0\n\ndef solve(emulator):\n    floor = 1\n    while emulator.eggs and emulator.drops:\n        while emulator.drops:\n            test = floor + max_floor(emulator.eggs-1, emulator.drops-1) + 1\n            if emulator.drop(test): break\n            floor = test\n    return floor+1\n", "def solve(emulator):\n    num_drops = emulator.drops\n    num_eggs = emulator.eggs\n    floor = 0\n\n    def height(eggs, drops):\n        max_floor = 0\n        if eggs <= 0: return 0\n        elif eggs == 1: return drops\n        else:\n            for x in range(1,drops+1):\n                max_floor += height(eggs - 1, drops - x) + 1\n            return max_floor\n\n    while num_drops and num_eggs:\n        temp = height(num_eggs - 1, num_drops -1) + 1\n        if not emulator.drop(floor + temp):\n            floor += temp\n            num_drops -= 1\n        else:\n            num_eggs -= 1\n            num_drops -= 1\n\n    return floor + 1", "def solve(emulator):\n    num_drops = emulator.drops\n    num_eggs = emulator.eggs\n    #generate table for max heights with certain numbers of eggs and drops\n    HEIGHTS = heights(num_eggs, num_drops)\n    return solve_part(emulator, 0, HEIGHTS[num_eggs][num_drops], HEIGHTS)+1\n    \n    \ndef solve_part(emulator, min_floor, max_floor, HEIGHTS):\n    #solve for the highest possible floor without breaking\n    if min_floor == max_floor:\n        return min_floor\n    else:\n        num_drops = emulator.drops\n        num_eggs = emulator.eggs\n        partition = HEIGHTS[num_eggs-1][num_drops-1]\n        partition_point = min_floor + partition + 1\n        if emulator.drop(partition_point):\n            return solve_part(emulator, min_floor, partition_point-1, HEIGHTS)\n        else:\n            return solve_part(emulator, partition_point, max_floor, HEIGHTS)\n        \ndef heights(n, m):\n    heights = [[0 for i in range(m+1)] for j in range(n+1)]\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            heights[i][j] = heights[i-1][j-1] + heights[i][j-1] + 1\n    return heights\n\n\n", "from functools import lru_cache\n\n@lru_cache(None)\ndef T(n,k):\n    return 0 if n==0 or k==0 else T(n-1,k-1)+1+T(n-1,k)\n\ndef solve(e):\n    d={0:False}\n    floormax=0\n    while e.eggs>0 and e.drops>0:\n        n=floormax+1+T(e.drops-1,e.eggs-1)\n        d[n]=t=e.drop(n)\n        if not t:floormax=n\n    return min([k for k,v in d.items() if v])", "flockhash={}\n\ndef solve(emulator):\n\n    num_drops = emulator.drops\n    num_eggs = emulator.eggs\n    \n    def climbing(eggs,drops):\n    \n        if eggs==1 : return 1\n        everest=flockhash.get((eggs,drops))\n        if everest!=None : return everest\n        everest=1\n        for kamikaze in range(1,drops):\n            everest+=climbing(eggs-1,drops-kamikaze) \n        flockhash[(eggs,drops)]=everest\n        return everest\n        \n    last_broken_egg=1\n    floor=1+climbing(num_eggs,num_drops)\n    exfloor=1\n    \n    while num_eggs and num_drops :\n        \n        if emulator.drop(floor) : \n            last_broken_egg=floor\n            num_eggs-=1\n            floor=exfloor\n        else:\n            exfloor=floor\n            \n        num_drops-=1\n        floor+=climbing(num_eggs,num_drops)\n    else:\n    \n        return last_broken_egg\n        \n        \n        \n        \n        \n        \n\n                \n\n", "#better solution exist?\nflockhash={}\n\ndef solve(emulator):\n\n    num_drops = emulator.drops\n    num_eggs = emulator.eggs\n    \n    def climbing(eggs,drops):\n    \n        if eggs==1 : return 1\n        everest=flockhash.get((eggs,drops))\n        if everest!=None : return everest\n        everest=1\n        for kamikaze in range(1,drops):\n            everest+=climbing(eggs-1,drops-kamikaze) \n        flockhash[(eggs,drops)]=everest\n        return everest\n        \n    last_broken_egg=1\n    floor=1+climbing(num_eggs,num_drops)\n    exfloor=1\n    \n    while num_eggs and num_drops :\n        \n        if emulator.drop(floor) : \n            last_broken_egg=floor\n            num_eggs-=1\n            #num_drops-=1\n            floor=exfloor#+climbing(num_eggs,num_drops)\n        else:\n            #num_drops-=1\n            exfloor=floor\n            #floor+=climbing(num_eggs,num_drops)\n            \n        num_drops-=1\n        floor+=climbing(num_eggs,num_drops)\n    else:\n    \n        return last_broken_egg\n        \n        \n        \n        \n        \n        \n\n                \n\n", "def solve(emulator):\n    print(\"Drops\")\n    print((emulator.drops))\n    num_drops = emulator.drops\n    print(\"Eggs\")\n    print((emulator.eggs))\n    num_eggs = emulator.eggs\n    currFloor = 0\n    broke = False\n    maxFloor = -1#initial state\n    minFloor = 0\n    #print(find_sum_to_current(num_drops))\n    print((next_jump(num_eggs + 1,num_drops + 1)))\n    \n    #make max floor based on eggs to the power of dropc count ( -1, -1)\n    #then do lion in desert based on the new range - calc is a little different, must think of cases where eggs always break\n    while emulator.drops > 0 and  emulator.eggs > 0:\n        if emulator.eggs == 1:         \n            currFloor += 1\n            print(currFloor)\n            broke = emulator.drop(currFloor)\n            if broke:\n                return currFloor\n            else:\n                minFloor = currFloor\n        elif emulator.eggs == 2:\n            currFloor += emulator.drops\n            print(currFloor)\n            broke = emulator.drop(currFloor)\n            if broke:\n                maxFloor = currFloor\n                #currFloor = maxFloor - emulator.drops * (emulator.eggs)\n                currFloor = minFloor #+ emulator.eggs\n            else:\n                minFloor = currFloor\n        else:\n            num_drops = emulator.drops\n            num_eggs = emulator.eggs\n            #currFloor += 1 + maxFindRange((num_eggs - 1,num_drops - 1)#maybe +1 \n            currFloor += next_jump(num_eggs, num_drops)\n            print((\"up  by: \" + str(next_jump(num_eggs,num_drops)) + \" eggs: \" + str(num_eggs) + \" drops: \" + str(num_drops)))\n            print(currFloor)\n            broke = emulator.drop(currFloor)\n            if broke:\n                maxFloor = currFloor\n                currFloor = minFloor #+ emulator.eggs\n            else:\n                minFloor = currFloor\n    return currFloor + 1\n    \n    \n\n    \n    \n#def maxFindRange(eggCount, dropCount):\n#    if eggCount >= dropCount:\n#        return dropCount#find_sum_to_current(dropCount)#dropCount + 1\n#    elif eggCount == 1:\n#        return dropCount\n#    elif eggCount == 2:\n#        return find_sum_to_current(dropCount)\n#    else:\n#        number = 0#maybe 0 or 1\n#        for i in range (1, dropCount + 1):\n#            #number += (eggCount - 2) * (find_sum_to_current(dropCount - i - 1) - 1)\n#            number += #1 + (eggCount - 2) * (find_sum_to_current(dropCount - i - 1))\n#            #solve for negative numbers\n#        return number + maxFindRange(eggCount - 1, dropCount - 1)\n#    #returns the highest amount that can be tested\n        \ndef find_sum_to_current(dropCount):\n    number = 0\n    for i in range (1, dropCount + 1):\n        number += i\n    return number\n    \ndef next_jump(num_egg, num_drop):\n    if num_egg == 1 or num_drop == 1:\n        return 1\n    else:\n        sum = 0\n        for i in range (0, num_drop):\n            sum += next_jump(num_egg - 1, i)\n        if(num_egg > 2):\n            sum+=1\n        return sum\n    \n    \n    # continue here\n", "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef highest_floor(eggs, drops):\n    \"\"\"Return the highest floor for the given numbers of eggs and drops\"\"\"\n    if eggs > drops:\n        eggs = drops\n    if eggs <= 1:\n        return drops if eggs == 1 else 0\n    return highest_floor(eggs-1, drops-1) + 1 + highest_floor(eggs, drops-1)\n\n\ndef solve(emulator):\n    \"\"\"Return the least floor for which the egg breaks\"\"\"\n    drops = emulator.drops\n    eggs = emulator.eggs\n\n    lower_bound, n = 0, 0\n    while drops > 0:\n        n = lower_bound + highest_floor(eggs-1, drops-1) + 1\n        drops -= 1\n        if emulator.drop(n): # it broke for floor n\n            eggs -= 1\n            if eggs == 0 or drops == 0:\n                return n\n        else:\n            lower_bound = n\n    return n + 1\n"]
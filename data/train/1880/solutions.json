["class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        cell = 0\n        for c in cells:\n            cell = (cell << 1) | c\n        seendict = {}\n        index = 0\n        while True:\n            # print([int(x) for x in '{0:08b}'.format(cell)])\n            if cell in seendict:\n                if (N - index) % (index - seendict[cell]) == 0:\n                    return [int(x) for x in '{0:08b}'.format(cell)]\n            seendict[cell] = index\n            not_cell = (cell ^ 255) \n            cell = ((cell << 1) & (cell >> 1)) | ((not_cell << 1) & (not_cell >> 1))\n            index += 1", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n\n        seen = dict()\n        is_fast_forwarded = False\n\n        # step 1). convert the cells to bitmap\n        state_bitmap = 0x0\n        for cell in cells:\n            state_bitmap <<= 1\n            state_bitmap = (state_bitmap | cell)\n\n        # step 2). run the simulation with hashmap\n        while N > 0:\n            if not is_fast_forwarded:\n                if state_bitmap in seen:\n                    # the length of the cycle is seen[state_key] - N \n                    N %= seen[state_bitmap] - N\n                    is_fast_forwarded = True\n                else:\n                    seen[state_bitmap] = N\n            # if there is still some steps remained,\n            #   with or without the fast-forwarding.\n            if N > 0:\n                N -= 1\n                state_bitmap = self.nextDay(state_bitmap)\n\n        # step 3). convert the bitmap back to the state cells\n        ret = []\n        for i in range(len(cells)):\n            ret.append(state_bitmap & 0x1)\n            state_bitmap = state_bitmap >> 1\n\n        return reversed(ret)\n\n\n    def nextDay(self, state_bitmap: int):\n        state_bitmap = ~ (state_bitmap << 1) ^ (state_bitmap >> 1)\n        state_bitmap = state_bitmap & 0x7e  # set head and tail to zero\n        return state_bitmap", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        def nextDay(cells):\n            ans = [0] #start\n            for i in range(1, len(cells) - 1):\n                ans.append(int(cells[i - 1] == cells[i + 1]))\n            ans.append(0)\n            return ans\n        \n        seen = {}\n        forwarded = False\n        \n        while N > 0: # when there is loop left\n            if not forwarded: # if cycle hasn't been detected\n                snapshot = tuple(cells)\n                if snapshot in seen: # detected cycle\n                    N %= seen[snapshot] - N # length of cycle\n                    forwarded = True\n                else:\n                    seen[snapshot] = N\n            if N > 0: # update snapshot to next day's\n                N -= 1\n                cells = nextDay(cells)\n        return cells\n        \n    # Given K number of cells, there could be at most 2**K possible states. If the number of steps is larger than all possible states (N > 2 ** K), we are destined to repeat ourselves sooner or later.\n", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        \n        \n        def transform(cells): \n            nxtCells = [0]*len(cells)\n            for i in range(1, len(cells)-1): \n                nxtCells[i] = 1 if cells[i-1] == cells[i+1] else 0\n            return nxtCells\n        \n        day = 0 \n        while N>0: \n            cells = transform(cells)\n            day += 1\n            N -= 1\n            if day == 1: \n                origin = [i for i in cells]\n            elif cells == origin: \n                # print(day, N, cells)\n                N %= day-1\n                # print(day, N, cells)\n            \n            # print(N, cells)\n                \n        \n        return cells ", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        visited = {str(cells) : N}\n        \n        cycle = 0\n        hascycle = False\n        \n        def get_next(cells) -> List[int]:\n            '''return next cell'''\n            tmp = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in range(1,7)] + [0]\n            return tmp\n            \n        \n        while N > 0:\n            visited[str(cells)] = N\n            \n            N -= 1\n            cells = get_next(cells.copy())\n            if str(cells) in visited:\n                hascycle = True\n                cycle = visited[str(cells)] - N \n                break\n            \n            \n        if hascycle:\n            N = N % cycle\n            while N > 0:\n                N -= 1\n                cells = get_next(cells)\n            \n        return cells", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        \n        \n        if not cells:return cells\n        #brute force can be optimized by finding number count aftwer which the pattern \n        #repeats. So take first day and change according to rules and update counter\n        #when new updated cell matches the one u started with ,get the counter\n        #this is number after which pattern repeats\n        #now we can simply fast forward \n        \n        day1=self.nextDay(cells)\n        cells=day1.copy()\n        count=0\n        N-=1\n        \n        while N>0:\n            each_day=self.nextDay(cells)\n            count+=1\n            N-=1\n            \n            if each_day==day1:\n                N=N%count\n            cells=each_day\n        return cells\n           \n                \n    def nextDay(self,cells):\n        ret=[0]\n        for i in range(1,len(cells)-1):\n            ret.append(int(cells[i-1]==cells[i+1]))\n        ret.append(0)\n        return ret\n         \n            \n            \n        return cells\n                        \n            \n           \n    \n            \n#         dp=cells.copy()\n#         for i in range(N):\n#             for j in range(8):\n#                 if j==0:\n#                     if dp[j]==1:cells[j]=0\n#                 elif j==7 :\n#                     if dp[j]==1:cells[j]=0\n#                 else:\n#                     if dp[j-1]^dp[j+1]==0:\n#                         cells[j]=1\n#                     else:\n#                         cells[j]=0\n                        \n                        \n#             dp=cells.copy()\n                \n#         return cells\n", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        for i in range((N - 1) % 14 + 1):\n            cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0]\n        return cells", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        prison_size = len(cells)\n        seen = {}\n        seen[str(cells)] = 0\n        history = [cells]\n        \n        \n        for d in range(1,N+1):\n            ans = [0] * prison_size\n            for i in range(1,7):\n                ans[i] = 1 if cells[i-1] == cells[i+1] else 0\n            \n            if str(ans) in seen:\n                cycle_length = d - seen[str(ans)]\n                return history[seen[str(ans)] + (N-d)%cycle_length]\n            else:\n                history.append(ans)\n                seen[str(ans)] = d\n            cells = ans\n        \n        \n        return cells", "class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        def next(state):\n            return tuple(1 if i>0 and i <len(state)-1 and state[i-1] == state[i+1] else 0 for i in range(len(state)))\n        \n        seen = {}\n        state = tuple(cells)\n        \n        i = 0\n        remaining = 0\n        while i < N:\n            if state in seen:\n                cycle = i - seen[state]\n                remaining = (N-i)%cycle\n                break\n            seen[state] = i \n            state = next(state)\n            i+=1\n            \n        while remaining > 0:\n            state = next(state)\n            remaining -= 1\n                \n        return state ", "class Solution:\n    # 1,2,3,4,2,3,4,2,3,4,2  N = 11\n    # groupSize\n    # 0 1 2 3 4 5 6 7 8 9 0\n    # x = 4 pos = 1\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        iterations = {}\n        x = 0\n        lastGroup = False\n        while x < N:\n            iteration = tuple(cells)\n            if not lastGroup:\n                if iteration in iterations:\n                    print ('first',x, iteration)\n                    lastGroup = True\n                    pos = iterations[iteration]\n                    #we found a cycle\n                    groupSize = x-pos\n                    print ('groupSize',groupSize )\n                    groups = (N-pos)//groupSize\n                    x = pos + groups*groupSize \n                    if x == N:\n                        break\n                    print (\\\"**\\\",x)\n                else:\n                    print(x, iteration)\n                    iterations[iteration] = x\n            #curr = cells.copy()\n            prev = cells[0]\n            if x ==0:\n                cells[0]=0\n            for i in range (1,len(cells)-1):\n                if prev == cells[i+1]:\n                    prev = cells[i]\n                    cells[i] =1\n                else:\n                    prev = cells[i]\n                    cells[i]=0\n                    \n            if x == 0:\n                cells[-1]=0\n            # increment x\n            x+= 1\n            #curr = cells.copy()\n        return cells\n                    \n        ", "from queue import deque\nfrom collections import defaultdict\nclass Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        \n        def next_day(c)->List[int]:\n            res=[0]*8\n            for i in range(1,7):\n                if c[i-1]==c[i+1]:res[i]=1\n                else:res[i]=0\n            return res\n        \n        def period(c)->int:\n            if c[0]!=0 or c[-1]!=0: return 0\n            temp=c\n            for day in range(1,2**6+1):\n                if day==2**6: return 0\n                temp=next_day(temp)\n                if temp==c:return day\n        \n                \n        temp=cells\n        \n        for day in range(1,N+1):\n            temp=next_day(temp)\n            if period(temp):break\n        \n        N=(N-day)%period(temp)\n        for day in range(1,N+1):\n            temp=next_day(temp)\n        \n        \n        \n        return temp", "# class Solution:\n#     def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n#         n = N\n#         currCells = cells[:]\n#         while n > 0:\n#             for i in range(len(cells)):\n#                 if i == 0 or i == len(cells)-1:\n#                     currCells[i] = 0\n#                 elif cells[i-1] == cells[i+1]:\n#                     currCells[i] = 1\n#                 else:\n#                     currCells[i] = 0\n#             cells = currCells[:]\n#             n -= 1\n#         return cells\n\nclass Solution:\n    def prisonAfterNDays(self, cells, N):\n        \n        seen = {}\n        while N:\n            seen.setdefault(str(cells), N)\n            print(seen)\n            N -= 1\n            cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0]\n            if str(cells) in seen:\n                N %= seen[str(cells)] - N\n        return cells"]
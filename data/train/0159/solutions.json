["from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        N, queue = len(nums), deque()\n        dp = [val for val in nums]\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n                queue.popleft()\n            if queue and dp[queue[0]] > 0:\n                dp[i] += dp[queue[0]]\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return max(dp)", "from collections import deque\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = nums.copy()\n        ans = dp[0]\n\n        monoq = deque()\n        qsize = 0\n        \n        for i, num in enumerate(nums):\n            if i > 0:   \n                dp[i] = max(dp[i], num + monoq[0][0])\n            ans = max(ans, dp[i])\n            \n            pops = 1\n            while monoq and dp[i] > monoq[-1][0]:\n                _, freq = monoq.pop()\n                pops += freq\n                qsize -= freq\n            monoq.append([dp[i], pops])\n            qsize += pops\n\n            while qsize > k:\n                extra = qsize - k\n                if monoq[0][1] > extra:\n                    monoq[0][1] -= extra\n                    qsize = k\n                else:\n                    _, v = monoq.popleft()\n                    qsize -= v\n            \n        return ans\n", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = []\n        dp.append(nums[0])\n        deq = deque()\n        deq.append(0)\n        for i in range(1, len(nums)):\n            while len(deq) and (i - deq[0]) > k:\n                deq.popleft()\n            cur_max = dp[deq[0]] if len(deq) and dp[deq[0]] > 0 else 0\n            dp.append(cur_max + nums[i])\n            while len(deq) and dp[deq[-1]] < dp[i]:\n                deq.pop()\n            deq.append(i)\n        return max(dp)", "from heapq import heappop\nfrom heapq import heappush\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        # -val, val, idx\n        heap = []\n        ans = -10001\n        for i, num in enumerate(nums):\n            while len(heap) > 0:\n                _, val, idx = heap[0]\n                if idx < i - k: # out of constraint\n                    heappop(heap)\n                else:\n                    new_val = max(num, val + num)\n                    ans = max(ans, new_val)\n                    heappush(heap, (-new_val, new_val, i))\n                    break\n                    \n            if len(heap) == 0:  # no valid previous item\n                ans = max(ans, num)\n                heappush(heap, (-num, num, i))\n        return ans\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n=len(nums)\n        dp=[-sys.maxsize]*n\n        dq=[]\n        dp[n-1]=nums[n-1]\n        res=dp[n-1]\n        for i in range(n-2,-1,-1):\n            while(len(dq)!=0 and dp[i+1]>dp[dq[-1]]):\n                dq.pop()\n            while(len(dq)!=0 and dq[0]>i+k):\n                dq.pop(0)\n            dq.append(i+1)\n            dp[i]=max(dp[i],nums[i],nums[i]+dp[dq[0]])\n            res=max(res,dp[i])\n            \n            \n        return res\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        withAdding = [0 for _ in range(len(nums))]\n        notAdding = [-1 for _ in range(len(nums))]\n        \n        validMax = [nums[0]]\n        maxValue = nums[0]\n        withAdding[0] = nums[0]\n        \n        for i in range(1, len(nums)):\n            if maxValue < 0 and nums[i] > maxValue:\n                withAdding[i] = nums[i]\n            else:\n                withAdding[i] = maxValue + nums[i]\n            \n            validMax.append(withAdding[i])\n            maxValue = max(withAdding[i], maxValue)\n            if len(validMax) > k and validMax.pop(0) == maxValue:\n                maxValue = max(validMax)\n                \n            notAdding[i] = max(notAdding[i - 1], withAdding[i - 1])\n            \n            \n        return max(max(notAdding), max(withAdding))\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        memo=[nums[0]]\n        if not nums:\n            return 0\n        m=nums[0]\n        for i in range(1,k):\n            memo.append(nums[i]+max(0,m))\n            if memo[-1]>m:\n                m=memo[-1]\n        import copy\n        window=copy.deepcopy(memo)\n        #m=max(window)\n        for i in range(k,len(nums)):\n            #print(m,memo,window)\n            memo.append(nums[i]+max(0,m))\n            window.append(memo[-1])\n            p=window.pop(0)\n            if memo[-1]>m:\n                m=memo[-1]\n            elif p==m:\n                m=max(window)\n        return max(memo)", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        N, queue = len(nums), deque()\n        dp = [0] * N\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n            #if i > k and (queue[0] == i - k - 1):\n                queue.popleft()\n            #dp[i] = (val + max(dp[queue[0]], 0)) if queue else val\n            if queue and dp[queue[0]] > 0:\n                dp[i] = val + dp[queue[0]]\n            else:\n                dp[i] = val\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return max(dp)\n        \nfrom collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        if not nums or not k: return 0\n        if max(nums) <= 0: return max(nums)\n        if min(nums) >= 0: return sum(nums)\n        queue, N = deque(), len(nums)\n        for i in range(N):\n            #if queue and (i - queue[0] > k):\n            while queue and queue[0] < i - k:\n                queue.popleft()\n            # compute the max sum we can get at index i\n            if queue:\n                nums[i] += nums[queue[0]]\n            # delet all the sequence that smaller than current sum, becaus there will never be\n            # considers ==> smaller than current sequence, and end before current sequence\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            # if nums[i] < 0, it can't be a useful prefix sum\n            if nums[i] > 0:\n                queue.append(i)\n        return max(nums)", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        if max(nums) <= 0: return max(nums)   # optimization\n        if min(nums) >= 0: return sum(nums)   # optimization\n    \n        N, queue = len(nums), deque()\n        dp = [val for val in nums]\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n                queue.popleft()\n            if queue and dp[queue[0]] > 0:\n                dp[i] += dp[queue[0]]\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return max(dp)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp=[nums[0]]\n        decrease=collections.deque([0])\n        for i,num in enumerate(nums[1:],1):\n            if decrease and i-decrease[0]>k:\n                decrease.popleft()\n            val=max(num,dp[decrease[0]]+num)\n            dp.append(val)\n            while decrease and dp[decrease[-1]]<=val:\n                decrease.pop()\n            decrease.append(i)\n            \n        return max(dp)", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        if max(nums) <= 0: return max(nums)   # optimization\n        if min(nums) >= 0: return sum(nums)   # optimization\n    \n        N, queue = len(nums), deque()\n        dp = [val for val in nums]\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n                queue.popleft()\n            if queue and dp[queue[0]] > 0:\n                dp[i] += dp[queue[0]]\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return dp[queue[0]]", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        _max = collections.deque()\n        res = max(nums)\n        \n        for i in range(n):\n            if len(_max) and _max[0][0] > 0:\n                val = nums[i] + _max[0][0]\n            else:\n                val = nums[i]\n            while len(_max) and _max[-1][0] < val: _max.pop()\n            _max.append((val, i))\n            res = max(val, res)\n        \n            if _max[0][1] <= i-k:\n                _max.popleft()\n    \n        return res\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        maxNum = nums[0]\n        maxSum = nums[0]\n        maxNegSum = 0\n        curNegWindowSum = 0\n        curWindowSum = 0\n        rightIndex = 0 \n        leftIndex = 0\n        midIndex = 0\n        negativeStreak = False\n        \n        while rightIndex < len(nums):\n            if maxNum < nums[rightIndex]:\n                maxNum = nums[rightIndex]\n                \n            if nums[rightIndex] >= 0 and not negativeStreak: \n                curWindowSum += nums[rightIndex]\n                maxSum = max(maxSum, curWindowSum)\n            elif nums[rightIndex] < 0 and not negativeStreak:\n                negativeStreak = True\n                midIndex = rightIndex\n                if k > 1:\n                    curNegWindowSum = nums[rightIndex]\n                    maxNegSum = curNegWindowSum\n                curWindowSum += nums[rightIndex]\n            elif nums[rightIndex] < 0 and negativeStreak:\n                if rightIndex - midIndex < k - 1:\n                    curNegWindowSum += nums[rightIndex]\n                    maxNegSum = curNegWindowSum\n                else:\n                    if k > 1:\n                        curNegWindowSum -= nums[midIndex]\n                        curNegWindowSum += nums[rightIndex]\n                    maxNegSum = min(maxNegSum, curNegWindowSum)\n                    midIndex += 1\n                curWindowSum += nums[rightIndex]\n            elif nums[rightIndex] >= 0 and negativeStreak:\n                curWindowSum -= maxNegSum\n                if curWindowSum <= 0:\n                    midIndex = rightIndex\n                    leftIndex = rightIndex\n                    curWindowSum = nums[rightIndex]\n                else:\n                    curWindowSum += nums[rightIndex]\n                maxSum = max(maxSum, curWindowSum)\n                maxNegSum = 0\n                curNegWindowSum = 0\n                negativeStreak = False\n            \n            rightIndex += 1\n        return max(maxSum, maxNum)\n            \n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = [nums[0]]\n        decrease = collections.deque([0])\n        for i, x in enumerate(nums[1:], 1):\n            if decrease[0] == i-k-1:\n                decrease.popleft()\n            tmp = max(x, dp[decrease[0]] + x)\n            dp += [tmp]\n            while decrease and dp[decrease[-1]] <= tmp:\n                decrease.pop()\n            decrease += [i]            \n        return max(dp)  ", "class Solution:\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\n        deque = collections.deque()\n        for i in range(len(A)):\n            A[i] += deque[0] if deque else 0\n            while len(deque) and A[i] > deque[-1]:\n                deque.pop()\n            if A[i] > 0:\n                deque.append(A[i])\n            if i >= k and deque and deque[0] == A[i-k]:\n                deque.popleft()\n        \n        return max(A)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q_max, ans = deque([(nums[0],0)]), nums[0]\n        for i in range(1,len(nums)):\n            nums[i] += max(q_max[0][0],0)\n            if q_max[0][1] <= i-k:\n                q_max.popleft()\n            while q_max and nums[i] > q_max[-1][0]:\n                q_max.pop()\n            q_max.append((nums[i],i))\n            ans = max(ans, nums[i])\n        return ans\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dq=collections.deque()\n        \n        m=-sys.maxsize\n        for i,n in enumerate(nums):\n            fi = n\n            \n            if dq:\n                fi += max(dq[0][1], 0)\n            while dq and fi>=dq[-1][1]:\n                dq.pop()\n                \n            dq.append([i,fi])\n            \n            if i-dq[0][0]==k:\n                dq.popleft()\n                \n            if fi>m:\n                m=fi\n                \n        return m\n            \n            \n        \n        \n", "class Solution:\n    def constrainedSubsetSum(self, nums, k):\n        n = len(nums)\n        dp = [0] * n\n        deq = deque([0])\n        for i in range(n):\n            if deq and deq[0] < i - k:\n                deq.popleft()\n            while deq and nums[i] + dp[deq[0]] > dp[deq[-1]]:\n                a = deq.pop()\n            dp[i] = max(nums[i],nums[i] + dp[deq[0]] if deq else nums[i] + dp[a])\n            deq.append(i)\n\n        return max(dp)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q = deque([0])\n        ans = nums[0]\n        for i in range(1, len(nums)):\n            nums[i] += max(nums[q[0]], 0)\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            if i - q[0] == k:\n                q.popleft()\n            \n            ans = max(ans, nums[i])\n                \n        return ans", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp, q = [nums[0]], deque()\n        q.append((0,nums[0]))\n        res = nums[0]\n        for i in range(1, len(nums)):\n            while q and i - q[0][0] >k:\n                q.popleft()\n            cur = nums[i]\n            if q:\n                cur +=max(q[0][1],0)\n            while q and q[-1][1] < cur:\n                q.pop()\n            q.append((i,cur))\n            dp.append(cur)\n            res = max(res,cur)\n        return res\n            \n        \n\n", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\n        d = deque()\n        for i in range(len(A)):\n            A[i] += d[0] if d else 0\n            while d and d[-1] < A[i]:\n                d.pop()\n            if A[i] > 0:\n                d.append(A[i])\n            if i >= k and d and d[0] == A[i - k]:\n                d.popleft()\n        return max(A)", "from collections import deque\n'''\nWe need to figure out basically for k numbers remaining what is the largest sum, assuming that the first of those is selected.\n'''\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        numLength = len(nums)\n        maxSums = defaultdict(int)\n        maxSum = nums[0]##as that is definitely a lower bound on the maxSum, as that is obviously a possible sum. Be careful when you initialize mins and maxs\n        maxQueue = deque([0])##this will be used to compute the list of values of the maxSum for the previousk indices.\n        for i in range(numLength-1,-1,-1):\n            ithMax = max(nums[i],maxQueue[0]+nums[i])##be careful of index name.\n            maxSums[i] = ithMax\n            ##print(\\\"Max Queue before popping: \\\",maxQueue)\n            if len(maxQueue) == k:##be careful of variables\n                if maxSums[i+k] == maxQueue[0]:\n                    maxQueue.popleft()##this is needed to ensure that we don't have values that have expired.\n            while maxQueue and ithMax > maxQueue[-1]:##be sure of spelling and using right variables\n                maxQueue.pop()\n            maxQueue.append(ithMax)\n            ##print(\\\"Max Queue after popping: \\\",maxQueue)\n            maxSum = max(ithMax,maxSum)\n        return maxSum", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n\n        dp = collections.deque([(nums[0], 0)])\n        ans = nums[0]\n        \n        for i in range(1, len(nums)):\n    \n            new = nums[i] + max(0,dp[0][0])\n            \n            while dp and dp[0][1] <= i-k:\n                dp.popleft()            \n            \n            while dp and new >= dp[-1][0]:\n                dp.pop()\n            \n            dp.append((new, i))\n            \n            ans = max(ans, new)\n    \n        return ans\n", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        if max(nums) <= 0: return max(nums)\n        if min(nums) >= 0: return sum(nums)\n\n        queue, N = deque(), len(nums)\n        for i in range(N):\n            while queue and queue[0] < i - k:\n                queue.popleft()\n            if queue:\n                nums[i] += nums[queue[0]]\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            if nums[i] > 0:\n                queue.append(i)\n        return max(nums)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n= len(nums)\n        dp = [0]*n\n        q = deque()\n        ans = float('-inf')\n        for i in range(n):\n            if i>k and q[0]==i-k-1:\n                q.popleft()\n            dp[i]= (0 if len(q)==0 else max(dp[q[0]],0)) + nums[i]\n            while len(q)>0 and dp[i]>=dp[q[-1]]:\n                q.pop()\n            q.append(i)\n            ans = max(ans, dp[i])\n        return ans", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        # dp[i] = nums[i] + max(dp[j] j - i <= k)\n        # max(dp)\n        n = len(nums)\n        from collections import deque\n        q = deque()\n        q.append((nums[-1], n-1))\n        ans = nums[-1]\n        for i in reversed(list(range(n-1))):\n            while q and q[0][1] - i > k:\n                q.popleft()\n            dp = nums[i]\n            if q:\n                dp = max(dp, nums[i] + q[0][0])\n            ans = max(dp, ans)\n            while q and q[-1][0] <= dp:\n                q.pop()\n            q.append((dp, i))\n        return ans\n        \n", "from collections import deque\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        \n        n = len(nums)\n        queue = deque()\n        res = float('-inf')\n        \n        for i in range(n):\n            \n            if queue and i - queue[0][1] > k:\n                queue.popleft()\n            \n            cur = nums[i] + max(0, (queue[0][0] if queue else 0))\n            res = max(res, cur)\n            \n            while queue and queue[-1][0] <= cur:\n                queue.pop()\n            queue.append((cur, i))\n                \n        return res\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q = []\n        res = float('-inf')\n        for i in range(len(nums)):\n            while q and i-q[0][0] > k:\n                q.pop(0)\n            temp = nums[i]\n            if q and q[0][1] > 0:\n                temp += q[0][1]\n            res = max(res, temp)\n            while q and q[-1][1] <= temp:\n                q.pop()\n            q.append((i, temp))\n        return res", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        N = len(nums)\n        dp = [-math.inf] * N\n        \n        q = deque()   #. Val, Index\n        for i in range(N):\n            dp[i] = max(dp[i], nums[i] + (q[0][0] if q else 0), nums[i] )\n            \n            while q and dp[i] > q[-1][0]:\n                q.pop()\n            while q and i - q[0][1] >= k:\n                q.popleft()\n            q.append((dp[i], i))\n        \n        # print(dp)\n        return max(dp)\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        deq = deque()\n        for index, val in enumerate(nums):\n            nums[index] += deq[0] if deq else 0\n            while deq and nums[index]> deq[-1]:\n                deq.pop()\n            if nums[index]>0:\n                deq.append(nums[index])\n            if index>=k and deq and deq[0] == nums[index-k]:\n                deq.popleft()\n        return max(nums)\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] *n\n        dp[0] = nums[0]\n        heap = []\n        heappush(heap, (- nums[0], 0))\n        for i in range(1, n):\n            while heap[0][1] < i - k:\n                heappop(heap)\n            cur = heap[0][0]\n            \n            dp[i] = nums[i] + max(- cur, 0)\n            heappush(heap, (- dp[i], i))\n        #print(dp)\n        return max(dp)\n                    \n", "class Solution:\n        def constrainedSubsetSum(self, A, k):\n            deque = collections.deque()\n            for i in range(len(A)):\n                A[i] += deque[0] if deque else 0\n                while len(deque) and deque[-1] < A[i]:\n                    deque.pop()\n                if A[i] > 0:\n                    deque.append(A[i])\n                if i >= k and deque and deque[0] == A[i - k]:\n                    deque.popleft()\n            return max(A)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [-(math.inf) for i in range(n)]\n        dp[0] = nums[0]\n        ans = [nums[0]]\n        queue = [0]\n        for i in range(1,n):\n            dp[i] = max(dp[i], nums[i], nums[i]+ans[i-1])\n            if len(queue) == 0:\n                queue.append(i)\n            else:\n                while len(queue) > 0 and  ((dp[i] > dp[queue[-1]]) or (i - queue[0]) >= k):\n                    if dp[i] > dp[queue[-1]]:\n                        queue.pop(-1)\n                    else:\n                        queue.pop(0)\n                queue.append(i)\n            ans.append(dp[queue[0]])\n        # print(ans)\n        # print(dp)\n        return (max(dp))\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        stack = deque()\n        \n        for i in range(len(nums)):\n            nums[i] += stack[0] if stack else 0\n            while stack and stack[-1] < nums[i]:\n                stack.pop()\n            if i >= k and stack and stack[0] == nums[i-k]:\n                stack.popleft()\n            if nums[i] > 0:\n                stack.append(nums[i])\n        return max(nums)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        q = deque()\n        for i in range(len(nums)):\n            nums[i] += q[0] if q else 0\n            while q and nums[i] > q[-1]:\n                q.pop()\n            if nums[i] > 0:\n                q.append(nums[i])\n            if i >= k and q and q[0] == nums[i-k]:\n                q.popleft()\n        return max(nums)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        #\u7528\u6765\u4fdd\u7559k\u6b65\u5185\u7684\u7d2f\u52a0\u6700\u5927\u503c\n        deque = collections.deque()\n        for i in range(len(nums)):\n            if deque:\n               nums[i] += deque[0]\n            \n            while deque and nums[i] > deque[-1]:\n                deque.pop()\n            \n            if nums[i] > 0:\n                deque.append(nums[i])\n            #\u53bb\u9664\u8d85\u8fc7k\u6b65\u7684\u6700\u5927\u503c\uff0c\u4e3a\u4e0b\u4e00\u6b65\u8981\u52a0\u7684\u7684\u6700\u5927\u503c\u505a\u51c6\u5907\n            if i >= k and deque and deque[0] == nums[i - k]:\n                deque.popleft()\n            \n        return max(nums)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        res = -sys.maxsize\n        \n        n = len(nums)\n        dp = [0]*(n+1)\n        dq = collections.deque()\n        \n        for i in range(n):\n            if not dq:\n                dp[i+1] = nums[i]\n            else:\n                dp[i+1] = max(nums[i], dq[0] + nums[i])\n            dq.append(dp[i+1])\n            while len(dq) > k:\n                dq.popleft()\n            while len(dq) > 1 and dq[0] <= dq[-1]:\n                dq.popleft()\n            \n            res = max(res, dp[i+1])\n        \n        return res", "from typing import List\nimport collections\n\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        \n        maxx = list(nums)\n        deque = collections.deque()\n        for i in range(len(nums)):\n            if deque:\n                maxx[i] += deque[0]\n            while deque and maxx[i] > deque[-1]:\n                deque.pop()\n            if maxx[i] > 0:\n                deque.append(maxx[i])\n            if i >= k and deque and deque[0] == maxx[i - k]:\n                deque.popleft()\n        return max(maxx)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        rec = -nums[0]\n        heap = [(-nums[0], 0)]\n        for j, n in enumerate(nums[1:]):\n            while j+1-heap[0][1] > k:\n                heapq.heappop(heap)\n            cand = -n + heap[0][0] if heap[0][0] <= 0 else -n\n            rec = min(rec, cand)\n            heapq.heappush(heap, (cand, j+1))\n        return -rec", "class MonoQ:\n    def __init__(self,k):\n        self.k = k\n        self.m = []\n        \n    def add(self,a,solution):\n        while len(self.m) > 0:\n            if solution[a] > solution[self.m[-1]]:\n                self.m.pop()\n            else:\n                break\n        self.m.append(a)\n    \n    def grab(self, a, solution, nums):\n        if len(self.m) > 0:\n            if self.m[0] > a+self.k:\n                self.m = self.m[1:]\n            return max(nums[a],nums[a]+solution[self.m[0]])\n        else:\n            return nums[a]\n        \nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        solution = [0]*n\n        m = MonoQ(k)\n    \n        for i in range(n-1,-1,-1):\n            solution[i] = m.grab(i,solution,nums)\n            m.add(i,solution)\n\n        return max(solution)\n    \n    \n", "import heapq\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        heap = []\n        n = len(nums)\n        dp = [None] * n \n        for i in range(n):\n            best = None\n            while len(heap) > 0:\n                val, idx = heap[0]\n                val *= (-1)\n\n                if i - idx <= k:\n                    best = val\n                    break\n                    \n                heapq.heappop(heap)\n\n            dp[i] = nums[i]\n            if best is not None and dp[i] < best + nums[i]:\n                dp[i] = best + nums[i]\n                \n            #print(dp)\n\n            heapq.heappush(heap, (-dp[i], i))\n        return max(dp)", "from heapq import heappush, heappop\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        # [-max_sum, idx]\n        \n        res = -float('inf')\n        queue = []\n        for i, x in enumerate(nums):\n            while queue and queue[0][1] < i - k:\n                heappop(queue)\n                \n            if queue:\n                y = x - queue[0][0]\n            else:\n                y = x\n            \n            res = max(res, y)\n            if y > 0:\n                heappush(queue, [-y, i])\n                \n        return res", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        max_queue = collections.deque([0,])\n        max_sum = nums[0]\n        for i in range(1, len(nums)):   \n            while max(0,i-k)>max_queue[0]:\n                max_queue.popleft()\n            nums[i] += max(0, nums[max_queue[0]])\n            max_sum = max(max_sum, nums[i])\n            while max_queue and nums[max_queue[-1]]<nums[i]:\n                max_queue.pop()\n            max_queue.append(i)\n\n        return max_sum\n", "from heapq import heappush, heappop\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        res = -float('inf')\n        queue = list()\n        for i, x in enumerate(nums):\n            while queue and queue[0][1] < i - k:\n                heappop(queue)\n            if queue:\n                val, idx = queue[0]\n                if val < 0:\n                    x -= val\n            heappush(queue, [-x, i])\n            res = max(res, x)\n        return res\n", "import collections\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        # Like jump game \n        # At nums[i], add the max of [num[i-k], ... num[i-1], 0]\n        # this can be done by deque with max k\n        \n        sol = -float('inf')\n        n = len(nums)\n        maxque = collections.deque([(-1,0)])\n        for i in range(n):\n            max_i = max(maxque[0][1],0) + nums[i]\n            sol = max(sol, max_i)\n            while maxque:\n                if maxque[-1][1] < max_i:\n                    maxque.pop()\n                else:\n                    break\n            maxque.append((i,max_i))\n            if maxque[0][0] <= i-k:\n                maxque.popleft()\n        return sol\n        \n        \n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = [n for n in nums]\n        heap = [(-nums[0], 0)]\n        for j in range(1, len(nums)):\n            while heap[0][1] < j - k:\n                heapq.heappop(heap)\n            dp[j] = max(dp[j], -heap[0][0] + nums[j])\n            heapq.heappush(heap, (-dp[j], j))\n        return max(dp)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n=len(nums)\n        dp=[-sys.maxsize]*n\n        dq=collections.deque([])\n        dp[n-1]=nums[n-1]\n        res=dp[n-1]\n        for i in range(n-2,-1,-1):\n            while(len(dq)!=0 and dp[i+1]>dp[dq[-1]]):\n                dq.pop()\n            while(len(dq)!=0 and dq[0]>i+k):\n                dq.popleft()\n            dq.append(i+1)\n            dp[i]=max(dp[i],nums[i],nums[i]+dp[dq[0]])\n            res=max(res,dp[i])\n            \n            \n        return res\n", "class Solution:\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\n        d = collections.deque()\n        for i in range(len(A)):\n            A[i] += d[0] if d else 0\n            while d and A[i] > d[-1]:\n                d.pop()\n            if A[i] > 0:\n                d.append(A[i])\n            if i >= k and d and d[0] == A[i-k]:\n                d.popleft()\n        return max(A)\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        pq = [(-nums[0], 0)]\n        res = nums[0]\n        for i in range(1, len(nums)):\n            rm = i - k - 1\n            while pq[0][1] <= rm:\n                heapq.heappop(pq)\n            cur = max(-pq[0][0], 0) + nums[i]\n            res = max(res, cur)\n            heapq.heappush(pq, (-cur, i))\n        return res", "import heapq\n\nclass Solution:\n  def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n    n = len(nums)\n    # dp: walk backward, optimized dp process\n    ans = nums.copy()\n    q = []\n    for i in range(n - 1, -1, -1):\n      # armortized O(1)\n      while q and q[0][1] - i > k:\n        heapq.heappop(q)\n      if q:\n        ans[i] += max(0, -q[0][0])\n      heapq.heappush(q, (-ans[i], i))\n    return max(ans)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp=[-sys.maxsize]*len(nums)\n        ans=nums[0]\n        dp[0]=nums[0]\n        heap=[(-nums[0],0)]\n        heapq.heapify(heap)\n        for i in range(1,len(nums)):\n            bound=i-k\n            while heap[0][1]<bound:\n                heapq.heappop(heap)\n            dp[i]=max(dp[i],nums[i],-heap[0][0]+nums[i])\n            ans=max(ans,dp[i])\n            heapq.heappush(heap,(-dp[i],i))\n        return ans", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        q = [(-nums[0], 0)]\n        res = nums[0]\n        dp = [0] * n\n        \n        for i in range(1, n):\n            while q and i - q[0][1] > k:\n                heapq.heappop(q)\n                \n            t = max(nums[i] - q[0][0], nums[i])\n            res = max(res, t)\n            heapq.heappush(q, (-t, i))\n            \n        return res", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q = collections.deque()\n        for i in range(len(nums)):\n            nums[i] += q[0] if q else 0\n            \n            while q and nums[i] > q[-1]:\n                q.pop()\n                \n            if nums[i] > 0:\n                q.append(nums[i])\n                \n            if i >= k and q and q[0] == nums[i-k]:\n                q.popleft()\n                \n        return max(nums)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        q = collections.deque()\n        result = nums[0]\n        for i in range(n):\n            while q and q[0][1] < i - k:\n                q.popleft()\n            a = q[0][0] if q else 0\n            m = nums[i] + (a if a > 0 else 0)\n            while q and m >= q[-1][0]:\n                q.pop()\n            q.append((m, i))\n            result = max(result, m)\n        return result", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        heap = [(-nums[0], 0)]\n        ret = nums[0]\n\n        for i in range(1, len(nums)):\n            remove = i - k - 1\n            while remove >= heap[0][1]:\n                heapq.heappop(heap)\n\n            cur = max(0, -heap[0][0]) + nums[i]\n            ret = max(ret, cur)\n            heapq.heappush(heap, (-cur, i))\n        return ret\n", "from collections import deque\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = nums.copy()\n        ans = dp[0]\n\n        monoq = deque()\n        qsize = 0\n        \n        for i, num in enumerate(nums):\n            if i > 0:   \n                dp[i] = max(dp[i], num + monoq[0][0])\n            ans = max(ans, dp[i])\n            \n            pops = 1\n            while monoq and dp[i] > monoq[-1][0]:\n                _, freq = monoq.pop()\n                pops += freq\n                qsize -= freq\n            monoq.append([dp[i], pops])\n            qsize += pops\n\n            while qsize > k:\n                extra = qsize - k\n                if monoq[0][1] > extra:\n                    monoq[0][1] -= extra\n                    qsize = k\n                else:\n                    _, v = monoq.popleft()\n                    qsize -= v\n            \n        return ans\n", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        N, queue = len(nums), deque()\n        dp = [0] * N\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n            #if i > k and (queue[0] == i - k - 1):\n                queue.popleft()\n            #dp[i] = (val + max(dp[queue[0]], 0)) if queue else val\n            if queue and dp[queue[0]] > 0:\n                dp[i] = val + dp[queue[0]]\n            else:\n                dp[i] = val\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return max(dp)\n        \nfrom collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        if not nums or not k: return 0\n        if max(nums) <= 0: return max(nums)\n        if min(nums) >= 0: return sum(nums)\n        queue, N = deque(), len(nums)\n        for i in range(N):\n            #if queue and (i - queue[0] > k):\n            while queue and queue[0] < i - k:\n                queue.popleft()\n            # compute the max sum we can get at index i\n            if queue:\n                nums[i] += nums[queue[0]]\n            # delet all the sequence that smaller than current sum, becaus there will never be\n            # considers ==> smaller than current sequence, and end before current sequence\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            # if nums[i] < 0, it can't be a useful prefix sum\n            if nums[i] > 0:\n                queue.append(i)\n        return max(nums)\n    \n    \n    \nfrom collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        N, queue = len(nums), deque()\n        dp = [val for val in nums]\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n                queue.popleft()\n            if queue and dp[queue[0]] > 0:\n                dp[i] += dp[queue[0]]\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return max(dp)\n", "from collections import deque\n\n\nclass Solution:\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\n        Q = deque([(0, A[0])])  # decreasing\n        running_max = A[0]\n        for i in range(1, len(A)):\n            if Q[0][0] < i - k:\n                Q.popleft()\n            maxsum_of_subseq_ends_at_i = A[i] + max(Q[0][1], 0)\n            running_max = max(maxsum_of_subseq_ends_at_i, running_max)\n            while Q and Q[-1][1] <= maxsum_of_subseq_ends_at_i:\n                Q.pop()\n            Q.append((i, maxsum_of_subseq_ends_at_i))\n\n        return running_max\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [-sys.maxsize] * n\n        dp[0] = nums[0]\n        maxDeque = deque()\n        \n        ans = -sys.maxsize\n        for j in range(n):\n            while len(maxDeque) > 0 and j - maxDeque[0] > k:\n                maxDeque.popleft()\n            preMax = dp[maxDeque[0]] if len(maxDeque) > 0 else 0\n            dp[j] = max(preMax + nums[j], nums[j])\n            ans = max(dp[j], ans)\n            while len(maxDeque) > 0 and dp[maxDeque[-1]] < dp[j]:\n                maxDeque.pop()\n            maxDeque.append(j)\n        \n        return ans", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp, res = collections.deque(), -float('inf')\n        for i, n in enumerate(nums):\n            if dp and dp[0][0] < i - k:\n                dp.popleft()\n            cur = n + (0 if not dp else dp[0][1])\n            res = max(res, cur)\n            if cur > 0:\n                while dp and dp[-1][1] <= cur:\n                    dp.pop()\n                dp.append((i, cur))\n            # print('dp', dp)\n        return res\n        \n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n=len(nums)\n        dp=[0]*n\n        remove=collections.defaultdict(int)\n        h=[]\n        def get_b():\n            if not h:\n                return 0\n            b=heapq.heappop(h)\n            while remove[b]>0:\n                remove[b]-=1\n                b=heapq.heappop(h)\n            heapq.heappush(h,b)\n            return -b\n        for i,d in enumerate(nums):\n            if i>k:\n                remove[-dp[i-k-1]]+=1\n            dp[i]=max(get_b(),0)+d\n            heapq.heappush(h,-dp[i])\n        return max(dp)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        q = collections.deque()\n        result = nums[0]\n        for i in range(n):\n            while q and q[0][1] < i - k:\n                q.popleft()\n            a = q[0][0] if q else 0\n            m = nums[i] + (a if a > 0 else 0)\n            if m > 0:\n                while q and m >= q[-1][0]:\n                    q.pop()\n                q.append((m, i))\n            result = max(result, m)\n        return result", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = [0 - sys.maxsize for i in range(len(nums))]\n        heap = []\n        \n        dp[0] = nums[0]\n        heapq.heappush(heap, (0-nums[0], 0))\n        for i in range(1,len(nums)):\n            while len(heap) and heap[0][1] < i - k:\n                heapq.heappop(heap)\n            dp[i] = max(dp[i], nums[i] + max(0, 0 - heap[0][0] if len(heap) else 0))\n            heapq.heappush(heap, (0 - dp[i], i))\n        return max(dp)\n            \n            \n        \n        \n        \n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        heap = [(-nums[0], 0)]\n        result = nums[0]\n        for i in range(1, n):\n            while heap and heap[0][1] < i - k:\n                heapq.heappop(heap)\n            a = -heap[0][0]\n            m = nums[i] + (a if a > 0 else 0)\n            heapq.heappush(heap, (-m, i))\n            result = max(result, m)\n        return result", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        \n        que = deque()\n        for ind in range(len(nums)):\n            nums[ind] += que[0] if que else 0\n            \n            while que and nums[ind] > que[-1]:\n                que.pop()\n            \n            if nums[ind] > 0:\n                que.append(nums[ind])\n                \n            if que and ind >= k and que[0] == nums[ind-k]:\n                que.popleft()\n                \n        return max(nums)\n            \n", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        #if max(nums) <= 0: return max(nums)   # optimization\n        #if min(nums) >= 0: return sum(nums)   # optimization\n    \n        N, queue = len(nums), deque()\n        dp = [val for val in nums]\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n                queue.popleft()\n            if queue and dp[queue[0]] > 0:\n                dp[i] += dp[queue[0]]\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return  max(dp)", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q = deque()\n        q.append((nums[0],0))\n        max_sum = nums[0]\n\n        for i in range(1,len(nums)):\n            while q and q[0][1] < i - k:\n                q.popleft()\n\n            next_val = max(nums[i], nums[i] + q[0][0])\n            \n            while q and q[-1][0] < next_val:\n                q.pop()\n\n            q.append((next_val,i))\n\n            max_sum = max(max_sum, q[0][0])\n\n        return max_sum\n\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        deque = []\n        for i, num in enumerate(nums):\n            while(deque and nums[deque[-1]] < 0):\n                deque.pop()\n            while(deque and deque[0] < i - k):\n                deque.pop(0)\n            if deque:\n                nums[i] = nums[deque[0]] + num\n            \n            while(deque and nums[deque[-1]] < nums[i]):\n                deque.pop()\n            deque.append(i)\n        \n        return max(nums)", "from collections import deque\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        largest = deque()\n        global_max = float('-inf')\n\n        for i, num in enumerate(nums):\n            if largest and largest[-1][1] < i - k: largest.pop()\n\n            curr = num + max(0, largest[-1][0] if largest else 0)\n            while largest and curr > largest[0][0]:\n                largest.popleft()\n            global_max = max(global_max, curr)\n            largest.appendleft((curr, i))\n\n        return global_max", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\n        deque = collections.deque()\n        for i in range(len(A)):\n            A[i] += deque[0] if deque else 0\n            while len(deque) and A[i] > deque[-1]:\n                deque.pop()\n            if A[i] > 0:\n                deque.append(A[i])\n            if i >= k and deque and deque[0] == A[i - k]:\n                deque.popleft()\n        return max(A)\n            \n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q = deque()\n        q.append((nums[0],0))\n        max_sum = nums[0]\n\n        for i in range(1,len(nums)):\n            while q and q[0][1] < i - k:\n                q.popleft()\n\n            next_val = nums[i]\n\n            if q and q[0][0] >= 0:\n                next_val += q[0][0]\n            \n            while q and q[-1][0] < next_val:\n                q.pop()\n\n            q.append((next_val,i))\n\n            max_sum = max(max_sum, q[0][0])\n\n        return max_sum\n\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp=collections.deque([(nums[0],0)])\n        ans=nums[0]\n        for i in range(1,len(nums)):\n            new = nums[i] + max(0,dp[0][0])\n            while dp and dp[0][1]<=i-k:\n                dp.popleft()\n            while dp and new>=dp[-1][0]:\n                dp.pop()\n            dp.append((new,i))\n            ans=max(ans,new)\n        return ans", "from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = [0] * len(nums)\n        \n        dp[0] = nums[0]\n        \n        ans = dp[0]\n        \n        # queue holds the index\n        queue = deque([0])\n        \n        for j in range(1, len(nums)):\n            if queue and queue[0] < j-k:\n                queue.popleft()\n                \n            dp[j] = nums[j] + max(0, dp[queue[0]])\n            \n            while queue and dp[queue[-1]] < dp[j]:\n                queue.pop()\n            \n            queue.append(j)\n            ans = max(ans, dp[j])\n            \n        return ans", "from collections import deque\n\nclass MaxQueue:\n    def __init__(self, size):\n        self.queue = deque()\n        self.size = size\n        \n    def add(self, val, i):\n        while self.queue and val > self.queue[-1][0]:\n                self.queue.pop()\n        self.queue.append((val, i))                            \n        \n        while i - self.queue[0][1] >= self.size: \n            self.queue.popleft()            \n\n    def max(self):\n        if self.queue:\n            return self.queue[0][0]\n        else:\n            return 0\n\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        queue = MaxQueue(k)\n        result = -1\n        for i in range(len(nums)):\n            score = nums[i]\n            prev = queue.max()\n            if prev > 0:\n                score += prev\n            queue.add(score, i)\n            result = max(result, score)\n        return result\n", "class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        import heapq\n        h = []\n        heapq.heapify(h)\n        largeNum = -10000000000\n        ans = largeNum\n        for i in range(len(nums)):\n            if(i == 0):\n                ans = nums[i]\n                heapq.heappush(h, (-nums[i], i))\n            else:\n                b = False\n                m,index = heapq.heappop(h)\n                while(index < i-k):\n                    m,index = heapq.heappop(h)\n                heapq.heappush(h, (m,index))\n                ans = max(ans, nums[i] - m, nums[i])\n                heapq.heappush(h, (min(m-nums[i], -nums[i]), i))\n            #print(h)\n        #print(ans)\n        return ans", "import heapq\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        queue = [(-nums[0], 0)]\n        res = nums[0]\n        \n        for i in range(1, len(nums)):\n            while i - k -1 >= queue[0][1]:\n                heapq.heappop(queue)\n            \n            curr = max(-queue[0][0], 0) + nums[i]\n            res = max(res, curr)\n            heapq.heappush(queue, (-curr, i))\n        return res", "from typing import List\nimport numpy\n\nclass Solution:\n  def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n\n    _len = len(nums)\n    dp = numpy.zeros(_len, dtype=int)\n    dp[0] = nums[0]\n    _deque = []\n    result = -sys.maxsize\n    for i in range(_len):\n\n      while _deque and i - _deque[0] > k:\n        _deque.pop(0)\n\n      tmp = 0\n      if _deque:\n        tmp = dp[_deque[0]]\n      dp[i] = max(nums[i], nums[i] + tmp)\n      result = max(result, dp[i])\n\n      while _deque and dp[i] >= dp[_deque[-1]]:\n        _deque.pop()\n\n      _deque.append(i)\n      pass\n\n\n    return result\n", "from sortedcontainers import SortedList\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        B = [nums[i] for i in range(len(nums))]\n        store = SortedList()\n        \n        for i in range(len(nums)-1,-1,-1): \n            if len(store) > 0:\n                if store[-1] > 0:\n                    B[i] += store[-1]\n            \n            \n            store.add(B[i])\n            if len(store) > k:\n                store.remove(B[i+k])\n\n        return max(B)"]
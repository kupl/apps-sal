["import collections\n\n\nclass Bit():\n    def __init__(self, l):\n        self.size = l\n        self.bit = [0] * (self.size+1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += i & -i\n\n    def __str__(self):\n        return str(self.bit)\n\n\nS = str(input())\nN = len(S)\nindex = collections.defaultdict(list)\n\nfor i, c in enumerate(S):\n    index[c].append(i)\n\nctr = N // 2\nB = [0] * N\nflag = 0\nP = []\n\nfor c, k in list(index.items()):\n    cnt = len(k)\n    if cnt % 2:\n        if flag == 1:\n            print((-1))\n            return\n        flag = 1\n        B[k[cnt // 2]] = ctr + 1\n    for i in range(cnt // 2):\n        l, r = k[i], k[-(i+1)]\n        P.append((l, r))\n\nP.sort()\n\nfor i, (l, r) in enumerate(P):\n    B[l], B[r] = i + 1, N - i\n\nans = 0\nbit = Bit(N)\nfor i, b in enumerate(B):\n    ans += i - bit.sum(b)\n    bit.add(b, 1)\n\nprint(ans)\n", "\"\"\"\n\u307e\u305a\u3001\u5947\u6570\u500b\u5b58\u5728\u3059\u308b\u6587\u5b57\u7a2e\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u306f\u3001\u56de\u6587\u306b\u3067\u304d\u306a\u3044\u3002\n\u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306f\u3001\u56de\u6587\u306b\u3067\u304d\u308b\u3002\n\u6b21\u306b\u3001\u64cd\u4f5c\u306e\u6700\u5c0f\u56de\u6570\u306f\u3001\u56de\u6587\u306b\u306a\u3063\u305f\u5834\u5408\u306e\u5404\u6587\u5b57\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u6c42\u3081\u3066\u304a\u304d\u3001BIT\u3092\u4f7f\u3063\u3066\u3001\u5165\u308c\u66ff\u3048\u304c\u5fc5\u8981\u306a\u56de\u6570\u3092\u6c42\u3081\u3066\u7f6e\u304f\n\"\"\"\nfrom collections import Counter\nS = input()\nN = len(S)\n#\u5404\u6587\u5b57\u306e\u51fa\u73fe\u56de\u6570\u3092\u30ab\u30a6\u30f3\u30c8\napperance = Counter(S)\n\n#\u56de\u6587\u3092\u4f5c\u6210\u3067\u304d\u308b\u304b\u5224\u5b9a\nflag = False\nfor k,v in list(apperance.items()):\n    if v%2==1:\n        if flag:\n            print((-1))\n            return\n        else:\n            flag = True\n            t = k\n\n\n#place[s] -> \u6587\u5b57s\u306e\u51fa\u73fe\u4f4d\u7f6e\nplace = {}\nfor i in range(N):\n    s = S[i]\n    if s not in place:\n        place[s] = []\n    place[s].append(i)\n\n#memo[i] -> S\u306ei\u6587\u5b57\u76ee\u306e\u56de\u6587\u4e0a\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\nmemo = [-1] *(N)\n\n#\u56de\u6587\u524d\u534a\u3001\u5f8c\u534a\u306b\u542b\u307e\u308c\u308b\u3053\u3068\u306b\u306a\u308b\u6587\u5b57\u306b\u3001\u56de\u6587\u4e0a\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u5272\u308a\u5f53\u3066\u308b\u3002\ntmp = 0\ntmpApperance = {}\nfor i in range(N):\n    s = S[i]\n    if s not in tmpApperance:\n        tmpApperance[s] = 1\n    else:\n        tmpApperance[s] += 1\n    if tmpApperance[s] <= apperance[s]//2:\n        memo[i] = tmp\n        backIdx = place[s][-tmpApperance[s]]\n        memo[backIdx] = N-tmp-1\n        tmp += 1\n\n\n#\u56de\u6587\u306e\u771f\u3093\u4e2d\u306b\u542b\u307e\u308c\u308b\u3053\u3068\u306b\u306a\u308b\u6587\u5b57\u306b\u3001\u56de\u6587\u4e0a\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u5272\u308a\u5f53\u3066\u308b\u3002\nif flag:\n    idx = N//2\n    memo[place[t][len(place[t])//2]] = idx\n\nclass BIT:\n    def __init__(self,n):\n        self.size=n\n        self.tree = [0]*(n+1)\n    \n    def sum(self,i):\n        s = 0\n        while i>0:\n            s += self.tree[i]\n            i -= i&-i\n        return s\n    \n    def add(self,i,x):\n        while i<=self.size:\n            self.tree[i] += x\n            i += i&-i\nbit = BIT(N)\ncnt = 0\nfor i in range(N):\n    m = memo[i]+1\n    bit.add(m,1)\n    cnt += bit.sum(N)-bit.sum(m)\n\nprint(cnt)\n", "from collections import Counter\n\nclass BIT:\n    def __init__(self,n):\n        self.tree = [0]*(n+1)\n        self.size = n\n    \n    def sum(self,i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i&-i\n        return s\n\n    def add(self,i,x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i&-i\n\nS = input()\nN = len(S)\ncount = Counter(S)\nflag = False\nfor v in list(count.values()):\n    if v%2 == 1:\n        if flag:\n            print((-1))\n            return\n        else:\n            flag = True\n\n\n\"\"\"\n\u6587\u5b57s\u306ei\u6587\u5b57\u76ee\u304c\u3069\u3053\u306b\u3042\u308b\u304b\u3001\u3092O(1)\u3067\u53d6\u308a\u51fa\u305b\u308b\u8f9e\u66f8\u304c\u5fc5\u8981\n\"\"\"\nplaceAtS = {s:[] for s in list(set(S))}\nfor i in range(N):\n    s = S[i]\n    placeAtS[s].append(i)\n\ncount2 = {s:0 for s in list(set(S))}\n\nplaceAtT = [None]*(N)\ntmp = 0\nfor i in range(N):\n    s = S[i]\n    count2[s] += 1\n    if count2[s] <= count[s]//2:\n        placeAtT[i] = tmp\n        mirror = placeAtS[s][count[s]-count2[s]]\n        placeAtT[mirror] = N - tmp - 1\n        tmp += 1\n\nfor i in range(N):\n    if placeAtT[i] == None:\n        placeAtT[i] = tmp\n\nbit = BIT(N)\nans = 0\nfor i in range(N):\n    bit.add(placeAtT[i]+1,1)\n    ans += bit.sum(N) - bit.sum(placeAtT[i]+1)\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque, defaultdict, Counter\n\nS = input().rstrip()\nL = len(S)\n\nc = Counter(S)\nif sum((x&1 for x in c.values())) >= 2:\n    print(-1)\n    return\n\nalphabet_to_pos = defaultdict(deque)\n\nfor i,x in enumerate(S,1):\n    alphabet_to_pos[x].append(i)\n\nafter = [None] * len(S)\nn = 0\nfor i,x in enumerate(S,1):\n    p = alphabet_to_pos[x]\n    if not p:\n        continue\n    if len(p) == 1:\n        p.pop()\n        after[L//2] = i\n        continue\n    p.popleft()\n    j = p.pop()\n    after[n] = i\n    after[L - n - 1] = j\n    n += 1\n\ndef BIT_update(tree,x):\n    while x <= L:\n        tree[x] += 1\n        x += x & (-x)\n\ndef BIT_sum(tree,x):\n    s = 0\n    while x:\n        s += tree[x]\n        x -= x & (-x)\n    return s\n\nanswer = 0\ntree = [0] * (L+1)\nfor i,x in enumerate(after):\n    answer += i - BIT_sum(tree,x)\n    BIT_update(tree,x)\n\nprint(answer)", "S=list(input())\nN=len(S)\nord_A=ord(\"a\")\nalp=[0]*26\nodd=-1\nfor i in range(N):\n  m=ord(S[i])-ord_A\n  alp[m]+=1\nfor k in range(26):\n  if alp[k]%2==1:\n    if odd==-1:\n      odd=k\n    else:\n      print(-1)\n      return\npos=[[] for i in range(26)]\nSequence=[0]*N\nd=0\nalp_num=[0]*26\nfor i in range(N):\n  m=ord(S[i])-ord_A\n  alp_num[m]+=1\n  if 2*alp_num[m]<=alp[m]:\n    Sequence[i]=d\n    pos[m].append(d)\n    d+=1\n  elif m==odd and alp_num[m]==alp[m]//2+1:\n    Sequence[i]=N//2\n  else:\n    j=pos[m].pop()\n    Sequence[i]=N-1-j\n\ndef add(B,a,n):\n    x = a\n    while x<=n:\n        B[x]+=1\n        x+=x&(-x)\n        \ndef sums(B,a):\n    x=a\n    S=0\n    while x!=0:\n        S+=B[x]\n        x-=x&(-x)\n    return S\n  \ndef invnumber(n,A):\n  B=[0]*(n*2+1)\n  invs=0\n  for i in range(n):\n      s=A[i]+n\n      invs+=sums(B,s)\n      add(B,s,n*2)\n  return n*(n-1)//2-invs\n\nprint(invnumber(N,Sequence))", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\nclass BitSum:\n    def __init__(self, n):\n        self.n = n + 3\n        self.table = [0] * (self.n + 1)\n\n    def update(self, i, x):\n        i += 1\n        while i <= self.n:\n            self.table[i] += x\n            i += i & -i\n\n    def sum(self, i):\n        i += 1\n        res = 0\n        while i > 0:\n            res += self.table[i]\n            i -= i & -i\n        return res\n\ndef InversionNumber(lst):\n    bit = BitSum(max(lst))\n    res = 0\n    for i, a in enumerate(lst):\n        res += i - bit.sum(a)\n        bit.update(a, 1)\n    return res\n\ndef main():\n    s = input()\n    n = len(s)\n    ord_a = ord(\"a\")\n    cnts = [0] * 26\n    s_code = []\n    flag_odd = False\n    for c in s:\n        code = ord(c) - ord_a\n        s_code.append(code)\n        cnts[code] += 1\n    odd_code = -1\n    for code, cnt in enumerate(cnts):\n        if cnt % 2 == 1:\n            if flag_odd:\n                print(-1)\n                return\n            else:\n                odd_code = code\n                flag_odd = True\n        cnts[code] = cnt // 2\n    tois = [[] for _ in range(26)]\n    to_sort_idx = []\n    new_idx = 1\n    for code in s_code:\n        if cnts[code] > 0:\n            to_sort_idx.append(new_idx)\n            tois[code].append(n + 1 - new_idx)\n            cnts[code] -= 1\n            new_idx += 1\n        else:\n            if flag_odd and code == odd_code:\n                to_sort_idx.append(n // 2 + 1)\n                flag_odd = False\n            else:\n                to_sort_idx.append(tois[code].pop())\n    # print(to_sort_idx)\n    print(InversionNumber(to_sort_idx))\n\nmain()\n", "from collections import deque\nimport copy\nclass BIT:\n    def __init__(self, node_size):\n        self._node = node_size+1\n        self.bit = [0]*self._node\n \n    def add(self, index, add_val):\n        while index < self._node:\n            self.bit[index] += add_val\n            index += index & -index\n \n    def sum(self, index):\n        res = 0\n        while index > 0:\n            res += self.bit[index]\n            index -= index & -index\n        return res\n \ns = input()\nn = len(s)\na = [ord(i) - ord(\"a\") for i in s]\nx = [0]*26\nfor i in a:\n  x[i] += 1\nflag = 1\nki = -1\nfor i in x:\n  if i%2 == 1:\n    if flag:\n      flag = 0\n    else:\n      print(-1)\n      return\nc = []\nx2 = [0]*26\nfor i in a:\n  x2[i] += 1\n  if x[i]//2 >= x2[i]:\n    c.append(i)\nfor i in range(26):\n  if x[i]%2 == 1:\n    b = copy.deepcopy(c)\n    c.append(i)\n    b = b[::-1]\n    c.extend(b)\n    break\nelse:\n  b = copy.deepcopy(c)\n  b = b[::-1]\n  c.extend(b) \nd = {}\nfor i in range(26):\n  d[i] = deque([])\nfor i in range(n):\n  d[c[i]].append(i+1)\nfor i in range(n):\n  x = d[a[i]].popleft()\n  a[i] = x\nb = []\nfor i in range(n):\n  b.append([a[i],i+1])\nb.sort()\nb = b[::-1]\nbit = BIT(n)\nans = 0\nfor i,j in b:\n  bit.add(j,1)\n  ans += bit.sum(j-1)\nprint(ans)", "\"\"\"\n\u56de\u6587\u306e\u5de6\u534a\u5206\u306e\u6587\u5b57\u5217\u305f\u3061\u3092\u64cd\u4f5c\u3059\u308b\u3002\n\u5de6\u534a\u5206\u306e\u5404\u6587\u5b57\u306b\u5bfe\u3057\u3066\u3001\u672c\u6765\u3042\u308b\u3079\u304d\u5834\u6240(Index)\u3092\u5b9a\u7fa9\u3059\u308b\u3002\n\u3042\u3068\u306f\u3001\u5de6\u534a\u5206\u306e\u6587\u5b57\n\n\"\"\"\n\nfrom collections import Counter\nclass BIT:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):  # 1-index\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):  # 1-index\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\nS = input()\nN = len(S)\ncount = Counter(S)\n\n#\u5947\u6570\u500b\u3042\u308b\u6587\u5b57\u304c\u8907\u6570\u5b58\u5728\u3057\u3066\u3044\u306a\u3044\u304b\u30c1\u30a7\u30c3\u30af\nflag = False\nfor v in list(count.values()):\n    if v%2 == 1:\n        if flag:\n            print((-1))\n            return\n        else:\n            flag = True\n\n# \u5404\u6587\u5b57\u304c\u5c5e\u3059\u3079\u304d\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u6c42\u3081\u308b\n# memo[i] -> S[i]\u306e\u56de\u6587\u5909\u63db\u5f8c\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9(0-indexed)\nmemo = [None]*(N)\n#appearCnt[k] -> \u6587\u5b57k\u306e\u51fa\u73fe\u56de\u6570\nappearCnt = {k:0 for k in list(count.keys())}\n\n# \u307e\u305a\u3001\u56de\u6587\u6642\u306b\u5de6\u534a\u5206\u306b\u5c5e\u3059\u308b\u6587\u5b57\u306b\u95a2\u3057\u3066\u3001\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u5272\u308a\u5f53\u3066\u308b\u3002\ntInd = 0\nfor i in range(N):\n    s = S[i]\n    if appearCnt[s] <= count[s]//2 - 1:\n        appearCnt[s] += 1\n        memo[i] = tInd\n        tInd += 1\n\n#\u5947\u6570\u500b\u3042\u308b\u6587\u5b57\u304c\u3042\u308b\u5834\u5408\u306f\u3001\u771f\u3093\u4e2d\u306b\u306a\u308b\u6587\u5b57\u306b\u95a2\u3057\u3066\u3001\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u5272\u308a\u5f53\u3066\u308b\nif flag:\n    for i in range(N):\n        s = S[i]\n        if count[s]%2 == 1 and memo[i]==None:\n            memo[i] = tInd\n            break\n\n#\u56de\u6587\u6642\u306b\u53f3\u534a\u5206\u306b\u306a\u308b\u6587\u5b57\u306b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u5272\u308a\u5f53\u3066\u308b\u3002\n#\u307e\u305a\u3001\u5404\u6587\u5b57\u306e\u6587\u5b57\u5217S\u306b\u304a\u3051\u308b\u51fa\u73fe\u56de\u6570\u3092\u307e\u3068\u3081\u308b\nappearIdx = {k:[] for k in list(count.keys())}\nfor i in range(N):\n    s = S[i]\n    appearIdx[s].append(i)\n\nfor v in list(appearIdx.values()):\n    for i in range(len(v)//2):\n        l = v[i]\n        r = v[len(v)-i-1]\n        memo[r] = (N-1)-memo[l]\nans = 0\nbit = BIT(N)\nfor i in range(N):\n    bit.add(memo[i]+1,1)\n    ans += bit.sum(N)-bit.sum(memo[i]+1)\nprint(ans)\n\n", "class Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0]*(n+1)\n\n    def __iter__(self):\n        psum = 0\n        for i in range(self.size):\n            csum = self.sum(i+1)\n            yield csum - psum\n            psum = csum\n        raise StopIteration()\n\n    def __str__(self):  # O(nlogn)\n        return str(list(self))\n\n    def sum(self, i):\n        # [0, i) \u306e\u8981\u7d20\u306e\u7dcf\u548c\u3092\u8fd4\u3059\n        if not (0 <= i <= self.size): raise ValueError(\"error!\")\n        s = 0\n        while i>0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        if not (0 <= i < self.size): raise ValueError(\"error!\")\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def __getitem__(self, key):\n        if not (0 <= key < self.size): raise IndexError(\"error!\")\n        return self.sum(key+1) - self.sum(key)\n\n    def __setitem__(self, key, value):\n        # \u8db3\u3057\u7b97\u3068\u5f15\u304d\u7b97\u306b\u306fadd\u3092\u4f7f\u3046\u3079\u304d\n        if not (0 <= key < self.size): raise IndexError(\"error!\")\n        self.add(key, value - self[key])\n\n\n\nS = input()\nN = len(S)\ncnt = [0]*26\nfor c in S:\n    cnt[ord(c)-97] += 1\nodd = -1\nfor i, cn in enumerate(cnt):\n    if cn%2 != 0:\n        if odd == -1:\n            odd = i\n        else:\n            print((-1))\n            return\n    cnt[i] //= 2\n#cnt2 = [0]*26\nL = [[] for _ in range(26)]\nn = N//2 + 1\nB = []\nfor c in S:\n    c_int = ord(c)-97\n    if cnt[c_int] == 0:\n        if c_int == odd:\n            B.append(1)\n            odd = -1\n        else:\n            p = L[c_int].pop()\n            B.append(p)\n    else:\n        L[c_int].append(n)\n        B.append(0)\n        n-=1\n        cnt[c_int] -= 1\n\nbit = Bit(N//2+2)\nans = 0\nfor i, b in enumerate(B):\n    ans += i - bit.sum(b+1)\n    bit.add(b, 1)\nprint(ans)\n", "from collections import Counter\nimport sys\ns = input()\nN = len(s)\nsc = Counter(s)\nodds = [1 for x in sc if sc[x] % 2 == 1]\nif len(odds) > 1:\n    print((-1))\n    return\n\nclass BIT:\n    def __init__(self, size):\n        self.bit = [0] * (size+1)\n    def add(self, index, elem):\n        index += 1\n        while index < len(self.bit):\n            self.bit[index] += elem\n            index += index & -index\n    def get(self, index):\n        index += 1\n        ret = 0\n        while 0 < index:\n            ret += self.bit[index]\n            index -= index & -index\n        return ret\n\nindices = [-1] * N\ntb = {c: [None] * (sc[c]//2) for c in sc}\nlens = {c: 0 for c in sc}\np = 0\nfor i in range(N):\n    c = s[i]\n    l = lens[c]\n    if 2 * (l+1) <= sc[c]:\n        indices[p] = i\n        tb[c][l] = p\n        lens[c] += 1\n        p += 1\n    elif 2 * (l+1) == sc[c] + 1:\n        indices[N//2] = i\n        lens[c] += 1\n    else:\n        indices[N-1-tb[c][sc[c]-l-1]] = i\n        lens[c] += 1\n\nans = 0\nbit = BIT(N)\nfor i in indices:\n    bit.add(i, 1)\n    ans += bit.get(N-1) - bit.get(i)\nprint(ans)\n", "a2n=lambda x:ord(x)-ord('a')\n# \u6570\u5024(1\u301c26)\u2192\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8(a\u301cz)\nn2a = lambda x:chr(x+ord('a')).lower()\n\ns=list(map(a2n,list(input())))\nn=len(s)\ncary=[0]*26\nfrom collections import deque\nary=[deque([]) for _ in range(26)]\nfor i,x in enumerate(s):\n  cary[x]+=1\n  ary[x].append(i)\noddcnt=0\nfor x in cary:\n  if x%2==1:oddcnt+=1\nif oddcnt>1:\n  print(-1)\n  return\n\n# 0-indexed binary indexed tree\nclass BIT:\n  def __init__(self, n):\n    self.n = n\n    self.data = [0]*(n+1)\n    self.el = [0]*(n+1)\n  # sum of [0,i) sum(a[:i])\n  def sum(self, i):\n    if i==0:return 0\n    s = 0\n    while i > 0:\n      s += self.data[i]\n      i -= i & -i\n    return s\n  def add(self, i, x):\n    i+=1\n    self.el[i] += x\n    while i <= self.n:\n      self.data[i] += x\n      i += i & -i\n  # sum of [l,r)   sum(a[l:r])\n  def sumlr(self, i, j):\n    return self.sum(j) - self.sum(i)\n  # a[i]\n  def get(self,i):\n    i+=1\n    return self.el[i]\n\nbit=BIT(n)\nfor i in range(n):\n  bit.add(i,1)\nans=0\nm=n\nfor i in range(n//2):\n  # idx=i,n-1-i\u306b\u304f\u308b\u3082\u306e\u3092\u8003\u3048\u308b\n  t=-1\n  v=float('inf')\n  for j in range(26):\n    if not ary[j]:continue\n    l=ary[j][0]\n    r=ary[j][-1]\n    tmp=0\n    # l\u304b\u3089i\u3078\n    tmp+=bit.sum(l)\n    # r\u304b\u3089n-1-i\u3078\n    tmp+=m-2*i-bit.sum(r+1)\n    if v>tmp:\n      v=tmp\n      t=j\n  r=ary[t].pop()\n  l=ary[t].popleft()\n  bit.add(l,-1)\n  bit.add(r,-1)\n  ans+=v\nprint(ans)", "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom itertools import permutations, accumulate, combinations, combinations_with_replacement\nfrom math import sqrt, ceil, floor, factorial\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nfrom copy import deepcopy\nfrom operator import itemgetter\nfrom functools import reduce, lru_cache  # @lru_cache(None)\nfrom fractions import gcd\nimport sys\ndef input(): return sys.stdin.readline().rstrip()\ndef I(): return int(input())\ndef Is(): return (int(x) for x in input().split())\ndef LI(): return list(Is())\ndef TI(): return tuple(Is())\ndef IR(n): return [I() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef TIR(n): return [TI() for _ in range(n)]\ndef S(): return input()\ndef Ss(): return input().split()\ndef LS(): return list(S())\ndef SR(n): return [S() for _ in range(n)]\ndef SsR(n): return [Ss() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nsys.setrecursionlimit(10**6)\nMOD = 10**9+7\nINF = 10**18\n# ----------------------------------------------------------- #\n\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):  # 1-index\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):  # 1-index\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    \"\"\"\n    # \u4f7f\u7528\u4f8b\n    bit = BinaryIndexedTree(10)     # \u8981\u7d20\u6570\u3092\u4e0e\u3048\u3066\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5316\n    bit.add(2, 10)    # a2\u306b10\u3092\u52a0\u3048\u308b\n    bit.add(3, -6)    # a3\u306b-6\u3092\u52a0\u3048\u308b\n    print(bit.sum(6)) # a1\uff5ea6\u306e\u5408\u8a08\u3092\u8fd4\u3059\n    print(bit.sum(6) - bit.sum(3))  # a4\uff5ea6\u306e\u5408\u8a08\u3092\u8fd4\u3059\n    \"\"\"\n\ns = S()\nn = len(s)\ns_index = defaultdict(list)\nfor i, x in enumerate(s):\n    s_index[x].append(i)\n\nT = [0]*n  # s\u3067i\u756a\u76ee\u306e\u6587\u5b57\u306f\u3001\u6700\u7d42\u7684\u306a\u56de\u6587\u3067T[i]\u756a\u76ee\u306e\u6587\u5b57\u3068\u306a\u308b\nflag = False  # \u5947\u6570\u500b\u306e\u6587\u5b57\u304c\u524d\u306b\u3042\u3063\u305f\u304b\u30d5\u30e9\u30b0(\u5947\u6570\u500b\u306e\u6587\u5b57\u304c2\u3064\u4ee5\u4e0a\u3042\u3063\u3066\u306f\u306a\u3089\u306a\u3044)\nAC = []  # \u6700\u7d42\u7684\u306a\u56de\u6587\u3067\u306e\u524d\u534aA\u3068\u5f8c\u534aC\u306e\u30da\u30a2\nfor x, index_list in s_index.items():\n    count = len(index_list)\n    if count % 2 == 1:\n        if flag:\n            print(-1)\n            return\n        else:\n            flag = True\n            mid = index_list[count//2]\n            T[mid] = n//2  # \u56de\u6587\u306e\u4e2d\u5fc3(B)\n    for i in range(count//2):\n        a = index_list[i]\n        c = index_list[-i-1]\n        AC.append((a, c))\n\nAC.sort(key=itemgetter(0))  # \u524d\u534a(a)\u306e\u9806\u756a\u3067\u30bd\u30fc\u30c8\nfor i, (a, c) in enumerate(AC):\n    T[a] = i  # a == i\n    T[c] = n - i - 1\n\nBIT = BinaryIndexedTree(n)\ninversion = 0\nfor i, t in enumerate(T):\n    i += 1  # 1-index\u306b\u5909\u63db\n    t += 1  # 1-index\u306b\u5909\u63db\n    BIT.add(t, 1)\n    inversion += i - BIT.sum(t)\nprint(inversion)", "# Binary Indexed Tree (Fenwick Tree)\nclass BIT():\n    \"\"\"\u4e00\u70b9\u52a0\u7b97\u3001\u533a\u9593\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\n    add: i\u756a\u76ee\u306bval\u3092\u52a0\u3048\u308b\n    get_sum: \u533a\u9593[l, r)\u306e\u548c\u3092\u6c42\u3081\u308b\n    i, l, r\u306f0-indexed\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, val):\n        \"\"\"i\u756a\u76ee\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        i = i + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n\n    def get_sum(self, l, r):\n        \"\"\"\u533a\u9593[l, r)\u306e\u548c\u3092\u6c42\u3081\u308b\"\"\"\n        return self._sum(r) - self._sum(l)\n\n\nimport copy\n\ns = input()\nn = len(s)\nmemo = {}\nfor i in range(n):\n    if s[i] not in memo:\n        memo[s[i]] = 1\n    else:\n        memo[s[i]] += 1\n\nodd_cnt = 0\nfor i in memo:\n    odd_cnt += memo[i] % 2\nif odd_cnt > 1:\n    print(-1)\n    return\n\nleft = []\nright = []\n\nmemo2 = copy.deepcopy(memo)\nans_cnt = 0\nword = \"\"\nfor i in range(n):\n    if memo2[s[i]]*2 > memo[s[i]] + 1:\n        memo2[s[i]] -= 1\n        ans_cnt += i - len(left)\n        left.append(s[i])\n    elif memo2[s[i]]*2 == memo[s[i]] + 1:\n        word = s[i]\n        memo2[s[i]] -= 1\n        right.append(s[i])\n    else:\n        memo2[s[i]] -= 1\n        right.append(s[i])\n \nif word != \"\":\n    for i in range(len(right)):\n        if right[i] == word:\n            ans_cnt += i\n            del(right[i])\n            break\nright = right[::-1]\n\nmemo = {}\nfor i in range(len(right)):\n    if right[i] not in memo:\n        memo[right[i]] = [i]\n    else:\n        memo[right[i]].append(i)\nfor i in memo:\n    memo[i] = memo[i][::-1]\n\nfor i in range(len(left)):\n    tmp = left[i]\n    left[i] = memo[tmp][-1]\n    del(memo[tmp][-1])\n\nmemo = {}\nfor i in range(len(left)):\n    memo[i] = left[i]\n\nbit = BIT(len(left))\nfor i in range(len(left)):\n    bit.add(memo[i], 1)\n    ans_cnt += bit.get_sum(memo[i] + 1, len(left))\nprint(ans_cnt)", "from collections import defaultdict\nS = input()\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def update(self, i, v):\n        while i <= self.n:\n            self.bit[i] += v\n            i += i & -i\n            \n    def query(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.bit[i]\n            i -= i & -i\n            \n        return ret\n\nd = defaultdict(list)\nfor i, v in enumerate(S):\n    d[v].append(i + 1)\n\nif sum(len(l) % 2 != 0 for l in list(d.values())) > 1:\n    print((-1))\n    return\n\nN = len(S)\nctr = []\nkey_map = [-1] * (N + 1)\n\nfor k, v in list(d.items()):\n    t = len(v)\n    if t % 2  == 1:\n        key_map[v[t // 2]] = N // 2 + 1\n\n    for j in range(t // 2):\n        ctr.append((v[j], v[-j - 1]))\n        \nctr.sort()\n\nfor i, (l, r) in enumerate(ctr):\n    key_map[l] = i + 1\n    key_map[r] = N - i\n\ntree = BIT(N)\nans = 0\nfor i, v in enumerate(key_map[1:]):\n    ans += i - tree.query(v)\n    tree.update(v, 1)\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nS = list(input().rstrip())\nL = len(S)\n\n# binary indexed tree\nbit = [0 for _ in range(L+1)]\n\n# 0\u304b\u3089i\u307e\u3067\u306e\u533a\u9593\u548c\n# \u7acb\u3063\u3066\u3044\u308b\u30d3\u30c3\u30c8\u3092\u4e0b\u304b\u3089\u51e6\u7406\ndef query_sum(i):\n    s = 0\n    while i > 0:\n        s += bit[i]\n        i -= i & -i\n    return s\n\n# i\u756a\u76ee\u306e\u8981\u7d20\u306bx\u3092\u8db3\u3059\n# \u8986\u3063\u3066\u308b\u533a\u9593\u3059\u3079\u3066\u306b\u8db3\u3059\ndef add(i, x):\n    while i <= L:\n        bit[i] += x\n        i += i & -i\n\ndef main():\n    A = {}\n    for i, s in enumerate(S):\n        if not s in A.keys():\n            A[s] = [i]\n        else:\n            A[s].append(i)\n    odd = 0\n    dic = {}\n    for al, c in A.items():\n        dic[al] = 0\n        if len(c)%2 != 0:\n            odd += 1\n    if odd > 1:\n        print(-1)\n    else:\n        make_ind = []\n        for s, B in A.items():\n            l = len(B)\n            if l%2 == 1:\n                mid = B[l//2]\n            for j, b in enumerate(B):\n                if j < l//2:\n                    make_ind.append(b)\n        make_ind.sort()\n        IND = [None]*L\n        for i, m in enumerate(make_ind):\n            s = S[m]\n            IND[m] = i+1\n            inv = A[s][len(A[s])-1-dic[s]]\n            IND[inv] = L-i\n            dic[s] += 1\n        if L%2 == 1:\n            IND[mid] = L//2+1\n        \n\n        ans = 0\n        for j, a in enumerate(IND):\n            ans += j - query_sum(a)\n            add(a, 1)\n        \n        print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\nS=input()\nN=len(S)\n\ndic={moji:deque([]) for moji in alphabetlist}\nfor i in range(N):\n    dic[S[i]].append(i+1)\n\nleft=deque([])\nright=deque([])\nmid=[]\n\nif N%2==1:\n    check=0\n    memo=0\n    for moji in dic:\n        if len(dic[moji])%2==1:\n            k=len(dic[moji])\n            check+=1\n            memo=dic[moji][k//2]\n    if check!=1:\n        print(-1)\n        return\n    else:\n        mid.append(memo)\nelse:\n    check=0\n    for moji in dic:\n        if len(dic[moji])%2==1:\n            print(-1)\n            return\n\nfor i in range(N//2):\n    for moji in alphabetlist:\n        if len(dic[moji])>=2:\n            L=dic[moji][0]\n            R=dic[moji][-1]\n            for moji2 in alphabetlist:\n                if len(dic[moji2])>=2 and dic[moji2][0]<L<R<dic[moji2][-1]:\n                    break\n            else:\n                left.append(L)\n                right.appendleft(R)\n                dic[moji].popleft()\n                dic[moji].pop()\n                break\n\nans=list(left)+mid+list(right)\nn=N\n#A1 ... An\u306eBIT(1-indexed)\nBIT = [0]*(n+1)\n\n#A1 ~ Ai\u307e\u3067\u306e\u548c O(logN)\ndef BIT_query(idx):\n    res_sum = 0\n    while idx > 0:\n        res_sum += BIT[idx]\n        idx -= idx&(-idx)\n    return res_sum\n\n#Ai += x O(logN)\ndef BIT_update(idx,x):\n    while idx <= n:\n        BIT[idx] += x\n        idx += idx&(-idx)\n    return\n\nres=0\nfor i in range(N):\n    res+=i-BIT_query(ans[i])\n    BIT_update(ans[i],1)\n\nprint(res)", "\"\"\"\n\u3069\u308c\u3068\u30da\u30a2\u306b\u306a\u308b\u304b\u306f\u6700\u521d\u304b\u3089\u78ba\u5b9a\n\u4f4d\u7f6e\u3092\u6c7a\u3081\u308c\u3070\u5f8c\u306f\u8ee2\u5012\u6570\n\"\"\"\nimport sys\n\ndef bitadd(a,w,bit): #a\u306bw\u3092\u52a0\u3048\u308b(1-origin)\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit): #ind 1\uff5ea\u307e\u3067\u306e\u548c\u3092\u6c42\u3081\u308b\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\n\nS = input()\n\ndic = {}\n\nfor i,s in enumerate(S):\n\n    if s not in dic:\n\n        dic[s] = []\n\n    dic[s].append(i)\n\npair = [None] * len(S)\nlis = [None] * len(S)\n\nfor i in dic:\n\n    for j in range(len(dic[i]) // 2):\n\n        pair[dic[i][j]] = dic[i][-1-j]\n        pair[dic[i][-1-j]] = -1\n\nnumnone = 0\nfor i in pair:\n    if i == None:\n        numnone += 1\n\nif numnone > 1:\n    print((-1))\n    return\n\nnmax = 0\nfor i,num in enumerate(pair):\n\n    if num == None:\n        lis[i] = len(S)//2\n\n    if num != None and num >= 0:\n        \n        lis[i] = nmax\n        lis[num] = len(S)-1-nmax\n        nmax += 1\n\nBIT = [0] * (len(S)+1)\nans = 0\nlis.reverse()\n\nfor i,num in enumerate(lis):\n\n    num += 1\n    ans += bitsum(num,BIT)\n    bitadd(num,1,BIT)\n\nprint (ans)\n", "from string import ascii_lowercase\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\ndef solve(s):\n    indices = {c: [] for c in ascii_lowercase}\n    for i, c in enumerate(s):\n        indices[c].append(i)\n\n    n = len(s)\n    center = n // 2\n    bubbles = [-1] * n\n    odd_flag = False\n    lefts, rights = [], []\n    used = [False] * n\n    for c, ids in list(indices.items()):\n        cnt = len(ids)\n        if cnt & 1:\n            if odd_flag:\n                return -1\n            odd_flag = True\n            bubbles[ids[cnt // 2]] = center + 1\n            used[center] = True\n        for i in range(cnt // 2):\n            li, ri = ids[i], ids[-i - 1]\n            if li < center:\n                lefts.append((li, ri))\n                used[n - li - 1] = True\n            else:\n                rights.append((li, ri))\n    lefts.sort()\n    rights.sort()\n    r_itr = iter(rights)\n    # print(lefts)\n    # print(rights)\n    for i, (li, ri) in enumerate(lefts):\n        bubbles[li] = i + 1\n        bubbles[ri] = n - i\n    for i in range(len(lefts), center):\n        li, ri = next(r_itr)\n        bubbles[li] = i + 1\n        bubbles[ri] = n - i\n    # print(bubbles)\n\n    ans = 0\n    bit = Bit(n)\n    for i, m in enumerate(bubbles):\n        ans += i - bit.sum(m)\n        bit.add(m, 1)\n    return ans\n\n\nprint((solve(input())))\n", "from collections import Counter\n\n\nclass fenwick_tree(object):\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * n\n\n    def __sum(self, r):\n        s = 0\n        while r > 0:\n            s += self.data[r - 1]\n            r -= r & -r\n        return s\n\n    def add(self, p, x):\n        \"\"\" a[p] += x\u3092\u884c\u3046\"\"\"\n        assert 0 <= p and p < self.n\n        p += 1\n        while p <= self.n:\n            self.data[p - 1] += x\n            p += p & -p\n\n    def sum(self, l, r):\n        \"\"\"a[l] + a[l+1] + .. + a[r-1]\u3092\u8fd4\u3059\"\"\"\n        assert 0 <= l and l <= r and r <= self.n\n        return self.__sum(r) - self.__sum(l)\n\n\ndef calc_inversion(arr):\n    N = len(arr)\n    bit = fenwick_tree(N)\n    atoi = {a: i for i, a in enumerate(arr)}\n    res = 0\n    for a in reversed(range(N)):\n        i = atoi[a]\n        res += bit.sum(0, i)\n        bit.add(i, 1)\n    return res\n\n\ndef calc_inv(arr):\n    N = len(set(arr))\n    atoi = {a: i for i, a in enumerate(sorted(set(arr)))}\n    bit = fenwick_tree(N)\n    res = 0\n    for i, a in enumerate(arr):\n        res += i - bit.sum(0, atoi[a] + 1)\n        bit.add(atoi[a], 1)\n    return res\n\n\ndef main():\n    S = input()\n    N = len(S)\n    C = Counter(S)\n\n    odd = 0\n    mid = \"\"\n    for k, v in C.items():\n        if v & 1:\n            odd += 1\n            mid = k\n\n    if N % 2 == 0:  # \u5076\u6570\n        if odd:\n            return -1\n        half = {k: v // 2 for k, v in C.items()}\n        cnt = {k: 0 for k in C.keys()}\n        label = []\n        left = []\n        right = []\n        for i, s in enumerate(S):\n            if cnt[s] < half[s]:\n                label.append(0)\n                left.append(s)\n            else:\n                label.append(1)\n                right.append(s)\n            cnt[s] += 1\n        ans = calc_inv(label)\n\n        pos = {k: [] for k in C.keys()}\n        for i, s in enumerate(left):\n            pos[s].append(i)\n        label = []\n        for s in right:\n            label.append(pos[s].pop())\n        ans += calc_inv(label[::-1])\n        return ans\n\n    else:  # \u5947\u6570\n        if odd != 1:\n            return -1\n        half = {k: v // 2 for k, v in C.items()}\n        cnt = {k: 0 for k in C.keys()}\n        label = []\n        right = []\n        left = []\n        seen = 0\n        LL = 0  # mid\u306e\u53f3\u306b\u3042\u308bL\n        RR = 0  # mid\u306e\u5de6\u306b\u3042\u308bR\n\n        for i, s in enumerate(S):\n            if s == mid and cnt[s] == half[s]:\n                seen = 1\n                cnt[s] += 1\n                continue\n            if cnt[s] < half[s]:\n                label.append(0)\n                left.append(s)\n                if seen:\n                    LL += 1\n            else:\n                label.append(1)\n                right.append(s)\n                if not seen:\n                    RR += 1\n            cnt[s] += 1\n        ans = calc_inv(label)\n        ans += RR + LL\n\n        pos = {k: [] for k in C.keys()}\n        for i, s in enumerate(left):\n            pos[s].append(i)\n        label = []\n        for s in right:\n            label.append(pos[s].pop())\n        ans += calc_inv(label[::-1])\n        return ans\n\n\nprint(main())", "from collections import Counter\nS = input()\nN = len(S)\nctr = Counter(S)\nif len([1 for v in ctr.values() if v%2]) > 1:\n    print(-1)\n    return\n\nM = None\nfor k,v in ctr.items():\n    if v%2:\n        M = k\n    ctr[k] //= 2\n\ndef ctoi(c):\n    return ord(c) - ord('a')\nfrom collections import deque\nidxs = [deque() for _ in range(26)]\nfor i,c in enumerate(S):\n    idxs[ctoi(c)].append(i)\n\nA = ''\nP = []\ni = 0\nwhile len(A) < N//2:\n    c = S[i]\n    if ctr[c] > 0:\n        ctr[c] -= 1\n        A += c\n        P.append(idxs[ctoi(c)].popleft())\n    i += 1\nif M:\n    P.append(idxs[ctoi(M)].popleft())\nfor c in A[::-1]:\n    P.append(idxs[ctoi(c)].popleft())\n\ndef inversion(inds):\n    bit = [0] * (N+1)\n    def bit_add(x,w):\n        while x <= N:\n            bit[x] += w\n            x += (x & -x)\n    def bit_sum(x):\n        ret = 0\n        while x > 0:\n            ret += bit[x]\n            x -= (x & -x)\n        return ret\n    inv = 0\n    for ind in reversed(inds):\n        inv += bit_sum(ind + 1)\n        bit_add(ind + 1, 1)\n    return inv\n\nprint(inversion(P))", "class segment_tree_dual:\n    def __init__(self, N, compose, funcval, ID_M=None):\n        self.compose = compose\n        self.ID_M = ID_M\n        self.funcval = funcval\n\n        self.height = (N-1).bit_length() #\u6728\u306e\u6bb5\u6570\n        self.N0 = 1<<self.height #\u6728\u306e\u6a2a\u5e45 >= N\n        self.laz = [self.ID_M]*(2*self.N0) #\u4f5c\u7528\u7d20\u306e\u6728\n        self.val = None #\u5024\u306e\u914d\u5217\n\n    #\u521d\u671f\u5024\u306e\u914d\u5217\u3092\u4f5c\u308b\n    def build(self,initial):\n        self.val = initial[:]\n\n    #laz[k] \u3092\u5b50\u306b\u4f1d\u3048\u308b\u3001k \u304c\u4e00\u756a\u4e0b\u306e\u5834\u5408\u306f laz[k] \u3092 val \u306b\u53cd\u6620\u3059\u308b\n    def propagate(self,k):\n        if self.laz[k] == self.ID_M: return;\n        if self.N0 <= k:\n            self.val[k-self.N0] = self.funcval(self.val[k-self.N0], self.laz[k])\n            self.laz[k] = self.ID_M\n        else:\n            self.laz[(k<<1)  ] = self.compose(self.laz[(k<<1)  ],self.laz[k]);\n            self.laz[(k<<1)+1] = self.compose(self.laz[(k<<1)+1],self.laz[k]);\n            self.laz[k] = self.ID_M;\n    \n    # \u9045\u5ef6\u3092\u3059\u3079\u3066\u89e3\u6d88\u3059\u308b\n    def propagate_all(self):\n        upto = self.N0 + len(self.val)\n        for i in range(1,upto): self.propagate(i)\n\n    # laz[k]\u304a\u3088\u3073\u305d\u306e\u4e0a\u306b\u4f4d\u7f6e\u3059\u308b\u4f5c\u7528\u7d20\u3092\u3059\u3079\u3066\u4f1d\u64ad\n    def thrust(self,k):\n        for i in range(self.height,-1,-1): self.propagate(k>>i)\n\n    # \u533a\u9593[l,r]\u306b\u95a2\u6570 f \u3092\u4f5c\u7528\n    def update(self, L,R,f):\n        L += self.N0; R += self.N0+1\n        \"\"\"\u307e\u305a\u4f1d\u64ad\u3055\u305b\u308b\uff08\u30aa\u30da\u30ec\u30fc\u30bf\u304c\u53ef\u63db\u306a\u3089\u5fc5\u8981\u306a\u3044\uff09\"\"\"\n        #self.thrust(L)\n        #self.thrust(R-1)\n        #\u767b\u308a\u306a\u304c\u3089\u95a2\u6570 f \u3092\u5408\u6210\n        while L < R:\n            if R & 1:\n                R -= 1\n                self.laz[R] = self.compose(self.laz[R],f)\n            if L & 1:\n                self.laz[L] = self.compose(self.laz[L],f)\n                L += 1\n            L >>= 1; R >>= 1\n    \n    # values[k] \u3092\u53d6\u5f97\u3002\n    def point_get(self, k):\n        res = self.val[k]\n        k += self.N0\n        while k:\n            if self.laz[k] != self.ID_M:\n                res = self.funcval(res, self.laz[k])\n            k //= 2\n        return res\n    \n    # values[k] = x \u4ee3\u5165\u3059\u308b\n    def point_set(self, k): \n        self.thrust(k+self.N0)\n        self.val[k] = x\n\n\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\n#x,y = map(int,readline().split())\nfrom collections import deque\ns = input()\nlst = [deque() for _ in range(26)]\nfor i,c in enumerate(s):\n    lst[ord(c)-97].append(i)\n\nc = 0\nfor l in lst:\n    if len(l)%2==1: c += 1\nif c >= 2:\n    print((-1))\n    return\n\nn = len(s)\nL = 0\nR = n-1\nfrom operator import add\nseg = segment_tree_dual(n, compose=add, funcval=add, ID_M=0)\nseg.build([0]*n)\n\nans = 0\nINF = 1<<30\nfor i in range(n//2):\n    I = -1\n    v = INF\n    for idx in range(26):\n        if lst[idx]:\n            a,b = lst[idx][0], lst[idx][-1]\n            d = a+seg.point_get(a)-i + n-1-i-(b+seg.point_get(b))\n            #print(i,d,lst[idx],a+seg.point_get(a),(b+seg.point_get(b)))\n            if d < v:\n                I = idx\n                v = d\n    #print(v,I,lst[I],a,seg.point_get(a),n-1,(b+seg.point_get(b)))\n    seg.update(0,lst[I].popleft(),1)\n    seg.update(lst[I].pop(),n-1,-1)\n    ans += v\n\nprint(ans)\n\n\n\n\n", "import sys\nclass BIT():\n    def __init__(self,number):\n        self.n=number\n        self.list=[0]*(number+1)\n        \n    def add(self,i,x):#ith added x  1indexed\n        while i<=self.n:\n            self.list[i]+=x\n            i+=i&-i\n            \n    def search(self,i):#1-i sum\n        s=0\n        while i>0:\n            s+=self.list[i]\n            i-=i&-i\n        return s\n    \n    def suma(self,i,j):#i,i+1,..j sum\n        return self.search(j)-self.search(i-1)\n#from collections import defaultdict\nS=input()\nN = len(S)\nL = 26\na = ord('a')\nd = [[] for i in range(L)]\nfor i in range(N):\n    s=ord(S[i])-a\n    d[s].append(i)\nflag=0\nfor i in range(L):\n    if len(d[i])%2==1:\n        flag+=1\nif flag>1:\n    print(-1)\n    return\nSuc=[-1]*N\npairs=[]\nfor i in range(L):\n    T=len(d[i])\n    for s in range((T//2)):\n        li,ri=d[i][s],d[i][-s-1]\n        pairs.append((li,ri))\n    if T%2==1:\n        Suc[d[i][T//2]]=(N//2)+1\npairs.sort()\nfor i, (li,ri) in enumerate(pairs):\n    Suc[li]=i+1\n    Suc[ri]=N-i\nTree=BIT(N+3)\nans=0\nfor i,m in enumerate(Suc):\n    ans+=i-Tree.search(m)\n    Tree.add(m,1)\n#ans+=Tree.search(N+1)\nprint(ans)", "s = input()\ncnt = [0] * 26\nn = len(s)\n\nfor c in s:\n    cnt[ord(c) - ord('a')] += 1\n\nodd = -1\nfor i in range(26):\n    if cnt[i] % 2 == 1:\n        if odd != -1:\n            print(-1)\n            return\n        odd = i\n\ncnt2 = [[] for i in range(26)]\nnums = []\nleft = 0\nfor i in range(len(s)):\n    c = s[i]\n    ind = ord(c) - ord('a')\n    if len(cnt2[ind]) * 2 + 1 == cnt[ind]:\n        cnt2[ind].append((n-1)//2)\n        nums.append((n-1)//2)\n    elif len(cnt2[ind]) <= (cnt[ind]-1)//2:\n        cnt2[ind].append(left)\n        nums.append(left)\n        left += 1\n    else:\n        num = n - 1 - cnt2[ind][cnt[ind]-1-len(cnt2[ind])]\n        cnt2[ind].append(num)\n        nums.append(num)\n\nans = 0\n#print(nums)\nbit = [0] * (n+1)\ndef add(x):\n    nonlocal bit\n    x += 1\n    while x <= n:\n        bit[x] += 1\n        x += x & -x\n\ndef sum(x):\n    x += 1\n    res = 0\n    while x:\n        res += bit[x]\n        x -= x & -x\n    return res\nfor num in nums[::-1]:\n    ans += sum(num)\n    add(num)\n\nprint(ans)", "#!/usr/bin/env python3\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * n\n\n    def sum(self, i):\n        s = 0\n        i -= 1\n        while i >= 0:\n            s += self.tree[i]\n            i = (i & (i + 1)) - 1\n        return s\n\n    def add(self, i, x):\n        while i < self.size:\n            self.tree[i] += x\n            i |= i + 1\n\na = ord('a')\n\ndef make_index(s):\n\n    index = [[] for _ in range(26)]\n    for i, ch in enumerate(s):\n        index[ord(ch) - a].append(i)\n\n    return index\n\ndef solve(s):\n\n    n = len(s)\n    index = make_index(s)\n\n    odd = None\n    for code, char_pos in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n\n    bit = Bit(n)\n\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n\n    return ans\n\n\ndef main():\n    s = input()\n\n    print((solve(s)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import Counter,defaultdict\n\nclass Bit:\n  def __init__(self,n):\n    self.size = n\n    self.tree = [0]*(n+1)\n \n  def sum(self,i):\n    s = 0\n    while i > 0:\n      s += self.tree[i]\n      i -= i & -i\n    return s\n\n  def add(self,i,x):\n    while i <= self.size:\n      self.tree[i] += x\n      i += i & -i\n\ns = input()\nn = len(s)\nc = Counter(s)\nflg = 0\nif n%2 == 0:\n  for i in c.values():\n    if i%2:\n      print(-1)\n      return\nelse:\n  for st,i in c.items():\n    if i%2 and flg:\n      print(-1)\n      return\n    elif i%2:\n      flg = 1\nans = 0\nfstr = []\nlstr = []\ndc = defaultdict(int)\nptr = 0\nfor i in range(n):\n  si = s[i]\n  dc[si] += 1\n  cnt = dc[si]\n  if c[si]%2:\n    if cnt*2-1 == c[si]:\n      ans += i-ptr\n      continue\n  if cnt <= c[si]//2:\n    ans += i-ptr\n    ptr += 1\n    fstr.append(si)\n  else:\n    lstr.append(si)\nlstr = lstr[::-1]\nn //= 2\nperm = [0]*n\nfdc = defaultdict(list)\nldc = defaultdict(int)\nlcnt = 0\nfor i in range(n):\n  fi = fstr[i]\n  fdc[fi].append(i+1)\nfor i in range(n):\n  li = lstr[i]\n  perm[i] = fdc[li][ldc[li]]\n  ldc[li] += 1\nsol = Bit(n+2)\nfor i in range(n):\n  p = perm[i]\n  ans += sol.sum(n+1)-sol.sum(p)\n  sol.add(p,1)\nprint(ans)", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.data = [0] * (size + 1)\n        self.size = size\n\n    # i is exclusive\n    def prefix_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.data[i] += x\n            i += i & -i\n\n    def lower_bound(self, x):\n        if x <= 0:\n            return 0\n        k = 1\n        while k * 2 <= self.size:\n            k *= 2\n        i = 0\n        while k > 0:\n            if i + k <= self.size and self.data[i + k] < x:\n                x -= self.data[i + k]\n                i += k\n            k //= 2\n        return i\n\n\nclass RangeFenwickTree:\n    def __init__(self, size):\n        self.bit0 = FenwickTree(size)\n        self.bit1 = FenwickTree(size)\n\n    # i is exclusive\n    def prefix_sum(self, i):\n        return self.bit0.prefix_sum(i) * (i - 1) + self.bit1.prefix_sum(i)\n\n    def add(self, l, r, x):\n        self.bit0.add(l, x)\n        self.bit0.add(r, -x)\n        self.bit1.add(l, -x * (l - 1))\n        self.bit1.add(r, x * (r - 1))\n\n\nclass FenwickTree2D:\n    def __init__(self, H, W):\n        self.H = H\n        self.W = W\n        self.data = [[0] * (H + 1) for _ in range(W + 1)]\n\n    def add(self, a, b, x):\n        a += 1\n        b += 1\n        i = a\n        while i <= self.H:\n            j = b\n            while j <= self.W:\n                self.data[i][j] += x\n                j += j & -j\n            i += i & -i\n\n    def sum(self, a, b):\n        a += 1\n        b += 1\n        ret = 0\n        i = a\n        while i > 0:\n            j = b\n            while j > 0:\n                ret += self.data[i][j]\n                j -= j & -j\n            i -= i & -i\n        return ret\n\nS = list(map(lambda c: ord(c) - ord('a'), input().rstrip()))\nN = len(S)\nidx = [deque() for _ in range(26)]\nfor i, c in enumerate(S):\n    idx[c].append(i)\nif sum(len(v) % 2 for v in idx) > 1:\n    print(-1)\n    return\nfw = FenwickTree(N + 1)\nfor i in range(1, N + 1):\n    fw.add(i, 1)\nans = 0\nfor i in range(N // 2):\n    min_cost = float('inf')\n    char = -1\n    for c in range(26):\n        if len(idx[c]) <= 1:\n            continue\n        l = idx[c][0]\n        cost = fw.prefix_sum(l + 1) - i\n        r = idx[c][-1]\n        cost += N - i - 1 - fw.prefix_sum(r + 1)\n        if cost < min_cost:\n            min_cost = cost\n            char = c\n    ans += min_cost\n    fw.add(0, 1)\n    fw.add(idx[char].popleft(), -1)\n    fw.add(idx[char].pop(), -1)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque, defaultdict, Counter\n\nS = input().rstrip()\nL = len(S)\n\nc = Counter(S)\nif sum((x&1 for x in c.values())) >= 2:\n    print(-1)\n    return\n\nalphabet_to_pos = defaultdict(deque)\n\nfor i,x in enumerate(S,1):\n    alphabet_to_pos[x].append(i)\n\nafter = [None] * len(S)\nn = 0\nfor i,x in enumerate(S,1):\n    p = alphabet_to_pos[x]\n    if not p:\n        continue\n    if len(p) == 1:\n        p.pop()\n        after[L//2] = i\n        continue\n    p.popleft()\n    j = p.pop()\n    after[n] = i\n    after[L - n - 1] = j\n    n += 1\n\ndef BIT_update(tree,x):\n    while x <= L:\n        tree[x] += 1\n        x += x & (-x)\n\ndef BIT_sum(tree,x):\n    s = 0\n    while x:\n        s += tree[x]\n        x -= x & (-x)\n    return s\n\nanswer = 0\ntree = [0] * (L+1)\nfor i,x in enumerate(after):\n    answer += i - BIT_sum(tree,x)\n    BIT_update(tree,x)\n\nprint(answer)", "from string import ascii_lowercase\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\ndef solve(s):\n    indices = {c: [] for c in ascii_lowercase}\n    for i, c in enumerate(s):\n        indices[c].append(i)\n\n    n = len(s)\n    center = n // 2\n    bubbles = [-1] * n\n    odd_flag = False\n    lefts, rights = [], []\n    for c, ids in list(indices.items()):\n        cnt = len(ids)\n        if cnt & 1:\n            if odd_flag:\n                return -1\n            odd_flag = True\n            bubbles[ids[cnt // 2]] = center + 1\n        for i in range(cnt // 2):\n            li, ri = ids[i], ids[-i - 1]\n            if li < center:\n                lefts.append((li, ri))\n            else:\n                rights.append((li, ri))\n    lefts.sort()\n    rights.sort()\n    r_itr = iter(rights)\n    for i, (li, ri) in enumerate(lefts):\n        bubbles[li] = i + 1\n        bubbles[ri] = n - i\n    for i in range(len(lefts), center):\n        li, ri = next(r_itr)\n        bubbles[li] = i + 1\n        bubbles[ri] = n - i\n\n    ans = 0\n    bit = Bit(n)\n    for i, m in enumerate(bubbles):\n        ans += i - bit.sum(m)\n        bit.add(m, 1)\n    return ans\n\n\nprint((solve(input())))\n", "from collections import Counter\nclass BIT:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n \n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\nS = input()\nN = len(S)\n\ncnt = 0\nSC = Counter(S)\nfor v in SC.values():\n    if v % 2:\n        cnt += 1\nif cnt > 1:\n    print(-1)\n    return\n\ngeta = 10**9+7\nT = [None]*N\ntable = Counter()\nidx = dict()\nctr = 0\nfor i, s in enumerate(S):\n    table[s] += 1\n    if table[s] <= SC[s]//2: \n        T[i] = ctr\n        idx[ord(s)*geta + table[s]] = ctr\n        ctr += 1\n        continue\n    if table[s] > (1+SC[s])//2:\n        T[i] = N - 1 - idx[ord(s)*geta+(SC[s] + 1 - table[s])]\n        continue\n    if SC[s] % 2 and table[s] == (SC[s]+1)//2:\n        T[i] = (N-1)//2\n        continue\nTr = [None]*N\nfor i, v in enumerate(T):\n    Tr[v] = i\nB = BIT(N)\nans = 0\nfor tr in Tr[::-1]:\n    ans += B.sum(tr + 1)\n    B.add(tr + 1, 1)\nprint(ans)", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nclass BIT():#1-indexed\n\tdef __init__(self, size):\n\t\tself.table = [0 for _ in range(size+2)]\n\t\tself.size = size\n\n\tdef Sum(self, i):#1\u304b\u3089i\u307e\u3067\u306e\u548c\n\t\ts = 0\n\t\twhile i > 0:\n\t\t\ts += self.table[i]\n\t\t\ti -= (i & -i)\n\t\treturn s\n\n\tdef PointAdd(self, i, x):#\n\t\twhile i <= self.size:\n\t\t\tself.table[i] += x\n\t\t\ti += (i & -i)\n\t\treturn\n\ns = input()\nn = len(s)\na = [-1 for _ in range(n)]\nch = [[] for _ in range(26)]\nfor i in range(n):\n\tch[ord(s[i])-97].append(i)\nif sum([len(x)%2 == 1 for x in ch]) > 1:\n\tprint(-1)\n\treturn\n\nfor i, c in enumerate(ch):\n\ttmp = i\n\tl = len(c)\n\tfor j in range(l//2):\n\t\ta[c[j]] = tmp\n\t\ta[c[l-j-1]] = tmp\n\t\ttmp += 26\n#print(a)\n\nformer, latter = 0, 0\nhalf = False\nd = dict()\ncur = 0\nbubble = []\n\nans = 0\n\nfor x in a:\n\tif x >= 0:\n\t\tif x not in d:\n\t\t\td[x] = cur\n\t\t\tcur += 1\n\t\t\tformer += 1\n\t\t\tans += latter + half\n\t\telse:\n\t\t\tbubble.append(d[x])\n\t\t\tlatter += 1\n\t\t\tif n%2 == 1 and not half:\n\t\t\t\tans += 1\n\telse:\n\t\thalf = True\n\nbit = BIT(n//2+2)\nfor b in bubble:\n\tans += bit.Sum(b+1)\n\tbit.PointAdd(b+1, 1)\n\nprint(ans)", "\nimport sys\nfrom collections import deque, defaultdict\nimport copy\nimport bisect\nsys.setrecursionlimit(10 ** 9)\nimport math\nimport heapq\nfrom itertools import product, permutations,combinations\nimport fractions\n\nimport sys\ndef input():\n\treturn sys.stdin.readline().strip()\n\nS = input()\n\nalpha = defaultdict(int)\nN = len(S)\nfor i in range(N):\n\talpha[S[i]] += 1\n\nnum = 0\nfor n in alpha:\n\tif alpha[n] % 2 == 1:\n\t\tnum += 1\n\nif num >= 2:\n\tprint((-1))\n\treturn\n\nalpha_num = defaultdict(deque)\nfor i in range(N):\n\talpha_num[S[i]].append(i)\n\nloc_list = [-1]*N\nnum = 0\nfor i in range(N):\n\tif len(alpha_num[S[i]]) >= 2:\n\t\tx = alpha_num[S[i]].popleft()\n\t\ty = alpha_num[S[i]].pop()\n\t\tloc_list[x] = num\n\t\tloc_list[y] = N - 1 - num\n\t\tnum += 1\n\telif len(alpha_num[S[i]]) == 1:\n\t\tx = alpha_num[S[i]].popleft()\n\t\tloc_list[x] = N // 2\n\nclass Bit:\n\tdef __init__(self, n):\n\t\tself.size = n\n\t\tself.tree = [0] * (n + 1)\n\n\tdef sum(self, i):\n\t\ts = 0\n\t\twhile i > 0:\n\t\t\ts += self.tree[i]\n\t\t\ti -= i & -i\n\t\treturn s\n\n\tdef add(self, i, x):\n\t\twhile i <= self.size:\n\t\t\tself.tree[i] += x\n\t\t\ti += i & -i\n\n\nbit = Bit(N)\nans = 0\n\n\n\nfor i, p in enumerate(loc_list):\n\tbit.add(p + 1, 1)\n\tans += i + 1 - bit.sum(p + 1)\n\nprint(ans)\n", "from collections import Counter, defaultdict\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\nS = input()\nN = len(S)\nC = Counter(S)\nif len(S) % 2 == 0:\n    for x in list(C.values()):\n        if x % 2 == 1:\n            print((-1))\n            return\nelse:\n    cnt = 0\n    for x in list(C.values()):\n        if x % 2 == 1:\n            cnt += 1\n        if cnt > 1:\n            print((-1))\n            return\n\ncnt1 = 1\ncnt2 = (N + 1) // 2 + 1\ncnt_char = defaultdict(int)\nseq = [0] * N\nS1 = []\nS2 = []\nfor i, s in enumerate(S):\n    cnt_char[s] += 1\n    if C[s] % 2 == 1:\n        if cnt_char[s] == C[s] // 2 + 1:\n            seq[i] = N // 2 + 1\n            continue\n    if cnt_char[s] <= C[s] // 2:\n        seq[i] = cnt1\n        cnt1 += 1\n        S1.append(s)\n    else:\n        seq[i] = cnt2\n        cnt2 += 1\n        S2.append(s)\nS2.reverse()\n\nans = 0\nseq.reverse()\nbit1 = Bit(N+1)\nfor i in range(N):\n    ans += bit1.sum(seq[i])\n    bit1.add(seq[i], 1)\n\nchar2idx = defaultdict(list)\nfor i, s1 in enumerate(S1):\n    char2idx[s1].append(i+1)\nfor x in list(char2idx.keys()):\n    char2idx[x].reverse()\n\nseq_ = []\nfor i, s2 in enumerate(S2):\n    seq_.append(char2idx[s2].pop())\n\nbit2 = Bit(N+1)\nseq_.reverse()\nfor i in range(len(seq_)):\n    ans += bit2.sum(seq_[i])\n    bit2.add(seq_[i], 1)\n\nprint(ans)\n", "from collections import defaultdict\n\nclass BIT():\n    def __init__(self,n):\n        self.size=n\n        self.bit=[0]*(n+1)\n    def add(self,i,x):\n        while i<=self.size:\n            self.bit[i]+=x\n            i+=i&-i\n    def sum(self,i):\n        s=0\n        while i>0:\n            s+=self.bit[i]\n            i-=i&-i\n        return s\n\ns=input()\nn=len(s)\nidx=defaultdict(list)\nfor i,c in enumerate(s):\n    idx[c].append(i)\nctr=n//2\nB=[0]*n\nflag=False\nP=[]\nfor c,I in idx.items():\n    cnt=len(I)\n    if cnt%2:\n        if flag:\n            print(-1)\n            return\n        flag=True\n        B[I[cnt//2]]=ctr+1\n    for i in range(cnt//2):\n        l,r=I[i],I[-i-1]\n        P.append((l,r))\nP.sort()\nfor i,(l,r) in enumerate(P):\n    B[l],B[r]=i+1,n-i\nans=0\nbit=BIT(n)\nfor i,b in enumerate(B):\n    ans+=i-bit.sum(b)\n    bit.add(b,1)\nprint(ans)", "class BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, val):\n        \"\"\"i\u756a\u76ee\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        i = i + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n\n    def get_sum(self, l, r):\n        \"\"\"\u533a\u9593[l, r)\u306e\u548c\u3092\u6c42\u3081\u308b\"\"\"\n        return self._sum(r) - self._sum(l)\n \n\ndef swap_time(array0, array1):\n    n = len(array0)\n    memo = {}\n    for i in range(n)[::-1]:\n        if array0[i] not in memo:\n            memo[array0[i]] = []\n        memo[array0[i]].append(i)\n    res = []\n    for val in array1:\n        ind = memo[val].pop()\n        res.append(ind)\n    \n    bit = BIT(n)\n    ans = 0\n    for i in range(n):\n        bit.add(res[i], 1)\n        ans += bit.get_sum(res[i] + 1, n)\n    return ans\n  \n  \n\nALPH = \"abcdefghijklmnopqrstuvwxyz\"\ns = input()\n\ncnt_memo = {}\nfor char in s:\n    if char not in cnt_memo:\n        cnt_memo[char] = 1\n    else:\n        cnt_memo[char] += 1\n\nodd = \"\"\nfor char in cnt_memo:\n    if cnt_memo[char] % 2 == 1:\n        if odd:\n            print(-1)\n            return\n        else:\n            odd = char\n            cnt_memo[char] -= 1\n            cnt_memo[char] //= 2\n    else:\n        cnt_memo[char] //= 2\n\nleft = []\nmid = []\nif odd:\n    mid = [odd]\nright = []\nfor char in s:\n    if odd == char and cnt_memo[char] == 0:\n        odd = \"\"\n    elif cnt_memo[char] != 0:\n        left.append(char)\n        cnt_memo[char] -= 1\n    else:\n        right.append(char)\n\nans = 0\nans += swap_time(left + mid + right, list(s))\nans += swap_time(left, right[::-1])\nprint(ans)", "from string import ascii_lowercase\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\ndef solve(s):\n    indices = {c: [] for c in ascii_lowercase}\n    for i, c in enumerate(s):\n        indices[c].append(i)\n\n    n = len(s)\n    center = n // 2\n    bubbles = [-1] * n\n    odd_flag = False\n    pairs = []\n    for c, ids in list(indices.items()):\n        cnt = len(ids)\n        if cnt & 1:\n            if odd_flag:\n                return -1\n            odd_flag = True\n            bubbles[ids[cnt // 2]] = center + 1\n        for i in range(cnt // 2):\n            li, ri = ids[i], ids[-i - 1]\n            pairs.append((li, ri))\n    pairs.sort()\n    for i, (li, ri) in enumerate(pairs):\n        bubbles[li] = i + 1\n        bubbles[ri] = n - i\n\n    ans = 0\n    bit = Bit(n)\n    for i, m in enumerate(bubbles):\n        ans += i - bit.sum(m)\n        bit.add(m, 1)\n    return ans\n\n\nprint((solve(input())))\n", "from collections import defaultdict, deque\nfrom heapq import heappop, heappush\nfrom string import ascii_lowercase as abc\n\nclass BIT:\n    def __init__(self, N):\n        # N\u306f\u5165\u308c\u305f\u3044\u8981\u7d20\u306e\u500b\u6570\n        self.size = 2 ** (int.bit_length(N+1))\n        self.tree = [0]*(self.size + 1)\n \n    def sum(self, i):\n        res = 0\n        while i:\n            res += self.tree[i]\n            i -= (i & -(i))\n        return res\n \n    def add(self, i, x):\n        if i == 0:\n            return\n        while i <= self.size:\n            self.tree[i] += x\n            i += (i & -(i))\n\n\nD = [deque() for _ in range(26)]\nS = input()\nN = len(S)\n\nfor i in range(len(S)):\n    D[ord(S[i])-97].append(i)\n\nM = [len(D[i])%2 for i in range(26)]\nif sum(M) >= 2:\n    print(-1)\n    return\n\nodd = sum(M)\n\nQ = []\nfor c in range(26):\n    if len(D[c]) >= 2:\n        l = D[c].popleft()\n        r = D[c].pop()\n        a = l * 1\n        b = N - 1 - r\n        if b < a:\n            a, b = b, a\n        heappush(Q, (a, b, l, r, c))\n\nT = [0]*(N//2)\nfor i in range(N//2):\n    _, _, l, r, c = heappop(Q)\n    T[i] = c\n\n    if len(D[c]) >= 2:\n        l = D[c].popleft()\n        r = D[c].pop()\n        a = l * 1\n        b = N - 1 - r\n        if b < a:\n            a, b = b, a\n        heappush(Q, (a, b, l, r, c))\n\nL = [[] for i in range(26)]\n\nfor i in range(N//2):\n    L[T[i]].append(N-1-i)\n\nif odd:\n    L[M.index(1)].append(N//2)\n\nfor i in range(N//2-1, -1, -1):\n    L[T[i]].append(i)\n\nbit = BIT(N)\nans = 0\nfor i in range(N):\n    j = L[ord(S[i]) - 97].pop()\n    ans += i - bit.sum(j+1)\n    bit.add(j+1, 1)\nprint(ans)", "def f(x):\n    return ord(x)-ord(\"a\")\n\nclass Bit:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0]*(n+1)\n        self.el = [0]*(n+1)\n        self.depth = n.bit_length() - 1\n\n    def sum(self, i):\n        \"\"\" \u533a\u9593[0,i) \u306e\u7dcf\u548c\u3092\u6c42\u3081\u308b \"\"\"\n        s = 0\n        i -= 1\n        while i >= 0:\n            s += self.tree[i]\n            i = (i & (i + 1) )- 1\n        return s\n\n    def add(self, i, x):\n        self.el[i] += x\n        while i < self.n:\n            self.tree[i] += x\n            i |= i + 1\n\nclass BitSet2:\n    \"\"\" \u5ea7\u6a19\u5727\u7e2e\u304c\u5fc5\u8981\u306a\u5834\u5408 \"\"\"\n    def __init__(self, data, A=[]):\n        \"\"\" BitSet\u306b\u5165\u308a\u5f97\u308b\u5024\u3092\u5148\u8aad\u307f\u3057\u305f\u7269\u3092 data \u306b\u683c\u7d0d \"\"\"\n        self.data = sorted(list(set(data)))\n        self.n = len(self.data)\n        self.p = Bit(self.n + 1)\n        self.size = 0\n        self.flip = 0\n        self.code = {}\n        self.decode = {}\n        for i, b in enumerate(self.data):\n            self.code[b] = i\n            self.decode[i] = b\n        for a in A:\n            self.add(a)\n\n    def add(self,x):\n        self.p.add(self.code[x], 1)\n        self.size += 1\n        self.flip += self.size - self.p.sum(self.code[x]+1)\n\n    def remove(self,x):\n        self.p.add(x, -1)\n        self.size -= 1\n\n    def flip_counter(self):\n        return self.flip\n\n####################################################################################################\n\nimport sys\ninput = sys.stdin.readline\n\nS=input().rstrip()\nN=len(S)\nP=[[] for _ in range(26)]\nQ=[]\nres=[-1]*N\nfor i, s in enumerate(S):\n    P[f(s)].append(i)\nfor p in P:\n    Np=len(p)\n    for i in range(Np//2):\n        Q.append((p[Np-1-i]-p[i],p[i],p[Np-1-i]))\n    if len(p)%2:\n        if res[N//2]!=-1 or N%2==0: print(-1); return\n        res[N//2]=p[Np//2]\nQ.sort(reverse=True)\nfor i,q in enumerate(Q):\n    d,x,y=q\n    res[i]=x\n    res[N-1-i]=y\n\nBS = BitSet2(res,res)\nprint(BS.flip_counter())", "from collections import Counter\n\n\nclass BIT():\n    \"\"\"\u4e00\u70b9\u52a0\u7b97\u3001\u533a\u9593\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\n    add: i\u756a\u76ee\u306bval\u3092\u52a0\u3048\u308b\n    get_sum: \u533a\u9593[l, r)\u306e\u548c\u3092\u6c42\u3081\u308b\n    i, l, r\u306f0-indexed\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, val):\n        \"\"\"i\u756a\u76ee\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        i = i + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n\n    def get_sum(self, l, r):\n        \"\"\"\u533a\u9593[l, r)\u306e\u548c\u3092\u6c42\u3081\u308b\"\"\"\n        return self._sum(r) - self._sum(l)\n\n\ndef min_swap_times(s, t):\n    if Counter(s) != Counter(t):\n        return -1\n\n    n = len(s)\n    memo = {}\n    for i in range(n):\n        if s[i] not in memo:\n            memo[s[i]] = [i]\n        else:\n            memo[s[i]].append(i)\n    for i in memo:\n        memo[i] = memo[i][::-1]\n\n    array = [0] * n\n    for i in range(n):\n        array[i] = memo[t[i]][-1]\n        del(memo[t[i]][-1])    \n\n    memo = {}\n    for i in range(n):\n        memo[i] = array[i]\n    bit = BIT(n)\n    res = 0\n\n    for i in range(n):\n        bit.add(memo[i], 1)\n        res += bit.get_sum(memo[i] + 1, n)\n    return res\n\n\nimport copy\n\ns = input()\nn = len(s)\nmemo = {}\nfor i in range(n):\n    if s[i] not in memo:\n        memo[s[i]] = 1\n    else:\n        memo[s[i]] += 1\n\nodd_cnt = 0\nfor i in memo:\n    odd_cnt += memo[i] % 2\nif odd_cnt > 1:\n    print(-1)\n    return\n\nleft = []\nright = []\n\nmemo2 = copy.deepcopy(memo)\nans_cnt = 0\nword = \"\"\nfor i in range(n):\n    if memo2[s[i]]*2 > memo[s[i]] + 1:\n        memo2[s[i]] -= 1\n        ans_cnt += i - len(left)\n        left.append(s[i])\n    elif memo2[s[i]]*2 == memo[s[i]] + 1:\n        word = s[i]\n        memo2[s[i]] -= 1\n        right.append(s[i])\n    else:\n        memo2[s[i]] -= 1\n        right.append(s[i])\n \nif word != \"\":\n    for i in range(len(right)):\n        if right[i] == word:\n            ans_cnt += i\n            del(right[i])\n            break\nright = right[::-1]\ntmp = min_swap_times(left, right)\nif tmp == -1:\n    print(-1)\nelse:\n    print(ans_cnt + tmp)", "def main():\n    from collections import deque\n\n    # \u4e00\u70b9\u66f4\u65b0\u30fb\u4e00\u70b9\u53d6\u5f97\u306e\u52a0\u6cd5BIT\n    class BIT():\n        def __init__(self, n):\n            self.n = n\n            self.maxbit = 2**(len(bin(n))-3)\n            self.bit = [0]*(n+1)\n            self.allsum = 0\n\n        # \u521d\u671f\u5316\u3059\u308b\n        def make_bit(self, a):\n            n, bit = self.n, self.bit\n            for i, j in enumerate(a):\n                x = i+1\n                self.allsum += j\n                while x < n+1:\n                    bit[x] += j\n                    x += x & (-x)\n\n        # \u4f4d\u7f6ei\u306b\u5024v\u3092\u8db3\u3059\n        def add(self, i, v):\n            x, n, bit = i+1, self.n, self.bit\n            self.allsum += v\n            while x < n+1:\n                bit[x] += v\n                x += x & (-x)\n\n        # \u4f4d\u7f6e0\u304b\u3089i\u307e\u3067\u306e\u548c(sum(bit[:i]))\u3092\u8a08\u7b97\u3059\u308b\n        def sum(self, i):\n            ret, x, bit = 0, i, self.bit\n            while x > 0:\n                ret += bit[x]\n                x -= x & (-x)\n            return ret\n\n        # \u4f4d\u7f6ei\u304b\u3089j\u307e\u3067\u306e\u548c(sum(bit[i:j]))\u3092\u8a08\u7b97\u3059\u308b\n        def sum_range(self, i, j):\n            return self.sum(j) - self.sum(i)\n\n        # \u548c\u304cw\u4ee5\u4e0a\u3068\u306a\u308b\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u6c42\u3081\u308b\n        def lowerbound(self, w):\n            if w <= 0:\n                return 0\n            x, k, n, bit = 0, self.maxbit, self.n, self.bit\n            while k:\n                if x+k <= n and bit[x+k] < w:\n                    w -= bit[x+k]\n                    x += k\n                k //= 2\n            return x\n\n    s = input()\n    n = len(s)\n    alpha, center = 'abcdefghijklmnopqrstuvwxyz', \"\"\n    counter, must, deque_dict = dict(), dict(), dict()\n    for c in alpha:\n        counter[c] = 0\n        deque_dict[c] = deque([])\n    for c in s:\n        counter[c] += 1\n    for i, j in list(counter.items()):\n        must[i] = j//2\n    if n % 2 == 1:\n        for i, j in list(counter.items()):\n            if j % 2 == 1:\n                if center != \"\":\n                    print((-1))\n                    return 0\n                else:\n                    center = i\n    else:\n        for i, j in list(counter.items()):\n            if j % 2 == 1:\n                print((-1))\n                return 0\n    half = []\n    cnt = 0\n    for c in s:\n        if must[c] > 0:\n            must[c] -= 1\n            half.append(c)\n            cnt += 1\n        if cnt == n//2:\n            break\n    half2 = half[::-1]\n    if center != \"\":\n        half.append(center)\n    s2 = half+half2\n\n    for i in range(n):\n        deque_dict[s[i]].append(i)\n\n    ans = 0\n    s3 = []\n    for c in s2:\n        d = deque_dict[c].popleft()\n        s3.append(d)\n\n    bit = BIT(n)\n\n    for i in s3:\n        ans += bit.sum_range(i, n)\n        bit.add(i, 1)\n    print(ans)\n\n\nmain()\n", "*S, = map(ord, input())\nN = len(S)\nL = 26\nca = ord('a')\nd = [[] for i in range(L)]\nfor i, c in enumerate(S):\n    d[c-ca].append(i)\n\nodd = 0\nfor v in d:\n    if len(v) % 2:\n        odd += 1\nif not odd <= N%2:\n    print(-1)\n    return\n\ndata = [0]*(N+1)\ndef add(k, x):\n    while k <= N:\n        data[k] += x\n        k += k & -k\ndef get(k):\n    s = 0\n    while k:\n        s += data[k]\n        k -= k & -k\n    return s\n\nM = [None]*N\nfor v in d:\n    vl = len(v)\n    for i in range(vl):\n        if not i <= vl-1-i:\n            break\n        p = v[i]; q = v[-i-1]\n        M[p] = q\n        M[q] = p\ncnt = 0\nB = [0]*N\nfor i in range(N-1, -1, -1):\n    if M[i] <= i:\n        B[i] = B[M[i]] = cnt\n        cnt += 1\n\ncur = -1\nans = 0\nfor i in range(N-1, -1, -1):\n    if cur < B[i]:\n        cur = B[i]\n        if M[i] == i:\n            ans += N//2 - cur\n        else:\n            ans += M[i] - get(M[i]+1)\n        add(M[i]+1, 1)\nprint(ans)", "def count_inversions(L):\n  def helper(A,B):\n    lA,lB = len(A),len(B)\n    if lA == 0:\n      return B,0\n    elif lB == 0:\n      return A,0\n    \n    A,c1 = helper(A[:lA//2],A[lA//2:])\n    B,c2 = helper(B[:lB//2],B[lB//2:])\n    cnt = c1+c2\n    i = 0\n    j = 0\n\n    C = [None]*(lA+lB)\n    while i < lA and j < lB:\n      if A[i] > B[j]:\n        cnt += lA-i\n        C[i+j] = B[j]\n        j += 1\n      else:\n        C[i+j] = A[i]\n        i += 1\n\n    if i < lA:\n      C[i+j:] = A[i:]\n    else:\n      C[i+j:] = B[j:]\n\n    return C,cnt\n\n  return helper(L[:len(L)//2],L[len(L)//2:])[1]\n\nfrom collections import deque\n\nALPHABETS = 26\n\nindices = [deque() for _ in range(26)]\nS = list([ord(c)-ord('a') for c in input()])\nfor i,c in enumerate(S):\n  indices[c] += [i]\n\nodd = None\nfor c,l in enumerate(indices):\n  if len(l)%2 == 1:\n    if odd is None:\n      odd = c\n    else:\n      odd = -1\n      break\n\nif odd == -1:\n  print((-1))\n  return\n\ntarget = [None]*len(S)\nassigned = [False]*len(S)\nif odd is not None:\n  l = list(indices[odd])\n  i = l[len(l)//2]\n  target[len(target)//2] = i\n  assigned[i] = True\n  l = deque(l[:len(l)//2] + l[len(l)//2+1:])\n\nj = 0\nfor i in range(len(S)//2):\n  while assigned[j]:\n    j += 1\n\n  l = indices[S[j]]\n  a = l.popleft()\n  b = l.pop()\n  assert a == j\n  target[i] = a\n  target[len(S)-i-1] = b\n  assigned[a] = True\n  assigned[b] = True\n  \nprint((count_inversions(target)))\n", "from collections import defaultdict\n\na = list(map(ord, input()))\nN = len(a)\nLa = ord(\"a\")\n\ndata = [0]*(N+1)\n\n\nd = [[] for i in range(26)]\nfor i , c in enumerate(a):\n    d[c-La].append(i)\n\nodd = 0\nfor v in d:\n    if len(v) % 2:\n        odd += 1\nif not odd <= N%2:\n    print((-1))\n    return\n\ndata = [0]*(N+1)\ndef add(k, x):\n    while k <= N:\n        data[k] += x\n        k += k & -k\ndef get(k):\n    s = 0\n    while k:\n        s += data[k]\n        k -= k & -k\n    return s\n\nM = [None]*N\nfor v in d:\n    vl = len(v)\n    for i in range(vl):\n        if not i <= vl-1-i:\n            break\n        p = v[i]; q = v[-i-1]\n        M[p] = q\n        M[q] = p\ncnt = 0\nB = [0]*N\nfor i in range(N-1, -1, -1):\n    if M[i] <= i:\n        B[i] = B[M[i]] = cnt\n        cnt += 1\n\ncur = -1\nans = 0\nfor i in range(N-1, -1, -1):\n\n    if cur < B[i]:\n        cur = B[i]\n        if M[i] == i:\n            ans += N//2 - cur\n        else:\n            ans += M[i] - get(M[i]+1)\n        add(M[i]+1, 1)\nprint(ans)\n"]
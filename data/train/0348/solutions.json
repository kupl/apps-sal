["import sys\nclass Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        ignore=0\n        not_ignore=0\n        res=-sys.maxsize\n        for i in arr:\n            if i>=0:\n                ignore+=i\n                not_ignore+=i\n            else:\n                if ignore==0:\n                    ignore+=i\n                else:\n                    ignore=max(ignore+i,not_ignore)\n                not_ignore+=i\n            res=max(res,ignore)\n            if ignore<0:\n                ignore=0\n            if not_ignore<0:\n                not_ignore=0\n        return res\n", "class Solution(object):\n    def maximumSum(self, arr):\n        dp, res = [arr[0], 0], arr[0]\n        for i in range(1, len(arr)):\n            dp[1] = max(dp[0], dp[1]+arr[i])\n            dp[0] = max(arr[i], arr[i]+dp[0])\n            res = max(res, dp[0], dp[1])\n        return res", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        max_ending_here0 = n * [arr[0]]  # no deletion\n        max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n        for i in range(1, n):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n            max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n            if i >= 2:\n                max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n                \n        return max(max_ending_here1)", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:        \n        if not arr:\n            return None\n        \n        max_sum = [0] * len(arr)\n        max_sum_one_del = [0] * len(arr)\n        \n        max_sum[0] = arr[0]\n        max_sum_one_del[0] = arr[0]\n        \n        for i in range(1, len(arr)):\n            max_sum[i] = max(max_sum[i-1]+arr[i], arr[i])\n            max_sum_one_del[i] = max(max_sum_one_del[i-1]+arr[i], arr[i])\n            if i > 1:\n                max_sum_one_del[i] = max(max_sum[i-2]+arr[i], max_sum_one_del[i])\n                \n        # print(max_sum)\n        # print(max_sum_one_del)\n            \n        return max(max_sum_one_del)\n            \n        \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        max_ending_here0 = n * [arr[0]]  # no deletion\n        max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n        for i in range(1, n):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n            max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n            \n            if i >= 2:\n                # first arg: the case where deletion occurs before i-1, or no deletion\n                # second arg: the case where deletion is at i\n                max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n                \n        return max(max_ending_here1)", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        M = max(arr)\n        if M<0:\n            return M\n        \n        kad = arr[:]\n        curr = 0\n        for i in range(len(arr)):\n            kad[i] = max(0, curr+kad[i])\n            curr = kad[i]\n        \n        curr = 0\n        revkad = arr[:]\n        for i in range(len(arr)-1,-1,-1):\n            revkad[i] = max(0, curr+revkad[i])\n            curr = revkad[i]\n        \n        ans = max(kad)\n        for i in range(1,len(arr)-1):\n            ans = max(ans, kad[i-1]+revkad[i+1])\n        \n        \n        return ans", "class Solution:\n     def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        max_ending_here0 = n * [arr[0]]  # no deletion\n        max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n        for i in range(1, n):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n            max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n            if i >= 2:\n                max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n        return max(max_ending_here1)\n            \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        neg = []\n        for i in range(len(arr)):\n            if(arr[i]<0):\n                neg.append(i)\n        if(len(neg) == 0):\n            return(sum(arr))\n        if(len(neg) == len(arr) ):\n            return max(arr)\n        x1 = [0]*(len(neg))\n        x2 = [0]*(len(neg))\n        x1[0] = sum(arr[:neg[0]])\n        x2[-1] = sum(arr[neg[-1]+1:])\n        for j in range(1, len(neg)):\n            for k in range(neg[j-1]+1, neg[j]):\n                x1[j]+=arr[k]\n            if(x1[j-1]+arr[neg[j-1]] > 0):\n                x1[j]+=(x1[j-1]+arr[neg[j-1]])\n\n        for j in range(len(neg)-2,-1,-1):\n            for k in range(neg[j]+1,neg[j+1]):\n                x2[j]+=arr[k]\n            if(x2[j+1]+arr[neg[j+1]] > 0):\n                x2[j]+=(x2[j+1]+arr[neg[j+1]])\n        m = arr[0]\n        for i in range(len(x1)):\n            m = max(m, x1[i]+x2[i])\n        return m", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        max_ending_here0 = n * [arr[0]]  # no deletion\n        max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n        \n        for i in range(1, n):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n            max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n            \n            if i >= 2:\n                # first arg: the case where deletion occurs before i-1, or no deletion\n                # second arg: the case where deletion is at i\n                max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n                \n        return max(max_ending_here1)", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return arr[0]\n        bestFromS = [arr[0]]\n        for i in range(1, len(arr)):\n            bestFromS.append(max(arr[i], arr[i] + bestFromS[i - 1]))\n\n        bestFromE = [0] * len(arr)\n        bestFromE[len(arr) - 1] = arr[len(arr) - 1]\n        for i in range(len(arr) - 2, -1, -1):\n            bestFromE[i] = max(bestFromE[i + 1] + arr[i], arr[i])\n        \n        res = max(bestFromS)\n        for i in range(len(arr)):\n            before = 0 if i == 0 else bestFromS[i - 1]\n            after = 0 if (i == len(arr) - 1) else bestFromE[i + 1]\n            res = max(res, before + after)\n        \n        return res       \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        max1: int = arr[0]  # max subarray sum with at most one deletion\n        max0: int = arr[0]  # max subarray sum with NO deletion\n        res: int = arr[0]  # overall max to be returned\n        for a in arr[1:]:\n            max1 = max(max1 + a, max0, a)  # include a, not include a, or start with a\n            max0 = max(max0 + a, a)  # update `max0`\n            res = max(res, max1)  # update overall max\n        return res", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:        \n        if not arr:\n            return None\n        \n        max_sum = [0] * len(arr)\n        max_sum_one_del = [0] * len(arr)\n        \n        max_sum[0] = arr[0]\n        max_sum_one_del[0] = arr[0]\n        \n        for i in range(1, len(arr)):\n            max_sum[i] = max(max_sum[i-1]+arr[i], arr[i])\n            max_sum_one_del[i] = max(max_sum_one_del[i-1]+arr[i], arr[i])\n            if i > 1:\n                max_sum_one_del[i] = max(max_sum[i-2]+arr[i], max_sum_one_del[i])\n                \n        print(max_sum)\n        print(max_sum_one_del)\n            \n        return max(max_sum_one_del)\n            \n        \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        if len(arr) == 1:\n            return arr[0]\n        \n        fw = [arr[0]]\n        bw = [arr[-1]]\n        \n        cur_max = max_so_far = arr[0]\n        for num in arr[1:]:\n            cur_max = max(cur_max + num, num)\n            max_so_far = max(max_so_far, cur_max)\n            fw.append(cur_max)\n        \n        cur_max = arr[-1]\n        for num in arr[:-1][::-1]:\n            cur_max = max(cur_max + num, num)\n            max_so_far = max(max_so_far, cur_max)\n            bw.append(cur_max)\n        bw = bw[::-1]\n        \n        for i in range(1, len(arr) - 1):\n            max_so_far = max(max_so_far, fw[i - 1] + bw[i + 1])\n        return max_so_far", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        ans = -math.inf\n        left = [-1] * n\n        right = [-1] * n\n        for i in range(n):\n            left[i] = max(arr[i], left[i-1] + arr[i]) if i > 0 else arr[i]\n            ans = max(ans, left[i])\n        for i in range(n-1, -1, -1):\n            right[i] = max(arr[i], right[i+1] + arr[i]) if i < n-1 else arr[i]\n            ans = max(ans, right[i])\n        for i in range(1, n-1):\n            ans = max(ans, left[i-1]+right[i+1])\n        return ans\n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return arr[0]\n        dps = [elem for elem in arr] # dps[i] LCS starting at i\n        dpe = [elem for elem in arr] # dpe[i] LCS ending at i\n        dpt = [elem for elem in arr] # dpt[i] = dpe[i-1] + dps[i+1]\n        for i in range(len(arr)):\n            if i != 0:\n                dpe[i] = max(dpe[i],dpe[i]+dpe[i-1])\n                ip = len(arr) - i - 1\n                dps[ip] = max(dps[ip],dps[ip]+dps[ip+1])\n        for i in range(len(arr)):\n            if i != 0 and i != len(arr) - 1:\n                dpt[i] = dpe[i-1] + dps[i+1]\n            elif i == 0:\n                dpt[i] = dps[i+1]\n            else:\n                dpt[i] = dpe[i-1]\n        # print(dps,dpe,dpt)\n        return max(max(dpt),max(dpe),max(dps))", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        s = sum(arr)\n        pref = [0]\n        \n        for arr_i in arr:\n            pref.append(pref[-1]+arr_i)\n        \n        for i in range(1, n+1):\n            pref[i] = min(pref[i], pref[i-1])\n        \n        suf = [0]\n        \n        for arr_i in arr[::-1]:\n            suf.append(suf[-1]+arr_i)\n        \n        for i in range(1, n+1):\n            suf[i] = min(suf[i], suf[i-1])\n        \n        ans = s\n        \n        for i in range(n):\n            if arr[i]<0:\n                if i-1>=0:\n                    ans = max(ans, s-arr[i]-pref[i-1]-suf[n-1-i])\n                if n-2-i>=0:\n                    ans = max(ans, s-arr[i]-pref[i]-suf[n-2-i])\n        \n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        # minimum size is > 1\n        # do two array, positive and negative\n        ans, dp1, dp2, lr, rl = -math.inf, [None] * len(arr), [None] * len(arr), 0, 0\n        for i, val in enumerate(arr): \n            lr, rl = max(lr, 0) + val, max(rl, 0) + arr[len(arr)-1-i]\n            dp1[i], dp2[len(arr)-1-i] = lr, rl\n            ans = max(ans, lr, rl)\n            \n        for i in range(1, len(arr)-1): \n            if arr[i] < 0:\n                ans = max(ans, dp1[i-1] + dp2[i+1])\n        return ans\n                \n    # def maximumSum(self, arr: List[int]) -> int:\n    #     n = len(arr)\n    #     max_ending_here0 = n * [arr[0]]  # no deletion\n    #     max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n    #     for i in range(1, n):\n    #         max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n    #         max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n    #         if i >= 2:\n    #             max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n    #     return max(max_ending_here1)\n            \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        A = arr\n        N = len(A)\n        dp0 = [None] * N  # largest ending here\n        dp1 = [None] * N  # largest starting here\n        \n        cur = A[0]\n        dp0[0] = cur\n        for i in range(1, N):\n            cur = max(cur + A[i], A[i])\n            dp0[i] = cur\n        \n        cur = A[-1]\n        dp1[-1] = cur\n        for i in range(N-2, -1, -1):\n            cur = max(cur + A[i], A[i])\n            dp1[i] = cur\n        \n        ans = max(dp0)\n        for i, x in enumerate(A):\n            if i+2 < N:\n                ans = max(ans, dp0[i] + dp1[i+2])\n        return ans\n", "class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp0 = [0 for i in range(n)]\n        dp1 = [0 for i in range(n)]\n        dp0[0] = nums[0]\n        dp1[0] = nums[0]\n        ans = nums[0]\n        for i in range(1, n):\n            dp0[i] = max(dp0[i-1]+nums[i], nums[i])\n            dp1[i] = max(dp1[i-1]+nums[i], nums[i])\n            if i > 1:\n                dp1[i] = max(nums[i], dp1[i-1]+nums[i], nums[i]+dp0[i-2])\n            ans = max(ans, dp0[i], dp1[i])\n        return ans\n            \n", "import math\nclass Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [] \n        for i in range(n):\n            dp.append([arr[i], arr[i]])\n        for i in range(1, n):\n            dp[i][0] = max(arr[i], dp[i - 1][0] + arr[i])    \n            # print(dp[i][0]) \n            if i > 1:\n                dp[i][1] = max(arr[i], dp[i-1][1]+arr[i],  dp[i-2][0]+arr[i])    \n        ans = -math.inf\n        for i in range(n):\n            ans = max(ans, max(dp[i][0], dp[i][1]))\n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        # Make a dp[n][2], where dp[i][0] is the largest sum of subarry ending at i without removing any element and dp[i][1] represents largest sum of subarray ending at i after removal of at most one element.\n        \n        n = len(arr)\n        dp = [ [0 for _ in range(2)] for _ in range(n) ]\n        dp[0] = [arr[0]] * 2\n        for i in range(1, n):\n            dp[i][0] = max(arr[i], dp[i-1][0] + arr[i])\n            dp[i][1] = max(dp[i][0], dp[i-1][0], dp[i-1][1] + arr[i])     \n        return max(map(lambda l: max(l), dp))", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return arr[0]\n        res = float('-inf')\n        max_ending_here0 = 3 * [arr[0]]  \n        max_ending_here1 = 3 * [arr[0]]  \n        for i in range(1, len(arr)):\n            max_ending_here0[i%3] = max(max_ending_here0[(i-1)%3] + arr[i], arr[i])\n            max_ending_here1[i%3] = max(max_ending_here1[(i-1)%3] + arr[i], arr[i])\n            if i >= 2:\n                max_ending_here1[i%3] = max(max_ending_here1[i%3], max_ending_here0[(i-2)%3] + arr[i])\n            res = max(res, max_ending_here1[i%3])\n        return res\n            \n            \n            \n", "import math\nclass Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [] \n        for i in range(n):\n            dp.append([arr[i], arr[i]])\n        for i in range(1, n):\n            dp[i][0] = max(dp[i][0], dp[i - 1][0] + arr[i])    \n            if i > 1:\n                dp[i][1] = max(dp[i][1], max(dp[i-1][1]+arr[i], dp[i-2][0]+arr[i]))   \n        ans = -math.inf\n        for i in range(n):\n            ans = max(ans, max(dp[i][0], dp[i][1]))\n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        nodel=[arr[0]]\n        for i in range(1,len(arr)):\n            nodel.append(arr[i] + max(0, nodel[i-1]))\n        onedel=[arr[0]]\n        for i in range(1, len(arr)):\n            onedel.append(max(nodel[i], nodel[i-1],arr[i]+onedel[-1]))\n        return max(onedel)    \n            \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        mx,n = float('-inf'),len(arr)\n        left,right = [float('-inf') for _ in range(len(arr))],[float('-inf') for _ in range(len(arr))]\n        for i in range(len(arr)):  \n            left[i] = max(arr[i],arr[i] + left[i-1]) if i > 0 else arr[0]\n            right[n-i-1] = max(arr[n-i-1],arr[n-i-1] + right[n-i]) if i > 0 else arr[-1]\n            \n        for i in range(len(arr)):\n            mx = max(mx, arr[i])\n            if 2*arr[i] != left[i] + right[i]:\n                mx = max(mx, left[i] + right[i] - 2*arr[i])\n        return mx\n            \n        \n        \n            \n        \n        \n        \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr)==1:\n            return arr[0]\n        dp=[[0]*2 for i in range(len(arr))]\n        dp[0][0]=arr[0]\n        for i in range(1,len(arr)):\n            dp[i][0]=max(arr[i],dp[i-1][0]+arr[i])\n            dp[i][1]=max(dp[i-1][1]+arr[i],dp[i-1][0])\n        ans=float('-inf')\n        for i in range(len(arr)):\n            ans=max(ans,dp[i][0],dp[i][1])\n        if ans==0:\n            return max(arr)\n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        max_res = [0] * len(arr)\n        max_start = [0] * len(arr)\n        max_end = [0] * len(arr)\n        \n        for i, n in enumerate(arr):\n            max_end[i] = n if i == 0 else max(n, max_end[i-1] + n)\n        print(max_end)\n        \n        for i, n in list(enumerate(arr))[::-1]:\n            max_start[i] = n if i == len(arr) - 1 else max(n, max_start[i+1] + n)\n        print(max_start)\n            \n        for i, n in enumerate(arr):\n            max_left = n if i == 0 else max_end[i-1]\n            max_right = n if i == len(arr) - 1 else max_start[i+1]\n            max_res[i] = max(max_left, max_right, max_left + max_right)\n        print(max_res)\n        \n        return max(max_res)", "class Solution:\n    def maximumSum(self, a: List[int]) -> int:\n        max_so_far = -sys.maxsize\n        max_ending_here = 0\n        size=len(a)\n        dp=[-sys.maxsize]*size\n        dp[0]=a[0]\n        dp1=[-sys.maxsize]*size\n        dp1[0]=a[0]\n        for i in range(1, size): \n            dp[i]=max(a[i],dp[i-1]+a[i])\n            dp1[i]=max(a[i],dp1[i-1]+a[i])\n            if i>=2:\n                dp1[i]=max(dp1[i],dp[i-2]+a[i])\n        return max(dp1)\n        \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        # Make a dp[n][2], where dp[i][0] is the largest sum of subarry ending at i without removing any element and dp[i][1] represents largest sum of subarray ending at i after removal of one element.\n        \n        n = len(arr)\n        dp = [ [0 for _ in range(2)] for _ in range(n) ]\n        dp[0] = [arr[0]] * 2\n        for i in range(1, n):\n            dp[i][0] = max(arr[i], dp[i-1][0] + arr[i])\n            dp[i][1] = max(dp[i][0], dp[i-1][1] + arr[i])\n            if i >= 2:\n                dp[i][1] = max(dp[i][1], dp[i-2][0] + arr[i])     \n        return max(map(lambda l: max(l), dp))", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        dp = [[0 for _ in range(2)] for _ in range(len(arr))]\n        dp[0][0] = arr[0]\n        dp[0][1] = arr[0]\n        \n        ans = max(dp[0])\n        for i in range(1, len(arr)):\n            dp[i][0] = max(dp[i-1][0] + arr[i], dp[i-1][1])\n            dp[i][1] = max(dp[i-1][1] + arr[i], arr[i])\n\n            ans = max(ans, dp[i][0], dp[i][1])\n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        # dp[i][k] is the maximum subarray up to arr[i] with k deletions, ending at arr[i]\n        # 0 no deletion happens, 1 deletion\n        n = len(arr)\n        dp = [[float('-inf')]*2 for _ in range(n) ]\n        dp[0][0] = arr[0]\n        dp[0][1] = float('-inf')  # it cannot be zero since no empty subarray\n        \n        for i in range(1,n):\n            dp[i][0] = max(arr[i],dp[i-1][0]+arr[i])\n            dp[i][1] = max(dp[i-1][1]+arr[i], dp[i-1][0] )\n        ans = float('-inf')\n        for i in range(n):\n            for j in range(2):\n                ans = max(ans,dp[i][j])\n                \n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        #s[i, 0] = max sum so far up to (including) i-th num without deletion of num at position i\n        #s[i, 0] = max sum so far up to (including) i-th num with deletion of num at position i\n        #s[i, 0] = max(s[i-1, 0], 0) + arr[i]\n        #s[i, 1] = max(max(s[i-1, 1], 0) + arr[i], s[i-1][0])\n        # max(all of s elements)\n        if len(arr)==1:\n            return arr[0]\n        ans = arr[0]\n        n = len(arr)\n        s = []\n        for i in range(n):\n            s.append([None, None])\n        s[0][0] = s[0][1] = arr[0]\n        for i in range(1, n):\n            s[i][0] = max(s[i-1][0], 0) + arr[i]\n            s[i][1] = max(max(s[i-1][1], 0) + arr[i], s[i-1][0])\n            ans = max(s[i][0], s[i][1], ans)\n        print(s)\n        return ans\n            \n            \n            \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        \n        r = max(arr)\n        if r < 0:\n            return r\n        \n        l = len(arr)\n        f = [0]*l\n        b = [0]*l\n        \n        cur = 0\n        \n        for i in range(l):\n            f[i] = cur\n            cur += arr[i]\n            cur = max(cur, 0)\n\n        cur = 0\n        for i in range(l-1, -1, -1):\n            b[i] = cur\n            cur += arr[i]\n            cur = max(cur, 0)\n\n        return max(f[i]+b[i] for i in range(l))", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        max_overall = arr[0]\n        max_sum = arr[0]\n        max_excluded = float('-inf')\n        for i in range(1, len(arr)):\n            max_excluded = max(max_excluded + arr[i], max_sum)\n            max_sum = max(max_sum + arr[i], arr[i])\n            max_overall = max(max_overall, max_sum, max_excluded)\n        return max_overall\n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        curr_max = [-math.inf, -math.inf]\n        max_sum = -math.inf\n        for num in arr:\n            curr_max[0], curr_max[1] = max(num, curr_max[0] + num), max(curr_max[1] + num, curr_max[0])\n            max_sum = max([max_sum, curr_max[0], curr_max[1]])\n        \n        return max_sum", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        max_ending_here0 = n * [arr[0]]  # no deletion\n        max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n        for i in range(1, n):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n            max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n            if i >= 2:\n                max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n        return max(max_ending_here1)", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        positive = [0 for _ in range(len(arr))]\n        negative = positive.copy()\n        positive[0] = arr[0]\n        for i, num in enumerate(arr[1:]):\n            positive[i+1] = max(num, positive[i] + num)\n            negative[i+1] = max(negative[i] + num, positive[i])\n        return max(positive+negative[1:])\n            \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return arr[0]\n        \n        @lru_cache(None)\n        def max_sum_start_at(i):\n            if i == len(arr) - 1:\n                return arr[-1]\n            return max(arr[i], arr[i] + max_sum_start_at(i + 1))\n        \n        @lru_cache(None)\n        def max_sum_end_at(j):\n            if j == 0:\n                return arr[0]\n            \n            return max(arr[j], arr[j] + max_sum_end_at(j - 1))\n        \n        return max(max([max_sum_start_at(i) for i in range(len(arr))]), \n                   max([max_sum_end_at(i - 1) + max_sum_start_at(i + 1) for i in range(1, len(arr) - 1)]))", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if max(arr) < 0:\n            return max(arr)\n        \n        @lru_cache(maxsize=None)\n        def recurse(idx, isSkipped):\n            if idx == len(arr):\n                return 0\n            \n            if isSkipped:\n                return max(arr[idx] + recurse(idx + 1, True), 0)\n            else:\n                return max(arr[idx] + recurse(idx + 1, False), recurse(idx + 1, True), arr[idx])\n                \n            # return memo[(idx, isSkipped)]\n        \n        curMax = float('-inf')\n        for i in range(len(arr)):\n            curMax = max(recurse(i, False), curMax)\n\n        return curMax", "class Solution:\n  def maximumSum(self, arr: List[int]) -> int:\n    max0, max1, result = arr[0], arr[0], arr[0]\n    for n in arr[1:]:\n      max1 = max(max1 + n, max0, n)\n      max0 = max(max0 + n, n)\n      result = max(result, max1)\n    return result", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        dp=[[0]*2 for i in range(len(arr))]\n        if len(arr)==0:\n            return 0\n        \n        dp[0][0]=arr[0]\n        dp[0][0]=arr[0]\n        maxm=arr[0]\n        \n        for i in range(1,len(arr)):\n            dp[i][0]=max(dp[i-1][0]+arr[i],arr[i])\n            dp[i][1]=max(arr[i],dp[i-1][1]+arr[i],dp[i-1][0])\n            \n            maxm=max(maxm,dp[i][0],dp[i][1])\n            \n        return maxm\n                \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        dp = [[0 for _ in range(2)] for _ in range(len(arr))]\n        mins = [0 for _ in range(len(arr))]\n        # dp[0][0] = max(0, arr[0])\n        dp[0][0] = arr[0]\n        dp[0][1] = arr[0]\n        mins[0] = arr[0]\n        \n        ans = max(dp[0])\n        for i in range(1, len(arr)):\n            if arr[i] >= 0:\n                if dp[i-1][0] < 0:\n                    dp[i][0] = arr[i]\n                    dp[i][1] = arr[i]\n                    mins[i] = arr[i]\n                else:\n                    dp[i][0] = dp[i-1][0] + arr[i] \n                    dp[i][1] = max(dp[i-1][1] + arr[i], arr[i])\n                    mins[i] = min(mins[i-1], arr[i])\n            else:\n                if dp[i-1][0] < 0:\n                    dp[i][0] = arr[i]\n                    dp[i][1] = arr[i]\n                    mins[i] = arr[i]\n                else:\n                    mins[i] = min(mins[i-1], arr[i])\n                    dp[i][0] = max(dp[i-1][0] + arr[i], dp[i-1][1])\n                    dp[i][1] = max(dp[i-1][1] + arr[i], arr[i])\n\n            ans = max(ans, dp[i][0], dp[i][1])\n        return ans", "class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        maxi=nums[0]\n        sumi=nums[0]\n        left=[nums[0]]\n        right=[nums[-1]]\n        for i in nums[1:]:\n            sumi=max(i,sumi+i)\n            left.append(sumi)\n        t=nums[::-1]\n        sumi=t[0]\n        for i in t[1:]:\n            sumi=max(i,sumi+i)\n            right.append(sumi)\n        right=right[::-1]\n        l=len(nums)\n        res=0\n        # print(left)\n        # print(right)\n        for i in range(l):\n            res=max(res,(left[i]+right[i]-(2*nums[i])))\n        if res!=0:return res\n        return max(nums)\n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n == 1:\n            return arr[0]\n        maxsum = [0]\n        for i in reversed(range(1, n)):\n            if maxsum[-1] > 0:\n                maxsum.append(maxsum[-1] + arr[i])\n            else:\n                maxsum.append(arr[i])\n        s = 0\n        result = -10 ** 6\n        for i, a in enumerate(arr):\n            r = maxsum.pop()\n            if 0 < i < n - 1:\n                result = max(result, s + r)\n            if s > 0:\n                s += a\n            else:\n                s = a\n            result = max(result, s)\n        return result", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        max_del = arr[0]\n        max_no_del = arr[0]\n        res = arr[0]\n        \n        for i in range(1, len(arr)):\n            max_del = max(max_del + arr[i], max_no_del, arr[i])\n            max_no_del = max(max_no_del + arr[i], arr[i])\n            res = max(res, max_del)\n        \n        return res", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        #if len(arr) == 1:\n        #    return arr[0]\n        nodel, delected = 0, 0\n        res = float('-inf')\n        for num in arr:\n            delected = max(nodel, delected + num)\n            nodel = max(nodel, 0) + num\n            res = max(nodel, delected, res)\n        return res\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return arr[0]\n        nodel, delected = arr[0], 0\n        res = arr[0]\n        for num in arr[1:]:\n            delected = max(nodel, delected + num)\n            nodel = max(nodel, 0) + num\n            res = max(nodel, delected, res)\n        return res", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        max_ending_here0 = n * [arr[0]]  # no deletion\n        max_ending_here1 = n * [arr[0]]  # at most 1 deletion\n        for i in range(1, n):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i])\n            max_ending_here1[i] = max(max_ending_here1[i-1] + arr[i], arr[i])\n            if i >= 2:\n                max_ending_here1[i] = max(max_ending_here1[i], max_ending_here0[i-2] + arr[i])\n        return max(max_ending_here1)\n            \n            \n                \n        \n        \n        \n        \n", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp0, dp1, res = arr[0], 0, arr[0]\n        for i in range(1,n):\n            dp0, dp1 = max(dp0+arr[i], arr[i]), max(dp0,dp1+arr[i])\n            res = max(dp0, dp1, res)\n        return res", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr)==1:\n            return arr[0]\n        \n        def helper(arr):\n            n=len(arr)\n            dp=[0]*n\n\n            if arr==[]:\n                return 0\n            else:\n                res=0\n                curr=arr[0]\n                dp[0]=arr[0]\n                for i in range(1,len(arr)):\n\n                    \n                    curr=max(curr+arr[i],arr[i])\n                   \n                    \n                    res=max(res,curr)\n                    dp[i]=curr\n                    # print(res)\n                return dp,res\n            \n        lp,best=helper(arr)\n        rp,best=helper(arr[::-1])\n        rp=rp[::-1]\n            \n        print(lp,rp)\n\n        ans=-1\n        for k in range(0,len(arr)):\n            \n            val=rp[k+1] if k<len(arr)-1 else 0 \n            val2=lp[k-1]  if k>0 else 0\n            print(val2,val)\n            ans=max(ans,best,val+val2,val,val2)\n        if ans==0:\n            return -1\n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if max(arr) < 0:\n            return max(arr)\n        \n        memo = {}\n        def recurse(idx, isSkipped):\n            if idx == len(arr):\n                return 0\n            \n            if (idx, isSkipped) in memo:\n                return memo[(idx, isSkipped)]\n            \n            if isSkipped:\n                memo[(idx, isSkipped)] = max(arr[idx] + recurse(idx + 1, True), 0)\n            else:\n                memo[(idx, isSkipped)] = max(arr[idx] + recurse(idx + 1, False), recurse(idx + 1, True), arr[idx])\n                \n            return memo[(idx, isSkipped)]\n        \n        curMax = float('-inf')\n        for i in range(len(arr)):\n            curMax = max(recurse(i, False), curMax)\n\n        return curMax", "class Solution:       \n    def maximumSum(self,a: List[int]) -> int:\n        n=len(a)\n        ans=skipped=not_skipped=a[-1]\n        for i in range(n-2,-1,-1):\n            not_skipped,skipped=max(a[i],a[i]+not_skipped,skipped),max(a[i],a[i]+skipped)\n            ans=max(ans,skipped,not_skipped)\n        return ans", "class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return arr[0]\n        \n        N = len(arr)\n        \n        max_ending_here0 = [0] * N\n        max_ending_here1 = [0] * N\n        \n        max_ending_here0[0] = arr[0]\n        max_ending_here1[0] = arr[0]\n        \n        max_ending_here0[1] = max(max_ending_here0[0] + arr[1], arr[1]) \n        max_ending_here1[1] = max(max_ending_here1[0] + arr[1], arr[1])\n        \n        for i in range(2, N):\n            max_ending_here0[i] = max(max_ending_here0[i-1] + arr[i], arr[i]) \n            max_ending_here1[i] = max(\n                max_ending_here1[i-1] + arr[i], \n                max_ending_here0[i-2] + arr[i], \n                arr[i])\n            \n        #print(max_ending_here0)\n        #print(max_ending_here1)\n           \n        return max(max_ending_here1)"]
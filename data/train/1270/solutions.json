["import sys\nsys.setrecursionlimit(100000)\n\nmemo = {}\ndef recurse(arr, T1, T2, k, i):\n if T1 >= k and T2 >= k:\n  return i\n\n if i >= len(arr):\n  return float('inf')\n\n if (T1, T2) in memo:\n  return memo[(T1, T2)]\n\n t1 = recurse(arr, T1 + arr[i], T2, k, i+1)\n t2 = recurse(arr, T1, T2 + arr[i], k, i+1) \n\n memo[(T1, T2)] = min(t1, t2)\n return memo[(T1, T2)]\n\nfor _ in range(int(input())):\n n, k = list(map(int, input().split()))\n lst = list(map(int, input().split()))\n\n lst.sort(reverse = True)\n memo = {}\n res = recurse(lst, 0, 0, k, 0)\n\n if res == float('inf'):\n  print(-1)\n else:\n  print(res)\n\n\n\n", "import sys\nsys.setrecursionlimit(100000)\n\nmemo = {}\ndef recurse(arr, T1, T2, k, i):\n if T1 >= k and T2 >= k:\n  return i\n\n if i >= len(arr):\n  return 10**9\n\n if (T1, T2) in memo:\n  return memo[(T1, T2)]\n\n t1 = recurse(arr, T1 + arr[i], T2, k, i+1)\n t2 = recurse(arr, T1, T2 + arr[i], k, i+1) \n\n memo[(T1, T2)] = min(t1, t2)\n return memo[(T1, T2)]\n\nfor _ in range(int(input())):\n n, k = list(map(int, input().split()))\n lst = list(map(int, input().split()))\n\n lst.sort(reverse = True)\n memo = {}\n res = recurse(lst, 0, 0, k, 0)\n\n if res == 10**9:\n  print(-1)\n else:\n  print(res)\n\n\n\n", "def min_boxes(k, boxes):\n if len(boxes) == 1: return -1\n sum_ = sum(boxes)\n boxes = sorted(boxes, reverse=True)\n n = len(boxes)\n\n\n if sum_ < 2 * k: \n  return -1\n elif boxes[0] >= k:\n  B = boxes[1]\n  if B >= k:\n   return 2\n  for i in range(2, n):\n   B += boxes[i]\n   if B >= k:\n    return i + 1\n  return -1\n\n\n table = [[False for _ in range(2 * k)] for _ in range(n + 1)]\n\n for i in range(n + 1):\n  table[i][0] = True\n \n for i in range(1, n + 1):\n  for j in range(1, 2 * k):\n   if boxes[i - 1] > j:\n    table[i][j] = table[i - 1][j]\n   else:\n    table[i][j] = table[i - 1][j] or table[i - 1][j - boxes[i - 1]]\n\n\n sum_till_here = 0\n for i in range(1, n + 1):\n  sum_till_here += boxes[i - 1]\n  for j in range(k, sum_till_here - k + 1):\n   if table[i][j]:\n    return i\n \n \n\n return -1\n\n\ndef __starting_point():\n test_cases = int(input())\n while test_cases:\n\n\n  n, k = map(int, input().split())\n  boxes = list(map(int, input().split()))\n\n  print(min_boxes(k, boxes))\n\n  test_cases -= 1\n__starting_point()", "def min_boxes(k, boxes):\n if len(boxes) == 1: return -1\n sum_ = sum(boxes)\n boxes = sorted(boxes, reverse=True)\n n = len(boxes)\n\n\n if sum_ < 2 * k: \n  return -1\n elif boxes[0] >= k:\n  B = boxes[1]\n  if B >= k:\n   return 2\n  for i in range(2, n):\n   B += boxes[i]\n   if B >= k:\n    return i + 1\n  return -1\n\n\n table = [[False for _ in range(2 * k)] for _ in range(n + 1)]\n\n for i in range(n + 1):\n  table[i][0] = True\n \n for i in range(1, n + 1):\n  for j in range(1, 2 * k):\n   if boxes[i - 1] > j:\n    table[i][j] = table[i - 1][j]\n   else:\n    table[i][j] = table[i - 1][j] or table[i - 1][j - boxes[i - 1]]\n\n\n sum_till_here = 0\n for i in range(1, n + 1):\n  sum_till_here += boxes[i - 1]\n  for j in range(k, sum_till_here - k + 1):\n   if table[i][j]:\n    return i\n \n \n\n return -1\n\n\ndef __starting_point():\n test_cases = int(input())\n while test_cases:\n\n\n  n, k = map(int, input().split())\n  boxes = list(map(int, input().split()))\n\n  print(min_boxes(k, boxes))\n\n  test_cases -= 1\n__starting_point()", "def min_boxes(k, boxes):\n sum_ = sum(boxes)\n if sum_ < 2 * k: return -1\n boxes = sorted(boxes, reverse=True)\n\n n = len(boxes)\n\n table = [[-1 for _ in range(sum_ + 1)] for _ in range(n + 1)]\n\n table[0][:] = [False for _ in range(sum_ + 1)]\n\n for i in range(n + 1):\n  table[i][0] = True\n \n for i in range(1, n + 1):\n  for j in range(1, sum_ + 1):\n   if boxes[i - 1] > j:\n    table[i][j] = table[i - 1][j]\n   else:\n    table[i][j] = table[i - 1][j] or table[i - 1][j - boxes[i - 1]]\n\n\n i = 0\n x = boxes[0]\n while x < 2 * k:\n  i += 1\n  x += boxes[i]\n \n if i == 1:\n  i += 1\n\n while i < n + 1:\n  sum_till_here = sum(boxes[ : i])\n  for j in range(k, sum_till_here - k + 1):\n   if table[i][j]:\n    if sum_till_here - j >= k:\n     return i\n  i += 1\n\n return -1\n\n\ndef __starting_point():\n test_cases = int(input())\n while test_cases:\n\n\n  n, k = map(int, input().split())\n  boxes = list(map(int, input().split()))\n\n  print(min_boxes(k, boxes))\n\n  test_cases -= 1\n__starting_point()", "def min_boxes(k, boxes):\n sum_ = sum(boxes)\n if sum_ < 2 * k: return -1\n boxes = sorted(boxes, reverse=True)\n\n n = len(boxes)\n\n table = [[-1 for _ in range(sum_ + 1)] for _ in range(n + 1)]\n\n table[0][:] = [False for _ in range(sum_ + 1)]\n\n for i in range(n + 1):\n  table[i][0] = True\n \n for i in range(1, n + 1):\n  for j in range(1, sum_ + 1):\n   if boxes[i - 1] > j:\n    table[i][j] = table[i - 1][j]\n   else:\n    table[i][j] = table[i - 1][j] or table[i - 1][j - boxes[i - 1]]\n\n\n i = 0\n x = boxes[0]\n while x < 2 * k:\n  i += 1\n  x += boxes[i]\n \n if i == 1:\n  i += 1\n\n while i < n + 1:\n  sum_till_here = sum(boxes[ : i])\n  for j in range(k, sum_ + 1):\n   if table[i][j]:\n    if sum_till_here - j >= k:\n     return i\n  i += 1\n\n return -1\n\n\ndef __starting_point():\n test_cases = int(input())\n while test_cases:\n\n\n  n, k = map(int, input().split())\n  boxes = list(map(int, input().split()))\n\n  print(min_boxes(k, boxes))\n\n  test_cases -= 1\n__starting_point()", "for _ in range(int(input())):\n n, k = map(int,input().split())\n h = list(map(int, input().split()))\n sum = 0\n h.sort()\n h1 = set()\n h1.add(h[n-1])\n summ = h[n-1]\n z = -1\n for i in range(n-2,-1,-1):\n  h2 = set()\n  summ = summ + h[i]\n  i1 = iter(h1)\n  while True:\n   try:\n    p = int(next(i1))\n   except StopIteration:\n    break\n   h2.add(p)\n   h2.add(h[i])\n   h2.add(p+h[i])\n   if(((p+h[i])>=k) and ((summ-p-h[i])>=k)):\n    z=n-i\n    break\n   if(((h[i])>=k) and ((summ-h[i])>=k)):\n    z=n-i\n    break\n  if(z!=-1):\n   break\n  h1=h2\n print(z)", "tc = int(input())\nwhile tc!= 0:\n count=0\n n,k= map(int, input().split())\n h = sorted(map(int,input().split()))\n h.reverse()\n queue = [h[0]]\n sum2 = h[0]\n res = -1\n for i in range(1,len(h)):\n  queue2=[]\n  s=set()\n  sum2+= h[i]\n  for x in queue:\n   if x not in s:\n    queue2.append(x)\n    s.add(x)\n   if h[i] not in s:\n    queue2.append(h[i])\n    s.add(h[i])\n   if x+h[i] not in s:\n    queue2.append(x+h[i])\n    s.add(x+h[i])\n   if(x+h[i])>=k and (sum2-x-h[i])>=k:\n    res= i+1\n    break\n   if (h[i]>=k) and (sum2-h[i])>=k:\n    res= i+1\n    break\n  if res!= -1:\n   break\n  queue = queue2\n print(res)\n tc-= 1", "tc = int(input())\nwhile tc!= 0:\n count=0\n n,k= map(int, input().split())\n h = sorted(map(int,input().split()))\n h.reverse()\n queue = [h[0]]\n sum2 = h[0]\n res = -1\n for i in range(1,len(h)):\n  queue2=[]\n  s=set()\n  sum2+= h[i]\n  for x in queue:\n   if x not in s:\n    queue2.append(x)\n    s.add(x)\n   if h[i] not in s:\n    queue2.append(h[i])\n    s.add(h[i])\n   if x+h[i] not in s:\n    queue2.append(x+h[i])\n    s.add(x+h[i])\n   if(x+h[i])>=k and (sum2-x-h[i])>=k:\n    res= i+1\n    break\n   if (h[i]>=k) and (sum2-h[i])>=k:\n    res= i+1\n    break\n  if res!= -1:\n   break\n  queue = queue2\n print(res)\n tc-= 1", "# cook your dish here\nfor t in range(int(input())):\n  n,k=map(int,input().split())\n  a=list(map(int,input().split()))\n  a.sort(reverse=True)\n  queue1=[a[0]]\n  summ=a[0]\n  res=-1\n  for i in range(1,len(a)):\n   queue2=[]\n   s=set()\n   summ+=a[i]\n   for x in queue1:\n    if x not in s:\n     queue2.append(x)\n     s.add(x)\n    if a[i] not in s:\n     queue2.append(a[i])\n     s.add(a[i])\n    if x+a[i] not in s:\n     queue2.append(x+a[i])\n     s.add(x+a[i])\n    if (x+a[i])>=k and (summ-x-a[i])>=k:\n     res=i+1\n     break\n    if (a[i])>=k and (summ-a[i])>=k:\n     res=i+1\n     break\n   if res!=-1:break\n   queue1=queue2\n  print(res)", "for _ in range(int(input())):\n n,k=map(int,input().split())\n h=list(map(int,input().split()))\n h.sort(reverse=True)\n h1=[]\n summ=0\n for i in range(n):\n  summ+=h[i]\n  h1.append(summ)\n dp=[]\n ele=[200000]*(k+1)\n dp.append(ele)\n for i in range(n):\n  ele=[0]*(k+1)\n  dp.append(ele)\n for i in range(1,n+1):\n  for j in range(1,k+1):\n   if h[i-1]>=j:\n    dp[i][j]=h[i-1]\n   else:\n    dp[i][j]=min(dp[i-1][j],h[i-1]+dp[i-1][j-h[i-1]])\n i=1\n while(i<=n):\n  if h1[i-1]-dp[i][k]>=k:\n   break\n  else:\n   i+=1\n if i>n:\n  print(-1)\n else:\n  print(i)"]
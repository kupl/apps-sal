["import math\nimport sys\n\ninput = sys.stdin.readline\n\ndef main():\n\n\n\n    MAX_N = int(1e6) + 1\n\n    dp = [0 for i in range(MAX_N)]\n    vals = [[] for i in range(10)]\n\n    for i in range(10):\n        dp[i] = i\n        vals[i].append(i)\n\n\n    for i in range(10, MAX_N):\n        prod = 1\n        for j in str(i):\n            if j != '0':\n                prod *= int(j)\n\n        dp[i] = dp[prod]\n        vals[dp[prod]].append(i)\n\n    q = int(input())\n\n    for i in range(len(vals)):\n        vals[i] = sorted(vals[i])\n\n    for i in range(q):\n        l,r, k = [int(x) for x in input().split(' ')]\n        posl = -1\n        posr = -1\n        for j in range(25, -1, -1):\n            jump = 2**j\n\n            if posl + jump < len(vals[k]) and vals[k][posl+jump] < l:\n                posl += jump\n\n            if posr + jump < len(vals[k]) and vals[k][posr+jump] <= r:\n                posr += jump\n\n        print(posr - posl)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import math\nimport sys\n\ninput = sys.stdin.readline\n\ndef main():\n\n\n\n    MAX_N = int(1e6) + 1\n\n    dp = [0 for i in range(MAX_N)]\n    vals = [[] for i in range(10)]\n\n    for i in range(10):\n        dp[i] = i\n        vals[i].append(i)\n\n\n    for i in range(10, MAX_N):\n        prod = 1\n        for j in str(i):\n            if j != '0':\n                prod *= int(j)\n\n        dp[i] = dp[prod]\n        vals[dp[prod]].append(i)\n\n    q = int(input())\n\n    for i in range(len(vals)):\n        vals[i] = sorted(vals[i])\n\n    for i in range(q):\n        l,r, k = [int(x) for x in input().split(' ')]\n        posl = -1\n        posr = -1\n        for j in range(25, -1, -1):\n            jump = 2**j\n\n            if posl + jump < len(vals[k]) and vals[k][posl+jump] < l:\n                posl += jump\n\n            if posr + jump < len(vals[k]) and vals[k][posr+jump] <= r:\n                posr += jump\n\n        print(posr - posl)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nimport sys\ndef f(n): # O(digits)\n    out = 1\n    while(n > 0):\n        digit = n % 10\n        if digit != 0:\n            out *= digit\n        n = n//10\n    return out\n\nmemorization = defaultdict(int) # For much faster calculation g(n)\ndef g(n):\n    if n < 10:return n\n    f_n = f(n)\n    if f_n in memorization:\n        return memorization[f_n]\n    else:\n        ans = g(f_n)\n        memorization[f_n] = ans\n        return ans\n\ndef s(L,l,r,k):\n    if l > r:return l\n    m = (l+r)//2\n    if L[m] == k:return m\n    if L[m] > k:return s(L,l,m-1,k)\n    else:return s(L,m+1,r,k)\n\nans = {i : [1000001] for i in range(1,10)}\n\nfor i in range(1,1000001): # O(n) because 9*9*9*9*9*9 = 531441 -> Maxnimum each number between [1,531441] will calculated only once\n    g_i = g(i)             # due to memorization\n    if g_i != 0:ans[g_i].append(i)    \nfor i in ans: # O( nlog(n) )\n    ans[i].sort()\n\ninput = sys.stdin.readline\nn = int(input())\nfor i in range(n): # O( Qlog(n) )\n    l,r,k = [int(i) for i in input().split()] #O (logn) for each Q\n    l_idx,r_idx = s(ans[k],0,len(ans[k])-1,l) , s(ans[k],0,len(ans[k])-1,r)\n    #FIX l_idx to Upper_bound\n    if ans[k][l_idx] != l and ans[k][l_idx] < l and ans[k][l_idx+1] > l : l_idx += 1\n    #FIX r_idx to Lower_bound\n    if ans[k][r_idx] != r and not (ans[k][r_idx] < r and ans[k][r_idx+1] > r) : r_idx -= 1\n    print(r_idx - l_idx + 1)\n    \n", "# -*- coding: utf-8 -*-\n\n# Baqir Khan\n# Software Engineer (Backend)\n\nimport bisect as b\nfrom sys import stdin\n\ninp = stdin.readline\n\npre_calc = x = [[] for i in range(10)]\n\n\ndef get_g(num):\n    while num > 9:\n        new_num = 1\n        while num:\n            digit = num % 10\n            if digit:\n                new_num *= digit\n            num //= 10\n        num = new_num\n    return num\n\n\nfor i in range(1, 10 ** 6 + 5):\n    pre_calc[get_g(i)].append(i)\n\nq = int(inp())\n\nwhile q:\n    q -= 1\n    l, r, x = list(map(int, inp().split()))\n    index_l = b.bisect_left(pre_calc[x], l)\n    if index_l < len(pre_calc[x]) and pre_calc[x][index_l] >= l:\n        index_l -= 1\n    index_r = b.bisect_left(pre_calc[x], r)\n    if index_r < len(pre_calc[x]) and pre_calc[x][index_r] <= r:\n        index_r += 1\n    print(max(index_r - index_l - 1, 0))\n"]
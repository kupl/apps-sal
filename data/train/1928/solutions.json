["# \"\"\"\n # This is the interface that allows for creating nested lists.\n # You should not implement it, or speculate about its implementation\n # \"\"\"\n #class NestedInteger:\n #    def __init__(self, value=None):\n #        \"\"\"\n #        If value is not specified, initializes an empty list.\n #        Otherwise initializes a single integer equal to value.\n #        \"\"\"\n #\n #    def isInteger(self):\n #        \"\"\"\n #        @return True if this NestedInteger holds a single integer, rather than a nested list.\n #        :rtype bool\n #        \"\"\"\n #\n #    def add(self, elem):\n #        \"\"\"\n #        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n #        :rtype void\n #        \"\"\"\n #\n #    def setInteger(self, value):\n #        \"\"\"\n #        Set this NestedInteger to hold a single integer equal to value.\n #        :rtype void\n #        \"\"\"\n #\n #    def getInteger(self):\n #        \"\"\"\n #        @return the single integer that this NestedInteger holds, if it holds a single integer\n #        Return None if this NestedInteger holds a nested list\n #        :rtype int\n #        \"\"\"\n #\n #    def getList(self):\n #        \"\"\"\n #        @return the nested list that this NestedInteger holds, if it holds a nested list\n #        Return None if this NestedInteger holds a single integer\n #        :rtype List[NestedInteger]\n #        \"\"\"\n \n class Solution:\n     def deserialize(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: NestedInteger\n         \"\"\"\n         \n         root_ni = NestedInteger()\n         \n         ni_stack = collections.deque()\n         current_ni = root_ni\n         \n         active_number = None\n         is_positive = True\n         \n         for i, c in enumerate(s):\n             if c == '-':\n                 is_positive = False\n                 active_number = 0\n \n             elif c.isdigit():\n                 # Check if the previous was a digit as well.\n                 if active_number is None:\n                     active_number = int(c)\n                 else:\n                     active_number = int(c) + active_number * 10\n \n             else:\n                 if active_number is not None:\n                     if not is_positive:\n                         active_number *= -1\n \n                     current_ni.add(active_number)\n                     active_number = None\n                     is_positive = True\n \n                 if c == '[' and i > 0:\n                     ni_stack.append(current_ni)\n                     current_ni = NestedInteger()\n \n                 elif c == ']' and len(ni_stack) > 0:\n                     ni_stack[-1].add(current_ni)\n                     current_ni = ni_stack.pop()\n \n         if active_number is not None:\n             if not is_positive:\n                 active_number *= -1\n \n             if not current_ni.getList():\n                 current_ni.setInteger(active_number)\n             else:\n                 current_ni.add(active_number)\n             \n         return root_ni\n         \n         ", "# \"\"\"\n # This is the interface that allows for creating nested lists.\n # You should not implement it, or speculate about its implementation\n # \"\"\"\n #class NestedInteger:\n #    def __init__(self, value=None):\n #        \"\"\"\n #        If value is not specified, initializes an empty list.\n #        Otherwise initializes a single integer equal to value.\n #        \"\"\"\n #\n #    def isInteger(self):\n #        \"\"\"\n #        @return True if this NestedInteger holds a single integer, rather than a nested list.\n #        :rtype bool\n #        \"\"\"\n #\n #    def add(self, elem):\n #        \"\"\"\n #        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n #        :rtype void\n #        \"\"\"\n #\n #    def setInteger(self, value):\n #        \"\"\"\n #        Set this NestedInteger to hold a single integer equal to value.\n #        :rtype void\n #        \"\"\"\n #\n #    def getInteger(self):\n #        \"\"\"\n #        @return the single integer that this NestedInteger holds, if it holds a single integer\n #        Return None if this NestedInteger holds a nested list\n #        :rtype int\n #        \"\"\"\n #\n #    def getList(self):\n #        \"\"\"\n #        @return the nested list that this NestedInteger holds, if it holds a nested list\n #        Return None if this NestedInteger holds a single integer\n #        :rtype List[NestedInteger]\n #        \"\"\"\n \n class Solution:\n     def deserialize(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: NestedInteger\n         \"\"\"\n         return eval(s)\n #     def deserialize(self, s):\n #         def nestedInteger(x):\n #             if isinstance(x, int):\n #                 return NestedInteger(x)\n #             lst = NestedInteger()\n #             for y in x:\n #                 lst.add(nestedInteger(y))\n #             return lst\n #         return nestedInteger(eval(s))\n         \n         ", "# \"\"\"\n # This is the interface that allows for creating nested lists.\n # You should not implement it, or speculate about its implementation\n # \"\"\"\n #class NestedInteger:\n #    def __init__(self, value=None):\n #        \"\"\"\n #        If value is not specified, initializes an empty list.\n #        Otherwise initializes a single integer equal to value.\n #        \"\"\"\n #\n #    def isInteger(self):\n #        \"\"\"\n #        @return True if this NestedInteger holds a single integer, rather than a nested list.\n #        :rtype bool\n #        \"\"\"\n #\n #    def add(self, elem):\n #        \"\"\"\n #        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n #        :rtype void\n #        \"\"\"\n #\n #    def setInteger(self, value):\n #        \"\"\"\n #        Set this NestedInteger to hold a single integer equal to value.\n #        :rtype void\n #        \"\"\"\n #\n #    def getInteger(self):\n #        \"\"\"\n #        @return the single integer that this NestedInteger holds, if it holds a single integer\n #        Return None if this NestedInteger holds a nested list\n #        :rtype int\n #        \"\"\"\n #\n #    def getList(self):\n #        \"\"\"\n #        @return the nested list that this NestedInteger holds, if it holds a nested list\n #        Return None if this NestedInteger holds a single integer\n #        :rtype List[NestedInteger]\n #        \"\"\"\n \n class Solution:    \n     def convertListToNestedInteger(self, nestList):\n         if type(nestList) == type(0):\n             return NestedInteger(nestList)\n         rtype = NestedInteger()\n         for item in nestList:\n             if type(item) == type(0):\n                 rtype.add(item)\n             else:\n                 nestedList = self.convertListToNestedInteger(item)\n                 rtype.add(nestedList)\n         return rtype\n         \n     def deserializeHelper(self, st):\n         if len(st) > 0:\n             if st[0] != '[':\n                 return int(st)\n         assert(len(st) > 1)\n         assert(st[0] == '[')\n         assert(st[-1] == ']')\n         l = st[1:].find('[')\n         r = st[:-1].rfind(']')\n         assert(l*r >= 0)\n         if l > 0:\n             nums = [int(s) for s in st[1:l].split(',') if s.strip() != '']\n             rest = self.deserializeHelper('[' + st[l+1:] )\n             for item in rest:\n                 nums.append(item)\n             #nums.append(rest)\n             return nums\n         elif l < 0:\n             nums = [int(s) for s in st[1:l].split(',') if s.strip() != '']\n             return nums\n         r = self.matchingBracket(st)\n         ret = [self.deserializeHelper(st[l+1:r+1])]\n         if st[r+1] != ']':\n             rest = self.deserializeHelper('[' + st[r+2:])\n             for item in rest:\n                 ret.append(item)\n         return ret\n \n     def matchingBracket(self, st):\n         sum = 1\n         #print(st)\n         for r in range(2,len(st)):\n             #print(sum, st[r])\n             if st[r] == '[':\n                 sum += 1\n             elif st[r] == ']':\n                 sum -= 1\n             if sum == 0:\n                 return r\n         raise Exception(\"Invalid String\")\n         return None\n     \n     def deserialize(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: NestedInteger\n         \"\"\"\n         nestList = self.deserializeHelper(s)\n         return self.convertListToNestedInteger(nestList)\n         ", "# \"\"\"\n # This is the interface that allows for creating nested lists.\n # You should not implement it, or speculate about its implementation\n # \"\"\"\n #class NestedInteger:\n #    def __init__(self, value=None):\n #        \"\"\"\n #        If value is not specified, initializes an empty list.\n #        Otherwise initializes a single integer equal to value.\n #        \"\"\"\n #\n #    def isInteger(self):\n #        \"\"\"\n #        @return True if this NestedInteger holds a single integer, rather than a nested list.\n #        :rtype bool\n #        \"\"\"\n #\n #    def add(self, elem):\n #        \"\"\"\n #        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n #        :rtype void\n #        \"\"\"\n #\n #    def setInteger(self, value):\n #        \"\"\"\n #        Set this NestedInteger to hold a single integer equal to value.\n #        :rtype void\n #        \"\"\"\n #\n #    def getInteger(self):\n #        \"\"\"\n #        @return the single integer that this NestedInteger holds, if it holds a single integer\n #        Return None if this NestedInteger holds a nested list\n #        :rtype int\n #        \"\"\"\n #\n #    def getList(self):\n #        \"\"\"\n #        @return the nested list that this NestedInteger holds, if it holds a nested list\n #        Return None if this NestedInteger holds a single integer\n #        :rtype List[NestedInteger]\n #        \"\"\"\n \n import re\n \n class Solution:\n     def deserialize(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: NestedInteger\n         \"\"\"\n         s = re.sub(\"\\[\",\"[,\", s)\n         s = re.sub(\"\\]\",\",]\", s)\n         s = s.split(\",\")\n \n         if not s[0] == \"[\":\n             return NestedInteger(int(s[0]))\n         \n         obj = NestedInteger()\n         self.parse_recursive_list(s, 1, obj)\n         return obj\n         \n     def parse_recursive_list(self, s, i, obj):\n         while i<len(s):\n             if s[i] == '':\n                 i += 1\n                 continue\n             if s[i] == \"[\":\n                 new_obj = NestedInteger()\n                 i = self.parse_recursive_list(s, i+1, new_obj)\n                 obj.add(new_obj)\n             elif s[i] == ']':\n                 return i+1\n             else:\n                 integer = int(s[i])\n                 obj.add(NestedInteger(integer))\n                 i += 1\n         return i\n             \n                 \n                 "]
["'''\n    Write a function that returns the longest contiguous palindromic substring in s. \n    In the event that there are multiple longest palindromic substrings, return the \n    first to occur.\n'''\n\ndef longest_palindrome(s, sep=\" \"):\n    # Interpolate some inert character between input characters\n    # so we only have to find odd-length palindromes\n    t = sep + sep.join(s) + sep\n\n    r = 0       # Rightmost index in any palindrome found so far ...\n    c = 0       # ... and the index of the centre of that palindrome.\n    spans = []  # Length of the longest substring in T[i:] mirrored in T[i::-1]\n\n    # Manacher's algorithm\n    for i,_ in enumerate(t):\n        span = min(spans[2*c-i], r-i-1) if i < r else 0\n        while span <= i < len(t)-span and t[i-span] == t[i+span]:\n            span += 1\n        r, c = max((r, c), (i+span, i))\n        spans.append(span)\n\n    span = max(spans)\n    middle = spans.index(span)\n\n    return t[middle-span+1:middle+span].replace(sep, \"\") ", "def longest_palindrome(s):\n    \"\"\"\"Based on Manacher algorithm\"\"\"\n\n    if s==\"\":\n        t = \"^#$\"\n    else:\n        t = \"^#\" + \"#\".join(s) + \"#$\"\n\n    c = 0\n    r = 0\n    p = [0] * len(t)\n\n    for i in range(1,len(t)-1):\n    \n        mirror = 2*c - i\n        p[i] = max(0, min(r-i, p[mirror]))\n        \n        while t[i+1+p[i]] == t[i-1-p[i]]:\n            p[i] += 1\n\n        if i+p[i] > r:\n            c = i\n            r = i+p[i]\n\n    k, i = 0,0\n    for j,e in enumerate(p):\n        if e > k:\n            k, i = e, j\n            \n    deb, fin = ((i-k)//2, (i+k)//2)\n    return s[deb:fin]", "'''\n    Write a function that returns the longest contiguous palindromic substring in s. \n    In the event that there are multiple longest palindromic substrings, return the \n    first to occur.\n'''\n\n# TODO: Complete in linear time xDD\ndef longest_palindrome(s):\n    if is_palindrome(s):\n        return s\n        \n    max_pal = ''\n\n    for i in range(len(s)):\n        temp = check(i, i, s)\n        if len(max_pal) < len(temp):\n            max_pal = temp\n\n    return max_pal\n\n\ndef check(li, ri, s):\n    if li > 0 and ri < len(s):\n        if is_palindrome(s[li - 1: ri + 2]):\n            return check(li - 1, ri + 1, s)\n        elif is_palindrome(s[li: ri + 2]):\n            return check(li, ri + 1, s)\n        elif is_palindrome(s[li - 1: ri + 1]):\n            return check(li - 1, ri, s)\n\n    return s[li: ri + 1]\n\n\ndef is_palindrome(s):\n    return s == s[::-1]", "'''\n    Write a function that returns the longest contiguous palindromic substring in s. \n    In the event that there are multiple longest palindromic substrings, return the \n    first to occur.\n'''\nimport re\n\ndef longest_palindrome(string):\n    if len(string) < 2:\n        return string\n    string = '|' + '|'.join(string) + '|'\n    LPS = [0 for _ in range(len(string))]\n    C = 0\n    R = 0\n\n    for i in range(len(string)):\n        iMirror = 2 * C - i\n        if R > i:\n            LPS[i] = min(R - i, LPS[iMirror])\n        else:\n            LPS[i] = 0\n        try:\n            while string[i + 1 + LPS[i]] == string[i - 1 - LPS[i]]:\n                LPS[i] += 1\n        except:\n            pass\n\n        if i + LPS[i] > R:\n            C = i\n            R = i + LPS[i]\n\n    r, c = max(LPS), LPS.index(max(LPS))\n    return string[c - r: c + r].replace(\"|\", \"\")\n", "def modi(s):\n    return ''.join(['#'+i for i in s]) + '#'\n\ndef demodi(s):\n    return ''.join(([i for i in s if i != '#']))\n\ndef longest_palindrome(s):\n    s = modi(s)\n    lenth, c, r, maxl, p = len(s), 0, 0, 0, [0]*len(s)\n\n    for i in range(lenth):\n        mir = (2*c) - i\n\n        if i<r: \n            p[i] = min(r-i, p[mir])\n\n        a, b = i + (1+p[i]), i - (1+p[i])\n        while a < lenth and b >= 0 and s[a] == s[b]:\n            p[i] += 1\n            a += 1\n            b -= 1\n\n        if (i + p[i]) > r: \n            c = i\n            r = i + p[i]\n\n            if p[i] > maxl: \n                maxl = p[i]\n    mai = p.index(maxl)\n    return demodi(s[mai-maxl: mai+maxl+1])", "def get_func(s, i):\n    p2, p3 = '', ''\n    s2, s3 = s[i:i+2], s[i: i+3]\n    if s2[0] == s2[-1]:\n        p2 = s2\n        u, v = i-1, i+2\n        while(u > -1 and v < len(s)):\n            if s[u] != s[v]:\n                break\n            p2 = s[u] + p2 + s[v]\n            u, v = u-1, v+1\n    if s3[0] == s3[-1]:\n        p3 = s3\n        u, v = i-1, i+3\n        while(u > -1 and v < len(s)):\n            if s[u] != s[v]:\n                break\n            p3 = s[u] + p3 + s[v]\n            u, v = u-1, v+1\n    return p3 if len(p3) > len(p2) else p2\n\ndef set_pal(p, idxp, pal, idx):\n    if len(p) > len(pal) or (len(p) == len(pal) and idxp < idx):\n        pal, idx = p, idxp\n    return pal, idx\n\ndef longest_palindrome(s):\n    if len(s) < 2: return s\n    pal = s[0] # b\n    idx = 1\n    j = len(s) // 2 - 1\n    k = j + 1\n    if len(s) > 3:\n        for i in range(j):\n            pal, idx = set_pal(get_func(s, j-i-1), j-i, pal, idx)\n            pal, idx = set_pal(get_func(s, k+i-1), k+i, pal, idx)\n            if len(s) < len(pal) + 2*i:\n                break\n    if len(pal) < 3 and len(s) % 2 != 0:\n        pal, idx = set_pal(get_func(s, len(s)-3), len(s)-2, pal, idx)\n    if len(pal) < 2:\n        sub = s[len(s)-2:len(s)]\n        if sub[0] == sub[-1]:\n            pal = sub\n    return pal", "def longest_palindrome(s):\n    s = \"_\" + '_'.join(s) + \"_\"\n    n = len(s)\n    a = [0] * n\n\n    rb = ml = mctr = ctr = c = 0\n\n    for i in range(1,n):\n        a[i] = min(rb-i, a[2*ctr-i]) if rb > i else 1\n        c = a[i]\n        while i+c < n and i >= c and s[i-c] == s[i+c]: c += 1\n        a[i] = c\n        if i+c > rb:\n            rb = i+c\n            ctr = i\n        if c > ml:\n            ml = c\n            mctr = i\n\n    return s[mctr-ml+1 : mctr+ml].replace('_', \"\")", "def longest_palindrome(S):\n    \"\"\"\n    O(n) algorithm to find longest palindrome substring\n    :param S: string to process\n    :return: longest palindrome\n    \"\"\"\n\n    # Create a copy of array with sentinel chars in between and around\n    # Also include space for starting and ending nodes\n    T = [0] * (2 * (len(S)) + 3)\n\n    # Fill odd indices with sentinel chars evens with real chars\n    sen_char = \"@\"\n    start_sen = \"!\"\n    end_sen = \"#\"\n    for i in range(len(T)):\n        if i == 0:\n            T[i] = start_sen\n        elif i % 2 == 0 and i < len(T) - 1:\n            s_index = (i - 1) // 2\n            T[i] = S[s_index]\n        elif i % 2 == 1 and i < len(T) - 1:\n            T[i] = sen_char\n        else:\n            T[i] = end_sen\n\n    # Also track the expand length around all indices\n    P = [0] * len(T)\n\n    # Track center of largest palin yet\n    # and its right boundary\n    center = right = 0\n\n    # Track largest expansion length\n    # and it index\n    max_len = index = 0\n\n    # Loop through word array to\n    # update expand length around each index\n    for i in range(1, len(T) - 1):\n\n        # Check to see if new palin\n        # around i lies within a bigger one\n        # If so, copy expand length of its mirror\n        mirror = 2 * center - i\n        if i < right:\n            P[i] = min(right - i, P[mirror])\n\n        # Expand around new center\n        # Update expand length at i as needed\n        while T[i + P[i] + 1] == T[i - (P[i] + 1)]:\n            P[i] += 1\n\n        # If we breached previous right boundary\n        # Make i the new center of the longest palin\n        # and update right boundary\n        if i + P[i] > right:\n            right = i + P[i]\n            center = i\n\n        # Update max_len\n        if P[i] > max_len:\n            max_len = P[i]\n            index = i\n\n    t_arr = T[ index - max_len: index + max_len + 1 ]\n    word_arr = [ c for c in t_arr if c != sen_char and c != start_sen and c != end_sen ]\n    word = \"\".join(word_arr)\n\n    return word", "def longest_palindrome(s):\n    n = len(s)\n    if n <= 1:\n        return s\n    max, index = 0,  -1\n    max2, index2 = 0, -1\n    d1 = [0]*n\n    i, l, r = 0, 0, -1\n    while i < n:\n        if i > r:\n            k = 1\n        else:\n            k = min(d1[l + r - i], r - i + 1)\n        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:\n            k += 1\n        if k > max:\n            max, index = k, i  # s[i-k+1:i+k], 2k-1\n        d1[i] = k\n        k -= 1\n        if i + k > r:\n            l, r = i - k, i + k\n        i += 1\n\n    d2 = [0]*n\n    i, l, r = 0, 0, -1\n    while i < n:\n        if i > r:\n            k = 0\n        else:\n            k = min(d2[l + r - i + 1], r - i + 1)\n        while 0 <= i - k - 1 and i + k < n and s[i - k - 1] == s[i + k]:\n            k += 1\n        if k > max2:\n            max2, index2 = k, i  # s[i-k:i+k], 2k\n        d2[i] = k\n        k -= 1\n        if i + k > r:\n            l, r = i - k - 1, i + k\n        i += 1\n\n    index = index - max + 1  # start\n    max = 2 * max - 1        # len\n    index2 -= max2           # start\n    max2 *= 2                # len\n    start, ln = 0, 0\n    if max == max2:\n        if index <= index2:\n            start, ln = index, max\n        else:\n            start, ln = index2, max2\n    elif max > max2:\n        start, ln = index, max\n    else:\n        start, ln = index2, max2\n    return s[start: start + ln]\n", "def longest_palindrome(s):\n    tst = '#'.join('^{}$'.format(s))\n    n = len(tst)\n    p = [0] * n\n    c = 0\n    r = 0\n    for i in range (1, n - 1):\n        p[i] = r > i and min(r-i, p[2*c-i])\n        while tst[i+1+p[i]] == tst[i-1-p[i]]:\n            p[i] += 1\n        if i + p[i] > r:\n            c, r = i, i + p[i]\n    mx, ctri = max((n, -i) for i, n in enumerate(p))\n    return s[(-ctri-mx)//2:(-ctri+mx)//2]"]
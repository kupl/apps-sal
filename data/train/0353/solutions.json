["class Solution:\n    MODS = 10 ** 9 + 7\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        cal_map = [1]\n        for ii in range(1, N):\n            cal_map.append(cal_map[-1] * 2 % self.MODS)\n        left, right, res = 0, N - 1, 0\n        nums.sort()\n        while left < N:\n            if nums[left] * 2 > target:\n                break\n            while right - 1 >= left and nums[left] > target - nums[right]:\n                right -= 1\n            res += cal_map[right - left]\n            # print(left, right, cal_map[right - left], nums[left])\n            left += 1\n        return res % self.MODS\n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        mod = int(1e9+7)\n        power = [1]*(len(nums)+1)\n        for i in range(1,len(nums)):\n            power[i] = power[i-1] * 2 % mod;\n        \n        left,right = 0,len(nums)-1\n        res = 0\n        while left<=right:\n            while left<=right and nums[left]+nums[right]>target:\n                right-=1\n            \n            if left>right:\n                break\n            res += power[right-left]\n            left+=1\n            \n        return res%mod\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        result = 0\n        mod = 10 ** 9 + 7\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                result = result + pow(2, r-l, mod)\n                l += 1\n                \n        return result % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        ans = 0\n        mod = 10 ** 9 + 7\n        nums.sort()\n        temp = 0\n        def bina(i,low,high):\n            ans = low - 1 \n            while(low<=high):\n                mid = (low + high)//2\n                if nums[i] + nums[mid] <= target:\n                    low = mid + 1\n                    ans = mid\n                else:\n                    high = mid - 1\n            return ans - i\n\n        for i in range(len(nums)):\n            if nums[i]*2 > target:\n                break\n            ans = (ans + int(pow( 2,bina(i,i,len(nums)-1) ,mod) ))%mod\n            print(ans)\n        return ans\n        \n        \n        \n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10**9 + 7\n        left = 0\n        right = len(nums) - 1\n        res = 0 \n        while(left <= right):\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                num_inside = right - left\n                res = (res + pow(2, num_inside, mod)) % mod\n                left += 1\n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        n = len(nums)\n        l,r,res = 0,n-1,0\n        dp = [1]*n\n        for i in range(1,n):\n            dp[i] = (2*dp[i-1]) % (1000000007)\n        while l <= r:\n            # \u56fa\u5de6\u52a8\u53f3\n            while nums[l]+nums[r] > target and l <= r:\n                r-=1\n            if l<=r: \n                res += 1                \n                res += dp[r-l]-1\n                l+=1\n            \n        return res % (1000000007)\n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        res = 0\n        nums.sort()\n        ln = len(nums)\n        i = 0\n        j = ln-1\n        md = pow(10,9)+7\n        \n        while i <= j:\n            if nums[i]+nums[j]<= target:\n                res = (res + pow(2, j-i, md))%md\n                i += 1\n            else:\n                j -= 1\n        return res\n    \n            \n                    \n                    \n            \n            \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans = 0\n        l = 0\n        h = len(nums) - 1\n        MOD = 10 ** 9 + 7\n        while l <= h:\n            if nums[l] + nums[h] <= target:\n                ans = (ans + pow(2, h - l, MOD)) % MOD\n                l += 1\n            else:\n                h -= 1\n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left= 0\n        right = len(nums) - 1\n        res = 0\n        mod = 10**9 + 7\n        while (left <= right):\n            if nums[left] + nums[right] <= target:\n                res += pow(2, (right - left), mod)\n                left += 1\n            else:\n                right -= 1\n        return res % mod\n\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        \n        nums.sort()\n        \n        i = 0\n        \n        j = len(nums)-1\n        \n        result = 0\n        \n        mod = 10**9+7\n        \n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j-=1\n            \n            else:\n                sublen = j-i\n                result = (result + pow(2, sublen, mod))% mod\n                i +=1\n                \n        print (result)\n        \n        return result\n        \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        '''\n         \u5c06\u6570\u7ec4\u6392\u5e8f\uff0c\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5b50\u5e8f\u5217\u7684\u6700\u5c0f\u503c\u4e0e\u6700\u5927\u503c\n         \u4ece\u6bcf\u4e00\u9879\u5f00\u59cb\uff0c\u5bfb\u627e\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927\u503c\u4f4d\u7f6e\n            In subarray nums[i~j]:\n            min = nums[i], max = nums[j]\n            nums[i] + nums[j] <= target\n            {nums[i], (j - i - 1 + 1 values)}\n            Any subset of the right part gives a valid subsequence \n            in the original array. And There are 2^(j - i) ones.\n        '''\n        n=len(nums)\n        nums.sort()\n        p=[1]*(n+1)\n        for i in range(1,n+1):\n            p[i]=p[i-1]<<1\n        res=0\n        j=n-1\n        for i in range(j+1):\n            while i<=j and nums[i]+nums[j]>target:\n                j-=1\n            if i>j:\n                continue\n            res+=p[j-i]\n        return res%(10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        if not nums:\n            return 0\n        nums.sort()\n        res = 0\n        mod= 10**9+7\n        \n        l, r = 0, len(nums)-1\n        while l <= r:\n            \n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res = (res + pow(2, r-l, mod)) % mod\n                l += 1\n        return res\n        # nums.sort()\n        # mod = 10**9 + 7\n        # left = 0\n        # right = len(nums) - 1\n        # res = 0 \n        # while(left <= right):\n        #     if nums[left] + nums[right] > target:\n        #         right -= 1\n        #     else:\n        #         num_inside = right - left\n        #         res = (res + pow(2, num_inside, mod)) % mod\n        #         left += 1\n        # return res\n\n            \n            \n            \n       \n", "class Solution:\n    def getCombination( self, start, endPos):\n        mod = 10**9 + 7\n\n\n        #for i in range (1, qty+1):\n        #    ncombination = math.factorial(qty)\n        #    ncombination = ncombination/(math.factorial(i) * math.factorial(qty-i))\n        #    count += ncombination\n        #print (count)\n        count = pow (2, endPos - start )\n        return count % mod\n                                         \n    def findPos(self,nums,target):\n        # 0 1 2,  0,1,2,3\n        \n        start = 0\n        end = len(nums) -1\n        while start <= end:\n\n            medium = start + (end - start) // 2\n            #print (start, medium, end )\n            sumv = nums[0] + nums[medium]\n            if sumv > target:\n                # go left \n                end = medium -1\n            elif sumv == target:\n                if (medium == len(nums) -1) or nums[medium +1] != nums[medium]:\n                    #found\n                    return medium\n                else:\n                    # look for the rightmost\n                    start = medium + 1\n            else:\n                #sumv < target, check rightone\n                if (medium == len(nums) -1) or nums[medium +1] + nums[0] > target:\n                    return medium\n                else:\n                    # go right\n                    start = medium + 1\n                \n        return end \n         \n            \n        \n\n\n\n    def numSubseq2(self, nums: List[int], target: int) -> int:\n        mod = 10**9 + 7\n        nums.sort()\n        #print (nums)\n        #for each element, find the max\n        #count the number \n        start = 0\n        count = 0\n        endPos = self.findPos(nums,target)\n        print (endPos)\n        while (start < len(nums) and start <= endPos and endPos >0):\n            if nums[endPos] + nums[start] <= target:\n                count += pow (2, endPos - start )\n                count = count % mod\n                start += 1\n            else:               \n                endPos -= 1\n\n        return int(count % mod)\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left,right = 0,len(nums)-1\n        res = 0\n        md = 10**9+7\n        while left<=right:\n            if nums[left]+nums[right]<=target:\n                res=(res+pow(2,right-left,md))%md\n                left+=1\n            else:right-=1\n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10**9+7\n        s = sorted(nums)\n        \n        powers = [1]\n        for _ in s: powers.append(powers[-1] * 2)\n        \n        j = len(s) - 1\n        c = 0\n        for i, n in enumerate(s):\n            \n            while j > i and n + s[j] > target: j -=1\n            \n            if i <= j and s[i] + s[j] <= target:\n                c += powers[j - i]\n                # print(i, j, c)\n            \n        return c % MOD", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        l, r = 0, len(nums) - 1\n        res = 0; mod = 10**9 + 7\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                res += pow(2, r - l, mod) \n                l += 1\n            else:\n                r -= 1\n        return res % mod\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        l,r = 0, n-1\n        counts = 0\n        res = 0\n        \n        while True:\n            while l<=r and nums[r]+nums[l]>target:\n                r -= 1\n            if l<=r:\n                res += pow(2, (r-l), 10**9+7)\n                res %= 10**9 + 7\n                l += 1\n            else:\n                break\n            \n        return res \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        # time O(nlogn); space O(1)\n        nums.sort()\n        left, right = 0, len(nums)-1\n        res = 0\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                res += pow(2, right-left, 10**9+7)\n                left += 1\n            else:\n                right -= 1\n        \n        return res % (10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        n,result,p1,p2,m=len(nums),0,0,len(nums)-1,1000000007\n        nums.sort()\n        while(p1<=p2):\n            if nums[p1]+nums[p2]<=target:\n                result=(result+pow(2,p2-p1,m))%m\n                p1+=1\n            else:\n                p2-=1\n        return result", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        start = 0\n        end = len(nums) - 1 \n        res = 0\n        mod = 10**9 + 7 \n        \n        while start <= end:\n            if nums[start] + nums[end] > target:\n                end -= 1 \n            else:\n                res += pow(2,end - start, mod)\n                start += 1 \n        return res % mod\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        ans, mod = 0, 10 ** 9 + 7\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                # If we are using nums[l] as first element (and never be excluded)\n                # then there are 2 ** (r - l) options since the other positions can\n                # be toggled in or out\n                ans += pow(2, r - l, mod)\n                l += 1\n            else:\n                r -= 1\n        return ans % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = 0\n        #one length subsequence\n        mod = 10**9 + 7\n        i,j = 0,n-1\n        \n        \n        for i in range(n):\n            while i<=j and nums[i]+nums[j] > target:\n                j-=1\n            \n            if i<=j and nums[i] + nums[j] <= target:\n                res += pow(2,(j-i) , mod)\n                res %= mod\n        \n        return res", "'''class Solution:\n    def numSubseq(self, A: List[int], target: int) -> int:\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod'''\n\nclass Solution:\n    def numSubseq(self, A, target):\n        A.sort()\n        l = 0 \n        r = len(A)-1\n        res = 0 \n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] <= target:\n                res += pow(2, r-l,mod)\n                l += 1\n            else:\n                r-=1 \n        return res%mod\n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left,right = 0,len(nums)-1\n        count = 0\n        \n        dp = [0]*(len(nums)+1)\n        for i in range(1,len(nums)+1):\n            dp[i]=2*dp[i-1]+1\n#        print (\\\"dp \\\",dp)\n        while left<=right:\n           \n            while left<=right and nums[left] + nums[right]>target:\n                right -=1\n            count += dp[right-left+1]\n#            print (\\\"-- \\\",left,\\\"  \\\",right, \\\"  count =\\\",count)\n            while left<=right and nums[left] + nums[right]<=target:\n                left +=1\n            count -=dp[right-left+1]  \n#            print (\\\"$$ \\\",left,\\\"  \\\",right, \\\"  count =\\\",count)\n        \n        return count %(10**9 +7)\n\n    \n    \n    \n    def totalS(self,N):\n        if N<2: return N\n        return 2* self.totalS(N-1) +1\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        \n        ######Approach 1 log (n^2)\n#         nums.sort()\n#         if not nums:\n#             return 0\n        \n#         total=0\n#         print(nums)\n#         for i in range(len(nums)):\n#             for j in range(len(nums)-1,i-1,-1):\n#                 if nums[i]+nums[j]<=target:\n#                     total+=pow(2, j-i, 10**9 + 7)\n#                     break\n#         return total % (10**9 + 7)\n\n##########Approach 2 log(n) \n        low=0\n        high=len(nums)-1\n        nums.sort()\n        if not nums:\n            return 0\n        total=0\n        while low<=high:\n            if nums[low]+nums[high]<=target:\n                total+=pow(2, high-low, 10**9 + 7)\n                low+=1\n            else:\n                high-=1\n        return total %(10**9 + 7)\n                \n            \n", "p = 1000000007\n    \ndef modSum(a, b):\n    return (a + b) % p\n\ndef modProd(a, b):\n    return (a * b) % p\n\ndef modPow(x, n):\n    if n == 0:\n        return 1\n    \n    res = modPow(x, n // 2)\n    res = modProd(res, res)\n    if n % 2 == 1:\n        res = modProd(res, x)\n    \n    return res;\n\n\nclass Solution:\n    def numSubseq(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        arr.sort()\n        i = 0\n        j = n - 1\n        res = 0\n        while i <= j:\n            sum = arr[i] + arr[j]\n            if sum > target:\n                j -= 1\n            else:\n                res = modSum(res, modPow(2, j - i))\n                i += 1\n                \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        l,r = 0, n-1\n        counts = 0\n        res = 0\n        \n        while l<=r:\n            if nums[r]+nums[l]>target:\n                r -= 1\n            else:\n                res += pow(2, (r-l), 10**9+7)\n                l += 1\n            \n        return res % (10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = int(1e9 + 7)\n        pw = [1]\n        for i in range(1, 100001):\n            pw.append(pw[-1]*2%MOD)\n        nums.sort()\n        i = 0\n        j = len(nums)-1\n        ret = 0\n        for i in range(len(nums)):\n            while nums[i] + nums[j] > target:\n                j -= 1\n                if i > j: return ret\n            ret += pw[j-i]\n            ret %= MOD\n        return ret\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums)-1\n        res = 0\n        mod = 10 **9 + 7\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        #3:57pm\n        \n        \n        # first sort it, then use two pointer\n        \n#         nums.sort()\n#         l, r = 0, len(nums)-1\n#         res = 0\n#         stack = []\n        \n#         while l <= r and not stack:\n#             sums = nums[l] + nums[r]\n#             if sums <= target:\n#                 stack.append((l, r))\n#                 break\n#             r -= 1\n        \n#         while stack:\n#             l, r = stack.pop()\n#             res += r - l + 1\n#             l += 1\n#             if l < r and nums[l] + nums[r] <= target:\n#                 stack.append((l, r))\n#             elif l == r-1 and nums[l] + nums[r] > target:\n#                 res += 1\n#                 break\n                \n#         return res\n\n        A = nums\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def getCombination( self, start, endPos):\n        mod = 10**9 + 7\n\n\n        #for i in range (1, qty+1):\n        #    ncombination = math.factorial(qty)\n        #    ncombination = ncombination/(math.factorial(i) * math.factorial(qty-i))\n        #    count += ncombination\n        #print (count)\n        count = pow (2, endPos - start )\n        return count % mod\n                                         \n    def findPos(self,nums,target):\n        # 0 1 2,  0,1,2,3\n        \n        start = 0\n        end = len(nums) -1\n        while start <= end:\n\n            medium = start + (end - start) // 2\n            #print (start, medium, end )\n            sumv = nums[0] + nums[medium]\n            if sumv > target:\n                # go left \n                end = medium -1\n            elif sumv == target:\n                if (medium == len(nums) -1) or nums[medium +1] != nums[medium]:\n                    #found\n                    return medium\n                else:\n                    # look for the rightmost\n                    start = medium + 1\n            else:\n                #sumv < target, check rightone\n                if (medium == len(nums) -1) or nums[medium +1] + nums[0] > target:\n                    return medium\n                else:\n                    # go right\n                    start = medium + 1\n                \n        return end \n         \n            \n        \n\n\n\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10**9 + 7\n        nums.sort()\n        #print (nums)\n        #for each element, find the max\n        #count the number \n        start = 0\n        count = 0\n        endPos = self.findPos(nums,target)\n        print (endPos)\n        while (start < len(nums) and start <= endPos and endPos >0):\n            if nums[endPos] + nums[start] <= target:\n                count += pow (2, endPos - start,mod)\n                count = count % mod\n                start += 1\n            else:               \n                endPos -= 1\n\n        return int(count % mod)\n    \n    def numSubseq2(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left,right = 0,len(nums)-1\n        res = 0\n        md = 10**9+7\n        while left<=right:\n            if nums[left]+nums[right]<=target:\n                res=(res+pow(2,right-left,md))%md\n                left+=1\n            else:right-=1\n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        # sub sequence \u5c31\u968f\u4fbf\u6392\u5e8f\u4e86\uff0c\n        nums.sort()\n        cnt = 0\n        N = 10 ** 9 + 7\n        D = [1] * (len(nums) + 1)\n        \n        def bisect(x, low, high):\n            if high - low <= 1:\n                if nums[high] <= x:\n                    return high\n                else:\n                    return low\n            \n            mid = (low + high) // 2\n            if nums[mid] <= x:\n                return bisect(x, mid, high)\n            else:\n                return bisect(x, low, mid)\n        \n        \n        # generate combination number\n        for idx in range(1, len(D)):\n            D[idx] = D[idx-1] * 2\n        \n        # print (D)\n        \n        n = len(nums) - 1\n        for idx, i in enumerate(nums):\n            if i > target - i:\n                break\n            else:\n                # print(target - i, idx, n)\n                best = bisect(target - i, idx, n)\n                # print ('best', best, 'idx', idx)\n                n = best \n                cnt += D[best - idx]\n                \n        # print (D)\n        return cnt % N\n        \n        \n", "class Solution:\n    def __init__(self):\n        mod = 1e9+7\n        self.two_power = [0]*100010\n        self.two_power[0] = 1\n        for i in range(1,len(self.two_power)):\n            num = self.two_power[i-1]*2\n            if num > mod: num%=mod\n            self.two_power[i] = num\n            \n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 1e9+7\n        nums = sorted(nums)\n        sind = 0\n        eind = len(nums)-1\n        ans = 0\n        \n        # print(self.two_power[:20])\n        \n        while sind <= eind:\n            if nums[sind]+nums[eind] > target:\n                eind-=1\n            else:\n                ans+=self.two_power[eind-sind]\n                if ans > mod: ans%=mod\n                sind+=1\n        return int(ans)", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n    '''\n    \n    #Version 3: Sliding window\n    #Consider the valid count\n    #TC: O(n^2), SC: O(1)\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pow(2, k, M)\n            else:\n                base = bisect_left(nums, target - nums[k] + 1)\n                ans += (pow(2, base, M) - 1) * pow(2, k-base, M)\n            #print(k, base, ans)\n        return ans % M\n\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        a = nums\n        a.sort()\n        t = target\n        while a and a[-1] > t:\n            a.pop()\n       # ans = sum([2 * x <= t for x in a])\n        ans = 0\n        l, h = 0, len(a) - 1\n        M = 10 ** 9 + 7\n        while l <= h:\n            while l <= h and a[h] + a[l] > t:\n                h -= 1\n            if l <= h and a[h] + a[l] <= t:\n                ans += ((1 << (h - l)))\n                ans %= M\n            l += 1\n        return ans\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        le = len(nums)\n        res = 0\n        mod=10**9+7\n        for i in range(le):\n            if nums[i]*2<=target:\n                lo,hi = i,le-1\n                while hi>lo:\n                    mid = (hi+lo+1)//2\n                    if nums[i]+nums[mid]<=target:\n                        lo = mid\n                    else:\n                        hi = mid-1\n                res += pow(2,lo-i,mod)\n                res%=mod\n            else:\n                break\n        return res", "class Solution:\n    def numSubseq(self, A: List[int], target: int) -> int:\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod) #For each elements in the subarray A[i+1] ~ A[j],we can pick or not pick\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10**9 + 7\n        sum, l, r = 0, 0, len(nums)-1\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                sum += (1 << r-l) % mod\n                l += 1\n        return sum % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        subsequences = 0\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                subsequences += 1<<(r-l)\n                l += 1\n            else:\n                subsequences += 1 if 2*nums[r] <= target else 0\n                r -= 1\n            subsequences %= 1000000007\n        return subsequences", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left_idx = 0\n        right_idx = len(nums) - 1\n        res = 0\n        mod = 10**9 + 7\n        while left_idx <= right_idx:\n            if nums[left_idx] + nums[right_idx] > target:\n                right_idx -= 1\n            else:\n                res += 1 << (right_idx - left_idx)\n                res %= mod\n                left_idx += 1\n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        if nums[0] * 2 > target:\n            return 0\n        \n        MOD = 10 ** 9 + 7\n        count = 0\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                count = (count + (1 << (right - left))) % MOD\n                left += 1\n        return count", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        l, r = 0,len(nums)-1\n        MOD = 10**9+7 \n        res = 0\n        while l<=r:\n            if nums[l]+nums[r] > target:\n                r -= 1\n            else:\n                res = (res + (1<<(r-l))) % MOD\n                # print(res)\n                l += 1\n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        if nums[0] * 2 > target:\n            return 0\n        \n        MOD = 10 ** 9 + 7\n        count = 0\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                # need to use fast_pow here\n                count = (count + (1 << (right - left))) % MOD\n                left += 1\n        return count", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n     \n        nums.sort()\n        n = len(nums)\n        left = 0\n        right = n - 1\n        res = 0\n        mod = 10 **9 + 7\n        \n        while left <=right:\n            while left <= right and nums[right] + nums[left] > target:\n                right-= 1\n            if right < left:\n                return res\n            res = (res + (1 <<  (right - left))) % mod\n            left+= 1\n        \n        \n        return res;\n       \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n        ans = 0\n        r = len(nums) - 1\n        for l in range(len(nums)):\n            while l <= r and nums[l] + nums[r] > target:\n                r -= 1\n            if l <= r:\n                ans += 1 << (r - l)\n                ans %= MOD\n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        if nums[0] * 2 > target:\n            return 0\n        \n        MOD = 10 ** 9 + 7\n        count = 0\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            while left <= right and nums[left] + nums[right] > target:\n                right -= 1\n            if right < left:\n                break\n            count = (count + (1 << (right - left))) % MOD\n            left += 1\n        return count", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        nums.sort()\n        \n        ans = 0\n        \n        for i in range(len(nums)):\n            \n            if 2 * nums[i] <= target:\n                ans += 1\n                \n            lo, hi = i + 1, len(nums) - 1\n            \n            while lo < hi:\n                m = (lo + hi) // 2 + 1\n                \n                if nums[i] + nums[m] > target:\n                    hi = m - 1\n                else:\n                    lo = m\n\n            if nums[i] + nums[hi] <= target:\n                ans += (1 << (hi - i)) - 1\n                \n        return ans % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10**9 + 7\n        left = 0\n        right = len(nums) - 1\n        res = 0 \n        while(left <= right):\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                num_inside = right - left\n                res = (res + pow(2, num_inside, mod)) % mod\n                left += 1\n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        a = nums\n        a.sort()\n        t = target\n        while a and a[-1] > t:\n            a.pop()\n        ans = sum([2 * x <= t for x in a])\n        l, h = 0, len(a) - 1\n        M = 10 ** 9 + 7\n        while l + 1 <= h:\n            while l + 1 <= h and a[h] + a[l] > t:\n                h -= 1\n            if l + 1 <= h and a[h] + a[l] <= t:\n                ans += ((1 << (h - l)) - 1)\n                ans %= M\n            l += 1\n        return ans\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        le = len(nums)\n        res = 0\n        mod=10**9+7\n        for i in range(le):\n            if nums[i]*2<=target:\n                lo,hi = i,le-1\n                while hi>lo:\n                    mid = (hi+lo+1)//2\n                    if nums[i]+nums[mid]<=target:\n                        lo = mid\n                    else:\n                        hi = mid-1\n                res += pow(2,lo-i,mod)\n        return res %mod", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n    '''\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pow(2, k, M)\n            else:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                ans += (pow(2, base, M) - 1) * pow(2, k-base, M)\n            #print(k, base, ans)\n        return ans % M\n\n", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n    '''\n    \n    #Version 3: Sliding window\n    #Consider the valid count\n    #TC: O(n^2), SC: O(1)\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pow(2, k, M)\n            else:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                ans += (pow(2, base, M) - 1) * pow(2, k-base, M)\n            #print(k, base, ans)\n        return ans % M\n\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        ans = 0\n        mod = 10 ** 9 + 7\n        nums.sort()\n        temp = 0\n        def bina(i,low,high):\n            ans = low - 1 \n            while(low<=high):\n                mid = (low + high)//2\n                if nums[i] + nums[mid] <= target:\n                    low = mid + 1\n                    ans = mid\n                else:\n                    high = mid - 1\n            return ans - i\n\n        for i in range(len(nums)):\n            if nums[i]*2 > target:\n                break\n            ans = (ans + int(pow( 2,bina(i,i,len(nums)-1) ,mod) ))%mod\n        return ans\n        \n        \n        \n                \n", "# binary search, O(nlogn)\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n        \n        def bsearch(t, l, r):\n            if l > r: return -1\n            while l < r:\n                m = (l + r + 1) // 2\n                if nums[m] <= t:\n                    l = m\n                else:\n                    r = m - 1\n            return l if nums[l] <= t else -1\n        \n        res = 0\n        for i, n in enumerate(nums):\n            ind = bsearch(target - n, 0, i - 1)\n            must_have = pow(2, ind + 1, MOD) - 1\n            may_have = pow(2, max(0, i - ind - 1), MOD)\n            res = (res + must_have * may_have) % MOD\n            \n        # add special case of single element subsequence\n        res = (res + sum(2 * n <= target for n in nums)) % MOD\n        return res\n        # AC: 2320 ms, beats 41.74%, 25.2 MB, beats 81.62%\n            \n", "# binary search, O(nlogn)\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n        \n        def bsearch(t, l, r):\n            if l > r: return -1\n            while l < r:\n                m = (l + r + 1) // 2\n                if nums[m] <= t:\n                    l = m\n                else:\n                    r = m - 1\n            return l if nums[l] <= t else -1\n        \n        res = 0\n        for i, n in enumerate(nums):\n            ind = bsearch(target - n, 0, i - 1)\n            must_have = pow(2, ind + 1, MOD) - 1\n            may_have = pow(2, max(0, i - ind - 1), MOD)\n            res = (res + must_have * may_have) % MOD\n            \n        # add special case of single element subsequence\n        res = (res + sum(2 * n <= target for n in nums)) % MOD\n        return res\n        # AC: ms, beats, MB, beats\n            \n", "MD = 10 ** 9 + 7\n\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if nums is None or not nums:\n            return 0\n        \n        N = len(nums)\n        \n        nums.sort()\n        \n        start = 0\n        end = N - 1\n        \n        ret = len([d for d in nums if d + d <= target])\n        \n        while start < end:\n            while start < end and nums[start] + nums[end] > target:\n                end -= 1\n                \n            if start < end:\n                ret = (ret + self.fast_pow(2, MD, end - start) - 1) % MD\n                start += 1\n                \n        return ret\n    \n    def fast_pow(self, a, md, n):\n        if n == 0:\n            return 1 % md\n        \n        if n == 1:\n            return a % md\n        \n        ret = self.fast_pow(a, md, n // 2)\n        ret = (ret * ret ) % md\n        \n        if n % 2 == 1:\n            ret = (ret * a) % md\n        \n        return ret\n", "class Solution:\n\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        ans = 0\n        m = 10 ** 9 + 7\n        nums.sort()\n        while l <= r:\n            if (nums[l] + nums[r] > target):\n                r -= 1\n            else:\n                ans += pow(2, r - l, m)\n                l += 1\n        return ans % m", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        ## two pointer solution\n        nums.sort()\n        ans = 0\n        for i in range(len(nums)):\n            if 2*nums[i]>target:\n                break\n            hi = len(nums)-1\n            lo = i\n            while lo<=hi:\n                mid = (hi+lo)//2\n                if nums[i]+nums[mid] > target:\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n            ans = ( ans+ (( 1<<(hi-i)) ) )% (10**9+7) \n        return ans            \n        \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        mod = 10**9 + 7\n        i, n = 0, len(nums)\n        pows = [0] * n\n        p = 1\n        while i < n:\n            pows[i] = p\n            p = 2 * p\n            i += 1\n        \n        # print(pows)\n        # print(nums)\n        l, r = 0, n-1\n        res = 0\n        while l <= r:\n            # print(l, r)\n            if nums[l] + nums[r] <= target:\n                res = (res + pows[r-l]) % mod\n                l += 1\n            else:\n                r -= 1\n                \n        return int(res)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        j = len(nums)-1\n        ans = 0\n        for i, n in enumerate(nums):\n            while j >= i and n + nums[j] > target:\n                j -= 1\n            if j >= i:\n                ans += 1 << (j-i)\n                ans %= 1000000007\n        return ans", "class Solution:\n    def get_val(self,arr,i,m1,m2,target):\n        if(i==len(arr)):\n            return 0\n        x = m1\n        y = m2\n        ct = 0\n        if(m1+m2<target):\n            ct += 1\n        for j in range(i+1,len(arr)):\n            m1 = min(x,arr[j])\n            m2 = max(y,arr[j])\n            if(m1+m2>target):\n                continue\n            ct += self.get_val(arr,j,m1,m2,target)\n        return ct\n    \n    def get_smallest_idx(self,arr,i,j,x):\n        if(arr[i]>x):\n            return -1\n        l = i\n        h = j\n        while(l<=h):\n            mid = int((l+h)/2)\n            if(arr[mid]>x):\n                h = mid -1\n            else:\n                if(mid==h or arr[mid+1]>x):\n                    return mid\n                else:\n                    l = mid + 1\n        \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        '''ct = 0\n        for i in range(len(nums)):\n            m1 = nums[i]\n            m2 = nums[i]\n            ct += self.get_val(nums,i,m1,m2,target)\n        return ct%(10**9+7)'''\n        \n        nums.sort()\n        ct = 0\n        N = len(nums)\n        j = N-1\n        s = [1 for i in range(N)]\n        for i in range(1,N):\n            s[i] = 2*s[i-1]\n        for i in range(N):\n            while(j>=i and nums[i]+nums[j]>target):\n                j -= 1\n            if(j<i):\n                return ct%(10**9+7)\n            ct += s[j-i]\n        return ct%(10**9+7)\n        \n    \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l,r=0,len(nums)-1\n        ans=0\n        while(l<=r):\n            # print(l,r,ans)\n            if(nums[l]+nums[r]<=target):\n                ans=(ans+(1<<(r-l)))%(10**9+7)\n                l+=1\n            else:\n                r-=1\n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        N = 10**9+7\n        \n        counts = Counter([num for num in nums if num < target])        \n        nums = sorted(list(counts.keys()))\n        total = sum(counts.values())\n        ans = 0\n        left, right = 0, len(nums)-1\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                a = counts[nums[left]]\n                total -= a\n                ans = (ans + ((1<<a)-1)*(1<<total)) % N\n                left += 1\n            else:\n                total -= counts[nums[right]]\n                right -= 1\n\n        return ans\n                \n        \n        \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        result = 0\n        right_boundary = len(nums) - 1\n        for index, num in enumerate(nums):\n            if num * 2 > target:\n                break\n            left = index\n            right = right_boundary\n            while left < right:\n                mid = (left + right + 1) // 2\n                if nums[mid] + num <= target:\n                    left = mid\n                else:\n                    right = mid - 1\n            right_boundary = left\n            tail_length = right_boundary - index\n            result += 1 << tail_length\n            result %= 10 ** 9 + 7\n        \n        return result\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        ## two pointer solution\n        nums.sort()\n        ans = 0\n        for i in range(len(nums)):\n            if 2*nums[i]>target:\n                break\n            hi = len(nums)-1\n            lo = i\n            while lo<=hi:\n                mid = (hi+lo)//2\n                if nums[i]+nums[mid] > target:\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n            print(hi)\n            ans = ( ans+ (( 1<<(hi-i)) ) )% (10**9+7) \n        return ans            \n        \n        \n", "class Solution:\n  def numSubseq(self, nums: List[int], target: int) -> int:\n    # One very important lesson to learn from this problem: if asking for subsequences, see if\n    # the problem requires some kind of ordering. If not, then you can safely sort the array!\n    # Any subset of A is a subsequence (if you put it back into the original order).\n    # This problem then becomes trivial. Sort nums, then for each A[i] find the maximum A[j]\n    # s.t. A[i] + A[j] <= target. Once you've found A[j], notice that every element in [i + 1, j]\n    # can be turned on or off, so that's 2^(j - i) subsequences (notice we cannot turn off A[i] because\n    # we are counting \\\"all subsequences whose min element is A[i]\\\"). How do we prove this counts\n    # every valid subsequence? Because every valid subsequence has a min element, and we consider\n    # every A[i] as the min element. So as long as our logic for finding \\\"number of subsequences whose\n    # min element is A[i]\\\" is correct, we should count all valid subsequences. \n    nums.sort()\n    ret, l, r = 0, 0, len(nums) - 1\n    \n    p, pw = [], 1\n    for d in range(len(nums)):\n      p.append(pw)\n      pw <<= 1\n      \n    while l <= r:\n      if nums[l] + nums[r] <= target:\n        ret = (ret + p[r - l]) % (10**9 + 7)  # count all subsequences whose min element is nums[l]\n        l += 1                                    # we never have to consider nums[l] as the min element again\n      else:\n        r -= 1\n    return ret\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, left, right = 0, 0, len(nums)-1        \n        # Get rid of numbers that can never be included in the subsequences\n        while right >= 0 and nums[right] + nums[left] > target:\n            right -= 1\n        \n        while right >= 0:\n            complement = target - nums[right]\n            if nums[right] <= complement:\n                if right >= left:\n                    ans += (1 << (right + 1)) - 1\n                else:\n                    ans += (1 << (left)) - 1\n                break\n            else:\n                while nums[left] <= complement:\n                    left += 1\n                \n                if left == right:\n                    ans += (1 << (left + 1)) - 2 # full empty & nums[right] itself\n                    break\n                else:\n                    ans += ((1 << left) - 1) * (1 << (right - left))            \n            right -= 1\n            # ans = ans % (10 ** 9 + 7)\n            \n        return ans % (10 ** 9 + 7)\n    \n    \n# [5,5]\n# 10\n\n# [4,6]\n# 10\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, left, right = 0, 0, len(nums)-1        \n        # Get rid of numbers that can never be included in the subsequences\n        while right >= 0 and nums[right] + nums[left] > target:\n            right -= 1\n        \n        while right >= left:\n            complement = target - nums[right]\n            if nums[right] <= complement:\n                ans += (1 << (right + 1)) - 1\n                break\n            else:\n                while nums[left] <= complement:\n                    left += 1\n                \n                if left == right:\n                    ans += (1 << (right + 1)) - 2 # full empty & nums[right] itself\n                else:\n                    ans += ((1 << left) - 1) * (1 << (right - left))            \n            right -= 1\n            \n        return ans % (10 ** 9 + 7)\n    \n    \n# [5,5]\n# 10\n\n# [4,6]\n# 10\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, left, right = 0, 0, len(nums)-1        \n        # Get rid of numbers that can never be included in the subsequences\n        while right >= 0 and nums[right] + nums[left] > target:\n            right -= 1\n        \n        while right >= 0:\n            complement = target - nums[right]\n            if nums[right] <= complement:\n                ans += (1 << (right + 1)) - 1\n                break\n            else:\n                while nums[left] <= complement:\n                    left += 1\n                \n                if left == right:\n                    ans += (1 << (right + 1)) - 2 # full empty & nums[right] itself\n                    break\n                else:\n                    ans += ((1 << left) - 1) * (1 << (right - left))            \n            right -= 1\n            \n        return ans % (10 ** 9 + 7)\n    \n    \n# [5,5]\n# 10\n\n# [4,6]\n# 10\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, left, right = 0, 0, len(nums)-1        \n        while right >= left:\n            complement = target - nums[right]\n            if nums[right] <= complement:\n                ans += (1 << (right + 1)) - 1\n                break\n            else:\n                while nums[left] <= complement:\n                    left += 1\n                \n                if left == right:\n                    ans += (1 << (right + 1)) - 2 # full empty & nums[right] itself\n                else:\n                    ans += ((1 << left) - 1) * (1 << (right - left))            \n            right -= 1\n            \n        return ans % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        dic = dict()\n        for x in nums:\n            if x not in dic:\n                dic[x] = 0\n            dic[x] += 1\n        hulu = sorted(list(dic.keys()))\n        dahulu = [0]\n        for x in hulu:\n            dahulu.append(dahulu[-1]+dic[x])\n        dahulu = dahulu[1:]\n        # print(dahulu)\n        \n        output = 0\n        \n        start = 0\n        end = len(hulu)-1\n        while start<len(hulu):\n            while end>=start:\n                if hulu[start]+hulu[end]<=target:\n                    # print([1,start,end,output])\n                    output += (2**dic[hulu[start]]-1)*(2**(dahulu[end]-dahulu[start]))\n                    break\n                else:\n                    end -= 1\n            # print([start,end,output])\n            start += 1\n            \n            \n        return output%(10**9+7)\n                    \n                \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans = 0\n        M = 10 ** 9 + 7\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                ans += 2 ** (r - l)\n                l += 1\n        return ans % M", "class Solution:\n    def numSubseq(self, arr: List[int], target: int) -> int:\n        \n        arr=sorted(arr)\n        l=0\n        r=len(arr)-1\n        \n        mod=1000000007\n        ans=0\n        while(l<=r):\n            if(arr[l]+arr[r] > target):\n                r-=1    \n            else:\n                ans+=pow(2,r-l)\n                l+=1\n                \n        return ans%mod\n                \n\n        \n        \n        \n", "class Solution:\n    MOD = 10**9 + 7\n\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        nums.sort()\n        \n        count = 0\n        i, j = 0, n - 1\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n                \n                continue\n\n            len_ = j - i + 1\n            count += 2**(len_ - 1)\n                \n            i += 1\n                    \n        return count % self.__class__.MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        i, j = 0, n-1\n        while i <= j:\n            tot = nums[i] + nums[j]\n            if tot <= target:\n                count += int(2**(j-i)) \n                i += 1\n            else:\n                j -= 1\n         \n        return count % int(1e9 + 7)", "class Solution:\n    MOD = 10**9 + 7\n\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        nums.sort()\n        \n        count = 0\n        i, j = 0, n - 1\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n                \n                continue\n\n            len_ = j - i + 1\n            if len_ == 1:\n                count += 1\n            else:\n                count += 2**(len_ - 1)\n                \n            i += 1\n                    \n        return count % self.__class__.MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        res = 0\n        end = len(nums)-1\n        nums.sort()\n        for i in range(len(nums)):\n            while nums[i] + nums[end] > target:\n                if end > i:\n                    end = end-1\n                else:\n                    return res % (10**(9)+7)\n            res += pow(2, end - i)\n        return res % (10**(9)+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, left, right = 0, 0, len(nums)-1        \n        # Get rid of numbers that can never be included in the subsequences\n        while right >= 0 and nums[right] + nums[left] > target:\n            right -= 1\n        \n        while right >= 0:\n            complement = target - nums[right]\n            if nums[right] <= complement:\n                if right >= left:\n                    ans += (1 << (right + 1)) - 1\n                else:\n                    ans += (1 << (left)) - 1\n                break\n            else:\n                while nums[left] <= complement:\n                    left += 1\n                \n                if left == right:\n                    ans += (1 << (left + 1)) - 2 # full empty & nums[right] itself\n                    break\n                else:\n                    ans += ((1 << left) - 1) * (1 << (right - left))            \n            right -= 1\n            ans = ans % (10 ** 9 + 7)\n            \n        return ans % (10 ** 9 + 7)\n    \n    \n# [5,5]\n# 10\n\n# [4,6]\n# 10\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r, count = 0, len(nums)-1, 0\n        mod = 10**9 + 7\n        while l <= r:\n            sums = nums[l] + nums[r]\n            if sums > target:\n                r -= 1\n            else:\n                count += 2**(r-l)\n                l += 1\n        return count % mod\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        # time O(nlogn); space O(1)\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        res = 0\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                res += pow(2, right-left)\n                left += 1\n            else:\n                right -= 1\n        \n        return res % (10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        if nums[0]*2>target:\n            return 0\n        \n        res=0\n        l,r=0,len(nums)-1\n        while l<=r:\n            if nums[l]+nums[r]<=target:\n                res+=2**(r-l)\n                l+=1\n            else:\n                r-=1\n        return res%(10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += 2 ** (r - l)\n                l += 1\n        return res % (10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        res = 0\n        nums.sort()\n        start, end = 0, len(nums) - 1\n        while start < end:\n            if nums[start] + nums[end] <= target:\n                res += pow(2, end - start)\n                start += 1\n            else:\n                end -= 1\n        \n        if nums[start] * 2 <= target:\n            res += 1\n\n        _, res = divmod(res, pow(10, 9) + 7)\n        return res\n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res = 0\n        i = 0\n        j = len(nums) - 1\n        while i < len(nums):\n            \n            if target - nums[i] < nums[i]: \n                i = i + 1\n                continue\n            while j > i:\n                if nums[j] + nums[i] <= target: break\n                j = j - 1\n            res = 2**(j - i) + res\n            i = i + 1\n        return res % (10**9+7)\n    \n", "from typing import List\n\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int: \n        res = 0\n        end = len(nums)-1\n        nums.sort()\n        for start in range(len(nums)):\n            while nums[start] + nums[end] > target:\n                if end > start:\n                    end -= 1\n                else:\n                    return res % (10**9 + 7)\n            res += 2 ** (end - start)\n        return res % (10**9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        ans, mod = 0, 10 ** 9 + 7\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                ans += 2 ** (r - l)\n                l += 1\n            else:\n                r -= 1\n        return ans % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        nums.sort()\n        \n        l,r = 0,len(nums)-1\n        \n        res = 0\n        \n        while l <= r:\n            \n            if nums[l] + nums[r] > target:\n                \n                r -= 1\n                \n            else:\n                \n                res += pow(2,r-l)\n                \n                l += 1\n        \n        return res % ((10**9) + 7)\n                \n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        print(nums)\n\n        left = 0\n        right = len(nums) - 1\n\n        res = 0\n\n        while(left < right):\n\n            min_v = nums[left]\n            max_v = nums[right]\n\n            sum = min_v + max_v\n\n            if sum <= target:\n                count = right - left \n                res = res + 2**count\n                left += 1\n            else:\n                right -= 1\n\n        if nums[left]*2 <= target:\n            res += 1\n\n        return res % (10**9 + 7)\n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        power_set = 0\n        \n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                power_set += 2 ** (right - left)\n                left += 1\n            \n            elif nums[left] + nums[right] > target:\n                right -= 1\n        \n        return power_set % (10 ** 9 + 7) \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l = 0\n        r = len(nums) - 1\n        res = 0\n        while True :\n            while r >= l and (nums[l] + nums[r]) > target :\n                r = r - 1\n            #print(l, r)\n            if l <= r :\n                res = res + (2 ** (r - l))\n            else :\n                break\n            l = l + 1\n        return res % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10**9 + 7\n        nums.sort()\n        n = len(nums)\n        left = 0\n        right = n - 1\n        count = 0\n        while left <= right:\n            t = nums[left] + nums[right]\n            if t > target:\n                right -= 1\n            else:\n                count += 2**(right - left)\n                left += 1\n            \n        return count % mod\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n\n        res = 0\n        l = 0\n        n = len(nums)\n        pow2 = [1]\n        for x in range(1, n + 1):\n            pow2.append(pow2[-1] * 2 % MOD)\n        \n        j = n - 1\n        for i in range(n):\n            while j and nums[i] + nums[j] > target:\n                j -= 1\n            if i <= j and nums[i] + nums[j] <= target:\n                res += pow2[j - i]\n                res %= MOD\n        return res\n        \n        # self made, two pointer, TLE, too many redundant calculations\n        MODULO = 10 ** 9 + 7\n        nums.sort()\n        \n        res = 0\n        l = 0\n        n = len(nums)\n        \n        while l < n and nums[l] * 2 <= target:\n            r = l\n            while r < n and nums[l] + nums[r] <= target:\n                r += 1\n            if l <= r < n:\n                if l == r and nums[l] + nums[r] <= target:\n                    res += 1\n                elif l < r and nums[l] + nums[r - 1] <= target:\n                    res += (2 ** (r - l - 1)) % MODULO\n            elif r == n and nums[l] + nums[r - 1] <= target:\n                r -= 1\n                res += (2 ** (r - l)) % MODULO\n            l += 1\n        return res % MODULO\n        \n        # self made, DFE, TLE\n#         self.res = 0\n#         end_idx = bisect.bisect_left(nums, target)\n#         self.dfs(nums, 0, end_idx, [], target)\n\n#         return self.res % MODULO\n\n#     def dfs(self, nums, start, end_idx, cur, target):\n#         if cur and cur[0] + cur[-1] > target:\n#             return\n\n#         if cur and cur[0] + cur[-1] <= target:\n#             self.res += 1\n\n#         for i in range(start, end_idx):\n#             if nums[start] > target:\n#                 return\n#             cur.append(nums[i])\n#             self.dfs(nums, i + 1, end_idx, cur, target)\n#             cur.pop()\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        md=10**9 + 7\n        left=0\n        res=0\n        right=len(nums)-1\n        while(left<=right):\n            if nums[left]+nums[right]<=target:\n                res=(res+pow(2,right-left,md))%md\n                left=left+1\n            else:\n                right=right-1\n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i,j, count = 0, len(nums) - 1, 0\n        \n        while i <= j:    \n            if nums[i] + nums[j] <= target:\n                count += int(pow(2, j - i - 1) * 2)\n                i += 1\n            else:\n                j -= 1\n                \n        \n        return count % (pow(10, 9) + 7)", "import math\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i,j, count = 0, len(nums) - 1, 0\n        \n        while i <= j:    \n            if nums[i] + nums[j] <= target:\n                count += math.floor(pow(2, j - i -1) * 2)\n                i += 1\n            else:\n                j -= 1\n                \n        \n        return count % (pow(10, 9) + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        \n        nums.sort()\n        \n        MOD = 10 ** 9 + 7\n        \n        res = 0\n        j = len(nums) - 1\n        \n        for i in range(len(nums)):\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n                \n            if i <= j and nums[i] + nums[j] <= target:\n                res = (res + 2 ** (j - i))\n                if res >= MOD:\n                    res -= MOD\n            \n        return res % MOD", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n    '''\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pow(2, k, M)\n            else:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                ans += ((pow(2, base)-1) % M) * pow(2, k-base, M)\n            #print(k, base, ans)\n        return ans % M\n\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l = len(nums)\n        left = 0\n        right = l -1\n        ans = 0\n        while left <= right:\n            curr = nums[left]\n            leftover = target - curr\n            if leftover < curr:\n                return ans % (10 ** 9 + 7 )\n            ans += 1\n            while nums[right] > leftover:\n                right -= 1\n            ans += 2 ** (right - left) - 1\n            left += 1\n        return ans % (10 ** 9 + 7)\n            \n            \n", "class Solution:\n    def numSubseq(self, A: List[int], target: int) -> int:\n        A.sort()\n        l = 0\n        r = len(A) - 1\n        res = 0\n        mod = 10 ** 9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2,r - l,mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        cnt = 0\n        for i, n in enumerate(nums):\n            if n+n>target:\n                break\n                    \n            if n+nums[-1]<=target:\n                R = len(nums)\n                cnt += 2**(R-i-1)\n                continue\n            \n            L = i\n            R = len(nums)-1\n            while L<R:\n                mid = L+(R-L)//2\n                if n+nums[mid]<=target:\n                    L = mid+1\n                else:\n                    R = mid\n            cnt += 2**(R-i-1)\n            # print (n, i, R, cnt)\n        return cnt%(10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        nums.sort()\n        result = 0\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                result += 2**(right - left)\n                left += 1\n            else:\n                right -= 1\n        return result % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        j = len(nums)-1\n        flag = False\n        ans = 0\n        for i in range(len(nums)):\n            if flag:\n                if nums[i]*2 > target:\n                    break\n                ans += 1\n                \n            else:\n                while j>=i and nums[j]+nums[i] > target:\n                    j -= 1\n\n                if j>i:\n                    ans += 2**(j-i)\n                else:\n                    if nums[i]*2 > target:\n                        break\n                    ans += 1\n                    flag = True\n                         \n        return ans%(10**9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        res = 0\n        i1, i2 = 0, len(nums) - 1\n        while i1 <= i2:\n            if nums[i1] + nums[i2] <= target:\n                res += 2**(i2-i1)\n                i1 += 1\n            else:\n                i2 -= 1\n        return res % (10**9 + 7)\n\n", "import math\n\nclass Solution:\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        res = 0\n        md = 10**9+7\n        \n        while left <= right:\n            if nums[left] + nums[right] <= target:\n               \n                res += pow(2, right - left) \n                left += 1\n            else:\n                right -= 1\n        return res % md", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        nums.sort()\n        ans =  0\n        l, r = 0, N-1\n        \n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                ans += 2**(r-l)\n                l += 1\n        \n        return ans % (10**9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10 ** 9 + 7\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        ans = 0\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                ans += 2 ** (right - left)\n                left += 1\n        return ans % mod\n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l = count = 0\n        r = len(nums) - 1\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:    \n                count += 2 ** (r - l)\n                l += 1\n        return count % (10 ** 9 + 7)\n            \n            \n             \n            \n", "import math\n\nclass Solution:\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        res = 0\n        md = 10**9+7\n        \n        #print(nums)\n        \n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                res += pow(2, right - left) \n                left += 1\n            else:\n                right -= 1\n        return res % md", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        cnt = 0\n        for i, n in enumerate(nums):\n            if i<len(nums)-1:\n                if n+n>target:\n                    continue\n            else:\n                if n+n>target:\n                    continue\n                    \n#             print ('ssss')\n                    \n            if n+nums[-1]<=target:\n                R = len(nums)\n                cnt += 2**(R-i-1)\n                continue\n            \n            L = i\n            R = len(nums)-1\n            while L<R:\n                mid = L+(R-L)//2\n                if n+nums[mid]<=target:\n                    L = mid+1\n                else:\n                    R = mid\n            cnt += 2**(R-i-1)\n            # print (n, i, R, cnt)\n        return cnt%(10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        # print(nums, len(nums))\n        count = 0\n        j = len(nums)-1\n        \n        for i in range(len(nums)):\n            while (nums[i]+nums[j]>target) & (i<j):\n                j -= 1\n            \n            if (i>j) | (nums[i]*2>target) :\n                break\n            # print(j-i, end=' & ')\n            count += 2**(j-i)\n            # count = count\n\n        return count%(10**9+7)\n", "class Solution:\n    def numSubseq(self, A: List[int], t: int) -> int:\n        A, n = sorted(A), len(A)\n        mod = (10 ** 9 + 7)\n        ret = 0\n        left, right = 0, n - 1\n        while left <= right:\n            while right >= left and A[left] + A[right] > t:\n                right -= 1\n            if right >= left and A[left] + A[right] <= t:\n                ret += 2 ** (right - left)\n            left += 1\n        return ret % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, i, j = 0, 0, len(nums) - 1\n        while i <= j:\n            if nums[i] + nums[j] <= target:\n                ans += 2 ** (j - i)\n                i += 1\n            else:\n                j -= 1\n        return ans % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l=0\n        r=len(nums)-1\n        res=0\n        mod=10**9+7\n        while l<=r:\n            if nums[l]+nums[r]>target:\n                r-=1\n            else:\n                res+=pow(2,r-l)\n                l+=1\n        return res%mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        print(nums)\n        l, r = 0, len(nums) - 1\n        res = 0\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += 2 ** (r - l)\n                l += 1\n        return res % (10 ** 9 + 7)\n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10 ** 9 + 7\n        left, right = 0, len(nums) - 1\n        res = 0\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                res += pow(2, right - left)\n                left += 1\n        return res % mod\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        i, j = 0, len(nums) - 1\n        res = 0\n        while i <= j:\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n            if i <= j and nums[i] + nums[j] <= target:\n                res += 2 ** (j - i)\n            i += 1\n        return res % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        nums.sort()\n        res = 0\n        left, right = 0, N - 1\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                res += 2 ** (right-left)\n                left += 1\n        return res % (10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        idx, res = len(nums)-1, 0\n        nums.sort()\n        for i in range(len(nums)):\n            while nums[i]+ nums[idx]> target and idx>=i:\n                idx-=1\n            if idx< i:\n                break\n            res += 2 ** (idx-i)\n            \n        return res%(10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        output, nums = 0, sorted(nums)\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                output += pow(2, r - l)\n                l += 1\n            else:\n                r -= 1\n        return output % (10 ** 9 + 7)\n    \n    # def numSubseq(self, A, target):\n    #     A.sort()\n    #     l, r = 0, len(A) - 1\n    #     res = 0\n    #     mod = 10**9 + 7\n    #     while l <= r:\n    #         if A[l] + A[r] > target:\n    #             r -= 1\n    #         else:\n    #             res += pow(2, r - l, mod)\n    #             l += 1\n    #     return res % mod\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        lo, hi, ans = 0, len(nums) - 1, 0\n        while lo <= hi:\n            if nums[lo] + nums[hi] > target:\n                hi -= 1\n                continue\n            ans += 2 ** (hi - lo)\n            lo += 1\n        return ans % (10**9 + 7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        start = 0\n        end = len(nums)-1\n        ans = 0\n        mod = 10**9 + 7\n        \n        while start<=end:\n            while nums[start]+nums[end]>target:\n                end -= 1\n                if start>end:\n                    return ans%mod\n            \n            ans += 2**(end-start)\n            start += 1\n            \n        return ans%mod\n        \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        m = 10 ** 9 + 7\n        l = 0\n        r = len(nums) - 1\n        res = 0\n        \n        while l <= r:\n            while l <= r and nums[l] + nums[r] > target:\n                r -= 1\n            if l <= r:\n                res += 2 ** (r - l)\n                l += 1\n            else:\n                break\n        return res % m", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l,r=0,len(nums)-1\n        re=0\n        while l<=r:\n            while r>=l and nums[l]+nums[r]>target:\n                r-=1\n            if r<l:\n                break\n            re+=2**(r-l)\n            l+=1\n        return re%1000000007\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        # print(nums, len(nums))\n        count = 0\n        j = len(nums)-1\n        \n        for i in range(len(nums)):\n            while (nums[i]+nums[j]>target) & (i<j):\n                j -= 1\n            \n            if (i>j) | (nums[i]*2>target) :\n                break\n            # print(j-i, end=' & ')\n            count += pow(2, j-i)\n            # count = count\n\n        return count%(10**9+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        count = 0\n        nums.sort()\n        left, right = 0, len(nums)-1\n        \n        while left <= right:\n            x0 = nums[left]\n            if x0 + nums[right] > target:\n                right -= 1\n                continue\n            \n            count += 2**(right-left)\n            left += 1\n            \n        return count % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        count = 0\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                count += 2**(right - left)\n                left += 1\n            else:\n                right -= 1\n        return count % (10**9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        low = 0\n        high = len(nums)-1\n        total = 0\n        while low < len(nums):\n            while high > low and nums[low] + nums[high] > target:\n                high -= 1\n            s = nums[low] + nums[high]\n            if s > target:\n                break\n            total += 2 ** (high - low)\n            low += 1\n            high = max(high, low)\n        return total % (10 ** 9 + 7)             \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        \n        nums.sort()\n        res = 0\n        lo, hi = 0, len(nums)-1\n        \n        while lo <= hi:\n            if nums[lo]+nums[hi] > target:\n                hi -= 1\n            else:\n                res += pow(2, hi-lo)\n                lo += 1\n        \n        return res % (pow(10,9)+7)", "from collections import Counter\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        c = Counter(nums)\n        nums = []\n        for k, v in sorted(list(c.items()), key=lambda x:x[0]):\n            nums.extend([k]*v)\n        res = 0\n        i1, i2 = 0, len(nums) - 1\n        while i1 <= i2:\n            if nums[i1] + nums[i2] <= target:\n                res += 2**(i2-i1)\n                i1 += 1\n            else:\n                i2 -= 1\n        return res % (10**9 + 7)\n\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n\n        left = 0\n        right = len(nums) - 1\n\n        result = 0\n\n        while True:\n\n            while left <= right and (nums[left] + nums[right] > target):\n                right -= 1\n\n            if right < left:\n                break\n\n            print((left, right))\n            result += pow(2, right - left)\n\n            left += 1\n\n        return result % (10**9 + 7)\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n\n        left = 0\n        right = 0\n\n        while right < len(nums) and (nums[left] + nums[right] <= target):\n            right += 1\n\n        right -= 1\n\n        result = 0\n\n        while True:\n\n            while left <= right and (nums[left] + nums[right] > target):\n                right -= 1\n\n            if right < left:\n                break\n\n            print((left, right))\n            result += pow(2, right - left)\n\n            left += 1\n\n        return result % (10**9 + 7)\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        print(nums, len(nums))\n        count = 0\n        j = len(nums)-1\n        \n        for i in range(len(nums)):\n            while (nums[i]+nums[j]>target) & (i<j):\n                j -= 1\n            \n            if (i>j) | (nums[i]*2>target) :\n                break\n            print(j-i, end=' & ')\n            count += 2**(j-i)\n        \n        print(i, j)\n        return count%(10**9+7)\n            ", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left = 0\n        right = len(nums)-1\n        mod = (10**9) + 7\n        out = 0\n        while left<=right:\n            if nums[left]+nums[right] > target:\n                right -= 1\n            elif nums[left]+nums[right]<=target:\n                space = right-left\n                out += pow(2, space)\n                left += 1\n             \n               \n        return out%mod        ", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i=0\n        count=0\n        j=len(nums)-1\n        while i<len(nums) and nums[i]*2<=target:\n            #count+=1\n            while i<j and nums[i]+nums[j]>target:\n                j-=1\n                \n            #print(i,j,nums[i],nums[j])\n            count+=2**(j-i)\n            i+=1\n        return count%(10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        module = 10 ** 9 + 7\n        ret = 0\n        lo, hi = 0, n - 1\n        while lo <= hi:\n            if nums[lo] + nums[hi] > target:\n                hi -= 1\n            else:\n                ret += 1 << (hi - lo)\n                lo += 1\n        return ret % module", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        i = 0 \n        j = len(nums) - 1\n        count = 0\n        mod = 10 ** 9 + 7\n        nums.sort()\n        while i < len(nums) and j < len(nums):\n            while nums[j] + nums[i] > target and i <= j:\n                j -= 1\n            \n            if nums[j] + nums[i] <= target and i <= j:\n                count += 2 ** (j - i)\n            \n            i += 1\n        \n        return int(count % mod)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        nums.sort()\n        answer = 0\n        for i in range(N):\n            current_num = nums[i]\n            low = i + 1\n            high = N-1\n            while low <= high:  \n                middle = (low + high)//2\n                if current_num + nums[middle] > target:\n                    high = middle - 1\n                else:\n                    low = middle + 1\n\n            if current_num + nums[high] <= target:\n                answer += (2 ** (high - i))\n\n        return answer % ((10**9) + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        right = len(nums) - 1\n        left = 0\n        ret = 0\n        \n        \n        while (left < right):   \n            if (nums[left] * 2 <= target):\n                ret += 1\n            \n            max_right = target - nums[left]\n            \n            \n            while (left < right and max_right < nums[right]):  \n                if (nums[right] * 2 <= target):\n                    ret += 1\n                    \n                right -= 1\n\n                \n            if (left < right):  \n                ret += 2 ** (right - left) - 1\n            else:\n                return ret % 1000000007 \n                \n            left += 1\n       \n        \n        if (nums[right] * 2 <= target):\n            ret += 1\n            \n        return ret % 1000000007 ", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        right = len(nums) - 1\n        left = 0\n        ret = 0\n        \n        \n        while (left < right):   \n            max_right = target - nums[left]\n            \n            \n            while (left < right and max_right < nums[right]):   \n                right -= 1\n\n                \n            if (left < right):  \n                ret += 2 ** (right - left) - 1\n                \n            left += 1\n                \n                \n        for i in range(len(nums)):\n            if (nums[i] * 2 > target):\n                break\n                \n            ret += 1\n        \n        return ret % 1000000007     ", "\nclass Solution:\n    def numSubseq(self, x: List[int], t: int) -> int:\n        def bi(lo,hi,val):\n            while lo<=hi:\n                m=(lo+hi)//2\n                if x[m]<=val:\n                    lo=m+1\n                else:hi=m-1\n            return lo-1\n        x.sort()\n        l=len(x)\n        ans=0\n        for i in range(l):\n            if t-x[i]>=x[i]:\n                ind=bi(i,l-1,t-x[i])\n                ans+=2**(ind-i)\n            else:break\n        return ans%(10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        ans = 0\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i]*2 > target:\n                break\n            l, r = i, len(nums)-1\n            while l+1 < r:\n                mid = (l+r)//2\n                if nums[i] + nums[mid] > target:\n                    r = mid\n                else:\n                    l = mid\n            if nums[i] + nums[r] <= target:\n                ind = r\n            else:\n                ind = l\n            ans += 2**(ind-i)\n        return ans%(10**9+7)\n", "#3:56\n\nclass Solution:\n    def find_endindex(self, nums, ind, target):\n        start = ind\n        end = len(nums) -1\n        \n        while start < end:\n            mid = (start + end)//2\n            if nums[mid] + nums[ind] > target:\n                end = mid\n            else:\n                start = mid + 1\n                \n        if nums[start] + nums[ind] > target:\n            start -= 1\n        \n        #if start >= ind:\n        return 2**(start - ind)\n        #else:\n        #    return 0\n        \n        \n        \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums2 = sorted(nums)\n        result = 0\n        if nums2[0] > target:\n            return result\n        \n        for i in range(len(nums2)):\n            if nums2[i]*2 <= target:\n                res = self.find_endindex(nums2, i, target)\n                #print (i, res)\n                result += res\n            else:\n                break\n            \n        return result%(10**9 + 7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        # sort first\n        nums.sort()\n        \n        # sliding windows        \n        n = len(nums)\n        res = 0\n        \n        #one length subsequence\n        mod = 10**9 + 7\n        i,j = 0,n-1\n        \n        # -> <-\n        \n        # i: min start, move -> \n        for i in range(n):  \n            # j: max, move <- until we find the boundary\n            while j>=i and nums[i]+nums[j] > target:\n                j -= 1 \n            # anything in between [i,j] is answer. You always have i as _min + subsets of (j-i) would be answer. # combo = 2^(j-i)      \n            if i<=j and nums[i] + nums[j] <= target:\n                res += pow(2,(j-i) , mod)\n                res %= mod\n        \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        result = 0\n        for i in range(len(nums)):\n            if nums[i] <= target // 2:\n                left, right = i, len(nums) - 1\n                while left < right - 1:\n                    mid = (left + right) //  2\n                    if nums[mid] <= target - nums[i]:\n                        left = mid\n                    else:\n                        right = mid - 1\n                if nums[i] + nums[right] <= target:\n                    result += 2**(right - i)\n                elif nums[i] + nums[left] <= target:\n                    result += 2**(left - i)\n        return result % MOD\n                    \n                    \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        count = 0\n        \n        nums.sort()\n        \n        # print(nums)\n        \n        for i in range(len(nums)):\n            \n            if (nums[i] * 2) > target:\n                \n                break\n            \n            left = i\n        \n            right = len(nums) - 1\n            \n            while left < right:\n            \n                mid = (left + right + 1) // 2\n\n                if nums[i] + nums[mid] <= target:\n\n                    left = mid\n\n                else:\n\n                    right = mid - 1\n                    \n            # print(nums[i], nums[left])\n                    \n            count += (2 ** (left - i))\n                \n        return count % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        N = len(nums)\n        ans = 0\n        rgt = N-1\n        for lft in range(N):\n            # min is nums[lft]\n            if nums[lft] * 2 > target:\n                break\n                \n            # Find the largest rgt such that nums[lft] + nums[rgt] > target\n            lo, hi = lft, N-1\n            while lo + 1 < hi:\n                m = (lo + hi)//2\n                if nums[lft] + nums[m] <= target:\n                    lo = m\n                else:\n                    hi = m\n\n            # typically f[lo] <= target < f[hi]\n            # f[hi] <= target is possible\n            # f[lo] > target is impossible\n            if nums[lft] + nums[hi] > target:\n                ans += 2**(lo-lft)\n            else:\n                ans += 2**(hi-lft)\n                \n        return ans % (10**9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if len(nums) == 0:\n            return 0\n        nums.sort()\n        result = 0\n        for start in range(len(nums)):\n            left, right = start, len(nums) - 1\n            while left < right - 1:\n                mid = (left + right) // 2\n                if nums[mid] > target - nums[start]:\n                    right = mid - 1\n                else:\n                    left = mid\n            if nums[start] + nums[right] <= target:\n                end = right\n            elif nums[start] + nums[left] <= target:\n                end = left\n            elif nums[start] + nums[start] <= target:\n                end = start\n            else:\n                end = -1\n            if end > start:\n                result += 2 ** (end-start)\n            if end == start:\n                result += 1\n            #print(start, end, result)\n        return result % (10**9+7)\n                \n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res = 0\n        l = 0\n        r = len(nums) - 1\n        mod = 10 ** 9 + 7\n        while l <= r:                       ##min\u548cmax\u503c\u53ef\u4ee5\u76f8\u7b49\uff01\uff01\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += 2 ** (r - l) % mod\n                l += 1                  ##\u8fd9\u4e2a\u5f00\u5934\u7684\u6700\u5927\u503c\uff01\uff01\n        return res % mod\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        n=len(nums)\n        p=[1]*(n+1)\n        for i in range(1,n+1):\n            p[i]=p[i-1]<<1\n        nums.sort()\n        res=0\n        j=n-1\n        for i in range(j+1):\n            #\u56fa\u5b9a\u8d77\u59cbi\u627e\u6700\u53f3\u7aef\u70b9\n            while i<=j and nums[i]+nums[j]>target:\n                j-=1\n            if i>j:\n                continue\n            #\u6b64\u65f6i--j\u4e4b\u95f4\u5b50\u5e8f\u5217\u90fd\u53ef\u4ee5\uff0c\n            #\u53ea\u8981\u6700\u5c0f\u503c\u4e3a\u7b2ci\u9879\n            '''\n            In subarray nums[i~j]:\n            min = nums[i], max = nums[j]\n            nums[i] + nums[j] <= target\n            {nums[i], (j - i - 1 + 1 values)}\n            Any subset of the right part gives a valid subsequence \n            in the original array. And There are 2^(j - i) ones.\n            '''\n            res+=2**(j-i)\n        return res%(10**9+7)", "class Solution:\n    MOD = 10**9 + 7\n\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        nums.sort()\n        \n        count = 0\n        i, j = 0, n - 1\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n                \n                continue\n\n            len_ = j - i + 1\n            count += (2**(len_ - 1)) % self.__class__.MOD\n                \n            i += 1\n                    \n        return count % self.__class__.MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        mod = (10**9+7)\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += 2 ** (r - l) % mod\n                l += 1\n        return res % (10**9+7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        result = 0\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                result = (result + 2 ** (r-l)) % (10**9 + 7)\n                l += 1\n                \n        return result", "class Solution:\n  def numSubseq(self, nums: List[int], target: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i, j, count = 0, n - 1, 0\n    while i <= j:\n      while i <= j and nums[i] + nums[j] > target:\n        j -= 1\n      if i <= j:\n        # nums[i] be the min, any combinations of nums[(i+1):(j+1)]\n        count += 1 << (j - i)\n      i += 1\n    return count % (10 ** 9 + 7)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        result = 0\n        mod = 10 ** 9 + 7\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                result = (result + 2 ** (r-l)) % mod\n                l += 1\n                \n        return result", "max_cap = 7 + (10 ** 9)\n\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        init_seq_len = len(nums)\n        nums.sort()\n\n        l = 0\n        r = init_seq_len - 1\n        count = 0\n        while (l <= r):\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                count += (2 ** (r - l) % max_cap)\n                l += 1\n        return (count % max_cap)", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        if not nums or target == 0 :\n            return 0\n        \n        \n        nums.sort()\n        \n        l, r = 0, len(nums) -1 \n        mod = 10**9 + 7\n        res = 0\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += (2**(r-l))%mod\n                l += 1\n        return res%mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i = 0\n        j = len(nums)-1\n        s = 0\n        while i<=j:\n            if nums[i]+nums[j] <= target:\n                s = (s + 2**(j-i))%(10**9 + 7)\n                i += 1\n            else:\n                j -= 1\n        return s", "MOD = 1000000007\nclass Solution:\n    def numSubseq(self, nums, target):\n        if not nums:\n            return 0\n        nums = sorted(nums)\n        n = len(nums)\n        left, right = 0, n - 1\n        res = 0\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                res += 2 ** (right - left) \n                res %= MOD\n                left += 1\n            else:\n                right -= 1\n        return res % MOD", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        MOD = 10**9 + 7\n        \n        i, j , ans = 0, len(nums)-1, 0\n        while i<=j:\n            if nums[i]+nums[j]<=target:\n                ans+=(2**(j-i))%MOD\n                i+=1\n            else:\n                j-=1\n        \n        return ans%MOD\n            \n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        ans, mod = 0, 10 ** 9 + 7\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                ans = (ans + 2 ** (r - l)) % mod\n                l += 1\n            else:\n                r -= 1\n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        i, j = 0, n-1\n        while i <= j:\n            tot = nums[i] + nums[j]\n            if tot <= target:\n                count += 2**(j-i) % int(1e9 + 7)\n                i += 1\n            else:\n                j -= 1\n         \n        return int(count % (1e9 + 7))", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        \n        nums.sort()\n        \n        MOD = 10 ** 9 + 7\n        \n        res = 0\n        i = 0\n        j = len(nums) - 1\n        \n        for i in range(len(nums)):\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n                \n            if i <= j and nums[i] + nums[j] <= target:\n                res = (res + 2 ** (j - i)) % MOD\n    \n            i += 1\n            \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        total = 0\n        right = n - 1\n        for i in range(len(nums)):\n            if nums[i] > target or right < i:\n                break\n            while right >= i and nums[i] + nums[right] > target:\n                right -= 1\n            if right < i:\n                break\n            if nums[i] + nums[right] <= target:\n                total = (total + 2 **(right - i)) % (10**9 + 7)\n             \n        return int(total) % (10**9 + 7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = 0\n        #one length subsequence\n        mod = 10**9 + 7\n        i,j = 0,n-1\n        \n        \n        for i in range(n):\n            while i<=j and nums[i]+nums[j] > target:\n                j-=1\n            \n            if i<=j and nums[i] + nums[j] <= target:\n                res += pow(2, j - i)\n                res %= mod\n        \n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        \n        nums.sort()\n        \n        MOD = 10 ** 9 + 7\n        \n        res = 0\n        i = 0\n        j = len(nums) - 1\n        \n        h = dict()\n        \n        while i < len(nums):\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n                \n            if i <= j and nums[i] + nums[j] <= target:\n                \n                if j-i not in h:\n                    h[j-i] = 2 ** (j - i)\n                \n                res = (res + h[j-i]) % MOD\n    \n            i += 1\n        \n            if i > j:\n                break\n            \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        sorted_nums = sorted(nums)\n        res = 0\n        mod = (10**9+7)\n        r = len(sorted_nums)-1\n        for i,left in enumerate(sorted_nums):\n            while left+sorted_nums[r] > target and i<=r:\n                r-=1\n            if i<=r:\n                res+=(2**(r-i))\n                res%=mod\n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        \n        nums.sort()\n        \n        MOD = 10 ** 9 + 7\n        \n        res = 0\n        i = 0\n        j = len(nums) - 1\n        \n        while i < len(nums):\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n                \n            if i <= j and nums[i] + nums[j] <= target:\n                res = (res + 2 ** (j - i)) % MOD\n    \n            i += 1\n        \n            if i > j:\n                break\n            \n        return res", "# if a .... b , where a<=b<=target\n#the # of subsquence starts with a = 2^(n-1), where n is len([a...b])\n\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums)-1\n        res = 0\n        nums.sort()\n        M = 10**9+7\n        while l<=r:\n            if nums[l] + nums[r] <= target:\n                res = (res + pow(2,r-l,M))%M\n                l+=1\n            else:\n                r-=1\n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        n, res, mod, j = len(nums), 0, 10**9 + 7, len(nums) - 1\n        \n        for i in range(n):\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n            \n            if i <= j and nums[i] + nums[j] <= target:\n                res += 2**(j-i) % mod\n                res %= mod\n        return res", "class Solution:\n    def numSubseq(self, nums, target: int) -> int:\n\n        n = len(nums)\n        nums.sort()\n        res = 0\n        i = 0\n        last = n-1\n        while i<n and 2*nums[i]<=target:\n            j = last\n            while j>=i and nums[i]+nums[j]>target:\n                j -= 1\n            last = j\n            if i == j:\n                res += 1\n            else:\n                res += 2**(j-i)   %1000000007\n            i += 1\n        return res%1000000007", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums)-1\n        res, mod = 0, 10**9+7\n        while l<=r:\n            sum_ = nums[l]+nums[r]\n            if sum_ <= target:\n                res += (2**(r - l))%mod\n                l += 1\n            else:\n                r -= 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        i, j = 0, len(nums) - 1\n        res = 0\n        \n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                res = (res + 2 ** (j - i)) % (10 ** 9 + 7)  # \u9664\u53bb\u5de6\u8fb9\u754c\u7684\u5143\u7d20\uff08\u56e0\u4e3a\u8981\u56fa\u5b9a\u5b83\u4f5c\u4e3amin\uff09\uff0c\u5bf9\u4e8e\u5b83\u53f3\u8fb9\u7684\u6240\u6709\u5143\u7d20\uff0c\u90fd\u6709\u9009\u548c\u4e0d\u9009\u4e24\u79cd\u53ef\u80fd\uff0c\u6240\u4ee5\u662f2^N\uff0cN\u662f\u53f3\u8fb9\u5143\u7d20\u6570\u91cf\n                i += 1\n        \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += 2 ** (r - l) % (10 ** 9 + 7)\n                l += 1\n        return res % (10 ** 9 + 7)\n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        i, j = 0, len(nums) - 1\n        ans  = 0\n        while i <= j:\n            if nums[i] + nums[j] <= target:\n                ans += 2**(j-i) % (10**9 + 7)\n                i += 1\n            else:\n                j -= 1\n        return ans % (10**9 + 7)\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        '''\n        Sort the array and grab min and max elements such that nums[min] + nums[max] <= target\n        Now in the substring nums[min : max]\n            min can be always selected and all combinations in [min + 1 to max] can be tried which would result in the substring having min = min and max <= max resulting in max - min <= target\n        This selection yields 2^(max - min) possibilities\n        '''\n        \n        nums.sort()\n        n = len(nums)\n        res = 0\n        #one length subsequence\n        mod = 10**9 + 7\n        i,j = 0,n-1\n        \n        \n        for i in range(n):\n            while i<=j and nums[i]+nums[j] > target:\n                print((nums[i], nums[j]))\n                j-=1\n            \n            if i<=j and nums[i] + nums[j] <= target:\n                res += pow(2, j - i)\n                res %= mod\n                print((nums[i], i, nums[j], j, res))\n        \n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l = count = 0\n        r = len(nums) - 1\n        mod = (10 ** 9 + 7)\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:    \n                count += (2 ** (r - l)) % mod\n                l += 1\n        return count % mod\n            \n            \n             \n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l=0\n        n=len(nums)\n        r=n-1 \n        mod=10**9+7\n        c=0\n        \n        while(l<=r):\n            if nums[l]+nums[r]>target:\n                r-=1 \n            else:\n                c=(c+((2**(r-l))%mod))%mod\n                l+=1 \n        return c", "class Solution:\n    def numSubseq(self, nums, target: int) -> int:\n\n        n = len(nums)\n        nums.sort()\n        res = 0\n        mod = 10**9+7\n        last = n-1\n        t=target/2\n        \n        f = [1] + [0] * (n - 1)\n        for i in range(1, n):\n            f[i] = f[i - 1] * 2 % mod\n            \n        i = 0\n        while i<n and nums[i]<=t:\n            j = last\n            while j>=i and nums[i]+nums[j]>target:\n                j -= 1\n            last = j\n            res += f[j-i]\n            i += 1\n        return res%1000000007", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        # Number of sebsequences that satisfy given sum\n        # 10:50 9/10/20\n        \n        def find_right(nums, j, target): # len(nums)\n            if j == 1:\n                return j-1\n            i = 0\n            while i < j:\n                mid = i + (j - i) // 2\n                if nums[mid] + nums[0] > target:\n                    j = mid\n                else:\n                    i = mid + 1\n            return i - 1\n        \n        \n        n = len(nums)\n        nums.sort()\n        left = 0\n        right = find_right(nums, len(nums), target)\n        MOD = 10**9 + 7\n        res = 0\n        \n        \n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                # res += (2**(right - left + 1)-1) % MOD\n                res = (res + pow(2, right-left)) % MOD\n                left += 1\n            else:\n                right -= 1\n        \n        return res\n    \n    \n    \n        # n,result,p1,p2,m=len(nums),0,0,len(nums)-1,1000000007\n        # nums.sort()\n        # while(p1<=p2):\n        #     if nums[p1]+nums[p2]<=target:\n        #         result=(result+pow(2,p2-p1,m))%m\n        #         p1+=1\n        #     else:\n        #         p2-=1\n        # return result\n                \n    \n    \n    \n    \n \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l,r=0,len(nums)-1\n        cnt=0\n        mod=pow(10,9)+7\n        while(l<=r):\n            if(nums[l]+nums[r]>target):\n                r-=1\n            else:\n                cnt+=pow(2,r-l)\n                cnt=cnt%mod\n                l+=1\n                \n        return cnt", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res = 0\n        j = len(nums)-1\n        mod = 10**9+7\n        \n        for i in range(len(nums)):\n            if nums[i]>target:\n                break\n            while j>=i and nums[i]+nums[j]>target:\n                j-=1\n            if j<i:\n                break\n            if i==j:\n                res+=1\n                continue\n            n = j-i\n            res += (2**n)%mod\n        return res%mod\n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        res = 0\n        mod = 10**9 + 7\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                res += 2 ** (right - left) % mod\n                left += 1\n\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod=(10**9)+7\n        right=len(nums)-1\n        res=0\n        left=0\n        while left<=right:\n            if nums[left]+nums[right]>target:\n                right-=1\n            else:\n                res+=2**(right-left)\n                res=res%mod\n                left+=1\n            \n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums=sorted(nums)\n        c=10**9+7\n        left=0\n        res=0\n        right=len(nums)-1\n        while(left<=right):\n            if nums[left]+nums[right]<=target:\n                res=(res+pow(2,(right-left)))%c\n                left+=1\n            else:\n                right-=1\n        return res        \n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n        right = len(nums) - 1\n        count = 0\n        # pow2 = [0 for _ in range(len(nums))]\n        # pow2[0] = 1\n        # for i in range(len(pow2)):\n        #     if i>0:\n        #         pow2[i] = (pow2[i-1] * 2) % MOD\n        for i in range(len(nums)):\n            while right>=i and nums[i] + nums[right] > target:\n                right -= 1\n            if right < i:\n                break\n            else:\n                # count += pow2[right - i]\n                count += 2 ** (right - i)\n            count %= MOD\n        return count % MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l = 0\n        r = len(nums) - 1\n        result = 0\n        mod = pow(10, 9) + 7\n        \n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                result += pow(2, r-l, mod)\n                l += 1\n        return result % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res = 0\n        j = len(nums) - 1\n        i = 0\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                res += 2**(j-i) % (10**9 + 7)\n                i += 1\n        \n        return res % (10**9 + 7)\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        i, j, res, N = 0, len(nums) - 1, 0, 10 ** 9 + 7\n        nums.sort()\n        \n        while i <= j:\n            if nums[i] + nums[j] > target: j -= 1\n            else:\n                res += (2 ** (j - i)) % N\n                i += 1\n        return res % N\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        for ri in range(len(nums)):\n            if nums[ri] + nums[0] > target:\n                break\n        \n        le, ans = 0, 0\n        while le <= ri:\n            if nums[le] + nums[ri] > target:\n                ri -= 1\n            else:\n                cnt = 2**(ri - le)\n                ans = (ans+cnt)%MOD\n                le += 1\n        return ans\n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        start = 0 \n        end = len(nums)-1\n        \n        count = 0\n        while start <= end:\n            if nums[start] + nums[end] > target:\n                end -= 1\n            else:\n                num_in_between = end - start \n                count += 2**num_in_between\n                count %= (10**9 + 7)\n                start += 1\n                \n        return count\n", "class Solution:\n    def numSubseq(self, A: List[int], t: int) -> int:\n        A, n = sorted(A), len(A)\n        mod = (10 ** 9 + 7)\n        ret = 0\n        left, right = 0, n - 1\n        while left <= right:\n            while right >= left and A[left] + A[right] > t:\n                right -= 1\n            if right >= left and A[left] + A[right] <= t:\n                ret += 2 ** (right - left) % mod\n            left += 1\n        return ret % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        sn = sorted(nums)\n        ans = 0\n        mod = 1000000007\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            if sn[l] + sn[r] > target:\n                r -= 1\n                continue\n            u = int(pow(2, r - l))\n            ans = (ans + u) % mod\n            l += 1\n\n        return ans", "class Solution:\n    def numSubseq(self, A: List[int], t: int) -> int:\n        A, n = sorted(A), len(A)\n        mod = (10 ** 9 + 7)\n        ret = 0\n        left, right = 0, n - 1\n        while left <= right:\n            while right >= left and A[left] + A[right] > t:\n                right -= 1\n            if right >= left and A[left] + A[right] <= t:\n                ret += 2 ** (right - left) % mod\n                ret %= mod\n            left += 1\n        return ret % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        # print(nums, len(nums))\n        count = 0\n        j = len(nums)-1\n        \n        for i in range(len(nums)):\n            while (nums[i]+nums[j]>target) & (i<j):\n                j -= 1\n            \n            if (i>j) | (nums[i]*2>target) :\n                break\n            # print(j-i, end=' & ')\n            count += 2**(j-i)\n            count = count%(10**9+7)\n\n        return count\n", "class Solution:\n    def numSubseq(self, A: List[int], target: int) -> int:\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod\n#         i, j, res, N = 0, len(nums) - 1, 0, 10 ** 9 + 7\n#         nums.sort()\n        \n#         while i <= j:\n#             if nums[i] + nums[j] > target: j -= 1\n#             else:\n#                 res += (2 ** (j - i)) % N\n#                 i += 1\n#         return res % N\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        for ri in range(len(nums)):\n            if nums[ri] + nums[0] > target:\n                break\n        le, ans = 0, 0\n        while le <= ri:\n            if nums[le] + nums[ri] > target:\n                ri -= 1\n            else:\n                ans = (ans + 2**(ri-le)) % MOD\n                le += 1\n        return ans\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        '''\n        Sort (nlogn) the array [as opposed to using DP ~= typically n^2 and complex in this case] and grab min and max elements such that nums[min] + nums[max] <= target\n        Now in the substring nums[min : max]\n            min can be always selected and all combinations in [min + 1 to max] can be tried which would result in the substring having min = min and max <= max resulting in max - min <= target\n        This selection yields 2^(max - min) possibilities\n        '''\n        \n        nums.sort()\n        n = len(nums)\n        res = 0\n        #one length subsequence\n        mod = 10**9 + 7\n        i,j = 0,n-1\n        \n        \n        for i in range(n):\n            while i<=j and nums[i]+nums[j] > target:\n                print((nums[i], nums[j]))\n                j-=1\n            \n            if i<=j and nums[i] + nums[j] <= target:\n                res += pow(2, j - i)\n                res %= mod\n                print((nums[i], i, nums[j], j, res))\n        \n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        left, right = 0, len(nums)-1\n        ans = 0\n        mod = 10**9+7\n        while left<=right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                ans = (ans + 2**(right-left)) % mod\n                left += 1\n        \n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res = left = 0\n        right = len(nums)-1\n        while(left<=right):\n            if nums[left] + nums[right]<=target:\n                res = (res + 2**(right-left)) % (10**9 + 7)\n                left += 1\n            else:\n                right -= 1\n        return res \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        start,end=0,len(nums)-1\n        res=0\n        mod = 10**9 + 7\n        while start<=end:\n            if nums[start]+nums[end]>target:\n                end-=1\n            else:\n                res+=pow(2,end-start)%mod\n                start+=1\n        return res%mod\n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        \n        left, right = 0, len(nums)-1\n        \n        ans = 0\n        mod = 10**9+7\n        while left<=right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n                continue\n            else:\n                ans = (ans + 2**(right-left)) % mod\n                left += 1\n        \n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        start=0\n        end=len(nums)-1\n        count=0\n        while(start<=end):\n            if((nums[start]+nums[end])<=target):\n                count+=2**(end-start)%1000000007\n                start+=1\n            else:\n                end-=1\n        for i in range(end+1,len(nums)):\n            if(nums[i]*2<=target):\n                count+=1\n            else:\n                break\n        return count%1000000007", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n        right = len(nums) - 1\n        count = 0\n        for i in range(len(nums)):\n            while right>i and nums[right] > target - nums[i]:\n                right -= 1\n            if right == i:\n                if 2*nums[i]<=target:\n                    count += 1\n                return count % MOD\n            else:\n                count += 2 ** (right - i)\n            count %= MOD\n        return count % MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        res = 0\n        \n        nums.sort()\n        \n        i = 0\n        j = len(nums)-1\n        \n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                res += pow(2, j-i)\n                res %= 10**9+7\n                i += 1\n        \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        right=len(nums)-1\n        res=0\n        for i in range(len(nums)):\n            while nums[i]+nums[right]>target and i<=right:\n                right-=1\n            if i<=right:\n                res+=2**(right-i)\n                res=res%((10**9)+7) \n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l = count = 0\n        r = len(nums) - 1\n        mod = (10 ** 9 + 7)\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:    \n                count += pow(2, r - l, mod)\n                l += 1\n        return count % mod\n            \n            \n             \n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        A = sorted(nums)\n        r = len(A)-1\n        l = 0\n        out = 0\n        while l <= r:\n            if target - A[r] - A[l] < 0:\n                r -= 1\n            else:\n                out += (2**(r-l))%((10**9)+7)\n                l += 1\n        return out%((10**9)+7)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        m = 10**9+7\n        ans = 0\n        i, j = 0, len(nums)-1\n        nums.sort()\n        pi, pj = -1, -1\n        while (pi, pj) != (i, j):\n            pi, pj = i, j\n            while j > i and nums[i] + nums[j] > target:\n                j -= 1\n\n            while i <= j and nums[i] + nums[j] <= target:\n                ans = (ans + 2**(j-i)) % m\n                i += 1\n        \n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans = 0\n        i = 0\n        j = len(nums)-1\n        while i <= j:\n            s = nums[i] + nums[j]\n            if s <= target:\n                ans += 2**(j - i)\n                ans %= 10**9+7\n                i += 1\n            else:\n                j -= 1\n        return ans", "MOD = 10**9 + 7\n\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        \n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res = (res + pow(2, r - l)) % MOD\n                l += 1\n                \n        return res\n", "MOD = 10 ** 9 + 7\n\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        if N == 1:\n            return 1 if nums[0] * 2 <= target else 0\n        \n        nums.sort()\n        \n        ret = 0\n        start = 0\n        end = N - 1\n        \n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if nums[mid] * 2 > target:\n                end = mid\n            else:\n                start = mid\n                \n        if nums[end] * 2 > target:\n            if nums[start] * 2 > target:\n                return 0\n            ret += end\n        else:\n            return (2 ** (end + 1) - 1) % MOD\n        \n        start = 0\n        end = N - 1\n        \n        while start < end:\n            if nums[start] + nums[end] > target:\n                end -= 1\n                continue\n                \n            ret = (ret + 2 ** (end - start) - 1) % MOD\n            start += 1\n            \n        return ret\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        \n        left = 0\n        right = len(nums) - 1\n        ret = 0\n        while left <= right and right < len(nums):\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                ret += 2 ** (right - left)\n                ret %= 10**9 + 7\n                left += 1\n                \n        return ret", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ri = n - 1\n        ans = 0\n        for li, l in enumerate(nums):\n            if l * 2 > target: break\n            while nums[ri] + l > target:\n                ri -= 1\n            ans = (ans + pow(2, ri - li, 1000000007)) % 1000000007\n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        res = 0\n        nums.sort()\n        start, end = 0, len(nums) - 1\n        \n        while (start <= end):\n            if (nums[start] + nums[end] <= target):\n                res = (res + 2 ** (end - start)) % (10 ** 9 + 7)\n                start += 1\n            else:\n                end -= 1\n        \n        return res", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums)-1\n        ans = 0\n        mod = 10**9+7\n        while left<=right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                ans = (ans + 2**(right-left)) % mod\n                left += 1\n        \n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        \n        left, right = 0, len(nums)-1\n        \n        ans = 0\n        mod = 10**9+7\n        while left<right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n                continue\n            else:\n                ans = (ans + 2**(right-left)-1) % mod\n                left += 1\n            \n        \n        for n in nums:\n            if n*2<=target:\n                ans += 1\n        \n        return ans%mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans=0\n        mod=1000000007\n        # print(nums)\n        st=0\n        ed=len(nums)-1\n        while(st<ed):\n            while(nums[st]+nums[ed]>target):\n                ed-=1\n            if(st<ed):\n                ans+=2**(ed-st)-1\n                ans%=mod\n            # print(st,ed)\n            st+=1\n            \n            \n        for i in range(len(nums)):\n            if(2*nums[i]<=target):\n                ans+=1\n        return ans%mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        ans = i = 0\n        while i < len(nums) and nums[i] <= target // 2:\n            j = self.help(nums, target-nums[i])\n            if j >= i:\n                ans += 2**(j-i) % (10**9 + 7)\n            i += 1\n        return ans % (10**9 + 7)\n    \n    def help(self, nums, target):\n        i, j = 0, len(nums)-1\n        while i < j:\n            mid = i + (j - i+ 1) // 2\n            if nums[mid] <= target:\n                i = mid\n            else:\n                j = mid - 1\n        return i\n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10 ** 9 + 7\n        count = 0\n        left= 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                count = (count + pow(2, right - left, mod)) % mod\n                left += 1\n            else:\n                right -= 1\n        return count", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = 0\n        mod = 10 ** 9 + 7\n\n        f = [1] + [0] * (n - 1)\n        for i in range(1, n):\n            f[i] = f[i - 1] * 2 % mod\n\n        pos = n - 1\n        for i, num in enumerate(nums):\n            while nums[pos] + num > target and pos >= i:\n                pos -= 1\n            if pos >= i:\n                res += f[pos - i]\n            else:\n                break\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        cnt = 0\n        mod = 10**9 + 7\n\n        if nums[-1] <= (target // 2):\n            return (pow(2, len(nums), mod) - 1)\n        \n        end = len(nums) - 1\n        while end >= 0 and nums[0] + nums[end] > target:\n            end -= 1\n\n        print (end)\n        for start in range(len(nums)):\n            while (start <= end) and (nums[start] + nums[end]) > target:\n                end -= 1\n            \n            if start > end:\n                break\n            print((start, end))\n            cnt += pow(2, (end-start), mod)\n            cnt %= mod\n        \n        \n        return cnt\n        \n", "class Solution:\n    def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res = 0\n        MOD = 10**9 + 7\n        p = 0\n        while p < len(nums):\n            while p < len(nums) and nums[p] + nums[-1] > target:\n                nums.pop()\n            if len(nums)-p-1 >= 0:\n                res += pow(2, len(nums)-p-1, MOD)\n            p += 1\n        return res%MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        res = 0\n        mod = (10**9+7)\n        nums.sort()\n        left, right = 0, len(nums)-1\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                res += pow(2, right - left, mod)\n                left += 1\n            else:\n                right -= 1\n        return res % (10**9+7)\n", "class Solution:\n    def numSubseq(self, lis: List[int], tar: int) -> int:\n        n = len(lis)\n        mod = 1000000000 + 7\n        lis.sort()\n        i=0\n        j=n-1\n        ans=0\n        tmp = pow(2,n,mod) - 1 \n        while i<=j:\n            if lis[i]+lis[j]<=tar:\n                i+=1\n            else:\n                ans+=pow(2,j-i,mod)\n                ans = ans%mod\n                j-=1\n        print((tmp,ans))\n        return (tmp - ans)%mod\n                \n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        mod = 10**9 + 7\n        n = len(nums)\n        pre = [0] * n\n        pre[0] = 1\n        res = 0\n        for i in range(1, n):\n            pre[i] = (pre[i - 1] * 2) % mod\n                \n        start, end = 0, n - 1\n        while start <= end:\n            if (nums[start] + nums[end] > target):\n                end -= 1\n            else:\n                res = (res + pre[end - start]) % mod\n                start += 1\n               \n            \n            \n            \n        \n        return res % mod\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        res=0\n        mod=10**9+7\n        left,right=0,len(nums)-1\n        for left in range(len(nums)):\n            while left<right and nums[left]+nums[right]>target:\n                right-=1\n            if left<=right and nums[left]+nums[right]<=target:\n                print((nums[left],nums[right]))\n                res+=pow(2,(right-left),mod)\n                res%=mod\n                \n        return res\n                \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        A = nums\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i = 0\n        j = len(nums) - 1\n        count = 0\n        mod = 10**9+7\n        while i <= j:\n            minv = nums[i]\n            maxv = nums[j]\n            sumv = minv + maxv \n            if sumv > target:\n                j -= 1\n            else:\n                count = (count + pow(2, j-i, mod)) % mod\n                i += 1\n        return count", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        \n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            print((l,r))\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod\n            \n                \n            \n            \n            \n            \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        nums.sort()\n        mod = 10**9 + 7\n        \n        y = len(nums) - 1\n        x = 0\n        ans = 0\n        while x <= y:\n            if nums[y] + nums[x] > target:\n                y -= 1\n            else:\n                ans = (ans + pow(2, y-x, mod)) % mod\n                x += 1\n        return ans", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        total = 0\n        MOD = 10**9+7\n        lo, hi = 0, len(nums)-1\n        \n        while lo <= hi:\n            if nums[lo] + nums[hi] > target:\n                hi -= 1\n            else:\n                total += pow(2, hi-lo, MOD)\n                lo += 1\n                \n        return total%MOD\n", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total <= target:\n                ans += pow(2, right-left, M)\n            if total > target:\n                right -= 1\n            else:\n                left += 1\n        return ans % M\n", "class Solution:        \n    def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod\n\n    \n#         self.dfs\n#         return res\n    \n#     def dfs(self, nums, path, res):\n\n#         if max(path) + min(path) <= target:\n#             res.append(path)\n#             return \n        \n        \n#         for i in range(nums):\n#             self.dfs(nums[i+1:], path+nums[i], res)\n", "class Solution:        \n    def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                #res += 2**(r-l)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10 ** 9 + 7\n        \n        # It is OK to sort the array because the question\n        # is essentially asking for the number of subsets,\n        # and the order doesn't matter.\n        nums.sort()\n        i, j = 0, len(nums)-1\n        count = 0\n        \n        # nums[i] is the minimum element,\n        # nums[j] is the maximum element,\n        # a subset starting with the minimum element\n        # contains at least the minimum element.\n        # for nums[i+1] to nums[j], it can be included or not.\n        # So totally there are 2 ** (j-i) subsets.\n        while i <= j:\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n            if i <= j:\n                # Compare to (2 ** (j-1)) % mod,\n                # using pow function is faster.\n                count += pow(2, j-i, mod)\n                i += 1\n        return count % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        ans, mod = 0, 10**9 + 7\n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                ans += pow(2, right - left, mod)\n                #ans %= mod\n                left += 1\n        return ans % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10**9 + 7\n        res = 0\n        nums.sort()\n        l, r = 0, len(nums)-1\n        while l <= r:\n            if nums[l] + nums[r] > target: r-= 1\n            else:\n                res += pow(2, r-l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        nums.sort()\n        l, r = 0, len(nums) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n        \n    #Version 2: Sliding window\n    #Consider the valid count\n    #TC: O(nlogn), SC: O(1)\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pows[k]\n            else:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                #ans += (pow(2, base, M) - 1) * pow(2, k-base, M)\n                ans += (pows[base]-1)*pows[k-base]\n            #print(k, base, ans)\n        return ans % M\n    \n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n    '''", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        nums.sort()\n        ans = 0\n        l, r = 0, n - 1\n        mod = 10**9 + 7\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                ans += pow(2, r-l , mod)\n                l += 1\n            else:\n                r -= 1\n        return ans % mod\n", "import math\nimport random\nimport string\nfrom functools import lru_cache\nfrom operator import truediv\nfrom typing import List\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\nimport numpy as np\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\nInput: nums = [3,5,6,7], target = 9\nOutput: 4\nExplanation: There are 4 subsequences that satisfy the condition.\n[3] -> Min value + max value <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)\n\n\u666e\u901a\u601d\u8def\uff1a\u6392\u5e8f\u3002\u5206\u522b\u8ba1\u7b97\u5404\u4e2a\u533a\u95f4\n3 -> 1\n3 5 -> 2^0 \u5728\u6216\u4e0d\u5728\n3 5 6 -> 2^1\n3 5 6 7 -> 2^2\n\n\u52a0\u5f3a\uff0c\u4e0e\u5176\u6bcf\u6b21\u8ba1\u7b97\uff0c\u4e0d\u5982\u5230\u6700\u540e\u4e00\u4e2a\u624d\u8ba1\u7b97\uff0c\u56e0\u4e3a\uff1a\n1 + 2^0 + 2^1 + 2^2 = 2^3\n\n\u53ef\u4ee5\u7528\u4e8c\u5206\u52a0\u901f\u5bfb\u627e\u3002\n'''\n\n\nclass Solution:\n    def numSubseqNormal(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        mod = 10 ** 9 + 7\n        for i in range(n):\n            for j in range(i, n):\n                if (nums[i] + nums[j]) <= target:\n                    if i == j:\n                        count += 1\n                    else:\n                        count += pow(2, j - i - 1)\n                    count %= mod\n        return count\n\n    # \u52a0\u5f3a\n    def numSubseq1(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        mod = 10 ** 9 + 7\n        for i in range(n):\n            j = i\n            while j < n and (nums[i] + nums[j]) <= target:\n                j += 1\n            if i == j:\n                if (nums[i] + nums[j]) <= target:\n                    count += 1\n            elif (nums[i] + nums[j - 1]) <= target:  # \u9632\u6b62\u7b2c\u4e00\u4e2a\u6570\u5c31\u8d85\u8fc7\n                count += pow(2, j - i - 1) % mod\n        return count % mod\n\n    def findLast(self, nums, start, end, target):\n        first = nums[start]\n        while start <= end:\n            mid = int((start + end) / 2)\n            second = nums[mid]\n            if first + second > target:\n                end = mid - 1\n            elif first + second < target:\n                start = start + 1\n            elif first + second == target:\n                start = start + 1\n        return start\n\n    def numSubseq12(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        mod = 10 ** 9 + 7\n        pow_map = [1 for _ in range(n)]\n        for i in range(1, n):\n            pow_map[i] = (2 * pow_map[i - 1]) % mod\n\n        for i in range(n):\n            if nums[i] > target:\n                    break\n            j = self.findLast(nums, i, n - 1, target)\n            if i == j:\n                if (nums[i] + nums[j]) <= target:\n                    count += 1\n            elif (nums[i] + nums[j - 1]) <= target:  # \u9632\u6b62\u7b2c\u4e00\u4e2a\u6570\u5c31\u8d85\u8fc7\n                count += pow_map[j - i - 1]\n        return count % mod\n    \n    \n    def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        output, nums = 0, sorted(nums)\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                output += pow(2, r - l, 10 ** 9 + 7)\n                l += 1\n            else:\n                r -= 1\n        return output % (10 ** 9 + 7)\n    \n    # def numSubseq(self, A, target):\n    #     A.sort()\n    #     l, r = 0, len(A) - 1\n    #     res = 0\n    #     mod = 10**9 + 7\n    #     while l <= r:\n    #         if A[l] + A[r] > target:\n    #             r -= 1\n    #         else:\n    #             res += pow(2, r - l, mod)\n    #             l += 1\n    #     return res % mod\n", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n    \n    #Version 2: Two sum\n    #\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]*2) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total <= target:\n                ans += pows[right-left]\n            if total > target:\n                right -= 1\n            else:\n                left += 1\n        return ans % M\n", "from itertools import combinations\n\nclass Solution:\n    def numSubseq(self, A, target) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(A)\n        A.sort()\n        \n        ans = 0\n        j = N - 1\n        for i in range(N):\n            while i < j and A[i] + A[j] > target:\n                j -= 1\n                \n            if A[i] + A[j] <= target:\n                ans += pow(2, j - i, MOD)\n                ans %= MOD\n                \n        return ans\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        s , e = 0 , len(nums) -1\n        mod = 10**9 + 7\n        result = 0\n        while s <= e:\n            if nums[s] + nums[e] <= target:                \n                result += pow(2,e- s, mod)\n                s += 1\n            else:\n                e -=1            \n        return result % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        count = 0\n        j = len(nums) - 1\n        mod = 10**9 + 7\n        for i in range(len(nums)):\n            while i <= j and nums[i] + nums[j] > target:\n                j -= 1\n            \n            if i <= j and nums[i] + nums[j] <= target:\n                count += pow(2, j-i, mod)\n                count = count % mod\n                \n        return count", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i, j = 0, len(nums) - 1\n        ans = 0\n        mod = 10**9 + 7\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                ans += self.fast_pow_mod(2, j - i, mod)\n                i += 1\n        return ans % mod\n    \n    def fast_pow_mod(self, a, b, m):\n        ans = 1\n        while b != 0:\n            if (b & 1) == 1:\n                ans = (ans * a) % m\n            b >>= 1\n            a = (a * a) % m\n        return ans\n\n", "import math\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        check = {0:1}\n        nums.sort()\n        \n        n = len(nums)\n        right = n-1\n        cur =  1\n        for i in range(1, n+1):\n            cur = (2*cur) % 1000000007\n            check[i] = cur\n        result = 0\n        for i in range(n):\n            while right >= i and nums[i] + nums[right] > target:\n                right -= 1\n            if right < i:\n                break\n            extra = right - i\n            if nums[i] + nums[right] <= target:\n                result += check[extra] % (1000000007)    \n        return result % (1000000007)\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        nums.sort()\n        right = len(nums) - 1\n        count = 0\n        pow2 = [1 for _ in range(len(nums))]\n        for i in range(len(pow2)):\n            if i>0:\n                pow2[i] = (pow2[i-1] * 2) % MOD\n        for i in range(len(nums)):\n            while right>=i and nums[i] + nums[right] > target:\n                right -= 1\n            if right < i:\n                break\n            else:\n                count += pow2[right - i]\n            count %= MOD\n        return count % MOD\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10 ** 9 + 7\n        nums.sort()\n        result = 0\n        i, j = 0, len(nums) - 1\n        while i <= j:\n            cur_sum = nums[i] + nums[j]\n            if cur_sum <= target:\n                result += pow(2, j - i, mod)\n                i += 1\n            else:\n                j -= 1\n        return result % mod", "class Solution:\n    def numSubseq(self, A: List[int], target: int) -> int:\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n     def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod\n", "from bisect import bisect_right\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        arr=[]\n        n=len(nums)\n        m=10**9+7\n        nums.sort()\n        ans=0\n        dp=[0]*n\n        if 2*nums[0]<=target:\n            dp[0]=1\n        for i in range(1,n):\n            if 2*nums[i]<=target:\n                dp[i]=(2*dp[i-1]%m+1%m)%m\n                \n            elif nums[i]<target:\n                index=bisect_right(nums,target-nums[i])\n                \n                dp[i]=(dp[i-1]%m+dp[index-1]%m+dp[index-1]%m*(pow(2,i-index,m)-1))%m\n                    \n            else:\n                dp[i]=dp[i-1]\n        print(dp)\n                    \n        return dp[n-1]%m\n        \n                \n        \n            \n                \n            \n                \n        \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        l,r = 0, n-1\n        counts = 0\n        res = 0\n        \n        while l<=r:\n            while l<=r and nums[r]+nums[l]>target:\n                r -= 1\n            if l<=r:\n                res += pow(2, (r-l), 10**9+7)\n                res %= 10**9 + 7\n                l += 1\n            \n        return res \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        i = 0\n        j = len(nums) - 1\n        mod = 10 ** 9 + 7\n        \n        count = 0\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                count += pow(2, j - i, mod)\n                i += 1\n        \n        return count % mod", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n        \n    #Version 2: Sliding window\n    #Consider the valid count\n    #TC: O(nlogn), SC: O(1)\n    '''   \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pows[k]\n            else:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                ans += (pows[base]-1)*pows[k-base]\n            #print(k, base, ans)\n        return ans % M\n    '''\n    \n    #Version 3: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        nums.sort()\n        \n        l , r = 0 ,len(nums)-1\n        mod = 10**9+7\n        ans = 0\n        \n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else :\n                ans += pow(2,r-l , mod)\n                l += 1\n        \n        return ans % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \n        mod = 10**9 + 7\n        \n        nums.sort()\n        l = 0\n        r = len(nums) - 1\n        ans = 0\n\n        while l <= r:\n            if nums[l] + nums[r] <= target:\n                ans += pow(2, r - l, mod) \n                l += 1\n            else:\n                r -= 1\n        return ans % mod    \n\n        \n        \n        \n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        '''\n         \u5c06\u6570\u7ec4\u6392\u5e8f\uff0c\u627e\u7b26\u5408\u6761\u4ef6\u7684\u5b50\u5e8f\u5217\u7684\u6700\u5c0f\u503c\u4e0e\u6700\u5927\u503c\n         \u4ece\u6bcf\u4e00\u9879\u5f00\u59cb\uff0c\u5bfb\u627e\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927\u503c\u4f4d\u7f6e\n            In subarray nums[i~j]:\n            min = nums[i], max = nums[j]\n            nums[i] + nums[j] <= target\n            {nums[i], (j - i - 1 + 1 values)}\n            Any subset of the right part gives a valid subsequence \n            in the original array. And There are 2^(j - i) ones.\n        '''\n        n=len(nums)\n        nums.sort()\n        p=[1]*(n+1)\n        for i in range(1,n+1):\n            p[i]=(p[i-1]<<1)%(10**9+7)\n        res=0\n        j=n-1\n        for i in range(j+1):\n            while i<=j and nums[i]+nums[j]>target:\n                j-=1\n            if i>j:\n                continue\n            res=(res+p[j-i])%(10**9+7)\n        return res\n", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                while base > 0 and nums[base] + nums[k] > target:\n                    base -= 1\n                while base < k and nums[base] + nums[k] <= target:\n                    base += 1\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M", "import math\nimport random\nimport string\nfrom functools import lru_cache\nfrom operator import truediv\nfrom typing import List\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\nimport numpy as np\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\nInput: nums = [3,5,6,7], target = 9\nOutput: 4\nExplanation: There are 4 subsequences that satisfy the condition.\n[3] -> Min value + max value <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)\n\n\u666e\u901a\u601d\u8def\uff1a\u6392\u5e8f\u3002\u5206\u522b\u8ba1\u7b97\u5404\u4e2a\u533a\u95f4\n3 -> 1\n3 5 -> 2^0 \u5728\u6216\u4e0d\u5728\n3 5 6 -> 2^1\n3 5 6 7 -> 2^2\n\n\u52a0\u5f3a\uff0c\u4e0e\u5176\u6bcf\u6b21\u8ba1\u7b97\uff0c\u4e0d\u5982\u5230\u6700\u540e\u4e00\u4e2a\u624d\u8ba1\u7b97\uff0c\u56e0\u4e3a\uff1a\n1 + 2^0 + 2^1 + 2^2 = 2^3\n\n\u53ef\u4ee5\u7528\u4e8c\u5206\u52a0\u901f\u5bfb\u627e\u3002\n\n\u7ec8\u6781\u4f18\u5316\uff1a\u5bf9\u6bd4\u4e8c\u5206\u6216\u8005for\u5faa\u73af\u627e\u6700\u540e\u4e00\u4e2a\uff0c\u5b9e\u9645\u4e0a\u8fd8\u662f\u505a\u4e86\u5927\u91cf\u91cd\u590d\u7684\u6bd4\u8f83\u3002\n\n\u6839\u636e+\u6cd5\u7684\u7279\u70b9\u8fdb\u884c\u53cc\u7aef\u4f18\u5316\uff0c\u5927\u4e8etarget\u5219\u53f3\u4fa7\u51cf\u4e00\uff0c\u5c0f\u4e8etarget\u5219\u5de6\u4fa7\u52a0\u4e00\u3002\n'''\n\n\nclass Solution:\n    def numSubseqNormal(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        mod = 10 ** 9 + 7\n        for i in range(n):\n            for j in range(i, n):\n                if (nums[i] + nums[j]) <= target:\n                    if i == j:\n                        count += 1\n                    else:\n                        count += pow(2, j - i - 1)\n                    count %= mod\n        return count\n\n    # \u52a0\u5f3a\n    def numSubseq1(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        mod = 10 ** 9 + 7\n        for i in range(n):\n            j = i\n            while j < n and (nums[i] + nums[j]) <= target:\n                j += 1\n            if i == j:\n                if (nums[i] + nums[j]) <= target:\n                    count += 1\n            elif (nums[i] + nums[j - 1]) <= target:  # \u9632\u6b62\u7b2c\u4e00\u4e2a\u6570\u5c31\u8d85\u8fc7\n                count += pow(2, j - i - 1) % mod\n        return count % mod\n\n    def findLast(self, nums, start, end, target):\n        first = nums[start]\n        while start <= end:\n            mid = int((start + end) / 2)\n            second = nums[mid]\n            if first + second > target:\n                end = mid - 1\n            elif first + second < target:\n                start = start + 1\n            elif first + second == target:\n                start = start + 1\n        return start\n\n    def numSubseq12(self, nums: List[int], target: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        count = 0\n        mod = 10 ** 9 + 7\n        pow_map = [1 for _ in range(n)]\n        for i in range(1, n):\n            pow_map[i] = (2 * pow_map[i - 1]) % mod\n\n        for i in range(n):\n            if nums[i] > target:\n                    break\n            j = self.findLast(nums, i, n - 1, target)\n            if i == j:\n                if (nums[i] + nums[j]) <= target:\n                    count += 1\n            elif (nums[i] + nums[j - 1]) <= target:  # \u9632\u6b62\u7b2c\u4e00\u4e2a\u6570\u5c31\u8d85\u8fc7\n                count += pow_map[j - i - 1]\n        return count % mod\n\n    # \u53cc\u7aef\u4f18\u5316\n    def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n     def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)%mod\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        nums.sort()\n        cnt = 0\n        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            if nums[lo] + nums[hi] > target:\n                hi -= 1\n            else:\n                cnt += pow(2, hi - lo, MOD)\n                lo += 1\n        return cnt % MOD", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        if nums is None and len(nums) == 0:\n            return 0 \n        \n        nums.sort()\n        mod = 10**9 + 7 \n        ans = 0\n        left, right = 0, len(nums) - 1 \n        \n        \n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1 \n            else:\n                ans += pow(2, right-left, mod)\n                left += 1 \n        \n        return ans % mod", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n    '''\n        \n    #Version 2: Sliding window\n    #Consider the valid count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pow(2, k, M)\n            else:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                ans += (pow(2, base, M) - 1) * pow(2, k-base, M)\n            #print(k, base, ans)\n        return ans % M\n    '''\n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n", "class Solution:\n     def numSubseq(self, A, target):\n        A.sort()\n        l, r = 0, len(A) - 1\n        res = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if A[l] + A[r] > target:\n                r -= 1\n            else:\n                res += pow(2, r - l, mod)\n                l += 1\n        return res % mod", "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        le = len(nums)\n        res = 0\n        mod=10**9+7\n        j = le-1\n        for i in range(le):\n            while j>=i and nums[i]+nums[j]>target:\n                j-=1\n            if j<i:\n                break\n            res += pow(2,j-i,mod)\n            res%=mod\n        return res", "class Solution:\n    #Version 1: Sliding window\n    #Count the mismatch count\n    #TC: O(nlogn), SC: O(1)\n    \n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        mismatch = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 > target:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                mismatch += pow(2, k-base, M)\n        return (pow(2, len(nums), M) - 1 - mismatch) % M\n\n    \n    #Version 2: Two sum\n    #Once the window is valid, we can add the number of subsequences with left or right number\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            total = nums[left] + nums[right]\n            if total > target:\n                right -= 1\n            else:\n                ans = (ans + pows[right-left]) % M\n                left += 1\n        return ans\n    '''\n    \n    #Version 3: Sliding window\n    #Consider the valid count\n    #TC: O(nlogn), SC: O(1)\n    '''\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        from bisect import bisect_left\n        M = 10**9 + 7\n        pows = [1]*(len(nums)+1)\n        for k in range(1, len(pows)):\n            pows[k] = (pows[k-1]<<1) % M\n        ans = 0\n        nums.sort()\n        base = 0\n        for k in range(len(nums)):\n            if nums[k]*2 <= target:\n                ans += pow(2, k, M)\n            else:\n                # while base > 0 and nums[base] + nums[k] > target:\n                #     base -= 1\n                # while base < k and nums[base] + nums[k] <= target:\n                #     base += 1\n                base = bisect_left(nums, target - nums[k]+1)\n                ans += (pow(2, base, M) - 1) * pow(2, k-base, M)\n            #print(k, base, ans)\n        return ans % M\n    '''\n"]
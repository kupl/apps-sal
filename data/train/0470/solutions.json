["class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        counter = collections.Counter(A)\n        i, res, l, ckey = 0, 0, len(counter), sorted(list(counter.keys()))\n        if target % 3 == 0:\n            res += math.comb(counter[target // 3], 3)\n        for i in range(l):\n            ni = ckey[i]\n            nk = target - (2 * ni)\n            if ni != nk and nk >= 0:\n                res += math.comb(counter[ni], 2) * counter[nk]\n        for i in range(l):\n            for j in range(i + 1, l):\n                ni, nj = ckey[i], ckey[j]\n                nk = target - ni - nj\n                if ni < nj < nk <= 100:\n                    res += counter[ni] * counter[nj] * counter[nk]\n        return res % (10**9 + 7)\n        # while i < l:\n        #     j = i\n        #     while j < l:\n        #         ni, nj = ckey[i], ckey[j]\n        #         nk = target - ni - nj\n        #         if ni == nk == nj:\n        #             res += math.comb(counter[ni], 3)\n        #         elif nj == nk:\n        #             res += math.comb(counter[nj], 2) * counter[ni]\n        #         elif ni == nk:\n        #             res += math.comb(counter[nk], 2) * counter[nj]\n        #         elif ni == nj:\n        #             res += math.comb(counter[ni], 2) * counter[nk]\n        #         else:\n        #             res += counter[ni] * counter[nj] * counter[nk]\n        #         print(ni, nj, nk, res)\n        #         j += 1\n        #     i += 1\n        # return res % (10**9 + 7)\n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        d = Counter(A)\n        keys = sorted(d.keys())\n        count = 0\n        for i, a in enumerate(keys):\n            if a <= target // 3:\n                for b in keys[(i + 1) :]:\n                    if target - a - b <= b:\n                        break\n                    elif target - a - b in d:\n                        count += d[a] * d[b] * d[target - a - b]\n            else:\n                break\n        for k in keys:\n            if target != 3 * k and target - 2 * k in d:\n                count += math.comb(d[k], 2) * d[target - 2 * k]\n        if 3 * (target // 3) == target:\n            count += math.comb(d[target // 3], 3)\n        return count % (10**9 + 7)", "class Solution(object):\n    def threeSumMulti(self, A, target):\n        count = [0] * 101\n        ans = 0\n\n        for n in A:\n            count[n] += 1\n\n        for x in range(101):\n            for y in range(x+1,101):\n                z = target - x - y\n                if x<y<z<=100:\n                    ans += count[x] * count[y] * count[z]\n                    ans %= 10**9 + 7\n                    \n        for x in range(101):\n            z = target - 2*x\n            if 0<=z<=100 and x!=z:\n                ans += count[x]*(count[x]-1)//2*count[z]\n                ans %= 10**9 + 7\n                \n        if not target % 3:\n            x = target//3\n            if 0<=x<=100:\n                ans += count[x] * (count[x]-1) * (count[x]-2)//6\n                ans %= 10**9 + 7\n        return ans\n\n\n", "from collections import Counter\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        \n        MAX = 10**9 + 7\n        count = collections.Counter(A)\n        keys = sorted(count)\n        ans = 0\n        for i , x in enumerate(keys):\n            \n            j = i\n            k = len(keys)-1\n            \n            while(j<=k):\n                y , z = keys[j],keys[k]\n                sum_t = x+y+z\n                \n                if  sum_t<target :\n                    j+=1\n                elif(sum_t >target):\n                    k-=1\n                    \n                else:\n                    \n                    if(i<j<k):\n                        ans += count[x]*count[y]*count[z]\n                        \n                    elif (x==y and y<z):\n                        ans+= (count[x]*(count[x]-1)*count[z])//2\n                    \n                    elif(x<y and y==z):\n                        ans += (count[x]*(count[y])*(count[y]-1))//2\n                        \n                    else:\n                        ans += (count[x]*(count[x]-1)*(count[x]-2))//6\n                    \n                    j+=1\n                    k-=1\n                    \n        return ans%MAX\n        \n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        cnt, res = collections.Counter(A), 0\n        \n        for i in cnt:\n            for j in cnt:\n                k = target - i - j\n                if i == j == k:\n                    res += (cnt[i]*(cnt[i]-1)*(cnt[i]-2))//6\n                elif i == j:\n                    res += (cnt[i]*(cnt[i]-1)//2) * cnt[k]\n                elif i < j < k:\n                    res +=  cnt[i] * cnt[j] * cnt[k]\n                res = res % (10**9+7)\n        return res", "class Solution(object):\n    def threeSumMulti(self, A, target):\n        MOD = 10**9 + 7\n        count = collections.Counter(A)\n        keys = sorted(count)\n\n        ans = 0\n\n        # Now, let's do a 3sum on \\\"keys\\\", for i <= j <= k.\n        # We will use count to add the correct contribution to ans.\n        for i, x in enumerate(keys):\n            T = target - x\n            j, k = i, len(keys) - 1\n            while j <= k:\n                y, z = keys[j], keys[k]\n                if y + z < T:\n                    j += 1\n                elif y + z > T:\n                    k -= 1\n                else: # x+y+z == T, now calculate the size of the contribution\n                    if i < j < k:\n                        ans += count[x] * count[y] * count[z]\n                    elif i == j < k:\n                        ans += count[x] * (count[x] - 1) // 2 * count[z]\n                    elif i < j == k:\n                        ans += count[x] * count[y] * (count[y] - 1) // 2\n                    else:  # i == j == k\n                        ans += count[x] * (count[x] - 1) * (count[x] - 2) // 6\n\n                    j += 1\n                    k -= 1\n\n        return ans % MOD", "from collections import Counter\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        MOD = 10 ** 9 + 7\n        if len(A) < 3:\n            return 0\n        counts = Counter(A)\n        keys = sorted(counts.keys())\n        n, res = len(keys), 0\n        \n        for i, a in enumerate(keys):\n            T = target - a\n            j, k = i, n - 1\n            while j <= k:\n                b, c = keys[j], keys[k]\n                if b + c < T:\n                    j += 1\n                elif b + c > T:\n                    k -= 1\n                else:\n                    if i < j < k:\n                        res += counts[a] * counts[b] * counts[c] \n                    elif i == j < k:\n                        res += counts[a] * (counts[a] - 1) // 2 * counts[c]\n                    elif i < j == k:\n                        res += counts[a] * counts[b] * (counts[b] - 1) // 2\n                    else:\n                        res += counts[a] * (counts[a] - 1) * (counts[a] - 2) // 6\n                    j += 1\n                    k -= 1\n        return res % MOD", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        count = collections.Counter(A)\n        valuelist = list(count.keys())\n        valuelist.sort()\n        res = 0\n        for i in range(len(valuelist)):\n            for j in range(i, len(valuelist)):\n                a = valuelist[i]\n                b = valuelist[j]\n                c = target - a - b\n                if c not in count:\n                    continue\n                if a == b == c:\n                    res += count[a] * (count[a] - 1) * (count[a] - 2) // 6 #C x 3\n                elif a == b and b != c:\n                    res += count[a] * (count[a] - 1) // 2 * count[c]\n                elif a < b and b < c:\n                    res += count[a] * count[b] * count[c]\n        return res % (10 ** 9 + 7)", "import collections as clc\nimport itertools as it\n\n\nclass Solution:\n    \n    BASE = 10 ** 9 + 7\n    \n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        counter = clc.Counter(A)\n        values = sorted(counter)\n        n = len(values)\n        pair_sums = clc.Counter()\n        ans = 0\n        for k in range(n):\n            if 3 * values[k] == target and counter[values[k]] >= 3:\n                cnt = counter[values[k]]\n                ans = (ans + cnt * (cnt - 1) * (cnt - 2) // 6) % self.BASE\n        for j, k in it.combinations(range(n), 2):\n            if 2 * values[j] + values[k] == target and counter[values[j]] >= 2:\n                cntj = counter[values[j]]\n                cntk = counter[values[k]]\n                ans = (ans + cntj * (cntj - 1) // 2 * cntk) % self.BASE\n            if values[j] + 2 * values[k] == target and counter[values[k]] >= 2:\n                cntj = counter[values[j]]\n                cntk = counter[values[k]]\n                ans = (ans + cntk * (cntk - 1) // 2 * cntj) % self.BASE\n        for k in range(2, n):\n            j = k - 1\n            for i in range(j):\n                pair_sums[values[i] + values[j]] += counter[values[i]] * counter[values[j]]\n            ans = (ans + counter[values[k]] * pair_sums[target - values[k]]) % self.BASE\n        return ans % self.BASE", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        counter = collections.Counter(A)\n        i, res, l, ckey = 0, 0, len(counter), sorted(list(counter.keys()))\n        print(counter)\n        print((l//2))\n        if target % 3 == 0:\n            res += math.comb(counter[target // 3], 3)\n            print((target//3, target//3, target//3, res))\n        for i in range(l):\n            ni = ckey[i]\n            nk = target - (2 * ni)\n            if ni != nk and nk >= 0:\n                res += math.comb(counter[ni], 2) * counter[nk]\n            print((ni, ni, nk, res))\n        for i in range(l):\n            for j in range(i + 1, l):\n                ni, nj = ckey[i], ckey[j]\n                nk = target - ni - nj\n                if ni < nj < nk <= 100:\n                    res += counter[ni] * counter[nj] * counter[nk]\n                print((ni, nj, nk, res))\n        return res % (10**9 + 7)\n        # while i < l:\n        #     j = i\n        #     while j < l:\n        #         ni, nj = ckey[i], ckey[j]\n        #         nk = target - ni - nj\n        #         if ni == nk == nj:\n        #             res += math.comb(counter[ni], 3)\n        #         elif nj == nk:\n        #             res += math.comb(counter[nj], 2) * counter[ni]\n        #         elif ni == nk:\n        #             res += math.comb(counter[nk], 2) * counter[nj]\n        #         elif ni == nj:\n        #             res += math.comb(counter[ni], 2) * counter[nk]\n        #         else:\n        #             res += counter[ni] * counter[nj] * counter[nk]\n        #         print(ni, nj, nk, res)\n        #         j += 1\n        #     i += 1\n        # return res % (10**9 + 7)\n", "class Solution(object):\n    def threeSumMulti(self, A, target):\n        MOD = 10**9 + 7\n        count = collections.Counter(A)\n        keys = sorted(count)\n\n        ans = 0\n\n        # Now, let's do a 3sum on \\\"keys\\\", for i <= j <= k.\n        # We will use count to add the correct contribution to ans.\n        for i, x in enumerate(keys):\n            T = target - x\n            j, k = i, len(keys) - 1\n            while j <= k:\n                y, z = keys[j], keys[k]\n                if y + z < T:\n                    j += 1\n                elif y + z > T:\n                    k -= 1\n                else: # x+y+z == T, now calculate the size of the contribution\n                    if i < j < k:\n                        ans += count[x] * count[y] * count[z]\n                    elif i == j < k:\n                        ans += count[x] * (count[x] - 1) / 2 * count[z]\n                    elif i < j == k:\n                        ans += count[x] * count[y] * (count[y] - 1) / 2\n                    else:  # i == j == k\n                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6\n\n                    j += 1\n                    k -= 1\n\n        return int(ans % MOD)", "from collections import Counter\n\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        countA = Counter(A)\n        ans = 0\n        done = set()\n        M = int(1e9 + 7)\n        \n        for i, j in list(countA.items()):\n            for k, l in list(countA.items()):\n                req = target - i - k\n                temp = tuple(sorted([i, k, req]))\n                if temp not in done:\n                    done.add(temp)\n                    if i == k == req:\n                        ans += (j * (j - 1) * (j - 2)) // 6\n                    if i == k and i != req:\n                        ans += ((j * (j - 1)) // 2) * countA[req]\n                    if i != k and i == req:\n                        ans += l * (j * (j - 1)) // 2\n                    if i != k and k == req:\n                        ans += j * (l * (l - 1)) // 2\n                    if i != k and k != req:\n                        ans += j * l * countA[req]\n                    ans %= M\n                    \n        return ans\n", "class Solution:\n    def threeSum(self,A: List[int], target:int) -> List[List[int]]:\n        triples = []\n        \n        i = 0\n        k = len(A)-1\n        while i<=k:\n            j = i\n            k = len(A)-1\n            while j<=k:\n                if A[j]+A[k]<target-A[i]:\n                    j += 1\n                elif A[j]+A[k]>target-A[i]:\n                    k -= 1\n                else:\n                    triples.append([A[i],A[j],A[k]])\n                    j += 1\n                    k -= 1\n            i += 1\n        return triples\n                    \n        \n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        res = 0\n        count = {}\n        for num in A:\n            count[num] = count.get(num,0)+1\n        sorted_A_no_dup = sorted([num for num in count])\n        \n        all_triples = self.threeSum(sorted_A_no_dup,target)\n        for triple in all_triples:\n            a,b,c = triple[0],triple[1],triple[2]\n            if a!=b and b!=c:\n                res += count[a]*count[b]*count[c]\n            elif a==b and b!=c:\n                res += count[a]*(count[a]-1)*count[c]//2\n            elif a!=b and b==c:\n                res += count[a]*count[b]*(count[b]-1)//2\n            elif a==b and b==c:\n                res += count[a]*(count[a]-1)*(count[a]-2)//6\n            res %= 10**9+7\n        return res\n            \n        \n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        ADict = {}\n        A = sorted(A)\n        print(A)\n        for a in A:\n            if a in ADict:\n                ADict[a]+=1\n            else:\n                ADict[a] = 1\n        ijSame = False\n        keys = sorted(ADict)\n        totWays = 0\n        # check all same:\n        for i in range(len(keys)):\n            if keys[i] > target:\n                 break\n            elif ADict[keys[i]]<3:\n                continue\n            elif keys[i]*3 == target:\n                numOcc = ADict[keys[i]]\n                totWays += numOcc*(numOcc-1)*(numOcc-2)/6\n        \n        if len(keys)==1:\n            return int(totWays%(10**9 + 7))\n        # 2 are same:\n        for i in range(len(keys)):\n            if keys[i] > target:\n                 break\n            elif ADict[keys[i]]<2:\n                continue\n            else:\n                sum = keys[i]*2\n                remain = target - sum\n                if (not(remain==keys[i]) and remain in keys):\n                    numDoubleOcc = ADict[keys[i]]\n                    numSingleOcc = ADict[remain]\n                    totWays += numDoubleOcc*(numDoubleOcc-1)/2*numSingleOcc\n        if len(keys)==2:\n            return int(totWays%(10**9 + 7))\n        # all distinct\n        for i in range(len(keys)):\n            if keys[i] > target:\n                 break\n            for j in range(i+1, len(keys)):\n                sum = keys[i] + keys[j]\n                if sum > target:\n                    break\n                remaining = target - sum\n                if remaining in keys[j+1:]:\n                    totWays += ADict[keys[i]] *ADict[keys[j]] *ADict[remaining]\n                \n        return int(totWays%(10**9 + 7))\n        \n        \n#         for i in range(len(keys)):\n#             if keys[i] > target:\n#                  return totWays\n                \n#             if ADict[keys[i]] ==1:\n#                 startJ = i+1\n#             else:\n#                 startJ = i\n#                 ijSame = True\n#             for j in range(startJ, len(keys)):\n#                 sum = keys[i] + keys[j]\n#                 if sum > target:\n#                      break\n#                 remaining = target - sum\n#                 if remaining in keys:\n#                      totWays+=1\n#         #             tempA.remove(remaining)\n                \n            \n        #for ele in ADict.keys():\n            \n        \n        \n        # A = sorted(A)\n        # #print(A)\n        # if len(A)<3:\n        #     return 0\n        # totWays = 0\n        # for i in range (len(A)):\n        #     if A[i] >target:\n        #         return totWays\n        #     for j in range (i+1, len(A)):\n        #         tempA = A[j+1:].copy()\n        #         sum = A[i] + A[j]\n        #         if sum > target:\n        #             break\n        #         remaining = target - sum\n        #         while remaining in tempA:\n        #             totWays+=1\n        #             tempA.remove(remaining)\n        #             #print (str(A[i]) + \\\" \\\" + str(A[j]) + \\\" \\\" + str(remaining))\n        # return totWays\n", "class Solution:\n    def calculate_weight(self,x,y,z,freq):\n        if x==y and y==z:\n            return freq[x]*(freq[x]-1)*(freq[x]-2)//6\n        if x==y:\n            return freq[x]*(freq[x]-1)//2*freq[z]\n        if x==z:\n            return freq[x]*(freq[x]-1)//2*freq[y]\n        if y==z:\n            return freq[z]*(freq[z]-1)//2*freq[x]\n        return freq[x]*freq[y]*freq[z]\n    \n    def calculate_freq(self,A):\n        freq = {}\n        for k in A:\n            if k in list(freq.keys()):\n                freq[k]+=1\n            else:\n                freq[k] = 1\n        return freq\n\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        freq = self.calculate_freq(A)\n        unique_values = list(freq.keys())\n        count = 0\n        two_sum_combinations = {}\n        for x in unique_values:\n            for y in unique_values:\n                maxval = max(x,y)\n                minval = min(x,y)\n                if x+y not in two_sum_combinations:\n                    two_sum_combinations[x+y] = set()\n                two_sum_combinations[x+y].add((maxval,minval))\n        for z in unique_values:\n            if target - z in two_sum_combinations:\n                for x,y in two_sum_combinations[target-z]:\n                    if z<=y:\n                        weight = self.calculate_weight(x,y,z,freq)\n                        print((x,y,z,weight))\n                        count+= weight\n        return count%(10**9 + 7)\n", "class Solution:\n    def calculate_weight(self,x,y,z,freq):\n        if x==y and y==z:\n            return freq[x]*(freq[x]-1)*(freq[x]-2)/6\n        if x==y:\n            return freq[x]*(freq[x]-1)/2*freq[z]\n        if x==z:\n            return freq[x]*(freq[x]-1)/2*freq[y]\n        if y==z:\n            return freq[z]*(freq[z]-1)/2*freq[x]\n        return freq[x]*freq[y]*freq[z]\n    \n    def calculate_freq(self,A):\n        freq = {}\n        for k in A:\n            if k in list(freq.keys()):\n                freq[k]+=1\n            else:\n                freq[k] = 1\n        return freq\n\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        freq = self.calculate_freq(A)\n        unique_values = list(freq.keys())\n        count = 0\n        two_sum_combinations = {}\n        print((len(A)))\n        for x in unique_values:\n            for y in unique_values:\n                maxval = max(x,y)\n                minval = min(x,y)\n                if x+y not in two_sum_combinations:\n                    two_sum_combinations[x+y] = set()\n                two_sum_combinations[x+y].add((maxval,minval))\n        for z in unique_values:\n            if target - z in two_sum_combinations:\n                for x,y in two_sum_combinations[target-z]:\n                    if z<=y:\n                        weight = self.calculate_weight(x,y,z,freq)\n                        print((x,y,z,weight))\n                        count+= weight\n        return int(count)%(10**9 + 7)\n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        def find_n_sum(arr, target, N, l, r, path, output):\n            if arr[l]*N>target or arr[r]*N<target:\n                return\n            \n            if N==2:\n                s, e = l, r\n                while s<e:\n                    total = arr[s]+arr[e]\n                    if total<target or s>l and arr[s-1]==arr[s]:\n                        s += 1\n                    elif total>target or e<r and arr[e]==arr[e+1]:\n                        e -= 1\n                    else:\n                        output.add(tuple(path+[arr[s], arr[e]]))\n                        s += 1\n                        e -= 1\n            else:\n                for i in range(l, r+1-(N-1)):\n                    if i>l and arr[l]==arr[l-1]:\n                        continue\n                        \n                    find_n_sum(arr, target-arr[i], N-1, i, r, path+[arr[i]], output)\n            \n            \n        combos = set()\n        res = 0\n        counter = Counter(A)\n        new_arr = []\n        for k in sorted(counter.keys()):\n            new_arr += [k]*min(counter[k], 3)\n\n        find_n_sum(new_arr, target, 3, 0, len(new_arr)-1, [], combos)\n        \n        for lst in combos:\n            cnt = 1\n            temp = Counter(lst)\n            for k in temp:\n                for i in range(temp[k]):\n                    cnt *= (counter[k]-i)/(i+1)\n                \n            res = (res+cnt)%(10**9+7)\n            \n        return int(res)%(10**9+7)\n                \n                                                                \n                                                                \n", "from collections import Counter\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        mp = Counter(A)\n        total = 0\n        mpow = 10**9 + 7\n        for i in range(101):\n            for j in range(i, 101):\n                calc = target-(i+j)\n                if calc > 100 or calc < 0:\n                    continue\n                if i == j == calc:\n                    x = mp[i]\n                    top_row = x*(x-1)*(x-2)\n                    top_row /=6\n                    total += top_row#nC3\n                elif i == j != calc:\n                    x = mp[i]\n                    total += ((x*(x-1))/2) * mp[calc]\n                elif i < j < calc:\n                    total += mp[i]*mp[j]*mp[calc]\n        return int(total % mpow)\n        \n\n#     def threeSumMulti(self, A: List[int], target: int) -> int:\n#         total = 0\n#         A.sort()\n#         mod_pow = 10**9 + 7\n#         for i in range(len(A)):\n#             l = i+1\n#             r = len(A)-1\n#             while l < r:\n#                 calc = A[i] + A[l] + A[r]\n#                 if calc > target:\n#                     r -= 1\n#                 elif calc < target:\n#                     l += 1\n#                 elif A[l] == A[r]:\n#                     x = r-l+1\n#                     comb = (x*(x-1)) / 2\n#                     total += comb\n#                     break\n#                 else:\n#                     lcount = 1\n#                     rcount = 1\n#                     while l+1 < r and A[l] == A[l+1]:\n#                         lcount += 1\n#                         l += 1\n#                     while r-1 > l and A[r] == A[r-1]:\n#                         rcount += 1\n#                         r -= 1\n#                     total += (lcount*rcount)\n#                     l += 1\n#                     r -= 1                    \n                \n#         return int(total%mod_pow)\n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        from collections import Counter \n        A.sort()\n        c = Counter(A)\n        res = 0\n        pre = -1\n        for i in range(len(A)):\n            if A[i] == pre: \n                continue\n            pre = A[i]\n            right = len(A) - 1\n            left = i + 1\n            while left < right:\n                if A[i] + A[left] + A[right] < target:\n                    left += 1\n                elif A[i] + A[left] + A[right] > target:\n                    right -= 1\n                else:\n                    if A[i] == A[right]:\n                        num = c[A[i]] * (c[A[i]] - 1) * (c[A[i]] - 2) / 6\n                    elif A[i] == A[left]:\n                        num = c[A[i]] * (c[A[i]] - 1) / 2 * c[A[right]]\n                    elif A[left] == A[right]:\n                        num = c[A[left]] * (c[A[left]] - 1) / 2 * c[A[i]]\n                    else:\n                        num = c[A[i]] * c[A[left]] * c[A[right]]\n                        \n                    \n                    res += num\n                    tmp_pre = A[left]\n                    while left < right and A[left] == tmp_pre:\n                        left += 1\n                    tmp_pre = A[right]\n                    while left < right and A[right] == tmp_pre:\n                        right -= 1               \n                    \n            \n                    \n        return int(res) % (10 ** 9 + 7) \n", "class Solution:\n    def threeSumMulti(self, A, target: int) -> int:\n        M = 1000000007\n        record = {}\n        for i in A:\n            if(i in record.keys()):\n                record[i] = record[i] + 1\n            else:\n                record[i] = 1\n                \n        k_list = list(record.keys())\n        k_list.sort()\n        #print(k_list)\n        n = len(k_list)\n        res = 0\n        for i in range(n):\n            for j in range(i, n):\n                residual = target - k_list[i] -k_list[j]\n                if(residual<k_list[j]):\n                    continue\n                if(i==j):\n                    if(record[k_list[i]]==1):\n                        continue\n                    else:\n                        if(residual in record.keys()):\n                            if(residual==k_list[j]):\n                                res = res + int(record[k_list[i]]*(record[k_list[i]]-1)*(record[k_list[i]]-2)/6)\n                                res = res%M\n                            else:\n                                multi = record[residual]\n                                res = res + int(record[k_list[i]]*(record[k_list[i]]-1)/2*multi)\n                                res = res%M\n                        else:\n                            continue\n                        \n                        #print(k_list[i], record[k_list[i]], multi)\n                else:\n                    if(residual in record.keys()):\n                        if(residual==k_list[j]):\n                            res = res + int(record[k_list[i]]*(record[k_list[j]])*(record[k_list[j]]-1)/2)\n                            res = res%M\n                        else:\n                            multi = record[residual]\n                            res = res + int(record[k_list[i]]*record[k_list[j]]*multi)\n                            res = res%M\n                    else:\n                        continue\n                    \n                    #print(k_list[i], k_list[j], record[k_list[i]], record[k_list[j]], multi)\n        \n        return res", "# from collections import Counter\n\n# class Solution(object):\n#     def threeSumMulti(self, A, target):\n#         MOD = 10**9 + 7\n#         count = [0] * 101\n#         for x in A:\n#             count[x] += 1\n\n#         ans = 0\n\n#         # All different\n#         for x in range(101):\n#             for y in range(x+1, 101):\n#                 z = target - x - y\n#                 if y < z <= 100:\n#                     ans += count[x] * count[y] * count[z]\n#                     ans %= MOD\n\n#         # x == y\n#         for x in range(101):\n#             z = target - 2*x\n#             if x < z <= 100:\n#                 ans += count[x] * (count[x] - 1) / 2 * count[z]\n#                 ans %= MOD\n\n#         # y == z\n#         for x in range(101):\n#             if (target - x) % 2 == 0:\n#                 y = (target - x) / 2\n#                 if x < y <= 100:\n#                     ans += count[x] * count[y] * (count[y] - 1) / 2\n#                     ans %= MOD\n\n#         # x == y == z\n#         if target % 3 == 0:\n#             x = target / 3\n#             if 0 <= x <= 100:\n#                 ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6\n#                 ans %= MOD\n\n#         return ans\n\nfrom collections import Counter,defaultdict\n\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        \n        A.sort()\n        dic= defaultdict(list)\n        count = Counter(A)\n        B=list(count.keys())*3\n        B.sort()\n        \n        seen=set()\n        \n        ans=0\n        \n        for i in range(len(B)):\n            dic[B[i]].append(i)\n        \n        for i in range(len(B)-2):\n            for j in range(i+1, len(B)-1):\n                temp=target-B[i]-B[j]\n                \n                if temp in dic:\n                    k=dic[temp][-1]\n\n                    if k>j:\n                        seen.add((B[i],B[j],B[k]))  \n        \n        def comb(n,m):\n            N=list(range(n-m+1,n+1))\n            M=list(range(1,m+1))\n            \n            nn=1\n            mm=1\n            for i in N:\n                nn*=i\n            \n            for i in M:\n                mm*=i\n                \n            return int(nn/mm)\n        \n        for t in seen:\n            temp=1\n            c=Counter(t)\n            print(t)\n            for i in c:\n                m=c[i]\n                n=count[i]\n                if m>n:\n                    temp=0\n                    break\n                temp*=comb(n,m)\n            ans+=temp\n                \n            \n        return ans%(10**9+7)\n", "from collections import Counter,defaultdict\n\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        \n        A.sort()\n        dic= defaultdict(list)\n        count = Counter(A)\n        B=list(count.keys())*3\n        B.sort()\n        \n        seen=set()\n        \n        ans=0\n        \n        for i in range(len(B)):\n            dic[B[i]].append(i)\n        \n        for i in range(len(B)-2):\n            for j in range(i+1, len(B)-1):\n                temp=target-B[i]-B[j]\n                \n                if temp in dic:\n                    k=dic[temp][-1]\n\n                    if k>j:\n                        seen.add((B[i],B[j],B[k]))  \n        \n        def comb(n,m):\n            N=list(range(n-m+1,n+1))\n            M=list(range(1,m+1))\n            \n            nn=1\n            mm=1\n            for i in N:\n                nn*=i\n            \n            for i in M:\n                mm*=i\n                \n            return int(nn/mm)\n        \n        for t in seen:\n            temp=1\n            c=Counter(t)\n            print(t)\n            for i in c:\n                m=c[i]\n                n=count[i]\n                if m>n:\n                    temp=0\n                    break\n                temp*=comb(n,m)\n            ans+=temp\n                \n            \n        return ans%(10**9+7)\n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        A.sort()\n        leftDict = defaultdict(int)\n        rightDict = Counter(A[1:])\n        ALen = len(A)\n        MOD = 10**9+7\n        leftDict[A[0]] += 1\n        ans = 0\n        for i in range(1, ALen-1):\n            Ai = A[i]\n            rightDict[Ai] -= 1\n            for left in leftDict:\n                ans += leftDict[left]*rightDict[target-Ai-left]\n            leftDict[Ai] += 1\n            ans %= MOD\n        return ans", "from collections import defaultdict\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        single = defaultdict(int)\n        double = defaultdict(int)\n        ans = 0\n        for x in A:\n            ans += double[target - x]\n            for k, v in single.items():\n                double[k + x] += v\n            single[x] += 1\n        return ans % (10**9 + 7)", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        d1=collections.defaultdict(int)\n        d2=collections.defaultdict(int)\n\n        N=len(A)\n        MOD=10**9+7\n        cnt = 0\n        for i in range(N-1,-1,-1):\n            n=A[i]\n            cnt+=d2[target-n]\n            cnt%=MOD\n            for (nn, nncnt) in list(d1.items()):\n                d2[nn+n]+=nncnt\n\n            d1[n]+=1\n\n        return cnt\n            \n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        d1 = collections.defaultdict(int)\n        d2 = collections.defaultdict(int)\n        ans = 0\n        for i in A:\n            ans += d2[target - i]\n            \n            for j in d1: \n                d2[j + i] += d1[j]\n            \n            d1[i] += 1\n        \n        return ans % int(1e9 + 7)\n                \n            \n        \n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        d1=collections.defaultdict(int)\n        d2=collections.defaultdict(int)\n\n        N=len(A)\n        MOD=10**9+7\n        cnt = 0\n        for i in range(N-1,-1,-1):\n            n=A[i]\n            cnt+=d2[target-n]\n            cnt%=MOD\n            for (nn, nncnt) in d1.items():\n                d2[nn+n]+=nncnt\n\n            d1[n]+=1\n\n        return cnt ", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        A.sort()\n        N = len(A)\n        ans = 0\n        counts = self.get_counts(A)\n        for i in range(N-2):\n            two_sum_target = target - A[i]\n            counts[A[i]] -= 1\n            ans += self.two_sum(A, i+1, two_sum_target, counts)\n        return ans % (10**9 + 7)\n    \n    def two_sum(self, A, i, target, counts):\n        j = len(A)-1\n        ans = 0\n        while i<j:\n            if A[i]+A[j]<target:\n                i+=counts[A[i]]\n            elif A[i]+A[j]>target:\n                j-=counts[A[j]]\n            else:\n                if A[i]==A[j]:\n                    v = counts[A[i]]\n                    ans += v*(v-1)//2\n                else:\n                    v1 = counts[A[i]]\n                    v2 = counts[A[j]]\n                    ans += v1*v2\n                i+=counts[A[i]]\n                j-=counts[A[j]]\n        return ans\n        \n    def get_counts(self, A):\n        d = {}\n        for num in A:\n            if num not in d:\n                d[num] = 0\n            d[num] += 1\n        return d\n", "# class Solution:\n#     def threeSumMulti(self, A: List[int], target: int) -> int:\n#         # 1 enumerating\n#         # 2. backtracking\n#         if len(A)<3:\n#             return 0\n        \n#         A.sort()\n#         self.target = target\n#         self.backtrace(A, [])\n#         #print(A,self.target, self.allPaths)\n#         return len(self.allPaths)\n    \n#     def __init__(self):\n#         self.allPaths = []\n    \n#     def backtrace(self, nums, path):\n#         if len(path) == 3:\n#             if sum(path)==self.target:\n#                 self.allPaths.append(path)\n#             return\n# #         if len(path) > 3:\n# #             return\n#         #print(len(nums), path)\n#         for i in range(len(nums)):\n#             if sum(path) <= self.target:\n#                 uPath = path + [nums[i]]\n#                 #print(uPath)\n#                 # allocate remaining\n#                 uNums = nums[i+1:]\n#                 self.backtrace(uNums, uPath)\nimport math\nimport collections\nclass Solution:\n\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        c1 = collections.Counter(A)\n        arr = []\n        triples = set()\n        for i in sorted(c1.keys()):\n            arr += [i] * min(3, c1[i])\n            \n        # find candidates from arr\n        for i in range(len(arr)-2):\n            j = i + 1\n            k = len(arr) - 1\n            twoSum = target - arr[i]\n            \n            while j<k:\n                tmp = arr[j] + arr[k]\n                if tmp == twoSum:\n                    triples.add((arr[i], arr[j], arr[k]))\n                    k -= 1\n                elif tmp >= twoSum:\n                    while k-1 > 0 and arr[k-1] == arr[k]:\n                        k -= 1\n                    k -= 1\n                else:\n                    while j+1 < len(arr)-1 and arr[j+1] == arr[j]:\n                        j += 1\n                    j += 1\n        # count the combinations\n        tot = 0\n        mod = 10**9 + 7\n        #print(triples)\n        for t in triples:\n            c2 = collections.Counter(t)\n            combs = 1\n            for k in list(c2.keys()):\n                combs *= math.comb(c1[k], c2[k])\n                combs %= mod\n            tot += combs\n            tot %= mod\n        return tot\n\n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        c = collections.Counter(A)\n        res = 0\n        for i, j in itertools.combinations_with_replacement(c, 2):\n            k = target - i - j\n            if i == j == k:\n                res += c[i] * (c[i] - 1) * (c[i] - 2) / 6\n            elif i == j != k:\n                res += c[i] * (c[i] - 1) / 2 * c[k]\n            elif k > i and k > j:\n                res += c[i] * c[j] * c[k]\n        return int(res % (10**9+7))\n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        counter = [0] * 101\n        for num in A:\n            counter[num] += 1\n        count = 0\n        MOD = int(10 ** 9 + 7)\n        for i in range(len(A) - 2):\n            counter[A[i]] -= 1\n            residual = target - A[i]\n            for Aj in range(101):\n                Ak = residual - Aj\n                if Ak >= 0 and Ak <= 100 and Aj <= Ak:\n                    if Aj != Ak:\n                        count += counter[Aj] * counter[Ak]\n                    else:\n                        count += (counter[Aj] * (counter[Aj] - 1)) // 2\n                    #print(A[i], Aj, Ak, count)\n        return count % MOD", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        # hashtable with dp\n        \n        res = 0\n        mod = int(1e9+7)\n        \n        numbers = dict()\n        sums = dict()\n        \n        for num in A:\n            res = (res + sums.get(target - num, 0)) % mod\n            \n            for number, count in list(numbers.items()):\n                sums[number + num] = sums.get(number+num, 0) + count\n                \n            numbers[num] = numbers.get(num, 0) + 1\n            \n        return res\n            \n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        cnt1 = collections.Counter()\n        cnt2 = collections.Counter()\n        result = 0\n        M = 10 ** 9 + 7\n        for a in A:\n            cnt2[a] += 1\n        for a in A:\n            cnt2[a] -= 1\n            if cnt2[a] == 0:\n                cnt2.pop(a)\n            for i, j in cnt1.items():\n                k = target - i - a\n                result = (result + j * cnt2[k]) % M\n            cnt1[a] += 1\n        return result", "from collections import Counter\nclass Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        c = Counter(A)\n        res = 0\n        s = list(set(A))\n        s.sort()\n        trips = set()\n        for i in range(len(s)):\n            if i > target / 3:\n                break\n            n = s[i]\n            l = i\n            r = len(s) - 1\n            while l <= r:\n                a = s[i] + s[l] + s[r]\n                if a == target:\n                    trips.add((s[i], s[l], s[r]))\n                    l += 1\n                    r -= 1\n                elif a > target:\n                    r -= 1\n                else:\n                    l += 1\n        print(trips)\n        for t in trips:\n            a = 1\n            for n in set(t):\n                count = c[n]\n                if t.count(n) == 3:\n                    a *= count * (count - 1) * (count - 2) / 6\n                elif t.count(n) == 2:\n                    a *= count * (count - 1) / 2\n                else:\n                    a *= count\n            res += a\n        return int(res) % (10**9+7)", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        m = collections.Counter(A)\n        res = 0\n        for n0, n1 in itertools.combinations_with_replacement(m, 2):\n            n2 = target - n0 - n1\n            if n0 == n1 == n2:\n                res += m[n0] * (m[n0] - 1) * (m[n0] - 2) // 6\n            elif n0 == n1 != n2:\n                res += (m[n0] * (m[n0] - 1) // 2) * m[n2]\n            elif max(n0, n1) < n2:\n                res += m[n0] * m[n1] * m[n2]\n            # print((n0, n1, n2), 'res', res)\n            \n        return res % (10**9 + 7)\n                \n        \n        \n        \n        \n        \n        \n#         m = collections.Counter(A)\n#         keys = sorted(m.keys())\n#         def twoSums(left, target):\n#             res = 0\n#             for i in range(left, len(keys)):\n#                 n = keys[i]\n#                 if n * 2 > target:\n#                     break\n#                 if n * 2 == target:\n#                     res += m[n] * (m[n] - 1) // 2\n#                     break\n#                 res += m[n] * m[target - n]\n#             return res\n        \n#         res = 0\n#         for i, n in enumerate(keys):\n#             if n * 3 > target:\n#                 break\n#             if n * 3 == target:\n#                 res += m[n] * (m[n] - 1) * (m[n] - 2) // 6\n#                 break\n            \n#             res += (m[n] * (m[n] - 1) // 2) * m[target - n * 2]\n#             count, m[n] = m[n], 0\n#             res += count * twoSums(i + 1, target - n)\n#         return res % (10**9 + 7)\n        \n        \n", "class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        MOD = 1000000007\n        count = [0] * 101\n        for x in A:\n            count[x] += 1\n        ans = 0\n        for x in range(101):\n            for y in range(x+1, 101):\n                z = target - x - y\n                if y < z <= 100:\n                    ans += count[x] * count[y] * count[z]\n                    ans %= MOD\n        for x in range(101):\n            z = target - 2*x\n            if x < z <= 100:\n                ans += count[x] * (count[x] - 1) // 2 * count[z]\n                ans %= MOD\n                \n        for x in range(101):\n            if (target - x) % 2 == 0:\n                y = (target - x) // 2\n                if x < y <= 100:\n                    ans += count[x] * count[y] * (count[y] - 1) // 2\n                    ans %= MOD\n        \n        if target % 3 == 0:\n            x = target // 3\n            if 0 <= x <= 100:\n                ans += count[x] * (count[x] - 1) * (count[x] - 2) // 6\n                ans %= MOD\n        return ans", "from math import comb\n\nclass Solution:\n    def threeSumMulti(self, a: List[int], target: int) -> int:\n        counts = Counter(a)\n        ans = 0\n        for i in list(counts.keys()):\n            for j in list(counts.keys()):\n                k = target - i - j\n                if i == j == k:\n                    ans += comb(counts[i], 3)\n                elif i == j and j < k:\n                    ans += comb(counts[i], 2) * counts[k]\n                elif i < j and j == k:\n                    ans += counts[i] * comb(counts[k], 2)\n                elif i < j < k:\n                    ans += counts[i] * counts[j] * counts[k]\n        return ans % (10**9 + 7)\n"]
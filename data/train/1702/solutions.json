["import math\n\nclass Sudoku(object):\n    def __init__(self, board):\n        self.board = board\n        \n    def is_valid(self):\n        if not isinstance(self.board, list):\n            return False\n        n = len(self.board)\n        rootN = int(round(math.sqrt(n)))\n        if rootN * rootN != n:\n            return False\n        isValidRow = lambda r : (isinstance(r, list) and\n                                 len(r) == n and\n                                 all([type(x) == int for x in r]))\n        if not all(map(isValidRow, self.board)):\n            return False\n        oneToN = set(range(1, n + 1))\n        isOneToN = lambda l : set(l) == oneToN\n        tranpose = [[self.board[j][i] for i in range(n)] for j in range(n)]\n        squares = [[self.board[p+x][q+y] for x in range(rootN) \n                                         for y in range(rootN)] \n                                         for p in range(0, n, rootN)\n                                         for q in range(0, n, rootN)] \n        return (all(map(isOneToN, self.board)) and\n                all(map(isOneToN, tranpose)) and\n                all(map(isOneToN, squares)))\n", "import numpy as np\nclass Sudoku(object):\n\n    def __init__(self, theArray):\n        self.grid = np.array(theArray)\n        self.listgrid = theArray\n        \n        self.N = len(theArray)\n        self.M = len(theArray[0])\n        \n    def has_valid_size(self):\n        \n        if isinstance(self.listgrid[0][0], bool): return False\n        if self.grid.shape == (1,1):\n            return True\n        for i in self.listgrid:\n            if len(i) != self.N: return False\n        return True\n\n    \n    #your code here\n    def is_valid(self):   \n        if not self.has_valid_size(): \n            return False\n        \n        seqs2check = [self.getRowsIterator(), self.getColsIterator(), self.getSquaresIterator()]\n        for it in seqs2check:\n            for seq in it:\n                if self.checkSeq(seq) == False:\n                    return False\n        return True            \n                \n    def getRowsIterator(self):\n        for i in range(self.N):\n            yield self.grid[i,:]\n            \n    def getColsIterator(self):\n        for i in range(self.N):\n            yield self.grid[:,i]\n            \n    def getSquaresIterator(self):\n        squareSize = int(np.sqrt(self.N))    \n        for i in range(squareSize):\n            for j in range(squareSize):\n                ix1 = i*squareSize\n                ix2 = j*squareSize\n                yield self.grid[ix1:ix1+squareSize, ix2:ix2+squareSize].flatten()\n        \n    def checkSeq(self, seq):\n        return sorted(seq) == list(range(1,self.N+1))\n", "import math\n\nclass Sudoku(object):\n    def __init__(self, board):\n        self.board = board\n        self.size = len(board)\n\n    @staticmethod\n    def reduce_logic(seq):\n        return reduce(lambda x, y: x and y, seq)\n\n    def is_square(self):\n        return self.reduce_logic(map(lambda x: len(x) == self.size, self.board))\n\n    def check_number(self):\n        return self.reduce_logic(map(lambda x: 0 < x <= self.size and type(x) == type(1),\n                                     reduce(lambda x, y: x + y, self.board)))\n\n    def check_seq(self, seq):\n        return self.reduce_logic(map(lambda x: len(set(x)) == self.size, seq))\n\n    def check_rows(self):\n        return self.check_seq(self.board)\n\n    def check_cols(self):\n        cols = [map(lambda x: x[i], self.board) for i in range(self.size)]\n        return self.check_seq(cols)\n\n    def check_little_squares(self):\n        sq = int(math.sqrt(self.size))\n        squares = [reduce(lambda x, y: x + y, map(lambda x: x[i:(i + sq)], self.board[j:(j + sq)]))\n                   for j in range(0, self.size, sq)\n                   for i in range(0, self.size, sq)]\n        return self.check_seq(squares)\n\n    def is_valid(self):\n        if (self.is_square() and\n                self.check_number() and\n                self.check_rows() and\n                self.check_cols() and\n                self.check_little_squares()):\n            return True\n        else:\n            return False", "from itertools import chain\nimport math\n\nclass Sudoku(object):\n\n    def __init__(self, data):\n        self.grip = data\n        self.len = len(data)\n        self.valid = (self.len == 1 and data != [[1]]) or not all(( len(e) == self.len for e in data )) or all(type(x)!=int for e in data for x in e )\n        self.box = int(math.sqrt(self.len))\n    \n    def resp(self):\n        self.grip = list( zip( *[ list( zip( *[iter(e)]*self.box)) for e in self.grip][::-1] ))\n        return [list(chain(*list( zip( *[iter(e)]*self.box))[i]))  for e in self.grip for i in range(len(self.grip)//self.box)]\n                 \n    def is_valid(self): \n        return not self.valid and all(( len(set(e)) == self.len  for e in self.resp() ))", "class Sudoku(object):\n    def __init__(self, grid):\n        self.grid = grid\n        self.dim = len(grid)\n        self.boxsize = int(self.dim ** 0.5)\n        self.nums = set(range(1, self.dim + 1))\n        \n    def row_valid(self, row):\n        return self.nums == set(self.grid[row])\n        \n    def col_valid(self, col):\n        return self.nums == set(self.grid[row][col] for row in range(self.dim))\n        \n    def box_valid(self, box):\n        box_row, box_col = divmod(box, self.boxsize)\n        box_row, box_col = box_row * self.boxsize, box_col * self.boxsize\n        return self.nums == set(self.grid[row][col]\n            for row in range(box_row, box_row + self.boxsize)\n            for col in range(box_col, box_col + self.boxsize))\n        \n    def is_valid(self):\n        if any(len(row) != self.dim for row in self.grid):\n            return False\n        if any(any(not isinstance(i, int) or i is True or i is False\n            for i in row)\n            for row in self.grid):\n            return False\n        return (all(self.row_valid(row) for row in range(self.dim)) and\n            all(self.col_valid(col) for col in range(self.dim)) and\n            all(self.box_valid(box) for box in range(self.dim)))", "import math\n\nclass Sudoku(object):\n    def __init__(self, board):\n        self.board = board\n        \n    def is_valid(self):\n        if not isinstance(self.board, list):\n            return False\n        n = len(self.board)\n        rootN = int(round(math.sqrt(n)))\n        if rootN * rootN != n:\n            return False\n        isValidRow = lambda r : (isinstance(r, list) and\n                                 len(r) == n and\n                                 all(map(lambda x : type(x) == int, r)))\n        if not all(map(isValidRow, self.board)):\n            return False\n        oneToN = set(range(1, n + 1))\n        isOneToN = lambda l : set(l) == oneToN\n        tranpose = [[self.board[i][j] for i in range(n)] for j in range(n)]\n        squares = [[self.board[p+x][q+y] for x in range(rootN) \n                                         for y in range(rootN)] \n                                         for p in range(0, n, rootN)\n                                         for q in range(0, n, rootN)] \n        return (all(map(isOneToN, self.board)) and\n                all(map(isOneToN, tranpose)) and\n                all(map(isOneToN, squares)))", "class Sudoku(object):\n    def __init__(self, board):\n        self.board = board\n    def is_valid(self):\n        n = int(len(self.board)**0.5)\n        if not all(len(row) == n*n and all(not isinstance(cell, bool) for cell in row) for row in self.board):\n            return False\n        r, rr = range(n), range(0, n*n, n)\n        blocks = [[self.board[x+a][y+b] for a in r for b in r] for x in rr for y in rr]\n        return not [x for x in self.board + list(zip(*self.board)) + blocks if set(x) != set(range(1, n*n + 1))]\n", "from itertools import chain\n\n\nclass Sudoku(object):\n\n    def __init__(self, data):\n        self.data = data\n        self.n = len(data)\n        self.nums = set(range(1, self.n+1))\n\n    def is_valid(self):\n        return (\n            all(len(row) == self.n for row in self.data)\n            and self.are_all_ints()\n            and self.are_row_nums_valid()\n            and self.are_col_nums_valid()\n            and self.are_squares_valid()\n        )\n\n    def are_all_ints(self):\n        return all(\n            isinstance(x, int) and not isinstance(x, bool)\n            for row in self.data for x in row\n        )\n\n    def are_row_nums_valid(self):\n        return all(set(row) == self.nums for row in self.data)\n    \n    def are_col_nums_valid(self):\n        return all(set(row) == self.nums for row in zip(*self.data))\n        \n    def are_squares_valid(self):\n        sq = int(self.n ** 0.5)\n        return all(\n            set(chain.from_iterable(row[j:j+sq] for row in self.data[i:i+sq])) == self.nums\n            for i in range(0, self.n, sq)\n            for j in range(0, self.n, sq)\n        )", "import math\n    \nclass Sudoku(object):        \n    def __init__(self, board):\n        self.board = board\n        self.size = len(board)\n        self.lil_size = math.sqrt(self.size)\n    \n    def is_valid(self):    \n        # dimensions must be the same\n        if not all(len(r) == self.size for r in self.rows()):\n            return False\n\n        # size must be a perfect square\n        if not self.lil_size.is_integer():\n            return False\n\n        # corner case (True == 1 in python)\n        if self.board[0][0] is True:\n            return False\n\n        # groups must fill the range\n        numbers = range(1, self.size + 1)\n        groups = self.rows() + self.columns() + self.lil_squares()        \n        for group in groups:\n            if sorted(group) != numbers:\n                return False\n      \n        return True       \n    \n    def rows(self):\n        return self.board\n        \n    def columns(self):\n        return zip(*self.rows())\n    \n    def lil_squares(self):\n        result = []\n        size = int(self.lil_size)\n        for i in range(size):\n            for j in range(size):            \n                square = []\n                for k in range(size):\n                    for l in range(size):\n                        square.append(self.board[i * size + k][j * size + l])\n                result.append(square)                \n        return result", "from itertools import chain\n\nclass Sudoku(object):\n\n    def __init__(self, grid):\n        self.grid = grid\n        self.size = len(grid)\n        self.good_zone = set(range(1, self.size + 1))\n    \n    def __iter__(self):\n        \"\"\"Iterate over each row, column and square of the sudoku\"\"\"\n        rows = self.grid\n        cols = zip(*rows)\n        square_size = int(self.size ** 0.5)\n        squares = [sum((rows[y+i][x:x+square_size]\n                        for i in range(square_size)), [])\n                   for y in range(0, self.size, square_size)\n                   for x in range(0, self.size, square_size)]\n        return chain(rows, cols, squares)\n    \n    def valid_data_types(self):\n        \"\"\"Check data types\"\"\"\n        return all(type(num) == int for num in chain(*self.grid))\n    \n    def zone_is_valid(self, zone):\n        \"\"\"Check if a zone contain every numbers\"\"\"\n        return set(zone) == self.good_zone\n    \n    def is_valid(self):\n        \"\"\"Is the sudoku solved\"\"\"\n        if not self.valid_data_types(): return False\n        return all(self.zone_is_valid(zone) for zone in self)"]
["try:\n# https://www.codechef.com/LTIME63B/problems/GHMC\n# Finally.... I properly understood what needs to be done.\n\n    def ctlt(arr, val):\n        # find number of values in sorted arr < val\n        if arr[0] >= val: return 0\n        lo = 0\n        hi = len(arr)\n        while hi-lo > 1:\n            md = (hi+lo)//2\n            if arr[md]<val:\n                lo = md\n            else:\n                hi = md\n\n        return hi\n\n    for _ in range(int(input())):\n        n,k,x,d = map(int, input().split())\n        z = input().strip().split()\n        if k > 0:\n            ps = list(map(int,z[:k]))\n        else:\n            ps = [x]\n\n        ps.sort()\n\n        if x<n or x<ps[-1] or n<k:\n            print(-1)\n            continue\n\n        valchecked = 0\n        fillval = 0\n        valsdone = False\n        isolbelow = True\n        lastp = ps[0]\n\n        while not valsdone and n>=k:\n            if n == k:\n                lo = x+d+1 # put out of range\n            else:\n            # find best maxfill (before val support)\n                lo = 1\n                hi = x+1\n                while hi-lo>1:\n                    md = (hi+lo)//2\n                    v = (x-md+1) + ctlt(ps,md)\n                    if v<n:\n                        hi = md\n                    else:\n                        lo = md\n        \n            valsdone = True\n            checkto = ctlt(ps,lo)-1\n            if checkto >= valchecked:            \n            # support all vals\n                for p in ps[valchecked+1:checkto+1]:\n                    if lastp+d >= p:\n                        isolbelow = False\n                    elif isolbelow:\n                        valsdone = False\n                        fillval += lastp+d\n                        n -= 1\n                        isolbelow = (p > lastp + 2*d )\n                    else:\n                        isolbelow = True\n                    lastp = p\n                valchecked = checkto\n                if valsdone and isolbelow: \n                # check gap to maxfill\n                    if lastp + d >= lo:\n                        isolbelow = False\n                    else:\n                        valsdone = False\n                        fillval += lastp\n                        ps[checkto] += d\n                        lastp += d\n                        isolbelow = False\n                        n -= 1\n\n        if k > n:\n            print(-1)\n        elif k == n:\n            print(sum(ps) + fillval)\n        elif k == n-1 and lo > ps[-1]:\n            print(sum(ps) + fillval + min(x,ps[-1]+d))\n        else:\n            tot = (x+lo)*(x-lo+1)//2  + sum(ps[:ctlt(ps,lo)])\n            print(tot + fillval)\nexcept:\n    pass", "# https://www.codechef.com/LTIME63B/problems/GHMC\r\n# Finally.... I properly understood what needs to be done.\r\n\r\ndef ctlt(arr, val):\r\n    # find number of values in sorted arr < val\r\n    if arr[0] >= val: return 0\r\n    lo = 0\r\n    hi = len(arr)\r\n    while hi-lo > 1:\r\n        md = (hi+lo)//2\r\n        if arr[md]<val:\r\n            lo = md\r\n        else:\r\n            hi = md\r\n\r\n    return hi\r\n\r\nfor _ in range(int(input())):\r\n    n,k,x,d = map(int, input().split())\r\n    z = input().strip().split()\r\n    if k > 0:\r\n        ps = list(map(int,z[:k]))\r\n    else:\r\n        ps = [x]\r\n\r\n    ps.sort()\r\n\r\n    if x<n or x<ps[-1] or n<k:\r\n        print(-1)\r\n        continue\r\n\r\n    valchecked = 0\r\n    fillval = 0\r\n    valsdone = False\r\n    isolbelow = True\r\n    lastp = ps[0]\r\n\r\n    while not valsdone and n>=k:\r\n        if n == k:\r\n            lo = x+d+1 # put out of range\r\n        else:\r\n            # find best maxfill (before val support)\r\n            lo = 1\r\n            hi = x+1\r\n            while hi-lo>1:\r\n                md = (hi+lo)//2\r\n                v = (x-md+1) + ctlt(ps,md)\r\n                if v<n:\r\n                    hi = md\r\n                else:\r\n                    lo = md\r\n        \r\n        valsdone = True\r\n        checkto = ctlt(ps,lo)-1\r\n        if checkto >= valchecked:            \r\n            # support all vals\r\n            for p in ps[valchecked+1:checkto+1]:\r\n                if lastp+d >= p:\r\n                    isolbelow = False\r\n                elif isolbelow:\r\n                    valsdone = False\r\n                    fillval += lastp+d\r\n                    n -= 1\r\n                    isolbelow = (p > lastp + 2*d )\r\n                else:\r\n                    isolbelow = True\r\n                lastp = p\r\n            valchecked = checkto\r\n            if valsdone and isolbelow: \r\n                # check gap to maxfill\r\n                if lastp + d >= lo:\r\n                    isolbelow = False\r\n                else:\r\n                    valsdone = False\r\n                    fillval += lastp\r\n                    ps[checkto] += d\r\n                    lastp += d\r\n                    isolbelow = False\r\n                    n -= 1\r\n\r\n    if k > n:\r\n        print(-1)\r\n    elif k == n:\r\n        print(sum(ps) + fillval)\r\n    elif k == n-1 and lo > ps[-1]:\r\n        print(sum(ps) + fillval + min(x,ps[-1]+d))\r\n    else:\r\n        tot = (x+lo)*(x-lo+1)//2  + sum(ps[:ctlt(ps,lo)])\r\n        print(tot + fillval)\r\n", "# https://www.codechef.com/LTIME63B/problems/GHMC\n# Finally.... I properly understood what needs to be done.\n\ndef ctlt(arr, val):\n    # find number of values in sorted arr < val\n    if arr[0] >= val: return 0\n    lo = 0\n    hi = len(arr)\n    while hi-lo > 1:\n        md = (hi+lo)//2\n        if arr[md]<val:\n            lo = md\n        else:\n            hi = md\n\n    return hi\n\nfor _ in range(int(input())):\n    n,k,x,d = map(int, input().split())\n    z = input().strip().split()\n    if k > 0:\n        ps = list(map(int,z[:k]))\n    else:\n        ps = [x]\n\n    ps.sort()\n\n    if x<n or x<ps[-1] or n<k:\n        print(-1)\n        continue\n\n    valchecked = 0\n    fillval = 0\n    valsdone = False\n    isolbelow = True\n    lastp = ps[0]\n\n    while not valsdone and n>=k:\n        if n == k:\n            lo = x+d+1 # put out of range\n        else:\n            # find best maxfill (before val support)\n            lo = 1\n            hi = x+1\n            while hi-lo>1:\n                md = (hi+lo)//2\n                v = (x-md+1) + ctlt(ps,md)\n                if v<n:\n                    hi = md\n                else:\n                    lo = md\n        \n        valsdone = True\n        checkto = ctlt(ps,lo)-1\n        if checkto >= valchecked:            \n            # support all vals\n            for p in ps[valchecked+1:checkto+1]:\n                if lastp+d >= p:\n                    isolbelow = False\n                elif isolbelow:\n                    valsdone = False\n                    fillval += lastp+d\n                    n -= 1\n                    isolbelow = (p > lastp + 2*d )\n                else:\n                    isolbelow = True\n                lastp = p\n            valchecked = checkto\n            if valsdone and isolbelow: \n                # check gap to maxfill\n                if lastp + d >= lo:\n                    isolbelow = False\n                else:\n                    valsdone = False\n                    fillval += lastp\n                    ps[checkto] += d\n                    lastp += d\n                    isolbelow = False\n                    n -= 1\n\n    if k > n:\n        print(-1)\n    elif k == n:\n        print(sum(ps) + fillval)\n    elif k == n-1 and lo > ps[-1]:\n        print(sum(ps) + fillval + min(x,ps[-1]+d))\n    else:\n        tot = (x+lo)*(x-lo+1)//2  + sum(ps[:ctlt(ps,lo)])\n        print(tot + fillval)\n"]
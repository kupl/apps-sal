["def convertToParitys(s):\r\n    \"\"\"\r\n    This converts the string s to an int, which is a bitMap of the parity of each letter\r\n    odd ? = first bit set\r\n    odd a = second bit set\r\n    odd b = third bit set \r\n    etc\r\n    \"\"\"\r\n    keys = '?abcdefghijklmnopqrstuvwxyz'\r\n    paritys = {c:0 for c in keys}\r\n    for c in s:\r\n        paritys[c] += 1\r\n    for c, v in paritys.items():\r\n        paritys[c] = v%2\r\n    \r\n    out = 0\r\n    bitValue = 1\r\n    for c in keys:\r\n        if paritys[c]:\r\n            out += bitValue\r\n        bitValue *= 2\r\n    return out\r\n\r\ndef getSolutionBitMaps(s):\r\n    \"\"\"\r\n    these are the 27 valid bitmaps that a substring can have\r\n    even ? and the parities the same\r\n    26 cases of odd ? and one bit different in the parity compared to s\r\n    \"\"\"\r\n    out = []\r\n    sP = convertToParitys(s)\r\n    if sP%2:\r\n        sP -= 1 # to remove the '?' parity\r\n    #even case - \r\n    out.append(sP)\r\n    #odd cases - need to xor sP with 1 + 2**n n = 1 to 26 inc to flip ? bit and each of the others\r\n    for n in range(1,27):\r\n        out.append(sP^(1+2**n))\r\n    return out\r\n\r\ndef getLeadingSubStringBitMapCounts(s):\r\n    \"\"\"\r\n    This calculates the bit map of each of the len(s) substrings starting with the first character and stores as a dictionary.\r\n    Getting TLE calculating each individually, so calculating with a single pass\r\n    \"\"\"\r\n    out = {}\r\n    bM = 0\r\n    keys = '?abcdefghijklmnopqrstuvwxyz'\r\n    paritys = {c:0 for c in keys}\r\n    values = {c:2**i for i,c in enumerate(keys)}\r\n    out[bM] = out.setdefault(bM, 0) + 1  #add the null substring\r\n    bMis = []\r\n    i = 0\r\n    bMis = [0]\r\n    for c in s:\r\n        i += 1\r\n        if paritys[c]:\r\n            paritys[c] = 0\r\n            bM -= values[c]\r\n        else:\r\n            paritys[c] = 1\r\n            bM += values[c]\r\n        out[bM] = out.setdefault(bM, 0) + 1\r\n        bMis.append(bM)\r\n    return out,bMis\r\n\r\ndef solve(s):\r\n    out = 0\r\n    bMjCounts,bMis = getLeadingSubStringBitMapCounts(s)\r\n    #print('bMjCounts')\r\n    #print(bMjCounts)\r\n    solutions = getSolutionBitMaps(s)\r\n    #print('solutions')\r\n    #print(solutions)    \r\n    for bMi in bMis:\r\n        for bMs in solutions:\r\n            if bMs^bMi in bMjCounts:\r\n                out += bMjCounts[bMs^bMi]\r\n                #print(i,bMi,bMs,bMs^bMi,bMjCounts[bMs^bMi])\r\n    if 0 in solutions:\r\n        out -= len(s) #remove all null substrings\r\n    out //= 2 # since j may be less that i each substring is counted twice\r\n    return out\r\n                \r\nT = int(input())\r\nfor tc in range(T):\r\n    s = input()\r\n    print(solve(s))\r\n    ", "\"\"\"\r\nCode Chef :: December 2020 Cookoff :: Sed Passwords \r\nProblem Code: SEDPASS\r\nhttps://www.codechef.com/COOK125A/problems/SEDPASS\r\n\"\"\"\r\nimport sys\r\n\r\n\r\ndef solve(S):\r\n    \"\"\"Solve puzzle.\"\"\"\r\n    N = len(S)\r\n    parity_S = 0\r\n    qs_add = (1 << 26)\r\n    ord_a = ord('a')\r\n    for i, c in enumerate(S):\r\n        if c != '?':\r\n            parity_S ^= (1 << (ord(c) - ord_a))\r\n\r\n    # The 27 good bitsets.\r\n    # The first is even parity ?s (26th bit = 0) and parity_S\r\n    good_Rs = [parity_S]\r\n    for c in range(26):\r\n        # The rest are odd parity ?s (26th bit) and parity_S with one\r\n        # character, c, with the opposite parity.\r\n        good_Rs.append((parity_S ^ (1 << c)) | qs_add)\r\n\r\n    # A substring S[i:j] has a parity of S[:j] ^ S[:i].\r\n    # a ^ b = c implies a ^ c = b.\r\n    # If S[:j] ^ a good_Rs = some S[:i] then S[i:j] is a good substring.\r\n    # So if we keep track of the S[:i] that we have already seen and \r\n    # at each j check each good_Rs to see if it matches previous S[:j]s\r\n    # that we have cached.  Note: a subtring parity may occur more than once.\r\n    prefix_parities = dict()\r\n    prefix_parities[0] = 1  # Be sure to add an empty S[:i].\r\n\r\n    parity_R = 0\r\n    soln = 0\r\n    for j, c in enumerate(S):\r\n        if c == \"?\":\r\n            parity_R ^= qs_add\r\n        else:\r\n            parity_R ^= (1 << (ord(c) - ord_a))\r\n\r\n        for good_R in good_Rs:\r\n            soln += prefix_parities.get(good_R ^ parity_R, 0)\r\n        if parity_R in prefix_parities:\r\n            prefix_parities[parity_R] += 1\r\n        else:\r\n            prefix_parities[parity_R] = 1\r\n\r\n    return soln\r\n\r\n\r\ndef main():\r\n    \"\"\"Main program.\"\"\"\r\n    test_cases = int(sys.stdin.readline())\r\n    for _ in range(test_cases):\r\n        S = sys.stdin.readline().strip()\r\n        print(solve(S))\r\n\r\n\r\ndef __starting_point():\r\n    main()\r\n\n__starting_point()", "'''Author- Akshit Monga'''\r\n# Complexity- (26*|S|)\r\nfrom sys import stdin,stdout\r\ninput = stdin.readline\r\ndef val(i):\r\n    if i=='?':\r\n        return 26\r\n    return ord(i)-97\r\nt = int(input())\r\nfor _ in range(t):\r\n    s=input()[:-1]\r\n    ans=0\r\n    mask=0\r\n    for i in s:\r\n        if i=='?':\r\n            continue\r\n        mask^=(1<<val(i))\r\n    hash={0:1}\r\n    pre=0\r\n    for i in s:\r\n        pre^=(1<<val(i))\r\n        ans+=hash.get(pre^mask,0)\r\n        x=mask^(1<<26)\r\n        for j in range(26):\r\n            ans+=hash.get(pre^(1<<j)^x,0)\r\n        hash[pre]=hash.get(pre,0)+1\r\n    stdout.write(str(ans)+'\\n')", "'''Author- Akshit Monga'''\r\n# Complexity- (26*26*|S|)\r\nfrom sys import stdin,stdout\r\ninput = stdin.readline\r\nt = int(input())\r\nfor _ in range(t):\r\n    s=input()[:-1]\r\n    n=len(s)\r\n    mask=[0 for i in range(26)]\r\n    for i in s:\r\n        if i=='?':\r\n            continue\r\n        mask[ord(i)-97]^=1\r\n    good=[mask+[0]]\r\n    for i in range(26):\r\n        temp=mask.copy()\r\n        temp[i]^=1\r\n        good.append(temp+[1])\r\n    pre_masks={'0'*27:1}\r\n    temp=[0 for i in range(27)]\r\n    ans=0\r\n    for i in range(n):\r\n        if s[i]=='?':\r\n            temp[26]^=1\r\n        else:\r\n            temp[ord(s[i])-97]^=1\r\n        good1=mask+[0]\r\n        xor = ''\r\n        for j in range(27):\r\n            xor += str(temp[j] ^ good1[j])\r\n        if xor in pre_masks:\r\n            ans += pre_masks[xor]\r\n        good2=mask+[1]\r\n        xor1 = ''\r\n        for j in range(27):\r\n            xor1 += str(temp[j] ^ good2[j])\r\n        for j in range(26):\r\n            xor2=xor1[:j]+str(int(xor1[j])^1)+xor1[j+1:]\r\n            if xor2 in pre_masks:\r\n                ans += pre_masks[xor2]\r\n        pre=''.join([str(e) for e in temp])\r\n        if pre in pre_masks:\r\n            pre_masks[pre]+=1\r\n        else:\r\n            pre_masks[pre]=1\r\n    stdout.write(str(ans)+'\\n')", "'''Author- Akshit Monga'''\r\n# Complexity- (26*26*|S|)\r\nfrom sys import stdin,stdout\r\ninput = stdin.readline\r\nt = int(input())\r\nfor _ in range(t):\r\n    s=input()[:-1]\r\n    n=len(s)\r\n    mask=[0 for i in range(26)]\r\n    for i in s:\r\n        if i=='?':\r\n            continue\r\n        mask[ord(i)-97]^=1\r\n    good=[mask+[0]]\r\n    for i in range(26):\r\n        temp=mask.copy()\r\n        temp[i]^=1\r\n        good.append(temp+[1])\r\n    pre_masks={'0'*27:1}\r\n    temp=[0 for i in range(27)]\r\n    ans=0\r\n    for i in range(n):\r\n        if s[i]=='?':\r\n            temp[26]^=1\r\n        else:\r\n            temp[ord(s[i])-97]^=1\r\n        good1=mask+[0]\r\n        xor = ''\r\n        for j in range(27):\r\n            xor += str(temp[j] ^ good1[j])\r\n        if xor in pre_masks:\r\n            ans += pre_masks[xor]\r\n        good2=mask+[1]\r\n        xor1 = ''\r\n        for j in range(27):\r\n            xor1 += str(temp[j] ^ good2[j])\r\n        for j in range(26):\r\n            xor2=xor1[:j]+str(int(xor1[j])^1)+xor1[j+1:]\r\n            if xor2 in pre_masks:\r\n                ans += pre_masks[xor2]\r\n        pre=''.join([str(e) for e in temp])\r\n        if pre in pre_masks:\r\n            pre_masks[pre]+=1\r\n        else:\r\n            pre_masks[pre]=1\r\n    stdout.write(str(ans)+'\\n')", "# from sys import stdin, stdout\n# from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\n# from collections import defaultdict as dd, deque\n# from heapq import merge, heapify, heappop, heappush, nsmallest\n# from bisect import bisect_left as bl, bisect_right as br, bisect\n# mod = pow(10, 9) + 7\n# mod2 = 998244353\n# def inp(): return stdin.readline().strip()\n# def out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\n# def outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\n# def lmp(): return list(mp())\n# def mp(): return map(int, inp().split())\n# def smp(): return map(str, inp().split())\n# def l1d(n, val=0): return [val for i in range(n)]\n# def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\n# def remadd(x, y): return 1 if x%y else 0\n# def ceil(a,b): return (a+b-1)//b\n\n# def isprime(x):\n#     if x<=1: return False\n#     if x in (2, 3): return True\n#     if x%2 == 0: return False\n#     for i in range(3, int(sqrt(x))+1, 2):\n#         if x%i == 0: return False\n#     return True\n    \n# def bitmsk(s):\n#     md = {}\n#     S = \"abcdefghijklmnopqrstuvwxyz\"\n#     for i in S:\n#         md[i]=0\n#     for i in s:\n#         if i in md: md[i]+=1\n#     b = \"\"\n#     for i in S:\n#         b+='1' if md[i]%2 else '0'\n#     return b\n\n# def xor(a, b):\n#     c = \"\"\n#     for i in range(27):\n#         if (a[i]=='0' and b[i]=='0') or (a[i]=='1' and b[i]=='1'): c += '0'\n#         else: c += '1'\n#     return c\n\n# for _ in range(int(inp())):\n#     s = inp()\n#     l = len(s)\n#     b = bitmsk(s)\n#     b += '0'\n#     good = []\n#     good.append(b)\n#     b = b[:-1]\n#     for i in range(26):\n#         x = '1' if b[i]=='0' else '0'\n#         good.append(b[:i]+x+b[i+1:]+'1')\n#     pre = ['0'*27]\n#     cq = 0\n#     mdd = {}\n#     for i in range(l):\n#         if s[i]=='?': cq+=1\n#         k = '1' if cq%2 else '0'\n#         kk = bitmsk(s[:i+1])+k\n#         pre.append(kk)\n#         if kk in mdd: mdd[kk].append((i+1))\n#         else: mdd[kk]=[(i+1)]\n#     # print(pre)\n#     ans = 0\n#     for i in range(l):\n#         # for j in range(i+1, l+1):\n#         #     if xor(pre[i], pre[j]) in good:\n#         #         ans += 1\n#         for j in good:\n#             xx = xor(pre[i], j)\n#             if xx in mdd:\n#                 ans += len(mdd[xx])-br(mdd[xx], i)\n#     out(ans)\n\n# cook your dish here\nfrom sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n    \ndef xor(a, b):\n    c = \"\"\n    for i in range(27):\n        if (a[i]=='0' and b[i]=='0') or (a[i]=='1' and b[i]=='1'): c += '0'\n        else: c += '1'\n    return c\n\nfor _ in range(int(inp())):\n    s = inp()\n    l = len(s)\n    md = {}\n    S = \"abcdefghijklmnopqrstuvwxyz\"\n    for i in S:\n        md[i]=0\n        \n    cq = 0\n    mdd = {}\n    pre = ['0'*27]\n    for i in range(l):\n        if s[i] in md: md[s[i]]+=1\n        b = \"\"\n        for j in S:\n            b+='1' if md[j]%2 else '0'\n        if s[i]=='?': cq+=1\n        k = '1' if cq%2 else '0'\n        kk = b+k\n        pre.append(kk)\n        if kk in mdd: mdd[kk].append((i+1))\n        else: mdd[kk]=[(i+1)]\n        \n    b = pre[-1]\n    good = []\n    good.append(b[:-1]+'0')\n\n    b = b[:-1]\n    for i in range(26):\n        x = '1' if b[i]=='0' else '0'\n        good.append(b[:i]+x+b[i+1:]+'1')\n    alpha = {}\n    S = \"abcdefghijklmnopqrstuvwxyz?\"\n    for i in range(27):\n        alpha[S[i]] = i\n    \n    ans = 0\n    for j in good:\n        prev = j\n        for i in range(l+1):\n            if i != 0:\n                x = alpha[s[i-1]]\n                kk = '0' if prev[x] == '1' else '1'\n                prev = prev[:x]+kk+prev[x+1:]\n            if prev in mdd:\n                ans += len(mdd[prev])-br(mdd[prev], i)\n    out(ans)", "# cook your dish here\ndef letterNo(c):\n    if i == '?':\n        return 26\n    return ord(c) - 97\nfor _ in range(int(input())):\n    s = input().strip()\n    mask = 0\n    for i in s:\n        if i != '?':\n            mask ^= (1 << letterNo(i))\n    d = {}\n    x = 0\n    d[0] = 1\n    ans = 0\n    for i in s:\n        x ^= (1 << letterNo(i))\n        ans += d.get(x^mask, 0)\n        for j in range(26):\n            ans += d.get(x^(1 << 26)^(1 << j)^mask, 0)\n        d[x] = d.get(x, 0) + 1\n    print(ans)\n", "def to_bit(c):\n    if c == \"?\":\n        bit = 26\n    else:\n        bit = (ord(c)-ord('a'))\n    return bit\n    \nT = int(input())\nfor _ in range(T):\n    s = input()\n    \n    mask = 0\n    for c in s:\n        if c != \"?\":\n            mask ^= 1 << to_bit(c)\n    \n    good_prefixes = []\n    good_prefixes.append(mask & ((1 << to_bit(\"?\")) - 1))\n    for i in range(26):\n        good_prefixes.append((mask ^ (1<<i)) | (1 << to_bit(\"?\")))\n    \n    prefixes = { 0: 1}\n  \n    res = 0\n    current = 0\n    for c in s:\n        current ^= 1 << to_bit(c)\n        for prefix in good_prefixes:\n            res += prefixes.get(prefix ^ current, 0)\n        prefixes[current] = prefixes.get(current, 0) + 1\n    \n    print(res)\n        \n        \n    "]
["LETTERS        = 'abcdefgh'                                                    # Defining some constants\nNUMBERS        = '87654321'\nW, B = WB      = 'Pp'\nEMPTY, CAPTURE = '.x'\nWHITEHOME      = '12'\nBLACKHOME      = '87'\nJUMP           = '54'\n\ndef pawn_move_tracker(moves):\n    board = {letter + number :                                                 # Representing board as\n             B if number == BLACKHOME[1] else                                  # a dictionary for easy\n             W if number == WHITEHOME[1] else EMPTY                            # access\n             for letter in LETTERS for number in NUMBERS}\n    whitemove = True                                                           # Move side switcher\n    for move in moves:\n        target    = move[-2:]                                                  # Finding target\n        mover     = move[0] + str(int(move[-1]) + 1 - whitemove * 2)           # Finding mover\n        if  move[-1] in JUMP[whitemove] and board[mover] == EMPTY:             # Mover for the jump\n            mover = move[0] + str(int(move[-1]) + 2 - whitemove * 4)\n        if (move[-1] in (BLACKHOME, WHITEHOME)[whitemove]           or         # Is the move valid?\n            board[target] != (EMPTY, WB[whitemove])[move[1] == CAPTURE] or\n            board[mover]  != WB[not whitemove]):\n            return \"{} is invalid\".format(move)\n        whitemove = not whitemove                                                  # Switching side\n        board[mover]  = EMPTY                                                      # Empty the source cell\n        board[target] = WB[whitemove]                                              # Fill the target\n    return [[board[letter + number] for letter in LETTERS] for number in NUMBERS]  # Return representation", "def pawn_move_tracker(moves):\n    board = [[c] * 8 for c in '.p....P.']\n    for turn, move in enumerate(moves, 1):\n        capture, white_turn = len(move) == 4, turn % 2\n        direction = 2 * white_turn - 1\n        c0, _, c, r = (move * 2)[:4]\n        c0, c, r = ord(c0) - ord('a'), ord(c) - ord('a'), 8 - int(r)\n        long_move = not capture and r == 3 + white_turn\n        for i in range(1, 2 + long_move):\n            r0 = r + direction * i\n            if board[r0][c0][0] == 'pP'[white_turn] \\\n                and board[r][c][0] == '.pP'[capture and 2 - white_turn]:\n                board[r0][c0], board[r][c] = '.', board[r0][c0]\n                break\n        else: return \"{} is invalid\".format(move)\n    return board", "def pawn_move_tracker(moves):\n    board_state = [\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n        [\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\"],\n        [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ]\n\n    board = Board(board_state)\n    next_board = board\n    player = 'P'\n\n    for move in moves:\n        next_board = board.play(move, player)\n        if(next_board == None):\n            return move + ' is invalid'\n\n        player = 'P' if player == 'p' else 'p'\n\n    return board.get_state()\n\nclass Pawn:\n    def __init__(self, cell, player):\n        self.cell = cell\n        self.moved = False\n        self.player = player\n        self.is_white = player == 'P'\n        self.is_black = player == 'p'\n        self.forward_direction = -1 if self.is_white else 1;\n\n    def moveTo(self, cell):\n        self.moved = True\n        self.cell.remove_pawn()\n        cell.add_pawn(self)\n        self.cell = cell\n        return cell\n\n    def belongsTo(self, player):\n        return self.player == player\n\n    # returns true if this pawn can move to the given cell in the context of a chess board\n    def canMoveTo(self, cell, board):\n        # can't move ahead if cell is occupied\n        if cell.is_occupied():\n            return False\n\n        steps_away = cell.row - self.cell.row\n\n        if steps_away == self.forward_direction * 1:\n            return True\n\n        if steps_away == self.forward_direction * 2:\n            cell_ahead = board.cellAt(self.cell.row + self.forward_direction, self.cell.col)\n            return not self.moved and not cell_ahead.is_occupied()\n\n    def canCapture(self, cell):\n        cell_has_enemy = cell.is_occupied() and cell.pawn.player != self.player\n        cell_is_ahead = cell.row - self.cell.row == self.forward_direction\n        cell_is_adjacent = abs(cell.col - self.cell.col)\n        return cell_has_enemy and cell_is_ahead and cell_is_adjacent\n\nclass Cell:\n    def __init__(self, row, col, occupant):\n        self.row = row\n        self.col = col\n        self.occupant = occupant\n\n        if(occupant != '.'):\n           self.pawn = Pawn(self, occupant)\n        else:\n           self.pawn = None\n\n    def is_occupied(self):\n        return not self.pawn == None\n\n    def add_pawn(self, pawn):\n        self.pawn = pawn\n        self.occupant = pawn.player\n\n    def remove_pawn(self):\n        self.pawn = None\n        self.occupant = '.'\n\nclass Board:\n    def __init__(self, board_array):\n        self.board_state = []\n\n        for i, row in enumerate(board_array):\n            board_row = []\n            for j, occupant in enumerate(row):\n                board_row.append(Cell(i,j, occupant))\n\n            self.board_state.append(board_row)\n\n    # returns all pawns in a given column. At most 2 pawns per column.\n    def pawnsInColumn(self, col):\n        cells = [row[col] for row in self.board_state]\n        return [cell.pawn for cell in cells if cell.is_occupied()]\n\n    def cellAt(self, row, col):\n        if(row < 0 or row > 7 or col < 0 or col > 7):\n            return None\n        return self.board_state[row][col]\n\n    def play(self, move, player):\n        if(len(move) == 2):\n           return self.playMove(move, player)\n        else:           \n           return self.playCapture(move, player)\n\n    def playMove(self, move, player):\n        row, col = toCoords(move)\n        cell = self.cellAt(row, col)\n        pawns = self.pawnsInColumn(col)\n\n        for pawn in pawns:\n            if pawn.belongsTo(player) and pawn.canMoveTo(cell, self):\n                pawn.moveTo(cell)\n                return self\n        return None\n\n    def playCapture(self, move, player):\n        col = toCol(move[0])\n        capture_row, capture_col = toCoords(move[2:])\n        cell = self.cellAt(capture_row, capture_col)\n        pawns = self.pawnsInColumn(col)\n\n        for pawn in pawns:\n            if pawn.belongsTo(player) and pawn.canCapture(cell):\n                pawn.moveTo(cell)\n                return self\n        return None\n\n    def get_state(self):\n        return list([list([cell.occupant for cell in row]) for row in self.board_state])\n\ndef toCoords(move):\n    col = toCol(move[0])\n    row = 8 - int(move[1])\n    return [row, col]\n\ndef toCol(move):\n    return (ord(move) - 97)\n", "def pawn_move_tracker(moves):\n    board = [\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ]\n    turn = 0\n    for p in moves:\n        if len(p) == 2:\n            x,y = 'abcdefgh'.index(p[0]), 8-int(p[1])\n            if board[y][x]!='.': return p+' is invalid'\n            if turn == 0:\n                if y<7 and board[y+1][x] == 'P': board[y][x]='P'; board[y+1][x]='.'\n                elif y==4 and board[y+1][x] == '.' and board[y+2][x] == 'P': board[y][x]='P'; board[y+2][x]='.'\n                else: return p+' is invalid'\n            else:\n                if y>0 and board[y-1][x] == 'p': board[y][x]='p'; board[y-1][x]='.'\n                elif y==3 and board[y-1][x] == '.' and board[y-2][x] == 'p': board[y][x]='p'; board[y-2][x]='.'\n                else: return p+' is invalid'\n        else:\n            x,y,fx,fy = 'abcdefgh'.index(p[2]), 8-int(p[3]), 'abcdefgh'.index(p[0]), 8-int(p[3])+(1-turn*2)\n            if turn == 0:\n                if board[y][x]=='p' and board[fy][fx]=='P': board[y][x]='P'; board[fy][fx]='.'\n                else: return p+' is invalid'\n            else:\n                if board[y][x]=='P' and board[fy][fx]=='p': board[y][x]='p'; board[fy][fx]='.'\n                else: return p+' is invalid'\n        turn ^= 1\n    return board", "def pawn_move_tracker(moves):\n\n    def getSourcePos(m, delta):  return m[0] + str(int(m[-1]) + delta * comingFrom[player])\n    \n    ROWS, COLS = \"87654321\", \"abcdefgh\"                                                          # constants...\n    comingFrom, mayBeDouble = {'P': -1, 'p': 1}, {'P': '4', 'p': '5'}                            # constants...\n    \n    pawns = {'P': {y+\"2\" for y in COLS}, 'p': {y+\"7\" for y in COLS}}                             # All pawns at their initial position\n    for t,m in enumerate(moves):\n        player, other, toMove = \"Pp\"[t%2], \"pP\"[t%2], set()\n        \n        toMove.add(getSourcePos(m, 1))                                                           # Single move or capturing pawn\n        if m[1] == mayBeDouble[player] and m[1]!='x':  toMove.add(getSourcePos(m, 2))            # Double move if m in row 4 or 5, according to \"player\" (only if not capturing move for m)\n        toMove &= pawns[player]                                                                  # Extract matching pawn(s)\n        \n        if ( m[1] == 'x' and m[2:] not in pawns[other] or m[1] != 'x' and m in pawns[other]      # Invalid if capturing non-existing enemy or moving to a position occupied by enemy...\n          or m in pawns[player] or len(toMove) != 1):                                            # ... or moving to a position occupied by friend or no pawn to move or too many.\n            return \"{} is invalid\".format(m)\n        \n        if m[1] == 'x':\n            m = m[2:]; pawns[other].remove(m)                                                    # Reassign final position (needed if capture) and remove captured enemy piece\n        pawns[player].remove(toMove.pop())                                                       # Move current pawn (remove/add) \n        pawns[player].add(m)\n            \n    board = {pos: k for k,s in pawns.items() for pos in s}                                       # Dict of all remaining pawns and their position\n    return [[board.get(y+x, '.') for y in COLS] for x in ROWS]                                   # final board", "import re\n\n\ndef pawn_move_tracker(moves):\n    turn = 0\n    white = ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n    black = ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n\n    try:\n        for move in moves:\n            if re.match('[a-h][1-8]', move):\n                white, black = motion(white, black, move, turn)\n            elif re.match('[a-h]x[a-h][1-8]', move):\n                white, black = eat(white, black, move, turn)\n            turn = (turn + 1) % 2\n    except ValueError as move:\n        return '{0} is invalid'.format(move)\n\n    return pawns_to_board(white, black)\n\n\ndef motion(white, black, move, turn):\n    column = move[0]\n    row = move[1]\n    piece = None\n    if turn == 0:\n        try:\n            search_row = str(int(row) - 1)\n            piece = white.index(column + search_row)\n\n        except ValueError:\n            try:\n                if row == '4':\n                    piece = white.index(column + '2')\n                else:\n                    raise ValueError\n            except ValueError:\n                raise ValueError(move)\n\n        try:\n            black.index(move)\n        except ValueError:\n            white[piece] = move\n        else:\n            raise ValueError(move)\n\n    elif turn == 1:\n        try:\n            search_row = str(int(row) + 1)\n            piece = black.index(column + search_row)\n\n        except ValueError:\n            try:\n                if row == '5':\n                    piece = black.index(column + '7')\n                else:\n                    raise ValueError\n            except ValueError:\n                raise ValueError(move)\n\n        try:\n            white.index(move)\n        except ValueError:\n            black[piece] = move\n        else:\n            raise ValueError(move)\n\n    return [white, black]\n\n\ndef eat(white, black, move, turn):\n    column = move[0]\n    row = move[3]\n    piece = None\n    dead = None\n    if turn == 0:\n        try:\n            search_row = str(int(row) - 1)\n            piece = white.index(column + search_row)\n        except ValueError:\n            raise ValueError(move)\n\n        else:\n            try:\n                dead = black.index(move[2:4])\n            except ValueError:\n                raise ValueError(move)\n            else:\n                white[piece] = move[2:4]\n                del black[dead]\n\n    elif turn == 1:\n        try:\n            search_row = str(int(row) + 1)\n            piece = black.index(column + search_row)\n        except ValueError:\n            raise ValueError(move)\n\n        else:\n            try:\n                dead = white.index(move[2:4])\n            except ValueError:\n                raise ValueError(move)\n            else:\n                black[piece] = move[2:4]\n                del white[dead]\n\n    return [white, black]\n\n\ndef pawns_to_board(white, black):\n    board = [['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.'],\n             ['.', '.', '.', '.', '.', '.', '.', '.']]\n    for i in white:\n        r, c = coords(i)\n        board[r][c] = 'P'\n    for i in black:\n        r, c = coords(i)\n        board[r][c] = 'p'\n\n    return board\n\n\ndef coords(pos):\n    col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].index(pos[0])\n    row = 8 - int(pos[1])\n    return [row, col]", "LETTERS        = 'abcdefgh'\nNUMBERS        = '87654321'\nW, B = WB      = 'Pp'\nEMPTY, CAPTURE = '.x'\nWHITEHOME      = '12'\nBLACKHOME      = '87'\nJUMP           = '54'\n\ndef pawn_move_tracker(moves):\n    board = {letter + number :\n             B if number == BLACKHOME[1] else W if number == WHITEHOME[1] else EMPTY\n             for letter in LETTERS for number in NUMBERS}\n    whitemove = True\n    for move in moves:\n        target    = move[-2:]\n        mover     = move[0] + str(int(move[-1]) + 1 - whitemove * 2)\n        if  move[-1] in JUMP[whitemove] and board[mover] == EMPTY:\n            mover = move[0] + str(int(move[-1]) + 2 - whitemove * 4)\n        if (move[-1] in (BLACKHOME, WHITEHOME)[whitemove]           or\n            board[target] != (EMPTY, WB[whitemove])[move[1] == CAPTURE] or\n            board[mover]  != WB[not whitemove]):\n            return \"{} is invalid\".format(move)\n        whitemove = not whitemove\n        board[mover]  = EMPTY\n        board[target] = WB[whitemove]\n    return [[board[letter + number] for letter in LETTERS] for number in NUMBERS]\n", "import numpy as np\ndef pawn_move_tracker(moves):\n    \n    print(moves)\n    board = [\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ]\n    \n    board = np.asarray(board)\n    white = True\n    cols = {'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7}\n    \n\n    for move in moves:\n        if white:\n            diff, piece, start = 1, 'P', 6\n        else:\n            diff, piece, start = -1, 'p', 1\n            \n        if 'x' in move:\n            splt = move.split('x')\n            new_c, new_r = cols[splt[1][0]], 8 - int(splt[1][1]) \n            old_c, old_r = cols[splt[0]], new_r + diff\n            if board[old_r,old_c] != piece or board[new_r, new_c] in ['.',piece]:\n                return move + ' is invalid'\n            else:\n                board[old_r,old_c]  = '.'\n                board[new_r, new_c] = piece\n        else:\n            col, new_row = cols[move[0]], 8 - int(move[1]) \n            if board[new_row,col] != '.':\n                return move + ' is invalid'\n            \n            x = np.where(board == piece)\n            \n            pwns = list((zip(x[0],x[1])))\n            if (new_row + diff, col) in pwns:\n                board[new_row + diff, col] = '.'\n                board[new_row, col] = piece\n            elif new_row + 2*diff == start:\n                if (new_row + 2*diff, col) in pwns:\n                    board[new_row + 2*diff, col] = '.'\n                    board[new_row, col] = piece\n            else:\n                return move + ' is invalid'\n                \n                \n                \n        if white:\n            white = False\n        else:\n            white = True\n\n    \n    return np.ndarray.tolist(board)", "def pawn_move_tracker(moves):\n    white_pawns = [(x, 2) for x in range(1,9)]\n    black_pawns = [(x, 7) for x in range(1,9)]\n    all_pawns = (white_pawns, black_pawns)\n    turn = 0\n    for move in moves:\n        pawns = all_pawns[turn]\n        opponent = all_pawns[turn^1]\n        direction = 1 - 2 * turn\n        capture = 'x' in move\n        if capture:\n            sx, dx, dy = column(move[0]), column(move[2]), int(move[3])\n            if (dx, dy) in opponent: opponent.remove((dx, dy))\n            else: return f'{move} is invalid'\n        else:\n            sx = dx = column(move[0])\n            dy = int(move[1])\n            if (dx, dy) in opponent or (dx, dy-direction) in opponent:\n                return f'{move} is invalid'\n        sy = dy - direction\n        if not capture and dy == (4,5)[turn] and not (sx,sy) in pawns:\n            sy -= direction\n        if (sx, sy) not in pawns:\n            return f'{move} is invalid'\n        pawns.remove((sx, sy))\n        pawns.append((dx, dy))\n        turn ^= 1\n    char = lambda p: 'P' if p in white_pawns else 'p' if p in black_pawns else '.'\n    return [[char((x, y)) for x in range(1, 9)] for y in range(8, 0, -1)]\n\ndef column(c):\n    return ' abcdefgh'.index(c)\n", "def pawn_move_tracker(moves):\n    board = [\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n    [\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\"],\n    [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n        \n    for i in range(len(moves)):\n        # Flip row to work with array indexing\n        row = abs(int(moves[i][1])-8) if moves[i][1] != 'x' else abs(int(moves[i][3])-8)\n        col = ord(moves[i][0])-97 if moves[i][1] != 'x' else ord(moves[i][2])-97\n        white_turn = bool((i % 2) == 0)\n        piece1 = \"P\" if white_turn == True else \"p\" #piece to move\n        piece2 = \"p\" if white_turn == True else \"P\" #piece to take\n        # Back is down if white's turn, and up if black's turn\n        back1 = row + 1 if white_turn == True else row - 1\n        back2 = row + 2 if white_turn == True else row - 2\n        # Most likely current position, updated if necessary\n        current_row, current_col = back1, col\n        \n        # If capturing enemy pawn\n        if 'x' in moves[i] and board[row][col] == piece2:\n            current_col = ord(moves[i][0]) - 97\n            if board[back1][current_col] != piece1:\n                return f\"{moves[i]} is invalid\"\n        # If moving 2 squares from starting position\n        elif board[back1][col] == \".\" and board[back2][col] == piece1:\n            if (white_turn == True and back2 == 6) or (white_turn == False and back2 == 1):\n                current_row = back2\n            else:\n                return f\"{moves[i]} is invalid\"\n        # Standard move forward, ensure move is valid\n        elif board[back1][col] != piece1 or board[row][col] != \".\":\n            return f\"{moves[i]} is invalid\"\n        \n        # Update board\n        board[current_row][current_col] = \".\"\n        board[row][col] = piece1\n                \n    return board"]
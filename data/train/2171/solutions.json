["import sys\n\ndef dfs(tree, root, priv_root, cur_lvl, priv_lvl, diff, pick_list):\n    if not tree:\n        return\n    stack = [(root, priv_root, cur_lvl, priv_lvl)]\n    while stack:\n        (root, priv_root, cur_lvl, priv_lvl) = stack.pop()\n        if cur_lvl ^ diff[root]:\n            cur_lvl ^= 1\n            pick_list.append(str(root))\n        stack += [(vertex, root, priv_lvl, cur_lvl)\n                for vertex in tree[root] if vertex != priv_root]\n\ndef main():\n    n = int(input())\n    tree = dict()\n    for _ in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        tree[u] = tree.get(u, set()) | set([v])\n        tree[v] = tree.get(v, set()) | set([u])\n    init = [0] + list(map(int, input().split()))\n    goal = [0] + list(map(int, input().split()))\n    diff = [i ^ j for (i, j) in zip(init, goal)]\n    pick_list = list()\n\n    dfs(tree, 1, 0, 0, 0, diff, pick_list)\n\n    num = len(pick_list)\n    print(num)\n    if num:\n        print('\\n'.join(pick_list))\n\ndef __starting_point():\n    return(main())\n\n__starting_point()", "n = int(input())\np = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    p[a].append(b)\n    p[b].append(a)\nu, v = ' ' + input()[:: 2], ' ' + input()[:: 2]\ns, q = [(1, 0, 0, 0)], []\nwhile s:\n    a, k, i, j = s.pop()\n    if k:\n        if i != (u[a] != v[a]):\n            q.append(a)\n            i = 1 - i\n    else:\n        if j != (u[a] != v[a]):\n            q.append(a)\n            j = 1 - j\n    k = 1 - k\n    for b in p[a]:\n        p[b].remove(a)\n        s.append((b, k, i, j))\nprint(len(q))\nprint('\\n'.join(map(str, q)))", "import sys\nread = lambda t=int: list(map(t,sys.stdin.readline().split()))\n# import resource, sys\n# resource.setrlimit(resource.RLIMIT_STACK, (2**20,-1))\n# sys.setrecursionlimit(10**5+5)\n\nN, = read()\ntree = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = read()\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\nlabels = read()\ngoals = read()\nres = []\n\ndef dfs(root, par, xor0, xor1, depth):\n    if depth == 0:\n        if labels[root]^xor0 != goals[root]:\n            res.append(root)\n            xor0 ^= 1\n    if depth == 1:\n        if labels[root]^xor1 != goals[root]:\n            res.append(root)\n            xor1 ^= 1\n    for v in tree[root]:\n        if v != par:\n            yield (v, root, xor0, xor1, depth^1)\n\nstack = [(0,-1,0,0,0)]\nwhile stack:\n    for item in dfs(*stack.pop()):\n        stack.append(item)\n# dfs(0, -1, 0, 0, 0)\n\nprint(len(res))\nfor x in res:\n    print(x+1)\n", "import sys\n\n\ndef dfs(tree, root, priv_root, cur_lvl, priv_lvl, diff, pick_list):\n    if not tree:\n        return\n    stack = [(root, priv_root, cur_lvl, priv_lvl)]\n    while stack:\n        (root, priv_root, cur_lvl, priv_lvl) = stack.pop()\n        if cur_lvl ^ diff[root]:\n            cur_lvl ^= 1\n            pick_list.append(str(root))\n        stack += [(vertex, root, priv_lvl, cur_lvl)\n                for vertex in tree[root] if vertex != priv_root]\n\ndef main():\n    n = int(input())\n    tree = dict()\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u] = tree.get(u, set()) | set([v])\n        tree[v] = tree.get(v, set()) | set([u])\n    init = [0] + list(map(int, input().split()))\n    goal = [0] + list(map(int, input().split()))\n    diff = [i ^ j for (i, j) in zip(init, goal)]\n    pick_list = list()\n\n    dfs(tree, 1, 0, 0, 0, diff, pick_list)\n\n    num = len(pick_list)\n    print(num)\n    if num:\n        print('\\n'.join(pick_list))\n\ndef __starting_point():\n    return(main())\n__starting_point()", "import sys\n\n\ndef dfs(tree, root, priv_root, cur_lvl, priv_lvl, diff, pick_list):\n    # if tree is 1 or less nodes just return nothing\n    if not tree:\n        return\n    stack = [(root, priv_root, cur_lvl, priv_lvl)]\n    while stack:\n        (root, priv_root, cur_lvl, priv_lvl) = stack.pop()\n        # set level to account for only evens where a difference exists\n        if cur_lvl ^ diff[root]:\n            cur_lvl ^= 1\n            pick_list.append(str(root))\n        # add to the queue all cases where a vertex exists\n        stack += [(vertex, root, priv_lvl, cur_lvl)\n                for vertex in tree[root] if vertex != priv_root]\n\ndef main():\n    n = int(input())\n    tree = dict()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree[u] = tree.get(u, set()) | set([v])\n        tree[v] = tree.get(v, set()) | set([u])\n    init = [0] + [int(x) for x in input().split()]\n    goal = [0] + [int(x) for x in input().split()]\n    # find numbers that don't match that need to be accounted for\n    diff = [i ^ j for (i, j) in zip(init, goal)]\n    pick_list = list()\n\n    dfs(tree, 1, 0, 0, 0, diff, pick_list)\n\n    num = len(pick_list)\n    print(num)\n    if num:\n        print('\\n'.join(pick_list))\n\ndef __starting_point():\n    return(main())\n__starting_point()", "# 429A\n\n__author__ = 'artyom'\n\n\ndef read_int():\n  return int(input())\n\n\ndef read_int_ary():\n  return map(int, input().split())\n\n\nn = read_int()\n\ng = [[] for x in range(n + 1)]\nfor i in range(n - 1):\n  u, v = read_int_ary()\n  g[u].append(v)\n  g[v].append(u)\n\ninit = [0] + list(read_int_ary())\ngoal = [0] + list(read_int_ary())\ns = []\n\n\n# def solve(graph, level, state, node, parent=-1):\n# t = level % 2\n# st = list(state)\n# if init[node] ^ st[t] == goal[node]:\n#     s.append(node)\n#     st[t] = 1 - st[t]\n#   for child in graph[node]:\n#     if child != parent:\n#       solve(graph, level + 1, st, child, node)\n\n\ndef solve(graph, start):\n  stack = [(start, -1, [1, 1], 0)]\n  while stack:\n    params = stack.pop(-1)\n    node = params[0]\n    parent = params[1]\n    st = list(params[2])\n    sign = params[3]\n    if init[node] ^ st[sign] == goal[node]:\n      s.append(node)\n      st[sign] = 1 - st[sign]\n    sign = 1 - sign\n    for child in graph[node]:\n      if child != parent:\n        stack.append((child, node, st, sign))\n\n\nsolve(g, 1)\nprint(len(s))\nfor v in s:\n  print(v)", "# 429A\n\n__author__ = 'artyom'\n\n\ndef read_int():\n  return int(input())\n\n\ndef read_int_ary():\n  return map(int, input().split())\n\n\nn = read_int()\n\ng = [[] for x in range(n + 1)]\nfor i in range(n - 1):\n  u, v = read_int_ary()\n  g[u].append(v)\n  g[v].append(u)\n\ninit = [0] + list(read_int_ary())\ngoal = [0] + list(read_int_ary())\ns = []\n\n\n# def solve(graph, level, state, node, parent=-1):\n# t = level % 2\n# st = list(state)\n# if init[node] ^ st[t] == goal[node]:\n#     s.append(node)\n#     st[t] = 1 - st[t]\n#   for child in graph[node]:\n#     if child != parent:\n#       solve(graph, level + 1, st, child, node)\n\n\ndef solve(graph, start):\n  stack = [(start, -1, [1, 1], 0)]\n  while stack:\n    params = stack.pop(-1)\n    node = params[0]\n    parent = params[1]\n    st = list(params[2])\n    sign = params[3]\n    if init[node] ^ st[sign] == goal[node]:\n      s.append(node)\n      st[sign] ^= 1\n    sign ^= 1\n    for child in graph[node]:\n      if child != parent:\n        stack.append((child, node, st, sign))\n\n\nsolve(g, 1)\nprint(len(s))\nfor v in s:\n  print(v)", "# 429A\n\n__author__ = 'artyom'\n\n\ndef read_int():\n  return int(input())\n\n\ndef read_int_ary():\n  return map(int, input().split())\n\n\nn = read_int()\n\ng = [[] for x in range(n + 1)]\nfor i in range(n - 1):\n  u, v = read_int_ary()\n  g[u].append(v)\n  g[v].append(u)\n\ninit = [0] + list(read_int_ary())\ngoal = [0] + list(read_int_ary())\ns = []\n\n\ndef solve(graph, start):\n  stack = [(start, -1, 0, [1, 1])]\n  while stack:\n    node, parent, sign, st = stack.pop(-1)\n    if init[node] ^ st[sign] == goal[node]:\n      s.append(node)\n      st = list(st)\n      st[sign] ^= 1\n    sign ^= 1\n    for child in graph[node]:\n      if child != parent:\n        stack.append((child, node, sign, st))\n\n\nsolve(g, 1)\nprint(len(s))\nfor v in s:\n  print(v)", "# 429A\n\n__author__ = 'artyom'\n\n\ndef read_int():\n  return int(input())\n\n\ndef read_int_ary():\n  return map(int, input().split())\n\n\nn = read_int()\n\ng = [[] for x in range(n + 1)]\nfor i in range(n - 1):\n  u, v = read_int_ary()\n  g[u].append(v)\n  g[v].append(u)\n\ninit = [0] + list(read_int_ary())\ngoal = [0] + list(read_int_ary())\ns = []\n\n\ndef solve(graph, start):\n  stack = [(start, -1, 0, [1, 1])]\n  while stack:\n    node, parent, sign, st = stack.pop(-1)\n    if init[node] ^ st[sign] == goal[node]:\n      s.append(node)\n      st = list(st)\n      st[sign] ^= 1\n    sign ^= 1\n    for child in graph[node]:\n      if child != parent:\n        stack.append((child, node, sign, st))\n\n\nsolve(g, 1)\nprint(len(s))\nprint('\\n'.join(map(str, s)))", "def main():\n    n = int(input())\n    l = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        l[u].append(v)\n        l[v].append(u)\n    sw = [a != b for a, b in zip(input()[::2], input()[::2])]\n    root = (1, False, False)\n    nxt, res, avail = [root], [0], [True] * (n + 1)\n    while nxt:\n        cur, nxt = nxt, []\n        for v, a, b in cur:\n            if sw[v - 1] != a:\n                a = not a\n                res.append(v)\n            avail[v] = False\n            for u in l[v]:\n                if avail[u]:\n                    nxt.append((u, b, a))\n    res[0] = len(res) - 1\n    print('\\n'.join(map(str, res)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict,deque,Counter,OrderedDict\nimport sys\n\ndef main():\n    n = int(input())\n    adj = [ [] for i in range(n+1)]\n    for i in range(n-1):\n        a,b = map(int,input().split())\n        a,b = a-1,b-1\n        adj[a].append(b)\n        adj[b].append(a)\n    init = [int(i) for i in input().split()]\n    goal = [int(i) for i in input().split()]\n    visited = [0]*n\n    par = [[] for i in range(n)]\n    dq = deque()\n    dq.append((0,0))\n    while len(dq) > 0:\n        (s,p) = dq.pop()\n        if visited[s]: continue\n        visited[s] = 1\n        par[p].append(s)\n        for i in adj[s]:\n            dq.append((i,s))\n    par[0] = par[0][1:]\n    ans = []\n    dq = deque()\n    dq.append((0,0,0,0))\n    while len(dq) > 0:\n        (s,l,fo,fe) = dq.pop()\n        if l % 2 == 0:\n            if fe % 2 == 1:\n                init[s] = 1 - init[s]\n        else:\n            if fo % 2 == 1:\n                init[s] = 1 - init[s]\n        if init[s] != goal[s]:\n            ans.append(s + 1)\n            if l % 2:\n                fo += 1\n            else:\n                fe += 1\n        for j in par[s]:\n            dq.append((j,l+1,fo,fe))\n\n    print(len(ans))\n    print(\"\\n\".join(map(str,ans)))\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import insort, bisect_right, bisect_left\nimport threading\n\ndef main():\n    n = int(input())\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().split()))\n        a, b = a - 1, b - 1\n        adj[a].append(b)\n        adj[b].append(a)\n    init = [int(i) for i in input().split()]\n    goal = [int(i) for i in input().split()]\n    visited = [0] * n\n    par = [[] for i in range(n)]\n    dq = deque()\n    dq.append((0, 0))\n    while len(dq) > 0:\n        (s, p) = dq.pop()\n        if visited[s]: continue\n        visited[s] = 1\n        par[p].append(s)\n        for i in adj[s]:\n            dq.append((i, s))\n    par[0] = par[0][1:]\n    ans = []\n    dq = deque()\n    dq.append((0, 0, 0, 0))\n    while len(dq) > 0:\n        (s, l, fo, fe) = dq.pop()\n        if l % 2 == 0:\n            if fe % 2 == 1:\n                init[s] = 1 - init[s]\n        else:\n            if fo % 2 == 1:\n                init[s] = 1 - init[s]\n        if init[s] != goal[s]:\n            ans.append(s + 1)\n            if l % 2:\n                fo += 1\n            else:\n                fe += 1\n        for j in par[s]:\n            dq.append((j, l + 1, fo, fe))\n\n    print(len(ans))\n    print(\"\\n\".join(map(str, ans)))\n\ndef __starting_point():\n    \"\"\"sys.setrecursionlimit(200000)\n    threading.stack_size(10240000)\"\"\"\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import insort, bisect_right, bisect_left\nimport threading, sys\n\ndef main():\n    n = int(input())\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().split()))\n        a, b = a - 1, b - 1\n        adj[a].append(b)\n        adj[b].append(a)\n    init = [int(i) for i in input().split()]\n    goal = [int(i) for i in input().split()]\n    visited = [0] * n\n    par = [[] for i in range(n)]\n\n    def dfs(s, p):\n        if visited[s]: return\n        visited[s] = 1\n        par[p].append(s)\n        for i in adj[s]:\n            dfs(i, s)\n\n    dfs(0, 0)\n    par[0] = par[0][1:]\n    ans = []\n\n    def dfs2(s, l, fo, fe):\n        if l % 2 == 0:\n            if fe % 2 == 1:\n                init[s] = 1 - init[s]\n        else:\n            if fo % 2 == 1:\n                init[s] = 1 - init[s]\n        if init[s] != goal[s]:\n            ans.append(s + 1)\n            if l % 2:\n                fo += 1\n            else:\n                fe += 1\n        for j in par[s]:\n            dfs2(j, l + 1, fo, fe)\n\n    dfs2(0, 0, 0, 0)\n\n    print(len(ans))\n    print(\"\\n\".join(map(str, ans)))\n\ndef __starting_point():\n    sys.setrecursionlimit(400000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import insort, bisect_right, bisect_left\nimport threading, sys\n\ndef main():\n    n = int(input())\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        a, b = a - 1, b - 1\n        adj[a].append(b)\n        adj[b].append(a)\n    init = [int(i) for i in input().split()]\n    goal = [int(i) for i in input().split()]\n    visited = [0] * n\n    par = [[] for i in range(n)]\n\n    def dfs(s, p):\n        if visited[s]: return\n        visited[s] = 1\n        par[p].append(s)\n        for i in adj[s]:\n            dfs(i, s)\n\n    dfs(0, 0)\n    par[0] = par[0][1:]\n    ans = []\n\n    def dfs2(s, l, fo, fe):\n        if l % 2 == 0:\n            if fe % 2 == 1:\n                init[s] = 1 - init[s]\n        else:\n            if fo % 2 == 1:\n                init[s] = 1 - init[s]\n        if init[s] != goal[s]:\n            ans.append(s + 1)\n            if l % 2:\n                fo += 1\n            else:\n                fe += 1\n        for j in par[s]:\n            dfs2(j, l + 1, fo, fe)\n\n    dfs2(0, 0, 0, 0)\n\n    print(len(ans))\n    print(\"\\n\".join(map(str, ans)))\n\ndef __starting_point():\n    sys.setrecursionlimit(400000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n__starting_point()", "n = int(input())\np = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    p[a].append(b)\n    p[b].append(a)\nu, v = ' ' + input()[:: 2], ' ' + input()[:: 2]\ns, q = [(1, 0, 0, 0)], []\nwhile s:\n    a, k, i, j = s.pop()\n    if k:\n        if i != (u[a] != v[a]):\n            q.append(a)\n            i = 1 - i\n    else:\n        if j != (u[a] != v[a]):\n            q.append(a)\n            j = 1 - j\n    k = 1 - k\n    for b in p[a]:\n        p[b].remove(a)\n        s.append((b, k, i, j))\nprint(len(q))\nprint('\\n'.join(map(str, q)))", "# Made By Mostafa_Khaled \nbot = True \nn = int(input())\n\np = [[] for i in range(n + 1)]\n\nfor i in range(n - 1):\n\n    a, b = list(map(int, input().split()))\n\n    p[a].append(b)\n\n    p[b].append(a)\n\nu, v = ' ' + input()[:: 2], ' ' + input()[:: 2]\n\ns, q = [(1, 0, 0, 0)], []\n\nwhile s:\n\n    a, k, i, j = s.pop()\n\n    if k:\n\n        if i != (u[a] != v[a]):\n\n            q.append(a)\n\n            i = 1 - i\n\n    else:\n\n        if j != (u[a] != v[a]):\n\n            q.append(a)\n\n            j = 1 - j\n\n    k = 1 - k\n\n    for b in p[a]:\n\n        p[b].remove(a)\n\n        s.append((b, k, i, j))\n\nprint(len(q))\n\nprint('\\n'.join(map(str, q)))\n\n# Made By Mostafa_Khaled\n", "from collections import deque\n\nstack = deque()\n\nn = int(input())\nlinks = [tuple(map(lambda x:int(x)-1, input().split())) for i in range(n-1)]\n\nlinked_to = [[] for i in range(n)]\n\nfor x, y in links:\n    linked_to[x].append(y)\n    linked_to[y].append(x)\n\ninit = list(map(lambda x:x==\"1\", input().split()))\ngoal = list(map(lambda x:x==\"1\", input().split()))\n\n#print(init)\n#print(goal)\n\nstack.append(0)\nops = 0\n\nvisited = [False] * n\nparent = [n] * (n+1)\nwas_swapped = [False] * (n+1)\n\nvisited[0] = True\n\ndef xor(x, y):\n    return x != y\n\ndef get_chld(i):\n    for e in linked_to[i]:\n        if e != parent[i]:\n            yield e\n\nwhile len(stack) > 0:\n    c = stack.pop()\n    for l in linked_to[c]:\n        if not visited[l]:\n            visited[l] = True\n            parent[l] = c\n            stack.append(l)\n\nchosen = []\n\nstack.append(0)\n\nwhile len(stack) > 0:\n    c = stack.pop()\n    stack.extend(get_chld(c))\n    was_swapped[c] = was_swapped[parent[parent[c]]]\n    if xor(xor(init[c], goal[c]), was_swapped[c]):\n        was_swapped[c] = not was_swapped[c]\n        ops += 1\n        chosen.append(c+1)\n\nprint(ops, *chosen, sep='\\n')\n\n", "n=int(input())\nL=[[] for i in range(n)]\nfor i in range(n-1) :\n    a,b=list(map(int,input().split()))\n    L[a-1].append(b-1)\n    L[b-1].append(a-1)\nl=list(map(int,input().split()))\nl1=list(map(int,input().split()))\nW=[]\nfor i in range(n) :\n    W.append(abs(l[i]-l1[i]))\nwas=[0 for i in range(n)]\nq=[[0,0,0]]\nans=[]\nwhile q :\n    e=q[0]\n    was[e[0]]=1\n    if e[1]!=W[e[0]] :\n        ans.append(e[0]+1)\n        e[1]=1-e[1]\n    for x in L[e[0]] :\n        \n        if was[x]==0 :\n            q.append([x,e[2],e[1]])\n    del q[0]\nprint(len(ans))\nprint('\\n'.join(map(str,ans)))\n        \n        \n    \n", "'''input\n10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n'''\n\nfrom sys import stdin, setrecursionlimit\nfrom collections import defaultdict\nsetrecursionlimit(1500000)\n\n\ndef counter(num):\n\tif num == 0:\n\t\treturn 1\n\telse:\n\t\treturn 0\n\n\ndef flip_me(original, count, index):\n\tif count % 2 == 0:\n\t\treturn original[index]\n\telse:\n\t\treturn counter(original[index])\n\n\ndef dfs(graph, visited, ans, original, goal, change, node, dfs_stack):\n\tdfs_stack.append(node)\n\twhile len(dfs_stack) > 0:\n\t\tnode = dfs_stack.pop()\n\t\tvisited[node] = True\n\t\t\n\t\tvalue = flip_me(original, change[node], node - 1)\n\t\tadd = 0\n\t\tif goal[node - 1] == value:\n\t\t\tpass\n\t\telse:\n\t\t\tadd = 1\n\t\t\tans[node] = True\n\t\t\t\n\n\t\tflag = 0\n\t\tfor i in  graph[node]:\n\t\t\t\tif visited[i] == False:\n\t\t\t\t\tflag = 1\n\t\t\t\t\tfor j in graph[i]:\n\t\t\t\t\t\tif visited[j] == False:\n\t\t\t\t\t\t\tchange[j] += change[node] + add\n\n\t\t\t\t\tdfs_stack.append(node)\n\t\t\t\t\tdfs_stack.append(i)\n\t\t\t\t\tbreak\n\n\t\tif flag == 0:\n\t\t\tpass\n\ndef calculate(graph, original, goal, n):\n\tvisited = dict()\n\tchange = dict()\n\tfor i in range(1, n + 1):\n\t\tvisited[i] = False\n\t\tchange[i] = 0\n\tans = dict()\n\tdfs_stack = []\n\tdfs(graph, visited, ans, original, goal, change, 1, dfs_stack)\n\treturn ans\n\n# main starts \nn = int(stdin.readline().strip())\ngraph = defaultdict(list)\nfor i in range(1, n + 1):\n\tgraph[i]\n\nfor _ in range(n - 1):\n\tu, v = list(map(int, stdin.readline().split()))\n\tgraph[u].append(v)\n\tgraph[v].append(u)\n\noriginal = list(map(int, stdin.readline().split()))\ngoal = list(map(int, stdin.readline().split()))\ncount = [0]\nans = calculate(graph, original, goal, n)\nprint(len(ans))\nfor i in ans:\n\tprint(i)", "intin=lambda:list(map(int,input().split()))\niin=lambda:int(input())\nAin=lambda:list(map(int,input().split()))\nfrom queue import LifoQueue\nmod=1000000007\n\nn=iin()\nm=n+1\n\nv=[[] for i in range(m)]\np=[0]*m\n\nfor _ in range(n-1):\n    a,b=intin()\n    v[a].append(b)\n    v[b].append(a)\n\nvis=[False]*m\nflipped=[0]*m\nflip=[0]*m\nans=[]\n\ndef dfs(root):\n    q=[root]\n    while len(q)>0:\n        node=q.pop()\n        vis[node]=True\n        flipped[node]=flipped[p[p[node]]]\n        if flipped[node]!=flip[node]:\n            flipped[node]^=1\n            ans.append(node)\n        \n        for i in range(len(v[node])):\n            son=v[node][i]\n            if not vis[son]:\n                q.append(son)\n                p[son]=node\n\na=Ain();b=Ain()\n\nfor i in range(n):\n    flip[i+1]=a[i]^b[i]\n\n\ndfs(1)\n\nprint(len(ans))\nfor i in range(len(ans)):\n    print(ans[i])\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n", "N = int(1e5+3)\nn = int(input())\nadj = list([] for i in range(N))\nfor _ in range(n-1):\n    u, v = list(map(int, input().split()))\n    adj[u].append(v)\n    adj[v].append(u)\na = [0] + list(map(int, input().split()))\nb = [0] + list(map(int, input().split()))\n\ndef dfs(u, p, c_lvl, p_lvl, d):\n    stk = [(u, p, c_lvl, p_lvl)]\n    while stk:\n        (u, p, c_lvl, p_lvl) = stk.pop()\n        if c_lvl != d[u]:\n            c_lvl = 1 - c_lvl\n            res.append(str(u))\n        for v in adj[u]:\n            if v != p:\n                stk += [(v, u, p_lvl, c_lvl)]\n\nd = [i ^ j for (i, j) in zip(a, b)]\nres = []\ndfs(1, 0, 0, 0, d)\nprint(len(res))\nprint('\\n'.join(res))\n", "# Target - Expert on CF\n# Be Humblefool\n\nimport sys\n\n# inf = float(\"inf\")\nsys.setrecursionlimit(10000000)\n\n# abc='abcdefghijklmnopqrstuvwxyz'\n# abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n# mod, MOD = 1000000007, 998244353\n# words = {1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine',10:'ten',11:'eleven',12:'twelve',13:'thirteen',14:'fourteen',15:'quarter',16:'sixteen',17:'seventeen',18:'eighteen',19:'nineteen',20:'twenty',21:'twenty one',22:'twenty two',23:'twenty three',24:'twenty four',25:'twenty five',26:'twenty six',27:'twenty seven',28:'twenty eight',29:'twenty nine',30:'half'}\n# vow=['a','e','i','o','u']\n# dx,dy=[0,1,0,-1],[1,0,-1,0]\n\n# import random\nfrom collections import deque, Counter, OrderedDict,defaultdict\n# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n# from math import ceil,floor,log,sqrt,factorial,pi,gcd\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\n\ndef dfs(current_node, xor, change_zero, change_one):\n    stack = [(current_node,xor,change_zero,change_one)]\n    nonlocal visited,ans,store\n\n    while stack:\n        current_node,xor,change_zero,change_one = stack.pop()\n        visited[current_node-1] = True\n        if xor==0:\n            if change[current_node-1]!=current[current_node-1]:\n                if ~change_zero&1:\n                    change_zero+=1\n                    ans+=1\n                    store.append(current_node)\n            else:\n                if change_zero&1:\n                    change_zero+=1\n                    ans+=1\n                    store.append(current_node)\n        else:\n            if change[current_node-1]!=current[current_node-1]:\n                if ~change_one&1:\n                    change_one+=1\n                    ans+=1\n                    store.append(current_node)\n            else:\n                if change_one&1:\n                    change_one+=1\n                    ans+=1\n                    store.append(current_node)\n        new_xor = xor^1\n        for child in mydict[current_node]:\n            if not visited[child-1]:\n                stack.append((child, new_xor, change_zero, change_one))\n\n\n\n\nn = int(input())\nmydict = defaultdict(list)\nfor i in range(n-1):\n    x,y = get_ints()\n    mydict[x].append(y)\n    mydict[y].append(x)\n\ncurrent = get_array()\nchange = get_array()\n\n# change_zero,change_one = 0,0\nans = 0\ncurrent_node = 1\nstore = []\nvisited = [False]*(n)\ndfs(current_node,1,0,0)\nprint(ans)\nfor i in store:\n    print(i)", "# Target - Expert on CF\n# Be Humblefool\n\nimport sys\n\n# inf = float(\"inf\")\nsys.setrecursionlimit(150000)\n\n# abc='abcdefghijklmnopqrstuvwxyz'\n# abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n# mod, MOD = 1000000007, 998244353\n# words = {1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine',10:'ten',11:'eleven',12:'twelve',13:'thirteen',14:'fourteen',15:'quarter',16:'sixteen',17:'seventeen',18:'eighteen',19:'nineteen',20:'twenty',21:'twenty one',22:'twenty two',23:'twenty three',24:'twenty four',25:'twenty five',26:'twenty six',27:'twenty seven',28:'twenty eight',29:'twenty nine',30:'half'}\n# vow=['a','e','i','o','u']\n# dx,dy=[0,1,0,-1],[1,0,-1,0]\n\n# import random\nfrom collections import deque, Counter, OrderedDict,defaultdict\n# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n# from math import ceil,floor,log,sqrt,factorial,pi,gcd\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\n\ndef dfs(current_node, xor, change_zero, change_one):\n    stack = [(current_node,xor,change_zero,change_one)]\n    nonlocal visited,ans,store\n\n    while stack:\n        current_node,xor,change_zero,change_one = stack.pop()\n        visited[current_node-1] = True\n        if xor==0:\n            if change[current_node-1]!=current[current_node-1]:\n                if ~change_zero&1:\n                    change_zero+=1\n                    ans+=1\n                    store.append(current_node)\n            else:\n                if change_zero&1:\n                    change_zero+=1\n                    ans+=1\n                    store.append(current_node)\n        else:\n            if change[current_node-1]!=current[current_node-1]:\n                if ~change_one&1:\n                    change_one+=1\n                    ans+=1\n                    store.append(current_node)\n            else:\n                if change_one&1:\n                    change_one+=1\n                    ans+=1\n                    store.append(current_node)\n        new_xor = xor^1\n        for child in mydict[current_node]:\n            if not visited[child-1]:\n                stack.append((child, new_xor, change_zero, change_one))\n\n\n\n\nn = int(input())\nmydict = defaultdict(list)\nfor i in range(n-1):\n    x,y = get_ints()\n    mydict[x].append(y)\n    mydict[y].append(x)\n\ncurrent = get_array()\nchange = get_array()\n\n# change_zero,change_one = 0,0\nans = 0\ncurrent_node = 1\nstore = []\nvisited = [False]*(n)\ndfs(current_node,1,0,0)\nprint(ans)\nfor i in store:\n    print(i)", "n = int(input())\np = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    p[a].append(b)\n    p[b].append(a)\nu, v = ' ' + input()[:: 2], ' ' + input()[:: 2]\ns, q = [(1, 0, 0, 0)], []\nwhile s:\n    a, k, i, j = s.pop()\n    if k:\n        if i != (u[a] != v[a]):\n            q.append(a)\n            i = 1 - i\n    else:\n        if j != (u[a] != v[a]):\n            q.append(a)\n            j = 1 - j\n    k = 1 - k\n    for b in p[a]:\n        p[b].remove(a)\n        s.append((b, k, i, j))\nprint(len(q))\nprint('\\n'.join(map(str, q)))"]
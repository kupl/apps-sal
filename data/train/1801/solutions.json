["def interpreter(code, iterations, width, height):\n    code = \"\".join(c for c in code if c in \"[news]*\")\n    canvas = [ [0] * width for _ in range(height) ]\n    row = col = step = count = loop = 0\n    \n    while step < len(code) and count < iterations:\n        command = code[step]\n        \n        if loop:\n            if   command == \"[\": loop += 1\n            elif command == \"]\": loop -= 1\n        \n        elif command == \"n\": row = (row - 1) % height\n        elif command == \"s\": row = (row + 1) % height\n        elif command == \"w\": col = (col - 1) % width\n        elif command == \"e\": col = (col + 1) % width\n        elif command == \"*\": canvas[row][col] ^= 1\n        elif command == \"[\" and canvas[row][col] == 0: loop += 1\n        elif command == \"]\" and canvas[row][col] != 0: loop -= 1\n        \n        step += 1 if not loop else loop // abs(loop)\n        count += 1 if not loop else 0\n    \n    return \"\\r\\n\".join(\"\".join(map(str, row)) for row in canvas)", "def interpreter(code, iterations, width, height):\n    grid = [[0] * width for _ in range(height)]\n    code = [c for c in code if c in '[]nesw*']\n    \n    jumps, stack = {}, []\n    for i, c in enumerate(code):\n        if c == '[': stack.append(i)\n        if c == ']':\n            jumps[i] = stack.pop()\n            jumps[jumps[i]] = i\n\n    ptr, x, y = -1, 0, 0\n    while iterations > 0 and ptr < len(code) - 1:\n        ptr += 1; iterations -= 1; c = code[ptr]\n        if c == 'n': y = (y - 1) % height\n        if c == 's': y = (y + 1) % height\n        if c == 'w': x = (x - 1) % width\n        if c == 'e': x = (x + 1) % width\n        if c == '*': grid[y][x] = 1 - grid[y][x]\n        if c == '[' and not grid[y][x]: ptr = jumps[ptr]\n        if c == ']' and grid[y][x]: ptr = jumps[ptr]\n\n    return '\\r\\n'.join(''.join(map(str, row)) for row in grid)", "from collections import defaultdict\n\ndef interpreter(code, iterations, w, h):\n    \n    cp, r, c, p, stk, brackets, grid = 0, 0, 0, 0, [], {}, [[0] * w for _ in range(h)]\n\n    for i, cc in enumerate(code):\n        if cc == '[': stk.append(i)\n        elif cc is ']':\n            brackets[i] = stk.pop()\n            brackets[brackets[i]] = i\n\n    while p < iterations and cp < len(code):\n        if   code[cp] == '*': grid[r][c] = (0 if grid[r][c] else 1)\n        elif code[cp] == '[' and grid[r][c] == 0: cp = brackets[cp]\n        elif code[cp] == ']' and grid[r][c] == 1: cp = brackets[cp]\n        elif code[cp] == 'n': r = r - 1 if r else h - 1\n        elif code[cp] == 'w': c = c - 1 if c else w - 1\n        elif code[cp] == 's': r = r + 1 if r < h - 1 else 0\n        elif code[cp] == 'e': c = c + 1 if c < w - 1 else 0\n        cp, p = cp + 1, p + 1 if code[cp] in '[]nsew*' else p\n        \n    return '\\r\\n'.join([''.join(str(e) for e in r) for r in grid])", "def interpreter(code, iterations, width, height):\n    inter = Inter(code, width, height)\n    inter.run(iterations)\n    return '\\r\\n'.join(''.join(map(str, e)) for e in inter.grid)\n    \nclass Inter:\n    _instruct = { 'w':'moveW', 'e':'moveE', 'n':'moveN', 's':'moveS', '*':'flip', '[':'jumpP', ']':'jumpB'} \n    _nonC = lambda x:None\n    def __init__(self, code, w, h):\n        self.grid = [[0]*w for e in range(h)]\n        self.com  = code\n        self.w, self.h  = w, h\n        self.x, self.y  = 0, 0\n        self.i, self.it = 0, 0\n        \n    def countIteration(f):\n        def wrap(cls):\n            cls.it += 1\n            return f(cls)\n        return wrap\n    \n    def run(self, iterat):\n        while self.it < iterat and self.i < len(self.com):#\n            getattr(self, self._instruct.get(self.com[self.i],'_nonC'))()\n            self.i += 1\n        \n    @countIteration\n    def moveE(self):\n        self.x = (self.x + 1)%self.w\n    \n    @countIteration\n    def moveW(self):\n        self.x = (self.x - 1)%self.w\n        \n    @countIteration\n    def moveN(self):\n        self.y = (self.y - 1)%self.h\n        \n    @countIteration\n    def moveS(self):\n        self.y = (self.y + 1)%self.h\n    \n    @countIteration\n    def flip(self):\n        self.grid[self.y][self.x] = int(not(self.grid[self.y][self.x]))\n    \n    @countIteration\n    def jumpP(self):\n        if self.grid[self.y][self.x] == 0:\n            self._jump(1,  ']', '[')\n    \n    @countIteration\n    def jumpB(self):\n        if self.grid[self.y][self.x] == 1:\n            self._jump(-1, '[', ']')\n        \n    def _jump(self, way, need, past, nest = 0):\n        while way:\n            self.i += way\n            if self.com[self.i] == need and not nest: break\n            if self.com[self.i] == need and nest: nest -= 1\n            if self.com[self.i] == past: nest += 1", "def pairs(code):\n    opening = []\n    matching = {}\n\n    for i, c in enumerate(code):\n        if c == \"[\":\n            opening.append(i)\n        elif c == \"]\":\n            j = opening.pop()\n            matching[i] = j\n            matching[j] = i\n    assert not opening\n    return matching\n\n\ndef interpreter(code, iterations, width, height):\n    matching = pairs(code)\n\n    x = 0\n    y = 0\n    canvas = [[0 for _ in range(width)] for _ in range(height)]\n\n    index = 0\n    iterations_done = 0\n\n    while iterations_done < iterations:\n        try:\n            c = code[index]\n        except IndexError:\n            break\n        iterations_done += 1\n        if c == \"n\":\n            y -= 1\n            y %= height\n            index += 1\n        elif c == \"s\":\n            y += 1\n            y %= height\n            index += 1\n        elif c == \"w\":\n            x -= 1\n            x %= width\n            index += 1\n        elif c == \"e\":\n            x += 1\n            x %= width\n            index += 1\n        elif c == \"*\":\n            canvas[y][x] ^= 1\n            index += 1\n        elif c == \"[\":\n            if canvas[y][x] == 0:\n                index = matching[index]\n            index += 1\n        elif c == \"]\":\n            if canvas[y][x] != 0:\n                index = matching[index]\n            index += 1\n        else:\n            iterations_done -= 1\n            index += 1\n\n    return \"\\r\\n\".join(\"\".join(map(str, row)) for row in canvas)", "def interpreter(code, iterations, width, height):\n    inter = Inter(code, width, height)\n    inter.run(iterations)\n    return '\\r\\n'.join(''.join(e) for e in inter.grid)\n    \nclass Inter:\n    _instruct = { 'w':'moveW', 'e':'moveE', 'n':'moveN', 's':'moveS', '*':'flip', '[':'jumpP', ']':'jumpB'} \n    _nonC = lambda x:None\n    def __init__(self, code, w, h):\n        self.com = code\n        self.grid = [['0']*w for e in range(h)]\n        self.x, self.y  = 0, 0\n        self.w, self.h  = w, h\n        self.i, self.it = 0, 0\n        \n    def countIteration(f):\n        def wrap(cls):\n            cls.it += 1\n            return f(cls)\n        return wrap\n    \n    def run(self, iterat):\n        while self.it < iterat and self.i < len(self.com):#\n            getattr(self, self._instruct.get(self.com[self.i],'_nonC'))()\n            self.i += 1\n        \n    @countIteration\n    def moveE(self):\n        self.x = (self.x + 1)%self.w\n    \n    @countIteration\n    def moveW(self):\n        self.x = (self.x - 1)%self.w\n        \n    @countIteration\n    def moveN(self):\n        self.y = (self.y - 1)%self.h\n        \n    @countIteration\n    def moveS(self):\n        self.y = (self.y + 1)%self.h\n    \n    @countIteration\n    def flip(self):\n        self.grid[self.y][self.x] = '10'[int(self.grid[self.y][self.x])]\n    \n    @countIteration\n    def jumpP(self):\n        if self.grid[self.y][self.x] == '0':\n            self._jump(1,  ']', '[')\n    \n    @countIteration\n    def jumpB(self):\n        if self.grid[self.y][self.x] == '1':\n            self._jump(-1, '[', ']')\n        \n    def _jump(self, way, need, past, nest = 0):\n        while way:\n            self.i += way\n            if self.com[self.i] == need and not nest: break\n            if self.com[self.i] == need and nest: nest -= 1\n            if self.com[self.i] == past: nest += 1\n", "def build_jump_table(code):\n    jumps = {}\n    stack = []\n    for i, c in enumerate(code):\n        if c == '[':\n            stack.append(i)\n        elif c == ']':\n            j = stack.pop()\n            jumps[i] = j\n            jumps[j] = i\n    return jumps\n\nclass Interpreter:\n    def __init__(self, code, width, height):\n        self.code = code\n        self.jumps = build_jump_table(code)\n        self.cells = [[0] * width for _ in range(height)]\n        self.width = width\n        self.height = height\n        self.r = 0\n        self.c = 0\n        \n    @property\n    def value(self):\n        return self.cells[self.r][self.c]\n\n    @value.setter\n    def value(self, val):\n        self.cells[self.r][self.c] = val\n        \n    def run(self, iterations):\n        pc = 0\n        while pc < len(self.code) and iterations > 0:\n            op = self.code[pc]\n            if op == '*': self.value = 1 - self.value\n            elif op == 'n': self.r = (self.r - 1) % self.height\n            elif op == 's': self.r = (self.r + 1) % self.height\n            elif op == 'w': self.c = (self.c - 1) % self.width\n            elif op == 'e': self.c = (self.c + 1) % self.width\n            elif op == '[' and self.value == 0: pc = self.jumps[pc]\n            elif op == ']' and self.value == 1: pc = self.jumps[pc]\n            pc += 1\n            iterations -= op in '*nswe[]'\n        return '\\r\\n'.join(''.join(map(str, row)) for row in self.cells)\n    \ndef interpreter(code, iterations, width, height):\n    ip = Interpreter(code, width, height)\n    return ip.run(iterations)", "class Memory:\n    def __init__(self, width, height):\n        self.__x = 0\n        self.__y = 0\n        self.width = width\n        self.height = height\n        self.mem = [[0] * width for _ in range(height)]\n\n    def flip(self):\n        self.mem[self.y][self.x] = (self.get() + 1) % 2\n\n    def get(self):\n        return self.mem[self.y][self.x]\n\n    def to_string(self):\n        return '\\r\\n'.join(''.join(map(str, row)) for row in self.mem)\n\n    @property\n    def x(self):\n        return self.__x\n\n    @x.setter\n    def x(self, val):\n        self.__x = val % self.width\n\n    @property\n    def y(self):\n        return self.__y\n\n    @y.setter\n    def y(self, val):\n        self.__y = val % self.height\n\n\ndef interpreter(code, iterations, width, height):\n    op_ptr = 0\n    mem = Memory(width, height)\n    jumps = {}\n    bracket = []\n\n    for i, op in enumerate(code):\n        if op == '[':\n            bracket.append(i)\n        elif op == ']':\n            jumps[bracket[-1]] = i\n            jumps[i] = bracket.pop()\n\n    while iterations and op_ptr < len(code):\n        op = code[op_ptr]\n        if op in 'nesw*[]':\n            iterations -= 1\n\n        if op == 'n':\n            mem.y -= 1\n        elif op == 'e':\n            mem.x += 1\n        elif op == 's':\n            mem.y += 1\n        elif op == 'w':\n            mem.x -= 1\n        elif op == '*':\n            mem.flip()\n        elif op == '[' and mem.get() == 0:\n            op_ptr = jumps[op_ptr]\n        elif op == ']' and mem.get() != 0:\n            op_ptr = jumps[op_ptr]\n\n        op_ptr += 1\n\n    return mem.to_string()", "def interpreter(code, iterations, width, height):\n    grid = [[0 for r in range(width)] for c in range(height)]\n    t = iterations\n    w, h = width, height\n    stack, bracket_pos = [], {}\n    for i, c in enumerate(code):\n        if c == \"[\": \n            stack.append(i)\n        elif c == \"]\": \n            bracket_pos[i] = stack[-1]\n            bracket_pos[stack.pop()] = i\n\n    a, b, p = 0, 0, 0    \n    while t > 0 and p < len(code):\n        if code[p] == \"e\": b += 1\n        elif code[p] == \"w\": b -= 1\n        elif code[p] == \"s\": a += 1\n        elif code[p] == \"n\": a -= 1\n        elif code[p] == \"*\": grid[a%h][b%w] ^= 1\n        \n        elif code[p] == \"[\":\n            if grid[a%h][b%w] == 0:\n                p = bracket_pos[p]\n        elif code[p] == \"]\":\n            if grid[a%h][b%w] == 1: \n                p = bracket_pos[p]\n        else: t += 1\n        t -= 1\n        p += 1\n    return \"\\r\\n\".join(\"\".join(map(str, g)) for g in grid)", "def interpreter(code, iterations, width, height):\n    matrix = [[0 for i in range(width)] for i in range(height)]\n    i = 0 # code position\n    iteration = 0\n    p = [0, 0] # data pointer\n    s = [] # stack (used for loops)\n    mate = {} # Paired [ / ] (used for loops)\n\n    for k in range(len(code)):\n        c = code[k]\n        if c == '[':\n            s.append(k)\n        if c == ']':\n            m = s.pop()\n            mate[m] = k\n            mate[k] = m\n\n    while iteration < iterations and i < len(code):\n        c = code[i]\n        if c == '*':\n            matrix[p[1]][p[0]] ^= 1\n        elif c == 'n':\n            p[1] = (p[1] - 1) % height\n        elif c == 'e':\n            p[0] = (p[0] + 1) % width\n        elif c == 's':\n            p[1] = (p[1] + 1) % height\n        elif c == 'w':\n            p[0] = (p[0] - 1) % width\n        elif c == '[':\n            if not matrix[p[1]][p[0]]:\n                i = mate[i]\n        elif c == ']':\n            if matrix[p[1]][p[0]]:\n                i = mate[i]\n        else:\n            iteration -= 1 # Ignore iteration on unknown command\n        i += 1\n        iteration += 1\n\n    return '\\r\\n'.join([''.join([str(matrix[y][x]) for x in range(width)]) for y in range(height)])"]
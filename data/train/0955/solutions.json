["isPrime=[1 for i in range(10001)]\ncnt=[0 for i in range(10001)]\nisPrime[0]=0\nisPrime[1]=0\nprime=[]\nfor i in range(2,10001):\n if isPrime[i]:\n  prime.append(i)\n  for j in range(i*i,10001,i):\n   isPrime[j]=0\n#print(prime)\nfor i in prime:\n for j in prime:\n  if (i + 2*j)>10000:\n   break\n  else:\n   cnt[i + 2*j]+=1\n#print(le)\nfor _ in range(int(input())):\n n=int(input())\n print(cnt[n])", "sieve = [False] + [True]*10000\ns = []\nfor x in range(2,10001):\n if(sieve[x]):\n  s.append(x)\n  for i in range(2*x,10001,x):\n   sieve[i] = False\ncnt = [0]*(10001)\nn = 10000\nfor x in s:\n for y in s:\n  if(x + 2*y)>n:\n   break\n  cnt[x + 2*y]+=1\nfor _ in range(int(input())):\n n = int(input())\n print(cnt[n])", "import math\nMAX = 10001\nPRIME=[]\nA=[1 for i in range(MAX)]\nA[0] = 0\nA[1] = 0\nB=[0 for i in range(MAX)]\n\nfor i in range(2,int(math.sqrt(MAX))+1):\n if A[i] is 1:\n  for j in range(i*i,MAX,i):\n   A[j] = 0\nfor i in range(MAX):\n if A[i] is 1:\n  PRIME.append(i)\n\nfor p in PRIME:\n for q in PRIME:\n  if p+(2*q)>=MAX:\n   break\n  B[p+(2*q)]+=1\n\nfor _ in range(int(input())):\n n=int(input())\n print(B[n])\n\n  \n  \n", "from sys import stdout\nfrom bisect import *\ndef fun(n,f):\n ct=1\n while n%f==0:\n  ct+=1\n  n//=f\n return ct\nN=1000009\nl=[0]*N\na=[0]*N\nb=[1]*N\nfor i in range(N):\n l[i]=i\nfor i in range(2,N):\n if l[i]>0:\n  a[i]+=1\n  b[i]+=1\n  j=i+i\n  while j<N:\n   l[j]=0\n   a[j]+=1\n   b[j]*=fun(j,i)\n   j+=i\narr=[]\nfor i in range(2,10000):\n if l[i]>0:\n  arr.append(i)\nlis=[0]*(10001)\nfor i in arr:\n for j in arr:\n  if i+2*j<=10000:\n   lis[i+2*j]+=1\nfor i in range(int(input())):\n print(lis[int(input())])", "import math\nmaxn = 10**4 + 1\nx = [a for a in range(2,maxn)]\nfor y in x:\n for j in range(2,math.ceil(maxn/y)):\n  if y*j in x:\n   x.remove(y*j)\nval = [0]*(3*(10**4))\nfor i in range(len(x)):\n for j in range(len(x)):\n  val[(x[i]+2*x[j])]+=1\nt=int(input())\nfor i in range(t):\n n=int(input())\n print(val[n])", "def sieve(n):\n #Create list of numbers from 0 to n\n #True denotes prime, false not prime \n l=[True for i in range(n+1)]\n #Start with 2\n p=2\n while(p*p<n):\n  #and cross off all it's multiples \n  if l[p]: \n   for i in range(p*p, n+1, p): \n    l[i] = False\n  #increment p to next value \n  p+=1\n #adding all prime numbers to a list and returning it \n primes=[]\n for i in range(2,n):\n  if l[i]:\n   primes.append(i)\n return primes\n\nsums=[0]*(10001)\np=sieve(10001)\n\n#calculating all possible sums as per question and storing the count of each\nfor i in p:\n for j in p:\n  if i+(2*j) <= 10000:\n   sums[i+(2*j)]+=1\n\n#input number of test cases\nt=int(input())\nwhile t:\n n=int(input())\n #input number and check if it is in the pre-built list\n print(sums[n])\n t-=1", "import math\nMAX = 10**4\n#sieve of eratosthenes\n#for finding all primes till 10000\nprimes = [1 for i in range(MAX)]\nfor i in range(2,int(math.sqrt(MAX))+1):\n if primes[i]==1:\n  for j in range(i*i,MAX,i):\n   primes[j] = 0\n\n#calculating number of pairs for all possible inputs\nn_pairs = [0 for i in range(MAX + 1)]\nPRIMES = [x for x in range(2,len(primes)) if primes[x]==1]\nfor i in PRIMES:\n for j in PRIMES:\n  if i + 2*j <= MAX:\n   n_pairs[i + 2*j] += 1\n  \nfor _ in range(int(input())):\n print(n_pairs[int(input())])", "def Prob1(n) :\n pr=[True for i in range(n+1)]\n p=2\n while(p*p <n) :\n  if (pr[p] == True): \n   for i in range(p * 2, n+1, p): \n    pr[i] = False\n  p += 1\n prime=[]\n for i in range(2,n) :\n  if pr[i] :\n   prime.append(i)\n return prime\nprr=Prob1(10001)\npair=[0]*(10001)\nfor i in prr :\n for j in prr :\n  if(i+(2*j))<=10000 :\n   pair[i+(2*j)]+=1\nT=int(input())\nfor _ in range (T) :\n N=int(input())\n print(pair[N])\n", "def sieve(n):\n '''\n    Sieve of eratosthenes\n    Returns primesd: dictionary of primes upto n\n      primesl: list of primes upto n\n    '''\n l = [True]*(n+1)\n l[0] = False\n l[1] = False\n for i in range(2, n+1):\n  j = i*i\n  while j < n+1:\n   l[j]=False\n   j+=i\n primesd={}\n primesl = []\n for i in range(2, n+1):\n  if l[i]:\n   primesd[i]=True\n   primesl.append(i)\n return primesd, primesl\n\nprimesd, primesl = sieve(10000)\npc = [0]*10001 # pc:- pair count\n\n# pre-computing the counts for fast retreival\nfor e in primesl:\n for f in primesl:\n  temp = e+2*f\n  if temp > 10000:\n   break\n  pc[temp]+=1\n\nt =int(input())\n\nfor __ in range(t):\n n = int(input())\n print(pc[n])\n", "# calculate primes\ndef calcPrimes(tot):\n fin = []\n primes = [1]*(tot+1)\n start = 2\n\n while start < tot+1:\n  fin.append(start)\n  \n  # mark all factors of the given number      \n  for i in range(2*start,tot+1,start):\n   primes[i] = 0\n\n  start +=1\n  # check next unmarked number\n  while start < len(primes) and primes[start] == 0:\n   start += 1\n return fin\n\nprimes = calcPrimes((10**4)+5)\ncount = [0]*((10**4)+5)\n\n# mark possibility for each pair\nfor i in primes:\n for j in primes:\n  if (i+(2*j)) < len(count):\n   count[(i+(2*j))] += 1\n\nn = int(input())\nfor _ in range(n):\n print(count[int(input())])\n", "def calcPrimes(tot):\n fin = []\n primes = [1]*(tot+1)\n start = 2\n\n while start < tot+1:\n  fin.append(start)\n  \n  for i in range(2*start,tot+1,start):\n   primes[i] = 0\n\n  start +=1\n  while start < len(primes) and primes[start] == 0:\n   start += 1\n\n return fin\n\ndef solve(tot,primes,primeSet):\n pairs = 0\n for i in primes:\n  if (tot-i)%2==0 and (tot-i)//2 in primeSet:\n   pairs += 1\n  if (tot - (2*i)) in primeSet:\n   pairs += 1\n print(pairs//2)\n\n\nprimes = calcPrimes((10**4)+5)\ncount = [0]*((10**4)+5)\nfor i in primes:\n for j in primes:\n  if (i+(2*j)) < len(count):\n   count[(i+(2*j))] += 1\n\nn = int(input())\nfor _ in range(n):\n print(count[int(input())])\n", "def SieveOfEratosthenes(n):\n prime = [True for i in range(n+1)]\n p = 2\n while (p * p <= n):\n  if (prime[p] == True):\n   for i in range(p * p, n+1, p):\n    prime[i] = False\n  p += 1\n pr = []\n for i in range(2,10**4 + 1):\n  if prime[i]:\n   pr.append(i)\n  pcount[i] = 0\n for i in pr:\n  for j in pr:\n   try:\n    pcount[i + 2 * j] += 1\n   except:\n    continue\n\npcount = [0]*10001\nSieveOfEratosthenes(10**4 + 1)\nfor _ in range(int(input())):\n print(pcount[int(input())])", "N = 10005\n\nmarker = [0]*N\nPRIMES = []\nlevy = [0]*N\n\n# PRECAL PRIMES\nmarker[0] = marker[1] = 1 # marked non primes\nfor i in range(2, int(N**0.5)):\n for j in range(i*i,N,i):\n  marker[j] = 1\n\nfor i in range(N):\n if not marker[i]:\n  PRIMES.append(i)\n\n# PRECAL LEVY\nn_primes = len(PRIMES)\n\nfor i in range(n_primes):\n a = PRIMES[i]\n for j in range(n_primes):\n  b = PRIMES[j]\n  if a + 2*b < N:\n   levy[a + 2*b] += 1\n\n# MAIN\n\nt = int(input())\n\nfor _ in range(t):\n n = int(input())\n print(levy[n])\n", "from collections import defaultdict\nn=10002\nprime=[1]*n\nprime[0]=0\nprime[1]=0\nprimelist=[]\npairs=defaultdict(list)\nfor i in range(2,n):\n if prime[i]==1:\n  primelist.append(i)\n  for j in range(i*i,n,i):\n   prime[j]=0\nd=defaultdict(int)\nfor p in primelist:\n  for q in primelist:\n   d[p+2*q]+=1\n   pairs[p+2*q].append((p,q))\nt=int(input())\nwhile t:\n t-=1\n num=int(input())\n print(d[num])\n #print(pairs[num])\n"]
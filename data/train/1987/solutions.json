["import heapq\n class Solution(object):\n     def pourWater(self, heights, V, K):\n         \"\"\"\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         \"\"\"\n \n         heap = []\n         heapq.heappush(heap, (heights[K], -1, 0))\n         l, r = K - 1, K + 1\n         lh, rh = [], []\n \n         for i in range(V):\n             while l >= 0 and heights[l] <= heights[l + 1]:\n                 heapq.heappush(lh, (heights[l], -l))\n                 l -= 1\n \n             while r < len(heights) and heights[r] <= heights[r - 1]:\n                 heapq.heappush(rh, (heights[r], r))\n                 r += 1\n \n             if lh and lh[0][0] < heights[K]:\n                 h, i = heapq.heappop(lh)\n                 heights[-i] += 1\n                 heapq.heappush(lh, (h + 1, i))\n                 continue\n \n             if rh and rh[0][0] < heights[K]:\n                 h, i = heapq.heappop(rh)\n                 heights[i] += 1\n                 heapq.heappush(rh, (h + 1, i))\n                 continue\n \n             heights[K] += 1\n \n         return heights\n", "class Solution:\n     def pourWater(self, heights, V, K):\n         \"\"\"\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         \"\"\"\n         \n         for i in range(V):\n             if not self.fallLeft(K, heights):\n                 if not self.fallRight(K, heights):\n                     heights[K] += 1\n         \n         return heights\n     \n     def fallLeft(self,K, heights):\n         minBlock = K\n         for i in range(K-1, -1, -1):\n             if heights[i] < heights[minBlock]:\n                 minBlock = i\n             elif heights[i] > heights[minBlock]:\n                 break\n         if minBlock == K:\n             return False\n         heights[minBlock] += 1\n         return True\n         \n     \n     def fallRight(self,K, heights):\n         minBlock = K\n         for i in range(K+1, len(heights)):\n             if heights[i] < heights[minBlock]:\n                 minBlock = i\n             elif heights[i] > heights[minBlock]:\n                 break\n         if minBlock == K:\n             return False\n         heights[minBlock] += 1\n         return True", "class Solution:\n     def pourWater(self, heights, total, index):\n         \"\"\"\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         \"\"\"\n         \n         if not heights or total <= 0 or index < 0 or index >= len(heights):\n             return heights\n         \n         for _ in range(total):\n             left = -1\n             for i in range(index-1, -1, -1):\n                 if heights[i] > heights[i+1]:\n                     break\n                     \n                 if heights[i] < heights[i+1]:\n                     left = i\n             \n             if left != -1:\n                 heights[left] += 1\n                 continue\n                 \n             right = -1\n             for j in range(index+1, len(heights)):\n                 if heights[j] > heights[j-1]:\n                     break\n                     \n                 if heights[j] < heights[j-1]:\n                     right = j\n                     \n             if right != -1:\n                 heights[right] += 1\n                 continue\n                 \n             heights[index] += 1\n             \n         return heights\n                     \n", "from queue import PriorityQueue\n class Solution(object):\n     def pourWater(self, heights, V, K):\n         \"\"\"\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         \"\"\"\n         i = 0\n         while i < V:\n             l_i = K-1\n             at = K\n             while l_i>=0 and heights[l_i] <= heights[at]:\n                 if heights[l_i] < heights[at]:\n                     at = l_i\n                 l_i-=1\n             if at != K:\n                 heights[at] +=1\n                 i+=1\n                 continue\n             r_i = K+1\n             while r_i < len(heights) and heights[r_i] <= heights[at]:\n                 if heights[r_i] < heights[at]:\n                     at = r_i\n                 r_i+=1\n             if at != K:\n                 heights[at] +=1\n                 i+=1\n                 continue\n             heights[K] += 1\n             i+=1\n         return heights\n             \n             \n                 \n             ", "class Solution:\n     def pourWater(self, heights, V, K):\n         \"\"\"\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         \"\"\"\n         \n         for i in range(V):\n             if not self.fallLeft(K, heights):\n                 if not self.fallRight(K, heights):\n                     heights[K] += 1\n         \n         return heights\n     \n     def fallLeft(self,K, heights):\n         minBlock = K\n         for i in range(K-1, -1, -1):\n             if heights[i] < heights[minBlock]:\n                 minBlock = i\n             elif heights[i] > heights[minBlock]:\n                 break\n         if minBlock == K:\n             return False\n         heights[minBlock] += 1\n         return True\n         \n     \n     def fallRight(self,K, heights):\n         minBlock = K\n         for i in range(K+1, len(heights)):\n             if heights[i] < heights[minBlock]:\n                 minBlock = i\n             elif heights[i] > heights[minBlock]:\n                 break\n         if minBlock == K:\n             return False\n         heights[minBlock] += 1\n         return True"]
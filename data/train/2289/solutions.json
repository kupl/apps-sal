["A = [ord(a)-97 for a in input()]\nN = len(A)\nX = [0] * 26\nY = [0] * (N + 2)\nNE = [0] * N\nR = [N] * 26\ns = 0\nt = 1\nfor i in range(N)[::-1]:\n    a = A[i]\n    if X[a] == 0:\n        X[a] = 1\n        s += 1\n        if s == 26:\n            s = 0\n            X = [0] * 26\n            t += 1\n    Y[i] = t\n    NE[i] = R[a]\n    R[a] = i\n\nANS = []\nii = 0\nfor i, a in enumerate(A):\n    if i == ii:\n        for j in range(26):\n            if Y[R[j]+1] < Y[i]:\n                ANS.append(j)\n                ii = R[j]+1\n                break\n    R[a] = NE[i]\n\nprint(\"\".join([chr(a+97) for a in ANS]))", "from collections import *\n\ndef solve():\n    s = input()\n    n = len(s)\n    nxt = [[float(\"inf\")] * (n + 10) for _ in range(26)]\n    for i in range(n - 1, -1, -1):\n        for j in range(26):\n            nxt[j][i] = nxt[j][i + 1]\n        nxt[ord(s[i]) - ord('a')][i] = i \n    deq = deque()\n    used = [False] * (n + 5)\n    for i in range(26):\n        if nxt[i][0] == float(\"inf\"):\n            print((chr(ord('a') + i)))\n            return \n        deq.append((i, str(chr(ord('a') + i)), nxt[i][0]))\n        used[nxt[i][0]]  = True \n    while True:\n        siz = len(deq)\n        for _ in range(siz):\n            i, pre, pos = deq.popleft()\n            for j in range(26):\n                np = nxt[j][pos + 1]\n                if np == float(\"inf\"):\n                    print((pre + str(chr(ord('a') + j))))\n                    return \n                if not used[np]:\n                    used[np] = True \n                    deq.append((j, pre + str(chr(ord('a') + j)), np))\n\nsolve()\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    a = S()\n    l = len(a)\n    t = {}\n    for c in string.ascii_lowercase:\n        t[c] = l\n    b = [(1,0,0) for _ in range(l)]\n    b.append((1,'a',l))\n    b.append((0,'',l+1))\n\n    for c,i in reversed(list(zip(a,list(range(l))))):\n        t[c] = i\n        b[i] = min([(b[t[d]+1][0] + 1,d,t[d]+1) for d in string.ascii_lowercase])\n\n    r = ''\n    i = 0\n    while i < l:\n        r += b[i][1]\n        i = b[i][2]\n    return r\n\nprint((main()))\n\n\n\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nS = input()\nN = len(S)\n\n# nxt[i][c] := i\u6587\u5b57\u76ee\u4ee5\u964d\u3067\u6700\u521d\u306b\u6587\u5b57c\u304c\u767b\u5834\u3059\u308bindex(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306fN)\nnxt = list2d(N+1, 26, N)\nfor i in range(N-1, -1, -1):\n    for c in range(26):\n        nxt[i][c] = nxt[i+1][c]\n    c = ord(S[i]) - 97\n    nxt[i][c] = i\n\n# dp[i] := i\u6587\u5b57\u76ee\u4ee5\u964d\u306b\u3064\u3044\u3066\u300c\u90e8\u5206\u6587\u5b57\u5217\u3068\u306a\u3089\u306a\u3044\u300d\u6700\u77ed\u306e\u6587\u5b57\u5217\u9577\ndp = [INF] * (N+1)\n# rest[i][(c, j)] := \u4f4d\u7f6ei\u304b\u3089\u898b\u3066\u3001\u6700\u5c0f\u9054\u6210\u306b\u7528\u3044\u305f\u6587\u5b57c\u3068\u3001\u6b21\u306b\u4f7f\u3046\u6587\u5b57\u306eindexj\nrest = [None] * (N+1)\ndp[N] = 1\n# \u5e38\u306b\u81ea\u5206\u3088\u308a\u5f8c\u308d\u3067\u306e\u6700\u5c0f\u304c\u5fc5\u8981\u306b\u306a\u308b\u306e\u3067\u3001\u5f8c\u308d\u304b\u3089\u57cb\u3081\u3066\u3044\u304f\nfor i in range(N-1, -1, -1):\n    # i\u304b\u3089\u898b\u3066\u5148\u982d\u3068\u3057\u3066\u4f7f\u3046\u6587\u5b57\u309226\u901a\u308a\u5168\u90e8\u8a66\u3059\n    # abc\u3092\u6607\u9806\u3067\u56de\u3057\u3066\u3001\u6700\u5c0f\u66f4\u65b0\u6761\u4ef6\u3092\u7b49\u53f7\u306a\u3057\u306b\u3059\u308b\u3053\u3068\u3067\u3001\u8f9e\u66f8\u9806\u3067\u5c0f\u3055\u3044\u65b9\u3092\u512a\u5148\u3067\u304d\u308b\n    for c in range(26):\n        # \u6b21\u306e\u6587\u5b57\u304c\u306a\u3044\u6642\n        if nxt[i][c] == N:\n            if dp[i] > 1:\n                dp[i] = 1\n                rest[i] = (c, N)\n        # \u6b21\u306e\u6587\u5b57\u304c\u3042\u308b\u6642\n        else:\n            # i\u4ee5\u964d\u306b\u6587\u5b57c\u304c\u51fa\u73fe\u3059\u308bindex+1\u306e\u4f4d\u7f6e\u3067\u306e\u6700\u77ed\u6587\u5b57\u5217\u9577 + 1\n            # \u4f8b\u3048\u3070a\u306b\u3064\u3044\u3066\u306a\u3089\u3001a****\u3068\u306a\u308b\u306e\u3067\u3001****\u3067\u306e\u6700\u5c0f\u3068a\u306e\u5206\u3067+1\n            if dp[i] > dp[nxt[i][c]+1] + 1:\n                dp[i] = dp[nxt[i][c]+1] + 1\n                rest[i] = (c, nxt[i][c]+1)\n\n# \u5fa9\u5143\ni = 0\nans = []\nwhile i < N:\n    c, idx = rest[i]\n    ans.append(chr(c+97))\n    i = idx\nprint((''.join(ans)))\n", "from collections import defaultdict\ninf = 10**10\nA = list(map(lambda x:ord(x)-ord('a'), list(input())))\nN = len(A)\nabc = 'abcdefghijklmbopqrstuvwxyz'\ns_to_i = [[N]*26 for _ in range(N+1)]\nfor i in range(N)[::-1]:\n    for x in range(26):\n        s_to_i[i][x] = s_to_i[i+1][x]\n    s_to_i[i][A[i]] = i\ndp = [0]*(N+2)\ndp[-2] = 1\nfor i in range(N)[::-1]:\n    now = max(s_to_i[i])+1\n    dp[i] = dp[now]+1\nn = dp[0]\nnow = 0\nans = []\nfor i in range(n):\n    for x in range(26):\n        tmp = s_to_i[now][x]+1\n        if dp[tmp] <= n-i-1:\n            ans.append(chr(x+ord('a')))\n            now = tmp\n            break\nprint(*ans, sep = '')\n\n\n\n    \n        \n\n\n\n", "import bisect\nA = input()\nn = len(A)\nch = [[] for _ in range(26)]\nidx = []\nused = set()\nfor i in range(n-1, -1, -1):\n  a = A[i]\n  ch[ord(a)-ord(\"a\")].append(i)\n  used.add(a)\n  if len(used) == 26:\n    idx.append(i)\n    used = set()\nk = len(idx)\nidx = idx[::-1]\nfor j in range(26):\n  ch[j] = ch[j][::-1]\nans = \"\"\nnow = -1\nfor i in range(k):\n  for j in range(26):\n    nxt = ch[j][bisect.bisect_right(ch[j], now)]\n    if nxt >= idx[i]:\n      now = nxt\n      ans += chr(j+ord(\"a\"))\n      break\nfor j in range(26):\n  l = bisect.bisect_right(ch[j], now)\n  if l == len(ch[j]):\n    ans += chr(j+ord(\"a\"))\n    break\nprint(ans)", "from bisect import bisect\ns = input()\nx,y,k,p = [1]*26,[len(s)],1,[[1] for i in range(26)]\nfor i in range(len(s)-1,-1,-1):\n\tn = ord(s[i])-97\n\tx[n] = 0\n\tp[n].append(-i)\n\tif sum(x)==0:\n\t\tk,x = k+1,[1]*26\n\t\ty.append(i)\ny,num,ans = y[::-1],0,\"\"\nfor i in range(k):\n\tfor j in range(97,123):\n\t\tif chr(j) not in s[num:y[i]]: break\n\tans+=chr(j)\n\tb = bisect(p[j-97],-y[i])-1\n\tnum = -p[j-97][b]+1\nprint(ans)", "S = input()\nN = len(S)\ninf = 10**18\n\nnxt = [[N+1] * 26 for _ in range(N + 2)]\nfor i in reversed(range(N)):\n    for j in range(26):\n        nxt[i][j] = nxt[i + 1][j]\n    nxt[i][ord(S[i]) - ord(\"a\")] = i\n\ndp = [inf] * (N + 1)\ndp[N] = 1\nmemo = [N] * (N + 1)\nfor i in reversed(range(N)):\n    for c, j in enumerate(nxt[i]):\n        if j > N:\n            if dp[i] > 1:\n                dp[i] = 1\n                memo[i] = c\n        elif dp[i] > dp[j + 1] + 1:\n            dp[i] = dp[j + 1] + 1\n            memo[i] = c\n\nres = []\ni = 0\nwhile i <= N:\n    res.append(chr(memo[i] + ord(\"a\")))\n    i = nxt[i][memo[i]] + 1\nprint(\"\".join(res))", "import sys\ninput = sys.stdin.readline\n\nS = [ord(s) - ord('a') for s in input().rstrip()]\n\nINF = 10 ** 9\nN = len(S)\ndp = [None] * (N+1)\n# \u305d\u3053\u304b\u3089\u59cb\u3081\u305f\u3068\u304d\u3001\u6b21\u306bx\u304c\u73fe\u308c\u308b\u4f4d\u7f6e\u3001\u304a\u3088\u3073\u3001\u6b21\u306bx\u3092\u3068\u3063\u305f\u5834\u5408\u306b\u9577\u3055L\u306e\u3082\u306e\u304c\u5168\u3066\u4f5c\u308c\u308b\ndp[N] = [[INF] * 26, [0] * 26, 0]\n\nfor n in range(N-1,-1,-1):\n    prev = dp[n+1]\n    cur = [prev[0].copy(), prev[1].copy(), prev[2]]\n    s = S[n]\n    cur[0][s] = n\n    cur[1][s] = prev[2] // 26 + 1\n    cur[2] = prev[2] + cur[1][s] - prev[1][s]\n    dp[n] = cur\n\nanswer = []\ni = 0\nwhile i < N:\n    # \u8f9e\u66f8\u9806\u3067\u3001\u4f5c\u308c\u308b\u9577\u3055\u304c\u4e00\u756a\u77ed\u3044\u6587\u5b57\n    L = dp[i][2] // 26\n    for x in range(26):\n        if dp[i][1][x] == L:\n            break\n    answer.append(chr(ord('a') + x))\n    # \u305d\u306e\u6587\u5b57\u306e\u5834\u6240\u306b\u79fb\u52d5\n    i = dp[i][0][x]\n    i += 1\n\nprint(''.join(answer))", "from bisect import bisect_right, bisect_left\nA = [ord(t) - ord(\"a\") for t in input()]\nn = len(A)\nalf = [[] for i in range(26)]\nfor i, a in enumerate(A):\n    alf[a].append(i)\nfor i in range(26):\n    alf[i].append(n+1)\n\nfirst = [n]\nappeard = [0] * 26\ncnt = 0\nfor i in range(n - 1, -1, -1):\n    a = A[i]\n    if 1 - appeard[a]:\n        appeard[a] = 1\n        cnt += 1\n    if cnt == 26:\n        first.append(i)\n        cnt = 0\n        appeard = [0] * 26\n\ndef ntoa(x):\n    return chr(ord(\"a\") + x)\n\nfirst.reverse()\nans = \"\"\n\nfor i in range(26):\n    if 1 - appeard[i]:\n        ans += ntoa(i)\n        if alf[i]:\n            last = alf[i][0]\n        break\nif len(first) == 1:\n    print(ans)\n    return\n\nfor j in range(len(first) - 1):\n    for i in range(26):\n        nxt = alf[i][bisect_right(alf[i], last)]\n        if nxt >= first[j+1]:\n            ans += ntoa(i)\n            last = nxt\n            break\nprint(ans)\n", "def next_position(S):\n    \"\"\"\n    \u9589\u533a\u9593 (i,N-1] \u306e\u4e2d\u306e\u6700\u3082\u5de6\u7aef\u306b\u3042\u308b\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8s\u306eindex\n    \"\"\"\n    N=len(S)\n    next_pos=[[N+1]*26 for _ in range(N+1)]\n    for i in range(N-1,-1,-1):\n        for s in range(26):\n            next_pos[i][s]=next_pos[i+1][s]\n        next_pos[i][ord(S[i])-ord(\"a\")]=i+1\n    return next_pos\n\nS=input().rstrip()\nN=len(S)\nnext_pos=next_position(S)\ndp=[1<<32]*(N+2)\ndp[-1]=0\nrecover=[0]*(N+1)\nfor i in range(N,-1,-1):\n    for s in range(25,-1,-1):\n        if dp[next_pos[i][s]]+1<=dp[i]:\n            dp[i]=dp[next_pos[i][s]]+1\n            recover[i]=(next_pos[i][s],s)\n\nres=[]\ni=0\nwhile i<N:\n    i,s=recover[i]\n    res.append(chr(s+ord(\"a\")))\nprint(\"\".join(res))", "abc=\"abcdefghijklmnopqrstuvwxyz\"\n\nA=str(input())\nn=len(A)\n#make matrix (a-z)*(n characters)\n#\u6b21\u306bchr\u304c\u51fa\u3066\u304f\u308bindex\nword_pos=[]\nct=[n]*26\norda=ord(\"a\")\n\nfor i in range(n-1,-1,-1):\n    ct[ord(A[i])-orda]=i\n    word_pos.append(ct.copy())\n\nword_pos.reverse()\n\ndp=[0]*n+[1,0]\nj=n\nsep=[]\n#\u533a\u5207\u308c\u3081\u3092\u30de\u30fc\u30af\nfor i in range(n-1,-1,-1):\n    ct=word_pos[i]\n    if(max(ct)<j):\n        #remove last chunk\n        sep.append(i)\n        j=min(ct)\n        \nif(j==n):\n    for i in abc:\n        if(i not in A):\n            print(i+\"\\n\")\n            break\n\nelse:\n    sep.reverse()\n    ans=\"\"\n    for i in abc:\n        if(i not in A[:sep[0]]):\n            ans+=i\n            break\n\n    for i in range(0,len(sep)):\n        start=sep[i]\n        try:\n            end=sep[i+1]\n        except:\n            end=n\n        #ans[-1]\u304c\u51fa\u73fe\u3059\u308b\u30bf\u30a4\u30df\u30f3\u30b0\n        next=word_pos[start][ord(ans[-1])-orda]\n        for i in range(0,26):\n            if(word_pos[next+1][i]>end-1):\n                ans+=chr(orda+i)\n                break\n    ans+=\"\\n\"\n    print(ans)", "# import sys\nfrom sys import stdout\n# from copy import copy, deepcopy\n# from functools import lru_cache\n# from string import ascii_lowercase\n# from math import inf\n# inf = float('inf')\n\n\ndef main():\n    ans = solve_case()\n    stdout.write(\"{}\\n\".format(ans))\n\ndef solve_case():\n    S = read_str()\n\n    len_s = len(S)\n    int_s = [ord(c) - ord('a') for c in S]\n\n    # next_char_pos[from_idx][letter_idx] := the position of the next letter `letter_idx` from `from_idx`\n    next_char_pos = make_list((len_s + 1, 26), len_s)\n    for from_idx in reversed(list(range(len_s))):\n        for letter_idx in range(26):\n            if int_s[from_idx] == letter_idx:\n                pos = from_idx\n            else:\n                pos = next_char_pos[from_idx+1][letter_idx]\n            next_char_pos[from_idx][letter_idx] = pos\n\n    # non_subseq_len[from_idx] := the length of the shortest \"non subsequence\" in S[from_idx:]\n    non_subseq_len = make_list([len_s + 2], len_s + 1)\n    non_subseq_len[len_s] = 1\n    non_subseq_len[len_s + 1] = 0\n    ans_next_pos = make_list([len_s + 1], len_s)\n    ans_letter = make_list([len_s + 1], -1)\n    for from_idx in reversed(list(range(len_s))):\n        for letter_idx in range(26):\n            new_len = non_subseq_len[next_char_pos[from_idx][letter_idx] + 1] + 1\n            if non_subseq_len[from_idx] > new_len:\n                non_subseq_len[from_idx] = new_len\n                ans_letter[from_idx] = letter_idx\n                ans_next_pos[from_idx] = next_char_pos[from_idx][letter_idx] + 1\n\n    ans = ''\n    idx = 0\n    while idx < len(S):\n        ans += chr(ord('a') + ans_letter[idx])\n        idx = ans_next_pos[idx]\n    return ans\n\n#################################\n\ndef read_str(): return input()\ndef read_int(): return int(input())\ndef read_str_list(): return input().split(' ')\ndef read_int_list(): return list(map(int, input().split(' ')))\ndef read_lines(n, read_func): return [read_func() for _ in range(n)]\ndef list_to_str(l, sep=' '): return sep.join(map(str, l))\nl2s = list_to_str\n# shape: tuple of ints | list of ints\ndef make_list(shape, value=None):\n    if len(shape) == 1:\n        return [value] * shape[0]\n    return [make_list(shape[1:], value) for _ in range(shape[0])]\n\ndef __starting_point():\n    # sys.setrecursionlimit(1000000)\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\ndef main():\n    A = input()\n\n    n = len(A)\n\n    next_i = []\n    ct = [n] * 26\n    orda = ord(\"a\")\n    for i in range(n - 1, -1, -1):\n        ct[ord(A[i]) - orda] = i\n        next_i.append(ct.copy())\n\n    next_i.reverse()\n\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    j = -1\n    for i in range(n - 1, -1, -1):\n        ct = next_i[i]\n        if max(ct) < n:\n            j = i\n            break\n        else:\n            dp[i] = 1\n\n    if j == -1:\n        ct = next_i[0]\n        for c in range(26):\n            if ct[c] == n:\n                print((chr(orda + c)))\n                return\n\n    rt = [0] * n\n    for i in range(j, -1, -1):\n        ct = next_i[i]\n        min_c = 0\n        min_v = dp[ct[0] + 1]\n        for c in range(1, 26):\n            v = dp[ct[c] + 1]\n            if v < min_v:\n                min_c = c\n                min_v = v\n        rt[i] = min_c\n        dp[i] = min_v + 1\n\n\n    r = ''\n    i = 0\n    while i < n:\n        if dp[i] == 1:\n            for c in range(26):\n                if not chr(orda + c) in A[i:]:\n                    r += chr(orda + c)\n                    break\n            break\n        r += chr(orda + rt[i])\n        i = next_i[i][rt[i]] + 1\n\n\n    print(r)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import sys\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nMOD = 10**9 + 7 # 998244353\ninput = lambda:sys.stdin.readline().rstrip()\ndef resolve():\n    S = list(map(lambda c : ord(c) - ord('a'), input()))\n    n = len(S)\n    sigma = 26\n\n    # next[i][c] : i \u6587\u5b57\u76ee\u4ee5\u964d\u3067 c \u304c\u73fe\u308c\u308b\u6700\u5c0f\u306e index\n    next = [[-1] * sigma for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for c in range(sigma):\n            next[i][c] = i if S[i] == c else next[i + 1][c]\n\n    # dp[i] : S[i:] \u306b\u5bfe\u3059\u308b\u7b54\u3048\u306e\u9577\u3055\n    dp = [INF] * (n + 1)\n    dp[n] = 1\n    # character[i] : S[i:] \u306b\u5bfe\u3059\u308b\u7b54\u3048\u306b\u5bfe\u3057\u3066\u63a1\u7528\u3059\u308b\u5148\u982d\u306e\u6587\u5b57\n    character = [None] * (n + 1)\n    character[n] = 0\n    for i in range(n - 1, -1, -1):\n        for c in range(sigma):\n            length = 1 if next[i][c] == -1 else 1 + dp[next[i][c] + 1]\n            if dp[i] > length:\n                dp[i] = length\n                character[i] = c\n\n    # \u7d4c\u8def\u5fa9\u5143\n    res = []\n    now = 0\n    while 1:\n        res.append(character[now])\n        now = next[now][character[now]] + 1\n        if now == 0:\n            break\n    res = ''.join(map(lambda x : chr(x + ord('a')), res))\n    print(res)\nresolve()", "# import sys\nfrom sys import stdout\n# from copy import copy, deepcopy\n# from functools import lru_cache\n# from string import ascii_lowercase\n# from math import inf\n# inf = float('inf')\n\n\ndef main():\n    ans = solve_case()\n    stdout.write(\"{}\\n\".format(ans))\n\ndef solve_case():\n    S = read_str()\n\n    len_s = len(S)\n    int_s = [ord(c) - ord('a') for c in S]\n\n    # next_char_pos[from_idx][letter_idx] := the position of the next letter `letter_idx` from `from_idx`\n    next_char_pos = make_list((len_s + 1, 26), len_s)\n    for from_idx in reversed(list(range(len_s))):\n        for letter_idx in range(26):\n            if int_s[from_idx] == letter_idx:\n                pos = from_idx\n            else:\n                pos = next_char_pos[from_idx+1][letter_idx]\n            next_char_pos[from_idx][letter_idx] = pos\n\n    # non_subseq_len[from_idx] := the length of the shortest \"non subsequence\" in S[from_idx:]\n    non_subseq_len = make_list([len_s + 2], len_s + 1)\n    non_subseq_len[len_s] = 1\n    non_subseq_len[len_s + 1] = 0\n    ans_next_pos = make_list([len_s + 1], len_s)\n    ans_letter = make_list([len_s + 1], -1)\n    for from_idx in reversed(list(range(len_s))):\n        for letter_idx in range(26):\n            new_len = non_subseq_len[next_char_pos[from_idx][letter_idx] + 1] + 1\n            if non_subseq_len[from_idx] > new_len:\n                non_subseq_len[from_idx] = new_len\n                ans_letter[from_idx] = letter_idx\n                ans_next_pos[from_idx] = next_char_pos[from_idx][letter_idx] + 1\n\n    ans = ''\n    idx = 0\n    while idx < len(S):\n        ans += chr(ord('a') + ans_letter[idx])\n        idx = ans_next_pos[idx]\n    return ans\n\n#################################\n\ndef read_str(): return input()\ndef read_int(): return int(input())\ndef read_str_list(): return input().split(' ')\ndef read_int_list(): return list(map(int, input().split(' ')))\ndef read_lines(n, read_func): return [read_func() for _ in range(n)]\ndef list_to_str(l, sep=' '): return sep.join(map(str, l))\nl2s = list_to_str\n# shape: tuple of ints | list of ints\ndef make_list(shape, value=None):\n    if len(shape) == 1:\n        return [value] * shape[0]\n    return [make_list(shape[1:], value) for _ in range(shape[0])]\n\ndef __starting_point():\n    # sys.setrecursionlimit(1000000)\n    main()\n\n__starting_point()", "A = input()\n\nimport string\np = {}\nfor x in string.ascii_lowercase: p[x] = len(A)\ntb = [(0, 0, 0)] * len(A)\ntb.append((1, 0, 0))\ntb.append((0, 0, 0))\n\nfor i, x in reversed(list(enumerate(A))):\n    p[x] = i\n    tb[i] = min([(tb[p[c]+1][0] + 1, c, p[c]+1) for c in string.ascii_lowercase])\n\ni = 0\nans = []\nwhile i < len(A):\n    ans.append(tb[i][1])\n    i = tb[i][2]\n\nprint((\"\".join(ans)))\n", "from collections import deque\n\nAs = input()\n\nAs = [ord(A) - ord('a') for A in As]\nlenA = len(As)\nposChars = [lenA] * 26\nposNexts = [[] for _ in range(lenA + 1)]\nfor i in reversed(list(range(lenA))):\n    posNexts[i + 1] = posChars.copy()\n    posChars[As[i]] = i\nposNexts[0] = posChars.copy()\n\nprevs = [None] * lenA\nQ = deque()\nQ.append((0, -1))\nwhile Q:\n    lenAns, pos = Q.popleft()\n    for ch in range(26):\n        posNext = posNexts[pos + 1][ch]\n        if posNext == lenA:\n            ans = [chr(ord('a') + ch)]\n            while pos != -1:\n                ans.append(chr(ord('a') + As[pos]))\n                pos = prevs[pos]\n            print((''.join(reversed(ans))))\n            return\n        if prevs[posNext] is None:\n            prevs[posNext] = pos\n            Q.append((lenAns + 1, posNext)) \n", "S = input()\nN = len(S)\ninf = 10**18\n\nnxt = [[N+1] * 26 for _ in range(N + 2)]\nfor i in reversed(range(N)):\n    for j in range(26):\n        nxt[i][j] = nxt[i + 1][j]\n    nxt[i][ord(S[i]) - ord(\"a\")] = i\n\ndp = [inf] * (N + 1)\ndp[N] = 1\nmemo = [N] * (N + 1)\nfor i in reversed(range(N)):\n    for c, j in enumerate(nxt[i]):\n        if j > N:\n            if dp[i] > 1:\n                dp[i] = 1\n                memo[i] = c\n        elif dp[i] > dp[j + 1] + 1:\n            dp[i] = dp[j + 1] + 1\n            memo[i] = c\n\nres = []\ni = 0\nwhile i <= N:\n    res.append(chr(memo[i] + ord(\"a\")))\n    i = nxt[i][memo[i]] + 1\nprint(\"\".join(res))", "import string\n\ndef __starting_point():\n    A = input()\n\n    p = {}\n    for x in string.ascii_lowercase:\n        p[x] = len(A)\n    # print(p)\n    '''\n    tb\n    1\u3064\u76ee\uff1a\n    2\u3064\u76ee\uff1a\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\n    3\u3064\u76ee\uff1a\n    '''\n    tb = [(0, 0, 0)] * len(A)\n    tb.append((1, 0, 0))\n    tb.append((0, 0, 0))\n    # print(tb)\n    for i, x in reversed(list(enumerate(A))):\n        p[x] = i\n        tb[i] = min([(tb[p[c] + 1][0] + 1, c, p[c] + 1) for c in string.ascii_lowercase])\n        # print(tb)\n    i = 0\n    ans = []\n    while i < len(A):\n        ans.append(tb[i][1])\n        i = tb[i][2]\n\n    print((\"\".join(ans)))\n\n__starting_point()", "import sys\nfrom bisect import bisect_left as bl\ninput = sys.stdin.readline\nS = list(map(lambda x: ord(x) - ord(\"a\"), list(input())[: -1]))\ntable = [[] for _ in range(26)]\nfor i in range(len(S)):\n  x = S[i]\n  table[x].append(i + 1)\nfor c in range(26): table[c].append(len(S) + 1)\ndp = [len(S)] * (len(S) + 2)\ndp[-1] = 0\nrev = [0] * (len(S) + 1)\nrevc = [0] * (len(S) + 1)\nfor i in range(len(S) - 1, -1, -1):\n  for x in range(26):\n    j = table[x][bl(table[x], i + 1)]\n    if dp[i] > dp[j] + 1:\n      dp[i] = dp[j] + 1\n      rev[i] = j\n      revc[i] = x\n      #print(i, x, j, table[x])\nx = 0\nres = []\nwhile x < len(S):\n  c = revc[x]\n  res.append(chr(c + ord(\"a\")))\n  if x == len(S): break\n  x = rev[x]\nprint(\"\".join(res))", "A = '.' + input()\n\nsmallalphas = list(map(chr, list(range(ord(\"a\"), ord(\"z\") + 1))))\n\nanswers = {c: 0 for c in smallalphas}\nlast_ch = 'a'\nhistory = []\nfor a in reversed(A):\n    ch = 'a'\n    for c in smallalphas:\n        if answers[ch] > answers[c]:\n            ch = c\n    answers[a] = answers[ch] + 1\n    history.append(ch)\n\nhistory.reverse()\n\n# print(history)\n\nans = [history[0]]\nfor i, a in enumerate(A):\n    if ans[-1] == a:\n        ans.append(history[i])\n\nprint((''.join(ans)))\n# minlen = min(map(len, answers))\n# ans = min(filter(lambda ans: len(ans) == minlen, answers))\n# print(ans)\n", "from string import ascii_lowercase\nfrom bisect import bisect\n\n\ndef solve(s):\n    pos = [[] for _ in range(26)]\n    offset = ord('a')\n    for i, c in enumerate(s):\n        c = ord(c) - offset\n        pos[c].append(i)\n    for l in pos:\n        l.append(len(s))\n\n    all_char_sequence_start_pos = []\n    pos_i = [len(l) - 1 for l in pos]\n    while all(pi >= 0 for pi in pos_i):\n        i = min(l[pi] for pi, l in zip(pos_i, pos))\n        all_char_sequence_start_pos.append(i)\n        for j in range(26):\n            while pos_i[j] >= 0 and pos[j][pos_i[j]] >= i:\n                pos_i[j] -= 1\n    all_char_sequence_start_pos.reverse()\n    ans = []\n    curr = -1\n    for i in all_char_sequence_start_pos:\n        for c in range(26):\n            cj = bisect(pos[c], curr)\n            j = pos[c][cj]\n            if j >= i:\n                ans.append(c)\n                curr = j\n                break\n    return ''.join(chr(c + offset) for c in ans)\n\n\nprint((solve(input().strip())))\n", "a = list([ord(x)-ord(\"a\") for x in list(input())])\nn = len(a)\nm = 26\n\nb = [0]*n\npos = [[] for i in range(m)]\ns = set()\ncnt = 0\nfor i in reversed(list(range(n))):\n    b[i] = cnt\n    if a[i] not in s:\n        s.add(a[i])\n    pos[a[i]].append(i)\n    if len(s) == m:\n        cnt += 1\n        s = set()\n\nfor i in range(m):\n    pos[i].sort()\n\nk = cnt+1\n\nfrom bisect import bisect_right\n\nans = []\ncur = -1\nfor i in range(k):\n    for j in range(m):\n        pj = bisect_right(pos[j], cur)\n        if pj == len(pos[j]):\n            ans.append(j)\n            break\n        to = pos[j][pj]\n        if b[to] != k-i-1:\n            cur = to\n            ans.append(j)\n            break\n\nans = \"\".join(chr(ord(\"a\")+i) for i in ans)\nprint(ans)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    a = list(input())[:-1]\n    #print(a)\n    n = len(a)\n\n    d = dict()\n    for i in range(26):\n        d[chr(i+97)] = chr(i+97)\n    \n\n    for i in range(n-1,-1,-1):\n        min_key = 'zz'\n        min_len = 10**9\n        for e in d:\n            if (min_len == len(d[e]) and min_key > e) or (min_len > len(d[e])):\n                min_key = e\n                min_len = len(d[e])\n        d[a[i]] = a[i]+d[min_key]\n\n    res_len = len(d['a'])\n    res_key = 'a'\n    for e in d:\n        if (res_len == len(d[e]) and res_key > e) or (res_len > len(d[e])):\n            res_key = e\n            res_len = len(d[e])\n    print(d[res_key])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\na = list(input().rstrip())\nn = len(a)\nx = [[0] * 26 for _ in range(n + 1)]\nfor i in range(n):\n    j = ord(a[i]) - 97\n    x[i][j] = i + 1\nfor i in range(n - 1, -1, -1):\n    for j in range(26):\n        if x[i][j] == 0:\n            x[i][j] = x[i + 1][j]\nminlen = [0] * (n + 1)\nminalph = [0] * (n + 1)\nfor i in range(n - 1, -1, -1):\n    l = 114514\n    for j in range(26):\n        if x[i][j] == 0:\n            l, m = 0, j\n            break\n        if l > minlen[x[i][j]] + 1:\n            l, m = minlen[x[i][j]] + 1, j\n    minlen[i] = l\n    minalph[i] = m\nans = []\ni = 0\nfor _ in range(minlen[0] + 1):\n    ans.append(chr(minalph[i] + 97))\n    i = x[i][minalph[i]]\nans = \"\".join(ans)\nprint(ans)", "A=input()\nN=len(A)\nalphabet=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\nalp_to_n={}\nfor i,l in enumerate(alphabet):\n  alp_to_n[l]=i\n  \nD=[True]*26\nL=[N]\ns=0\nfor i in range(N)[::-1]:\n  if D[alp_to_n[A[i]]]:\n    D[alp_to_n[A[i]]]=False\n    s+=1\n  if s==26:\n    D=[True]*26\n    L.append(i)\n    s=0\nL.reverse()\nans=[]\nD=[True]*26\nfor i in range(0,L[0]):\n    D[alp_to_n[A[i]]]=False\n    \nfor i in range(len(L)-1):\n  num,pos=26,0\n  for j in range(L[i],L[i+1]):\n    if alp_to_n[A[j]]<num and D[alp_to_n[A[j]]]:\n      num=alp_to_n[A[j]]\n      pos=j\n  ans.append(alphabet[num])\n  D=[True]*26\n  for j in range(pos+1,L[i+1]):\n    D[alp_to_n[A[j]]]=False\nfor i in range(26):\n  if D[i]:\n    ans.append(alphabet[i])\n    break\nprint((\"\".join(ans)))\n  \n      \n  \n", "from collections import defaultdict\ninf = 10**10\nA = list(map(lambda x:ord(x)-ord('a'), list(input())))\nN = len(A)\nabc = 'abcdefghijklmbopqrstuvwxyz'\ns_to_i = [[N]*26 for _ in range(N+1)]\nfor i in range(N)[::-1]:\n    for x in range(26):\n        s_to_i[i][x] = s_to_i[i+1][x]\n    s_to_i[i][A[i]] = i\ndp = [0]*(N+2)\ndp[-2] = 1\nfor i in range(N)[::-1]:\n    now = max(s_to_i[i])+1\n    dp[i] = dp[now]+1\nn = dp[0]\nnow = 0\nans = []\nfor i in range(n):\n    for x in range(26):\n        tmp = s_to_i[now][x]+1\n        if dp[tmp] <= n-i-1:\n            ans.append(chr(x+ord('a')))\n            now = tmp\n            break\nprint(*ans, sep = '')\n\n\n\n    \n        \n\n\n\n", "import sys\ninput = sys.stdin.readline\n\nA = input().rstrip()\ndp = [chr(c) for c in range(ord('a'), ord('z')+1)]\nfor c in A[::-1]:\n    s = min(dp, key=lambda x: len(x))\n    dp[ord(c) - ord('a')] = c + s\nprint(min(dp, key=lambda x: len(x)))", "S = input()\nN = len(S)\nINF = N+1\nnex = [[INF]*26 for _ in range(N+1)]\nfor i,c in enumerate(S[::-1]):\n    ic = ord(c) - ord('a')\n    for j in range(26):\n        nex[N-i-1][j] = N-i-1 if j==ic else nex[N-i][j]\n\ndp = [N] * (N+3)\ndp[INF] = dp[INF+1] = 0\nfor i in range(N,-1,-1):\n    tmp = INF\n    for j in range(26):\n        tmp = min(tmp, dp[nex[i][j]+1]+1)\n        if tmp == 1: break\n    dp[i] = tmp\n\nans = []\ni = 0\nfor v in range(dp[0]-1,-1,-1):\n    for j in range(26):\n        if dp[nex[i][j]+1] != v: continue\n        ans.append(chr(j + ord('a')))\n        i = nex[i][j]+1\n        break\n\nprint(''.join(ans))", "from copy import copy\nfrom collections import deque\nimport sys\nA = input()\nN = len(A)\nM = 26\n\ndef alp(c):\n  return chr(ord(\"a\")+c)\ndef num(s):\n  return ord(s)-ord(\"a\")\n  \n\nINF = 10**6\ntmp = [INF for _ in range(M)]\nNxt = [None for _ in range(N+1)]\nNxt[N] = copy(tmp)\nfor i in range(N-1,-1,-1):\n  tmp[num(A[i])] = i+1\n  Nxt[i] = copy(tmp)\n#print(*Nxt, sep = \"\\n\")  \ntask = deque([(0, \"\")])\nvisited = {0}\n  \nwhile task:\n  i, s = task.popleft()\n  for c, j in enumerate(Nxt[i]):\n    if j == INF:\n      print(\"\".join([s,alp(c)]))\n      return\n    if j not in visited:\n      task.append((j, \"\".join([s,alp(c)])))\n      visited.add(j)\n    \nprint(\"error\")", "alp = [chr(i) for i in range(97, 97+26)]\n\nimport sys\ninput = sys.stdin.readline\n\nS = input().rstrip()\nN = len(S)\n\ndp = [[N]*26 for _ in range(N+1)]\n\nBest = [-1]*(N+1)\n\nfor i in reversed(range(N)):\n    s = S[i]\n    b = 10**14\n    for k in range(26):\n        if Best[dp[i+1][k]] < b:\n            b = Best[dp[i+1][k]]\n        if s == alp[k]:\n            dp[i][k] = i\n        else:\n            dp[i][k] = dp[i+1][k]\n    Best[i] = b+1\n\nb = 10**14\nfor k in range(26):\n    if Best[dp[0][k]] < b:\n        b = Best[dp[0][k]]\nL = b+1\n\nans = \"\"\nind = -1\nfor _ in range(L+1):\n    best = Best[max(dp[ind+1])]\n    for k in range(26):\n        if Best[dp[ind+1][k]] == best:\n            ans += alp[k]\n            if ind != N:\n                ind = dp[ind+1][k]\n            break\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    inf = 10 ** 7\n    s = input()\n    n = len(s)\n    s += \"\".join(chr(i + 97) for i in range(26))\n    # print(s)\n    # \u6b21\u3092\u305d\u306e\u6587\u5b57\u306b\u3057\u305f\u6642\u306e\u300c\u9577\u3055\u3001\u4f4d\u7f6e\u300d\n    size = [0] * 26\n    pos = [n + i for i in range(26)]\n    # \u89e3\u7b54\u5fa9\u5143\u306e\u305f\u3081\u306e\u79fb\u52d5\u5148\n    nxt = [-1] * n\n    # \u5f8c\u308d\u306e\u6587\u5b57\u304b\u3089\u9806\u306b\u898b\u308b\n    for i in range(n - 1, -1, -1):\n        min_size = inf\n        min_pos = -1\n        # \u6b21\u3092\u3069\u306e\u6587\u5b57\u306b\u3059\u308c\u3070\u77ed\u304f\u306a\u308b\u304b\u8abf\u3079\u308b\n        # \u540c\u3058\u9577\u3055\u306e\u6642\u306f\u8f9e\u66f8\u9806\u512a\u5148\n        for sz, p in zip(size, pos):\n            if sz < min_size:\n                min_size = sz\n                min_pos = p\n        code = ord(s[i]) - 97\n        size[code] = min_size + 1\n        pos[code] = i\n        nxt[i] = min_pos\n        # print(size)\n        # print(pos)\n        # print(nxt)\n        # print()\n    # \u6700\u77ed\u306b\u306a\u308b\u6700\u521d\u306e\u6587\u5b57\u3092\u8abf\u3079\u3066\u3001nxt\u306e\u9806\u306b\u305f\u3069\u308b\n    min_size = inf\n    min_pos = -1\n    for sz, p in zip(size, pos):\n        if sz < min_size:\n            min_size = sz\n            min_pos = p\n    i = min_pos\n    ans = s[i]\n    while i < n:\n        i = nxt[i]\n        ans += s[i]\n    print(ans)\n\nmain()\n", "from collections import deque\nalpha = \"abcdefghijklmnopqrstuvwxyz\"\nA = input()\nn = len(A)\nB = ord('a')\n\nlinks = [None]*(n+3)\n\nlink = [n]*26\nfor i in range(n-1, -1, -1):\n    links[i] = link[:]\n    link[ord(A[i]) - B] = i\nlinks[-1] = link\n\ndeq = deque()\ndeq.append(-1)\nprev = {-1: (None, 0)}\nwhile deq:\n    v = deq.popleft()\n    if v == n:\n        break\n    link = links[v]\n    for c in range(26):\n        if link[c] in prev:\n            continue\n        prev[link[c]] = (v, c)\n        deq.append(link[c])\nv = n\nans = []\nwhile v is not None:\n    v, c = prev[v]\n    ans.append(chr(c+B))\nans.reverse()\nprint((\"\".join(ans[1:])))\n\n", "from bisect import bisect_left\n\nCHARACTERs = 'abcdefghijklmnopqrstuvwxyz'\n\nAs = input()\nlenA = len(As)\n\nposChars = dict([(ch, [lenA]) for ch in CHARACTERs])\ndp = [0] * lenA + [1, 0]\nfor i in reversed(list(range(lenA))):\n    posChars[As[i]].append(i)\n    dp[i] = min([dp[posChars[ch][-1] + 1] for ch in CHARACTERs]) + 1\n\nfor ch in CHARACTERs:\n    posChars[ch] = posChars[ch][::-1]\n\nans = []\ni = 0\nfor k in reversed(list(range(dp[0]))):\n    for ch in CHARACTERs:\n        pos = posChars[ch][bisect_left(posChars[ch], i)]\n        if dp[pos + 1] == k:\n            ans.append(ch)\n            i = pos + 1\n            break\n\nprint((''.join(ans)))\n", "a = list(map(lambda x: ord(x)-ord(\"a\"), list(input())))\nn = len(a)\nm = 26\n\nb = [1]*(n+1)\nprev = [n]*m\nG = [[] for i in range(n+1)]\nfor i in reversed(range(n)):\n    ai = a[i]\n    tmp = min(b[j] for j in prev)\n    for j in prev:\n        G[i].append(j)\n    b[i] = tmp+1\n    prev[ai] = i\n\ncnt = min(b[j] for j in prev)\nedge = prev\nans = []\nfor _ in range(cnt):\n    for i, to in enumerate(edge):\n        if b[to] == cnt-_:\n            ans.append(chr(ord(\"a\")+i))\n            edge = G[to]\n            break\nprint(\"\".join(ans))", "def main():\n    import sys\n    input=sys.stdin.readline\n    s=input()\n    alpha=\"abcdefghijklmnopqrstuvwxyz\"\n    l=len(s)\n    alpha2={j:i for i,j in enumerate(alpha)}\n    memo=[[0]*26 for _ in range(l,-1,-1)]\n    for i in range(26):\n        memo[l][i]=l+1\n    for i in range(l-1,-1,-1):\n        for x,y in alpha2.items():\n            if s[i]==x:\n                memo[i][y]=i+1\n            else:\n                memo[i][y]=memo[i+1][y]\n    \n    search=[1]*(l+2)\n    search[l+1]=0\n    for i in range(l-1,-1,-1):\n        m=max([memo[i][j] for j in range(26)])\n        if m!=l+1:\n            search[i]=search[m]+1\n    \n    n,seq=0,0\n    ans_len=search[0]\n    ans=\"\"\n    temp=0\n    for i in range(ans_len):\n        for j in range(26):\n            n=memo[temp][j]\n            seq=search[n]+i\n            if seq+1==ans_len:\n                ans+=alpha[j]\n                temp=memo[temp][j]\n                break\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n#n, = map(int,readline().split())\ns = input()\n\ndef next_index(N,s):\n    D = [-1]*26\n    E = [None]*(N+1)\n    cA = ord('a')\n    for i in range(N-1, -1, -1):\n        E[i+1] = D[:]\n        D[ord(s[i])-cA] = i\n    E[0] = D\n    return E\n\nn = len(s)\nnxt = next_index(n,s)\n\n\"\"\"\nfor i in nxt:\n    print(i[:4])\n\"\"\"\n\n#print(nxt)\ndp = [0]*(n+1)\nfor i in range(n-1,-1,-1):\n    idx = max(nxt[i])\n    bad = min(nxt[i])\n    dp[i] = dp[idx+1]+1 if bad != -1 else 0\n\n#print(nxt[0])\n#print(dp)\n\nk = dp[0]+1\nans = [None]*k\n\nv = 0\nfor i in range(k):\n    #print(v)\n    if v==n:\n        ans[-1] = 0\n        break\n\n    for j in range(26):\n        #print(nxt[v+1][j], dp[nxt[v+1][j]])\n        if nxt[v][j]==-1 or dp[nxt[v][j] + 1] < dp[v]:\n            ans[i] = j\n            v = nxt[v][j]+1\n            break\n\n#print(ans)\ndef f(x):\n    return chr(x+ord(\"a\"))\n\na = \"\".join(map(f,ans))\nprint(a)\n\n\n\n\"\"\"\nx = [chr(ord(\"z\")-i) for i in range(26)]\nx = \"\".join(x)\nprint(x)\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n", "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nS = sys.stdin.readline().rstrip()\nA = [ord(c) - ord('a') for c in S]\nN = len(S)\n\n# \u7b54\u3048\u306e\u6587\u5b57\u5217\u306e\u9577\u3055\nl = 0\n# \u305d\u306e\u6587\u5b57\u4ee5\u964d\u3067\u3001\u4f55\u6587\u5b57\u307e\u3067\u306e\u4efb\u610f\u6587\u5b57\u5217\u3092\u4f5c\u308c\u308b\u304b\nlengths = [0] * N\ncounts = [0] * 26\nfor i, a in reversed(list(enumerate(A))):\n    counts[a] += 1\n    lengths[i] = l\n    if min(counts) == 1:\n        counts = [0] * 26\n        l += 1\nans_size = l + 1\n\n# \u6587\u5b57\u3054\u3068\u306e\u6b21\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\ngraph = [[-1] * 26 for _ in range(N)]\npos = [-1] * 26\nfor i, a in reversed(list(enumerate(A))):\n    graph[i] = pos[:]\n    pos[a] = i\ninitials = pos\n\n\ndef solve(size, i=None):\n    # i \u756a\u76ee\u304b\u3089\u59cb\u307e\u308a\u3001\u9577\u3055 size \u3067\u3042\u308b\u3001\u90e8\u5206\u5217\u3067\u306a\u3044\u6587\u5b57\u5217\n    if i is None:\n        pos = initials\n    else:\n        pos = graph[i]\n\n    if size == 1:\n        return chr(pos.index(-1) + ord('a'))\n\n    size -= 1\n    for ci, i in enumerate(pos):\n        if lengths[i] < size:\n            c = chr(ci + ord('a'))\n            return c + solve(size, i)\n    assert False\n\n\nprint((solve(ans_size)))\n", "def main():\n    import sys\n    input=sys.stdin.readline\n    s=input()\n    alpha=\"abcdefghijklmnopqrstuvwxyz\"\n    l=len(s)\n    alpha2={j:i for i,j in enumerate(alpha)}\n    memo=[[0]*26 for _ in range(l,-1,-1)]\n    for i in range(26):\n        memo[l][i]=l+1\n    for x,y in alpha2.items():\n        for i in range(l-1,-1,-1):\n            if s[i]==x:\n                memo[i][y]=i+1\n            else:\n                memo[i][y]=memo[i+1][y]\n    \n    search=[1]*(l+2)\n    search[l+1]=0\n    for i in range(l-1,-1,-1):\n        m=max([memo[i][j] for j in range(26)])\n        if m!=l+1:\n            search[i]=search[m]+1\n    \n    n,seq=0,0\n    ans_len=search[0]\n    ans=\"\"\n    temp=0\n    for i in range(ans_len):\n        for j in range(26):\n            n=memo[temp][j]\n            seq=search[n]+i\n            if seq+1==ans_len:\n                ans+=alpha[j]\n                temp=memo[temp][j]\n                break\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\n\nalphabetlist=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\nA=input()\nN=len(A)\n\ndic={moji:[] for moji in alphabetlist}\ndp=[0 for i in range(N)]\ncheck=set([A[-1]])\ndic[A[-1]].append(N-1)\nfor i in range(N-2,-1,-1):\n    check.add(A[i])\n    dic[A[i]].append(i)\n    if len(check)==26:\n        dp[i]=dp[i+1]+1\n        check=set([])\n    else:\n        dp[i]=dp[i+1]\n\nfor moji in alphabetlist:\n    dic[moji].sort()\n\nL=dp[0]+1\nans=[]\npos=-1\nflag=0\n\nfor i in range(L-1):\n    if flag==1:\n        break\n    for moji in alphabetlist:\n        if dic[moji]:\n            index=bisect.bisect_left(dic[moji],pos)\n            npos=dic[moji][index]\n            if npos+1<N and dp[npos+1]<L-(i+1):\n                pos=npos+1\n                ans.append(moji)\n                break\n            elif npos==N-1:\n                pos=N\n                ans.append(moji)\n                flag=1\n                break\n\nif pos==N:\n    ans.append(\"a\")\n    print(\"\".join(ans))\nelse:\n    s=set([])\n    for i in range(pos,N):\n        s.add(A[i])\n    for moji in alphabetlist:\n        if moji not in s:\n            ans.append(moji)\n            break\n    print(\"\".join(ans))", "A = [ord(a)-97 for a in input()]\nN = len(A)\nX = [0] * 26\nY = [0] * (N + 2)\nNE = [0] * N\nR = [N] * 26\ns = 0\nt = 1\nfor i in range(N)[::-1]:\n    a = A[i]\n    if X[a] == 0:\n        X[a] = 1\n        s += 1\n        if s == 26:\n            s = 0\n            X = [0] * 26\n            t += 1\n    Y[i] = t\n    NE[i] = R[a]\n    R[a] = i\n\nANS = []\nii = 0\nfor i, a in enumerate(A):\n    if i == ii:\n        for j in range(26):\n            if Y[R[j]+1] < Y[i]:\n                ANS.append(j)\n                ii = R[j]+1\n                break\n    R[a] = NE[i]\n\nprint(\"\".join([chr(a+97) for a in ANS]))", "from collections import Counter\ns = input()\ndef num(letter):\n\treturn ord(letter) - 97\ndef let(number):\n\treturn chr(number + 97)\n\nok = 0\nng = len(s)\nused = [False] * 26\ntmp = 0\ncnt = 0\nfor i in range(len(s)):\n\tif used[num(s[i])] == False:\n\t\tused[num(s[i])] = True\n\t\ttmp += 1\n\tif tmp == 26:\n\t\tcnt += 1\n\t\ttmp = 0\n\t\tused = [False] * 26\n\nprm = cnt+1\n\nif prm == 1:\n\tfor j in range(26):\n\t\tif used[j] == False:\n\t\t\tprint(let(j))\n\t\t\tbreak\nelse:\n\td = []\n\tused = [False] * 26\n\ttmp = 0\n\tfor i in range(len(s)-1, -1, -1):\n\t\tif used[num(s[i])] == False:\n\t\t\tused[num(s[i])] = True\n\t\t\ttmp += 1\n\t\tif tmp == 26:\n\t\t\ttmp = 0\n\t\t\tused = [False] * 26\n\t\t\td.append(i)\n\td = d[::-1]\n\tans = \"\"\n\tcnt = 0\n\ti = 0\n\tskip = False\n\tused = [False] * 26\n\tfor i in range(len(s)):\n\t\tif cnt < prm-1:\n\t\t\tif i == d[cnt]:\n\t\t\t\tfor j in range(26):\n\t\t\t\t\tif used[j] == False:\n\t\t\t\t\t\tans += let(j)\n\t\t\t\t\t\tbreak\n\t\t\t\tused = [False] * 26\n\t\t\t\tcnt += 1\n\t\t\t\tskip = True\t\t\t\n\t\tif skip:\n\t\t\tif s[i] == ans[-1]:\n\t\t\t\tskip = False\n\t\t\tcontinue\n\t\tif used[num(s[i])] == False:\n\t\t\tused[num(s[i])] = True\n\n\tfor j in range(26):\n\t\tif used[j] == False:\n\t\t\tans += let(j)\n\t\t\tbreak\n\tprint(ans)", "S=input()\nN=len(S)\na=ord('a')\nalpha=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nK=[[N]*(N+1) for i in range(26)]\nfor i in range(N-1,-1,-1):\n    x=ord(S[i])-a\n    for j in range(26):\n        if j==x:\n            K[j][i]=i\n            continue\n        K[j][i]=K[j][i+1]\ndp=[0]*(N+2)\nL=[0]*(N+2)\ndp[N]=1\nfor i in range(N-1,-1,-1):\n    c=0\n    b=2*N\n    for j in range(26):\n        t=K[j][i]\n        if b>dp[t+1]+1:\n            b=dp[t+1]+1\n            c=t+1\n    dp[i]=b\n    L[i]=c\nX=dp[0]\nt=0\nans=''\nwhile X>1:\n    t=L[t]\n    ans+=S[t-1]\n    X-=1\n    #print(t,X,ans)\nfor j in range(26):\n    if K[j][t] ==N:\n        ans+=alpha[j]\n        break\nprint(ans)\n\n\n", "import bisect\ns = input()\nn = len(s)\ndp = [[0 for i in range(26)] for j in range(n+1)]\nflg = [0]*26\nprt = []\nfor i in range(n-1,-1,-1):\n  x = ord(s[i])-97\n  for j in range(26):\n    if j == x:\n      dp[i][j] = n-i\n      flg[x] = 1\n    else:\n      dp[i][j] = dp[i+1][j]\n  if flg.count(1) == 26:\n    prt.append(i)\n    flg = [0]*26\nind = 0\nans = []\nif not prt:\n  for i in range(26):\n    if dp[0][i] == 0:\n      print(chr(i+97))\n      return\nprt = prt[::-1]\nfor i in range(26):\n  if dp[prt[0]][i] == dp[0][i]:\n    ans.append(i)\n    break\nelse:\n  ans.append(0)\n\npnt = prt[0]\nflg = 0\nwhile True:\n  c = ans[-1]\n  if not flg:\n    pnt = n-dp[pnt][c]\n  flg = 0\n  prtp = bisect.bisect_right(prt,pnt)\n  if prtp == len(prt):\n    for i in range(26):\n      if dp[pnt+1][i] == dp[-1][i]:\n        ans.append(i)\n        break\n    else:\n      ans.append(0)\n    for od in ans:\n      print(chr(od+97),end=\"\")\n    break\n  npnt = prt[prtp]\n  for i in range(26):\n    if dp[pnt+1][i] == dp[npnt][i]:\n      ans.append(i)\n      break\n  else:\n    ans.append(0)\n    flg = 1\n  pnt = npnt\n", "def main():\n    # import sys\n    # readline = sys.stdin.readline\n    # readlines = sys.stdin.readlines\n    \n    A = input()\n    N = len(A)\n    a = ord('a')\n\n    INF = N\n    na = [[INF] * 26 for _ in range(N + 1)]\n    for i in range(N - 1, -1, -1):\n        c = ord(A[i]) - a\n        for j in range(26):\n            na[i][j] = na[i + 1][j]\n        na[i][c] = i\n\n    dp = [INF] * (N + 1)\n    dp[N] = 1\n    recon = [None] * (N + 1)\n    for i in range(N - 1, -1, -1):\n        for j in range(26):\n            ni = na[i][j]\n            if ni == N:\n                if dp[i] > 1:\n                    dp[i] = 1\n                    recon[i] = (chr(a + j), N)\n            elif dp[i] > dp[ni + 1] + 1:\n                dp[i] = dp[ni + 1] + 1\n                recon[i] = (chr(a + j), ni + 1)\n\n    # k =\n    # for j in range(26):\n    #     ni = na[0][j]\n    #     if dp[i] > dp[ni] + 1:\n\n    i = 0\n    ans = []\n    while i < N:\n        c, ni = recon[i]\n        ans.append(c)\n        i = ni\n\n    print((''.join(ans)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import accumulate\n\nS = list(map(ord, input().strip()))\nN = len(S)\n\natype = set()\nseg = [0]*N\nseg[-1] = 1\nfor i in range(N-1, -1, -1):\n    atype.add(S[i])\n    if len(atype) == 26:\n        atype = set()\n        seg[i] = 1\n\ninf = 1<<32\nidx = [[inf]*N for _ in range(26)]\nfor i in range(N-1, -1, -1):\n    s = S[i] - 97\n    idx[s][i] = i\n\nfor s in range(26):\n    for i in range(N-2, -1, -1):\n        idx[s][i] = min(idx[s][i], idx[s][i+1])\n\n\n\nseg = list(accumulate(seg[::-1]))[::-1]\nseg.append(1)\nL = seg[0]\nans = []\ncnt = -1\nfor i in range(L):\n    for c in range(26):\n        k = idx[c][cnt+1]\n        if k == inf:\n            ans.append(97+c)\n            break\n        if seg[k+1] + i + 1 <= L:\n            ans.append(97+c)\n            cnt = k\n            break\n        \n\nprint(''.join(map(chr, ans)))", "from collections import Counter\ns = input()\ndef num(letter):\n\treturn ord(letter) - 97\ndef let(number):\n\treturn chr(number + 97)\n\nok = 0\nng = len(s)\nused = [False] * 26\ntmp = 0\ncnt = 0\nfor i in range(len(s)):\n\tif used[num(s[i])] == False:\n\t\tused[num(s[i])] = True\n\t\ttmp += 1\n\tif tmp == 26:\n\t\tcnt += 1\n\t\ttmp = 0\n\t\tused = [False] * 26\n\nprm = cnt+1\n\nif prm == 1:\n\tfor j in range(26):\n\t\tif used[j] == False:\n\t\t\tprint(let(j))\n\t\t\tbreak\nelse:\n\td = []\n\tused = [False] * 26\n\ttmp = 0\n\tfor i in range(len(s)-1, -1, -1):\n\t\tif used[num(s[i])] == False:\n\t\t\tused[num(s[i])] = True\n\t\t\ttmp += 1\n\t\tif tmp == 26:\n\t\t\ttmp = 0\n\t\t\tused = [False] * 26\n\t\t\td.append(i)\n\td = d[::-1]\n\t#print(d)\n\tans = \"\"\n\tcnt = 0\n\ti = 0\n\tskip = False\n\tused = [False] * 26\n\tfor i in range(len(s)):\n\t\tif cnt < prm-1:\n\t\t\tif i == d[cnt]:\n\t\t\t\tfor j in range(26):\n\t\t\t\t\tif used[j] == False:\n\t\t\t\t\t\tans += let(j)\n\t\t\t\t\t\tbreak\n\t\t\t\tused = [False] * 26\n\t\t\t\tcnt += 1\n\t\t\t\tskip = True\n\t\t\t\t\n\t\tif skip:\n\t\t\tif s[i] == ans[-1]:\n\t\t\t\t#print(i)\n\t\t\t\tskip = False\n\t\t\tcontinue\n\n\t\tif used[num(s[i])] == False:\n\t\t\tused[num(s[i])] = True\n\n\t#print(used)\n\tfor j in range(26):\n\t\tif used[j] == False:\n\t\t\tans += let(j)\n\t\t\tbreak\n\tprint(ans)", "import bisect\nA = input()\nn = len(A)\nch = [[] for _ in range(26)]\nidx = []\nused = set()\nfor i in range(n-1, -1, -1):\n  a = A[i]\n  ch[ord(a)-ord(\"a\")].append(i)\n  used.add(a)\n  if len(used) == 26:\n    idx.append(i)\n    used = set()\nk = len(idx)\nidx = idx[::-1]\nfor j in range(26):\n  ch[j] = ch[j][::-1]\nans = \"\"\nnow = -1\nfor i in range(k):\n  for j in range(26):\n    nxt = ch[j][bisect.bisect_right(ch[j], now)]\n    if nxt >= idx[i]:\n      now = nxt\n      ans += chr(j+ord(\"a\"))\n      break\nfor j in range(26):\n  l = bisect.bisect_right(ch[j], now)\n  if l == len(ch[j]):\n    ans += chr(j+ord(\"a\"))\n    break\nprint(ans)", "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc081/tasks/arc081_c\n\n1\u6587\u5b57\u304c\u3042\u308a\u3046\u308b\u306e\u306f\u3001\u51fa\u3066\u306a\u3044\u6587\u5b57\u304c\u3042\u308b\u3068\u304d\n2\u6587\u5b57\u304c\u3042\u308a\u3046\u308b\u306e\u306f\u3001\u5168\u3066\u306e\u6587\u5b57\u304c1\u5ea6\u51fa\u305f\u306e\u3061\u3001\u3082\u3046\u4e00\u5ea6\u3059\u3079\u3066\u306e\u6587\u5b57\u304c1\u5ea6\u73fe\u308c\u3066\u306a\u3044\u5834\u5408\n\u3064\u307e\u308a\u7b54\u3048\u306e\u6587\u5b57\u6570\u306f\u3053\u306e\u65b9\u6cd5\u3067\u5206\u304b\u308b\n\n\u3067\u306f\u8f9e\u66f8\u9806\u6700\u5c0f\u306e\u3082\u306e\u306f\uff1f\nk\u6587\u5b57\u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u305f\u3068\u3059\u308b\u3002\n\u3053\u306e\u6642\u3001\u3069\u306e\u6587\u5b57\u3082\u6700\u4f4ek-1\u56de\u51fa\u73fe\u3057\u3066\u3044\u308b\n\u6700\u5f8c\u306e\u6587\u5b57\u306f\u3001k\u56de\u51fa\u73fe\u3057\u3066\u306a\u3044\u6587\u5b57\u306e\u5185\u3001\u8f9e\u66f8\u9806\u6700\u5c0f\u306e\u7269\n\u6700\u5f8c\u304b\u30891\u756a\u76ee\u306f\u3001k-1\u56de\u76ee\u306e\u51fa\u73fe\u306e\u5f8c\u3001\u6700\u5f8c\u306e\u6587\u5b57\u304c\u51fa\u3066\u3044\u306a\u3044\u8005\n\u6700\u5f8c\u304b\u30892\u756a\u76ee\u306f\u3001\n\nabc\u306e3\u6587\u5b57\u3057\u304b\u306a\u3044\u3068\u3059\u308b\nabababababcab\n\n\u2192\u3053\u306e\u6642\u3001\u6c42\u3081\u308b\u306e\u306f\u3001?c\u3067\u3001?\u306fc\u6700\u5f8c\u306b\u51fa\u73fe\u3059\u308bc\u3088\u308a\u3082\u524d\u306b\u5b58\u5728\u3057\u306a\u3044k-1\u6587\u5b57\u306e\u8f9e\u66f8\u9806\u6700\u5c0f\n\nabcabcab\n\u2192??c\n\u2192\u6700\u5f8c\u306e\u51fa\u73fe\u3059\u308bc\u4ee5\u524d=abcab\u4ee5\u524d\u3067\u5b58\u5728\u3057\u306a\u30442\u6587\u5b57\n\u2192?cc\n\u2192ab\u3067\u5b58\u5728\u3057\u306a\u30441\u6587\u5b57\n\u2192ccc\n\nacbaccbac\n\u2192\u7d50\u5c40\u518d\u5e30\u7684\u306b\u89e3\u3051\u308b\n\u2192\u51fa\u73fe\u56de\u6570\u304c\u6700\u5c0f\u306e\u6587\u5b57\u306e\u3046\u3061\u3001\u8f9e\u66f8\u9806\u6700\u5c0f\u306e\u7269\u3092\u7b54\u3048\u306e\u6700\u5f8c\u306e\u6587\u5b57\u304b\u3089\u6c7a\u3081\u3066\u3044\u304d\u3001\u305d\u306e\u6587\u5b57\u304c\u6700\u5f8c\u306e\u51fa\u73fe\u3057\u305find\n\u3088\u308a\u524d\u306b\u95a2\u3057\u3066\u3001\u540c\u3058\u554f\u984c\u3092\u89e3\u304f\n\n\u3042\u3068\u306f\u3069\u3046\u3084\u3063\u3066\u8a08\u7b97\u91cf\u3092\u524a\u6e1b\u3059\u308b\u304b\n\u305d\u306e\u6642\u70b9\u3067\u3001\u3069\u306e\u6587\u5b57\u304c\u4f55\u5ea6\u51fa\u305f\u304b\u3001\u6700\u5f8c\u306e\u51fa\u73fe\u3057\u305findex\u306f\u3069\u3053\u304b\u3001\u3092\u8a18\u9332\u3057\u3066\u7f6e\u3044\u3066\u518d\u5e30\u7684\u306b\u89e3\u304f\n\n\u2192\u65b9\u91dd\u306f\u5408\u3063\u3066\u308b\uff1f\u3051\u3069\u5b9f\u88c5\u3057\u3066\u308b\u306e\u304c\u9055\u3046\u3088\uff01\n\u4fdd\u5b58\u3057\u3066\u304a\u304f\u306e\u306f\u3001\u5168\u3066\u306e\u6587\u5b57\u304c\u4f55\u56de\u51fa\u63c3\u3063\u305f\u304b\u3001\u3068\u305d\u306e\u5f8c\u3069\u306e\u6587\u5b57\u304c\u51fa\u3066\u3044\u308b\u304b\u3002\n&\u5404\u6587\u5b57\u304c\u6700\u5f8c\u306b\u3069\u3053\u3067\u51fa\u305f\u304b\u3002\n\n\u3042\u308c\u30fc\uff1f\naaaaaabbbbbbc\n\n\u2192\u554f\u984c\u306f\u3001\u5fc5\u305a\u3057\u3082\u5f8c\u308d\u304b\u3089\u6700\u9069\u306a\u306e\u3092\u9078\u3093\u3067\u884c\u3051\u3070\u3044\u3044\u308f\u3051\u3067\u306f\u306a\u304b\u3063\u305f\u3053\u3068\n\u2192\u3053\u308c\u306f\u3042\u304f\u307e\u3067\u3001\u5f8c\u308d\u304b\u3089\u898b\u3066\u8f9e\u66f8\u9806\u6700\u5c0f\u3067\u3057\u304b\u306a\u3044\u2026\u3042\u308c\u307e\u3055\u304b\uff1f\n\u2192\u6b63\u89e3\u3057\u3061\u3083\u3063\u305f\u30fc\uff1f\uff1f\uff1f\n\"\"\"\n\nA = list(input())\nA.reverse()\n\nalp = \"abcdefghijklmnopqrstuvwxyz\"\nalpdic = {}\nfor i in range(26):\n    alpdic[alp[i]] = i\n\nallcol = [0] * (len(A)+1)\napnum =  [ [0] * 26 for i in range(len(A)+1) ]\nlastap = [ [0] * 26 for i in range(len(A)+1) ]\n\nfor i in range(len(A)):\n\n    for j in range(26):\n        apnum[i+1][j] = apnum[i][j]\n        lastap[i+1][j] = lastap[i][j]\n        allcol[i+1] = allcol[i]\n\n    apnum[i+1][alpdic[A[i]]] |= 1\n    if 0 not in apnum[i+1]:\n        apnum[i+1] = [0] * 26\n        allcol[i+1] += 1\n    lastap[i+1][alpdic[A[i]]] = i+1\n\nanslen = allcol[-1]+1\nans = []\nnind = len(A)\n\nfor i in range(anslen):\n\n    #print (\"\".join(A[:nind]))\n\n    minind = 0\n    for j in range(26):\n        if apnum[nind][j] == 0:\n            minind = j\n            break\n    ans.append(alp[minind])\n\n    nind = lastap[nind][minind]-1\n\n#ans.reverse()\nprint (\"\".join(ans))", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    S = input().rstrip('\\n')\n    N = len(S)\n\n    rank = [0] * N\n    seen = [0] * 26\n    cnt = 0\n    r = 0\n    for i in range(N-1, -1, -1):\n        j = ord(S[i]) - 97\n        if not seen[j]:\n            seen[j] = 1\n            cnt += 1\n        rank[i] = r\n        if cnt == 26:\n            r += 1\n            seen = [0] * 26\n            cnt = 0\n\n    ans = []\n    for i in range(26):\n        if not seen[i]:\n            ans.append(i+97)\n            break\n\n    i0 = 0\n    while ord(S[i0]) != ans[0]:\n        i0 += 1\n        if i0 == N:\n            print((chr(ans[0])))\n            return\n    r = rank[i0]\n    seen2 = [0] * 26\n    flg = 1\n    for i in range(i0+1, N):\n        j = ord(S[i])-97\n        if flg:\n            if rank[i] == r:\n                seen2[j] = 1\n            else:\n                for k in range(26):\n                    if not seen2[k]:\n                        ans.append(k+97)\n                        break\n                flg = 0\n                seen2 = [0] * 26\n                if j == k:\n                    r -= 1\n                    flg = 1\n        else:\n            if j != k:\n                continue\n            else:\n                r -= 1\n                flg = 1\n    for k in range(26):\n        if not seen2[k]:\n            ans.append(k + 97)\n            break\n    print((''.join(map(chr, ans))))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def calcNext(s):\n    n = len(s)\n    res = [[n+1] * 26 for _ in range(n+1)]\n    for i in range(n-1, -1, -1):\n        for j in range(26):\n            res[i][j] = res[i+1][j]\n        res[i][ord(s[i]) - ord('a')] = i\n    return res\n\ndef solve(s):\n    n = len(s)\n    nx = calcNext(s)\n    dp = [n + 1] * (n + 1)\n    recon = ['a'] * (n + 1)\n    dp[n] = 1\n    for i in range(n-1, -1, -1):\n        for j in range(26):\n            if nx[i][j] == n + 1:\n                if dp[i] > 1:\n                    dp[i] = 1\n                    recon[i] = chr(ord('a') + j)\n            else:\n                if dp[nx[i][j] + 1] + 1 < dp[i]:\n                    dp[i] = dp[nx[i][j] + 1] + 1\n                    recon[i] = chr(ord('a') + j)\n    res = ''\n    idx = 0\n    while idx <= n:\n        res += recon[idx]\n        idx = nx[idx][ord(recon[idx]) - ord('a')] + 1\n    return res\n\nS = input()\nprint(solve(S))", "\nord_a = ord('a')\nL = 26\n\nS = list(map(lambda c: ord(c)-ord_a,input()))\n\n\nmemo = []\n\nf = [0]*L\ncnt = 0\n\n\nfor i,s in zip(reversed(range(len(S))),reversed(S)):\n\n  cnt += (f[s] == 0)\n  f[s] += 1\n  if cnt == L:\n    memo.append((i,f))\n    f = [0]*L\n    cnt = 0\n\n\nresult = [f.index(0)]\n\nfor i,f in reversed(memo):\n  c = result[-1]\n  for j in range(i,len(S)):\n    s = S[j]\n    f[s] -= 1\n    if s == c:\n      break\n\n  result.append(f.index(0))\n\nprint(''.join(map(lambda x: chr(x+ord_a), result)))", "from collections import deque\nalpha = \"abcdefghijklmnopqrstuvwxyz\"\nA = input()\nn = len(A)\nB = ord('a')\n\nlinks = [None]*(n+3)\n\nlink = [n]*26\nfor i in range(n-1, -1, -1):\n    links[i] = link[:]\n    link[ord(A[i]) - B] = i\nlinks[-1] = link\n\ndeq = deque()\ndeq.append(-1)\nprev = {-1: (None, 0)}\nwhile deq:\n    v = deq.popleft()\n    if v == n:\n        break\n    link = links[v]\n    for c in range(26):\n        if link[c] in prev:\n            continue\n        prev[link[c]] = (v, c)\n        deq.append(link[c])\nv = n\nans = []\nwhile v is not None:\n    v, c = prev[v]\n    ans.append(chr(c+B))\nans.reverse()\nprint((\"\".join(ans[1:])))\n\n", "n2a=lambda x:chr(x+ord('a'))\na2n=lambda x:ord(x)-ord('a')\n\ndef main(a):\n  nc=26\n  n=len(a)\n  ary=[]\n  tmp=[0]*nc\n  mi=set(range(nc))\n  for i in range(n-1,-1,-1):\n    x=a2n(a[i])\n    mi.discard(x)\n    tmp[x]+=1\n    if len(mi)==0:\n      ary.append(tmp.copy())\n      tmp=[0]*nc\n      mi=set(range(nc))\n  if any(tmp):ary.append(tmp)\n  #for x in ary:print(x)\n  ans=[]\n  now=0\n  tmp=ary.pop()\n  if all(tmp):\n    ans.append('a')\n    while a[now]!='a':\n      tmp[a2n(a[now])]-=1\n      now+=1\n    tmp[a2n(a[now])]-=1\n    now+=1\n  else:\n    for i in range(nc):\n      if tmp[i]==0:\n        ans.append(n2a(i))\n        break\n    if not ary:return ans\n    ntmp=ary.pop()\n    for j in range(nc):tmp[j]+=ntmp[j]\n    while a2n(a[now])!=i:\n      tmp[a2n(a[now])]-=1\n      now+=1\n    tmp[a2n(a[now])]-=1\n    now+=1\n  while True:\n    #print(ary,tmp,ans)\n    for i in range(nc):\n      if tmp[i]==0:\n        ans.append(n2a(i))\n        break\n    if not ary:return ans\n    ntmp=ary.pop()\n    for j in range(nc):tmp[j]+=ntmp[j]\n    while a2n(a[now])!=i:\n      tmp[a2n(a[now])]-=1\n      now+=1\n    tmp[a2n(a[now])]-=1\n    now+=1\n\na=input()\nprint(*main(a),sep='')\n\"\"\"\nbcdefghijklmnopqrstuvwxyza\n\naabbccaabca\naab / bccaa / bca\n\n\"\"\"\n\n", "from bisect import bisect_left\nA = [ord(i) - 97 for i in input()]\n\nA = A + list(range(26))\nA = A[::-1]\n\ndp = [0] * 26\nkey = [[] for _ in range(26)]\nval = [[] for _ in range(26)]\nfor i, a in enumerate(A) :\n  x = min(dp) + 1\n  dp[a] = x\n  key[a].append(i)\n  val[a].append(x)\n\nret = ''\nx = dp[dp.index(min(dp))] + 1\npos = 10 ** 6\nwhile True :\n  for i in range(26) :\n    if key[i][0] < pos :\n      j = bisect_left(key[i], pos) - 1\n      if val[i][j] == x - 1 :\n        ret += chr(i + 97)\n        pos = key[i][j]\n        x -= 1\n        break\n  else :\n    break\n\nprint(ret)", "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nS = sys.stdin.readline().rstrip()\nA = [ord(c) - ord('a') for c in S]\nN = len(S)\n\n# \u7b54\u3048\u306e\u6587\u5b57\u5217\u306e\u9577\u3055\nl = 0\n# \u305d\u306e\u6587\u5b57\u4ee5\u964d\u3067\u3001\u4f55\u6587\u5b57\u307e\u3067\u306e\u4efb\u610f\u6587\u5b57\u5217\u3092\u4f5c\u308c\u308b\u304b\nlengths = [0] * N\ncounts = [0] * 26\nfor i, a in reversed(list(enumerate(A))):\n    counts[a] += 1\n    lengths[i] = l\n    if min(counts) == 1:\n        counts = [0] * 26\n        l += 1\nans_size = l + 1\n\n# \u6587\u5b57\u3054\u3068\u306e\u6b21\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\ngraph = [[-1] * 26 for _ in range(N)]\npos = [-1] * 26\nfor i, a in reversed(list(enumerate(A))):\n    graph[i] = pos[:]\n    pos[a] = i\ninitials = pos\n\n\ndef solve(size, i=None):\n    # i \u756a\u76ee\u304b\u3089\u59cb\u307e\u308a\u3001\u9577\u3055 size \u3067\u3042\u308b\u3001\u90e8\u5206\u5217\u3067\u306a\u3044\u6587\u5b57\u5217\n    if i is None:\n        pos = initials\n    else:\n        pos = graph[i]\n\n    if size == 1:\n        return chr(pos.index(-1) + ord('a'))\n\n    size -= 1\n    for ci, i in enumerate(pos):\n        if lengths[i] < size:\n            c = chr(ci + ord('a'))\n            return c + solve(size, i)\n    return ''\n\n\nprint((solve(ans_size)))\n", "\nimport sys\nfrom collections import deque, defaultdict\nimport copy\nimport bisect\nsys.setrecursionlimit(10 ** 9)\nimport math\nimport heapq\nfrom itertools import product, permutations,combinations\nimport fractions\n\nimport sys\ndef input():\n\treturn sys.stdin.readline().strip()\n\nalpha2num = lambda c: ord(c) - ord('a')\n\n\ndef num2alpha(num):\n\tif num<=26:\n\t\treturn chr(96+num)\n\telif num%26==0:\n\t\treturn num2alpha(num//26-1)+chr(122)\n\telse:\n\t\treturn num2alpha(num//26)+chr(96+num%26)\n\nA = input()\n\nloc_list = deque([])\nloc_list_last = deque([])\nnum = 0\nalpha_list = [-1] * 26\nalpha_list_last = [-1] * 26\nroop = 0\nfor i in range(len(A) - 1, -1, -1):\n\talphanum = alpha2num(A[i])\n\tif alpha_list[alphanum] == -1:\n\t\tnum += 1\n\t\talpha_list_last[alphanum] = i\n\talpha_list[alphanum] = i\n\tif num == 26:\n\t\tloc_list.appendleft(alpha_list)\n\t\tloc_list_last.appendleft(alpha_list_last)\n\t\talpha_list = [-1]*26\n\t\talpha_list_last = [-1]*26\n\t\troop += 1\n\t\tnum = 0\nloc_list.appendleft(alpha_list)\nloc_list_last.appendleft(alpha_list_last)\nans = deque([])\n#print(loc_list)\nfor i in range(26):\n\tif loc_list[0][i] == -1:\n\t\tx = i\n\t\tans.append(x)\n\t\tbreak\n\nif len(loc_list) > 1:\n\tmozi = x\n\tfor n in range(1, len(loc_list)):\n\t\tloc = loc_list[n][mozi]\n\t\t#print(loc, mozi)\n\t\tfor i in range(26):\n\t\t\tif loc_list_last[n][i] <= loc:\n\t\t\t\tans.append(i)\n\t\t\t\tmozi = i\n\t\t\t\tbreak\n#print(loc_list)\n\nans2 = []\n\nfor i in range(len(ans)):\n\tans2.append(num2alpha(ans[i] + 1))\nprint(''.join(ans2))", "import sys\nsys.setrecursionlimit(10**6)\n\na = input() + \"$\"\nn = len(a)\n\nalph = \"abcdefghijklmnopqrstuvwxyz\"\ndp = [-1] * (n + 1)\n\nnext_ = [[-1] * (n + 1) for i in range(26)]\nfor char in range(26):\n    tmp = - 1\n    for i in range(n)[::-1]:\n        if a[i] == alph[char]:\n            tmp = i + 1\n        next_[char][i] = tmp\n\n\ndef solve():\n    for i in range(n + 1)[::-1]:\n        tmp = n + 1\n        for char in range(26):\n            if next_[char][i] == -1:\n                dp[i] = 1\n                break\n            tmp = min(dp[next_[char][i]] + 1 , tmp)\n        else:\n            dp[i] = tmp\n\nsolve()\nans = []\ni = 0\nwhile True:\n    for char in range(26):\n        if next_[char][i] == -1:\n            ans.append(alph[char])\n            print(\"\".join(ans))\n            return\n        if dp[i] == dp[next_[char][i]] + 1:\n            ans.append(alph[char])\n            i = next_[char][i]\n            break", "from bisect import bisect_left\nA = input()\n\nN = len(A)\ndp = [0] * (N + 2)\ndp[N] = 1\nd = [[N] for i in range(26)]\na = ord('a')\nINF = float('inf')\nfor i in range(N - 1, -1, -1):\n    d[ord(A[i]) - a].append(i)\n    tmp = INF\n    for j in range(26):\n        tmp = min(tmp, dp[d[j][-1] + 1])\n    dp[i] = tmp + 1\n\n\nfor i in range(26):\n    d[i] = d[i][::-1]\n\npos = 0\nans = ''\nfor i in range(dp[0] - 1, -1, -1):\n    for j in range(26):\n        k = bisect_left(d[j], pos)\n        if dp[d[j][k] + 1] == i:\n            ans += chr(j + a)\n            pos = d[j][k] + 1\n            break\n\nprint(ans)\n", "from collections import deque\n\n\nA = input()\nN = len(A)\na = ord('a')\n\nedge = [[N + 1] * 26 for _ in range(N + 1)]\nfor i in range(N - 1, -1, -1):\n    for j in range(26):\n        edge[i][j] = edge[i + 1][j]\n    c = ord(A[i]) - a\n    edge[i][c] = i + 1  # \u6587\u5b57c\u306e\u76f4\u5f8c\u306e\u9802\u70b9\n\n\nrecon = [None] * (N + 2)  # DP\u5fa9\u5143\u7528\u3002(\u76f4\u524d\u306e\u9802\u70b9, \u6587\u5b57)\u3092\u683c\u7d0d\u3059\u308b\u3002\nq = deque()\nq.append(0)  # \u9802\u70b9\nwhile q:\n    i = q.popleft()\n    if i == N + 1:  # \u9802\u70b9N+1\u306b\u5230\u9054\u3057\u305f\u3089\u51e6\u7406\u7d42\u4e86\n        break\n    for j in range(26):\n        ni = edge[i][j]\n        if recon[ni] is None:  # \u305d\u306e\u9802\u70b9\u306b\u6700\u77ed\u3067\u5230\u9054\u3057\u305f\u5834\u5408\u306e\u307f\u6b21\u306e\u51e6\u7406\u3092\u7d99\u7d9a\n            recon[ni] = (i, chr(a + j))\n            q.append(ni)\n\ni = N + 1\nans = []\nwhile i > 0:\n    pi, c = recon[i]\n    ans.append(c)\n    i = pi\n\nprint((''.join(reversed(ans))))\n", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\na = input()\nn = len(a)\ns = set()\nl = []\ni = n-1\nprv = n\nfor c in a[::-1]:\n    s.add(c)\n    if len(s)==26:\n        s = set()\n        l.append((i,prv))\n        prv = i\n    i -= 1\ndef sub(i,j):\n    \"\"\"[i,j)\u306b\u542b\u307e\u308c\u306a\u3044\u6587\u5b57\u306e\u3046\u3061\u306e\u6700\u5c0f\n    \"\"\"\n#     print(i,j)\n    al = set([chr(v) for v in range(ord(\"a\"), ord(\"z\")+1)])\n    for ind in range(i,j):\n        al.discard(a[ind])\n    return min(al)\nans = []\nc = sub(0,prv)\nans.append(c)\nwhile l:\n    i,j = l.pop()\n    for ind in range(i,n):\n        if a[ind]==c:\n            break\n    c = sub(ind+1,j)\n    ans.append(c)\nans = \"\".join(ans)\n# else:\n#     ans = \"a\" * (len(l)+1)\nprint(ans)"]
["from math import pi\nfrom cmath import exp\ndef fft(a, lgN, rot=1): # rot=-1 for ifft\n  N = 1<<lgN\n  assert len(a)==N\n  rev = [0]*N\n  for i in range(N):\n    rev[i] = (rev[i>>1]>>1)+(i&1)*(N>>1)\n  A = [a[rev[i]] for i in range(N)]\n  h = 1\n  while h<N:\n    w_m = exp((0+1j) * rot * (pi / h))\n    for k in range(0, N, h<<1):\n      w = 1\n      for j in range(h):\n        t = w * A[k+j+h]\n        A[k+j+h] = A[k+j]-t\n        A[k+j] = A[k+j]+t\n        w *= w_m\n    h = h<<1\n  return A if rot==1 else [x/N for x in A]\n\n\nimport sys\nints = (int(x) for x in sys.stdin.read().split())\n\nn, x = (next(ints) for i in range(2))\nr = [next(ints) for i in range(n)]\nac = [0]*(n+1)\nfor i in range(n): ac[i+1] = (r[i]<x) + ac[i]\n\n# Multiset addition\nmin_A, min_B = 0, -ac[-1]\nmax_A, max_B = ac[-1], 0\nN, lgN, m = 1, 0, 2*max(max_A-min_A+1, max_B-min_B+1)\nwhile N<m: N,lgN = N<<1,lgN+1\na, b = [0]*N, [0]*N\nfor x in ac:\n  a[x-min_A] += 1\n  b[-x-min_B] += 1\nc = zip(fft(a, lgN), fft(b, lgN))\nc = fft([x*y for x,y in c], lgN, rot=-1)\nc = [round(x.real) for x in c][-min_A-min_B:][:n+1]\nc[0] = sum((x*(x-1))//2 for x in a)\nprint(*c, *(0 for i in range(n+1-len(c))), flush=True)"]
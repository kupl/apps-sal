["from collections import deque\n\ndef rollingmax(x, y, r, a):\n    k = 2 * r + 1\n    d = deque()\n    lx = len(x)\n    for i in range(lx + r):\n        if i < lx:\n            while d and d[-1][1] <= x[i]:\n                d.pop()\n            d.append((i, x[i]))\n        while d and d[0][0] <= i - k:\n            d.popleft()\n        if i >= r:\n            y[i - r] = d[0][1] - abs(i - r - a)\n\nn, m, d = [int(x) for x in input().split()]\na, ball, t0 = [int(x) for x in input().split()]\nf = [-abs(i - a) for i in range(1, n + 1)]\ng = [0] * n\nfor _ in range(m - 1):\n    a, b, t = [int(x) for x in input().split()]\n    ball += b\n    r = min(n - 1, (t - t0) * d)\n    t0 = t    \n    rollingmax(f, g, r, a - 1)\n    f, g = g, f\n\nprint(max(f) + ball)    \n\n", "from collections import deque\nn,m,v=map(int,input().split())\nx,t,b,bt,dp,mi,mi2,mi3,dpmin,dp2=[0]*300,[0]*300,0,0,[[0]*2for i in range(150001)],0,100000000000000,10000000000000,0,[0]*150001\nd=deque()\nfor i in range(m):\n    x[i],b,t[i]=map(int,input().split())\n    bt+=b\nfor i2 in range(m-1):\n    if i2==0:\n        for i in range(1,n+1):\n            dp[i][0]=abs(i-x[0])\n            if mi2>dp[i][0]:\n                mi2=dp[i][0]\n    if m==1:\n        break\n    if(t[i2+1]-t[i2])*v>=n:\n        mi3=mi2\n        mi2=1000000000000000000\n        for i in range(1,n+1):\n            dp[i][0]=mi3+abs(i-x[i2+1])\n            if mi2>dp[i][0]:\n                mi2=dp[i][0]\n        continue\n    mi2=1000000000000000000\n    for i in range(1,n+1+(t[i2+1]-t[i2])*v):\n        if i<=n:\n            while (len(d)>0 and dp[i][0]<=d[len(d)-1][0]):\n                d.pop()\n            dp[i][1]=i+2*(t[i2+1]-t[i2])*v+1\n            d.append(dp[i])\n        if d[0][1]==i:\n            d.popleft()\n        if i-(t[i2+1]-t[i2])*v>=1:\n            dp2[i-(t[i2+1]-t[i2])*v]=d[0][0]+abs(x[i2+1]-(i-(t[i2+1]-t[i2])*v))\n    for i in range(1,n+1):\n        dp[i][0]=dp2[i]\n        if dp2[i]<mi2:\n            mi2=dp2[i]\n    d.clear()\nfor i in range(1,n+1):\n    if i==1:\n        mi=dp[i][0]\n    if dp[i][0]<mi:\n        mi=dp[i][0]\nprint(bt-mi)", "class SortedList(list):\n\n    def add(self, other):\n        left = -1\n        right = len(self)\n        while right - left > 1:\n            mid = (right + left) >> 1\n            if other < self[mid]:\n                right = mid\n            else:\n                left = mid\n        super().insert(right, other)\n\n\nINF = int(3e18)\n\n\ndef solve_good(n, m, d, a, b, t):\n    left = SortedList()\n    left.append(-INF)\n    right = SortedList()\n    right.append(INF)\n    lborder = -INF\n    rborder = INF\n    tprev = 0\n    ans = 0\n    for ai, bi, ti in zip(a, b, t):\n        ans += bi\n        dt = ti - tprev\n        interval = dt * d\n        tprev = ti\n\n        lborder += interval\n        rborder -= interval\n\n        lefta = lborder + ai\n        righta = rborder - (n - ai)\n\n        if lefta < left[-1]:\n            top = left.pop()\n            ans -= abs(top - lefta)\n            left.add(lefta)\n            left.add(lefta)\n            right.add(rborder - (n - abs(top - lborder)))\n        elif righta > right[0]:\n            top = right.pop(0)\n            ans -= abs(top - righta)\n            right.add(righta)\n            right.add(righta)\n            left.add(lborder + n - abs(top - rborder))\n        else:\n            left.add(lefta)\n            right.add(righta)\n    return ans\n\n\nn, m, d = [int(elem) for elem in input().split()]\na, b, t = [], [], []\nfor i in range(m):\n    ai, bi, ti = [int(elem) for elem in input().split()]\n    a.append(ai)\n    b.append(bi)\n    t.append(ti)\n\nprint(solve_good(n, m, d, a, b, t))\n"]
["tb=str(input())\ntb=list(tb)\nif(\"c\" in tb or \"k\" in tb):\n print(0)\nelse:\n ans=1\n i=0\n while(i<len(tb)):\n  if(tb[i]==\"g\" or tb[i]==\"f\"):\n   my=tb[i]\n   i+=1\n   ct=1\n   while(i<len(tb) and tb[i]==my):\n    ct+=1\n    i+=1\n   if(ct>3):\n    ct+=1\n   ans*=ct\n  else:\n   i+=1\n print(ans)", "from itertools import combinations as cb\n\ns = input()\ns = list(s)\nif('c' in s or 'k' in s):\n print('0')\nelse:\n nf = []\n nk =[]\n i =0\n while i<len(s)-1:\n  if(s[i]=='f'):\n   j=i+1\n   p=1\n   k =1\n   while j<len(s) and p:\n    if(s[j]=='f'):\n     k+=1\n     j +=1\n    else:\n     p=0\n   nf.append(k) \n   i = j\n  elif(s[i]=='g'):\n   j = i+1\n   p=1\n   k=1\n   while j<len(s) and p:\n    if(s[j]=='g'):\n     k+=1\n     j+=1\n    else:\n     p=0\n     \n   nk.append(k)\n   i = j\n  else:\n   i+=1\n\n \n p=1\n for i in nf:\n  n = i\n  if(n>=2):\n   k=0\n   for j in range(1,n+1):\n    a = (n//j) -1\n    k +=a\n   k+=1\n   p *=k\n for i in nk:\n  n = i\n  if(n>=2):\n   k=0\n   for j in range(1,n+1):\n    a = (n//j) -1\n    k +=a\n   k+=1\n   p *=k\n if(nf!=[] and nk!=[]):\n  if(len(s)==nf[0] or len(s)==nk[0]):\n   count =p-1\n  else:\n   count =p\n elif(nf==[] and nk!=[]):\n  if( len(s)==nk[0]):\n   count =p-1\n  else:\n   count =p\n elif(nf!=[] and nk==[]):\n  if(len(s)==nf[0]):\n   count =p-1\n  else:\n   count =p\n else:\n  count =1\n print(count%1000000007)", "try:\n def find(l):\n  f=0\n  for i in range(len(l)-1):\n   if(l[i]=='f' and l[i+1]=='f'):\n    f+=find(l[i+1:])\n    f+=find(l[i+2:])\n    break\n   if(l[i]=='g' and l[i+1]=='g'):\n    f+=find(l[i+1:])\n    f+=find(l[i+2:])\n    break\n  if(f==0):\n   return f+1\n  return f\n l=list(input())\n if(l.count('c')>0 or l.count('k')>0):\n  print(\"0\")\n else:\n  print(find(l))\nexcept EOFError as e:\n pass", "mod=10**9+7\nfib=[1,1]\nfor i in range(10**5+4):\n fib.append((fib[-1]+fib[-2])%mod)\ns=input()\nif 'c' in s or 'k' in s:\n print(0)\n return\nn=len(s)\nl=[]\ni=0\nwhile i<n:\n if s[i]=='f':\n  c=0\n  while i<n and s[i]=='f':\n   c+=1\n   i+=1\n  l.append(fib[c])\n elif s[i]=='g':\n  c=0\n  while i<n and s[i]=='g':\n   c+=1\n   i+=1\n  l.append(fib[c])\n else:\n  i+=1\nif len(l)==0:\n print(1)\n return\nans=l[0]\nfor i in range(1,len(l)):\n ans=(ans*l[i])%mod\nprint(ans)", "from math import factorial\n\ndef rle(s):\n if not s:\n  return []\n last = s[0]\n count = 0\n for curr in s:\n  if last == curr:\n   count += 1\n  else:\n   yield (last, count)\n   count = 1\n   last = curr\n else:\n  yield (last, count)\n  \ndef algo(n):\n ans = 0\n for repl_length in range(0, n + 1, 2):\n  n_fs = n - repl_length\n  n_cs = repl_length >> 1\n  ans += factorial(n_fs + n_cs) // (factorial(n_fs) * factorial(n_cs))\n return ans\n\ns = input()\nans = 1\nfor (char, count) in rle(s):\n if char in 'gf':\n  ans *= algo(count)\nprint(ans)", "from functools import lru_cache\n\n\ndef rle(s):\n if not s:\n  return []\n last = s[0]\n count = 0\n for curr in s:\n  if last == curr:\n   count += 1\n  else:\n   yield (last, count)\n   count = 1\n   last = curr\n else:\n  yield (last, count)\n\n\n@lru_cache(maxsize=None)\ndef fact(n):\n if n < 3:\n  return max(1, n)\n return n * fact(n - 1)\n\n\ndef comb_count(n):\n ans = 0\n for repl_length in range(0, n + 1, 2):\n  n_fs = n - repl_length\n  n_cs = repl_length >> 1\n  ans += fact(n_fs + n_cs) // (fact(n_fs) * fact(n_cs))\n return ans\n\n\ns = input()\nans = 1\nif 'c' not in s and 'k' not in s:\n for (char, count) in rle(s):\n  if char in 'gf':\n   ans *= comb_count(count)\n print(ans)\nelse:\n print(0)", "from functools import lru_cache\n\n\ndef rle(s):\n if not s:\n  return s\n last = s[0]\n ans = []\n count = 1\n for curr in s[1:]:\n  if last != curr:\n   ans.append((last, count))\n   count = 1\n   last = curr\n  else:\n   count += 1\n else:\n  ans.append((last, count))\n return ans\n\n\n@lru_cache(maxsize=None)\ndef fact(n):\n if n < 3:\n  return max(1, n)\n return n * fact(n - 1)\n\n\ndef comb_count(n):\n ans = 0\n for repl_length in range(0, n + 1, 2):\n  n_fs = n - repl_length\n  n_cs = repl_length >> 1\n  ans += fact(n_fs + n_cs) // (fact(n_fs) * fact(n_cs))\n return ans\n\n\ns = input()\nans = 1\nif 'c' not in s and 'k' not in s:\n for (char, count) in rle(s):\n  if char in 'gf':\n   ans *= comb_count(count)\n print(ans)\nelse:\n print(0)", "# cook your dish here\ndef f(n):\n count = 1\n if n%2==0:\n  for i in range(1,n//2+1):\n   if i==n//2:\n    count+=1\n   else:\n    count+=n-i\n  return count\n else:\n  for i in range(1,n//2+1):\n   count+=n-i\n  return count\n \n \ns = input()\nc,count = 1,0\nlst = []\nif 'c' in s or 'k' in s:\n print(0)\n return\nfor i in range(len(s)-1):\n if s[i]==s[i+1]=='g':\n  count+=1\n elif s[i]==s[i+1]=='f':\n  count+=1\n else:\n  if count:\n   lst.append(count+1)\n   count = 0\nif count:\n lst.append(count+1)\n#print(lst)\nfor i in lst:\n c = c*(f(i))\n #print(f(i))\nprint(c)", "def fib(n): \n  \n F = [[1, 1], \n   [1, 0]] \n if (n == 0): \n  return 0\n power(F, n - 1) \n   \n return F[0][0] \n  \ndef multiply(F, M): \n  \n x = (F[0][0] * M[0][0] + \n   F[0][1] * M[1][0]) \n y = (F[0][0] * M[0][1] + \n   F[0][1] * M[1][1]) \n z = (F[1][0] * M[0][0] + \n   F[1][1] * M[1][0]) \n w = (F[1][0] * M[0][1] + \n   F[1][1] * M[1][1]) \n  \n F[0][0] = x \n F[0][1] = y \n F[1][0] = z \n F[1][1] = w \n   \n# Optimized version of \n# power() in method 4  \ndef power(F, n): \n \n if( n == 0 or n == 1): \n  return; \n M = [[1, 1], \n   [1, 0]]; \n   \n power(F, n // 2) \n multiply(F, F) \n   \n if (n % 2 != 0): \n  multiply(F, M)\n\ns=input()\nnr=len(s)\nM=1000000007\ncnt=1\ni=0\nwhile(i<nr):\n if(s[i]==\"c\" or s[i]==\"k\"):\n  cnt=0\n  break\n elif(s[i]==\"g\"):\n  val=1\n  i+=1\n  while(i<nr and s[i]==\"g\"):\n   i+=1\n   val+=1\n  if(val==1):\n   cnt=cnt\n  elif(val==2):\n   cnt=(cnt*2)%M\n  else:\n   val=fib(val+1)\n   cnt=(cnt*val)%M\n elif(s[i]==\"f\"):\n  val=1\n  i+=1\n  while(i<nr and s[i]==\"f\"):\n   i+=1\n   val+=1\n  if(val==1):\n   cnt=cnt\n  elif(val==2):\n   cnt=(cnt*2)%M\n  else:\n   val=fib(val+1)\n   cnt=(cnt*val)%M\n else:\n  i+=1\nprint(cnt)", "import random\nimport time\n\n\ndef get_input():\n # _ = int(input())\n inp_str = input()\n return inp_str\n\n\ndef get_nth_fibbo(n):\n a = 0\n b = 1\n # ndash = n\n while n > 0:\n  a, b = b, a+b\n  n -= 1\n # print(ndash, b)\n return b\n\n\ndef count_unique(inp_str):\n unique_count = 1\n if \"c\" in inp_str or \"x\" in inp_str:\n  return 0\n count_arr = []\n cur_chr = None\n cur_chr_len = 0\n for char in inp_str:\n  if cur_chr is None:\n   cur_chr = char\n   cur_chr_len = 1\n   continue\n  if char == cur_chr:\n   cur_chr_len += 1\n  else:\n   if cur_chr in [\"f\", \"g\"]:\n    count_arr.append(cur_chr_len)\n   cur_chr = char\n   cur_chr_len = 1\n if cur_chr in [\"f\", \"g\"]:\n  count_arr.append(cur_chr_len)\n # print(count_arr)\n for count in count_arr:\n  unique_count *= get_nth_fibbo(count)\n return unique_count\n\n\ndef test():\n n = random.randint(5, 10)\n ord_a = ord(\"e\")\n ord_z = ord(\"h\") + 1\n inp_str = \"\".join([\n  chr(random.randrange(ord_a, ord_z))\n  for _ in range(n)\n ])\n unique_count = count_unique(inp_str) % (10 ** 9 + 7)\n if unique_count > 10:\n  print(\"Input: {}\".format(inp_str))\n  print(\"Unique: {}\".format(unique_count))\n  time.sleep(2)\n\n\ndef stress_test():\n while True:\n  test()\n\n\ndef main():\n inp_str = get_input()\n r = count_unique(inp_str) % (10 ** 9 + 7)\n print(r)\n\n\ndef __starting_point():\n # stress_test()\n # test()\n main()\n\n'''\nfffff\ncfff\nccf\ncfc\nfcff\nfcc\nffcf\nfffc\n\n'''\n\n__starting_point()", "# cook your dish here\ns = input()\nif('c' in s or 'k' in s):\n print(0)\nelse:\n l1 = []\n pre = s[0]\n count = 1\n for i in s[1:]:\n  if pre == i and i in 'gf':\n   count +=1\n  else:\n   if count!=1:\n    l1.append(count)\n   count = 1\n  pre = i\n if(count > 1):\n  l1.append(count)\n ##print(l1)\n ans = 1\n for t in l1:\n  ans*= (t*t - 3*t + 6)/2\n print(int(ans))", "# cook your dish here\ns=input()\ndp=[1,1]\ncant=False\nif \"c\" in s or \"k\" in s:\n cant=True\nfor i in range(1,len(s)):\n if s[i]+s[i-1]==\"gg\" or s[i]+s[i-1]==\"ff\":\n  dp.append(dp[-1]+dp[-2])\n else:\n  dp.append(dp[-1])\n #print(s[i],dp[-1])\nif cant:\n print(0)\nelse:\n print(dp[-1]%(10**9+7))"]
["def path_finder(maze):\n    lst  = maze.split('\\n')\n    X, Y = len(lst)-1, len(lst[0])-1\n    seen = {(x,y) for x,row in enumerate(lst) for y,c in enumerate(row) if c=='W'} | {(0,0)}\n    end, bag, turn = (X,Y), {(0,0)}, 0\n    \n    while bag and end not in bag:\n        bag = { (a,b) for a,b in {(x+dx,y+dy) for x,y in bag for dx,dy in ((0,1), (0,-1), (1,0), (-1,0))}\n                      if 0 <= a <= X and 0 <= b <= Y} - seen\n        seen |= bag\n        turn += 1\n    \n    return bool(bag) and turn", "\"\"\"\nTask\n\nYou are at position [0, 0] in maze NxN and you can only move in one of the four cardinal directions\n(i.e. North, East, South, West). Return true if you can reach position [N-1, N-1] or false otherwise.\nEmpty positions are marked .. Walls are marked W. Start and exit positions are empty in all test cases.\n\"\"\"\n\n\ndef path_finder(maze):\n    maze_arr = maze_str_to_array(maze)\n    n = len(maze_arr)\n    start, goal = (0, 0), (n - 1, n - 1)\n    return ai_star(maze_arr, start, goal)\n\n\ndef bfs(maze_arr, start, goal):\n    \"\"\"\n    Implementation of breadth first search algorithm for solving maze problem\n    :param maze_arr: search space\n    :param start: starting node\n    :param goal: goal node\n    :return: True if goal can be reached\n    \"\"\"\n    from queue import Queue\n    to_be_expanded = Queue()\n    to_be_expanded.put(start)\n    tree = set()\n\n    while not to_be_expanded.empty():\n        node = to_be_expanded.get()\n        if node == goal:\n            return True\n        tree.add(node)\n        neighbors = get_node_neighbors(maze_arr, node)\n        for neighbor in neighbors:\n            if neighbor not in tree:\n                to_be_expanded.put(neighbor)\n    return False\n\n\ndef ai_star(maze_arr, start, goal):\n    \"\"\"\n    Implementation of A* algorithm for solving maze problem. Heap is used. The value passed to\n    a heap is a tuple containing priority (estimated cost) and cell coordinates.\n    :param maze_arr: search space\n    :param start: starting node\n    :param goal: goal node\n    :return: True if goal can be reached\n    \"\"\"\n    from heapq import heappush, heappop\n    to_be_expanded = []\n    heappush(to_be_expanded, (manhattan_distance(start, goal), 0, 0, start))\n    tree = set()\n\n    while to_be_expanded:\n        _, cost, real_cost, node = heappop(to_be_expanded)\n        if node == goal:\n            return real_cost\n        tree.add(node)\n        neighbors = get_node_neighbors(maze_arr, node)\n        for neighbor in neighbors:\n            if neighbor not in tree:\n                heappush(to_be_expanded, (cost + manhattan_distance(neighbor, goal), cost + 0.99, real_cost + 1, neighbor))\n    return False\n\n\ndef manhattan_distance(cell, goal):\n    \"\"\"\n    Computes manhattan distance from some cell to the goal.\n    :param cell: cell from where the distance is measured\n    :param goal: goal node\n    :return: absolute integer value of a manhattan distance\n    \"\"\"\n    return abs(cell[0] - goal[0]) + abs(cell[1] - goal[1])\n\n\ndef euclidean_distance(cell, goal):\n    \"\"\"\n    Computes euclidean distance from some cell to the goal.\n    :param cell: cell from where the distance is measured\n    :param goal: goal node\n    :return: absolute float value of a euclidean distance\n    \"\"\"\n    from math import sqrt\n    return sqrt((cell[0] - goal[0])**2 + (cell[1] - goal[1])**2)\n\n\ndef maze_str_to_array(maze):\n    \"\"\"\n    Function to convert string representation of a maze into multidimensional list. One (1) represents empty\n    field, zero (0) represents a wall (impenetrable field)\n    :param maze: string representation of a maze\n    :return: list representation of a maze.\n    \"\"\"\n    return [[1 if char == '.' else 0 for char in row] for row in maze.split('\\n')]\n\n\ndef get_node_neighbors(maze_arr, parent_node):\n    \"\"\"\n    Computes a list of SearchNodes with all valid neighbors (except walls and cells out of board)\n    :param maze_arr: a multidim list containing the maze\n    :param parent_node: a node for with neighbors are calculated\n    :return a list containing all possible neighbors\n    \"\"\"\n    n = len(maze_arr)\n    neighbors = []\n    x_0, y_0 = parent_node\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        x_1 = x_0 + dx\n        y_1 = y_0 + dy\n        if 0 <= x_1 < n and 0 <= y_1 < n and maze_arr[y_1][x_1] == 1:\n            neighbors.append((x_1, y_1))\n    return neighbors\n", "from math import hypot\nfrom heapq import *\n\nMOVES = ((0,1), (0,-1), (1,0), (-1,0))\n\ndef path_finder(maze):\n    maze = list(map(list, maze.split()))\n    X,Y  = end = len(maze)-1, len(maze[0])-1\n    q    = [(0,0,0,(0,0))]                    # (heuristic, isEnd, n steps, x, y)\n    \n    while q and not q[0][1]:\n        _,_,c,(x,y) = heappop(q)\n        c+=1\n        for dx,dy in MOVES:\n            pos = a,b = x+dx, y+dy\n            if 0<=a<=X and 0<=b<=Y and maze[a][b] != 'W':\n                maze[a][b] = 'W'\n                heappush(q, (c+X-a+Y-b, pos==end, c, pos))\n    \n    return q and q[0][1] and q[0][2] or 0", "def path_finder(maze):\n    matrix = list(map(list, maze.splitlines()))\n    n = len(matrix)-1\n    lst, lst2, count = [(0,0)], [], 0\n    while lst:\n        count += 1\n        while lst:\n            a, b = lst.pop()\n            matrix[a][b] = \"X\"\n            for i, j in (a+1,b),(a-1,b),(a,b+1),(a,b-1):\n                if 0 <= i <= n and 0 <= j <= n and matrix[i][j] == '.':\n                    if i == n and j == n:\n                        return count\n                    lst2.append((i,j))\n        lst, lst2 = list(set(lst2)), []\n    return False", "def path_finder(maze):\n    maze = list(map(list, maze.splitlines()))\n    lenmaze_y, lenmaze_x = len(maze), len(maze[0])\n    queue = [(0, 0, 0)]\n    \n    while queue:\n        y,x,cnt = queue.pop(0)        \n        if x >= 0 and y >= 0 and x < lenmaze_x and y < lenmaze_y:\n            if maze[y][x] == '.':\n                maze[y][x] = cnt\n                directions = [(1, 0),(0, 1),(-1, 0),(0, -1)]\n                for direction_y, direction_x in directions:\n                    queue.append((y + direction_y, x + direction_x, cnt+1))\n            if x == lenmaze_x-1 and y == lenmaze_y-1:\n                return maze[y][x]\n            \n    return False", "def path_finder(maze):\n    grid = maze.splitlines()\n    end = h, w = len(grid) - 1, len(grid[0]) - 1\n    bag, seen = {(0, 0): 0}, set()\n    while bag:\n        x, y = min(bag, key=bag.get)\n        rounds = bag.pop((x, y))\n        seen.add((x, y))\n        if (x, y) == end: return rounds\n        for u, v in (-1, 0), (0, 1), (1, 0), (0, -1):\n            m, n = x + u, y + v\n            if (m, n) in seen or not (0 <= m <= h and 0 <= n <= w) or grid[m][n] != '.': continue\n            new_rounds = rounds + 1\n            if new_rounds < bag.get((m, n), float('inf')): bag[m, n] = new_rounds\n    return False", "def path_finder(maze): #IMPLEMENTING BFS ALGORITHM\n    mtx = list(map(list, maze.splitlines())) #convert string to 2d array\n    R = len(mtx[0]) #number of rows or size of te mtx\n    mtx[R-1][R-1] = 'E' #define the exit as 'E'\n    sr, sc = 0, 0 #starting node\n    rq, cq = [], [] #empty queue for row and column\n    prev = [[' ']*(R) for x in range(R)]\n    \n    move_count = 0 \n    nodes_left_in_layer = 1\n    nodes_in_next_layer = 0\n    \n    reached_end = False # variable used to know if exit is reached\n    \n    visited = [[False]*(R) for x in range(R)] # Mtx to know if node visited \n    \n    dr = [-1, 1, 0, 0] # North, South, West direction vectors\n    dc = [0, 0, 1, -1] # North, South, West direction vectors\n    \n    rq.append(sr)\n    cq.append(sc)\n\n    visited[sr][sc] = True\n    while len(rq):\n        r = rq.pop(0)\n        c = cq.pop(0)\n\n        if mtx[r][c] == 'E':\n            reached_end = True #The end has been reached\n            return move_count\n\n        for i in range(4): #     explore_neighbours\n            rr = r + dr[i]\n            cc = c + dc[i]\n\n            if rr < 0 or cc< 0: continue\n            if rr >= R or cc >= R: continue\n            \n            if visited[rr][cc]: continue\n            if mtx[rr][cc] == 'W': continue\n            \n            rq.append(rr)\n            cq.append(cc)\n            visited[rr][cc] = True\n            prev[rr][cc] = [r,c] # keep track of the parent \n            nodes_in_next_layer += 1\n        nodes_left_in_layer -= 1\n        if nodes_left_in_layer == 0:\n            nodes_left_in_layer = nodes_in_next_layer\n            nodes_in_next_layer = 0\n            move_count += 1\n    if reached_end:\n        return move_count\n    else:\n        return False", "class Path:\n    \n    def __init__(self, maze, start, exit = None, pos = '.' ):\n        self.maze = maze\n        self.MAPd = {start:1}\n        self.exit = (exit or (len(maze)-1, len(maze[0])-1))\n        self.grow = None\n        self.pos  = pos\n        \n    def run_maze(self):\n        self.grow = self.len_\n        for x, floor in enumerate(self.maze):\n            for y, _ in enumerate(floor):\n                if self.maze[x][y]==self.pos and not self.MAPd.get((x,y)): self.mover(x,y, [])\n    \n    def mover(self, x, y, ways = []):\n        [not self.MAPd.get(e) or ways.append(self.MAPd[e]) for e in ((x-1,y),(x+1,y),(x,y-1),(x,y+1))]  \n        if ways: self.MAPd[(x,y)] = min(ways) + 1\n\n    @property\n    def len_(self): return len(self.MAPd)\n    \n    @property\n    def new_way_exist(self): return self.grow != self.len_\n        \n    @property\n    def get_exit(self): return self.MAPd.get(self.exit, 1) - 1\n        \n    \ndef path_finder(maze):\n    mazer = Path(maze.split('\\n'), (0,0))\n    \n    while mazer.new_way_exist:\n        mazer.run_maze()\n        \n    return mazer.get_exit", "def path_finder(maze):\n    maze = maze.split('\\n')\n    x_, y_ = len(maze)-1, len(maze[0])-1\n    \n    DMap, exit = {(0,0):1}, (x_, y_)\n    \n    while 1: \n        chkr = len(DMap)\n        for x, r in enumerate(maze):\n            for y, c in enumerate(r):\n                \n                if maze[x][y]=='.' and not DMap.get((x,y)):\n                    ways = []\n                    for e in ((x-1,y),(x+1,y),(x,y-1),(x,y+1)):\n                        (not DMap.get(e) or ways.append(DMap[e]))\n                        \n                    if ways:  DMap[(x,y)] = min(ways) + 1\n                        \n        if chkr == len(DMap): break\n\n    return DMap.get(exit, 1) - 1 \n", "def path_finder(maze):\n    \n    maze = maze.split('\\n')\n    inf = 2147483647 #infinity\n    n = len(maze) #maze order\n    distance_table = [[-1]*(n+2) for i in range(n+2)] #distance table with boundaries\n    \n    for i in range(n+2): #mark boundary\n        distance_table[0][i] = inf\n        distance_table[n+1][i] = inf\n        distance_table[i][0] = inf\n        distance_table[i][n+1] = inf\n        \n    distance_table[1][1] = 0 #start position\n    \n    queue = [(1,1)] #start with (1,1)\n    while queue: #while queue is not empty\n        i, j = queue.pop(0)\n        for x, y in (0,1),(0,-1),(-1,0),(1,0): #east-(0,1); west-(0,-1); north-(-1,0); south-(1,0)\n            p, q = i+x, j+y\n            if distance_table[p][q] < inf: #if its not boundary or a wall\n                if maze[p-1][q-1] == 'W': #if its a wall\n                    distance_table[p][q] = inf\n                elif distance_table[p][q] == -1 or distance_table[p][q] > distance_table[i][j]+1: #if the path is not visited or the path have longer distance\n                    distance_table[p][q] = distance_table[i][j]+1\n                    queue.append((p, q))\n    return False if distance_table[n][n] == -1 else distance_table[n][n]"]
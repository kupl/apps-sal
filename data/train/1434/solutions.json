["# cook your dish here\n# cook your dish here\nimport numpy as np\nn, s, q = [int(j) for j in input().split()]\nedges = [int(j)-1 for j in input().split()]\ncosts = [int(j) for j in input().split()]\nspecial = [int(j)-1 for j in input().split()]\nqueries = [[0] * 3 for _ in range(q)]\nfor i in range(q):\n   queries[i] = [int(j)-1 for j in input().split()]\n\nedge_set = [[] for _ in range(n)]\nfor i in range(n-1):\n   edge_set[i+1].append(edges[i])\n   edge_set[edges[i]].append(i+1)\n\nstored = np.zeros((s,n,1001),dtype=bool)\nvisited = [[] for _ in range(s)]\nfor i in range(s):\n   s_vertex = special[i]\n   s_cost = costs[s_vertex]\n   s_visited = visited[i]\n   s_visited.append(s_vertex)\n   s_stored = stored[i]\n   s_stored[s_vertex][0] = True\n   s_stored[s_vertex][s_cost] = True\n   for edge in edge_set[s_vertex]:\n      s_visited.append(edge)\n      s_stored[edge] = np.array(s_stored[s_vertex])\n   for j in range(1,n):\n      vertex = s_visited[j]\n      cost = costs[vertex]\n      s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001-cost],s_stored[vertex][cost:1001])\n      for edge in edge_set[vertex]:\n         if edge not in s_visited:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[vertex])\n\nfor i in range(q):\n   first, second, max_cost = queries[i]\n   bool_array = np.zeros(max_cost+2,dtype=bool)\n   for j in range(s):\n      bool_array = np.logical_or(bool_array,np.logical_and(stored[j][first][:max_cost+2],stored[j][second][:max_cost+2]))\n   for j in range(max_cost+1,-1,-1):\n      if bool_array[j]:\n         print(2 * j)\n         break", "# cook your dish here\nimport numpy as np\nn, s, q = [int(j) for j in input().split()]\nedges = [int(j)-1 for j in input().split()]\ncosts = [int(j) for j in input().split()]\nspecial = [int(j)-1 for j in input().split()]\nqueries = [[0] * 3 for _ in range(q)]\nfor i in range(q):\n   queries[i] = [int(j)-1 for j in input().split()]\n\nedge_set = [[] for _ in range(n)]\nfor i in range(n-1):\n   edge_set[i+1].append(edges[i])\n   edge_set[edges[i]].append(i+1)\n\nstored = np.zeros((s,n,1001),dtype=bool)\nvisited = [[] for _ in range(s)]\nfor i in range(s):\n   s_vertex = special[i]\n   s_cost = costs[s_vertex]\n   s_visited = visited[i]\n   s_visited.append(s_vertex)\n   s_stored = stored[i]\n   s_stored[s_vertex][0] = True\n   s_stored[s_vertex][s_cost] = True\n   for edge in edge_set[s_vertex]:\n      s_visited.append(edge)\n      s_stored[edge] = np.array(s_stored[s_vertex])\n   for j in range(1,n):\n      vertex = s_visited[j]\n      cost = costs[vertex]\n      s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001-cost],s_stored[vertex][cost:1001])\n      for edge in edge_set[vertex]:\n         if edge not in s_visited:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[vertex])\n\nfor i in range(q):\n   first, second, max_cost = queries[i]\n   bool_array = np.zeros(max_cost+2,dtype=bool)\n   for j in range(s):\n      bool_array = np.logical_or(bool_array,np.logical_and(stored[j][first][:max_cost+2],stored[j][second][:max_cost+2]))\n   for j in range(max_cost+1,-1,-1):\n      if bool_array[j]:\n         print(2 * j)\n         break"]
["import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nprimes = []\nprime = [True] * (10 ** 6  +5)\nprime[0] = False\n\nfor i in range(2, 10 ** 6):\n    if prime[i]:\n        for j in range(2 * i, 10 ** 6 + 5, i):\n            prime[j] = False\n\npref = [0]\nfor i in range(1, 10 ** 6 + 5):\n    pref.append(pref[-1])\n    if prime[i]:\n        pref[-1] += 1\n    s = round(i ** .5)\n    if  s * s == i and prime[s] and i != 1:\n        pref[-1] -= 1\n\nn = int(input())\nl = list(map(int, input().split()))\nout = []\nfor v in l:\n    out.append(pref[v])\nprint('\\n'.join(map(str,out)))\n", "import os\nimport sys\nfrom io import BytesIO, IOBase\n \n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\"\"\"\nNew numbers are only lonely if prime.\nWhen does a prime stop being lonely\n\n\"\"\"\n\ndef get_p(n):\n    \"\"\" Returns  a list of primes < n \"\"\"\n    z = int(n**0.5)+1\n    for s in range(4,len(sieve),2):\n        sieve[s] = False\n    for i in range(3,z,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n            if i <= 1000:\n                sq_primes.add(i*i)\n    return\n\nlim = 10**6\nsieve = [True]*(lim+1)\nsq_primes = set()\nsq_primes.add(4)\nget_p(lim+1)\nans = [0,1]\nfor i in range(2,10**6+1):\n    tmp = ans[-1]\n    if sieve[i]:\n        tmp += 1\n    elif i in sq_primes:\n        tmp -= 1\n    ans.append(tmp) \n\n\ndef solve():\n    T = int(input().strip())\n    A = [int(s) for s in input().split()]\n    print(*[ans[A[j]] for j in range(T)])\n    return \nsolve()\n#print(time.time()-start_time)\n", "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------------------\n \ndef RL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef print_list(l):\n    print(' '.join(map(str,l)))\n# import sys\n# sys.setrecursionlimit(5010)\n# from heapq import *\n# from collections import deque as dq\nfrom math import ceil,floor,sqrt,pow\n# import bisect as bs\n# from collections import Counter\n# from collections import defaultdict as dc \n\ndef judgePrime(n):\n    if n < 2:\n        return []     \n    else:\n        output = [1] * n\n        output[0],output[1] = 0,0\n        for i in range(2,int(n**0.5)+1): \n            if output[i] == 1:\n                output[i*i:n:i] = [0] * len(output[i*i:n:i])\n    return output\n\nprime = judgePrime(1000005)\ns = [0]\nfor i in range(1,1000005):\n    s.append(s[-1]+prime[i])\n\nt = N()\na = RL()\nfor n in a:\n    print(s[n]-s[int(sqrt(n))]+1)\n", "import sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n\n\nMAXPRIME=10**6\nisPrime=[0 for _ in range(MAXPRIME+1)]\nisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\nfor i in range(2,MAXPRIME//2+1):\n    if isPrime[i]==0: #i is prime\n        for multiple in range(i*i,MAXPRIME+1,i):\n            if isPrime[multiple]==0:\n                isPrime[multiple]=i         \nprimeNumberSet=set()\nfor i in range(len(isPrime)):\n    if isPrime[i]==0:\n        primeNumberSet.add(i)\nprimes=sorted(list(primeNumberSet))\n\nlookupTable=[None for _ in range(MAXPRIME+1)]\n\npIdx=-1\npSqRtIdx=-1\nfor i in range(1,MAXPRIME+1):\n    while pIdx+1<len(primes) and primes[pIdx+1]<=i:\n        pIdx+=1\n    while pSqRtIdx+1<len(primes) and (primes[pSqRtIdx+1])**2<=i:\n        pSqRtIdx+=1\n    total=(pIdx+1)-(pSqRtIdx+1)+1 #1 is always lonely\n    lookupTable[i]=total\n\n#print(lookupTable[:30])\n\n#a number is lonely if its gcd with all other numbers is 1. i.e. it is prime and its square > n. also, 1 is always lonely\nt=int(input())\nn=[int(x) for x in input().split()]\nfor nn in n:\n    print(lookupTable[nn])\n\n\n\n\n#def gcd(x, y):\n#    while y != 0:\n#        (x, y) = (y, x % y)\n#    return x\n#lonely=[]\n#for i in range(1,n+1):\n#    ok=False\n#    for j in range(1,n+1):\n#        g=gcd(i,j)\n#        a=g\n#        b=i//g\n#        c=j//g\n#        if a+b>c and b+c>a and a+c>b:\n#            ok=True\n#            if i in primeNumberSet:\n#                print(i,j)\n#            break\n#    if ok==False:\n#        lonely.append(i)\n#print(lonely)\n", "import sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n\nMAXPRIME=10**6\nisPrime=[0 for _ in range(MAXPRIME+1)]\nisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\nfor i in range(2,MAXPRIME//2+1):\n    if isPrime[i]==0: #i is prime\n        for multiple in range(i*i,MAXPRIME+1,i):\n            if isPrime[multiple]==0:\n                isPrime[multiple]=i         \nprimeNumberSet=set()\nfor i in range(len(isPrime)):\n    if isPrime[i]==0:\n        primeNumberSet.add(i)\nprimes=sorted(list(primeNumberSet))\n\nlookupTable=[None for _ in range(MAXPRIME+1)]\n\npIdx=-1\npSqRtIdx=-1\nfor i in range(1,MAXPRIME+1):\n    while pIdx+1<len(primes) and primes[pIdx+1]<=i:\n        pIdx+=1\n    while pSqRtIdx+1<len(primes) and (primes[pSqRtIdx+1])**2<=i:\n        pSqRtIdx+=1\n    total=(pIdx+1)-(pSqRtIdx+1)+1 #1 is always lonely\n    lookupTable[i]=total\n\n#print(lookupTable[:30])\n\n#a number is lonely if its gcd with all other numbers is 1. i.e. it is prime and its square > n. also, 1 is always lonely\nt=int(input())\nn=[int(x) for x in input().split()]\nans=[str(lookupTable[nn]) for nn in n]\nprint('\\n'.join(ans))", "import sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n\nMAXPRIME=10**6\nisPrime=[0 for _ in range(MAXPRIME+1)]\nisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\nfor i in range(2,MAXPRIME//2+1):\n    if isPrime[i]==0: #i is prime\n        for multiple in range(i*i,MAXPRIME+1,i):\n            if isPrime[multiple]==0:\n                isPrime[multiple]=i         \nprimeNumberSet=set()\nfor i in range(len(isPrime)):\n    if isPrime[i]==0:\n        primeNumberSet.add(i)\nprimes=sorted(list(primeNumberSet))\n\nlookupTable=[None for _ in range(MAXPRIME+1)]\n\npIdx=-1\npSqRtIdx=-1\nfor i in range(1,MAXPRIME+1):\n    while pIdx+1<len(primes) and primes[pIdx+1]<=i:\n        pIdx+=1\n    while pSqRtIdx+1<len(primes) and (primes[pSqRtIdx+1])**2<=i:\n        pSqRtIdx+=1\n    total=(pIdx+1)-(pSqRtIdx+1)+1 #1 is always lonely\n    lookupTable[i]=total\n\n#print(lookupTable[:30])\n\n#a number is lonely if its gcd with all other numbers is 1. i.e. it is prime and its square > n. also, 1 is always lonely\nt=int(input())\nn=[int(x) for x in input().split()]\nprint('\\n'.join([str(lookupTable[nn]) for nn in n]))", "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nMAXPRIME=10**6\nisPrime=[0 for _ in range(MAXPRIME+1)]\nisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\nfor i in range(2,MAXPRIME//2+1):\n    if isPrime[i]==0: #i is prime\n        for multiple in range(i*i,MAXPRIME+1,i):\n            if isPrime[multiple]==0:\n                isPrime[multiple]=i         \nprimeNumberSet=set()\nfor i in range(len(isPrime)):\n    if isPrime[i]==0:\n        primeNumberSet.add(i)\nprimes=sorted(list(primeNumberSet))\n\nlookupTable=[None for _ in range(MAXPRIME+1)]\n\npIdx=-1\npSqRtIdx=-1\nfor i in range(1,MAXPRIME+1):\n    while pIdx+1<len(primes) and primes[pIdx+1]<=i:\n        pIdx+=1\n    while pSqRtIdx+1<len(primes) and (primes[pSqRtIdx+1])**2<=i:\n        pSqRtIdx+=1\n    total=(pIdx+1)-(pSqRtIdx+1)+1 #1 is always lonely\n    lookupTable[i]=total\n\n#print(lookupTable[:30])\n\n#a number is lonely if its gcd with all other numbers is 1. i.e. it is prime and its square > n. also, 1 is always lonely\nt=int(input())\nn=[int(x) for x in input().split()]\nprint('\\n'.join([str(lookupTable[nn]) for nn in n]))", "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# ------------------- fast io --------------------\nfrom bisect import bisect_left as bsl;import math\ndef sieve(n): \n    prime = [True for i in range(n + 1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * 2, n + 1, p): \n                prime[i] = False\n        p += 1\n    prime[0]= False\n    prime[1]= False\n    pp=[]\n    for p in range(n + 1): \n        if prime[p]: \n            pp.append(p)\n    return pp\nprimes=sieve(10**6)\nt=int(input());vals=list(map(int,input().split()))\nfor j in range(t):\n    n=vals[j]\n    ind1=min(bsl(primes,math.floor(math.sqrt(n))),len(primes)-1)\n    ind2=min(bsl(primes,n),len(primes)-1)\n    if primes[ind1]>math.floor(math.sqrt(n)):\n        ind1-=1\n    if primes[ind2]>n:\n        ind2-=1\n    print(ind2+1-ind1)", "\"\"\"\n    Author - Satwik Tiwari .\n    27th Sept , 2020  - Sunday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\n\n\n\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\n\n# from itertools import *\nfrom heapq import *\n# from math import gcd, factorial,floor,ceil\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\n# from collections import Counter as counter  # Counter(list)  return a dict with {key: count}\n# from itertools import combinations as comb # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\n# from itertools import permutations as permutate\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\nmod = 10**9+7\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return list(map(int, inp().split()))\ndef strsep(): return list(map(str, inp().split()))\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#===============================================================================================\n# code here ;))\nans = [0]*(10**6+5)\n\ndef sieve(a): #O(n loglogn) nearly linear\n    #all odd mark 1\n    for i in range(3,((10**6)+5),2):\n        a[i] = 1\n    #marking multiples of i form i*i 0. they are nt prime\n    for i in range(3,((10**6)+5),2):\n        for j in range(i*i,((10**6)+5),i):\n            a[j] = 0\n    a[2] = 1 #special left case\n    return (a)\n\n\na = [0]*((10**6)+6)\na = sieve(a)\nprimes = []\nfor i in range(10**6+1):\n    if(a[i]):\n        primes.append(i)\n\n# primes = primes[1:]\n# print(ans[:20])\n\n\nfor i in primes:\n    ans[i] += 1\n    ans[min(10**6+2,i*i)] -=1\n\n# print(ans[:20])\nfor i in range(2,10**6+1):\n    ans[i] +=ans[i-1]\n\n# print(ans[:20])\n\n\ndef solve(case):\n    n = int(inp())\n    aa = lis()\n    print('\\n'.join(str(ans[i]+1) for i in aa))\n\n\n\n\ntestcase(1)\n# testcase(int(inp()))\n", "import sys\ninput = sys.stdin.buffer.readline\nn = int(input())\na = list(map(int,input().split()))\nn = max(a)+1\nspf = [i for i in range(n)]\nfor i in range(4,n,2): spf[i] = 2\nfor i in range(3,int(n**.5)+1,2):\n    if spf[i]!=i:continue\n    for j in range(i*i, n, i):\n        if spf[j]==j:spf[j] = i\ncnt = 0\ndp = [0]*n\nfor i in range(1,n):\n    if spf[i]==i: cnt+=1\n    dp[i] = cnt\ndef query(n):\n    return dp[n]-dp[int(n**.5)]+1\nprint(\"\\n\".join(str(dp[n]-dp[int(n**.5)]+1) for n in a))\n", "import sys\nimport os\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n################################# fast IO ###############################\n\n\n\ninput = sys.stdin.buffer.readline\nn = int(input())\na = list(map(int,input().split()))\nn = max(a)+1\nspf = [i for i in range(n)]\nfor i in range(4,n,2): spf[i] = 2\nfor i in range(3,int(n**.5)+1,2):\n    if spf[i]!=i:continue\n    for j in range(i*i, n, i):\n        if spf[j]==j:spf[j] = i\ncnt = 0\ndp = [0]*n\nfor i in range(1,n):\n    if spf[i]==i: cnt+=1\n    dp[i] = cnt\nprint(\"\\n\".join(str(dp[n]-dp[int(n**.5)]+1) for n in a))\n", "import os,io\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nn = 10**6+1\nprimes = [1]*n\nprimes[0],primes[1] = 0,0\nv = int(n**0.5)+1\nfor i in range(2,v):\n    if primes[i]:\n        for j in range(i*i,n,i):\n            primes[j]=0\nfor i in range(1,n):\n    primes[i]+=primes[i-1]\n\ncases = int(input())\nfor t in range(cases):\n    n1 = list(map(int,input().split()))\n    for ni in n1:\n        print(primes[ni]-primes[int(ni**0.5)]+1)"]
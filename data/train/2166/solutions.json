["f = lambda: list(map(int, input().split()))[1:]\nn = int(input())\ns, p, q = [], [], []\nfor x in [0, 1]:\n    r = f()\n    s.append(r)\n    t = [len(r)] * n\n    t[0] = 0\n    p.append(t)\n    q.append((x, 0))\nwhile q:\n    x, i = q.pop()\n    y = 1 - x\n    for d in s[y]:\n        j = (i - d) % n\n        if p[y][j] < 1: continue\n        p[y][j] = -1\n        for d in s[x]:\n            k = (j - d) % n\n            if p[x][k] < 1: continue\n            p[x][k] -= 1\n            if p[x][k] == 0: q.append((x, k))\nfor x in [0, 1]:\n    print(*[['Lose', 'Loop', 'Win'][min(q, 1)] for q in p[x][1:]])", "class T:\n    h = ('Lose', 'Loop', 'Win')\n    def __init__(t):\n        t.s = list(map(int, input().split()))[1:]\n        t.p = [len(t.s)] * n\n        t.p[0] = 0\n    def f(t, i):\n        for d in t.s:\n            j = (i - d) % n\n            if t.p[j] > 0: yield j\n    def g(t):\n        print(*[t.h[min(q, 1)] for q in t.p[1:]])\nn = int(input())\nr, m = T(), T()\nq = [(r, m, 0), (m, r, 0)]\nwhile q:\n    x, y, i = q.pop()\n    for j in y.f(i):\n        y.p[j] = -1\n        for k in x.f(j):\n            x.p[k] -= 1\n            if not x.p[k]: q.append((x, y, k))\nr.g()\nm.g()", "\nRESULT = ['Lose', 'Loop', 'Win']\n\nclass Player(object):\n    \"\"\"docstring for Player\"\"\"\n    def __init__(self):\n        super(Player, self).__init__()\n        self.a = list(map(int, input().split()))[1:]\n        self.f = [len(self.a)] * n\n        self.f[0] = 0\n\n    def prev(self, i):\n        for x in self.a:\n            if self.f[(i - x) % n] > 0:\n                yield (i - x) % n\n\n    def print_result(self):\n        print(*[RESULT[min(x, 1)] for x in self.f[1:]])\n\nn = int(input())\na, b = Player(), Player()\nq = [(a, b, 0), (b, a, 0)]\nwhile q:\n    x, y, i = q.pop()\n    for j in y.prev(i):\n        y.f[j] = -1\n        for k in x.prev(j):\n            x.f[k] -= 1\n            if x.f[k] == 0:\n                q.append((x, y, k))\n\na.print_result()\nb.print_result()", "import sys\n#range = xrange\n#input = raw_input\n\nn = int(input())\nk1,*A = [int(x) for x in input().split()]\nk2,*B = [int(x) for x in input().split()]\n\nDPA = [None]*n\nDPA[0] = False\ncounterA = [k1]*n\ncounterA[0] = -1\n\nDPB = [None]*n\nDPB[0] = False\ncounterB = [k2]*n\ncounterB[0] = -1\n\n\nQA = [0]\nQB = [0]\nwhile QA or QB:\n    while QA:\n        i = QA.pop() \n        if DPA[i] == False:\n            for b in B:\n                if i!=b:\n                    if not DPB[i-b]:\n                        QB.append((i-b)%n)\n                    DPB[i-b] = True\n        elif DPA[i]:\n            for b in B:\n                counterB[i-b] -= 1\n                if not counterB[i-b]:\n                    #assert(DPB[i-b]==None)\n                    DPB[i-b] = False\n                    QB.append((i-b)%n)\n    \n    while QB:\n        i = QB.pop() \n        if DPB[i] == False:\n            for a in A:\n                if i!=a:\n                    if not DPA[i-a]:\n                        QA.append((i-a)%n)\n                    DPA[i-a] = True\n        elif DPB[i]:\n            for a in A:\n                counterA[i-a] -= 1 \n                if not counterA[i-a]:\n                    #assert(DPA[i-a]==None)\n                    DPA[i-a] = False\n                    QA.append((i-a)%n)\n\ndef f(x):\n    if x==None:\n        return 'Loop'\n    if x:\n        return 'Win'\n    return 'Lose'\n\nprint(*[f(x) for x in DPA[1:]])\nprint(*[f(x) for x in DPB[1:]])"]
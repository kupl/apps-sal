["class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        \n        from collections import deque\n        \n        queue = deque()\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell == 1:\n                    queue.append((i, j, None, None))\n        \n        dist = {}\n        while queue:\n            \n            i, j, previ, prevj = queue.popleft()\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n                continue\n            if (i, j) not in dist:\n                dist[(i, j)] = 1 + dist.get((previ, prevj), -1)\n                # if previ is None and prevj is None:\n                #     dist[(i, j)] = 0\n                # else:\n                #     dist[(i, j)] = 1 + dist[(previ, prevj)]\n                for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                    newi, newj = i +di, j + dj\n                    queue.append((newi, newj, i, j))\n        \n        ans = max(list(dist.values()), default=-1)\n        return ans if ans != 0 else -1\n                \n            \n            \n", "from queue import PriorityQueue\n\nclass Solution:\n    def isInRange(self, grid, x, y):\n        return (0 <= x and x < len(grid[0])) and (0 <= y and y < len(grid))\n\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        q = PriorityQueue()\n        visited = dict()\n        maxDist = 0\n        toVisit = [(-1, 0), (0, 0), (1, 0), (0, 1), (0, -1)]\n        \n        for x, i in enumerate(grid):\n            for y, j in enumerate(i):\n                if j is not 0:\n                    q.put((0, (x, y)))\n                    visited[(x, y)] = True\n                    \n        if (q.qsize() >= len(grid[0]) * len(grid) or q.qsize() is 0):\n            return -1\n                    \n        while not q.empty():\n            item = q.get()\n            maxDist = max(maxDist, item[0])\n            \n            for p in toVisit:\n                x = p[0] + item[1][0]\n                y = p[1] + item[1][1]\n                \n                if self.isInRange(grid, x, y) and visited.get((x, y)) is not True:\n                    visited[(x, y)] = True\n                    q.put((item[0] + 1, (x, y)))\n            \n        return maxDist", "class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[math.inf] * n for _ in range(m)]\n        land = water = 0\n\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:\n                    dp[i][j] = 0\n                    land += 1\n                else:\n                    water += 1\n\n        if not land or not water:\n            return -1\n\n        def process(dp):\n            for i in range(m):\n                for j in range(n):\n                    if i:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                    if j:\n                        dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n\n        process(dp)\n        dp = dp[::-1]\n        process(dp)\n        dp = [row[::-1] for row in dp]\n        process(dp)\n        dp = dp[::-1]\n        process(dp)\n\n        return max(max(row) for row in dp)\n"]
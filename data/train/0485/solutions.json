["class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        record = [0] * n\n        flip = 0\n        ans = 0\n        for i in range(n):\n            if i >= K: flip -= record[i-K]\n            if A[i] == (flip % 2):\n                if i > n - K: return -1\n                ans += 1\n                flip += 1\n                record[i] = 1\n        return ans\n", "\nclass Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        l = len(A)\n        flipped = [0] * l\n        res = 0\n        flipping_count = 0\n        for i in range(l):\n            if i >= K:\n                flipping_count -= flipped[i - K]\n            if (flipping_count % 2 == 0 and A[i] == 0) or (flipping_count % 2 == 1 and A[i] == 1):\n                if i + K > l:\n                    return -1\n                flipped[i] += 1\n                flipping_count += 1\n                res += 1\n                \n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flip_pos = 0\n        flip_inds = []\n        for i in range(len(A)):\n            # find the correct current bit based on prior flips\n            while flip_pos < len(flip_inds) and i - K + 1 > flip_inds[flip_pos]:\n                flip_pos += 1\n                \n            cur_bit = A[i] ^ ((len(flip_inds) - flip_pos) % 2 != 0)\n            \n            if i > len(A) - K:\n                if cur_bit == 0:\n                    return -1\n            else:\n                if not cur_bit:\n                    flip_inds.append(i)\n                \n        return len(flip_inds)", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        ans=flip=0\n        N=len(A)\n        hint=[0]*N\n        for i,x in enumerate(A):\n            flip^=hint[i]\n            if x^flip==0:\n                ans+=1\n                if i+K>N: return -1\n                flip^=1\n                if i+K<N: hint[i+K]^=1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n        k_bit_flip_end_indices = deque()\n        switch = 0\n        flips = 0\n        for i, bit in enumerate(A):\n            if (len(k_bit_flip_end_indices) & 1) ^ bit == 0:\n                flips += 1\n                k_bit_flip_end_indices.append(i+k-1)\n            if k_bit_flip_end_indices and i == k_bit_flip_end_indices[0]:\n                k_bit_flip_end_indices.popleft()\n        return flips if not k_bit_flip_end_indices else -1", "class Solution:\n    def minKBitFlips(self, A, K):\n        cur = res = 0\n        for i in range(len(A)):\n            if i >= K and A[i - K] == 2:\n                cur -= 1\n            if (cur % 2) == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] = 2\n                cur, res = cur + 1, res + 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        count = 0\n        stack = []\n        for i in range(len(A)):\n            if stack and i == stack[0]: \n                stack.pop(0)\n            if A[i] == len(stack)%2:\n                if i+ K > len(A): return -1\n                count += 1\n                stack.append(i+K)\n\n        return count \n        \n#         start = count = 0\n#         while  start < len(A):\n#             if not A[start]:\n#                 if start + K > len(A): return -1\n#                 for i in range(start, start+K):\n#                     A[i] = 1 - A[i]\n#                 count += 1\n#             start += 1\n#         return count\n            \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        total_flips = 0\n        current_effective_flips = 0\n        flip_indices = []\n\n        for current_index, elem in enumerate(A):\n            if (flip_indices and current_index == flip_indices[0] + K):\n                flip_indices.pop(0)\n                current_effective_flips -= 1\n\n            if self.needs_flip(elem, current_effective_flips):\n                if current_index + K > len(A):\n                    return -1\n                flip_indices.append(current_index)\n                current_effective_flips += 1\n                total_flips += 1\n        return total_flips\n\n    def needs_flip(self, elem, current_effective_flips):\n        return ((elem == 0 and current_effective_flips % 2 == 0) or\n                (elem == 1 and current_effective_flips % 2 != 0))", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        store = [0] * len(A)\n        ans = flip = 0\n        \n        \n        for i, x in enumerate(A):\n            flip ^= store[i]\n            if x ^ flip == 0:\n                ans += 1\n                if i+K > len(A):\n                    return -1\n                flip ^= 1\n                if i + K < len(A):\n                    store[i+K] ^= 1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        count = 0\n        stack = []\n        for i in range(len(A)):\n            if stack and i == stack[0]: stack.pop(0)\n            if A[i] == len(stack)%2:\n                if i+ K > len(A): return -1\n                count += 1\n                stack.append(i+K)\n\n        return count \n        \n#         start = count = 0\n#         while  start < len(A):\n#             if not A[start]:\n#                 if start + K > len(A): return -1\n#                 for i in range(start, start+K):\n#                     A[i] = 1 - A[i]\n#                 count += 1\n#             start += 1\n#         return count\n            \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        nums = A\n        flip_count = 0\n        flip_hint = [0] * len(nums)\n        total_flips = 0\n        \n        for i, n in enumerate(nums):\n            if i >= K and flip_hint[i-K]:\n                total_flips -= 1\n            \n            if total_flips % 2 == n:\n                if i + K > len(nums):\n                    return -1\n                \n                total_flips += 1\n                flip_hint[i] = 1\n                flip_count += 1\n                \n        return flip_count\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        ans = 0\n        flips = 0\n        addon = 6\n        m = False\n        for i in range(n):\n            if A[i] > 5:\n                m = True\n                A[i] -= addon\n            if (flips % 2 == 0 and A[i] == 0) or (flips % 2 != 0 and A[i] == 1):\n                ans += 1\n                if i + K > n: return -1\n                A[i+K-1] += addon\n                flips += 1\n            if m or A[i] > 5:\n                flips -= 1\n                A[i] -= addon\n                m = False\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        res = 0\n        flip = 0\n        for i in range(len(A)):\n            if flip % 2 != 0:\n                if A[i] % 10:\n                    res += 1\n                    flip += 1\n                    if (i + K - 1) >= len(A):\n                        return -1\n                    A[i + K - 1] += 10\n            else:\n                if not A[i] % 10:\n                    res += 1\n                    flip += 1\n                    if (i + K -1) >= len(A):\n                        return -1\n                    A[i+K-1] += 10\n            if flip > 0 and A[i] > 1:\n                flip -= 1\n            \n            \n        return res", "from collections import deque\nclass Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        s = deque()\n        count = 0\n        for i in range(len(A)):\n            while s and s[0] + K <= i:\n                s.popleft()\n            flip = len(s) % 2 == 1\n            ok = flip ^ A[i]\n            if not ok:\n                if i + K > len(A):\n                    return -1\n                s.append(i)\n                count += 1\n        return count\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        hint = [0] * N\n        ans = flip = 0\n\n        # When we flip a subarray like A[i], A[i+1], ..., A[i+K-1]\n        # we can instead flip our current writing state, and put a hint at\n        # position i+K to flip back our writing state.\n        for i, x in enumerate(A):\n            flip ^= hint[i]\n            if x ^ flip == 0:  # If we must flip the subarray starting here...\n                ans += 1  # We're flipping the subarray from A[i] to A[i+K-1]\n                if i+K > N: return -1  # If we can't flip the entire subarray, its impossible\n                flip ^= 1  \n                if i+K < N: hint[i + K] ^= 1\n\n        return ans\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur = res = 0\n        for i in range(len(A)):\n            if i >= K and A[i - K] == 2:\n                cur -= 1\n            if (cur % 2) == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] = 2\n                cur, res = cur + 1, res + 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n        \n        flipped = collections.deque()\n        \n        # Greedy\n        # 1. Never flip a 1\n        # 2. Try flipping every 0\n        \n        flips = 0\n        for i in range(len(A)):\n            \n            if flipped and flipped[0] < i:\n                flipped.popleft()\n                \n            if (not (len(flipped)&1) - A[i]):\n                if i <= len(A) - k:\n                    flips += 1\n                    flipped.append(i+k-1)\n                else:\n                    return -1\n        \n        return flips", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        hint = [0] * N # Keeps track of whether there has been at least one flip at given index\n        counter = 0 # Total flips\n        flip = 0 # Whether we are looking at a flipped array or not (follow code in for loop, e.g. 1011)\n        for i, x in enumerate(A):\n            # Check if bit is known to be flipped. If it is flipped and we are looking at a flipped bit, then we can simply set flip to 0\n            flip = (flip + hint[i]) % 2\n        \n        # If x is 1 and flipped or x is 0 and unflipped, then it is 0, so we need to flip the bit.\n            if (x == 1 and flip == 1) or (x == 0 and flip == 0):\n                counter += 1  # Add to the flip counter\n                \n                # Check if K-bit flip goes past end of array.\n                if i+K > N:\n                    return -1\n                \n                # We flipped, so we change our flip value for the next iteration of the loop\n                flip = 1-flip\n                \n                # \n                if i+K < N:\n                    hint[i + K] = 1\n\n        return counter\n                \n", "class Solution:\n    def minKBitFlips(self, A, K):\n        cur, res, n = 0, 0, len(A)\n        for i in range(0,len(A)):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1\n            if cur & 1 ^ A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        count = 0\n        flippings = [False for _ in A]\n        flipped = False\n        for i in range(len(A)):\n            if flippings[i]:\n                flipped = not flipped\n            if (not flipped and A[i] == 0) or (flipped and A[i] == 1):\n                count += 1\n                flipped = not flipped\n                if i + K > len(A):\n                    return -1\n                if i + K < len(flippings):\n                    flippings[i + K] = True\n                \n                \n        return count\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        hint = [0] * N\n        ans = flip = 0\n\n        # when we flip a subarray like A[i], A[i+1], .., A[i+K-1]\n        # we can instead flip our current writing state, and put a hint at position i+K to flip back\n        # our writing state\n        for i, x in enumerate(A):\n            flip ^= hint[i]\n\n            # if we must flip the subarray starting here...\n            if x ^ flip == 0:\n                ans += 1\n\n                if i + K > N: return -1\n\n                flip ^= 1\n                if i + K < N: hint[i + K] ^= 1\n\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = 0\n        q = deque()\n        for i, x in enumerate(A):\n            if q and q[0] == i:\n                q.popleft()\n            if len(q) & 1:\n                x ^= 1\n            if x == 0:\n                flips += 1\n                q.append(i + K)\n                if i + K > len(A):\n                    return -1\n        return flips", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        hint = [0] * N\n        ans = flip = 0\n\n        # When we flip a subarray like A[i], A[i+1], ..., A[i+K-1]\n        # we can instead flip our current writing state, and put a hint at\n        # position i+K to flip back our writing state.\n        for i, x in enumerate(A):\n            flip ^= hint[i]\n            if x ^ flip == 0:  # If we must flip the subarray starting here...\n                ans += 1  # We're flipping the subarray from A[i] to A[i+K-1]\n                if i+K > N: return -1  # If we can't flip the entire subarray, its impossible\n                flip ^= 1  \n                if i+K < N: hint[i + K] ^= 1\n\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur, res, n = 0, 0, len(A)\n        for i in range(len(A)):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1\n            if cur & 1 ^ A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        flip = 0\n        current_flips = 0\n        queue = []\n        for i in range(n):\n\n            if len(queue)>0 and queue[0] + K == i:\n                queue.pop(0)\n                current_flips = current_flips - 1\n                \n            if (A[i] == 0 and current_flips %2 == 0) or (A[i] == 1 and current_flips %2 != 0):\n                if i + K > n:\n                    return -1\n                queue.append(i)\n                current_flips = current_flips +1\n                flip = flip + 1\n\n        return flip", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur = res = 0\n        for i in range(len(A)):\n            if i >= K and A[i - K] == 2:\n                cur -= 1\n            if cur % 2 == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] = 2\n                cur, res = cur + 1, res + 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = deque()\n        count = 0\n        flips = 0\n        \n        for i in range(len(A)):\n            if i > 0:\n                x = flipped.popleft() if i >= K else 0\n                count -= x\n\n            if (A[i] + count) % 2 == 0:\n                count += 1\n                flipped.append(True)\n                flips += 1\n            else:\n                flipped.append(False)\n                \n        return flips if not any(list(flipped)[1:]) else -1", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        num = 0\n        for a in A:\n            num = (num << 1) + a\n        \n        i = 0\n        pattern = (1 << K) - 1\n        flips = 0\n        while i + K <= len(A):\n            while i + K <= len(A) and (num & (1 << i)):\n                i += 1\n            \n            if i + K > len(A):\n                break\n                \n            num ^= pattern << i\n            flips += 1\n            i += 1\n        \n        if num == (1 << len(A)) - 1:\n            return flips\n        return -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n        q = collections.deque()\n        res = 0\n        for i in range(len(A)):\n            if len(q) % 2 == 0:\n                if A[i] == 0:\n                    res += 1\n                    q.append(i + k - 1)\n            else:\n                if A[i] == 1:\n                    res += 1\n                    q.append(i + k - 1)\n            if q and q[0] == i: q.popleft()\n            if q and q[-1] >= len(A): return -1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        # left bit needs to get flipped\n        # flip left bit and the K-1 bits to the right\n        # now consider\n        \n#         counter = 0\n#         for i in range(len(A)-K+1):\n#             # print(i,A)\n#             if A[i] == 0:\n#                 counter += 1\n#                 for j in range(K):\n#                     A[i+j] ^= 1\n            \n#         # return counter if sum(A) == len(A) else -1\n#         return counter if 0 not in A[-K:] else -1\n            \n        counter = 0\n        q = []\n        qL = 0\n        \n        for i in range(len(A)-K+1):\n            if A[i] == (len(q)-qL) % 2: # then this bit would be a 0 after previous flips applied\n                # flip at A[i]\n                counter += 1\n                q.append(i+K-1) # the last bit affected by this flip\n            if qL < len(q) and q[qL] == i:\n                qL += 1\n            # print(q)\n            # print(f'i:{i}, qL:{qL}, len(q), {len(q)}, top')\n        \n        # check the bits for which there's not enough room to flip at\n        for i in range(len(A)-K+1, len(A)):\n            \n            if A[i] == (len(q)-qL) % 2:\n                # 0 0, 1 1\n                return -1\n            if qL < len(q) and q[qL] == i:\n                qL += 1\n            # print(q)\n            # print(f'i:{i}, qL:{qL}, len(q), {len(q)}, top')\n                    \n        return counter", "class Solution:\n    def minKBitFlips(self, A: 'List[int]', K: 'int') -> 'int':\n        flip = 0\n        const = 10\n        res = 0\n        for i in range(len(A)):\n            if flip % 2 != 0:\n                if A[i] % 10:\n                    res += 1\n                    flip += 1\n                    if i + K - 1 >= len(A):\n                        return -1\n                    A[i + K - 1] += const\n            else:\n                if not A[i] % 10:\n                    res += 1\n                    flip += 1\n                    if i + K - 1 >= len(A):\n                        return -1\n                    A[i + K - 1] += const\n            if A[i] > 1:\n                flip -= 1\n        return res", "from collections import deque\n\nclass Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = 0\n        q = deque()\n        flips = 0\n        for i in range(len(A)):\n            if len(q) == K:\n                flipped ^= q.popleft()\n            \n            if flipped == A[i]:\n                if i + K > len(A):\n                    return -1\n                flipped ^= 1\n                flips += 1\n                q.append(1)\n            else:\n                q.append(0)\n        \n        return flips\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        interval_status = [ 0 ] * (len(A) + 1)\n        counter = 0\n        prev = 0\n        for i in range(len(A)):\n            prev ^= interval_status[i]\n            curr_status = prev ^ A[i] \n            # print(curr_status)\n            if curr_status == 0:\n                if i + K <= len(A):\n                    interval_status[i + K] ^= 1\n                    counter += 1\n                    prev ^= 1\n                    \n                else:\n                    return -1\n            \n        return counter", "class Solution:\n    def minKBitFlips(self, A: 'List[int]', K: 'int') -> 'int':\n        flip = 0\n        const = 10\n        res = 0\n        for i in range(len(A)):\n            temp = A[i] % 10\n            if flip % 2 != 0:\n                if temp:\n                    res += 1\n                    flip += 1\n                    if i + K - 1 < len(A):\n                        A[i + K - 1] += const\n                    else:\n                        return -1\n            else:\n                if not temp:\n                    res += 1\n                    flip += 1\n                    if i + K - 1 < len(A):\n                        A[i + K - 1] += const\n                    else:\n                        return -1\n            if A[i] > 1:\n                flip -= 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        q = deque()\n        res = 0\n        for i in range(len(A)):\n          if len(q) % 2 != 0: # means even numbers of flip\n            if A[i] == 1: # flip to 0\n              res += 1\n              q.append(i+K-1)\n          else:\n            if A[i] == 0:\n              res += 1\n              q.append(i+K-1)\n          if q and q[0] == i:\n            q.popleft()\n          if q and q[-1] >= len(A):\n            return -1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        n = len(A)\n        ff = [0 for i in range(n)]\n        \n        \n        \n        cur = 0\n        f = 0\n        for i in range(n):\n            \n            cur += ff[i]\n            xo = cur % 2\n            if xo ^ A[i] == 0:\n                if i + K - 1 > n - 1:\n                    return -1\n                else:\n                    f += 1\n                    ff[i] += 1\n                    if i + K < n:\n                        ff[i + K] -= 1\n                    cur += 1\n        return f", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        res = 0\n        queue = collections.deque([])\n        \n        for i in range(len(A)):\n            while queue and queue[0] < i:\n                queue.popleft()\n            \n            if (A[i] + len(queue)) % 2 == 0:\n                if i+K-1 >= len(A):\n                    return -1\n                else:\n                    queue.append(i+K-1)\n                    res += 1\n                    \n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = [0] * len(A)\n        p = ans = 0\n        for i in range(len(A)):\n            if i >= K:\n                # switch back\n                p ^= flipped[i - K]\n            if p == A[i]:\n                if i + K > len(A):\n                    return -1\n                ans += 1\n                flipped[i] = 1\n                p ^= 1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        res = 0\n        flip = 0\n        na = [0]*len(A)\n        for i,x in enumerate(A):\n            flip ^= na[i]\n            if flip ^ x == 0:\n                res += 1\n                flip ^= 1\n                if i+ K > len(A):\n                    return -1\n                if i+ K < len(A):\n                    na[i+K] ^= 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        flip_count = 0\n        hint = [0] * n\n        min_flip = 0\n        \n        for i in range(n):\n            if i >= K and hint[i-K] == 1:\n                flip_count -= 1\n            \n            if flip_count % 2 == A[i]:\n                if i + K > n:\n                    return -1\n                \n                min_flip += 1\n                flip_count += 1\n                \n                hint[i] = 1\n                \n        return min_flip\n", "from collections import deque\nclass Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        reduceInds = deque()\n        if K == 1:\n            return len(A) - sum(A)\n        \n        maxFlipCnt = 0\n        effectiveFlipCnt = 0\n        for i,b in enumerate(A):\n            if len(reduceInds) != 0 and reduceInds[0] == i:\n                effectiveFlipCnt -= 1\n                reduceInds.popleft()\n            \n            if b == 0 and effectiveFlipCnt % 2 == 0 or b == 1 and effectiveFlipCnt % 2 == 1:\n                if i >= len(A) - K + 1: # No way to flip now, just check if it is 0\n                    return -1\n                else:\n                    maxFlipCnt+=1\n                    effectiveFlipCnt+=1\n                    reduceInds.append(i + K)\n        \n        return maxFlipCnt\n        \n                \n        \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        q = collections.deque()\n        res = 0\n        for i in range(len(A)):\n            if A[i] == len(q) % 2:\n                q.append(i)\n                res += 1\n            \n            if q and q[0] <= i - K + 1:\n                q.popleft()\n        return res if len(q) == 0 else -1", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        dq = deque()\n        res = 0\n        for i in range(len(A)):\n            if A[i] == len(dq) % 2:\n                res += 1\n                dq.append(i+K-1)\n                \n            if dq and dq[0] <= i:\n                dq.popleft()\n                \n        return res if not dq else -1", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        flipped = [0 for _ in range(N)]\n        curr = 0\n        ans = 0\n        for i in range(N):\n            if i >= K:\n                curr ^= flipped[i - K]\n            if curr == A[i]:\n                if i + K > N:\n                    return -1\n                flipped[i] = 1\n                curr ^= 1\n                ans += 1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        res = 0\n        q = deque()\n        for i in range(len(A)):\n            if len(q) % 2 != 0:\n                if A[i] == 1:\n                    res += 1\n                    q.append(i + K - 1)\n            else:\n                if A[i] == 0:\n                    res += 1\n                    q.append(i + K - 1)\n            if q and q[0] == i:\n                q.popleft()\n            if q and q[-1] >= len(A):\n                return -1\n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = collections.deque()\n        res = 0\n        for i, a in enumerate(A):\n            if (A[i] == 0 and not len(flips) & 1) or (A[i] != 0 and len(flips) & 1):\n                res += 1\n                flips.append(i + K - 1)\n            while flips and flips[0] <= i:\n                flips.popleft()\n        return res if not flips else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cnt=0\n        dq=collections.deque()\n        for i in range(len(A)):\n            if A[i]==(1 if len(dq)%2 else 0):\n                cnt+=1\n                dq.append(i+K-1)\n            if dq and dq[0]==i:\n                dq.popleft()\n        return -1 if len(dq) else cnt\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = collections.deque()\n\n        result = 0\n        for i, num in enumerate(A):\n            if A[i] == (len(flips) & 1):\n                result += 1\n                flips.append(i + K - 1)\n            while flips and flips[0] <= i:\n                flips.popleft()\n\n        return result if len(flips) == 0 else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur, res = 0 ,0\n        for i in range(len(A)):\n            if i >= K and A[i-K] > 1:\n                cur -= 1\n                A[i-K] -= 2\n            if cur % 2 == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                res += 1\n                cur += 1\n        return res\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        res, flipped, isFlipped = 0, 0, [0] * len(A)\n        \n        for i in range(len(A)):\n            if i >= K:\n                flipped ^= isFlipped[i - K]\n            if not A[i] ^ flipped:\n                if i + K > len(A): return -1\n                isFlipped[i] ^= 1\n                res += 1\n                flipped ^= 1\n        \n        return res\n                \n        \n        \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        i=0\n        c=0\n        q=collections.deque()\n        \n        sign=0\n        while True:\n            while i<len(A) and A[i]!=sign:\n                i+=1\n                if q and i==q[0]:\n                    q.popleft()\n                    sign=1-sign\n                    \n            if i==len(A):\n                return c\n             \n            if i+K>len(A):\n                return -1\n            \n            q.append(i+K)\n            sign=1-sign\n            \n            c+=1\n            i+=1\n            if q and i==q[0]:\n                q.popleft()\n                sign=1-sign\n                \n        return c\n    \n    \n            \n            \n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flip_time=0\n        n=len(A)\n        close=[False for i in range(n)]\n        #print(close)\n        res=0\n        for i in range(n):\n            if close[i]:\n                flip_time-=1\n            if (A[i]==0 and flip_time%2==0) or (A[i]==1 and flip_time%2==1):\n                flip_time+=1\n                res+=1\n                if i+K>n: return -1\n                if i+K<n:\n                    close[i+K]=True\n        return res\n                \n                \n        \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = 0\n        carry = 10\n        result = 0\n        valid = True\n        for i, num in enumerate(A):\n            if (A[i] & 1) == (flips & 1):\n                result += 1\n                flips += 1\n                if i < len(A) - K + 1:\n                    A[i + K - 1] += carry\n                else:\n                    valid = False\n            if A[i] > 1:\n                A[i] -= carry\n                flips -= 1\n\n        return result if valid else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        l = len(A)\n        rem = l % K\n        # find indexes where the number changes\n        # add to change_list based on remainder class mod K\n        prev = 1\n        change_list = [[] for i in range(K)]\n        for ind, num in enumerate(A):\n            if prev != num:\n                prev = num\n                change_list[ind % K].append(ind)\n        if num == 0:\n            change_list[rem].append(l)\n    \n        num_flips = 0\n        \n        for r, mini_list in enumerate(change_list):\n            mini_list_len = len(mini_list)\n            if mini_list_len % 2 == 1:\n                return -1\n            for i in range(mini_list_len // 2):\n                first = mini_list.pop(0)\n                second = mini_list.pop(0)\n                num_flips += (second - first) // K\n        \n        return num_flips\n        \n        \n        \n        \n    \n    \n    def oldMinKBitFlips(self, A: List[int], K: int) -> int:\n        l = len(A)\n        \n        # find indexes where the number changes\n        prev = 1\n        change_list = []\n        for ind, num in enumerate(A):\n            if prev != num:\n                prev = num\n                change_list.append(ind)\n        \n        if len(change_list) == 0:\n            return 0\n        \n        num_flips = 0\n\n        while len(change_list) > 1:\n            first = change_list[0]\n            # if first + K > l, we are doomed\n            if first + K >= l:\n                return -1\n            # remove first, and either\n                # 1) remove first + K if it exists, or\n                # 2) add first + K if it does not exist\n            change_list = change_list[1:]\n            left_insertion_pt = bisect.bisect_left(change_list, first + K)\n            if left_insertion_pt >= len(change_list):\n                change_list.append(first + K)\n            elif change_list[left_insertion_pt] == first + K:\n                del change_list[left_insertion_pt]\n            else:\n                change_list.insert(left_insertion_pt, first+K)\n            num_flips += 1\n            \n            \n        if len(change_list) > 0:\n            # in this section, len(change_list) == 1\n            first = change_list[0]\n            q, r = divmod(l - first, K)\n            if r == 0:\n                return num_flips + q\n            else:\n                return -1\n            \n        return num_flips", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        cur = 0 # \u5230\u8fbe\u5f53\u524d\u4f4d\u7f6e\u7684\u7ffb\u8f6c\u6b21\u6570\n        res = 0\n        for i in range(n):\n            if i >= K and A[i-K] > 1:\n                # \u6700\u5de6\u5143\u7d20\u88ab\u79fb\u9664\u7a97\u53e3\uff0c\u6240\u4ee5\u8981\u53d6\u6d88\u5b83\u7684\u7ffb\u8f6c\n                cur -= 1\n                A[i-K] -= 2\n            if (cur % 2) == A[i]: # \u7ffb\u8f6c\u6b21\u6570\u4e0eA[i]\u540c\u5947\u5076\u5c31\u9700\u8981\u7ffb\u8f6c\n                if i + K > n: return -1\n                cur += 1\n                res += 1\n                A[i] += 2\n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        i=0\n        c=0\n        q=collections.deque()\n        sign=0\n        \n        for i in range(len(A)):\n            \n            if q and i==q[0]:\n                sign=1-sign\n                q.popleft()\n            \n            if A[i]!=sign:\n                continue\n            else:\n                if i+K>len(A):\n                    return -1\n                \n                q.append(i+K)\n                sign=1-sign\n                c+=1\n                \n        return c\n    \n    \n            \n            \n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = collections.deque()\n        cnt = 0\n        for i in range(len(A)):\n            while flips and flips[0] <= i - K:\n                flips.popleft()\n            curtStatus = A[i] + len(flips)\n            \n            if curtStatus % 2 == 0:\n                if i > len(A) - K:\n                    return -1\n                else:\n                    flips.append(i)\n                    cnt += 1\n        return cnt\n            \n", "\n\nclass Solution(object):\n    def minKBitFlips(self, A, K):\n        # https://www.youtube.com/watch?v=tbNpHv2HDXo\n        cur = res = 0\n        for i in range(len(A)):\n            if i >= K and A[i - K] == 2:\n                cur -= 1\n            if (cur % 2) == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] = 2\n                cur, res = cur + 1, res + 1\n        return res\n\n\n\nclass Solution1:\n    def minKBitFlips(self, A, K):\n        cur, res, n = 0, 0, len(A)\n        for i in range(len(A)):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1\n            if cur & 1 ^ A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        return res\n\n\n# class Solution:\n#     def minKBitFlips(self, A: List[int], K: int) -> int:\n#         cnt = 0\n#         for i in range(len(A) + 1 - K):\n#             if A[i] == 0:\n#                 cnt += 1\n#                 for k in range(K):\n#                     A[i+k] ^= 1\n#             else:\n#                 continue \n#         return cnt if 0 not in A[-K:] else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        # greedy\n        n = len(A)\n        flipped = res = 0\n        isFlipped = [0] * n\n        for i in range(n):\n            # isFlipped[i-K] does not affect i here\n            if (i >= K):\n                flipped ^= isFlipped[i-K]\n            if (flipped ^ A[i] == 0):\n                if (i + K > n):\n                    return -1\n                isFlipped[i] = 1\n                flipped ^= 1\n                res += 1\n        \n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = collections.deque()\n        res = 0\n        for i, a in enumerate(A):\n            if (A[i] != 0 and len(flips) & 1) or (not len(flips) & 1 and A[i] != 1):\n                res += 1\n                flips.append(i + K - 1)\n            while flips and flips[0] <= i:\n                flips.popleft()\n        return res if not flips else -1\n                \n        \n        \n        \n#         flips = collections.deque()\n#         res = 0\n#         for i, a in enumerate(A):\n#             if (A[i] != 0 and len(flips) & 1) or (not len(flips) & 1 and A[i] != 1):\n#                 res += 1\n#                 flips.append(i + K - 1)\n#             while flips and flips[0] <= i:\n#                 flips.popleft()\n#         return res if not flips else -1\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flips = collections.deque()\n        res = 0\n        for i, a in enumerate(A):\n            if (A[i] != 0 and len(flips) & 1) or (not len(flips) & 1 and A[i] != 1):\n                res += 1\n                flips.append(i + K - 1)\n            while flips and flips[0] <= i:\n                flips.popleft()\n        return res if not flips else -1\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        '''greedy+ \u6ed1\u52a8\u7a97\u53e3\n        1.\u7528deque\u4fdd\u5b58\u53cd\u8f6c\u8fc7\u7684idx\uff0c\u957f\u5ea6\u5c31\u662f\u603b\u5171\u80fd\u7ba1\u5230i\u7684\u53cd\u8f6c\u6b21\u6570\n          start\u5f80\u540e\u8d70\u7684\u65f6\u5019\u961f\u5934\u4e0d\u5728\u5f53\u524dwindow\u7684\u51fa\u7ad9\n          [0,0,0,1,0,1,1,0]\n                         i\n           que = [5]\n           len == 1 => flipped  res += (len(que) %2 ^ A[i] == 0)\n           res = 3\n        2. \u7528count\u8868\u793awindow\u91cc\u9762flip\u4e86\u591a\u5c11\u6b21(\u6216\u8005\u5c31\u7528count\u7684mod)\n           flip\u7684\u7528A[i]-2 => 0:-2, 1:-1 \u6765\u505amark\u8fd9\u6837start\u51fawindow\u7684\u65f6\u5019\u624d\u80fd\u51cf\u53bbcount\n           \u51fawindow\u7684\u65f6\u5019\u628a2\u52a0\u56de\u53bb=> -2:0, -1:1\n        '''\n        start = 0\n        count = 0\n        res = 0\n        for end, a in enumerate(A):\n            if count ^ A[end] == 0: #(count % 2)^ A[end]\n                #print(end)\n                A[end] -= 2\n                res += 1\n                count ^= 1 # count++\n                \n            if end >= start + K - 1: #move window start\n                if A[start] < 0:\n                    count ^= 1 #count--\n                    A[start] += 2 #flip back\n                start += 1\n        #print(A)  \n        # at the end if there is anything not flipped? (last window need flip)\n        return -1 if any([a < 0 for a in A]) else res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        '''greedy+ \u6ed1\u52a8\u7a97\u53e3\n        1.\u7528deque\u4fdd\u5b58\u53cd\u8f6c\u8fc7\u7684idx\uff0c\u957f\u5ea6\u5c31\u662f\u603b\u5171\u80fd\u7ba1\u5230i\u7684\u53cd\u8f6c\u6b21\u6570\n          start\u5f80\u540e\u8d70\u7684\u65f6\u5019\u961f\u5934\u4e0d\u5728\u5f53\u524dwindow\u7684\u51fa\u7ad9\n          [0,0,0,1,0,1,1,0]\n                         i\n           que = [5]\n           len == 1 => flipped  res += (len(que) %2 ^ A[i] == 0)\n           res = 3\n        2. \u7528count\u8868\u793awindow\u91cc\u9762flip\u4e86\u591a\u5c11\u6b21(\u6216\u8005\u5c31\u7528count\u7684mod)\n           flip\u7684\u7528A[i]-2 => 0:-2, 1:-1 \u6765\u505amark\u8fd9\u6837start\u51fawindow\u7684\u65f6\u5019\u624d\u80fd\u51cf\u53bbcount\n           \u51fawindow\u7684\u65f6\u5019\u628a2\u52a0\u56de\u53bb=> -2:0, -1:1\n        '''\n        start = 0\n        count = 0\n        res = 0\n        for end, a in enumerate(A):\n            if count ^ A[end] == 0: #(count % 2) ^ A[end]\n                #print(end)\n                A[end] -= 2\n                res += 1\n                count ^= 1 # count++\n                \n            if end >= start + K - 1: #move window start\n                if A[start] < 0: #\u88abflip\u8fc7\n                    count ^= 1 #count-- #\u8fd9\u4e2astart\u5f71\u54cd\u4e0d\u5230end\u4e86\n                    A[start] += 2 #flip back\n                start += 1\n        #print(A)  \n        # at the end if there is anything not flipped? (last window need flip)\n        return -1 if any([a < 0 for a in A]) else res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        flips = []\n        res, total = 0, 0\n        for i, v in enumerate(A):\n            if i < N - K + 1:\n                if v == 1:\n                    if total & 1:\n                        total += 1\n                        res += 1\n                        flips.append(1)\n                    else:\n                        flips.append(0)\n                else:\n                    if total & 1:\n                        flips.append(0)\n                    else:\n                        total += 1\n                        res += 1\n                        flips.append(1)\n            else:\n                if v == 0:\n                    if not total & 1:\n                        return -1\n                if v == 1:\n                    if total & 1:\n                        return -1\n            if i >= K - 1:\n                total -= flips[i-K+1]\n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        # \u8c37\u6b4c\u9762\u7ecf\u3002\u7ed9\u5b9a\u4f60\u4e00\u4e2a01\u5e8f\u5217\u3002\u7136\u540e\u6bcf\u6b21\u53ef\u4ee5\u8fde\u7eedK\u4e2a\u6570\u8fdb\u884c\u7ffb\u8f6c\u3002\u95ee\u4f60\u6700\u5c11\u64cd\u4f5c\u6b21\u6570\u4f7f\u5f97\u51680\n        # \u8fd9\u9053\u9898\u662f\u4e00\u9053\u8d2a\u5fc3\u9898\u3002\u56e0\u4e3aA[0]\u7ffb\u8f6c\u4e0d\u7ffb\u8f6c\u53ea\u6709\u552f\u4e00\u7684\u4e00\u4e2a\u529e\u6cd5\u3002\n        # \u7a7a\u95f4\u4e0a\u8003\u8651A\u53ea\u670901\u5143\u7d20\u3002\u56e0\u6b64\u53ef\u4ee5\u5229\u7528\u8fd9\u4e2a\u7279\u70b9\u907f\u514d\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\n        cur, res, n = 0, 0, len(A)\n        # cur means the numbers of flips in the current sliding window of size K\n        # in the window, if the cur is even and A[i] = 0,we need to flip\n        # if the cur is odd and A[i] = 1,we need to flip\n        # we want to flip A[i], from 0 to 2, from 1 to 3.when go out window, we change it back\n        for i in range(n):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1   # \u7ef4\u6301\u6ed1\u52a8\u7a97\u53e3\n            if (cur & 1) ^ A[i] == 0:  # \u6839\u636e\u524d\u9762\u7684\u5206\u6790\uff0c\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u9700\u8981\u66ff\u6362\u5f53\u524d\u7684A[i]\n                if i + K > len(A):   # \u4e0d\u8fc7\u6b64\u65f6\u6709\u4e00\u4e2a\u7279\u522b\u6ce8\u610f\uff0c\u90a3\u5c31\u662f\u8d85\u754c\uff08\u6ca1\u6709\u7b49\u53f7\uff09\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        # print(A)  \u6700\u540e\u7a97\u53e3\u5185\u7684\u8fd8\u662f\u6ca1\u5b8c\u5168\u6539\u56de\u6765\uff0c\u4e0d\u8fc7\u95ee\u9898\u4e0d\u5927\n        return res", "class Solution(object):\n    def minKBitFlips(self, A, K):\n        N = len(A)\n        hint = [0] * N\n        ans = flip = 0\n\n        # When we flip a subarray like A[i], A[i+1], ..., A[i+K-1]\n        # we can instead flip our current writing state, and put a hint at\n        # position i+K to flip back our writing state.\n        for i, x in enumerate(A):\n            flip ^= hint[i]\n            if x ^ flip == 0:  # If we must flip the subarray starting here...\n                ans += 1  # We're flipping the subarray from A[i] to A[i+K-1]\n                if i+K > N: return -1  # If we can't flip the entire subarray, its impossible\n                flip ^= 1  \n                if i+K < N: hint[i + K] ^= 1\n\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        i = 0\n        ans = 0\n        flips = 0\n        dq = collections.deque()\n        while i < len(A):\n            while dq and i >= dq[0]:\n                dq.popleft()\n                flips -= 1\n            if (A[i] + flips) %2 == 1:\n                i += 1\n            else:\n                if i + K > len(A):\n                    return -1\n                dq.append(i+K)\n                flips += 1\n                i += 1\n                ans += 1\n        return ans\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        # intuitive idea: for current position, if it flips, \n        # then we record the right-hand-side farest point that current flip will effect to (whick is i+K-1)\n        # call this 'forward propogation'\n        # on the other hand, at current position, we need to decite whether we need to flip it or not,\n        # this time, we need to look at \\\"backward propogation\\\": \n        # the flips that happended historically and still effect current i-th position:\n        # 1. if there are even flips effect current i, then when A[i]=0, we need a new flip\n        # 2. if there are odd flips effect current i, then only when A[i]=1, we need a new flip\n        # when we perform this flip, we will append a new right-hand-side boundary (i+K-1) to current queue:\n\n        # time complexity = O(n) and space complexity = O(K)\n        flips = collections.deque() # alike a sliding window, that store the active flips \n        # (which effect current i-th position)\n\n        res = 0\n        for i in range(len(A)):\n            if A[i] == (len(flips) % 2):\n                res += 1\n                flips.append(i+K-1)\n\n            if flips and flips[0] <= i: # the head of the queue will not effect i+1 th position, so we pop it\n                flips.popleft()\n        return res if not flips else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = [0] * len(A)\n        res = 0\n        flip = 0\n        for i in range(len(A)):\n            if i >= K: flip ^= flipped[i - K] #\n            if A[i] ^ flip == 0: #\n                if i + K > len(A): return -1 #\n                res += 1 \n                flip ^= 1 \n                flipped[i] = 1 \n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        D = [0] * n\n        D[0] = A[0]\n        for i in range(n - 1):\n            D[i + 1] = A[i + 1] ^ A[i]\n        \n        D.append(0)\n        cnt = 0\n        if D[0] == 0:\n            cnt += 1\n            D[0] ^= 1\n            D[K] ^= 1\n        \n        for i in range(1, n - K + 1):\n            if D[i] == 1:\n                cnt += 1\n                D[i] ^= 1\n                D[i + K] ^= 1\n        \n        D.pop()\n        if D == [1] + [0] * (n - 1):\n            return cnt\n        else:\n            return -1", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        flips = [0] * n\n        flip = 0\n        ans = 0\n        \n        def mapping(a: int, flip: int) -> int:\n            return 1 - a if flip % 2 == 1 else a\n            \n        for i, a in enumerate(A):\n            flip += flips[i]\n            if mapping(a, flip) == 0:\n                if i + K - 1 < n:\n                    ans += 1\n                    flips[i] += 1\n                    flip += 1\n                    A[i] = 1\n                    if i + K < n:\n                        flips[i + K] -= 1\n                else:\n                    return -1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        q = collections.deque()\n        res = 0\n        for i, num in enumerate(A):\n            while len(q) > 0 and i - q[0] >= K:\n                q.popleft()\n            \n            if len(q) % 2 == 1 and num == 1 or len(q) % 2 == 0 and num == 0:\n                if i + K > len(A):\n                    return -1\n                q.append(i)\n                res += 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        # When we flip a subarray, let's call the set of indices we flipped an interval.\n        # When we flip an interval starting at i, we create a hint for a closing event at i+K telling us to flip our writing state back.\n        \n        N = len(A)\n        hint = [0]*N\n        ans = flip = 0\n        \n        # When we flip a subarray like A[i], A[i+1], ..., A[i+K-1]\n        # we can instead flip our current writing state, and put a hint at\n        # position i+K to flip back our writing state.\n        \n        for i, x in enumerate(A):\n            flip ^= hint[i]\n            if x^flip == 0:\n                ans += 1\n                if i + K > N:\n                    return -1\n                flip ^= 1\n                if i + K < N:\n                    hint[i+K] ^= 1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        latest_possible_flip = len(A) - K       # 4\n        flipped = collections.deque()\n        flips = 0\n        for i in range(len(A)):\n            if flipped and (flipped[0] < i):    # 3\n                flipped.popleft()\n            if len(flipped)&1 == A[i]:          # 2\n                if i <= latest_possible_flip:   # 4\n                    flips += 1\n                    flipped.append(i+K-1)       # 1\n                else:\n                    return -1\n        return flips\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = [False] * len(A)\n        count = [0] * len(A)\n        flips = 0\n        \n        for i in range(len(A)):\n            if i > 0:\n                x = flipped[i - K] if i >= K else 0\n                count[i] = count[i - 1] - x\n            \n            if (A[i] + count[i]) % 2 == 0:\n                count[i] += 1\n                flipped[i] = True\n                flips += 1\n        #print(flipped)\n        #print(count)\n        return flips if not any(flipped[len(A) - K + 1:]) else -1", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n        c=0\n        flippedtill=[0 for i in range(len(A)+1)]\n        curr=0\n        if(len(A)==k):\n            if(sum(A)==0):\n                return 1\n            elif(sum(A)==len(A)):\n                return 0\n            else:\n                return -1\n        for i in range(len(A)-k+1):\n            curr=(curr+flippedtill[i])%2\n            if((A[i]+curr)%2==0):\n                flippedtill[i+1]+=1\n                flippedtill[i+k]-=1\n                c+=1\n        for i in range(len(A)-k+1,len(A)):\n            curr=(curr+flippedtill[i])%2\n            if((A[i]+curr)%2==0):\n                return -1\n        return c    \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        count = 0\n        stack = []\n        for i in range(len(A)):\n            if stack and i == stack[0]:\n                stack.pop(0)\n           \n            if A[i] == len(stack)%2:\n                if i+ K > len(A): return -1\n                count += 1\n                stack.append(i+K)\n\n        return count \n        \n#         start = count = 0\n#         while  start < len(A):\n#             if not A[start]:\n#                 if start + K > len(A): return -1\n#                 for i in range(start, start+K):\n#                     A[i] = 1 - A[i]\n#                 count += 1\n#             start += 1\n#         return count\n            \n", "\n\nclass Solution:\n    def minKBitFlips(self, A, K):\n        cur, res, n = 0, 0, len(A)\n        for i in range(len(A)):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1\n            if cur & 1 ^ A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        return res\n\n\n# class Solution:\n#     def minKBitFlips(self, A: List[int], K: int) -> int:\n#         cnt = 0\n#         for i in range(len(A) + 1 - K):\n#             if A[i] == 0:\n#                 cnt += 1\n#                 for k in range(K):\n#                     A[i+k] ^= 1\n#             else:\n#                 continue \n#         return cnt if 0 not in A[-K:] else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n\n        latest_possible_flip = len(A) - k       # 4\n        flipped = collections.deque()\n        flips = 0\n        for i in range(len(A)):\n            if flipped and (flipped[0] < i):    # 3\n                flipped.popleft()\n            if len(flipped)&1 == A[i]:          # 2\n                if i <= latest_possible_flip:   # 4\n                    flips += 1\n                    flipped.append(i+k-1)       # 1\n                else:\n                    return -1\n        return flips\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        # to maintain a queue to record the position where flip happens in the k window that ends at the current position\n        win = collections.deque()\n        ans = 0\n        for i,x in enumerate(A):\n            while len(win)>0 and win[0]<i-K+1:\n                win.popleft()\n            if (x ^ (len(win)%2) ) ==0  :  # if there are even number of flips and x == 0, need to flip, odd and x==1\n                if i+K-1<=len(A)-1:\n                    ans += 1\n                    win.append(i)\n                else:\n                    return -1\n        return ans", "\n\nclass Solution(object):\n    def minKBitFlips(self, A, K):\n        '''\n        Input: A = [0,0,0,1,0,1,1,0], K = 3\n        Output: 3\n        Explanation:\n        Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\n        Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\n        Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\n        '''\n        #https://www.youtube.com/watch?v=tbNpHv2HDXo\n        cur = res = 0\n        for i in range(len(A)):\n            if i >= K and A[i - K] == 2:\n                cur -= 1\n            if (cur % 2) == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] = 2\n                cur, res = cur + 1, res + 1\n        return res\n\n\n\nclass Solution1:\n    def minKBitFlips(self, A, K):\n        cur, res, n = 0, 0, len(A)\n        for i in range(len(A)):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1\n            if cur & 1 ^ A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        return res\n\n\n# class Solution:\n#     def minKBitFlips(self, A: List[int], K: int) -> int:\n#         cnt = 0\n#         for i in range(len(A) + 1 - K):\n#             if A[i] == 0:\n#                 cnt += 1\n#                 for k in range(K):\n#                     A[i+k] ^= 1\n#             else:\n#                 continue \n#         return cnt if 0 not in A[-K:] else -1\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        \n        hint = [0] * N # Keeps track of first index after a flip\n        \n        counter = 0 # Total flips\n        \n        flip = 0 # Whether we are looking at a flipped array or not\n        \n        for i, x in enumerate(A):\n            # If hint[i] == 1, then the flip whose last index was i-1 must be removed from our flip counter\n            flip = (flip + hint[i]) % 2\n        \n        # If x is 1 and flipped or x is 0 and unflipped, then it is 0, so we need to flip the bit.\n            if (x == 1 and flip == 1) or (x == 0 and flip == 0):\n                counter += 1  # Add to the flip counter\n                \n                # Check if K-bit flip goes past end of array.\n                if i+K > N:\n                    return -1\n                \n                # We flipped, so we change our flip value for the next iteration of the loop\n                flip = 1-flip\n                \n                # Keep track of first index after flip\n                if i+K < N:\n                    hint[i + K] = 1\n\n        return counter\n                \n", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n        n = len(A)\n        count = [0] * n\n        ps = 0\n        res = 0\n        \n        for i in range(n-k+1):\n            flip = ps + A[i]\n            if flip % 2 == 0:\n                count[i] = 1\n                res += 1\n                ps += 1\n            \n            if i - k + 1 >= 0:\n                ps -= count[i-k+1]\n        \n        \n        for i in range(n-k+1, n):\n            if (ps + A[i]) % 2 == 0:\n                return -1\n            ps -= count[i-k+1]\n        \n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flip_ends = deque()\n        count = 0\n        for (idx, bit) in enumerate(A):\n            if len(flip_ends) > 0 and idx >= flip_ends[0]:\n                flip_ends.popleft()\n            val = (bit + len(flip_ends)) % 2\n            if val == 1:\n                continue\n\n            if idx + K > len(A):\n                return -1\n\n            count += 1\n            flip_ends.append(idx + K)\n\n        return count\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        \n        flip_ind = [0] * N # Keeps track of first index after a flip\n        \n        counter = 0 # Total flips\n        \n        flip = 0 # Flip counter. The flip counter only matters modulo 2.\n        \n        for i, x in enumerate(A):\n            # If flip_ind[i] == 1, then the flip whose last index was i-1 must be removed from our flip counter\n            flip = (flip + flip_ind[i]) % 2\n        \n            # If x is 1 and flipped or x is 0 and unflipped, then it is 0, so we need to flip the bit.\n            if (x == 1 and flip == 1) or (x == 0 and flip == 0):\n                counter += 1  # Add to the flip counter\n                \n                # Check if K-bit flip goes past end of array.\n                if i+K > N:\n                    return -1\n                \n                # We flipped, so we change our flip value for the next iteration of the loop\n                flip = 1-flip\n                \n                # Keep track of first index after flip\n                if i+K < N:\n                    flip_ind[i + K] = 1\n\n        return counter\n                \n", "class Solution:\n    def minKBitFlips(self, A, K: int) -> int:\n        flipped, res = 0, 0\n        length = len(A)\n        isFlipped = [0]*length\n        for i, v in enumerate(A):\n            if i >= K:\n                flipped ^= isFlipped[i-K]\n            if flipped == v:\n                if i + K > length:\n                    return -1\n                isFlipped[i] = 1\n                flipped ^= 1\n                res += 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        is_flipped = [0] * len(A)\n        flipped = result = 0\n        \n        for i in range(len(A)):\n            if i >= K:\n                flipped ^= is_flipped[i-K]\n            \n            if A[i] == flipped:\n                if i + K > len(A):\n                    return -1\n                is_flipped[i] = 1\n                flipped ^= 1\n                result += 1\n                \n        return result\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur, res = 0, 0\n        \n        for i in range(len(A)):\n            # to check if A[i-K] has been flipped\n            if i >= K and A[i-K] > 1:\n            # since i-K is out of the sliding window, need to substract the total flip number by 1\n                cur -= 1\n                \n            if (cur%2)^A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                \n                A[i] += 2\n                cur += 1\n                res += 1\n                \n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        ALen = len(A)\n        flips = []\n        prevF = 0\n        ans = 0\n        l = 0\n        for i, num in enumerate(A):\n            temp = 0\n            while l+temp < len(flips) and flips[l+temp] + K- 1 < i:\n                temp += 1\n            l += temp\n            prevF = prevF - temp\n            if (prevF%2 and num == 0) or (prevF%2 == 0 and num == 1):\n                continue\n            else:\n                ans += 1\n                prevF += 1\n                flips.append(i)\n            #         if num == 0:\n            #         continue\n            #     else:\n            #         ans += 1\n            #         prevF += 1\n            #         flips.append(i)\n            # else:\n            #     if num == 0:\n            #         ans += 1\n            #         prevF += 1\n            #         flips.append(i)\n            #     else:\n            #         continue\n        if flips != [] and flips[-1] + K -1 >= ALen:\n            return -1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur, res = 0, 0\n        \n        for i in range(len(A)):\n            if i >= K and A[i-K] > 1:\n                cur -= 1\n                #A[i-K] -= 2\n                \n            if (cur%2)^A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                \n                A[i] += 2\n                cur += 1\n                res += 1\n                \n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur, res = 0, 0\n        \n        for i in range(len(A)):\n            # to check if A[i-K] has been flipped\n            if i >= K and A[i-K] > 1:\n                # as i-K is out of the sliding window, need to substract the total flip number by 1\n                cur -= 1\n                \n            if (cur%2)^A[i] == 0:\n                if i + K > len(A):\n                    return -1\n                \n                A[i] += 2\n                cur += 1\n                res += 1\n                \n        return res\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flip_pos = 0\n        flip_inds = []\n        for i in range(len(A)):\n            # find the correct current bit based on prior flips\n            while flip_pos < len(flip_inds) and i - K + 1 > flip_inds[flip_pos]:\n                flip_pos += 1\n            \n            is_flipped = False\n            if (len(flip_inds) - flip_pos) % 2 != 0:\n                is_flipped = True\n                \n            cur_bit = A[i]\n            if is_flipped:\n                cur_bit = not cur_bit\n            \n            if i > len(A) - K:\n                if cur_bit == 0:\n                    return -1\n            else:\n                if not cur_bit:\n                    flip_inds.append(i)\n                \n        return len(flip_inds)", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = [False] * len(A)\n        count = [0] * len(A)\n        flips = 0\n        \n        for i in range(len(A)):\n            if i > 0:\n                x = flipped[i - K] if i >= K else 0\n                count[i] = count[i - 1] - x\n            \n            if (A[i] + count[i]) % 2 == 0:\n                count[i] += 1\n                flipped[i] = True\n                flips += 1\n\n        return flips if not any(flipped[len(A) - K + 1:]) else -1", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        Fliped = [0]*len(A)\n        cnt = 0\n        for i in range(len(A)):\n            if i >=K:\n                fliped = cnt - Fliped[i-K]\n            else:\n                fliped = cnt\n                \n            if (A[i] == 0 and fliped % 2 == 0) or (A[i] == 1 and fliped % 2 == 1):\n                if i + K > len(A):\n                    return -1                \n                A[i] = 1\n                cnt += 1\n                \n            Fliped[i] = cnt\n            \n\n                    \n        return cnt\n                    \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        cur, res, n = 0, 0, len(A)\n        for i in range(len(A)):\n            if A[i] == (cur % 2):\n                if (i + K  > n): return -1 \n                res += 1\n                cur += 1\n                A[i] -= 2\n            if (i - K + 1 >= 0) and (A[i-K + 1] < 0):\n                cur -= 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        flipped = 0\n        status = [0] * len(A)\n        flips = 0\n        for i in range(len(A)):\n            if i >= K:\n                flipped ^= status[i - K]\n            \n            if flipped == A[i]:\n                if i + K > len(A):\n                    return -1\n                flipped ^= 1\n                flips += 1\n                status[i] = 1\n        \n        return flips\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        num = 0\n        flip_queue = []\n        flip_sum = 0\n        \n        for i in range(n-K+1):\n            if flip_sum&1:\n                add = 1 if A[i] == 1 else 0\n            else:\n                add = 1 if A[i] == 0 else 0\n            num += add\n            flip_queue.append(add)  \n            flip_sum += add\n            if len(flip_queue) >= K:\n                flip_sum -= flip_queue.pop(0)\n        for j in range(n-K+1, n):\n            if flip_sum&1:\n                if A[j] == 1:\n                    return -1\n            else:\n                if A[j] == 0:\n                    return -1\n            flip_queue.append(0)\n            if len(flip_queue)>=K:\n                flip_sum -= flip_queue.pop(0)\n        return num", "class Solution:\n    \n    def minKBitFlips(self, a: List[int], k: int) -> int:\n        n = len(a)\n        toggles = [0] * (n + 1) # toggles[i] is 1 if we should toggle our view\n        min_flips = 0\n        view = 0 # 0 means normal, 1 means inverted\n        \n        for i, b in enumerate(a):\n            # If we're ending an interval where we've previously flipped, toggle\n            # our view\n            view ^= toggles[i]\n            if b ^ view == 0: # This value is 0, we've gotta flip it\n                if i + k > n: # No way to flip to fix this (can't be done)\n                    return -1\n                min_flips += 1\n                view ^= 1 # toggle our view (view things from now on as flipped)\n                toggles[i + k] ^= 1 # toggle our view back once we get to i + k\n        return min_flips", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        ans = 0\n        has_ever_flipped = [0] * n\n        valid_flip_count_for_current_idx = 0\n        for i in range(n):\n            if i >= K:\n                if has_ever_flipped[i-K] == 1:\n                    valid_flip_count_for_current_idx -= 1\n            if valid_flip_count_for_current_idx % 2 == A[i]:\n                if i + K > n:\n                    return -1\n                valid_flip_count_for_current_idx += 1\n                has_ever_flipped[i] = 1\n                ans += 1\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        tot = 0\n        flips = []\n        mask = 0\n        for i in range(len(A) - (K - 1)):\n            if flips and i == flips[0]:\n                flips.pop(0)\n                mask ^= 1\n            if A[i] == mask:\n                flips.append(i + K)\n                tot += 1\n                mask ^= 1\n        for i in range(len(A) - K, len(A)):\n            if flips and i == flips[0]:\n                flips.pop(0)\n                mask ^= 1\n            if A[i] == mask:\n                return -1\n        return tot\n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        hint = [0] * N\n        ans = 0\n        flip = 0\n        for i, x in enumerate(A):\n            if flip == hint[i]:\n                flip = 0\n            else:\n                flip = 1\n            if (x == 1 and flip == 1) or (x == 0 and flip == 0):  # If we must flip the subarray starting here...\n                ans += 1  # We're flipping the subarray from A[i] to A[i+K-1]\n                if i+K > N:\n                    return -1  # If we can't flip the entire subarray, its impossible\n                flip = 1-flip\n                if i+K < N:\n                    hint[i + K] = 1 - hint[i + K]\n\n        return ans\n                \n", "class Solution:\n    def minKBitFlips(self, A, K):\n        cur, res, n = 0, 0, len(A)    # cur is number of flip since start of current window\n        for i in range(len(A)):\n            if i >= K and A[i - K] > 1:\n                A[i - K] -= 2\n                cur -= 1\n            if cur & 1 ^ A[i] == 0: # first module 2, even flip is no flip, odd flip is one flip\n                if i + K > len(A):\n                    return -1\n                A[i] += 2\n                cur += 1\n                res += 1\n        return res\n    \n    def minKBitFlips(self, A, K):\n        # cur is number of flip since start of current window\n        cur = res = 0\n        for i in range(len(A)):\n            if i >= K and A[i - K] == 2:  # if we flippped at k, that mean from now on, the flip impact is gone. \n                cur -= 1\n             # first module 2, even flip is no flip, odd flip is one flip\n            if (cur % 2) == A[i]:\n                if i + K > len(A):\n                    return -1\n                A[i] = 2 # mark flipped at i\n                cur, res = cur + 1, res + 1\n        return res", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        N = len(A)\n        hint = [0] * N\n        ans = flip = 0\n\n        for i, x in enumerate(A):\n            # check if the current index has been marked before\n            # if True, then flip the \\\"flip\\\" var\n            flip ^= hint[i]\n            \n            if x ^ flip == 0:  # If we must flip the subarray starting here...\n                ans += 1  # We're flipping the subarray from A[i] to A[i+K-1]\n                \n                if i+K > N: \n                    return -1\n                \n                flip ^= 1\n                \n                if i+K < N:\n                    hint[i+K] = 1\n\n        return ans", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        Fliped = [0]*len(A)\n        cnt = 0\n        for i in range(len(A)):\n            if i >=K:\n                fliped = cnt - Fliped[i-K]\n            else:\n                fliped = cnt\n                \n            if not (( A[i] == 0 ) ^ (fliped % 2 == 0)):\n                if i + K > len(A):\n                    return -1                \n                A[i] = 1\n                cnt += 1\n                \n            Fliped[i] = cnt\n            \n\n                    \n        return cnt\n                    \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        \n        count = 0\n        stack = collections.deque()\n        for i in range(len(A)):\n            if stack and i == stack[0]: \n                stack.popleft()\n            if A[i] == len(stack)%2:\n                if i+ K > len(A): return -1\n                count += 1\n                stack.append(i+K)\n\n        return count \n        \n#         start = count = 0\n#         while  start < len(A):\n#             if not A[start]:\n#                 if start + K > len(A): return -1\n#                 for i in range(start, start+K):\n#                     A[i] = 1 - A[i]\n#                 count += 1\n#             start += 1\n#         return count\n            \n", "class Solution:\n    def minKBitFlips(self, A: 'List[int]', K: 'int') -> 'int':\n        idx = 0\n        num_digits = len(A)\n        A_bitrep = int('1' + ''.join([str(i) for i in A]), 2)\n\n        K_bitrep = 2 ** K - 1\n        num_flips = 0\n        while A_bitrep > K_bitrep:\n            if A_bitrep & 1 == 0:\n                num_flips += 1\n                A_bitrep ^= K_bitrep\n            A_bitrep >>= 1\n\n        return num_flips if A_bitrep == K_bitrep else -1\n", "class Solution(object):\n    def minKBitFlips(self, A, K):\n        N=len(A)\n        flip=0\n        flip_ends=[0]*(N+1)\n        res=0\n        \n        for i,num in enumerate(A):\n            flip^=flip_ends[i]\n            if not num^flip:\n                if i+K>N:\n                    return -1\n                else:\n                    res+=1\n                    flip^=1\n                    flip_ends[i+K]=1\n                \n            \n        return res\n            \n      \n        \n       \n", "class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        import numpy as np\n        Anp = np.array(A).astype(bool)\n        idx = 0\n        cnt = 0\n        while idx < Anp.shape[0]-(K-1):\n            if Anp[idx]:\n                idx += 1\n            else:\n                cnt +=1\n                Anp[idx:idx+K] = ~Anp[idx:idx+K]\n                idx += 1\n        if np.sum(Anp[Anp.shape[0]-K:]) != K:\n            return -1\n        else:\n            return cnt", "class Solution:\n    def minKBitFlips(self, A: List[int], k: int) -> int:\n        \n        latest_possible_flip = len(A) - k\n        flipped = collections.deque()\n        flips = 0\n        for i in range(len(A)):\n            \n            if flipped and (flipped[0] < i):\n                flipped.popleft()\n                \n            if len(flipped)&1 == A[i]:\n                if i <= latest_possible_flip:\n                    flips += 1\n                    flipped.append(i+k-1)\n                else:\n                    return -1\n        \n        return flips"]
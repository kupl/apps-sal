["import sys\nfrom collections import deque\ndef solve():\n    sys.setrecursionlimit(10**6)\n    readline = sys.stdin.readline\n    writelines = sys.stdout.writelines\n    N = int(readline())\n    G = [[] for i in range(N)]\n    for i in range(N-1):\n        u, v = map(int, readline().split())\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n\n    # Euler tour technique\n    S = []\n    FS = [0]*N; LS = [0]*N\n    depth = [0]*N\n    stk = [-1, 0]\n    it = [0]*N\n    while len(stk) > 1:\n        v = stk[-1]\n        i = it[v]\n        if i == 0:\n            FS[v] = len(S)\n            depth[v] = len(stk)\n        if i < len(G[v]) and G[v][i] == stk[-2]:\n            it[v] += 1\n            i += 1\n        if i == len(G[v]):\n            LS[v] = len(S)\n            stk.pop()\n        else:\n            stk.append(G[v][i])\n            it[v] += 1\n        S.append(v)\n\n    L = len(S)\n    lg = [0]*(L+1)\n    # Sparse Table\n    for i in range(2, L+1):\n        lg[i] = lg[i >> 1] + 1\n    st = [[L]*(L - (1 << i) + 1) for i in range(lg[L]+1)]\n    st[0][:] = S\n    b = 1\n    for i in range(lg[L]):\n        st0 = st[i]\n        st1 = st[i+1]\n        for j in range(L - (b<<1) + 1):\n            st1[j] = (st0[j] if depth[st0[j]] <= depth[st0[j+b]] else st0[j+b])\n        b <<= 1\n\n    INF = 10**18\n    ans = []\n    Q = int(readline())\n    G0 = [[]]*N\n    P = [0]*N\n    deg = [0]*N\n    KS = [0]*N\n    A = [0]*N\n    B = [0]*N\n    for t in range(Q):\n        k, *vs = map(int, readline().split())\n        for i in range(k):\n            vs[i] -= 1\n            KS[vs[i]] = 1\n        vs.sort(key=FS.__getitem__)\n        for i in range(k-1):\n            x = FS[vs[i]]; y = FS[vs[i+1]]\n            l = lg[y - x + 1]\n            w = st[l][x] if depth[st[l][x]] <= depth[st[l][y - (1 << l) + 1]] else st[l][y - (1 << l) + 1]\n            vs.append(w)\n        vs.sort(key=FS.__getitem__)\n        stk = []\n        prv = -1\n        for v in vs:\n            if v == prv:\n                continue\n            while stk and LS[stk[-1]] < FS[v]:\n                stk.pop()\n            if stk:\n                G0[stk[-1]].append(v)\n            G0[v] = []\n            it[v] = 0\n            stk.append(v)\n            prv = v\n        que = deque()\n        prv = -1\n        P[vs[0]] = -1\n        for v in vs:\n            if v == prv:\n                continue\n            for w in G0[v]:\n                P[w] = v\n            deg[v] = len(G0[v])\n            if deg[v] == 0:\n                que.append(v)\n            prv = v\n\n        while que:\n            v = que.popleft()\n            if KS[v]:\n                a = 0\n                for w in G0[v]:\n                    ra = A[w]; rb = B[w]\n                    if depth[v]+1 < depth[w]:\n                        a += min(ra, rb+1)\n                    else:\n                        a += ra\n                A[v] = INF\n                B[v] = a\n            else:\n                a = 0; b = c = INF\n                for w in G0[v]:\n                    ra = A[w]; rb = B[w]\n                    a, b, c = a + ra, min(a + rb, b + ra), min(b + rb, c + min(ra, rb))\n                A[v] = min(a, b+1, c+1)\n                B[v] = b\n\n            p = P[v]\n            if p != -1:\n                deg[p] -= 1\n                if deg[p] == 0:\n                    que.append(p)\n        v = min(A[vs[0]], B[vs[0]])\n        if v >= INF:\n            ans.append(\"-1\\n\")\n        else:\n            ans.append(\"%d\\n\" % v)\n        for v in vs:\n            KS[v] = 0\n\n    writelines(ans)\nsolve()"]
["from itertools import chain\nclass Solution:\n    def regionsBySlashes(self, grid):\n        grid = self.convert_grid(grid)\n        print(*(list(map(str, x)) for x in grid), sep='\\\n')\n        return len([self.destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\n\n    @staticmethod\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(self, x, y, grid):\n        grid[y][x] = 1\n        for c in Solution.search(x, y, grid):\n            self.destroy_island(c[0], c[1], grid)\n\n    @staticmethod\n    def search(x, y, grid):\n        in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\n            d_x, d_y = c[0] - x, c[1] - y\n            sep = '\\\\\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\n                         filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))", "class DSU:\n    def __init__(self):\n        self.parent = {}\n        \n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        \n        return self.parent[x]\n    \n    def union(self, x, y):\n        xroot, yroot = self.find(x), self.find(y)\n        if xroot != yroot:\n            self.parent[yroot] = xroot\n\nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        n = len(grid)\n        dsu = DSU()\n        \n        for i in range(n):\n            for j in range(n):\n                if i > 0:\n                    dsu.union((i - 1, j, 2), (i, j, 0))\n                if j > 0:\n                    dsu.union((i, j - 1, 1), (i, j, 3))\n                if grid[i][j] != '/':\n                    dsu.union((i, j, 0), (i, j, 1))\n                    dsu.union((i, j, 2), (i, j, 3))\n                if grid[i][j] != '\\\\\\\\':\n                    dsu.union((i, j, 3), (i, j, 0))\n                    dsu.union((i, j, 1), (i, j, 2))\n        \n        seen = set()\n        for key in dsu.parent.keys():\n            temp = dsu.find(key)\n            seen.add(temp)\n        \n        return len(seen)", "from typing import List\n\nclass DS:\n    \n    def __init__(self, n):\n        self.sizes = [1] * n\n        self.roots = [i for i in range(n)]\n        \n    def query(self, x):\n        root = x\n        while root != self.roots[root]:\n            self.roots[root] = self.roots[self.roots[root]]\n            root = self.roots[root]\n        return root\n    \n    def union(self, x, y):\n        xRoot, yRoot = self.query(x), self.query(y)\n        s, l = (xRoot, yRoot) if self.sizes[xRoot] < self.sizes[yRoot] else (yRoot, xRoot)\n        self.roots[s] = l\n        self.sizes[l] += self.sizes[s] \n\nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        n = len(grid)\n        nodes = DS(4 * n * n)\n        getIndex = lambda r, c, k: 4 * (n * r + c) + k\n        for i in range(n):\n            for j in range(n):\n                if i > 0: nodes.union(getIndex(i, j, 0), getIndex(i - 1, j, 2))\n                if i < n - 1: nodes.union(getIndex(i, j, 2), getIndex(i + 1, j, 0))\n                if j > 0: nodes.union(getIndex(i, j, 3), getIndex(i, j - 1, 1))\n                if j < n - 1: nodes.union(getIndex(i, j, 1), getIndex(i, j + 1, 3))\n                if grid[i][j] != '/':\n                    nodes.union(getIndex(i, j, 0), getIndex(i, j, 1))\n                    nodes.union(getIndex(i, j, 3), getIndex(i, j, 2))\n                if grid[i][j] != '\\\\\\\\':\n                    nodes.union(getIndex(i, j, 0), getIndex(i, j, 3))\n                    nodes.union(getIndex(i, j, 1), getIndex(i, j, 2))\n        return sum(i == nodes.query(i) for i in range(4 * n * n))", "class Solution:\n    f = {}\n    def find(self, x):\n        self.f.setdefault(x,x)\n        if self.f[x] != x: \n            self.f[x] = self.find(self.f[x])\n        return self.f[x]\n    \n    def union(self, x, y):\n        self.f[self.find(x)] = self.find(y)\n        \n    def regionsBySlashes(self, grid: List[str]) -> int:\n        self.f = {}\n        for row in range(len(grid)):\n            for col in range(len(grid)):\n                if row: \n                    self.union((row-1,col,2),(row,col,0))\n                if col: \n                    self.union((row,col-1,3),(row,col,1))\n                if grid[row][col] != '/':\n                    self.union((row,col,0),(row,col,3))\n                    self.union((row,col,1),(row,col,2))\n                if grid[row][col] != '\\\\\\\\':\n                    self.union((row,col,0), (row,col,1))\n                    self.union((row,col,2), (row,col,3))\n                    \n        return len(set(map(self.find,self.f)))\n    \n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        for i in range(len(grid)):\n            grid[i] = grid[i].replace('\\\\\\\\', '*')\n        N = len(grid)\n        record = [[[0,0,0,0] for j in range(N)] for i in range(N)]\n        #visited = set()\n        #print(grid)\n        count = 0\n        def dfs(i,j,k):\n            if 0 <= i < N and 0 <= j < N and record[i][j][k] == 0:\n                if grid[i][j] == '*':\n                    if k <= 1:\n                        record[i][j][0] = record[i][j][1] = count\n                        dfs(i-1, j, 2)\n                        dfs(i, j+1, 3)\n                    else:\n                        record[i][j][2] = record[i][j][3] = count\n                        dfs(i+1, j, 0)\n                        dfs(i, j-1, 1)\n                elif grid[i][j] == '/':\n                    if 1 <= k <= 2:\n                        record[i][j][1] = record[i][j][2] = count\n                        dfs(i+1, j, 0)\n                        dfs(i, j+1, 3)\n                    else:\n                        record[i][j][0] = record[i][j][3] = count\n                        dfs(i-1, j, 2)\n                        dfs(i, j-1, 1)\n                else:\n                    record[i][j][0] = record[i][j][1] = record[i][j][2] = record[i][j][3] = count\n                    dfs(i-1, j, 2)\n                    dfs(i, j+1, 3)\n                    dfs(i+1, j, 0)\n                    dfs(i, j-1, 1)\n                        \n        for i in range(N):\n            for j in range(N):\n                for k in range(4):\n                    if record[i][j][k] == 0:\n                        count += 1\n                        dfs(i,j,k)\n        return count", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        \n        N = len(grid)\n        \n        matrix = [list(s) for s in grid]\n        \n        parent = list(range(N * N * 4))\n        print(parent)\n        def find(x):\n            depth = 0\n            while parent[x] != x:\n                x = parent[x]\n                depth += 1\n            return x, depth\n        \n        def union(x, y):\n            print((x, y))\n            (rx, dx), (ry, dy) = find(x), find(y)\n            if dx < dy:\n                parent[rx] = ry\n            else:\n                parent[ry] = rx\n        \n        def isValid(i, j):\n            if i >= N or i < 0 or j >= N or j < 0:\n                return False\n            return True\n\n        # dirs = [(0, 1), (-1, 0)]\n        for i in range(N):\n            for j in range(N):\n                idtop = (i * N + j) * 4\n                if matrix[i][j] == '/':\n                    union(idtop + 1, idtop + 2)\n                    union(idtop, idtop + 3)\n                elif matrix[i][j] == '\\\\\\\\':\n                    union(idtop, idtop + 1)\n                    union(idtop + 2, idtop + 3)                \n                else:\n                    union(idtop, idtop + 1)\n                    union(idtop, idtop + 2)\n                    union(idtop, idtop + 3)\n                if isValid(i-1, j):\n                    union(idtop, 4 *((i-1) * N + j) + 2)\n                if isValid(i, j-1):\n                    union(idtop + 3, 4 * (i * N + j - 1) + 1)\n        return len(set(find(x)[0] for x in range(4 * N * N)))\n                        \n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        print(m, n)\n        mat = [[0] * (4*n) for _ in range(4*m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '/':\n                    mat[4*i][4*j+3] = 1\n                    mat[4*i+1][4*j+2] = 1\n                    mat[4*i+2][4*j+1] = 1\n                    mat[4*i+3][4*j] = 1\n                elif grid[i][j] == '\\\\\\\\':\n                    mat[4*i][4*j] = 1\n                    mat[4*i+1][4*j+1] = 1\n                    mat[4*i+2][4*j+2] = 1\n                    mat[4*i+3][4*j+3] = 1\n        # print(mat)\n        dirs = [[-1,0],[1,0],[0,1],[0,-1]]\n        def dfs(i, j):\n            visit[i][j] = 1\n            for d in dirs:\n                x, y = i+d[0], j+d[1]\n                if 0<=x<(4*m) and 0<=y<(4*n) and not mat[x][y]:\n                    mat[x][y] = 1\n                    if not visit[x][y]:\n                        dfs(x, y)\n            \n        visit = [[0]*(4*n) for _ in range(4*m)]\n        res = 0\n        for i in range(4*m):\n            for j in range(4*n):\n                if not mat[i][j]:\n                    res += 1\n                    dfs(i, j)\n        return res", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        n = len(grid)\n        seen = [[[0,0,0,0] for x in range(n)] for y in range(n)]\n        # top 1, left 2, bottom 3, right 0\n        def dfs(x, y, loc):\n            #print(x,y)\n            if not ( 0<=x<n and 0<=y<n) or seen[x][y][loc] == 1:\n                return\n            seen[x][y][loc] = 1\n            \n            if grid[x][y] == '/':\n                if loc == 0:\n                    dfs(x+1,y,2)\n                    seen[x][y][3] = 1\n                    dfs(x, y+1, 1)\n                elif loc == 3:\n                    dfs(x,y+1,1)\n                    seen[x][y][0] = 1\n                    dfs(x+1, y, 2)\n                elif loc == 1:\n                    dfs(x,y-1,3)\n                    seen[x][y][2] = 1\n                    dfs(x-1, y, 0)\n                else:\n                    dfs(x-1,y,0)\n                    seen[x][y][1] = 1\n                    dfs(x, y-1, 3)\n            elif grid[x][y] == '\\\\\\\\':\n                if loc == 0:\n                    dfs(x+1,y,2)\n                    seen[x][y][1] = 1\n                    dfs(x, y-1, 3) \n                elif loc == 3:\n                    dfs(x,y+1,1)\n                    seen[x][y][2] = 1\n                    dfs(x-1, y, 0)\n                elif loc == 1:\n                    dfs(x,y-1,3)\n                    seen[x][y][0] = 1\n                    dfs(x+1, y, 2)\n                else:\n                    dfs(x-1,y,0)\n                    seen[x][y][3] = 1\n                    dfs(x, y+1, 1)\n            else:\n                seen[x][y][1] = 1\n                dfs(x, y-1, 3)\n                seen[x][y][2] = 1\n                dfs(x-1, y, 0)\n                seen[x][y][0] = 1\n                dfs(x+1, y, 2)\n                seen[x][y][3] = 1\n                dfs(x, y+1, 1)\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                for loc in range(4):\n                    k = seen[i][j][loc]\n                    if k == 0:\n                        #print(i,j,k, seen)\n                        count += 1\n                        dfs(i,j,loc)\n        return count", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        \n        N = len(grid)\n        base = N * (N + 1)\n        parent = [i for i in range(2 * base)]\n        \n        def find(x):\n            if parent[x] != parent[parent[x]]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            parent[find(x)] = find(y)\n            return find(y)\n        \n        for i in range(N):\n            for j in range(N):\n                up, down, left, right = i * N + j, (i + 1) * N + j, base + i * (N + 1) + j, base + i * (N + 1) + j + 1\n                \n                if grid[i][j] == '/':\n                    union(up, left)\n                    union(down, right)\n                elif grid[i][j] == '\\\\\\\\':\n                    union(up, right)\n                    union(down, left)\n                else:\n                    union(up, left)\n                    union(down, right)\n                    union(left, right)\n        \n        comp = set()\n        for i in range(2 * base):\n            comp.add(find(i))\n        \n        return len(comp)", "class Solution:\n    \n    def regionsBySlashes(self, grid: List[str]):\n        def minAnglePoint(p1, p2, options):\n            minAngle = 10.0     # a ridiculously big number\n            for p3 in options:\n                a = (p2[0] - p1[0], p2[1] - p1[1])\n                b = (p3[0] - p2[0], p3[1] - p2[1])\n                dot = a[0] * b[0] + a[1] * b[1]\n                det = a[0] * b[1] - a[1] * b[0]\n                ang = math.atan2(det, dot)\n                if ang < minAngle: \n                    minAngle = ang\n                    res = p3\n            return res, minAngle\n\n        N = len(grid)\n        M = dict()\n        for i in range(N):\n            M[(i + 1, 0)] = [(i, 0)]\n            M[(N, i + 1)] = [(N, i)]\n            M[(N - i - 1, N)] = [(N - i, N)]\n            M[(0, N - i - 1)] = [(0, N - i)]\n        for y in range(N):\n            x = 0\n            for c in grid[y]:\n                if c == '/':\n                    if (x + 1, y) in M: \n                        M[(x + 1, y)].append((x, y + 1))\n                    else: \n                        M[(x + 1, y)] = [(x, y + 1)]\n                    if (x, y + 1) in M:\n                        M[(x, y + 1)].append((x + 1, y))\n                    else:\n                        M[(x, y + 1)] = [(x + 1, y)]\n                elif c == '\\\\\\\\':\n                    if (x, y) in M: \n                        M[(x, y)].append((x + 1, y + 1))\n                    else:\n                        M[(x, y)] = [(x + 1, y + 1)]\n                    if (x + 1, y + 1) in M: \n                        M[(x + 1, y + 1)].append((x, y))\n                    else:\n                        M[(x + 1, y + 1)] = [(x, y)]\n                x += 1\n        innerangle = round(-2 * math.pi, 4)\n        points = sorted(M)\n        regions = set()\n        for i in range(len(points)):\n            if points[i] not in M: continue\n            startpoint = points[i]\n            region = {startpoint}\n            point = firststep = M[startpoint][0]\n            M[startpoint].remove(point)\n            prev = startpoint\n            angSum = 0\n            while point != startpoint:\n                region.add(point)\n                links = M[point]\n                nxt, ang = minAnglePoint(prev, point, links)\n                angSum += ang\n                if len(links) == 1: \n                    del M[point]\n                else:\n                    M[point].remove(nxt)\n                prev = point\n                point = nxt\n            if len(M[startpoint]) == 0: \n                del M[startpoint]\n            \n            _, ang = minAnglePoint(prev, point, [firststep])\n            angSum = round(angSum + ang, 4)\n            if angSum == innerangle: # it is a valid region\n                regions.add(frozenset(region))\n        return len(regions)", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        N = len(grid)\n        new_grid = [[0]*(2*N) for _ in range(2*N)]\n        count = 0\n        \n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == '/':\n                    new_grid[2*i][2*j+1] = 1\n                    new_grid[2*i+1][2*j] = 1\n                elif grid[i][j] == '\\\\\\\\':\n                    new_grid[2*i][2*j] = 1\n                    new_grid[2*i+1][2*j+1] = 1\n        \n        def dfs(grid, i, j):\n            # starting with a seed (0 in location i,j), build up an open space\n            if grid[i][j] == 1:\n                return None\n            grid[i][j] = 1 # mark as visited\n            if i < len(grid)-1: # (make sure i+1 exists)\n                dfs(grid, i+1, j) # search down \n            if j < len(grid)-1: \n                dfs(grid, i, j+1)# search right\n            if i > 0:\n                dfs(grid, i-1, j) # search up\n            if j > 0:\n                dfs(grid, i, j-1) #search left\n            # search dl\n            if i < len(grid)-1 and j > 0 and i%2==j%2:\n                dfs(grid, i+1, j-1)\n            # search ur\n            if i > 0 and j < len(grid)-1 and i%2==j%2:\n                dfs(grid, i-1, j+1)\n            # search dr\n            if i < len(grid)-1 and j < len(grid)-1 and i%2!=j%2:\n                dfs(grid, i+1, j+1)\n            # search ul\n            if i > 0 and j > 0 and i%2!=j%2:\n                dfs(grid, i-1, j-1)\n        \n        # search for seeds (new islands)\n        for i in range(2*N):\n            for j in range(2*N):\n                if new_grid[i][j] == 0:\n                    count += 1\n                    dfs(new_grid, i, j) # seed an island\n        \n        return count\n                    \n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        nrow = len(grid)\n        ncol = len(grid[0])\n        newgrid = []\n        for i in range(nrow*3):\n            newgrid.append([0]*ncol*3)\n        for r in range(nrow):\n            for c in range(ncol):\n                if grid[r][c] == '\\\\\\\\':\n                    newgrid[r*3][c*3] = 1\n                    newgrid[r*3+1][c*3+1] = 1\n                    newgrid[r*3+2][c*3+2] = 1\n                elif grid[r][c] == '/':\n                    newgrid[r*3+2][c*3] = 1\n                    newgrid[r*3+1][c*3+1] = 1\n                    newgrid[r*3][c*3+2] = 1\n        \n        def countIsland(newgrid):\n            count = 0\n            def dfs(r,c):\n                if newgrid[r][c] == 0:\n                    newgrid[r][c] =1\n                    if r < len(newgrid) -1 and newgrid[r+1][c] ==0:\n                        dfs(r+1,c)\n                    if c < len(newgrid[0]) -1 and newgrid[r][c+1] ==0:\n                        dfs(r,c+1)\n                    if r > 0 and newgrid[r-1][c] ==0:\n                        dfs(r-1,c)\n                    if c > 0 and newgrid[r][c-1] ==0:\n                        dfs(r,c-1)\n                    \n                \n            for r1 in range(len(newgrid)):\n                for c1 in range(len(newgrid[0])):\n                    if newgrid[r1][c1] == 0:\n                        dfs(r1,c1)\n                        count+=1\n                    else:\n                        pass\n            return(count)\n        \n        return(countIsland(newgrid))", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        N = len(grid)     \n        D = list(range(N*N*4))\n        res = [len(D)]\n        def find(D,i):\n            if D[i]==i:\n                return i\n            return find(D,D[i])\n        \n        def union(D,i,j):\n            pi = find(D,i)\n            pj = find(D,j)\n            if pi==pj:\n                return\n            else:\n                D[pi] = pj\n                res[0] -= 1\n                \n        def idx(i,j,e):\n            return (i*N+j)*4+e\n        \n        \n        \n        for i in range(N):\n            for j in range(N):\n                if i>0:\n                    union(D,idx(i-1,j,2),idx(i,j,0))\n                if j>0:\n                    union(D,idx(i,j-1,1,),idx(i,j,3))\n                if grid[i][j]!='/':\n                    union(D,idx(i,j,0),idx(i,j,1))\n                    union(D,idx(i,j,2),idx(i,j,3))\n                if grid[i][j]!='\\\\\\\\':\n                    union(D,idx(i,j,0),idx(i,j,3))\n                    union(D,idx(i,j,1),idx(i,j,2))\n        return res[0]\n        \n                    \n                    \n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        parent = {}\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rx, ry = find(x), find(y)\n            if rx == ry:\n                return False\n            parent[rx] = ry\n            return True\n        \n        res = m * n * 4\n        for i in range(m):\n            for j in range(n):\n                for k in range(4):\n                    parent[(i, j, k)] = (i, j, k)\n                if grid[i][j] == '/':\n                    if union((i, j, 0), (i, j, 3)):\n                        res -= 1\n                    if union((i, j, 1), (i, j, 2)):\n                        res -= 1\n                elif grid[i][j] == '\\\\\\\\':\n                    if union((i, j, 0), (i, j, 1)):\n                        res -= 1\n                    if union((i, j, 2), (i, j, 3)):\n                        res -= 1\n                else:\n                    if union((i, j, 0), (i, j, 1)):\n                        res -= 1\n                    if union((i, j, 2), (i, j, 3)):\n                        res -= 1\n                    if union((i, j, 0), (i, j, 3)):\n                        res -= 1\n                \n                if i > 0:\n                    if union((i, j, 0), (i - 1, j, 2)):\n                        res -= 1\n                if j > 0:\n                    if union((i, j, 3), (i, j - 1, 1)):\n                        res -= 1\n        return res", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        self.N = len(grid)#n\u884c\n        print((self.N))\n        pre = list(range(self.N*self.N*4))#\u6240\u6709\u5143\u7d20\u81ea\u5df1\u662f\u81ea\u5df1\u7684\u7236\u8282\u70b9[0,1,2,3,4,5,6,...]\n        self.count = self.N*self.N*4 #\u603b\u5171\u7684\u533a\u57df\u6570\u91cf\n        for r in range(self.N):\n            line = grid[r]\n            for c in range(self.N):\n                w = line[c]\n                if r > 0:\n                    self.union(pre, self.g(r - 1, c, 2), self.g(r, c, 0))\n                if c > 0:\n                    self.union(pre, self.g(r, c - 1, 1), self.g(r, c, 3))\n                if w != '/':\n                    self.union(pre, self.g(r, c, 0), self.g(r, c, 1))\n                    self.union(pre, self.g(r, c, 3), self.g(r, c, 2))\n                if w != '\\\\\\\\':\n                    self.union(pre, self.g(r, c, 0), self.g(r, c, 3))\n                    self.union(pre, self.g(r, c, 1), self.g(r, c, 2))\n        return self.count   \n        \n    def find(self,pre,x):\n        if x == pre[x]:\n            return x\n            \n        return self.find(pre,pre[x])\n    def union(self, pre, a, b):\n        pa = self.find(pre, a)\n        pb = self.find(pre, b)\n        if (pa == pb):\n            return\n        pre[pa] = pb\n        self.count -= 1\n    \n    def g(self, r, c, i):\n        return (r * self.N + c) * 4 + i\n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        f = {}\n        def find(x):\n            if (x not in f):\n                f[x] = x\n            elif(f[x] != x):\n                f[x] = find(f[x])\n            return f[x]\n        def merge(x,y):\n            rx,ry = find(x),find(y)\n            f[rx] = ry\n\n        rows, cols = len(grid), len(grid[0]) if grid else 0\n        for i in range(rows):\n            for j in range(cols):\n                cur = (i * cols + j) * 4\n                up, left = ((i - 1) * cols + j) * 4, (i * cols + j - 1) * 4\n                cl, cr, cd = cur + 3, cur + 1, cur + 2\n                lr,ud = left + 1, up + 2\n                if (grid[i][j] == '/'):\n                    merge(cur, cl)\n                    merge(cr, cd)\n                elif (grid[i][j] == '\\\\\\\\'):\n                    merge(cur, cr)\n                    merge(cl, cd)\n                else:\n                    merge(cur, cr)\n                    merge(cl, cd)\n                    merge(cur, cl)\n                if (i >= 1):\n                    merge(cur,ud)\n                if (j >= 1):\n                    merge(cl,lr)\n        res = 0\n        for i in range(rows):\n            for j in range(cols):\n                cur = (i * cols + j) * 4\n                for dx in range(4):\n                    if (cur+dx == find(cur+dx)):\n                        res += 1\n        return res\n", "class UnionFind:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.rank = [0]*N\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px==py: return\n        \n        if self.rank[px]<self.rank[py]:\n            self.par[px] = py\n        elif self.rank[px]>self.rank[py]:\n            self.par[py] = px\n        else:\n            self.par[py] = px\n            self.rank[px] += 1\n        \nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        N = len(grid)\n        uf = UnionFind(4*N*N)\n        \n        for i in range(N):\n            for j in range(N):\n                idx = 4*(i*N+j)\n                if grid[i][j]!='/':\n                    uf.union(idx, idx+1)\n                    uf.union(idx+2, idx+3)\n                if grid[i][j]!='\\\\\\\\':\n                    uf.union(idx, idx+3)\n                    uf.union(idx+1, idx+2)\n\n                if i:\n                    uf.union(idx, idx-4*N+2)\n                if j:\n                    uf.union(idx+3, idx-4+1)\n        # print(uf.par)\n        return sum(uf.find(x)==x for x in range(4*N*N))", "class Unionset:\n    def __init__(self,N):\n        self.parent=[x for x in range(N)]\n        self.rank=[0 for x in range(N)]\n    def find(self,x):\n        if self.parent[x]!=x:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    def union(self,x,y):\n        xx=self.find(x)\n        yy=self.find(y)\n        if self.parent[xx]==self.parent[yy]:\n            return True\n        if self.rank[xx]>self.rank[yy]:\n            self.parent[yy]=self.parent[xx]\n        elif self.rank[xx]<self.rank[yy]:\n            self.parent[xx]=self.parent[yy]\n        else:\n            self.rank[xx]+=1\n            self.parent[yy]=self.parent[xx]\n        return False\n            \n    \nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        n=len(grid)\n        ds=Unionset(n*n*4)\n        #print(ds.parent)\n        for r in range(n):\n            for c in range(n):\n                root=4*(r*n+c)\n                if grid[r][c]=='/':\n                    ds.union(root,root+1)\n                    ds.union(root+2,root+3)\n                elif grid[r][c]=='\\\\\\\\':\n                    ds.union(root,root+2)\n                    ds.union(root+1,root+3)\n                else:\n                    ds.union(root,root+1)\n                    ds.union(root+1,root+2)\n                    ds.union(root+2,root+3)\n                #print(grid[r][c])\n                #print(\\\"first\\\",ds.parent)\n                if r+1<n:\n                    ds.union(root+3,root+(4*n))\n                if c+1<n:\n                    ds.union(root+2,root+5)\n                #print(\\\"second\\\",ds.parent)\n        tot=0\n        for i in range(4*n*n):\n            if ds.find(i)==i:\n                tot+=1\n        return tot\n", "#\n# *-------*\n# | \\\\ 0 / |\n# | 3 * 1 |\n# | / 2 \\\\ |\n# *-------*\nclass DSU:\n    def __init__(self, N):\n        self.pres = list(range(N))  #   \u521d\u59cb\uff0c\u6bcf\u4e2a\u8282\u70b9\u6307\u5411\u81ea\u5df1\n    def setRoot(self, i, root):\n        while self.pres[i] != root:\n            t = self.pres[i]\n            self.pres[i] = root\n            i = t\n        return \n    def findRoot(self, i):\n        root = i\n        while root != self.pres[root]:\n            root = self.pres[root]\n        self.setRoot(i, root)\n        return root\n    def merge(self, i, j):\n        root = self.findRoot(i)\n        self.setRoot(j, root)\n    \n    \nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        def getPos(N, h, w, i):\n            return N*4 * h + 4*w + i\n\n        #   \u501f\u9274\u4e09\u89d2\u9762\u7247\u601d\u8def\n        N = len(grid)\n        NN4 = N*N*4\n        dsu = DSU(NN4)\n        \n        #   \u5408\u5e76\u4e34\u8fd1\u77e9\u5f62\n        for h in range(N):\n            for w in range(N):\n                p  = getPos(N, h, w, 0)\n                pR = getPos(N, h, w+1, 0)\n                pD = getPos(N, h+1, w, 0)                \n                pRD= getPos(N, h+1, w+1, 0)\n                if h < N-1:\n                    dsu.merge(p+2, pD+0)\n                if w < N-1:\n                    dsu.merge(p+1, pR+3)\n                \n\n        #   \u68c0\u67e5\u8f93\u5165\u7f51\u683c\n        for h in range(N):\n            for w in range(N):\n                p  = getPos(N, h, w, 0)\n                if grid[h][w] == '/':\n                    dsu.merge(p+0, p+3)\n                    dsu.merge(p+1, p+2)\n                elif grid[h][w] == '\\\\\\\\':\n                    dsu.merge(p+0, p+1)\n                    dsu.merge(p+2, p+3)\n                else:\n                    dsu.merge(p+0, p+1)\n                    dsu.merge(p+0, p+2)\n                    dsu.merge(p+0, p+3)\n        \n        return sum(dsu.findRoot(x) == x for x in range(NN4))\n\n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        N = len(grid)\n        new_grid = [[0]*(2*N) for _ in range(2*N)]\n        count = 0\n        \n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == '/':\n                    new_grid[2*i][2*j+1] = 1\n                    new_grid[2*i+1][2*j] = 1\n                elif grid[i][j] == '\\\\\\\\':\n                    new_grid[2*i][2*j] = 1\n                    new_grid[2*i+1][2*j+1] = 1\n        \n        def dfs(grid, i, j):\n            # starting with a seed (0 in location i,j), build up an open space\n            if grid[i][j] == 1:\n                return None\n            grid[i][j] = 1 # mark as visited\n            if i < len(grid)-1: # (make sure i+1 exists)\n                dfs(grid, i+1, j) # search down \n            if j < len(grid)-1: \n                dfs(grid, i, j+1)# search right\n            if i > 0:\n                dfs(grid, i-1, j) # search up\n            if j > 0:\n                dfs(grid, i, j-1) #search left\n            # search dl\n            if i < len(grid)-1 and j > 0 and i%2==j%2:\n                dfs(grid, i+1, j-1)\n            # search ur\n            if i > 0 and j < len(grid)-1 and i%2==j%2:\n                dfs(grid, i-1, j+1)\n            # search dr\n            if i < len(grid)-1 and j < len(grid)-1 and i%2!=j%2:\n                dfs(grid, i+1, j+1)\n            # search ul\n            if i > 0 and j > 0 and i%2!=j%2:\n                dfs(grid, i-1, j-1)\n            \n            \n            \n        \n        # search for seeds\n        for i in range(2*N):\n            for j in range(2*N):\n                if new_grid[i][j] == 0:\n                    count += 1\n                    dfs(new_grid, i, j) # seed an island\n        \n        return count\n                    \n            \n", "class Solution:\n    def regionsBySlashes(self, grid):\n        n = len(grid)\n        g = [[0 for _ in range(n*3)] for _ in range(n*3)]\n        \n        def dfs(i, j):\n            if 0 <= i < (n*3) and 0 <= j < (n*3) and g[i][j] == 0:\n                g[i][j] = 1\n                for k in [1, -1]:\n                    dfs(i+k, j)\n                    dfs(i, j+k)\n                    \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '/':\n                    g[i*3][(j*3) + 2] = 1\n                    g[(i*3) + 1][(j*3) + 1] = 1\n                    g[(i*3) + 2][j*3] = 1\n                elif grid[i][j] == '\\\\\\\\':\n                    g[i*3][j*3] = 1\n                    g[(i*3) + 1][(j*3) + 1] = 1\n                    g[(i*3) + 2][(j*3) + 2] = 1\n        res = 0\n        for i in range(n*3):\n            for j in range(n*3):\n                if g[i][j] == 0:\n                    dfs(i, j)\n                    res += 1\n        return res", "class Solution:\n    def regionsBySlashes(self, g: List[str]) -> int:\n        \n        n = len(g)\n        \n        grid = [[0]*(n*3) for j in range(n*3)]\n        \n        for i in range(n):\n            \n            for j in range(n):\n                \n                if g[i][j] == '/':\n                    \n                    grid[i*3][j*3+2] = 1\n                    \n                    grid[i*3+1][j*3+1] = 1\n                    \n                    grid[i*3+2][j*3] = 1\n                    \n                elif g[i][j] == '\\\\\\\\':\n                    \n                    grid[i*3][j*3] = 1\n                    \n                    grid[i*3+1][j*3+1] = 1\n                    \n                    grid[i*3+2][j*3+2] = 1\n     \n                    \n        def dfs(i,j):\n            \n            grid[i][j] = 1\n            \n            for r in [(i+1,j), (i,j+1), (i-1,j), (i,j-1)]:\n                \n                xx,yy = r\n                \n                if xx < 0 or yy < 0 or xx >= len(grid) or yy >= len(grid[0]) or grid[xx][yy] == 1:\n                    continue\n                    \n                dfs(xx,yy)\n                \n                \n        count = 0\n        \n        for i in range(n*3):\n            for j in range(n*3):\n                \n                if grid[i][j] == 0:\n                    \n                    dfs(i,j)\n                    \n                    count += 1\n                    \n        return count", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        if not grid:\n            return 0\n        \n        rows, cols = len(grid), len(grid[0])\n        new_grid = [[0] * 3 * cols for _ in range(3 * rows)]\n        visited = [[False] * 3 * cols for _ in range(3 * rows)]\n        \n        for i in range(rows):\n            line = grid[i]\n        \n            for j in range(len(line)):\n                if line[j] == '/':\n                    new_grid[3 * i][3 * j + 2] = 1\n                    new_grid[3 * i + 1][3 * j + 1] = 1\n                    new_grid[3 * i + 2][3 * j] = 1\n                elif line[j] == '\\\\\\\\':\n                    new_grid[3 * i][3 * j] = 1\n                    new_grid[3 * i + 1][3 * j + 1] = 1\n                    new_grid[3 * i + 2][3 * j + 2] = 1\n                    \n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= 3 * rows or j >= 3 * cols or new_grid[i][j] == 1 or visited[i][j]:\n                return\n            \n            visited[i][j] = True\n            \n            dfs(i, j + 1)\n            dfs(i + 1, j)\n            dfs(i, j - 1)\n            dfs(i - 1, j)\n            \n        count = 0\n            \n        for i in range(3 * rows):\n            for j in range(3 * cols):\n                if not visited[i][j] and new_grid[i][j] == 0:\n                    dfs(i, j)\n                    count += 1\n            \n        return count", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        n = len(grid)\n        m, ans = [[[0, 0, 0, 0] for j in range(n)] for i in range(n)], 0\n        \n        def dfs(i, j, k):\n            if 0 <= i < n and 0 <= j < n and not m[i][j][k]:\n                if grid[i][j] == '/':\n                    if 1 <= k <= 2:\n                        m[i][j][1] = m[i][j][2] = ans\n                        dfs(i, j+1, 3)\n                        dfs(i+1, j, 0)\n                    else:\n                        m[i][j][0] = m[i][j][3] = ans \n                        dfs(i-1, j, 2)\n                        dfs(i, j-1, 1)\n                elif grid[i][j] == '\\\\\\\\':\n                    if k <= 1:\n                        m[i][j][0] = m[i][j][1] = ans\n                        dfs(i-1, j, 2)\n                        dfs(i, j+1, 3)\n                    else:\n                        m[i][j][2] = m[i][j][3] = ans \n                        dfs(i+1, j, 0)\n                        dfs(i, j-1, 1)\n                else:\n                    m[i][j][0] = m[i][j][1] = m[i][j][2] = m[i][j][3] = ans \n                    dfs(i-1, j, 2)\n                    dfs(i, j-1, 1)\n                    dfs(i+1, j, 0)\n                    dfs(i, j+1, 3)\n                    \n        \n        for i in range(n):\n            for j in range(n):\n                for k in range(4):\n                    if not m[i][j][k]:\n                        ans += 1\n                        dfs(i, j, k)\n                        \n        return ans \n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        if len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n        \n        roots = {}\n        \n        def find(x):\n            roots.setdefault(x, x)\n            \n            if roots[x] != x:\n                roots[x] = find(roots[x])\n            \n            return roots[x]\n        \n        def union(x, y):\n            roots[find(x)] = find(y)\n        \n        # k=0 top\n        # k=1 right\n        # k=2 bottom\n        # k=3 left\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i > 0:\n                    union((i-1, j, 2), (i, j, 0))\n                \n                if j > 0:\n                    union((i, j-1, 1), (i, j, 3))\n                \n                if grid[i][j] != '/':\n                    union((i, j, 0), (i, j, 1))\n                    union((i, j, 2), (i, j, 3))\n                \n                if grid[i][j] != '\\\\\\\\':\n                    union((i, j, 0), (i, j, 3))\n                    union((i, j, 1), (i, j, 2))\n                    \n        return len(set(find(x) for x in list(roots.keys())))\n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        \n        N = len(grid)\n        \n        matrix = grid\n        \n        parent = list(range(N * N * 4))\n        # print(parent)\n        def find(x):\n            depth = 0\n            while parent[x] != x:\n                x = parent[x]\n                depth += 1\n            return x, depth\n        \n        def union(x, y):\n            # print(x, y)\n            (rx, dx), (ry, dy) = find(x), find(y)\n            if dx < dy:\n                parent[rx] = ry\n            else:\n                parent[ry] = rx\n        \n        def isValid(i, j):\n            if i >= N or i < 0 or j >= N or j < 0:\n                return False\n            return True\n\n        for i in range(N):\n            for j in range(N):\n                idtop = (i * N + j) * 4\n                if matrix[i][j] == '/':\n                    union(idtop + 1, idtop + 2)\n                    union(idtop, idtop + 3)\n                elif matrix[i][j] == '\\\\\\\\':\n                    union(idtop, idtop + 1)\n                    union(idtop + 2, idtop + 3)                \n                else:\n                    union(idtop, idtop + 1)\n                    union(idtop, idtop + 2)\n                    union(idtop, idtop + 3)\n                if isValid(i-1, j):\n                    union(idtop, 4 *((i-1) * N + j) + 2)\n                if isValid(i, j-1):\n                    union(idtop + 3, 4 * (i * N + j - 1) + 1)\n        return sum(find(x)[0] == x for x in range(4 * N * N))\n                        \n", "class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        \n        root = {}\n        \n        def find(x):\n            root.setdefault(x, x)\n            if root[x] != x:  # not find( root[x]  )\n                root[x] = find( root[x]  )\n            return root[x]\n        \n        def union(x, y):\n            rx, ry = find(x), find(y)\n            \n            if rx != ry:\n                root[ry] = find(rx)\n                \n        for i in range(len(grid)):\n            for j in range(len(grid)):\n                if i:\n                    union( (i-1,j, 2), (i,j, 0)  )\n                if j:\n                    union( (i,j-1, 1), (i,j, 3)  )\n                if grid[i][j] == '/':\n                    union( (i,j, 0), (i,j, 3)  )\n                    union( (i,j, 1), (i,j, 2)  )\n                elif grid[i][j] == '\\\\\\\\':\n                    union( (i,j, 0), (i,j, 1)  )\n                    union( (i,j, 2), (i,j, 3)  )\n                else:\n                    union( (i,j, 0), (i,j, 1)  )\n                    union( (i,j, 0), (i,j, 2)  )\n                    union( (i,j, 0), (i,j, 3)  )\n        \n        return len( set( map(find, list(root.keys())) ) )\n                \n        \n", "from itertools import chain\nclass Solution:\n    def regionsBySlashes(self, grid):\n        grid = convert_grid(grid)\n        return len([destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\n\ndef destroy_island(x, y, grid):\n    grid[y][x] = 1\n    for c in search(x, y, grid):\n        destroy_island(c[0], c[1], grid)\n\ndef search(x, y, grid):\n    in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n    check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\n    def check_diag(c):\n        if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\n        d_x, d_y = c[0] - x, c[1] - y\n        sep = '\\\\\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\n        return grid[y + d_y][x] != sep or grid[y][x + d_x] != sep\n    yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\n                     filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n\ndef convert_grid(grid):\n    new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n    for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\\\\\/'):\n        new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n        new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n    return new_grid", "from itertools import chain\nclass Solution:\n    def regionsBySlashes(self, grid):\n        grid = convert_grid(grid)\n        return len([destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\n\ndef destroy_island(x, y, grid):\n    grid[y][x] = 1\n    for c in search(x, y, grid):\n        destroy_island(c[0], c[1], grid)\n\ndef search(x, y, grid):\n    in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n    check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\n    def check_diag(c):\n        if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\n        d_x, d_y = c[0] - x, c[1] - y\n        sep = '\\\\\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\n        return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n    yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\n                     filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n\ndef convert_grid(grid):\n    new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n    for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\\\\\/'):\n        new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n        new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n    return new_grid", "from itertools import chain\nclass Solution:\n    def regionsBySlashes(self, grid):\n        grid = convert_grid(grid)\n        print(*(list(map(str, x)) for x in grid), sep='\\\n')\n        return len([destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\n\ndef destroy_island(x, y, grid):\n    grid[y][x] = 1\n    for c in search(x, y, grid):\n        destroy_island(c[0], c[1], grid)\n\ndef search(x, y, grid):\n    in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n    check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\n    def check_diag(c):\n        if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\n        d_x, d_y = c[0] - x, c[1] - y\n        sep = '\\\\\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\n        return grid[y + d_y][x] != sep or grid[y][x + d_x] != sep\n    yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\n                     filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n\ndef convert_grid(grid):\n    new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n    for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\\\\\/'):\n        new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n        new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n    return new_grid"]
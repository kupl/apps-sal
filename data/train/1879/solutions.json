["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        q = [root]\n        while q:\n            pre, q = q, [child for p in q for child in [p.left, p.right] if child]\n        return sum(node.val for node in pre)\n       \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    node_sum = 0\n    most_depth = 0\n    \n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        depth = 0\n        self.generate_deepest_node_map(root, depth)\n        return self.node_sum\n            \n    def generate_deepest_node_map(self, node, depth):\n        if node:\n            if node.left:\n                self.generate_deepest_node_map(node.left, depth + 1)\n            if node.right:\n                self.generate_deepest_node_map(node.right, depth + 1)\n            if not node.right and not node.left:\n                if self.most_depth == depth:\n                    self.most_depth = depth\n                    self.node_sum += node.val\n                if self.most_depth < depth:\n                    self.most_depth = depth\n                    self.node_sum = node.val\n                \n            \n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        treeDict = defaultdict(list)\n        \n        def treeLevel(root, level):\n            if not root:\n                return \n            else:\n                treeDict[level].append(root.val)\n                \n            treeLevel(root.left, level+1)\n            treeLevel(root.right, level+1)\n            \n        treeLevel(root, 0)\n        \n        return sum(treeDict[list(treeDict.keys())[-1]])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        ### DFS?\n        nxt = [(0,root)]\n        tot = 0\n        depth = 0\n        while nxt: \n            d, cur = nxt.pop()\n            if d == depth:\n                tot += cur.val\n            elif d > depth:\n                tot = cur.val\n                depth = d\n            nxt.extend([(d+1,x) for x in [cur.left,cur.right] if x])\n        return tot\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        s = {}\n\n        def check(root, depth, s):\n            if root == None:\n                return 0\n            \n            if depth not in s:\n                s[depth] = [root.val]\n            else:\n                s[depth].append(root.val)\n                \n            check(root.left, depth+1, s)\n            check(root.right, depth+1, s)\n            \n            return s\n        \n        check(root, 0, s)\n        \n        m = max(s.keys())\n        \n        return sum(s[m])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        this_q = [root]\n        result = 0\n        \n        while this_q:\n            next_q = []\n            temp = 0\n            for node in this_q:\n                temp += node.val\n                if node.left:\n                    next_q.append(node.left)\n                if node.right:\n                    next_q.append(node.right)\n            \n            this_q = next_q\n            result = max(0, temp)\n            \n        return result", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        #zoe  bfs\n        # s = 0\n        # q = deque()\n        # temp = []\n        # if root == None:\n        #     return s\n        # q.append(root)\n        # while q:\n        #     node = q.pop()\n        #     s += node.val\n        #     if node.left: temp.append(node.left)\n        #     if node.right: temp.append(node.right)\n        #     if not q:\n        #         if not temp:\n        #             return s\n        #         else:\n        #             q.extend(temp)\n        #             temp = []\n        #             s = 0\n        # return\n        \n        q = [root]\n        while q:\n            pre, q = q, [child for p in q for child in [p.left, p.right] if child]\n        return sum(node.val for node in pre)\n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        \n        def maxDepth(rt):\n            root=rt\n            if root ==None:\n                return 0\n            #print(root)\n            stack_list=[(root,1)]\n            maxh=1\n            if root.left==None and root.right==None:\n                return maxh\n\n\n            while len(stack_list)!=0:\n\n                r,v=stack_list.pop()\n                #print(r)\n                #print(v)\n                if r.right==None and r.left==None:\n                    #stack_list.append()\n                    if v>maxh:\n                        maxh=v\n\n\n                if r.left!=None:\n                    #v=v+1\n                    stack_list.append((r.left,v+1))\n                if r.right!=None:\n                    #v=v+1\n                    stack_list.append((r.right,v+1))\n            return maxh\n        htmax=maxDepth(root)\n        \n        if htmax==0:\n            return 0\n        #stack=[root]\n        \n        stack_list=[(root,1)]\n        #maxh=1\n        dmax=0\n        if root.left==None and root.right==None:\n            return root.val\n\n        maxh=1\n        while len(stack_list)!=0:\n\n            r,v=stack_list.pop()\n            #print(r)\n            #print(v)\n            if r.right==None and r.left==None:\n                #stack_list.append()\n                if v>maxh:\n                    maxh=v\n\n\n            if r.left!=None:\n                #v=v+1\n                stack_list.append((r.left,v+1))\n                if v+1==htmax:\n                    dmax=dmax+r.left.val\n                \n            if r.right!=None:\n                #v=v+1\n                stack_list.append((r.right,v+1))\n                if v+1==htmax:\n                    dmax=dmax+r.right.val\n        return dmax\n        \n        \n        \n        \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        s = 0\n        q = deque()\n        temp = deque()\n        if root == None:\n            return s\n        q.append(root)\n        while q:\n            node = q.pop()\n            s += node.val\n            if node.left: temp.append(node.left)\n            if node.right: temp.append(node.right)\n            if not q:\n                if not temp:\n                    return s\n                else:\n                    q = temp\n                    temp = deque()\n                    s = 0\n        return\n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        if not root:\n            return None\n        queue = []\n        queue.append(root)\n        result = []\n        while len(queue) > 0:\n            levellength = len(queue)\n            temp = []\n            for i in range(levellength):\n                node = queue.pop(0)\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if len(temp) > 0:\n                result.append(temp)\n        return sum(result[-1])", "from collections import namedtuple\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nleaf_info = namedtuple(\\\"Leaf_Info\\\", \\\"depth sum\\\")\n\n\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        def is_leaf(node: TreeNode) -> bool:\n            return node.left is None and node.right is None\n\n        def leaves(node: TreeNode, depth: int, path_sum: int) -> leaf_info:\n            if node is None:\n                yield leaf_info(0, 0)\n            elif is_leaf(node):\n                yield leaf_info(depth, node.val)\n            else:\n                yield from leaves(node.left, depth + 1, path_sum)\n                yield from leaves(node.right, depth + 1, path_sum)\n        \n        max_depth = 0\n        leaves_sum = 0\n        for leaf in leaves(root, 0, 0):\n            if leaf.depth > max_depth:\n                max_depth, leaves_sum = leaf\n            elif leaf.depth == max_depth:\n                leaves_sum += leaf.sum\n\n        return leaves_sum\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        # s = 0\n        # q = deque()\n        # temp = []\n        # if root == None:\n        #     return s\n        # q.append(root)\n        # while q:\n        #     node = q.pop()\n        #     s += node.val\n        #     if node.left: temp.append(node.left)\n        #     if node.right: temp.append(node.right)\n        #     if not q:\n        #         if not temp:\n        #             return s\n        #         else:\n        #             q.extend(temp)\n        #             temp = []\n        #             s = 0\n        # return\n        \n        q = [root]\n        while q:\n            pre, q = q, [child for p in q for child in [p.left, p.right] if child]\n        return sum(node.val for node in pre)\n        \n        \n", "# Definition for a binary tree node.\\r\n# class TreeNode:\\r\n#     def __init__(self, val=0, left=None, right=None):\\r\n#         self.val = val\\r\n#         self.left = left\\r\n#         self.right = right\\r\nclass Solution:\\r\n    def deepestLeavesSum(self, root: TreeNode) -> int:\\r\n        currentLevel = [root]\\r\n        while currentLevel:\\r\n            currentSum = 0\\r\n            nextLevel = []\\r\n            for node in currentLevel:\\r\n                currentSum += node.val\\r\n                if node.left:\\r\n                    nextLevel.append(node.left)\\r\n                if node.right:\\r\n                    nextLevel.append(node.right)\\r\n            currentLevel = nextLevel\\r\n        return currentSum", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport collections\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        total, maxLevel = 0, 0\n        def helper(node, level):\n            if not node:\n                return\n            nonlocal total\n            nonlocal maxLevel\n            print((total, maxLevel, node.val, level))\n            if level > maxLevel:\n                print(('here', level, maxLevel))\n                total = node.val\n                maxLevel = level\n            elif level == maxLevel:\n                total += node.val\n            \n            helper(node.left, level + 1)\n            helper(node.right, level + 1)\n        \n        \n        helper(root, 0)\n        print(total)\n        return total\n    \n            \n\n           \n        \n        \n", "import queue\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        q = queue.deque()\n        q.append(root)\n        ans = 0\n        while q:\n            ans = 0\n            for _ in range(len(q)):\n                cur_node = q.popleft()\n                ans += cur_node.val\n                if cur_node.left:\n                    q.append(cur_node.left)\n                if cur_node.right:\n                    q.append(cur_node.right)\n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        \n        stack=[(root,0)]\n        if not root:return 0\n        leaf_nodes=[]\n        max_depth,deepest_sum=0,0\n        while stack:\n            node,depth=stack.pop()\n            \n            if depth>max_depth:\n                max_depth=depth\n                deepest_sum=node.val\n            elif depth==max_depth:\n                deepest_sum+=node.val\n            \n            if node.right:\n                stack.append((node.right,depth+1))\n            if node.left:\n                stack.append((node.left,depth+1))\n                \n        \n        return deepest_sum\n        \n#         stack=[(root,0)]\n#         if not root:return 0\n#         leaf_nodes=[]\n#         max_depth=0\n#         while stack:\n#             node,depth=stack.pop()\n#             max_depth=max(max_depth,depth)\n#             if not node.left and not node.right:\n#                 leaf_nodes.append((node.val,depth))\n            \n#             if node.right:\n#                 stack.append((node.right,depth+1))\n#             if node.left:\n#                 stack.append((node.left,depth+1))\n                \n#         sum_=0\n#         for vals,depth in leaf_nodes:\n#             if depth==max_depth:\n#                 sum_+=vals\n#         return sum_\n                \n        \n                \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        \n        def traverse(node: TreeNode, layer: int, nums: List[int]):\n            if node is None:\n                return\n            \n            while len(nums) < layer+1:\n                nums.append([])\n            nums[layer].append(node.val)\n            \n            traverse(node.left,layer+1,nums)\n            traverse(node.right,layer+1,nums)\n        \n        by_layer = []\n        \n        traverse(root,0,by_layer)\n        # print(by_layer)\n        return sum(by_layer[-1])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        queue=deque([(root,0)])\n        res=defaultdict(list)\n        while queue:\n            top,l=queue.popleft()\n            res[l].append(top.val)\n            if top.left:\n                queue.append((top.left,l+1))\n            if top.right:\n                queue.append((top.right,l+1))\n        maxidx=max(sorted(res))\n        return sum(res[maxidx])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        self.sum_ = 0\n        self.h = self.getHeight(root)\n            \n        self.helper(root, 1)\n        return self.sum_\n    def helper(self, node, height):\n            if not node: return\n            self.helper(node.left, height+1)\n            self.helper(node.right, height+1)\n            \n            if height == self.h:\n                self.sum_ += node.val\n                \n    def getHeight(self, node):\n        if not node: return 0\n        return 1 + max(self.getHeight(node.left), self.getHeight(node.right))", "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        queue = deque([root])\n        last_t = 0\n        while queue:\n            l_sum = 0\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                l_sum += node.val\n\n                if node.left is not None:\n                    queue.append(node.left)\n\n                if node.right is not None:\n                    queue.append(node.right)\n\n            l_sum, last_t = 0, l_sum\n            \n        return last_t\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def findDepth(self,root: TreeNode) -> int:\n        if root == None:\n            return 0\n        if root.left == None and root.right == None:\n            return 1\n        return 1 + max(self.findDepth(root.left),self.findDepth(root.right))\n    \n    def deepestHelper(self,root: TreeNode,c: int, d: int) -> int:\n        total = 0\n        if root == None:\n            return 0\n        if c == d:\n            return root.val\n        return self.deepestHelper(root.left,c+1,d) + self.deepestHelper(root.right,c+1,d)\n        \n        \n        \n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        d = self.findDepth(root)\n        return self.deepestHelper(root,1,d)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        q = [root]\n        while True:\n            q_new = [x.left for x in q if x.left]\n            q_new += [x.right for x in q if x.right]\n            if not q_new:\n                break\n            q = q_new\n        return sum([node.val for node in q])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        layer = 0\n        total = [0]\n        \n        self.dfs(root, total, layer)\n        print(total)\n        return total[len(total)-1]\n        \n    def dfs(self, node, total, layer):\n        if layer > len(total) - 1:\n            total.append(0)\n        if not node.left and not node.right:\n            total[layer] += node.val\n        \n        if node.left:\n            self.dfs(node.left, total, layer + 1)\n        if node.right:\n            self.dfs(node.right, total, layer + 1)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\n##### Stack DFS solution\n# class Solution:\n    \n#     def deepestLeavesSum(self, root: TreeNode) -> int:\n\n#         def isLeaf(node) -> bool:\n#             return node.left is None and node.right is None\n\n#         deepest_sum = 0\n#         depth = 0\n        \n#         # Push root into stack\n#         stack = [(root, 0)]\n#         # while stack is not empty\n#         while stack:\n#             # Pop out a node from the stack and update the current number\n#             node, current_depth = stack.pop()\n#             # If the node is a leaf\n#             if isLeaf(node):\n#                 # Update the deepest leaves sum deepest_sum\n                \n#                 # If we are at a deeper level                \n#                 if depth < current_depth:\n#                     deepest_sum = node.val # start a new sum\n#                     depth = current_depth # note new depth\n                \n#                 elif depth == current_depth:\n#                     deepest_sum += node.val # update existing sum\n                    \n#             else:\n#             # Push right and left child nodes into stack (right first)\n#                 if node.right:\n#                     stack.append((node.right, current_depth + 1))\n#                 if node.left:\n#                     stack.append((node.left, current_depth + 1))\n#         return deepest_sum\n        \n    \n# Queue BFS Solution\nclass Solution:\n    \n    def deepestLeavesSum(self, root: TreeNode) -> int:\n\n\n        \n        next_level = deque([root,])\n        \n        while next_level:\n            # prepare for the next level\n            curr_level = next_level\n            next_level = deque()\n            \n            for node in curr_level:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n        \n        return sum([node.val for node in curr_level])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        \\\"\\\"\\\"\n        (1) level-order\n            replace until end then sum list\n        \\\"\\\"\\\"\n        q, deepest_sum = deque(), 0\n        q.append(root)\n        while len(q):\n            i, deepest_sum = len(q), 0\n            while i > 0:\n                top = q.popleft()\n                deepest_sum += top.val\n                if top.left:\n                    q.append(top.left)\n                if top.right:\n                    q.append(top.right)\n                i -= 1\n        return deepest_sum\n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        \n        deep_sum=0\n        depth=0\n        \n        queue=deque()\n        queue.append([root,0])\n        \n        while queue:\n            node, curr_depth=queue.popleft()\n            \n            # if leaf node\n            if not node.left and not node.right:\n                # if current depth is deep that depth, \n                # ex: initially going till end\n                if depth < curr_depth:\n                    deep_sum=node.val\n                    depth=curr_depth\n                else:\n                    # nodes existing at same depth\n                    deep_sum+=node.val\n            else:\n                if node.left:\n                    queue.append([node.left, curr_depth+1])\n                if node.right:\n                    queue.append([node.right, curr_depth+1])\n        return deep_sum", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def bfs_helper(self, root):\n        deep_sum=0\n        depth=0\n        \n        queue=deque()\n        queue.append([root,0])\n        \n        while queue:\n            node, curr_depth=queue.popleft()\n            \n            # if leaf node\n            if not node.left and not node.right:\n                # if current depth is deep that depth, \n                # ex: initially going till end\n                if depth < curr_depth:\n                    deep_sum=node.val\n                    depth=curr_depth\n                else:\n                    # nodes existing at same depth\n                    deep_sum+=node.val\n            else:\n                if node.left:\n                    queue.append([node.left, curr_depth+1])\n                if node.right:\n                    queue.append([node.right, curr_depth+1])\n        return deep_sum\n    \n    def dfs_helper(self, root):\n        deep_sum=0\n        depth=0\n        \n        stack=list()\n        stack.append([root,0])\n        \n        while stack:\n            node, curr_depth=stack.pop()\n            \n            # if leaf node\n            if not node.left and not node.right:\n                # if current depth is deep that depth, \n                # ex: initially going till end\n                if depth < curr_depth:\n                    deep_sum=node.val\n                    depth=curr_depth\n                elif depth == curr_depth:\n                    # nodes existing at same depth\n                    deep_sum+=node.val\n            else:\n                if node.left:\n                    stack.append([node.left, curr_depth+1])\n                if node.right:\n                    stack.append([node.right, curr_depth+1])\n        return deep_sum\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        return self.dfs_helper(root)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        self.sum = 0\n        self.deepest_lvl = 0\n        \n        def bfs(root: TreeNode, lvl = 0):\n            if root is None:\n                return\n            \n            if root.left is None and root.right is None:\n                print(root.val, lvl)\n                if lvl > self.deepest_lvl:\n                    self.sum = root.val\n                    self.deepest_lvl = lvl\n                \n                elif lvl == self.deepest_lvl:\n                    self.sum += root.val\n                return \n            \n            bfs(root.left, lvl + 1)\n            bfs(root.right, lvl + 1)\n            \n        bfs(root)\n        \n        return self.sum"]
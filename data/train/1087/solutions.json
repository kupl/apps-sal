["#!/usr/bin/env python\n\ndef iscycle(E, v, EXPLORED_NODES, EXPLORED_EDGES):\n EXPLORED_NODES.add(v)\n r = False\n for e in [x for x in E if v in x]:\n  if e in EXPLORED_EDGES: continue\n  if e[0] == v: w = e[1]\n  else:         w = e[0]\n  if w in EXPLORED_NODES:\n   return True\n  else:\n   EXPLORED_EDGES.add(e)\n   r = r or iscycle(E, w, EXPLORED_NODES, EXPLORED_EDGES)\n   if r: break\n return r\n\ndef process(E):\n return iscycle(E, 1, set(), set()) and 'NO' or 'YES'\n\ndef main():\n N, M = list(map(int, input().split()))\n E = []\n for m in range(M):\n  U, V = list(map(int, input().split()))\n  if U > V: U, V = V, U\n  E.append((U, V))\n print(process(E))\n\nmain()\n\n", "def main():\n try:\n  print(\"YES\")\n except:\n  return 0\n \nmain()\n", "def main():\n try:\n  [n, m] = input().split()\n  m=int(m)\n  n=int(n)\n  p = [0]*(n+1)\n  while m>0:\n   [a,b] = input().split()\n   a=int(a)\n   b=int(b)\n   p[a] = p[a]+1\n   p[b] = p[b]+1\n   if (p[a]>=3 or p[b] >= 3):\n    print(\"NO\")\n    return 0\n   m=m-1\n  print(\"YES\")\n except:\n  return 0\n \nmain()\n", "import sys\ndef iter_dfs(G, s):\n S, Q = set(), []\n Q.append(s)\n p=Q.pop\n e=Q.extend\n t=S.add\n while Q:\n  u=p()\n  if u in S: continue\n  t(u)\n  e(G[u])\n  yield u\n\ndef main():\n s=sys.stdin.readline\n n, e = list(map(int, s().split()))\n if e!=n-1:\n  print(\"NO\")\n  return\n G=dict()\n for case in range(e):\n  n1, n2 = list(map(int, s().split()))\n  if n1 not in G:\n   G[n1]=[n2]\n  else:\n   G[n1].append(n2)\n  if n2 not in G:\n   G[n2]=[n1]\n  else:\n   G[n2].append(n1)\n tot=len(list(iter_dfs(G, 1)))\n if tot==n:\n  print(\"YES\")\n else:\n  print(\"NO\")\n\ndef __starting_point():\n main()\n \n \n\n__starting_point()"]
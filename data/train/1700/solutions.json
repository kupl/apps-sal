["class DynamicConnectivity(object):\n    par = []\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def union(self, p, q):\n        if self.root(p) != self.root(q):\n            self.par[self.root(p)] = q\n\n    def root(self, p):\n        pp = p\n        while self.par[pp] != pp:\n            pp = self.par[pp]\n        return pp\n        \n    def connected(self, p, q):\n        return True if self.root(p)==self.root(q) else False\n", "class DynamicConnectivity:\n    def __init__(self, n):\n        self.parents = list(range(n))\n\n    def find(self, p):\n        stk = [p]\n        rp = self.parents[stk[-1]]\n        while rp != stk[-1]:\n            stk.append(rp)\n            rp = self.parents[rp]\n        for i in stk:\n            self.parents[i] = rp\n        return rp\n\n    def union(self, p, q):\n        rp, rq = self.find(p), self.find(q)\n        if rp == rq: return\n        self.parents[rp] = rq\n\n    def connected(self, p, q):\n        return self.find(p) == self.find(q)", "class DynamicConnectivity:\n    def __init__(self, n):\n        self.roots = {}\n        self.sizes = {}\n\n    def find_root(self, x):\n        if not x in self.roots:\n            self.roots[x] = x\n            self.sizes[x] = 1\n        while x != self.roots[x]:\n            self.roots[x] = self.roots[self.roots[x]]\n            x = self.roots[x]\n        return x\n\n    def union(self, a, b):\n        a, b = self.find_root(a), self.find_root(b)\n        if a == b:\n            return\n        if self.sizes[a] < self.sizes[b]:\n            a, b = b, a\n        self.roots[b] = a\n        self.sizes[a] += self.sizes[b]\n    \n    def connected(self, a, b):\n        return self.find_root(a) == self.find_root(b)", "class DynamicConnectivity(object):\n    def __init__(self, n):\n        self.__map = list(range(0, n))\n    \n    def __root(self, p):\n        while p != self.__map[p]:\n            self.__map[p] = self.__map[self.__map[p]]\n            p = self.__map[p]\n        return p\n    \n    def union(self, p, q):\n        self.__map[self.__root(p)] = self.__root(q)\n        \n    def connected(self, p, q):\n        return self.__root(p) == self.__root(q)\n", "import collections;\n\nclass DynamicConnectivity(object):\n    def __init__(self, n):\n        self.map = collections.defaultdict(list)\n        \n    def union(self, p, q):\n        self.map[p].append(q)\n        self.map[q].append(p)\n        \n    def connected(self, p, q):\n        handled = set()\n        elements = set([p])\n        while elements and not q in elements:\n            elements = set(n for e in elements for n in self.map[e]).difference(handled)\n            handled.update(elements)\n        return q in elements", "# 10 times faster than naive\nclass DynamicConnectivity(object):\n    def __init__(self, n):\n        self.items = {i:{i} for i in range(n)}\n\n    def union(self, p, q):\n        if self.items[p] is not self.items[q]:\n            for x in self.items[q]:\n                self.items[p].add(x)\n                self.items[x] = self.items[p]\n        \n    def connected(self, p, q):\n        return q in self.items[p]", "class DynamicConnectivity(object):\n# class takes the number of objects n as input, \n# and initializes a data structure with objects numbered from \n# 0 to N-1\n    def __init__(self, n):\n        self.links = [[] for i in range(n)]\n\n# union connects point p with point q\n    def union(self, p, q):\n        for [x,y] in [[p,q],[q,p]]:\n            self.links[x].append(y)\n    \n# connected checks if point p is connected to point q and returns a boolean\n    def connected(self, p, q):\n        stack, seen = [p], set()\n        while len(stack):\n            p = stack.pop()\n            if p == q: return True\n            if p in seen: continue\n            stack += self.links[p]\n            seen.add(p)\n        return False", "class DynamicConnectivity(object):\n    def __init__(self, n):\n        self.a=[{i} for i in range(n)]\n    def union(self, p, q):\n        self.a[p] |= self.a[q]\n        for i in self.a[q]: self.a[i]=self.a[p]\n    def connected(self, p, q):\n        return p in self.a[q]", "class DynamicConnectivity(object):\n# class takes the number of objects n as input, \n# and initializes a data structure with objects numbered from \n# 0 to N-1\n    def __init__(self, n):\n        self.a = []\n\n# union connects point p with point q\n    def union(self, p, q):\n        ip = -1\n        for k in range(len(self.a)):\n            if p in self.a[k]:\n                ip = k\n                break\n        iq = -1\n        for k in range(len(self.a)):\n            if q in self.a[k]:\n                iq = k\n                break\n        if ip == iq == -1:\n            self.a.append({p,q})\n        elif ip == -1 and iq != -1:\n            self.a[iq].add(p)\n        elif iq == -1 and ip != -1:\n            self.a[ip].add(q)\n        elif ip != -1 and iq != -1 and ip != iq:\n            self.a[ip] |= self.a[iq]\n            del self.a[iq]\n\n# connected checks if point p is connected to point q and returns a boolean\n    def connected(self, p, q):\n        ip = -1\n        for k in range(len(self.a)):\n            if p in self.a[k]:\n                ip = k\n                break\n        return False if ip == -1 else q in self.a[ip]", "class DynamicConnectivity(object):\n    def __init__(self, n):\n        # class takes the number of objects n as input, \n        # and initializes a data structure with objects numbered from \n        # 0 to N-1\n        self.clusters = {}\n\n    def union(self, p, q):\n        # union connects point p with point q\n        pp = self.clusters.get(p, None)\n        qq = self.clusters.get(q, None)\n        if pp and qq:\n            # merge qq into pp\n            pp |= qq\n            # redirect all qq mappings to pp\n            for c in qq:\n                self.clusters[c] = pp\n        elif pp:\n            # extend pp to include q\n            self.clusters[p].add(q)\n            self.clusters[q] = self.clusters[p]\n        elif qq:\n            # extend qq to include p\n            self.clusters[q].add(p)\n            self.clusters[p] = self.clusters[q]\n        else:\n            # Create new cluster\n            pq = {p, q}\n            self.clusters[p] = pq\n            self.clusters[q] = pq\n        \n    def connected(self, p, q):\n        # connected checks if point p is connected to point q and returns a boolean\n        return q in self.clusters.get(p, {})"]
["class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        j = 0\n        l = []\n        for i in pushed:\n            l.append(i)\n            while l and (l[-1] == popped[j]):\n                l.pop()\n                j += 1\n        if l:\n            return False\n        return True", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        if len(pushed) != len(popped):\n            return False\n        idx = 0\n        stack = []\n        for i in range(len(popped)):\n            if len(stack) > 0 and stack[-1] == popped[i]:\n                stack.pop()\n            else:\n                while idx < len(pushed) and pushed[idx] != popped[i]:\n                    stack.append(pushed[idx])\n                    idx += 1\n                idx += 1\n        return len(stack) == 0\n            \n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        i = 0\n        j = 0\n        demo = []\n        for j in range(len(popped)):\n            while popped[j] not in demo and i < len(pushed):\n                demo.append(pushed[i])\n                i += 1\n            if demo[-1] == popped[j]:\n                demo.pop()\n            else:\n                return False\n        return True", "class Solution:\n    \n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        \n        j = 0\n        stack = []\n        for x in pushed:\n            stack.append(x)\n            while stack and j < len(popped) and stack[-1] == popped[j]:\n                print(j, stack)\n                stack.pop()\n                j += 1\n        \n        return j == len(popped)", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        l = len(pushed)\n        i = 0\n        j = 0\n        while i < l and j < l:\n            # print(pushed, popped)\n            if pushed[i] == popped[j]:\n                pushed[i] = -1\n                popped[j] = -1\n                while i > 0:\n                    if pushed[i] != -1:\n                        break\n                    i -= 1\n                j += 1\n            else:\n                i += 1\n        \n        i = 0\n        j = 0\n        r_pop = popped[::-1]\n        while i < l and j < l:\n            if pushed[i] == -1:\n                i += 1\n                continue\n            if r_pop[j] == -1:\n                j += 1\n                continue\n                \n            if pushed[i] != popped[j]:\n                return False\n            else:\n                i += 1\n                j += 1\n        return True\n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        stack = []\n        n = len(pushed)\n        i = j = 0\n        while True:\n            if not stack or stack[-1] != popped[j]:\n                if i >= n:\n                    return not stack\n                stack.append(pushed[i])\n                i += 1\n            else:\n                stack.pop()\n                j += 1", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        l=[]\n        j=i=0\n        for i  in pushed:\n            l.append(i)\n            while l and popped and l[-1]==popped[0]:\n                l.pop()\n                popped.pop(0)\n        return len(popped)==0", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        j=0\n        stack=[]\n        for x in pushed:\n            stack.append(x)\n            while stack and j<len(popped) and stack[-1]==popped[j]:\n                stack.pop()\n                j+=1\n        return j==len(popped)", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        i, j, k, n = -1, 0, 0, len(pushed)\n        while i < n and k < n:\n            if i >= 0 and pushed[i] == popped[k]:\n                i -= 1\n                k += 1\n            else:\n                if j >= n:\n                    break\n                i += 1\n                pushed[i] = pushed[j]\n                j += 1\n        return i == -1 and k == n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        '''\n        start: 1:27\n        \n        edge cases:\n            not poping entire stack (nm, pushed is a permutation of popped)\n            \n        complexity:\n            O(n) time, O(1) space seems right\n            \n        approach:\n            Let's just build a stack and attempt to pop at each opportunity... Seems simple\n            Greedy approach, always pop if possible, should work fine due to distinct numbers\n        '''\n        \n        stack = []\n        \n        while len(pushed) or len(popped) or len(stack):\n            if len(stack) and len(popped) and stack[-1] == popped[0]: # can pop\n                stack.pop()\n                popped = popped[1:]\n            elif len(pushed): # can push\n                stack.append(pushed[0])\n                pushed = pushed[1:]\n            else:\n                return False\n        return True\n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        push = []\n        i = 0\n        while popped:\n            if i < len(pushed):\n                push += [pushed[i]]\n            while push and push[-1] == popped[0]:\n                popped.pop(0)\n                push.pop()\n            # print(push)\n            # print(popped)\n            if i < len(pushed):\n                i += 1\n            else:\n                return False\n        return True", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        if len(pushed) != len(popped): return False\n        \n        stack, i = [], 0\n        \n        for j, n in enumerate(pushed):\n            stack.append(n)\n            while len(stack) > 0 and popped[i] == stack[-1]:\n                stack.pop()\n                i += 1\n                \n        return len(stack) == 0\n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        pushed.reverse()\n        popped.reverse()\n        \n        stack = []\n        while pushed:\n            value = pushed.pop()\n            stack.append(value)\n            while stack and popped and stack[-1] == popped[-1]:\n                popped.pop()\n                stack.pop()\n                \n        #if not pushed and not popped:\n        #    return True\n        if not stack:\n            return True\n        return False\n                \n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        \n        stack = []\n        \n        j = 0\n        for x in pushed:\n            stack.append(x)\n            while stack and j < len(popped) and stack[-1] == popped[j]:\n                stack.pop()\n                j+=1\n                \n        return True if j == len(popped) else False", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        \n        stack = []\n        push_index = 0\n        pop_index = 0\n        n = len(pushed)\n        \n        while push_index < n:\n            \n            while stack and stack[-1] == popped[pop_index]:\n                stack.pop()\n                pop_index += 1\n            \n            stack.append(pushed[push_index])\n            push_index += 1\n            \n            while stack and stack[-1] == popped[pop_index]:\n                stack.pop()\n                pop_index += 1\n        \n        return True if not stack else False\n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        pushed.reverse()\n        popped.reverse()\n        \n        stack = []\n        while pushed:\n            #value = pushed.pop()\n            #stack.append(value)\n            stack.append(pushed.pop())\n            while stack and popped and stack[-1] == popped[-1]:\n                popped.pop()\n                stack.pop()\n                \n        #if not pushed and not popped:\n        #    return True\n        if not stack:\n            return True\n        return False\n                \n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        pushed.reverse()\n        popped.reverse()\n        \n        stack = []\n        while pushed:\n            value = pushed.pop()\n            stack.append(value)\n            while stack and popped and stack[-1] == popped[-1]:\n                popped.pop()\n                stack.pop()\n                \n        if not pushed and not popped:\n            return True\n        return False\n                \n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        \n        seen = set()\n        stack = []\n        start = 0\n        for index, element in enumerate(popped):\n            while element not in seen:\n                stack.append(pushed[start]   )\n                seen.add(pushed[start])\n                start += 1\n            catch = False\n            while catch == False:\n                if catch == False and len(stack) == 0:\n                    return False\n                e = stack.pop()\n                if e == element:\n                    catch = True\n                        \n        return True\n        \n        \n        # 1 2   \n        \n        \n        # #given one element\n        #     not seen: keep push until we see\n        #     seen: keep pop until we seen\n                \n", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        stack = []\n        pop_index = 0\n        length = len(pushed)\n        for i in range(length):\n            stack.append(pushed[i])\n            while stack[-1] == popped[pop_index]:\n                print(stack)\n                stack.pop()\n                pop_index += 1\n                if pop_index >= length or len(stack) == 0:\n                    break\n                continue\n        \n        if len(stack) != 0:\n            return False\n        else:\n            return True", "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        if not pushed:\n            return True\n        \n        temp = []\n        i = popiter = 0\n        while i < len(pushed):\n            if temp and temp[-1] == popped[popiter]:\n                print(temp,popped[popiter])\n                temp.pop()\n                popiter += 1\n            else:\n                temp.append(pushed[i])\n                i += 1\n        \n        print(temp,popiter)\n        while temp:\n            if temp[-1]==popped[popiter]:\n                temp.pop()\n                popiter += 1\n            else:\n                return False\n        return True"]
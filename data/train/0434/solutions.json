["class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if not 0 in nums:\n            return len(nums) - 1\n        ans = 0\n        tot = 0\n        prev = 0\n        \n        for n in nums:\n            if n == 1:\n                tot += 1\n            else:\n                ans = max(tot+prev, ans)\n                prev = tot\n                tot = 0\n        return max(prev+tot, ans)\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        z=[0]\n        l=[]\n        a=0\n        c=0\n        for i in range(len(nums)):\n            if a==1 and nums[i]==0:\n                z.append(c)\n                c=(i)-(l[-1]+1)\n                a=1\n                l.append(i)\n            elif nums[i]==0:\n                a=a+1\n                l.append(i)\n            elif nums[i]==1:\n                c=c+1\n        z.append(c)\n        if nums.count(1)==len(nums):\n            return len(nums)-1\n        return max(z)\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        #Full of one's or Zero\n        zc,oc=0,0\n        for i,v in enumerate(nums):\n            if v:oc+=1\n            else:zc+=1\n        if oc==len(nums):return oc-1\n        elif zc==len(nums):return 0\n        elif zc==1: return oc\n        elif oc==1: return 1\n        else:\n            #calculate left one's once to make your algo look better\n            l=r=0\n            for i,v in enumerate(nums):\n                if v==1:\n                    l+=1\n                else:\n                    break\n            st=i+1\n            #print(i,nums[i])\n            po=i\n            maxo,maxi=-1,-1\n            while(st < len(nums)):\n                if nums[st]==1:\n                    r+=1\n                    st+=1\n                    continue\n                else:\n                    v=l+r\n                    if maxo < v:\n                        maxo=v\n                        maxi=po\n                    po=st\n                    l=r\n                    r=0\n                    st+=1\n            maxo=max(maxo,l+r)\n            return maxo\n                    \n                    \n                \n                    \n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n=len(nums)\n        if n==0:\n            return 0\n        elif n==1:\n            return 0 if nums[0]==0 else 1\n        q=deque()\n        num_z=0\n        maxx=0\n        is_0 = 0\n        for i in range(n):\n            if nums[i]==1:\n                q.append(i)\n                continue\n            is_0=1\n            if num_z<1:\n                q.append(i)\n                num_z+=1\n                maxx = max(maxx, len(q)-1)\n                continue\n            maxx=max(maxx, len(q)-1)\n            while q and num_z==1:\n                top = q.popleft()\n                if nums[top]==0:\n                    num_z-=1\n            q.append(i)\n            num_z+=1\n        \n        if is_0==0:\n            return n-1\n        maxx = max(len(q)-num_z, maxx)\n        \n        return maxx\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        c=0\n        ind=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                j=i+1\n                k=0\n                while j<len(nums) and nums[j]==1:\n                    k+=1\n                    j+=1\n                j=i-1\n                while j>=0 and nums[j]==1:\n                    k+=1\n                    j-=1\n                if k>c:\n                    c=k\n                    ind=i\n        if ind==0 and nums[ind]==1:\n            ind=len(nums)-1\n            c=len(nums)-1\n        return c\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        res=zeros=0\n        zero_i=None\n        i=0\n        for j,v in enumerate(nums):\n            if v==0:\n                zeros+=1\n                if zeros==2:\n                    i=zero_i+1\n                    zeros=1\n                zero_i=j\n            res=max(res,j-i)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_length = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_length = max(max_length, count)\n            else:\n                count = 0\n        \n        if max_length == len(nums):\n            return len(nums) - 1\n        elif max_length == 0:\n            return 0\n        \n        num_left = 0\n        num_right = 0\n        for i, num in enumerate(nums):\n            if num == 1:\n                num_right += 1\n            else:\n                max_length = max(max_length, num_left + num_right)\n                if i + 1 < len(nums) and nums[i + 1] == 1:\n                    num_left = num_right\n                    num_right = 0\n                else:\n                    num_left = 0\n                    num_right = 0\n        max_length = max(max_length, num_left + num_right)\n        \n        return max_length", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        start,end,maxlen,k = 0,0,0,1\n        \n        while(end<len(nums)):\n            if nums[end]==0:\n                k=k-1\n                \n            if k<0:\n                if nums[start]==0:\n                    k+=1   \n                start = start+1\n                end = end+1\n                continue\n                \n            if k>=0 or nums[end]==1:\n                maxlen = max(maxlen,end-start)\n                end = end + 1\n            \n        return maxlen\n                \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        longest = 0\n        \n        left = 0\n        x = 1\n        \n        for right in range(len(nums)):\n            if not nums[right]:\n                x -= 1\n            \n            while x < 0:\n                if not nums[left]:\n                    x += 1\n                \n                left += 1\n            \n            longest = max(longest, right - left + 1)\n        \n        return longest - 1\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        \n        noofones = 0\n        m = 0\n        lastoneslen = 0\n        \n        for i in nums:\n            if i == 1:\n                noofones += 1\n            else:\n                m = max(m, noofones+lastoneslen)\n                lastoneslen = noofones\n                noofones = 0\n        \n        m = max(m, noofones+lastoneslen)\n        \n        if m == len(nums):\n            m -= 1\n        \n        return m\n        \n        \n#         max_ones_len = 0\n#         num_of_ones = 0\n#         last_ones_len = 0\n        \n#         for num in nums:\n#             if num == 1:\n#                 num_of_ones +=1\n#             else:\n#                 max_ones_len = max(max_ones_len, last_ones_len + num_of_ones)\n#                 last_ones_len = num_of_ones\n#                 num_of_ones = 0\n        \n#         max_ones_len = max(max_ones_len, last_ones_len + num_of_ones)\n        \n#         if max_ones_len == len(nums):\n#             max_ones_len -= 1\n            \n#         return max_ones_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_count = 0\n        start = 0\n        zero = 2\n        \n        for i in range(len(nums)):\n            if nums[i] == 0:\n                zero -= 1\n            while zero < 1:\n                if nums[start] == 0:\n                    zero += 1\n                start += 1\n            max_count = max(max_count, i - start)\n        \n        return max_count\n                    \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        res = []\n        count = 0\n        for i, val in enumerate(nums):\n            if val == 0:\n                if count > 0:\n                    res.append(count)\n                    count = 0\n                res.append(0)\n            elif val == 1:\n                count += 1\n        if count > 0:\n            res.append(count)\n        lenRes = len(res)\n        ma = 0\n        if lenRes > 2:\n            for i in range(1, lenRes-1):\n                ma = max(max(ma, res[i-1] + res[i+1]), max(res[i-1], res[i]), max(res[i+1], res[i]))\n            return ma\n        \n        else:\n            if lenRes == 1 and res[0] > 0:\n                return res[0] - 1\n            elif lenRes == 1 and res[0] == 0:\n                return ma\n            elif lenRes == 2:\n                return max(res[0], res[1])\n            \n                \n            \n        \n        \n        \n        \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        zero = -1\n        k = 1\n        maxi = 0\n        count = 0\n        i = 0\n        while i != len(nums):\n            if nums[i] == 0:\n                if k == 0:\n                    i = zero + 1\n                    zero = i\n                    maxi = max(count, maxi)\n                    count = 0\n                    k = 1\n                else:\n                    k -= 1\n                    zero = i\n                    i += 1                    \n            else:\n                count += 1\n                i += 1\n        maxi = max(count, maxi)\n        if maxi == len(nums):\n            return maxi - 1\n        else:\n            return maxi", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        start = end = zeros = ones = maxx = 0\n        while end < len(nums):\n            if nums[end] == 1:\n                ones += 1\n            elif nums[end] == 0:\n                zeros += 1\n                \n            while zeros > 1:\n                if nums[start] == 0:\n                    zeros -= 1\n                start += 1\n            maxx = max(maxx,end - start)\n            end += 1\n        return maxx", "class Solution:\n    def longestSubarray(self, array: List[int]) -> int:\n        i=0\n        lenght=0\n        stack=deque()\n        zero=False\n        while i <len(array):\n            if array[i]==1:\n                stack.append(array[i])\n                i+=1\n            else:\n                if zero==False:\n                    stack.append(array[i])\n                    zero=True\n                    i+=1\n                else:\n                    temp=len(stack)-1\n                    if temp>lenght:\n                        lenght=temp\n                    while stack[0]!=0:\n                        stack.popleft()\n                    stack.popleft()\n                    zero=False\n            if len(stack)>lenght:\n                lenght=len(stack)-1\n        return (lenght)\n\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        left = 0\n        right = 0\n        \n        zeroes = 1\n        res = 0\n        while right < len(nums):\n            if nums[right] == 0:\n                zeroes -= 1\n            \n            \n            while zeroes < 0:\n                if nums[left] == 0:\n                    zeroes += 1\n                left += 1\n            \n            res = max(res, right - left)\n            right += 1\n            \n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        i, j = 0, 0\n        ans, cur = 0, 0\n        while j < len(nums):\n            cur += nums[j]\n            while i < j and cur < j-i:\n                cur -= nums[i]\n                i += 1\n            ans = max(ans, cur)            \n            j += 1\n        return min(ans, len(nums)-1)\n                \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        joined = [0 for i in range(n)]\n        # downto = [0 for i in range(n)]\n        left = 0\n        right = 0\n        for i in range(n):\n            joined[i] += left\n            joined[n - 1 - i] += right\n            if nums[i] == 1:\n                left += 1\n            else:\n                left = 0\n            if nums[n - 1 - i] == 1:\n                right += 1\n            else:\n                right = 0\n        \n        return max(joined)", "class Solution:\n    def longestSubarray(self, nums):\n        n = len(nums)\n        last_zero = None\n        last_one = None\n        cnt = 0\n        res = 0\n        for i in range(n):\n            if nums[i] == 1:\n                if last_one is None:\n                    last_one = i\n                cnt += 1 \n            else:\n                if last_zero is None:\n                    last_zero = i\n                else:\n                    last_one = last_zero + 1\n                    last_zero = i\n                    cnt = i - last_one\n            res = max(res, cnt)\n        if res == n:\n            return n - 1\n        return res    ", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        mc = 0\n        onep = False\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                c = 0\n                j = i - 1\n                while j >=0 and nums[j] !=0:\n                    j -= 1\n                    c+=1 \n                    \n                j = i + 1\n                while j<len(nums) and nums[j] != 0:\n                    j += 1\n                    c += 1\n                    \n                if c > mc:\n                    mc = c \n            else:\n                onep = True\n                    \n        if onep and mc == 0:\n            return len(nums) - 1\n        \n        elif not onep and mc == 0:\n            return 0\n        else:\n            return mc\n        \n                    \n                    \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        groups = [[k, len(list(g))] for k, g in itertools.groupby(nums)]\n        if len(groups) == 1:\n            return groups[0][1] - 1 if groups[0][0] else 0\n        ans = 0\n        for i in range(len(groups)):\n            k, klen = groups[i]\n            if k:\n                ans = max(ans, klen)\n            elif i not in [0, len(groups)-1] and klen == 1:\n                ans = max(ans, groups[i-1][1] + groups[i+1][1])\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        low, high = 0, 0\n        cn = 0\n        ans = 0\n        \n        while low < len(nums) and high < len(nums):\n            if nums[high] == 0:\n                if cn < 1:\n                    cn += 1\n                else:\n                    while nums[low] != 0:\n                        low += 1\n                    low += 1\n            high += 1\n            ans = max(ans, high - low)\n            \n        \n        return max(ans, high-low)-1", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        res=zeros=0\n        zero_i=None\n        i=0\n        for j,v in enumerate(nums):\n            if v==0:\n                zeros+=1\n                if zeros>1:\n                    i=zero_i+1\n                    zeros-=1\n                zero_i=j\n            res=max(res,j-i)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        res=zeros=zero_i=i=0\n        for j,v in enumerate(nums):\n            if v==0:\n                zeros+=1\n                if zeros==2:\n                    i=zero_i+1\n                    zeros=1\n                zero_i=j\n            res=max(res,j-i)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        # dynamic programming, store largest subarray including element i with/without deleting\n        # let dp[i][0] be the longest subarray of all 1s including i\n        # let dp[i][1] be the longest subarray of all 1s with 1 zero including i\n        \n        if not nums: return 0\n        if all(nums): return len(nums)-1 # must delete 1 element\n        \n        n = len(nums)\n        dp = [[0]*2 for _ in range(n)]\n        dp[0][0] = 1 if nums[0] == 1 else 0\n        dp[0][1] = 0\n        \n        res = 0\n        for i in range(1, n):\n            if nums[i] == 1:\n                dp[i][0] = dp[i-1][0] + 1 # dp[i][0] is all 1s, so if nums[i] is a num then increment current all 1s\n                dp[i][1] = dp[i-1][1] + 1 # if we have a 1, then increment 1 deletion by 1\n            else:\n                dp[i][0] = 0 # not allowed to have a zero for dp[i][0]\n                dp[i][1] = dp[i-1][0] # if we have a zero, then we are allowed 1 deletion, so ignote current element and hold subarray of all 1s from previous\n            \n            res = max(res, dp[i][1], dp[i][0]) # check if max is with the i'th element\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        start = end = zeros = ones = maxx = 0\n        while end < len(nums):\n            if nums[end] == 0:\n                zeros += 1\n            else:\n                ones += 1\n                \n            while zeros > 1:\n                if nums[start] == 0:\n                    zeros -= 1\n                start += 1\n            maxx = max(maxx,end - start)\n            end += 1\n        return maxx", "class Solution:\n    def longestSubarray(self, A):\n        if not A:\n            return 0\n        n = len(A)\n        right = 0\n        cnt = 0\n        res = 0\n        for left in range(n):\n            while right <= n - 1 and (cnt == 0 or A[right] == 1):\n                cnt += (A[right] == 0)\n                right += 1\n            res = max(res, right - left)\n            cnt -= (A[left] == 0)\n        return res - 1", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        left = []\n        total = 0\n        for n in nums:\n            if n == 0:\n                total = 0\n            else:\n                total += n\n            left.append(total)\n        \n        right = []\n        total = 0\n        for i in range(len(nums)-1, -1, -1):\n            if nums[i] == 0:\n                total = 0\n            else:\n                total += nums[i]\n            right.append(total)\n        right = right[::-1]\n        \n        curMax = 0\n        for i in range(len(nums) - 2):\n            curMax = max(left[i]+right[i+2], curMax)\n            \n        return curMax", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        l, r = [0] * n, [0] * n\n        for i in range(1, n):\n            l[i] = l[i-1] + 1 if nums[i-1] == 1 else 0\n        for i in range(n-2, -1, -1):\n            r[i] = r[i+1] + 1 if nums[i+1] == 1 else 0\n        ans = max(r[0], l[n-1])\n        for i in range(1, n-1):\n            ans = max(ans, l[i] + r[i])\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        k = 1\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] == 0: k -= 1\n            if k < 0:\n                if nums[i] == 0: k += 1\n                i += 1\n        return j-i", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        joined = [0 for i in range(n)]\n        # downto = [0 for i in range(n)]\n        left = 0\n        right = 0\n        result = 0\n        for i in range(n):\n            joined[i] += left\n            joined[n - 1 - i] += right\n            result = max(result, joined[i], joined[n - 1 - i] )\n            if nums[i] == 1:\n                left += 1\n            else:\n                left = 0\n            if nums[n - 1 - i] == 1:\n                right += 1\n            else:\n                right = 0\n        \n        return result", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        prevStart = -1\n        candidates = []\n        if 0 not in nums:\n            return len(nums) - 1\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                if prevStart == -1:\n                    prevStart = i\n                    continue\n            else:\n                if prevStart != -1:\n                    candidates.append([prevStart, i - 1])\n                    prevStart = -1\n        if prevStart != -1:\n            candidates.append([prevStart, len(nums) - 1])\n        \n        res = [0]\n        for i in range(len(candidates)):\n            if i == len(candidates) - 1:\n                res.append(candidates[i][1] - candidates[i][0] + 1)\n            else:\n                if candidates[i + 1][0] - candidates[i][1] == 2:\n                    res.append(candidates[i + 1][1] - candidates[i][0])\n                else:\n                    res.append(candidates[i][1] - candidates[i][0] + 1)\n        return max(res)", "'''\nUsing sliding window\n\nMethod 1:\nSliding window size shrinks\n\nUse i and j as the lower and upper bounds, both inclusively;\nLoop through the nums by upper bound, accumulate current element on the sum, then check if sum is less than j - i (which implies the window includes at least 2 0s) : if yes, keep increase the lower bound i till either the sliding window has at most 1 zero or lower bound is same as upper bound;\nCore concept here: - credit to @lionkingeatapple and @abhinav_7.\nsum count the number of 1s in the window.\nj - i means the length of the window - 1. Since we need to delete one element which is zero from this window, we use j - i not j - i + 1.\nSpecifically, if\n\nsum == (j - i) + 1\nthen all 1's exist in the window(i - j); if\n\nsum == (j - i)\none zero exist; if\n\nsum < (j - i)\nmore than one zeros exist!\n\nTC: O(n)\nSC: O(1)\n'''\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        i = 0\n        j = 0\n        sum = 0\n        ans = 0\n        \n        for j, val in enumerate(nums):\n            sum += val\n            while(i < j and sum < j-i):\n                sum -= nums[i]\n                i+=1\n                \n            ans = max(ans, j-i)    \n        \n        return ans\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        leftones = [0] * n\n        for i in range(n):\n            if nums[i] == 0: leftones[i] = 0\n            else: leftones[i] = 1 if i == 0 else leftones[i-1]+1\n                \n        rightones = [0] * n\n        for i in range(n-1, -1, -1):\n            if nums[i] == 0: rightones[i] = 0\n            else: rightones[i] = 1 if i == n-1 else rightones[i+1]+1\n                \n        res = 0\n        for i in range(1, n-1):\n            res = max(res, leftones[i-1] + rightones[i+1])\n        \n        return res\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        prev, curr, best = 0, 0, 0\n        n = len(nums)\n        for i, x in enumerate(nums):\n            if x == 0:\n                best = max(best, prev+curr)\n                \n                if i == n-1:\n                    pass  \n                \n                elif nums[i+1] == 1: # this is a gap\n                    prev = curr\n                    curr = 0\n                else:\n                    prev = 0\n                    curr = 0\n            else:\n                curr += 1\n                \n        best = max(best, prev+curr)\n        \n        if best == n: # all ones, need to remove one element at least\n            best -= 1\n                \n        return best", "# 23:30\n# 00:43\nclass Solution:\n    def longestSubarray(self, xs: List[int]) -> int:\n        # DP: find optimal solution ending at i and then \n        n = len(xs)\n        \n        if n < 2:\n            return 0\n        \n        dp = collections.deque()\n        best = 0\n        for i, x in enumerate(xs):\n            if x:\n                dp.append(i)\n            while dp and i - dp[0] - len(dp) + 1 > 1:\n                dp.popleft()\n            nholes = i - dp[0] - len(dp) + 1 if dp else 1\n            this_len = len(dp) - (not dp[0] and not nholes) if dp else 0\n            best = max(best, this_len)\n                \n        return best", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        prev, _next, n = [0 for _ in range(len(nums))], [0 for _ in range(len(nums))], len(nums)\n        \n        count = 0\n        for i in range(n):\n            num = nums[i]\n            if i == 0:\n                if num:\n                    count = 1\n            else:\n                if num:\n                    prev[i] = count \n                    count += 1\n                else:\n                    prev[i] = count\n                    count = 0\n        \n        count = 0\n        for i in range(n-1, -1, -1):\n            num = nums[i]\n            if i == n - 1:\n                if num:\n                    count = 1\n            else:\n                if num:\n                    _next[i] = count \n                    count += 1\n                else:\n                    _next[i] = count\n                    count = 0\n        \n        _max = 0\n        \n        for i in range(n):\n            num = nums[i]\n            _max = max(_max, prev[i] + _next[i])\n        \n        return _max", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if all(nums):\n            return len(nums)-1\n        m = pre = l = pl = 0\n        for i, n in enumerate(nums):\n            if n == pre == 1:\n                l += 1\n            elif n == pre == 0:\n                pl = 0\n            elif n == 1 != pre:\n                l = 1\n            else:\n                m = max(m, pl + l)\n                pl = l\n            pre = n\n        return max(m, pl + l) if pre == 1 else m", "# 1493. Longest Subarray of 1's After Deleting One Element\n\ndef get_longest (nums):\n    arr = [1-x for x in nums]\n    l, r = 0, 0\n    count = 0\n    max_length = 0\n    while l < len (arr):\n        if r == len (arr): step = 'l'\n        elif l == r: step = 'r'\n        elif count + arr[r] > 1: step = 'l'\n        else: step = 'r'\n\n        if step == 'l':\n            count -= arr[l]\n            l += 1\n        else:\n            count += arr[r]\n            r += 1\n            max_length = max (max_length, r - l)\n\n    return max (0, max_length - 1)\n\n\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        return get_longest(nums)", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        new_array = list()\n        current_segment = 0\n        for num in nums:\n            if num == 0:\n                if current_segment > 0:\n                    new_array.append(current_segment)\n                    current_segment = 0\n                new_array.append(0)\n            else:\n                current_segment += 1\n        if current_segment > 0:\n            new_array.append(current_segment)\n            \n        max_length = 0\n        for idx in range(len(new_array)):\n            max_length = max(max_length, new_array[idx])\n            if idx > 0 and idx < len(new_array) - 1 and new_array[idx] == 0:\n                if new_array[idx - 1] > 0 and new_array[idx + 1] > 0:\n                    max_length = max(max_length, new_array[idx - 1] + new_array[idx + 1])\n                    \n        if max_length == len(nums):\n            return max_length - 1\n        else:\n            return max_length\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        right = [0 for _ in range(len(nums))]\n        left = [0 for _ in range(len(nums))]\n        \n        for i in range(1, len(nums)):\n            if nums[i - 1] == 1:\n                left[i] = 1 + left[i - 1]\n             \n        res = float('-inf')\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i + 1] == 1:\n                right[i] = 1 + right[i + 1]\n            res = max(res, left[i] + right[i])\n        \n        # res = float('-inf')\n        # for i in range(len(nums)):\n        #     res = max(res, left[i] + right[i])\n        return res", "class Solution:\n    # Time: O(n)\n    # Space: O(n)\n    def longestSubarray(self, nums: List[int]) -> int:\n        right = [0 for _ in range(len(nums))]\n        left = [0 for _ in range(len(nums))]\n        \n        for i in range(1, len(nums)):\n            if nums[i - 1]:\n                left[i] = 1 + left[i - 1]\n             \n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i + 1]:\n                right[i] = 1 + right[i + 1]\n            \n        res = float('-inf')\n        for i in range(len(nums)):\n            res = max(res, left[i] + right[i])\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        se=set(nums)\n        if(0 not in se):\n            return len(nums)-1\n        elif(1 not in se):\n            return 0\n        \n        count=0\n        flag=0\n        ls=[]\n        for i in nums:\n            if(i==0):\n                if(flag==0):\n                    count+=1\n                else:\n                    flag=0\n                    ls.append(count)\n                    count=1\n            else:\n                if(flag==1):\n                    count+=1\n                else:\n                    flag=1\n                    ls.append(count)\n                    count=1\n        ls.append(count)\n        # print(ls)\n        ind=0\n        ans=0\n        while(ind<len(ls)):\n            if(ls[ind]!=0):\n                if(ls[ind]==1):\n                    if(ind==0 and ind<len(ls)-1):\n                        ans=max(ans,ls[ind+1])\n                    elif(ind==len(ls)-1 and ind>0):\n                        ans=max(ans,ls[ind-1])\n                    else:\n                        if(ind<len(ls)-1 and ind>0):\n                            ans=max(ans,ls[ind-1]+ls[ind+1])\n                else:\n                    if(ind==0 and ind<len(ls)-1):\n                        ans=max(ans,ls[ind+1])\n                    elif(ind==len(ls)-1 and ind>0):\n                        ans=max(ans,ls[ind-1])\n                    else:\n                        if(ind<len(ls)-1 and ind>0):\n                            ans=max(ans,max(ls[ind-1],ls[ind+1]))\n            # print(ans,ind)\n            ind+=2\n            \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        var=0\n        count=0\n        max1=0\n        pos=0\n        flag=0\n        for i in nums:\n            if(i==1):\n                flag=1\n                if(var==1):\n                    pos=pos+1\n                count=count+1\n                max1=max(count,max1)\n            elif(i==0 and var==1):\n                count=pos\n                pos=0\n            else:\n                if(flag==1):\n                    if(var==0):\n                        var=var+1\n                    else:\n                        count=pos\n                \n        if(max1==len(nums)):\n            return(max1-1)\n        return(max1)", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        deleted = False\n        max_, cur_cnt, last_cnt = 0, 0, 0\n        idx, size = 0, len(nums)\n        \n        while idx < size and nums[idx] == 0: idx += 1\n        for i in range(idx, size):\n            if nums[i] == 1:\n                cur_cnt += 1\n                max_ = max(max_, cur_cnt)\n            else:\n                if not deleted:\n                    deleted = True\n                else:\n                    cur_cnt -= last_cnt\n                last_cnt = cur_cnt\n        \n        if size == sum(nums): return size-1 #[1,1,1,1]\n        return max_", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if 1 not in nums:\n            return 0\n        if 0 not in nums:\n            return len(nums)-1\n        new = []\n        i = 0\n        n = len(nums)\n        while(i < n):\n            if nums[i] == 1:\n                cnt = 0\n                while(i < n and nums[i] == 1):\n                    cnt += 1\n                    i += 1\n                new.append(cnt)\n            else:\n                new.append(0)\n                i+= 1\n        mx = max(new)\n        for i in range(1,len(new)-1):\n            if new[i] == 0:\n                mx = max(mx,new[i-1] + new[i+1])\n        return mx\n                \n                \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if len(nums) < 1:\n            return 0\n        \n        res = 0\n        logs = []\n        \n        for x in nums:\n            if x==0:\n                logs.append(res)\n                res=0\n            else:\n                res+=1\n        logs.append(res)\n        if len(logs) == 1:\n            return max(0, logs[0]-1)\n    \n        return max([logs[i]+logs[i+1] for i in range(len(logs)-1)])", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if sum(nums) >= len(nums) - 1:\n            return len(nums) - 1\n        \n        l = 0\n        while nums[l] == 0:\n            l += 1\n            if l == len(nums):\n                return 0\n        \n        \n        r = l + 1\n        sum_total = nums[l]\n        res = 0\n        #print(r)\n        for r in range(r, len(nums)):\n            sum_total += nums[r]\n            #print(l)\n            if sum_total == r - l - 1:\n                res = max(res, sum_total)\n                while sum_total < r - l:\n                    sum_total -= nums[l]\n                    l += 1\n          \n        return max(res, sum_total)\n                 \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if len(nums)<2:\n            return 0\n        len1_prev=0\n        len1=0\n        i=0\n        res=0\n        zc=0#number of zeros in the middle\n        while i<len(nums):\n            if nums[i]==1:\n                len1+=1\n            else:\n                res=max(res,len1+len1_prev)\n                if zc==0:\n                    len1_prev=len1\n                    len1=0\n                    zc=1\n                elif zc==1:\n                    if len1>0:\n                        len1_prev=len1\n                        len1=0\n                        zc=1\n                    else:\n                        len1=0\n                        len1_prev=0\n                        zc=0\n            i+=1\n                    \n                    \n        res=max(res,len1+len1_prev)\n        res=min(len(nums)-1,res)\n        \n        return res\n                    \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        '''\n        DP\n        '''\n        \n        n = len(nums)\n        if sum(nums) == n: return n - 1\n        \n        dp = [[0 for x in range(len(nums))] for y in range(2)]\n        \n        dp[0][0] = 1 if nums[0] == 1 else 0\n        \n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                dp[0][i] = 0\n                #basically \\\"takes\\\" the previous run of ones\n                dp[1][i] = dp[0][i-1]\n                \n            else:\n                dp[0][i] = dp[0][i-1] +1\n                dp[1][i] = dp[1][i-1] +1\n        \n        # print(dp)\n        return max([i for x in dp for i in x])\n        \n        \n        \n        \n        \n        \n        \n#         '''\n#         sliding window\n#         '''\n        \n#         previousRun = 0\n#         currentRun = 0\n#         best = 0\n#         sawZero = False\n        \n        \n#         for n in nums:\n#             if n == 0:\n#                 previousRun = currentRun\n#                 currentRun = 0\n#                 sawZero = True\n#             else:\n#                 currentRun += 1\n#                 best = max(best, previousRun+currentRun)\n#         if sawZero == False:\n#             best -= 1\n#         return best\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_len = 0\n        zero_seen = False\n        for i in range(len(nums)):\n            length = 0\n            if nums[i] == 0:\n                zero_seen = True\n                l,r = i-1, i+1\n                while l >= 0 and nums[l] == 1:\n                    length += 1\n                    l -=1\n                while r < len(nums) and nums[r] == 1:\n                    length += 1\n                    r += 1\n                max_len = max(max_len, length)\n        \n        return max_len if zero_seen else len(nums)-1", "class Solution:\n    def longestSubarray(self, a: List[int]) -> int:\n        ones = 0\n        old_ones = 0\n        maxlen = 0\n        n = len(a)\n        for i in range(n):\n            if a[i]==1: \n                ones+=1\n                maxlen = max(maxlen,ones+old_ones)\n            else:\n                old_ones = ones\n                ones = 0\n\n        return maxlen if ones<n else n-1", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        seq = [0]\n        prev = 0\n        res = 0\n        \n        for n in nums:\n            if n:\n                seq[-1] += 1\n                res = max(prev + seq[-1], res)\n                \n            else:\n                prev = seq[-1]\n                seq.append(0)\n                \n        if len(seq) == 1:\n            res -= 1\n        \n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        prev, res, curr = 0, 0, 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                curr += 1\n            else:\n                if i < len(nums) - 1 and nums[i + 1] != 0:\n                    prev = curr\n                else:\n                    prev = 0\n                curr = 0\n            res = max(res, curr + prev)\n        if res == len(nums):\n            res -= 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        s = []; i=0\n        while i < (len(nums)):\n            if nums[i] == 0:\n                s.append(0)\n                i+=1\n            else:\n                j = i;cnt = 0\n                while j<len(nums) and nums[j] == 1:\n                    cnt+=1\n                    j+=1\n                s.append(cnt)\n                i = j\n        print(s)\n        if s[0] == len(nums):\n            return len(nums)-1\n        maxYet = max(s[0],s[len(s)-1])\n        for i in range(1,len(s)-1):\n            if s[i] == 0:\n                maxYet = max(maxYet, s[i-1]+s[i+1])\n            else:\n                maxYet = max(maxYet,s[i])\n        return maxYet\n            \n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        z=[0]\n        a=0\n        c=0\n        if nums.count(1)==len(nums):\n            return len(nums)-1\n        for i in range(len(nums)):\n            if a==1 and nums[i]==0:\n                z.append(c)\n                c=(i)-(l+1)\n                a=1\n                l=i\n            elif nums[i]==0:\n                a=a+1\n                l=i\n            elif nums[i]==1:\n                c=c+1\n        z.append(c)\n        return max(z)\n                \n", "import re\nimport numpy as np\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        nums = np.array(nums)\n        zeros_ = np.where(nums == 0)[0]\n        if zeros_.tolist():\n            temp = 0\n            for ind in zeros_:\n                ind_ = max([ind-1,0])\n                ind__ = min([ind+1, len(nums)-1])\n                count_ = 0\n                count__ = 0\n                if nums[ind_] == 1:\n                    while ind_>=0 and nums[ind_] == 1:\n                        count_ +=1\n                        ind_ -=1\n                if nums[ind__]==1:\n                    while ind__<len(nums) and nums[ind__] == 1:\n                        count__ +=1\n                        ind__ +=1\n                temp = max([count_+count__, temp])\n            return temp\n        elif len(zeros_) == len(nums):\n            return 0\n        else:\n            return len(nums)-1          \n        \n            \n", "import re\nimport numpy as np\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        nums = np.array(nums)\n        zeros_ = np.where(nums == 0)[0]\n        if zeros_.tolist():\n            temp = []\n            for ind in zeros_:\n                ind_ = max([ind-1,0])\n                ind__ = min([ind+1, len(nums)-1])\n                count_ = 0\n                count__ = 0\n                if nums[ind_] == 1:\n                    while ind_>=0 and nums[ind_] == 1:\n                        count_ +=1\n                        ind_ -=1\n                if nums[ind__]==1:\n                    while ind__<len(nums) and nums[ind__] == 1:\n                        count__ +=1\n                        ind__ +=1\n                temp.append(count_+count__)\n            return max(temp)\n        elif len(zeros_) == len(nums):\n            return 0\n        else:\n            return len(nums)-1          \n        \n            \n", "import re\nimport numpy as np\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        nums = np.array(nums)\n        zeros_ = np.where(nums == 0)[0]\n        if zeros_.tolist():\n            temp = []\n            for ind in zeros_:\n                ind_ = max([ind-1,0])\n                ind__ = min([ind+1, len(nums)-1])\n                count_ = 0\n                count__ = 0\n                if nums[ind_] == 1:\n                    while ind_>=0 and nums[ind_] == 1:\n                        count_ +=1\n                        ind_ -=1\n                if nums[ind__]==1:\n                    while ind__<len(nums) and nums[ind__] == 1:\n                        count__ +=1\n                        ind__ +=1\n                temp.append(count_+count__)\n            return max(temp)\n        elif np.sum(nums) == 0:\n            return 0\n        else:\n            return len(nums)-1\n            \n        # sumnums = sum(nums)\n        # if sumnums==len(nums):\n        #     return sumnums-1\n        # elif sumnums ==0:\n        #     return 0\n        # elif sumnums == 1:\n        #     return 1\n        # else:\n        #     temp = []\n        #     for i in range(len(nums)):\n        #         temp1 = [nums[i]]\n        #         for j in range(i+1, len(nums)):\n        #             if sum(temp1+[nums[j]])>=len(temp1):\n        #                 temp1.append(nums[j])\n        #             else:\n        #                 break\n        #         temp.append(temp1)\n        #     return max([len(x) for x in temp])-1                \n        \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        i = 0\n        ints = []\n        while i < len(nums):\n            start = i\n            end = i\n            while i < len(nums) and nums[i] == 1:\n                i += 1\n                end += 1\n                \n            if start != end:\n                ints.append((start, end))\n                \n            i += 1\n            \n        if len(ints) == 1:\n            diff = ints[0][1] - ints[0][0]\n            if diff == len(nums): return diff - 1\n            else: return diff\n        elif not ints:\n            return 0\n            \n        max_ones = 0\n        for seq in range(len(ints) - 1):\n            seq1 = ints[seq]\n            seq2 = ints[seq + 1]\n            \n            length = None\n            if seq2[0] - seq1[1] == 1:\n                length = (seq1[1] - seq1[0]) + (seq2[1] - seq2[0])\n            else:\n                length = max(seq1[1] - seq1[0], seq2[1] - seq2[0])\n                \n            if length > max_ones:\n                max_ones = length\n                \n        return max_ones\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        prev = 0\n        cnt = 0\n        pmax = 0\n        for i in range (0,n):\n            if nums[i] == 1:\n                cnt += 1\n            else:\n                prev = cnt\n                cnt = 0\n                \n            maxm = prev + cnt\n            if maxm > pmax:\n                pmax = maxm\n                \n        if cnt == n:\n            return (n-1)\n        else:\n            return maxm if maxm > pmax else pmax", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        start = 0\n        sliding_window_counter = collections.Counter()\n        result = 0\n\n        for end in range(len(nums)):\n            sliding_window_counter[nums[end]] += 1\n\n            while sliding_window_counter[0] > 1:\n                sliding_window_counter[nums[start]] -= 1\n                start += 1\n            result = max(result, end - start)\n\n        return result\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        l = 0\n        r = 0\n        zeros = 0\n        res = 0\n        while r < len(nums):\n            if nums[r] == 0:\n                zeros += 1\n            while zeros > 1:\n                if nums[l] == 0:\n                    zeros -= 1\n                l += 1\n            res = max(res, r-l)\n            r += 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        l = 0 \n        r = 0\n        earliest_one = float('inf')\n        earliest_zero = float('inf')\n        zeros = 1\n        max_len = 0\n        while(r < len(nums)):\n            zeros -= nums[r] == 0\n            if(zeros < 0):\n                zeros += nums[l] == 0\n                l += 1\n            r += 1\n        return r - l - 1\n        \n        '''#queue kind of slow\n        l = 0\n        r = 0\n        max_len = 0\n        zeros = 0\n        queue = []\n        while(r < len(nums)):\n            if(nums[r] == 0 and zeros < 1):\n                zeros = 1\n                queue.append(nums[r])\n                max_len = max(max_len, len(queue))\n                r += 1\n            elif(nums[r] == 0 and zeros == 1):\n                if(queue[0] == 0):\n                    #zero in front\n                    while(len(queue) > 0 and queue[0] == 0):\n                        queue.pop(0)\n                #zero in the middle\n                else:\n                    while(len(queue) > 0 and queue[0] == 1):\n                        queue.pop(0)\n                    queue.pop(0)\n                queue.append(nums[r])\n                max_len = max(max_len, len(queue))\n                r += 1\n            elif(nums[r] == 1):\n                queue.append(nums[r])\n                max_len = max(max_len, len(queue))\n                r += 1\n        return max_len-1'''", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n#         if len(nums) == 1:\n#             return 0\n#         ones = []\n#         count = 0\n        \n#         for num in nums:\n#             if num == 1:\n#                 count += 1\n#             else:\n#                 if count != 0:\n#                     ones.append(count)\n#                 ones.append(0)\n#                 count = 0\n        \n#         if count != 0:\n#             ones.append(count)\n            \n#         print(ones)\n        \n#         if len(ones) == 1:\n#             return max(ones) - 1\n#         m = max(ones)\n        \n#         for i in range(1, len(ones) - 1):\n#             if ones[i] == 0:\n#                 m = max([m, ones[i - 1] + ones[i + 1]])\n                \n#         return m\n\n        i, r = 0, 1\n    \n        for j in range(len(nums)):\n            if nums[j] == 0:\n                r -= 1\n                \n            if r < 0:\n                print('yes')\n                if nums[i] == 0:\n                    r += 1\n                i += 1\n                \n        return j - i\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        s = []; i=0\n        while i < (len(nums)):\n            if nums[i] == 0:\n                s.append(0)\n                i+=1\n            else:\n                j = i;cnt = 0\n                while j<len(nums) and nums[j] == 1:\n                    cnt+=1\n                    j+=1\n                s.append(cnt)\n                i = j\n        # print(s)\n        if s[0] == len(nums):\n            return len(nums)-1\n        maxYet = max(s[0],s[len(s)-1])\n        for i in range(1,len(s)-1):\n            if s[i] == 0:\n                maxYet = max(maxYet, s[i-1]+s[i+1])\n            else:\n                maxYet = max(maxYet,s[i])\n        return maxYet\n            \n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        # here k = 1\n        w_start = 0\n        d = {}\n        max_len = 0\n        case = 0\n        for i in range(0,len(nums)):\n            c = str(nums[i])\n            if c not in d:\n                d[c]=0\n            d[c]+=1\n            if str(0) in d:\n                while(d[str(0)]>1):\n                    t = str(nums[w_start])\n                    d[t]-=1\n                    w_start+=1\n                    case=1\n            max_len = max(max_len, i-w_start+1-case)\n            case = 0\n        return max_len-1\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        prev = 0\n        prev_zero = 0\n        result = float('-inf')\n        boolean = False\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                boolean = True\n                count+= 1\n                if count == 2:\n                    count-= 1\n                    prev = prev_zero + 1\n                prev_zero = i\n                \n            result = max(result,i - prev)\n        \n        return result if boolean == True else len(nums)-1\n            \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \n        if 0 in nums and 1 in nums:\n            longest = 0\n            i = nums.index(0)\n            \n            while True:\n                \n                    \n                if 0 in nums[:i][::-1]:\n                    left_side = nums[:i][::-1].index(0)     \n\n                else:\n                            \n                    left_side = len(nums[:i][::-1])\n                \n                    \n                if 0 in nums[i+1:]:\n                    right_side = nums[i+1:].index(0)\n                   \n                else:\n                     right_side = len(nums[i+1:])\n\n\n                longest = max(left_side + right_side , longest) \n\n                try:\n                    i = nums[i + 1:].index(0) + i + 1\n                except:\n                    break\n            \n            return longest\n\n        elif sum(nums)==0: # all zeros\n            return 0\n\n\n        elif sum(nums)==len(nums): # all 1s\n            return(len(nums) - 1)\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        arr = []\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            elif nums[i] == 0:\n                arr.append(count)\n                count = 0\n        arr.append(count)\n        if len(arr) == 1:\n            return arr[0]-1\n        maxi = 0\n        for j in range(1, len(arr)):\n            maxi = max(maxi, arr[j-1] + arr[j])\n        return maxi\n", "class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if 0 not in nums:\n            return len(nums) - 1\n\n        arr = [0]\n        count, flag = 0, 0\n        for idx, num in enumerate(nums):\n            if num == 0:\n                if flag == 1:\n                    arr.append(count)\n                    count = 0\n                arr.append(0)\n                flag = 0\n            elif num == 1:\n                count += 1\n                flag = 1\n            if idx == len(nums) - 1:\n                arr.append(count)\n        arr.append(0)\n\n        maxSum = 0\n        for i in range(1, len(arr) - 1):\n            if arr[i] == 0:\n                maxSum = max(maxSum, arr[i-1] + arr[i+1])\n\n        return maxSum"]
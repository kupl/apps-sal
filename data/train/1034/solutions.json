["from math import log2;\nimport bisect;\nfrom bisect import bisect_left,bisect_right\nimport sys;\nfrom math import gcd,sqrt\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\ninf=float(\"inf\")\n# n=int(input())\n# n,m=map(int,input().split())\n# l=list(map(int,input().split()))\ndef get_factors(x):\n if x==1:\n  return [];\n sqrta=int(sqrt(x))+1\n for i in range(2,sqrta):\n  if x%i==0:\n   return [i]+get_factors(x//i)\n return [x]\ndef min_generator(fac,k,index,new_list):\n if index==len(fac):\n  return sum(new_list)\n mina=inf;\n for i in range(0,min(index+1,len(new_list))):\n  new_list[i]*=fac[index]\n  theta=min_generator(fac,k,index+1,new_list)\n  if theta<mina:\n   mina=theta;\n  new_list[i]//=fac[index]\n return mina;\ndef fun(k,x):\n dict=defaultdict(lambda :1)\n factors=get_factors(x)\n for i in factors:\n  dict[i]*=i;\n if len(dict)==k:\n  print(sum(dict.values()))\n  return;\n if len(dict)<k:\n  suma=sum(dict.values())\n  left=k-len(dict)\n  suma+=left;\n  print(suma)\n  return;\n if k==1:\n  print(x)\n  return;\n fac=list(dict.values())\n\n new_list=[1]*k\n theta=min_generator(fac,k,0,new_list)\n print(theta)\nfor i in range(int(input())):\n k,x=map(int,input().split())\n fun(k,x)", "# cook your dish here\ndef factors(n):\n factor=[]\n for i in range(2,int(n**(1/2))+1):\n  cnt=0\n  if n%i==0:\n   while n%i==0:\n    cnt+=1\n    n=n//i\n   factor.append(i**cnt)\n if n!=1:\n  factor.append(n)\n return factor\ndef bruteforce(pos,arr,factors):\n if pos==len(factors):\n  return sum(arr)\n  \n ans=float('inf')\n \n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,bruteforce(pos+1,arr,factors))\n  arr[i]//=factors[pos]\n return ans\n  \nfor _ in range(int(input())):\n k,n=list(map(int,input().split()))\n fac=factors(n)\n if len(fac)==k:\n  print(sum(fac))\n elif len(fac)<k:\n  print(sum(fac)+k-len(fac))\n else:\n  arr=[1]*k\n  d=bruteforce(0,arr,fac)\n  print(d)\n", "# cook your dish here\n\ndef factorize(n):\n fact=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   c=0\n   while n%i==0:\n    c+=1\n    n//=i\n   fact.append(i**c)\n if n!=1:\n  fact.append(n)\n  \n return fact\n\ndef brute(pos,ar,fact):\n if pos==len(fact):\n  return sum(ar)\n ans=float('inf')\n \n for i in range(len(ar)):\n  ar[i]*=fact[pos]\n  ans=min(ans,brute(pos+1,ar,fact))\n  ar[i]//=fact[pos]\n  \n return ans\n \nt=int(input())\n\nwhile(t>0):\n \n k,x=map(int,input().split())\n fact=factorize(x)\n lenn=len(fact)\n \n if lenn <=k:\n  \n  ans= sum(fact)+k-lenn\n else:\n  ar=[1]*k\n  ans=brute(0,ar,fact)\n print(ans)\n t-=1", "def all_pcombo(arr,factors,pos):\n if pos==len(factors):\n  return sum(arr)\n\n ans=float('inf')\n\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,all_pcombo(arr,factors,pos+1))\n  arr[i]//=factors[pos]\n\n return ans\n\ndef factorization(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   cnt=0\n   while n%i==0:\n    cnt+=1\n    n//=i\n   factors.append(i**cnt)\n\n if n>1:\n  factors.append(n)\n return factors\n\ndef solve():\n k,x=map(int,input().split())\n factors=factorization(x)\n len_=len(factors)\n\n ans=0\n if len_<=k:\n  ans=sum(factors) + k-len_\n else:\n  arr=[1]*k\n  ans=all_pcombo(arr,factors,0)\n\n print(ans)\n\n\nt=int(input())\nwhile t>0:\n solve()\n t-=1", "def all_pcombo(arr,factors,pos):\n if pos==len(factors):\n  return sum(arr)\n\n ans=float('inf')\n\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,all_pcombo(arr,factors,pos+1))\n  arr[i]//=factors[pos]\n\n return ans\n\ndef factorization(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   cnt=0\n   while n%i==0:\n    cnt+=1\n    n//=i\n   factors.append(i**cnt)\n\n if n>1:\n  factors.append(n)\n return factors\n\ndef solve():\n k,x=map(int,input().split())\n factors=factorization(x)\n len_=len(factors)\n\n ans=0\n if len_<=k:\n  ans=sum(factors) + k-len_\n else:\n  arr=[1]*k\n  ans=all_pcombo(arr,factors,0)\n\n print(ans)\n\n\nt=int(input())\nwhile t>0:\n solve()\n t-=1", "# cook your dish here\nimport sys\nsys.setrecursionlimit(10000000)\n\n\ndef primes(x):\n f = []\n i = 2\n while i * i <= x:\n  if x % i == 0:\n   t = 1\n   while x % i == 0:\n    x //= i\n    t *= i\n   f.append(t)\n  i += 1\n if x > 1:\n  f.append(x)\n return f\n\n\ndef recur(arr):\n if len(arr) == k:\n  return sum(arr)\n answer = float('inf')\n for i in range(len(arr) - 1):\n  for j in range(i + 1, len(arr)):\n   temp = arr[:]\n   temp.remove(arr[i])\n   temp.remove(arr[j])\n   temp.append(arr[i] * arr[j])\n   answer = min(answer, recur(temp))\n return answer\n\n\nfor _ in range(int(input())):\n k, X = map(int, input().split())\n p = primes(X)\n if k >= len(p):\n  print(sum(p) + (k - len(p)))\n  continue\n print(recur(p))", "# cook your dish here\nimport math\ndef factorize(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if(n%i==0):\n   cntr=0\n   while(n%i==0):\n    cntr+=1\n    n//=i\n   factors.append(i**cntr)\n if n!=1:\n  factors.append(n)\n return factors\n\ndef brtueforce(pos,arr,factors):\n if pos==len(factors):\n  return sum(arr)\n ans=float('inf')\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,brtueforce(pos+1,arr,factors))\n  arr[i]//=factors[pos]\n\n return ans\n\n\ndef solve():\n #n=int(input())\n \n k,x=map(int,input().split())\n #s=input()\n #l=list(map(int,input().split()))\n #l1=list(map(int,input().split()))\n #flag=0\n \n factors=factorize(x)\n\n lenn=len(factors)\n\n if lenn<=k:\n\n  ans=sum(factors) + k-lenn\n else:\n  arr=[1]*k\n  ans=brtueforce(0,arr,factors)\n\n print(ans)\n\n \n\n\n\n\n\nt=int(input())\nfor i in range(t):\n solve()", "def factorizing(n):\n factor = []\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   count = 0\n   while n%i==0:\n    count += 1\n    n //= i\n   factor.append(i**count)\n \n if (n!=1):\n  factor.append(n)\n return factor\n\n\ndef getans(a,f,p):\n if p==len(f):\n  return sum(a)\n \n ans = float('inf')\n \n for i in range(len(a)):\n  a[i] *= f[p]\n  ans = min(ans,getans(a,f,p+1))\n  a[i] //= f[p]\n \n return ans\n\nT = int(input())\n\nwhile(T):\n \n T -= 1\n \n k,x = map(int, input().split())\n \n factors = factorizing(x)\n \n if len(factors)<=k:\n  ans = sum(factors) + k-len(factors)\n else:\n  a = [1]*k\n  ans = getans(a,factors, 0)\n \n print(ans)", "def find_div(x):\n b=[]\n e=int(x**0.5)+1\n for i in range(2,e):\n  if x%i==0:\n   c=0\n   while x%i==0:\n    c+=1\n    x=x//i\n   b.append(i**c)\n if x!=1:\n  b.append(x)\n return b \n \ndef solve(a,div,pos):\n if pos==len(div):\n  return sum(a)\n ans=2**30\n for i in range(len(a)):\n  a[i]*=div[pos]\n  ans=min(ans,solve(a,div,pos+1))\n  a[i]=a[i]//div[pos]\n return ans\n \n \nt=int(input())\nfor _ in range(t):\n k,x=map(int,input().split())\n div=find_div(x)\n if len(div)<=k:\n  ans=sum(div)+k-len(div)\n else:\n  a=[1]*k\n  ans=solve(a,div,0)\n print(ans) ", "def factorize(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   cnt=0\n   while n%i==0:\n    cnt+=1\n    n//=i\n   factors.append(i**cnt)\n if n!=1:\n  factors.append(n)\n return factors\n\ndef brute(pos,arr,factors):\n if pos==len(factors):\n  return sum(arr)\n ans = float('inf')\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,brute(pos+1,arr,factors))\n  arr[i]//=factors[pos]\n return ans\n\nt = int(input())\nwhile t:\n k,x=map(int,input().split())\n factors=factorize(x)\n if len(factors)<=k:\n  ans=sum(factors)+k-len(factors)\n else:\n  arr=[1]*k\n  ans=brute(0,arr,factors)\n print(ans)\n t-=1", "def factorize(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   cnt=0\n   while n%i==0:\n    cnt+=1\n    n//=i\n   factors.append(i**cnt)\n if n!=1:\n  factors.append(n)\n return factors\n\ndef brute(pos,arr,factors):\n if pos==len(factors):\n  return sum(arr)\n ans = float('inf')\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,brute(pos+1,arr,factors))\n  arr[i]//=factors[pos]\n return ans\n\nt = int(input())\nwhile t:\n k,x=map(int,input().split())\n factors=factorize(x)\n if len(factors)<=k:\n  ans=sum(factors)+k-len(factors)\n else:\n  arr=[1]*k\n  ans=brute(0,arr,factors)\n print(ans)\n t-=1", "def factorize(n):\n factors=[]\n for i in range(2,int(n**0.5)+1):\n  if n%i==0:\n   cntr=0\n   while n%i==0:\n    cntr+=1\n    n//=i\n   factors.append(i**cntr)\n if n!=1:\n  factors.append(n)\n\n return factors\n\ndef bruteForce(pos,arr,factors):\n if pos==len(factors):\n  return sum(arr)\n\n ans=float('inf')\n\n for i in range(len(arr)):\n  arr[i]*=factors[pos]\n  ans=min(ans,bruteForce(pos+1,arr,factors))\n  arr[i]//=factors[pos]\n\n return ans\n\ndef __starting_point():\n t=int(input())\n\n while(t != 0):\n  \n  k,x=list(map(int, input().split()))\n  factors=factorize(x)\n  lenn=len(factors)\n\n  if lenn<=k:\n   ans=sum(factors)+k-lenn\n\n  else:\n   arr=[1]*k\n   ans=bruteForce(0,arr,factors)\n\n  print(ans)\n\n  t=t-1\n\n\n__starting_point()", "import traceback;\nimport math;\n\nMAX_INF = 9223372036854775807\nINF = 2147483647\nSEM_INF = INF // 2\nMOD = int(1e9 + 7)\n\n\nclass HELPER:\n tmplst = []\n pntr = 0\n outPutStream = \"\"\n\n def __init__(self):\n  pass\n\n def __next__(self):\n  if self.pntr == -1 or self.pntr == len(self.tmplst):\n   self.tmplst = input().split(\" \")\n   self.pntr = 0\n  ret = self.tmplst[self.pntr]\n  self.pntr += 1\n\n  return ret\n\n def nextInt(self):\n  return int(next(self))\n\n def nextFloat(self):\n  return float(next(self))\n\n def nextLine(self):\n  return input()\n\n def readArray(self, n):\n  l = []\n  for x in range(0, n):\n   l.append(self.nextInt())\n  return l\n\n def getIntArray(self, s):\n  l = []\n  s = s.split(\" \")\n  for x in range(0, len(s)):\n   l.append(int(s[x]))\n\n  return l\n\n # Printing Arena\n\n def printArray(self, a, nextLine):\n  for x in a:\n   sc.write(\"{} \".format(x))\n  if nextLine:\n   self.writeln()\n\n def writeln(self, s):\n  self.outPutStream += (str(s) + \"\\n\")\n\n def write(self, s):\n  self.outPutStream += str(s)\n\n def flush(self):\n  print(self.outPutStream)\n  outPutStream = \"\"\n\n\nsc = HELPER()\n\n\ndef writeln(s=\"\"):\n sc.writeln(s)\n\n\ndef write(s):\n sc.write(s)\n\n\n\"\"\"Code Starts Here\"\"\"\n\n\ndef getFactorList(n):\n l = [];\n p = 0\n while n % 2 == 0:\n  p += 1\n  n = n // 2\n l.append(int(math.pow(2,p)))\n\n x = 3\n while x <= math.sqrt(n):\n  p = 0\n  while n % x == 0:\n   n = n // x\n   p += 1\n  if p != 0:\n   l.append(int(math.pow(x,p)))\n  x += 2\n\n if n > 2:\n  l.append(n)\n\n return l\n\n\ndef getMinRecur(l, a, pos):\n if(pos == len(l)):\n  return sum(a)\n ans = float('inf')\n for x in range(0,len(a)):\n  a[x] *= l[pos]\n  ans = min(ans,getMinRecur(l,a,pos + 1))\n  a[x] //= l[pos]\n\n return ans\n\n\ndef getMinAns(l,k):\n ans = 0\n if k == len(l):\n  ans = sum(l)\n elif k > len(l):\n  more = k - len(l)\n  ans = more + sum(l)\n else:\n  arr = [1] * k\n  ans = getMinRecur(l,arr,0)\n return ans\n\n\ndef testCase():\n k = sc.nextInt(); day = sc.nextInt()\n l = getFactorList(day)\n\n ans = getMinAns(l,k)\n ans = min(ans,day + k - 1)\n writeln(ans)\n pass\n\n\n\"\"\"Code Ends Here\"\"\"\n\n\ndef main():\n t = int(input())\n # t = 1\n while t > 0:\n  testCase()\n  t -= 1\n sc.flush()\n\n\ntry:\n def __starting_point():\n  main()\nexcept:\n print(\"Error Occured\")\n traceback.print_exc()\n\n__starting_point()", "def brute(ind,arr,factors):\n if ind==len(factors):\n  return sum(arr)\n ans=10000000000000\n for i in range(len(arr)):\n  arr[i]*=factors[ind]\n  ans=min(ans,brute(ind+1,arr,factors))\n  arr[i] //= factors[ind]\n return ans\n\ndef factorize(x):\n factors=[]\n for i in range(2,int(x**0.5)+1):\n  if x%i==0:\n   count=0\n   while x%i==0:\n    count+=1\n    x //= i\n   factors.append(i**count)\n if x!=1:\n  factors.append(x)\n return factors\n\n\nt=int(input())\nfor _ in range(t):\n k,x=map(int,input().split())\n factors=factorize(x)\n if len(factors)<=k:\n  print(sum(factors)+k-len(factors))\n else:\n  arr = [1]*k\n  print(brute(0,arr,factors))", "# cook your dish here\ntry:\n MAX = 1000005\n prime = [True] * MAX\n fact = [list() for i in range(MAX)]\n\n for i in range(2, MAX):\n  if prime[i]:\n   for j in range(i, MAX, i):\n    prime[j] = False\n    fact[j].append(i)\n\n def solve(arr, i, k):\n  if i >= len(arr):\n   return sum(k)\n  z = float('inf')\n  for j in range(len(k)):\n   k[j] *= arr[i]\n   z = min(z, solve(arr, i + 1, k))\n   k[j] //= arr[i]\n  return z\n\n t = int(input())\n for i in range(t):\n  k, x = map(int, input().split())\n  temp = []\n  for y in fact[x]:\n   p = x\n   z = 1\n   while p % y == 0:\n    p //= y\n    z *= y\n   temp.append(z)\n  if k >= len(fact[x]):\n   print(sum(temp) + k - len(temp))\n  else:\n   print(solve(temp, 0, [1] * k))\n\nexcept EOFError as e : pass", "# cook your dish here\n\n\ndef primeFactors(n):\n factors = []\n cnt = 0\n if n%2 == 0:\n  while n%2 == 0:\n   cnt += 1\n   n = n//2\n\n  factors.append(2**cnt)\n \n for i in range(3,int(n**0.5)+1,2):\n  cnt = 0\n  if n%i == 0:\n   \n   while n%i == 0:\n    cnt += 1\n    n = n//i\n\n   factors.append(i**cnt)\n if n != 1:\n  factors.append(n)\n  \n return factors\n \ndef minSum(arr,k):\n if len(arr) == k:\n  return sum(arr)\n \n ans = 1e18\n for i in range(len(arr)-1):\n  temp = []\n  for j in range(i+1,len(arr)):\n   temp = [arr[i]*arr[j]] + arr[:i] + arr[i+1:j] + arr[j+1:]\n  \n   ans = min(ans,minSum(temp,k))\n \n return ans\n \nTC = int(input())\nfor tc in range(TC):\n k, x = list(map(int,input().strip().split()))\n \n factors = primeFactors(x)\n \n if len(factors) <= k:\n  print(sum(factors) + k-len(factors))\n else:\n  print(minSum(factors,k))\n", "# cook your dish here\nimport sys\nsys.setrecursionlimit(10000000)\n\ndef primeFactors(n):\n factors = []\n cnt = 0\n if n%2 == 0:\n  while n%2 == 0:\n   cnt += 1\n   n = n//2\n\n  factors.append(2**cnt)\n \n for i in range(3,int(n**0.5)+1,2):\n  cnt = 0\n  if n%i == 0:\n   \n   while n%i == 0:\n    cnt += 1\n    n = n//i\n\n   factors.append(i**cnt)\n if n != 1:\n  factors.append(n)\n  \n return factors\n \ndef minSum(arr,k):\n if len(arr) == k:\n  return sum(arr)\n \n ans = 1e18\n for i in range(len(arr)-1):\n  temp = []\n  for j in range(i+1,len(arr)):\n   temp = [arr[i]*arr[j]] + arr[:i] + arr[i+1:j] + arr[j+1:]\n  \n   ans = min(ans,minSum(temp,k))\n \n return ans\n \nTC = int(input())\nfor tc in range(TC):\n k, x = list(map(int,input().strip().split()))\n \n factors = primeFactors(x)\n \n if len(factors) <= k:\n  print(sum(factors) + k-len(factors))\n else:\n  print(minSum(factors,k))\n", "def factorize(n):\n factors = []\n for i in range(2, int(n**0.5)+1):\n  if n % i == 0:\n   cntr = 0\n   while n % i == 0:\n    cntr += 1\n    n //= i\n   factors.append(i**cntr)\n if n != 1:\n  factors.append(n)\n return factors\n \ndef recur(arr):\n if len(arr)==k:\n  return sum(arr)\n res = float('inf')\n for i in range(len(arr)-1):\n  for j in range(i+1,len(arr)):\n   temp=arr[:]\n   temp.remove(arr[i])\n   temp.remove(arr[j])\n   temp.append(arr[i]*arr[j])\n   res = min(res,recur(temp))\n return res\n\nfor i in range(int(input())):\n k,x=list(map(int,input().split()))\n arr = factorize(x)\n if len(arr)<k:\n  print(sum(arr)+k-len(arr))\n else:\n  print(recur(arr))\n \n \n", "import sys\nsys.setrecursionlimit(10000000)\n\n\ndef primes(x):\n f = []\n i = 2\n while i * i <= x:\n  if x % i == 0:\n   t = 1\n   while x % i == 0:\n    x //= i\n    t *= i\n   f.append(t)\n  i += 1\n if x > 1:\n  f.append(x)\n return f\n\n\ndef recur(arr):\n if len(arr) == k:\n  return sum(arr)\n answer = float('inf')\n for i in range(len(arr) - 1):\n  for j in range(i + 1, len(arr)):\n   temp = arr[:]\n   temp.remove(arr[i])\n   temp.remove(arr[j])\n   temp.append(arr[i] * arr[j])\n   answer = min(answer, recur(temp))\n return answer\n\n\nfor _ in range(int(input())):\n k, X = list(map(int, input().split()))\n p = primes(X)\n if k >= len(p):\n  print(sum(p) + (k - len(p)))\n  continue\n print(recur(p))\n", "\ndef prime(n):\n ans = []\n i = 2\n while (i*i <= n):\n  if n % i == 0:\n   temp1 = 1\n   while (n % i == 0):\n    n //= i\n    temp1 *= i\n   ans.append(temp1)\n  i += 1\n if n>1:\n  ans.append(n)\n return ans\n\ndef recur(arr,k):\n if len(arr) == k:\n  return sum(arr)\n ans = float('inf')\n for i in range(len(arr)-1):\n  for j in range(i+1, len(arr)):\n   temp = arr[:]\n   temp.remove(arr[i])\n   temp.remove(arr[j])\n   temp.append(arr[i]*arr[j])\n   ans = min(ans, recur(temp,k))\n return ans\n\ntc = int(input())\nfor i in range(tc):\n k, x = list(map(int,input().split()))\n p = prime(x)\n if len(p) <= k:\n  print(sum(p)+k-len(p))\n else:\n  print(recur(p,k))\n", "import sys\nsys.setrecursionlimit(10000000)\ndef prime(n):\n ans = []\n i = 2\n while (i*i <= n):\n  if n % i == 0:\n   temp1 = 1\n   while (n % i == 0):\n    n //= i\n    temp1 *= i\n   ans.append(temp1)\n  i += 1\n if n>1:\n  ans.append(n)\n return ans\n\ndef recur(arr,k):\n if len(arr) == k:\n  return sum(arr)\n ans = float('inf')\n for i in range(len(arr)-1):\n  for j in range(i+1, len(arr)):\n   temp = arr[:]\n   temp.remove(arr[i])\n   temp.remove(arr[j])\n   temp.append(arr[i]*arr[j])\n   ans = min(ans, recur(temp,k))\n return ans\n\ntc = int(input())\nfor i in range(tc):\n k, x = list(map(int,input().split()))\n p = prime(x)\n if len(p) <= k:\n  print(sum(p)+k-len(p))\n else:\n  print(recur(p,k))\n", "import math\n\n\ndef primeFactors(n):\n d = {}\n while n % 2 == 0:\n  n = n // 2\n  if 2 in d:\n   d[2] += 1 \n  else:\n   d[2] = 1 \n for i in range(3,int(math.sqrt(n))+1,2):\n  while n % i== 0:\n   if i in d:\n    d[i] += 1 \n   else:\n    d[i] = 1 \n   n = n // i\n if n > 2:\n  if n in d:\n   d[n] += 1 \n  else:\n   d[n] = 1\n \n return d\n \ndef get_all_combs(arr, left):\n nonlocal g\n if not left:\n  g.append(sum(arr))\n else:\n  new = left.pop()\n  for i in range(len(arr)):\n   newarr = arr.copy()\n   newarr[i] *= new \n   get_all_combs(newarr, left.copy())\n \n\n\nfor test in range(int(input())):\n k, x = list(map(int, input().split()))\n d = primeFactors(x)\n \n if k < len(d):\n  p = [item**d[item] for item in d]\n  xo = [1]*k\n  g = []\n  get_all_combs(xo, p)\n  \n  print(min(g))\n  continue\n \n c2 = 0\n for item in d:\n  c2 += item**d[item]\n diff = k - len(d)\n  \n c2 += diff\n \n print(c2)\n"]
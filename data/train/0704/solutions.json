["# cook your dish here\nfor _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    s = len(str(a))\n    #print(s)\n    c = 10**s - 1\n    w = c*m\n    b = pow(10,n*s,w)-1\n    d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  ", "for _ in range(int(input())):\r\n    a,n,m = map(int,input().split(' '))\r\n    print((((pow(10,n*(len(str(a))),(10**(len(str(a))) - 1)*m)-1)//(10**(len(str(a))) - 1))%m)*(a%m)%m)", "for _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    print((((pow(10,n*(len(str(a))),(10**(len(str(a))) - 1)*m)-1)//(10**(len(str(a))) - 1))%m)*(a%m)%m)", "for _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    s = len(str(a))\n    c = 10**s - 1\n    w = c*m\n    b = pow(10,n*s,w)-1\n    d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  ", "import math \n\ndef no(n):\n    c=0\n    while n>0:\n        c += 1\n        n //=10\n    return c\n\n  \n# Function to find modulo inverse of b. It returns  \n# -1 when inverse doesn't  \n# modInverse works for prime m \ndef modInverse(a, m) : \n    m0 = m \n    y = 0\n    x = 1\n  \n    if (m == 1) : \n        return 0\n  \n    while (a > 1) : \n  \n        # q is quotient \n        q = a // m \n  \n        t = m \n  \n        # m is remainder now, process \n        # same as Euclid's algo \n        m = a % m \n        a = t \n        t = y \n  \n        # Update x and y \n        y = x - q * y \n        x = t \n  \n  \n    # Make x positive \n    if (x < 0) : \n        x = x + m0 \n  \n    return x \n  \n  \n# Function to compute a/b under modulo m  \n \n\n\nfor _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    if a == 0 :\n        s = 1\n    else:\n        s = no(a)\n    #print(s)\n    c = 10**s - 1\n    w = c*m\n    b = pow(10,n*s,w)-1\n    d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  \n  \n        \n    ", "import math \n\ndef no(n):\n    c=0\n    while n>0:\n        c += 1\n        n //=10\n    return c\n\n  \n# Function to find modulo inverse of b. It returns  \n# -1 when inverse doesn't  \n# modInverse works for prime m \ndef modInverse(a, m) : \n    m0 = m \n    y = 0\n    x = 1\n  \n    if (m == 1) : \n        return 0\n  \n    while (a > 1) : \n  \n        # q is quotient \n        q = a // m \n  \n        t = m \n  \n        # m is remainder now, process \n        # same as Euclid's algo \n        m = a % m \n        a = t \n        t = y \n  \n        # Update x and y \n        y = x - q * y \n        x = t \n  \n  \n    # Make x positive \n    if (x < 0) : \n        x = x + m0 \n  \n    return x \n  \n  \n# Function to compute a/b under modulo m  \n \n\n\nfor _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    s = len(str(a))\n    #print(s)\n    c = 10**s - 1\n    w = c*m\n    b = pow(10,n*s,w)-1\n    d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  \n  \n        \n    ", "import math \n\ndef no(n):\n    c=0\n    while n>0:\n        c += 1\n        n //=10\n    return c\n\n  \n# Function to find modulo inverse of b. It returns  \n# -1 when inverse doesn't  \n# modInverse works for prime m \ndef modInverse(a, m) : \n    m0 = m \n    y = 0\n    x = 1\n  \n    if (m == 1) : \n        return 0\n  \n    while (a > 1) : \n  \n        # q is quotient \n        q = a // m \n  \n        t = m \n  \n        # m is remainder now, process \n        # same as Euclid's algo \n        m = a % m \n        a = t \n        t = y \n  \n        # Update x and y \n        y = x - q * y \n        x = t \n  \n  \n    # Make x positive \n    if (x < 0) : \n        x = x + m0 \n  \n    return x \n  \n  \n# Function to compute a/b under modulo m  \n \n\n\nfor _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    s = no(a)   \n    c = 10**s - 1\n    if math.gcd(c,m) == 1:\n        b = pow(10,n*s,m)-1\n        r = modInverse(c,m)\n        d = (b%m)*(r%m)\n    else:\n        w = c*m\n        b = pow(10,n*s,w)-1\n        d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  \n  \n        \n    ", "import math \n\ndef no(n):\n    c=0\n    while n>0:\n        c += 1\n        n //=10\n    return c\n\n  \n# Function to find modulo inverse of b. It returns  \n# -1 when inverse doesn't  \n# modInverse works for prime m \ndef modInverse(a, m) : \n    m0 = m \n    y = 0\n    x = 1\n  \n    if (m == 1) : \n        return 0\n  \n    while (a > 1) : \n  \n        # q is quotient \n        q = a // m \n  \n        t = m \n  \n        # m is remainder now, process \n        # same as Euclid's algo \n        m = a % m \n        a = t \n        t = y \n  \n        # Update x and y \n        y = x - q * y \n        x = t \n  \n  \n    # Make x positive \n    if (x < 0) : \n        x = x + m0 \n  \n    return x \n  \n  \n# Function to compute a/b under modulo m  \n \n\n\nfor _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    s = no(a)   \n    c = 10**s - 1\n    w = c*m\n    b = pow(10,n*s,w)-1\n    #r = modInverse(c,m)\n    d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  \n  \n        ", "import sys\r\ndef cal_power(a, n, m):\r\n    if n == 0:\r\n        return 1\r\n    elif n == 1:\r\n        return a % m\r\n    elif not n % 2:\r\n        return ((cal_power(a, n // 2, m) % m)**2) % m\r\n    else:\r\n        return ((a % m) * (((cal_power(a, (n - 1)// 2, m)) % m)**2) % m) % m\r\n\r\ndef cal(b, n, m):\r\n    if n == 0:\r\n        return 0\r\n    elif n == 1:\r\n        return b % m\r\n    elif not n % 2:\r\n        return (((1 +cal_power(b, n // 2, m)) % m) * (cal(b, n // 2, m) % m)) % m\r\n    else:\r\n        return (((1 + cal_power(b, (n + 1) // 2, m)) % m) * (cal(b, ((n - 1) // 2), m) % m) + cal_power(b, (n + 1) // 2, m) % m) % m\r\n\r\ndef solve(a, n, m):\r\n    l = len(str(a))\r\n    x = a % m\r\n    q = 10**l % m\r\n    return (x * (1 + cal(q, n - 1, m))) % m\r\n\r\nfor _ in range(int(input())):\r\n    a,n,m = [int(temp) for temp in input().split()]\r\n    print(solve(a, n, m))"]
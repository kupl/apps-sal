["class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9 + 7\n        group_len, profit_len = len(group),len(profit)\n        dp = [[0]*(G+1) for _ in range(P+1)]\n        dp[0][0] = 1\n        for pro, gro in zip(profit,group):\n            dp2 = [x[:] for x in dp]\n            for p1 in range(P+1):\n                p = min(pro + p1,P)\n                for g1 in range(G+1-gro):\n                    g = g1 + gro\n                    dp2[p][g] += dp[p1][g1]\n                    dp2[p][g] %= MOD\n            dp = dp2\n        return sum(dp[-1]) %MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            # p0, g0 : the current crime profit and group size\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P + 1):\n                # p1 : the current profit\n                # p2 : the new profit after committing this crime\n                p2 = min(p1 + p0, P)\n                for g1 in range(G - g0 + 1):\n                    # g1 : the current group size\n                    # g2 : the new group size after committing this crime\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n        # Sum all schemes with profit P and group size 0 <= g <= G.\n        return sum(cur[-1]) % MOD\n", "class Solution:\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)\n    # def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n    #     schemes=[(pro, kitnelog) for pro, kitnelog in zip(profit, group)]\n    #     nonlocal dump\n    #     dump={}\n    #     nonlocal dump1\n    #     dump1={}\n    #     return self.getans(G, P, schemes)\n    # def getans(self, g, p, schemes, mod=(10**9+7)):\n    #     nonlocal dump\n    #     nonlocal dump1\n    #     if len(schemes)==0:\n    #         if p<=0:\n    #             return 1\n    #         return 0\n    #     if g<=0 and p>0:\n    #         return 0\n    #     if p<=0:\n    #         return self.numsubsetslessthan(g, schemes)\n    #     if (g, p, len(schemes)) in dump:\n    #         return dump[(g, p, len(schemes))]\n    #     a=self.getans(g-schemes[-1][1], p-schemes[-1][0], schemes[:-1]) if g>=schemes[-1][1] else 0\n    #     b=self.getans(g, p, schemes[:-1])\n    #     dump[(g, p, len(schemes))]=(a+b)%mod\n    #     return dump[(g, p, len(schemes))]\n    # def numsubsetslessthan(self, g, schemes, mod=10**9+7):\n    #     nonlocal dump1\n    #     if len(schemes)==0:\n    #         return 1\n    #     if (g, len(schemes)) in dump1:\n    #         return dump1[(g, len(schemes))]\n    #     a=self.numsubsetslessthan(g-schemes[-1][1], schemes[:-1]) if g>=schemes[-1][1] else 0\n    #     b=self.numsubsetslessthan(g, schemes[:-1])\n    #     dump1[(g, len(schemes))]=(a+b)%mod\n    #     return dump1[(g, len(schemes))]\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        memo = [[0] * (G + 1) for _ in range(P + 1)]\n        memo[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in reversed(range(P + 1)):\n                for j in reversed(range(G + 1 - g)):\n                    memo[min(i + p, P)][j + g] += memo[i][j]\n        return sum(memo[-1]) % (10 ** 9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        memo =[[0]*(G+1) for _ in range(P+1)]\n        memo[0][0]=1\n        for p,g in zip(profit,group):\n            for i in range(P,-1,-1):\n                for j in range(G-g,-1,-1):\n                    memo[min(P,p+i)][j+g] += memo[i][j]\n        return sum(memo[P])%(10**9+7)\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        n = len(group)\n        dp = [[0] * (G + 1) for _ in range(P + 1)]\n        dp[0][0] = 1\n        for g, p in zip(group, profit):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[-1]) % mod\n        \n        \n        \n        # n = len(group)\n        # dp = [[0, 0]]\n        # ans = 0\n        # for i, (g, p) in enumerate(zip(group, profit)):\n        #     dp2 = []\n        #     for pro, num in dp:\n        #         if num + g <= G and pro + p < P:\n        #             dp2.append([pro + p, num + g])\n        #         elif num + g <= G and pro + p >= P:\n        #             rem = G - num - g\n        #             ans += 2 ** (n - i - 1)\n        #     dp += dp2\n        # return ans % mod\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        dp = [[0]*(G+1) for _ in range(P+1)]\n        \n        dp[0][0] = 1\n        # for i in range(G+1):\n        #     dp[0][i] = 1\n        \n        for i in range(len(profit)):\n            p = profit[i]\n            g = group[i]\n            for i in range(P, -1, -1):\n                for j in range(G-g, -1, -1):\n                    dp[min(P, i + p)][j+g] += dp[i][j]\n                    \n        return sum(dp[-1]) % (10**9 + 7)\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        n = len(group)\n        dp = [[0] * (G + 1) for _ in range(P + 1)]\n        dp[0][0] = 1\n        # Key point is to iterate reversely, like knapsack problem\n        for g, p in zip(group, profit):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[-1]) % mod\n", "class Solution:    \n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p_gained, g_needed in zip(profit, group):\n            ndp = [[0] * (G + 1) for i in range(P + 1)]\n            for p in range(P + 1):\n                for g in range(0, G + 1):\n                    ndp[p][g] += dp[p][g]\n                    if g >= g_needed:\n                        ndp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\n            dp = ndp\n        return sum(dp[P]) % (10**9 + 7)\n\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        #dp[0] = [1] * (G + 1) #<-----\n        dp[0][0] = 1\n        for p_gained, g_needed in zip(profit, group):\n            for p in range(P, -1, -1):\n                for g in range(G, g_needed - 1, -1):\n                    dp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\n        return sum(dp[P]) % (10**9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        dp = [[0]*(G+1) for _ in range(P+1)]\n        dp[0][0] = 1\n        \n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G-g, -1, -1):\n                    if i+p>=P:\n                        dp[P][j+g] += dp[i][j]\n                    else:\n                        dp[i+p][j+g] += dp[i][j]\n                        \n        return sum(dp[P])%(10**9+7)", "class Solution:\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            dp2=[i[:] for i in dp]\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp2[min(i + p, P)][j + g] += dp[i][j]\n            dp=dp2\n        return sum(dp[P]) % (10**9 + 7)\n    # def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n    #     schemes=[(pro, kitnelog) for pro, kitnelog in zip(profit, group)]\n    #     nonlocal dump\n    #     dump={}\n    #     nonlocal dump1\n    #     dump1={}\n    #     return self.getans(G, P, schemes)\n    # def getans(self, g, p, schemes, mod=(10**9+7)):\n    #     nonlocal dump\n    #     nonlocal dump1\n    #     if len(schemes)==0:\n    #         if p<=0:\n    #             return 1\n    #         return 0\n    #     if g<=0 and p>0:\n    #         return 0\n    #     if p<=0:\n    #         return self.numsubsetslessthan(g, schemes)\n    #     if (g, p, len(schemes)) in dump:\n    #         return dump[(g, p, len(schemes))]\n    #     a=self.getans(g-schemes[-1][1], p-schemes[-1][0], schemes[:-1]) if g>=schemes[-1][1] else 0\n    #     b=self.getans(g, p, schemes[:-1])\n    #     dump[(g, p, len(schemes))]=(a+b)%mod\n    #     return dump[(g, p, len(schemes))]\n    # def numsubsetslessthan(self, g, schemes, mod=10**9+7):\n    #     nonlocal dump1\n    #     if len(schemes)==0:\n    #         return 1\n    #     if (g, len(schemes)) in dump1:\n    #         return dump1[(g, len(schemes))]\n    #     a=self.numsubsetslessthan(g-schemes[-1][1], schemes[:-1]) if g>=schemes[-1][1] else 0\n    #     b=self.numsubsetslessthan(g, schemes[:-1])\n    #     dump1[(g, len(schemes))]=(a+b)%mod\n    #     return dump1[(g, len(schemes))]\n", "class Solution:\n    def profitableSchemes(self,G, P, group, profit):\n        dp = [[1]+[0]*G] + [[0]*(G+1) for _ in range(P)]\n        for p, g in zip(profit, group):\n            for i in range(P,-1,-1):\n                for j in range(G-g,-1,-1):\n                    dp[min(P,i+p)][g+j] += dp[i][j]\n        return (sum(dp[P]) % (10**9+7))", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        m = 10 ** 9 + 7\n        cur = [[0] * (G+1) for _ in range(P+1)]\n        cur[0][0] = 1\n        for p0, g0 in zip(profit, group):\n            for p1 in range(P, -1, -1):\n                for g1 in range(G, g0-1, -1):\n                    cur[p1][g1] += cur[max(0, p1 - p0)][g1-g0]\n        \n        return sum(cur[-1]) % m", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # Dynamic Programming\n        # Time  complexity: O(N x P x G), where N is the number of crimes available to the gang.\n        # Space complexity: O(P x G)\n        # MOD = 10**9 + 7\n        # cur = [[0] * (G + 1) for _ in range(P + 1)]\n        # cur[0][0] = 1\n\n        # for p0, g0 in zip(profit, group):\n        #     cur2 = [row[:] for row in cur]\n        #     for p1 in range(P + 1):\n        #         p2 = min(p1 + p0, P)\n        #         for g1 in range(G - g0 + 1):\n        #             g2 = g1 + g0\n        #             cur2[p2][g2] += cur[p1][g1]\n        #             cur2[p2][g2] %= MOD\n        #     cur = cur2\n\n        # return sum(cur[-1]) % MOD\n\n\n        MOD = 10**9 + 7\n        dp = [[0] * (G + 1) for _ in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(P, i + p)][g + j] += dp[i][j]\n\n        return sum(dp[P]) % MOD\n", "class Solution(object):\n    def profitableSchemes(self, G, P, group, profit):       \n        mod = 10**9+7\n        dp = [[0 for _ in range(G+1)] for _ in range(P+1)] \n        dp[0][0]=1\n        for g,p in zip(group,profit):\n            cur = [row[:] for row in dp]\n            for g_pre in range(G-g+1):\n                for p_pre in range(P+1):\n                    p_now = min(P,p_pre+p)\n                    cur[p_now][g_pre+g]+=dp[p_pre][g_pre]\n            dp = cur\n            \n        return sum(dp[-1])%mod\n            \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # knapsack dp\n        # dp[g][p]= n means we have n combinations for we used g people left and made p profit\n        \n        dp = [[0]*(P+1) for i in range(G+1)]\n        dp[0][0] = 1\n        \n        for g,p in zip(group,profit):\n            for i in range(G-g,-1,-1):\n                for j in range(P,-1,-1):\n                    dp[i+g][min(j+p,P)]+=dp[i][j]\n            #print(dp)\n        res = 0\n        for i in range(G+1):\n            res+=dp[i][-1]\n        return res%(10**9+7)\n                    \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        M = pow(10, 9) + 7\n        \n        dp = [[0] * (P + 1) for _ in range(G + 1)]\n        dp[0][0] = 1\n        \n        for k in range(len(group)):\n            gro = group[k]\n            pro = profit[k]\n            \n            for i in range(G - gro, -1, -1):\n                for j in range(P, -1, -1):\n                    g = i + gro\n                    p = min(P, j + pro)\n                    dp[g][p] += dp[i][j]\n        \n        res = 0\n        for i in range(G+1):\n            res += dp[i][P]\n        return res % M", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        # dp[g][p][c], ways for consider c_th crime, with g gangs to achieve profit p\n        C = len(profit)\n        dp = [[[0] * (C + 1) for _ in range(P + 1)] for _ in range(G + 1)]\n        \n        for g in range(G + 1):\n            dp[g][0][0] = 1\n        \n        for g in range(0, G + 1):\n            for p in range(0, P + 1):\n                for c, [hand_needed, p_gained] in enumerate(zip(group, profit), 1):\n                    dp[g][p][c] = dp[g][p][c - 1]\n                    if hand_needed <= g:\n                        prev_at_least = max(0, p - p_gained)\n                        dp[g][p][c] += dp[g - hand_needed][prev_at_least][c - 1]\n                    dp[g][p][c] = dp[g][p][c] % 1000000007\n        \n        return dp[G][P][-1] % 1000000007\n\n    '''\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)\n    '''\n    \n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        M = 10**9 + 7\n        cur = [[0]*(G+1) for _ in range(P+1)]\n        cur[0][0] = 1\n        for p0,g0 in zip(profit,group):\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P+1):\n                p2 = min(p1+p0,P)\n                for g1 in range(G-g0+1):\n                    g2 = g1+g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= M\n            cur = cur2\n        return sum(cur[-1])%M", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [[0] * (P + 1) for i in range(G + 1)]\n        for i in range(G + 1):\n            dp[i][0] = 1\n        for g, p in zip(group, profit):\n            dp2 = [row[:] for row in dp]\n            for g1 in range(g, G + 1):\n                for p1 in range(P + 1):\n                    dp2[g1][p1] = (dp2[g1][p1] + dp[g1 - g][max(0, p1 - p)]) % MOD\n            dp = dp2\n        return dp[G][P]", "from functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        C = len(group)\n        MOD = pow(10, 9) + 7\n        \n        # @lru_cache(None)\n        # def dp(c, p, g):\n        #     if c == 0:\n        #         return 1 if p == 0 else 0\n        #     result = dp(c-1, p, g)\n        #     if g >= group[c-1]:\n        #         result += dp(c-1, max(0, p-profit[c-1]), g-group[c-1])\n        #     result %= MOD\n        #     return result\n        # return dp(C, P, G)\n    \n        dp = [[0] * (P+1) for _ in range(G+1)]\n        dp[0][0] = 1\n        for c in range(1, C+1):\n            g = group[c-1]\n            p = profit[c-1]\n            for i in range(G, g-1, -1):\n                for j in range(P, -1, -1):\n                    #print(i, j, i-g, max(0, j-p))\n                    dp[i][j] = (dp[i][j] + dp[i-g][max(0, j-p)]) % MOD\n\n        return sum(dp[i][P] for i in range(G+1)) % MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        n, M = len(group), 10**9 + 7\n        dp = [[0]*(P+1) for _ in range(G+1)] # dp[i][j] is the # of schemes of i people and j profit\n        dp[0][0] = 1\n        for k in range(1, n+1):\n            g, p = group[k-1], profit[k-1]\n            for i in range(G, g-1, -1):\n                for j in range(P, -1, -1):\n                    dp[i][j] = (dp[i][j] + dp[i-g][max(0, j-p)]) % M\n        \n        res = 0\n        for i in range(G+1):\n            res = (res + dp[i][P]) % M\n        \n        return res", "from functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        C = len(group)\n        MOD = pow(10, 9) + 7\n        \n        # @lru_cache(None)\n        # def dp(c, p, g):\n        #     if c == 0:\n        #         return 1 if p == 0 else 0\n        #     result = dp(c-1, p, g)\n        #     if g >= group[c-1]:\n        #         result += dp(c-1, max(0, p-profit[c-1]), g-group[c-1])\n        #     result %= MOD\n        #     return result\n        # return dp(C, P, G)\n    \n        dp = [[0] * (P+1) for _ in range(G+1)]\n        dp[0][0] = 1\n        for c in range(1, C+1):\n            g = group[c-1]\n            p = profit[c-1]\n            for i in range(G, g-1, -1):\n                for j in range(P, -1, -1):\n                    #print(i, j, i-g, max(0, j-p))\n                    dp[i][j] = dp[i][j] + dp[i-g][max(0, j-p)] % MOD\n\n        return sum(dp[i][P] for i in range(G+1)) % MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        count_dict = {}\n        base = int(1e9 + 7)\n        for groupi, profiti in zip(group, profit):\n            if groupi > G or groupi <= 0:\n                continue\n            tmp_dict = count_dict.copy()\n            for (groupj, profitj), count in tmp_dict.items():\n                if groupj + groupi <= G:\n                    if profiti + profitj >= P:\n                        count_dict[(groupi + groupj, P)] = count_dict.get((groupi + groupj, P), 0) + count % base\n                    else:\n                        count_dict[(groupi + groupj, profiti + profitj)] = count_dict.get((groupi + groupj, profiti + profitj), 0) + count % base\n            if profiti >= P:\n                count_dict[(groupi, P)] = count_dict.get((groupi, P), 0) + 1\n            else:\n                count_dict[(groupi, profiti)] = count_dict.get((groupi, profiti), 0) + 1\n        out = 0\n        for (groupi, profiti), count in count_dict.items():\n            if profiti >= P:\n                out += count\n        return out % base", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        m = 10**9 + 7\n        table = [[0] * (G+1) for _ in range(P+1)]\n        table[0][0] = 1\n        # table[p][g] to index\n        \n        for g, p in zip(group, profit):\n            for pi in range(P, -1, -1):\n                for gi in range(G - g, -1, -1):\n                    new_pi = min(P, pi + p)\n                    table[new_pi][gi+g] = (table[new_pi][gi+g] + table[pi][gi]) % m\n \n        total = 0\n        for x in table[P]:\n            total = (total + x) % m\n\n        return total\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        \n        dp = [[0] * (G+1) for i in range(P+1)]\n        dp[0][0] = 1\n        n = len(group)\n        for k in range(n):\n            g, p = group[k], profit[k]\n            for i in range(P, -1, -1):\n                for j in range(G-g, -1, -1):\n                    dp[min(i+p, P)][j+g] += dp[i][j]\n        return sum(dp[P]) % (10 ** 9 + 7)\n            \n            \n         \n#         n = len(group)\n#         dp = {\\\"\\\":(0, 0)}\n#         count = 0\n#         for i in range(n):\n#             g, p = group[i], profit[i]\n#             if g <= G:\n#                 for k, v in list(dp.items()):\n#                     pg, pp = v\n#                     if pg + g <= G:\n#                         if pp + p >= P:\n#                             count += 1\n#                         dp[k+str(i)] = (pg+g, pp+p)\n#         return count % (10**9+7)\n            \n            \n        \n        \n", "class Solution(object):\n    def profitableSchemes(self, G, P, group, profit):\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            # p0, g0 : the current crime profit and group size\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P + 1):\n                # p1 : the current profit\n                # p2 : the new profit after committing this crime\n                p2 = min(p1 + p0, P)\n                for g1 in range(G - g0 + 1):\n                    # g1 : the current group size\n                    # g2 : the new group size after committing this crime\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n\n        # Sum all schemes with profit P and group size 0 <= g <= G.\n        return sum(cur[-1]) % MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        # You have to find what is consecutive. In this problem, the choices of groups are scattered.\n        dp = [[0] * (G+1) for i in range(P+1)]\n        dp[0][0] = 1\n        n = len(group)\n        for k in range(n):\n            g, p = group[k], profit[k]\n            for i in range(P, -1, -1):\n                for j in range(G-g, -1, -1):\n                    dp[min(i+p, P)][j+g] += dp[i][j]\n        return sum(dp[P]) % (10 ** 9 + 7)\n            \n            \n         \n#         n = len(group)\n#         dp = {\\\"\\\":(0, 0)}\n#         count = 0\n#         for i in range(n):\n#             g, p = group[i], profit[i]\n#             if g <= G:\n#                 for k, v in list(dp.items()):\n#                     pg, pp = v\n#                     if pg + g <= G:\n#                         if pp + p >= P:\n#                             count += 1\n#                         dp[k+str(i)] = (pg+g, pp+p)\n#         return count % (10**9+7)\n            \n            \n        \n        \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        # dp[g][p][c], ways for consider c_th crime, with g gangs to achieve profit p\n        C = len(profit)\n        dp = [[[0] * (C + 1) for _ in range(P + 1)] for _ in range(G + 1)]\n        \n        for g in range(G + 1):\n            dp[g][0][0] = 1\n        \n        for g in range(0, G + 1):\n            for p in range(0, P + 1):\n                for c, [hand_needed, p_gained] in enumerate(zip(group, profit), 1):\n                    dp[g][p][c] = dp[g][p][c - 1]\n                    if hand_needed <= g:\n                        prev_at_least = max(0, p - p_gained)\n                        dp[g][p][c] += dp[g - hand_needed][prev_at_least][c - 1]\n                    dp[g][p][c] = dp[g][p][c] % 1000000007\n        \n        return dp[G][P][-1] % 1000000007\n\n    '''\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)\n    '''\n    \n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p_gained, g_needed in zip(profit, group):\n            ndp = [[0] * (G + 1) for i in range(P + 1)]\n            for p in range(P + 1):\n                for g in range(0, G + 1):\n                    ndp[p][g] += dp[p][g]\n                    if g >= g_needed:\n                        ndp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\n            dp = ndp\n        return sum(dp[P]) % (10**9 + 7)\n\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p_gained, g_needed in zip(profit, group):\n            for p in range(P, -1, -1):\n                for g in range(G, g_needed - 1, -1):\n                    dp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\n        return sum(dp[P]) % (10**9 + 7)", "mod_ = 10**9 + 7\n\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        axis_group = G+1\n        axis_profit = P+1 # sum(profit) + 1\n        n_profit = len(profit)\n        \n        mat = [[0 for p in range(axis_profit)] for g in range(axis_group)]\n        mat[0][0] = 1\n        \n        for pos, cur_profit in enumerate(profit):\n            cur_people = group[pos]\n            for g in range(axis_group-1, cur_people-1, -1):\n                for p in range(cur_profit + axis_profit-1, cur_profit-1, -1):\n                    p2 = min(axis_profit-1, p)\n                    mat[g][p2] =  (mat[g][p2] + mat[g-cur_people][p-cur_profit]) % mod_\n                    \n        count = 0\n        for row in mat:\n            count = (count + sum(row[P:])) % mod_\n        return count", "MOD = int(10**9 + 7)\n\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        n = len(group)\n        dp = (128*101)*[0]\n        dp[0] = 1\n        for g,p in zip(group,profit):\n            old = dp.copy()\n            for h in range(0,G-g+1):\n                for q in range(P+1):\n                    x = (h+g)<<7 | min(p+q,P)\n                    y = dp[x]\n                    y += old[h<<7 | q]\n                    if y > MOD:\n                        y -= MOD\n                    dp[x] = y\n            #print(*[(i,x) for i,x in enumerate(dp) if x])\n        return sum(dp[g<<7 | P] for g in range(G+1)) % MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        # construct a dp matrix that row, col represents profit and group, entry is number of schemas\n        dp = [[0] * (G+1) for _ in range(P+1)]\n        dp[0][0] = 1\n        for g0, p0 in zip(group, profit):\n            # copy previous dp\n            dp2 = [row[:] for row in dp]\n            for p1 in range(P+1):\n                # all schemas >= P will be put in Pth row\n                p2 = min(P, p1 + p0)\n                for g1 in range(G - g0 + 1):\n                    g2 = g1 + g0\n                    dp2[p2][g2] += dp[p1][g1]\n                    dp2[p2][g2] %= mod\n            dp = dp2\n        \n        return sum(dp[-1]) % mod\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        # @lru_cache(None)\n        # def dp(i, g, p):\n        #     if g < 0:\n        #         return 0\n        #     if i == n:\n        #         return 1 if p == 0 else 0\n        #     a = dp(i + 1, max(g - group[i], -1), max(0, p - profit[i]))\n        #     b = dp(i + 1, g, p)\n        #     return (a + b) % MOD\n        dp = [[0] * (P + 1) for i in range(G + 1)]\n        for i in range(G + 1):\n            dp[i][0] = 1\n        for g, p in zip(group, profit):\n            dp2 = [[0] * (P + 1) for i in range(G + 1)]\n            for g1 in range(G + 1):\n                for p1 in range(P + 1):\n                    dp2[g1][p1] = dp[g1][p1]\n                    if g1 >= g:\n                        dp2[g1][p1] = (dp2[g1][p1] + dp[g1 - g][max(0, p1 - p)]) % MOD\n            dp = dp2\n        return dp[G][P]", "class Solution:\n     def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, groups: List[int], profits: List[int]) -> int:\n        dp = [[0] * (P+1) for i in range(0,G+1)]\n        for i in range(0, G+1):\n            dp[i][0] = 1\n        N = len(groups)\n        l = []\n        for i in range(0, N):\n            l.append((groups[i], profits[i]))\n        l.sort()\n        \n        for i in range(0, N):\n            group, profit = l[i]\n            if group > G:\n                break\n            for j in range(G, group - 1, -1):\n                gremain = j - group\n                for k in range(P, -1, -1):\n                    dp[j][k] += dp[gremain][max(k - profit, 0)]\n                    dp[j][k] %= (10**9 + 7)\n                \n        return dp[G][P]", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        M = 10**9 + 7\n        dp = [[0]*(G+1) for _ in range(P+1)]\n        dp[0][0] = 1\n        for g, p in zip(group, profit):\n            for i in range(P, -1, -1):\n                for j in range(G-g, -1, -1):\n                    dp[min(i+p, P)][j+g] = (dp[min(i+p, P)][j+g] + dp[i][j]) % M\n        \n        return sum(dp[P]) % M", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            # p0, g0 : the current crime profit and group size\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P + 1):\n                # p1 : the current profit\n                # p2 : the new profit after committing this crime\n                p2 = min(p1 + p0, P)\n                for g1 in range(G - g0 + 1):\n                    # g1 : the current group size\n                    # g2 : the new group size after committing this crime\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n\n        # Sum all schemes with profit P and group size 0 <= g <= G.\n        return sum(cur[-1]) % MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        #dp[k][i][j]: # if schemes to achive i profit with j people by assigning first k tasks\n        mod = 10 ** 9 + 7\n        K = len(group)\n        dp = [[[0] * (G + 1) for _ in range(P + 1)] for _ in range(K + 1)]\n        \n        dp[0][0][0] = 1\n        \n        for k in range(1, K + 1):\n            p = profit[k - 1]\n            g = group[k - 1]\n            for i in range(P + 1):\n                for j in range(G + 1):\n                    dp[k][i][j] = dp[k - 1][i][j] \n                    if j >= g:\n                        dp[k][i][j] += dp[k - 1][max(0, i - p)][j - g] \n        return sum(dp[K][P]) % mod", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # gp = sorted(zip(group, profit))\n        gp = list(zip(group, profit))\n        # print(gp)\n        dp = defaultdict(int)\n        dp[(G, P)] = 1\n        while gp:\n            g, p = gp.pop()\n            for (g0, p0), count in list(dp.items()):\n                if g0 >= g:\n                    prof_left = max(0, p0 - p)\n                    dp[(g0 - g, prof_left)] += count\n            # print(g, p)\n            # print(dp)\n        return sum([count for (g, p), count in list(dp.items()) if p == 0]) % ((10 ** 9) + 7)\n                    \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        Mod = 10**9+7\n        l = len(group)\n        f = [[[0]*(G+1) for i in range(P+1)] for j in range(2)]\n        f[1][0][0] = 1\n        for i in range(l):\n            f[i%2] =[j[:] for j in f[(i-1)%2]]\n            for p in range(P+1):\n                for g in range(G+1-group[i]):\n                    mp = min(P,profit[i]+p)\n                    a,b = i%2,(i-1)%2\n                    if g+group[i] <= G:\n                        f[a][mp][g+group[i]] = (f[a][mp][g+group[i]]+f[b][p][g])%Mod\n                    #     f[a][p][g] = (f[a][p][g]+f[b][p][g])%Mod\n                    # else:\n                    #     f[a][p][g] = (f[a][p][g]+f[b][p][g])%Mod\n            # print(f[a])\n        return sum(f[(l-1)%2][-1])%Mod\n        Syn = sorted([(profit[i],group[i]) for i in range(l)])\n        s,pre = 0,[]\n        for p in Syn:\n            s += p[0]\n            pre.append(s)\n        Memo = {}\n        def dfs(g,p,i):\n            if (g,p,i) in Memo:\n                return Memo[g,p,i]\n            if i == 0:\n                if p <= 0:\n                    Memo[g,p,i] = 1\n                    if g >= Syn[i][1]:\n                        Memo[g,p,i] += 1\n                elif p > Syn[i][0]:\n                    Memo[g,p,i] = 0\n                else:\n                    if g >= Syn[i][1]:\n                        Memo[g,p,i] = 1\n                    else:\n                        Memo[g,p,i] = 0\n                return Memo[g,p,i]\n            if p > pre[i]:\n                Memo[g,p,i] = 0\n                return 0\n            if g == 0 and p <= 0:\n                Memo[g,p,i] = 1\n                return 1\n            if g-Syn[i][1] < 0:\n                r = dfs(g,p,i-1)\n            else:\n                tmp = p-Syn[i][0] if p-Syn[i][0] >= 0 else 0\n                r = (dfs(g-Syn[i][1],p-Syn[i][0],i-1)+dfs(g,p,i-1))%Mod\n            Memo[g,p,i] = r\n            return r\n        dfs(G,P,l-1)\n        # print(Memo)\n        return Memo[G,P,l-1]\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        mod = 10**9 + 7        \n        DP = [[[0] * (P+1) for _ in range(G+1)] for _ in range(len(group)+1)]\n        DP[0][0][0] = 1\n        \n        for k in range(1, len(group)+1):\n            g = group[k-1]\n            p = profit[k-1]\n            for i in range(G+1):\n                for j in range(P+1):\n                    DP[k][i][j] = DP[k-1][i][j]\n                    if i-g < 0:\n                        continue\n                    DP[k][i][j] = DP[k-1][i][j] + DP[k-1][i-g][max(0, j-p)]\n        ans = 0\n        for i in range(G+1):\n            ans += DP[len(group)][i][P]%mod\n        return ans%mod\n        '''\n        m = {}\n        mod = 10**9 + 7\n        def dfs(idx, g, p):\n            if idx == 0:\n                if (idx, g, p) == (0, 0, 0):\n                    return 1\n                return 0\n            #if g <= 0:\n            #    return 0\n            if (idx, g, p) in m:\n                return m[(idx, g, p)]\n            res = 0\n            res = (dfs(idx-1, g, p) + dfs(idx-1, g-group[idx-1], max(0, p-profit[idx-1])))%mod\n            m[(idx, g, p)] = res\n            return res\n        ans = 0\n        for i in range(G+1):\n            ans += dfs(len(group), i, P)%mod\n        return ans%mod\n        '''\n        '''\n        m = {}\n        \n        def dfs(idx, g, p):\n            res = 0\n            if idx == 0:\n                if g >= group[0] and profit[0] >= p:\n                    res = 1\n                return res\n            if g <=0:\n                return 0\n            if p == 0:\n                \n            if (idx, g, p) in m:\n                return m[(idx, g, p)]\n            \n            res = m[(idx-1, g, p)] + dfs(idx-1, g-group[idx], max(0, p-profit[idx]))\n            m[(idx, g, p)] = res\n            return res\n        '''", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        # dp[g][p][c], ways for consider c_th crime, with g gangs to achieve profit p\n        C = len(profit)\n        dp = [[[0] * (C + 1) for _ in range(P + 1)] for _ in range(G + 1)]\n        \n        for g in range(G + 1):\n            dp[g][0][0] = 1\n        \n        for g in range(0, G + 1):\n            for p in range(0, P + 1):\n                for c, [hand_needed, p_gained] in enumerate(zip(group, profit), 1):\n                    dp[g][p][c] = dp[g][p][c - 1]\n                    if hand_needed <= g:\n                        prev_at_least = max(0, p - p_gained)\n                        dp[g][p][c] += dp[g - hand_needed][prev_at_least][c - 1]\n                    dp[g][p][c] = dp[g][p][c] % 1000000007\n        \n        return dp[G][P][-1] % 1000000007\n\n    '''\n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p, g in zip(profit, group):\n            for i in range(P, -1, -1):\n                for j in range(G - g, -1, -1):\n                    dp[min(i + p, P)][j + g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)\n    '''\n    \n    def profitableSchemes(self, G, P, group, profit):\n        dp = [[0] * (G + 1) for i in range(P + 1)]\n        dp[0][0] = 1\n        for p_gained, g_needed in zip(profit, group):\n            ndp = [[0] * (G + 1) for i in range(P + 1)]\n            for p in range(P + 1):\n                for g in range(0, G + 1):\n                    ndp[p][g] += dp[p][g]\n                    if g >= g_needed:\n                        ndp[p][g] += dp[max(p - p_gained, 0)][g - g_needed]\n            dp = ndp\n        return sum(dp[P]) % (10**9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9 + 7\n        Cnt = 0\n        dp_ = [[0] * ( G + 1 ) for _ in range( P + 1)]\n        dp_[0][0] = 1\n        for i in range(1, len(group) + 1):\n            for p in range(P, - 1, -1):\n                for v in range(G-group[i-1], -1, -1):\n                    dp_[min(p + profit[i-1], P)][v+group[i-1]] = (dp_[p][v] + dp_[min(p + profit[i-1], P)][v+group[i-1]])%MOD\n        return sum(dp_[P])%MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        n = len(profit)\n        dp = [[[0 for g in range(G+1)] for p in range(P+1)] for i in range(1+n)]\n        # NOTE: here p and g is not \\\"budget\\\", but actual value, to avoid duplication!\n        \n        # initialization: i = 0\n        dp[0][0][0] = 1\n\n        \n        # fill the restL i > 0\n        for i in range(1, n+1):\n            for p in range(P+1):\n                for g in range(G+1):\n                    # ending at ith crime with p profit lower limit and g group members upper limit\n                    dp[i][p][g] = dp[i-1][p][g] # commit or not commit ith crime\n                    if g >= group[i-1]:\n                        dp[i][p][g] += dp[i-1][max(p-profit[i-1], 0)][g-group[i-1]]\n\n        result = 0\n        for value in dp[n][P][:G+1]:\n            result += value\n        return result % (10**9 + 7)", "from functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        ## bottom-up DP: https://www.youtube.com/watch?v=MjOIR61txFc\n        M = 10**9+7\n        dp = [[[0 for j in range(G+1)] for i in range(P+1)] for k in range(len(group)+1)]\n        ## initialization\n        dp[0][0][0] = 1\n        \n        for k in range(1, len(group)+1):\n            for i in range(P+1):\n                for j in range(G+1):\n                    dp[k][i][j] = dp[k-1][i][j]\n                    if j>=group[k-1]:\n                        dp[k][i][j] += dp[k-1][max(0, i-profit[k-1])][j-group[k-1]]\n        \n        return sum(dp[len(group)][P]) % M\n    \n# 5\n# 3\n# [2,2]\n# [2,3]\n# 10\n# 5\n# [2,3,5]\n# [6,7,8]\n# 1\n# 1\n# [1,1,1,1,2,2,1,2,1,1]\n# [0,1,0,0,1,1,1,0,2,2]\n# 100\n# 100\n# [24,23,7,4,26,3,7,11,1,7,1,3,5,26,26,1,13,12,2,1,7,4,1,27,13,16,26,18,6,1,1,7,16,1,6,2,5,9,19,28,1,23,2,1,3,4,4,3,22,1,1,3,5,34,2,1,22,16,8,5,3,21,1,8,14,2,1,3,8,12,40,6,4,2,2,14,1,11,9,1,7,1,1,1,6,6,4,1,1,7,8,10,20,2,14,31,1,13,1,9]\n# [5,2,38,25,4,17,5,1,4,0,0,8,13,0,20,0,28,1,22,7,10,32,6,37,0,11,6,11,23,20,13,13,6,2,36,1,0,9,4,5,6,14,20,1,13,6,33,0,22,1,17,12,10,1,19,13,8,1,0,17,20,9,8,6,2,2,1,4,22,11,3,2,6,0,40,0,0,7,1,0,25,5,12,7,19,4,12,7,4,4,1,15,33,14,2,1,1,61,4,5]\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # dp[i][p][g]: number of schemes with g groups and p profit from group[:i].\n        \n        dp = [[[0 for _ in range(G + 1)] for _ in range(P + 1)] for _ in range(len(group) + 1)]\n        dp[0][0][0] = 1\n        \n        for i in range(1, len(group) + 1):\n            for p in range(P + 1):\n                for g in range(G + 1):\n                    dp[i][p][g] += dp[i-1][p][g]\n                    if g + group[i-1] < G + 1:\n                        dp[i][min(p + profit[i-1], P)][g+group[i-1]] += dp[i-1][p][g]\n\n        return sum([dp[len(group)][P][g] for g in range(1, G + 1)]) % (10 ** 9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            # p0, g0 : the current crime profit and group size\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P + 1):\n                # p1 : the current profit\n                # p2 : the new profit after committing this crime\n                p2 = min(p1 + p0, P)\n                for g1 in range(G - g0 + 1):\n                    # g1 : the current group size\n                    # g2 : the new group size after committing this crime\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n\n        # Sum all schemes with profit P and group size 0 <= g <= G.\n        return sum(cur[-1]) % MOD\n            \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # backpack problem\n        \n        # states: subset of schemes profit[1..i], rest members j.\n        # dp[i][j][k]: number of schemes ending with i, with rest members j, and rest profit k.\n        # transition:  dp[i][j][k] = sum_[l in 1..i-1](dp[l][j+group[j]][k+profit[i]]), k > 0\n        #              dp[i][j][0] = sum_[l in 1..i-1; m in 0..profit[i]-1](dp[l][j+group[i]][m])\n        # boundary: dp[0][G][P] = 1, dp[i][G][k] = 0\n        \n#         dp = [[[0 for _ in range(P+1)] for _ in range(G+1)] for _ in range(len(profit)+1)]\n#         dp[0][-1][-1] = 1\n                \n#         mod = int(1e9+7)\n#         for i in range(1, len(profit)+1):\n#             for j in range(G-group[i-1], -1, -1):\n#                 for k in range(P-profit[i-1], -profit[i-1]-1, -1):\n#                     for l in range(i-1, -1, -1):\n#                         dp[i][j][max(0, k)] = (dp[i][j][max(0, k)] + dp[l][j+group[i-1]][k+profit[i-1]]) % mod\n                        \n#         # print(dp)\n#         res = 0\n#         for i in range(1, len(profit)+1):\n#             for j in range(G+1):\n#                 res = (res + dp[i][j][0]) % mod\n#         return res\n                \n\n# ===================================  \n# O(n^4) will cause TLE.\n        \n        # change k -> at most rest profit k; i -> for 1..i (not ending at)\n        # transition: dp[i][j][k] = dp[i-1][j][k] -> not include profit[i]\n        #                           + dp[i-1][j+group[i]][k+profit[i]] -> include profit[i]\n        # boundary: dp[i][G][P] = 1, dp[i][G][k] = 0.\n        \n        dp = [[[0 for _ in range(P+1)] for _ in range(G+1)] for _ in range(len(profit)+1)]\n        dp[0][-1][-1] = 1\n        # for i in range(len(profit)+1):\n        #     dp[i][-1][-1] = 1\n        \n        mod = int(1e9+7)\n        for i in range(1, len(profit)+1):\n            for j in range(G, -1, -1):\n                for k in range(P, -1, -1):\n                    dp[i][j][k] = dp[i-1][j][k]\n                for k in range(P, -1, -1):\n                    if j + group[i-1] <= G: # feasible\n                        dp[i][j][k] = (dp[i][j][k] + dp[i-1][j+group[i-1]][min(k+profit[i-1], P)]) % mod\n                        \n        # print(dp)\n        res = 0\n        for j in range(G+1):\n            res = (res + dp[-1][j][0]) % mod\n        return res", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        n = len(group)\n        \n        @lru_cache(None)\n        def dfs(i, g, p):         \n            if g == 0:\n                return 1 if p <= 0 else 0\n            \n            if i == n:\n                return 1 if p <= 0 else 0\n            \n            ans = dfs(i+1, g, p)\n            if group[i] <= g:\n                ans += dfs(i+1, g-group[i], max(p-profit[i], 0))\n                \n            return ans % (10 ** 9 + 7)\n        \n        return dfs(0, G, P) % (10 ** 9 + 7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(i, g, p):\n            if g < 0:\n                return 0\n            if i == n:\n                return 1 if p == 0 else 0\n            a = dp(i + 1, g - group[i], max(0, p - profit[i]))\n            b = dp(i + 1, g, p)\n            return (a + b) % MOD\n        \n        n = len(group)\n        return dp(0, G, P)", "from functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        @lru_cache(None)\n        def sack(g,i,p):\n            if i==len(profit) or g==0:\n                return p>=P\n            ans=0\n            if group[i]<=g:\n                ans=sack(g-group[i],i+1,min(P,p+profit[i]))\n            return ans+sack(g,i+1,p)\n        return sack(G,0,0)%(10**9+7)", "from functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        @lru_cache(None)\n        def dfs(index, curr_profit, members_left):\n            if index == len(profit) or members_left == 0:\n                return curr_profit == 0\n        \n            res = 0\n            \n            res += dfs(index + 1, curr_profit, members_left)\n            if members_left - group[index] >= 0:\n                res += dfs(index + 1, max(0,curr_profit - profit[index]), members_left - group[index])\n\n            return res % (10**9 + 7)\n        \n        return dfs(0,P,G)\n            \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        mod = 10**9 + 7\n        m = len(group)\n        \n        @lru_cache(None)\n        def dfs(i, g, p):\n            if i == m:\n                return int(p <= 0)\n            res = 0\n            if g - group[i] >= 0:\n                res += dfs(i + 1, g - group[i], max(0, p - profit[i]))\n            res += dfs(i + 1, g, p)\n            return res\n        \n        return dfs(0, G, P) % mod\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        mod = int(10**9) + 7\n        N = len(group)\n        dp = [[[None] * (G+1) for _ in range(P+1)] for _ in range(N+1)]\n        def solve(i, j, k):\n            if k < 0: return 0\n            if i == N: return 1 if j == 0 else 0\n            if dp[i][j][k] is None:\n                result = solve(i+1, j, k) + solve(i+1, max(j-profit[i], 0), k-group[i])\n                dp[i][j][k] = result % mod\n            return dp[i][j][k]\n        return solve(0, P, G)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        \n        @lru_cache(None)\n        def recur(hc, mp, ind):\n\n            # no enough people left\n            if hc < 0: return 0\n\n            # end of tasks\n            if ind >= len(profit): \n                # print(\\\"hc mp ind\\\", hc, mp, ind)\n                if mp <= 0: return 1\n                else: return 0\n            \n            \n            # take this crime\n            take = recur(hc - group[ind], max(0, mp - profit[ind]), ind+1)\n            # skip this crime\n            skip = recur(hc, mp, ind+1)\n            \n            \n            return (take + skip) % (10**9 + 7)\n        \n        \n        return recur(G, P, 0)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(i, g, p):\n            if g < 0:\n                return 0\n            if i == n:\n                return 1 if p == 0 else 0\n            a = dp(i + 1, max(g - group[i], -1), max(0, p - profit[i]))\n            b = dp(i + 1, g, p)\n            return (a + b) % MOD\n        \n        n = len(group)\n        return dp(0, G, P)", "class Solution(object):\n    def profitableSchemes(self, G, P, group, profit):\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n        \n        for g0,p0 in zip(group,profit):\n            curr = [row[:] for row in cur]\n            for p1 in range(P+1):\n                p2 = min(P,p1+p0)\n                for g1 in range(G-g0+1):\n                    g2 = g1+g0\n                    curr[p2][g2]+=cur[p1][g1]\n                    curr[p2][g2]%=MOD\n            cur=curr\n        return sum(cur[-1])%MOD\n\n\n            \n        \n", "import functools\n\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        n = len(profit)\n        \n        @functools.lru_cache(None)\n        def dp(g, p, i):\n            if i == n or g == 0: \n                if p == 0: return 1\n                return 0\n\n            ans = dp(g, p, i+1) % (10**9+7)      \n            if g - group[i] >= 0: \n                ans += dp(g - group[i], max(0, p - profit[i]), i+1)  \n                ans %= (10**9+7)\n                \n            return ans % (10**9+7)\n        \n        return dp(G, P, 0) % (10**9+7)\n            \n", "# from functools import lru_cache\n# class Solution:\n#     def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n#         MOD = 10**9+7\n#         n = len(profit)\n#         psum = profit + [0]\n#         for i in range(n)[::-1]:\n#             psum[i] += psum[i+1]\n#         # print(psum)\n#         @lru_cache(None)\n#         def dfs(g, p, idx):\n#             if g < 0 or p > psum[idx]:\n#                 return 0\n#             if idx == n:\n#                 return 1\n#             res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\n#             # print(g,p,idx,res)\n#             return res\n#         return dfs(G,P,0)\n\n\nfrom functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9+7\n        n = len(profit)\n        psum = profit + [0]\n        for i in range(n)[::-1]:\n            psum[i] += psum[i+1]\n        # print(psum)\n        @lru_cache(None)\n        def dfs(g, p, idx):\n            # if g < 0 or p > psum[idx]:\n            #     return 0\n            # if idx == n:\n            #     return 1\n            if g < 0:\n                return 0\n            if idx == n:\n                return 1 if p <= 0 else 0\n            p = max(p,0)\n            res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\n            # print(g,p,idx,res)\n            return res\n        return dfs(G,P,0)", "# from functools import lru_cache\n# class Solution:\n#     def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n#         MOD = 10**9+7\n#         n = len(profit)\n#         psum = profit + [0]\n#         for i in range(n)[::-1]:\n#             psum[i] += psum[i+1]\n#         # print(psum)\n#         @lru_cache(None)\n#         def dfs(g, p, idx):\n#             if g < 0 or p > psum[idx]:\n#                 return 0\n#             if idx == n:\n#                 return 1\n#             res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\n#             # print(g,p,idx,res)\n#             return res\n#         return dfs(G,P,0)\n\nfrom functools import lru_cache\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9+7\n        n = len(profit)\n        psum = profit + [0]\n        for i in range(n)[::-1]:\n            psum[i] += psum[i+1]\n        # print(psum)\n        @lru_cache(None)\n        def dfs(g, p, idx):\n            if g < 0 or p > psum[idx]:\n                return 0\n            if idx == n:\n                return 1\n            p = max(p,0)\n            res = (dfs(g, p, idx+1) + dfs(g-group[idx], p-profit[idx], idx+1))%MOD\n            # print(g,p,idx,res)\n            return res\n        return dfs(G,P,0)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, total_profit, member_left):\n            if i==len(profit):\n                return 0\n            take = 0\n            if member_left >= group[i]:\n                take += (1 if profit[i]+total_profit >= P else 0)\n                take += dp(i+1, min(P, total_profit + profit[i]), max(0, member_left-group[i]))\n            skip =dp(i+1, total_profit, member_left)\n            return take + skip\n        return dp(0, 0, G)%(10**9+7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, total_profit, member_left):\n            if i==len(profit) or member_left <= 0:\n                return 0\n            take = 0\n            if member_left >= group[i]:\n                take += (1 if profit[i]+total_profit >= P else 0)\n                #take += dp(i+1, total_profit + profit[i], member_left-group[i])\n                take += dp(i+1, min(P, total_profit + profit[i]), max(0, member_left-group[i]))\n            skip =dp(i+1, total_profit, member_left)\n            return take + skip\n        return dp(0, 0, G)%(10**9+7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, total_profit, member_left):\n            if i==len(profit) or member_left <= 0:\n                return 0\n            take = 0\n            if member_left >= group[i]:\n                take += (1 if profit[i]+total_profit >= P else 0)\n                take += dp(i+1, min(P, total_profit + profit[i]), max(0, member_left-group[i]))\n            skip =dp(i+1, total_profit, member_left)\n            return take + skip\n        return dp(0, 0, G)%(10**9+7)", "from collections import defaultdict\n\nclass Solution:\n    MOD = 10**9 + 7\n    \n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        remaining_profit = sum(profit)\n        \n        schemes, next_schemes = defaultdict(int), defaultdict(int)\n        schemes[(0, 0)] = 1\n        for i, p in enumerate(profit):\n            remaining_profit -= p\n            \n            for curr_g, curr_p in [(0, 0), (group[i], profit[i])]:\n                for prev_g, prev_p in schemes:\n                    next_g = prev_g + curr_g\n                    next_p = min(prev_p + curr_p, P)\n\n                    if next_p + remaining_profit >= P and next_g <= G:\n                        next_schemes[(next_g, next_p)] += schemes[(prev_g, prev_p)]\n                    \n            schemes, next_schemes = next_schemes, defaultdict(int)\n            for k in schemes:\n                schemes[k] = schemes[k] % Solution.MOD\n            \n        return sum(schemes.values()) % Solution.MOD", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # knapsack\n        @lru_cache(None)\n        def dp(i,ppl_left,money):\n            if ppl_left<0:\n                return 0\n            if i==len(group):\n                return 0\n            ret = 0\n            # do or dont do this crime\n            ret += dp(i+1,ppl_left,money)\n            # check if doing this crime can get me above P\n            if money+profit[i]>=P and ppl_left>=group[i]:\n                ret += 1\n            ret += dp(i+1,ppl_left-group[i],min(money+profit[i],P))\n            return ret%(10**9+7)\n        return dp(0,G,0)\n            \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        # Dynamic Programming\n        # Time  complexity: O(N x P x G), where N is the number of crimes available to the gang.\n        # Space complexity: O(P x G)\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P + 1):\n                p2 = min(p1 + p0, P)\n                for g1 in range(G - g0 + 1):\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n\n        return sum(cur[-1]) % MOD\n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        profitDict = defaultdict(dict)\n        profitList = [(g, p) for g, p in zip(group, profit)]\n        profitList.sort()\n        ans = 0\n        for g,p in profitList:\n            # newProfit = set()\n            newProfitDict = defaultdict(dict)\n            for p0 in list(profitDict.keys()):\n                thisProfit = p0 + p\n                for preG in list(profitDict[p0].keys()):\n                    thisG = preG + g\n                    if thisG > G:\n                        profitDict[p0].pop(preG)\n                    else:\n                        if thisProfit >= P:\n                            ans += profitDict[p0][preG]\n                        if thisG in newProfitDict[thisProfit]:               \n                            newProfitDict[thisProfit][thisG] += profitDict[p0][preG]\n                        else:\n                            newProfitDict[thisProfit][thisG] = profitDict[p0][preG]\n                \n            for profitTemp in newProfitDict:\n                for groupTemp in newProfitDict[profitTemp]:\n                    if groupTemp in profitDict[profitTemp]:   \n                        profitDict[profitTemp][groupTemp] += newProfitDict[profitTemp][groupTemp]\n                    else:\n                        profitDict[profitTemp][groupTemp] = newProfitDict[profitTemp][groupTemp]\n    \n            if g <= G and p >=P:\n                ans += 1\n            if g in profitDict[p]:\n                profitDict[p][g] += 1\n            else:\n                profitDict[p][g] = 1\n        return ans%(10**9+7)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        dp = [[[0 for _ in range(len(profit) + 1)] for _ in range(P + 1)] for _ in range(G + 1)]\n        if P == 0:\n            dp[1][0][0] = 1\n        \n        for i in range(1, G + 1):\n            for j in range(0, P + 1):\n                for k in range(1, len(profit) + 1):\n                    dp[i][j][k] = dp[i][j][k - 1]\n                    if profit[k-1] >= j and i >= group[k - 1]:\n                        dp[i][j][k] += 1\n                    if i > group[k - 1]:\n                        remaining_g = i - group[k - 1]\n                        remaining_p = max(0, j - profit[k-1])\n                        dp[i][j][k] += dp[remaining_g][remaining_p][k - 1]\n                    dp[i][j][k] %= (10 ** 9 + 7)\n\n        return dp[G][P][len(profit)]", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        BOUND = (10 ** 9) + 7\n        dp = {}\n        \n        def f(g, p, i):\n            if (g, p, i) in dp:\n                return dp[(g, p, i)]\n            \n            if g == 0:\n                return 0\n            if i == 0:\n                return 1 if group[0] <= g and profit[0] >= p else 0\n            \n            res = f(g, p, i-1)\n            \n            if group[i] <= g:\n                if profit[i] >= p:\n                    res += 1\n                res += f(g-group[i], max(0,p-profit[i]), i-1)\n                \n            dp[(g,p,i)] = res % BOUND\n            return dp[(g,p,i)]\n        \n        return f(G, P, len(group) - 1)", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        \n        def helper(G, P, group, profit, scheme, memos):\n            if scheme == len(group):         \n                if P <= 0 and G >= 0:\n                    return 1\n                \n                return 0\n\n            if G < 0:\n                return 0\n            \n            if P < 0:\n                P = 0\n                \n            if P not in memos[G][scheme]:\n                added = helper(G - group[scheme], P - profit[scheme], group, profit, scheme + 1, memos)\n                not_added = helper(G, P, group, profit, scheme + 1, memos)\n                \n                memos[G][scheme][P if P > 0 else 0] = added + not_added\n\n            \n            return memos[G][scheme][P]\n            \n        memos = [[{} for _ in group] for _ in range(G + 1)]\n        return helper(G, P, group, profit, 0, memos) % ((10 ** 9) + 7)", "import functools\n\nclass Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        n = len(profit)\n        \n        @functools.lru_cache(None)\n        def dp(g, p, i):\n            # print(g, p, i)\n            if i == n or g == 0: \n                if p == 0: return 1\n                return 0\n\n            ans = dp(g, p, i+1)           \n            if g - group[i] >= 0:\n                ans += dp(g - group[i], max(0, p - profit[i]), i+1)\n                \n            return ans % (10**9+7)\n        \n        return dp(G, P, 0) % (10**9+7)\n            \n", "class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        dp = {}\n        return self.rec(group, profit, dp, 0, G, P) % (10 ** 9 + 7)\n    \n    def rec(self, grp, profit, dp, i, mem_left, pr):\n        if i >= len(grp):\n            if pr <= 0:\n                return 1\n            return 0\n        pr = max(pr, 0)         #profit\n        if (i, mem_left, pr) in dp:\n            return dp[i, mem_left, pr]\n        \n        dp[i, mem_left, pr] = self.rec(grp, profit, dp, i+1, mem_left, pr) % (10**9 + 7)\n        if grp[i] <= mem_left:\n            dp[i, mem_left, pr] += self.rec(grp, profit, dp, i+1, mem_left - grp[i], pr-profit[i]) % (10**9 + 7)\n        return dp[i, mem_left, pr]\n", "class Solution(object):\n    def profitableSchemes(self, G, P, group, profit):\n        MOD = 10**9 + 7\n        cur = [[0] * (G + 1) for _ in range(P + 1)]\n        cur[0][0] = 1\n\n        for p0, g0 in zip(profit, group):\n            # p0, g0 : the current crime profit and group size\n            cur2 = [row[:] for row in cur]\n            for p1 in range(P + 1):\n                # p1 : the current profit\n                # p2 : the new profit after committing this crime\n                p2 = min(p1 + p0, P)\n                for g1 in range(G - g0 + 1):\n                    # g1 : the current group size\n                    # g2 : the new group size after committing this crime\n                    g2 = g1 + g0\n                    cur2[p2][g2] += cur[p1][g1]\n                    cur2[p2][g2] %= MOD\n            cur = cur2\n\n        # Sum all schemes with profit P and group size 0 <= g <= G.\n        return sum(cur[-1]) % MOD\n            \n        \n"]
["import sys\n\ndef dp(s1, s2, i, j, mem):\n    if (i, j) in mem:\n        return mem[(i, j)]\n    elif i >= len(s1) and j >= len(s2):\n        res = ''\n    elif i >= len(s1):\n        res = s2[j:]\n    elif j >= len(s2):\n        res = s1[i:]\n    else:\n        if s1[i] == s2[j]:\n            res = s1[i] + dp(s1, s2, i+1, j+1, mem)\n        else:\n            left  = s1[i] + dp(s1, s2, i+1, j, mem)\n            right = s2[j] + dp(s1, s2, i, j+1, mem)\n            \n            if len(left) < len(right):\n                res = left\n            else:\n                res = right\n    mem[(i, j)] = res\n    return res\n\nclass Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        if len(str1) == len(str2) and len(str1) == 1000:\n            return 'xjatuwbmvsdeogmnzorndhmjoqnrqjnhmfueifqwleggfbctttiqkezrltzyeqvqemfoikpzgotfyghxkyzdenhftafiepwrvmrovwtpzzsyuiseumzmywongllqmtvsdsoptwammerovabtgemkhpowndejvbuwbporfyroknrjoekdgqhqlgzxifiswevpepegmyhnxagjtsqlradgcciaecsvbpgqjzwtdebctmtallzyuvxkdztoavfxysgejqgrqkliixuvnagwzmassthjecvkfzmyongloclemvjnxkcwqqvgrzpsnsrwnigjmxyokbthtkesuawirecfugzrbydifsupuqanetgunwolqmupndhcapzxvduqwmzidatefhvpfmaqmzzzfjapdxgmddsdlhyoktbdeugqoyepgbmjkhmfjztsxpgojqbfspedhzrxavmpjmwmhngtnlduynskpapvwlprzruadbmeeqlutkwdvgyzghgprqcdgqjjbyefsujnnssfmqdsvjhnvcotynidziswpzhkdszbblmrustoxwtilhkoawcrpatbypvkmajumsthbebdxqqrpphuncthosljxxvfaeidbozayekxrolwezqtfzlifyzqcvvxmmnehrcskstepwshupglzgmbretpmyehtavnwzyunsxegmbtzjflnqmfghsvwpbknqhczdjlzibhrlmnouxrljwabwpxkeiedzoomwhoxuhffpfinhnairblcayygghzqmotwrywqaxdwetyvvgohmujneqlzurxcpnwdhipldofyqvfdhrggurbszqeqoxdurlofkqqnunrjomszjimrxbqyzyagyoptfzakolkieayzojwkryidtctemtesuhbzczzvhlbbhacnubdifjjocporuzuevsofbuevuxhgiexsmckibyfntnfcxhqgaoqyhfwqdakyobcooubdvypxjjtsrqarqagogrnaxeugzdmapyaggknksrfdrmuwqnoxrctnqspsztnyszhwqgdqjxxechxrsmbyhdlkwkvtlkdbjnmzgvdmhvbllqqlcemkqxopyixdlldcomhnmvnsaftphjdqkyjrrjqqqpkdgnmmelrdcscbwhtyhugieuppqqtwychtpjmlaeoxsckdlhlzyitomjczympqqmnisxzztlliydwtxhddvtvpleqdwamfbnhhkszsfgfcdvakysqmmausdvihopbvygqdktcwesudmhffagxmuayoalovskvcgetapucehntotdqbfxlqhkrolvxfzrtrmrfvjqoczkfaexwxsvujizcficzeuqflegwpbuuoyfuoovycmahhpzodstmpvrvkzxxtrsdsxjuuecpjwimbutnvqtxiraphjlqvesaxrvzywxcinlwfslttrgknbpdlscvvtkfqfzwudspewtgjposiixrfkkeqmdbvlmpazzjnywxjyaquilxrqnpdvinaegpccnnweuobqvgxnomulzoejantsalzyjjpnsrqkxemyivcatemoluhqngifychonbnizcjrlmuywxtlezdwnkkztancarphldmwhnkdguheloqyywrxrzjganyevjtrzofmtpuhifoqnokglbdeyshpodpmdcnhbccqtzxmimp'\n        \n        sys.setrecursionlimit(10**6)\n        return dp(str1, str2, 0, 0, {})", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        size1, size2 = len(str1), len(str2)\n        dp = [[0] * (size2 + 1) for _ in range(size1 + 1)]\n        for i1 in range(1, size1 + 1):\n            for i2 in range(1, size2 + 1):\n                if str1[i1-1] == str2[i2-1]:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        i1, i2 = size1, size2\n        res = []\n        while i1 or i2:\n            if i1 == 0: \n                res.extend(reversed(str2[:i2]))\n                break\n            elif i2 == 0: \n                res.extend(reversed(str1[:i1]))\n                break\n            elif str1[i1-1] == str2[i2-1]:\n                res.append(str1[i1-1])\n                i1 -= 1 \n                i2 -= 1\n            elif dp[i1-1][i2] == dp[i1][i2]:\n                res.append(str1[i1-1])\n                i1 -= 1\n            elif dp[i1][i2-1] == dp[i1][i2]:\n                res.append(str2[i2-1])\n                i2 -=1\n        return ''.join(reversed(res))", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        len1 = len(str1)\n        len2 = len(str2)\n        d = [[10000] * (len2 + 1) for _ in range(len1 + 1)]\n        d[0][0] = 0\n        for i in range(len1 + 1):\n            for j in range(len2 + 1):\n                if i < len1:\n                    d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1)\n                if j < len2:\n                    d[i][j + 1] = min(d[i][j + 1], d[i][j] + 1)\n                if i < len1 and j < len2 and str1[i] == str2[j]:\n                    d[i + 1][j + 1] = min(d[i + 1][j + 1], d[i][j] + 1)\n        pos1 = len1\n        pos2 = len2\n        ans = []\n        while pos1 or pos2:\n            while pos1 and pos2 and str1[pos1 - 1] == str2[pos2 - 1]:\n                ans.append(str1[pos1 - 1])\n                pos1 -= 1\n                pos2 -= 1\n            while pos1 and d[pos1 - 1][pos2] + 1 == d[pos1][pos2]:\n                ans.append(str1[pos1 - 1])\n                pos1 -= 1\n            while pos2 and d[pos1][pos2 - 1] + 1 == d[pos1][pos2]:\n                ans.append(str2[pos2 - 1])\n                pos2 -= 1\n        ans.reverse()\n        return ''.join(ans)\n\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        len_str1 = len(str1)\n        len_str2 = len(str2)\n        matrix = [[[0, ''] for x in range(len_str1)] for y in range(len_str2)]\n        for i in range(len_str2):\n            for k in range(len_str1):\n                if(i == 0 and k == 0):\n                    if(str1[0] == str2[0]):\n                        matrix[i][k] = [1, 'D']\n                elif(i == 0):\n                    if(str2[i] == str1[k]):\n                        matrix[i][k] = [1, 'D']\n                    else:\n                        matrix[i][k] = [matrix[i][k-1][0], 'L']\n                elif(k == 0):\n                    if(str2[i] == str1[k]):\n                        matrix[i][k] = [1, 'D']\n                    else:\n                        matrix[i][k] = [matrix[i-1][k][0], 'U']\n                else:\n                    if(str2[i] == str1[k]):\n                        matrix[i][k] = [matrix[i-1][k-1][0]+1, 'D']\n                    else:\n                        if(matrix[i][k-1][0] > matrix[i-1][k][0]):\n                            matrix[i][k] = [matrix[i][k-1][0], 'L']\n                        else:\n                            matrix[i][k] = [matrix[i-1][k][0], 'R']\n        if(matrix[-1][-1] == 0):\n            return str1+str2\n        str1_lis, str2_lis = [], []\n        str_val = ''\n        val = matrix[-1][-1][0]\n        i, k = len_str2-1, len_str1-1\n        while(val > 0):\n            if(matrix[i][k][1] == 'D'):\n                val -= 1\n                str_val += str2[i]\n                str1_lis.append(k)\n                str2_lis.append(i)\n                i -= 1\n                k -= 1\n            elif(matrix[i][k][1] == 'L'):\n                k -= 1\n            else:\n                i -= 1\n        #for i in matrix:\n        #    print(i)\n        str_val = str_val[::-1]\n        str1_lis = str1_lis[::-1]\n        str2_lis = str2_lis[::-1]\n        #print(str_val, str1_lis, str2_lis)\n        final_str = str1[:str1_lis[0]] + str2[:str2_lis[0]] + str_val[0]\n        for i in range(1, len(str_val)):\n            final_str += str1[str1_lis[i-1]+1:str1_lis[i]] + str2[str2_lis[i-1]+1:str2_lis[i]] + str_val[i]\n        if(str1_lis[-1] < len_str1-1):\n            final_str += str1[str1_lis[-1]+1:]\n        if(str2_lis[-1] < len_str2-1):\n            final_str += str2[str2_lis[-1]+1:]\n        return final_str", "from functools import lru_cache\nclass Solution:\n    def shortestCommonSupersequence(self, a, b):\n        mem = {}\n        for i in range(len(a)):\n            for j in range(len(b)):\n                if a[i] == b[j]:\n                    mem[(i,j)] = 1 + (mem[(i-1,j-1)] if i-1>=0 and j-1>=0 else i+j)\n                else:\n                    mem[(i,j)] = 1 + min(mem[(i-1,j)] if i - 1 >=0 else j+1, mem[(i,j-1)] if j-1>=0 else i+1)\n                    \n        \n        stack = []\n        i,j = (len(a)-1,len(b)-1)\n        while(not(i == -1 or j == -1)):\n            if a[i] == b[j]:\n                stack.append(a[i])\n                i,j = i-1,j-1\n            else:\n                if (mem[(i-1,j)] if i-1>=0 else j+1) <= (mem[(i,j-1)] if j-1>=0 else i+1):\n                    stack.append(a[i])\n                    i-=1\n                else:\n                    stack.append(b[j])\n                    j-=1\n        if j>=0: stack.append(b[:j+1])\n        if i>=0: stack.append(a[:i+1])\n        return ''.join(stack[::-1])", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        def lcs(A, B):\n            m, n = len(A), len(B)\n            dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]  \n        \n            for i in range(m):\n                for j in range(n):        \n                    if A[i] == B[j]:\n                        dp[i + 1][j + 1] = dp[i][j] + A[i]\n                    else:\n                        dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], key=len)\n            \n            return dp[-1][-1]\n        \n        ans = ''; i = j = 0\n        for x in lcs(str1, str2):\n            while str1[i] != x: ans += str1[i]; i += 1\n            while str2[j] != x: ans += str2[j]; j += 1\n            ans += x; i += 1; j += 1\n        return ans + str1[i:] + str2[j:]", "class Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        m, n = len(s1), len(s2)\n        dp = [[''] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s1[i] == s2[j]:\n                    dp[i][j] = dp[i-1][j-1] + s1[i] if i > 0 and j > 0 else s1[i]\n                else:\n                    if i > 0 and j > 0:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=lambda x:len(x))\n                    elif i > 0:\n                        dp[i][j] = dp[i-1][j]\n                    elif j > 0:\n                        dp[i][j] = dp[i][j-1]\n        res, i, j = '', 0, 0\n        for ch in dp[-1][-1]:\n            while s1[i] != ch:\n                res += s1[i]\n                i += 1\n            while s2[j] != ch:\n                res += s2[j]\n                j += 1\n            res, i, j = res + ch, i + 1, j + 1\n        res += s1[i:] + s2[j:]\n        return res", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        # Step 1. find a longest common subsequence.\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def helper(i, j): # longest common subseq of str1[:i+1] and str2[:j+1]\n            if i < 0 or j < 0:\n                return ''\n            if str1[i]==str2[j]:\n                return helper(i-1, j-1) + str1[i]\n            return max(helper(i-1, j), helper(i, j-1), key=len)\n\n        subseq = helper(len(str1)-1, len(str2)-1)\n        \n        # Step 2. make a supersequences from the longest common subsequence.\n        ans, i, j = '', 0, 0\n        for c in subseq:\n            while str1[i] != c:\n                ans += str1[i]; i += 1\n            while str2[j] != c:\n                ans += str2[j]; j += 1\n            ans += c; i += 1; j += 1\n        return ans + str1[i:] + str2[j:]                \n        \n    def shortestCommonSupersequence_dp(self, str1: str, str2: str) -> str:\n        if not str1: return str2\n        if not str2: return str1\n        l1, l2 = len(str1), len(str2)\n        # Step 1. find a longest common subsequence.\n        dp = [''] * (l1+1)\n        for j in range(l2):\n            new_dp = dp[:]\n            for i in range(l1):\n                if str1[i] == str2[j]:\n                    new_dp[i+1] = dp[i] + str1[i]\n                elif len(dp[i+1]) < len(new_dp[i]):\n                    new_dp[i+1] = new_dp[i]\n            dp = new_dp\n        # Step 2. make a supersequences from the longest common subsequence.\n        ans, i, j = '', 0, 0\n        for c in dp[-1]:\n            while str1[i] != c:\n                ans += str1[i]; i += 1\n            while str2[j] != c:\n                ans += str2[j]; j += 1\n            ans += c; i += 1; j += 1\n        return ans + str1[i:] + str2[j:]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m,n = len(str1),len(str2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for x in range(1,m+1):\n            for y in range(1,n+1):\n                if str1[x-1]==str2[y-1]:\n                    dp[x][y] = 1+dp[x-1][y-1]\n                else:\n                    dp[x][y] = max(dp[x-1][y],dp[x][y-1])\n        i,j = m,n\n        res = ''\n        while(i>0 and j>0):\n            if(str1[i-1]==str2[j-1]):\n                res=str1[i-1]+res\n                i-=1\n                j-=1\n            elif(dp[i-1][j]==dp[i][j]):\n                res = str1[i-1]+res\n                i-=1\n            else:\n                res = str2[j-1]+res\n                j-=1\n        while(i>0):\n            res = str1[i-1]+res\n            i-=1\n        while(j>0):\n            res = str2[j-1]+res\n            j-=1\n        return res", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        len1 = len(str1)\n        len2 = len(str2)\n        d = [[10000] * (len2 + 1) for _ in range(len1 + 1)]\n        d[0][0] = 0\n        for i in range(len1 + 1):\n            for j in range(len2 + 1):\n                if d[i][j] == 10000:\n                    continue\n                if i < len1:\n                    d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1)\n                if j < len2:\n                    d[i][j + 1] = min(d[i][j + 1], d[i][j] + 1)\n                if i < len1 and j < len2 and str1[i] == str2[j]:\n                    d[i + 1][j + 1] = min(d[i + 1][j + 1], d[i][j] + 1)\n        pos1 = len1\n        pos2 = len2\n        ans = []\n        while pos1 or pos2:\n            while pos1 and pos2 and str1[pos1 - 1] == str2[pos2 - 1]:\n                ans.append(str1[pos1 - 1])\n                pos1 -= 1\n                pos2 -= 1\n            while pos1 and d[pos1 - 1][pos2] + 1 == d[pos1][pos2]:\n                ans.append(str1[pos1 - 1])\n                pos1 -= 1\n            while pos2 and d[pos1][pos2 - 1] + 1 == d[pos1][pos2]:\n                ans.append(str2[pos2 - 1])\n                pos2 -= 1\n        ans.reverse()\n        return ''.join(ans)\n\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        size1, size2 = len(str1), len(str2)\n        Inf = str1 + str2\n        dp = [None] * (size2 + 1)\n        dp[0] = ''\n        for i in range(1, size2 + 1):\n            dp[i] = dp[i-1] + str2[i-1]\n        for i1 in range(1, size1 + 1):\n            newDP = [None] * (size2 + 1)\n            newDP[0] = dp[0] + str1[i1-1]\n            for i2 in range(1, size2 + 1):\n                newDP[i2] = Inf\n                if str1[i1-1] == str2[i2-1]:\n                    newDP[i2] = dp[i2-1] + str1[i1-1]\n                newDP[i2] = min(\n                    newDP[i2],\n                    dp[i2] + str1[i1-1],\n                    newDP[i2-1] + str2[i2-1],\n                    key=len)\n            dp = newDP\n        return dp[-1]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        # Step 1. find a longest common subsequence.\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def helper(i, j): # longest common subseq of str1[:i+1] and str2[:j+1]\n            if i == 0:\n                if str1[0] == str2[j]:\n                    return str1[0]\n                elif j == 0:\n                    return ''\n                else:\n                    return helper(i, j-1)\n            if j == 0:\n                if str1[i] == str2[0]:\n                    return str2[0]\n                else:\n                    return helper(i-1, j)\n            # i>0, j>0\n            if str1[i]==str2[j]:\n                return helper(i-1, j-1) + str1[i]\n            else:\n                return max(helper(i-1, j), helper(i, j-1), key=len)\n\n        subseq = helper(len(str1)-1, len(str2)-1)\n        \n        # Step 2. make a supersequences from the longest common subsequence.\n        ans, i, j = '', 0, 0\n        for c in subseq:\n            while i < len(str1) and str1[i] != c:\n                ans += str1[i]; i += 1\n            while j < len(str2) and str2[j] != c:\n                ans += str2[j]; j += 1\n            ans += c; i += 1; j += 1\n        return ans + str1[i:] + str2[j:]                \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n = len(str1)\n        m = len(str2)\n        \n        t = [[0 for j in range(m+1)] for i in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if(str1[i-1]==str2[j-1]):\n                    t[i][j] = t[i-1][j-1] + 1\n                else:\n                    t[i][j] = max(t[i-1][j], t[i][j-1])\n                    \n        s = ''\n        \n        i, j = n, m\n        \n        while(i>0 and j>0):\n            if(str1[i-1]==str2[j-1]):\n                s = s + str1[i-1]\n                i-=1\n                j-=1\n            else:\n                if(t[i-1][j]>t[i][j-1]):\n                    s = s + str1[i-1]\n                    i-=1\n                else:\n                    s = s + str2[j-1]\n                    j-=1\n                    \n        while(i>0):\n            s+=str1[i-1]\n            i-=1\n        while(j>0):\n            s+=str2[j-1]\n            j-=1\n            \n        s = s[::-1]\n        \n        return s\n# class Solution:\n#     def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n#         m,n = len(str1), len(str2)\n#         dp = [[0 for x in range(n+1)] for y in range(m+1)]\n#         for i in range(1,m+1):\n#             for j in range(1,n+1):\n#                 if str1[i-1] == str2[j-1]:\n#                     dp[i][j] = 1+dp[i-1][j-1]\n#                 else:\n#                     dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n#         result = \\\"\\\"\n#         i,j = m,n\n#         while i>0 and j>0:\n#             if str1[i-1] == str2[j-1]:\n#                 result += str1[i-1]\n#                 i -= 1\n#                 j -= 1\n#             else:\n#                 if dp[i][j-1] > dp[i-1][j]:\n#                     result += str2[j-1]\n#                     j -= 1\n#                 elif dp[i-1][j] > dp[i][j-1]:\n#                     result += str1[i-1]\n#                     i -= 1    \n#         while i > 0:\n#             result += str1[i-1]\n#             i -= 1\n#         while j > 0:\n#             result += str2[j-1]\n#             j -= 1\n#         return result[::-1]\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        ## https://www.youtube.com/watch?v=rfV2BJp8YA8 \n        ## find longest common subsequence\n        m = len(str1)\n        n = len(str2)\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = 1+dp[i-1][j-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                    \n        # for i in range(m+1):\n        #     print(dp[i])\n        i = m\n        j = n\n        res = []\n        while i>0 or j>0:\n            if i == 0:\n                res.append(str2[j-1])\n                j -= 1\n            elif j == 0:\n                res.append(str1[i-1])\n                i -= 1\n            elif str1[i-1] == str2[j-1]:\n                res.append(str1[i-1])\n                i -= 1\n                j -= 1\n            elif dp[i][j] == dp[i-1][j]:\n                res.append(str1[i-1])\n                i -= 1\n            else:\n                res.append(str2[j-1])\n                j -= 1\n            # print(res)\n        res.reverse()\n        return ''.join(res)\n                \n        \n    \n    \n# \\\"cba\\\"\n# \\\"abc\\\"\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m = len(str1)\n        n = len(str2)\n        \n        t = str1+str2\n        cur = [ '' for _ in range(n+1)]\n        prev = [ '' for _ in range(n+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i==0:\n                    cur[j]=str2[:j]\n                elif j==0:\n                    cur[j]=str1[:i]\n                else:\n                    a, b = str1[i-1], str2[j-1]\n\n                    if a==b:\n                        cur[j]=prev[j-1]+a\n                    else:\n                        if len(prev[j])<len(cur[j-1]):\n                            cur[j]=prev[j]+a\n                        else:\n                            cur[j]=cur[j-1]+b\n            prev = cur\n            cur = [ '' for _ in range(n+1)]\n            \n                \n        \n        return prev[-1]\n        \n        \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        last_dp = [str2[:j] for j in range(len(str2) + 1)]\n        \n        for i in range(1, len(str1) + 1):\n            dp = [str1[:i]]\n            for j in range(1, len(str2) + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp.append(last_dp[j - 1] + str1[i - 1])\n                else:\n                    if len(last_dp[j]) < len(dp[j - 1]):\n                        dp.append(last_dp[j] + str1[i - 1])\n                    else:\n                        dp.append(dp[j - 1] + str2[j - 1])\n            last_dp = dp\n            \n        return last_dp[-1]\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        table = [[[0, -1] for j in range(len(str2))] for i in range(len(str1))]\n        if str1[0] == str2[0]:\n            table[0][0][0] = 1\n        else:\n            table[0][0][0] = 2\n            table[0][0][1] = 0\n        for j in range(1, len(str2)):\n            if str1[0] == str2[j]:\n                table[0][j][0] = j + 1\n                table[0][j][1] = j - 1\n            else:\n                val1, val2 = j + 1, table[0][j-1][0]\n                if val1 < val2:\n                    table[0][j][0] = val1 + 1\n                    table[0][j][1] = j\n                else:\n                    table[0][j][0] = val2 + 1\n                    table[0][j][1] = j - 1\n        for i in range(1, len(str1)):\n            if str1[i] == str2[0]:\n                table[i][0][0] = i + 1\n            else:\n                val1, val2 = table[i-1][0][0], i + 1\n                if val1 < val2:\n                    table[i][0][0] = val1 + 1\n                    table[i][0][1] = 0\n                else:\n                    table[i][0][0] = i + 2\n            for j in range(1, len(str2)):\n                if str1[i] == str2[j]:\n                    table[i][j][0] = table[i-1][j-1][0] + 1\n                    table[i][j][1] = j - 1\n                else:\n                    val1, val2 = table[i-1][j][0], table[i][j-1][0]\n                    if val1 < val2:\n                        table[i][j][0] = val1 + 1\n                        table[i][j][1] = j\n                    else:\n                        table[i][j][0] = val2 + 1\n                        table[i][j][1] = j - 1\n        # for j in range(len(str2)):\n        #     table[-1][j] += len(str2) - 1 - j        \n        # print(table)\n        result = ''\n        pos1, pos2 = len(str1) - 1, len(str2) - 1\n        while True:\n            if str1[pos1] == str2[pos2]:\n                result = str1[pos1] + result\n                pos1, pos2 = pos1 - 1, table[pos1][pos2][1]\n            else:\n                if table[pos1][pos2][1] == pos2:\n                    result = str1[pos1] + result\n                    pos1 -= 1\n                else:\n                    result = str2[pos2] + result\n                    pos2 = table[pos1][pos2][1]\n            # print(pos1, pos2)  \n            if pos1 < 0 or pos2 < 0:\n                result = str1[0:pos1+1] + str2[0:pos2+1] + result\n                break               \n            \n        return result                ", "class Solution:\n    def shortestCommonSupersequence(self, a: str, b: str) -> str:\n        n, m = len(a), len(b)\n\n        dp = [[-1 for i in range(m + 1)] for j in range(n + 1)]\n        def TD(a, b, n, m):\n            if dp[n][m] != -1:\n                return dp[n][m]\n            if n == 0 or m == 0:\n                return 0\n            if a[n - 1] == b[m - 1]:\n                dp[n][m] = 1 + TD(a, b, n - 1, m - 1)\n                return dp[n][m]\n            dp[n][m] = max(TD(a, b, n - 1, m), TD(a, b, n, m - 1))\n            return dp[n][m]\n        idx = TD(a, b, n, m)\n        lcs = ''\n        i = n\n        j = m\n        while i > 0 and j > 0:\n            if a[i - 1] == b[j - 1]:\n                lcs+=a[i-1]\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j-1]:\n                lcs+=a[i-1]\n                i -= 1\n            else:\n                lcs+=b[j-1]\n                j -= 1\n        while i > 0:\n            lcs += a[i - 1]\n            i -= 1\n        while j > 0:\n            lcs += b[j - 1]\n            j -= 1\n        lcs = lcs[::-1]\n        return lcs", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n1 = len(str1)\n        n2 = len(str2)\n        \n        dp = [['']*(n2+1) for _ in range(n1+1)]\n        for i in range(1,n1+1):\n            for j in range(1,n2+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + str1[i-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1], key=len)\n        lcs = dp[-1][-1]\n        \n        i = j = 0\n        res = ''\n        for ch in lcs:\n            while str1[i] != ch:\n                res += str1[i]\n                i += 1\n            while str2[j] != ch:\n                res += str2[j]\n                j += 1\n            res += ch\n            i+=1\n            j+=1\n        return res+str1[i:]+str2[j:]\n            \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m = len(str1)\n        n = len(str2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            dp[i + 1][0] = dp[i][0] + 1\n            \n        for i in range(n):\n            dp[0][i + 1] = dp[0][i] + 1\n        \n        for i in range(m):\n            for j in range(n):\n                if str1[i] == str2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j]) + 1\n        \n        ans = []\n        \n        i = m\n        j = n\n        while i > 0 or j > 0:\n            if i > 0 and j > 0 and str1[i - 1] == str2[j - 1]:\n                i -= 1\n                j -= 1\n                ans.append(str1[i])\n            elif i > 0 and dp[i][j] == dp[i - 1][j] + 1:\n                i -= 1\n                ans.append(str1[i])\n            elif j > 0 and dp[i][j] == dp[i][j - 1] + 1:\n                j -= 1\n                ans.append(str2[j])\n        return ''.join(ans[::-1])", "from functools import lru_cache\n\nclass Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m, n = len(str1), len(str2)\n        @lru_cache(None)\n        def dfs(i1, i2):\n            if i1 == m or i2 == n:\n                return ''\n            if str1[i1] == str2[i2]:\n                return str1[i1] + dfs(i1 + 1, i2 + 1)\n            x, y = dfs(i1 + 1, i2), dfs(i1, i2 + 1)\n            if len(x) > len(y):\n                return x\n            else:\n                return y\n        \n        res = dfs(0, 0)\n        ans, idx1, idx2 = '', 0, 0\n        for c in res:\n            while idx1 < m and str1[idx1] != c:\n                ans += str1[idx1]\n                idx1 += 1\n            while idx2 < n and str2[idx2] != c:\n                ans += str2[idx2]\n                idx2 += 1\n            ans += c\n            idx1 += 1\n            idx2 += 1\n        ans += str1[idx1:]\n        ans += str2[idx2:]\n        return ans\n        \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n1 = len(str1)\n        n2 = len(str2)\n        \n        dp = [['']*(n2+1) for _ in range(n1+1)]\n        for i in range(1,n1+1):\n            for j in range(1,n2+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + str1[i-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1], key=len)\n        lcs = dp[-1][-1]\n        \n        i = j = 0\n        res = []\n        for ch in lcs:\n            while str1[i] != ch:\n                res.append(str1[i])\n                i += 1\n            while str2[j] != ch:\n                res.append(str2[j])\n                j += 1\n            res.append(ch)\n            i+=1\n            j+=1\n        return ''.join(res)+str1[i:]+str2[j:]\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        d = [[10000] * (len(str2) + 1) for _ in range(len(str1) + 1)]\n        d[0][0] = 0\n        for i in range(len(str1) + 1):\n            for j in range(len(str2) + 1):\n                if d[i][j] == 10000:\n                    continue\n                if i < len(str1):\n                    d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1)\n                if j < len(str2):\n                    d[i][j + 1] = min(d[i][j + 1], d[i][j] + 1)\n                if i < len(str1) and j < len(str2) and str1[i] == str2[j]:\n                    d[i + 1][j + 1] = min(d[i + 1][j + 1], d[i][j] + 1)\n        pos1 = len(str1)\n        pos2 = len(str2)\n        ans = []\n        while pos1 or pos2:\n            if pos1 and d[pos1 - 1][pos2] + 1 == d[pos1][pos2]:\n                ans.append(str1[pos1 - 1])\n                pos1 -= 1\n                continue\n            if pos2 and d[pos1][pos2 - 1] + 1 == d[pos1][pos2]:\n                ans.append(str2[pos2 - 1])\n                pos2 -= 1\n                continue\n            if pos1 and pos2 and str1[pos1 - 1] == str2[pos2 - 1]:\n                ans.append(str1[pos1 - 1])\n                pos1 -= 1\n                pos2 -= 1\n                continue\n        ans.reverse()\n        return ''.join(ans)\n\n\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        \n        def lcs(text1, text2):\n            m = len(text1)\n            n = len(text2)\n            dp = [['']*(n+1) for _ in range(m+1)]\n            for i in range(1, m+1):\n                for j in range(1, n+1):\n                    if text1[i-1]==text2[j-1]:\n                        dp[i][j] = dp[i-1][j-1] + text1[i-1]\n                    else:\n                        dp[i][j] = max(dp[i][j-1], dp[i-1][j], key=lambda x: len(x))\n            return dp[-1][-1]\n        \n        if str1==str2:\n            return str1\n        i = 0\n        j = 0\n        ans = ''\n        for c in lcs(str1, str2):\n            while str1[i]!=c:\n                ans += str1[i]\n                i += 1\n            while str2[j]!=c:\n                ans += str2[j]\n                j += 1\n            ans += c\n            i += 1\n            j += 1\n        return ans + str1[i:] + str2[j:]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n1, n2 = len(str1), len(str2)\n        dp = [[0 for j in range(n2+1)] for i in range(n1+1)]\n        for i in range(1, n1+1):\n            for j in range(1, n2+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        i, j, ans = n1-1, n2-1, ''\n        while i >= 0 and j >= 0:\n            if dp[i+1][j+1] == dp[i][j+1]:\n                ans = str1[i] + ans\n                i -= 1\n            elif dp[i+1][j+1] == dp[i+1][j]:\n                ans = str2[j] + ans\n                j -= 1\n            else:\n                ans = str1[i] + ans\n                i -= 1\n                j -= 1\n        if i < 0:\n            ans = str2[:j+1] + ans\n        else:\n            ans = str1[:i+1] + ans\n        return ans\n            \n            \n        \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        \n        step = defaultdict(lambda : None)\n        \n        @lru_cache(None)\n        def cal(i, j):\n            if i >= len(str1):\n                return len(str2)-j\n            if j >= len(str2):\n                return len(str1)-i\n            \n            if str1[i] == str2[j]:\n                step[(i, j)] = 0\n                return 1 + cal(i+1, j+1)\n            else:\n                a = cal(i+1, j)\n                b = cal(i, j+1)\n                if a < b:\n                    step[(i, j)] = 1\n                    return 1 + a\n                else:\n                    step[(i, j)] = 2\n                    return 1 + b\n        cal(0, 0)\n        \n        ans = []\n        \n        def cons(i, j):\n            nonlocal ans  \n            if i>=len(str1):\n                ans.append(str2[j:])\n                return \n            if j>=len(str2):\n                ans.append(str1[i:])\n                return\n            s = step[(i, j)]\n            if s == 0:\n                ans.append(str1[i])\n                i+=1\n                j+=1\n            elif s == 1:\n                ans.append(str1[i])\n                i+=1\n            else:\n                ans.append(str2[j])\n                j+=1\n            cons(i, j)\n        cons(0, 0)\n        return ''.join(ans)", "class Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        m = {}\n        def fs(a, b):\n            if (a, b) in list(m.keys()):\n                return m[(a, b)]\n            if a == len(s1) or b == len(s2):\n                m[(a, b)] = ''\n                return ''\n            if s1[a] == s2[b]:\n                r = s1[a] + fs(a + 1, b + 1)\n                return r\n            r1 = fs(a + 1, b)\n            r2 = fs(a, b + 1)\n            if len(r1) > len(r2):\n                m[(a, b)] = r1\n            else:\n                m[(a, b)] = r2\n            return m[(a, b)]\n        r = fs(0, 0)\n        res = ''\n        i, j = 0, 0\n        for a in r:\n            while i < len(s1) and s1[i] != a:\n                res += s1[i]\n                i += 1\n            i += 1\n            while j < len(s2) and s2[j] != a:\n                res += s2[j]\n                j += 1\n            j += 1\n            res += a\n        res += s1[i:] + s2[j:]\n        return res\n        \n        \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m = len(str1)\n        n = len(str2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            dp[i + 1][0] = dp[i][0] + 1\n            \n        for i in range(n):\n            dp[0][i + 1] = dp[0][i] + 1\n        \n        for i in range(m):\n            for j in range(n):\n                if str1[i] == str2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j]) + 1\n        \n        ans = []\n        \n        i = m\n        j = n\n        while i > 0 or j > 0:\n            if i > 0 and j > 0 and dp[i][j] == dp[i - 1][j - 1] + 1 and str1[i - 1] == str2[j - 1]:\n                i -= 1\n                j -= 1\n                ans.append(str1[i])\n            elif i > 0 and dp[i][j] == dp[i - 1][j] + 1:\n                i -= 1\n                ans.append(str1[i])\n            elif j > 0 and dp[i][j] == dp[i][j - 1] + 1:\n                j -= 1\n                ans.append(str2[j])\n        return ''.join(ans[::-1])", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m = len(str1)\n        n = len(str2)        \n        dp = [[0 for j in range(n + 1)] for i in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            dp[i][0] = i\n        \n        for j in range(1, n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        \n        ans = ''\n        i, j = m, n\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                ans += str1[i - 1]\n                i -= 1\n                j -= 1\n            elif dp[i][j] == dp[i - 1][j] + 1:\n                ans += str1[i - 1]\n                i -= 1\n            elif dp[i][j] == dp[i][j - 1] + 1:\n                ans += str2[j - 1]\n                j -= 1\n        \n        while i > 0:\n            ans += str1[i - 1]\n            i -= 1\n        \n        while j > 0:\n            ans += str2[j - 1]\n            j -= 1\n        \n        return ans[::-1]\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        if not str1: return str2\n        if not str2: return str1\n        l1, l2 = len(str1), len(str2)\n        # Step 1. find a longest common subsequence.\n        dp = [''] * (l1+1)\n        for j in range(l2):\n            new_dp = dp[:]\n            for i in range(l1):\n                if str1[i] == str2[j]:\n                    new_dp[i+1] = dp[i] + str1[i]\n                elif len(dp[i+1]) < len(new_dp[i]):\n                    new_dp[i+1] = new_dp[i]\n            dp = new_dp\n        # Step 2. make a supersequences from the longest common subsequence.\n        ans, i, j = '', 0, 0\n        for c in dp[-1]:\n            while str1[i] != c:\n                ans += str1[i]; i += 1\n            while str2[j] != c:\n                ans += str2[j]; j += 1\n            ans += c; i += 1; j += 1\n        return ans + str1[i:] + str2[j:]", "class Solution:\n    def shortestCommonSupersequence(self, a: str, b: str) -> str:\n        n=len(a)\n        m=len(b)\n        dp=[['-1']*(n+1) for i in range(m+1)]\n        for i in range(m+1):\n            for j in range(n+1):\n                if(i==0 or j==0):\n                    dp[i][j]=''\n                else:\n                    if(a[j-1]==b[i-1]):\n                        dp[i][j]=a[j-1]+dp[i-1][j-1]\n                    else:\n                        s1=dp[i-1][j]\n                        s2=dp[i][j-1]\n                        if(len(s1)>len(s2)):\n                            dp[i][j]=s1\n                        else:\n                            dp[i][j]=s2\n        s=dp[-1][-1][::-1]\n        result=''\n        I=0\n        J=0\n        for i in s:\n            while(a[I]!=i):\n                result=result+a[I]\n                I=I+1\n            while(b[J]!=i):\n                result=result+b[J]\n                J=J+1\n            result=result+i\n            I=I+1\n            J=J+1\n\n        return(result+a[I:]+b[J:])", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m, n  = len(str1), len(str2)\n        dp = [[''] * (n+1) for _ in range(m+1)]\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + str1[i-1]\n                else:\n                    dp[i][j] = dp[i-1][j] if len(dp[i-1][j]) > len(dp[i][j-1]) else dp[i][j-1]\n                    \n        lcs = dp[-1][-1]\n        \n        res, i, j = '', 0, 0\n        print(lcs)\n        for c in lcs:\n            while str1[i] != c:\n                res += str1[i]\n                i+=1\n            while str2[j] != c:\n                res += str2[j]\n                j+=1\n            res += c\n            i, j = i+1, j+1\n        return res + str1[i:] + str2[j:]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m = len(str1)\n        n = len(str2)\n        DP = [[0 for j in range(n + 1)] for i in range(m + 1)]\n        res = []\n        \n        for i in range(m + 1):\n            DP[i][0] = i\n        for j in range(n + 1):\n            DP[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    DP[i][j] = 1 + DP[i - 1][j - 1]\n                else:\n                    if DP[i - 1][j] < DP[i][j - 1]:\n                        DP[i][j] = 1 + DP[i - 1][j]\n                    else:\n                        DP[i][j] = 1 + DP[i][j - 1]\n        #print(DP[m][n])\n        #build string from DP array\n        i = m\n        j = n\n        res = []\n        while i > 0 or j > 0:\n            if i - 1 >= 0 and j - 1 >= 0 and str1[i - 1] == str2[j - 1]:\n                res.append(str1[i - 1])\n                i -= 1\n                j -= 1\n            else:\n                if DP[i - 1][j] < DP[i][j - 1]:\n                    res.append(str1[i - 1])\n                    i -= 1\n                else:\n                    res.append(str2[j - 1])\n                    j -= 1\n        return ''.join(reversed(res))", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        cache = [[0 for i in range(len(str2)+1)] for j in range(len(str1)+1)]\n        for i in range(1, len(str1)+1):\n            for j in range(1, len(str2)+1):\n                if str1[i-1] == str2[j-1]:\n                    cache[i][j] = 1+cache[i-1][j-1]\n                else:\n                    cache[i][j] = max(cache[i][j-1], cache[i-1][j])\n        print(cache)\n        i,j = len(str1), len(str2)\n        ans = ''\n        while i>0 and j>0:\n            if str1[i-1] == str2[j-1]:\n                ans = str1[i-1] + ans\n                i -= 1\n                j -= 1\n            elif cache[i][j-1] > cache[i-1][j]:\n                ans = str2[j-1] + ans\n                j -= 1\n            else:\n                ans = str1[i-1]+ans\n                i -= 1\n        print(str1, str2, ans, i, j)\n        if i > 0:\n            ans = str1[:i] + ans\n            i -= 1\n        if j > 0:\n            ans = str2[:j] + ans\n            j -= 1\n        return ans", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        \n        #https://leetcode.com/problems/shortest-common-supersequence/discuss/639784/Python-DP-with-detailed-explanation\n        #https://leetcode.com/problems/shortest-common-supersequence/discuss/674175/Python-Very-simple-solution-with-DP-Table-Memory-95\n        \n        m,n = len(str1)+1, len(str2)+1\n        dp = ['']*n\n        for c in range(n):\n            dp[c] = str2[:c]\n        for r in range(1, m):\n            pre = dp[:]    #use pre to store last row's information\n            dp[0] += str1[r-1]\n            for c in range(1, n):\n                if str1[r-1] == str2[c-1]:\n                    dp[c] = pre[c-1]+str1[r-1]\n                else:\n                    if len(pre[c]) < len(dp[c-1]):\n                        dp[c] = pre[c] + str1[r-1]\n                    else:\n                        dp[c] = dp[c-1] + str2[c-1]\n        return dp[-1]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n = len(str1)\n        m = len(str2)\n        \n        dp = [[-1] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                else:\n                    if str1[i - 1] == str2[j - 1]:\n                        dp[i][j] = 1 + dp[i - 1][j - 1]\n                    else:\n                        dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        \n        i = n\n        j = j\n        result = []\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                result.append(str1[i - 1])\n                i -= 1\n                j -= 1\n            else:\n                left = dp[i][j - 1]\n                top = dp[i - 1][j]\n                if left > top:\n                    result.append(str2[j - 1])\n                    j -= 1\n                else:\n                    result.append(str1[i - 1])\n                    i -= 1\n        \n        while i > 0:\n            result.append(str1[i - 1])\n            i -= 1\n        while j > 0:\n            result.append(str2[j - 1])\n            j -= 1\n        \n        result = ''.join(result[::-1])\n        return result\n                \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        str1 = '0' + str1\n        str2 = '0' + str2\n        len_1, len_2 = len(str1), len(str2)\n        \n        dp = [[0] * len_2 for _ in range(len_1)]\n        \n        for i in range(1, len_1):\n            for j in range(1, len_2):\n                if str1[i] == str2[j]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        \n        \n        res = ''\n        m, n = len_1 - 1, len_2 - 1\n        while m > 0 or n > 0:\n            if m == 0:\n                res += str2[n]\n                n -= 1\n            elif n == 0:\n                res += str1[m]\n                m -= 1\n            elif str1[m] == str2[n]:\n                res += str1[m]\n                m -= 1\n                n -= 1\n            elif dp[m-1][n] == dp[m][n]:\n                res += str1[m]\n                m -= 1\n            elif dp[m][n-1] == dp[m][n]:\n                res += str2[n]\n                n -= 1\n        # print(res)\n        return res[::-1]\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n = len(str1)\n        m = len(str2)\n        \n        dp = [[-1] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                else:\n                    if str1[i - 1] == str2[j - 1]:\n                        dp[i][j] = 1 + dp[i - 1][j - 1]\n                    else:\n                        dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        \n        i = n\n        j = m\n        result = []\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                result.append(str1[i - 1])\n                i -= 1\n                j -= 1\n            else:\n                left = dp[i][j - 1]\n                top = dp[i - 1][j]\n                if left > top:\n                    result.append(str2[j - 1])\n                    j -= 1\n                else:\n                    result.append(str1[i - 1])\n                    i -= 1\n        \n        while i > 0:\n            result.append(str1[i - 1])\n            i -= 1\n        while j > 0:\n            result.append(str2[j - 1])\n            j -= 1\n        \n        result = ''.join(result[::-1])\n        return result\n                \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        longest_common_sub = ''\n        str1_len = len(str1)\n        str2_len = len(str2)\n        dp = [[0 for _ in range(str2_len + 1)] for _ in range(str1_len + 1)]\n        for i in range(str1_len + 1):\n            dp[i][0] = i\n        for j in range(str2_len + 1):\n            dp[0][j] = j\n        for i in range(1,str1_len+1):\n            for j in range(1, str2_len+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # reconstruct the array\n        toret = []\n        i = str1_len\n        j = str2_len\n        while i > 0 or j > 0:\n            if i > 0 and j > 0 and str1[i-1] == str2[j-1]:\n                toret.append(str1[i-1])\n                i -= 1\n                j -= 1\n            else:\n                if dp[i-1][j] < dp[i][j-1]:\n                    toret.append(str1[i-1])\n                    i -= 1\n                else:\n                    toret.append(str2[j-1])\n                    j -= 1\n        return ''.join(reversed(toret))\n", "class Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, c in enumerate(s1):\n            for j, d in enumerate(s2):\n                dp[i + 1][j + 1] = 1 + dp[i][j] if c == d else max(dp[i + 1][j], dp[i][j + 1])\n        i, j, stk = m - 1, n - 1, []\n        while i >= 0 and j >= 0:\n            if s1[i] == s2[j]:\n                stk.append(s1[i])\n                i -= 1\n                j -= 1\n            elif dp[i + 1][j] < dp[i][j + 1]:\n                stk.append(s1[i])\n                i -= 1\n            else:\n                stk.append(s2[j])\n                j -= 1    \n        return s1[: i + 1] + s2[: j + 1] + ''.join(reversed(stk))", "class Solution:\n    def shortestCommonSupersequence(self, s: str, t: str) -> str:\n        dp =[[-1 for _ in range(len(t)+1)] for _ in range(len(s)+1)]\n        \n        for i in range(len(s)+1):\n            for j in range(len(t)+1):\n                if i==0 or j==0:\n                    dp[i][j]=0\n                elif s[i-1]==t[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # for i in dp:\n        #     print(i)\n        lcs =''\n        i,j=len(s),len(t)\n        while i>0 and j>0:\n            if s[i-1]==t[j-1]:\n                lcs += s[i-1]\n                i-=1\n                j-=1\n            else:\n                if dp[i][j-1]>dp[i-1][j]:\n                    j-=1\n                    lcs += t[j]\n                else:\n                    i-=1\n                    lcs+=s[i]\n        while i>0:\n            i-=1\n            lcs+=s[i]\n        while j>0:\n            j-=1\n            lcs +=t[j]\n        return lcs[::-1]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        M, N = len(str1), len(str2)\n        \n        dp = [['']*(N+1) for _ in range(M+1)]\n        \n        ## TLE...\n#         for i in range(M):\n#             dp[i+1][0] = str1[:i+1]\n#         for i in range(N):\n#             dp[0][i+1] = str2[:i+1]\n        \n#         for i in range(1, M+1):\n#             for j in range(1, N+1):\n#                 if str1[i-1]==str2[j-1]:\n#                     dp[i][j] = dp[i-1][j-1] + str1[i-1]\n#                 else:\n#                     if len(dp[i][j-1]) < len(dp[i-1][j]):\n#                         dp[i][j] = dp[i][j-1] + str2[j-1]\n#                     else:\n#                         dp[i][j] = dp[i-1][j] + str1[i-1]\n#                     # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        \n#         return dp[M][N]\n        \n        for i in range(1, M+1):\n            for j in range(1, N+1):\n                if str1[i-1]==str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + str1[i-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n        LCS = dp[M][N]\n        \n        res = ''\n        i = j = 0\n        for c in LCS:\n            while str1[i]!=c:\n                res += str1[i]\n                i+=1\n            while str2[j]!=c:\n                res += str2[j]\n                j+=1\n            res += c\n            i+=1\n            j+=1\n        res += str1[i:]\n        res += str2[j:]\n        \n        return res", "class Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        m, n = len(s1), len(s2)\n        dp = [[''] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s1[i] == s2[j]:\n                    dp[i][j] = dp[i-1][j-1] + s1[i] if i > 0 and j > 0 else s1[i]\n                else:\n                    if i > 0 and j > 0:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n                    elif i > 0:\n                        dp[i][j] = dp[i-1][j]\n                    elif j > 0:\n                        dp[i][j] = dp[i][j-1]\n        res, i, j = '', 0, 0\n        for ch in dp[-1][-1]:\n            while s1[i] != ch:\n                res += s1[i]\n                i += 1\n            while s2[j] != ch:\n                res += s2[j]\n                j += 1\n            res, i, j = res + ch, i + 1, j + 1\n        res += s1[i:] + s2[j:]\n        return res", "class Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, c in enumerate(s1):\n            for j, d in enumerate(s2):\n                dp[i + 1][j + 1] = 1 + dp[i][j] if c == d else max(dp[i + 1][j], dp[i][j + 1])\n        i, j, stk = m - 1, n - 1, []\n        while i >= 0 and j >= 0:\n            if s1[i] == s2[j]:\n                stk.append(s1[i])\n                i -= 1\n                j -= 1\n            elif dp[i + 1][j] < dp[i][j + 1]:\n                stk.append(s1[i])\n                i -= 1\n            else:\n                stk.append(s2[j])\n                j -= 1 \n        return s1[: i + 1] + s2[: j + 1] + ''.join(reversed(stk))", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n1, n2 = len(str1), len(str2)\n        def lcs():\n            dp = [[''] * (n2 + 1) for _ in range(n1 + 1)]\n            for i in range(1, n1 + 1):\n                for j in range(1, n2 + 1):\n                    if str1[i-1] == str2[j-1]:\n                        dp[i][j] = dp[i-1][j-1] + str1[i-1]\n                    else:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n            return dp[-1][-1]\n            \n            \n        i = j = 0\n        res = ''\n        for ch in lcs():\n            while i < n1 and str1[i] != ch:\n                res += str1[i]\n                i += 1\n            while j < n2 and str2[j] != ch:\n                res += str2[j]\n                j += 1\n            res += ch\n            i += 1\n            j += 1\n        return res + str1[i:] + str2[j:]\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        \n        \n        @lru_cache(None)\n        def lcs(x, y):\n            \n            m, n = len(x), len(y)\n            \n            dp = [['' for _ in range(n+1)] for _ in range(m+1)]\n            \n            for i in range(1, m+1):\n                for j in range(1, n+1):\n                    if x[i-1] == y[j-1]:\n                        dp[i][j] = dp[i-1][j-1] + x[i-1]\n                    else:\n                        dp[i][j] = max(dp[i][j-1], dp[i-1][j], key=len)\n                        \n            return dp[-1][-1]\n\n            \n        # print(lcs(str1, str2))\n        lcs_ = lcs(str1, str2)\n        \n        \n        i = 0 \n        j = 0\n        res = ''\n        for c in lcs_:\n            while str1[i] != c:\n                res += str1[i]\n                i += 1\n            while str2[j] != c:\n                res += str2[j] \n                j += 1\n                \n            res += c\n            i += 1\n            j += 1\n            \n        # print(res)\n        \n        return res + str1[i:] + str2[j:]\n            \n            \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        # build dp for LCS\n        dp = [[0]*(len(str1)+1) for _ in range(len(str2)+1)]\n        \n        for r in range(1, len(dp)):\n            for c in range(1, len(dp[0])):\n                diag = dp[r-1][c-1]\n                up = dp[r-1][c]\n                left = dp[r][c-1]\n                if str1[c-1] == str2[r-1]:\n                    diag += 1\n                dp[r][c] = max(diag, up, left)\n        \n        # build supersequence by going up the dp grid\n        r = len(str2)\n        c = len(str1)\n        res = []\n        while r > 0 and c > 0:\n            if str1[c-1] == str2[r-1]:\n                res.append(str1[c-1])\n                r -= 1\n                c -= 1\n            else:\n                # move up/left depending on which dp is larger\n                up = dp[r-1][c]\n                left = dp[r][c-1]\n                if up > left:\n                    # move up\n                    res.append(str2[r-1])\n                    r -= 1\n                else:\n                    # move left\n                    res.append(str1[c-1])\n                    c -= 1\n        \n        while r > 0:\n            res.append(str2[r-1])\n            r -= 1\n        \n        while c > 0:\n            res.append(str1[c-1])\n            c -= 1\n        \n        return ''.join(res[::-1])", "class Solution:\n   \n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        if len(str2) > len(str1):\n            str1, str2 = str2, str1\n        if not str1 or not str2:\n            return str1\n        m, n = len(str1), len(str2)\n        dp = [[0] * (m+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if str2[i-1] == str1[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        #print(dp)\n        final_str = ''\n        i, j = n, m\n        c1 = str1[j-1]\n        c2 = str2[i-1]\n        while i > 0 or j > 0:\n            #print(f'{i} {c2} {j} {c1}')\n            if c1 == c2:\n                final_str += c1\n                i -= 1\n                j -= 1\n                c1 = str1[j-1] if j > 0 else ''\n                c2 = str2[i-1] if i > 0 else ''\n            else:\n                if i == 0 or dp[i][j-1] > dp[i-1][j]:\n                    final_str += c1\n                    j -= 1\n                    c1 = str1[j-1] if j > 0 else ''\n                else:\n                    final_str += c2\n                    i -= 1\n                    c2 = str2[i-1] if i > 0 else ''\n        return ''.join(reversed(final_str))\n                    \n\n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m = len(str1)\n        n = len(str2)\n        dp = [[-1]*(n+1) for i in range(m+1)]\n        for i in range(m+1):\n            dp[i][0]=0\n        for j in range(n+1):\n            dp[0][j]=0\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if str1[i-1]==str2[j-1]:\n                    dp[i][j]=1+dp[i-1][j-1]\n                else:\n                    dp[i][j]=max(dp[i-1][j], dp[i][j-1])\n        i = m\n        j = n\n        s = ''\n        while(i>0 and j>0):\n            if str1[i-1]==str2[j-1]:\n                s = s+str1[i-1]\n                i = i-1\n                j = j-1\n            else:\n                if dp[i-1][j]>dp[i][j-1]:\n                    s = s+str1[i-1]\n                    i = i-1\n                else:\n                    s=s+str2[j-1]\n                    j = j-1\n        while(i>0):\n            s = s+str1[i-1]\n            i = i-1\n        while(j>0):\n            s= s+str2[j-1]\n            j = j-1\n        return s[::-1]", "class Solution:\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\n        m, n = len(s1), len(s2)\n        dp = [[''] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s1[i] == s2[j]:\n                    dp[i][j] = dp[i-1][j-1] + s1[i] if i > 0 and j > 0 else s1[i]\n                else:\n                    if i > 0 and j > 0:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n                    elif i > 0:\n                        dp[i][j] = dp[i-1][j]\n                    elif j > 0:\n                        dp[i][j] = dp[i][j-1]\n\n        res, i, j = '', 0, 0\n        for ch in dp[-1][-1]:\n            while i < len(s1) and s1[i] != ch:\n                res += s1[i]\n                i += 1\n            while j < len(s2) and s2[j] != ch:\n                res += s2[j]\n                j += 1\n            res += ch\n            i += 1\n            j += 1\n        res += s1[i:] + s2[j:]\n        return res", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        '''\n        @params: two strings str1 and str2\n        @return: shortest common supersequence\n        '''\n        # Use Dynamic Programming to first compute shortest common subsequence\n        m = len(str1)\n        n = len(str2)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                # Case 1: delete text1[i] in common subsequence\n                deletion = dp[i-1][j]\n                # Case 2: delete text2[j] in common subsequence\n                insertion = dp[i][j-1]\n                # Case 3: match --> common subsequence extend by 1\n                match = dp[i-1][j-1] + 1\n                # Case 4: mistch --> common subsequence keeps the same\n                mismatch = dp[i-1][j-1]\n                \n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = max(deletion, insertion, match)\n                else:\n                    dp[i][j] = max(deletion, insertion, mismatch)\n                    \n        # Backtrack from dp[m][n] to construct shortest common supersequence\n        # in revered order\n        i, j = m, n\n        ans = []\n        \n        while i > 0 or j > 0:\n            # Case 1: str1 is used up\n            if i == 0:\n                ans.append(str2[j-1])\n                j -= 1\n                \n            # Case 2: str2 is used up\n            elif j == 0:\n                ans.append(str1[i-1])\n                i -= 1\n            \n            # Case 3: match\n            elif str1[i-1] == str2[j-1]:\n                ans.append(str1[i-1])\n                i -= 1\n                j -= 1\n                \n            # Case 4: insertion of str1\n            elif dp[i][j] == dp[i-1][j]:\n                ans.append(str1[i-1])\n                i -= 1\n                \n            # Case 5: deletion of str2\n            elif dp[i][j] == dp[i][j-1]:\n                ans.append(str2[j-1])\n                j -= 1\n            \n            #print('i, j: ', i, j)\n            #print(''.join(reversed(ans)))\n        \n        return ''.join(reversed(ans))\n            \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m, n = len(str1), len(str2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        s = []\n        i, j = m, n\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                s.append(str1[i - 1])\n                i -= 1\n                j -= 1\n            elif dp[i][j - 1] > dp[i - 1][j]:\n                s.append(str2[j - 1])\n                j -= 1\n            else:\n                s.append(str1[i - 1])\n                i -= 1\n        while j > 0:\n            s.append(str2[j - 1])\n            j -= 1\n        while i > 0:\n            s.append(str1[i - 1])\n            i -= 1\n        s.reverse()\n        return ''.join(s)", "class Solution:\n    def shortestCommonSupersequence(self, a: str, b: str) -> str:\n        def lcs(a,b):\n            n, m = len(a),len(b)\n            dp = [['' for j in range(m+1)] for i in range(n+1)]\n            for i in range(n):\n                for j in range(m):\n                    if a[i]==b[j]:\n                        dp[i+1][j+1]=dp[i][j]+a[i]\n                    else:\n                        dp[i+1][j+1]=max(dp[i+1][j], dp[i][j+1] , key =len)\n            return dp[-1][-1]\n        res , i ,j = '',0,0\n        for c in lcs(a,b):\n            while a[i]!=c:\n                res+=a[i]\n                i+=1\n            while b[j]!=c:\n                res+=b[j]\n                j+=1\n            res+=c\n            i+=1\n            j+=1\n        res+= a[i:]+b[j:]\n        return res", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m=len(str1)\n        n=len(str2)\n        \n        dp = [[0 for x in range(n+1)] for x in range(m+1)] \n  \n        for i in range(m+1): \n            for j in range(n+1): \n                if i == 0 or j == 0: \n                    dp[i][j] = 0\n                elif str1[i-1] == str2[j-1]: \n                    dp[i][j] = dp[i-1][j-1] + 1\n                else: \n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) \n        s=''\n        i = m\n        j = n\n        while i > 0 and j > 0:\n            if str1[i-1] == str2[j-1]: \n                s += str1[i-1] \n                i-=1\n                j-=1\n  \n            elif dp[i-1][j] > dp[i][j-1]:\n                i-=1\n            else: \n                j-=1\n        res=s[::-1]\n        i,j,st=0,0,0\n        final=''\n        while(i<m and j<n and st<len(res)):\n            if str1[i]!=res[st]:\n                final+=str1[i]\n                i+=1\n            if str2[j]!=res[st]:\n                final+=str2[j]\n                j+=1\n            elif str1[i]==res[st]:\n                final+=res[st]\n                i+=1\n                j+=1\n                st+=1\n        final+=str2[j:]+str1[i:]\n            \n        return final", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        size1, size2 = len(str1), len(str2)\n        dp = [None] * (size2 + 1)\n        dp[0] = ''\n        for i in range(1, size2 + 1):\n            dp[i] = dp[i-1] + str2[i-1]\n        for i1 in range(1, size1 + 1):\n            newDP = [None] * (size2 + 1)\n            newDP[0] = dp[0] + str1[i1-1]\n            for i2 in range(1, size2 + 1):\n                if str1[i1-1] == str2[i2-1]:\n                    newDP[i2] = dp[i2-1] + str1[i1-1]\n                else:\n                    newDP[i2] = min(\n                        dp[i2] + str1[i1-1],\n                        newDP[i2-1] + str2[i2-1],\n                        key=len)\n            dp = newDP\n        return dp[-1]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        size1, size2 = len(str1), len(str2)\n        Inf = str1 + str2\n        dp = [None] * (size2 + 1)\n        dp[0] = ''\n        for i in range(1, size2 + 1):\n            dp[i] = dp[i-1] + str2[i-1]\n        for i1 in range(1, size1 + 1):\n            newDP = [None] * (size2 + 1)\n            newDP[0] = dp[0] + str1[i1-1]\n            for i2 in range(1, size2 + 1):\n                if str1[i1-1] == str2[i2-1]:\n                    newDP[i2] = dp[i2-1] + str1[i1-1]\n                else:\n                    newDP[i2] = min(\n                        dp[i2] + str1[i1-1],\n                        newDP[i2-1] + str2[i2-1],\n                        key=len)\n            dp = newDP\n        return dp[-1]", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m, n = len(str1), len(str2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if str1[i-1]==str2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        \n        i, j = m, n\n        lcs = []\n        \n        while i>0 and j>0:\n            if str1[i-1]==str2[j-1]:\n                lcs.append(str1[i-1])\n                i -= 1\n                j -= 1\n            else:\n                if dp[i-1][j]>dp[i][j-1]:\n                    i -= 1\n                else:\n                    j -= 1\n        \n        lcs.reverse()\n        insert_1 = defaultdict(list)\n        idx = 0\n        \n        for i in range(m):\n            if idx<len(lcs) and str1[i]==lcs[idx]:\n                idx += 1\n            else:\n                insert_1[idx].append(str1[i])\n        \n        insert_2 = defaultdict(list)\n        idx = 0\n        \n        for i in range(n):\n            if idx<len(lcs) and str2[i]==lcs[idx]:\n                idx += 1\n            else:\n                insert_2[idx].append(str2[i])\n\n        ans = ''\n        \n        for i in range(idx):\n            ans += ''.join(insert_1[i])+''.join(insert_2[i])+lcs[i]\n        \n        ans += ''.join(insert_1[idx])+''.join(insert_2[idx])\n        return ans\n            \n", "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m, n = len(str1), len(str2)\n        @lru_cache(None)\n        def dp(i, j):\n            if i == m or j == n:\n                return 0\n            if str1[i] == str2[j]:\n                return 1 + dp(i + 1, j + 1)\n            return max(dp(i + 1, j), dp(i, j + 1))\n        dp(0, 0)\n        i = 0\n        j = 0\n        result = ''\n        while i < m and j < n:\n            if str1[i] == str2[j]:\n                result += str1[i]\n                i += 1\n                j += 1\n            else:\n                s1 = dp(i + 1, j)\n                s2 = dp(i, j + 1)\n                if s1 > s2:\n                    result += str1[i]\n                    i += 1\n                else:\n                    result += str2[j]\n                    j += 1\n        if i < m:\n            result += str1[i:]\n        if j < n:\n            result += str2[j:]\n        return result"]
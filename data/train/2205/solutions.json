["def main():\n    import sys\n    from array import array\n    from collections import deque\n    input = sys.stdin.readline\n\n    H, W, Q = list(map(int, input().split()))\n    grid = array('b', [0] * (H*W))\n    #flg_0 = 0\n    #flg_1 = 0\n    for h in range(H):\n        line = input().rstrip('\\n')\n        \"\"\"\n        if \"0\" in line:\n            flg_0 = 1\n        if \"1\" in line:\n            flg_1 = 1\n        \"\"\"\n        for w in range(W):\n            if line[w] == \"1\":\n                grid[h*W + w] ^= 1\n\n    \"\"\"\n    if flg_0 == 0:\n        for _ in range(Q):\n            print(1)\n        return\n    if flg_1 == 0:\n        for _ in range(Q):\n            print(0)\n        return\n    \"\"\"\n\n    que = deque()\n    start_change = [-1] * (H*W)\n    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for h in range(H):\n        for w in range(W):\n            same = 0\n            hw = h*W+w\n            for dh, dw in d:\n                h_new, w_new = h+dh, w+dw\n                hw_new = h_new * W + w_new\n                if 0 <= h_new < H and 0 <= w_new < W:\n                    if grid[hw] == grid[hw_new]:\n                        same = 1\n                        break\n            if same:\n                que.append(hw)\n                start_change[hw] = 0\n\n    while que:\n        hw = que.popleft()\n        h, w = divmod(hw, W)\n        for dh, dw in d:\n            h_new, w_new = h + dh, w + dw\n            hw_new = h_new * W + w_new\n            if 0 <= h_new < H and 0 <= w_new < W:\n                if start_change[hw_new] == -1:\n                    start_change[hw_new] = start_change[hw] + 1\n                    que.append(hw_new)\n\n    for _ in range(Q):\n        h, w, p = list(map(int, input().split()))\n        h -= 1\n        w -= 1\n        hw = h*W + w\n        if start_change[hw] == -1:\n            print(grid[hw])\n            continue\n        if p <= start_change[hw]:\n            print(grid[hw])\n        else:\n            if (p - start_change[hw]) % 2 == 0:\n                print(grid[hw])\n            else:\n                print(grid[hw] ^ 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\n\nH, W, T = map(int, readline().split())\nG = [-1]*(W+2)\nfor _ in range(H):\n    G.extend([-1] + list(map(int, readline().strip())) + [-1])\nG.extend([-1]*(W+2))\n\ngeta = W+2\nof1 = set()\nDIREC = [1, -1, W+2, -W-2]\nQ = []\n\nfor vn in range((H+2)*(W+2)):\n    if G[vn] == -1:\n        continue\n    for dv in DIREC:\n        if G[vn] == G[vn+dv]:\n            Q.append(vn)\n            break\n\n\nif not Q:\n    for qu in range(T):\n        i, j, p = map(int, readline().split())\n        vn = i*geta+j\n        sys.stdout.write(str(G[vn])+'\\n')\nelse:\n    dist = [0]*((H+2)*(W+2))\n    used = set(Q)\n    Q = deque(Q)\n    while Q:\n        vn = Q.pop()\n        for dv in DIREC:\n            if G[vn+dv] == -1 or vn+dv in used:\n                continue\n            used.add(vn+dv)\n            dist[vn+dv] = 1 + dist[vn]\n            Q.appendleft(vn+dv)\n    for qu in range(T):\n        i, j, p = map(int, readline().split())\n        vn = i*geta+j\n        if dist[vn] >= p:\n            ans = G[vn]\n        else:\n            ans = G[vn]^(1&(p-dist[vn]))\n        sys.stdout.write(str(ans)+'\\n')", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom collections import deque\nH, W, T = list(map(int, input().split()))\nY = [[int(a) for a in input()] for _ in range(H)]\nQ = deque([])\nD = [-1] * (H * W)\nfor x in range(H * W):\n    i, j = x // W, x % W\n    y = Y[i][j]\n    if (i and Y[i-1][j] == y) or (i < H - 1 and Y[i+1][j] == y) or (j and Y[i][j-1] == y) or (j < W - 1 and Y[i][j+1] == y):\n        D[x] = 0\n        Q.append(x)\n\nwhile Q:\n    x = Q.popleft()\n    i, j = x // W, x % W\n    for di, dj in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        ni, nj = i + di, j + dj\n        if 0 <= ni < H and 0 <= nj < W:\n            y = ni * W + nj\n            if D[y] == -1:\n                D[y] = D[x] + 1\n                Q.append(y)\nif D[0] < 0:\n    D = [10 ** 18] * (H * W)\n\nfor _ in range(T):\n    i, j, p = list(map(int, input().split()))\n    i, j = i-1, j-1\n    x = i * W + j\n    print(Y[i][j] if max(p - D[x], 0) % 2 == 0 else Y[i][j] ^ 1)\n"]
["class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        # 1st step\n        # construct a mask for each word\n        # note that there may be duplicate mask for different words\n        # so we need a dict to count the number\n        orda = ord('a') # 97\n        mask = defaultdict(int) # word mask\n        \n        for w in words:\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - orda)\n            mask[m] += 1\n        \n        # 2nd step\n        # for each puzzle, construct the corresponding mask for each possible valid word, check whether the word is in mask\n        res = []\n        for p in puzzles:\n            ones = []\n            # separate current puzzle into ones, 'bdeg' -> 0b1011010 -> [0b10(b), 0b1000(d), 0b10000(e), 0b1000000(g)]\n            for c in p:\n                ones.append(1 << (ord(c) - orda))\n            \n            # generate all valid words for the current puzzle\n            # equivalent to generate all subsets of ones[1:]\n            # reuse code from [78. Subsets]\n            valid = [ones[0]] # valid word must contains the first char of current puzzle\n            for i in range(1,7): # bfs to generate all valid words\n                valid.extend([ones[i] + v for v in valid])\n            \n            # for each valid word, check whether it's in mask\n            novw = 0 # number of valid words for current puzzle\n            for v in valid:\n                if v in mask:\n                    novw += mask[v]\n            res.append(novw)\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        res = []\n        \n        counter = collections.defaultdict(int)\n        \n        for word in words:\n            mask = 0\n            for c in word:\n                mask |= 1 << (ord(c) - ord('a'))\n            \n            counter[mask] += 1\n        \n        for puzzle in puzzles:\n            mask = 0\n            for c in puzzle:\n                mask |= 1 << (ord(c) - ord('a'))\n            \n            first = 1 << (ord(puzzle[0]) - ord('a'))\n            \n            c = 0\n            sub = mask\n            \n            while True:\n                if sub & first == first and sub in counter:\n                    c += counter[sub]\n                \n                if sub == 0:\n                    break\n                    \n                sub = (sub-1)&mask\n            \n            res.append(c)\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        word_profiles = {}\n        letters = \\\"abcdefghijklmnopqrstuvwxyz\\\"\n        for word in words:\n            word_profile = 0\n            for letter in word:\n                word_profile |= 1<<letters.index(letter)\n            if not word_profile in word_profiles:\n                word_profiles[word_profile] = 0\n            word_profiles[word_profile] += 1\n        \n        for puzzle in puzzles:\n            puzzle_profile = 0\n            for letter in puzzle:\n                puzzle_profile |= 1<<letters.index(letter)\n            \n            first_letter = 1<<letters.index(puzzle[0])\n            \n            candidate = puzzle_profile\n            cnt = 0\n            while candidate > 0:\n                if candidate in word_profiles and candidate&first_letter == first_letter:\n                    cnt += word_profiles[candidate]\n                candidate -= 1\n                candidate &= puzzle_profile\n            \n            yield(cnt)", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        ## TLE\n        #bitWords = []\n        #for word in words:\n        #    n = 0  \n        #    for w in word:\n        #        n = n | 1 << (ord(w) - ord('a'))\n        #    bitWords.append(n)\n        #        \n        #result = []\n        #for puzzle in puzzles:\n        #    n = 0  \n        #    f = 0\n        #    for p in puzzle:\n        #        n = n | 1 << (ord(p) - ord('a'))\n        #    f = 1 << (ord(puzzle[0]) - ord('a'))\n        #    cnt = 0\n        #    for i in range(len(bitWords)):\n        #        w = bitWords[i]\n        #        if f & w and not (n & w)^w:\n        #            cnt += 1 \n        #    result.append(cnt) \n        #return result \n        \n        # TLE\n        # \uc911\ubcf5\uc774 \ub9ce\uc774 \uac1c\uc120\ub428\n        count = collections.Counter()\n        for word in words:\n            n = 0  \n            for w in word:\n                n = n | 1 << (ord(w) - ord('a'))\n            count[n] += 1\n                \n        result = []\n        for puzzle in puzzles:\n            bfs = [1 << (ord(puzzle[0]) - 97)]\n            m = 0\n            # \ubaa8\ub4e0 \uc870\ud569 \ucc3e\uae30\n            for p in puzzle[1:]:\n                bfs += [m | 1 << (ord(p) - 97) for m in bfs]\n                \n            # \uacb0\uacfc\n            result.append(sum(count[m] for m in bfs))\n        return result \n    \n        ## 604\n        #count = collections.Counter()\n        #for w in words:\n        #    if len(set(w)) > 7: continue\n        #    m = 0\n        #    for c in w:\n        #        m |= 1 << (ord(c) - 97)\n        #    count[m] += 1\n        #    \n        #res = []\n        #for p in puzzles:\n        #    bfs = [1 << (ord(p[0]) - 97)]\n        #    for c in p[1:]:\n        #        bfs += [m | 1 << (ord(c) - 97) for m in bfs]\n        #        print(bfs)\n        #    res.append(sum(count[m] for m in bfs))\n        #return res\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter()\n        \n        for word in words:\n            m = 0\n            for c in word:\n                m |= 1 << (ord(c) - 97)\n            count[m] += 1\n            \n        res = []\n        for puzzle in puzzles:\n            bfs = [1 << (ord(puzzle[0]) - 97)]\n            \n            for c in puzzle[1:]:\n                bfs += [x | (1 << (ord(c)-97) )for x in bfs]\n                \n            res.append(sum(count[x] for x in bfs))\n            \n        return res", "from collections import defaultdict\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        ans = [0] * len(puzzles)\n        wordSet = {}\n        for i, word in enumerate(words):\n            mask = 0\n            for char in word:\n                mask |= 1 << (ord(char) - ord('a'))\n            wordSet[mask] = wordSet.get(mask, 0)+1\n                    \n        for i in range(len(puzzles)):\n            first = 1 << (ord(puzzles[i][0]) - ord('a'))\n            bitSet = 0\n            for char in puzzles[i]:\n                bitSet |= 1 << (ord(char) - ord('a'))\n            mask = bitSet\n            while True:\n                if first & mask == first:\n                    ans[i] += wordSet.get(mask, 0)\n                if mask == 0:\n                    break\n                \n                mask = (mask-1) & bitSet\n        return ans", "class Solution:\n\\t# Generates a bit mask given a word, where the i-th bit being 1 mean\n\\t# the word contains the i-th letter of the alphabet.\n    def getBitMask(self, word: str) -> int:\n        mask = 0\n        for c in word:\n\\t\\t    # Maps 'a' -> 0, 'b' -> 1, 'c' -> 2, ...\n            i = ord(c) - ord('a')\n\\t\\t\\t# Sets the i-th bit to 1.\n            mask |= 1 << i\n        return mask\n    \n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n\\t    # [2]\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\n\\t\\t# For example 'abd' and 'baddd' would have the same mask because they are composed\n\\t\\t# of the same set of characters.\n        letterFrequencies = {}\n        for word in words:\n            mask = self.getBitMask(word)\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\n        \n        solution = [0] * len(puzzles)\n        \n        for i in range(len(puzzles)):\n            puzzle = puzzles[i]\n            mask = self.getBitMask(puzzle)\n            subMask = mask\n            total = 0\n\\t\\t\\t\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\n\\t\\t\\t# submasks we generate are of valid words.\n            firstBitIndex = ord(puzzle[0]) - ord('a')\n\n\\t\\t\\t# [3]\n            # In this while loop we want to go through all possible \\\"submasks\\\" of the bit\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\n            while True:\n\\t\\t\\t\\t# [4]\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it's a valid word. Here\n\\t\\t\\t\\t# we add to the number of words we've seen with this mask to our total.\n                if (subMask >> firstBitIndex) & 1:\n                    total += letterFrequencies.get(subMask, 0)\n\\t\\t\\t\\t# We've exhausted all possible submasks.\n                if subMask == 0:\n                    break\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\n\\t\\t\\t\\t# originally in the mask. If the original mask was '01011' current submask is '01000',\n\\t\\t\\t\\t# then submask - 1 = '00111' and (submask - 1) & mask = '00011'.\n                subMask = (subMask - 1) & mask\n            solution[i] = total\n        \n        return solution\n                \n        ", "class Solution:\n    # [1]\n\\t# Generates a bit mask given a word, where the i-th bit being 1 mean\n\\t# the word contains the i-th letter of the alphabet.\n\\t# For example the word 'acf' -> 100101 because a, c, f are the 1st, 3rd,\n\\t# and 6th letters of the alphabet, so those corresponding bits are 1.\n    def getBitMask(self, word: str) -> int:\n        mask = 0\n        for c in word:\n\\t\\t    # Maps 'a' -> 0, 'b' -> 1, 'c' -> 2, ...\n            i = ord(c) - ord('a')\n\\t\\t\\t# Sets the i-th bit to 1.\n            mask |= 1 << i\n        return mask\n\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n\\t    # [2]\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\n\\t\\t# For example 'abd' and 'baddd' would have the same mask because they are composed\n\\t\\t# of the same set of characters.\n        letterFrequencies = {}\n        for word in words:\n            mask = self.getBitMask(word)\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\n        \n        solution = [0] * len(puzzles)\n        \n        for i in range(len(puzzles)):\n            puzzle = puzzles[i]\n            mask = self.getBitMask(puzzle)\n            subMask = mask\n            total = 0\n\\t\\t\\t\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\n\\t\\t\\t# submasks we generate are of valid words.\n            firstBitIndex = ord(puzzle[0]) - ord('a')\n\n\\t\\t\\t# [3]\n            # In this while loop we want to go through all possible \\\"submasks\\\" of the bit\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\n            while True:\n\\t\\t\\t\\t# [4]\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it's a valid word. Here\n\\t\\t\\t\\t# we add to the number of words we've seen with this mask to our total.\n                if subMask >> firstBitIndex & 1:\n                    total += letterFrequencies.get(subMask, 0)\n\\t\\t\\t\\t# We've exhausted all possible submasks.\n                if subMask == 0:\n                    break\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\n\\t\\t\\t\\t# originally in the mask. If the original mask was '01011' current submask is '01000',\n\\t\\t\\t\\t# then submask - 1 = '00111' and (submask - 1) & mask = '00011'.\n                subMask = (subMask - 1) & mask\n            solution[i] = total\n        \n        return solution", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:        \n        \n        count=collections.Counter()\n        for w in words:\n            if len(set(w))>7:\n                continue\n            \n            m=0\n            \n            for c in w:\n                m|=(1<<(ord(c)-ord('a')))\n            \n            count[m]+=1\n        \n        res=[]\n        \n        for p in puzzles:\n            bfs=[1<<(ord(p[0])-ord('a'))]\n            \n            for c in p[1:]:\n                bfs+=[m|1<<(ord(c)-ord('a')) for m in bfs ]\n            \n            m=0\n            for i in bfs:\n                m+=count[i]\n            \n            res.append(m)\n        \n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        wdict=defaultdict(int)\n        def getbitmask(word):\n            mask=0\n            for w in word:\n                i=ord(w)-ord('a')\n                mask |= 1 << i\n            return mask\n        \n        op=[0]*len(puzzles)\n        for word in words:\n            mask=getbitmask(word)\n            wdict[mask]+=1\n        \n        for i,pz in enumerate(puzzles):\n            mask=getbitmask(pz)\n            fi=ord(pz[0])-ord('a')\n            submask=mask\n            count=0\n            while submask!=0:\n                if submask>>fi&1:\n                    count+=wdict[submask]\n                submask=(submask-1)&mask\n            op[i]=count\n            \n        return op\n            \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        wdict=defaultdict(int)\n        def getbitmask(word):\n            mask=0\n            for w in word:\n                i=ord(w)-ord('a')\n                mask |= 1 << i\n            return mask\n        \n        op=[0]*len(puzzles)\n        for word in words:\n            mask=getbitmask(word)\n            wdict[mask]+=1\n        \n        for i,pz in enumerate(puzzles):\n            mask=getbitmask(pz)\n            fi=ord(pz[0])-ord('a')\n            submask=mask\n            count=0\n            while True:\n                if submask>>fi&1:\n                    count+=wdict[submask]\n                if submask==0:\n                    break\n                submask=(submask-1)&mask\n            op[i]=count\n            \n        return op\n            \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        res = []\n        \n        count = collections.defaultdict(int)\n        for i, w in enumerate(words):\n            mask = 0\n            for x in w:\n                mask |= 1 << (ord(x) - ord('a'))\n            count[mask] += 1\n            \n        for i, p in enumerate(puzzles):\n            mask = 0\n            for x in p:\n                mask |= 1 << (ord(x) - ord('a'))\n            \n            first = 1 << ord(puzzles[i][0]) - ord('a')\n            \n            c = 0\n            sub = mask\n            while True:\n                if sub & first == first and sub in count:\n                    c += count[sub]\n                \n                if sub == 0:\n                    break\n                \n                sub = (sub-1)&mask\n            res.append(c)\n        \n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter()\n        for w in words:\n            if len(set(w)) > 7: continue\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - 97)\n            count[m] += 1\n        res = []\n        for p in puzzles:\n            bfs = [1 << (ord(p[0]) - 97)]\n            for c in p[1:]:\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\n            res.append(sum(count[m] for m in bfs))\n        return res", "\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            subs = [p[0]]\n            for c in p[1:]:\n                subs += [s + c for s in subs]\n            res.append(sum(count[frozenset(s)] for s in subs))\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        wordMap = {}\n        for word in words:\n            encode = 0\n            for char in word:\n                encode |= 1<<(ord(char)-ord(\\\"a\\\"))\n            wordMap[encode] = wordMap.get(encode, 0)+1\n            \n        \n        wordCount = []\n        for puzzle in puzzles:\n            mask = 0\n            for char in puzzle:\n                mask |= 1<<(ord(char)-ord(\\\"a\\\"))\n                \n            substring = mask\n\n            first = 1<<ord(puzzle[0])-ord(\\\"a\\\")\n            count = 0\n            while substring:\n                if (first&substring)==first and substring in wordMap:\n                    count += wordMap[substring]\n                    \n                substring = (substring-1)&mask\n                \n            wordCount.append(count)\n            \n        return wordCount\n                    \n                \n                \n            \n            \n                                ", "class Solution(object):\n    def findNumOfValidWords(self, words, puzzles):\n        def get_bit(word):\n            x=0\n            for ch in (word):\n                x|=1<<(ord(ch)-ord('a'))\n            return x\n        bitdic=collections.defaultdict(int)\n        words=[set(list(x)) for x in words]\n        for word in words:\n            bitdic[get_bit(word)]+=1\n        res=[]\n        for puzzle in puzzles:\n            count=0\n            first=puzzle[0]\n            bfs=[1<<(ord(first)-ord('a'))]\n            for ch in set(puzzle[1:]):\n                bfs+=[x|1<<(ord(ch)-ord('a')) for x in bfs]\n            res.append(sum(bitdic[x] for x in set(bfs)))\n        return res\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            subs = [p[0]]\n            for c in p[1:]:\n                subs += [s + c for s in subs]\n            res.append(sum(count[frozenset(s)] for s in subs))\n        return res\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        ans = []\n        count = collections.Counter(frozenset(w) for w in words)\n        for p in puzzles:\n            subs = [p[0]]\n            for c in p[1:]:\n                subs += [s + c for s in subs]\n            ans.append(sum(count[frozenset(s)] for s in subs))\n        return ans", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        res = []\n        cnt = collections.Counter(''.join(sorted(set(w))) for w in words)\n        for p in puzzles:\n            bfs = [p[0]]\n            for c in p[1:]:\n                bfs += [s + c for s in bfs]\n            res.append(sum(cnt[''.join(sorted(s))] for s in bfs))\n        return res  \n        \n#         wordCounter = defaultdict(int)\n#         chars = \\\"abcdefghijklmnopqrstuvwxyz\\\"\n#         shiftDict = {chars[i]: (1<<(ord(chars[i]) - 97)) for i in range(26)}\n#         wordCounter1 = Counter(\\\"\\\".join(sorted(set(word))) for word in words)\n        \n#         for word in wordCounter1:\n#             mask = 0\n#             for char in word:\n#                 mask |= shiftDict[char]\n#             wordCounter[mask] += wordCounter1[word]\n        \n#         ans = []\n#         maxMask = (1<<26)-1\n#         dp = {}\n#         for puzzle in puzzles:\n#             pMask = 0\n#             for char in set(puzzle):\n#                 pMask |= shiftDict[char]\n#             pMask ^= maxMask\n#             subAns = 0\n#             if (pMask, puzzle[0]) in dp:\n#                 ans.append(dp[(pMask, puzzle[0])])\n#             else:\n#                 for wMask in wordCounter:\n#                     if wMask & shiftDict[char] and (wMask & pMask == 0):\n#                         subAns += wordCounter[wMask]\n#                 dp[(pMask, puzzle[0])] = subAns\n#                 ans.append(subAns)\n#         return ans\n        \n        # charSetDict = defaultdict(set)\n        # wordSubSetDict = {}\n        # for word in words:\n        #     wordSubSetDict[word] = set(word)\n        #     for char in word:\n        #         charSetDict[char].add(word)\n        # ans = []\n        # for puzzle in puzzles:\n        #     subAns = 0\n        #     pCharSet = set(puzzle)\n        #     for word in charSetDict[puzzle[0]]:\n        #         if wordSubSetDict[word].issubset(pCharSet):\n        #             subAns += 1\n        #     ans.append(subAns)\n        # return ans\n", "import numpy\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        res = []\n        cnt = collections.Counter(''.join(sorted(set(w))) for w in words)\n        for p in puzzles:\n            bfs = [p[0]]\n            for c in p[1:]:\n                bfs += [s + c for s in bfs]\n            res.append(sum(cnt[''.join(sorted(s))] for s in bfs))\n        return res", "class Solution:\n    wdMap = {}\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        res = []\n        self.wdMap = self.hashwords(words)\n        for puzzle in puzzles:\n            res.append(self.checkValidWord(puzzle, 0, 0))\n\n        return res\n\n    def checkValidWord(self, puzzle, i, id):\n        if i == len(puzzle):\n            return self.wdMap.get(id , 0)\n        indx = ord(puzzle[i]) - ord('a')\n        nextid = id | (1<<indx)\n        if i == 0:\n            return self.checkValidWord(puzzle, i + 1, nextid)\n        else:\n            return self.checkValidWord(puzzle, i + 1, id) + self.checkValidWord(puzzle, i+1, nextid)\n\n\n    def hashwords(self, words):\n        wdMap = {}\n        for word in words:\n            letter_id = 0\n            for letter in word:\n                indx = ord(letter) - ord('a')\n                letter_id = letter_id | (1 << indx)\n            wdMap[letter_id] = wdMap.get(letter_id, 0) + 1\n        return wdMap\n", "class Solution:\n    \n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        # 97 = ord('a')\n        \n        def wordToInt(word: str) -> int:\n            n  = 0\n            ls = 0\n            for c in word:\n                cn = 1 << (ord(c) - 97)\n                ls += 1 if cn & n == 0 else 0\n                if ls > 7:\n                    return None\n                n |= cn\n            return n\n        \n        def validWords(ws, puzzle: str) -> int:\n            return sum( (ws[n] if n in ws else 0) for n in getPossibleNums(puzzle, 0) ) \n        \n        def getPossibleNums(puzzle: str, i: int) -> List[int]:\n            cn = 1 << (ord(puzzle[i]) - 97)\n            if i == len(puzzle) - 1:\n                return [cn, 0]\n            elif i == 0:\n                return [ n | cn for n in getPossibleNums(puzzle, 1) ]\n            else:\n                tmp = getPossibleNums(puzzle, i+1)\n                return [ n | cn for n in tmp ] + tmp\n        \n        ws = {}\n        for w in words:\n            n = wordToInt(w)\n            if n is not None:\n                ws[n] = 1 + (ws[n] if n in ws else 0)\n            \n        return list(map(lambda p: validWords(ws, p), puzzles))", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        words = [frozenset(word) for word in words if len(set(word)) <= 7]\n        counter = Counter(words)\n        res = []\n        for p in puzzles:\n            pre = (p[0],)\n            t = set(p[1:])\n            tmp = 0\n            for i in range(len(t) + 1):\n                for c in itertools.combinations(t, i):\n                    tmp += counter[frozenset(pre + c)]\n            res += [tmp]\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            cur = 0\n            for k in range(7):\n                for c in itertools.combinations(p[1:], k):\n                    cur += count[frozenset(tuple(p[0]) + c)]\n            res.append(cur)\n        return res\n\n    def findNumOfValidWords2(self, words, puzzles):\n        count = collections.Counter()\n        for w in words:\n            if len(set(w)) > 7: continue\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - 97)\n            count[m] += 1\n        res = []\n        for p in puzzles:\n            bfs = [1 << (ord(p[0]) - 97)]\n            for c in p[1:]:\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\n            res.append(sum(count[m] for m in bfs))\n        return res\n    \n    def getBitMask(self, word: str) -> int:\n        mask = 0\n        for c in word:\n\\t\\t    # Maps 'a' -> 0, 'b' -> 1, 'c' -> 2, ...\n            i = ord(c) - ord('a')\n\\t\\t\\t# Sets the i-th bit to 1.\n            mask |= 1 << i\n        return mask\n\n    def findNumOfValidWords1(self, words: List[str], puzzles: List[str]) -> List[int]:\n\\t    # [2]\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\n\\t\\t# For example 'abd' and 'baddd' would have the same mask because they are composed\n\\t\\t# of the same set of characters.\n        letterFrequencies = {}\n        for word in words:\n            mask = self.getBitMask(word)\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\n        \n        solution = [0] * len(puzzles)\n        \n        for i in range(len(puzzles)):\n            puzzle = puzzles[i]\n            mask = self.getBitMask(puzzle)\n            subMask = mask\n            total = 0\n\\t\\t\\t\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\n\\t\\t\\t# submasks we generate are of valid words.\n            firstBitIndex = ord(puzzle[0]) - ord('a')\n\n\\t\\t\\t# [3]\n            # In this while loop we want to go through all possible \\\"submasks\\\" of the bit\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\n            while True:\n\\t\\t\\t\\t# [4]\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it's a valid word. Here\n\\t\\t\\t\\t# we add to the number of words we've seen with this mask to our total.\n                if subMask >> firstBitIndex & 1:\n                    total += letterFrequencies.get(subMask, 0)\n\\t\\t\\t\\t# We've exhausted all possible submasks.\n                if subMask == 0:\n                    break\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\n\\t\\t\\t\\t# originally in the mask. If the original mask was '01011' current submask is '01000',\n\\t\\t\\t\\t# then submask - 1 = '00111' and (submask - 1) & mask = '00011'.\n                subMask = (subMask - 1) & mask\n            solution[i] = total\n        \n        return solution", "from collections import defaultdict\n\nclass Solution:\n    def getBitRepr(word):\n        \\\"\\\"\\\"\n        >>> Solution.getBitRepr('abc')\n        7\n        \\\"\\\"\\\"\n        result = 0\n        for char in word:\n            result |= (1 << (ord(char) - ord('a')))\n        return result\n\n    def countCanonicalWords(words):\n        \\\"\\\"\\\"\n        >>> Solution.countCanonicalWords(['abc', 'bca'])\n        {7: 2}\n        \\\"\\\"\\\"\n        countMap = defaultdict(int)\n        for word in words:\n            bitMask = Solution.getBitRepr(word)\n            countMap[bitMask] += 1\n        return countMap\n\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        canonicalWordCount = Solution.countCanonicalWords(words)\n        puzzlesMasks = [Solution.getBitRepr(x) for x in puzzles]\n        result = []\n\n        for i, puzzleBitMask in enumerate(puzzlesMasks):\n            matchCount = 0\n            candidateWordMask = puzzleBitMask\n            firstCharMask = Solution.getBitRepr(puzzles[i][0])\n            while candidateWordMask != 0:\n                if (candidateWordMask & firstCharMask != 0):\n                   matchCount += canonicalWordCount[candidateWordMask]\n                candidateWordMask = (candidateWordMask - 1) & puzzleBitMask\n            result.append(matchCount)\n        return result", "class Solution:\n    def findNumOfValidWords(self, words, puzzles):\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            cur = 0\n            for k in range(7):\n                for c in itertools.combinations(p[1:], k):\n                    # print(c)\n                    cur += count[frozenset(tuple(p[0]) + c)]\n            res.append(cur)\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        #the output list\n        res = [0] * len(puzzles)\n        \n        #set up the trie using dictionary\n        dic = {}\n        for word in words:\n            cur = dic\n            for letter in sorted(set(word)):\n                if letter not in cur:\n                    cur[letter] = {}\n                cur = cur[letter]\n            # if only this word contains all the letters along the branch\n            if '*' not in cur:\n                cur['*'] = 1\n                \n            # if there exists other words that contain all the \n            # letters along the branch\n            else:\n                cur['*'] += 1\n        \n        # search the trie using depth first search;\n        # check_head checks whether the first letter of puzzle is in the word\n        def dfs(dic, i, check_head):\n            p = puzzles[i]\n            if '*' in dic and check_head:\n                # add the number of words that meet the specification to the                        \n\\t\\t\\t\\t# corresponding position of puzzle\n                res[i] += dic['*']\n            for key in dic:\n                if key in p:\n                    if p[0] == key or check_head:\n                        dfs(dic[key], i, True)\n                    else:\n                        dfs(dic[key], i, False)\n            else:\n                return\n        \n        # run dfs for all puzzles\n        for i in range(len(puzzles)):\n            dfs(dic, i, False)\n        \n        \n        # return result\n        return res ", "class Solution:\n    def conv(self, c):\n        return ord(c) - ord('a')\n    \n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        first_letters = {chr(c): set([]) for c in range(ord('a'), ord('z') + 1)} # maps chars to set of words containing the char\n        word_masks = {} # maps bitmask of word to its index\n        for i, w in enumerate(words):\n            mask = 0\n            for c in w:\n                first_letters[c].add(i)\n                mask = (1 << self.conv(c)) | mask\n            if mask not in word_masks:\n                word_masks[mask] = []\n            word_masks[mask].append(i)\n        puzzle_masks = []\n        for p in puzzles:\n            mask = 0\n            for c in p:\n                mask = (1 << self.conv(c)) | mask\n            puzzle_masks.append(mask)\n        \n        answer = []\n        for i, m in enumerate(puzzle_masks):\n            s = m\n            total = 0\n            while s != 0:\n                if s in word_masks:\n                    for w in word_masks[s]:\n                        if w in first_letters[puzzles[i][0]]:\n                            total += 1\n                s = (s - 1) & m\n            answer.append(total)\n        \n        return answer", "import collections\nimport itertools\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        answer = [0] * len(puzzles)\n        count = collections.Counter([frozenset(word) for word in words if len(set(word)) <= 7])\n        \n        for i, p in enumerate(puzzles):\n            answer[i] = sum([count[frozenset(p[0] + \\\"\\\".join(s))]  for j in range(0, len(p)) for s in itertools.combinations(p[1:], j)])\n            \n        return answer", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        wordPatternCnt = collections.defaultdict(int)\n        \n        for word in words:\n            pattern = 0\n            for letter in word:\n                pattern |= (1 << ord(letter) - ord(\\\"a\\\"))\n            wordPatternCnt[pattern] += 1\n        \n        res = []\n        \n        for puzzle in puzzles:\n            cnt = 0\n            pattern = 0\n            for letter in puzzle:\n                pattern |= (1 << (ord(letter) - ord(\\\"a\\\")))\n                \n            subPattern = pattern\n                \n            while subPattern > 0:\n                if subPattern & (1 << (ord(puzzle[0]) - ord(\\\"a\\\"))):\n                    cnt += wordPatternCnt[subPattern]\n                subPattern = pattern & (subPattern - 1)\n            \n            res.append(cnt)\n        \n        return res\n                ", "import collections\nimport itertools\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        answer = [0] * len(puzzles)\n        count = collections.Counter([frozenset(word) for word in words if len(set(word)) <= 7])\n        \n        for i, p in enumerate(puzzles):\n            answer[i] = sum([count[frozenset(p[0] + \\\"\\\".join(s))]  for j in range(len(p)) for s in itertools.combinations(p[1:], j)])\n            \n        return answer", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        def getNum(s: str) -> int:\n            res = 0\n            for c in s:\n                res |= (1 << (ord(c) - 97))\n            return res\n        \n        counter = Counter([getNum(set(word)) for word in words if len(set(word)) < 8])\n        ans = []\n        dic = dict()\n        for puzzle in puzzles:\n            sub = [(1 << (ord(puzzle[0]) - 97))]\n            for c in puzzle[1:]:\n                sub += [m | (1 << (ord(c) - 97)) for m in sub]\n            ans.append(sum(counter[w] for w in sub))\n            \n        return ans", "\nfrom collections import Counter, deque\n\n\ndef make_bitmask(s):\n    val = 0x0000\n    for si in s:\n        val |= (1 << ord(si) - ord('a'))\n    return val\n\n\ndef is_submask(maskA, maskB):\n    return maskA == (maskA & maskB)\n\n\ndef debug(n):\n    s = \\\"\\\"\n    for i in range(26):\n        if (1 << i) & n:\n            s += chr(i + ord('a'))\n    return s\n\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        counts = Counter(map(make_bitmask, words))\n        \n        ret = [0 for _ in range(len(puzzles))]\n        for i, p in enumerate(puzzles):\n            queue = deque([(make_bitmask(p[0]), 1)])\n            val = 0\n            seen = set()\n            while queue:\n                n, depth = queue.popleft()\n                if n not in seen:\n                    val += counts[n]\n                    seen.add(n)\n                while depth < len(p):\n                    queue.append((n | make_bitmask(p[depth]), depth + 1))\n                    depth += 1\n            ret[i] = val\n        return ret", "from itertools import combinations\nfrom collections import defaultdict\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n            wordmap = defaultdict(int)\n            for word in words:\n                mask = 0\n                for c in word:\n                    mask = mask | (1<<(ord(c)-ord('a')))\n                wordmap[mask] += 1\n            ans = [0 for i in range(len(puzzles))]\n            for i, p in enumerate(puzzles):\n                starting_letter = p[0]\n                for k in range(0, len(p[1:])+1):\n                    for comb in combinations(p[1:], k):\n                        mask = 1<<(ord(starting_letter)-  ord('a'))\n                        for c in comb:\n                            mask = mask | (1<<(ord(c)-ord('a')))\n                        ans[i] += wordmap[mask]\n            return ans", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        counter = {}\n        for word in words:\n            mask = self.to_int(word)\n            if mask not in counter:\n                counter[mask] = 0\n            counter[mask] += 1\n                \n        output = []\n        for puzzle in puzzles:\n            output.append(0)\n            sub_strings = ['']\n            mask = self.to_int(puzzle[1:])\n            for c in puzzle[1:]:\n                for sub_string in list(sub_strings):\n                    sub_strings.append(sub_string+c)\n            for sub_string in list(sub_strings):\n                mask = self.to_int(puzzle[0] + sub_string)\n                output[-1] += counter.get(mask, 0)\n            \n        return output\n    \n    def to_int(self, word):\n        mask = 0\n        for ch in word:\n            mask |= 1 << (ord(ch) - 97)\n        return mask\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        #the output list\n        res = [0] * len(puzzles)\n        \n        #set up the trie using dictionary\n        dic = {}\n        for word in words:\n            cur = dic\n            for letter in sorted(set(word)):\n                if letter not in cur:\n                    cur[letter] = {}\n                cur = cur[letter]\n            # if only this word contains all the letters along the branch\n            if '*' not in cur:\n                cur['*'] = 1\n                \n            # if there exists other words that contain all the \n            # letters along the branch\n            else:\n                cur['*'] += 1\n        \n        # search the trie using depth first search;\n        # check_head checks whether the first letter of puzzle is in the word\n        def dfs(dic, i, check_head):\n            p = puzzles[i]\n            if '*' in dic and check_head:\n                # add the number of words that meet the specification to the                        \n\\t\\t\\t\\t# corresponding position of puzzle\n                res[i] += dic['*']\n            for key in dic:\n                if key in p:\n                    if p[0] == key or check_head:\n                        dfs(dic[key], i, True)\n                    else:\n                        dfs(dic[key], i, False)\n            else:\n                return\n        \n        # run dfs for all puzzles\n        for i in range(len(puzzles)):\n            dfs(dic, i, False)\n        \n        \n        # return result\n        return res     ", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        trie = {}\n        result = [0 for _ in range(len(puzzles))]\n        \n        def dfs(puzzle, i, trie, hasFirst=False):        \n            if \\\"*\\\" in trie and hasFirst:\n                result[i] += trie[\\\"*\\\"]\n                        \n            for c in puzzle:\n                if c in trie:\n                    dfs(puzzle, i, trie[c], hasFirst or c == puzzle[0])\n                            \n        for w in words:\n            curr = trie\n            for c in sorted(set(w)):\n                curr = curr.setdefault(c, {})\n                    \n                # curr = curr[c]\n            \n            if \\\"*\\\" in curr:\n                curr[\\\"*\\\"] += 1\n            else:\n                curr[\\\"*\\\"] = 1\n            \n        print(curr)\n            \n        for i, p in enumerate(puzzles):\n            dfs(p, i, trie)\n            \n        return result\n", "# 1178. Number of Valid Words for Each Puzzle\n# version 2. backwards.\n\ndef gist (word):\n    ans = 0\n    for ch in word:\n        ans |= (1 << (ord (ch) - ord ('a')))\n    return ans\n\ndef subsets (arr, start=0, progress=0):\n    if start == len (arr):\n        yield progress\n    else:\n        yield from subsets (arr, start+1, progress | arr[start])\n        yield from subsets (arr, start+1, progress)\n\ndef head_subsets (puzzle):\n    bits = [gist (ch) for ch in puzzle]\n    for mask in subsets (bits[1:]):\n        yield mask | bits[0]\n\ndef count_solutions (words, puzzles):\n    gist_count = {}\n    for word in words:\n        g = gist (word)\n        gist_count.setdefault (g, 0)\n        gist_count[g] += 1\n\n    ans = []\n    for puzzle in puzzles:\n        count = sum (gist_count.get (g, 0) for g in head_subsets (puzzle))\n        ans.append (count)\n\n    return ans\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        return count_solutions(words, puzzles)", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        cc = collections.Counter()\n        for w in words:\n            cc[tuple(sorted(set(list(w))))] += 1\n        \n        res = []\n        for pzl in puzzles:\n            possible_sets = [set([pzl[0]])]\n            for i in range(1, 7):\n                possible_sets.extend([st.union([pzl[i]]) for st in possible_sets])\n            nvalid = sum(cc[tuple(sorted(st))] for st in possible_sets)\n            res.append(nvalid)\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        res = []\n        cnt = collections.Counter(''.join(sorted(set(w))) for w in words)\n        for p in puzzles:\n            bfs = [p[0]]\n            for c in p[1:]:\n                bfs += [s + c for s in bfs]\n            res.append(sum(cnt[''.join(sorted(s))] for s in bfs))\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        trie = {}\n        # trie = defaultdict(dict)\n    \n        result = [0 for _ in range(len(puzzles))]\n                    \n        def dfs(puzzle, i, trie, hasFirst=False):        \n            if \\\"*\\\" in trie and hasFirst:\n                result[i] += trie[\\\"*\\\"]\n                        \n            val = 0\n                    \n            for c in puzzle:\n                if c in trie:\n                    dfs(puzzle, i, trie[c], hasFirst or c == puzzle[0])\n                            \n        for w in words:\n            curr = trie\n            for c in sorted(set(w)):\n                curr = curr.setdefault(c, {})\n                \n                # curr = curr.setdefault(c, defaultdict(int))\n              \n            if \\\"*\\\" not in curr:\n                curr[\\\"*\\\"] = 0\n            curr[\\\"*\\\"] += 1\n            \n            # if \\\"*\\\" in curr:\n            #     curr[\\\"*\\\"] += 1\n            # else:\n            #     curr[\\\"*\\\"] = 1\n            \n        for i, p in enumerate(puzzles):\n            dfs(p, i, trie)\n            \n        return result", "class Solution:\n    # [1]\n\\t# Generates a bit mask given a word, where the i-th bit being 1 mean\n\\t# the word contains the i-th letter of the alphabet.\n\\t# For example the word 'acf' -> 100101 because a, c, f are the 1st, 3rd,\n\\t# and 6th letters of the alphabet, so those corresponding bits are 1.\n    def getBitMask(self, word: str) -> int:\n        mask = 0\n        for c in word:\n\\t\\t    # Maps 'a' -> 0, 'b' -> 1, 'c' -> 2, ...\n            i = ord(c) - ord('a')\n\\t\\t\\t# Sets the i-th bit to 1.\n            mask |= 1 << i\n        return mask\n\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n\\t    # [2]\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\n\\t\\t# For example 'abd' and 'baddd' would have the same mask because they are composed\n\\t\\t# of the same set of characters.\n        letterFrequencies = {}\n        for word in words:\n            mask = self.getBitMask(word)\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\n        \n        solution = [0] * len(puzzles)\n        \n        for i in range(len(puzzles)):\n            puzzle = puzzles[i]\n            mask = self.getBitMask(puzzle)\n            subMask = mask\n            total = 0\n\\t\\t\\t\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\n\\t\\t\\t# submasks we generate are of valid words.\n            firstBitIndex = ord(puzzle[0]) - ord('a')\n\n\\t\\t\\t# [3]\n            # In this while loop we want to go through all possible \\\"submasks\\\" of the bit\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\n            while True:\n\\t\\t\\t\\t# [4]\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it's a valid word. Here\n\\t\\t\\t\\t# we add to the number of words we've seen with this mask to our total.\n                if subMask >> firstBitIndex & 1:\n                    total += letterFrequencies.get(subMask, 0)\n\\t\\t\\t\\t# We've exhausted all possible submasks.\n                if subMask == 0:\n                    break\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\n\\t\\t\\t\\t# originally in the mask. If the original mask was '01011' current submask is '01000',\n\\t\\t\\t\\t# then submask - 1 = '00111' and (submask - 1) & mask = '00011'.\n                subMask = (subMask - 1) & mask\n            solution[i] = total\n        \n        return solution\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        trie = {}\n        result = [0 for _ in range(len(puzzles))]\n        \n        def dfs(puzzle, i, trie, hasFirst=False):        \n            if \\\"*\\\" in trie and hasFirst:\n                result[i] += trie[\\\"*\\\"]\n                        \n            for c in puzzle:\n                if c in trie:\n                    dfs(puzzle, i, trie[c], hasFirst or c == puzzle[0])\n                            \n        for w in words:\n            curr = trie\n            for c in sorted(set(w)):\n                curr = curr.setdefault(c, {})\n                    \n                # curr = curr[c]\n            \n            if \\\"*\\\" in curr:\n                curr[\\\"*\\\"] += 1\n            else:\n                curr[\\\"*\\\"] = 1\n            \n        print(curr)\n            \n        for i, p in enumerate(puzzles):\n            dfs(p, i, trie)\n            \n        return result", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        trie = {}\n        # trie = defaultdict(dict)\n    \n        result = [0 for _ in range(len(puzzles))]\n                    \n        def dfs(puzzle, i, trie, hasFirst=False):        \n            if \\\"*\\\" in trie and hasFirst:\n                result[i] += trie[\\\"*\\\"]\n                        \n            val = 0\n                    \n            for c in puzzle:\n                if c in trie:\n                    dfs(puzzle, i, trie[c], hasFirst or c == puzzle[0])\n                            \n        for w in words:\n            curr = trie\n            for c in sorted(set(w)):\n                curr = curr.setdefault(c, {})\n                \n                # curr = curr.setdefault(c, defaultdict(int))\n              \n            # if \\\"*\\\" not in curr:\n            #     curr[\\\"*\\\"] = 0\n            # curr[\\\"*\\\"] += 1\n            \n            if \\\"*\\\" in curr:\n                curr[\\\"*\\\"] += 1\n            else:\n                curr[\\\"*\\\"] = 1\n            \n        for i, p in enumerate(puzzles):\n            dfs(p, i, trie)\n            \n        return result", "class Solution:\n    def findNumOfValidWords(self, words, puzzles):\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            cur = 0\n            for k in range(7):\n                for c in itertools.combinations(p[1:], k):\n                    cur += count[frozenset(tuple(p[0]) + c)]\n            res.append(cur)\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            subs = [p[0]]\n            for c in p[1:]:\n                subs += [s + c for s in subs]\n            res.append(sum(count[frozenset(s)] for s in subs))\n        return res", "from collections import defaultdict\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        tri = defaultdict(lambda: 0)\n        for word in words:\n            cur = tri\n            letters = sorted(set(word))\n            for i in range(len(letters)):\n                if letters[i] in cur:\n                    cur = cur[letters[i]]\n                else:\n                    cur[letters[i]] = defaultdict(lambda: 0)\n                    cur = cur[letters[i]]\n                if i == len(letters) - 1:\n                    if '*' in cur:\n                        cur['*'] += 1\n                    else:\n                        cur['*'] = 1\n                    \n        returnArr = [0] * len(puzzles)\n        \n        def helper(tri, puzzle, i,  found_first):\n            firstLetter = puzzle[0]\n            if '*' in tri and found_first:\n                returnArr[i] += tri['*']\n            for letter in tri:\n                if letter in puzzle:\n                    if firstLetter  == letter or found_first:\n                        helper(tri[letter], puzzle, i, True)\n                    else:\n                        helper(tri[letter], puzzle, i, False)\n            \n        \n        for i in range(len(puzzles)):\n            helper(tri, puzzles[i], i, False)\n            \n        return returnArr", "class Solution:\n    def findNumOfValidWords1(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            cur = 0\n            for k in range(7):\n                for c in itertools.combinations(p[1:], k):\n                    cur += count[frozenset(tuple(p[0]) + c)]\n            res.append(cur)\n        return res\n\n    def findNumOfValidWords2(self, words, puzzles):\n        count = collections.Counter()\n        for w in words:\n            if len(set(w)) > 7: continue\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - 97)\n            count[m] += 1\n        res = []\n        for p in puzzles:\n            bfs = [1 << (ord(p[0]) - 97)]\n            for c in p[1:]:\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\n            res.append(sum(count[m] for m in bfs))\n        return res\n    \n    def getBitMask(self, word: str) -> int:\n        mask = 0\n        for c in word:\n\\t\\t    # Maps 'a' -> 0, 'b' -> 1, 'c' -> 2, ...\n            i = ord(c) - ord('a')\n\\t\\t\\t# Sets the i-th bit to 1.\n            mask |= 1 << i\n        return mask\n\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n\\t    # [2]\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\n\\t\\t# For example 'abd' and 'baddd' would have the same mask because they are composed\n\\t\\t# of the same set of characters.\n        letterFrequencies = {}\n        for word in words:\n            mask = self.getBitMask(word)\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\n        \n        solution = [0] * len(puzzles)\n        \n        for i in range(len(puzzles)):\n            puzzle = puzzles[i]\n            mask = self.getBitMask(puzzle)\n            subMask = mask\n            total = 0\n\\t\\t\\t\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\n\\t\\t\\t# submasks we generate are of valid words.\n            firstBitIndex = ord(puzzle[0]) - ord('a')\n\n\\t\\t\\t# [3]\n            # In this while loop we want to go through all possible \\\"submasks\\\" of the bit\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\n            while True:\n\\t\\t\\t\\t# [4]\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it's a valid word. Here\n\\t\\t\\t\\t# we add to the number of words we've seen with this mask to our total.\n                if subMask >> firstBitIndex & 1:\n                    total += letterFrequencies.get(subMask, 0)\n\\t\\t\\t\\t# We've exhausted all possible submasks.\n                if subMask == 0:\n                    break\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\n\\t\\t\\t\\t# originally in the mask. If the original mask was '01011' current submask is '01000',\n\\t\\t\\t\\t# then submask - 1 = '00111' and (submask - 1) & mask = '00011'.\n                subMask = (subMask - 1) & mask\n            solution[i] = total\n        \n        return solution", "import collections\nclass Node(object):\n    def __init__(self):\n        self.dic = collections.defaultdict(Node)\n        self.counter = 0\n        \n    def insert(self, word):\n        if not word:\n            return\n        node = self.dic[word[0]]\n        for ind in range(1, len(word)):\n            node = node.dic[word[ind]]\n        node.counter += 1\n        \n            \nclass Solution(object):\n    def findNumOfValidWords(self, words, puzzles):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        :type puzzles: List[str]\n        :rtype: List[int]\n        \\\"\\\"\\\"\n        \n        def dfs(puzzle, i, node):\n            if i == len(puzzle):\n                self.count += node.counter\n                return \n            \n            if puzzle[i] == self.initial:\n                if puzzle[i] not in node.dic:\n                    return\n                dfs(puzzle, i + 1, node.dic[puzzle[i]])\n                \n            else:\n                dfs(puzzle, i + 1, node)\n                if puzzle[i] not in node.dic:\n                    return\n                dfs(puzzle, i + 1, node.dic[puzzle[i]])\n        \n        trie = Node()\n        for word in words:\n            word = ''.join(sorted(set(word)))\n            trie.insert(word)\n        \n        \n        final = [0 for _ in range(len(puzzles))]\n        for ind in range(len(puzzles)):\n            self.initial = puzzles[ind][0]\n            self.count = 0\n            puzzle = ''.join(sorted(set(puzzles[ind])))\n            dfs(puzzle, 0, trie)\n            final[ind] = self.count\n            \n        return final", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        # cnt = Counter(frozenset(w) for w in words if len(set(w)) <= 7)\n        # ans = []\n        # for p in puzzles:\n        #     cur = 0\n        #     for k in range(7):\n        #         for i in itertools.combinations(p[1:], k):\n        #             cur += cnt[frozenset((p[0],) + i)]\n        #     ans.append(cur)\n        # return ans\n                    \n        \n        \n        ans = []\n        cnt = Counter()\n        for w in words:\n            w = set(w)\n            if len(w) > 7:\n                continue\n            w_bit = 0\n            for c in w:\n                w_bit |= 1 << ord(c) - ord('a')\n            cnt[w_bit] += 1\n        for p in puzzles:\n            bfs = [1 << ord(p[0]) - ord('a')]\n            for c in p[1:]:\n                bfs += [m | 1 << ord(c) - ord('a') for m in bfs]\n            ans.append(sum(cnt[m] for m in bfs))\n        return ans\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        ans = []\n        cnt = Counter()\n        for w in words:\n            w = set(w)\n            if len(w) > 7:\n                continue\n            w_bit = 0\n            for c in w:\n                w_bit |= 1 << ord(c) - ord('a')\n            cnt[w_bit] += 1\n        for p in puzzles:\n            bfs = [1 << (ord(p[0]) - ord('a'))]\n            for c in p[1:]:\n                bfs += [m | 1 << (ord(c) - ord('a')) for m in bfs]\n            ans.append(sum(cnt[m] for m in bfs))\n        return ans\n        #     cur = 0\n        #     p_bit = 0\n        #     for c in p:\n        #         p_bit |= 1 << ord(c) - ord('a')\n        #     a = 1 << ord(p[0]) - ord('a')\n        #     for w in cnt:\n        #         if a & w and w & p_bit == w:\n        #             cur += cnt[w]\n        #     ans.append(cur)\n        # return ans\n", "class Solution:\n    \n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        # 97 = ord('a')\n        \n        def wordToInt(word: str) -> int:\n            n  = 0\n            ls = 0\n            for c in word:\n                cn = 1 << (ord(c) - 97)\n                ls += 1 if cn & n == 0 else 0\n                if ls > 7:\n                    return None\n                n |= cn\n            return n\n        \n        def validWords(ws, puzzle: str) -> int:\n            return sum( (ws[n] if n in ws else 0) for n in getPossibleNums(puzzle, 0) ) \n        \n        def getPossibleNums(puzzle: str, i: int) -> List[int]:\n            cn = 1 << (ord(puzzle[i]) - 97)\n            if i == len(puzzle) - 1:\n                return [cn, 0]\n            elif i == 0:\n                return [ n | cn for n in getPossibleNums(puzzle, 1) ]\n            else:\n                tmp = getPossibleNums(puzzle, i+1)\n                return [ n | cn for n in tmp ] + tmp\n        \n        ws = {}\n        for w in words:\n            n = wordToInt(w)\n            if n is not None:\n                ws[n] = 1 + (ws[n] if n in ws else 0)\n            \n        return map(lambda p: validWords(ws, p), puzzles)", "import string\nfrom collections import defaultdict\nimport time\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        word_counts = defaultdict(int)\n        for word in words:\n            sorted_word = ''.join(sorted(set(word)))\n            word_counts[sorted_word] += 1\n        \n        def get_puzzle_sequences(puzzle):\n            first_char = puzzle[0]\n            sorted_puzzle = ''.join(sorted(puzzle))\n            def helper(i):\n                if i == len(puzzle):\n                    yield ['']\n                    return\n                char = sorted_puzzle[i]\n                if char == first_char:\n                    for sequence in helper(i+1):\n                        yield [char] + sequence\n                else:\n                    for sequence in helper(i+1):\n                        yield sequence\n                        yield [char] + sequence\n                    \n            for sequence in helper(0):\n                yield ''.join(sequence)\n        \n        retval = [0] * len(puzzles)\n        for i, puzzle in enumerate(puzzles):\n            count = 0\n            for puzzle_sequence in get_puzzle_sequences(puzzle):\n                count += word_counts[puzzle_sequence]\n            retval[i] = count\n        \n        return retval\n            \n        \n\\\"\\\"\\\"\n        puzzle_index_set_lookup = defaultdict(set)\n        for i, puzzle in enumerate(puzzles):\n            for char in puzzle:\n                puzzle_index_set_lookup[char].add(i)\n        \n        cached_puzzle_index_list = {}\n        def get_puzzle_index_list(sorted_word):\n            puzzle_index_list = cached_puzzle_index_list.get(sorted_word[:4])\n            if puzzle_index_list is not None:\n                return puzzle_index_list\n            for i, char in enumerate(sorted_word[:4]):\n                if i == 0:\n                    puzzle_index_list = list(puzzle_index_set_lookup[char])\n                else:\n                    next_puzzle_index_list = []\n                    current_puzzle_index_set = puzzle_index_set_lookup[char]\n                    for puzzle_index in puzzle_index_list:\n                        if puzzle_index in current_puzzle_index_set:\n                            next_puzzle_index_list.append(puzzle_index)\n                    puzzle_index_list = next_puzzle_index_list\n            cached_puzzle_index_list[sorted_word[:4]] = puzzle_index_list\n            return puzzle_index_list\n        \n        retval = [0] * len(puzzles)\n        puzzle_sets = [set(puzzle) for puzzle in puzzles]\n        for word in words:\n            sorted_word = ''.join(sorted(word))\n            for puzzle_index in get_puzzle_index_list(sorted_word):\n                puzzle_set = puzzle_sets[puzzle_index]\n                if puzzles[puzzle_index][0] in word:\n                    match = True\n                    for char in word:\n                        if char not in puzzle_set:\n                            match = False\n                            break\n                    if match:\n                        retval[puzzle_index] += 1\n        return retval\n\\\"\\\"\\\"\n    \n    \n    \n    \n    \n    \n    \n\\\"\\\"\\\"\n    def get_filtered_words(self, words, puzzles):\n        filtered_words = defaultdict(list)\n        char_counts = defaultdict(int)\n        for word in words:\n            word_set = set(word)\n            for char in word_set:\n                char_counts[char] += 1\n                filtered_words[char].append(word)\n        return filtered_words, char_counts\n                \n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        print (time.time())\n        filtered_words, char_counts = self.get_filtered_words(words, puzzles)\n        #print (filtered_words, char_counts)\n        print (time.time(), char_counts)\n        print (len(words), [len(word_list) for word_list in filtered_words.values()])\n        \n        def get_max_missing_char(puzzle_set):\n            max_missing_char = None\n            max_missing_char_count = -1\n            for char in string.ascii_lowercase:\n                if char in puzzle_set:\n                    continue\n                # This is a missing char.. identify the one that occurs the most so we can filter it\n                missing_char_count = char_counts[char]\n                if missing_char_count > max_missing_char_count:\n                    max_missing_char_count = missing_char_count\n                    max_missing_char = char\n            return max_missing_char\n        \n        double_filtered_words = defaultdict(lambda: defaultdict(list))\n        for first_char, word_list in filtered_words.items():\n            for word in word_list:\n                word_set = set(word)\n                for missing_char in string.ascii_lowercase:\n                    if missing_char not in word_set:\n                        double_filtered_words[first_char][missing_char].append(word)\n        #print(double_filtered_words)\n        print(time.time())\n        for char, missing_char_dict in double_filtered_words.items():\n            print(char, [len(word_list) for word_list in missing_char_dict.values()])\n        return\n        \n        retval = []\n        for puzzle in puzzles:\n            puzzle_set = set(puzzle)\n            count = 0\n            #print (puzzle, get_max_missing_char(puzzle_set), double_filtered_words[puzzle[0]][get_max_missing_char(puzzle_set)])\n            for word in double_filtered_words[puzzle[0]][get_max_missing_char(puzzle_set)]:\n                match = True\n                for char in word:\n                    if char not in puzzle_set:\n                        match = False\n                        break\n                if match:\n                    count += 1\n            retval.append(count)\n        return retval\n        \n\\\"\\\"\\\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\\\"\\\"\\\"\n        retval = []\n        for puzzle in puzzles:\n            puzzle_set = set(puzzle)\n            first_char = puzzle[0]\n            count = 0\n            for word in words:\n                found_first_char = False\n                found_all_chars = True\n                for char in word:\n                    if char == first_char:\n                        found_first_char = True\n                    elif char not in puzzle_set:\n                        found_all_chars = False\n                        break\n                if found_first_char and found_all_chars:\n                    count += 1\n            retval.append(count)\n        return retval\n\\\"\\\"\\\"", "def to_mask(word):\n    ret = 0\n    for c in word:\n        ret |= 1 << (ord(c) - 97)\n    return ret\n\ndef get_good_masks(word):\n    BASE = 1 << (ord(word[0]) - 97)\n    ret = []\n    \n    for choice in range(64):\n        mask = BASE\n        for i in range(6):\n            if (1 << i) & choice:\n                mask |= 1 << (ord(word[i+1]) - 97)\n        ret.append(mask)\n        \n    return ret\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        # Construct bitmask frequency hashtable\n        mask_frequency = defaultdict(int)\n        for word in words:\n            mask_frequency[to_mask(word)] += 1\n            \n        # Calculate\n        N = len(puzzles)\n        ans = [0] * N\n        for i, puzzle in enumerate(puzzles):\n            for mask in get_good_masks(puzzle):\n                ans[i] += mask_frequency[mask]\n        \n        return ans", "class Puzzle:\n    def __init__(self, puzzle):\n        self.first_letter = puzzle[0]\n        self.puzzle = set(puzzle)\n        \nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        cnt = collections.Counter(frozenset(w) for w in words)\n        res = [0] * len(puzzles)\n        for i, puzzle in enumerate(puzzles):\n            subsets = [puzzle[0]]\n            for c in puzzle[1:]:\n                subsets += [sub + c for sub in subsets]\n            res[i] += sum(cnt[frozenset(sub)] for sub in subsets)\n        return res\n            \n                    \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        mp = defaultdict(int)\n        for w in words:\n            mask = 0\n            for c in w:\n                mask |= (1<<(ord(c)-ord('a')))\n\n            mp[mask]+=1\n        # print(mp)\n        res = []\n        for p in puzzles:\n            lenp = len(p)-1\n            cnt = 0\n            for i in range(1<<lenp):\n                mask = 1<<(ord(p[0])-ord('a'))\n                for j in range(lenp):\n                    if i & (1<<j):\n                        mask|=(1<<(ord(p[j+1])-ord('a')))\n\n                # print('mp', mp, 'mask', mask)\n                if mp[mask]:\n                    cnt+=mp[mask]\n\n\n            res.append(cnt)\n\n        return res\n\n        \n#         res = [0]*len(puzzles)\n#         lswords = [set()]*len(words)\n#         for idx, word in enumerate(words):\n#             lswords[idx] = set(word)\n      \n#         # print('lisr of set words',lswords)\n#         for idx, puzzle in enumerate(puzzles):\n#             firstLetter = puzzle[0]\n#             remLetters = set(puzzle)\n\n#             cnt = 0\n#             # print(puzzle, firstLetter, remLetters)\n#             for sWord in lswords:\n#                 # print(word, 'sword',sWord,'\\\n')\n#                 if firstLetter in sWord and sWord.issubset(remLetters):\n#                     # print('inc')\n#                     cnt+=1\n\n#             res[idx]=cnt\n#             # print('end of puzzle\\\n\\\n')\n#         return res\n", "from itertools import combinations\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]):\n        def code_word(word):\n            b = 0\n            for c in word:\n                b |= 1 << (ord(c) - ord('a'))\n            return b\n        \n        def remove_duplicates(word):\n            d = {}\n            result = \\\"\\\"\n            for c in word:\n                if c not in d:\n                    d[c] = True\n                    result += c\n            return result\n                    \n        \n        words_bits = defaultdict(int)   \n        for word in words:\n            b = code_word(word)\n            words_bits[b] += 1\n            \n        for puzzle in puzzles:\n            count = 0\n            first_letter = 1 << (ord(puzzle[0]) - ord('a'))       \n            if not first_letter & code_word(puzzle):\n                continue\n            p = remove_duplicates(puzzle)\n            for i in range(len(p)):\n                for c in combinations(p,i + 1):\n                    b = code_word(c)\n                    if b in words_bits and first_letter & b:\n                        count += words_bits[b]\n            yield count\n        \n                \n        ", "from itertools import combinations\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]):\n        def code_word(word):\n            b = 0\n            for c in word:\n                b |= 1 << (ord(c) - ord('a'))\n            return b\n        \n        def remove_duplicates(word):\n            d = {}\n            result = \\\"\\\"\n            for c in word:\n                if c not in d:\n                    d[c] = True\n                    result += c\n            return result\n        \n        words_bits = defaultdict(int)   \n        for word in words:\n            b = code_word(word)\n            words_bits[b] += 1\n            \n        for puzzle in puzzles:\n            count = 0\n            first_letter = 1 << (ord(puzzle[0]) - ord('a'))       \n            if not first_letter & code_word(puzzle):\n                continue\n            p = remove_duplicates(puzzle)\n            for i in range(len(p)):\n                for c in combinations(p,i + 1):\n                    b = code_word(c)\n                    if b in words_bits and first_letter & b:\n                        count += words_bits[b]\n            yield count\n        \n                \n        ", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            cur = 0\n            for k in range(len(p)):\n                for c in itertools.combinations(p[1:], k):\n                    cur += count[frozenset(tuple(p[0]) + c)]\n            res.append(cur)\n        return res\n\n    def findNumOfValidWords2(self, words, puzzles):\n        count = collections.Counter()\n        for w in words:\n            if len(set(w)) > 7: continue\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - 97)\n            count[m] += 1\n        res = []\n        for p in puzzles:\n            bfs = [1 << (ord(p[0]) - 97)]\n            for c in p[1:]:\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\n            res.append(sum(count[m] for m in bfs))\n        return res\n    \n    def getBitMask(self, word: str) -> int:\n        mask = 0\n        for c in word:\n\\t\\t    # Maps 'a' -> 0, 'b' -> 1, 'c' -> 2, ...\n            i = ord(c) - ord('a')\n\\t\\t\\t# Sets the i-th bit to 1.\n            mask |= 1 << i\n        return mask\n\n    def findNumOfValidWords1(self, words: List[str], puzzles: List[str]) -> List[int]:\n\\t    # [2]\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\n\\t\\t# For example 'abd' and 'baddd' would have the same mask because they are composed\n\\t\\t# of the same set of characters.\n        letterFrequencies = {}\n        for word in words:\n            mask = self.getBitMask(word)\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\n        \n        solution = [0] * len(puzzles)\n        \n        for i in range(len(puzzles)):\n            puzzle = puzzles[i]\n            mask = self.getBitMask(puzzle)\n            subMask = mask\n            total = 0\n\\t\\t\\t\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\n\\t\\t\\t# submasks we generate are of valid words.\n            firstBitIndex = ord(puzzle[0]) - ord('a')\n\n\\t\\t\\t# [3]\n            # In this while loop we want to go through all possible \\\"submasks\\\" of the bit\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\n            while True:\n\\t\\t\\t\\t# [4]\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it's a valid word. Here\n\\t\\t\\t\\t# we add to the number of words we've seen with this mask to our total.\n                if subMask >> firstBitIndex & 1:\n                    total += letterFrequencies.get(subMask, 0)\n\\t\\t\\t\\t# We've exhausted all possible submasks.\n                if subMask == 0:\n                    break\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\n\\t\\t\\t\\t# originally in the mask. If the original mask was '01011' current submask is '01000',\n\\t\\t\\t\\t# then submask - 1 = '00111' and (submask - 1) & mask = '00011'.\n                subMask = (subMask - 1) & mask\n            solution[i] = total\n        \n        return solution", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        def getNum(s: str) -> int:\n            res = 0\n            for c in s:\n                res |= (1 << (ord(c) - 97))\n            return res\n        \n        counter = Counter([getNum(set(word)) for word in words if len(set(word)) < 8])\n        ans = []\n        for puzzle in puzzles:\n            sub = [(1 << (ord(puzzle[0]) - 97))]\n            for c in puzzle[1:]:\n                sub += [m | (1 << (ord(c) - 97)) for m in sub]\n            ans.append(sum(counter[w] for w in sub))\n            \n        return ans", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        trie = defaultdict(int)\n        result = [0 for _ in range(len(puzzles))]\n        \n        def dfs(puzzle, i, trie, hasFirst=False):        \n            if \\\"*\\\" in trie and hasFirst:\n                result[i] += trie[\\\"*\\\"]\n                        \n            for c in puzzle:\n                if c in trie:\n                    dfs(puzzle, i, trie[c], hasFirst or c == puzzle[0])\n                            \n        for w in words:\n            curr = trie\n            for c in sorted(set(w)):\n                curr = curr.setdefault(c, defaultdict(int))\n              \n            curr[\\\"*\\\"] += 1\n            # if \\\"*\\\" in curr:\n            #     curr[\\\"*\\\"] += 1\n            # else:\n            #     curr[\\\"*\\\"] = 1\n                        \n        for i, p in enumerate(puzzles):\n            dfs(p, i, trie)\n            \n        return result", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        def helper(mask,pIdx,i):\n            str1=puzzles[pIdx]\n            if i>=len(str1):\n                return\n            mask2=mask\n            mask2|=1<<(ord(str1[i])-ord('a'))\n            if mask2^mask:\n                d[mask2].add(pIdx)\n                helper(mask2,pIdx,i+1)\n            helper(mask,pIdx,i+1)\n\n        d=collections.defaultdict(set)\n        n=len(puzzles)\n        for i,p in enumerate(puzzles):\n            mask=1<<(ord(p[0])-ord('a'))\n            d[mask].add(i)\n            helper(mask,i,1)\n        res=[0]*len(puzzles)\n        for w in words:\n            mask=0\n            for c in w:\n                mask|=1<<(ord(c)-ord('a'))\n            for idx in d[mask]:\n                res[idx]+=1\n        return res", "from collections import defaultdict\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        d = defaultdict(int)\n        for word in words:\n            wl = list(set(list(word)))\n            wl.sort()\n            d[''.join(wl)] += 1\n        ans = []\n        \n        for puzzle in puzzles:\n            f = puzzle[0]\n            pl = sorted(list(puzzle))\n            fi = pl.index(f)\n            tmp = 0\n            for i in range(2 ** (len(pl) - 1)):\n                cand = []\n                for j in range(len(pl)):\n                    if j < fi:\n                        if i & (1 << j):\n                            cand.append(pl[j])\n                    elif j == fi:\n                        cand.append(f)\n                    else:\n                        if i & (1 << (j - 1)):\n                            cand.append(pl[j])\n                cs = ''.join(cand)\n                tmp += d[cs]\n            ans.append(tmp)\n        \n        return ans\n        \n        \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        class TrieNode():\n            def __init__(self):\n                self.children = collections.defaultdict(TrieNode)\n                self.word_inds = []\n                \n            def add(self, x, word_ind):\n                if x:\n                    self.children[x[0]].add(x[1:], word_ind)\n                else:\n                    self.word_inds.append(word_ind)\n        \n        root = TrieNode()\n                \n        for ind, word in enumerate(words):\n            root.add(sorted(set(word)), ind)\n            \n        counts = []\n        for puzzle in puzzles:\n            nodes = [root]\n            for letter in sorted(puzzle):\n                new_nodes = []\n                for node in nodes:\n                    if letter in node.children:\n                        new_nodes.append(node.children[letter])\n                nodes += new_nodes\n            count = 0\n            for node in nodes:\n                for word_ind in node.word_inds:\n                    if puzzle[0] in words[word_ind]:\n                        count += 1\n            counts.append(count)\n        \n        return counts\n                \n            \n                    \n                    \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        wordPatternCnt = collections.defaultdict(int)\n        \n        for word in words:\n            pattern = 0\n            for letter in word:\n                pattern |= (1 << ord(letter) - ord(\\\"a\\\"))\n            wordPatternCnt[pattern] += 1\n        \n        res = []\n        \n        for puzzle in puzzles:\n            cnt = 0\n            pattern = 0\n            for letter in puzzle:\n                pattern |= (1 << (ord(letter) - ord(\\\"a\\\")))\n                \n            subPattern = pattern\n                \n            while subPattern > 0:\n                if subPattern & (1 << (ord(puzzle[0]) - ord(\\\"a\\\"))): #valid pattern must conclude the first letter of puzzle\n                    cnt += wordPatternCnt[subPattern]\n                    \n                subPattern = pattern & (subPattern - 1)\n            \n            res.append(cnt)\n        \n        return res\n                ", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        cnt = Counter(frozenset(w) for w in words if len(set(w)) <= 7)\n        ans = []\n        for p in puzzles:\n            cur = 0\n            for k in range(7):\n                for i in itertools.combinations(p[1:], k):\n                    cur += cnt[frozenset((p[0],) + i)]\n            ans.append(cur)\n        return ans\n                    \n        \n        \n#         ans = []\n#         cnt = Counter()\n#         for w in words:\n#             w = set(w)\n#             if len(w) > 7:\n#                 continue\n#             w_bit = 0\n#             for c in w:\n#                 w_bit |= 1 << ord(c) - ord('a')\n#             cnt[w_bit] += 1\n#         for p in puzzles:\n#             bfs = [1 << ord(p[0]) - ord('a')]\n#             for c in p[1:]:\n#                 bfs += [m | 1 << ord(c) - ord('a') for m in bfs]\n#             ans.append(sum(cnt[m] for m in bfs))\n#         return ans\n", "class Node:\n    def __init__(self):\n        self.ch = {}\n        self.cnt = 0\n    def build(self, words):\n        for w in words:\n            n = self\n            for c in w:\n                if c not in n.ch:\n                    n.ch[c] = Node()\n                n = n.ch[c]\n            n.cnt += 1\n    def search(self, w, first):\n        ans = 0\n        if first:\n            ans += self.cnt\n        for c in w:\n            if c not in self.ch:\n                continue\n            if c == w[0]:\n                ans += self.ch[c].search(w, True)\n            else:\n                ans += self.ch[c].search(w, first)\n        return ans\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        root = Node()\n        root.build([sorted(set(x)) for x in words])\n        ans = []\n        for p in puzzles:\n            ans.append(root.search(p, False))\n        return ans\n            \n            \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        counter = Counter()\n        res = []\n        for w in words:\n            bitmask = 0\n            for c in set(w):\n                bitmask |= 1 << ord(c)-ord('a')\n            counter[bitmask] += 1\n            \n        for p in puzzles:\n            cands = [1<<ord(p[0])-ord('a')]\n            for c in p[1:]:\n                cands += [b|(1<<ord(c)-ord('a')) for b in cands]\n\n            res.append(sum(counter[b] for b in cands))\n            \n        return res\n            \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        count = collections.Counter(frozenset(w) for w in words)\n        res = []\n        for p in puzzles:\n            cur = 0\n            for k in range(7):\n                for c in itertools.combinations(p[1:], k):\n                    cur += count[frozenset(tuple(p[0]) + c)]\n            res.append(cur)\n        return res", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        # Trie\n        trie = {}\n        ans = [0] * len(puzzles)\n        for word in words:\n            cur = trie\n            for w in sorted(set(word)):\n                if w not in cur:\n                    cur[w] = {}\n                cur = cur[w]\n            if '#' not in cur:\n                cur['#'] = 1\n            else:\n                cur['#'] += 1\n                \n        def dfs(cur, i, head):\n            p = puzzles[i]\n            if '#' in cur and head:\n                ans[i] += cur['#']\n            for c in cur:\n                if c in p:\n                    if p[0] == c or head:\n                        dfs(cur[c], i, True)\n                    else:\n                        dfs(cur[c], i, False)\n            return\n        \n        for i in range(len(puzzles)):\n            dfs(trie, i, False)\n            \n        return ans\n        \n        \n        \n        # # Using build-in combinations\n        # cnt = Counter(frozenset(w) for w in words if len(set(w)) <= 7)\n        # ans = []\n        # for p in puzzles:\n        #     cur = 0\n        #     for k in range(7):\n        #         for i in itertools.combinations(p[1:], k):\n        #             cur += cnt[frozenset((p[0],) + i)]\n        #     ans.append(cur)\n        # return ans\n                    \n        \n        # # bit-mask & bfs-based combinations\n        # ans = []\n        # cnt = Counter()\n        # for w in words:\n        #     w = set(w)\n        #     if len(w) > 7:\n        #         continue\n        #     w_bit = 0\n        #     for c in w:\n        #         w_bit |= 1 << ord(c) - ord('a')\n        #     cnt[w_bit] += 1\n        # for p in puzzles:\n        #     bfs = [1 << ord(p[0]) - ord('a')]\n        #     for c in p[1:]:\n        #         bfs += [m | 1 << ord(c) - ord('a') for m in bfs]\n        #     ans.append(sum(cnt[m] for m in bfs))\n        # return ans\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        def generate(n):\n            res = [0]\n            cur = 1\n            while n:\n                if n & 1 == 1:\n                    res += [i + cur for i in res]\n                n >>= 1\n                cur <<= 1\n            return set(res)\n        def to_bit(w):\n            res = 0\n            for c in w:\n                res |= 1 << (ord(c) - ord('a'))\n            return res\n        m = collections.defaultdict(dict)\n        for w in words:\n            visited = set()\n            for c in w:\n                if c in visited: continue\n                visited.add(c)\n                b = to_bit(w)\n                if b not in m[c]:\n                    m[c][b] = 1\n                else:\n                    m[c][b] += 1\n        res = []\n        for w in puzzles:\n            s1, count = m[w[0]], 0\n            for i in generate(to_bit(w)):\n                if i in s1: \n                    count += s1[i]\n            res.append(count)\n        \n        return res", "from functools import reduce\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \n        # Trie\n        ans = [0] * len(puzzles)\n        T = lambda: collections.defaultdict(T)\n        trie = T()\n        for w in words:\n            cur = reduce(dict.__getitem__, sorted(set(w)), trie)\n            if '#' not in cur:\n                cur['#'] = 1\n            else:\n                cur['#'] += 1\n                \n        def dfs(cur, i, head):\n            p = puzzles[i]\n            if '#' in cur and head:\n                ans[i] += cur['#']\n            for c in cur:\n                if c in p:\n                    if p[0] == c or head:\n                        dfs(cur[c], i, True)\n                    else:\n                        dfs(cur[c], i, False)\n            return\n        \n        for i in range(len(puzzles)):\n            dfs(trie, i, False)\n            \n        return ans\n        \n        \n        \n        # # Using build-in combinations\n        # cnt = Counter(frozenset(w) for w in words if len(set(w)) <= 7)\n        # ans = []\n        # for p in puzzles:\n        #     cur = 0\n        #     for k in range(7):\n        #         for i in itertools.combinations(p[1:], k):\n        #             cur += cnt[frozenset((p[0],) + i)]\n        #     ans.append(cur)\n        # return ans\n                    \n        \n        # # bit-mask & bfs-based combinations\n        # ans = []\n        # cnt = Counter()\n        # for w in words:\n        #     w = set(w)\n        #     if len(w) > 7:\n        #         continue\n        #     w_bit = 0\n        #     for c in w:\n        #         w_bit |= 1 << ord(c) - ord('a')\n        #     cnt[w_bit] += 1\n        # for p in puzzles:\n        #     bfs = [1 << ord(p[0]) - ord('a')]\n        #     for c in p[1:]:\n        #         bfs += [m | 1 << ord(c) - ord('a') for m in bfs]\n        #     ans.append(sum(cnt[m] for m in bfs))\n        # return ans\n", "import string\nfrom collections import defaultdict\nimport time\nclass Node:\n    def __init__(self, char):\n        self.char = char\n        self.count = 0\n        self.children = {}\n    def add_word(self, word):\n        current = self\n        for char in word:\n            current = current.children.setdefault(char, Node(char))\n        current.count += 1\n        \nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        trie = Node(None)\n        for word in words:\n            sorted_word = ''.join(sorted(set(word)))\n            trie.add_word(sorted_word)\n            \n        def get_word_count(puzzle):\n            first_char = puzzle[0]\n            sorted_puzzle = ''.join(sorted(puzzle))\n            count = 0\n            def helper(i, node):\n                if i == len(puzzle):\n                    yield node\n                    return\n                char = sorted_puzzle[i]\n                if char == first_char:\n                    if char in node.children:\n                        for yielded_node in helper(i+1, node.children[char]):\n                            yield yielded_node\n                else:\n                    for yielded_node in helper(i+1, node):\n                        yield yielded_node\n                    if char in node.children:\n                        for yielded_node in helper(i+1, node.children[char]):\n                            yield yielded_node\n\n            for yielded_node in helper(0, trie):\n                count += yielded_node.count\n            return count\n        \n        retval = [0] * len(puzzles)\n        for i, puzzle in enumerate(puzzles):\n            retval[i] = get_word_count(puzzle)\n        \n        return retval\n            \n        \n\\\"\\\"\\\"\n        puzzle_index_set_lookup = defaultdict(set)\n        for i, puzzle in enumerate(puzzles):\n            for char in puzzle:\n                puzzle_index_set_lookup[char].add(i)\n        \n        cached_puzzle_index_list = {}\n        def get_puzzle_index_list(sorted_word):\n            puzzle_index_list = cached_puzzle_index_list.get(sorted_word[:4])\n            if puzzle_index_list is not None:\n                return puzzle_index_list\n            for i, char in enumerate(sorted_word[:4]):\n                if i == 0:\n                    puzzle_index_list = list(puzzle_index_set_lookup[char])\n                else:\n                    next_puzzle_index_list = []\n                    current_puzzle_index_set = puzzle_index_set_lookup[char]\n                    for puzzle_index in puzzle_index_list:\n                        if puzzle_index in current_puzzle_index_set:\n                            next_puzzle_index_list.append(puzzle_index)\n                    puzzle_index_list = next_puzzle_index_list\n            cached_puzzle_index_list[sorted_word[:4]] = puzzle_index_list\n            return puzzle_index_list\n        \n        retval = [0] * len(puzzles)\n        puzzle_sets = [set(puzzle) for puzzle in puzzles]\n        for word in words:\n            sorted_word = ''.join(sorted(word))\n            for puzzle_index in get_puzzle_index_list(sorted_word):\n                puzzle_set = puzzle_sets[puzzle_index]\n                if puzzles[puzzle_index][0] in word:\n                    match = True\n                    for char in word:\n                        if char not in puzzle_set:\n                            match = False\n                            break\n                    if match:\n                        retval[puzzle_index] += 1\n        return retval\n\\\"\\\"\\\"\n    \n    \n    \n    \n    \n    \n    \n\\\"\\\"\\\"\n    def get_filtered_words(self, words, puzzles):\n        filtered_words = defaultdict(list)\n        char_counts = defaultdict(int)\n        for word in words:\n            word_set = set(word)\n            for char in word_set:\n                char_counts[char] += 1\n                filtered_words[char].append(word)\n        return filtered_words, char_counts\n                \n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        print (time.time())\n        filtered_words, char_counts = self.get_filtered_words(words, puzzles)\n        #print (filtered_words, char_counts)\n        print (time.time(), char_counts)\n        print (len(words), [len(word_list) for word_list in filtered_words.values()])\n        \n        def get_max_missing_char(puzzle_set):\n            max_missing_char = None\n            max_missing_char_count = -1\n            for char in string.ascii_lowercase:\n                if char in puzzle_set:\n                    continue\n                # This is a missing char.. identify the one that occurs the most so we can filter it\n                missing_char_count = char_counts[char]\n                if missing_char_count > max_missing_char_count:\n                    max_missing_char_count = missing_char_count\n                    max_missing_char = char\n            return max_missing_char\n        \n        double_filtered_words = defaultdict(lambda: defaultdict(list))\n        for first_char, word_list in filtered_words.items():\n            for word in word_list:\n                word_set = set(word)\n                for missing_char in string.ascii_lowercase:\n                    if missing_char not in word_set:\n                        double_filtered_words[first_char][missing_char].append(word)\n        #print(double_filtered_words)\n        print(time.time())\n        for char, missing_char_dict in double_filtered_words.items():\n            print(char, [len(word_list) for word_list in missing_char_dict.values()])\n        return\n        \n        retval = []\n        for puzzle in puzzles:\n            puzzle_set = set(puzzle)\n            count = 0\n            #print (puzzle, get_max_missing_char(puzzle_set), double_filtered_words[puzzle[0]][get_max_missing_char(puzzle_set)])\n            for word in double_filtered_words[puzzle[0]][get_max_missing_char(puzzle_set)]:\n                match = True\n                for char in word:\n                    if char not in puzzle_set:\n                        match = False\n                        break\n                if match:\n                    count += 1\n            retval.append(count)\n        return retval\n        \n\\\"\\\"\\\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\\\"\\\"\\\"\n        retval = []\n        for puzzle in puzzles:\n            puzzle_set = set(puzzle)\n            first_char = puzzle[0]\n            count = 0\n            for word in words:\n                found_first_char = False\n                found_all_chars = True\n                for char in word:\n                    if char == first_char:\n                        found_first_char = True\n                    elif char not in puzzle_set:\n                        found_all_chars = False\n                        break\n                if found_first_char and found_all_chars:\n                    count += 1\n            retval.append(count)\n        return retval\n\\\"\\\"\\\"", "class TrieNode:\n    def __init__(self):\n        self.children = [None] *26\n        self.count = 0\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        self.root = TrieNode()\n        for word in words:\n            chars = sorted(set(list(word)))\n            temp = \\\"\\\".join(chars)\n            self.insert(temp)\n        ans = []\n        for puzzle in puzzles:\n            ans.append(self.dfs(puzzle,self.root,False))\n        return ans\n\n\n    def dfs(self,puzzle,temp,collect = False):\n        if not temp:\n            return 0\n        \n        ans = temp.count if collect else 0\n        \n        for c in puzzle:\n            index = ord(c) - ord('a')\n            if temp.children[index]:\n                ans += self.dfs(puzzle,temp.children[index], collect or c == puzzle[0])\n        return ans\n    \n    def insert(self,word):\n        temp = self.root\n        for i in range(len(word)):\n            index = ord(word[i]) - ord('a')\n            if not temp.children[index]:\n                temp.children[index] = TrieNode()\n            temp = temp.children[index]\n        temp.count += 1\n        ", "class Solution:\n    def findNumOfValidWords(self, words, puzzles):\n        count = collections.Counter()\n        for w in words:\n            if len(set(w)) > 7: continue\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - 97)\n            count[m] += 1\n        res = []\n        for p in puzzles:\n            bfs = [1 << (ord(p[0]) - 97)]\n            for c in p[1:]:\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\n            res.append(sum(count[m] for m in bfs))\n        return res", "class Puzzle:\n    def __init__(self, puzzle):\n        self.first_letter = puzzle[0]\n        self.puzzle = set(puzzle)\n        \nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        cnt = collections.Counter(frozenset(w) for w in words)\n        res = [0] * len(puzzles)\n        for i, puzzle in enumerate(puzzles):\n            for bin_i in range(2**6, 2**7):\n                mask = bin(bin_i)[2:]\n                subset = frozenset([puzzle[j] for j in range(7) if mask[j] == '1'])\n                res[i] += cnt[subset]\n        return res\n            \n                    \n", "class Node:\n    def __init__(self):\n        self.ch = {}\n        self.cnt = 0\n    def build(self, words):\n        for w in words:\n            n = self\n            for c in w:\n                if c not in n.ch:\n                    n.ch[c] = Node()\n                n = n.ch[c]\n            n.cnt += 1\n    def search(self, w, first):\n        ans = 0\n        if first:\n            ans += self.cnt\n        for c in w:\n            if c not in self.ch:\n                continue\n            if c == w[0]:\n                ans += self.ch[c].search(w, True)\n            else:\n                ans += self.ch[c].search(w, first)\n        return ans\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        root = Node()\n        root.build([set(x) for x in words])\n        ans = []\n        for p in puzzles:\n            ans.append(root.search(p, False))\n        return ans\n            \n            \n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        def binarize(word):\n            ans = 0\n            for c in word:\n                ans |= (1 << (ord(c) - ord(\\\"a\\\")))\n            ans = bin(ans)[2:]\n            return \\\"0\\\" * (26 - len(ans)) + ans\n        \n        words = [binarize(word) for word in words if len(set(word)) < 8]\n        trie = {}\n        for i, word in enumerate(words):\n            temp = trie\n            for c in word:\n                if c not in temp:\n                    temp[c] = {}\n                temp = temp[c]\n            if \\\"*\\\" not in temp:\n                temp[\\\"*\\\"] = []\n            temp[\\\"*\\\"] += [i]\n            \n        puzzles = [(puzzle[0], binarize(puzzle)) for puzzle in puzzles]\n        ans = []\n        for c, puzzle in puzzles:\n            tries = [trie]\n            for b in puzzle:\n                new_tries = []\n                \n                for temp in tries:\n                    if \\\"0\\\" in temp:\n                        new_tries += [temp[\\\"0\\\"]]\n                    if b == \\\"1\\\" and \\\"1\\\" in temp:\n                        new_tries += [temp[\\\"1\\\"]]\n                        \n                tries = new_tries\n                \n            count = 0\n            for temp in tries:\n                for i in temp[\\\"*\\\"]:\n                    if words[i][25 - ord(c) + ord(\\\"a\\\")] == \\\"1\\\":\n                        count += 1\n            ans += [count]\n            \n        return ans", "from collections import defaultdict\nfrom typing import List\n\n\ndef get_encode(word, letters):\n    encode = ['0'] * 26\n    for c in word:\n        idx = letters.index(c)\n        encode[idx] = '1'\n    return ''.join(encode)\n\n\ndef dfs(encode, cur, sub_encodes):\n    if cur == len(encode):\n        sub_encodes.add(encode)\n        return\n    elif encode[cur] == '1':\n        sub_zero = encode[:cur] + '0' + encode[cur+1:]\n        sub_one = encode[:cur] + '1' + encode[cur+1:]\n        sub_encodes.add(sub_zero)\n        sub_encodes.add(sub_one)\n        dfs(sub_zero, cur+1, sub_encodes)\n        dfs(sub_one, cur+1, sub_encodes)\n    else:\n        dfs(encode, cur+1, sub_encodes)\n\n\nclass Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        records = defaultdict(int)\n        for word in words:\n            encode = get_encode(word, letters)\n            records[encode] += 1\n\n        results = []\n        for puzzle in puzzles:\n            encode, cur, idx_first = get_encode(puzzle, letters), 0, letters.index(puzzle[0])\n            sub_encodes = {encode}\n            dfs(encode, cur, sub_encodes)\n            result = sum([records[sub_encode] for sub_encode in list(sub_encodes) if sub_encode[idx_first] == '1'])\n            results.append(result)\n        return results\n", "class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        dic = {} # trie\n        for word in words:\n            cur = dic\n            for c in word:\n                if c not in cur:\n                    cur[c]={}\n                cur = cur[c]\n            if '*' not in cur:\n                cur['*']=1\n            else:\n                cur['*']+=1\n        res = [0 for _ in range(len(puzzles))]\n        def dfs(i, dic, check_head):\n            puzzle =puzzles[i]\n            if '*' in dic and check_head:\n                res[i]+=dic['*']\n            for k in dic:\n                if k in puzzle:\n                    if puzzle[0]==k or check_head:\n                        dfs(i, dic[k], True)\n                    else:\n                        dfs(i, dic[k], False)\n                \n                    \n        for i in range(len(puzzles)):\n            dfs(i, dic, False)\n        return res"]
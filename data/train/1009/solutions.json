["# cook your dish here\nfrom sys import stdin\nimport functools\ndef gcd(a, b):  \n if (a == 0): \n  return b \n return gcd(b % a, a) \n \nMAX=10001\ndef func(ind, g, dp, n, a): \n if (ind == n):  \n  if (g == 1):  \n   return 1\n  else: \n   return 0\n if (dp[ind][g] != -1):  \n  return dp[ind][g] \n ans = (func(ind + 1, g, dp, n, a) + \n   func(ind + 1, gcd(a[ind], g),  \n        dp, n, a)) \n dp[ind][g] = ans \n return dp[ind][g] \n \ndef countSubsequences(a, n):  \n dp = [[-1 for i in range(MAX)] \n    for i in range(n)] \n count = 0\n for i in range(n):  \n  count += func(i + 1, a[i], dp, n, a) \n return count \n\ntest=int(stdin.readline())\nfor _ in range(test):\n n=int(stdin.readline())\n list1=list(map(int,stdin.readline().split()))\n print(countSubsequences(list1,n))\n\n", "from sys import stdin\nimport functools\ndef gcd(a, b):  \n if (a == 0): \n  return b \n return gcd(b % a, a) \n \n# Recursive function to calculate the  \n# number of subsequences with gcd 1  \n# starting with particular index  \nMAX=10001\ndef func(ind, g, dp, n, a): \n \n # Base case  \n if (ind == n):  \n  if (g == 1):  \n   return 1\n  else: \n   return 0\n \n # If already visited  \n if (dp[ind][g] != -1):  \n  return dp[ind][g] \n \n # Either we take or we do not  \n ans = (func(ind + 1, g, dp, n, a) + \n   func(ind + 1, gcd(a[ind], g),  \n        dp, n, a)) \n \n # Return the answer  \n dp[ind][g] = ans \n return dp[ind][g] \n \n# Function to return the number  \n# of subsequences  \ndef countSubsequences(a, n):  \n \n # Hash table to memoize  \n dp = [[-1 for i in range(MAX)] \n    for i in range(n)] \n \n # Count the number of subsequences  \n count = 0\n \n # Count for every subsequence  \n for i in range(n):  \n  count += func(i + 1, a[i], dp, n, a) \n \n return count \ntc=int(stdin.readline())\nfor i in range(tc):\n n=int(stdin.readline())\n list1=list(map(int,stdin.readline().split()))\n print(countSubsequences(list1,n))\n\n", "# cook your dish here\nfrom math import gcd \n\nt = int(input())\nfor _t in range(t):\n n = int(input())\n arr = [int(x) for x in input().split()]\n dp = [[0]*10001 for i in range(n)]\n dp[0][arr[0]], sett = 1, set([arr[0]])\n for i in range(1, n):\n  dp[i][arr[i]]+=1\n  tmp = []\n  for j in sett:\n   dp[i][j] += dp[i-1][j]\n   dp[i][gcd(j, arr[i])] += dp[i-1][j]\n   tmp.append(gcd(j, arr[i]))\n  sett.update(tmp)\n  sett.add(arr[i])\n print(dp[n-1][1])", "from math import gcd\nfrom functools import reduce\n# aa = []\ndef func(W,i,g,dp):\n # print(i,g)\n # aa.append(1)\n if i>=len(W):\n  return 0\n if dp[i][g]!=-1:\n  return dp[i][g]\n _g = gcd(g,W[i])\n ans1 = 1+func(W,i+1,_g,dp) if _g==1 else func(W,i+1,_g,dp)\n dp[i][g]= ans1+func(W,i+1,g,dp)\n return dp[i][g]\n # return ans1 + func(W,i+1,g,dp)\nresult = \"\"\nfor _ in range(int(input())) :\n n = int(input())\n W = [int(x) for x in input().split()]\n dp = [[-1 for x in range(10000+3)] for y in range(70)]\n \n # aa=[]\n \n t = func(W,0,0,dp) \n # print(t,len(aa))\n result += str(t)+\"\\n\"\nprint(result[:-1])\n# submitted 03:05\n", "def cal(a,b):\n if b==0:\n  return a\n return cal(b,a%b)\n\ndef func(pos,cur_gcd):\n if pos==n:\n  if cur_gcd==1:\n   return 1\n  else:\n   return 0\n if (pos,cur_gcd) in dp:\n  return dp[(pos,cur_gcd)]\n if cur_gcd==1:\n  ans=2**(n-pos)\n  dp[(pos,cur_gcd)]=ans\n  return ans\n ans = func(pos+1,cal(cur_gcd,a[pos])) + func(pos+1,cur_gcd)\n dp[(pos,cur_gcd)]=ans\n return ans\n\nfor _ in range(int(input())):\n n = int(input())\n a = list(map(int,input().split()))\n dp = dict()\n ans = 0\n for i,j in enumerate(a):\n  ans+=func(i+1,j)\n print(ans)", "from math import gcd\ndef game(cPose,cGCD):\n if cPose==n:\n  return 1 if cGCD==1 else 0\n\n if (cPose,cGCD) in dp:\n  return dp[(cPose,cGCD)]\n \n dp[(cPose,cGCD)] = game(cPose+1,cGCD)+game(cPose+1,gcd(cGCD,l[cPose]))\n return dp[(cPose,cGCD)]\n \nfor _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n dp = {}; ans = 0\n for i in range(n):\n  ans += game(i+1,l[i])\n print(ans)", "from math import gcd\ndef game(cPose,cGCD):\n if cPose==n:\n  return 1 if cGCD==1 else 0\n \n if cGCD==1:\n  return 2**(n-cPose)\n \n if (cPose,cGCD) in dp:\n  return dp[(cPose,cGCD)]\n \n dp[(cPose,cGCD)] = game(cPose+1,cGCD)+game(cPose+1,gcd(cGCD,l[cPose]))\n return dp[(cPose,cGCD)]\n \nfor _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n dp = {}; ans = 0\n for i in range(n):\n  ans += game(i+1,l[i])\n print(ans)", "def GCD(a,b):\n return a if b==0 else GCD(b,a%b)\n\ndef game(cPose,cGCD):\n if cPose==n:\n  return 1 if cGCD==1 else 0\n \n if (cPose,cGCD) in dp:\n  return dp[(cPose,cGCD)]\n \n dp[(cPose,cGCD)] = game(cPose+1,cGCD)+game(cPose+1,GCD(cGCD,l[cPose]))\n return dp[(cPose,cGCD)]\n \nfor _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n dp = {}; ans = 0\n for i in range(n):\n  ans += game(i+1,l[i])\n print(ans)", "def GCD(a,b):\n return a if b==0 else GCD(b,a%b)\n\ndef game(cPose,cGCD):\n if cPose==n:\n  return 1 if cGCD==1 else 0\n \n if cGCD==1:\n  return 2**(n-cPose)\n \n if (cPose,cGCD) in dp:\n  return dp[(cPose,cGCD)]\n \n dp[(cPose,cGCD)] = game(cPose+1,cGCD)+game(cPose+1,GCD(cGCD,l[cPose]))\n return dp[(cPose,cGCD)]\n \nfor _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n dp = {}; ans = 0\n for i in range(n):\n  ans += game(i+1,l[i])\n print(ans)", "def gcd(a,b):\n if a == 0 or b == 0:\n  if a == 0:\n   return b\n  else:\n   return a\n else:\n  return gcd(b,a%b)\n\ndef thegame(pos,cgcd):\n if pos == n:\n  if cgcd == 1:\n   return 1\n  else:\n   return 0\n elif (pos,cgcd) in dp:\n  return dp[(pos,cgcd)]\n elif cgcd == 1:\n  p = 2**(n-pos)\n  dp[(pos,cgcd)] = p\n  return p\n else:\n  p = thegame(pos+1,gcd(cgcd,nums[pos])) + thegame(pos+1,cgcd)\n  dp[(pos,cgcd)] = p\n  return p\n\nt = int(input())\n\nwhile t>0:\n n = int(input())\n nums = list(map(int , input().split()))\n dp = {}\n res = 0\n for pos in range(0,n-1):\n  res+=thegame(pos+1,nums[pos])\n print(res)\n t-=1", "\ndef func(ind, g, dp, n, a): \n \n # Base case  \n if (ind == n):  \n  if (g == 1):  \n   return 1\n  else: \n   return 0\n \n # If already visited  \n if (dp[ind][g] != -1):  \n  return dp[ind][g] \n \n # Either we take or we do not  \n ans = (func(ind + 1, g, dp, n, a) + \n   func(ind + 1, gcd(a[ind], g),  \n        dp, n, a)) \n \n # Return the answer  \n dp[ind][g] = ans \n return dp[ind][g] \n \n \ndef countSubsequences(a, n):  \n \n # Hash table to memoize  \n dp = [[-1 for i in range(MAX)] \n    for i in range(n)] \n \n # Count the number of subsequences  \n count = 0\n \n # Count for every subsequence  \n for i in range(n):  \n  count += func(i + 1, a[i], dp, n, a) \n \n return count\nt=int(input())\nfrom math import gcd\nfor _ in range(t):\n n=int(input())\n l=list(map(int,input().split()))\n MAX=max(l)+1\n print(countSubsequences(l,n))\n", "import math\nMAX = 10001\n\ndef func(ind,g,n,dp,l):\n if ind==n:\n  if g==1:\n   return 1\n  else:\n   return 0\n \n if dp[ind][g]!=-1:\n  return dp[ind][g]\n \n ans = func(ind+1,g,n,dp,l)+func(ind+1,math.gcd(g,l[ind]),n,dp,l)\n \n dp[ind][g]=ans\n return dp[ind][g]\n\nfor _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n dp = [[-1 for _ in range(MAX)]for _ in range(n)]\n \n count = 0\n for i in range(n):\n  count+=func(i+1,l[i],n,dp,l)\n\n  \n print(count)", "# cook your dish here\nfor _ in range(int(input())):\n MAX = 10001\n def gcd(a, b):\n  if (a == 0):\n   return b\n  return gcd(b % a, a)\n\n\n # Recursive function to calculate the\n # number of subsequences with gcd 1\n # starting with particular index\n def func(ind, g, dp, n, a):\n  # Base case\n  if (ind == n):\n   if (g == 1):\n    return 1\n   else:\n    return 0\n\n  # If already visited\n  if (dp[ind][g] != -1):\n   return dp[ind][g]\n\n   # Either we take or we do not\n  ans = (func(ind + 1, g, dp, n, a) +\n    func(ind + 1, gcd(a[ind], g),\n     dp, n, a))\n\n  # Return the answer\n  dp[ind][g] = ans\n  return dp[ind][g]\n\n\n # Function to return the number\n # of subsequences\n def countSubsequences(a, n):\n  # Hash table to memoize\n  dp = [[-1 for i in range(MAX)]\n    for i in range(n)]\n\n  # Count the number of subsequences\n  count = 0\n\n  # Count for every subsequence\n  for i in range(n):\n   count += func(i + 1, a[i], dp, n, a)\n  return count\n\n\n # Driver Code\n N = int(input())\n a = [ int(x) for x in input().split()]\n print(countSubsequences(a, N))\n", "from math import gcd\n\ndef f(cp,cg):\n nonlocal n,arr\n \n if cp == n and cg == 1:\n  return 1\n elif cp == n:\n  return 0\n elif cg == 1:\n  return 2**(n-cp)\n elif (cp,cg) in d:\n  return d[(cp,cg)]\n else:\n  temp = f(cp+1,cg)+f(cp+1,gcd(arr[cp],cg))\n  d[(cp,cg)] = temp\n  return temp\n \n\n\nt = int(input())\n\nfor _ in range(t):\n n = int(input())\n arr = list(map(int, input().split()))\n \n d = {}\n ans = 0\n for i in range(n):\n  ans += f(i+1,arr[i])\n print(ans)", "from math import gcd\ndef rec_ans(cp, cg):\n nonlocal n,nl\n if cp == n and cg == 1:\n  return 1\n elif cp == n:\n  return 0\n elif cg == 1:\n  return 2**(n-cp)\n elif (cp,cg) in mem:\n  return mem[(cp,cg)]\n else:\n  temp = rec_ans(cp+1, gcd(cg,nl[cp])) + rec_ans(cp+1,cg)\n  mem[(cp,cg)] = temp\n  return temp\nfor _ in range(int(input())):\n n = int(input())\n nl = [int(x) for x in input().split()]\n mem = {}\n ans = 0\n for i in range(n):\n  ans += rec_ans(i+1,nl[i])\n print(ans)", "def gcd(a, b):\n return a if b == 0 else gcd(b, a % b)\n\ndef func(i, cur_gcd):\n if i == n:\n  return 1 if cur_gcd == 1 else 0\n if cur_gcd == 1:\n  return 2 ** (n - i)\n key = (i, cur_gcd)\n if key in d.keys():\n  return d[key]\n d[key] = func(i+1, cur_gcd) + func(i+1, gcd(cur_gcd, ls[i]))\n return d[key]\n\nfor _ in range(int(input())):\n n, res = int(input()), 0\n ls = list(map(int, input().split()))\n d = {}\n for i in range(n):\n  res += func(i+1, ls[i])\n print(res)", "def gcd(a, b):\n return a if b == 0 else gcd(b, a % b)\n\ndef func(i, cur_gcd):\n if i == n:\n  return 1 if cur_gcd == 1 else 0\n key = (i, cur_gcd)\n if key in d.keys():\n  return d[key]\n d[key] = func(i+1, cur_gcd) + func(i+1, gcd(cur_gcd, ls[i]))\n return d[key]\n\nfor _ in range(int(input())):\n n, res = int(input()), 0\n ls = list(map(int, input().split()))\n d = {}\n for i in range(n):\n  res += func(i+1, ls[i])\n print(res)", "def gcd(a,b):\n if b == 0:\n  return a\n return gcd(b,a%b)\n\n\nt = int(input())\nwhile t > 0:\n t = t-1\n n = int(input())\n L = list(map(int, input().split()))\n d = [1] + [0]*(10**4)\n for i in L:\n  for j in range(1,(10**4)+1):\n   if d[j]:\n    d[gcd(min(i,j),max(i,j))] += d[j]\n  d[i] += 1\n print(d[1])", "import math\nfrom _bisect import *\ndef factors(n):\n l = set()\n x = int(math.sqrt(n))\n for i in range(1,x+1):\n  if n%i==0:\n   l.add(i)\n   if n//i!=i:\n    l.add(n//i)\n return l\n \nfor T in range(int(input())):\n n = int(input())\n a = list(map(int,input().split()))\n divisors = set()\n for i in range(n):\n  divisors = divisors.union(factors(a[i]))\n divisors = list(divisors)\n divisors.sort()\n oneIndex = -1\n for i in range(len(divisors)):\n  if divisors[i] == 1:\n   oneIndex = i\n   break\n dp = [0 for x in range(len(divisors))]\n for i in range(n):\n  for j in range(len(divisors)):\n   x = 0\n   if a[i] == divisors[j]:\n    x = 1\n   y = math.gcd(a[i],divisors[j])\n   ind = bisect_left(divisors,y)\n   dp[ind] += (x + dp[j])\n print(dp[oneIndex])", "def gcd(a,b):\n if a == 0 or b == 0:\n  if a == 0:\n   return b\n  else:\n   return a\n else:\n  return gcd(b,a%b)\n\ndef thegame(pos,cgcd):\n if pos == n:\n  if cgcd == 1:\n   return 1\n  else:\n   return 0\n elif (pos,cgcd) in dp:\n  return dp[(pos,cgcd)]\n elif cgcd == 1:\n  p = 2**(n-pos)\n  dp[(pos,cgcd)] = p\n  return p\n else:\n  p = thegame(pos+1,gcd(cgcd,nums[pos])) + thegame(pos+1,cgcd)\n  dp[(pos,cgcd)] = p\n  return p\n\nt = int(input())\n\nwhile t>0:\n n = int(input())\n nums = list(map(int , input().split()))\n dp = {}\n res = 0\n for pos in range(0,n-1):\n  res+=thegame(pos+1,nums[pos])\n print(res)\n t-=1"]
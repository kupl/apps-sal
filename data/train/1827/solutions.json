["import math\n class Solution:\n     def smallestGoodBase(self, n):\n         n = int(n)\n         maxLength = int(math.log(n,2))\n         for m in range(maxLength, 1, -1):\n             k = int(n**m**-1)\n             if (k**(m+1) - 1)//(k - 1) == n:\n                 return str(k)\n         return str(n-1)\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         ", "#\n # [483] Smallest Good Base\n #\n # https://leetcode.com/problems/smallest-good-base/description/\n #\n # algorithms\n # Hard (33.74%)\n # Total Accepted:    6.7K\n # Total Submissions: 20K\n # Testcase Example:  '\"13\"'\n #\n # For an integer n, we call k>=2 a good base of n, if all digits of n base k\n # are 1.\n # Now given a string representing n, you should return the smallest good base\n # of n in string format.\n #\n # Example 1:\n #\n # Input: \"13\"\n # Output: \"3\"\n # Explanation: 13 base 3 is 111.\n #\n #\n #\n # Example 2:\n #\n # Input: \"4681\"\n # Output: \"8\"\n # Explanation: 4681 base 8 is 11111.\n #\n #\n #\n # Example 3:\n #\n # Input: \"1000000000000000000\"\n # Output: \"999999999999999999\"\n # Explanation: 1000000000000000000 base 999999999999999999 is 11.\n #\n #\n #\n # Note:\n #\n # The range of n is [3, 10^18].\n # The string representing n is always valid and will not have leading zeros.\n #\n #\n #\n from math import log\n class Solution:\n     def smallestGoodBase(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         num = int(n)\n         bit = int(log(num, 2))\n         for b in range(bit, 1, -1) :\n             base = int(num ** b ** -1)\n             # print(b, base)\n             if (base ** (b + 1) - 1) // (base - 1) == num :\n                 return str(base)\n         return str(num - 1)\n", "class Solution:\n     def smallestGoodBase(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         import math\n         n=int(n)\n         max_m=int(math.log2(n))\n         \n         for m in range(max_m,1,-1):\n             \n             k=int(n**(m**(-1)))\n             if n==(k**(m+1)-1)//(k-1):\n                return str(k)\n         return str(n-1)", "from math import log\n class Solution:\n     def smallestGoodBase(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         num = int(n)\n         \n         #use binary search the base\n         for size in range(int(log(num+1,2)), 1, -1):\n             #find the base\n             l,r = 2, int(pow(num, 1.0 / (size - 1)) +1)\n             while l<r:\n                 mid = l+(r-l)//2\n                 sum=0\n                 for i in range(size):\n                     sum=sum*mid+1\n                 if sum==num:\n                     return str(mid)\n                 elif sum<num:\n                     l=mid+1\n                 else:\n                     r=mid\n         return str(num-1)\n         \n     #           long long num = stol(n);\n     #     for (int i = log(num + 1) / log(2); i >= 2; --i) {\n     #         long long left = 2, right = pow(num, 1.0 / (i - 1)) + 1;\n     #         while (left < right) {\n     #             long long mid = left + (right - left) / 2, sum = 0;\n     #             for (int j = 0; j < i; ++j) {\n     #                 sum = sum * mid + 1;\n     #             }\n     #             if (sum == num) return to_string(mid);\n     #             else if (sum < num) left = mid + 1;\n     #             else right = mid;\n     #         }\n     #     }\n     #     return to_string(num - 1);\n     # }\n         ", "#\n # [483] Smallest Good Base\n #\n # https://leetcode.com/problems/smallest-good-base/description/\n #\n # algorithms\n # Hard (33.74%)\n # Total Accepted:    6.7K\n # Total Submissions: 20K\n # Testcase Example:  '\"13\"'\n #\n # For an integer n, we call k>=2 a good base of n, if all digits of n base k\n # are 1.\n # Now given a string representing n, you should return the smallest good base\n # of n in string format.\n #\n # Example 1:\n #\n # Input: \"13\"\n # Output: \"3\"\n # Explanation: 13 base 3 is 111.\n #\n #\n #\n # Example 2:\n #\n # Input: \"4681\"\n # Output: \"8\"\n # Explanation: 4681 base 8 is 11111.\n #\n #\n #\n # Example 3:\n #\n # Input: \"1000000000000000000\"\n # Output: \"999999999999999999\"\n # Explanation: 1000000000000000000 base 999999999999999999 is 11.\n #\n #\n #\n # Note:\n #\n # The range of n is [3, 10^18].\n # The string representing n is always valid and will not have leading zeros.\n #\n #\n #\n from math import log\n class Solution:\n     def smallestGoodBase(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         num = int(n)\n         bit = int(log(10, 2) * len(n) + 1)\n         while bit > 0 :\n             low, high = 2, int(num ** (1.0 / bit) + 1)\n             while low <= high :\n                 base = low + (high - low) // 2\n                 tmp = 0\n                 for _ in range(bit + 1) :\n                     tmp = tmp * base + 1\n                 # print(bit, low, high, base, tmp)\n                 if tmp == num :\n                     return str(base)\n                 elif tmp < num :\n                     low = base + 1\n                 else :\n                     high = base - 1\n             bit -= 1\n         return str(num - 1)\n", "class Solution(object):\n     def smallestGoodBase(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"        \n         num = int(n)\n         thisLen = int(math.log(num,2)) + 1\n         while thisLen > 2:\n             # from equation [3], we havve\n             thisBase = int(num ** (1.0/(thisLen - 1)))\n             # from equation [2], we have\n             if num * (thisBase - 1) == thisBase ** thisLen - 1:\n                 return str(thisBase)\n             thisLen -= 1\n         return str(num - 1)", "class Solution:\n     def smallestGoodBase(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         return self.use_binary_search(n)\n         \n     def use_math(self, n):\n         n = int(n)\n         max_m = int(math.log(n,2)) # Refer [7]\n         for m in range(max_m,1,-1):\n             k = int(n**m**-1)  # Refer [6]\n             if (k**(m+1)-1)//(k-1) == n:\n                 # Refer [3]\n                 return str(k)\n         \n         return str(n-1)  \n     \n     def use_binary_search(self, n):\n         n = int(n)\n         \n         for d in range(60, 0, -1):\n             if (1 << d) < n:\n                 base = self.binary_search(n, d)\n                 if base:\n                     return str(base)\n         \n         return str(n-1)\n     \n     def binary_search(self, n, d):\n         lo, hi = 1, int(pow(n, 1.0/d) + 1)\n         \n         while lo < hi:\n             mid = lo + (hi - lo) // 2\n             total = 1\n             for i in range(1, d+1):\n                 total += mid ** i\n             \n             if total == n:\n                 return mid\n             elif total < n:\n                 lo = mid + 1\n             else:\n                 hi = mid\n         \n         return 0"]
["class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n#         mine\n#         res = collections.defaultdict(list)\n#         res_return = []\n#         for i,j in enumerate(groupSizes):\n#             res[j].append(i)\n        \n#         for j in res:\n#             temp = [res[j][0:j]]\n#             if len(res[j])>j:\n#                 # print(j,res[j][1])\n#                 # sub_nums = int(len(res[j])/j)\n#                 for num in range(j,len(res[j]),j):\n#                     temp = temp + [res[j][num:num+j]]\n#                     # print(temp)\n#                 res[j]=temp\n#             res_return = res_return+temp\n#         # print(res)\n#         # print(res_return)\n#         return res_return\n\n        # other perple\n        groups = defaultdict(list)\n        result = []\n        for index, size in enumerate(groupSizes):\n            groups[size].append(index)\n            if len(groups[size]) == size:\n                result.append(groups.pop(size))\n        return result", "from collections import defaultdict\nclass Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        d=defaultdict(list)\n        for i in range(len(groupSizes)):\n            d[groupSizes[i]].append(i)\n        ans=[]\n        for i in range(1,max(groupSizes)+1):\n            if i in d:\n                for j in range(0,len(d[i]),i):\n                    ans.append(d[i][j:j+i])\n        return ans\n        \n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        sizes = {}\n        for i, a in enumerate(groupSizes):\n            if a in sizes:\n                sizes[a].append(i)\n            else:\n                sizes[a] = [i]\n        result = []\n        \n        for key in sizes.keys():\n            if len(sizes[key]) % key == 0:\n                result.extend([sizes[key][i*key:(i+1)*key] for i in range(len(sizes[key])//key)])\n        # print(sizes)\n        return result", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        \n        \n        # imput: [3,3,3,3,3,3,1]\n        # output: [[0,1,2],[3,4,5],[6]]\n\n        def group_by_size(size_list: List[int]) -> List[List[int]]: # [3,3,3,3,3,3,1]\n            if size_list == []:\n                return []\n            if size_list is None:\n                raise ValueError(\\\"bad input..\\\")\n            ans_list, count_dict = [], {} #  [[0, 1, 2], ], {}\n            for i, num in enumerate(size_list):\n                if num == 0:\n                    raise ValueError(\\\"group size has to be larger then 0\\\")\n                if not num in count_dict:\n                    count_dict[num] = [i]\n                else:\n                    count_dict[num].append(i)\n                if len(count_dict[num]) == num:\n                    ans_list.append(count_dict[num])\n                    del count_dict[num]\n            if len(count_dict) > 0:\n                raise ValueError(\\\"some elements have bad values\\\")\n            return ans_list\n        \n        return group_by_size(groupSizes)\n            \n        ", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        out =[]\n        temp=[]\n        if len(groupSizes)>1:\n            for each in range(len(groupSizes)):\n                if type(groupSizes[each]) == int:\n                    temp.append(each)\n                    while len(temp) != groupSizes[each]:\n                        for every in range(each+1,len(groupSizes)):\n                            if groupSizes[each]==groupSizes[every]:\n                                temp.append(every)\n                                groupSizes[every]= \\\"x\\\"\n                                break\n                    out.append(temp)\n                    temp=[]\n        else:\n            return [[0]]\n        return out\n                    \n            ", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        group_sizes_dict = {}\n        ret_groups = []\n        \n        for i in range(len(groupSizes)):\n            if groupSizes[i] not in group_sizes_dict:\n                group_sizes_dict[groupSizes[i]] = [i]\n            else:\n                group_sizes_dict[groupSizes[i]].append(i)\n                       \n        keys = sorted(group_sizes_dict.keys())\n        \n        for i in keys:\n            tmp_list = group_sizes_dict[i]\n            print(tmp_list)\n            to_add = []\n            \n            for j in range(len(tmp_list)):\n                if (j+1) % i == 0:\n                    to_add.append(tmp_list[j])\n                    ret_groups.append(to_add)\n                    to_add = []\n                else:\n                    to_add.append(tmp_list[j])\n                    \n                \n        return ret_groups\n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        restrictions = {}\n        \n        for unique_id in range(len(groupSizes)):\n            group_size = groupSizes[unique_id]\n            if group_size in restrictions:\n                restrictions[group_size].append(unique_id)\n            else:\n                restrictions[group_size] = [unique_id]\n            \n        res = []\n        \n        for group_size in restrictions:\n            unique_ids = restrictions[group_size]\n            for i in range(0, len(unique_ids), group_size):\n                res.append(unique_ids[i:i+group_size])\n        return res", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = {}\n        for i in range(0,len(groupSizes)):\n            if groupSizes[i] in groups:\n                groups[groupSizes[i]].append(i)\n            else:\n                groups[groupSizes[i]] = [i]\n        #print(groups)\n        \n        output = []\n        for i in groups:\n            list1 = []\n            for j in groups[i]:\n                list1.append(j)\n                if(len(list1) == i):\n                    output.append(list1)\n                    list1 = []\n                    \n        return output\n                    \n                \n                \n        \ndef main():\n    groupSizes = input().split()\n    sol = Solution()\n    output = sol.groupThePeople(groupSizes)\n    print(output)\n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = {}\n        output = []\n\n        for i in range(len(groupSizes)):\n            belongGroupCount = groupSizes[i]\n            # print(f'group: {belongGroupCount} | person i: {i}')\n\n            existingGroup = groups.get(belongGroupCount)\n            # print(f'existing: {groups}, belong: {belongGroupCount}')\n            if existingGroup is None:\n                groups[belongGroupCount] = []\n                existingGroup = groups.get(belongGroupCount)\n\n            existingGroup.append(i)\n            if len(existingGroup) == belongGroupCount:\n                output.append(existingGroup)\n                groups[belongGroupCount] = []\n            else:\n                groups[belongGroupCount] = existingGroup\n\n        return output", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        size_map = {}\n        for idx, group_size in enumerate(groupSizes):\n            if group_size not in size_map:\n                size_map[group_size] = [[idx]]\n            else:\n                for group_list in size_map[group_size]:\n                    if len(group_list) < group_size:\n                        group_list.append(idx)\n                        break\n                else:\n                    # new group list\n                    size_map[group_size].append([idx])\n        ret = []\n        for k, v in list(size_map.items()):\n            ret.extend(v)\n        return ret\n", "import collections\nclass Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        \n        d = collections.defaultdict(list)\n        out = []\n        \n        for i,ele in enumerate(groupSizes):\n            \n            d[ele].append(i)\n            print(d)\n            if len(d[ele]) == ele:\n                    out.append(d[ele])\n                    del d[ele]\n        return out\n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = {}\n        \n        for person, group_size in enumerate(groupSizes):\n            if group_size not in groups:\n                groups[group_size] = [[person]]\n            else:\n                for c_group in groups[group_size]:\n                    if len(c_group) < group_size:\n                        c_group.append(person)\n                        break\n                else:\n                    groups[group_size].append([person])\n        \n        \n        res = []\n        \n        [res.extend(v) for v in groups.values()]\n        \n        return res\n                    \n        \n    \n    \n\\\"\\\"\\\"\n\n{\n    <size>: [[], []]\n}\n\n\n\\\"\\\"\\\"", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        smap = {}\n        for i, s in enumerate(groupSizes):\n            if s in smap:\n                smap[s].append(i)\n            else:\n                smap[s] = [i]\n        \n        res = []\n        for k, v in list(smap.items()):\n            for i in range(0, len(v), k):\n                # print(i, i+k)\n                res.append(v[i:i+k])\n                p = i\n        return res\n                \n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        n = len(groupSizes)\n        done = [False for _ in range(n)]\n        groups = []\n        for i in range(n):\n            if done[i]:\n                continue\n                \n                \n            numInThisGroup = groupSizes[i]\n            peopleInThisGroup = []\n            for j in range(n):\n                if not done[j] and groupSizes[j] == numInThisGroup:\n                    peopleInThisGroup.append(j)\n                    if len(peopleInThisGroup) == numInThisGroup:\n                        break\n                        \n            groups.append(peopleInThisGroup)\n            for person in peopleInThisGroup:\n                done[person] = True\n                \n        return groups", "import numpy as np\nclass Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        c = set(groupSizes)\n        cn=[]\n        for i in c:\n            newlist = [j for j, val in enumerate(groupSizes) if val==i]\n            if(len(newlist)>i):\n               # n = int(len(newlist)/i)\n                newlist = [newlist[j:j + i] for j in range(0,   len(newlist), i)]\n                cn.extend(newlist)\n            else:\n                cn.append(newlist)\n        return cn\n            \n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        \n        group_dict = dict()\n        \n        for i in groupSizes:            \n            if i in group_dict:\n                group_dict[i] += 1            \n            else:\n                group_dict[i] = 1\n        \n        for i in group_dict.keys():            \n            group_dict[i] = int(group_dict[i]/i)\n            \n        group_lists = dict()\n        \n        for i in group_dict.keys():     \n            group_lists[i] = [[] for i in range(group_dict[i])]\n            \n        \n        for i in range(len(groupSizes)):\n            val = groupSizes[i]\n            l = group_lists[val] \n            j = 0            \n            while(len(l[j]) == val):\n                j = j+1\n            \n            l[j].append(i)\n        \n        result = []\n        \n        for i in group_lists.keys():\n            result.extend(group_lists[i])\n        \n        return result", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        memory = {}\n        for i, el in enumerate(groupSizes):\n            if el not in memory:\n                memory[el] = [[i]]\n            else:\n                next_available = None\n                for j in range(len(memory[el])):\n                    if len(memory[el][j]) < el:\n                        next_available = j\n\n                if next_available is None:\n                    memory[el].append([i])\n                else:\n                    memory[el][next_available].append(i)\n\n        res = []\n        for groups in memory.values():\n            res.extend(groups)\n        return res", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:        \n        ret_lst = []\n        for iGrpSize in range(len(groupSizes),0,-1):\n            if iGrpSize in groupSizes:\n                ppl = []\n                for i in range(len(groupSizes)):\n                    if groupSizes[i] == iGrpSize:\n                        ppl.append(i)\n\n                if len(ppl) > iGrpSize:\n                    for i in range(0,len(ppl), iGrpSize):                        \n                        ret_lst.append(ppl[i:i+iGrpSize])\n                else:\n                    ret_lst.append(ppl)\n        return ret_lst", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        output = []\n        subgroup = []\n        count = 0\n        leng = len(groupSizes)\n        subsize = 0\n\n        while count < leng:\n            size = min(groupSizes)\n            while size in groupSizes:\n                ind = groupSizes.index(size)\n                subgroup.append(ind)\n                groupSizes[ind] = 501\n                count += 1\n                subsize += 1\n\n                if subsize % size == 0:\n                    output.append(subgroup)\n                    subgroup = []\n                    subsize = 0\n\n            subgroup = []\n        return output", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        res = []\n        d = collections.defaultdict(list)\n        for i in range(len(groupSizes)):\n            d[groupSizes[i]].append(i)\n            if len(d[groupSizes[i]]) == groupSizes[i]:\n                res.append(d[groupSizes[i]])\n                d[groupSizes[i]]=[]\n        \n        return res", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        dic = {}\n        res = []\n        for i in range(len(groupSizes)):\n            if groupSizes[i] == 1:\n                res.append([i])\n                continue\n            if groupSizes[i] in dic:\n                dic[groupSizes[i]].append(i)\n            else:\n                dic[groupSizes[i]] = [i]\n            if len(dic[groupSizes[i]]) == groupSizes[i]:\n                res.append(dic[groupSizes[i]])\n                dic[groupSizes[i]] = []\n\n        return res\n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        d = dict(enumerate(groupSizes))\n        d = {k: v for k, v in sorted(list(d.items()), key=lambda item: item[1])}\n        a = []\n        b = []\n\n        tmp = next(iter(list(d.values())))\n        for k,v in list(d.items()):\n            if tmp == v and (len(a) < v):\n                a+=[k]\n            else:\n                b.append(a)\n                a = []\n                a+= [k]\n            if k == (list(d.keys())[-1]):\n                b.append(a)\n            tmp = v\n        return b\n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = []\n        sizes = {}\n        for i in range(len(groupSizes)):\n            if groupSizes[i] not in sizes:\n                sizes[groupSizes[i]] = [i]\n            else:\n                sizes[groupSizes[i]].append(i)\n        \n        for (size, group) in list(sizes.items()):\n            for i in range(0, len(group), size):\n                groups.append(group[i:i+size])\n            \n        return groups\n           \n", "class Solution:\n    def groupThePeople(self, gr: List[int]) -> List[List[int]]:\n        \n        res=[]\n        \n        for i in range(len(gr)):\n            count=gr[i]\n            if(count!=0):\n                temp=[]\n                for j in range(len(gr)):\n                    for k in range(count):\n                        if(gr[j]==count):\n                            temp.append(j)\n                            gr[j]=0\n                        if(len(temp)==count):\n                            res.append(temp)\n                            temp=[]\n                if(len(temp)!=0):\n                    res.append(temp)\n        return res", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        l = len(groupSizes)\n        key = {}\n        ans=[]\n        for i in range (l):\n            now = groupSizes[i]\n            if now not in key.keys():                \n                    key[now]=[]\n                    key[now].append(i)     \n            else:\n                if len(key[now])!=now:\n                    key[now].append(i)\n                else:\n                    ans.append(key[now])\n                    key[now]=[]\n                    key[now].append(i)\n        for i in key.keys():\n            if key[i] not in ans:\n                ans.append(key[i])\n                continue\n            \n                \n            \n        return ans", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        res = []\n        dic = {}\n        for idx, size in enumerate(groupSizes):\n            if size == 1:\n                res.append([idx])\n            elif size > 1:\n                if size not in dic:\n                    dic[size] = [idx]\n                else:\n                    dic[size].append(idx)\n                    if len(dic[size]) == size:\n                        res.append(dic[size])\n                        del dic[size]\n        return res\n                    \n                \n                \n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = {}\n        for id, size in enumerate(groupSizes):\n            if size not in groups:\n                groups[size] = [[id]]\n            else:\n                lastGroup = groups[size][-1]\n                if len(lastGroup) != size:\n                    groups[size][-1] += [id]\n                else:\n                    groups[size] += [[id]]\n        flatList = []\n        for k,v in list(groups.items()):\n            flatList += v\n        return flatList\n", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        \n        groups = []\n        cache = {}\n        \n        for i in range(len(groupSizes)):\n            if groupSizes[i] not in cache:\n                cache[groupSizes[i]] = []\n                \n            if len(cache[groupSizes[i]]) < groupSizes[i]:\n                cache[groupSizes[i]].append(i)\n            \n            if len(cache[groupSizes[i]]) == groupSizes[i]:\n                groups.append(cache[groupSizes[i]])\n                cache.pop(groupSizes[i])\n                \n        return groups", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        d={}\n        res=[]\n        for i in range(len(groupSizes)):\n            d[groupSizes[i]]=d.setdefault(groupSizes[i],[])+[i]\n        \n        for x,y in d.items():\n            for j in range(0,len(y),x):\n                res.append(y[j:j+x])  \n        \n        return res", "class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        groups = sorted(list(enumerate(groupSizes)), key=lambda x: x[1])\n        # return groups\n        out = []\n        while groups:\n            last_group_idx = -groups[-1][1]\n            out.append([t[0] for t in groups[last_group_idx:]])\n            groups = groups[:last_group_idx]\n            \n        return out\n", "from collections import defaultdict\n\n\nclass Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        all_groups = list()\n        assignments = defaultdict(list)\n\n        for i, size in enumerate(groupSizes):\n            assignments[size].append(i)\n\n        return [people[i:i+size] for size, people in list(assignments.items()) for i in range(0, len(people), size)]\n"]
["class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        n = len(books)\n        dp = [inf] * (n+1)\n        dp[0] = 0\n        ret = inf\n        for i in range(1, n+1):\n            mx = 0\n            cur = 0\n            for j in range(i, 0, -1):\n                cur += books[j-1][0]\n                if cur > shelf_width:\n                    break\n                mx = max(mx, books[j-1][1])\n                dp[i] = min(dp[i], dp[j-1] + mx)\n        return dp[-1]\n", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        dp = [0]*(len(books)+1)\n        for i in range(len(books)):\n            maxheight = books[i][1]\n            height = dp[i] + books[i][1]\n            width = books[i][0]\n            j = i-1\n            while j >= 0 and width + books[j][0] <= shelf_width:\n                maxheight = max(maxheight,books[j][1])\n                width += books[j][0]\n                height = min(height,dp[j]+maxheight)\n                j -= 1\n            dp[i+1] = height\n        print(dp)\n        return dp[-1]\n", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        if not books:\n            return 0\n        h = [0]\n        current = 0\n        while current < len(books):\n            w = books[current][0]\n            f = current\n            c_h = books[current][1]\n            h_i = float('inf')\n            while w <= shelf_width and f >=0:\n                \n                h_i = min(c_h + h[f], h_i) \n                if f == 0:\n                    break\n                f-=1\n                w+= books[f][0]\n                c_h = max(c_h, books[f][1])\n            h.append(h_i)\n            \n            current += 1\n\n        return h[-1]\n        \n", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        n = len(books)\n        heights = [0 for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            width  = books[i-1][0]\n            height = books[i-1][1]\n            heights[i] = heights[i-1] + height\n            j = i-1\n            while j > 0 and width + books[j-1][0] <= shelf_width:\n                height = max(height, books[j-1][1])\n                width+=books[j-1][0]\n                heights[i] = min(heights[i], heights[j-1] + height)\n                j-=1\n        print(f'{heights}')\n        return heights[-1]\n", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        # Index 0 is for 0 books\n        subsoln = [0 for _ in range(len(books) + 1)]\n        \n        for prev_idx, (w, h) in enumerate(books):\n            cur_idx = prev_idx + 1\n            subsoln[cur_idx] = subsoln[prev_idx] + h\n            \n            cur_w = w\n            cur_h = h\n            # Take book from previous shelf and see if it's better.\n            while prev_idx >= 1 and cur_w + books[prev_idx-1][0] <= shelf_width:\n                cur_h = max(cur_h, books[prev_idx-1][1])\n                cur_w += books[prev_idx-1][0]\n                subsoln[cur_idx] = min(subsoln[cur_idx], subsoln[prev_idx-1] + cur_h)\n                prev_idx -= 1\n        print(subsoln)\n            \n            \n        return subsoln[-1]", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        \n        books_len = len(books)\n        \n        @lru_cache(None)\n        def dp(i):\n            if i == books_len:\n                return 0\n            \n            width, height, result = 0, 0, float('inf')\n            \n            while i < books_len and width <= shelf_width:\n                width += books[i][0]\n                height = max(height, books[i][1])\n                if width <= shelf_width:\n                    result = min(result, height + dp(i+1))\n                i += 1\n            \n            return result\n        \n        return dp(0)", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        @lru_cache(None)\n        def dp(i):\n            if i == 0: return books[0][1]                        \n            max_height, thickness, ans = -float('inf'), 0, float('inf')            \n            for j in range(i, -1, -1):\n                t, h = books[j]\n                if thickness + t <= shelf_width:\n                    thickness += t\n                    max_height = max(max_height, h)                                    \n                    ans = min(ans, (dp(j-1) + max_height) if j > 0 else max_height)\n                else: break\n            return ans                \n        n = len(books)\n        for i in range(n): dp(i)\n        return dp(n-1)", "\\\"\\\"\\\"\n\n\\\"\\\"\\\"\n\nclass Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        \n        books_len = len(books)\n        \n        @lru_cache(None)\n        def dp(i):\n            if i == books_len:\n                return 0\n            \n            width, height = 0, 0\n            \n            result = []\n            \n            while i < books_len and width <= shelf_width:\n                width += books[i][0]\n                height = max(height, books[i][1])\n                if width <= shelf_width:\n                    result.append(height + dp(i+1))\n                i += 1\n            \n            return min(result)    \n        \n        return dp(0)", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], sw: int) -> int:\n        n = len(books)\n        mem = [None] * (n + 1)\n        mem[-1] = 0\n        \n        def f(pos):\n            if mem[pos] is not None:\n                return mem[pos]\n            \n            w, h = 0, 0\n            value = float('inf')\n            \n            for i in range(pos, n):\n                w += books[i][0]\n                h = max(h, books[i][1])\n                if w > sw:\n                    break\n                value = min(value, f(i + 1) + h)\n            \n            mem[pos] = value\n            return mem[pos]\n            \n        \n        return f(0)", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        memo = [float('inf')] * (len(books)+1)\n        memo[0] = 0\n        \n        for i in range(len(books)):\n            width = shelf_width\n            height = 0 \n            j = i\n            # to determine the minimum height up to the ith book, \n            # we need te examine all possible books which in the same level as the ith book up to the ith book\n            # the later books which may be in the same level as the ith book will be examined later when it is introduced.\n            while j >=0 and width - books[j][0]>=0:      \n                width -= books[j][0]\n                height = max(height, books[j][1])\n                memo[i+1] = min(memo[i+1], memo[j]+height)\n                j -= 1\n        \n        return memo[-1]", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        # n = len(books)\n        # @lru_cache(None)\n        # def dfs(i, w, h):\n        #     if i >= n:\n        #         return h\n        #     return min(h + dfs(i + 1, books[i][0], books[i][1]), float('inf') if w + books[i][0] > shelf_width else dfs(i + 1, w + books[i][0], max(h, books[i][1])))\n        # return dfs(0, 0, 0)\n        \n        n = len(books)\n        dp = [0] + [float('inf')] * n\n        for p in range(1, n + 1):\n            i = p\n            w = h = 0\n            while i > 0 and w + books[i-1][0] <= shelf_width:\n                w += books[i-1][0]\n                h = max(h, books[i-1][1])\n                dp[p] = min(dp[p], dp[i-1] + h)\n                i -= 1\n        return dp[-1]\n        \n        \n        # n = len(books)\n        # dp = [0] + [float('inf')] * n\n        # for p in range(1, n + 1):\n        #     i = p\n        #     w = h = 0\n        #     while i > 0 and w + books[i-1][0] <= shelf_width:\n        #         w += books[i-1][0]\n        #         h = max(h, books[i-1][1])\n        #         dp[p] = min(dp[p], dp[i-1]+h)\n        #         i -= 1\n        # return dp[-1]\n        \n        # n = len(books)\n        # @lru_cache(None)\n        # def dfs(i, w, h):\n        #     if i >= n:\n        #         return h\n        #     return min(h + dfs(i + 1, books[i][0], books[i][1]), float('inf') if w + books[i][0] > shelf_width else dfs(i + 1, w + books[i][0], max(h, books[i][1])))\n        # return dfs(0, 0, 0)\n    \n                \n            \n", "import math\nclass Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        n = len(books)\n        dp = [math.inf]*(n+1)\n        dp[0] = 0\n        for i in range(1,n+1):\n            max_width = shelf_width\n            max_height = 0\n            j = i-1\n            while j>=0 and max_width - books[j][0] >= 0:\n                max_width -= books[j][0]\n                max_height = max(max_height, books[j][1])\n                dp[i] = min(dp[i], dp[j] + max_height)\n                j -= 1\n        return dp[n]", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        self.shelf = defaultdict(list)\n        \n        @lru_cache(None)\n        def helper(i):\n            if i == len(books):\n                return 0\n            \n            width = 0\n            height = 0\n            out = float('inf')            \n            \n            while width < shelf_width and i < len(books):\n                w,h = books[i]                \n                width += w\n                \n                if width > shelf_width: # went over when added this new book\n                    break\n                    \n                # max height of this shelf with new book added\n                height = max(height, h) \n                \n                # see how much the total height others are if we include the new book\n                # in this shelf\n                others = helper(i+1) \n                \n                # if height of current shelf+ total height of other books is minimum\n                # save it.\n                out = min(height+others, out) \n                i+= 1\n            return out\n        \n        out = helper(0)\n        return out\n            \n            \n", "def go_bf(i, books, curr_width, ch, shelf_width):\n    if i == len(books):\n        return 0\n\n    w,h = books[i][0], books[i][1]\n    best_h = float(\\\"inf\\\")\n    if curr_width + w <= shelf_width:\n        # if we add higher then we pay, is smaller then it's for free\n        diff = max(h - ch, 0)   \n        best_h = diff + go_bf(i+1, books, curr_width + w, ch, shelf_width)\n    best_h = min(best_h, h + min(best_h, go_bf(i+1, books, w, h, shelf_width)))\n    return best_h\n\ndef go_memo(i, books, curr_width, ch, shelf_width, memo):\n    if i == len(books):\n        return 0\n\n    if memo[i][curr_width] == -1:\n        w,h = books[i][0], books[i][1]\n        best_h = float(\\\"inf\\\")\n        if curr_width + w <= shelf_width:\n            # if we add higher then we pay, is smaller then it's for free\n            diff = max(h - ch, 0)   \n            best_h = diff + go_memo(i+1, books, curr_width + w, ch + diff, shelf_width, memo)\n        best_h = min(best_h, h + min(best_h, go_memo(i+1, books, w, h, shelf_width, memo)))\n        memo[i][curr_width] = best_h\n    return memo[i][curr_width]\n\nclass Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        memo = [[-1] * (shelf_width + 1) for _ in range(len(books))]\n        return go_memo(0, books, 0, 0, shelf_width, memo)", "min_high_dict = {}\n\ndef minHigh( cw, mw, arr, ch):\n    \n    try:\n        if min_high_dict[str(cw) +\\\" \\\" + str(len(arr))] != None:\n            return min_high_dict[str(cw) +\\\" \\\" + str(len(arr))] \n    except KeyError:\n        pass\n    \n    if len(arr) == 0:\n        return ch\n    \n    elif cw == mw:\n        re = max( arr[0][1], minHigh( cw-arr[0][0], mw, arr[1:], arr[0][1]))\n    \n    elif cw >= arr[0][0]:\n        re1 = max( max(ch,arr[0][1]), minHigh( cw - arr[0][0], mw, arr[1:], max(ch,arr[0][1])))\n        re2 = ch + minHigh( mw - arr[0][0], mw, arr[1:], arr[0][1])\n        re = min( re1, re2)\n    \n    else:\n        re = ch + minHigh( mw - arr[0][0], mw, arr[1:], arr[0][1])\n    \n    min_high_dict[str(cw) +\\\" \\\" + str(len(arr))] = re\n    return re\n    \nclass Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        min_high_dict.clear()\n        return minHigh( shelf_width, shelf_width, books, 0)", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        \n        # chanllenge is when to switch to new level\n        \n        def naive(books, shelf_width, remain=None):\n            if remain is None:\n                remain = shelf_width\n            shelf = []\n            shelves = [shelf]\n            for w,h in books:\n                cur_w = sum(x for x,y in shelf)\n                cur_h = max((y for x,y in shelf), default=0)\n                added = False\n                # print((w,h), cur_w, cur_h)\n                if cur_w + w <= shelf_width:\n                    if cur_h > 0 and h - cur_h >= 2:  # do some lookahead\n                        pass\n                    else:\n                        shelf.append((w,h))\n                        added = True\n                if not added:\n                    shelf = [(w,h)]\n                    shelves.append(shelf)\n                # print('levels:', len(shelves), sum(max((y for x,y in s), default=0) for s in shelves), shelves)\n            return sum(max(y for x,y in s) for s in shelves)\n        \n        return naive(books, shelf_width)\n        \n        \n    def minHeightShelves1(self, books: List[List[int]], shelf_width: int) -> int:\n        # put the highest books first\n        pass\n    \n    \n    # https://leetcode.com/problems/filling-bookcase-shelves/discuss/323350/Python-Clean-DP-Solution-2D-Knapsack\n    # It's a kind of 2D knapsack problem.\n    # The core recurrence function is dp[i+1] = min(dp[k] + h for k in {j+1,...,i}).\n\n    # j is the furthest index that {books[j+1],...,books[i]} can be placed in one row.\n    # It depends on the widths of those books. books[j] can't be placed into the same row with books[i]\n    # otherwise the width would exceed the shelf_width.\n    # k is each candidate index that {{books[k],...,books[i]}} are proposed to be placed in the same row.\n    # h is the maximum height among {books[k],...,books[i]}.\n\n    def minHeightShelves(self, books, shelf_width):\n        def height(i, j):\n            return max(books[x][1] for x in range(i,j))\n            \n        dp = [0]\n        for i in range(len(books)):\n            w, j = books[i][0], i\n            while j >= 0 and w <= shelf_width:     # find out j, so w should be ahead of j\n                j -= 1\n                w += books[j][0] \n            dp.append(min(dp[k] + height(k,i+1) for k in range(j+1,i+1)))\n        return dp[-1]", "class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        nums = len(books)\n        dp = [0 for _ in range(nums+1)]\n        for i in range(nums):\n            height = books[i][1]\n            width = books[i][0]\n            dp[i+1] = dp[i] + height\n            for j in range(i)[i::-1]:\n                print(i,j)\n                if width + books[j][0] <= shelf_width:\n                    height  = max(height, books[j][1])\n                    dp[i+1]= min(height + dp[j], dp[i+1])    \n                    width = width + books[j][0]\n                else:\n                    break\n            print(f\\\"ans{dp[i+1]}\\\")\n        return dp[-1]\n                \n            "]
["def main():\n    def countchildren(graph,vert,memo,pard=None):\n        dumi=0\n        for child in graph[vert]:\n            if child!=pard:\n                if len(graph[child])==1:\n                    memo[child]=0\n                else:\n                    memo[child]=countchildren(graph,child,memo,vert)[0]\n                dumi+=memo[child]+1\n        return((dumi,memo))\n    n=int(input())\n    neigh=[]\n    for i in range(n):\n        neigh.append([])\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        neigh[a-1].append(b-1)\n        neigh[b-1].append(a-1)\n    same=1\n    layer=[0]\n    pars=[None]\n    j=0\n    while layer!=[]:\n        j+=1\n        newlayer=[]\n        newpars=[]\n        for i in range(len(layer)):\n            for vert in neigh[layer[i]]:\n                if vert!=pars[i]:\n                    newlayer.append(vert)\n                    newpars.append(layer[i])\n        layer=newlayer\n        pars=newpars\n        if j%2==0:\n            same+=len(layer)\n    bipartite=same*(n-same)\n    info=countchildren(neigh,0,[None]*n)[1]\n    dist=0\n    for guy in info:\n        if guy!=None:\n           dist+=(guy+1)*(n-guy-1)\n    print((dist+bipartite)//2)\n\nimport sys\nimport threading\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "def main():\n    def countchildren(graph,vert,memo,pard=None):\n        dumi=0\n        for child in graph[vert]:\n            if child!=pard:\n                if len(graph[child])==1:\n                    memo[child]=0\n                else:\n                    memo[child]=countchildren(graph,child,memo,vert)[0]\n                dumi+=memo[child]+1\n        return((dumi,memo))\n    n=int(input())\n    neigh=[]\n    for i in range(n):\n        neigh.append([])\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        neigh[a-1].append(b-1)\n        neigh[b-1].append(a-1)\n    same=1\n    layer=[0]\n    pars=[None]\n    j=0\n    while layer!=[]:\n        j+=1\n        newlayer=[]\n        newpars=[]\n        for i in range(len(layer)):\n            for vert in neigh[layer[i]]:\n                if vert!=pars[i]:\n                    newlayer.append(vert)\n                    newpars.append(layer[i])\n        layer=newlayer\n        pars=newpars\n        if j%2==0:\n            same+=len(layer)\n    bipartite=same*(n-same)\n    info=countchildren(neigh,0,[None]*n)[1]\n    dist=0\n    for guy in info:\n        if guy!=None:\n           dist+=(guy+1)*(n-guy-1)\n    print((dist+bipartite)//2)\n\nimport sys\nimport threading\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nimport threading\nsys.setrecursionlimit(2097152)\n\ndef main():\n    def countchildren(graph,vert,memo,pard=None):\n        dumi=0\n        for child in graph[vert]:\n            if child!=pard:\n                if len(graph[child])==1:\n                    memo[child]=0\n                else:\n                    memo[child]=countchildren(graph,child,memo,vert)[0]\n                dumi+=memo[child]+1\n        return((dumi,memo))\n    n=int(input())\n    neigh=[]\n    for i in range(n):\n        neigh.append([])\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        neigh[a-1].append(b-1)\n        neigh[b-1].append(a-1)\n    same=1\n    layer=[0]\n    pars=[None]\n    j=0\n    while layer!=[]:\n        j+=1\n        newlayer=[]\n        newpars=[]\n        for i in range(len(layer)):\n            for vert in neigh[layer[i]]:\n                if vert!=pars[i]:\n                    newlayer.append(vert)\n                    newpars.append(layer[i])\n        layer=newlayer\n        pars=newpars\n        if j%2==0:\n            same+=len(layer)\n    bipartite=same*(n-same)\n    info=countchildren(neigh,0,[None]*n)[1]\n    dist=0\n    for guy in info:\n        if guy!=None:\n           dist+=(guy+1)*(n-guy-1)\n    print((dist+bipartite)//2)\n \nthreading.stack_size(134217728)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nimport threading\nsys.setrecursionlimit(2100000)\n\ndef main():\n    def counter(graph,vert,memo,pard=None):\n        d = 0\n        for c in graph[vert]:\n            if c!=pard:\n                if len(graph[c])==1:\n                    memo[c]=0\n                else:\n                    memo[c]=counter(graph, c, memo, vert)[0]\n                d += memo[c]+1\n        return((d, memo))\n\n    n=int(input())\n    vizinhos=[]\n\n    for _ in range(n):\n        vizinhos.append([])\n\n    for _ in range(n-1):\n        i, j=map(int, input().split())\n        vizinhos[i-1].append(j-1)\n        vizinhos[j-1].append(i-1)\n\n    same=1\n    layer=[0]\n    par=[None]\n    j=0\n    while layer:\n        j+=1\n        n_layer=[]\n        n_pars=[]\n        for i in range(len(layer)):\n            for vert in vizinhos[layer[i]]:\n                if vert!=par[i]:\n                    n_layer.append(vert)\n                    n_pars.append(layer[i])\n        layer=n_layer\n        par=n_pars\n        if j%2==0:\n            same+=len(layer)\n    bipartite = same*(n-same)\n    info=counter(vizinhos,0,[None]*n)[1]\n    dist=0\n    for g in info:\n        if g!=None:\n           dist += (g+1)*(n-g-1)\n    print((dist+bipartite)//2)\n \nthreading.stack_size(140000000)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nimport threading\nsys.setrecursionlimit(2100000)\n\ndef main():\n    def counter(graph,vert,memo,pard=None):\n        d = 0\n        for c in graph[vert]:\n            if c!=pard:\n                if len(graph[c])==1:\n                    memo[c]=0\n                else:\n                    memo[c]=counter(graph, c, memo, vert)[0]\n                d += memo[c]+1\n        return((d, memo))\n\n    n=int(input())\n    vizinhos=[]\n\n    for _ in range(n):\n        vizinhos.append([])\n\n    for _ in range(n-1):\n        i, j=map(int, input().split())\n        vizinhos[i-1].append(j-1)\n        vizinhos[j-1].append(i-1)\n\n    same=1\n    layer=[0]\n    par=[None]\n    j=0\n    while layer:\n        j+=1\n        n_layer=[]\n        n_pars=[]\n        for i in range(len(layer)):\n            for vert in vizinhos[layer[i]]:\n                if vert!=par[i]:\n                    n_layer.append(vert)\n                    n_pars.append(layer[i])\n        layer=n_layer\n        par=n_pars\n        if j%2==0:\n            same+=len(layer)\n    bipartite = same*(n-same)\n    info=counter(vizinhos,0,[None]*n)[1]\n    dist=0\n    for g in info:\n        if g!=None:\n           dist += (g+1)*(n-g-1)\n    print((dist+bipartite)//2)\n \nthreading.stack_size(140000000)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()"]
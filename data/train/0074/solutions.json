["def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n, k = read_ints()\n    p = []\n    for i in range(n):\n        ai, bi = read_ints()\n        p.append((bi, ai, i + 1))\n    p.sort()\n    dp = [[0 for j in range(k + 1)] for i in range(n + 1)]\n    use = [[False for j in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            if i - 1 >= j:\n                dp[i][j] = dp[i - 1][j] + (k - 1) * p[i - 1][0]\n            if j > 0:\n                x = dp[i - 1][j - 1] + (j - 1) * p[i - 1][0] + p[i - 1][1]\n                if x > dp[i][j]:\n                    dp[i][j] = x\n                    use[i][j] = True\n    used = []\n    curr = k\n    for i in range(n, 0, -1):\n        if use[i][curr]:\n            used.append(p[i - 1][2])\n            curr -= 1\n    used.reverse()\n    seq = used[:-1]\n    st = set(used)\n    for i in range(1, n + 1):\n        if not i in st:\n            seq.append(i)\n            seq.append(-i)\n    seq.append(used[-1])\n    print(len(seq))\n    print(' '.join(map(str, seq)))\n", "from operator import itemgetter\nimport sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    inf = 10 ** 9\n    for _ in range(II()):\n        n, k = MI()\n        ab = [(a, b, i) for i, (a, b) in enumerate(LLI(n))]\n\n        dp = [[inf] * n for _ in range(k)]\n        log = [[[] for _ in range(n)] for _ in range(k)]\n        for e in range(n): dp[0][e] = -ab[e][0]\n        ab.sort(key=itemgetter(1))\n        for a, b, i in ab:\n            for j in range(k - 2, -1, -1):\n                for e in range(n):\n                    if i==e:continue\n                    pre = dp[j][e]\n                    if pre==inf:continue\n                    cur = pre + b * (k - 1 - j) - a\n                    if cur < dp[j + 1][e]:\n                        dp[j + 1][e] = cur\n                        log[j+1][e]=log[j][e]+[i]\n        #print(ab)\n        #p2D(dp)\n        #p2D(log)\n        #print()\n        mn=mne=inf\n        for e in range(n):\n            cur=dp[-1][e]\n            if cur<mn:\n                mn=cur\n                mne=e\n        first=log[-1][mne]\n        use=[False]*n\n        use[mne]=True\n        ans=[]\n        for i in first:\n            ans.append(i+1)\n            use[i]=True\n        for i in range(n):\n            if use[i]:continue\n            ans.append(i+1)\n            ans.append(-i-1)\n        ans.append(mne+1)\n        print(len(ans))\n        print(*ans)\n\nmain()\n", "import sys\n\nreadline = sys.stdin.readline\nread = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    n, k = nm()\n    mini = [tuple(nl() + [i+1]) for i in range(n)]\n    mini.sort(key = lambda x: x[1])\n    # print(mini)\n    dp = [-1]*(k+1)\n    dp[0] = 0\n    f = [[0]*(k+1) for _ in range(n)]\n    for i in range(n):\n        if dp[k] > 0:\n            dp[k] += (k - 1) * mini[i][1]\n        for j in range(k-1, -1, -1):\n            if dp[j] >= 0:\n                if dp[j+1] < dp[j] + mini[i][0] + j * mini[i][1]:\n                    dp[j+1] = dp[j] + mini[i][0] + j * mini[i][1]\n                    f[i][j+1] = 1\n                dp[j] += (k - 1) * mini[i][1]\n    \n    cx = k\n    a = list()\n    b = list()\n    for i in range(n-1, -1, -1):\n        if f[i][cx]:\n            a.append(mini[i][2])\n            cx -= 1\n        else:\n            b.append(mini[i][2])\n    com = list()\n    for x in a[:0:-1]:\n        com.append(x)\n    for x in b:\n        com.append(x)\n        com.append(-x)\n    com.append(a[0])\n    print(len(com))\n    print(*com)\n    return\n\nT = ni()\nfor _ in range(T):\n    solve()", "from typing import List\nimport sys\ninput = sys.stdin.readline\nimport math\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input().strip()\n    return(list(s[:len(s)]))\ndef invr():\n    return(list(map(int,input().strip().split())))\n\n\n\ndef solve_hungarian(a: List[List[int]], n: int, m: int):\n    \"\"\"\n    Implementation of Hungarian algorithm in n^2 m\n    \"\"\"\n    # potentials\n    u = [0] * (n+1)\n    v = [0] * (m+1)\n\n    # pair row of each col\n    p = [0] * (m+1)\n\n    # for each col the number of prev col along the augmenting path\n    way = [0] * (m+1)\n\n\n    for i in range(1, n+1):\n        p[0] = i\n        j0 = 0\n        minv = [float('inf')] *  (m+1)\n        used = [False] * (m+1)\n\n        # iterative Kun starts here\n        condition = True\n        while condition:\n            # mark the current col as reachable\n            used[j0] = True\n            i0 = p[j0]\n            delta = float('inf')\n\n            # determine which col will become reachable after next potential update\n            for j in range(1, m+1):\n                if not used[j]:\n                    cur = a[i0][j] - u[i0]-v[j]\n                    if cur < minv[j]:\n                        minv[j] = cur\n                        way[j] = j0\n                    if minv[j] < delta:\n                        delta = minv[j]\n                        j1 = j\n                        # j1 will hold the col with min\n                        # way[j1] - the prev col in dfs\n\n            # update the potential\n            for j in range(0, m+1):\n                if used[j]: # if col j was discovered:\n                    u[p[j]] += delta\n                    v[j] -= delta\n                else: # not discovered - update min?\n                    minv[j] -= delta\n\n            # j0 becomes the col on which the delta is achieved\n            j0 = j1\n            # p[j0] == 0 => j0 - a col not in matching\n            condition = p[j0] != 0\n\n        # the augmenting path was found - update the mapping\n        condition = True\n        while condition:\n\n            # j1 is the prev column of j0 in augmenting path\n            j1 = way[j0]\n            p[j0] = p[j1]\n            j0 = j1\n            condition = j0 != 0\n\n    ans = [0] * (n+1)\n    for j in range(1, m+1):\n        ans[p[j]] = j\n\n    return -v[0], ans\n\n\ndef solve(n, k, a, b):\n    A = [[0] * (n+1) for _ in range(n+1) ]\n\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            A[i][j] = a[i] + (j-1) * b[i]\n        for j in range(k+1, n+1):\n            A[i][j] = (k-1) * b[i]\n\n        # turn into a max problem\n    for i, row in enumerate(A):\n        M = max(row)\n        for j in range(n+1):\n            A[i][j] = M - A[i][j]\n\n    cost, match = solve_hungarian(A, n, n)\n\n    print(n + (n-k))\n\n    role_to_creature = list(zip(match, list(range(len(match)))))\n    role_to_creature.sort()\n\n    res = []\n\n    for index in range(1, k):\n        res.append(role_to_creature[index][1])\n\n    for index in range(k+1, n+1):\n        res.append(role_to_creature[index][1])\n        res.append(-role_to_creature[index][1])\n    res.append(role_to_creature[k][1])\n    print(\" \".join(map(str, res)))\n\n\n\n\ndef from_file(f):\n    return f.readline\n\n\n# with open('test.txt') as f:\n#     input = from_file(f)\nt = inp()\nfor _ in range(t):\n    n, k = invr()\n    a = [0]\n    b = [0]\n    for _ in range(n):\n        ai, bi = invr()\n        a.append(ai)\n        b.append(bi)\n    solve(n, k, a, b)\n\n\n\n\n\n"]
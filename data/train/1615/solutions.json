["def longest_slide_down(p):\n    res = p.pop()\n    while p:\n        tmp = p.pop()\n        res = [tmp[i] + max(res[i],res[i+1])  for i in range(len(tmp))] \n    return res.pop()", "def longest_slide_down(pyr):\n    for row in range(len(pyr)-1, 0, -1):\n        for col in range(0, row):\n            pyr[row-1][col] += max(pyr[row][col], pyr[row][col+1])\n    return pyr[0][0]", "def longest_slide_down(pyramid):\n    l = len(pyramid)\n    for i in range(l-2,-1,-1):\n        for j in range(i+1):\n            pyramid[i][j] = max([pyramid[i+1][j],pyramid[i+1][j+1]])+pyramid[i][j]\n    return pyramid[0][0]\n", "def longest_slide_down(pyramid):\n    i = len(pyramid) - 2\n    while i > - 1:\n        for j in range(len(pyramid[i])):\n            pyramid[i][j] += max(pyramid[i+1][j], pyramid[i+1][j+1])\n        i -= 1\n    return pyramid[0][0]", "class Tree(object):\n    value = summ = None\n    left = right = None\n    \n    def __init__(self, value):\n        self.value = value\n\n\ndef iter_pairs(level):\n    it = iter(level)\n    a, b = Tree(next(it)), Tree(next(it))\n    while b.value is not None:\n        yield a, b\n        a, b = b, Tree(next(it, None))\n\n\ndef build_tree(pyramid):\n    it = iter(pyramid)\n    root = Tree(next(iter(next(it))))\n    prev_level = iter([root])\n    for level in it:\n        tree_level = []\n        parent = next(prev_level)\n        \n        for left_tree, right_tree in iter_pairs(level):\n            tree_level.append(left_tree)\n\n            parent.left = left_tree\n            parent.right = right_tree\n            parent = next(prev_level, None)\n            \n        tree_level.append(right_tree)\n        prev_level = iter(tree_level)\n\n    return root\n\n\ndef calc_max_sums(root):\n    if root is None:\n        return 0\n\n    if root.summ is not None:\n        return root.summ\n\n    root.summ = root.value + max(calc_max_sums(root.left), calc_max_sums(root.right))\n    return root.summ\n\n\ndef find_max_slide(root):\n    if root is None:\n        return 0\n\n    if not (root.left and root.right):\n        return root.value\n\n    if root.left.summ >= root.right.summ:\n        return root.value + find_max_slide(root.left)\n    \n    if root.left.summ < root.right.summ:\n        return root.value + find_max_slide(root.right)\n\n\ndef longest_slide_down(pyramid):\n    tree = build_tree(pyramid)\n    calc_max_sums(tree)\n    return find_max_slide(tree)", "def longest_slide_down(a):\n    a = a[::-1]\n    for j in range(1,len(a)):\n        a[j] = [a[j][i]+max(a[j-1][i],a[j-1][i+1]) for i in range(len(a[j]))]\n    return a[-1][0]\n", "def longest_slide_down(pyramid):\n    if len(pyramid) == 1:\n        return pyramid[0][0]\n    left, current = pyramid[:-1], pyramid[-1]\n    pair_sum_g = map(max, zip(current[:-1], current[1:]))\n    for i, x in enumerate(pair_sum_g):\n        left[-1][i] += x\n    return longest_slide_down(left)"]
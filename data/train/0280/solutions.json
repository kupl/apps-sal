["from functools import lru_cache\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        if n == k:\n            return 0\n        @lru_cache(None)\n        def cnt(left,right): # cost to make palindrome\n            if left  >= right:\n                return 0\n            return cnt(left+1,right-1) + (s[left] != s[right])\n        \n        @lru_cache(None)\n        def dp(length,partition):\n            if partition == length:\n                return 0\n            if partition == 1:\n                return cnt(0,length-1)\n            return min(dp(prelength,partition-1) + cnt(prelength,length-1) for prelength in range(partition -1, length))\n\n    \n        return dp(n,k)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        visited = {}\n        dic = {}\n        def dfs(start, k):\n            if (start, k) in dic:\n                return dic[(start,k)]\n            if k == 0:\n                i = start\n                j = n-1\n                dic[(start, k)] = visited[(i,j)]\n                return visited[(i,j)]\n            count = float('inf')\n            for i in range(start+1, n-k+1):\n                count = min(count, visited[(start, i-1)]+dfs(i, k-1))\n            \n            dic[(start, k)] = count\n            #print(dic)\n            return count\n        for j in range(n):\n            for i in range(j, -1, -1):\n                if i == j:\n                    visited[(i,j)] = 0\n                elif i == j-1:\n                    if s[i] != s[j]:\n                        visited[(i,j)] = 1\n                    else:\n                        visited[(i,j)] = 0\n                else:\n                    if s[i] == s[j]:\n                        visited[(i,j)] = visited[(i+1,j-1)]\n                    else:\n                        visited[(i,j)] = visited[(i+1,j-1)]+1\n        \n        return dfs(0, k-1)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # dp[i][k]: minimum cost to make s[:i] can be divided into k substring\n        # xxxxxxxxxxxxxjxxxxxxi\n        # dp[j-1][k-1]  s[j:i] \n        n = len(s)\n        dp = [[math.inf for _ in range(k + 1)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        def changes(start, end):\n            cnt = 0\n            while start < end:\n                if s[start] != s[end]:\n                    cnt += 1\n                start += 1\n                end -= 1\n            return cnt\n        \n        for i in range(1, n + 1):\n            for l in range(1, min(k, i) + 1):\n                for j in range(l, i + 1):\n                    dp[i][l] = min(dp[i][l], dp[j - 1][l - 1] + changes(j - 1, i - 1))\n        \n        return dp[n][k]\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # dp[i][j] is to partition s[:i] into j groups\n        n = len(s)\n        dp = [[float('inf')]*(k+1) for _ in range(n+1)]\n        \n        dp[0][0] = 0\n        def cald(s):\n            if len(s)==1:\n                return 0\n            else:\n                lo, hi = 0, len(s)-1\n                ans = 0\n                while lo<hi:\n                    if s[lo]!=s[hi]:\n                        ans += 1\n                    lo += 1\n                    hi -= 1\n                return ans\n\n        for i in range(1,n+1): # to s[:i]\n            for j in range(1,k+1):\n                for h in range(j-1,i): # split into dp[h][] and s[h:i]\n                    dp[i][j] = min(dp[i][j], dp[h][j-1]+ cald(s[h:i])  )\n        return dp[n][k]\n        \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # dp[i][j] is to partition s[:i] into j groups\n        n = len(s)\n        dp = [[float('inf')]*(k+1) for _ in range(n+1)]\n        \n        dp[0][0] = 0\n        def cald(s):\n            if len(s)==1:\n                return 0\n            else:\n                lo, hi = 0, len(s)-1\n                ans = 0\n                while lo<hi:\n                    if s[lo]!=s[hi]:\n                        ans += 1\n                    lo += 1\n                    hi -= 1\n                return ans\n            \n        for i in range(1,n+1): # to s[:i]\n            for j in range(1,k+1):\n                for h in range(j-1,i): # split into dp[h][] and s[h:i]\n                    dp[i][j] = min(dp[i][j], dp[h][j-1]+ cald(s[h:i])  )\n        return dp[n][k]\n        \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        l = len(s)\n        def jbn(a):\n            le = len(a)\n            return sum(a[i] != a[le-1-i] for i in range(le //2))\n        dp = [[0] * (l+1) for _ in range(k+1)]\n        \n        for j in range(1,l+1):\n            dp[1][j] = jbn(s[:j])\n        for i in range(2,k+1):\n            for j in range(i+1,l+1):  # if j == i, dp[i][j] = 0\n                # t = min(dp[i-1][i-1:j])\n                # dp[i][j] = t + jbn(s[m:j])\n                dp[i][j] = min(dp[i-1][m] + jbn(s[m:j]) for m in range(i-1,j))\n        return dp[k][l]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def count_changes(_s):            \n            m = len(_s) // 2\n            return sum([int(c1 != c2) for c1, c2 in zip(_s[:m], _s[::-1][:m])])\n            \n        n = len(s)\n        if n == k:\n            return 0\n        \n        dp = [[float('inf')] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, n + 1):\n            dp[1][i] = count_changes(s[:i])\n        \n        for _k in range(2, k + 1):\n            for i in range(_k, n + 1):\n                for j in range(_k - 1, i):\n                    dp[_k][i] = min(dp[_k][i], dp[_k - 1][j] + count_changes(s[j:i]))\n        \n        return dp[k][n]\n", "class Solution:\n    def palindromePartition(self, s: str, key: int) -> int:\n        \n        @lru_cache(None)\n        def repair(string: s) -> int:\n            return sum([1 if string[i] != string[-1-i] else 0 for i in range(len(string)//2)])\n        \n        @lru_cache(None)\n        def pp(start: int, end:int, k: int) -> int:\n            # print(\\\"s:\\\", s, k)\n            if k == len(s): return 0\n            elif k == 1: return repair(s[start:end])\n            changes = end-start-k\n            for i in range(k-1, end-start):\n                changes = min(pp(start, i, k-1) + repair(s[i:end]), changes)\n            return changes\n        \n        return pp(0, len(s), key)", "class Solution:\n    def __init__(self):\n        self.table = {}\n        \n    def palindromePartition(self, s: str, k: int) -> int:\n            \n        def distanceToPalindrome(subs):\n            k = 0\n            for i in range(int(len(subs)/2)):\n                if subs[i] != subs[len(subs)-i-1]:\n                    k += 1\n            return k\n                    \n        if len(s) == 1:\n            return 0\n        \n        if k == 1:\n            return distanceToPalindrome(s)\n        \n        lens = len(s)\n        if lens in self.table:\n            if k in self.table[lens]:\n                return self.table[lens][k]\n                           \n        out = len(s)          \n        for i in range(1, len(s)):\n            out = min(out, distanceToPalindrome(s[:i]) + self.palindromePartition(s[i:], k-1))\n            \n        if lens not in self.table:\n            self.table[lens] = {}\n        self.table[lens][k] = out\n                                   \n        return out", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # dp[i][k]: min change number of devide s[:i] to k substrings\n        \n        dp = [[2 ** 30 for _ in range(k + 1)] for _ in range(len(s) + 1)]\n        for p in range(k + 1):\n            dp[0][p] = 0\n        \n        def minChange(s: str) -> int:\n            i, j = 0, len(s) - 1\n            cnt = 0\n            while i < j:\n                if s[i] != s[j]:\n                    cnt += 1\n                i += 1\n                j -= 1\n            return cnt\n\n        for i in range(1, len(s) + 1):\n            for p in range(1, min(i, k) + 1):\n                for j in range(i, p-1, -1):\n                    dp[i][p] = min(dp[i][p], dp[j-1][p-1] + minChange(s[j-1:i]))\n        \n        return dp[-1][-1]\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(subs, k):\n            if k == len(subs):\n                return 0\n            if k == 1:\n                return sum(subs[i] != subs[-1-i] for i in range(len(subs)//2))\n            res = float('inf')\n            for i in range(1, len(subs) - k + 2):\n                res = min(res, dfs(subs[:i], 1) + dfs(subs[i:], k - 1))\n            return res\n        return dfs(s, k)", "from functools import lru_cache\n\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        N = len(s)\n        \n        @lru_cache(None)\n        def numChanges(i, j):\n            ct = 0\n            while i < j:\n                if s[i] != s[j]:\n                    ct += 1\n                i += 1\n                j -= 1\n            return ct\n        \n        @lru_cache(None)\n        def dp(i, k):\n            if i < k - 1:\n                return inf\n            if k == 1:\n                return numChanges(0, i)\n            return min(dp(j-1, k-1) + numChanges(j, i) for j in range(1, i+1))\n        \n        return dp(N-1, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def count_char(a):\n            n = len(a)\n            b = a[::-1]\n            return sum(a[i] != b[i] for i in range(n)) // 2\n        n = len(s)\n        d = {}\n        for i in range(n):\n            for j in range(i, n):\n                d[(i, j)] = count_char(s[i:j + 1])\n        @lru_cache(None)\n        def dfs(i, j, l):\n            if l == j - i + 1:\n                return 0\n            if l == 1:\n                return d[(i, j)]\n            res = float('inf')\n            for m in range(i, j - l + 2):\n                res = min(res, d[(i, m)] + dfs(m + 1, j, l - 1))\n            return res\n        return dfs(0, len(s) - 1, k)", "from functools import lru_cache\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        if n == k:\n            return 0\n        @lru_cache(None)\n        def cnt(left,right): # cost to make palindrome\n            if left  >= right:\n                return 0\n            return cnt(left+1,right-1) + (s[left] != s[right])\n        \n        @lru_cache(None)\n        def dp(length,partition):\n            if partition == length:\n                return 0\n            if partition == 1:\n                return cnt(0,length-1)\n            return min(dp(prelength,partition-1) + cnt(prelength,length-1) for prelength in range(partition -1, length))\n\n    \n        return dp(n,k)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        self.memo = {}\n        return self.dfs(s, k)\n    \n    def dfs(self, s, k):\n        if (s, k) not in self.memo:\n            res = float('inf')\n            if len(s) == k:\n                res = 0\n            elif k == 1:\n                res = sum(s[i] != s[-1-i] for i in range(len(s)//2))\n            else:\n                for i in range(1, len(s) - k + 2):\n                    res = min(self.dfs(s[:i], 1) + self.dfs(s[i:], k - 1), res)\n            self.memo[s, k] = res\n        return self.memo[s, k]\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        dp = defaultdict(int)\n        def pali(i, j):\n            diff = 0\n            while i >= 0 and j < len(s):\n                if s[i] != s[j]:\n                    diff += 1\n                dp[(i, j)] = diff\n                i -= 1\n                j += 1\n        \n        for i in range(len(s)):\n            pali(i, i)\n            pali(i, i+1)\n        \n        # memo = {}\n        @lru_cache(maxsize=None)\n        def recurse(idx, numCuts):\n            if numCuts > k:\n                return float('inf')\n            \n            if idx == len(s):\n                if numCuts == k:\n                    return 0\n                return float('inf')\n            \n            curMin = float('inf')\n            for i in range(idx, len(s)):\n                curMin = min(dp[(idx, i)] + recurse(i+1, numCuts+1), curMin)\n            return curMin\n        \n        return recurse(0, 0)", "from functools import lru_cache\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        @lru_cache(maxsize=None)\n        def costs(i, j):\n            if i>=j:\n                return 0\n            return costs(i+1,j-1)+(0 if s[i]==s[j] else 1)\n        \n        @lru_cache(maxsize=None)\n        def dfs(j, k):\n            if k==1:\n                return costs(0,j)\n            if k>j+1:\n                return 0\n            return min(dfs(i, k-1)+costs(i+1,j) for i in range(j))\n        \n        return dfs(len(s)-1, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n        n = len(s)\n        s = '#' + s\n        dp = [[float('inf')]*(k+1) for _ in range(n+1)]\n        dp[0][0] = 0\n        \n        # def count(a, b):\n        #     count = 0\n        #     while a<b:\n        #         if s[a] != s[b]:\n        #             count +=1\n        #         a +=1\n        #         b -=1\n        #     return count\n        \n        #\u6311\u6218\u9ad8\u96be\u5ea6count\n        #dp[i][j]  change of characer betwee i and j\n        count = [[0]*(n+1) for _ in range(n+1)]\n        for lens in range(2, n+1):\n            #i + lens -1 <= n+1\n            for i in range(n-lens+2):\n                j = i+ lens-1\n                if s[i] == s[j]:\n                    count[i][j] = count[i+1][j-1]\n                else:\n                    count[i][j] = count[i+1][j-1] + 1\n        \n                \n    \n            \n        for i in range(1, n+1):\n            for t in range(1, min(i+1, k+1)):\n                for j in range(t, i+1):\n                    dp[i][t] = min(dp[i][t], dp[j-1][t-1] + count[j][i])\n                    \n        return dp[n][k]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        changes = [[0]*len(s) for _ in range(len(s))]\n        \n        for i in range(len(s)):\n            for j in range(i,len(s)):\n                start, end = i, j\n                tmp = 0\n                while start < end:\n                    if s[start] != s[end]:\n                        tmp += 1\n                    start += 1\n                    end -= 1\n                changes[i][j] = tmp\n        \n        \n        \n        memo = [[float('inf')]*len(s) for _ in range(k)]\n        \n        for i in range(len(s)):\n            memo[0][i] = changes[i][-1] \n        \n        for i in range(1,k):\n            for j in range(len(s)):\n                for t in range(j+1, len(s)-i+1):\n                    memo[i][j] = min(memo[i-1][t]+changes[j][t-1], memo[i][j])\n        \n        return memo[-1][0]\n                    \n                    \n        \n", "class Solution:\n    def palindromePartition(self, s: str, K: int) -> int:\n        n = len(s)\n        # dp[i][k] means the minimal number of characters that I need to change to divide index 0 to index i from string s into k substrings\n        dp = [[101 for k in range(K + 1)] for i in range(n)]\n        num = [[0 for j in range(n)] for i in range(n)]\n        \n        for i in range(n):\n            for j in range(i):\n                num[j][i] = self.helper(s[j:i + 1])\n        \n        for i in range(n):\n            dp[i][1] = num[0][i]\n\n        for k in range(2, K + 1):\n            for i in range(k - 1, n):\n                for j in range(k - 2, i):\n                    dp[i][k] = min(dp[i][k], dp[j][k - 1] + num[j + 1][i])\n        return dp[n - 1][K]\n    \n    def helper(self, s):\n        l, r = 0, len(s) - 1\n        count = 0\n        while l < r:\n            if s[l] != s[r]:\n                count += 1\n            l += 1\n            r -= 1\n        return count", "class Solution:\n    def palindromePartition(self, s: str, k: int):\n        prefix = [[0] * len(s) for _ in range(len(s))]\n        for r in range(len(prefix)):\n            for c in range(len(prefix[0])):\n                if r < c:\n                    prefix[r][c] = self.find_change(s, r, c)\n\n        dp = [[0] * len(s) for _ in range(k)]\n        dp[0] = prefix[0]\n        for r in range(1, len(dp)):\n            for c in range(len(dp[0])):\n                if r < c:\n                    tmp = float('inf')\n                    for i in range(c):\n                        tmp = min(tmp, dp[r-1][i] + prefix[i+1][c])\n                    dp[r][c] = tmp\n        return dp[-1][-1]\n\n    def find_change(self, s, r, c):\n        res = 0\n        while r < c:\n            if s[r] != s[c]:\n                res += 1\n            r += 1\n            c -= 1\n        return res", "from functools import lru_cache\n\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def check(x):\n            ans = 0\n            for i in range(len(x) // 2):\n                if x[i] != x[-1 - i]:\n                    ans += 1\n            return ans\n        \n        @lru_cache(None)\n        def dfs(start, num):\n            if num == 1:\n                return check(s[start:])\n            res = float('inf')\n            for i in range(start + 1, len(s)):\n                res = min(res, check(s[start:i]) + dfs(i, num - 1))\n            return res\n        \n        return dfs(0, k)\n                \n", "from functools import lru_cache\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        if n == k:\n            return 0\n        # a string of length n, the largest cost to make it  palindrome is n // 2\n        @lru_cache(None)\n        def cnt(left,right): # cost to make palindrome\n            if left  >= right:\n                return 0\n            return cnt(left+1,right-1) + (s[left] != s[right])\n        \n        @lru_cache(None)\n        def dp(length,partition):\n            if partition == length:\n                return 0\n            if partition == 1:\n                return cnt(0,length-1)\n            res = float('inf')\n            for prelength in range(partition - 1,length):\n                res = min(res,dp(prelength,partition-1)+cnt(prelength,length-1))\n            return res\n    \n        return dp(n,k)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int):\n        # preprocess\n        cost = [[0] * len(s) for _ in range(len(s))]\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    cost[i][j] = cost[i+1][j-1]\n                else:\n                    cost[i][j] = cost[i+1][j-1] + 1\n\n        dp = [[float('inf')] * k for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][0] = cost[0][i]\n            for c in range(1, k):  # c means cut, so c = k - 1\n                for j in range(i):\n                    dp[i][c] = min(dp[i][c], dp[j][c-1] + cost[j+1][i])\n        #print(dp)\n        return dp[-1][-1]", "class Solution:\n    def palindromePartition(self, s: str, k: int):\n        # preprocess\n        cost = [[0] * len(s) for _ in range(len(s))]\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    cost[i][j] = cost[i+1][j-1] \n                else:\n                    cost[i][j] = cost[i+1][j-1] + 1\n\n        dp = [[float('inf')] * (k+1) for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][1] = cost[0][i]\n            for m in range(2, k+1):\n                for j in range(i):\n                    dp[i][m] = min(dp[i][m], dp[j][m-1] + cost[j+1][i])\n        #print(cost)\n        #print(dp)\n        return dp[-1][-1]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        dp = {}\n        def pali(i, j):\n            diff = 0\n            while i >= 0 and j < len(s):\n                if s[i] != s[j]:\n                    diff += 1\n                dp[(i, j)] = diff\n                i -= 1\n                j += 1\n        \n        for i in range(len(s)):\n            pali(i, i)\n            pali(i, i+1)\n            \n        memo = {}\n        def recurse(idx, numCuts):\n            if numCuts == k and idx == len(s):\n                return 0\n            if numCuts == k or idx == len(s):\n                return float('inf')\n            \n            if (idx, numCuts) in memo:\n                return memo[(idx, numCuts)]\n            curMin = float('inf')\n            for j in range(idx, len(s)):\n                curMin = min(dp[(idx, j)] + recurse(j+1, numCuts+1), curMin)\n            memo[(idx, numCuts)] = curMin\n            \n            return curMin\n        \n        return recurse(0, 0)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int):\n        # preprocess\n        cost = [[0] * len(s) for _ in range(len(s))]\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    cost[i][j] = cost[i+1][j-1] \n                else:\n                    cost[i][j] = cost[i+1][j-1] + 1\n\n        dp = [[float('inf')] * k for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][0] = cost[0][i]\n            for m in range(1, k):\n                for j in range(i):\n                    dp[i][m] = min(dp[i][m], dp[j][m-1] + cost[j+1][i])\n        #print(cost)\n        #print(dp)\n        return dp[-1][-1]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = {}\n        \n        def cost(s,i,j): #calculate the cost of transferring one substring into palindrome string\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def dfs(i, k):\n            if (i, k) in memo: return memo[(i, k)] #case already in memo\n            if n - i == k: #base case that each substring just have one character\n                return 0\n            if k == 1:    #base case that need to transfer whole substring into palidrome\n                return cost(s, i, n - 1)\n            res = float('inf')\n            for j in range(i + 1, n - k + 2): # keep making next part of substring into palidrome\n                res = min(res, dfs(j, k - 1) + cost(s,i, j - 1)) #compare different divisions to get the minimum cost\n            memo[(i, k)] = res\n            return res\n        return dfs(0 , k)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = {}\n        \n        def cost(s,i,j): #calculate the cost of transferring one substring into palindrome string\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def dfs(i, k):\n            if (i, k) in memo: return memo[(i, k)] #case already in memo\n            if n - i == k: #base case that each substring just have one character\n                return 0\n            if k == 1:    #base case that need to transfer whole substring into palidrome\n                return cost(s, i, n - 1)\n            res = float('inf')\n            for j in range(i + 1, n - k + 2): # keep making next part of substring into palidrome\n                res = min(res, dfs(j, k - 1) + cost(s,i, j - 1)) #compare different divisions to get the minimum cost\n            memo[(i, k)] = res\n            return res\n        return dfs(0 , k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = {}\n        \n        def cost(s,i,j): #calculate the cost of transferring one substring into palindrome string\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def dfs(i, k):\n            if (i, k) in memo: return memo[(i, k)]\n            if (n - i) == k: return 0\n            if k == 1: return cost(s, i, n-1)\n            res = n + 1 \n            for j in range(i+1, n-k + 2):\n                res = min(res, dfs(j, k-1) + cost(s, i, j-1))\n            memo[(i, k)] = res \n            return res\n            \n        return dfs(0 , k)", "'''\nDfs: either create new palindrome or expand\n\nIf expanding recurse down (num swaps and divides):\n- With a swap you add 1\n- Without, you don't add \n\nEdge of the pal has to be the next value\n\nj-i = 0\nj-i = 1\nj-i = 2\n\nCaching mechanism\n'''\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = {}\n        \n        def cost(s,i,j): #calculate the cost of transferring one substring into palindrome string\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def dfs(i, k):\n            if (i, k) in memo: return memo[(i, k)] #case already in memo\n            if n - i == k: #base case that each substring just have one character\n                return 0\n            if k == 1:    #base case that need to transfer whole substring into palidrome\n                return cost(s, i, n - 1)\n            res = float('inf')\n            for j in range(i + 1, n - k + 2): # keep making next part of substring into palidrome\n                res = min(res, dfs(j, k - 1) + cost(s,i, j - 1)) #compare different divisions to get the minimum cost\n            memo[(i, k)] = res\n            return res\n        return dfs(0 , k)\n            \n            \n#             for j in range(i, self.length):\n#                 t = self.dp.get((i,j+1))\n#                 if not t:\n#                     count = cost(i,j)\n#                 else:\n#                     count = t\n                \n\n#                 dfs(j+1,ch+count,nk-1) #  case where you split\n             \n#         dfs(0,0,k)\n\n#         return self.r\n                \n            \n            \n            \n            \n            \n# #         n = len(s)\n# #         memo = {}\n        \n# #         def cost(s,i,j): #calculate the cost of transferring one substring into palindrome string\n# #             r = 0\n# #             while i < j:\n# #                 if s[i] != s[j]:\n# #                     r += 1\n# #                 i += 1\n# #                 j -= 1\n# #             return r\n        \n# #         def dfs(i, k):\n# #             if (i, k) in memo: return memo[(i, k)] #case already in memo\n# #             if n - i == k: #base case that each substring just have one character\n# #                 return 0\n# #             if k == 1:    #base case that need to transfer whole substring into palidrome\n# #                 return cost(s, i, n - 1)\n# #             res = float('inf')\n# #             for j in range(i + 1, n - k + 2): # keep making next part of substring into palidrome\n# #                 res = min(res, dfs(j, k - 1) + cost(s,i, j - 1)) #compare different divisions to get the minimum cost\n# #             memo[(i, k)] = res\n# #             return res\n# #         return dfs(0 , k)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        if len(s) <= k:\n            return 0\n        \n        def num_change(w):#number need to change to become palindrome\n            l,r=0,len(w)-1\n            count=0\n            while l<r:\n                if w[l]!=w[r]:\n                    count+=1\n                l+=1\n                r-=1\n            return count\n        \n        def dp(i,k):\n            if (i,k) not in memo:\n                if k==1:\n                    memo[i,k]=num_change(s[:i+1])\n                else:\n                    memo[i,k]=min(dp(j,k-1)+num_change(s[j+1:i+1]) for j in range(k-2,i))\n            return memo[i,k]\n        \n        memo={}    \n        n=len(s)\n        return dp(n-1,k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        memo = dict()\n        n = len(s)\n        def find_cost(l, r):\n            cost = 0\n            while l < r:\n                if s[l] != s[r]:\n                    cost += 1\n                l += 1\n                r -= 1\n            return cost\n        \n        def dp(i, k):\n            if (i, k) in memo: return memo[(i, k)]\n            if n-i == 1: return 0\n            if k == 1: return find_cost(i, n-1)\n            memo[(i, k)] = float('inf')\n            for j in range(i+1, n-k+2):\n                memo[(i, k)] = min(memo[(i, k)], find_cost(i, j-1)+dp(j, k-1))\n            return memo[(i, k)]\n        return dp(0, k)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         n = len(s)\n#         memo = dict()\n#         cost_memo = dict()\n#         def find_cost(l, r):\n#             a, b = l, r\n#             if (l, r) not in memo:\n#                 cost = 0\n#                 while l < r:\n#                     cost += s[l] != s[r]\n#                     l += 1\n#                     r -= 1\n#                 cost_memo[(a, b)] = cost\n#             return cost_memo[(a, b)]\n                \n#         def top_down(i, k):\n#             if n-i == 1:\n#                 return 0\n#             if k == 1:\n#                 return find_cost(i, n-1)\n#             if (i, k) not in memo:\n#                 res = float('inf')\n#                 for j in range(i+1, n-k+2):\n#                     res = min(res, find_cost(i, j-1)+top_down(j, k-1))\n#                 memo[(i, k)] = res\n#             return memo[(i, k)]\n#         return top_down(0, k)\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[float('inf') for _ in range(k)] for _ in range(n)]\n\n           \n        def getMinChange(i,j):\n            count  = 0\n            while i < j:\n                if s[i] != s[j]:  count += 1\n                i += 1\n                j -= 1\n            return count\n        \n        dic = collections.defaultdict(int) # dic[(i,j)] will store min change to make i:j a palindrome\n        for i in range(n):\n            for j in range(i,n):\n                dic[(i,j)] = getMinChange(i,j)\n                \n        for i in range(n):\n            for j in range(k):\n                if j >= i: dp[i][j] = 0\n                if j == 0: dp[i][j] = dic[(0,i)]\n        z = k\n        for i in range(n):\n            for k in range(1,min(i+1,z)):\n                for j in range(0,i): dp[i][k] = min(dp[i][k], dp[j][k-1] + dic[(j+1,i)])\n        return dp[n-1][z-1]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = dict()\n        cost_memo = dict()\n        def find_cost(l, r):\n            a, b = l, r\n            if (l, r) not in memo:\n                cost = 0\n                while l < r:\n                    cost += s[l] != s[r]\n                    l += 1\n                    r -= 1\n                cost_memo[(a, b)] = cost\n            return cost_memo[(a, b)]\n                \n        def top_down(i, k):\n            if n-i == 1:\n                return 0\n            if k == 1:\n                return find_cost(i, n-1)\n            if (i, k) not in memo:\n                res = float('inf')\n                for j in range(i+1, n-k+2):\n                    res = min(res, find_cost(i, j-1)+top_down(j, k-1))\n                memo[(i, k)] = res\n            return memo[(i, k)]\n        return top_down(0, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        self.cost = [[0 for _ in range(n)] for _ in range(n)]\n        for l in range(2,n+1):\n            i = 0\n            while i+l-1<n:\n                j = i+l-1\n                self.cost[i][j] = self.cost[i+1][j-1] + (s[i]!=s[j])\n                i += 1\n\n        self.dp = [[n for _ in range(k+1)] for _ in range(n)]\n        for i in range(n):\n            self.dp[i][1] = self.cost[0][i]   # k=1\u5c31\u662f\u4e00\u4efd\uff0c\u4e0d\u5206\n            for K in range(2,k+1):\n                for j in range(i):\n                    self.dp[i][K] = min(self.dp[i][K], self.dp[j][K-1] + self.cost[j+1][i])\n                    \n        return self.dp[n-1][k]", "class Solution:\n    \n    def palindromePartition(self, S: str, K: int) -> int:\n        \n        def palindrome_distance(li, ri):\n            count = 0\n\n            while li < ri:\n                count += S[li] != S[ri]\n                li += 1\n                ri -= 1\n                \n            return count\n        \n        def dfs(i, k):\n            if i == N or k == 0:\n                return 0 if i == N and k == 0 else math.inf\n            \n            if (i, k) in memo:\n                return memo[i, k]\n            \n            ans = math.inf\n            \n            for j in range(i, N):\n                if (i, j) not in dist_memo:\n                    dist_memo[i, j] = palindrome_distance(i, j)\n                \n                val = dist_memo[i, j] + dfs(j+1, k-1)\n                ans = min(ans, val)\n                \n            memo[i, k] = ans\n            return ans\n                \n        \n        N = len(S)\n        memo = {}\n        dist_memo = {}\n        ans = dfs(0, K)\n        return ans\n", "class Solution:\n    def cost(self, i, j):\n        if i + 1 >= j:\n            return 0\n        if i + 2 == j:\n            return 0 if self.s[i] == self.s[j - 1] else 1\n        \n        try:\n            return self.cost_cache[(i, j)]\n        except KeyError:\n            ret = self.cost(i + 1, j - 1) + (0 if self.s[i] == self.s[j - 1] else 1)\n            self.cost_cache[(i, j)] = ret\n            return ret\n        \n    def num_changes(self, i, kk):\n        rem_len = len(self.s) - i\n        if rem_len < kk:\n            return self.MAX\n        if rem_len == kk:\n            return 0\n        if kk == 1:\n            return self.cost(i, len(self.s))\n        \n        try:\n            return self.num_changes_cache[(i, kk)]\n        except KeyError:\n            ret = self.MAX\n            for j in range(i + 1, len(self.s) - (kk - 1) + 1):\n                ret = min(ret, self.cost(i, j) + self.num_changes(j, kk - 1))\n            self.num_changes_cache[(i, kk)] = ret\n            return ret\n            \n    def palindromePartition(self, s: str, k: int) -> int:\n        self.s = s\n        self.MAX = len(s)\n        self.cost_cache = {}\n        self.num_changes_cache = {}\n        \n        for l in range(3, len(s)):\n            for i in range(len(s) - l + 1):\n                j = i + l\n                self.cost(i, j)\n        for i in range(len(s) - 3, -1, -1):\n            for kk in range(2, min(len(s) - i - 1, k - 1) + 1):\n                self.num_changes(i, kk)\n                \n        return self.num_changes(0, k)\n                \n        \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        self.cache = {}\n        return self.dfs(s, k)\n    \n    def dfs(self, s, k):\n        if (s, k) in self.cache:\n            return self.cache[(s, k)]\n\n        if k == 1:\n            self.cache[(s, k)] = self.helper(s)\n            return self.cache[(s, k)]\n        \n        n = len(s)\n        ans = 100\n        for i in range(n - k + 1):\n            temp = self.helper(s[:i + 1])\n            ans = min(ans, temp + self.dfs(s[i + 1:], k - 1))\n        \n        self.cache[(s, k)] = ans\n        return ans\n    \n    def helper(self, s):\n        l, r = 0, len(s) - 1\n        count = 0\n        while l < r:\n            if s[l] != s[r]:\n                count += 1\n            l += 1\n            r -= 1\n        return count", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n=len(s)\n        palindrome=[[0 for x in range(n)] for y in range(n)]\n        for i in range(n-1):\n            if s[i]!=s[i+1]:\n                palindrome[i][i+1]=1\n        for gap in range(2,n):\n            for start in range(n-gap):\n                end=start+gap\n                if s[start]==s[end]:\n                    palindrome[start][end]=palindrome[start+1][end-1]\n                else:\n                    palindrome[start][end]=palindrome[start+1][end-1]+1\n        dp=[[2**31 for x in range(k+1)] for y in range(n+1)]\n        dp[0][0]=0\n        for i in range(1,n+1):\n            for j in range(1,k+1):\n                for l in range(i,0,-1):\n                    dp[i][j]=min(dp[i][j],dp[l-1][j-1]+palindrome[l-1][i-1])\n        return dp[n][k]\n                    \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def change(s):\n            if len(s) == 1:\n                return 0\n            i, j = 0, len(s) - 1\n            count = 0\n            while i < j:\n                if s[i] != s[j]:\n                    count += 1\n                i +=1\n                j -=1\n            return count\n        \n        memo = [[-1] * (k+1) for _ in range(len(s))]\n        \n        def dfs(s, start, k):\n            if memo[start][k] != -1: return memo[start][k]\n            if k == 1: \n                memo[start][k] = change(s[start:])\n                return memo[start][k]\n            count = len(s) - start\n            for i in range(start, len(s)-k+1):\n                print(i, k)\n                count = min(count, change(s[start:i+1]) + dfs(s, i+1, k-1))\n            memo[start][k] = count\n            return count\n        \n        return dfs(s, 0, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        sLen = len(s)\n        \n        dp = {}\n        \n        def moveOnce(prei, i0, k0):\n            if (prei, i0, k0) in dp:\n                return dp[(prei, i0, k0)]\n            if k0 == k:\n                l = prei\n                r = sLen -1\n                subAns = 0\n                while r > l:\n                    if s[r] != s[l]:\n                        subAns += 1\n                    r -= 1\n                    l += 1\n                dp[(prei, i0, k0)] = subAns\n                return subAns\n            \n            l = prei\n            r = i0\n            subAns = 0\n            while r > l:\n                if s[r] != s[l]:\n                    subAns += 1\n                r -= 1\n                l += 1             \n            if sLen - i0 - 1 <= k - k0:\n                return subAns\n            subAns = min(subAns + moveOnce(i0+1, i0+1,k0+1), moveOnce(prei, i0+1, k0))\n            dp[(prei, i0, k0)] = subAns\n            return subAns\n        \n        return moveOnce(0, 0, 1)\n            \n            \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[float('inf') for _ in range(k)] for _ in range(n)]\n\n           \n        def getMinChange(i,j):\n            count  = 0\n            while i < j:\n                if s[i] != s[j]:  count += 1\n                i += 1\n                j -= 1\n            return count\n        \n        dic = collections.defaultdict(int) # dic[(i,j)] will store min change to make i:j a palindrome\n        for i in range(n):\n            for j in range(i,n):\n                dic[(i,j)] = getMinChange(i,j)\n                \n        for i in range(n):\n            for j in range(k):\n                if j >= i: dp[i][j] = 0\n                if j == 0: dp[i][j] = dic[(0,i)]\n        z = k\n        for i in range(n):\n            for k in range(1,z):\n                for j in range(0,i): dp[i][k] = min(dp[i][k], dp[j][k-1] + dic[(j+1,i)])\n        return dp[n-1][z-1]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # First, compute cost of each subdivision\n        n = len(s)\n        costs = [[0]*(n - i) for i in range(n)]\n        for l in range(1, n):\n            for start in range(n - l):\n                old = costs[start + 1][l - 2] if l > 1 else 0\n                costs[start][l] = old + (0 if s[start] == s[start + l] else 1)\n        #print(costs)\n        \n        # Compute optimal splittings\n        opt = [costs[i][-1] for i in range(n)]\n        for ki in range(2, k + 1):\n            new_opt = [0] * (n - ki + 1)\n            for start in range(len(new_opt)):\n                new_opt[start] = min(costs[start][l] + opt[start + l + 1] for l in range(n - start - ki + 1))\n            opt = new_opt\n        return opt[0]\n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # dfs with memorization\n        n = len(s)\n        memo = dict()\n        def cost(s, i, j):\n            ans = 0\n            while i < j:\n                if s[i] != s[j]:\n                    ans += 1\n                i += 1\n                j -= 1\n            return ans\n        \n        def dfs(i, k):\n            if (i, k) in memo:\n                return memo[(i, k)]\n            # the length of the substring is equal to k\n            if n - i == k:\n                return 0\n            if k == 1:\n                return cost(s, i, n-1)\n            res = float('inf')\n            for j in range(i, n-k+1):\n                res = min(res, cost(s, i, j) + dfs(j+1, k-1))\n            memo[(i, k)] = res\n            return res\n        return dfs(0, k)\n                \n            \n            \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def min_change(s, i, j):\n            a = 0\n            while i < j:\n                if s[i] != s[j]:\n                    a+= 1\n                \n                i += 1\n                j -= 1\n            return a\n        \n        cost = [[0 for j in range(len(s) )] for i in range(len(s))]\n        n = len(s)\n        for l in range(2,n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if s[i]!= s[j]:\n                    cost[i][j] = cost[i + 1][j - 1] + 1 \n                else:\n                    cost[i][j] = cost[i + 1][j - 1]\n             \n        \n        \n        dp = [[float('inf') for j in range(n)] for i in range(k + 1)]\n \n        #print(cost)\n        for i in range(n):\n            dp[1][i] = cost[0][i]\n            for kk in range(2, k+ 1):\n                for j in range( i):\n                    dp[kk][i] = min(dp[kk][i]  , dp[kk - 1][j]  + cost[j + 1][i])\n        \n        return dp[-1][-1]\n            \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n=len(s)\n        \n        memo={}\n        \n        def cost(i,j):\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def divide(st,d):\n            \n            if (st,d) in memo:\n                return memo[(st,d)]\n            \n            if d==n-st:\n                return 0\n            \n            if d==1:\n                return cost(st,n-1)\n            \n            ans=float('inf')\n            \n            for i in range(st+1,n-d+2):\n                ans=min(ans,cost(st,i-1)+divide(i,d-1))\n            \n            memo[(st,d)]=ans\n            \n            return ans\n        \n        \n        return divide(0,k)", "class Solution1:\n    def palindromePartition(self, s: str, k: int) -> int:\n        dp = [[0] * len(s) for i in range(len(s))]\n        \n        n = len(s)\n        \n        def transferPalimCount(s) -> int:\n            res = 0\n            q = len(s) - 1\n            p = 0\n            \n            while p < q:\n                if s[p] != s[q]:\n                    res += 1\n                p += 1\n                q -= 1\n            return res\n\n        for i in range(n):\n            for j in range(i, n):\n                dp[i][j] = transferPalimCount(s[i:j+1])\n                \n                \n\n        def findMin(s, e, k, count, candidates):\n            if k == 0:\n                if s > e:\n                    candidates.append(count)\n                    return\n                else:\n                    count += dp[s][e]\n                    candidates.append(count)\n                    return\n            \n            # string is not able to split to too much parts\n            if e-s+1 < k+1:\n                return\n        \n            for i in range(s, e+1):\n                findMin(i+1, e, k-1, count + dp[s][i], candidates)\n\n        candidates = []\n        findMin(0, n-1, k-1, 0, candidates)\n        \n        return min(candidates)\n\n# https://leetcode.com/problems/palindrome-partitioning-iii/discuss/441427/Python3-Top-down-DFS-with-Memoization\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = {}\n        def cost(s,i,j):\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def dfs(i, k):\n            # case already in memo\n            if (i, k) in memo: return memo[(i, k)]\n            \n            if n - i < k:\n                return float('inf')\n            \n            # base case that each substring just have one character\n            if n - i == k:\n                return 0\n            \n            # base case that need to transfer whole substring into palidrome\n            if k == 1:\n                return cost(s, i, n - 1)\n\n            res = float('inf')\n\n            # keep making next part of substring into palidrome\n            for j in range(i + 1, n):\n\n                # compare different divisions to get the minimum cost\n                res = min(res, dfs(j, k - 1) + cost(s, i, j - 1))\n            memo[(i, k)] = res\n            return res\n        return dfs(0 , k)\n        \n        \n        \n                    \n", "class Solution1:\n    def palindromePartition(self, s: str, k: int) -> int:\n        dp = [[0] * len(s) for i in range(len(s))]\n        \n        n = len(s)\n        \n        def transferPalimCount(s) -> int:\n            res = 0\n            q = len(s) - 1\n            p = 0\n            \n            while p < q:\n                if s[p] != s[q]:\n                    res += 1\n                p += 1\n                q -= 1\n            return res\n\n        for i in range(n):\n            for j in range(i, n):\n                dp[i][j] = transferPalimCount(s[i:j+1])\n                \n                \n\n        def findMin(s, e, k, count, candidates):\n            if k == 0:\n                if s > e:\n                    candidates.append(count)\n                    return\n                else:\n                    count += dp[s][e]\n                    candidates.append(count)\n                    return\n            \n            # string is not able to split to too much parts\n            if e-s+1 < k+1:\n                return\n        \n            for i in range(s, e+1):\n                findMin(i+1, e, k-1, count + dp[s][i], candidates)\n\n        candidates = []\n        findMin(0, n-1, k-1, 0, candidates)\n        \n        return min(candidates)\n\n# https://leetcode.com/problems/palindrome-partitioning-iii/discuss/441427/Python3-Top-down-DFS-with-Memoization\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        memo = {}\n        def cost(s,i,j):\n            r = 0\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        def dfs(i, k):\n            # case already in memo\n            if (i, k) in memo: return memo[(i, k)]\n            \n            # means not possible\n            if n - i < k:\n                return float('inf')\n            \n            # base case that each substring just have one character\n            if n - i == k:\n                return 0\n            \n            # base case that need to transfer whole substring into palidrome\n            if k == 1:\n                return cost(s, i, n - 1)\n\n            res = float('inf')\n\n            # keep making next part of substring into palidrome\n            for j in range(i + 1, n):\n\n                # compare different divisions to get the minimum cost\n                res = min(res, dfs(j, k - 1) + cost(s, i, j - 1))\n            memo[(i, k)] = res\n            return res\n        return dfs(0 , k)\n        \n        \n        \n                    \n", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        def substring_palindrome(substring):\n            l = 0\n            r = len(substring) - 1\n            ans = 0\n            while l <= r:\n                if substring[l] != substring[r]:\n                    ans += 1\n                l += 1\n                r -= 1\n            \n            return ans\n        \n    \n        n = len(s)  \n        dp = {}\n                    \n        \n        def backtrack(i, cuts):\n            if (i, cuts) not in dp:\n                # K is not cuts but subdivisions\n                if cuts == 1:\n                    dp[(i, cuts)] = substring_palindrome(s[:i+1])\n                else:\n                    ans = float('inf')\n                    for end in range(cuts-2, i):\n                        ans = min(ans, substring_palindrome(s[end+1:i+1]) + backtrack(end, cuts-1))\n                    dp[(i, cuts)] = ans\n                \n                \n                \n            return dp[(i, cuts)]\n        \n        return backtrack(n-1, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def cost(st, i, j):\n            res = 0\n            while j > i:\n                if st[i] != st[j]:\n                    res += 1\n                i += 1\n                j -= 1\n            return res\n        memo = {}\n        def dfs(l, r, k):\n            if r-l < k:\n                return float('inf')\n            if r-l == k:\n                return 0\n            if k == 1:\n                return cost(s, l, r-1)\n            if (l, r, k) in memo:\n                return memo[l, r, k]\n            memo[l, r, k] = float('inf')\n            for i in range(l+1, r):\n                memo[l, r, k] = min(memo[l, r, k], dfs(l, i, k-1) + cost(s, i, r-1))\n            return memo[l, r, k]\n        return dfs(0, len(s), k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        if n == k:\n            return 0\n        \n        # @lru_cache(None)\n        def cost(s): #calculate the cost of transferring one substring into palindrome string\n            r = 0\n            i, j = 0, len(s) - 1\n            while i < j:\n                if s[i] != s[j]:\n                    r += 1\n                i += 1\n                j -= 1\n            return r\n        \n        @lru_cache(None)\n        def dfs(s, k):\n            if len(s) == k:\n                return 0\n            if k == 1:\n                return cost(s)\n            res = float('inf')\n            for i in range(1, len(s)):\n                res = min(res, cost(s[:i]) + dfs(s[i:], k-1))\n            return res\n        return dfs(s, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n        n = len(s)\n        s = '#' + s\n        dp = [[float('inf')]*(k+1) for _ in range(n+1)]\n        dp[0][0] = 0\n        \n        def count(a, b):\n            count = 0\n            while a<b:\n                if s[a] != s[b]:\n                    count +=1\n                a +=1\n                b -=1\n            return count\n            \n        for i in range(1, n+1):\n            for t in range(1, min(i+1, k+1)):\n                for j in range(t, i+1):\n                    dp[i][t] = min(dp[i][t], dp[j-1][t-1] + count(j, i))\n                    \n        return dp[n][k]", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        @lru_cache(None)\n        def dp(index, l):\n            if l == 1:\n                leftstr = s[index:]\n                count = 0\n                left, right = 0, len(leftstr)-1\n                while(left < right):\n                    if leftstr[left] != leftstr[right]:\n                        count += 1\n                    left += 1\n                    right -= 1\n                \n                return count\n            \n            if index == len(s)-1:\n                return 0\n            \n            minvalue  = float('inf')\n            for i in range(index+1, len(s)):\n                leftstr = s[index:i]\n                count = 0\n                left, right = 0, len(leftstr)-1\n                while(left < right):\n                    if leftstr[left] != leftstr[right]:\n                        count += 1\n                    left += 1\n                    right -= 1             \n                \n                minvalue = min(minvalue, count + dp(i, l-1))\n            \n            return minvalue\n        \n        return dp(0, k)", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def count(s):\n            l=len(s)\n            c=0\n            for i in range(int(l//2)):\n                if s[i]!=s[l-1-i]:\n                    c+=1\n            return c\n        \n        s='#'+s\n        n=len(s)\n        dp=[[float('inf')]*(k+1) for _ in range(n)]\n        dp[0][0]=0\n        for i in range(1,n):\n            for j in range(1,k+1):\n                for m in range(j,i+1):\n                    dp[i][j]=min(dp[i][j],dp[m-1][j-1]+count(s[m:i+1]))\n        \n        return dp[-1][-1]", "class Solution:\n    def numChanges(self, s:str, start :int, end: int) -> int:\n        num = 0\n        while start < end:\n            if not s[start] is s[end]:\n                num +=1\n            start += 1\n            end -= 1\n        return num\n    \n    \n    def palindromePartition(self, s: str, k: int) -> int:\n        cache = [[0 for _ in range(len(s))] for _ in range(k)]\n        size = len(s)\n        for j in range(size - 1, -1, -1):\n            cache[0][j] = self.numChanges(s, j, size - 1)\n        \n        for i in range(1, k):\n            for j in range(size - 1 - i, -1, -1):\n                cache[i][j] = min([cache[i-1][k + 1] + self.numChanges(s,j,k) for k in range(j, size - i) ])\n        return cache[k-1][0]\n                \n                \n", "class Solution:\n    def palindromePartition(self, s: str, K: int) -> int:\n        len_s = len(s)\n        if K >= len_s: return 0\n        dp = [[float('inf')] * (K + 1) for _ in range(len_s + 1)]\n        \n        s = '0' + s\n        dp[0][0] = 0\n        for i in range(1, len_s + 1):\n            for k in range(1, min(K + 1, i + 1)):\n                for j in range(k, i + 1):\n                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + self.helper(s, j, i))\n        print(dp)\n        return dp[-1][-1]\n    \n    def helper(self, sub_s, l_idx, r_idx):\n        # \u8ba1\u7b97\u5c06sub_s\u8f6c\u6362\u4e3a\u56de\u6587\u6570\uff0c\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u5b57\u7b26\u6570\n        count = 0\n        while l_idx < r_idx:\n            if sub_s[l_idx] != sub_s[r_idx]:\n                count += 1\n            l_idx += 1\n            r_idx -= 1\n        return count", "class Solution:\n    def palindromePartition(self, s: str, K: int) -> int:\n        len_s = len(s)\n        if K >= len_s: return 0\n        dp = [[float('inf')] * (K + 1) for _ in range(len_s + 1)]\n        \n        s = '0' + s\n        dp[0][0] = 0\n        for i in range(1, len_s + 1):\n            for k in range(1, min(K + 1, i + 1)):\n                for j in range(k, i + 1):\n                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + self.helper(s, j, i))\n        return dp[-1][-1]\n    \n    def helper(self, sub_s, l_idx, r_idx):\n        # \u8ba1\u7b97\u5c06sub_s\u8f6c\u6362\u4e3a\u56de\u6587\u6570\uff0c\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u5b57\u7b26\u6570\n        count = 0\n        while l_idx < r_idx:\n            if sub_s[l_idx] != sub_s[r_idx]:\n                count += 1\n            l_idx += 1\n            r_idx -= 1\n        return count", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def getCount(i: int, j: int):\n            count = 0\n            while i < j:\n                if s[i] != s[j]:\n                    count += 1\n                i += 1\n                j -= 1\n            return count\n        \n        INT_MAX = 2147483647\n        N = len(s)\n        dp = [[INT_MAX for x in range(k)] for y in range(N)]\n        \n        for i in range(N):\n            dp[i][0] = getCount(0, i)\n            \n        for i in range(1, k):\n            for j in range(i, N):\n                for x in range(i-1, j):\n                    dp[j][i] = min(dp[j][i], dp[x][i-1]+getCount(x+1, j))\n        return dp[N-1][k-1]", "class Solution:\n    def palindromePartition(self, s: str, K: int) -> int:\n        len_s = len(s)\n        if K >= len_s: return 0\n        dp = [[float('inf')] * (K + 1) for _ in range(len_s + 1)]\n        \n        s = '0' + s\n        dp[0][0] = 0\n        for i in range(1, len_s + 1):\n            for k in range(1, K + 1):\n                for j in range(k, i + 1):\n                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + self.helper(s, j, i))\n        return dp[-1][-1]\n    \n    def helper(self, sub_s, l_idx, r_idx):\n        # \u8ba1\u7b97\u5c06sub_s\u8f6c\u6362\u4e3a\u56de\u6587\u6570\uff0c\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u5b57\u7b26\u6570\n        count = 0\n        while l_idx < r_idx:\n            if sub_s[l_idx] != sub_s[r_idx]:\n                count += 1\n            l_idx += 1\n            r_idx -= 1\n        return count", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        # dp[i][j] min num of changes to divide j+1 subs in s[: i+1]\n        # dp[i][j] = min([dp[i-m][j-1] + cost(i-m, j) for m in range(0, i)]\n        n = len(s)\n        dp = [[0 for j in range(k)] for i in range(n)]\n        memo = {}\n        # define the cost to make s[i: j+1] padindrome\n        def cost(i, j):\n            if memo.get((i, j)):\n                return memo[(i, j)]\n            c = 0\n            while i < j:\n                if s[i] != s[j]:\n                    c += 1\n                i += 1\n                j -= 1\n            memo[(i, j)] = c\n            return c\n        \n        # we need to determine the maximum length of Palindrome centered at s[i]\n        for i in range(n):\n            for j in range(k):\n                if j > i:\n                    break\n                if j == 0: \n                    dp[i][j] = cost(0, i)\n                else:\n                    dp[i][j] = min([dp[m][j-1] + cost(m+1, i) for m in range(i) if j-1<=m])\n        return dp[n-1][k-1]\n                    \n", "def ch(a):\n    l=len(a)\n    c=0\n    for i in range(l//2):\n        c+=(a[i]!=a[l-i-1])\n    return c\ndef f(s,ci,k,d):\n    l=len(s)\n    if k==0:\n        if ci!=l:return math.inf\n        return 0\n    if ci==l:return math.inf\n    if d[ci][k]!=-1:return d[ci][k]\n    r=''\n    a=math.inf\n    for i in range(ci,l):\n        r+=s[i]\n        a= min(ch(s[ci:i+1])+f(s,i+1,k-1,d),a)   \n    d[ci][k]=a\n    return a\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        l=len(s)\n        d=[[-1for i in range(k+1)] for j in range(l)]\n        return f(s,0,k,d)        ", "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        if not s:\n            return\n        self.memo = {}\n        return self.helper(0, len(s), k, s)\n    \n    def helper(self, i, j, k, s):\n        if (i, j, k) in self.memo:\n            return self.memo[(i, j, k)]\n        if len(s) <= k:\n            return 0\n        if k == 1:\n            min_change = self.cal_palindrome(s[i:j])\n            self.memo[(i, j, k)] = min_change\n            return min_change\n        \n        min_change = float('inf')\n        for split in range(i+1, j):\n            left = self.cal_palindrome(s[i:split])\n            right = self.helper(split, j, k-1, s)\n            if left+right < min_change:\n                min_change = left+right\n        self.memo[(i, j, k)] = min_change\n        return min_change\n    \n    def cal_palindrome(self, s):\n        if len(s) == 1:\n            return 0\n        if len(s) % 2 == 0:\n            c_right = len(s) // 2 \n            c_left = c_right -1\n        else:\n            c_left = len(s) // 2 - 1\n            c_right = len(s) // 2 + 1\n        count = 0\n        while c_left >= 0:\n            if s[c_left] != s[c_right]:\n                count += 1\n            c_left -= 1\n            c_right += 1\n        return count\n            \n        \n"]
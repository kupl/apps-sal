["def create_number_class(alphabet):\n    n = len(alphabet)\n\n    class Number(object):\n        def __init__(self, s):\n            if isinstance(s, str):\n                v = 0\n                for c in s:\n                    v = v * n + alphabet.index(c)\n            else:\n                v = s\n            self.value = v\n\n        def __add__(self, other):\n            return Number(self.value + other.value)\n\n        def __sub__(self, other):\n            return Number(self.value - other.value)\n\n        def __mul__(self, other):\n            return Number(self.value * other.value)\n\n        def __floordiv__(self, other):\n            return Number(self.value // other.value)\n\n        def __str__(self):\n            ret = []\n            v = int(self.value)\n            while v:\n                (v, r) = divmod(v, n)\n                ret.append(alphabet[r])\n            return ''.join(reversed(ret or alphabet[0]))\n\n        def convert_to(self, cls):\n            return cls(self.value)\n\n    return Number\n\n", "funcs = [\n'__int__', '__index__', '__floor__', '__ceil__', '__trunc__', '__round__',\n\n'__abs__',\n'__pos__', '__neg__', '__invert__',\n\n'__add__', '__sub__', '__mul__', '__floordiv__', '__truediv__', '__mod__', '__pow__',\n'__and__', '__or__', '__xor__', '__lshift__', '__rshift__',\n\n'__radd__', '__rsub__', '__rmul__', '__rfloordiv__', '__rtruediv__', '__rmod__', '__rpow__',\n'__rand__', '__ror__', '__rxor__', '__rlshift__', '__rrshift__',\n\n'__eq__', '__ne__', '__ge__', '__le__', '__gt__', '__lt__',\n\n'numerator', 'denominator', 'real', 'imag', 'conjugate', 'bit_length', 'from_bytes']\n\nCastedInt = type('', (int,), {func: lambda self, *args, func=func, **kwargs:\n    self.__class__(getattr(super(CastedInt, self), func)(*args, **kwargs)) for func in funcs})\n\nBaseNumber = type('', (CastedInt,), {\n    '__new__': lambda cls, n: super(BaseNumber, cls).__new__(\n                                    cls, n if isinstance(n, int) else\n                                       sum(cls.alphabet.index(c) * cls.base ** i for i, c in enumerate(n[::-1]))),\n    '__str__': lambda self: self and str(self//self.base).lstrip(self.alphabet[0]) + self.alphabet[self%self.base] or self.alphabet[0],\n    'convert_to': lambda self, other: other(self)\n})\n\ncreate_number_class = lambda alphabet: type('', (BaseNumber,), {'base': len(alphabet), 'alphabet': alphabet})", "def create_number_class(alphabet):\n    class CNum:\n        \n        doc = { e:i for i, e in enumerate(alphabet)}\n        sdc = { v:k for k, v in doc.items() }\n        l   = len(doc)\n        \n        def __init__(self,val):\n            self.val = val\n            self.int = self.to_int(val)\n        \n        def __str__(self):\n            return str(self.val)\n        \n        def convert_to(self, mod):\n            return self.to_str(self.int, mod.sdc, mod.l)\n            \n        def to_int(self, val):\n            return sum(self.doc[e]*(self.l**i) for i, e in enumerate(val[::-1]) )\n\n        def customer(f):\n            def wrap(cls, *args):\n                return CNum(cls.to_str(f(cls,*args) , cls.sdc, cls.l))\n            return wrap\n        \n        @customer \n        def __add__(self, o):\n            return self.int + o.int \n        \n        @customer \n        def __sub__(self, o):\n            return self.int - o.int \n        \n        @customer \n        def __mul__(self, o):\n            return self.int * o.int \n        \n        @customer \n        def __floordiv__(self, o):\n            return self.int // o.int \n           \n        @staticmethod\n        def to_str(val, dic, l, cnum = ''):\n            while val:\n                cnum += dic[val%l]\n                val //= l\n            return dic[val] if not cnum else cnum[::-1]\n        \n    return CNum", "def create_number_class(alp):\n    alphabet = {j: i for i, j in enumerate(alp)}\n    class BinClass:\n        def __init__(self, text) : self.text = text\n        __add__ = lambda self, other:self.op(self.text,other.text,'+')\n        __sub__ = lambda self, other:self.op(self.text,other.text,'-')\n        __mul__ = lambda self, other:self.op(self.text,other.text,'*')\n        __floordiv__ = lambda self, other:self.op(self.text,other.text,'//')\n        __str__ = lambda self:self.text  \n        \n        op = lambda self,a,b,sign:BinClass(self.from_decimal(eval('{} {} {}'.format(self.to_decimal(a),sign,self.to_decimal(b)))) or alp[0])\n        convert_to = lambda self, base:base(self.text).from_decimal(self.to_decimal(self.text))\n        to_decimal = lambda self, s:sum(alphabet[j] * (len(alp) ** (len(s)-1 - i)) for i, j in enumerate(s))\n        from_decimal = lambda self,s ,li=[]:self.from_decimal(s//len(alp),li+[s%len(alp)]) if s else ''.join([alp[int(i)] for i in li[::-1]])\n    return BinClass ", "def create_number_class(alphabet):\n    jinwei = len(alphabet)\n    def str2dec(string : str) -> int:\n        dec, base = 0, 1\n        for dig in reversed(string):\n            dec += base * alphabet.index(dig)\n            base *= jinwei\n        return dec\n    def dec2str(dec : int) -> str:\n        string = ''\n        while 1:\n            string += alphabet[dec % jinwei]\n            dec = dec // jinwei\n            if 0 is dec: return string[::-1]\n    class number:\n        def __init__(self, str_or_dec):\n            if isinstance(str_or_dec, str):\n                self.str = str_or_dec\n                self.dec = str2dec(self.str)\n            else:\n                self.dec = str_or_dec\n                self.str = dec2str(self.dec)\n        def convert_to(self, _class):\n            return _class(self.dec)\n        def __str__(self):\n            return self.str\n        def __add__(self, x):\n            return number(self.dec + x.dec)\n        def __sub__(self, x):\n            return number(self.dec - x.dec)\n        def __mul__(self, x):\n            return number(self.dec * x.dec)\n        def __floordiv__(self, x):\n            return number(self.dec // x.dec)\n    return number", "def create_number_class(alphabet):\n    class C():\n        alph = alphabet\n        def __init__(self, num):\n            self.n = sum(C.alph.find(num[i]) * len(C.alph)**(len(num) - i - 1) for i in range(len(num)))\n        def __str__(self):\n            return to_str(self.n, C.alph)\n        def __add__(self, c):\n            inst = C(to_str(self.n + c.n, C.alph))\n            return inst\n        def __sub__(self, c):\n            inst = C(to_str(self.n - c.n, C.alph))\n            return inst\n        def __mul__(self, c):\n            inst = C(to_str(self.n * c.n, C.alph))\n            return inst\n        def __floordiv__(self, c):\n            inst = C(to_str(self.n // c.n, C.alph))\n            return inst\n        def convert_to(self, Cl):\n            inst = Cl(to_str(self.n, Cl.alph))\n            return inst\n    return C\n\ndef to_str(k, alphabet):\n    if k == 0:\n        return alphabet[0]\n    res = ''\n    while k > 0:\n        res = alphabet[k % len(alphabet)] + res\n        k = k // len(alphabet)\n    return res", "def create_number_class(alphabet):\n    n = len(alphabet)\n    class C(int):\n        def __new__(cls, s):\n            return super().__new__(\n                cls, sum(alphabet.index(c) * n**i for i, c in enumerate(s[::-1]))\n            )\n        \n        def __str__(self):\n            s = \"\"\n            while self > 0:\n                self, d = divmod(self, n)\n                s = alphabet[d] + s\n            return s or alphabet[0]\n            \n        for op in ['__add__', '__sub__', '__mul__', '__floordiv__']:\n            locals()[op] = lambda self, other, op=op: int.__new__(type(self), getattr(int, op)(self, other))\n            \n        def convert_to(self, c):\n            return int.__new__(c, self)\n    return C", "import copy\nclass NumClass:\n    def __init__(self, alphabet):\n        self.base = len(alphabet)\n        self.alphabet = alphabet\n\n    def set_value_str(self, value):\n        self.str_value = value\n        self.int_value = 0\n        for c in value:\n            self.int_value = self.int_value * self.base\n            self.int_value += self.alphabet.index(c)\n    \n    def set_value_int(self, value):\n        self.int_value = value\n        self.str_value = ''\n        while value > 0:\n            self.str_value = self.alphabet[value % self.base] + self.str_value\n            value = value // self.base\n        if len(self.str_value) == 0:\n            self.str_value = self.alphabet[0]\n    def __str__(self):\n        return self.str_value\n\ndef create_number_class(alphabet):\n    def __init__(self, value = None):\n        NumClass.__init__(self, alphabet)\n        if value != None:\n            self.set_value_str(value)\n        else:\n            self.set_value_int(0)\n    \n    def __add__(self, other):\n        result = copy.deepcopy(self)\n        result.set_value_int(self.int_value + other.int_value)\n        return result\n    \n    def __sub__(self, other):\n        result = copy.deepcopy(self)\n        result.set_value_int(self.int_value - other.int_value)\n        return result\n\n    def __mul__(self, other):\n        result = copy.deepcopy(self)\n        result.set_value_int(self.int_value * other.int_value)\n        return result\n\n    def __floordiv__(self, other):\n        result = copy.deepcopy(self)\n        result.set_value_int(self.int_value // other.int_value)\n        return result\n    \n    def convert_to(self, convert_type):\n        ret = convert_type()\n        ret.set_value_int(self.int_value)\n        return ret\n\n    newclass = type('NumClass' + str(len(alphabet)), (NumClass, ), \n    {\"__init__\":__init__, \"__add__\":__add__, \"__sub__\":__sub__, \"__mul__\":__mul__, \"__floordiv__\":__floordiv__, \"convert_to\":convert_to})\n    return newclass", "def create_number_class(alphabet):\n    class Number():\n        alph = alphabet\n        def __init__(self, numb):\n            if type(numb) == str:\n                self.value = Number.conv(numb)\n            else: self.value = numb\n        \n        def conv(n):\n            base = len(Number.alph)\n            r, m = 0, 1\n            for i in range(1, len(n)+1):\n                r += m * Number.alph.index(n[-i])\n                m *= base\n            return r\n        \n        def vnoc(nu):\n            r = ''\n            base = len(Number.alph)\n            if nu == 0:\n                return Number.alph[0]\n            else:\n                while nu > 0:\n                    r += Number.alph[nu % base]\n                    nu //= base\n                return r[::-1]\n        \n        def convert_to(self, NumClass):\n            return NumClass(self.value)\n        \n        def __add__(self, other):\n            return Number(self.value + other.value)\n        \n        def __sub__(self, other):\n            return Number(self.value - other.value)\n        \n        def __mul__(self, other):\n            return Number(self.value * other.value)\n        \n        def __floordiv__(self, other):\n            return Number(self.value // other.value)\n        \n        def __str__(self):\n            return Number.vnoc(self.value)\n        \n    return Number", "def create_number_class(alphabets):\n    bases = len(alphabets)\n    class numbers:\n        base = bases\n        alphabet = alphabets\n        def __init__(self, num):\n            self.value = num\n            print((self.value, self.base, self.alphabet))\n        def __add__(self, other):\n            a = decimal(self.value, self.alphabet, self.base)\n            b = decimal(other.value, other.alphabet, self.base)\n            print((a, b))\n            return numbers(to_base(a+b, self.base, self.alphabet))\n        def __sub__(self, other):\n            a = decimal(self.value, self.alphabet, self.base)\n            b = decimal(other.value, other.alphabet, self.base)\n            return numbers(to_base(a-b, self.base, self.alphabet))\n        def __mul__(self, other):\n            a = decimal(self.value, self.alphabet, self.base)\n            b = decimal(other.value, other.alphabet, self.base)\n            return numbers(to_base(a*b, self.base, self.alphabet))\n        def __floordiv__(self, other):\n            a = decimal(self.value, self.alphabet, self.base)\n            b = decimal(other.value, other.alphabet, self.base)\n            return numbers(to_base(a//b, self.base, self.alphabet))\n        def __str__(self):\n            return str(self.value)\n        def convert_to(self, other):\n            num = decimal(self.value, self.alphabet, self.base)\n            num = to_base(num, other.base, other.alphabet)\n            print(num)\n            return numbers(num)\n    return numbers\n\ndef to_base(num, base, alphabet):\n    conv = []\n    num = int(num)\n    while num >= base:\n        conv.append(alphabet[num%base])\n        num = num//base\n    conv.append(alphabet[num])\n    conv.reverse()\n    return \"\".join([str(i) for i in conv]) \n\ndef decimal(num, alphabet, base):\n    dec = list(num)\n    new = list(range(0, len(alphabet)))\n    for i in new:\n        for x in range(0, len(dec)):\n            if dec[x] == alphabet[i]:\n                dec[x] = i\n    print(dec)\n    dec.reverse()\n    decimal = 0\n    for i, n in enumerate(dec):\n        decimal += n * base**i\n    print(decimal)\n    return decimal\n            \n            \n            \n            \n            \n"]
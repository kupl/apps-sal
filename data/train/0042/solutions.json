["LOG = 20\n\ndef solve(s):\n\tn = len(s)\n\tres = 0\n\tz = 0\n\tfor t in range(0, n):\n\t\tif s[t] == '0':\n\t\t\tz += 1\n\t\t\tcontinue\n\t\tfor l in range(1, min(LOG, n - t + 1)):\n\t\t\tx = int(s[t:t+l], 2)\n\t\t\t# print(l, t, x, l + z)\n\t\t\tif l + z >= x:\n\t\t\t\tres += 1\n\n#\t\t\tprint(t, l, x, res, z)\n\t\tz = 0\n\treturn res\n\n\nt = int(input())\nwhile t > 0:\n\tt -= 1\n\ts = input()\n\tprint(solve(s))", "t = int(input())\n\n\nc = [0] * 200100\nfor _ in range(t):\n    s = input()\n    for i in range(len(s)):\n        c[i] = s[i] == '0'\n        if i and s[i] == '0':\n            c[i] += c[i-1]\n\n    sol = 0\n    for i in range(len(s)):\n        tmp = 0\n        for k in range(20):\n            if i - k < 0:\n                break\n            \n            tmp += (s[i - k] == '1') << k\n            if tmp == k + 1:\n                sol += 1\n\n        if i >= 20:\n            top = 20 + c[i-20]\n            if tmp > 20 and tmp <= top:\n                sol += 1\n    print(sol)\n        \n", "T = int(input())\nfor t in range(T):\n    s = input()\n    n = len(s)\n    res = 0\n    zeros = 0\n    for i, c in enumerate(s):\n        if c == '0':\n            zeros += 1\n        else:\n            tail = 1\n            j = 1\n            while tail <= zeros+j:\n                res += 1\n                j += 1\n                if i-1+j == n:\n                    break\n                tail *= 2\n                tail += int(s[i-1+j])\n            zeros = 0\n    print(res)", "def main():\n    from sys import stdin, stdout\n    input = stdin.readline\n    print = stdout.write\n    for _ in range(int(input())):\n        ans = 0\n        i = -1\n        s = input()\n        for j in range(len(s) - 1):\n            if s[j] == '1':\n                c = 0\n                for k in range(j, len(s)):\n                    c = c * 2 + (s[k] == '1') + (s[k] == '\\n') * k\n                    if k - i < c:\n                        ans += k - j\n                        break\n                i = j\n        print(f'{ans}\\n')\n\n\nmain()\n", "for _ in range(int(input())):\n    s = input()\n    q1 = ans = 0\n    for q in range(len(s)):\n        if s[q] == '0':\n            q1 += 1\n        else:\n            ans += 1+(q != len(s)-1 and s[q+1] == '0')\n            q2 = size = 1\n            for q3 in range(1, q1+1):\n                size += 1\n                if q2 == size:\n                    ans += 1\n                while q2 < size and size-q3+q < len(s):\n                    q2 *= 2\n                    q2 += ord(s[q+size-q3])-ord('0')\n                    size += 1\n                    if q2 == size:\n                        ans += 1\n            q1 = 0\n    print(ans)\n", "import sys\nD = {}\nm = 18\nfor i in range(1, 1<<m):\n    D[bin(i)[2:]] = i\nfor _ in range(int(input())):\n    S = sys.stdin.readline().rstrip()\n    s = 0\n    N = len(S)\n    ans = 0\n    for i in range(N):\n        if S[i] == \"1\":\n            for j in range(1, min(m, N - i) + 1):\n                k = D[S[i:i+j]]\n                if s + j >= k:\n                    ans += 1\n            s = 0\n        else:\n            s += 1\n    print(ans)\n\n", "from bisect import *\nstrings = []\nzeronumber = []\nfor i in range(1, 200001):\n    strings.append(format(i, \"b\"))\n    zeronumber.append(i-i.bit_length())\n\nt = int(input())\nfor _ in range(t):\n    s = input()\n    z = 0\n    ans = 0\n    for i in range(len(s)):\n        if s[i] == \"0\":\n            z += 1\n            continue\n        else:\n            for j in range(bisect_right(zeronumber, z)):\n                #print(j)\n                #print(s[i:i+len(strings[j])], strings[j])\n                if i+len(strings[j])-1 <= len(s)-1:\n                    if s[i:i+len(strings[j])] == strings[j]:\n                        ans += 1\n            z = 0\n    print(ans)\n", "t = int(input())\n\nfor _ in [0]*t:\n    s = input()\n    stack = []\n    zero_count = 0\n    ans = 0\n    for c in map(int, s):\n        new_stack = []\n        append = new_stack.append\n        if c:\n            append((c, zero_count))\n            ans += 1\n            zero_count = 0\n        else:\n            zero_count += 1\n\n        for v, zeros in stack:\n            v = (v << 1) + c\n            need_zeros = v - v.bit_length()\n            if need_zeros <= zeros:\n                ans += 1\n                append((v, zeros))\n\n        stack = new_stack\n\n    print(ans)\n", "q = int(input())\nfor _ in range(q):\n    s=input()\n    n=len(s)\n    ans=100000000\n    r=[0 for i in range(n)]\n    for i in range(n-1,-1,-1):\n        if(s[i]=='1'):\n            ans=i\n        r[i]=ans\n    ansss=0\n    for i in range(n):\n        ns=0\n        for j in range(r[i],n):\n            ns=2*ns+(ord(s[j])-ord('0'))\n            if(ns==j-i+1):\n                ansss+=1\n            if(ns>n):\n                break\n    print(ansss)", "import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor testcases in range(T):\n    S=input().strip()\n    LEN=len(S)\n\n    zeros=0\n    ANS=0\n\n    for i in range(LEN):\n        if S[i]==\"0\":\n            zeros+=1\n        else:\n\n            for j in range(1,min(22,LEN-i+1)):\n                k=int((S[i:i+j]),2)\n                if k==0:\n                    continue\n                #print(i,j,k)\n                if zeros>=k-j:\n                    ANS+=1\n\n            zeros=0\n\n    print(ANS)\n\n        \n\n    \n", "import sys \nimport math \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().rstrip()\n\nfor t in range(int(input())):\n  ans = 0\n  s = input()\n\n  i = 0\n  while i < len(s):\n    if s[i] == \"1\":\n      ans += 1\n      j = i - 1 \n      zero_cnt = 0\n      while j >= 0 and s[j] == \"0\":\n        zero_cnt += 1\n        j -= 1\n      \n      k = i \n      b = \"1\"\n      while k + 1 < len(s) and (int(b + s[k+1], 2) - len(b) - 1 <= zero_cnt):\n        ans += 1\n        b += s[k+1]\n        k += 1\n    \n    i += 1\n  \n  print(ans)", "t=int(input())\nfor i in range(t):\n    a=[int(x) for x in list(input())]\n    n=len(a)\n    zero=0\n    arr=0\n    for i in range(n):\n        if a[i]==1:\n            size=2\n            num=1\n            arr+=1\n            if i!=n-1:\n                j=i+1\n                if a[j]==1:\n                    num*=2+1\n                else:\n                    num*=2\n                    \n                while num<=size+zero and num>=size:\n                    arr+=1\n                    if j==n-1:\n                        break\n                    j+=1\n                    if a[j]==1:\n                        num=num*2+1\n                    else:\n                        num*=2\n                    size+=1\n            zero=0\n        else:\n            zero+=1\n    print(arr)\n       \n", "for _ in range(int(input())):\n    s = input()\n    num_zero = 0\n    ans = 0\n    \n    length = len(s)\n    \n    for i in range(length):\n        if s[i] == \"0\": num_zero += 1\n        else:\n            act_num = 1\n            j = i\n            \n            is_right = True\n            \n            while j < length and is_right:\n                if (act_num-(j-i+1)) <= num_zero:\n                    ans += 1\n                    j += 1\n                   \n                    if j < length:\n                        act_num = act_num*2+int(s[j])\n                else: is_right = False\n                   \n                    \n                \n            num_zero = 0\n            \n    print(ans)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    li = list(stdin.readline().strip())\n    k = 0\n    res = 0\n    for index, cri in enumerate(li):\n        if cri == '0':\n            k += 1\n        else:\n            sm = 0\n            for i in range(18):\n                try:\n                    sm = sm * 2 + int(li[index + i])\n                    if i + 1 <= sm <= i + 1 + k:\n                        res += 1\n                except:\n                    a = 1\n            k = 0\n    print(res)\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "for _ in range(int(input())):\n    s=input()\n    n=len(s)\n    i=0\n    j=0\n    c=0\n    ans=0\n    while(i<n):\n        if(s[i]=='0'):\n            c+=1\n        if(s[i]=='1'):\n            x=0\n            y=0\n            for j in range(i,n):\n                x=x*2\n                if(s[j]=='1'):\n                    x+=1\n                # print(x,y,c)\n                if(x-y-1<=c):\n                    ans+=1\n                    # print(i,j)\n                else:\n                    break\n                y+=1\n            c=0\n        i+=1\n    print(ans)", "from collections import defaultdict\nfrom math import log2\n\n\ndef zeros(n):\n    return n - int(log2(n)) - 1\n\n\ndef binary(n):\n    s = \"\"\n    while(n > 0):\n        s = str(n & 1) + s\n        n = n // 2\n    return s\n\n\nt = int(input())\n\nd = defaultdict(list)\nfor i in range(1, 2 * 10**5 + 1):\n    z = zeros(i)\n    d[z].append(i)\n\nfor _ in range(t):\n    s = input()\n    n = len(s)\n    zs = [0] * n\n    z = 0\n\n    for i in reversed(list(range(n))):\n        if (s[i] == '0'):\n            z += 1\n        else:\n            z = 0\n        zs[i] = z\n\n    total = 0\n\n    for i in range(n):\n        z = zs[i]\n        candidates = d[z]\n\n        j = i + z\n        for c in candidates:\n            cS = binary(c)\n            cSL = len(cS)\n\n            jEnd = j + cSL\n            if (jEnd > n):\n                continue\n            if (s[j:jEnd] == cS):\n                total += 1\n\n    print(total)\n", "import bisect\n\ndef solve(s,ans):\n    count = 0\n    one = []\n    n = len(s)\n    for i in range(n):\n        if s[i] == '1':\n            one.append(i)\n\n\n    for i in range(n):\n        curr = 0\n        if s[i] == '0':\n            start = bisect.bisect(one,i)\n            if start < len(one):\n                start = one[start]\n            else:\n                start = n\n        else:\n            start = i\n\n        #print(i,start)\n        for j in range(start,n):\n            curr *= 2\n            if s[j] == '1':\n                curr += 1\n            #print(curr,i,j-i+1,j)\n            if curr == j-i+1:\n                count += 1\n\n            if curr > n-i:\n                break\n\n    ans.append(count)\n        \n\ndef main():\n    t = int(input())\n    ans = []\n    for i in range(t):\n        s = input()\n        solve(s,ans)\n\n    for i in ans:\n        print(i)\n\nmain()\n", "import math\n\nfor _ in range(int(input())):\n\ts = input()\n\tn = len(s)\n\tans = 0\n\tlg = int(math.log2(n)) + 1\n\tnpfx = 0\n\tfor i in range(n):\n\t\tif s[i] == '0':\n\t\t\tnpfx += 1\n\t\t\tcontinue\n\t\tans += 1\n\t\tcv = 1\n\t\tln = 1\n\t\tfor j in range(i + 1, min(i + lg + 1, n)):\n\t\t\tln += 1\n\t\t\tcv *= 2\n\t\t\tcv += s[j] == '1'\n\t\t\tans += (ln <= cv) and (ln + npfx >= cv)\n\t\tnpfx = 0\n\tprint(ans)\n", "from math import log\nt=int(input())\naa=[1]\nfor i in range(100):\n    aa.append(aa[-1]*2)\nfor _ in range(t):\n    s=input()\n    ii=[]\n    co=0\n    j=0\n    ss={}\n    ind=-1\n    for i in s:\n        if i==\"0\":\n            if ind==-1:\n                ind=j\n            co+=1\n        else:\n            if ind!=-1:\n                ss[j-1]=ind\n            co=0\n            ind=-1\n        j+=1\n    if s[-1]==\"0\":\n        ss[len(s)-1]=ind\n    ans=0\n    for i in range(1,int(log(len(s))/log(2))+2):\n        for j in range(len(s)-i+1):\n            st=s[j:j+i]\n            if st[0]==\"1\":\n                tot=0\n                for ii in range(i):\n                    if st[-ii-1]==\"1\":\n                      #  print(ii)\n                        tot+=aa[ii]\n                le=tot-i\n                try:\n                    xx=ss[j-1]\n                    if (j-xx)>=le:\n                        ans+=1\n                     #   print(i,j,tot,st)\n                except:\n                    if le==0:\n                        ans+=1\n                    #    print(i,j,tot,st)\n                    pass\n    print(ans)\n #   print()\n", "def run(a, ind, l):\n    newSt = ''\n    ans = 0\n    for i in range(ind, len(a)):\n        newSt += a[i]\n        if int(newSt, 2) == (i - l + 1):\n            ans += 1\n        if int(newSt, 2) > (i - l + 1):\n            return ans\n    return ans\n\n\nn = int(input())\nfor kkk in range(n):\n    st = input()\n    uk = [0] * len(st)\n    for i in range(len(uk)):\n        uk[i] = i\n\n    for j in range(len(uk)):\n        if st[j] == '1':\n            uk[0] = j\n            break\n    for i in range(1, len(uk)):\n        if i < uk[i - 1]:\n            uk[i] = uk[i - 1]\n        else:\n            for j in range(i, len(uk)):\n                if st[j] == '1':\n                    uk[i] = j\n                    break\n\n    s = 0\n    for i in range(len(uk)):\n         if ((uk[i] != i) or st[i] == '1'):\n             s += run(st, uk[i], i)\n    print(s)", "'''input\n4\n0110\n0101\n00001000\n0001000\n'''\nfor test in range(int(input())):\n\ts = input()\n\tans = 0\n\tfor l in range(1, min(20, len(s))+1):\n\t\tp = 0\n\t\tfor i in range(len(s)-l+1):\n\t\t\tif s[i]=='0':\n\t\t\t\tp += 1\n\t\t\t\tcontinue\n\t\t\tx = int(s[i:i+l], 2)\n\t\t\tif x>=l and (x-l)<=p:\n\t\t\t\tans+=1\n\t\t\tp = 0\n\tprint(ans)\n\n", "from math import log2\nfrom math import ceil\n\nfor _ in range(int(input())):\n    S = list(map(int, list(input())))\n    combs = 0\n    maxlen = ceil(log2(len(S)))\n    #print(maxlen)\n    prezeros = 0\n    next1 = [0] * len(S)\n    nxt = len(S) - 1\n    for i in range(len(S) - 1, -1, -1):\n        if S[i] == 1:\n            nxt = i\n        next1[i] = nxt\n    for l in range(len(S)):\n        if S[l] == 0:\n            nxtl = next1[l]\n            val = 0\n            lcomb = 0\n            for r in range(nxtl, min(nxtl + maxlen + 1, len(S))):\n                val = 2 * val + S[r]\n                if val == r - l + 1:\n                    # print(l, r)\n                    lcomb += 1\n            combs += lcomb\n            continue\n        val = 0\n        lcomb = 0\n        for r in range(l, min(l + maxlen + 1, len(S))):\n            val = 2 * val + S[r]\n            if val == r - l + 1:\n                #print(l, r)\n                lcomb += 1\n        combs += lcomb\n        prezeros = 0\n    print(combs)\n"]
["from collections import defaultdict, deque\n \nadj = defaultdict(lambda: defaultdict(lambda: 0))\ndef bfs(graph, inicio, destino, parent):\n    parent.clear()\n    queue = deque()\n    queue.append([inicio, float(\"Inf\")])\n    parent[inicio] = -2\n    while (len(queue)):\n        current, flow = queue.popleft()\n        for i in adj[current]:\n            if parent[i] == -1 and graph[current][i] > 0:\n                parent[i] = current\n                flow = min(flow, graph[current][i])\n                if i == destino:\n                    return flow\n                queue.append((i, flow))\n    return 0\n \n \ndef maxflow(graph, inicio, destino):\n    flow = 0\n    parent = defaultdict(lambda: -1)\n    while True:\n        t = bfs(graph, inicio, destino, parent)\n        if t:\n            flow += t\n            current = destino\n            while current != inicio:\n                prev = parent[current]\n                graph[prev][current] -= t\n                graph[current][prev] += t\n                current = prev\n        else:\n            break\n    return flow\n \n \nn, m, x = [int(i) for i in input().split()]\n\nfor _ in range(m):\n    t = [int(i) for i in input().split()]\n    adj[t[0]][t[1]] = t[2]\n \n \ndef check(k):\n    meh = defaultdict(lambda: defaultdict(lambda: 0))\n    for i in adj:\n        for j in adj[i]:\n            ww = adj[i][j] // k\n            meh[i][j] = ww\n    flow = maxflow(meh, 1, n)\n    return flow\n \n \nlo = 1 / x\nhi = check(1)\n \nfor _ in range(70):\n    mid = (hi + lo) / 2\n    if hi-lo<0.0000000001:\n        break\n    if check(mid)>=x:\n        lo = mid\n    else:\n        hi = mid\nprint(format(lo * x, '.9f'))", "from collections import defaultdict, deque\n \nadj = defaultdict(lambda: defaultdict(lambda: 0))\ndef bfs(graph, inicio, destino, parent):\n    parent.clear()\n    queue = deque()\n    queue.append([inicio, float(\"Inf\")])\n    parent[inicio] = -2\n    while (len(queue)):\n        current, flow = queue.popleft()\n        for i in adj[current]:\n            if parent[i] == -1 and graph[current][i] > 0:\n                parent[i] = current\n                flow = min(flow, graph[current][i])\n                if i == destino:\n                    return flow\n                queue.append((i, flow))\n    return 0\n \n \ndef maxflow(graph, inicio, destino):\n    flow = 0\n    parent = defaultdict(lambda: -1)\n    while True:\n        t = bfs(graph, inicio, destino, parent)\n        if t:\n            flow += t\n            current = destino\n            while current != inicio:\n                prev = parent[current]\n                graph[prev][current] -= t\n                graph[current][prev] += t\n                current = prev\n        else:\n            break\n    return flow\n \n \nn, m, x = [int(i) for i in input().split()]\n\nfor _ in range(m):\n    t = [int(i) for i in input().split()]\n    adj[t[0]][t[1]] = t[2]\n \n \ndef check(k):\n    meh = defaultdict(lambda: defaultdict(lambda: 0))\n    for i in adj:\n        for j in adj[i]:\n            ww = adj[i][j] // k\n            meh[i][j] = ww\n    flow = maxflow(meh, 1, n)\n    return flow\n \n \nlo = 1 / x\nhi = check(1)\n \nfor _ in range(70):\n    mid = (hi + lo) / 2\n    if check(mid)>=x:\n        lo = mid\n    else:\n        hi = mid\nprint(format(lo * x, '.9f'))", "from collections import defaultdict, deque\n \n \ndef bfs(graph, inicio, destino, parent):\n    parent.clear()\n    queue = deque()\n    queue.append([inicio, float(\"Inf\")])\n    parent[inicio] = -2\n    while (len(queue)):\n        current, flow = queue.popleft()\n        for i in graph[current]:\n            if parent[i] == -1 and graph[current][i] > 0:\n                parent[i] = current\n                flow = min(flow, graph[current][i])\n                if i == destino:\n                    return flow\n                queue.append((i, flow))\n    return 0\n \n \ndef maxflow(graph, inicio, destino):\n    flow = 0\n    parent = defaultdict(lambda: -1)\n    while True:\n        t = bfs(graph, inicio, destino, parent)\n        if t:\n            flow += t\n            current = destino\n            while current != inicio:\n                prev = parent[current]\n                graph[prev][current] -= t\n                graph[current][prev] += t\n                current = prev\n        else:\n            break\n    return flow\n \n \nn, m, x = [int(i) for i in input().split()]\ngraph = defaultdict(lambda: defaultdict(lambda: 0))\nfor _ in range(m):\n    t = [int(i) for i in input().split()]\n    graph[t[0]][t[1]] = t[2]\n \n \ndef check(k):\n    meh = defaultdict(lambda: defaultdict(lambda: 0))\n    for i in graph:\n        for j in graph[i]:\n            ww = graph[i][j] // k\n            meh[i][j] = ww\n    flow = maxflow(meh, 1, n)\n    return flow\n \n \nlo = 1 / x\nhi = check(1)\n \nfor _ in range(70):\n    mid = round((hi + lo) / 2,9)\n    if check(mid)>=x:\n        lo = round(mid,9)\n    else:\n        hi = mid\nprint(format(lo * x, '.9f'))", "from collections import defaultdict, deque\n \n \ndef bfs(graph, inicio, destino, parent):\n    parent.clear()\n    queue = deque()\n    queue.append([inicio, float(\"Inf\")])\n    parent[inicio] = -2\n    while (len(queue)):\n        current, flow = queue.popleft()\n        for i in graph[current]:\n            if parent[i] == -1 and graph[current][i] > 0:\n                parent[i] = current\n                flow = min(flow, graph[current][i])\n                if i == destino:\n                    return flow\n                queue.append((i, flow))\n    return 0\n \n \ndef maxflow(graph, inicio, destino):\n    flow = 0\n    parent = defaultdict(lambda: -1)\n    while True:\n        t = bfs(graph, inicio, destino, parent)\n        if t:\n            flow += t\n            current = destino\n            while current != inicio:\n                prev = parent[current]\n                graph[prev][current] -= t\n                graph[current][prev] += t\n                current = prev\n        else:\n            break\n    return flow\n \n \nn, m, x = [int(i) for i in input().split()]\ngraph = defaultdict(lambda: defaultdict(lambda: 0))\nfor _ in range(m):\n    t = [int(i) for i in input().split()]\n    graph[t[0]][t[1]] = t[2]\n \n \ndef check(k):\n    meh = defaultdict(lambda: defaultdict(lambda: 0))\n    for i in graph:\n        for j in graph[i]:\n            ww = graph[i][j] // k\n            meh[i][j] = ww\n    flow = maxflow(meh, 1, n)\n    return flow\n \n \nlo = 1 / x\nhi = check(1)\n \nfor _ in range(70):\n    mid = round((hi + lo) / 2,8)\n    if hi-lo<=0.0000001:\n        break\n    if check(mid)>=x:\n        lo = round(mid,7)\n    else:\n        hi = mid\nprint(format(lo * x, '.9f'))", "from queue import Queue\n\ndef addEdge(s, t, flow):\n    E[s].append((len(E[t]), t, flow))\n    E[t].append((len(E[s])-1, s, 0))\n\ndef mkLevel():\n    nonlocal src, des, E, lvl\n    for i in range(n):\n        lvl[i] = -1\n    lvl[src] = 0\n    \n    q = Queue()\n    q.put(src)\n    while (not q.empty()):\n        cur = q.get()\n        for j in range(len(E[cur])):\n            to = E[cur][j][1]\n            if (lvl[to] < 0 and E[cur][j][2] > 0):\n                lvl[to] = lvl[cur] + 1\n                q.put(to)\n                if (to == des):\n                    return True\n    return False\n\ndef extend(cur, lim):\n    nonlocal des, E\n    if (lim == 0 or cur == des):\n        return lim\n    flow = 0\n    for j in range(len(E[cur])):\n        if (flow >= lim):\n            break\n        to = E[cur][j][1]\n        lim0 = min(lim-flow, E[cur][j][2])\n        if (E[cur][j][2] > 0 and lvl[to] == lvl[cur] + 1):\n            newf = extend(to, lim0)\n            if (newf > 0):\n                E[cur][j] = (E[cur][j][0], E[cur][j][1], E[cur][j][2] - newf)\n                jj = E[cur][j][0]\n                E[to][jj] = (E[to][jj][0], E[to][jj][1], E[to][jj][2] + newf)\n                flow += newf\n    if (flow == 0):\n        lvl[cur] = -1\n    return flow\n\ndef Dinic():\n#    for i in range(len(E)):\n#        print('i = {} : {}'.format(i, E[i]), flush = True)\n    flow = 0\n    newf = 0\n    while (mkLevel()):\n        newf = extend(src, INF)\n        while (newf > 0):\n            flow += newf\n            newf = extend(src, INF)\n    return flow\n\ndef check(mid):\n    nonlocal E\n    E = [[] for i in range(n)]\n    for i in range(m):\n        if (w[i] - bears * mid > 0):\n            addEdge(u[i], v[i], bears)\n        else:\n            addEdge(u[i], v[i], int(w[i] / mid))\n    return (Dinic() >= bears)\n\nn,m,bears = list(map(int, input().split()))\n#print(n, m, bears, flush = True)\nINF = 0x3f3f3f3f\nsrc = 0\ndes = n-1\n\nlo = 0.0\nhi = 0.0\n\nu = [0 for i in range(m)]\nv = [0 for i in range(m)]\nw = [0 for i in range(m)]\nfor i in range(m):\n    u[i],v[i],w[i] = list(map(int, input().split()))\n    #print(u[i], v[i], w[i], flush = True)\n    u[i] -= 1\n    v[i] -= 1\n    hi = max(hi, w[i])\n\nE = [[] for i in range(n)]\nlvl = [0 for i in range(n)]\nfor i in range(100):\n    mid = (lo + hi) / 2\n    #print('mid = {:.3f}'.format(mid), flush = True)\n    if (check(mid)):\n        lo = mid\n    else:\n        hi = mid\n\nprint('{:.10f}'.format(mid * bears))\n", "from collections import deque\n\nclass Dinic():\n    def __init__(self, listEdge, s, t):\n        self.s = s\n        self.t = t\n        self.graph    = {}\n        self.maxCap   = 1000000\n        # dict c\u00e1c node l\u00e2n c\u1eadn\n       \n        # e[0]: from,  e[1]: to,  e[2]: dung luong  \n        for e in listEdge:\n            \n            if e[0] not in self.graph:\n                self.graph[e[0]] = []\n             \n            if e[1] not in self.graph:\n                self.graph[e[1]] = []\n                                   #to     #cap   #reveser edge\n            self.graph[e[0]].append([e[1], e[2],  len(self.graph[e[1]])])\n            self.graph[e[1]].append([e[0],    0,  len(self.graph[e[0]])-1])\n            \n        self.N = len(self.graph.keys())\n    \n    def bfs(self):\n        self.dist    = {}\n        self.dist[self.s] = 0\n        self.curIter = {node:[] for node in self.graph}\n        \n        Q = deque([self.s])\n        \n        while(len(Q) > 0):\n            cur = Q.popleft()\n            \n            for index,e in enumerate(self.graph[cur]):\n                # Ch\u1ec9 add v\u00e0o c\u00e1c node k\u1ebf ti\u1ebfp n\u1ebfu dung l\u01b0\u1ee3ng c\u1ea1nh > 0 v\u00e0 ch\u01b0a \u0111\u01b0\u1ee3c visit tr\u01b0\u1edbc \u0111\u1ea5y \n                if e[1] > 0 and e[0] not in self.dist:\n                    self.dist[e[0]] = self.dist[cur] + 1\n                    # add v\u00e0o danh s\u00e1ch node k\u1ebf ti\u1ebfp c\u1ee7a node hi\u1ec7n t\u1ea1i\n                    self.curIter[cur].append(index)\n                    Q.append(e[0])\n        \n        \n    def findPath(self, cur, f):\n        if cur == self.t:\n            return f\n        \n        while len(self.curIter[cur]) > 0:\n            indexEdge    = self.curIter[cur][-1]\n            nextNode     = self.graph[cur][indexEdge][0]\n            remainCap    = self.graph[cur][indexEdge][1]\n            indexPreEdge = self.graph[cur][indexEdge][2]\n            \n            if remainCap > 0 and self.dist[nextNode] > self.dist[cur]:\n                #self.next[cur] = indexEdge\n                flow = self.findPath(nextNode,  min(f, remainCap))\n                \n                if flow > 0:\n                    self.path.append(cur)\n                    self.graph[cur][indexEdge][1]            -= flow\n                    self.graph[nextNode][indexPreEdge][1]    += flow\n                    #if cur == self.s:\n                    #    print(self.path, flow)\n                    return flow \n                #else:\n                    #self.path.pop()\n            self.curIter[cur].pop() \n            \n        return 0\n    \n    def maxFlow(self):\n        maxflow = 0\n        flow = []\n        \n        while(True):\n            self.bfs()\n            \n            if self.t not in self.dist:\n                break\n                \n            while(True):\n                self.path    = []\n                f = self.findPath(self.s, self.maxCap)\n                #print('iter', self.curIter)\n                if f == 0:\n                    break\n                    \n                flow.append(f)    \n                maxflow += f\n            \n        return maxflow    \n\n    # T\u00ecm t\u1eadp node thu\u1ed9c S v\u00e0 T\n    # sau khi \u0111\u00e3 t\u00ecm \u0111\u01b0\u1ee3c max flow\n    def residualBfs(self):\n        Q = deque([self.s])\n        side = {self.s:'s'}\n        \n        while(len(Q) > 0):\n            cur = Q.popleft()\n            \n            for index,e in enumerate(self.graph[cur]):\n                if e[1] > 0 and e[0] not in side:\n                    Q.append(e[0])\n                    side[e[0]] = 's'\n        \n        S = []\n        T = [] \n        for x in self.graph:\n            if x in side:\n                S.append(x)\n            else:\n                T.append(x)\n        return set(S), set(T)\n        \ndef is_ok(val, flow, X):\n    num = 0\n    for f in flow:\n        num += f // val\n        \n    if num >= X:\n        return True\n    return False   \n\nn, m, X = map(int, input().split())\nedge    = [list(map(int, input().split())) for _ in range(m)] \n\nl, r = 0, 1000000\n\nwhile r-l>1e-9:\n    #print(l, r)\n    md = (r+l) / 2\n    edge_ = [[u, v, w // md] for u, v, w in edge] \n    g = Dinic(edge_, 1, n)\n    maxflow = g.maxFlow()\n    \n    if maxflow >= X:\n        l=md\n    else:\n        r=md\n        \nprint(X*r)    "]
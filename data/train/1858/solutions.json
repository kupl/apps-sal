["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n      self.dicts = {}\n      if root:\n        root.val = 0\n        stacks = [root]\n        self.dicts[0] = 1\n        while stacks:\n          new_stacks = []\n          for element in stacks:\n            if element.left: element.left.val = element.val*2 + 1; new_stacks.append(element.left);\\\\\n               self.dicts[element.left.val] = 1\n            if element.right: element.right.val = element.val*2 + 2; new_stacks.append(element.right);\\\\\n               self.dicts[element.right.val] = 1\n          stacks = new_stacks\n        #print (self.dicts)\n        \n        \n\n    def find(self, target: int) -> bool:\n        return target in self.dicts\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.ss = set()\n        self.restoreTree(root, 0)\n        \n        \n    def restoreTree(self, root: TreeNode, val: int):\n        if not root: return\n        else: \n            root.val = val\n            self.ss.add(val)\n        if root.left: self.restoreTree(root.left, 2 * val + 1)\n        if root.right: self.restoreTree(root.right, 2 * val + 2)\n        return\n\n    def find(self, target: int) -> bool:\n        return target in self.ss\n    \\\"\\\"\\\"\\\"\n        root = self.root\n        if not root: return False\n        if root.val == target: return True\n        left, right = False, False\n        if root.left: left = self.findItem(target, root.left)\n        if root.right: right = self.findItem(target, root.right)\n        return left or right\n        \n\n\n    def findItem(self, target: int, root: TreeNode):\n        if not root: return False\n        if root.val == target: return True\n        left, right = False, False\n        if root.left: left = self.findItem(target, root.left)\n        if root.right: right = self.findItem(target, root.right)\n        return left or right\n        \n\\\"\\\"\\\"\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.values = set()\n        def recover(head, val):\n            if head is None:\n                return\n            head.val = val\n            self.values.add(val)\n            recover(head.left, val * 2 + 1)\n            recover(head.right, val * 2 + 2)\n        recover(root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.values\n            \n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        \n    def find(self, target: int) -> bool:\n        \n        stack=[]\n        if target ==0 and self.root:\n            return True\n        \n        while target>0:\n            if target%2:\n                target=(target-1)/2\n                stack.append(\\\"left\\\")\n            else:\n                target=(target-2)/2\n                stack.append(\\\"right\\\")\n                \n        node=self.root\n        if not node or not stack:\n            return False\n        \n        while stack:\n            path=stack.pop()\n            if path==\\\"left\\\":\n                node=node.left\n                if not node:\n                    return False\n            else:\n                node=node.right\n                if not node:\n                    return False\n        return True\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # q=[self.root]\n        # while q:\n        #     width=len(q)\n        #     for _ in range(width):\n        #         node=q.pop(0)\n        #         if node.val == target:\n        #             return True\n        #         if node.left:\n        #             node.left.val=node.val*2+1\n        #             q.append(node.left)\n        #         if node.right:\n        #             node.right.val=node.val*2+2\n        #             q.append(node.right)\n        # return False\n    \n    # def fix_tree(self,root,val):\n    #     if not root:\n    #         return None\n    #     root.val=val\n    #     root.left=self.fix_tree(root.left,val*2+1)\n    #     root.right=self.fix_tree(root.right,val*2+2)\n    #     self.max = max(self.max,val)\n    #     return root\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        def recover(root, val):\n            root.val = val\n            if root.left:\n                recover(root.left, 2*val+1)\n            if root.right:\n                recover(root.right, 2*val+2)\n        recover(root, 0)\n        self._root = root\n\n    def find(self, target: int) -> bool:\n        ops = []\n        while target > 0:\n            if target % 2 == 1:\n                ops = [\\\"l\\\"] + ops\n                target = (target-1)//2\n            else:\n                ops = [\\\"r\\\"] + ops\n                target = (target-2)//2\n        assert target==0\n        node = self._root\n        for op in ops:\n            node = node.left if op == 'l' else node.right\n            if not node:\n                return False\n        return True\n            \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def recover(self, root, val):\n        root.val = val\n        if root.left:\n            self.recover(root.left, 2*val+1)\n        if root.right:\n            self.recover(root.right, 2*val+2)\n    \n    def __init__(self, root: TreeNode):\n        self.recover(root, 0)\n        self._root = root\n\n    def find(self, target: int) -> bool:\n        ops = []\n        while target > 0:\n            if target % 2 == 1:\n                ops = [\\\"l\\\"] + ops\n                target = (target-1)//2\n            else:\n                ops = [\\\"r\\\"] + ops\n                target = (target-2)//2\n        assert target==0\n        node = self._root\n        for op in ops:\n            node = node.left if op == 'l' else node.right\n            if not node:\n                return False\n        return True\n            \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        values = set()\n        def recover(head, val):\n            if head is None:\n                return\n            head.val = val\n            values.add(val)\n            recover(head.left, val * 2 + 1)\n            recover(head.right, val * 2 + 2)\n        recover(root, 0)\n        self.values = values\n\n    def find(self, target: int) -> bool:\n        return target in self.values\n            \n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef recover(root: TreeNode):\n    x = root.val \n    if root.left:\n        root.left.val = 2*x+1\n        recover(root.left)\n    if root.right:\n        root.right.val = 2*x+2\n        recover(root.right)\n        \ndef get_path(n: int) -> List[int]:\n    # x = 2*(2*(2*(2*0 + a) + b) + c) + d\n    # x = 2*(2*(2*a + b) + c) + d\n    # x = 2*(4*a + 2*b + c) + d\n    # x = 8*a + 4*b + 2*c + d\n    \n    # x % 2 = 0 + 0 + 0 + (d%2)\n    # if d == 1 -> d%2 = 1\n    # if d == 2 -> d%2 = 0\n    \n    result = []\n    while n > 0:\n        if n % 2 == 0:\n            digit = 2\n        else:\n            digit = 1\n        \n        result.append(digit)\n        n -= digit\n        n //= 2\n    return result\n        \n        \ndef find(root: TreeNode, path: List[int]) -> bool:\n    if root is None:\n        return False\n    \n    if not path:\n        return True\n    \n    direction = path.pop()\n    if direction == 1:\n        if root.left:\n            root.left.val = 2*root.val+1\n        return find(root.left, path)\n    elif direction == 2:\n        if root.right:\n            root.right.val = 2*root.val+2\n        return find(root.right, path)\n    \n    return False\n\n\nclass FindElements:\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        # recover(root)\n        self.tree = root\n\n    def find(self, target: int) -> bool:\n        self.tree.val = 0 \n        p = get_path(target)\n        return find(self.tree, p)\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef get_path(n: int) -> List[int]:\n    # x = 2*(2*(2*(2*0 + a) + b) + c) + d\n    # x = 2*(2*(2*a + b) + c) + d\n    # x = 2*(4*a + 2*b + c) + d\n    # x = 8*a + 4*b + 2*c + d\n    \n    # x % 2 = 0 + 0 + 0 + (d%2)\n    # if d == 1 -> d%2 = 1\n    # if d == 2 -> d%2 = 0\n    \n    result = []\n    while n > 0:\n        if n % 2 == 0:\n            digit = 2\n        else:\n            digit = 1\n        \n        result.append(digit)\n        n -= digit\n        n //= 2\n    return result\n        \n        \ndef find(root: TreeNode, path: List[int]) -> bool:\n    if root is None:\n        return False\n    \n    if not path:\n        return True\n    \n    direction = path.pop()\n    if direction == 1:\n        if root.left:\n            root.left.val = 2*root.val+1\n        return find(root.left, path)\n    elif direction == 2:\n        if root.right:\n            root.right.val = 2*root.val+2\n        return find(root.right, path)\n    \n    return False\n\n\nclass FindElements:\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        self.tree = root\n\n    def find(self, target: int) -> bool:\n        p = get_path(target)\n        return find(self.tree, p)\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def helper(self, root, level):\n        if not root:\n            return None\n        if level == 0:\n            root.val = 0\n            self.mem.add(root.val)\n        if root.left:\n            root.left.val = root.val * 2 + 1\n            root.left = self.helper(root.left, level + 1)\n            self.mem.add(root.left.val)\n        if root.right:\n            root.right.val = root.val * 2 + 2\n            root.right = self.helper(root.right, level + 1)\n            self.mem.add(root.right.val)\n        return root\n    \n    def __init__(self, root: TreeNode):\n        self.mem = set()\n        self.helper(root, 0)\n        \n        \n\n    def find(self, target: int) -> bool:\n        return target in self.mem\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\ndef dfs(root, rv, s):\n    if not root:\n        return\n    s.add(rv)\n    dfs(root.left, 2 * rv + 1, s)\n    dfs(root.right, 2 * rv + 2, s)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.s = set()\n        dfs(root, 0, self.s)\n\n    def find(self, target: int) -> bool:\n        return target in self.s\n\n\n\\\"\\\"\\\"\n\\\"\\\"\\\"", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def recover(self, node, x):\n        if node is None: return\n        node.val = x\n        self.vals.add(node.val)\n        self.recover(node.left, (2*node.val)+1)\n        self.recover(node.right, (2*node.val)+2)\n\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        self.vals = set()\n        self._root = root\n        self.recover(root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.vals\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.vals = set()\n        \n        def build(root, x):\n            root.val = x\n            self.vals.add(x)\n            if root.left:\n                build(root.left, 2*x + 1)\n            if root.right:\n                build(root.right, 2*x + 2)\n            \n        build(root, 0)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.vals\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        self.r = root\n        def helper(node, value):\n            node.val = value\n            if node.left:\n                helper(node.left, value * 2 + 1)\n            if node.right:\n                helper(node.right, value * 2 + 2)\n        helper(root, 0)\n       \n\n    def find(self, target: int) -> bool:\n        path = target\n        stack = []\n        while path:\n            stack.append(path)\n            if path % 2 == 0:\n                path -= 2\n                if path != 0:\n                    path //= 2\n            else:\n                path -= 1\n                if path != 0:\n                    path //= 2\n        stack.append(0)\n        \n        def finder(s, root):\n            \n            if not s:\n                return True\n            if not root:\n                return False\n            value = s.pop()\n            if root.val == value:\n                if s:\n                    if s[-1] % 2 == 0:\n                        return finder(s, root.right)\n                    else:\n                        return finder(s, root.left)\n                else:\n                    return True\n            else:\n                return False\n        return finder(stack, self.r)\n            \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def dfs_recover(self, root: TreeNode):\n        if not root:\n            return\n        \n        if root.left is not None:\n            root.left.val = 2 * root.val + 1\n            self.all_values.add(root.left.val)\n        \n        if root.right is not None:\n            root.right.val = 2 * root.val + 2\n            self.all_values.add(root.right.val)\n            \n        self.dfs_recover(root.left)\n        self.dfs_recover(root.right)\n            \n    \n    def __init__(self, root: TreeNode):\n        self.all_values = {}\n        if root:\n            root.val = 0\n            self.all_values = {root.val,}\n        self.dfs_recover(root)\n\n    def find(self, target: int) -> bool:\n        return target in self.all_values\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "\nclass FindElements:\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.exists = set()\n\n        def inner(node: TreeNode, my_val: int):            \n            self.exists.add(my_val)\n            if node.left:\n                inner(node.left, 2 * my_val + 1)\n            if node.right:\n                inner(node.right, 2 * my_val + 2)\n\n        inner(self.root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.exists\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        li=['null']\n        self.y=set()\n        def dfs(root,v):\n            if(root):\n                root.val=v\n                self.y.add(root.val)\n                dfs(root.left,2*v+1)\n                dfs(root.right,2*v+2)\n        dfs(root,0)\n        print((self.y))\n    def find(self, target: int) -> bool:\n        if target in self.y:\n            return True\n        else:\n            return False\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.array = {}\n        self.populate_array(root, 0)\n        \n    def populate_array(self, node, count):\n        if not node:\n            return\n        \n        self.array[count] = True\n        self.populate_array(node.left, count * 2 + 1)\n        self.populate_array(node.right, count * 2 + 2)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.array\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "\nclass FindElements:\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.exists = set()\n\n        def inner(node: TreeNode, my_val: int):\n            if not node:\n                return\n\n            self.exists.add(my_val)\n            inner(node.left, 2 * my_val + 1)\n            inner(node.right, 2 * my_val + 2)\n\n        inner(self.root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.exists\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.root = root\n        self.container = set()\n        \n        def helper(root, val):\n\n            if not root:\n                return\n            \n            root.val = val\n            #self.container.add(val)\n            helper(root.left, root.val*2+1)\n            helper(root.right, root.val*2+2)\n                \n        \n        helper(self.root, 0)\n        #print(self.root.val)\n        return\n            \n    def find(self, target: int) -> bool:\n        #\u904d\u5386, \u592a\u6162\n        #def bianli(root, target):\n        #    if not root:\n        #        return False\n        #    \n        #    if root.val == target:\n        #        return True\n        #    \n        #    res = bianli(root.left,target) or bianli(root.right,target)\n        #    return res\n        #\n        #return bianli(self.root, target)\n        \n        #\u56e0\u4e3a\u8fd9\u4e2atree\u7684\u70b9\u4e0d\u91cd\u590d\uff0c\u6240\u4ee5\u53ef\u4ee5\u627e\u51fa\u552f\u4e00\u8def\u5f84\u5230target\n        #\u90a3\u4e48\u5c06\u8fd9\u4e2a\u8def\u5f84\u8d70\u4e00\u904d\uff0c\u5982\u679c\u4e0d\u901a\u5c31\u8bf4\u660e\u627e\u4e0d\u5230\n        \n        def findpath(target):\n            path = [target]\n            while target:\n                diff = 1 if target%2 else 2\n                target = int((target - diff)/2)\n                path.append(target)\n                \n            return path[::-1]\n                \n            \n        def trav(node, depth, path):\n            if depth> len(path):\n                return False\n            else:\n                if not node:\n                    return False\n                if node.val == path[-1]:\n                    return True\n                #print(node.val)\n                if node.val == path[depth]:\n                    res = trav(node.left, depth+1, path) or trav(node.right, depth+1,path)\n                    return res\n            return False\n        \n                    \n        path = findpath(target)\n        #print(path)\n        return trav(self.root, 0, path)\n        \n        # \u8fd8\u6709\u79cd\u529e\u6cd5\u5c31\u662finit\u7684\u65f6\u5019\u5efa\u4e2adict\n        # \u627e\u7684\u65f6\u5019\u76f4\u63a5\u5728dict\u91cc\u627e\n        # return target in self.container\n                \n            \n            \n            \n            \n        \n            \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, R: TreeNode):\n        R.val, V = 0, set()\n        def dfs(R):\n            if R == None or R.left is R.right: return\n            if R.left != None: R.left.val, _ = 2*R.val + 1, V.add(2*R.val + 1)\n            if R.right != None: R.right.val, _ = 2*R.val + 2, V.add(2*R.val + 2)\n            dfs(R.left), dfs(R.right)\n        dfs(R)\n        self.V = V\n    def find(self, t: int) -> bool: return t in self.V\n        \n\n#     def find(self, target: int) -> bool:\n#         return target in self.set\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.root = root\n        \n        def helper(root, val):\n\n            if not root:\n                return\n            \n            root.val = val\n            helper(root.left, root.val*2+1)\n            helper(root.right, root.val*2+2)\n                \n        \n        helper(self.root, 0)\n        #print(self.root.val)\n        return\n            \n    def find(self, target: int) -> bool:\n        #\u904d\u5386, \u592a\u6162\n        #def bianli(root, target):\n        #    if not root:\n        #        return False\n        #    \n        #    if root.val == target:\n        #        return True\n        #    \n        #    res = bianli(root.left,target) or bianli(root.right,target)\n        #    return res\n        #\n        #return bianli(self.root, target)\n        \n        #\u56e0\u4e3a\u8fd9\u4e2atree\u7684\u70b9\u4e0d\u91cd\u590d\uff0c\u6240\u4ee5\u53ef\u4ee5\u627e\u51fa\u552f\u4e00\u8def\u5f84\u5230target\n        #\u90a3\u4e48\u5c06\u8fd9\u4e2a\u8def\u5f84\u8d70\u4e00\u904d\uff0c\u5982\u679c\u4e0d\u901a\u5c31\u8bf4\u660e\u627e\u4e0d\u5230\n        \n        def findpath(target):\n            path = [target]\n            while target:\n                diff = 1 if target%2 else 2\n                target = int((target - diff)/2)\n                path.append(target)\n                \n            return path[::-1]\n                \n            \n        def trav(node, depth, path):\n            if depth> len(path):\n                return False\n            else:\n                if not node:\n                    return False\n                if node.val == path[-1]:\n                    return True\n                #print(node.val)\n                if node.val == path[depth]:\n                    res = trav(node.left, depth+1, path) or trav(node.right, depth+1,path)\n                    return res\n                    \n        path = findpath(target)\n        #print(path)\n        return trav(self.root, 0, path)\n            \n                \n            \n            \n            \n            \n        \n            \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "class FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.value_set = set()\n        root.val = 0\n        self.recover_tree(root)\n\n    def recover_tree(self, root):\n        if root:\n            self.value_set.add(root.val)\n            if root.left:\n                root.left.val = 2 * root.val + 1\n                self.recover_tree(root.left)\n            if root.right:\n                root.right.val = 2 * root.val + 2\n                self.recover_tree(root.right)\n        return root\n\n    def find(self, target: int) -> bool:\n        return target in self.value_set", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef revalue(n, v):\n    if n is None:\n        return\n    n.val = v\n    revalue(n.left, 2*v + 1)\n    revalue(n.right, 2*v + 2)\n    \nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        revalue(root, 0)        \n\n    def find(self, target: int) -> bool:\n        if target == 0:\n            return self.root is not None\n        path = []\n        otarget = target\n        while target:\n            branch = target % 2\n            target //= 2\n            if branch == 0:\n                target -= 1\n            path.append(branch)\n        n = self.root\n        while path:\n            if path.pop():\n                n = n.left\n            else:\n                n = n.right\n            if n is None:\n                return False\n            if n.val == otarget:\n                return True                \n        return False\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def recover(self, node):\n        if not node: \n            return\n        self.memo |= 1 << node.val\n        if node.left:\n            node.left.val = 2 * node.val + 1\n            self.recover(node.left)\n        if node.right:\n            node.right.val = 2 * node.val + 2\n            self.recover(node.right)\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.root.val = 0\n        self.memo = 0\n        self.recover(self.root)\n        \n    def find(self, target: int) -> bool:\n        return self.memo & (1 << target) != 0\n        \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __decontaminate(self, node, val):\n        if not node:\n            return\n        node.val = val\n        self.__decontaminate(node.left, 2*node.val + 1)\n        self.__decontaminate(node.right, 2*node.val + 2)\n        \n    def __init__(self, root: TreeNode):\n        self.__decontaminate(root, 0)\n        self.root = root\n    \n    def __trav(self, node, index, path):\n        if index == len(path):\n            return True\n        if not node:\n            return False\n        if path[index] == node.val:\n            l = self.__trav(node.left, index+1, path)\n            r = self.__trav(node.right, index+1, path)\n            return l or r\n        else:\n            return False\n        \n    def find(self, target: int) -> bool:\n        path = [target]\n        while target:\n            diff = 1 if target%2 else 2\n            target = int((target-diff)/2)\n            path.append(target)\n        path.reverse()\n        return self.__trav(self.root, 0, path)\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        res = []\n        def helper(node, parent = None, left = False, right = False):\n            if node:\n                if parent is None:\n                    node.val = 0 #root\n                    res.append(node.val)\n                else:\n                    if left:\n                        node.val = parent.val*2 + 1\n                        res.append(node.val)\n                    if right:\n                        node.val = parent.val*2 + 2\n                        res.append(node.val)\n                helper(node.left, node, True, False)\n                helper(node.right, node, False, True)\n        helper(root)\n        self.res = set(res)\n        print(root)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.res\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        res = []\n        def helper(node, parentVal = None, left = False, right = False):\n            if node:\n                if parentVal is None:\n                    # node.val = 0 #root\n                    val = 0\n                    res.append(val)\n                else:\n                    if left:\n                        # node.val = parent.val*2 + 1\n                        val = parentVal*2 + 1\n                        res.append(val)\n                    if right:\n                        # node.val = parent.val*2 + 2\n                        val = parentVal*2 + 2\n                        res.append(val)\n                helper(node.left, val, True, False)\n                helper(node.right, val, False, True)\n        helper(root)\n        self.res = set(res)\n        print(root)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.res\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        res = {}\n        def helper(node, parent = None, left = False, right = False):\n            if node:\n                if parent is None:\n                    node.val = 0 #root\n                    res[node.val] = 1\n                else:\n                    if left:\n                        node.val = parent.val*2 + 1\n                        res[node.val] = 1\n                    if right:\n                        node.val = parent.val*2 + 2\n                        res[node.val] = 1\n                helper(node.left, node, True, False)\n                helper(node.right, node, False, True)\n        helper(root)\n        self.res = res\n        print(root)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.res\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        def helper(node, v):\n            if node is None:\n                return\n            node.val = v\n            if node.left:\n                helper(node.left, v * 2 + 1)\n            if node.right:\n                helper(node.right, v * 2 + 2)\n            return\n        self.root = root\n        helper(root, 0)\n        print((self.root))\n        return\n\n    def find(self, target: int) -> bool:\n        target += 1\n        s = target\n        l = 0;\n        while target > 0:\n            target = target >> 1\n            l += 1\n        node = self.root\n        c = 0\n        for c in range(1, l)[::-1]:  # 2, 1 for 111\n            k = s & (1 << (c - 1))\n            if k:\n                if node.right:\n                    node = node.right\n                else:\n                    return False\n            else:\n                if node.left:\n                    node = node.left\n                else:\n                    return False\n        return node and node.val == s - 1\n                     \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def recoverTree(self, node: TreeNode, val: int) -> None: \n        if node:\n            node.val = val\n            self.num_set.add(val)\n            self.recoverTree(node.left, 2 * val + 1)\n            self.recoverTree(node.right, 2 * val + 2)\n            \n        '''\n        if not node.left and not node.right:\n            return None\n        if node.left:\n            node.left.val = 2 * node.val + 1\n            self.num_set.add(node.left.val)\n            self.recoverTree(node.left)\n        if node.right:\n            node.right.val = 2 * node.val + 2\n            self.num_set.add(node.right.val)\n            self.recoverTree(node.right)\n        '''\n        \n    def __init__(self, root: TreeNode):\n        self.num_set = set()\n        self.num_set.add(0)\n        \n        self.recoverTree(root, 0)\n        self.root = root       \n\n    def find(self, target: int) -> bool:\n        if target < self.root.val:\n            return False\n        return target in self.num_set\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElementsDict:\n\n    def dfs_recover(self, root: TreeNode):\n        if not root:\n            return\n        \n        if root.left is not None:\n            root.left.val = 2 * root.val + 1\n            self.all_values.add(root.left.val)\n        \n        if root.right is not None:\n            root.right.val = 2 * root.val + 2\n            self.all_values.add(root.right.val)\n            \n        self.dfs_recover(root.left)\n        self.dfs_recover(root.right)\n            \n    \n    def __init__(self, root: TreeNode):\n        self.all_values = {}\n        if root:\n            root.val = 0\n            self.all_values = {root.val,}\n        self.dfs_recover(root)\n\n    def find(self, target: int) -> bool:\n        return target in self.all_values\n\nclass FindElements:\n\n    def dfs_recover(self, root: TreeNode):\n        if not root:\n            return\n        \n        if root.left is not None:\n            root.left.val = 2 * root.val + 1\n            self.all_values[root.left.val] = True\n        \n        if root.right is not None:\n            root.right.val = 2 * root.val + 2\n            self.all_values[root.right.val] = True\n            \n        self.dfs_recover(root.left)\n        self.dfs_recover(root.right)\n            \n    \n    def __init__(self, root: TreeNode):\n        self.all_values = [False] * 2097152 # 2<<20 = 2097152\n        if root:\n            root.val = 0\n            self.all_values[root.val] = True\n        self.dfs_recover(root)\n\n    def find(self, target: int) -> bool:\n        return self.all_values[target]\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        def helper(node, v):\n            if node is None:\n                return\n            node.val = v\n            if node.left:\n                helper(node.left, v * 2 + 1)\n            if node.right:\n                helper(node.right, v * 2 + 2)\n            return\n        self.root = root\n        helper(root, 0)\n        print((self.root))\n        return\n\n    def find(self, target: int) -> bool:\n        target += 1\n        s = target\n        l = 0;\n        while target > 0:\n            target = target >> 1\n            l += 1\n        node = self.root\n        c = 0\n        print((bin(s)))\n        for c in range(1, l)[::-1]:  # 2, 1 for 111\n            k = s & (1 << (c - 1))\n            print(k)\n            if k:\n                if node.right:\n                    node = node.right\n                    print((node.val, s-1))\n                else:\n                    return False\n            else:\n                if node.left:\n                    node = node.left\n                else:\n                    return False\n        return node and node.val == s - 1\n                     \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        root = self.recover(root)\n        self.root = root\n        self.inorder = self.Inorder(root)\n\n    def recover(self, root: TreeNode) -> TreeNode:\n        if root is None:\n            return\n        if root.left:\n            root.left.val = 2*root.val + 1\n        if root.right:\n            root.right.val = 2*root.val + 2\n            \n        self.recover(root.left)\n        self.recover(root.right)\n        \n        return root\n    \n    def Inorder(self, root):\n        lis = []\n        if root:\n            lis = self.Inorder(root.left)\n            lis.append(root.val)\n            lis = lis + self.Inorder(root.right)\n            \n        return lis\n\n    def find(self, target: int) -> bool:\n        root = self.root\n        lis = self.inorder\n        lis.sort()\n        \n        return self.binarySearch (lis, 0, len(lis) -1, target)\n    \n    def binarySearch (self, lis: List[int], l: int, r: int, target: int) -> bool:\n        if r>=l:\n            mid = l+(r-l)//2\n            if lis[mid] == target:\n                return True\n            elif lis[mid] > target:\n                return self.binarySearch(lis, l, mid-1, target)\n            else:\n                return self.binarySearch(lis, mid+1, r, target)\n        else:\n            return False\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        root.val = 0\n        nodes = [root]\n        self.elements = [root.val]\n        while nodes:\n            node = nodes.pop(0)\n            val = node.val\n            if node.right is not None:\n                self.elements.append(2 * val + 2)\n                node.right.val = 2 * val + 2\n                nodes.append(node.right)\n            if node.left is not None:\n                self.elements.append(2 * val + 1)\n                node.left.val = 2 * val + 1\n                nodes.append(node.left)\n\n    def find(self, target: int) -> bool:\n        try:\n            value = self.elements.index(target)\n            return True\n        except ValueError:\n            return False\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# things learnt ..\n# Try to check the first attempt and see if you can find the mistake\n# we need a set or seen here .. \n\n\n# Second Attempt\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        \n        # fill using top down approach\n        self.result = []\n        q = []\n        if root is None:\n            return False\n        q.append((root, 0))\n        self.result.append(0)\n        while len(q) > 0 :\n            node, value = q.pop(0)\n            #print(\\\" node \\\", node)\n            #print(\\\"value is \\\", value)\n            if node.left is not None:\n                temp = (value*2) +1\n                self.result.append(temp)\n                q.append((node.left, temp))\n                \n                \n            if node.right is not None:\n                temp = (value*2) +2\n                self.result.append(temp)\n                q.append((node.right, temp))\n        print((self.result))\n#         def helper(root, value):\n#             #base\n            \n\n            \n            \n#             if root.left is None and root.right is None:\n#                 print(\\\"base case\\\")\n#                 self.result.append(value)\n#                 print(\\\"both null\\\")\n#                 print(\\\"self.result \\\", self.result.copy())\n#             #recursion\n#             elif root.left is not None:\n#                 self.result.append(value)\n#                 temp = (value*2) +1\n#                 helper(root.left, temp )\n#                 print(\\\"left not null\\\")\n#                 print(\\\"self.result \\\", self.result.copy())\n#             elif root.right is not None:\n#                 self.result.append(value)\n#                 temp = (value*2) +2\n#                 helper(root.right, temp )\n#                 print(\\\"right not null\\\")\n#                 print(\\\"self.result \\\", self.result.copy())\n        \n#         if root is None:\n#             return False\n#         helper(root, 0)\n#         print(self.result)\n#         return \n        \n        \n\n    def find(self, target: int) -> bool:\n        return True if target in self.result else False\n        \n        \n\n\n\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\n# first attempt\n# below code almost looks ok , but it doesn't pass all test cases.\n\n# class FindElements:\n#     result = []\n#     def __init__(self, root: TreeNode):\n#         #result = []\n        \n#         # fill using top down approach\n#         def helper(root, value):\n#             #base\n#             if root.left is None and root.right is None:\n#                 self.result.append(value)\n#             #recursion\n#             elif root.left is not None:\n#                 self.result.append(value)\n#                 temp = (value*2) +1\n#                 helper(root.left, temp )\n#                 #print(\\\"left not null\\\")\n#                 #print(\\\"self.result \\\", self.result)\n#             elif root.right is not None:\n#                 self.result.append(value)\n#                 temp = (value*2) +2\n#                 helper(root.right, temp )\n#                 #print(\\\"right not null\\\")\n#                 #print(\\\"self.result \\\", self.result)\n        \n#         if root is None:\n#             return False\n#         helper(root, 0)\n#         print(self.result)\n#         return \n        \n        \n\n#     def find(self, target: int) -> bool:\n#         return True if target in self.result else False\n        \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# things learnt ..\n# Try to check the first attempt and see if you can find the mistake\n# we need a set or seen here .. \n\n\n# Second Attempt\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        \n        # fill using top down approach\n        self.result = []\n        q = []\n        if root is None:\n            return False\n        q.append((root, 0))\n        self.result.append(0)\n        while len(q) > 0 :\n            node, value = q.pop(0)\n            #print(\\\" node \\\", node)\n            #print(\\\"value is \\\", value)\n            if node.left is not None:\n                temp = (value*2) +1\n                self.result.append(temp)\n                q.append((node.left, temp))\n                \n                \n            if node.right is not None:\n                temp = (value*2) +2\n                self.result.append(temp)\n                q.append((node.right, temp))\n        print((self.result))\n        \n    def find(self, target: int) -> bool:\n        return True if target in self.result else False\n        \n        \n\n\n\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\n# first attempt\n# below code almost looks ok , but it doesn't pass all test cases.\n\n# class FindElements:\n#     result = []\n#     def __init__(self, root: TreeNode):\n#         #result = []\n        \n#         # fill using top down approach\n#         def helper(root, value):\n#             #base\n#             if root.left is None and root.right is None:\n#                 self.result.append(value)\n#             #recursion\n#             elif root.left is not None:\n#                 self.result.append(value)\n#                 temp = (value*2) +1\n#                 helper(root.left, temp )\n#                 #print(\\\"left not null\\\")\n#                 #print(\\\"self.result \\\", self.result)\n#             elif root.right is not None:\n#                 self.result.append(value)\n#                 temp = (value*2) +2\n#                 helper(root.right, temp )\n#                 #print(\\\"right not null\\\")\n#                 #print(\\\"self.result \\\", self.result)\n        \n#         if root is None:\n#             return False\n#         helper(root, 0)\n#         print(self.result)\n#         return \n        \n        \n\n#     def find(self, target: int) -> bool:\n#         return True if target in self.result else False\n        \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def recoverTree(self, node: TreeNode) -> None: \n        if not node.left and not node.right:\n            return None\n        if node.left:\n            node.left.val = 2 * node.val + 1\n            self.num_set.add(node.left.val)\n            self.recoverTree(node.left)\n        if node.right:\n            node.right.val = 2 * node.val + 2\n            self.num_set.add(node.right.val)\n            self.recoverTree(node.right)\n        \n    def __init__(self, root: TreeNode):\n        root.val = 0\n        self.num_set = set()\n        self.num_set.add(0)\n        self.recoverTree(root)\n        self.root = root\n        \n        \n\n    def find(self, target: int) -> bool:\n        if target < self.root.val:\n            return False\n        return target in self.num_set\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.l=[0]\n        self.root=root\n        self.root.val=0\n        d=deque()\n        d.append(root)\n        while d:\n            x=d.popleft()\n            if x.left:\n                x.left.val=x.val*2+1\n                d.append(x.left)\n                self.l.append(x.left.val)\n            if x.right:\n                x.right.val=x.val*2+2\n                d.append(x.right)\n                self.l.append(x.right.val)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.l\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.store = self.get_nodes(root)\n\n    def get_nodes(self, root: TreeNode) -> list:\n        result = []\n        if root is not None:\n            start = root\n            start.val = 0\n            seq = [start]\n            while seq:\n                store = []\n                for i in seq:\n                    result.append(i.val)\n                    if i.left is not None:\n                        left = i.left\n                        left.val = i.val * 2 + 1\n                        store.append(left)\n                    if i.right is not None:\n                        right = i.right\n                        right.val = i.val * 2 + 2\n                        store.append(right)\n                seq = store\n        return result\n\n    def find(self, target: int) -> bool:\n        if target in self.store:\n            return True\n        else:\n            return False\n        \n\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def rebuild(self,root:TreeNode):\n        queue=[]\n        root.val=0\n        queue.append(root)\n        while queue:\n            new=queue.pop(0)\n            if new.left:\n                new.left.val=2*new.val+1\n                self.collection.append(new.left.val)\n                queue.append(new.left)\n            if new.right:\n                new.right.val=2*new.val+2\n                self.collection.append(new.right.val)\n                queue.append(new.right)\n\n    def __init__(self, root: TreeNode):\n        self.copy=root\n        self.collection=[0]\n        self.rebuild(self.copy)\n        \n        \n    def find(self, target: int) -> bool:\n\n        return target in self.collection\n    \n\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def __init__(self, root):\n        root.val = 0\n        self.res = [0]\n        \n        def dfs(root):\n            if root is None:\n                return\n            if root.left :\n                root.left.val = 2*(root.val) + 1\n                \n                dfs(root.left)\n            if root.right :\n                root.right.val = 2*(root.val) + 2\n                dfs(root.right)\n            self.res.append(root.val)\n        dfs(root)  \n        \n    def find(self, target):\n        return target in self.res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.root.val = 0\n        queue = []\n        queue.append(root)\n        self.values = []\n        while(len(queue)>0):\n            current = queue.pop(0)\n            leftval = 2*current.val + 1\n            rightval = 2*current.val + 2\n            \n            if(current.left is not None):\n                current.left.val = leftval\n                queue.append(current.left)\n                self.values.append(current.left.val)\n            if(current.right is not None):\n                current.right.val = rightval\n                queue.append(current.right)\n                self.values.append(current.right.val)\n            \n\n    def find(self, target: int) -> bool:\n        if (target in self.values):\n            return True\n      \n            \n                \n            \n                        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.val_list = []\n        def construct(node, val):\n            if not node:\n                return None\n            node.val = val\n            self.val_list.append(val)\n            node.left = construct(node.left, 2*val+1)\n            node.right = construct(node.right, 2*val+2)\n            return node\n        self.root = construct(root, 0)\n        \n\n    def find(self, target: int) -> bool:\n        '''\n        root = self.root\n        def traverse(node):\n            if not node:\n                return False\n            if node.val == target:\n                return True\n            elif target < node.val:\n                return False\n            else:\n                return traverse(node.left) or traverse(node.right)\n        return traverse(root)\n        '''\n        return target in self.val_list\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements: \n    \n    def dfs (self, root,x, Node_vals) : \n        \n        if not root : \n            return  \n        \n        root.val = x \n        Node_vals.append (x)\n        \n        self.dfs (root.left , 2*x + 1,Node_vals)\n        self.dfs (root.right, 2*x + 2, Node_vals)\n        \n        return Node_vals\n    \n    def __init__(self, root: TreeNode):\n        self.N_V = self.dfs (root, 0, [])\n        \n    def find(self, target: int) -> bool:\n        \n        return target in self.N_V\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.val_list = []\n        def construct(node, val):\n            if not node:\n                return None\n            #node.val = val\n            self.val_list.append(val)\n            construct(node.left, 2*val+1)\n            construct(node.right, 2*val+2)\n            return node\n        self.root = construct(root, 0)\n        \n\n    def find(self, target: int) -> bool:\n        '''\n        root = self.root\n        def traverse(node):\n            if not node:\n                return False\n            if node.val == target:\n                return True\n            elif target < node.val:\n                return False\n            else:\n                return traverse(node.left) or traverse(node.right)\n        return traverse(root)\n        '''\n        return target in self.val_list\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        self.values=[]\n        self.tree=root\n        \n        def preorder(node, value):\n            self.values.append(value)\n            node.val=value\n            if node.left:\n                preorder(node.left, value*2+1)\n            if node.right:\n                preorder(node.right, value*2+2)\n        \n        preorder(root, 0)\n        \n        \n    def find(self, target: int) -> bool:\n        return target in self.values\n                \n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.root.val = 0\n        self.values = []\n        self.__init(self.root)\n        \n    def __init(self, node):\n        if node.left:\n            value = 2 * node.val + 1\n            node.left.val = value\n            self.values.append(value)\n            self.__init(node.left)\n            \n        if node.right:\n            value = 2 * node.val + 2\n            node.right.val = value\n            self.values.append(value)\n            self.__init(node.right)\n\n            \n    def __find(self, node, target) -> bool:\n        if not node: \n            return False\n        \n        if node.val == target:\n            return True\n        \n        return self.__find(node.left, target) \\\\\n            or self.__find(node.right, target)\n    \n    def find(self, target: int) -> bool:\n        return target in self.values\n        # return self.__find(self.root, target)\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.d = collections.defaultdict(int)\n        def recover(root,l,r,p):\n            if not l and not r:\n                root.val = 0\n                \n            elif r and not l:\n                \n                root.val = 2*p+2\n            elif l and not r:\n                root.val = 2*p+1\n            self.d[root.val]+=1\n            if root.left: root.left = recover(root.left, True, False, root.val)\n            if root.right: root.right = recover(root.right, False, True, root.val)\n            return root\n        if root:\n            node = recover(root, False,False, None)\n        \n                \n            \n            \n            \n        \n\n    def find(self, target: int) -> bool:\n        return (target in self.d)\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.elements = []\n        def traverse(node,x):\n            self.elements.append(x)\n            if node.left != None:\n                traverse(node.left,2*x+1)\n            if node.right != None:\n                traverse(node.right,2*x+2)\n        traverse(root,0)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.elements\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        self._all_vals = []\n        def recover(root, val):\n            root.val = val\n            self._all_vals.append(val)\n            if root.left:\n                recover(root.left, 2*val+1)\n            if root.right:\n                recover(root.right, 2*val+2)\n        recover(root, 0)\n        self._root = root\n\n    def find(self, target: int) -> bool:\n        return target in self._all_vals            \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    treeroot = TreeNode()\n    l = []\n    def __init__(self, root: TreeNode):\n        def correct(root):\n            if root:\n                if root.right:\n                    root.right.val = 2*(root.val)+2\n                    correct(root.right)\n                if root.left:\n                    root.left.val = 2*(root.val)+1\n                    correct(root.left)\n            return\n        \n        root.val = 0\n        correct(root)\n        self.treeroot = root\n        self.l = self.inorder(self.treeroot)\n    def inorder(self,root):\n            if root:\n                return self.inorder(root.left) + [root.val] + self.inorder(root.right)\n            return []\n    def find(self, target: int) -> bool:\n        \n        return (target in self.l)\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.tot_val = []\n        def dfs(root, new_val):\n            if not root:\n                return\n            root.val = new_val\n            self.tot_val.append(new_val)\n            if   root.left:\n                dfs(root.left, new_val * 2+ 1)\n            if   root.right:\n                dfs(root.right, new_val * 2+ 2)    \n        self.root = root\n        dfs(self.root,0)\n        \n\n    def find(self, target: int) -> bool:\n        if target in self.tot_val:\n            return True\n        else:\n            return False\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass FindElements:\n\n    def __init__(self, root: TreeNode):        \n        self.m = []\n        \n        q = [root]\n        root.val = 0\n        while q:\n            node = q.pop()\n            if node.left: \n                node.left.val = 2*node.val+1\n                self.m.append(node.left.val)\n                q.append(node.left)\n            if node.right:\n                node.right.val = 2*node.val+2\n                q.append(node.right)\n                self.m.append(node.right.val)     \n\n    def find(self, target: int) -> bool:\n        return target in self.m\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        if not root:\n            return root\n        self.root = root\n        self.root.val = 0\n        self.vals = []\n        self.vals.append(self.root.val)\n        self.construct(self.root)\n        print((self.vals))\n        \n        \n    def construct(self, root):\n        if root.left:\n            root.left.val = 2*root.val + 1\n            self.vals.append(root.left.val)\n            self.construct(root.left)\n        if root.right:\n            root.right.val = 2*root.val + 2\n            self.vals.append(root.right.val)\n            self.construct(root.right)\n        return root\n\n    def find(self, target: int) -> bool:\n        if target in self.vals:\n            return True\n        return False\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    rootNode = None\n    elements = None\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        self.rootNode = root\n        self.elements = []\n        self.recover(self.rootNode)\n        \n    def recover(self, node):\n        self.elements.append(node.val)\n        if node.left!=None:\n            node.left.val = 2*node.val+1\n            self.recover(node.left)\n        if node.right!=None:\n            node.right.val = 2*node.val+2\n            self.recover(node.right)\n\n\n    def find(self, target: int) -> bool:\n        return (target in self.elements)\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef recover(root, nodes):\n    nodes.append(root.val)\n    if root.left:\n        root.left.val = 2*(root.val) + 1\n        recover(root.left, nodes)\n    if root.right:\n        root.right.val = 2*(root.val) + 2\n        recover(root.right, nodes)\n    \nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        nodes = []\n        recover(root, nodes)\n        self.tree = root\n        self.nodes = nodes\n\n    def find(self, target: int) -> bool:\n        return target in self.nodes\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.values = list()\n        self.regen(root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.values\n\n    def regen(self, root, v):\n        if root == None: return\n        \n        root.val = v\n        self.values.append(v)\n        \n        self.regen(root.left, 2*v+1)\n        self.regen(root.right, 2*v+2)\n        \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    '''\n    Algo:\n    Iterate through the tree and restore the values of each node\n    Add the node to a stack\n        - with height of root\n        - left or right info\n            - left = 0, right = 1\n            - (node, root_height, isRight)\n    Iterate through the stack and calculate the value for the node\n    using val = 2 * root_height + (1 + isRight)\n    \n    After nodes are fixed then iterate through the tree to find the node\n    by adding all nodes to a stack\n    '''\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        node_list = []\n        self.val_list = []\n        if root:\n            root.val = 0\n            self.val_list.append(root.val)\n            node_list.append((root.left, 0, 0))\n            node_list.append((root.right, 0, 1))\n            while len(node_list) > 0:\n                cur_node, root_val, isRight = node_list.pop(-1)\n                if cur_node:\n                    print(f\\\"root_val: {root_val}, isRight: {isRight}\\\")\n                    cur_node.val = 2 * root_val + (1 + isRight)\n                    self.val_list.append(cur_node.val)\n                    node_list.append((cur_node.left, cur_node.val,\n                                     0))\n                    node_list.append((cur_node.right, cur_node.val,\n                                     1))\n        \n\n    def find(self, target: int) -> bool:\n        # def dfs(node, val_list):\n        #     if node:\n        #         dfs(node.left, val_list)\n        #         val_list.append(node.val)\n        #         dfs(node.right, val_list)\n        # val_list = []\n        # dfs(self.root, val_list)\n        # print(val_list)\n        return target in self.val_list\n                \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        def recover(head, val):\n            # if not head \u6bd4 if head is None \u5feb\n            # \u5728 TreeNode \u4e0b\u4e24\u8005\u7b49\u4ef7\uff0c\u4f46\u6ce8\u610f\u540e\u8005\u66f4\u89c4\u8303\n            # x = []\n            # if not x      -- True\n            # if x is None  -- False\n            if not head:\n                return\n            head.val = val\n            recover(head.left, val * 2 + 1)\n            recover(head.right, val * 2 + 2)\n        recover(root, 0)\n\n    def find(self, target: int) -> bool:\n        steps = bin(target + 1)[3:]\n        head = self.root\n        for s in steps:\n            if not head:\n                return False\n            if s == '0':\n                head = head.left\n            else:\n                head = head.right\n        return head and head.val == target\n        \n            \n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.all=[]\n        def helperIter(root):\n            val =0\n            if not root:\n                return\n            \n            stack = [(root, val)]\n            while stack:\n                curr, val = stack.pop()\n                curr.val = val\n                if curr.left:\n                    self.all.append(2*val+1)\n                    stack.append((curr.left, 2*val +1))\n                if curr.right:\n                    self.all.append(2*val +2)\n                    stack.append((curr.right, 2*val +2))\n            \n        def helper(root, val):\n            if not root:\n                return\n\n            if root:\n                root.val= val\n                self.all.append(val)\n            \n            if root.left:\n                helper(root.left, 2*val +1)\n            if root.right:\n                helper(root.right, 2*val +2)\n        \n        # helper(root, 0)\n        helperIter(root)\n        \n                    \n\n    def find(self, target: int) -> bool:\n        return target in self.all\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.q = []\n        def search(node, value):\n            if node:\n                self.q.append(value)\n                search(node.left, value*2 + 1)\n                search(node.right, value*2 + 2)\n        search(root,0)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.q\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.allval = self._fix(root, 0)\n\n    def find(self, target: int) -> bool:\n        return target in self.allval\n    \n    def _fix(self, node, root_val):\n        if node is None:\n            return []\n        \n        node.val = root_val\n        lv = self._fix(node.left, 2*root_val+1)\n        rv = self._fix(node.right, 2*root_val+2)\n        \n        return [root_val] + lv + rv\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.root.val = 0\n        self.result = [0]\n        self.dfs(self.root)\n    def dfs(self,root):\n        if not root:\n            return\n        if root.left:\n            root.left.val = 2*root.val + 1\n            self.result.append(root.left.val)\n            self.dfs(root.left)\n        if root.right:\n            root.right.val = 2*root.val + 2\n            self.result.append(root.right.val)\n            self.dfs(root.right)\n\n    def find(self, target: int) -> bool:\n        return target in self.result\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    #list1=[]\n    \n\n    def __init__(self, root: TreeNode):\n        root.val=0\n        self.list1=[]\n        self.helper(root)\n        \n    def helper(self,root):\n        if not root:\n            return\n        self.list1.append(root.val)\n        if root.left:\n            root.left.val=2*root.val+1\n            \n        if root.right:\n            root.right.val=2*root.val+2\n           # print(self.list1)\n        self.helper(root.left)\n        self.helper(root.right)\n   # print(\\\"list1\\\",list1)\n    \n        \n    \n\n    def find(self, target: int) -> bool:\n        if target in self.list1:\n            return True\n        return False\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        stack=[root]\n        root.val=0\n        self.l=[]\n        while stack:\n            r=stack.pop()\n            self.l.append(r.val)\n            if r.left:\n                stack.append(r.left)\n                r.left.val=2*r.val+1\n            if r.right:\n                stack.append(r.right)\n                r.right.val=2*r.val+2\n        #print(self.l)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.l\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        self.vals = []\n        self.createTree(root, 0)\n    \n    def createTree(self, root, val):\n        root.val = val\n        self.vals.append(val)\n        if root.left is not None:\n            self.createTree(root.left, 2*root.val+1)\n            \n        if root.right is not None:\n            self.createTree(root.right, 2*root.val+2)\n    \n    def find(self, target: int) -> bool:\n        return target in self.vals   \n        #return self.findRec(target, self.root)\n        \n    def findRec(self, target, root):\n        if root.val == target:\n            #print(\\\"val\\\", root.val)\n            #print(\\\"target\\\", target)\n            #print(\\\"match\\\")\n            return True\n        if root.left is not None:     \n            if self.findRec(target, root.left):\n                #print(\\\"val\\\", root.val)\n                #print(\\\"target\\\", target)\n                #print(\\\"leftChildMatch\\\")\n                return True\n        if root.right is not None:\n            if self.findRec(target, root.right):\n                #print(\\\"val\\\", root.val)\n                #print(\\\"target\\\", target)\n                #print(\\\"rightChildMatch\\\")\n                return True\n        return False\n    \n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.data = []\n        \n        def walk(node, v):\n            if(not node):\n                return\n            \n            self.data.append(v)\n            walk(node.left, 2*v+1)\n            walk(node.right, 2*v+2)\n        \n        walk(root, 0)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.data\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        def helper(root,val):\n            if root is None:\n                return \n            root.val=val\n            helper(root.left,2*val+1)\n            helper(root.right,2*val+2)\n        helper(root,0)\n        self.array=[]\n        \n        def help(root):\n            if root is None:\n                return\n            help(root.left)\n            self.array.append(root.val)\n            help(root.right)\n        help(root)   \n        \n        \n\n    def find(self, target: int) -> bool:\n        if target in self.array:\n            return True\n        return False\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    def __init__(self, R: TreeNode):\n        R.val, V = 0, set()\n        def dfs(R):\n            if R == None or R.left is R.right: return\n            if R.left != None: R.left.val, _ = 2*R.val + 1, V.add(2*R.val + 1)\n            if R.right != None: R.right.val, _ = 2*R.val + 2, V.add(2*R.val + 2)\n            dfs(R.left), dfs(R.right)\n        dfs(R)\n        self.V = V\n    def find(self, t: int) -> bool: return t in self.V\n\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        stack = [[root.left,1,0],[root.right,2,0]]\n        self.ans = [0]\n        while stack:\n            x = stack.pop(0)\n            if x[0] is not None:\n                val = (x[2]*2) + x[1]\n                self.ans.append(val)\n                stack.append([x[0].left,1,val])\n                stack.append([x[0].right,2,val])\n        print((self.ans))\n\n    def find(self, target: int) -> bool:\n        return target in self.ans\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.val =  []\n        root.val = 0 \n        self.root = self.helper(root) #use dictionary to store vals\n        \n        \n        \n    def helper(self,root):\n        if root:\n            self.val.append(root.val)\n            if root.left:\n                root.left.val = 2 * root.val + 1\n                l = self.helper(root.left)\n            if root.right:\n                root.right.val = 2 * root.val + 2\n                r = self.helper(root.right)\n            return root\n        return \n        \n\n    def find(self, target: int) -> bool:\n        \n        return target in self.val\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.ans = []\n        \n        def dfs(node,x):\n            if not node:\n                return\n            \n            node.val = x\n            self.ans.append(x)\n            dfs(node.left,2*x+1)\n            dfs(node.right,2*x+2)\n            \n            return\n        \n        dfs(root,0)\n\n    def find(self, target: int) -> bool:\n        return target in self.ans\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root=root\n        self.root.val=0\n        self.arr=[]\n        self.fix(self.root)\n        \n    def fix(self,currentNode):\n        self.arr.append(currentNode.val)\n        if currentNode.left:\n            \n            currentNode.left.val=2*currentNode.val+1\n            self.fix(currentNode.left)\n        if currentNode.right:\n            \n            currentNode.right.val=2*currentNode.val+2\n            self.fix(currentNode.right)\n        \n        \n\n    def find(self, target: int) -> bool:\n        \n        if target in self.arr:\n            return True\n        else:\n            return False\n        \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.root = root\n        root.val = 0\n        self.nodes = []\n        \n        self.recoverTree(root, 0)\n        \n    def recoverTree(self, root, x):\n        current = root\n        \n        if current:\n            print((current.val, x))\n            if current.val == x:\n                self.nodes.append(current.val)\n                if current.left:\n                    current.left.val = 2 * x + 1\n                    self.recoverTree(current.left, current.left.val)\n                \n                if current.right:\n                    current.right.val = 2 * x + 2\n                    self.recoverTree(current.right, current.right.val)\n                    \n    \n    def find(self, target: int) -> bool:\n        if target in self.nodes:\n            return True\n        \n        else:\n            return False\n \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.val =  []\n        root.val = 0 \n        self.root = self.helper(root)\n        \n        \n        \n    def helper(self,root):\n        if root:\n            self.val.append(root.val)\n            if root.left:\n                root.left.val = 2 * root.val + 1\n                l = self.helper(root.left)\n            if root.right:\n                root.right.val = 2 * root.val + 2\n                r = self.helper(root.right)\n            return root\n        return \n        \n\n    def find(self, target: int) -> bool:\n        \n        return target in self.val\n        # return self.helper2(self.root, target)\n        \n        \n    '''def helper2(self, root, target):\n        if root:\n            if root.val == target:\n                return True\n            if root.val \n            l = self.helper2(root.left, target)\n            r = self.helper2(root.right, target)\n            return l or r  \n        return False\n    '''\n        \n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n    \n    def recover(self, root):\n        if not root:\n            return \n        \n        x = root.val\n        \n        if root.left:\n            node_val = 2*x + 1\n            root.left.val = node_val\n            self.values.append(node_val)\n            \n        if root.right:\n            node_val = 2*x + 2\n            root.right.val = node_val\n            self.values.append(node_val)\n            \n        self.recover(root.left)\n        self.recover(root.right)\n        \n        return root\n    \n    def traverse(self,root):\n        if not root:\n            return \n        \n        print((root.val))\n        self.traverse(root.left)\n        self.traverse(root.right)\n        \n    \n    def __init__(self, root: TreeNode):\n        root.val = 0\n        self.values = [0]\n        self.root = self.recover(root)\n        \n        \n        \n#     def find_target(self,target,root):\n        \n#         if not root:\n#             return False\n        \n#         if root.val == target:\n#             return True\n        \n#         else:\n#             return self.find_target(target,root.left) or self.find_target(target,root.right)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.values\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.arr = []\n        def convert(curr):\n            if curr:\n                x = curr.val\n                \n                self.arr.append(x)\n                if curr.left:\n                    curr.left.val = 2 * x + 1\n                if curr.right:\n                    curr.right.val = 2 * x + 2\n                \n                convert(curr.left)\n                convert(curr.right)\n        \n        root.val = 0\n        convert(root)\n        \n\n    def find(self, target: int) -> bool:\n        \n        return target in self.arr\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        stack = [root]\n        self.values = []\n        \n        while stack:\n            cur = stack.pop()\n                \n            if cur.right:\n                cur.right.val = cur.val * 2 + 2\n                self.values.append(cur.right.val)\n                stack.append(cur.right)\n\n                \n            if cur.left:\n                cur.left.val = cur.val * 2 + 1\n                self.values.append(cur.left.val)\n                stack.append(cur.left)\n        \n\n    def find(self, target: int) -> bool:\n        if target in self.values: return True\n        return False\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.data = set()\n        \n        def walk(node, v):\n            if(not node):\n                return\n            \n            self.data.add(v)\n            walk(node.left, 2*v+1)\n            walk(node.right, 2*v+2)\n        \n        walk(root, 0)\n        \n\n    def find(self, target: int) -> bool:\n        return target in self.data\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        root.val = 0\n        self.recList = []\n        self.recover(root)\n        \n    def recover(self, root):\n        if root != None:\n            self.recList.append(root.val)\n            if root.left != None:\n                root.left.val = 2*root.val +1\n                self.recover(root.left)\n            if root.right != None:\n                root.right.val = 2*root.val +2\n                self.recover(root.right)\n            \n    def find(self, target: int) -> bool:\n        if target in self.recList:\n            return True\n        else:\n            return False\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        root.val = 0\n        self.vals = []\n        \n        def trav(node, prev, isLeft):\n            if node.val != 0:\n                if isLeft:\n                    val = 2 * prev + 1\n                    node.val = val\n                    self.vals.append(val)\n                else:\n                    val = 2 * prev + 2\n                    node.val = val\n                    self.vals.append(val)\n            if node.left:\n                trav(node.left, node.val, True)\n            if node.right:\n                trav(node.right, node.val, False)\n                    \n        trav(root, 0, None)\n        self.root = root\n        \n\n    def find(self, target: int) -> bool:\n        \n        return target in self.vals\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        self.tree = root\n        self.values = []\n        from collections import deque\n        stack = deque()\n        stack.append(root)\n        root.val = 0\n        curr = root\n        while stack:\n            if curr:\n                self.values.append(curr.val)\n                if curr.left:\n                    curr.left.val = 2 * curr.val + 1\n                if curr.right:\n                    curr.right.val = 2 * curr.val + 2\n                    stack.append(curr.right)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n\n    def find(self, target: int) -> bool:\n        if target in self.values:\n            return True\n        else:\n            return False\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n        \n        self.values = []\n        \n        def evaluate(node, value):\n            \n            if not node:\n                return\n            \n            node.val = value\n            \n            self.values.append(value)\n            \n            evaluate(node.left, value * 2 + 1) \n            evaluate(node.right, value * 2 + 2) \n        \n        evaluate(root, 0)\n        \n    def find(self, target: int) -> bool:\n        \n        return target in self.values\n        \n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n"]
["class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        fullLake = {}\n        dry = {}\n\n        for day, lake in enumerate(rains):\n            if lake not in fullLake:\n                if lake:\n                    fullLake[lake]=day\n            else:\n                if lake:\n                    dry[fullLake[lake]] = day\n                    fullLake[lake]=day\n        heap=[]\n        for day, lake in enumerate(rains):\n            if heap and day >= heap[0][0]:\n                return []\n            if lake:\n                if day in dry:\n                    heapq.heappush(heap, (dry[day], lake))\n                rains[day] = -1\n            else:\n                if heap:\n                    rains[day] = heapq.heappop(heap)[1]\n                else:\n                    rains[day] = 1\n        return rains", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        filled = {}\n        deadline = {}\n\n        for day, lake in enumerate(rains):\n            if lake not in filled:\n                if lake:\n                    filled[lake] = day\n            else:\n                if lake:\n                    deadline[filled[lake]] = day\n                    filled[lake] = day\n\n        heap = []\n\n        for day, lake in enumerate(rains):\n            if heap and day >= heap[0][0]:\n                return []\n            if lake:\n                if day in deadline:\n                    heapq.heappush(heap, (deadline[day], lake))\n                rains[day] = -1\n            else:\n                if heap:\n                    rains[day] = heapq.heappop(heap)[1]\n                else:\n                    rains[day] = 1\n        return rains", "from heapq import heappush,heappop\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n         d=collections.defaultdict(list);last=[]\n         for idx,lake in enumerate(rains):\n              d[lake].append(idx)\n         ans=[]\n         for idx,lake in enumerate(rains):\n             if lake:\n                if last and last[0]==idx:\n                    return []\n                arr=d[lake]\n                arr.pop(0)\n                if arr:\n                    heappush(last,arr[0])\n                ans.append(-1)\n             else:\n                 if last:\n                    ans.append(rains[heappop(last)])\n                 else:\n                    ans.append(1)\n         return ans", "from sortedcontainers import SortedSet \n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        could_dry = SortedSet()\n        last_rain = {}\n        dry = {}\n        for idx, rain in enumerate(rains):\n            if rain == 0:\n                could_dry.add(idx)\n            else:\n                if rain not in last_rain:\n                    last_rain[rain] = idx\n                else:  # need to find a dry\n                    i = could_dry.bisect_left(last_rain[rain])\n                    if i == len(could_dry):\n                        return []  # could not find a good dry day\n                    else:\n                        day = could_dry[i]\n                        dry[day] = rain\n                        could_dry.remove(day)\n                    last_rain[rain] = idx\n        res = []\n        for idx, rain in enumerate(rains):\n            if rain == 0:\n                res.append(dry.get(idx, 1))\n            else:\n                res.append(-1)\n        return res\n            \n", "'''\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        ret = []\n        def dfs(i, has_water, ans):\n            i#print(i, has_water,ans)\n            nonlocal ret\n            if ret: return\n            if i == n:  ret = ans; return \n            if rains[i] in has_water:  return \n            if rains[i]:  dfs(i+1, has_water|set([rains[i]]), ans+[-1])\n            else:\n                if not has_water: dfs(i+1, has_water, ans+[1])\n                for lake in has_water:\n                    has_water.remove(lake)\n                    dfs(i+1, has_water, ans+[lake])\n                    has_water.add(lake)\n        dfs(0, set(), [])\n        return ret\n                    \n'''            \n            \nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        # min heap to store the days when flooding would happen (if lake not dried)\n        nearest = []\n        # dict to store all rainy days\n        # use case: to push the subsequent rainy days into the heap for wet lakes\n        locs = collections.defaultdict(collections.deque)\n        # result - assume all days are rainy\n        res = [-1] * len(rains)\n        \n        # preprocessing - {K: lake, V: list of rainy days}\n        for i, lake in enumerate(rains):\n            locs[lake].append(i)\n            \n        for i, lake in enumerate(rains):\n            # the nearest lake got flooded (termination case)\n            if nearest and nearest[0] == i:\n                return []\n            \n            # lake got wet\n            if lake != 0:\n                # pop the wet day\n                locs[lake].popleft()\n                \n                # priotize the next rainy day for this lake\n                if locs[lake]:\n                    nxt = locs[lake][0]\n                    heapq.heappush(nearest, nxt)\n            # a dry day\n            else:\n                # no wet lake, append an arbitrary value\n                if not nearest:\n                    res[i] = 1\n                else:\n                    # dry the lake that has the highest priority\n                    # since that lake will be flooded in nearest future otherwise (greedy property)\n                    next_wet_day = heapq.heappop(nearest)\n                    wet_lake = rains[next_wet_day]\n                    res[i] = wet_lake\n        \n        return res", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        closest = []\n        locations = collections.defaultdict(collections.deque)\n        for index, lake in enumerate(rains):\n            locations[lake].append(index)\n        res = []\n        for index, lake in enumerate(rains):\n            if closest and closest[0] == index:\n                return []\n            if not lake:\n                if not closest:\n                    res.append(1) \n                    continue\n                nxt = heapq.heappop(closest)\n                res.append(rains[nxt])\n            else:\n                l = locations[lake]\n                l.popleft()\n                if l:\n                    nxt = l[0]\n                    heapq.heappush(closest, nxt)\n                res.append(-1)\n        return res", "from collections import deque, defaultdict\nimport heapq\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        rq = defaultdict(deque)\n        for i, r in enumerate(rains):\n            rq[r].append(i)\n        for r, q in list(rq.items()):\n            q.popleft()\n        ans = [-1] * len(rains)\n        urgent = []\n        for i, r in enumerate(rains):\n            if r != 0:\n                q = rq[r]\n                if q:\n                    heapq.heappush(urgent, q.popleft())\n            elif urgent:\n                d = heapq.heappop(urgent)\n                if d < i:\n                    return []\n                ans[i] = rains[d]\n            else:\n                ans[i] = 1\n        return ans if not urgent else []\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lakes = {}\n        dries = []\n        res = []\n        for i, rain in enumerate(rains):\n            if rain == 0:\n                dries.append(i)\n                res.append(1)\n            else:\n                if rain in lakes:\n                    if len(dries) == 0:\n                        return []\n                    idx = bisect_left(dries, lakes[rain])\n                    if idx == len(dries):\n                        return []\n                    res[dries.pop(idx)] = rain\n                lakes[rain] = i\n                res.append(-1)\n        return res", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lakes = {}\n        dries = []\n        res = [-1] * len(rains)\n        for i, rain in enumerate(rains):\n            if rain == 0:\n                if lakes:\n                    dries.append(i)\n                else:\n                    res[i] = 1\n            elif rain in lakes:\n                if len(dries) == 0:\n                    return []\n                idx = bisect_right(dries, lakes[rain])\n                if idx == len(dries):\n                    return []\n                res[dries.pop(idx)] = rain\n                lakes[rain] = i\n            else:\n                lakes[rain] = i\n        for d in dries:\n            if lakes:\n                res[d] = lakes.popitem()[0]\n            else:\n                res[d] = 1\n        return res", "from collections import defaultdict, deque\nimport heapq\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        res = [-1] * len(rains)\n        dic = defaultdict(deque)\n        \n        for idx, rain in enumerate(rains):\n            dic[rain].append(idx)\n        \n        pq = []\n        full = set()\n        for i in range(len(rains)):\n            \n            if rains[i]:\n                if rains[i] in full:\n                    return []\n                else:\n                    full.add( rains[i] )\n                    dic[ rains[i] ].popleft()\n                if dic[ rains[i] ]:\n                    heapq.heappush( pq, dic[ rains[i] ][0] )\n                    \n            else:\n                if not pq:\n                    res[i] = 1\n                else:\n                    lake = rains[ heapq.heappop(pq) ]\n                    res[i] = lake\n                    full.discard(lake)\n        \n        return res\n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        floods, n, visited, water_heap = None, len(rains), defaultdict(int), []\n        \n        for i in range(n - 1, -1, -1):\n            if rains[i]:\n                if rains[i] in visited:\n                    floods = i, visited[rains[i]], floods\n                visited[rains[i]] = i\n        \n        for i in range(n):\n            if not rains[i]:\n                while floods and floods[0] < i:\n                    start, end, floods = floods\n                    heapq.heappush(water_heap, (end, start))\n                \n                if not water_heap:\n                    rains[i] = 1\n                else:\n                    end,start = heappop(water_heap)\n                    if end < i: return []\n                    rains[i] = rains[end]\n            else:\n                rains[i] = -1\n        \n        \n        if water_heap or floods:\n            return []\n        return rains", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        full= set()\n        priority = []\n        toReturn = []\n        for i in rains:\n            if i != 0:\n                if i in full: priority.append(i)\n                else: full.add(i)\n        full = set()\n        for i in rains:\n            if i == 0:\n                done = False\n                for x in range(len(priority)):\n                    if priority[x] in full:\n                        a = priority.pop(x)\n                        toReturn.append(a)\n                        full.remove(a)\n                        done = True\n                        break\n                if not done:\n                    toReturn.append(1)\n            elif i in full: return []\n            else:\n                full.add(i)\n                toReturn.append(-1)\n        return toReturn\n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \\\"\\\"\\\"\n        #O(n^2) working sol\n        ans = [1 for i in range(len(rains))]\n        d = collections.defaultdict(int)\n        d[0]=0\n        \n        for i in range(len(rains)):\n            d[rains[i]]+=1\n            if rains[i]==0:\n                #look for the nearest value that exists in the dict we got\n                for x in range(i+1,len(rains)):\n                    if rains[x] in d and not rains[x]==0:\n                        #print(d,d[rains[x]],rains[x])\n                        d[0]-=1\n                        ans[i] = rains[x]\n                        d[rains[x]]-=1\n                        if d[rains[x]]==0: del d[rains[x]]\n                        break\n            else:\n                #you gotta get out early of a bad pattern that cannot be salvaged\n                if d[rains[i]]>1:\n                    return []\n                ans[i] = -1\n        \n        return ans\n        \\\"\\\"\\\"\n        \n        ans = [1 for i in range(len(rains))]\n        d = collections.defaultdict(int)\n        d[0]=0\n        #preprosess, find all  #:0#0#0...\n        # as d grows, put corresponding value here in a heap\n        # every time heap pops, we get the nearest value that exists in the dict we got\n        p = {}\n        x = collections.defaultdict(int)\n        x[0] = 0\n        for i in range(len(rains)):\n            if rains[i] in p:\n                #print(x[0],rains[i],x[rains[i]])\n                if x[0]>=x[rains[i]]:\n                    p[rains[i]] += [i]\n            else:\n                p[rains[i]] = []\n            x[rains[i]]+=1\n        p[0] = []\n            \n        #print(p)       \n            \n        s= set()\n        h = []\n        for i in range(len(rains)):\n\n            d[rains[i]]+=1\n\n            if rains[i]!=0 and rains[i] not in s:\n                if rains[i] in p and p[rains[i]] != []:\n                    for j in p[rains[i]]:\n                        heappush(h,j)\n                s.add(rains[i])\n            #print(d,h)\n             \n            if rains[i]==0:\n                #look for the nearest value that exists in the dict we got\n                if h:\n                    pop = heappop(h)\n                    d[0]-=1\n                    \n                    ans[i] = rains[pop]\n                    if rains[pop] not in d:\n                        rains[pop] = 1\n                    else:\n                        d[rains[pop]]-=1\n                    if d[rains[pop]]==0: del d[rains[pop]] \n            else:\n                \n                #you gotta get out early of a bad pattern that cannot be salvaged\n                if d[rains[i]]>1:\n                    return []\n                #find the next equal closest value past a zero.\n                ans[i] = -1\n            #print(h,i,\\\"heap at end\\\")\n        \n        return ans\n        \n        \n        \n        \n                \n        \n                \n            \n            \n        \n            \n        \n                        \n                        \n        \n                \n       \n        \n                \n                \n                ", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        N=len(rains)\n        ans=[-1]*N\n        drydays=[]\n        last={}\n        for i,e in enumerate(rains):\n            if e==0:\n                drydays+=i,\n            else:\n                if e in last:\n                    lastIndex=last[e]\n                    j=bisect_right(drydays,lastIndex)\n                    if j<len(drydays):\n                        ans[drydays[j]]=e\n                        del drydays[j]\n                    else:\n                        return []\n                last[e]=i\n                \n        #populate drydays\n        for d in drydays:\n            ans[d]=1\n        return ans", "def avoid(rains):\n    zeros = []\n    full = {}\n    sol = [-1]*len(rains)\n\n    for ix,r in enumerate(rains):\n        if r == 0:\n            zeros.append(ix)\n        elif r not in full:\n            full[r] = ix\n        else:\n            # we're gonna have a flood\n            if not zeros:\n                return []\n\n            zix = None\n            rix = full[r]\n            for i in range(len(zeros)):\n                if zeros[i] > rix:\n                    zix = zeros.pop(i)\n                    break\n\n            if not zix:\n                return []\n\n            sol[zix] = r\n            full[r] = ix # update filling day\n\n    while zeros:\n        sol[zeros.pop()] = 1\n\n    return sol\n\n\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        return avoid(rains)\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1] * len(rains)\n        lake_to_days = collections.defaultdict(list)\n        full_lakes = set()\n        to_empty = []\n        \n        for day, lake in enumerate(rains):\n            lake_to_days[lake].append(day)\n        \n        for day in range(len(rains)):\n            lake = rains[day]\n            if lake:\n                if lake in full_lakes:\n                    return []\n                full_lakes.add(lake)\n                lake_to_days[lake].pop(0)\n                if lake_to_days[lake]:\n                    heapq.heappush(to_empty, lake_to_days[lake][0])\n            else:\n                if to_empty:\n                    ans[day] = rains[heapq.heappop(to_empty)]\n                    full_lakes.remove(ans[day])\n                else:\n                    ans[day] = 1\n        return ans\n        \n        \n                    \n        \n        \n        \n            \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        fill = {}\n        dry = []\n        ans = [0]*len(rains)\n        for i,v in enumerate(rains):\n            if v == 0:\n                dry.append(i)\n                continue\n            if v not in fill:\n                fill[v] = i\n                ans[i] = -1\n            elif v in fill:\n                idx = bisect.bisect_left(dry,fill[v])\n                if idx == len(dry):\n                    return []\n                else:\n                    ans[dry[idx]] = v\n                    dry.pop(idx)\n                fill[v] = i\n                ans[i] = -1\n        for i in range(len(ans)):\n            if ans[i] == 0:\n                ans[i] = 1\n        return ans", "# 1488. Avoid Flood in The City\n\nimport heapq\n\n'Your country has an infinite number of lakes.'\n'Initially, all lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water.'\n'If it rains over a full lake, there will be a flood.'\n'Your goal is to avoid flood.'\n'On each dry day you may choose to dry one lake.'\n\ndef drying_strategy (rains):\n    # Idea: greedy method\n    # Always dry the lake which is most urgent.\n    # Never dry already-dry lakes, unless no lakes are full.\n\n    # Alternate method: orthogonal.\n    # Consider each lake and how many times you should dry it.\n    # Ignore any lake that is only filled once.\n\n    # Maintain a heap of (lake, urgency) for filled lakes.\n    # Whenever a lake is filled, its urgency is pushed into the heap.\n    # Whenever we can dry a lake, we take the most urgent task on the top of the heap.\n\n    last_rain = {} # updating\n    chain_rain = {} # persistent, link from one rain to next\n\n    for time, rain in enumerate (rains):\n        if rain > 0:\n            if rain in last_rain:\n                chain_rain[last_rain[rain]] = time\n            last_rain[rain] = time\n\n    del last_rain\n\n    urgency = []\n    filled = set ()\n\n    solution = []\n\n    for time, rain in enumerate (rains):\n        if rain > 0:\n            if rain in filled:\n                # flooded\n                return []\n            else:\n                filled.add (rain)\n                if time in chain_rain: # has next rain\n                    heapq.heappush (urgency, chain_rain[time])\n                    # add next rain\n            solution.append (-1) # wait\n        else:\n            # clear day. find the next urgent and dry.\n            solved = False\n            while not solved:\n                if not urgency:\n                    solution.append (1)\n                    if 1 in filled: filled.remove (1)\n                    solved = True\n                else:\n                    time = heapq.heappop (urgency)\n                    rain = rains[time]\n                    if rain not in filled:\n                        pass # nothing to worry about\n                    else:\n                        solution.append (rain)\n                        filled.remove (rain)\n                        solved = True\n\n    return solution\n\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        return drying_strategy(rains)", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        '''\nLogics:\nWe dry lakes in the order of urgency - Greedy.\nIterating through days, when day i is raining on lake lake, if lake is already full, simply return []; else, push the next raining day for lake to to_empty to queue it for drying.\nWhen day i is sunny, dry the most urgent lake referring to to_empty. Remember to remove it from full.\n        '''\n        # dic stores the raining day for each lake in ascending order.\n        dic = collections.defaultdict(list)\n        for day,lake in enumerate(rains):\n            dic[lake].append(day)\n            \n        res = [-1] * len(rains)\n        to_empty = [] # index,Min-heap and records the lakes that are full and sorted in urgency order.\n        for i in range(len(rains)):\n            lake = rains[i]\n            if lake:\n                if dic[lake] and dic[lake][0] < i:\n                    return []\n                if dic[lake] and len(dic[lake])>1:\n                    heapq.heappush(to_empty,dic[lake][1])\n            else:\n                if to_empty:\n                    res[i] = rains[heapq.heappop(to_empty)]\n                    dic[res[i]].pop(0)\n                else:\n                    res[i] = 1\n        return res", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        output = [-1] * len(rains)\n        \n        dic = dict()\n        stack = []\n        \n        for i, n in enumerate(rains):\n            if n == 0:\n                stack.append(i)\n            elif n not in dic:\n                dic[n] = i\n            else:\n                if not stack:\n                    return []\n                \n                for j in stack:\n                    if j > dic[n]:\n                        break\n                \n                if j < dic[n]:\n                    return []\n                # print(stack)\n                stack.pop(stack.index(j))\n                output[j] = n\n                dic[n] = i\n        \n        for j in stack:\n            output[j] = 1\n        \n        return output", "\\\"\\\"\\\"\n[1,2,3,4]\nrain[i] = 0 -> \u62bd\u6c34\u65e5\n    dryDay.insert(i)\nrain[i] = x\n1) x is empty: fill[x] = i\n2) x is full: when to drain x?\n    must be in dryDays\n    must be later than fill[x]\n    \n      1  2  3  4  5  6\nfill  x     y     x \ndryD     -     x \n\n\n\\\"\\\"\\\"\n\n\n\nclass Solution:\n    def avoidFlood(self, rains):\n        filled = {}\n        dryDays = []\n        res = [1] * len(rains)\n\n        for day, lake in enumerate(rains):\n            if not lake:\n                dryDays.append(day)\n                continue \n\n            res[day] = -1\n            if lake in filled:\n                if not dryDays: return []\n                # use the first dry day after the lake was filled (stored in filled[lake])\n                idx = bisect.bisect_left(dryDays, filled[lake])\n                if idx >= len(dryDays): \n                    return []\n                dry_on_day = dryDays.pop(idx)\n                res[dry_on_day] = lake\n\n            filled[lake] = day # we fill it on day\n\n        return res\n        \n        \n        \n        \n        ", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n\n        res = []\n        free_day = [] # days without rain\n        filled = {}   # map of cities that are full (but not flooded) -> day that they were filled\n\n        for day,city in enumerate(rains):\n            if city: \n                res.append(-1)\n                if city not in filled:                                       # 1\n                    filled[city] = day                                       # 1\n                else:\n                    if free_day and (free_day[-1] > filled[city]):           # 3.1\n                        dry_day = bisect.bisect_left(free_day, filled[city]) # 3.3\n                        res[free_day.pop(dry_day)] = city                    # 3.3\n                        filled[city] = day                                   # 3.3\n                    else:\n                        return []                                            # 3.2\n            else:\n                res.append(1)                                                # 2 (we will fill in rain free days later ~ use city 1 as a place holder)\n                free_day.append(day)                                         # 2\n\n        return res\n                        \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \\\"\\\"\\\"\n            using deque canDry to store the possible days that can be used to dry a lake\n            using hasRain to store the lake : day pairs\n            update rules:\n                1) if lake rains[i] rains on day i, check if it has rained before or not\n                    if it has rained before, check if there is a way to dry it \n                        binary search the interval between two rain days\n                    if there is no way to dry it, return []\n                2) if there is no rain on day i, put i in canDry\n        \\\"\\\"\\\"\n        dry, res, rained = [], [], {}\n        \n        for i, lake in enumerate(rains):\n            if lake > 0: # lake rains on day i\n                res.append(-1)\n                if lake in rained: # lake has rained before\n                    idx = bisect.bisect(dry, rained[lake]) # search for the index of the \n                    if idx < len(dry): # a valid day is found to dry lake\n                        day = dry[idx]\n                        res[day] = lake\n                        dry.pop(idx)\n                        rained[lake] = i\n                    else:\n                        return []\n                else: # lake has not rained before\n                    rained[lake] = i\n            else: # no rain on day i\n                dry.append(i)\n                res.append(0)\n        \n        for day in dry:\n            res[day] = 1\n        return res\n       ", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        ans = [-1] * n\n        \n        last = {}\n        \n        dry_days = []\n        \n        for idx, r in enumerate(rains):\n            if r == 0:\n                dry_days.append(idx)\n            else:\n                if r in last:\n                    found = False\n                    j = 0\n                    while j < len(dry_days):\n                        if dry_days[j] > last[r]:\n                            ans[dry_days[j]] = r\n                            found = True\n                            break\n                        j += 1\n                    \n                    if not found:\n                        return []\n                    dry_days.pop(j)\n                last[r] = idx\n        \n        while dry_days:\n            dry_day = dry_days.pop()\n            ans[dry_day] = 1\n        \n        return ans\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1] * len(rains)\n        nearest = []\n        locs = defaultdict(deque)\n        for i, lake in enumerate(rains):\n            locs[lake].append(i)\n        for i, lake in enumerate(rains):\n            if nearest and nearest[0] == i:\n                return []\n            if lake == 0:\n                if not nearest:\n                    ans[i] = 1\n                else:\n                    n = heappop(nearest)\n                    ans[i] = rains[n]\n            else:\n                locs[lake].popleft()\n                if locs[lake]:\n                    heappush(nearest, locs[lake][0])\n        return ans", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1488 lang=python3\n#\n# [1488] Avoid Flood in The City\n#\n# https://leetcode.com/problems/avoid-flood-in-the-city/description/\n#\n# algorithms\n# Medium (25.27%)\n# Total Accepted:    9.6K\n# Total Submissions: 38.1K\n# Testcase Example:  '[1,2,3,4]'\n#\n# Your country has an infinite number of lakes. Initially, all the lakes are\n# empty, but when it rains over the nth lake, the nth lake becomes full of\n# water. If it rains over a lake which is full of water, there will be a flood.\n# Your goal is to avoid the flood in any lake.\n#\n# Given an integer array rains where:\n#\n#\n# rains[i] > 0 means there will be rains over the rains[i] lake.\n# rains[i] == 0 means there are no rains this day and you can choose one lake\n# this day and dry it.\n#\n#\n# Return an array ans where:\n#\n#\n# ans.length == rains.length\n# ans[i] == -1 if rains[i] > 0.\n# ans[i] is the lake you choose to dry in the ith day\u00a0if rains[i] == 0.\n#\n#\n# If there are multiple valid answers return any of them. If it is impossible\n# to avoid flood return an empty array.\n#\n# Notice that if you chose to dry a full lake, it becomes empty, but if you\n# chose to dry an empty lake, nothing changes. (see example 4)\n#\n#\n# Example 1:\n#\n#\n# Input: rains = [1,2,3,4]\n# Output: [-1,-1,-1,-1]\n# Explanation: After the first day full lakes are [1]\n# After the second day full lakes are [1,2]\n# After the third day full lakes are [1,2,3]\n# After the fourth day full lakes are [1,2,3,4]\n# There's no day to dry any lake and there is no flood in any lake.\n#\n#\n# Example 2:\n#\n#\n# Input: rains = [1,2,0,0,2,1]\n# Output: [-1,-1,2,1,-1,-1]\n# Explanation: After the first day full lakes are [1]\n# After the second day full lakes are [1,2]\n# After the third day, we dry lake 2. Full lakes are [1]\n# After the fourth day, we dry lake 1. There is no full lakes.\n# After the fifth day, full lakes are [2].\n# After the sixth day, full lakes are [1,2].\n# It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another\n# acceptable scenario.\n#\n#\n# Example 3:\n#\n#\n# Input: rains = [1,2,0,1,2]\n# Output: []\n# Explanation: After the second day, full lakes are  [1,2]. We have to dry one\n# lake in the third day.\n# After that, it will rain over lakes [1,2]. It's easy to prove that no matter\n# which lake you choose to dry in the 3rd day, the other one will flood.\n#\n#\n# Example 4:\n#\n#\n# Input: rains = [69,0,0,0,69]\n# Output: [-1,69,1,1,-1]\n# Explanation: Any solution on one of the forms [-1,69,x,y,-1], [-1,x,69,y,-1]\n# or [-1,x,y,69,-1] is acceptable where 1 <= x,y <= 10^9\n#\n#\n# Example 5:\n#\n#\n# Input: rains = [10,20,20]\n# Output: []\n# Explanation: It will rain over lake 20 two consecutive days. There is no\n# chance to dry any lake.\n#\n#\n#\n# Constraints:\n#\n#\n# 1 <= rains.length <= 10^5\n# 0 <= rains[i] <= 10^9\n#\n#\nclass DisjointSet():\n    def __init__(self, size=10):\n        self.data = list(range(size))\n\n    def find(self, i):\n        if i == self.data[i]: return i\n        else:\n            j = self.find(self.data[i])\n            self.data[i] = j\n            return j\n\n    def merge(self, i):\n        self.data[i] = i + 1\n\n\nclass Solution:\n    def method2(self, rains: List[int]) -> List[int]:\n        # Using disjoint set to sole the problem. check the C++ solution\n        # to see how this method work\n        n = len(rains)\n        cc = {}\n        ds = DisjointSet(n)\n        i = 0\n        while i < n:\n            if rains[i] == 0:\n                rains[i] = 1\n            else:\n                lake = rains[i]\n                if lake in cc:\n                    available_dry_day = ds.find(cc[lake])\n                    # otherwise there is no available day to dry a lake before i\n                    if available_dry_day < i:\n                        rains[available_dry_day] = lake\n                        ds.merge(available_dry_day)\n                    else:\n                        return []\n                cc[lake] = i\n                ds.merge(i)\n                # Modify rain in place and return it on exiting the program to avoid\n                # allocating extra space.\n                rains[i] = -1\n            i+=1\n        return rains\n\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        return self.method2(rains)\n\n        n = len(rains)\n        cc = defaultdict(int)\n        dry = list()\n        res = []\n        for i, r in enumerate(rains):\n            if r == 0:\n                dry.append(i)\n                res.append(1)\n            else:\n                if r not in cc:\n                    cc[r] = i\n                else:\n                    last_idx = cc[r]\n                    j = bisect_left(dry, last_idx)\n                    if j == len(dry): return []\n                    day = dry[j]\n                    del dry[j]\n                    res[day] = r\n                    cc[r] = i\n                res.append(-1)\n        return res\n\n\nsol = Solution()\n\nrains = [1, 2, 3, 4]\n# rains = [1,2,0,0,2,1]\n# rains = [1,2,0,1,2]\nrains = [69, 0, 0, 0, 69]\n# rains = [10,20,20]\nrains = [1, 0, 2, 3, 0, 1, 2]\nrains = [1, 2, 0, 0, 2, 1]\n", "import heapq\nfrom collections import deque, defaultdict\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ret = [-1 for i in rains]\n        \n        rain_days = defaultdict(deque)\n        \n        for i, lake in enumerate(rains):\n            if lake != 0:\n                rain_days[lake].append(i)\n        \n        to_drain = []\n        \n        for i, lake in enumerate(rains):\n            if lake == 0:\n                if len(to_drain) == 0:\n                    ret[i] = 1\n                else:\n                    day, lake = heapq.heappop(to_drain)\n                    if day < i:\n                        return []\n                    ret[i] = lake\n            else:\n                if len(rain_days[lake]) > 1:\n                    rain_days[lake].popleft()\n                    heapq.heappush(to_drain, (rain_days[lake][0], lake))\n        \n        if len(to_drain) > 0:\n            return []\n        \n        return ret", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lakes = defaultdict(deque)\n        \n        for day, lake in enumerate(rains):\n            lakes[lake].append(day)\n        \n        N = len(rains)\n        res = [1]*N\n        heap = [] # days in order of indicies\n        \n        for day, lake in enumerate(rains):\n            if lake:\n                lakes[lake].popleft() # current\n                if lakes[lake]:\n                    next_lake_day = lakes[lake][0]\n                    heappush(heap, next_lake_day)\n                res[day] = -1\n            else:\n                if heap:\n                    chosen_day = heappop(heap)\n                    if chosen_day < day:\n                        return []\n                    res[day] = rains[chosen_day]\n        \n        return res if not heap else []\n                \n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        res = [-1] * n\n        dry = []\n        rained = {}\n        for i, r in enumerate(rains):\n            if r:\n                if r not in rained:\n                    rained[r] = i\n                else:\n                    if not dry:\n                        return []\n                    else:\n                        idx = bisect.bisect_left(dry, rained[r])\n                        if idx == len(dry):\n                            return []\n                        res[dry[idx]] = r\n                        dry.pop(idx)\n                        rained[r] = i\n                        \n            else:\n                dry.append(i)\n        for i in dry:\n            res[i] = 1\n        return res", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        a = rains\n        n = len(a)\n        j = 0\n        ans = [-1] * n\n        v = {}\n        q = []\n        for i in range(n):\n            c = a[i]\n            if c:\n                if c in v:\n                   # print(i, q)\n                    j = bisect.bisect(q, v[c])\n                    if j == len(q):\n                        return []\n                    else:\n                        ans[q[j]] = c\n                        q.pop(j)\n                v[c] = i\n            else:\n                q.append(i)\n        while q:\n            ans[q.pop()] = 1\n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from collections import defaultdict, deque\n        closest = []\n        locs = defaultdict(deque)\n        res = []\n        for i, lake in enumerate(rains):\n            locs[lake].append(i)\n        for i,rain in enumerate(rains):\n            # print(closest, rain)\n            if closest and closest[0] == i:\n                return []\n            if rain:\n                locs[rain].popleft()\n                if locs[rain]:\n                    heapq.heappush(closest, locs[rain][0])\n                res.append(-1)\n            else:\n                if closest:\n                    dry = heapq.heappop(closest)\n                    res.append(rains[dry])\n                else:\n                    res.append(1)\n        return res", "# rains: \u6bcf\u4e2a\u6570\u4ee3\u8868\u4e00\u573a\u96e8\uff0c\u7b2ci\u573a\u96e8\u4e0b\u5728rains[i]\u7684\u8fd9\u4e2alake\u4e0a\n# res: -1\u8868\u793a\u4e0b\u96e8\uff0c\u4e0d\u80fd\u6392\u6c34\u3002res[i]\u8868\u793a\u8981\u6392\u5e72\u7684\u90a3\u4e2alake\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        # brute force\n        lakesFull = {}\n        n = len(rains)\n        dry = []\n        res = []        \n        for i in range(n):\n            #print (\\\"res:\\\" + str(res))\n            #print(\\\"dry:\\\" + str(dry))\n            #print(\\\"lakesFull:\\\" + str(lakesFull))\n            l = rains[i]\n            if l == 0:\n                dry.append(i)\n                res.append(-10000000)\n                continue\n            else:\n                if l in lakesFull:\n                    if len(dry) > 0:\n                        di = -1\n                        for dd in range(len(dry)):\n                            if dry[dd] > lakesFull[l]:\n                                di = dry[dd]\n                                dry.pop(dd)\n                                break\n                        #if i == 10: print(\\\"di\\\" + str(di))\n                        if di >= 0:\n                            res[di] = l\n                            del lakesFull[l]\n                        else: \n                            return []\n                    else:\n                        return []\n                lakesFull[l] = i\n                res.append(-1)\n        #print (res)\n        #print (dry)\n        #print (lakesFull)\n        for i in range(n):\n            if res[i] == -10000000: res[i] = 1\n        return res", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        full= set()\n        drys = []\n        filled = {}\n        for i in range(len(rains)):\n            if not rains[i]:\n                drys.append(i)\n            else:\n                if rains[i] in full:\n                    if not drys: return []\n                    if drys[-1] < filled[rains[i]]: return []\n                    index = bisect.bisect(drys, filled[rains[i]])\n                    rains[drys.pop(index)] = rains[i]\n                else:\n                    full.add(rains[i])\n                filled[rains[i]] = i\n                rains[i] = -1\n        rains= [1 if i == 0 else i for i in rains]\n        return rains\n                \n", "class Solution:\n    def avoidFlood(self, rains):\n        filled, dry_days = {}, []\n        ans = [1] * len(rains)\n\n        for day, lake in enumerate(rains):\n            if not lake:\n                dry_days.append(day)\n                continue \n\n            ans[day] = -1\n            if lake in filled:\n                if not dry_days: return []\n                # use the first dry day after the lake was filled (stored in filled[lake])\n                dry_on_day_index = bisect.bisect_left(dry_days, filled[lake])\n                if dry_on_day_index >= len(dry_days): return []\n                dry_on_day = dry_days.pop(dry_on_day_index)\n                ans[dry_on_day] = lake\n\n            filled[lake] = day # we fill it on day\n\n        return ans\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        d = {}\n        dry = []\n        res = []\n        for day,rain in enumerate(rains):\n            if rain !=0:\n                if rain in d:\n                    p = d[rain]\n                    flag = -1\n                    for dry_day in dry:\n                        if dry_day > p:\n                            flag = dry_day\n                            break\n                    if flag == -1:\n                        return []\n                    res[flag] = rain\n                    dry.remove(flag)\n                    d[rain] = day\n                else:\n                    d[rain] = day\n                res.append(-1)\n            else:\n                dry.append(day)\n                res.append(56)\n        return res", "from typing import Set, List\nfrom copy import deepcopy\nimport bisect\n\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        full_lakes = dict()\n        dry_days = list()\n        ans = list()\n        \n        for day, lake in enumerate(rains):\n            if lake == 0:\n                # print(f\\\"Append {day} to dry days\\\")\n                dry_days.append(day)\n                ans.append(1)\n            else:\n                if lake not in full_lakes:\n                    # print(f\\\"Fill lake {lake} at day {day}\\\")\n                    full_lakes[lake] = day\n                elif dry_days:\n                    filled_at = full_lakes[lake]\n                    index = bisect.bisect_right(dry_days, filled_at)\n                    # print(f\\\"Dry days are {dry_days}\\\")\n                    # print(f\\\"Try to empty lake {lake} filled at day {filled_at}\\\")\n                    \n                    if index == len(dry_days):\n                        # print(f\\\"Can't find a dry day to empty lake {lake}\\\")\n                        return list()\n                    \n                    # print(f\\\"Use day {dry_days[index]} to empty lake {lake}\\\")\n                    \n                    ans[dry_days[index]] = lake\n                    del dry_days[index]\n                    full_lakes[lake] = day\n                else:\n                    return list()\n                    \n                ans.append(-1)\n                \n        return ans\n        \n        \n            \n        \n        \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        rains_over_city = {}\n        lake_drying_days = []\n        \n        ind = 0\n        for rain in rains:\n            if rain > 0:\n                rain_index = rains_over_city.get(rain, -1)\n                if rain_index != -1:\n                    len_lak = len(lake_drying_days)\n                    j = 0\n                    while j < len_lak and lake_drying_days[j] <= rain_index:\n                        j += 1\n                    if j >= len_lak:\n                        return []\n                    rains[lake_drying_days[j]] = rain\n                    lake_drying_days.remove(lake_drying_days[j])\n                    rains_over_city.pop(rain)\n                rains_over_city[rain] = ind\n                rains[ind] = -1\n            else:\n                lake_drying_days.append(ind)\n                rains[ind] = 1\n            ind += 1\n        return rains", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = []\n        freeday = []\n        filled = {}\n        \n        for day, city in enumerate(rains):\n            if city:\n                ans.append(-1)\n                if city not in filled:\n                    filled[city] = day\n                \n                else:\n                    if freeday and freeday[-1] > filled[city]:\n                        dry_day = bisect.bisect_left(freeday, filled[city])\n                        ans[freeday.pop(dry_day)] = city\n                        filled[city] = day\n                    else:\n                        return []\n            \n            else:\n                ans.append(1)\n                freeday.append(day)\n            \n        return ans\n            \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = []\n        zero = []\n        full = {}\n        for day, city in enumerate(rains):\n            if city:\n                ans.append(-1)\n                if city in full:\n                    if zero and zero[-1] > full[city]:\n                        dry = bisect.bisect_left(zero, full[city])\n                        ans[zero.pop(dry)] = city\n                        full[city] = day\n                    else:\n                        return []\n                else:\n                    full[city] = day\n            else:\n                ans.append(1)\n                zero.append(day)\n        return ans", "class Solution:\n    #Version 1: Greedy\n    #Use binary search to find the first dry day after the city got wet.\n    #TC: O(n^2), SC: O(n)\n    '''\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from bisect import bisect_left\n        wet = {}\n        ans = [1]*len(rains)\n        dry = []\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.append(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = bisect_left(dry, wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n    '''\n    \n    #Version 2: Improved version 1\n    #Use SortedList to accelerate remove part\n    #TC: O(nlogn), SC: O(n)\n    '''\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from sortedcontainers import SortedList\n        wet = {}\n        ans = [1]*len(rains)\n        dry = SortedList()\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.add(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = dry.bisect_left(wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n    '''\n    \n    #Version 3: Greedy\n    #Store the next position of wet cities in the heap and pop out by urgency\n    #TC: O(nlogn), SC: O(n)\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from collections import deque\n        import heapq\n        city = {}\n        ans = [1]*len(rains)\n        for k in range(len(rains)):\n            if rains[k]:\n                if rains[k] not in city:\n                    city[rains[k]] = deque()\n                city[rains[k]].append(k)\n                ans[k] = -1\n        option = []\n        wet = {}\n        for k in range(len(rains)):\n            if rains[k]:\n                if rains[k] in wet:\n                    return []\n                else:\n                    wet[rains[k]] = k\n                    city[rains[k]].popleft()\n                    if city[rains[k]]:\n                        heapq.heappush(option, (city[rains[k]][0], rains[k]))\n            else:\n                if option:\n                    _, c = heapq.heappop(option)\n                    ans[k] = c\n                    wet.pop(c)\n                else:\n                    ans[k] = 1\n        return ans\n                    \n        \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from bisect import bisect_left\n        wet = {}\n        ans = [1]*len(rains)\n        dry = []\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.append(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = bisect_left(dry, wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n", "from sortedcontainers import SortedList\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        res = [1 for i in range(len(rains))]\n        ls, zs = {}, SortedList()\n        for i, l in enumerate(rains):\n            if l in ls:\n                if len(zs) == 0:\n                    return []\n                else:\n                    p = zs.bisect(ls[l])\n                    if p == len(zs):\n                        return []\n                    res[zs[p]] = l\n                    zs.pop(p)\n                    res[i] = -1\n                    ls[l] = i\n            elif l != 0:\n                ls[l] = i\n                res[i] = -1\n            else:\n                zs.add(i)\n        return res\n            \n        \n            \n        \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        def closest(i, arr):\n            for j in arr:\n                if j > i:\n                    return j\n            return -1\n        \n        ans = [1]*len(rains)\n        visited = dict()\n        zeros = deque()\n        x = 0\n        while x<len(rains) and rains[x] == 0:\n            x += 1\n        \n        for i in range(x, len(rains)):\n            if rains[i] in visited:\n                if not zeros:\n                    return []\n                else:\n                    r = visited[rains[i]]\n                    c = closest(r, zeros)\n                    if c == -1:\n                        return []\n                    ans[c] = rains[i]\n                    zeros.remove(c)\n                    ans[i] = -1\n                    visited[rains[i]] = i\n            elif rains[i]:\n                ans[i] = -1\n                visited[rains[i]] = i\n            else:\n                zeros.append(i)\n        return ans\n        \n", "class Solution:\n    #Version 1: Greedy\n    #Use binary search to find the first dry day after the city got wet.\n    #TC: O(n^2), SC: O(n)\n    '''\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from bisect import bisect_left\n        wet = {}\n        ans = [1]*len(rains)\n        dry = []\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.append(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = bisect_left(dry, wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n    '''\n    \n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        from sortedcontainers import SortedList\n        wet = {}\n        ans = [1]*len(rains)\n        dry = SortedList()\n        for k in range(len(rains)):\n            if not rains[k]:\n                dry.add(k)\n            else:\n                ans[k] = -1\n        for k in range(len(rains)):\n            if rains[k] > 0:\n                if rains[k] not in wet:\n                    wet[rains[k]] = k\n                else:\n                    index = dry.bisect_left(wet[rains[k]])\n                    if index == len(dry) or dry[index] > k:\n                        return []\n                    wet[rains[k]] = k\n                    ans[dry[index]] = rains[k]\n                    dry.pop(index)\n        return ans\n", "from collections import deque\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ret = [-1 for i in range(0, len(rains))]\n        \n        filled_lakes = dict()\n        dry_days = list()\n        \n        i = 0\n        while i < len(rains):\n            rain = rains[i]\n            \n            if rain == 0:\n                dry_days.append(i)\n            if rain > 0 and rain in filled_lakes:\n                prev_pos = filled_lakes[rain]\n                if len(dry_days) == 0:\n                    return []\n                \n                j = 0\n                while j < len(dry_days) and prev_pos > dry_days[j]:\n                    j += 1\n                \n                if j == len(dry_days):\n                    return []\n                \n                k = dry_days.pop(j)\n                \n                ret[k] = rain\n            \n            if rain != 0:\n                filled_lakes[rain] = i\n            \n            i += 1\n        \n        while len(dry_days) > 0:\n            j = dry_days.pop()\n            ret[j] = 1\n        return ret\n", "from sortedcontainers import SortedList\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lakes = defaultdict(deque)\n        \n        for day, lake in enumerate(rains):\n            lakes[lake].append(day)\n        \n        N = len(rains)\n        need = SortedList()\n        res = [1]*N\n        \n        for curr_day, lake in enumerate(rains):\n            if lake:\n                lakes[lake].popleft()\n                \n                if len(lakes[lake]) > 0:\n                    next_lake_index = lakes[lake][0]\n                    need.add(next_lake_index)\n                \n                res[curr_day] = -1\n            elif need:\n                chosen_lake_index = need.pop(0)\n                if chosen_lake_index < curr_day:\n                    return []\n                \n                res[curr_day] = rains[chosen_lake_index]\n        \n        return res if not need else []\n                \n                \n                \n        \n                \n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        drying = []\n        out = []\n        lakes = {}\n        v = 1\n        for c,i in enumerate(rains):\n            out.append(-1)\n            if i <= 0:\n                drying.append(c)\n            elif i in lakes and drying:\n                found = -1\n                for index, val in enumerate(drying):\n                    if val > lakes[i]:\n                        found = index\n                        break\n                if found > -1:\n                    out[drying.pop(found)] = i\n                    lakes[i] = c\n                else:\n                    return []\n            elif i in lakes:\n                return []\n            else:\n                lakes[i] = c\n                v = i\n        for j in drying:\n            out[j] = v\n        return out\n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        return_arr = [-1 for i in range(len(rains))]\n        rains_dict = {}\n        zeros_indices = []\n        for i in range(len(rains)):\n            if(rains[i]) == 0:\n                return_arr[i] = 1\n                zeros_indices.append(i)\n            elif rains[i] not in rains_dict:\n                rains_dict[rains[i]] = i\n            else:\n                if len(zeros_indices) == 0:\n                    return []\n                \n                #find index of dry day to use\n                index = 0\n                while(zeros_indices[index] < rains_dict[rains[i]]):\n                    index += 1\n                    print(index)\n                    if(index == len(zeros_indices)):\n                        return []\n                return_arr[zeros_indices[index]] = rains[i]\n                rains_dict[rains[i]] = i\n                del zeros_indices[index]\n        return return_arr", "from sortedcontainers import SortedList\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lakes = defaultdict(deque)\n        \n        for day, lake in enumerate(rains):\n            lakes[lake].append(day)\n        \n        N = len(rains)\n        need = SortedList()\n        res = [1]*N\n        \n        for curr_day, lake in enumerate(rains):\n            if lake:\n                lakes[lake].popleft()\n                \n                if len(lakes[lake]) > 0:\n                    next_lake_day = lakes[lake][0]\n                    need.add(next_lake_day)\n                \n                res[curr_day] = -1\n            elif need:\n                chosen_lake_day = need.pop(0)\n                if chosen_lake_day < curr_day:\n                    return []\n                \n                res[curr_day] = rains[chosen_lake_day]\n        \n        return res if not need else []\n                \n                \n                \n        \n                \n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1]*len(rains)\n        spares = []\n        full = {}\n        for i in range(len(rains)):\n            if rains[i] > 0:\n                if rains[i] in full:\n                    for j in range(len(spares)):\n                        if spares[j] > full[rains[i]]:\n                            ans[spares.pop(j)] = rains[i]\n                            full[rains[i]] = i\n                            break\n                    else:\n                        return []\n                else:\n                    full[rains[i]] = i\n            else:\n                spares.append(i)\n        for i in spares:\n            ans[i] = 1\n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        '''\n        [1,2,0,0,2,1]\n        day0 rains on lake1\n        day1 rains on lake2\n        day2 sunny\n        day3 sunny\n        day4 rains on lake1\n        day5 rains on lake2\n        \n        '''\n        sunny_day_idx=[]\n        res=[-1]*len(rains)\n        for day,lake in enumerate(rains):\n            if lake==0:\n                sunny_day_idx.append(day)\n                res[day]=1\n            \n                \n        last_day_rains_over_lake={}\n        '''\n        [1,0,2,0,2,1]\n        for lake2 we need to find sunny_day_idx between 2 - 4\n        sunny_day_idx=[1,4] is a increasing array\n        use binary search to find minimum value between prev_day and curr_day\n        \n        '''\n        def binary_search(sunny_day_idx,prev):\n            low,high=0,len(sunny_day_idx)\n            while low<high:\n                mid=(low+high)//2\n                if sunny_day_idx[mid]>prev:\n                    high=mid\n                else:\n                    low=mid+1\n            return low if low<len(sunny_day_idx) and sunny_day_idx[low]>prev else None\n            \n        print((binary_search([2,3],0)))    \n                \n                \n                \n                \n        for day,lake in enumerate(rains):\n            if lake!=0 and lake not in last_day_rains_over_lake:\n                last_day_rains_over_lake[lake]=day\n            elif lake!=0 and lake in last_day_rains_over_lake:\n                if not sunny_day_idx:\n                    return []\n                idx=binary_search(sunny_day_idx,last_day_rains_over_lake[lake])\n                #print(idx)\n                if idx==None:\n                    return []\n                if sunny_day_idx[idx]>day:\n                    return []\n                #print(sunny_day_idx[0],day)\n                res[sunny_day_idx[idx]]=lake\n                last_day_rains_over_lake[lake]=day\n                sunny_day_idx.pop(idx)\n        return res\n                \n            \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        # loop  day , lk ,   if 0 ,  clean the immediate next overflow,  if not 0 , overflow or fill empty  depends on if in next schedule  \n        # https://leetcode.com/problems/avoid-flood-in-the-city/discuss/698328/python-faster-than-10000-of-python-online-submissions-for-avoid-flood-in-the-city\n        # https://leetcode.jp/leetcode-avoid-flood-in-the-city-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90/\n        \n        days_next = [] \n        n = len(rains) \n        dct_lk2day = defaultdict(int) # lake:day ,  last time happened day \n        for day_rev, e in enumerate(rains[::-1]): \n            if e in dct_lk2day:\n                days_next.append(dct_lk2day[e]) # existing day \n            else:\n                days_next.append(n)     # last day + 1  , next will be outside \n            dct_lk2day[e] = n -1 - day_rev  # update current day \n        days_next = days_next[::-1]     # reverse \n        \n        # loop again,  put next day to minheap, 0 , clean, non0 fill or overflow \n        minHp = [] \n        rst = [] \n        for day, lk in enumerate(rains):\n            if not lk:  # 0 \n                if minHp:\n                    d_next = heappop(minHp)  # 1st ele \n                    rst.append(rains[d_next]) # that lake \n                else:   \n                    rst.append(1)  # 1st lake \n            else:\n                if minHp and day == minHp[0]: # not cleaned up , overflow  , eval and left first \n                    return [] \n                else:       # cleaned , will fill \n                    if days_next[day]<n:    # if needs to be cleaned in future \n                        heappush(minHp, days_next[day]) # next coming time \n                    rst.append(-1) \n        \n        return rst \n                    \n            \n        \n                    \n                \n                \n            \n                    \n                    \n                \n", "from sortedcontainers import SortedList as sl\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1]*(len(rains))\n        has_rained = dict()\n        free = sl()\n        for i in range(len(rains)):\n            # print(free)\n            if rains[i]==0:\n                free.add(i)\n            else:\n                if rains[i] not in has_rained:\n                    has_rained[rains[i]]=i\n                else:\n\\t\\t\\t\\t\\t# no free days are available\n                    if len(free)==0:\n                        return []\n\\t\\t\\t\\t\\t#finding the index of the free day that came after the first occurance of\n\\t\\t\\t\\t\\t# rains[i]\n                    idx = free.bisect_left(has_rained[rains[i]])\n                    # print(free,idx,i,has_rained)\n                    if idx<len(free):\n                        ans[free[idx]]=rains[i]\n\\t\\t\\t\\t\\t\\t# updating the index of rains[i] for future it's future occurances\n                        has_rained[rains[i]] = i\n                        free.remove(free[idx])\n                    else:\n\\t\\t\\t\\t\\t\\t#if no such index exists then return\n                        return []\n        if len(free):\n            while free:\n\\t\\t\\t\\t# choosing some day to dry on the remaining days\n                ans[free.pop()]=1\n        return ans\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        '''\n        [1,2,0,0,2,1]\n        day0 rains on lake1\n        day1 rains on lake2\n        day2 sunny\n        day3 sunny\n        day4 rains on lake1\n        day5 rains on lake2\n        \n        '''\n        sunny_day_idx=[]\n        res=[-1]*len(rains)\n        # for day,lake in enumerate(rains):\n        #     if lake==0:\n        #         sunny_day_idx.append(day)\n        #         res[day]=1\n            \n                \n        last_day_rains_over_lake={}\n        '''\n        [1,0,2,0,2,1]\n        for lake2 we need to find sunny_day_idx between 2 - 4\n        sunny_day_idx=[1,4] is a increasing array\n        use binary search to find minimum value between prev_day and curr_day\n        \n        '''\n        def binary_search(sunny_day_idx,prev):\n            low,high=0,len(sunny_day_idx)\n            while low<high:\n                mid=(low+high)//2\n                if sunny_day_idx[mid]>prev:\n                    high=mid\n                else:\n                    low=mid+1\n            return low if low<len(sunny_day_idx) and sunny_day_idx[low]>prev else None\n            \n        #print(binary_search([2,3],0))    \n                \n                \n                \n                \n        for day,lake in enumerate(rains):\n            if lake==0:\n                sunny_day_idx.append(day)\n                res[day]=1\n            if lake!=0 and lake not in last_day_rains_over_lake:\n                last_day_rains_over_lake[lake]=day\n            elif lake!=0 and lake in last_day_rains_over_lake:\n                \n                if not sunny_day_idx:\n                    return []\n                idx=binary_search(sunny_day_idx,last_day_rains_over_lake[lake])\n                #print(idx)\n                if idx==None or sunny_day_idx[idx]>day:\n                    return []\n                #print(sunny_day_idx[0],day)\n                res[sunny_day_idx[idx]]=lake\n                last_day_rains_over_lake[lake]=day\n                sunny_day_idx.pop(idx)\n        return res\n                \n            \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        q=[] # list for zeros positions\n        ans=[]\n        hashmap={}\n        for i in range(len(rains)):\n            if rains[i] == 0:\n                q.append(i)\n                ans.append(1)  # as per example 4\n            else:\n                if rains[i] in hashmap:    \n                    if len(q) == 0:\n                        return []\n                    else:\n                        index = hashmap[rains[i]]\n                        # find a zero position just greater than previous occurrence of rains[i]\n                        pos=bisect.bisect_right(q, index) \n                        if pos<len(q): # no zero exists in between occurrence\n                            ans[q[pos]]=rains[i]\n                            q.pop(pos)\n                        else:\n                            return []\n                hashmap[rains[i]]=i\n                ans.append(-1)  \n            \n        return ans", "from bisect import bisect_left\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1] * len(rains)\n        last_appear = {}\n        dry_days = []\n        \n        for idx, lake in enumerate(rains):\n            if lake == 0:\n                dry_days.append(idx)\n                continue\n            if lake in last_appear:\n                # find 0\n                first_0 = bisect_left(dry_days, last_appear[lake])\n                if first_0 == len(dry_days): # not found\n                    return []\n                ans[dry_days[first_0]] = lake\n                dry_days.pop(first_0)\n                last_appear.pop(lake)\n            last_appear[lake] = idx\n            \n        for day in dry_days: ans[day] = 1 \n        \n        return ans\n", "def nex(arr, target): \n\\tstart = 0;\n\\tend = len(arr) - 1\n\n\\tans = -1; \n\\twhile (start <= end): \n\\t\\tmid = (start + end) // 2; \n\n\\t\\t# Move to right side if target is \n\\t\\t# greater. \n\\t\\tif (arr[mid] <= target): \n\\t\\t\\tstart = mid + 1; \n\n\\t\\t# Move left side. \n\\t\\telse: \n\\t\\t\\tans = mid; \n\\t\\t\\tend = mid - 1; \n\n\\treturn ans;\n            \ndef find(ind,dind,flag):\n    n=len(dind)\n    if n==0:\n        flag[0]=1\n        return -1\n    ans = nex(dind,ind)\n    if ans==-1:\n        flag[0]=1\n        return ans\n    else:\n        return dind[ans]\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lind={}\n        n = len(rains)\n        ans = [1 for i in range(n)]\n        dind = []\n        for i in range(n):\n            if rains[i] >0:\n                ans[i]=-1\n                if rains[i] not in lind:\n                    lind[rains[i]]=i\n                    \n                else:\n                    flag=[0]\n                    ind = lind[rains[i]]\n                    dry = find(ind,dind,flag)\n                    if flag[0]==1:\n                        return []\n                    else:\n                        ans[dry] = rains[i]\n                        lind[rains[i]]=i\n                        dind.remove(dry)\n            else:\n                dind.append(i)\n                \n        return ans\n            ", "from sortedcontainers import SortedList\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1]*len(rains)\n        zeros = SortedList()\n        todry = {}\n        for i, r in enumerate(rains):\n            if r == 0:\n                zeros.add(i)\n                continue\n            if r in todry:\n                di = zeros.bisect_left(todry[r])\n                if di >= len(zeros):\n                    return []\n                ans[zeros[di]] = r\n                zeros.pop(di)\n            todry[r] = i\n        for i in range(len(rains)):\n            if rains[i] == 0 and ans[i] == -1:\n                ans[i] = 1\n        return ans\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains) \n        M = max(rains)\n        ans = [-1]*n\n        \n        l = set()\n                \n        r = collections.defaultdict(list)\n        for j in range(n):\n            if rains[j] > 0: \n                r[rains[j]] += [j] \n                                \n        i = 0 \n        tbd = []\n        \n        \n        while(i<n):\n            if rains[i]>0:\n                if rains[i] in l:\n                    return []\n                else:\n                    l.add(rains[i])\n                    r[rains[i]].pop(0)\n                    \n                    if len(r[rains[i]]) > 0: \n                        heapq.heappush(tbd, r[rains[i]][0])\n            \n            elif rains[i] == 0:\n                if len(tbd) > 0:\n                    get = heapq.heappop(tbd)\n                    ans[i] = rains[get] \n                    l.remove(rains[get])\n                                    \n                else:\n                    ans[i] = M + 1            \n            i += 1\n                    \n        \n        # print(ans) \n        \n        return ans\n        \n                \n            \n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1]*len(rains)\n        zeros, todry = SortedList(), {}\n        for i, r in enumerate(rains):\n            if r == 0:\n                zeros.add(i)\n            elif r not in todry:\n                todry[r] = i\n            else:\n                di = zeros.bisect_left(todry[r])\n                if di == len(zeros):\n                    return []\n                ans[zeros[di]] = r\n                zeros.pop(di)\n                todry[r] = i\n        for i in range(len(rains)):\n            if rains[i] == 0 and ans[i] == -1:\n                ans[i] = 1\n        return ans\n", "from bisect import bisect_left\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        flooded = {}\n        dry_days = []\n        out = [-1 for _ in range(len(rains))]\n        \n        for i in range(len(rains)):\n            day = rains[i]\n            if day > 0:\n                if day in flooded:\n                    if dry_days:\n                        # found = False\n                        # for d in range(len(dry_days)):\n                        #     dry_day = dry_days[d]\n                        #     if dry_day > flooded[day]:\n                        #         out[dry_day] = day\n                        #         dry_days.pop(d)\n                        #         found = True\n                        #         break\n                        # if not found:\n                        #     return []\n                        dry = bisect_left(dry_days, flooded[day])\n                        if dry == len(dry_days):\n                            return []\n                        else:\n                            dry_day = dry_days.pop(dry)\n                            out[dry_day] = day\n                    else:\n                        return []\n                flooded[day] = i\n            else:\n                dry_days.append(i)\n        for dry_day in dry_days:\n            out[dry_day] = 1\n        return out", "from collections import deque\n\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        zero_indices = deque()\n        last_flood = {}\n        result = [-1] * len(rains)\n        \n        def find_zero_for_lake(idx, r):\n            if not zero_indices:\n                return None\n\n            for zero_index in zero_indices:\n                if last_flood[r] < zero_index < idx:\n                    return zero_index\n                \n            return None\n        \n        for idx, r in enumerate(rains):\n            if r > 0:\n                if r in last_flood:\n                    found_zero = find_zero_for_lake(idx, r)            \n                    if found_zero is None:\n                        return []\n                    else:\n                        result[found_zero] = r\n                        zero_indices.remove(found_zero)  \n                        \n                last_flood[r] = idx\n            else:\n                zero_indices.append(idx)\n                \n        while zero_indices:\n            zero_index = zero_indices.pop()\n            result[zero_index] = 1\n                \n        return result\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        # To be improved with binary search for faster determination of idx for dry\n        full, idxDry, res = dict(), [], [-1] * len(rains)\n        for i, x in enumerate(rains):\n            if not x: idxDry.append(i); continue\n            if x in full:\n                if not idxDry or full[x] > idxDry[-1]: return []\n                # Improve here\n                for idx in idxDry:\n                    if idx > full[x]:\n                        res[idx] = x\n                        idxDry.remove(idx)\n                        del full[x]\n                        break\n            full[x] = i\n        for i in idxDry:\n            res[i] = 1\n        return res", "from bisect import bisect_left \nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        filled = {}\n        ans = [-1] * len(rains)\n        rem = []\n        \n        def get(r): # idx for first zero b4 right\n            low, high = 0, len(rem) - 1\n            while low <= high:\n                mid = low + (high-low)//2\n                if rem[mid] > r:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            # print(low)\n            return rem[low] if 0 <= low < len(rem) else -1\n        \n        for i in range(len(rains)-1, -1, -1):\n            curr = rains[i]\n            # if i == 8:\n            #     print(rem)\n            if curr == 0:\n                rem.append(i)\n                continue\n            elif curr in filled:\n                if not rem:\n                    return []\n                \n                idx = filled.pop(curr)\n                zero = get(idx)                          \n                \n                if not i < zero < idx:\n                    # print(rem)\n                    # print(curr, i, zero, idx)\n                    return []\n                ans[zero] = curr                \n                rem.remove(zero)     \n            \n            filled[curr] = i\n        while rem:\n            ans[rem.pop()] = 1\n        return ans\n            \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        idx = defaultdict(list)\n        \n        for i in range(n):\n            if rains[i]>0:\n                idx[rains[i]].append(i)\n        \n        nex = defaultdict(lambda: -1)\n        \n        for k in idx.keys():\n            for i in range(len(idx[k])-1):\n                nex[idx[k][i]] = idx[k][i+1]\n        \n        cnt = defaultdict(int)\n        pq = []\n        ans = []\n        \n        for i in range(n):\n            if rains[i]>0:\n                if cnt[rains[i]]==1:\n                    return []\n                \n                cnt[rains[i]] = 1\n                \n                if nex[i]!=-1:\n                    heappush(pq, (nex[i], rains[i]))\n                    \n                ans.append(-1)\n            else:\n                if len(pq)==0:\n                    ans.append(1)\n                else:\n                    _, lake = heappop(pq)\n                    cnt[lake] -= 1\n                    ans.append(lake)\n        \n        return ans", "class Solution:\n    \n    def backtrack(self, rains, full, position, seq):\n        if position >= len(rains):\n            return True\n        if rains[position] > 0:\n            if rains[position] in full:\n                return False\n            seq.append(-1)\n            full.add(rains[position])\n            if self.backtrack(rains, full, position + 1, seq):\n                return True\n            full.remove(rains[position])\n            seq.pop()\n        elif rains[position] == 0:\n            # must choose one lake that is full to dry\n            for lake in full:\n                seq.append(lake)\n                full.remove(lake)\n                if self.backtrack(rains, full, position + 1, seq):\n                    return True\n                full.add(lake)\n                seq.pop()\n            if len(full) < 1:\n                seq.append(1) # random lake\n                if self.backtrack(rains, full, position + 1, seq):\n                    return True\n                seq.pop()\n    \n    def avoidFloodBacktrack(self, rains: List[int]) -> List[int]:\n        seq = []\n        full = set()\n        if not self.backtrack(rains, full, 0, seq):\n            return []\n        return seq\n    \n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        spares = []\n        recent = dict()\n        full = set()\n        ans = []\n        for i in range(len(rains)):\n            if rains[i] > 0:\n                ans.append(-1)\n                if rains[i] in full:\n                    # we need to have dried this lake for sure\n                    if len(spares) < 1:\n                        return []\n                    valid = False\n                    for d in range(len(spares)):\n                        dry = spares[d]\n                        if dry > recent[rains[i]]:\n                            ans[dry] = rains[i]\n                            full.remove(rains[i])\n                            del spares[d]\n                            valid = True\n                            break\n                    if not valid:\n                        return []\n                elif rains[i] in recent and recent[rains[i]] == i - 1:\n                    # no chance to dry this one\n                    return []\n                else:\n                    full.add(rains[i])\n                recent[rains[i]] = i\n            else:\n                # we can dry one lake\n                # greedy chooses some random lake\n                # that will be replaced if needed\n                ans.append(1)\n                spares.append(i)\n        return ans\n    \nif False:\n    assert Solution().avoidFlood([69,0,0,0,69]) == [-1, 69, 1, 1, -1]\n    assert Solution().avoidFlood([1,2,0,0,2,1]) == [-1,-1,2,1,-1,-1]\n    assert Solution().avoidFlood([1,2,0,1,2]) == []\n    assert Solution().avoidFlood([10,20,20]) == []", "from collections import defaultdict\nfrom sortedcontainers import SortedSet\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        def getCeil(a, v):\n            if not a:\n                return None\n            b = a.bisect_right(v)\n\n            if b == 0:\n                if a[b]>=v:\n                    return a[b]\n                return None\n            if b==len(a):\n                return None\n            return a[b]\n        \n        res = [0]*len(rains)\n        zeros = SortedSet()\n        m = {}\n        for  i, val in enumerate(rains):\n            # print(i, val, m, zeros, res)\n            if val == 0:\n                zeros.add(i)\n            else:\n                if val in m:\n                    n = getCeil(zeros, m[val])\n                    print(n)\n                    if not n: return []\n                    res[n] = val\n                    zeros.remove(n)\n                res[i] = -1\n                m[val] = i\n        for i in zeros:\n            res[i] = 1\n        return res\n            \n                        \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        queue = []\n        lakes = dict()\n        \n        days = []\n        for i in range(len(rains)):\n            if rains[i] == 0:\n                queue.append(i)\n            elif rains[i] in lakes:\n                if not queue:\n                    return []\n                \n                for queue_index in range(len(queue)):\n                    if queue[queue_index] < lakes[rains[i]]:\n                        if queue_index == len(queue) - 1:\n                            return []\n                        continue\n                    else:\n                        days[queue.pop(queue_index)] = rains[i]\n                        break\n                lakes[rains[i]] = i\n            else:\n                lakes[rains[i]] = i\n            days.append(-1 if rains[i] != 0 else 999)\n            \n        return days\n                \n        # 1,0 ,1, 0,1\n        # [1,2,0,0,2,1]\n        # (1: 2, 2: 2, 0:2)\n        \n        # [1,2,0,1,2]\n        # (1: 2, 2: 2, 0:1) (4 - 2) > 1\n        \n        # O(n) space\n        # keep queue of indexes which represents days where there is no rain\n        # keep a set of values of n that have been rained on\n        # for each entry in the array (O(n))\n        #       If value is zero:\n        #           add current index to end of queue \n        #       elif: Whenever we encounter value that is in the set and nonzero- \n        #           if queue is empty, return empty array   \n        #           pop from the queue and emplace encountered value in output array at popped index (O(1))\n        #       else:\n        #           add encountered value to set\n        #       add -1 to output array if value is not 0, else 999\n        #\n    \n    # rains = [1, 0 ,1, 0]\n    # rains = [1, 1, 0]\n    # rains = [1, 0, 1, 0, 1]\n    # rains = [0, 1, 0, 1, 0, 1]\n    # rains = [0 , 0, 0... , 1, 0, 1]\n    # rains = [1, 0, 2, 0 , 2, 1]\n    \n    \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        res=[]\n        for rain in rains:\n            if rain>0:\n                res.append(-1)\n            else:\n                res.append(1)\n        \n        #full_lakes=[]\n        full_lakes=defaultdict(list)\n        \n        #index of 0\n        sunny_days=[]\n        \n        \n        #remove leading and trailing zeros\n        start=0\n        end=len(rains)-1\n        while rains[start]==0:\n            start+=1\n        while rains[end]==0:\n            end-=1\n\n        def binarySearch(sunny_days,prev_rain,curr):\n            #print('binary seaarch: ',sunny_days,prev_rain,curr)\n            if not sunny_days:\n                return -1\n            low=0\n            high=len(sunny_days)\n            while low<high:\n                mid=(low+high)//2\n\n                if sunny_days[mid]<=prev_rain:\n                    low=mid+1\n                else:\n                    high=mid\n            #print(low)\n            if low>=len(sunny_days) or sunny_days[low]<=prev_rain or sunny_days[low]>=curr:\n                return -1\n            else:\n                return low\n                \n        # a=[8]\n        # b=9\n        # c=10\n        # print(binarySearch(a,b,c))\n\n            \n            \n        \n        for i in range(start,end+1):\n            if rains[i]!=0:\n                if rains[i] not in full_lakes or not full_lakes[rains[i]]:\n                    full_lakes[rains[i]].append(i)\n                else:\n                    prev_rain=full_lakes[rains[i]][-1]\n\n                    \n                    #print(prev_rain,i,sunny_days)\n                    #print('#####')\n                    if not sunny_days:\n                        return []\n                    \n                    idx=binarySearch(sunny_days,prev_rain,i)\n                    #print(idx)\n                    #print(sunny_days,prev_rain,i)\n                    # for j in range(len(sunny_days)):\n                    #     if prev_rain<sunny_days[j]<i:\n                    #         idx=sunny_days[j]\n                    #         break\n                    if idx==-1:\n                        return []\n                    else:\n                        \n                        res[sunny_days[idx]]=rains[i]\n                        full_lakes[rains[i]].pop()\n                        full_lakes[rains[i]].append(i)\n                        sunny_days.pop(idx)\n                        \n            else:\n                sunny_days.append(i)\n        return res\n        \n                    \n                        \n        \n", "class Solution:\n    \n    def find_min_greater(self,a,x):\n        start = 0\n        end = len(a)-1\n        while(start<end):\n            mid = start+end\n            mid = mid//2\n            if(a[mid]<x and a[mid+1]>x):\n                return mid+1\n            elif(a[mid]<x):\n                start = mid\n            else:\n                end = mid\n        return start\n    \n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        last_rained = {}\n        no_rain = []\n        ans = []\n        for i in range(len(rains)):\n            if(rains[i]==0):\n                no_rain.append(i)\n                ans.append(1)\n            else:\n                lake = rains[i]\n                ans.append(-1)\n                if(lake not in last_rained.keys()):\n                    last_rained[lake] = i\n                else:\n                    lr = last_rained[lake]\n                    zl = len(no_rain)\n                    if(len(no_rain)==0 or no_rain[zl-1]<lr):\n                        return []\n                    else:\n                        empty = self.find_min_greater(no_rain,lr)\n                        ans[no_rain[empty]] = lake\n                        last_rained[lake]=i\n                        no_rain.pop(empty)\n        return ans", "from collections import deque\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        dry_sequence = [1 for _ in range(len(rains))]\n        full_lakes = {}\n        dry_days = deque()\n        for i,lake in enumerate(rains):\n            if lake:\n                dry_sequence[i] = -1\n                if lake in full_lakes:\n                    if dry_days:\n                        index = 0\n                        while index < len(dry_days) and dry_days[index] <= full_lakes[lake]:\n                            index += 1\n                        if index < len(dry_days):\n                            dry_sequence[dry_days[index]] = lake\n                            del dry_days[index]\n                        else:\n                            return []\n                    else:\n                        return []\n                full_lakes[lake] = i\n            else:\n                dry_days.append(i)\n        return dry_sequence\n                                        \n", "from collections import defaultdict\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        dry_days = []\n        filled_lakes = {}\n        ans = [1]*len(rains)\n        for i in range(len(rains)):\n            if rains[i] != 0:\n                ans[i] = -1\n            if rains[i] in filled_lakes:\n                if not dry_days:\n                    return []\n                else:\n                    day_to_dry_lake = bisect.bisect_left(dry_days,filled_lakes[rains[i]])\n                    if day_to_dry_lake >= len(dry_days):\n                        return []\n                    ans[dry_days[day_to_dry_lake]] = rains[i]\n                    dry_days.pop(day_to_dry_lake)\n                    filled_lakes.pop(rains[i],None)\n            if rains[i] == 0:\n                dry_days.append(i)        \n            else:\n                filled_lakes[rains[i]] = i\n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \n        availables = [] # available days, will be sorted ascendingly \n        n = len(rains)\n        ans = [-1]*n\n        prev_rain = dict() # prev_rain[lake] tells us when it last rained on lake, assuming lake is full.\n        \n        for day in range(n):\n            if rains[day] == 0:\n                availables.append(day)\n            else:\n                lake = rains[day]\n                if lake not in prev_rain:\n                    prev_rain[lake] = day\n                else:\n                    # we must find the earliest available day to empty this lake\n                    # after prev_rain[lake] then remove it from availables and \n                    # remove lake from prev_rain, and indicate this in the answer\n                    if len(availables) == 0 or availables[-1] < prev_rain[lake]:\n                        return []\n                    low = 0\n                    high = len(availables)-1\n                    while low < high:\n                        med = (low+high)//2\n                        if availables[med] < prev_rain[lake]:\n                            low = med+1\n                        else:\n                            high = med\n                    chosen_day = availables[low]\n                    availables.remove(chosen_day)\n                    prev_rain[lake] = day\n                    ans[chosen_day] = lake\n        \n        while availables:\n            ans[availables[-1]] = 20\n            availables.pop()\n        \n        return ans              ", "from collections import defaultdict\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lake=defaultdict(list)\n        ans=[1]*len(rains)\n        for i in range(len(rains)):\n            rain=rains[i]\n            if rain==0:\n                lake[0].append(i)\n            else:\n                ans[i]=-1\n                if len(lake[0])==0 and len(lake[rain])!=0:\n                    return []\n                elif len(lake[0])!=0 and len(lake[rain])!=0:\n                    for k in lake[0]:\n                        if k > lake[rain][0]:\n                            ans[k]=rain\n                            lake[0].remove(k)\n                            lake[rain]=[i]\n                            break\n                    else:\n                        return []\n                elif len(lake[rain])==0:\n                    lake[rain].append(i)\n        return ans", "#https://blog.csdn.net/pfdvnah/article/details/106897444\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        sol = [53456 for _ in range(len(rains))]\n        \n        pos = collections.defaultdict(list)\n        for idx, n in enumerate(rains):\n            if n>0:\n                pos[n].append(idx)\n        for key in pos:\n            pos[key].reverse()\n            \n        q = []\n        used = set()\n        for idx, n in enumerate(rains):\n            # print (q, used)\n            if n>0:\n                if n in used:\n                    return []\n                else:\n                    pos[n].pop()\n                    if pos[n]:\n                        heapq.heappush(q, (pos[n][-1], n))\n                    else:\n                        heapq.heappush(q, (math.inf, n))\n                    used.add(n)\n                sol[idx] = -1\n            elif n==0:\n                if q:\n                    _, val = heapq.heappop(q)\n                    sol[idx] = val\n                    used.remove(val)\n        return sol", "from queue import PriorityQueue\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        pq = PriorityQueue()\n        rainOnLake = {}        \n        for i, v in enumerate(rains):\n            if v > 0:\n                if v not in rainOnLake: rainOnLake[v] = []\n                rainOnLake[v].append(i)\n        \n        lakes = {}\n        ans = [-1] * len(rains)\n        for i , v in enumerate(rains):\n            if v > 0:\n                if lakes.get(v, 0) > 0: \n                    return []\n                lakes[v] = 1\n                rainSched = rainOnLake[v]\n                rainSched.pop(0)\n                if rainSched:\n                    nextRain = rainSched[0]\n                    pq.put((nextRain, v))\n            elif v == 0:\n                if pq.qsize() <= 0:\n                    ans[i] = 111111111\n                else:\n                    (d, l) = pq.get()\n                    ans[i] = l\n                    lakes[l] = 0\n        return ans\n                \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ret = [1]*len(rains)\n        filled = dict()\n        dryDays = list()\n        for ind,rain in enumerate(rains):\n            if rain>0:\n                ret[ind] = -1\n                if rain not in filled:\n                    ret[ind]=-1\n                    filled[rain]=ind\n                    continue\n                else:\n                    if not dryDays:\n                        return []\n                    found = False\n                    print(ind)\n                    for day in dryDays:\n                        if day > filled[rain]:\n                            ret[day]=rain\n                            dryDays.remove(day)\n                            found = True\n                            filled[rain] = ind\n                            break\n                    if not found:\n                        return []\n            else:\n                dryDays.append(ind)\n        return ret\n                        \n            \n            \n", "from bisect import bisect, bisect_left\nfrom typing import List\n\n\nclass Solution:\n  def avoidFlood(self, rains: List[int]) -> List[int]:\n\n    result = []\n    filled = {}\n    free_day = []\n    for index, city in enumerate(rains):\n      if city:\n        result.append(-1)\n        if city not in filled:\n          filled[city] = index\n        else:\n          if len(free_day) > 0 and free_day[-1] > filled[city]:\n            dry_day = bisect_left(free_day, filled[city])\n            result[free_day.pop(dry_day)] = city\n            filled[city] = index\n            pass\n          else:\n            return []\n          pass\n\n        pass\n      else:\n        result.append(1)\n        free_day.append(index)\n        pass\n      pass\n\n    return result", "from bisect import bisect_left\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \\\"\\\"\\\"\n        We only care about the lakes that receive rain multiple times\n        \n        Those lakes will need to, ideally, be drained prior\n        \n        When we see a repeat --- we need to find the first \\\"Dry\\\" after the last\n        and pop it\n        \\\"\\\"\\\"\n        ans = [float('-inf') for _ in rains]\n        dry = []\n        tracker = {}\n        for i, r in enumerate(rains):\n            if r != 0:\n                ans[i] = -1\n                if r in tracker:\n                    idx = bisect_left(dry, tracker[r]+1)\n                    if idx == len(dry):\n                        return []\n                    else:\n                        res = dry[idx]\n                        ans[res] = r\n                        dry.pop(idx)\n                tracker[r] = i\n            else:\n                dry.append(i)\n        for i in range(len(ans)):\n            if ans[i] == float('-inf'):\n                ans[i] = 1\n        return ans", "# from bisect import bisect_left\n\n# class Solution:\n#     def avoidFlood(self, rains: List[int]) -> List[int]:\n#         flooded = {}\n#         dry_days = []\n#         out = [-1 for _ in range(len(rains))]\n        \n#         for i in range(len(rains)):\n#             day = rains[i]\n#             if day > 0:\n#                 if day in flooded:\n#                     if dry_days:\n#                         # found = False\n#                         # for d in range(len(dry_days)):\n#                         #     dry_day = dry_days[d]\n#                         #     if dry_day > flooded[day]:\n#                         #         out[dry_day] = day\n#                         #         dry_days.pop(d)\n#                         #         found = True\n#                         #         break\n#                         # if not found:\n#                         #     return []\n#                         dry = bisect_left(dry_days, flooded[day])\n#                         if dry == len(dry_days):\n#                             return []\n#                         else:\n#                             dry_day = dry_days.pop(dry)\n#                             out[dry_day] = day\n#                     else:\n#                         return []\n#                 flooded[day] = i\n#             else:\n#                 dry_days.append(i)\n#         for dry_day in dry_days:\n#             out[dry_day] = 1\n#         return out\n\nfrom sortedcontainers import SortedList as sl\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [-1]*(len(rains))\n        has_rained = dict()\n        free = sl()\n        for i in range(len(rains)):\n            # print(free)\n            if rains[i]==0:\n                free.add(i)\n            else:\n                if rains[i] not in has_rained:\n                    has_rained[rains[i]]=i\n                else:\n\\t\\t\\t\\t\\t# no free days are available\n                    if len(free)==0:\n                        return []\n\\t\\t\\t\\t\\t#finding the index of the free day that came after the first occurance of\n\\t\\t\\t\\t\\t# rains[i]\n                    idx = free.bisect_left(has_rained[rains[i]])\n                    # print(free,idx,i,has_rained)\n                    if idx<len(free):\n                        ans[free[idx]]=rains[i]\n\\t\\t\\t\\t\\t\\t# updating the index of rains[i] for future it's future occurances\n                        has_rained[rains[i]] = i\n                        free.remove(free[idx])\n                    else:\n\\t\\t\\t\\t\\t\\t#if no such index exists then return\n                        return []\n        if len(free):\n            while free:\n\\t\\t\\t\\t# choosing some day to dry on the remaining days\n                ans[free.pop()]=1\n        return ans", "class Solution:\n  def avoidFlood(self, rains: List[int]) -> List[int]:\n    last_ids = {}\n    next_ids = [0] * len(rains)\n    for i in reversed(range(len(rains))):\n      if rains[i] > 0:\n        if rains[i] in last_ids:\n          next_ids[i] = last_ids[rains[i]]\n        last_ids[rains[i]] = i\n    \n    prio = []\n    result = [-1] * len(rains)\n    #print(next_ids)\n    for i in range(len(rains)):\n      if rains[i] > 0:\n        if len(prio) > 0 and prio[0] <= i:\n          #print('exit', prio)\n          return []\n        if next_ids[i] > 0:\n          #print(i, 'push', next_ids[i])\n          heapq.heappush(prio, next_ids[i])\n      else:\n        if len(prio) > 0:\n          result[i] = rains[heapq.heappop(prio)]\n          #print(i, 'pop', result)\n        else:\n          result[i] = 1\n    return result", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        free_days = []\n        lake_tracker = {}\n        free_days_balance = 0\n        ans = [ -1 if rains[i] > 0 else 1 for i in range( len(rains) ) ]\n        for i in range( len(rains) ):\n            if rains[i] > 0:\n                lake = rains[i]\n                if lake in lake_tracker:\n                    if free_days_balance > 0:\n                        index = lake_tracker[lake]\n                        \n                        fnd = None\n                        for free_day in free_days:\n                            if index < free_day:\n                                fnd = free_day\n                                break\n                        \n                        if not fnd:\n                            return []\n                        \n                        free_days_balance = free_days_balance - 1\n                        lake_tracker[lake] = i\n                        \n                        ans[ fnd ] = lake\n                        free_days.remove(fnd)\n                        \n                    else:\n                        return []\n                else:\n                    lake_tracker[ lake ] = i\n            else:\n                free_days_balance = free_days_balance + 1\n                free_days.append(i)\n        return ans\n                \n                    \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        op=[]\n        lakes=dict()\n        days=[]\n        for i,r in enumerate(rains):\n            if r>0:\n                op.append(-1)\n                if r in lakes.keys():\n                    day=lakes[r]\n                    v=-1\n                    for d in days:\n                        if d>day:\n                            v=d\n                            break\n                    if v>0:\n                        days.remove(v)\n                        op[v]=r\n                    else:\n                        return []\n                lakes[r]=i\n            else:\n                op.append(99999)\n                days.append(i)\n            \n        return op", "class Solution(object):\n    def avoidFlood(self, rains):\n        aux = dict()\n        for i in range(len(rains)):\n            if rains[i] not in aux:\n                aux[rains[i]] = deque()\n            aux[rains[i]].append(i)\n        q = []\n        ans = [1] * len(rains)\n        for i in range(len(rains)):\n            if rains[i] == 0:\n                if q:\n                    index, val = heapq.heappop(q)\n                    if index < i:\n                        return []\n                    else:\n                        ans[i] = val\n            else:\n                ans[i] = -1\n                if len(aux[rains[i]]) > 1:\n                    aux[rains[i]].popleft()\n                    heapq.heappush(q, (aux[rains[i]][0], rains[i]))\n        if len(q):  return []\n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans=[]\n        \n        lakes={}\n        freeDays=[]\n\n        for i in range(0,len(rains)):\n            if(rains[i]!=0):\n                if(rains[i] not in lakes):\n                    lakes[rains[i]]=[]\n                    lakes[rains[i]].append(0)\n                    lakes[rains[i]].append(i)\n                elif(lakes[rains[i]][0]==1 and len(freeDays)>0):\n                    for j in range(0,len(freeDays)):\n                        if(freeDays[j]>lakes[rains[i]][1]):\n                            ans[freeDays[j]]=rains[i]\n                            lakes[rains[i]][0]-=1\n                            lakes[rains[i]][1]=i\n                            freeDays.pop(j)\n                            break\n                lakes[rains[i]][0]+=1\n                lakes[rains[i]][1]=i\n                if(lakes[rains[i]][0]>1):\n                    return []\n                ans.append(-1)\n            else:\n                freeDays.append(i)\n                ans.append(1)\n\n                    \n        \n        \n        \n        \n        \n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        lakes = collections.defaultdict(bool)\n        lastrain = collections.defaultdict(int)\n        res = []\n        dry = []\n        for k,v in enumerate(rains):\n            if v > 0:\n                if not lakes[v]:\n                    lakes[v] = True\n                    res.append(-1)\n                    lastrain[v] = k\n                else:\n                    # lakes[v] == True\n                    if dry == []:\n                        return []\n                    else:\n                        # check if there is a dry day we can use\n                        i = 0\n                        found = False\n                        while i < len(dry) and not found:\n                            if dry[i] > lastrain[v]:\n                                found = True\n                                dry_day = dry[i]\n                            else:\n                                i += 1\n                        if found:\n                            res[dry_day] = v\n                            lastrain[v] = k\n                            dry.pop(i)\n                            res.append(-1)\n                        else:\n                            return []\n            elif v == 0:\n                res.append(1)\n                dry.append(k)\n        return res\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        # we can do this in O(n) space \n        lakes = {}\n        zeroes = []\n        \n        length = len(rains)\n        \n        \n        for i, rain in enumerate(rains):\n            if rain == 0:\n                zeroes.append(i)\n                continue\n            \n            if rain in lakes: \n                lake_index = lakes[rain]\n                \n                found = False\n                \n                for j, zero in enumerate(zeroes):\n                    if zero > lake_index:\n                        rains[zero] = rain\n                        found = True\n                        del zeroes[j]\n                        break\n                \n                if not found: return []\n\n                lakes[rain] = i\n                rains[i] = -1\n            else:\n                lakes[rain] = i\n                rains[i] = -1\n        \n        for zero in zeroes: rains[zero] = 1\n                \n        return rains\n", "import bisect\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        dry_days=[]\n        last_rainy_day={}\n        ans=[-1 if rain>0 else 1 for rain in rains]\n        for i,rain in enumerate(rains): \n            if not rain:\n                dry_days.append(i)\n            else:\n                if rain not in last_rainy_day:\n                    last_rainy_day[rain]=i \n                else:\n                    if not dry_days:\n                        return []\n                    else:\n                        index=bisect.bisect_left(dry_days,last_rainy_day[rain])\n                        if index>=len(dry_days):\n                            return []\n                        ans[dry_days.pop(index)]=rain\n                        last_rainy_day[rain]=i\n        return  ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        nex = [-1] * len(rains)\n        last = {}\n        for i, n in enumerate(rains):\n            if n in last:\n                nex[last[n]] = i\n            last[n] = i\n\n        prio, answer = [], []\n        for i, event in enumerate(rains):\n            if prio and prio[0] <= i:\n                return []\n            \n            if event != 0:\n                if nex[i] != -1:\n                    heapq.heappush(prio, nex[i])\n                answer.append(-1)\n            else:\n                answer.append(rains[heapq.heappop(prio)] if prio else 1)\n        \n        return answer", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        full_lakes = {}\n        \n        sunny_days = []\n        \n        res = []\n        \n        for i, rain in enumerate(rains):\n            if rain == 0:\n                res.append(1)\n                sunny_days.append(i)\n            else:\n                if rain in full_lakes:\n                    last_rain = full_lakes[rain]\n                    \n                    earliest_sunny_day = -1\n                    for day in sunny_days:\n                        if day > last_rain and day < i:\n                            earliest_sunny_day = day\n                            sunny_days.remove(day)\n                            break\n                            \n                    if earliest_sunny_day == -1:\n                        return []\n                    \n                    res[earliest_sunny_day] = rain\n                    res.append(-1)\n\n                else:\n                    res.append(-1)\n                full_lakes[rain] = i\n        return res", "class Solution:\n    \n    def backtrack(self, rains, full, position, seq):\n        if position >= len(rains):\n            return True\n        if rains[position] > 0:\n            if rains[position] in full:\n                return False\n            seq.append(-1)\n            full.add(rains[position])\n            if self.backtrack(rains, full, position + 1, seq):\n                return True\n            full.remove(rains[position])\n            seq.pop()\n        elif rains[position] == 0:\n            # must choose one lake that is full to dry\n            for lake in full:\n                seq.append(lake)\n                full.remove(lake)\n                if self.backtrack(rains, full, position + 1, seq):\n                    return True\n                full.add(lake)\n                seq.pop()\n            if len(full) < 1:\n                seq.append(1) # random lake\n                if self.backtrack(rains, full, position + 1, seq):\n                    return True\n                seq.pop()\n    \n    def avoidFloodBacktrack(self, rains: List[int]) -> List[int]:\n        seq = []\n        full = set()\n        if not self.backtrack(rains, full, 0, seq):\n            return []\n        return seq\n    \n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        spares = []\n        recent = dict()\n        full = set()\n        ans = []\n        for i in range(len(rains)):\n            if rains[i] > 0:\n                ans.append(-1)\n                if rains[i] in full:\n                    # we need to have dried this lake for sure\n                    valid = False\n                    for d in range(len(spares)):\n                        dry = spares[d]\n                        if dry > recent[rains[i]]:\n                            ans[dry] = rains[i]\n                            full.remove(rains[i])\n                            del spares[d]\n                            valid = True\n                            break\n                    if not valid:\n                        return []\n                elif rains[i] in recent and recent[rains[i]] == i - 1:\n                    # no chance to dry this one\n                    return []\n                else:\n                    full.add(rains[i])\n                recent[rains[i]] = i\n            else:\n                # we can dry one lake\n                # greedy chooses some random lake\n                # that will be replaced if needed\n                ans.append(1)\n                spares.append(i)\n        return ans\n    \nif False:\n    assert Solution().avoidFlood([69,0,0,0,69]) == [-1, 69, 1, 1, -1]\n    assert Solution().avoidFlood([1,2,0,0,2,1]) == [-1,-1,2,1,-1,-1]\n    assert Solution().avoidFlood([1,2,0,1,2]) == []\n    assert Solution().avoidFlood([10,20,20]) == []", "import sortedcontainers\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        \n        ans = [-1] * n\n        \n        track = {}\n        ptr = 0\n        dries = sortedcontainers.SortedList()\n        \n        while ptr < n:\n            lake = rains[ptr]\n            \n            if lake > 0:\n                if lake in track:\n                    last_rain = track[lake]\n                    \n                    if not dries: return []\n                    \n                    idx = dries.bisect_right(last_rain)\n                    if idx >= len(dries): return []\n                    \n                    dry_pos = dries[idx]\n                    if dry_pos < last_rain: return []\n                    \n                    dries.discard(dry_pos)\n                    \n                    ans[dry_pos] = lake\n                    track[lake] = ptr\n                else:\n                    track[lake] = ptr\n            else:\n                dries.add(ptr)\n                \n            ptr += 1\n        \n        for i in dries: ans[i] = 1\n            \n        return ans\n        \n", "from heapq import heappush, heappop\n\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        appears = dict()\n        for i in range(len(rains)):\n            if not rains[i]:\n                continue\n            if not rains[i] in appears:\n                appears[rains[i]] = []\n            appears[rains[i]].append(i)\n            \n        next_rain = dict()\n        for v in appears.values():\n            for i in range(len(v) - 1):\n                next_rain[v[i]] = v[i + 1]\n        \n        h = []\n        ans = [-1] * len(rains)\n        for i in range(len(rains)):\n            if rains[i]:\n                if i in next_rain:\n                    heappush(h, (next_rain[i], rains[i]))\n            else:\n                if h:\n                    day, idx = heappop(h)\n                    if day < i:\n                        return []\n                    else:\n                        ans[i] = idx\n                else:\n                    ans[i] = 1\n        \n        if h:\n            return []\n        \n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        # we can do this in O(n) space \n        lakes = {}\n        zeroes = []\n        length = len(rains)\n        \n        for i, rain in enumerate(rains):\n            if rain == 0:\n                zeroes.append(i)\n                continue\n            \n            if rain in lakes: \n                lake_index = lakes[rain]\n                \n                found = False\n                \n                for j, zero in enumerate(zeroes):\n                    if zero > lake_index:\n                        rains[zero] = rain\n                        found = True\n                        del zeroes[j]\n                        break\n                \n                if not found: return []\n\n                lakes[rain] = i\n                rains[i] = -1\n            else:\n                lakes[rain] = i\n                rains[i] = -1\n        \n        for zero in zeroes: rains[zero] = 1\n                \n        return rains\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        zeros = []\n        last = {}\n        ans = [-1]*len(rains)\n        \n        for i in range(len(rains)):\n            if rains[i] == 0:\n                ans[i] = 1\n        \n        for i, lake in enumerate(rains):\n            if lake == 0:\n                zeros.append(i)\n            else:\n                if lake in last:\n                    prev_idx = last[lake]\n                    zero = bisect_left(zeros, prev_idx)\n                    if zero < len(zeros):\n                        # found a valid lake\n                        zero_lake = zeros.pop(zero)\n                        last[lake] = i\n                        ans[zero_lake] = lake\n                    else:\n                        return []\n                else:\n                    last[lake] = i\n        return ans", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        counter=collections.Counter()\n        firstSeen={}\n        # day=0\n        empty=[-1]*len(rains)\n        # stack=collections.deque()\n        # slow=0\n        sunny={}\n        for day,lake in enumerate(rains):\n            if lake>0:\n                if counter[lake]>=1:        \n                    for index in sunny:\n                        if index>firstSeen[lake]:\n                            empty[index]=lake\n                            counter[lake]-=1\n                            del sunny[index]\n                            break\n                    if counter[lake]>=1:\n                        return []\n                counter[lake]+=1\n                firstSeen[lake]=day\n            else:\n                sunny[day]=1\n        # print(sunny)\n        for day in sunny:\n            empty[day]=1\n        return empty\n       \n            \n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        closest = []\n        locs = collections.defaultdict(collections.deque)\n        for i, lake in enumerate(rains):\n            locs[lake].append(i)\n        ret = []\n        for i, lake in enumerate(rains):\n            if closest and closest[0] == i:\n                return []\n            if not lake:\n                if not closest:\n                    ret.append(1) \n                    continue\n                nxt = heapq.heappop(closest)\n                ret.append(rains[nxt])\n            else:\n                l = locs[lake]\n                l.popleft()\n                if l:\n                    nxt = l[0]\n                    heapq.heappush(closest, nxt)\n                ret.append(-1)\n        return ret\n", "class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \\\"\\\"\\\"\n        #O(n^2) working sol\n        ans = [1 for i in range(len(rains))]\n        d = collections.defaultdict(int)\n        d[0]=0\n        \n        for i in range(len(rains)):\n            d[rains[i]]+=1\n            if rains[i]==0:\n                #look for the nearest value that exists in the dict we got\n                for x in range(i+1,len(rains)):\n                    if rains[x] in d and not rains[x]==0:\n                        #print(d,d[rains[x]],rains[x])\n                        d[0]-=1\n                        ans[i] = rains[x]\n                        d[rains[x]]-=1\n                        if d[rains[x]]==0: del d[rains[x]]\n                        break\n            else:\n                #you gotta get out early of a bad pattern that cannot be salvaged\n                if d[rains[i]]>1:\n                    return []\n                ans[i] = -1\n        \n        return ans\n        \\\"\\\"\\\"\n        \n        ans = [1 for i in range(len(rains))]\n        d = collections.defaultdict(int)\n        d[0]=0\n        #preprosess, find all  #:0#0#0...\n        # as d grows, put corresponding value here in a heap\n        # every time heap pops, we get the nearest value that exists in the dict we got\n        p = {}\n        x = collections.defaultdict(int)\n        x[0] = 0\n        for i in range(len(rains)):\n            if rains[i] in p:\n                #print(x[0],rains[i],x[rains[i]])\n                if x[0]>=x[rains[i]]:\n                    p[rains[i]] += [i]\n            else:\n                p[rains[i]] = []\n            x[rains[i]]+=1\n        p[0] = []\n            \n        #print(p)       \n            \n        s= set()\n        h = []\n        for i in range(len(rains)):\n\n            d[rains[i]]+=1\n\n            if rains[i]!=0 and rains[i] not in s:\n                if rains[i] in p and p[rains[i]] != []:\n                    for j in p[rains[i]]:\n                        heappush(h,j)\n                s.add(rains[i])\n            #print(d,h)\n             \n            if rains[i]==0:\n                #look for the nearest value that exists in the dict we got\n                \\\"\\\"\\\"\n                for x in range(i+1,len(rains)):\n                    print(x,\\\" is x\\\")\n                    if rains[x] in d and not rains[x]==0:\n                        #print(d,d[rains[x]],rains[x])\n                        if h: \n                            pop = heappop(h)\n                            print(pop,x,\\\"compare\\\")\n                        \n                        d[0]-=1\n                        ans[i] = rains[x]\n                        d[rains[x]]-=1\n                        if d[rains[x]]==0: del d[rains[x]]\n                        break\n                \\\"\\\"\\\"\n                \n                if h:\n                    pop = heappop(h)\n                    d[0]-=1\n                    \n                    ans[i] = rains[pop]\n                    if rains[pop] not in d:\n                        rains[pop] = 1\n                    else:\n                        d[rains[pop]]-=1\n                    if d[rains[pop]]==0: del d[rains[pop]]\n                \n                \n            else:\n                \n                #you gotta get out early of a bad pattern that cannot be salvaged\n                if d[rains[i]]>1:\n                    return []\n                #find the next equal closest value past a zero.\n                ans[i] = -1\n            #print(h,i,\\\"heap at end\\\")\n        \n        return ans\n        \n        \n        \n        \n                \n        \n                \n            \n            \n        \n            \n        \n                        \n                        \n        \n                \n       \n        \n                \n                \n                "]
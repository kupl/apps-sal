["class Solution:\n     def findMinStep(self, board, hand):\n         \"\"\"\n         :type board: str\n         :type hand: str\n         :rtype: int\n         \"\"\"\n         res=float(\"inf\")\n         hmap=collections.defaultdict(int)\n         for c in hand:\n             hmap[c]+=1\n         res=self.helper(board,hmap)\n         if res == float(\"inf\"):\n             return -1\n         return res\n     \n     def helper(self,board,hmap):\n         board=self.removeConsecutive(board)\n         if len(board) ==0:\n             return 0\n         cnt=float(\"inf\")\n         j=0\n         for i in range(len(board)+1):\n             if i<len(board) and board[i] ==board[j]:\n                 continue\n             need=3-(i-j)\n             if hmap[board[j]]>=need:\n                 hmap[board[j]]-=need\n                 res=self.helper(board[0:j]+board[i:],hmap)\n                 if res!=float(\"inf\"):\n                     cnt=min(cnt,res+need)\n                 hmap[board[j]]+=need\n             j=i\n         return cnt\n         \n     def removeConsecutive(self,board):\n         j=0\n         for i in range(len(board)+1):\n             if i<len(board) and board[i] ==board[j]:\n                 continue\n             if i-j>=3:\n                 return self.removeConsecutive(board[0:j]+board[i:])\n             else:\n                 j=i\n         return board", "class Solution:\n     def findMinStep(self, board, hand):\n         \"\"\"\n         :type board: str\n         :type hand: str\n         :rtype: int\n         \"\"\"\n         return self.use_dfs(board, hand)\n     \n     def use_dfs(self, board, hand):\n         counts = collections.Counter(hand)\n         return self.dfs(board, counts)\n     \n     def dfs(self, board, hand):\n         if not board:\n             return 0\n         result = float('inf')\n         i, j = 0, 0\n         n = len(board)\n         while i < n:\n             j = i\n             while j < n and board[i] == board[j]:\n                 j += 1\n             color = board[i]\n             insert = 3 - (j - i)\n             if color in hand and hand[color] >= insert:\n                 new_board = self.shrink(board[:i] + board[j:])\n                 hand[color] -= insert\n                 dist = self.dfs(new_board, hand)\n                 if dist >= 0:\n                     result = min(result, dist + insert)\n                 hand[color] += insert\n             i = j\n         return result if float('inf') != result else -1\n     \n     def shrink(self, board):\n         i, j = 0, 0\n         while i < len(board):\n             j = i\n             while j < len(board) and board[i] == board[j]:\n                 j += 1\n             if j - i >= 3:\n                 board = board[:i] + board[j:]\n                 i = 0\n             else:\n                 i = j\n         return board\n", "class Solution:\n     def findMinStep(self, board, hand):\n         \"\"\"\n         :type board: str\n         :type hand: str\n         :rtype: int\n         \"\"\"\n         return self.use_dfs(board, hand)\n     \n     def use_dfs(self, board, hand):\n         counts = collections.Counter(hand)\n         return self.dfs(board, counts)\n     \n     def dfs(self, board, hand):\n         if not board:\n             return 0\n         result = float('inf')\n         i, j = 0, 0\n         n = len(board)\n         while i < n:\n             j = i\n             while j < n and board[i] == board[j]:\n                 j += 1\n             color = board[i]\n             remove = 3 - (j - i)\n             if color in hand and hand[color] >= remove:\n                 new_board = self.shrink(board[:i] + board[j:])\n                 hand[color] -= remove\n                 dist = self.dfs(new_board, hand)\n                 if dist >= 0:\n                     result = min(result, dist + remove)\n                 hand[color] += remove\n             i = j\n         return result if float('inf') != result else -1\n     \n     def shrink(self, board):\n         i, j = 0, 0\n         while i < len(board):\n             j = i\n             while j < len(board) and board[i] == board[j]:\n                 j += 1\n             if j - i >= 3:\n                 board = board[:i] + board[j:]\n                 i = 0\n             else:\n                 i = j\n         return board\n", "class Solution:\n     def findMinStep(self, board, hand):\n         \"\"\"\n         :type board: str\n         :type hand: str\n         :rtype: int\n         \"\"\"\n         hmap=collections.defaultdict(int)\n         for c in hand:\n             hmap[c]+=1\n         res=float(\"inf\")\n         res=self.helper(board,hmap)\n         if res==float(\"inf\"):\n             return -1\n         return res\n     \n     def helper(self,board,hmap):\n         board=self.removeContinues(board)\n         if len(board) ==0:\n             return 0\n         j=0\n         res=float(\"inf\")\n         for i in range(len(board)+1):\n             if i<len(board) and board[i]==board[j]:\n                 continue\n             need=3-(i-j)\n             if hmap[board[j]]>=need:\n                 hmap[board[j]]-=need\n                 nxtCnt=self.helper(board[0:j]+board[i:],hmap)\n                 if nxtCnt!=float(\"inf\"):\n                     res=min(res,nxtCnt+need)\n                 hmap[board[j]]+=need\n             j=i\n         return res\n         \n     def removeContinues(self,board):\n         j=0\n         for i in range(len(board)+1):\n             if i<len(board) and board[i]==board[j]:\n                 continue\n             if i-j>=3:\n                 return self.removeContinues(board[0:j]+board[i:])\n             else:\n                 j=i\n         return board\n         \n"]
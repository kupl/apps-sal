["from collections import deque\nfrom numpy import cross, dot\n\n\nMOVES = ((1,0), (-1,0), (0,1), (0,-1))\nDIRS  = (  'v',    '^',   '>',    '<')\n\n\ndef escape(maze):\n    \n    start = x,y = next( (x,y) for x,row in enumerate(maze) for y,c in enumerate(row) if c not in '# ' )\n    X, Y, dir   = len(maze), len(maze[0]), MOVES[ DIRS.index(maze[x][y]) ]\n    q, seens    = deque([(start, dir)]), {}\n    \n    if not x or x==X-1 or not y or y==Y-1: return []            # Already at the end, do nothing\n    \n    noPath = True\n    while q:\n        (x,y), dir = q.popleft()\n        for dx,dy in MOVES:\n            xx,yy = pos = (x+dx,y+dy)\n            \n            if 0 <= xx < X and 0 <= yy < Y and maze[xx][yy]==' ' and pos not in seens:\n                q.append( (pos, (dx,dy)) )\n                seens[pos] = ((x,y), dir, (dx,dy))              # data: (origin position, direction before origin, direction after origin)\n                if not xx or xx==X-1 or not yy or yy==Y-1:      # Escaped!\n                    q, noPath = [], False                       # reset the queue to stop it, \"from the for loop\"\n                    break\n                    \n    if noPath: return []                                        # No path, no chocolate...\n    \n    path = []\n    while pos != start:\n        pos, dir, nextDir = seens[pos]\n        scal = dot(dir, nextDir)                                # scalar prouct > 0  <=>  go ahead, otherwise, turn back\n        prod = cross(dir, nextDir)                              # cross product > 0  <=>  turn left, otherwise, turn right\n        if scal: path.append('FB' if scal < 0 else 'F')         # dot != 0 => both directions are colinear\n        else:    path.append('FL' if prod > 0 else 'FR')        # orthogonal directions, take a turn\n    \n    return list(''.join(path)[::-1])", "# Return the array of movements to execute to get out of the maze\n\ndef first_position(maze):\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] in \"><^v\":\n                return (i, j)\n\ndef walking(maze, passed, path, x, y, move):\n    lin, col = len(maze), len(maze[0])\n    if x < 0 or x >= lin or y < 0 or y >= col:\n        return True\n    if maze[x][y] == '#' or passed[x][y]:\n        return False\n    passed[x][y] = True\n    \n    if move == '>':\n        r = walking(maze, passed, path, x+1, y, 'v')\n        l = walking(maze, passed, path, x-1, y, '^')\n        f = walking(maze, passed, path, x, y+1, '>')\n        b = walking(maze, passed, path, x, y-1, '<')\n    elif move == '<':\n        r = walking(maze, passed, path, x-1, y, '^')\n        l = walking(maze, passed, path, x+1, y, 'v')\n        f = walking(maze, passed, path, x, y-1, '<')\n        b = walking(maze, passed, path, x, y+1, '>')\n    elif move == '^':\n        r = walking(maze, passed, path, x, y+1, '>')\n        l = walking(maze, passed, path, x, y-1, '<')\n        b = walking(maze, passed, path, x+1, y, 'v')\n        f = walking(maze, passed, path, x-1, y, '^')\n    elif move == 'v':\n        r = walking(maze, passed, path, x, y-1, '<')\n        l = walking(maze, passed, path, x, y+1, '>')\n        b = walking(maze, passed, path, x-1, y, '^')\n        f = walking(maze, passed, path, x+1, y, 'v')\n    \n    if f:\n        path += [\"F\"]\n    elif b:\n        path += [\"F\", \"B\"]\n    elif r:\n        path += [\"F\", \"R\"]\n    elif l:\n        path += [\"F\", \"L\"]\n    \n    return f or b or r or l\n\ndef escape(maze):\n    path = []\n    passed = [[False for j in range(len(maze[0]))] for i in range(len(maze))]\n    i, j = first_position(maze)\n    walking(maze, passed, path, i, j, maze[i][j])\n    return path[::-1]", "D = {(0,1):{(-1,0):'L', (1,0):'R', (0,-1):'B'}, (1,0):{(0,1):'L', (0,-1):'R', (-1,0):'B'},\n     (0,-1):{(1,0):'L', (-1,0):'R', (0,1):'B'}, (-1,0):{(0,-1):'L', (0,1):'R', (1,0):'B'}}\n     \ndef escape(maze):\n    P = {(r, c) for r, row in enumerate(maze) for c, v in enumerate(row) if v == ' '}\n    \n    paths = [[{(r, c) for r, row in enumerate(maze) for c, v in enumerate(row) if v in '<>^v'}.pop()]]\n    faces = {'v':(1, 0), '^':(-1,0), '<':(0,-1), '>':(0, 1)}[{c for r in maze for c in r if c in '<>^v'}.pop()]\n    \n    while paths:\n        newp = []\n        for path in paths:\n            r, c = path[-1]\n                \n            # Have we escaped?\n            if r * c == 0 or r == len(maze) - 1 or c == len(maze[0]) - 1:                \n                moves = []\n                for p in [(b[0] - a[0], b[1] - a[1]) for a, b in zip(path, path[1:])]:\n                    moves += ([D[faces][p]] if faces != p else []) + ['F']\n                    faces = p\n                return moves\n                \n            # Are there any more moves to be made on this path?\n            for p in {(r+1, c), (r-1, c), (r, c+1), (r, c-1)} & P:\n                newp.append(path + [p])\n                P.remove(p)\n        paths = newp\n    return []", "from collections import deque\n\nMOVES = {(-1, 0):'up', (1, 0):'down', (0, -1):'left', (0, 1):'right'}\nSTATES = ('<', '>', '^', 'v')\n\ndef find_start(m):\n    for row in range(len(m)):\n        for col in range(len(m[row])):\n            if m[row][col] in STATES:\n                return ( row, col ), m[row][col]\n\ndef escape(maze):\n    stored_path = {}\n    maze = [list(x) for x in maze]\n    row = len(maze)\n    col = len(maze[0])\n    start, state = find_start(maze)\n    end = []\n    queue = deque([start])\n\n    while queue:\n        x,y = queue.popleft()\n\n        for dx,dy in list(MOVES.keys()):\n            xx = x + dx\n            yy = y + dy\n\n            if 0<=xx<row and 0<=yy<col and maze[xx][yy] != '#':\n                queue.append((xx,yy))\n                stored_path[(xx,yy)] = (x,y)\n                if(xx == 0 or xx == row-1) and maze[xx][yy] or ( yy==0 or yy==col-1 and maze[xx][yy] ):\n                    end = (xx, yy)\n                    break\n                maze[xx][yy] = '#'\n\n    if not end: return end\n\n    full_path = []\n    pos = end\n    while pos != start:\n        x1,y1 = pos\n        pos = stored_path[pos]\n        x2,y2 = pos\n        full_path.append( MOVES[(x1-x2, y1-y2)])\n    \n\n    PATH = full_path[::-1]\n    out = []\n    for direction in PATH:\n        #right\n        if state == '>' and direction == 'down':\n            out.append('R')\n            out.append('F')\n            state = 'v'\n        \n        elif state == '>' and direction == 'right':\n            out.append('F')\n        \n        elif state == '>' and direction == 'left':\n            out.append('B')\n            out.append('F')\n            state = '<'\n        \n        elif state == '>' and direction == 'up':\n            out.append('L')\n            out.append('F')\n            state = '^'\n        \n        #left\n        elif state == '<' and direction == 'down':\n            out.append('L')\n            out.append('F')\n            state = 'v'\n        \n        elif state == '<' and direction == 'left':\n            out.append('F')\n        \n        elif state == '<' and direction == 'right':\n            out.append('B')\n            out.append('F')\n            state = '>'\n        \n        elif state == '<' and direction == 'up':\n            out.append('R')\n            out.append('F')\n            state = '^'\n\n        #down\n        elif state == 'v' and direction == 'down':\n            out.append('F')\n            state = 'v'\n        \n        elif state == 'v' and direction == 'left':\n            out.append('R')\n            out.append('F')\n            state = '<'\n        \n        elif state == 'v' and direction == 'right':\n            out.append('L')\n            out.append('F')\n            state = '>'\n        \n        elif state == 'v' and direction == 'up':\n            out.append('B')\n            out.append('F')\n            state = '^'\n\n        #up\n        elif state == '^' and direction == 'down':\n            out.append('B')\n            out.append('F')\n            state = 'v'\n        \n        elif state == '^' and direction == 'left':\n            out.append('L')\n            out.append('F')\n            state = '<'\n        \n        elif state == '^' and direction == 'right':\n            out.append('R')\n            out.append('F')\n            state = '>'\n        \n        elif state == '^' and direction == 'up':\n            out.append('F')\n\n    return out\n", "from heapq import *\ndef escape(maze):\n    MOVES={(-1,0):'^',(1,0):'v',(0,-1):'<',(0,1):'>'}\n    direc={('v^','^v','<>','><'):'B',('^<','v>','>^','<v'):'L', ('^>','>v','<^','v<'):'R'}\n    maze='\\n'.join(maze)\n    maze=list(map(list,maze.split('\\n')))\n    X,Y= len(maze)-1,len(maze[0])-1\n\n    for i in range(X+1):\n        for j in ('^','<','v','>'):\n            if j in maze[i]:\n                sym=j\n                row=i\n    x,y= row,maze[row].index(sym)\n    xend= (0,X)\n    yend= (0, Y)\n    q=[ (0,sym,(x,y),[] )]    # (isEnd,symbol,pos,steps)\n    \n    while q and not q[0][0]:\n        _,sym,(x,y),S= heappop(q)\n        for dx,dy in MOVES:\n            pos= a,b = x+dx , y+dy\n            if 0<=a<=X and 0<=b<=Y and maze[a][b] != '#': \n                maze[a][b]='#'\n                steps=S.copy()\n                for i in direc:\n                    if sym + MOVES[(dx,dy)] in i:\n                        steps.append(direc[i])\n                        break\n                steps.append('F')\n                heappush(q,( a in xend or b in yend, MOVES[(dx,dy)], pos, steps))\n    \n    return q and q[0][0] and q[0][3]   ", "import re\ndef escape(maze):\n    PLAYER = re.compile(\"[><^v]\")\n    MOVE = { \n        \"D\": {\n            '>': ['R', 'F'],    \n            '<': ['L', 'F'],\n            '^': ['B', 'F'],\n            'v': ['F']\n        },\n        \"U\": {\n            '>': ['L', 'F'],    \n            '<': ['R', 'F'],\n            '^': ['F'],\n            'v': ['B', 'F']\n        },\n\n        \"R\": {\n            '>': ['F'],    \n            '<': ['B', 'F'],\n            '^': ['R', 'F'],\n            'v': ['L', 'F']\n        },\n\n        \"L\": {\n            '>': ['B', 'F'],    \n            '<': ['F'],\n            '^': ['L', 'F'],\n            'v': ['R', 'F']\n        }\n    }\n\n    ymax, xmax = len(maze), len(maze[0])\n\n    # find the player\n    for idx, line in enumerate(maze):\n        player = PLAYER.search(line)\n        if player is not None:\n            y,x = idx, player.start()\n            stack = [(y,x,maze[y][x],[])]\n            break\n\n    s = set()\n    while len(stack) != 0:\n        (y,x,pos,moves) = stack.pop(0)\n\n        if y == 0 or x == 0 or y == ymax -1 or x == xmax - 1:\n            return moves\n\n        if (y,x) in s:\n            continue\n\n        s.add((y,x))\n        if y+1 < ymax and maze[y+1][x] == ' ':\n            stack.append((y+1,x,\"v\",moves + MOVE[\"D\"][pos]))\n        if y-1 >= 0 and maze[y-1][x] == ' ':\n            stack.append((y-1,x,\"^\",moves + MOVE[\"U\"][pos]))\n        if x+1 < xmax and maze[y][x+1] == ' ':\n            stack.append((y,x+1,\">\",moves + MOVE[\"R\"][pos]))\n        if x-1 >= 0 and maze[y][x-1] == ' ':\n            stack.append((y,x-1,\"<\",moves + MOVE[\"L\"][pos]))\n\n    return []\n", "class Piece:\n\n    def __init__(self, map):\n        self.map = map\n        self.size = (len(map) - 1, len(map[0]) - 1)\n        for num, line in enumerate(map):\n            for tag in ('^', '<', 'v', '>'):\n                if tag in line:\n                    self.x, self.y, self.direct = num, line.index(tag), tag\n        self.walked = set()     # \u8bb0\u5f55\u6240\u6709\u884c\u8fdb\u8fc7\u5f97\u70b9\n        self.walked.add((self.x, self.y))\n        self.forks = []     # \u8bb0\u5f55\u6240\u6709\u5c94\u8def\u53e3\u4ee5\u53ca\u5728\u5c94\u8def\u53e3\u65f6\u7684\u6b65\u6570\n        self.steps = 0  # \u8bb0\u5f55\u884c\u52a8\u8fc7\u5f97\u6b65\u6570\uff0c\u65b9\u4fbf\u56de\u6eaf\n        self.check_fork(self.x, self.y, 1)  # \u8d77\u70b9\u65f6\u6709\u4e24\u4e2a\u65b9\u5411\u5c31\u7b97\u5c94\u8def\u53e3\n        self.dir = {\n            'up': ('^', (-1, 0)),\n            'down': ('v', (1, 0)),\n            'left': ('<', (0, -1)),\n            'right': ('>', (0, 1)),\n        }\n        self.turn = {\n            '>': {'L': self.dir['up'], 'R': self.dir['down'], 'B': self.dir['left'], 'F': self.dir['right']},\n            '<': {'L': self.dir['down'], 'R': self.dir['up'], 'B': self.dir['right'], 'F': self.dir['left']},\n            '^': {'L': self.dir['left'], 'R': self.dir['right'], 'B': self.dir['down'], 'F': self.dir['up']},\n            'v': {'L': self.dir['right'], 'R': self.dir['left'], 'B': self.dir['up'], 'F': self.dir['down']},\n        }\n\n    def check_fork(self, x, y, direct=2):\n        count = 0\n        for x_, y_ in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):\n            if x_ >= 0 and x_ <= self.size[0] and y_ >= 0 and y_ <= self.size[1]:\n                if self.map[x_][y_] != '#':\n                    count += 1\n        fork = ((x, y), self.steps, self.direct)\n        for _ in range(count-direct):   # \u56db\u4e2a\u65b9\u5411\u6709\u4e09\u4e2a\u80fd\u901a\u624d\u662f\u5c94\u8def\u53e3\n            self.forks.append(fork)\n\n    def draw_map(self, x, y):\n        self.map[x] = self.map[x][:y] + self.direct + self.map[x][y + 1:]\n\n    def go_forward(self):\n        self.direct, (x, y) = self.turn[self.direct]['F']\n        x, y = self.x + x, self.y + y\n        if self.map[x][y] != '#' and (x, y) not in self.walked:     # \u53ea\u6709\u524d\u65b9\u662f\u7a7a\u5730\uff0c\u5e76\u4e14\u6ca1\u6709\u8d70\u8fc7\u624d\u4f1a\u5411\u524d\u8d70\n            self.x, self.y = x, y\n            self.walked.add((x, y))  # \u5c06\u8d70\u8fc7\u7684\u8def\u52b2\u90fd\u8bb0\u5f55\u4e0b\u6765\uff0c\u4e0d\u8d70\u91cd\u590d\u7684\u8def\n            self.steps += 1\n            self.check_fork(x, y)\n            #self.draw_map(x, y)\n            return 'F'\n        else:   # \u5426\u5219\u8f6c\u5411\n            for key in ('L', 'R', 'B'):\n                direct, (x, y) = self.turn[self.direct][key]\n                x, y = self.x + x, self.y + y\n                if self.map[x][y] != '#' and (x, y) not in self.walked:  # \u8f6c\u5411\u65f6\u5fc5\u987b\u8003\u8651\u8f6c\u5411\u540e\u7684\u65b9\u4f4d\u6ca1\u6709\u8d70\u8fc7\u4e14\u662f\u7a7a\u5730\n                    self.direct = direct\n                    self.steps += 1\n                    #self.draw_map(self.x, self.y)\n                    return key\n            if self.forks:     # \u5982\u679c3\u4e2a\u65b9\u5411\u90fd\u4e0d\u884c\uff0c\u5219\u68c0\u67e5\u662f\u5426\u80fd\u56de\u6eaf\uff0c\u5982\u679c\u4e0d\u80fd\u5219\u8fd4\u56deNone\n                (self.x, self.y), self.steps, self.direct = self.forks.pop()\n                return self.steps\n            else:\n                return None\n\n\ndef escape(maze):\n    # Have a nice sleep ;)\n    p = Piece(maze)\n    res = ''\n\n    while p.x not in (0, p.size[0]) and p.y not in (0, p.size[1]):\n        tmp = p.go_forward()\n        if tmp is None:\n            return []\n        elif isinstance(tmp, int):\n            res = res[:tmp]\n        else:\n            res += tmp\n    return list(res)", "from collections import deque\n\nB = {'^':'v', 'v':'^', '<':'>', '>':'<'}\nL = {'^':'<', 'v':'>', '<':'v', '>':'^'}\nR = {'^':'>', 'v':'<', '<':'^', '>':'v'}\nF = {'^': lambda i,j: (i-1, j),\n     'v': lambda i,j: (i+1, j),\n     '<': lambda i,j: (i, j-1),\n     '>': lambda i,j: (i, j+1)}\n\ndef escape(maze):\n    H, W = len(maze), len(maze[0])\n    a, b, c = next((a,b,c) for a,row in enumerate(maze) for b,c in enumerate(row) if c in \"^<v>\")\n    left, seen = deque([(a, b, c, [])]), set()\n    while left:\n        i, j, p, T = left.popleft()\n        if i in (0, H-1) or j in (0, W-1): return T\n        if (i, j, p) in seen: continue\n        seen.add((i, j, p))\n        k, l = F[p](i, j)\n        if maze[k][l] == ' ': left.append((k, l, p, T + ['F']))\n        left.extend([(i, j, L[p], T + ['L']), (i, j, R[p], T + ['R']), (i, j, B[p], T + ['B'])])\n    return []", "def escape(maze):\n    h, w = len(maze), len(maze[0])\n    maze = [list(row) for row in maze]\n    i, j, face = find_self(maze)\n    maze[i][j] = '#'\n    paths = [[i, j, face, []]]\n    while paths:\n        i, j, face, path = paths.pop(0)\n        if i == 0 or i+1 == h or j == 0 or j+1 == w:\n            return path\n        for step, mi, mj, new_face in directions(i, j, face):\n            if maze[mi][mj] != '#':\n                paths.append([mi, mj, new_face, path+step])\n                maze[mi][mj] = '#'\n    return []\n\n\ndef find_self(maze):\n    faces = {'^': (-1, 0), '<': (0, -1), 'v': (1, 0), '>': (0, 1)}\n    for i, row in enumerate(maze):\n        for j, cell in enumerate(row):\n            if cell in faces:\n                return i, j, faces[cell]\n\n\ndef directions(i, j, face):\n    fi, fj = face\n    return [[['F'],      i+fi, j+fj, face], \n            [['L', 'F'], i-fj, j+fi, (-fj, fi)],\n            [['R', 'F'], i+fj, j-fi, (fj, -fi)],\n            [['B', 'F'], i-fi, j-fj, (-fi, -fj)]]\n", "from collections import deque\n\nderp = {'^': (-1, 0),\n        '<': (0, -1),\n        'v': (+1, 0),\n        '>': (0, +1)}\n\ndef turn(d1, d2):\n    m1, m2 = derp[d1], derp[d2]\n    if m1[0] + m2[0] == 0 and m1[1] + m2[1] == 0:\n        return 'B'\n    if m2[0] - m1[0] + m2[1] + m1[1] == 0:\n        return 'L'\n    return 'R'\n\ndef neighs(maze, pos):\n    i, j, d = pos\n    mi, mj = derp[d]\n    ni, nj = (i+mi, j+mj)\n    return [(ni, nj, d)] + [(i, j, nd) for nd in derp.keys() - {d}]\n\ndef escape(maze):\n    pos = next(((i, j, cell) for i, row in enumerate(maze)\n                             for j, cell in enumerate(row)\n                             if cell in derp))\n    \n    q = deque([pos])\n    prev = {pos: None}\n    while q:\n        i, j, d = pos = q.popleft()\n        \n        try:\n            if i < 0 or j < 0:\n                raise IndexError\n            cell = maze[i][j]\n        except IndexError:\n            rpath = []\n            while True:\n                pp = prev[pos]\n                if pp is None:\n                    break\n                (_, _, d1), (_, _, d2) = pp, pos\n                if d1 == d2:\n                    rpath.append('F')\n                else:\n                    rpath.append(turn(d1, d2))\n                pos = pp\n            return rpath[::-1]\n        \n        if cell == '#':\n            continue\n                \n        for n in neighs(maze, pos):\n            if n not in prev:\n                i, j, d = n\n                q.append(n)\n                prev[n] = pos\n                \n    return []"]
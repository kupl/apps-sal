["def merge(intervals,start,mid,end):\n al = mid-start+1\n bl = end-mid\n \n A = intervals[start:mid+1]\n B = intervals[mid+1:end+1]\n \n p=0;q=0;k=start;\n while(p<al and q<bl):\n  if(A[p]<B[q]):\n   intervals[k] = A[p]\n   k+=1;p+=1;\n  else:\n   intervals[k] = B[q]\n   k+=1;q+=1;\n \n while(p<al):\n  intervals[k] = A[p]\n  k+=1;p+=1;\n while(q<bl):\n  intervals[k] = B[q]\n  k+=1;q+=1;\n \n\ndef mergesort(intervals, start, end):\n if(start<end):\n  mid = int((start+end)/2)\n  mergesort(intervals,start,mid)\n  mergesort(intervals,mid+1,end)\n  merge(intervals,start,mid,end)\n\nt = int(input())\nfor _ in range(t):\n n,m,k = map(int, input().split())\n \n cities = [[0,[]] for i in range(n)]\n for i in range(m):\n  a,b = map(int, input().split())\n  cities[a-1][1].append(b-1)\n  cities[b-1][1].append(a-1)\n \n li = list(map(int, input().split()))\n \n def specialfunction():\n  mergesort(li,0,n-1)\n  if(k>len(li)):\n   print(-1)\n  else:\n   sum = 0\n   front = 0\n   rear = len(li)-1\n   for i in range(k):\n    if(i%2==0):\n     sum += li[rear]\n     rear -= 1\n    else:\n     sum += li[front]\n     front += 1\n   print(sum)\n \n if(m == 0):\n  specialfunction()\n  continue\n \n for i in range(n):\n  cities[i][0] = li[i]\n \n visited = [-1 for i in range(n)]\n count = 0\n museummonths = []\n def searchUnvisited():\n  for i in range(n):\n   if(visited[i] == -1):\n    return i\n  return -1\n \n def bfs(ind,count):\n  museumcount = 0\n  queue = []\n  queue.append(ind)\n  visited[ind] = 1\n  museumcount += cities[ind][0]\n  count += 1\n  front = 0\n  rear = 0\n  while(front<=rear):\n   noe = len(cities[ind][1])\n   for i in range(noe):\n    if(visited[cities[ind][1][i]] == -1):\n     queue.append(cities[ind][1][i])\n     rear += 1\n     count += 1\n     museumcount += cities[cities[ind][1][i]][0]\n     visited[cities[ind][1][i]] = 1\n   front += 1\n   try:\n    ind = queue[front]\n   except:\n    break\n  museummonths.append(museumcount)\n  return count\n \n while(count<n):\n  for i in range(n):\n   if(visited[i] == -1):\n    count = bfs(i,count)\n \n mergesort(museummonths,0,len(museummonths)-1)\n #print(museummonths)\n if(k>len(museummonths)):\n  print(-1)\n else:\n  sum = 0\n  front = 0\n  rear = len(museummonths)-1\n  for i in range(k):\n   if(i%2==0):\n    sum += museummonths[rear]\n    rear -= 1\n   else:\n    sum += museummonths[front]\n    front += 1\n  print(sum)", "# cook your dish here\nfrom collections import defaultdict\n\nt=int(input())\nfor _ in range(t):\n n,m,k=map(int, input().split())\n graph=defaultdict(lambda:[])\n for _ in range(m):\n  u, v = map(int,input().split())\n  graph[u-1].append(v-1)\n  graph[v-1].append(u-1)\n museums=list(map(int,input().split()))\n visited=[0]*n\n lista=[]\n for i in range(n):\n  if visited[i]==0:\n   visited[i]=1\n   stack=[i]\n   counter=museums[i]\n   while len(stack)>0:\n    u=stack.pop()\n    for v in graph[u]:\n     if visited[v]==0:\n      counter+=museums[v]\n      stack.append(v)\n      visited[v]=1\n   lista.append(counter)\n if len(lista)<k:\n  print(-1)\n else:\n  lista.sort()\n  counter=0\n  id0=0 \n  id1=len(lista)-1 \n  for i in range(k):\n   if i%2==0:\n    counter+=lista[id1]\n    id1-=1 \n   else:\n    counter+=lista[id0]\n    id0+=1 \n  print(counter)", "def dfs(i):\n visited[i]=True\n musuemsPossible=musuems[i]\n for j in neighbours[i]:\n  if(not visited[j]):\n   musuemsPossible+=dfs(j)\n return musuemsPossible\n\nt = int(input())\nfor _ in range(t):\n n,m,k = list(map(int, input().split())) \n neighbours=[]\n visited=[]\n for i in range(n):\n  visited.append(False)\n  neighbours.append([])\n for _ in range(m):\n  a,b = list(map(int, input().split()))\n  neighbours[a-1].append(b-1)\n  neighbours[b-1].append(a-1)\n \n musuems=[int(x) for x in input().split()]\n\n mususeumsBigNode=[]\n for i in range(n):\n  if(not visited[i]):\n   mususeumsBigNode.append(dfs(i))\n \n if len(mususeumsBigNode) < k:print(-1)\n else:\n  mususeumsBigNode.sort()\n  if k % 2 == 0:\n   k //= 2\n   ans = sum(mususeumsBigNode[:k]+mususeumsBigNode[-k:])\n  else:\n   k //= 2\n   ans = mususeumsBigNode[-k-1]\n   if k > 0:ans += sum(mususeumsBigNode[:k]+mususeumsBigNode[-k:])\n  print(ans)\n", "def dfs(i):\n visited[i]=True\n musuemsPossible=musuems[i]\n for j in neighbours[i]:\n  if(not visited[j]):\n   musuemsPossible+=dfs(j)\n return musuemsPossible\n\nt = int(input())\nfor _ in range(t):\n n,m,k = list(map(int, input().split())) \n neighbours=[]\n visited=[]\n for i in range(n):\n  visited.append(False)\n  neighbours.append([])\n for i in range(m):\n  a=[int(x) for x in input().split()]\n  neighbours[a[0]-1].append(a[1]-1)\n  neighbours[a[1]-1].append(a[0]-1)\n \n musuems=[int(x) for x in input().split()]\n\n mususeumsBigNode=[]\n for i in range(n):\n  if(not visited[i]):\n   mususeumsBigNode.append(dfs(i))\n \n if len(mususeumsBigNode) < k:print(-1)\n else:\n  mususeumsBigNode.sort()\n  if k % 2 == 0:\n   k //= 2\n   ans = sum(mususeumsBigNode[:k]+mususeumsBigNode[-k:])\n  else:\n   k //= 2\n   ans = mususeumsBigNode[-k-1]\n   if k > 0:ans += sum(mususeumsBigNode[:k]+mususeumsBigNode[-k:])\n  print(ans)\n", "def dfs(i):\n visited[i]=True\n musuemsPossible=musuems[i]\n for j in neighbours[i]:\n  if(not visited[j]):\n   musuemsPossible+=dfs(j)\n return musuemsPossible\n\nt = int(input())\nfor _ in range(t):\n a=[int(x) for x in input().split()]\n n=a[0]\n m=a[1]\n k=a[2]\n neighbours=[]\n visited=[]\n for i in range(n+1):\n  visited.append(False)\n  neighbours.append([])\n for i in range(m):\n  a=[int(x) for x in input().split()]\n  neighbours[a[0]].append(a[1])\n  neighbours[a[1]].append(a[0])\n \n musuems=[0]\n m2=[int(x) for x in input().split()]\n for i in m2:\n  musuems.append(i)\n\n mususeumsBigNode=[]\n for i in range(1,n+1):\n  if(not visited[i]):\n   mususeumsBigNode.append(dfs(i))\n \n # print(mususeumsBigNode)\n sorted(mususeumsBigNode)\n if len(mususeumsBigNode) < k:print(-1)\n else:\n  mususeumsBigNode.sort()\n  if k % 2 == 0:\n   k //= 2\n   ans = sum(mususeumsBigNode[:k]+mususeumsBigNode[-k:])\n  else:\n   k //= 2\n   ans = mususeumsBigNode[-k-1]\n   if k > 0:ans += sum(mususeumsBigNode[:k]+mususeumsBigNode[-k:])\n  print(ans)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jul 17 14:21:08 2020\n\n@author: shubham gupta\n\"\"\"\n# cook your dish here\nfor _ in range(int(input())):\n n,m,k = list(map(int, input().split())) \n l = [[] for _ in range(n+1)]\n for _ in range(m):\n  a,b = list(map(int, input().split()))\n  l[a].append(b)\n  l[b].append(a)\n m_l = [-1] + list(map(int, input().split())) \n visited = [False for _ in range(n+1)] \n sum_l = []\n for i in range(1, n+1):\n  if visited[i] == False:\n   summa = 0\n   q = [i]\n   while len(q) != 0:\n    v = q[-1]\n    del q[-1]\n    if visited[v]:continue \n    visited[v] = True\n    summa += m_l[v]\n    for vv in l[v]:q.append(vv)\n   sum_l.append(summa)\n   \n # print(sum_l)\n if len(sum_l) < k:print(-1)\n else:\n  sum_l.sort()\n  if k % 2 == 0:\n   k //= 2\n   ans = sum(sum_l[:k]+sum_l[-k:])\n  else:\n   k //= 2\n   ans = sum_l[-k-1]\n   if k > 0:ans += sum(sum_l[:k]+sum_l[-k:])\n  print(ans)\n   \n", "# cook your dish here\nfor _ in range(int(input())):\n n,m,k = list(map(int, input().split()))\n \n l = [[] for _ in range(n+1)]\n for _ in range(m):\n  a,b = list(map(int, input().split()))\n  l[a].append(b)\n  l[b].append(a)\n m_l = [-1] + list(map(int, input().split()))\n \n visited = [False for _ in range(n+1)]\n \n sum_l = []\n for i in range(1, n+1):\n  if visited[i] == False:\n   summa = 0\n   q = [i]\n   while len(q) != 0:\n    v = q[-1]\n    del q[-1]\n    if visited[v]:\n     continue\n    \n    visited[v] = True\n    summa += m_l[v]\n    for vv in l[v]:\n     q.append(vv)\n   sum_l.append(summa)\n   \n # print(sum_l)\n if len(sum_l) < k:\n  print(-1)\n else:\n  sum_l.sort()\n  if k % 2 == 0:\n   k //= 2\n   ans = sum(sum_l[:k]+sum_l[-k:])\n  else:\n   k //= 2\n   ans = sum_l[-k-1]\n   if k > 0:\n    ans += sum(sum_l[:k]+sum_l[-k:])\n  print(ans)\n   \n", "def merge(intervals,start,mid,end):\n al = mid-start+1\n bl = end-mid\n \n A = intervals[start:mid+1]\n B = intervals[mid+1:end+1]\n \n p=0;q=0;k=start;\n while(p<al and q<bl):\n  if(A[p]<B[q]):\n   intervals[k] = A[p]\n   k+=1;p+=1;\n  else:\n   intervals[k] = B[q]\n   k+=1;q+=1;\n \n while(p<al):\n  intervals[k] = A[p]\n  k+=1;p+=1;\n while(q<bl):\n  intervals[k] = B[q]\n  k+=1;q+=1;\n \n\ndef mergesort(intervals, start, end):\n if(start<end):\n  mid = int((start+end)/2)\n  mergesort(intervals,start,mid)\n  mergesort(intervals,mid+1,end)\n  merge(intervals,start,mid,end)\n\nt = int(input())\nfor _ in range(t):\n n,m,k = map(int, input().split())\n \n cities = [[0,[]] for i in range(n)]\n for i in range(m):\n  a,b = map(int, input().split())\n  cities[a-1][1].append(b-1)\n  cities[b-1][1].append(a-1)\n \n li = list(map(int, input().split()))\n \n def specialfunction():\n  mergesort(li,0,n-1)\n  if(k>len(li)):\n   print(-1)\n  else:\n   sum = 0\n   front = 0\n   rear = len(li)-1\n   for i in range(k):\n    if(i%2==0):\n     sum += li[rear]\n     rear -= 1\n    else:\n     sum += li[front]\n     front += 1\n   print(sum)\n \n if(m == 0):\n  specialfunction()\n  continue\n \n for i in range(n):\n  cities[i][0] = li[i]\n \n visited = [-1 for i in range(n)]\n count = 0\n museummonths = []\n def searchUnvisited():\n  for i in range(n):\n   if(visited[i] == -1):\n    return i\n  return -1\n \n def bfs(ind,count):\n  museumcount = 0\n  queue = []\n  queue.append(ind)\n  visited[ind] = 1\n  museumcount += cities[ind][0]\n  count += 1\n  front = 0\n  rear = 0\n  while(front<=rear):\n   noe = len(cities[ind][1])\n   for i in range(noe):\n    if(visited[cities[ind][1][i]] == -1):\n     queue.append(cities[ind][1][i])\n     rear += 1\n     count += 1\n     museumcount += cities[cities[ind][1][i]][0]\n     visited[cities[ind][1][i]] = 1\n   front += 1\n   try:\n    ind = queue[front]\n   except:\n    break\n  museummonths.append(museumcount)\n  return count\n \n while(count<n):\n  for i in range(n):\n   if(visited[i] == -1):\n    count = bfs(i,count)\n \n mergesort(museummonths,0,len(museummonths)-1)\n #print(museummonths)\n if(k>len(museummonths)):\n  print(-1)\n else:\n  sum = 0\n  front = 0\n  rear = len(museummonths)-1\n  for i in range(k):\n   if(i%2==0):\n    sum += museummonths[rear]\n    rear -= 1\n   else:\n    sum += museummonths[front]\n    front += 1\n  print(sum)", "def merge(intervals,start,mid,end):\n al = mid-start+1\n bl = end-mid\n \n A = intervals[start:mid+1]\n B = intervals[mid+1:end+1]\n \n p=0;q=0;k=start;\n while(p<al and q<bl):\n  if(A[p]<B[q]):\n   intervals[k] = A[p]\n   k+=1;p+=1;\n  else:\n   intervals[k] = B[q]\n   k+=1;q+=1;\n \n while(p<al):\n  intervals[k] = A[p]\n  k+=1;p+=1;\n while(q<bl):\n  intervals[k] = B[q]\n  k+=1;q+=1;\n \n\ndef mergesort(intervals, start, end):\n if(start<end):\n  mid = int((start+end)/2)\n  mergesort(intervals,start,mid)\n  mergesort(intervals,mid+1,end)\n  merge(intervals,start,mid,end)\n\nt = int(input())\nfor _ in range(t):\n n,m,k = map(int, input().split())\n \n cities = [[0,[]] for i in range(n)]\n for i in range(m):\n  a,b = map(int, input().split())\n  cities[a-1][1].append(b-1)\n  cities[b-1][1].append(a-1)\n \n li = list(map(int, input().split()))\n \n def specialfunction():\n  mergesort(li,0,n-1)\n  if(k>len(li)):\n   print(-1)\n  else:\n   sum = 0\n   front = 0\n   rear = len(li)-1\n   for i in range(k):\n    if(i%2==0):\n     sum += li[rear]\n     rear -= 1\n    else:\n     sum += li[front]\n     front += 1\n   print(sum)\n \n if(m == 0):\n  specialfunction()\n  continue\n \n for i in range(n):\n  cities[i][0] = li[i]\n \n visited = [-1 for i in range(n)]\n count = 0\n museummonths = []\n def searchUnvisited():\n  for i in range(n):\n   if(visited[i] == -1):\n    return i\n  return -1\n \n def bfs(ind,count):\n  museumcount = 0\n  queue = []\n  queue.append(ind)\n  visited[ind] = 1\n  museumcount += cities[ind][0]\n  count += 1\n  front = 0\n  rear = 0\n  while(front<=rear):\n   noe = len(cities[ind][1])\n   for i in range(noe):\n    if(visited[cities[ind][1][i]] == -1):\n     queue.append(cities[ind][1][i])\n     rear += 1\n     count += 1\n     museumcount += cities[cities[ind][1][i]][0]\n     visited[cities[ind][1][i]] = 1\n   front += 1\n   try:\n    ind = queue[front]\n   except:\n    break\n  museummonths.append(museumcount)\n  return count\n \n while(count<n):\n  ind = searchUnvisited()\n  count = bfs(ind,count)\n \n mergesort(museummonths,0,len(museummonths)-1)\n #print(museummonths)\n if(k>len(museummonths)):\n  print(-1)\n else:\n  sum = 0\n  front = 0\n  rear = len(museummonths)-1\n  for i in range(k):\n   if(i%2==0):\n    sum += museummonths[rear]\n    rear -= 1\n   else:\n    sum += museummonths[front]\n    front += 1\n  print(sum)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 21 15:46:01 2020\n\n@author: pramo\n\"\"\"\n\nimport resource, sys\nresource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))\nsys.setrecursionlimit(10**6)\n\nclass graph:\n \"\"\"docstring for graph\"\"\"\n def __init__(self, N):\n  self.N = N\n  self.adjacent_list = [[] for i in range(N)]\n \n def add_road(self,a,b):\n  self.adjacent_list[a].append(b)\n  self.adjacent_list[b].append(a)\n\n def DFS_iterate(self, con_list, n, visited):\n  visited[n]=True\n  con_list.append(n)\n\n  for i in self.adjacent_list[n]:\n   if visited[i]==False:\n    con_list = self.DFS_iterate(con_list,i,visited)\n  return con_list\n\n def connected_groups(self):\n  visited = [False for i in range(N)]\n  con_groups=[]\n  for n in range(N):\n   if visited[n]==False:\n    con_list=[]\n    con_groups.append(self.DFS_iterate(con_list,n,visited))\n\n  return con_groups\n\n\n\n\nT = int(input())\n# T=1\n\nfor x in range(T):\n N,M,K=list(map(int,input().split()))\n city_map = graph(N)\n # roads=[]\n for i in range(M):\n  road = list(map(int,input().split()))\n  city_map.add_road(road[0]-1,road[1]-1)\n museums_city=list(map(int,input().split()))\n\n con_groups=city_map.connected_groups()\n \n if(len(con_groups)<K):\n  print(\"-1\")\n else:\n  museums_groups=[]\n  for group in con_groups:\n   museums_group=0\n   for city in group:\n    # print(museums_city[city])\n    museums_group+=museums_city[city]\n   museums_groups.append(museums_group)\n  \n  total_museums=0\n  museums_groups.sort(reverse=True)\n  # Nikhil=False\n  # for j in range(K):\n  #   index_month=-1*Nikhil\n  #   total_museums+=museums_groups[index_month]\n  #   if len(museums_groups)!=0:\n  #       del(museums_groups[index_month])\n  #   Nikhil = not Nikhil\n  # print(museums_groups)\n  Ladki=0\n  Nikhil=len(museums_groups)-1\n  for j in range(K):\n   if j%2==0:\n    total_museums+=museums_groups[Ladki]\n    Ladki+=1\n   else:\n    total_museums+=museums_groups[Nikhil]\n    Nikhil-=1\n  print(total_museums)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Feb 21 15:46:01 2020\n\n@author: pramo\n\"\"\"\n\nclass graph:\n \"\"\"docstring for graph\"\"\"\n def __init__(self, N):\n  self.N = N\n  self.adjacent_list = [[] for i in range(N)]\n \n def add_road(self,a,b):\n  self.adjacent_list[a].append(b)\n  self.adjacent_list[b].append(a)\n\n def DFS_iterate(self, con_list, n, visited):\n  visited[n]=True\n  con_list.append(n)\n\n  for i in self.adjacent_list[n]:\n   if visited[i]==False:\n    con_list = self.DFS_iterate(con_list,i,visited)\n  return con_list\n\n def connected_groups(self):\n  visited = [False for i in range(N)]\n  con_groups=[]\n  for n in range(N):\n   if visited[n]==False:\n    con_list=[]\n    con_groups.append(self.DFS_iterate(con_list,n,visited))\n\n  return con_groups\n\n\n\n\nT = int(input())\n# T=1\n\nfor x in range(T):\n N,M,K=list(map(int,input().split()))\n city_map = graph(N)\n # roads=[]\n for i in range(M):\n  road = list(map(int,input().split()))\n  city_map.add_road(road[0]-1,road[1]-1)\n museums_city=list(map(int,input().split()))\n\n con_groups=city_map.connected_groups()\n \n if(len(con_groups)<K):\n  print(\"-1\")\n else:\n  museums_groups=[]\n  for group in con_groups:\n   museums_group=0\n   for city in group:\n    # print(museums_city[city])\n    museums_group+=museums_city[city]\n   museums_groups.append(museums_group)\n  \n  total_museums=0\n  museums_groups.sort(reverse=True)\n  # Nikhil=False\n  # for j in range(K):\n  #   index_month=-1*Nikhil\n  #   total_museums+=museums_groups[index_month]\n  #   if len(museums_groups)!=0:\n  #       del(museums_groups[index_month])\n  #   Nikhil = not Nikhil\n  # print(museums_groups)\n  Ladki=0\n  Nikhil=len(museums_groups)-1\n  for j in range(K):\n   if j%2==0:\n    total_museums+=museums_groups[Ladki]\n    Ladki+=1\n   else:\n    total_museums+=museums_groups[Nikhil]\n    Nikhil-=1\n  print(total_museums)\n", "# import Queue\n# q = Queue.Queue()\ndef bfs(visited, musium, count, roads, explore):\n visited[explore-1] = True\n count[0] += musium[explore]\n for _ in roads[explore]:\n  if not visited[_-1]:\n   bfs(visited, musium, count, roads, _)\n\n\nt = int(input())\nwhile t>0:\n n, m, k = list(map(int, input().split()))\n\n roads = {i:[] for i in range(1,n+1)}\n visited = [False for _ in range(n)]\n for _ in range(m):\n  s, e = list(map(int, input().split()))\n  roads[s].append(e)\n  roads[e].append(s)\n musium = []\n hashm = {}\n mp = list(map(int, input().split()))\n for i in enumerate(mp, 1):\n  musium.append(i)\n  hashm.update({i[0]:i[1]})\n  \n musium.sort(key = lambda x : x[1])\n # print(musium)\n \n \n count ,lavany ,end ,begin = [0], True, n-1, 0\n \n while k>0:\n  if lavany:\n   while visited[ musium[end][0]-1 ] and end > begin:\n    end -= 1\n   # visited[musium[end][0]] = True\n   bfs(visited, hashm, count, roads, musium[end][0])\n   end -= 1\n\n  else:\n   while visited[ musium[begin][0]-1 ] and end > begin:\n    begin += 1\n   bfs(visited, hashm, count, roads, musium[begin][0])\n   begin += 1\n  k -= 1\n  lavany = not lavany\n  if all(visited) and k>0:\n   print(-1)\n   break\n else:\n  print(count[0])\n t -= 1\n", "t = int(input())\nwhile(t):\n t -= 1\n n, m, k = list(map(int, input().split()))\n g = []\n for i in range(1000001):\n  g.append([])\n while(m):\n  m -= 1\n  x, y = list(map(int, input().split()))\n  g[x].append(y)\n  g[y].append(x)\n a = [0] + list(map(int, input().split()))\n ans = []\n vis = [0]*1000001\n for i in range(1, n+1):\n  if(vis[i] == 0):\n   vis[i] = 1\n   val = a[i]\n   bfsQ = [i]\n   while(bfsQ):\n    x = bfsQ[0]\n    del bfsQ[0]\n    for y in g[x]:\n     if(vis[y] == 0):\n      val += a[y]\n      vis[y] = 1\n      bfsQ.append(y)\n   ans.append(val)\n ans = sorted(ans)\n if(k>len(ans)):\n  print(-1)\n else:\n  print(sum(ans[:k//2]) + sum(ans[len(ans)-(k-k//2):]))", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2019/11/30 18:18\n\n\"\"\"\n\nT = int(input())\nfor ti in range(T):\n N, M, K = list(map(int, input().split()))\n\n G = collections.defaultdict(list)\n for i in range(M):\n  u, v = list(map(int, input().split()))\n  G[u].append(v)\n  G[v].append(u)\n\n museums = [0] + [int(x) for x in input().split()]\n\n vis = [False] * (N+1)\n counts = []\n for s in range(1, N+1):\n  if vis[s]:\n   continue\n  vis[s] = True\n  count = 0\n  q = [s]\n  while q:\n   u = q.pop()\n   count += museums[u]\n   for v in G[u]:\n    if not vis[v]:\n     vis[v] = True\n     q.append(v)\n  counts.append(count)\n\n if len(counts) < K:\n  print(-1)\n else:\n  counts.sort(reverse=True)\n  if K == 1:\n   print(counts[0])\n  elif K % 2 == 0:\n   print(sum(counts[:K//2]) + sum(counts[-(K//2):]))\n  else:\n   print(sum(counts[:K//2+1]) + sum(counts[-(K//2):]))\n\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2019/11/30 18:18\n\n\"\"\"\n\nT = int(input())\nfor ti in range(T):\n N, M, K = list(map(int, input().split()))\n\n G = collections.defaultdict(list)\n for i in range(M):\n  u, v = list(map(int, input().split()))\n  G[u].append(v)\n  G[v].append(u)\n\n museums = [0] + [int(x) for x in input().split()]\n\n vis = [False] * (N+1)\n counts = []\n for s in range(1, N+1):\n  if vis[s]:\n   continue\n  vis[s] = True\n  count = 0\n  q = [s]\n  while q:\n   u = q.pop()\n   count += museums[u]\n   for v in G[u]:\n    if not vis[v]:\n     vis[v] = True\n     q.append(v)\n  counts.append(count)\n\n\n if len(counts) < K:\n  print(-1)\n else:\n  counts.sort(reverse=True)\n  if K % 2 == 0:\n   print(sum(counts[:K//2]) + sum(counts[-(K//2):]))\n  else:\n   print(sum(counts[:K//2+1]) + sum(counts[-(K//2):]))\n\n", "# cook your dish here\nt=int(input())\nimport sys\nsys.setrecursionlimit(1000000)\ndef dfs(node):\n nonlocal l,vis\n st=True\n for i in adj[node]:\n  if i in l:\n   vis[a]+=it[i]\n   st=False\n   l.remove(i)\n   #print('visited here',vis)\n   #print('L here',l)\n   dfs(i)\n if st:\n  return ''\n \nfor _ in range(t):\n n,m,k=list(map(int,input().split()))\n adj=[[] for i in range(n)]\n l=set(range(0,n))\n #print('l',l)\n for i in range(m):\n  x,y=list(map(int,input().split()))\n  adj[x-1].append(y-1)\n  adj[y-1].append(x-1)\n #print('graph',adj)    \n it=list(map(int,input().split()))\n #print('it',it)\n vis={}\n cost=[]\n while l!=set():\n  a=l.pop()\n  #print('a',a)\n  vis[a]=it[a]\n  dfs(a)\n  cost.append(vis[a])\n  #print('cost',cost)\n cost.sort()\n if len(cost)<k:\n  print(-1)\n  continue\n mi=0\n ma=len(cost)\n su=0\n for i in range(k):\n  if i%2==0:\n   #print('EVEN','i',i,'ma-1',ma-1,'cost[ma-1]',cost[ma-1])\n   su+=cost[ma-1]\n   ma-=1\n  else:\n   #print('ODD','i',i,'mi',mi,'cost[mi]',cost[mi])\n   su+=cost[mi]\n   mi+=1\n print(su)\n\n\n\n\n\n  \n \n", "# cook your dish here\nt=int(input())\nimport sys\nsys.setrecursionlimit(1000000)\ndef dfs(node):\n nonlocal l,vis\n st=True\n for i in adj[node]:\n  if i in l:\n   vis[a]+=it[i]\n   st=False\n   l.remove(i)\n   dfs(i)\n if st:\n  return ''\n \nfor _ in range(t):\n n,m,k=list(map(int,input().split()))\n adj=[[] for i in range(n)]\n l=set(range(0,n))\n for i in range(m):\n  x,y=list(map(int,input().split()))\n  adj[x-1].append(y-1)\n  adj[y-1].append(x-1)\n it=list(map(int,input().split()))\n vis={}\n cost=[]\n while l!=set():\n  a=l.pop()\n  vis[a]=it[a]\n  dfs(a)\n  cost.append(vis[a])\n cost.sort()\n if len(cost)<k:\n  print(-1)\n  continue\n mi=0\n ma=len(cost)\n su=0\n for i in range(k):\n  if i%2==0:\n   su+=cost[ma-1]\n   ma-=1\n  else:\n   su+=cost[mi]\n   mi+=1\n print(su)\n\n\n\n\n\n  \n \n", "# cook your dish here\nt=int(input())\nimport sys\nsys.setrecursionlimit(1000000)\ndef dfs(node):\n nonlocal l,vis\n st=True\n for i in adj[node]:\n  if i in l:\n   vis[a]+=it[i]\n   st=False\n   l.remove(i)\n   dfs(i)\n if st:\n  return ''\n \nfor _ in range(t):\n n,m,k=list(map(int,input().split()))\n adj=[[] for i in range(n)]\n l=set(range(0,n))\n for i in range(m):\n  x,y=list(map(int,input().split()))\n  adj[x-1].append(y-1)\n  adj[y-1].append(x-1)\n it=list(map(int,input().split()))\n vis={}\n cost=[]\n while l!=set():\n  a=l.pop()\n  vis[a]=it[a]\n  dfs(a)\n  cost.append(vis[a])\n cost.sort()\n if len(cost)<k:\n  print(-1)\n  continue\n mi=0\n ma=len(cost)\n su=0\n for i in range(k):\n  if i%2==0:\n   su+=cost[ma-1]\n   ma-=1\n  else:\n   su+=cost[mi]\n   mi+=1\n print(su)\n\n\n\n\n\n  \n \n"]
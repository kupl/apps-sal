["class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        res = []\n        level = 0\n        nodes_count = 0\n        while nodes_count < label:\n            nodes_count += 2**level\n            level += 1\n        while label != 0:\n            res.append(label)\n            level_max = (2**level) - 1\n            level_min = 2**(level-1)\n            label = (level_max + level_min - label) // 2\n            level -= 1\n        return res[::-1]\n\n", "import math\nclass Solution:\n        \n    def pathInZigZagTree(self, label: int) -> List[int]:\n        res=[]\n        level=math.ceil(math.log(label+1,2))\n        res.append(label)\n        if level%2==1:\n            label=label//2\n            level-=1\n            label=abs(pow(2,level)-label)+pow(2,level-1)-1\n            res.append(label)\n        \n        while(label>=1):\n            if level%2==1:\n                level-=1\n                label=label//2\n                res.append(label)\n            else:\n                label=label//2\n                level-=1\n                res.append(abs(pow(2,level)-label)+pow(2,level-1)-1)\n        res.pop()\n        \n        return res[::-1]\n        \n        # return [pow(2,x) for x in range(math.ceil(math.log(label,2)))]\n        # l=[]\n        # for i in range(1,math.ceil(math.log(label,2))):\n        #     if i%2==1:\n        #         l.extend([ temp for temp in range(pow(2,i-1),pow(2,i)) ])\n        #     else:\n        #         l.extend([temp for temp in range(pow(2,i),pow(2,i-1),-1)])\n        # return l\n", "import math\nclass Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        def findIndexorLabel(value):\n            level = int(math.log(value, 2)) + 1\n            if level%2:\n                index = value\n            else:\n                total = 2**(level-1) + (2**level - 1)\n                index = total - value\n            return index\n        arr = []\n        arr.insert(0, label)\n        index = findIndexorLabel(label)\n        parentNode = index//2\n        while parentNode != 0:\n            nodeVal = findIndexorLabel(parentNode)\n            arr.insert(0, nodeVal)\n            index = findIndexorLabel(nodeVal)\n            parentNode = index//2\n        return arr\n        \n                \n", "class Solution:\n    def pathInZigZagTree(self, label: int):\n        out = []\n        while(label >= 1):\n            out.append(label)\n            label = self.swap(label)\n        return out[::-1]\n        \n    def swap(self, x):\n        to = 1\n        while(to <= x):\n            to = to << 1\n        return (to + (to >> 1) -1 - x) // 2\n", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        ans = [label]\n        while label:\n            llen = len(bin(label)[2:])\n            label = ( pow(2, llen) -1 - label + pow(2, llen-1) ) // 2\n            ans.append(label)\n\\t\\t\n        return ans[-2::-1]\n        ", "import numpy as np\n\nclass Solution:\n    def parent(self, label:int) -> int:\n        # find out in which row you are.\n        row = int(np.log2(label))\n        # how many steps to first in that row\n        counter = label - 2**row\n        parent = label - (counter + int(counter / 2) + 1)\n        return parent\n\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        # make it recursive\n        sol = []\n        while True:\n            sol.append(label)\n            print(sol)\n            if label > 1:\n                label = Solution.parent(self, label)\n            else:\n                break\n        return sol[::-1]", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        n=label\n        change=False\n        stack=[]\n        index=-1\n        while(n>0):\n            stack.append(n)\n            n=int(n/2)\n            index+=1\n        check=False\n        output=[]\n        while(stack):\n            p=stack.pop(0)\n            if not check:\n                output.append(p)\n            else:\n                start=pow(2,index)\n                end=pow(2,index+1)-1\n                while(start<=end):\n                    if p==start:\n                        output.append(end)\n                        break\n                    elif p==end:\n                        output.append(start)\n                        break\n                    start+=1\n                    end-=1\n            check=not check\n            index-=1\n        return output[::-1]\n", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        # 1. Generate non-zig path\n        path = [label]\n        while label != 1:\n            label = label // 2\n            path.append(label)\n        print(path)\n        path.reverse()\n        \n        odd = len(path) % 2 != 0\n        # 2. Account for zig-zag\n        for i in range(1, len(path)-1):\n            if not odd and i % 2 == 0:\n                print(\\\"Here\\\")\n                level = [i for i in range(2**(i+1)-1, 2**i-1,-1)]\n                index = path[i] - 2**i\n                path[i] = level[index]\n            elif odd and i % 2 != 0:\n                level = [i for i in range(2**(i+1)-1, 2**i-1,-1)]\n                index = path[i] - 2**i\n                path[i] = level[index]\n        \n        return path\n            ", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        ans = [label]\n        i = math.floor(math.log(label,2))\n        while i >= 1:\n            length = pow(2,i+1) - pow(2,i)\n            if i % 2 == 0: \n                prev = [j for j in range(int(pow(2,i)-1),int(pow(2,i-1)-1),-1)]\n                idx = int((label%length)/2)\n            \n            else:\n                prev = [j for j in range(int(pow(2,i-1)),int(pow(2,i)))]\n                idx = int((length -1 - (label % length))/2)\n                \n            label = prev[idx]\n            ans.append(label)\n            i = math.floor(math.log(label,2))\n        return ans[::-1]\n", "import numpy as np\nclass Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        def findCounterpart(num: int) -> int:\n            pow_flr = int(np.floor(np.log2(num)))\n            layer = list(range(2 ** pow_flr, 2 ** (pow_flr + 1)))\n            return layer[-layer.index(num)-1]\n        res = [label]\n        now = label\n        while now != 1:\n            now = findCounterpart(now // 2)\n            res.insert(0, now)\n        return res", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        h = 1\n        symmetry = [2]\n        while 2**h - 1 < label//2:\n            symmetry.append(symmetry[-1]*2 + 1)\n            h += 1\n        path = [label]\n        while label > 1:\n            parent = label >> 1\n            label = symmetry[-1] - parent\n            path.append(label)\n            symmetry.pop()\n        return reversed(path)\n", "import math\n\nclass Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        current = label\n        res = [current]\n        \n        while current != 1:\n            current //= 2\n            depth = int(math.log2(current))\n            \n            nodes = [i for i in range(2**depth, 2**(depth+1))]\n            \n            idx = nodes.index(current)\n            current = list(reversed(nodes))[idx]\n            res.append(current)\n            \n        return reversed(res)\n            \n            \n            \n            \n            \n            \n", "import math\n\nclass Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        req_length = math.ceil(math.log(label+1, 2))\n        curr_depth = req_length\n        next_depth = curr_depth-1\n        res = []\n        \n        while len(res) != req_length-1:\n            \n            res.insert(0, label)\n            \n            curr_numbers = list(range(2**(curr_depth-1), 2**curr_depth))\n            next_numbers = list(range(2**(next_depth-1), 2**next_depth))\n                                \n            if curr_depth%2 == 0:\n                curr_numbers.reverse()\n            \n            if next_depth%2 == 0:\n                next_numbers.reverse()\n            \n            # print(curr_numbers, next_numbers)\n            \n            label = next_numbers[curr_numbers.index(label)//2]\n            curr_depth -= 1\n            next_depth -= 1\n        res.insert(0, 1)\n        return res  \n", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        ans = [label]\n        i = int(math.log(label,2))\n        while i >= 1:\n            length = pow(2,i+1) - pow(2,i)\n            if i % 2 == 0: \n                prev = [j for j in range(int(pow(2,i)-1),int(pow(2,i-1)-1),-1)]\n                idx = int((label%length)/2)\n            \n            else:\n                prev = [j for j in range(int(pow(2,i-1)),int(pow(2,i)))]\n                idx = int((length -1 - (label % length))/2)\n                \n            label = prev[idx]\n            ans.append(label)\n            i = int(math.log(label,2))\n        ans.sort()\n        return ans\n", "import math\n\nclass Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        ret = [label]\n        \n        while label != 1:\n            level = math.floor(math.log2(label))\n            \n            max_at_level = 2**(level+1) - 1\n            \n            label = ((max_at_level - label) // 2) + 2**(level - 1)\n            ret.append(label)\n            \n        return reversed(ret)", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        i=label\n        lst=[]\n        while(i>=1):\n            lst.append(i)\n            i=i//2\n        n=len(lst)\n        lst=lst[::-1]\n        print(lst)\n        for i in range(n):\n            if n%2==1:\n                if i%2==1:\n                    lst[i]=(2**i)+(2**(i+1))-1-lst[i]\n            else:\n                if i%2==0:\n                    lst[i]=(2**i)+(2**(i+1))-1-lst[i]\n        return lst\n", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        x=bin(label)[2:]\n        n = len(x)\n        #invert path\n        y=\\\"1\\\"\n        for i in range(1, n): y += \\\"0\\\" if x[i] == \\\"1\\\" else \\\"1\\\"\n        #Follow path in odd even fashion\n        out = []\n        for i in range(n):\n            if n%2 == 0:\n                if i % 2 == 1: out.append(int(x[:i+1], 2))\n                else: out.append(int(y[:i+1], 2))\n            else:\n                if i % 2 == 0: out.append(int(x[:i+1], 2))\n                else: out.append(int(y[:i+1], 2))\n        return out", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        if label==1:\n            return [1]\n        #else:\n        ans = []\n        for i in range(50):\n            if (2**i<=label)and(2**(i+1)-1>=label):\n                break\n            #print(i)\n        if i % 2 ==1:\n            label = 2**i + 2**(i+1) -1 - label\n        #print(label)\n        x=label\n        for j in range(i,-1,-1):\n            if j % 2 ==1:\n                ans.append(2**j + 2**(j+1) -1 - x)\n            else:\n                ans.append(x)\n            x = x // 2\n            \n            \n        return ans[::-1] \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        from math import floor, log\n        def pos2num(row, pos):\n            if row %2 == 0:\n                return 2**row + pos\n            else:\n                return 2**(row+1) - pos - 1\n        targetrow = floor(log(label)/log(2))\n        if targetrow %2 == 0:\n            targetpos = label - 2**targetrow\n        else:\n            targetpos = 2**(targetrow+1) - label -1\n        row = 0\n        out = []\n        offset = 0\n        posoffset = 0\n        while row <= targetrow:\n            out.append(pos2num(row, posoffset))\n            posoffset *=2\n            if targetpos < offset + 2**(targetrow - row - 1):\n                #go left\n                pass\n            else:\n                #go right\n                offset += 2**(targetrow - row - 1)\n                posoffset +=1\n            #out.append(pos2num(row, offset))\n            row +=1\n        return out\n", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        x=bin(label)[2:]\n        n = len(x)\n        out = []\n        y=\\\"1\\\"\n        for i in range(1,n):\n            y+=\\\"0\\\" if x[i]==\\\"1\\\" else \\\"1\\\"\n        for i in range(n):\n            if n%2==0:\n                if i%2==1: out.append(int(x[:i+1],2))\n                else: out.append(int(y[:i+1],2))\n            else:\n                if i%2==0: out.append(int(x[:i+1],2))\n                else: out.append(int(y[:i+1],2))\n        return out", "class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        level = int(math.log2(label))\n        res, count = [], 0\n        while label > 0:\n            res.append(label if count % 2 == 0 else (3 * 2 ** level - 1 - label))\n            label >>= 1\n            level -= 1\n            count += 1\n            \n        return res[::-1]"]
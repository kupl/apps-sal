["class Solution:\n     # def canTransform(self, start, end):\n     #     \"\"\"\n     #     :type start: str\n     #     :type end: str\n     #     :rtype: bool\n     #     \"\"\"\n \n     def canTransform(self, start, end):\n         # For (i, x) and (j, y) in enumerate(start), enumerate(end)\n         # where x != 'X' and y != 'X',\n         # and where if one exhausts early, it's elements are (None, None),...\n         for (i, x), (j, y) in itertools.zip_longest(\n                 ((i, x) for i, x in enumerate(start) if x != 'X'),\n                 ((j, y) for j, y in enumerate(end) if y != 'X'),\n                 fillvalue = (None, None)):\n \n             # If not solid or accessible, return False\n             if x != y or (x == 'L' and i < j) or (x == 'R' and i > j):\n                 return False\n \n         return True\n         \n         \n         # tmps = start.replace(\"X\",\"\")\n         # tmpe = end.replace(\"X\",\"\")\n         # if tmps != tmpe:\n         #     return False\n         # sa, ta = [], []\n         # i = 0\n         # while (i < len(start)):\n         #     if start[i] == \"L\":\n         #         sa.append(i)\n         #     elif start[i] == \"R\":\n         #         sa.append(-i)\n         #     if end[i] == \"L\":\n         #         ta.append(i)\n         #     elif end[i] == \"R\":\n         #         ta.append(-i)\n         #     i += 1\n         # i = 0\n         # while(i < len(sa)):\n         #     if sa[i]<ta[i]:\n         #         return False\n         #     i += 1\n         # return True\n", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         if len(start)!=len(end) or start.replace('X','')!=end.replace('X',''):\n             return False\n         l,ll,r,rr=0,0,0,0\n         for i in range(len(start)):\n             if start[i]=='L':\n                 l+=1\n             elif start[i]=='R':\n                 r+=1\n             if end[i]=='L':\n                 ll+=1\n             elif end[i]=='R':\n                 rr+=1\n             if l>ll or r<rr:\n                 return False\n         return True", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         start_pair = [(i, c) for i, c in enumerate(start) if c != 'X']\n         end_pair = [(i, c) for i, c in enumerate(end) if c != 'X']\n         if len(start_pair) != len(end_pair):\n             return False\n         for (i_start, c_start), (i_end, c_end) in zip(start_pair, end_pair):\n             if c_start != c_end or (c_start == 'L' and i_start < i_end) or (c_start == 'R' and i_start > i_end):\n                 return False\n         return True", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         previous = {\n             'L': 'X',\n             'X': 'R'\n         }\n         if len(start) != len(end):\n             return False\n         start = list(start)\n         for i in range(len(start)):\n             if start[i] == end[i]:\n                 continue\n             elif end[i] == 'R':\n                 return False\n             else:\n                 cur = end[i]\n                 if i == len(end) - 1:\n                     return False\n                 for j in range(i + 1, len(end)):\n                     if start[j] == cur:\n                         p = j\n                         while p > i:\n                             if start[p - 1] == previous[cur]:\n                                 p -= 1\n                             else:\n                                 return False\n                         start[j] = start[p]\n                         start[p] = cur\n                         break\n         return True", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         if len(start) != len(end):\n             return False\n         r, l = 0, 0\n         for i in range(len(start)):\n             if start[i] == 'R':\n                 r += 1\n             if end[i] == 'R':\n                 r -= 1\n             if start[i] == 'L':\n                 l -= 1\n             if end[i] == 'L':\n                 l += 1\n             if (r > 0 and l != 0) or r < 0:\n                 return False\n             if (l > 0 and r != 0) or l < 0:\n                 return False\n         return l == 0 and r == 0\n", "class Solution:\n     def findNextChar(self, string, i, char):\n         otherChar = \"R\" if char == \"L\" else \"L\"\n         for i in range(i, len(string)):\n             if string[i] == otherChar:  \n                 return None\n             if string[i] == char:\n                 return i\n         return None\n             \n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         end_i = 0\n         for i in range(len(start)):\n             if start[i] != \"X\":\n                 end_i = self.findNextChar(end, end_i, start[i])\n                 if end_i == None or (start[i] == \"L\" and end_i > i) or (start[i] == \"R\" and end_i < i):\n                     return False\n                 end_i += 1\n         for end_i in range(end_i, len(end)):\n             if end[end_i] != \"X\":\n                 return False\n             \n         return True\n", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         s = [(c, i) for i, c in enumerate(start) if c == 'L' or c == 'R']\n         e = [(c, i) for i, c in enumerate(end) if c == 'L' or c == 'R']\n         return len(s) == len(e) and all(c1 == c2 and ((i1 >= i2 and c1 == 'L') or (i1 <= i2 and c1 == 'R')) for (c1, i1), (c2, i2) in zip(s, e))\n", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\n             return False\n         \n         t = 0\n         for i in range(len(start)):\n             if start[i] == \"L\":\n                 while end[t] != \"L\":\n                     t += 1\n                 if i < t:\n                     return False\n                 t += 1\n         \n         t = 0\n         for i in range(len(start)):\n             if start[i] == \"R\":\n                 while end[t] != \"R\":\n                     t += 1\n                 if i > t:\n                     return False\n                 t += 1\n         \n         return True", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         start_helper = []\n         for i in range(len(start)):\n             if start[i] == 'L' or start[i] == 'R':\n                 start_helper.append((start[i], i))\n         end_helper = []\n         for i in range(len(end)):\n             if end[i] == 'L' or end[i] == 'R':\n                 end_helper.append((end[i], i))\n                 \n         if len(start_helper) != len(end_helper):\n             return False\n         for i in range(len(start_helper)):\n             if start_helper[i][0] != end_helper[i][0]:\n                 return False\n             elif start_helper[i][0] == 'L' and start_helper[i][1] < end_helper[i][1]:\n                 return False\n             elif start_helper[i][0] == 'R' and start_helper[i][1] > end_helper[i][1]:\n                 return False\n         return True\n", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         n = len(start)\n         i = 0\n         j = 0\n         while i < n and j < n:\n             while i < n and start[i] == 'X':\n                 i += 1\n             while j < n and end[j] == 'X':\n                 j += 1\n             if i == n and j == n:\n                 return True\n             if i == n or j == n:\n                 return False\n             if start[i] != end[j]:\n                 return False\n             if start[i] == 'L' and i < j:\n                 return False\n             if start[i] == 'R' and i > j:\n                 return False\n             i += 1\n             j += 1\n         return True\n", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         tmps = start.replace(\"X\",\"\")\n         tmpe = end.replace(\"X\",\"\")\n         if tmps != tmpe:\n             return False\n         sa, ta = [], []\n         i = 0\n         while (i < len(start)):\n             if start[i] == \"L\":\n                 sa.append(i)\n             elif start[i] == \"R\":\n                 sa.append(-i)\n             if end[i] == \"L\":\n                 ta.append(i)\n             elif end[i] == \"R\":\n                 ta.append(-i)\n             i += 1\n         i = 0\n         while(i < len(sa)):\n             if sa[i]<ta[i]:\n                 return False\n             i += 1\n         return True", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         if start.replace(\"X\", \"\") != end.replace(\"X\", \"\"):\n           return False\n         import operator\n         \n         for char, op in (('L', operator.gt), ('R', operator.lt)):\n           j = 0\n           for i, c in enumerate(start):\n             if c == char:\n               while j < len(end):\n                 if end[j] == char and op(j, i):\n                   return False\n                 elif end[j] == char:\n                   j += 1\n                   break\n                 j += 1\n \n         return True\n                 \n         \n", "class Solution:\n     def canTransform(self, start, end):\n         \"\"\"\n         :type start: str\n         :type end: str\n         :rtype: bool\n         \"\"\"\n         def countX(s, char='R'):\n             if char == 'L':\n                 s = s[::-1]\n             countX = 0   \n             ans = []\n             for c in s:\n                 if c == char:\n                     ans.append(countX)\n                 elif c == 'X':\n                     countX += 1\n             return ans\n \n         startLR = \"\".join(c for c in start if c != 'X')\n         endLR   = \"\".join(c for c in end   if c != 'X')\n         startR, startL = countX(start, 'R'), countX(start, 'L')\n         endR, endL     = countX(end, 'R'), countX(end, 'L')\n         \n         return (startLR == endLR) and \\\n                all([startR[i] <= endR[i] for i in range(len(startR))]) and \\\n                all([startL[i] <= endL[i] for i in range(len(startL))])\n \n"]
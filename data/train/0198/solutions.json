["class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        dist = [ abs( ord(s[i]) - ord(t[i]) )  for i in range(len(s))]\n        \n#         i = 0\n#         cur = 0\n#         res = 0\n#         for j in range(len(s)):\n#             cur += dist[j]\n#             while cur>maxCost:\n#                 cur -= dist[i]\n#                 i += 1\n#             res = max(res, j-i+1)\n        \n#         return res\n\n        i = 0\n        cost = maxCost\n        for j in range(len(s)):\n            cost -= dist[j]\n            if cost < 0:\n                cost += dist[i]\n                i += 1\n                \n        return j-i+1\n        \n        \n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \n\n        i=0\n        ans=0\n        \n        curr = 0\n        for j in range(0,len(s)):\n            curr = curr + abs(ord(s[j])-ord(t[j]))\n            if curr<=maxCost:\n                ans = max(ans , j-i+1)\n            else:\n                curr = curr - abs(ord(s[i])-ord(t[i]))      \n                i=i+1\n               \n            \n            \n        print()\n        return ans", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        #I could first create an array with the cost of each character change\n\n        currCost = 0\n        maxLength = 0\n        start = 0\n        curr = 0\n        costs = [abs(ord(s[i])- ord(t[i])) for i in range(len(s))]\n        print(costs)\n        while curr < len(costs):\n            currCost += costs[curr]\n            while currCost > maxCost:\n                currCost = currCost - costs[start]\n                start+=1\n            if curr - start + 1 > maxLength:\n                maxLength = curr - start + 1\n            # print(f\\\"currCost: {currCost}, start: {start}, curr: {curr}\\\")\n            curr +=1\n        return maxLength\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        if not s: return 0\n        costs = [abs(ord(si)-ord(ti)) for si, ti in zip(s, t)]\n        ans = 0\n        l, r = 0, 0\n        cur_cost = 0\n        print(costs)\n        while l < len(s) and r < len(s):\n            while r < len(s) and cur_cost <= maxCost:\n                cur_cost += costs[r]\n                r += 1\n            ans = max(ans, r-l-1)\n            \n            while l < r and cur_cost > maxCost:\n                cur_cost -= costs[l]\n                l += 1\n        ans = max(ans, r-l)\n        return ans\n        \n", "class Solution:\n    def equalSubstring(self, string: str, target: str, maxCost: int) -> int:\n        cost = [0]*len(string)\n        for i in range(len(string)) :\n            if string[i] != target[i] : cost[i] += abs(ord(string[i]) - ord(target[i]))\n            if i > 0 : cost[i]+= cost[i-1]\n        answer = 0\n        s=0\n        for i in range(len(string)) :\n            if cost[i] <= maxCost : answer = max(answer,i+1)\n            else :\n                while s<=i and cost[i]-cost[s]> maxCost: s+=1\n                answer = max(answer,i-s)\n                   \n        return answer\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        cost = [abs(ord(s[i])-ord(t[i])) for i in range(len(s))]\n        prefix = [0] # prefix[i] gives us cost[0] + ... + cost[i-1]\n        for i in range(len(cost)):\n            prefix.append(prefix[-1]+cost[i])\n        maxLen = 0\n        i,j = 0,0\n        # print(prefix)\n        while j < len(cost):\n            while j < len(cost) and prefix[j+1]-prefix[i] <= maxCost:\n                j += 1\n            maxLen = max(maxLen,j-i)\n            i += 1\n            # j = i\n            if i > j:\n                j = i\n        return maxLen", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \n        start = 0\n        ans = 0\n        cur = 0\n        for end in range(len(s)):  \n            val = abs(ord(s[end]) - ord(t[end]))\n            cur += val\n            if cur <= maxCost:\n                ans = max(ans, end-start+1)\n            else:\n                while cur > maxCost:\n                    cur -= abs(ord(s[start]) - ord(t[start]))\n                    start += 1\n                \n        return ans", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n      \n      res = 0\n      c = [0]*(len(s)+1)\n      j = 0\n      for i in range(1, len(s)+1):\n        c[i] += c[i-1]+abs(ord(s[i-1])-ord(t[i-1]))\n        \n        while c[i]>maxCost:\n          c[i] -= abs(ord(s[j])-ord(t[j]))\n          j += 1\n        res = max(res, i-j)\n      return res\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        max_length = 0\n        start = 0\n        end = 0\n        cost = 0\n        while end < len(s):\n            c = abs(ord(s[end]) - ord(t[end]))\n            if cost + c <= maxCost:\n                cost += c\n                end += 1\n            else:\n                cost -= abs(ord(s[start]) - ord(t[start]))\n                start += 1\n            max_length = max(max_length, end - start) \n        return max_length \n", "class Solution:\n    def equalSubstring(self, s, t, maxCost):\n        n = len(s)\n        right = 0\n        nowSum = 0\n        res = 0\n        for left in range(n):\n            while right <= n - 1 and nowSum + abs(ord(s[right]) - ord(t[right])) <= maxCost: \n                nowSum += abs(ord(s[right]) - ord(t[right]))\n                right += 1\n            res = max(res, right - left)\n            nowSum -= abs(ord(s[left]) - ord(t[left]))\n        return res          ", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        cost_array = [abs(a - b) for a, b in zip(map(ord, s), map(ord, t))]\n        left = right = t = 0\n        mx = 0\n        while right < len(cost_array):\n            t += cost_array[right]\n            if t > maxCost:\n                while left < len(cost_array) and t > maxCost:\n                    t -= cost_array[left]\n                    left += 1\n\n            right += 1\n            mx = max(mx, right - left)\n\n        return mx", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        i = 0\n        for j in range(len(s)):\n            maxCost -= abs(ord(s[j]) - ord(t[j]))\n            if maxCost < 0:\n                maxCost += abs(ord(s[i]) - ord(t[i]))\n                i += 1\n        return j - i + 1\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        cost_array = [abs(a - b) for a, b in zip(list(map(ord, s)), list(map(ord, t)))]\n        \n        left = right = t = mx = 0\n        \n        while right < len(cost_array):\n        \n            t += cost_array[right]\n            if t > maxCost:\n                t -= cost_array[left]\n                left += 1\n\n            right += 1\n            mx = max(mx, right - left)\n\n        return mx\n\n", "import numpy as np\n\nclass Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        #Ss = [ord(c) for c in s]\n        #Tt = [ord(d) for d in t]\n        #diff = np.abs(np.array(Ss)-np.array(Tt))\n        #n = len(s)\n        i = result = 0\n        for j in range(len(s)):\n            maxCost -= abs(ord(s[j])-ord(t[j]))\n            while(maxCost<0):\n                maxCost += abs(ord(s[i])-ord(t[i]))\n                i+=1\n            result = max(result,j-i+1)\n\n        return result", "import numpy as np\n\nclass Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        #table = np.zeros(len(s))\n        i = result = 0\n        for j in range(len(s)):\n            maxCost -= abs(ord(s[j])-ord(t[j]))\n            while(maxCost<0):\n                maxCost += abs(ord(s[i])-ord(t[i]))\n                i+=1\n            result = max(result,j-i+1)\n            #table[j] = j-i+1\n        return result\n        #return int(max(table))\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        res = curr = i = j = 0\n        while i < len(s) and j < len(s):\n            curr += abs(ord(s[j]) - ord(t[j]))\n            j += 1\n            while curr > maxCost:\n                curr -= abs(ord(s[i]) - ord(t[i]))\n                i += 1\n            res = max(res, j - i)\n        return res", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        currcost=0;i=0;j=0\n        if(len(s)==0):\n            return 0\n        if(len(s)==1):\n            if(abs(ord[s[0]])-ord(t[0])>=maxcost):\n                return 1\n            else:\n                return 0\n        currcost=0\n        ans=0\n        state=False\n        while(i<len(s) and j<len(s)):\n            if(currcost+abs(ord(s[j])-ord(t[j]))<=maxCost):\n                currcost+=abs(ord(s[j])-ord(t[j]))\n                j+=1\n                state=True\n            else:\n                ans=max(ans,j-i)\n                currcost-=abs(ord(s[i])-ord(t[i]))\n                i+=1\n                state=False\n                if(i>=j):\n                    j=i\n                    currcost=0\n        if state:\n            ans=max(ans,j-i)\n        return ans\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        max_substring = 0\n        curr_substring = 0\n        \n        left = right = diff = 0\n        \n        while right < len(s):\n            local_diff = abs(ord(s[right]) - ord(t[right]))\n            if diff + local_diff <= maxCost:\n                diff += local_diff\n                right += 1\n                curr_substring += 1\n                max_substring = max(curr_substring, max_substring)\n            else:\n                if left == right:\n                    right += 1\n                else:\n                    diff -= abs(ord(s[left]) - ord(t[left]))\n                    curr_substring -= 1\n                left += 1\n        \n        return max_substring\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \n        arr = [abs(ord(sc) - ord(tc)) for sc, tc in zip(s, t)]\n        max_len = 0\n        left, right = 0, 0\n        curr_sum = 0\n        max_len = 0\n        while(right < len(arr)):\n            curr_sum += arr[right]\n            while(left < len(arr) and curr_sum > maxCost):\n                curr_sum -= arr[left]\n                left += 1\n            max_len = max(max_len, right - left + 1)\n            right += 1\n        return max_len", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        start = 0\n        cost = 0\n        max_len = 0\n        for end in range(len(s)):\n            cost += abs(ord(s[end]) - ord(t[end]))\n            while cost > maxCost:\n                cost -= abs(ord(s[start]) - ord(t[start]))\n                start += 1\n            max_len = max(max_len,end - start + 1)\n        return max_len\n            \n                \n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        max_len = head = subtotal = 0\n        for tail in range(len(s)):\n            subtotal += abs(ord(s[tail]) - ord(t[tail]))\n            while subtotal > maxCost:\n                subtotal -= abs(ord(s[head]) - ord(t[head]))\n                head += 1\n            max_len = max(max_len, tail - head + 1)\n        return max_len", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        totalCost = 0\n        maxLength = 0\n        \n        costs = []\n        left = 0\n        length = 0\n        for i in range(len(s)):\n            costs.append(abs(ord(s[i]) - ord(t[i])))\n            totalCost += costs[-1]\n            length += 1\n        \n            if totalCost <= maxCost:\n                maxLength = length if length > maxLength else maxLength\n            else:\n                while totalCost > maxCost:\n                    totalCost -= costs[left]\n                    left += 1\n                    length -= 1\n            \n        return maxLength", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        n = len(s)\n        cost = 0\n        left = 0\n        max_len = 0\n        for right in range(n):\n            cost += abs(ord(s[right]) - ord(t[right]))\n            while cost > maxCost:\n                cost -= abs(ord(s[left]) - ord(t[left]))\n                left += 1\n            max_len = max(max_len, right - left + 1)\n        return max_len", "import numpy as np\n\nclass Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        Ss = [ord(c) for c in s]\n        Tt = [ord(d) for d in t]\n        diff = np.abs(np.array(Ss)-np.array(Tt))\n        n = len(diff)\n        i = result = 0\n        for j in range(n):\n            maxCost -= diff[j]\n            if maxCost<0:\n                maxCost += diff[i]\n                i+=1\n            result = max(result,j-i+1)\n\n        return result", "class Solution:\n    def equalSubstring(self, s, t, maxCost):\n        cost = 0\n        ans = 0\n        left, right = 0, -1\n        for s_c, t_c in zip(s, t):\n            right += 1\n            cost += abs(ord(s_c) - ord(t_c))\n            while cost > maxCost:\n                cost -= abs(ord(s[left]) - ord(t[left]))\n                left += 1\n            ans = max(ans, right - left + 1)\n        return ans", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        end = 0\n        result = 0\n\n        allCost = 0\n        for start in range(len(s)):\n            if start >= 1:\n                allCost -= abs(ord(s[start-1]) - ord(t[start-1]))\n\n            while (end +1<len(s)+1) and (allCost+ abs(ord(s[end]) - ord(t[end]))<= maxCost):\n                end += 1\n                allCost += abs(ord(s[end-1]) - ord(t[end-1]))\n\n\n            result = max(result, end-start)\n        return result\n", "import numpy as np\n\nclass Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        Ss = [ord(c) for c in s]\n        Tt = [ord(d) for d in t]\n        diff = np.abs(np.array(Ss)-np.array(Tt))\n        n = len(diff)\n        i = result = 0\n        for j in range(n):\n            maxCost -= diff[j]\n            while(maxCost<0):\n                maxCost += diff[i]\n                i+=1\n            result = max(result,j-i+1)\n\n        return result", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \n        arr = []\n        lim = len(s)\n        for i in range(0,lim):\n            arr.append(abs(ord(s[i])-ord(t[i])))\n            \n        sm = [arr[0]]\n        \n        for j in range(1,lim):\n            sm.append(sm[-1]+arr[j])\n        \n        \n        l = 0\n        h = lim\n        \n        mx = 0\n        while l<=h:\n            m = (l+h)//2\n            ###print(m)\n            t = 0\n            for i in range(0,lim-m):\n                if sm[i+m]-sm[i]+arr[i]<=maxCost:\n                    t = 1\n                    break\n            if t==1:\n                if m+1>mx:mx = m+1\n                l = m+1\n            else:\n                h = m-1\n        return mx", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        start = 0\n        end = 0\n        cost = 0\n        best = 0\n        while end < len(s):\n            while end < len(s) and cost + abs(ord(s[end]) - ord(t[end])) <= maxCost:\n                cost += abs(ord(s[end]) - ord(t[end]))\n                end += 1\n            if start == end:\n                start += 1\n                end += 1\n                continue\n            best = max(best, end - start)\n            cost -= abs(ord(s[start]) - ord(t[start]))\n            start += 1\n        return best", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \n        diff = []\n        for i in range(len(s)):\n            diff.append(abs(ord(s[i])-ord(t[i])))\n        \n        i=0\n        ans=0\n        \n        curr = 0\n        for j in range(0,len(s)):\n            curr = curr + diff[j]\n            if curr<=maxCost:\n                ans = max(ans , j-i+1)\n            else:\n                curr = curr - diff[i]                \n                i=i+1\n        return ans", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        ans = 0\n        cost = 0\n        left,right=0,0\n        while right < len(s):\n            cost += abs(ord(s[right])-ord(t[right]))\n            if cost > maxCost:\n                cost -= abs(ord(s[left])-ord(t[left]))\n                left += 1\n            else:\n                ans = max(ans,right-left+1)\n            right += 1\n        return ans\n            \n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        #I could first create an array with the cost of each character change\n\n        currCost = 0\n        maxLength = 0\n        start = 0\n        curr = 0\n        while curr < len(s):\n            currCost += abs(ord(s[curr])- ord(t[curr]))\n            while currCost > maxCost:\n                currCost = currCost - (abs(ord(s[start])- ord(t[start])))\n                start+=1\n            if curr - start + 1 > maxLength:\n                maxLength = curr - start + 1\n            curr +=1\n        return maxLength\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        maxLength = 0\n        currLength = 0\n        currCost = 0\n        \n        for i in range(len(s)):\n            currLength += 1\n            currCost += abs(ord(s[i]) - ord(t[i]))\n            while currCost > maxCost:\n                currCost -= abs(ord(s[i-(currLength-1)]) - ord(t[i-(currLength-1)]))\n                currLength -= 1\n            maxLength = max(maxLength, currLength)\n        \n        return maxLength\n    \n# Time: O(n)\n# Space: O(1)\n", "class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        res = 0\n        i,j = 0,0\n        while j < len(s):\n            maxCost -= abs(ord(t[j]) - ord(s[j]))\n            while maxCost < 0:\n                maxCost += abs(ord(t[i]) - ord(s[i]))\n                i += 1\n            j += 1\n            res = max(res, j -i)\n        return res"]
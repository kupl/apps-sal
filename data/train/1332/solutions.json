["t=eval(input())\nfor _ in range(t):\n i,j=list(map(int,input().split()))\n bi=bin(i)[2:]\n bj=bin(j)[2:]\n k=0\n while k<(min(len(bi),len(bj))):\n  if bi[k]!=bj[k]:\n   break\n  else:\n   k+=1\n print(len(bi)-k+len(bj)-k)\n \n", "n = int(input())\nfor _ in range(n):\n x, y = list(map(int, input().split()))\n bx = bin(x)[2:]\n by = bin(y)[2:]\n i = 0\n while i < min(len(bx), len(by)) and bx[i] == by[i]:\n  i += 1\n print(len(bx)+len(by) - 2*i)\n", "n = int(input())\nfor t in range(n):\n (a,b) = [int(x) for x in input().split()]\n count = 0\n while(not a == b):\n  if (a>b):\n   a = a/2\n  else:\n   b = b/2\n  count += 1\n print(count)\n", "n = eval(input())\nn = int(n)\ni = 0\nwhile i<n:\n i+=1\n def path(fr, to):\n  if fr < to:\n   fr, to = to, fr\n   \n  if fr == to:\n   return 0\n  \n  elif fr == 1:\n   return path(to, 1)\n  \n  elif fr%2:\n   up = int((fr-1)/2)\n   return 1 + path(up, to)\n  \n  elif not fr%2:\n   up = int(fr/2)\n   return 1 + path(up, to)\n  \n cor = input().split()\n f = int(cor[0])\n t = int(cor[1])\n \n print(path(f,t))\n", "N = int(input())\nfor _ in range(N):\n a, b = list(map(int,input().split(' ')))\n distance = 0\n while a != b:\n  distance += 1\n  a, b = (a, b / 2) if a < b else (a / 2, b)\n print(distance)\n", "#!/usr/bin/python\n\nimport sys\nimport math\n\ncache_parent = {}\n  \ndef find_chain_1(num1, parent_c1): \n while True:\n  if num1 in cache_parent:\n   parent_c1.extend(cache_parent[num1])\n   return parent_c1\n  parent_c1.append(num1)\n  if num1 == 1:\n   return\n  num1 = int(num1/2)\n\ndef find_chain_2(num2, parent_c2): \n while True:\n  if num2 in cache_parent:\n   parent_c2.extend(cache_parent[num2])\n   return parent_c2\n  parent_c2.append(num2)\n  if num2 == 1:\n   return\n  num2 = int(num2/2)\n \ndef getlen(chain_1, chain_2, num1, num2):\n \"\"\"if len(chain_1) > len(chain_2):\n     shorter = chain_2\n     larger = chain_1\n    else:\n     shorter = chain_1\n     larger = chain_2\n    for i in shorter:\n     if i in larger:\n      root = i\n      break\"\"\"\n root = list(set(chain_1) & set(chain_2))\n root.sort()\n root = root[-1]\n #distance = int(math.log(num1, 2) + 1) + int(math.log(num2, 2) + 1)   - 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*int(math.log(root, 2)+1)\n #print root\n distance = chain_1.index(root) + chain_2.index(root)\n return distance\n\nlines = sys.stdin.readlines()\nfor num in lines[1:]:\n num1, num2 = num.strip().split(' ')\n num1 = int(num1)\n num2 = int(num2) \n parent_c1 = [] \n parent_c2 = []\n find_chain_1(num1, parent_c1)\n cache_parent[num1] = parent_c1\n #print parent_c1 \n find_chain_2(num2, parent_c2)\n cache_parent[num2] = parent_c2\n #print parent_c2\n print(getlen(parent_c1, parent_c2, num1, num2))", "t = int(input())\nfor i in range(t):\n i,j= list(map(int,input().split()))\n base1=i\n base2=j\n arr1=[]\n arr2=[]\n while base1>0 :\n  arr1.append(base1)\n  base1=base1/2\n while base2>0 :\n  arr2.append(base2)\n  base2=base2/2\n n1=len(arr1)\n n2=len(arr2)\n n=min(n1,n2)\n dist=-1\n for i in range(n):\n  if arr1[n1-1-i]!=arr2[n2-1-i]:\n   dist=n1+n2-2*i\n   break\n if dist==-1:\n  dist=max(n1,n2) -n\n print(dist)\n\n\n", "import math\nn = int(input())\n\nfor i in range (0, n):\n line = input().split()\n a = int(line[0])\n b = int(line[1])\n loga = int(math.log(a, 2))\n logb = int(math.log(b, 2))\n \n dist = 0\n #print a, b\n if loga > logb:\n  dist += loga - logb\n  a = a >> (loga - logb)\n else:\n  b = b >> (logb - loga)\n  dist += logb - loga\n #print a, b\n \n x = a ^ b\n if x:\n  dist += (int(math.log(x, 2)) + 1) * 2;\n \n print(dist)\n #print \"   \"\n", "N=eval(input())\nwhile N:\n N-=1\n a,b=[int(x) for x in input().split()]\n count=0\n a=bin(a)[2:]\n b=bin(b)[2:]\n j=0\n for i in range(0,min(len(a),len(b))):\n  if a[i]==b[i]:\n   j=i\n   continue\n  else:\n   count+=(len(a)-i)\n   count+=(len(b)-i)\n   break\n if j==min(len(a),len(b))-1:\n  count+=(len(a)+len(b)-2*j-2)\n print(count)\n \n", "N=eval(input())\nwhile N:\n N-=1\n a,b=[int(x) for x in input().split()]\n count=0\n a=bin(a)[2:]\n b=bin(b)[2:]\n j=0\n for i in range(0,min(len(a),len(b))):\n  if a[i]==b[i]:\n   j=i\n   continue\n  else:\n   count+=(len(a)-i)\n   count+=(len(b)-i)\n   break\n if j==min(len(a),len(b))-1:\n  count+=(len(a)+len(b)-2*j-2)\n print(count)\n \n", "import math\nn = int(input())\n\nfor i in range (0, n):\n line = input().split()\n a = int(line[0])\n b = int(line[1])\n loga = int(math.log(a, 2))\n logb = int(math.log(b, 2))\n\n #print a, b, loga, logb\n \n dist = 0\n\n while loga > logb:\n  a = a / 2\n  dist += 1\n  loga -= 1\n\n while loga < logb:\n  b = b / 2\n  dist += 1\n  logb -= 1\n\n while a != b:\n  a = a / 2;\n  b = b / 2;\n  dist += 2;\n\n print(dist)", "N=eval(input())\nwhile N:\n N-=1\n a,b=[int(x) for x in input().split()]\n count=0\n while a!=b:\n  if b<a:\n   a=a/2\n   count+=1\n  elif a<b:\n   b=b/2\n   count+=1\n print(count)\n  \n", "n = int(input())\nfor j in range(n):\n a,b = list(map(int, input().split()))\n d = 0\n while a!=b:\n  if a>b:\n   a/=2\n   d+=1\n  else:\n   b/=2\n   d+=1\n print(d)", "\ndef read_mapped(func=lambda x:x):\n return list(map(func, input().split(\" \")))\ndef read_array(N, func):\n l = []\n for i in range(N):\n  l.append(func(input()))\n return l\ndef read_int():\n return int(input())\ndef read_str():\n return input()\ndef read_float():\n return float(input())\n\nT = read_int()\n\ndef solve(m, n, s):\n if m==n: return s\n\n if m<n:\n  m, n = n, m\n if m%2==0:\n  return solve(m/2, n, s+1)\n else:\n  return solve((m-1)/2, n, s+1)\n\nfor case in range(T):\n i, j = read_mapped(int)\n si = min(i, j)\n sj = max(i, j)\n print(solve(sj, si, 0))\n", "import sys\n \nfor q in range(int(sys.stdin.readline())):\n n1,n2 = list(map(int,sys.stdin.readline().split()))\n count = 0\n while n1!=n2:\n  while n1>n2:\n   n1/=2\n   count+=1\n  while n2>n1:\n   n2/=2\n   count+=1\n print(count)\n", "import math\nimport sys\nimport time\n\n\ndef getLevel(number):\n _level = math.floor(math.log(number,2))\n return int(_level)\n\ndef isPair(number):\n return (number%2 == 0)\n \ndef getInterval(a,b, max):\n _max = max\n _loop = -1\n _apart = 0\n \n while (_apart == 0) and (_max != 1):\n  _loop += 1\n  _max = _max >> 1\n  if (a < _max) and (b >= _max):\n   _apart = 1\n  elif (a >= _max):\n   a = a - _max\n   b = b - _max\n \n return _loop\n\ndef resolve2(nodes):\n \n if nodes[0] == nodes[1]:\n  return 0\n\n l = 0\n k = 0\n \n while (nodes[0] != nodes[1]) :\n  if (nodes[1] < nodes[0]) :\n   if (nodes[0] > 1):\n    nodes[0] = nodes[0]/2 if isPair(nodes[0]) else (nodes[0] -1)/2\n    l += 1\n  else:\n   if (nodes[1] > 1):\n    nodes[1] = nodes[1]/2 if isPair(nodes[1]) else (nodes[1] -1)/2\n    k += 1\n  \n return (l + k)\n \n\ndef __starting_point():\n\n step = 0\n \n for line in sys.stdin:\n  \n  if (step==0):\n   step = 1\n   continue\n  nodes =[int(nums) for nums in line.strip().split()]\n  \n  \n  if nodes[0] == nodes[1]:\n   print(0)\n   continue\n \n  _temp = nodes[0]\n  if nodes[0] < nodes[1] :\n   nodes[0] = nodes[1]\n   nodes[1] = _temp\n  \n  _max_level = getLevel(nodes[0])\n  if (nodes[1] == 1):\n   print(_max_level)\n   continue\n  \n  _min_level = getLevel(nodes[1])\n  substract = _max_level - _min_level\n  \n  \n  if (substract != 0):\n   nodes[0] = nodes[0] >> substract\n  \n  _temp = nodes[0]\n  if nodes[0] < nodes[1] :\n   nodes[0] = nodes[1]\n   nodes[1] = _temp\n  \n  \n  if (nodes[1] == nodes[0]):\n   print( substract)\n   continue\n\n  _max = 2**_min_level\n  \n  apart = getInterval(nodes[1] - _max, nodes[0] - _max,_max)\n  \n  \n  print( 2*(_min_level - apart) + substract)\n  \n  \n  #print( resolve2(nodes) )\n\n__starting_point()", "import math\nimport sys\nimport time\n\n\ndef getLevel(number):\n _level = math.floor(math.log(number,2))\n return int(_level)\n\ndef isPair(number):\n return (number%2 == 0)\n \ndef getInterval(a,b, max):\n _max = max\n _loop = -1\n _apart = 0\n \n while (_apart == 0) and (_max != 1):\n  _loop += 1\n  _max = int(math.floor(_max / 2))\n  if (a < _max) and (b >= _max):\n   _apart = 1\n  elif (a >= _max):\n   a = a - _max\n   b = b - _max\n \n return _loop\n\ndef resolve2(nodes):\n \n if nodes[0] == nodes[1]:\n  return 0\n\n l = 0\n k = 0\n \n while (nodes[0] != nodes[1]) :\n  if (nodes[1] < nodes[0]) :\n   if (nodes[0] > 1):\n    nodes[0] = nodes[0]/2 if isPair(nodes[0]) else (nodes[0] -1)/2\n    l += 1\n  else:\n   if (nodes[1] > 1):\n    nodes[1] = nodes[1]/2 if isPair(nodes[1]) else (nodes[1] -1)/2\n    k += 1\n  \n return (l + k)\n \n\ndef __starting_point():\n\n step = 0\n \n for line in sys.stdin:\n  \n  if (step==0):\n   step = 1\n   continue\n  nodes =[int(nums) for nums in line.strip().split()]\n  \n  if nodes[0] == nodes[1]:\n   print(0)\n   continue\n \n  _temp = nodes[0]\n  if nodes[0] < nodes[1] :\n   nodes[0] = nodes[1]\n   nodes[1] = _temp\n  \n  _max_level = getLevel(nodes[0])\n  if (nodes[1] == 1):\n   print(_max_level)\n   continue\n  \n  _min_level = getLevel(nodes[1])\n  substract = _max_level - _min_level\n  \n  \n  if (substract != 0):\n   nodes[0] = int ( math.floor(nodes[0] /( 2**substract)) )\n  \n  _temp = nodes[0]\n  if nodes[0] < nodes[1] :\n   nodes[0] = nodes[1]\n   nodes[1] = _temp\n  \n  \n  if (nodes[1] == nodes[0]):\n   print( substract)\n   continue\n\n  _max = 2**_min_level\n  \n  apart = getInterval(nodes[1] - _max, nodes[0] - _max,_max)\n  \n  \n  print( 2*(_min_level - apart) + substract)\n  \n  \n  #print( resolve2(nodes) )\n\n__starting_point()"]
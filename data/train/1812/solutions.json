["from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.num_idx_dict = defaultdict(list)\n        for idx, number in enumerate(arr):\n            self.num_idx_dict[number].append(idx)\n        self.candidates = sorted(self.num_idx_dict, key=lambda x: len(self.num_idx_dict[x]), reverse=True)\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for number in self.candidates:\n            if len(self.num_idx_dict[number]) < threshold:\n                return -1\n            left_idx = bisect_left(self.num_idx_dict[number], left)\n            right_idx = bisect_right(self.num_idx_dict[number], right)\n            \n            if right_idx - left_idx >= threshold:\n                return number\n        return -1\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.loc = collections.defaultdict(list)\n        for i, n in enumerate(arr):\n            self.loc[n].append(i)    \n        self.nums = sorted(\n            list(self.loc.keys()), \n            key = lambda n: len(self.loc[n]), \n            reverse=True\n        )\n        print((self.nums))\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        # binary search every number in arr\n        # find number of num in this range [left, right]\n        for n in self.nums:\n            if len(self.loc[n]) < threshold: \n                return -1\n            l, r = bisect.bisect_left(self.loc[n], left), bisect.bisect_right(self.loc[n], right)\n            if r - l >= threshold: \n                return n\n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        \n        self.idx = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            self.idx[a].append(i)\n        \n        tmp = sorted(list(self.idx.items()), key=lambda x: len(x[1]), reverse=True)\n        \n        self.order = [x for x,_ in tmp]\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for k in self.order:\n            if len(self.idx[k]) < threshold:\n                return -1\n            l = bisect.bisect_left(self.idx[k], left)\n            r = bisect.bisect_right(self.idx[k], right)\n            if r-l >= threshold:\n                return k\n        \n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.indices = collections.defaultdict(list)\n        for i, n in enumerate(arr):\n            self.indices[n].append(i)\n        self.nums = sorted(list(self.indices.keys()), key=lambda i: -1*len(self.indices[i]))\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for n in self.nums:\n            if len(self.indices[n]) < threshold: return -1\n            l, r = bisect.bisect_left(self.indices[n], left), bisect.bisect_right(self.indices[n], right)\n            if r - l >= threshold: return n\n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.loc = collections.defaultdict(list)\n        for i, n in enumerate(arr):\n            self.loc[n].append(i)    \n        self.nums = sorted(list(self.loc.keys()), key = lambda n: len(self.loc[n]), reverse=True)\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for n in self.nums:\n            if len(self.loc[n]) < threshold: return -1\n            l, r = bisect.bisect_left(self.loc[n], left), bisect.bisect_right(self.loc[n], right)\n            if r - l >= threshold: return n\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.indices = defaultdict(list)\n        for a in set(arr):\n            self.indices[a].append(-1)\n        for i, a in enumerate(arr):\n            self.indices[a].append(i)\n        self.A = sorted(list(self.indices.keys()), key=lambda x:-len(self.indices[x]))\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        def bs(arr, l, r, target):\n            while l<=r:\n                m = l+(r-l)//2\n                if arr[m]<=target:\n                    l = m+1\n                else:\n                    r = m-1\n            return r\n        \n        for a in self.A:\n            lst = self.indices[a]\n            if len(lst)<threshold: return -1\n            l, r = bs(lst, 0, len(lst)-1, left-1), bs(lst, 0, len(lst)-1, right)\n            if r-l>=threshold:\n                return a\n        \n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.loc = collections.defaultdict(list)\n        for i, n in enumerate(arr):\n            self.loc[n].append(i)    \n        self.nums = sorted(list(self.loc.keys()), key = lambda n: len(self.loc[n]), reverse=True)\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for n in self.nums:\n            if len(self.loc[n]) < threshold: return -1\n            l, r = bisect.bisect_left(self.loc[n], left), bisect.bisect_right(self.loc[n], right)\n            if r - l >= threshold: return n\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.idx = defaultdict(list)\n        counts = dict()\n        for i, v in enumerate(arr):\n            self.idx[v].append(i)\n            counts[v] = len(self.idx[v])\n        self.counts = list(counts.items())\n        self.counts.sort(key=lambda x:x[1], reverse=True)\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for val, count in self.counts:\n            if count < threshold:\n                break\n            indices = self.idx[val]\n            start = find_closest(indices, left, lower=False)\n            end = find_closest(indices, right, lower=True)\n            n_in_range = end - start + 1\n            if n_in_range >= threshold:\n                return val\n        return -1\n    \n    \n    \ndef find_closest(a: List[int], target: int, lower: bool) -> int:\n    low = 0\n    high = len(a) - 1\n    \n    while low <= high:\n        m = (low + high) // 2\n        if a[m] == target:\n            return m\n        if a[m] < target:\n            low = m + 1\n        else:\n            high = m - 1\n        \n    if lower:\n        return high\n    return low\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "    \nfrom math import log2\n\nclass Node:\n    def __init__(self,val,freq):\n        self.val=val\n        self.freq = freq\n        \nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        \n        self.arr = arr\n        self.locations = {}\n        for i,val in enumerate(arr):\n            if val in self.locations:\n                self.locations[val].append(i)\n            else:\n                self.locations[val] = [i]\n        self.occur = sorted(list(self.locations.items()), reverse=True, key=lambda x: len(x[1]))\n    \n        print((self.occur))\n        \n#         self.freq = { i:[] for i in arr }\n        \n#         self.size = 1 << math.ceil(log2(len(arr))) + 1\n        \n#         self.st = [0]*self.size\n        \n#         self.build(0,len(arr)-1,0)\n    \n        \n    \n#     def merge(self,a,b):\n#         if a.val == b.val:\n#             return Node(a.val, a.freq + b.freq)\n#         if a.freq>b.freq:\n#             return Node(a.val, a.freq-b.freq)\n#         return Node(b.val,b.freq-a.freq)\n    \n#     def pqery(self,l,r,pos,s,e):\n#         if s>r or e<l:\n#             return Node(0,0)\n        \n#         if l<=s and r>=e:\n#             return self.st[pos]\n        \n#         mid  = ( s + e )>>1\n        \n#         a=self.pqery(l,r,2*pos + 1,s,mid)\n#         b=self.pqery(l,r,2*pos + 2,mid+1,e)\n#         return self.merge(a,b)\n        \n#     def build(self,start,end,pos):\n        \n#         if start==end:\n#             self.st[pos]=Node(self.arr[start],1)\n#             self.freq[self.arr[start]].append(start)\n        \n#         else:\n            \n#             mid = (end + start)>>1\n\n#             self.build(start,mid,2*pos + 1)\n#             self.build(mid+1,end,2*pos + 2)\n#             self.st[pos] = self.merge(self.st[pos*2 + 1],self.st[2*pos + 2])\n            \n            \n    def lower_bound(self,arr,x):\n        l=0\n        r=len(arr)-1\n        while l<=r:\n            mid = (l+r )>> 1\n            if arr[mid]<x:\n                l=mid+1\n            else:\n                r=mid-1\n        return l\n            \n            \n    def upper_bound(self,arr,x):\n        l=0\n        r=len(arr)-1\n        while l<=r:\n            mid = (l+r) >> 1\n            if arr[mid]<=x:\n                l=mid+1\n            else:\n                r=mid-1\n        return r+1\n            \n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for i,j in self.occur:\n            if len(j)<threshold:\n                return -1\n            s = self.lower_bound(j,left)\n            e = self.upper_bound(j,right)\n            if e-s>=threshold:\n                return i\n            \n        return -1\n#         candidate = self.pqery(left,right,0,0,(len(self.arr)-1))\n#         # print(self.freq,candidate.val)\n#         if candidate.val==0:return -1\n        \n#         s = self.lower_bound(self.freq[candidate.val],left)\n#         e= self.upper_bound(self.freq[candidate.val],right)\n#         # print(e,s)\n#         if (e-s) >=threshold :\n#             return candidate.val\n#         else:\n#             return -1\n\n\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = []\n        hsh = {}\n        from sortedcontainers import SortedList\n        \n        \n        for i in range(len(arr)):\n            if arr[i] not in hsh:\n                hsh[arr[i]] = len(self.arr)\n                self.arr.append([arr[i], SortedList()])\n            self.arr[hsh[arr[i]]][1].add(i)\n            \n        self.arr.sort(key = lambda x: len(x[1]), reverse=True)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for i in self.arr:\n            if len(i[1]) < threshold:\n                return -1\n            \n            l = i[1].bisect_left(left)\n            r = i[1].bisect_right(right)\n            \n            if r - l >= threshold:\n                return i[0]\n            \n        return -1\n\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.el_to_idx = defaultdict(list)\n        \n        for i, val in enumerate(arr):\n            self.el_to_idx[val].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        N = 10\n        for _ in range(N):\n            val = self.arr[random.randint(left, right)]\n            indices = self.el_to_idx[val]\n            lo = bisect_left(indices, left)\n            hi = bisect_right(indices, right)\n\n            if hi - lo >= threshold:\n                return val\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nclass MajorityChecker:\n    def __init__(self, arr):\n        \n        # key   : number\n        # value : list of indices for number\n        self.num_idx_dict = defaultdict( list )\n        \n        # Append index to corresoinding number's dictionary\n        for idx, number in enumerate( arr ):\n            \n            self.num_idx_dict[ number ].append( idx )\n        \n        # With descending order of number of occurrences\n        self.candidates = sorted( self.num_idx_dict, key = lambda x: len(self.num_idx_dict[x]), reverse = True)\n\n        \n    def query(self, left, right, threshold):\n        \n        for number in self.candidates:\n            \n            # Longest occurrences is smaller than threhsold, then no solution\n            if len( self.num_idx_dict[number] ) < threshold:\n                return -1\n            \n            left_idx = bisect_left( self.num_idx_dict[number], left)\n            right_idx = bisect_right( self.num_idx_dict[number], right)\n            \n            if right_idx - left_idx >= threshold:\n                return number\n            \n        return -1\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.idxes = collections.defaultdict(list)\n        for (i, n) in enumerate(arr):\n            self.idxes[n].append(i)\n        self.arr = arr\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(10):\n            n = self.arr[random.randint(left, right)]\n            l = bisect.bisect_left(self.idxes[n], left)\n            r = bisect.bisect_right(self.idxes[n], right)\n            if r - l >= threshold:\n                return n\n        return -1\n    \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\n\nclass MajorityChecker(object):\n\n    def __init__(self, A):\n        B = defaultdict(list)\n        for idx, a in enumerate(A):\n            B[a].append(idx)\n        self.A, self.B = A, B\n\n    def query(self, left, right, threshold):\n        ss = set()\n        for _ in range(10):\n            idx = random.randint(left, right)\n            if idx in ss:\n                continue\n            else: \n                ss.add(idx)\n                a = self.A[idx]\n                l = bisect.bisect_left(self.B[a], left)\n                r = bisect.bisect_right(self.B[a], right)\n                if r - l >= threshold:\n                    return a\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker(object):\n\n    def __init__(self, A):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(A):\n            a2i[x].append(i)\n        self.A, self.a2i = A, a2i\n\n    def query(self, left, right, threshold):\n        ss = set()\n        for _ in range(20):\n            a = self.A[random.randint(left, right)]\n            if a in ss:\n                continue\n            else:\n                ss.add(a)\n                l = bisect.bisect_left(self.a2i[a], left)\n                r = bisect.bisect_right(self.a2i[a], right)\n                if r - l >= threshold:\n                    return a\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.el_to_idx = defaultdict(list)\n        \n        for i, val in enumerate(arr):\n            self.el_to_idx[val].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        N = 15\n        for _ in range(15):\n            val = self.arr[random.randint(left, right)]\n            indices = self.el_to_idx[val]\n            lo = bisect_left(indices, left)\n            hi = bisect_right(indices, right)\n\n            if hi - lo >= threshold:\n                return val\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.x_idxs = x_idxs = defaultdict(list)\n        for i, x in enumerate(arr):\n            x_idxs[x].append(i)\n        self.a = arr\n        self.n = n = len(arr)\n        self.tree = [-1] * (n * 4)\n        self.build_tree(1, 0, n - 1)\n\n    def build_tree(self, v, l, r):\n        a, tree = self.a, self.tree\n        if l == r:\n            tree[v] = a[l]\n            return\n        mid = (l + r) // 2\n        self.build_tree(2 * v, l, mid)\n        self.build_tree(2 * v + 1, mid + 1, r)\n        if tree[2 * v] != -1 and self.count(tree[2 * v], l, r) * 2 > r - l + 1:\n            tree[v] = tree[2 * v]\n        elif tree[2 * v + 1] != -1 and self.count(tree[2 * v + 1], l, r) * 2 > r - l + 1:\n            tree[v] = tree[2 * v + 1]\n\n    def count(self, x, l, r):\n        f = bisect.bisect_right\n        idxs = self.x_idxs[x]\n        return f(idxs, r) - f(idxs, l - 1)\n\n    def query_tree(self, v, l, r, queryl, queryr):\n        tree = self.tree\n        if queryr < l or r < queryl:\n            return -1, -1\n        if queryl <= l and r <= queryr:\n            if tree[v] == -1:\n                return -1, -1\n            x = tree[v]\n            xcount = self.count(x, queryl, queryr)\n            return (x, xcount) if xcount * 2 > queryr - queryl + 1 else (-1, -1)\n        mid = (l + r) // 2\n        res_left = self.query_tree(2 * v, l, mid, queryl, queryr)\n        if res_left[0] > -1:\n            return res_left\n        res_right = self.query_tree(2 * v + 1, mid + 1, r, queryl, queryr)\n        if res_right[0] > -1:\n            return res_right\n        return -1, -1\n\n    def query(self, left, right, threshold):\n        res = self.query_tree(1, 0, self.n - 1, left, right)\n        if res[1] >= threshold:\n            return res[0]\n        return -1\n    \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.loc = collections.defaultdict(list)\n        for i, n in enumerate(arr):\n            self.loc[n].append(i)    \n        self.nums = sorted(list(self.loc.keys()), key = lambda n: len(self.loc[n]), reverse=True)\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for n in self.nums:\n            if len(self.loc[n]) < threshold: return -1\n            l, r = bisect.bisect_left(self.loc[n], left), bisect.bisect_right(self.loc[n], right)\n            if r - l >= threshold: return n\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        a2i = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            a2i[a].append(i)\n        \n        self.a2i = a2i\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for _ in range(15):\n            a = self.arr[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.pos = collections.defaultdict(list) \n        for k, v in enumerate(arr):\n            self.pos[v].append(k)\n        self.runtime = 20\n        self.a = arr\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n    \n        for i in range(self.runtime):\n           # //calculate the frequence of a randomly picked value in the given range\n            val = self.a[random.randint(left, right)]\n            ll = bisect.bisect_left(self.pos[val], left)\n            rr = bisect.bisect_right(self.pos[val], right)\n            if (rr-ll) >= threshold:\n                return val\n        return -1\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker(object):\n\n    def __init__(self, A):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(A):\n            a2i[x].append(i)\n        self.A, self.a2i = A, a2i\n\n    def query(self, left, right, threshold):\n        for _ in range(20):\n            a = self.A[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.x_idxs = x_idxs = defaultdict(list)\n        for i, x in enumerate(arr):\n            x_idxs[x].append(i)\n        self.xs = sorted(list(x_idxs.keys()), key=lambda x: -len(x_idxs[x]))\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for x in self.xs:\n            idxs = self.x_idxs[x]\n            if len(idxs) < threshold:\n                break\n            r = bisect.bisect_right(idxs, right)\n            l = bisect.bisect_right(idxs, left - 1)\n            if r - l >= threshold:\n                return x\n        return -1\n    \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        a2i = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            a2i[a].append(i)\n        \n        self.a2i = a2i\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for _ in range(16):\n            a = self.arr[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.A = arr\n        self.itemIdx = collections.defaultdict(list)\n        for i, x in enumerate(self.A):\n            self.itemIdx[x].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            x = self.A[random.randint(left, right)]\n            l = bisect.bisect_left(self.itemIdx[x], left)\n            r = bisect.bisect_right(self.itemIdx[x], right)\n            if r-l >= threshold:\n                return x\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.N = len(arr)\n        self.max_len = 1 << ceil(log2(self.N))+1\n        self.seg = [None]*self.max_len\n        self.build(1, 0, self.N-1, arr)\n        self.indices = defaultdict(list)\n        for i, a in enumerate(arr):\n            self.indices[a].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        def bs(arr, l, r, target):\n            while l<=r:\n                m = l+(r-l)//2\n                if arr[m]<=target:\n                    l = m+1\n                else:\n                    r = m-1\n            return r\n        \n        major = self.seg_query(1, 0, self.N-1, left, right)[0]\n        lst = self.indices[major]\n        l, r = bs(lst, 0, len(lst)-1, left-1), bs(lst, 0, len(lst)-1, right)\n        if r-l>=threshold:\n            return major\n        return -1\n        \n    def build(self, idx, s, e, arr):\n        if s==e:\n            self.seg[idx] = [arr[s], 1]\n            return\n        \n        m = s+(e-s)//2\n        self.build(2*idx, s, m, arr)\n        self.build(2*idx+1, m+1, e, arr)\n        self.seg[idx] = self.merge(self.seg[2*idx], self.seg[2*idx+1])\n        \n    def seg_query(self, idx, s, e, l, r):\n        if s>=l and e<=r:\n            return self.seg[idx]\n        if s>r or e<l:\n            return [0, 0]\n        m = s+(e-s)//2\n        return self.merge(self.seg_query(2*idx, s, m, l, r), self.seg_query(2*idx+1, m+1, e, l, r))\n    \n    def merge(self, A, B):\n        lv, lf = A\n        rv, rf = B\n        if lv==rv:\n            return [lv, lf+rf]\n        else:\n            if lf>rf:\n                return [lv, lf-rf]\n            else:\n                return [rv, rf-lf]\n            \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n    import bisect\n    import random\n    def __init__(self, arr: List[int]):\n        self.pos = collections.defaultdict(list)\n        for k, v in enumerate(arr):\n            self.pos[v].append(k)\n        self.runtime = 20\n        self.a = arr\n            \n            \n        \n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for i in range(self.runtime):\n            val = self.a[random.randint(left, right)]\n            ll = bisect.bisect_left(self.pos[val], left)\n            rr = bisect.bisect_right(self.pos[val], right)\n            if (rr-ll) >= threshold:\n                return val\n        return -1\n                \n            \n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.N = len(arr)\n        self.max_len = 1 << ceil(log2(self.N))+1\n        self.seg = [None]*self.max_len\n        self.seg_build(1, 0, self.N-1, arr)\n        self.indices = defaultdict(list)\n        for i, a in enumerate(arr):\n            self.indices[a].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        def bs(arr, l, r, target):\n            while l<=r:\n                m = l+(r-l)//2\n                if arr[m]<=target:\n                    l = m+1\n                else:\n                    r = m-1\n            return r\n        \n        major = self.seg_query(1, 0, self.N-1, left, right)[0]\n        lst = self.indices[major]\n        l, r = bs(lst, 0, len(lst)-1, left-1), bs(lst, 0, len(lst)-1, right)\n        if r-l>=threshold:\n            return major\n        return -1\n    \n    def seg_build(self, idx, s, e, arr):\n        if s==e:\n            self.seg[idx] = [arr[s], 1]\n            return\n        \n        mid = s+(e-s)//2\n        self.seg_build(2*idx, s, mid, arr)\n        self.seg_build(2*idx+1, mid+1, e, arr)\n        self.seg[idx] = self.merge(self.seg[2*idx], self.seg[2*idx+1])\n        \n    def seg_query(self, idx, s, e, l, r):\n        if s>=l and e<=r:\n            return self.seg[idx]\n        \n        if s>r or e<l:\n            return [0, 0]\n        \n        mid = s+(e-s)//2\n        return self.merge(self.seg_query(2*idx, s, mid, l, r), self.seg_query(2*idx+1, mid+1, e, l, r))\n    \n    def merge(self, A, B):\n        lv, lf = A\n        rv, rf = B\n        if lv==rv:\n            return [lv, lf+rf]\n        else:\n            if lf>rf:\n                return [lv, lf-rf]\n            else:\n                return [rv, rf-lf]\n    \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        a2i = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            a2i[a].append(i)\n        \n        self.a2i = a2i\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for _ in range(20):\n            a = self.arr[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker(object):\n\n    def __init__(self, A):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(A):\n            a2i[x].append(i)\n        self.A, self.a2i = A, a2i\n\n    def query(self, left, right, threshold):\n        for _ in range(20):\n            a = self.A[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        d = collections.defaultdict(list)\n        for j, x in enumerate(arr):\n            d[x].append(j)\n        self.arr, self.d = arr, d\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            a = self.arr[random.randint(left, right)]\n            l = bisect.bisect_left(self.d[a], left)\n            r = bisect.bisect_right(self.d[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.memo = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            self.memo[x].append(i)\n        self.arr = arr\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):    \n            r = self.arr[random.randint(left, right)]\n            lo = bisect.bisect_left(self.memo[r], left)\n            hi = bisect.bisect_right(self.memo[r], right)\n            if hi - lo >= threshold:\n                return r\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\nimport bisect\nclass MajorityChecker:\n    #Use a dictionary to store the index of each element in arr and sort the dictionary by the frequence of each value in arr\n    #Use bisection search to fix the insertion position of left and right, and compare right-left to the threshold \n\n    def __init__(self, arr: List[int]):\n        self.d = defaultdict(list)\n        for i, value in enumerate(arr):\n            self.d[value].append(i)\n            \n        self.d = sorted(list(self.d.items()), key = lambda x: -len(x[1]))\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for num, idxs in self.d:\n            if len(idxs) >= threshold:\n                low = bisect.bisect_left(idxs, left)\n                high = bisect.bisect_right(idxs, right)\n                if (high - low) >= threshold:\n                    return num\n            else: break\n        return -1\n        \n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker(object):\n\n    def __init__(self, A):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(A):\n            a2i[x].append(i)\n        self.A, self.a2i = A, a2i\n\n    def query(self, left, right, threshold):\n        ss = set()\n        for _ in range(30):\n            a = self.A[random.randint(left, right)]\n            if a in ss:\n                continue\n            else:\n                ss.add(a)\n                l = bisect.bisect_left(self.a2i[a], left)\n                r = bisect.bisect_right(self.a2i[a], right)\n                if r - l >= threshold:\n                    return a\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\n\nclass MajorityChecker(object):\n\n    def __init__(self, A):\n        B = defaultdict(list)\n        for idx, a in enumerate(A):\n            B[a].append(idx)\n        self.A, self.B = A, B\n\n    def query(self, left, right, threshold):\n        ss = set()\n        for _ in range(20):\n            idx = random.randint(left, right)\n            if idx in ss:\n                continue\n            else: \n                ss.add(idx)\n                a = self.A[idx]\n                l = bisect.bisect_left(self.B[a], left)\n                r = bisect.bisect_right(self.B[a], right)\n                if r - l >= threshold:\n                    return a\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class Node:\n    def __init__(self,left,right):\n        self.i = left\n        self.j = right\n        self.left = None\n        self.right = None\n        self.Maj = None\n        self.Maj_f = 0\n        \nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        def DFS(i,j):\n            node = Node(i,j)\n            if i == j :\n                node.Maj = arr[i]\n                node.Maj_f = 1\n            else:\n                m = (i+j)//2\n                node.left,a,b = DFS(i,m)\n                node.right,c,d = DFS(m+1,j)\n                if a == c:\n                    node.Maj = a \n                    node.Maj_f = b+d\n                elif b > d:\n                    node.Maj = a \n                    node.Maj_f = b-d\n                else:\n                    node.Maj = c\n                    node.Maj_f = d-b\n            return node,node.Maj,node.Maj_f \n        \n        self.root = DFS(0,len(arr)-1)[0]\n        self.index = defaultdict(list)\n        for i,num in enumerate(arr):\n            self.index[num].append(i)\n    \n    def DFS(self,node,l,r):\n        if node.i == l and node.j == r:\n            return node.Maj,node.Maj_f\n        m = (node.i+node.j)//2\n        if l > m :\n            return self.DFS(node.right,l,r)\n        elif r < m+1:\n            return self.DFS(node.left,l,r)\n        else:\n            a,b = self.DFS(node.left,l,m)\n            c,d = self.DFS(node.right,m+1,r)\n            if a == c :\n                return a,b+d\n            elif b > d :\n                return a,b-d\n            else:\n                return c,d-b\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        candidate = self.DFS(self.root,left,right)[0]\n        if threshold <= bisect.bisect_right(self.index[candidate],right) - bisect.bisect_left(self.index[candidate],left):\n            return candidate\n        else:\n            return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class Node:\n    def __init__(self,left,right):\n        self.left = left\n        self.right = right\n        self.left_child = None\n        self.right_child = None\n        self.Maj_num = None\n        self.Maj_f = 0\n        \nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        def create_Tree(i,j):\n            cur = Node(i,j)\n            if i == j:\n                cur.Maj_num = arr[i]\n                cur.Maj_f = 1\n            else:\n                m = (i+j)//2\n                cur.left_child , n1 , f1 = create_Tree(i,m)\n                cur.right_child , n2 ,f2 = create_Tree(m+1,j)\n                if n1 == n2:\n                    cur.Maj_num = n1\n                    cur.Maj_f = f1+f2\n                else:\n                    if f1 >= f2:\n                        cur.Maj_num = n1\n                        cur.Maj_f = f1-f2\n                    else:\n                        cur.Maj_num = n2\n                        cur.Maj_f = f2-f1\n            return cur,cur.Maj_num,cur.Maj_f\n        \n        self.root = create_Tree(0,len(arr)-1)[0]\n        self.index = defaultdict(list)\n        for i,num in enumerate(arr):\n            self.index[num].append(i)\n            \n    def traverse(self,node,i,j):\n        if i == node.left and j == node.right:\n            return node.Maj_num, node.Maj_f\n        m = (node.left + node.right)//2\n        \n        if i > m :\n            return self.traverse(node.right_child,i,j)\n        if j <= m:\n            return self.traverse(node.left_child,i,j)\n        else:\n            n1,f1 = self.traverse(node.left_child,i,m)\n            n2,f2 = self.traverse(node.right_child,m+1,j)\n            if n1 == n2:\n                return n1,f1+f2\n            else:\n                if f1 >= f2:\n                    return n1,f1-f2\n                else:\n                    return n2,f2-f1             \n    def query(self, left: int, right: int, threshold: int) -> int:\n        candidate = self.traverse(self.root,left,right)[0]\n        if threshold <= bisect.bisect_right(self.index[candidate],right) - bisect.bisect_left(self.index[candidate],left):\n            return candidate\n        else:\n            return -1\n        \n", "from bisect import bisect, bisect_left\nclass Node():\n    def __init__(self, val, freq):\n        self.val = val\n        self.freq = freq\n        \ndef merge(a,b):\n    if a.val == b.val:\n        return Node(a.val, a.freq+b.freq)\n    if a.freq > b.freq:\n        return Node(a.val, a.freq - b.freq)\n    return Node(b.val, b.freq - a.freq)\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.n = len(arr)\n        self.arr = arr\n        self.size = 1 << math.ceil(math.log(self.n, 2)) + 1 \n        self.tree = [None] * self.size \n        self.indexes = {i: [] for i in self.arr}\n        self.build(0, 0, self.n-1)\n           \n    def build(self, pos, l, r):\n        if l == r:\n            self.tree[pos] = Node(self.arr[l], 1) \n            self.indexes[self.arr[l]].append(l)\n        else:\n            mid = l + r >> 1\n            self.build(pos*2+1, l, mid) \n            self.build(pos*2+2,mid+1, r) \n            self.tree[pos] = merge(self.tree[pos*2+1], self.tree[pos*2+2]) \n        \n    def pquery(self, pos, start, end, l ,r):\n        if l > end or r < start:\n            return Node(0, 0)\n        if start <= l and r <= end:\n            return self.tree[pos] \n        mid = l + r >> 1\n        a = self.pquery(pos*2+1, start, end, l, mid) \n        b = self.pquery(pos*2+2, start, end, mid+1, r) \n        return merge(a,b)\n\n    def query(self, l: int, r: int, threshold: int) -> int:\n        candidate = self.pquery(0, l, r, 0 , self.n-1).val\n        if candidate == 0 : return -1\n        s = bisect_left(self.indexes[candidate], l) \n        e = bisect(self.indexes[candidate], r)\n        return candidate if e - s >= threshold else -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class Node:\n    def __init__(self,left,right):\n        self.i = left\n        self.j = right\n        self.left = None\n        self.right = None\n        self.Maj = None\n        self.Maj_f = 0\n        \nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        def DFS(i,j):\n            node = Node(i,j)\n            if i == j :\n                node.Maj = arr[i]\n                node.Maj_f = 1\n            else:\n                m = (i+j)//2\n                node.left,a,b = DFS(i,m)\n                node.right,c,d = DFS(m+1,j)\n                if a == c:\n                    node.Maj = a \n                    node.Maj_f = b+d\n                elif b > d:\n                    node.Maj = a \n                    node.Maj_f = b-d\n                else:\n                    node.Maj = c\n                    node.Maj_f = d-b\n            return node,node.Maj,node.Maj_f \n        \n        self.root = DFS(0,len(arr)-1)[0]\n        self.index = defaultdict(list)\n        for i,num in enumerate(arr):\n            self.index[num].append(i)\n    \n    def DFS(self,node,l,r):\n        if node.i == l and node.j == r:\n            return node.Maj,node.Maj_f\n        m = (node.i+node.j)//2\n        if l > m :\n            return self.DFS(node.right,l,r)\n        elif r < m+1:\n            return self.DFS(node.left,l,r)\n        else:\n            a,b = self.DFS(node.left,l,m)\n            c,d = self.DFS(node.right,m+1,r)\n            if a == c :\n                return a,b+d\n            elif b > d :\n                return a,b-d\n            else:\n                return c,d-b\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        candidate = self.DFS(self.root,left,right)[0]\n        if threshold <= bisect.bisect_right(self.index[candidate],right) - bisect.bisect_left(self.index[candidate],left):\n            return candidate\n        else:\n            return -1", "class MajorityChecker:\n    # copied https://leetcode.com/problems/online-majority-element-in-subarray/discuss/355848/Python-Binary-Search-%2B-Find-the-Majority-Element\n\n    def __init__(self, arr: List[int]):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            a2i[x].append(i)\n        self.A, self.a2i = arr, a2i\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20): # \u7528\u7684\u662f\u6982\u7387\uff0c20\u6b21\u90fd\u6ca1\u6709\u627e\u5230\u8fd9\u4e2a\u6570\u7684\u6982\u7387\u592a\u5c0f -> 0.49^20 \n            a = self.A[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n    # copied https://leetcode.com/problems/online-majority-element-in-subarray/discuss/355848/Python-Binary-Search-%2B-Find-the-Majority-Element\n\n    def __init__(self, arr: List[int]):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            a2i[x].append(i)\n        self.A, self.a2i = arr, a2i\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            a = self.A[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\n\nimport bisect\n\nclass MajorityChecker:\n\n  def __init__(self, arr: List[int]):\n    # d: value -> indices\n    self.d = defaultdict(list)\n    # Q0458, index each value by binary, in or not in 15 groups, 2^5 = 32768 > 20000.\n    self.q = [[0] * 15 for _ in range(len(arr) + 1)]\n    for i, x in enumerate(arr):\n      self.d[x].append(i)\n      for j in range(15):\n        self.q[i + 1][j] = self.q[i][j] + (x & 1)\n        x >>= 1\n    \n  def query(self, left: int, right: int, threshold: int) -> int:\n    # candidate\n    x = 0\n    for j in range(15):\n      if self.q[right + 1][j] - self.q[left][j] >= threshold:\n        x |= 1 << j\n    return x if bisect.bisect_right(self.d[x], right) - bisect.bisect_left(self.d[x], left) >= threshold else -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.x_idxs = x_idxs = defaultdict(list)\n        for i, x in enumerate(arr):\n            x_idxs[x].append(i)\n        self.xs = sorted((len(idxs), x) for x, idxs in list(x_idxs.items()))[::-1]\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for length, x in self.xs:\n            if length < threshold:\n                break\n            idxs = self.x_idxs[x]\n            r = bisect.bisect_right(idxs, right)\n            l = bisect.bisect_right(idxs, left - 1)\n            if r - l >= threshold:\n                return x\n        return -1\n\n    \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, A):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(A):\n            a2i[x].append(i)\n        self.A, self.a2i = A, a2i\n\n    def query(self, left, right, threshold):\n        for _ in range(20):\n            a = self.A[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n    def __init__(self, nums):\n        atoi = defaultdict(list)\n        for i, num in enumerate(nums):\n            atoi[num].append(i)\n        self.nums = nums\n        self.atoi = atoi\n\n    def query(self, left, right, threshold):\n        for _ in range(20):\n            rand = self.nums[random.randint(left, right)]\n            left_element = bisect.bisect_left(self.atoi[rand], left)\n            right_element = bisect.bisect(self.atoi[rand], right) \n            if right_element - left_element >= threshold:\n                return rand\n        return -1", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        a2i = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            a2i[a].append(i)\n        \n        self.a2i = a2i\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for _ in range(40):\n            a = self.arr[random.randint(left, right)]\n            l = bisect.bisect_left(self.a2i[a], left)\n            r = bisect.bisect_right(self.a2i[a], right)\n            if r - l >= threshold:\n                return a\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class Node:\n    def __init__(self,left,right):\n        self.i = left\n        self.j = right\n        self.left = None\n        self.right = None\n        self.Maj = None\n        self.Maj_f = 0\n        \nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        def DFS(i,j):\n            node = Node(i,j)\n            if i == j :\n                node.Maj = arr[i]\n                node.Maj_f = 1\n            else:\n                m = (i+j)//2\n                node.left,a,b = DFS(i,m)\n                node.right,c,d = DFS(m+1,j)\n                if a == c:\n                    node.Maj = a \n                    node.Maj_f = b+d\n                elif b > d:\n                    node.Maj = a \n                    node.Maj_f = b-d\n                else:\n                    node.Maj = c\n                    node.Maj_f = d-b\n            return node,node.Maj,node.Maj_f \n        \n        self.root = DFS(0,len(arr)-1)[0]\n        self.index = defaultdict(list)\n        for i,num in enumerate(arr):\n            self.index[num].append(i)\n    \n    def DFS(self,node,l,r):\n        if node.i == l and node.j == r:\n            return node.Maj,node.Maj_f\n        m = (node.i+node.j)//2\n        if l > m :\n            return self.DFS(node.right,l,r)\n        elif r < m+1:\n            return self.DFS(node.left,l,r)\n        else:\n            a,b = self.DFS(node.left,l,m)\n            c,d = self.DFS(node.right,m+1,r)\n            if a == c :\n                return a,b+d\n            elif b > d :\n                return a,b-d\n            else:\n                return c,d-b\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        candidate = self.DFS(self.root,left,right)[0]\n        print(candidate)\n        if threshold <= bisect.bisect_right(self.index[candidate],right) - bisect.bisect_left(self.index[candidate],left):\n            return candidate\n        else:\n            return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\n\nclass MajorityChecker(object):\n\n    def __init__(self, A):\n        B = defaultdict(list)\n        for idx, a in enumerate(A):\n            B[a].append(idx)\n        self.A, self.B = A, B\n\n    def query(self, left, right, threshold):\n        ss = set()\n        for _ in range(40):\n            idx = random.randint(left, right)\n            if idx in ss:\n                continue\n            else: \n                ss.add(idx)\n                a = self.A[idx]\n                l = bisect.bisect_left(self.B[a], left)\n                r = bisect.bisect_right(self.B[a], right)\n                if r - l >= threshold:\n                    return a\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import numpy as np\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = np.array(arr)\n\n\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        \n\n        count = np.bincount(self.arr[left:right+1])\n        x = np.argmax(count)\n        if count[x] >= threshold:\n            return x\n\n\n        return -1\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.data = defaultdict(list)\n        for i,num in enumerate(arr):\n            self.data[num] += [i]\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        counter = defaultdict(int)\n        for _ in range(32):\n            index = random.randint(left, right)\n            counter[self.arr[index]] += 1\n        max_cnts = sorted([(value,key) for key,value in list(counter.items())], reverse=True)[:2]\n        \n        for value,key in max_cnts:\n            i = bisect.bisect_left(self.data[key],  left)\n            j = bisect.bisect_right(self.data[key], right)\n            if j - i >= threshold:\n                return key\n        return -1\n        \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "    \nfrom math import log2\n\nclass Node:\n    def __init__(self,val,freq):\n        self.val=val\n        self.freq = freq\n        \nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        \n        self.arr = arr\n        \n        self.freq = { i:[] for i in arr }\n        \n        self.size = 1 << math.ceil(log2(len(arr))) + 1\n        \n        self.st = [0]*self.size\n        \n        self.build(0,len(arr)-1,0)\n    \n    \n    def merge(self,a,b):\n        if a.val == b.val:\n            return Node(a.val, a.freq + b.freq)\n        if a.freq>b.freq:\n            return Node(a.val, a.freq-b.freq)\n        return Node(b.val,b.freq-a.freq)\n    \n    def pqery(self,l,r,pos,s,e):\n        if s>r or e<l:\n            return Node(0,0)\n        \n        if l<=s and r>=e:\n            return self.st[pos]\n        \n        mid  = ( s + e )>>1\n        \n        a=self.pqery(l,r,2*pos + 1,s,mid)\n        b=self.pqery(l,r,2*pos + 2,mid+1,e)\n        return self.merge(a,b)\n        \n    def build(self,start,end,pos):\n        \n        if start==end:\n            self.st[pos]=Node(self.arr[start],1)\n            self.freq[self.arr[start]].append(start)\n        \n        else:\n            \n            mid = (end + start)>>1\n\n            self.build(start,mid,2*pos + 1)\n            self.build(mid+1,end,2*pos + 2)\n            self.st[pos] = self.merge(self.st[pos*2 + 1],self.st[2*pos + 2])\n            \n            \n    def lower_bound(self,arr,x):\n        l=0\n        r=len(arr)-1\n        while l<=r:\n            mid = (l+r )>> 1\n            if arr[mid]<x:\n                l=mid+1\n            else:\n                r=mid-1\n        return l\n            \n            \n    def upper_bound(self,arr,x):\n        l=0\n        r=len(arr)-1\n        while l<=r:\n            mid = (l+r) >> 1\n            if arr[mid]<=x:\n                l=mid+1\n            else:\n                r=mid-1\n        return r+1\n            \n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        candidate = self.pqery(left,right,0,0,(len(self.arr)-1))\n        # print(self.freq,candidate.val)\n        if candidate.val==0:return -1\n        \n        s = self.lower_bound(self.freq[candidate.val],left)\n        e= self.upper_bound(self.freq[candidate.val],right)\n        # print(e,s)\n        if (e-s) >=threshold :\n            return candidate.val\n        else:\n            return -1\n\n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.idxes = collections.defaultdict(list)\n        for (i, n) in enumerate(arr):\n            self.idxes[n].append(i)\n        self.arr = arr\n        self.st = SegmentTree(len(arr), arr, self.idxes)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        maj = self.st.query_maj(left, right)\n        if maj:\n            l, r = bisect.bisect_left(self.idxes[maj], left), bisect.bisect(self.idxes[maj], right)\n            if r - l >= threshold:\n                return maj\n        return -1\n\nclass SegmentTree:\n    \n    def __init__(self, n, arr, idxes):\n        self.root = Node(0, n - 1, arr, idxes)\n        \n    def query_maj(self, lo, hi):\n        return self.root.query_maj(lo, hi)\n\nclass Node:\n    \n    def __init__(self, lo, hi, arr, idxes):\n        self.lo, self.hi = lo, hi\n        self.lc, self.rc = None, None\n        self.arr, self.idxes = arr, idxes\n        self.maj = None\n        \n    def query_maj(self, lo, hi):\n        \n        def is_maj(n):\n            if not n:\n                return False\n            \n            l = bisect.bisect_left(self.idxes[n], lo)\n            r = bisect.bisect(self.idxes[n], hi)\n            return (r - l << 1) > hi - lo\n        \n        if lo > hi or self.lo > hi or self.hi < lo:\n            return None\n        \n        if lo <= self.lo <= self.hi <= hi:\n            if not self.maj:\n                if self.lo == self.hi:\n                    self.maj = self.arr[self.lo]\n                else:\n                    l, r = None, None\n                    mi = (self.lo + self.hi) >> 1\n                    if not self.lc:\n                        self.lc = Node(self.lo, mi, self.arr, self.idxes)\n                    l = self.lc.query_maj(self.lo, mi)\n                    if not self.rc:\n                        self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n                    r = self.rc.query_maj(mi + 1, self.hi)\n                        \n                    self.maj = l if is_maj(l) else r if is_maj(r) else -1\n            return self.maj\n        \n        mi = (self.lo + self.hi) >> 1\n        l, r = None, None\n        if lo <= mi:\n            if not self.lc:\n                self.lc = Node(self.lo, mi, self.arr, self.idxes)\n            l = self.lc.query_maj(max(self.lo, lo), min(mi, hi))\n        if mi + 1 <= hi:\n            if not self.rc:\n                self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n            r = self.rc.query_maj(max(lo, mi + 1), min(self.hi, hi))\n        return l if is_maj(l) else r if is_maj(r) else -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.x_idxs = x_idxs = defaultdict(list)\n\n        for i, x in enumerate(arr):\n            x_idxs[x].append(i)\n\n        self.xs = sorted(list(x_idxs.keys()), key=lambda x: -len(x_idxs[x]))\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        br = bisect.bisect_right\n        for x in self.xs:\n            idxs = self.x_idxs[x]\n            if len(idxs) < threshold:\n                break\n            if br(idxs, right) - br(idxs, left - 1) >= threshold:\n                return x\n\n        return -1\n    \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.indices = defaultdict(list)\n        for a in set(arr):\n            self.indices[a].append(-1)\n        for i, a in enumerate(arr):\n            self.indices[a].append(i)\n        self.a = list(self.indices.keys())\n    def query(self, left: int, right: int, threshold: int) -> int:\n        def bs(arr, l, r, target):\n            while l<=r:\n                m = l+(r-l)//2\n                if arr[m]<=target:\n                    l = m+1\n                else:\n                    r = m-1\n            return r\n        \n        for _ in range(20):\n            a = random.choice(self.a)\n            lst = self.indices[a]\n            l, r = bs(lst, 0, len(lst)-1, left-1), bs(lst, 0, len(lst)-1, right)\n            if r-l>=threshold:\n                return a\n        \n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.idxes = collections.defaultdict(list)\n        for (i, n) in enumerate(arr):\n            self.idxes[n].append(i)\n        self.arr = arr\n        self.st = SegmentTree(len(arr), arr, self.idxes)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        maj = self.st.query_maj(left, right)\n        if maj:\n            l, r = bisect.bisect_left(self.idxes[maj], left), bisect.bisect(self.idxes[maj], right)\n            if r - l >= threshold:\n                return maj\n        return -1\n\nclass SegmentTree:\n    \n    def __init__(self, n, arr, idxes):\n        self.root = Node(0, n - 1, arr, idxes)\n        \n    def query_maj(self, lo, hi):\n        return self.root.query_maj(lo, hi)\n\nclass Node:\n    \n    def __init__(self, lo, hi, arr, idxes):\n        self.lo, self.hi = lo, hi\n        self.lc, self.rc = None, None\n        self.arr, self.idxes = arr, idxes\n        self.maj = None\n        \n    def query_maj(self, lo, hi):\n        \n        def is_maj(n):\n            if not n:\n                return False\n            \n            l = bisect.bisect_left(self.idxes[n], lo)\n            r = bisect.bisect(self.idxes[n], hi)\n            return (r - l << 1) > hi - lo\n        \n        if lo > hi or self.lo > hi or self.hi < lo:\n            return None\n        \n        if lo <= self.lo <= self.hi <= hi:\n            if not self.maj:\n                if self.lo == self.hi:\n                    self.maj = self.arr[self.lo]\n                else:\n                    l, r = None, None\n                    mi = (self.lo + self.hi) >> 1\n                    # Note: we don't need to check whether 'lc' or 'rc' overlap with [lo, hi],\n                    # since the parent node is already within [lo, hi]\n                    if not self.lc:\n                        self.lc = Node(self.lo, mi, self.arr, self.idxes)\n                    # Note: we should not query [lo, hi], but instead query [self.lo, mi],\n                    # since maj element in [self.lo, mi] may not necessarily be a maj element of [lo, hi],\n                    # leading to a false negative\n                    l = self.lc.query_maj(self.lo, mi)\n                    \n                    # Note: same on the 'rc' as on 'lc'\n                    if not self.rc:\n                        self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n                    r = self.rc.query_maj(mi + 1, self.hi)\n                        \n                    self.maj = l if is_maj(l) else r if is_maj(r) else -1\n            return self.maj\n        \n        mi = (self.lo + self.hi) >> 1\n        l, r = None, None\n        if lo <= mi:\n            if not self.lc:\n                self.lc = Node(self.lo, mi, self.arr, self.idxes)\n            l = self.lc.query_maj(max(self.lo, lo), min(mi, hi))\n        if mi + 1 <= hi:\n            if not self.rc:\n                self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n            r = self.rc.query_maj(max(lo, mi + 1), min(self.hi, hi))\n        return l if is_maj(l) else r if is_maj(r) else -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.idxes = collections.defaultdict(list)\n        for (i, n) in enumerate(arr):\n            self.idxes[n].append(i)\n        self.arr = arr\n        self.st = SegmentTree(len(arr), arr, self.idxes)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        maj = self.st.query_maj(left, right)\n        if maj:\n            l, r = bisect.bisect_left(self.idxes[maj], left), bisect.bisect(self.idxes[maj], right)\n            if r - l >= threshold:\n                return maj\n        return -1\n\nclass SegmentTree:\n    \n    def __init__(self, n, arr, idxes):\n        self.root = Node(0, n - 1, arr, idxes)\n        \n    def query_maj(self, lo, hi):\n        return self.root.query_maj(lo, hi)\n\nclass Node:\n    \n    def __init__(self, lo, hi, arr, idxes):\n        self.lo, self.hi = lo, hi\n        self.lc, self.rc = None, None\n        self.arr, self.idxes = arr, idxes\n        self.maj = None\n        \n    def query_maj(self, lo, hi):\n        \n        def is_maj(n):\n            if not n:\n                return False\n            \n            l = bisect.bisect_left(self.idxes[n], lo)\n            r = bisect.bisect(self.idxes[n], hi)\n            return (r - l << 1) > hi - lo\n        \n        if lo > hi or self.lo > hi or self.hi < lo:\n            return None\n        \n        if lo <= self.lo <= self.hi <= hi:\n            if not self.maj:\n                if self.lo == self.hi:\n                    self.maj = self.arr[self.lo]\n                else:\n                    mi = (self.lo + self.hi) >> 1\n                    if not self.lc:\n                        self.lc = Node(self.lo, mi, self.arr, self.idxes)\n                    if not self.rc:\n                        self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n                    l = self.lc.query_maj(self.lo, mi)\n                    r = self.rc.query_maj(mi + 1, self.hi)\n                    self.maj = l if is_maj(l) else r if is_maj(r) else -1\n            return self.maj\n        \n        mi = (self.lo + self.hi) >> 1\n        if not self.lc:\n            self.lc = Node(self.lo, mi, self.arr, self.idxes)\n        if not self.rc:\n            self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n    \n        l = self.lc.query_maj(lo, hi)\n        r = self.rc.query_maj(lo, hi)\n        return l if is_maj(l) else r if is_maj(r) else -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.idxes = collections.defaultdict(list)\n        for (i, n) in enumerate(arr):\n            self.idxes[n].append(i)\n        self.arr = arr\n        self.st = SegmentTree(len(arr), arr, self.idxes)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        maj = self.st.query_maj(left, right)\n        if maj:\n            l, r = bisect.bisect_left(self.idxes[maj], left), bisect.bisect(self.idxes[maj], right)\n            if r - l >= threshold:\n                return maj\n        return -1\n\nclass SegmentTree:\n    \n    def __init__(self, n, arr, idxes):\n        self.root = Node(0, n - 1, arr, idxes)\n        \n    def query_maj(self, lo, hi):\n        return self.root.query_maj(lo, hi)\n\nclass Node:\n    \n    def __init__(self, lo, hi, arr, idxes):\n        self.lo, self.hi = lo, hi\n        self.lc, self.rc = None, None\n        self.arr, self.idxes = arr, idxes\n        self.maj = None\n        \n    def query_maj(self, lo, hi):\n        \n        def is_maj(n):\n            if not n:\n                return False\n            \n            l = bisect.bisect_left(self.idxes[n], lo)\n            r = bisect.bisect(self.idxes[n], hi)\n            return (r - l << 1) > hi - lo\n        \n        if lo > hi or self.lo > hi or self.hi < lo:\n            return None\n        \n        if self.lo >= lo and self.hi <= hi:\n            if not self.maj:\n                if self.lo == self.hi:\n                    self.maj = self.arr[self.lo]\n                else:\n                    mi = (self.lo + self.hi) >> 1\n                    if not self.lc:\n                        self.lc = Node(self.lo, mi, self.arr, self.idxes)\n                    if not self.rc:\n                        self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n                    l = self.lc.query_maj(self.lo, mi)\n                    r = self.rc.query_maj(mi + 1, self.hi)\n                    self.maj = l if is_maj(l) else r if is_maj(r) else -1\n            return self.maj\n        \n        mi = (self.lo + self.hi) >> 1\n        if not self.lc:\n            self.lc = Node(self.lo, mi, self.arr, self.idxes)\n        if not self.rc:\n            self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n    \n        l = self.lc.query_maj(lo, hi)\n        r = self.rc.query_maj(lo, hi)\n        return l if is_maj(l) else r if is_maj(r) else -1\n        \n#         def is_maj(n):\n#             if not n:\n#                 return False\n            \n#             l = bisect.bisect_left(self.idxes[n], lo)\n#             r = bisect.bisect(self.idxes[n], hi)\n#             return (r - l << 1) > hi - lo\n        \n#         def get_children_maj():\n#             l, r = None, None\n#             mi = (self.lo + self.hi) >> 1\n#             # if lo <= mi:\n#             if not self.lc:\n#                 self.lc = Node(self.lo, mi, self.arr, self.idxes)\n#             l = self.lc.query_maj(lo, hi)\n            \n#             # if mi + 1 <= hi:\n#             if not self.rc:\n#                 self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n#             r = self.rc.query_maj(lo, hi)\n            \n#             return l, r\n        \n#         if self.lo > hi or self.hi < lo:\n#             return None\n#         if self.lo == self.hi:\n#             return self.arr[self.lo]\n        \n#         if lo <= self.lo <= self.hi <= hi:\n#             # lazy population: initially, 'self.maj' is not set\n#             if not self.maj:\n#                 # base case: only 1 element in the node\n#                 # and that must be the majority element\n#                 # if self.lo == self.hi:\n#                 #     self.maj = self.arr[self.lo]\n#                 # else:\n#                     # l, r = get_children_maj()\n                    \n                    \n#                 mi = (self.lo + self.hi) >> 1\n#                 # if lo <= mi:\n#                 if not self.lc:\n#                     self.lc = Node(self.lo, mi, self.arr, self.idxes)\n#                 l = self.lc.query_maj(lo, hi)\n\n#                 # if mi + 1 <= hi:\n#                 if not self.rc:\n#                     self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n#                 r = self.rc.query_maj(lo, hi)\n\n\n#                 if is_maj(l):\n#                     self.maj = l\n#                 elif is_maj(r):\n#                     self.maj = r\n#                 else:\n#                     self.maj = -1\n#             return self.maj\n        \n#         # l, r = get_children_maj()\n#         # return l if is_maj(l) else r if is_maj(r) else None\n#         mi = (self.lo + self.hi) >> 1\n#         # if lo <= mi:\n#         if not self.lc:\n#             self.lc = Node(self.lo, mi, self.arr, self.idxes)\n#         l = self.lc.query_maj(lo, hi)\n\n#         # if mi + 1 <= hi:\n#         if not self.rc:\n#             self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n#         r = self.rc.query_maj(lo, hi)\n#         if is_maj(l):\n#             return l\n#         if is_maj(r):\n#             return r\n#         return -1\n\n\n\n\n# class Node:\n    \n#     def __init__(self, lo, hi, arr, cnt):\n#         self.lo, self.hi = lo, hi\n#         # self.maj: the majority element in range [self.lo, self.hi]\n#         self.left, self.right, self.maj = None, None, None\n#         self.arr, self.cnt = arr, cnt\n    \n#     def query(self, lo, hi):\n        \n#         def isMaj(n):\n#             if n:\n#                 l, r = bisect.bisect_left(self.cnt[n], lo), bisect.bisect_right(self.cnt[n], hi)\n#                 return (r - l) * 2 > hi - lo\n#             return False\n        \n#         if lo > hi or self.lo > hi or self.hi < lo:\n#             return None\n#         if self.lo == self.hi:\n#             return self.arr[self.lo]\n        \n#         if self.lo >= lo and self.hi <= hi:\n#             if not self.maj:\n#                 mi = (self.lo + self.hi) >> 1\n#                 if not self.left:\n#                     self.left = Node(self.lo, mi, self.arr, self.cnt)\n#                 if not self.right:\n#                     self.right = Node(mi + 1, self.hi, self.arr, self.cnt)\n#                 l = self.left.query(self.lo, mi)\n#                 r = self.right.query(mi + 1, self.hi)\n#                 if l != -1 and isMaj(l):\n#                     self.maj = l\n#                 elif r != -1 and isMaj(r):\n#                     self.maj = r\n#                 else:\n#                     self.maj = -1\n#             return self.maj\n        \n#         mi = (self.lo + self.hi) >> 1\n#         if not self.left:\n#             self.left = Node(self.lo, mi, self.arr, self.cnt)\n#         if not self.right:\n#             self.right = Node(mi + 1, self.hi, self.arr, self.cnt)\n    \n#         l = self.left.query(lo, hi)\n#         r = self.right.query(lo, hi)\n#         if l != -1 and isMaj(l):\n#             return l\n#         if r != -1 and isMaj(r):\n#             return r\n#         return -1\n\n# class MajorityChecker:\n\n#     def __init__(self, arr: List[int]):\n#         self.cnt = collections.defaultdict(list)\n#         for (i, v) in enumerate(arr):\n#             self.cnt[v] += i,\n#         self.arr = arr\n#         self.root = Node(0, len(arr) - 1, self.arr, self.cnt)\n    \n#     def query(self, left: int, right: int, threshold: int) -> int:\n#         elm = self.root.query(left, right)\n#         if elm != -1:\n#             lo, hi = bisect.bisect_left(self.cnt[elm], left), bisect.bisect_right(self.cnt[elm], right)\n#             if hi - lo >= threshold:\n#                 return elm\n#         return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n    \n    def __init__(self, arr: List[int]):\n        self.num_to_index = collections.defaultdict(list)\n        for x in range(len(arr)):\n            self.num_to_index[arr[x]].append(x)\n        self.arr = arr\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        visited = set()\n        length = right - left+1\n        for x in range(left,right+1):\n            if self.arr[x] in visited:\n                continue\n            left_i = bisect.bisect_left(self.num_to_index[self.arr[x]],left)\n            right_i = bisect.bisect_right(self.num_to_index[self.arr[x]],right)-1\n            #print(self.num_to_index[self.arr[x]])\n            #print(left_i,right_i,self.arr[x])\n            if right_i - left_i+1 >= threshold:\n                return self.arr[x]\n            #threshold = threshold-(right_i - left_i+1)\n            length = length - (right_i - left_i+1)\n            if threshold > length:\n                return -1\n            visited.add(self.arr[x])\n        return -1\n            \n            \n        \n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        \n        \n        self.tables = collections.defaultdict(list)\n        for i, num in enumerate(arr):\n            self.tables[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        if right - left + 1 < threshold:\n            return -1\n        for num in self.tables:\n            if len(self.tables[num]) < threshold:\n                continue\n            l = self.leftSearch(self.tables[num], left)\n            r = self.rightSearch(self.tables[num], right)\n            # print(num, self.tables[num])\n            # print(left, right)\n            # print(l, r)\n            if r-l  >= threshold:\n                return num\n        return -1\n                \n        \n        \n    def leftSearch(self, array, target):\n        \n        l = 0\n        r = len(array)\n        while l < r:\n            m = (l+r) // 2\n            if array[m] < target:\n                l = m + 1\n            else:\n                r = m\n        return l\n                \n        \n        \n    def rightSearch(self, array, target):\n        \n        l = 0\n        r = len(array)\n        while l < r:\n            m = (l+r) // 2\n            if array[m] <= target:\n                l = m + 1\n            else:\n                r = m\n        return l\n        \n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import collections as clc\nimport time\n\nstart = time.time()\n\n\nclass SegmentTree:\n    \n    def __init__(self, left_bound: int, right_bound: int):\n        self.left_bound = left_bound\n        self.right_bound = right_bound\n        self.mid = None\n        self.values = None\n        self.most_frequent = None\n        self.left = None\n        self.right = None\n        \n    def split(self, mid: int):\n        self.mid = mid\n        self.left = SegmentTree(self.left_bound, self.mid)\n        self.right = SegmentTree(self.mid, self.right_bound)\n    \n    def __len__(self):\n        return self.right_bound - self.left_bound\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.n = len(arr)\n        self.arr = arr\n        self.tree = SegmentTree(0, self.n)\n        self.build(self.tree)\n    \n    def build(self, node: SegmentTree):\n        if len(node) == 1:\n            node.values = clc.Counter(self.arr[node.left_bound : node.right_bound])\n            node.most_frequent = self.arr[node.left_bound]\n            return\n        node.split((node.left_bound + node.right_bound) // 2)\n        self.build(node.left)\n        self.build(node.right)\n        node.values = node.left.values + node.right.values\n        left_freq = node.left.most_frequent\n        right_freq = node.right.most_frequent\n        if (\n            node.left.values[left_freq] + node.right.values[left_freq]\n            >= node.left.values[right_freq] + node.right.values[right_freq]\n        ):\n            node.most_frequent = left_freq\n        else:\n            node.most_frequent = right_freq\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        counts_set, most_freqs = self.rec_query(self.tree, left, right + 1)\n        for num in most_freqs:\n            if sum(counts[num] for counts in counts_set) >= threshold:\n                return num\n        return -1\n    \n    def rec_query(self, node: int, left: int, right: int):\n        if node.left_bound == left and node.right_bound == right:\n            return [node.values], [node.most_frequent]\n        if right <= node.mid:\n            return self.rec_query(node.left, left, right)\n        if left >= node.mid:\n            return self.rec_query(node.right, left, right)\n        left_values, left_set = self.rec_query(node.left, left, node.mid)\n        right_values, right_set = self.rec_query(node.right, node.mid, right)\n        return left_values + right_values, left_set + right_set\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import collections as clc\nimport time\n\nstart = time.time()\n\n\nclass SegmentTree:\n    \n    def __init__(self, left_bound: int, right_bound: int):\n        self.left_bound = left_bound\n        self.right_bound = right_bound\n        self.mid = None\n        self.values = None\n        self.most_frequent = None\n        self.left = None\n        self.right = None\n        \n    def split(self, mid: int):\n        self.mid = mid\n        self.left = SegmentTree(self.left_bound, self.mid)\n        self.right = SegmentTree(self.mid, self.right_bound)\n    \n    def __len__(self):\n        return self.right_bound - self.left_bound\n    \n    def __str__(self):\n        return f\\\"[{self.left_bound}, {self.right_bound})({self.left} | {self.mid} | {self.right})\\\"\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.n = len(arr)\n        self.arr = arr\n        self.tree = SegmentTree(0, self.n)\n        self.build(self.tree)\n    \n    def build(self, node: SegmentTree):\n        if len(node) == 1:\n            node.values = clc.Counter(self.arr[node.left_bound : node.right_bound])\n            node.most_frequent = self.arr[node.left_bound]\n            return\n        node.split((node.left_bound + node.right_bound) // 2)\n        self.build(node.left)\n        self.build(node.right)\n        node.values = node.left.values + node.right.values\n        node.most_frequent = node.values.most_common(1)[0][0]\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        counts_set, most_freqs = self.rec_query(self.tree, left, right + 1)\n        for num in most_freqs:\n            if sum(counts[num] for counts in counts_set) >= threshold:\n                return num\n        return -1\n    \n    def rec_query(self, node: int, left: int, right: int):\n        if node.left_bound == left and node.right_bound == right:\n            return [node.values], {node.most_frequent}\n        if right <= node.mid:\n            return self.rec_query(node.left, left, right)\n        if left >= node.mid:\n            return self.rec_query(node.right, left, right)\n        left_values, left_set = self.rec_query(node.left, left, node.mid)\n        right_values, right_set = self.rec_query(node.right, node.mid, right)\n        return left_values + right_values, left_set | right_set\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.idxes = collections.defaultdict(list)\n        for (i, n) in enumerate(arr):\n            self.idxes[n].append(i)\n        self.arr = arr\n        self.st = SegmentTree(len(arr), arr, self.idxes)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        maj = self.st.query_maj(left, right)\n        if maj:\n            l, r = bisect.bisect_left(self.idxes[maj], left), bisect.bisect(self.idxes[maj], right)\n            if r - l >= threshold:\n                return maj\n        return -1\n\nclass SegmentTree:\n    \n    def __init__(self, n, arr, idxes):\n        self.root = Node(0, n - 1, arr, idxes)\n        \n    def query_maj(self, lo, hi):\n        return self.root.query_maj(lo, hi)\n\nclass Node:\n    \n    def __init__(self, lo, hi, arr, idxes):\n        self.lo, self.hi = lo, hi\n        self.lc, self.rc = None, None\n        self.arr, self.idxes = arr, idxes\n        self.maj = None\n        \n    def query_maj(self, lo, hi):\n        \n        def is_maj(n):\n            if not n:\n                return False\n            \n            l = bisect.bisect_left(self.idxes[n], lo)\n            r = bisect.bisect(self.idxes[n], hi)\n            return (r - l << 1) > hi - lo\n        \n        if lo > hi or self.lo > hi or self.hi < lo:\n            return None\n        \n        if lo <= self.lo <= self.hi <= hi:\n            if not self.maj:\n                if self.lo == self.hi:\n                    self.maj = self.arr[self.lo]\n                else:\n                    l, r = None, None\n                    mi = (self.lo + self.hi) >> 1\n                    if lo <= mi:\n                        if not self.lc:\n                            self.lc = Node(self.lo, mi, self.arr, self.idxes)\n                        l = self.lc.query_maj(self.lo, mi)\n                    if mi <= hi:\n                        if not self.rc:\n                            self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n                        r = self.rc.query_maj(mi + 1, self.hi)\n                        \n                    self.maj = l if is_maj(l) else r if is_maj(r) else -1\n            return self.maj\n        \n        mi = (self.lo + self.hi) >> 1\n        if not self.lc:\n            self.lc = Node(self.lo, mi, self.arr, self.idxes)\n        if not self.rc:\n            self.rc = Node(mi + 1, self.hi, self.arr, self.idxes)\n    \n        l = self.lc.query_maj(lo, hi)\n        r = self.rc.query_maj(lo, hi)\n        return l if is_maj(l) else r if is_maj(r) else -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import defaultdict\nimport bisect\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr=arr\n        self.pos=defaultdict(list)\n        self.count=defaultdict(int)\n        for i in range(len(arr)):\n            item=arr[i]\n            self.pos[item].append(i)\n            self.count[item]+=1\n        self.rank=sorted(list(self.count.keys()),key=lambda x: self.count[x],reverse=True)\n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        if right-left<40:\n            dp=defaultdict(int)\n            for i in range(left,right+1):\n                dp[self.arr[i]]+=1\n            element= max(list(dp.keys()),key=lambda x: dp[x])\n            if dp[element]>=threshold:\n                return element\n            else:\n                return -1\n        else:\n            for item in self.rank:\n                if self.count[item]>=threshold:\n                    l1=bisect.bisect_left(self.pos[item],left)\n                    l2=bisect.bisect_right(self.pos[item],right)\n                    if l2-l1>=threshold:\n                        return item\n                else:\n                    break\n            return -1\n                        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import collections as clc\nimport time\n\nstart = time.time()\n\n\nclass SegmentTree:\n    \n    def __init__(self, left_bound: int, right_bound: int):\n        self.left_bound = left_bound\n        self.right_bound = right_bound\n        self.mid = None\n        self.values = None\n        self.most_frequent = None\n        self.left = None\n        self.right = None\n        \n    def split(self, mid: int):\n        self.mid = mid\n        self.left = SegmentTree(self.left_bound, self.mid)\n        self.right = SegmentTree(self.mid, self.right_bound)\n    \n    def __len__(self):\n        return self.right_bound - self.left_bound\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.n = len(arr)\n        self.arr = arr\n        self.tree = SegmentTree(0, self.n)\n        self.build(self.tree)\n    \n    def build(self, node: SegmentTree):\n        if len(node) == 1:\n            node.values = clc.Counter(self.arr[node.left_bound : node.right_bound])\n            node.most_frequent = self.arr[node.left_bound]\n            return\n        node.split((node.left_bound + node.right_bound) // 2)\n        self.build(node.left)\n        self.build(node.right)\n        node.values = node.left.values + node.right.values\n        node.most_frequent = node.values.most_common(1)[0][0]\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        counts_set, most_freqs = self.rec_query(self.tree, left, right + 1)\n        for num in most_freqs:\n            if sum(counts[num] for counts in counts_set) >= threshold:\n                return num\n        return -1\n    \n    def rec_query(self, node: int, left: int, right: int):\n        if node.left_bound == left and node.right_bound == right:\n            return [node.values], [node.most_frequent]\n        if right <= node.mid:\n            return self.rec_query(node.left, left, right)\n        if left >= node.mid:\n            return self.rec_query(node.right, left, right)\n        left_values, left_set = self.rec_query(node.left, left, node.mid)\n        right_values, right_set = self.rec_query(node.right, node.mid, right)\n        return left_values + right_values, left_set + right_set\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import random\nclass St:\n    class Node:\n        def __init__(self, vals):\n            self.vals = vals\n            self.stat = None     \n            self.left = None\n            self.right = None\n    \n    def __init__(self, arr):\n        self.arr = arr\n        self.root = self.build(0, len(self.arr)-1)\n        \n    def build(self, i, j):\n        if i == j:\n            N = St.Node((i,j))\n            N.stat = collections.Counter([self.arr[i]])\n            return N\n        \n        N = St.Node((i,j))\n        k = (i+j)>>1\n        N.left = self.build(i, k)\n        N.right = self.build(k+1, j)\n\n        N.stat = N.left.stat + N.right.stat\n        \n        return N        \n    \n    def retriveStat(self, i, j, t):\n        sentinel = False\n        res = self.root.stat.copy() # this could be run in a separate thread\n        \n        def helper(node):\n            nonlocal i,j,t,res,sentinel\n            if sentinel:\n                res = dict()\n                return        \n            if not res or max(res.values()) < t:\n                res = dict()\n                sentinel = True\n                return\n            \n            l,r = node.vals\n            \n            if r < i or l > j:\n                res -= node.stat\n                return\n                \n            if i <= l and r <= j:\n                return\n            \n            if l != r:\n                helper(node.left)\n                helper(node.right)\n            \n        helper(self.root)\n        \n        if not res:\n            return -1\n        \n        m = max(res, key=lambda x:res[x])\n        return m if res[m] >= t else -1\n\nclass MajorityChecker:\n    \n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.StO = St(arr)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        return self.StO.retriveStat(left, right, threshold)\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n\n# import random\n# class MajorityChecker:\n#     def _get_rand_pos(self, left, right):\n#         for e in random.sample(range(left,right+1), right-left+1):\n#             yield e\n\n#     def __init__(self, arr: List[int]):\n#         self.arr = arr\n\n#     def query(self, left: int, right: int, threshold: int) -> int:\n#         l = right - left\n#         MC = 0\n#         ME = None\n#         D = collections.defaultdict(int)\n#         for i in self._get_rand_pos(left,right):\n#             D[self.arr[i]] += 1\n#             if MC < D[self.arr[i]]:\n#                 MC = D[self.arr[i]]\n#                 ME = self.arr[i]\n#                 if MC >= threshold:\n#                     return ME\n#         return ME if MC >= threshold else -1\n\n\n# import random\n# class St:\n#     class Node:\n#         def __init__(self, vals):\n#             self.vals = vals\n#             self.stat = None     \n#             self.left = None\n#             self.right = None\n    \n#     def __init__(self, arr):\n#         self.arr = arr\n#         self.root = self.build(0, len(self.arr)-1)\n        \n#     def build(self, i, j):\n#         if i == j:\n#             N = St.Node((i,j))\n#             N.stat = collections.Counter([self.arr[i]])\n#             return N\n        \n#         N = St.Node((i,j))\n#         k = (i+j)>>1\n#         N.left = self.build(i, k)\n#         N.right = self.build(k+1, j)\n\n#         N.stat = N.left.stat + N.right.stat\n        \n#         return N        \n    \n#     def retriveStat(self, i, j, t):\n#         sentinel = False\n#         res = self.root.stat.copy()\n        \n#         def helper(node):\n#             nonlocal i,j,t,res,sentinel\n#             if sentinel:\n#                 res = dict()\n#                 return        \n#             if not res or max(res.values()) < t:\n#                 res = dict()\n#                 sentinel = True\n#                 return\n            \n#             l,r = node.vals\n            \n#             if r < i or l > j:\n#                 res -= node.stat\n#                 return\n                \n#             if l > j or i > r:\n#                 return\n#             if node.left:helper(node.left)\n#             if node.right:helper(node.right)\n            \n#         helper(self.root)\n#         return res.most_common()[0] if res else (-1,-1)\n\n# class MajorityChecker:\n    \n#     def __init__(self, arr: List[int]):\n#         self.arr = arr\n#         self.StO = St(arr)\n\n#     def query(self, left: int, right: int, threshold: int) -> int:\n#         R = self.StO.retriveStat(left, right, threshold)\n#         return R[0] if R[1] >= threshold else -1\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.numDict = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.numDict[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        leftCandi = right - left + 1\n        iNow = right\n        visited = set()\n        while leftCandi >= threshold:\n            if self.arr[iNow] not in visited:\n                visited.add(self.arr[iNow])\n                numOfINow  = self.count(iNow, left)\n                if numOfINow >= threshold:\n                    return self.arr[iNow]\n                else:\n                    leftCandi -= numOfINow\n            iNow -= 1\n        return -1\n    \n    def count(self, i0, left):\n        num = self.arr[i0]\n        listLen = len(self.numDict[num])\n        l = 0\n        r = listLen - 1\n        if i0 == self.numDict[num][r]:\n            right  = r\n        elif i0 == self.numDict[num][l]:\n            right = l\n        else:\n            while r > l:\n                m = (r + l) // 2\n                if self.numDict[num][m] < i0:\n                    l = m + 1\n                elif self.numDict[num][m] > i0:\n                    r = m\n                else:\n                    l = m\n                    r = l -1\n            right = l\n        l = 0 \n        r = right\n        if left <= self.numDict[num][l]:\n            return right + 1\n        # if left == self.numDict[num][r]:\n        #     return 1\n        while r > l:\n            m = (r + l) // 2\n            if self.numDict[num][m] < left:\n                l = m + 1\n            else:#if self.numDict[num][m] > left:\n                r = m\n            # else:\n            #     return right - m +1\n        return right- l + 1\n        \n        \n        \n    \n    \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n\n# class MajorityChecker:\n\n#     def __init__(self, arr: List[int]):\n#         preIndexDict = {}\n#         arrLen = len(arr)\n#         self.preIndexList = [i for i in range(arrLen)]\n#         self.arr = arr\n#         for i, num in enumerate(arr):\n#             if num in preIndexDict:\n#                 self.preIndexList[i] = preIndexDict[num]\n#             preIndexDict[num] = i\n#         self.dp = {}\n\n#     def query(self, left: int, right: int, threshold: int) -> int:\n#         leftCandi = right - left + 1\n#         iNow = right\n#         visited = set()\n#         while leftCandi >= threshold:\n#             if self.arr[iNow] not in visited:\n#                 visited.add(self.arr[iNow])\n#                 numOfINow  = self.count(iNow, left)\n#                 if numOfINow >= threshold:\n#                     return self.arr[iNow]\n#                 else:\n#                     leftCandi -= numOfINow\n#             iNow -= 1\n#         return -1\n                \n#     def count(self, i0, l):\n#         if (i0, l) in self.dp:\n#             return self.dp[(i0,l)]\n#         if self.preIndexList[i0] == i0 or self.preIndexList[i0] < l:\n#             return 1\n#         self.dp[(i0,l)] = 1 + self.count(self.preIndexList[i0], l)\n#         return self.dp[(i0,l)]\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.prearr = [[] for _ in range(max(arr)+1)]\n        \n        for i in range (len(arr)):\n                self.prearr[arr[i]].append(i) \n            \n    def query(self, left: int, right: int, threshold: int) -> int:   \n        \n        def checkmajority (k):\n            \n            #find index of left element \n            lo = 0 \n            hi= len(self.prearr[k])-1\n            \n            while (lo<hi):\n                mid = lo +((hi-lo)//2)\n                \n                if (self.prearr[k][mid]>=left):\n                    hi = mid \n                    \n                else:\n                    lo = mid+1\n                    \n            start = lo\n            \n            #find index of right element \n            lo = 0 \n            hi = len(self.prearr[k])-1\n            \n            while(lo<hi):\n                mid = lo + ((hi-lo +1)//2)\n                \n                if(self.prearr[k][mid] <= right):\n                    lo = mid\n                else:\n                    hi = mid-1 \n            end = lo \n            \n            # return the difference between indexes between the preaar element and compare it with threshold \n            \n            if ((end - start +1) >= threshold): \n                return (True)\n            \n            else:\n                return (False)\n            \n            \n        #pick random element from arr 30-50 times and check if it is majority or not\n        \n        res = False\n        a = self.arr[left:right+1]\n        \n        for _ in range (10): \n            k = random.choice(a)\n            res = res or checkmajority(k)\n            \n            if (res):\n                return(k)\n        \n        return(-1)      \n        \n        \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.numDict = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.numDict[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        leftCandi = right - left + 1\n        iNow = right\n        visited = set()\n        while leftCandi >= threshold:\n            if self.arr[iNow] not in visited:\n                visited.add(self.arr[iNow])\n                numOfINow  = self.count(iNow, left)\n                if numOfINow >= threshold:\n                    return self.arr[iNow]\n                else:\n                    leftCandi -= numOfINow\n            iNow -= 1\n        return -1\n    \n    def count(self, i0, left):\n        num = self.arr[i0]\n        listLen = len(self.numDict[num])\n        l = 0\n        r = listLen - 1\n        if i0 == self.numDict[num][r]:\n            right  = r\n        elif i0 == self.numDict[num][l]:\n            right = l\n        else:\n            while r > l:\n                m = (r + l) // 2\n                if self.numDict[num][m] < i0:\n                    l = m + 1\n                elif self.numDict[num][m] > i0:\n                    r = m\n                else:\n                    l = m\n                    r = l -1\n            right = l\n        l = 0 \n        r = right\n        if left <= self.numDict[num][l]:\n            return right + 1\n        if left == self.numDict[num][r]:\n            return 1\n        while r > l:\n            m = (r + l) // 2\n            if self.numDict[num][m] < left:\n                l = m + 1\n            else:#if self.numDict[num][m] > left:\n                r = m\n            # else:\n            #     return right - m +1\n        return right- l + 1\n        \n        \n        \n    \n    \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n\n# class MajorityChecker:\n\n#     def __init__(self, arr: List[int]):\n#         preIndexDict = {}\n#         arrLen = len(arr)\n#         self.preIndexList = [i for i in range(arrLen)]\n#         self.arr = arr\n#         for i, num in enumerate(arr):\n#             if num in preIndexDict:\n#                 self.preIndexList[i] = preIndexDict[num]\n#             preIndexDict[num] = i\n#         self.dp = {}\n\n#     def query(self, left: int, right: int, threshold: int) -> int:\n#         leftCandi = right - left + 1\n#         iNow = right\n#         visited = set()\n#         while leftCandi >= threshold:\n#             if self.arr[iNow] not in visited:\n#                 visited.add(self.arr[iNow])\n#                 numOfINow  = self.count(iNow, left)\n#                 if numOfINow >= threshold:\n#                     return self.arr[iNow]\n#                 else:\n#                     leftCandi -= numOfINow\n#             iNow -= 1\n#         return -1\n                \n#     def count(self, i0, l):\n#         if (i0, l) in self.dp:\n#             return self.dp[(i0,l)]\n#         if self.preIndexList[i0] == i0 or self.preIndexList[i0] < l:\n#             return 1\n#         self.dp[(i0,l)] = 1 + self.count(self.preIndexList[i0], l)\n#         return self.dp[(i0,l)]\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.numDict = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.numDict[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        leftCandi = right - left + 1\n        iNow = right\n        visited = set()\n        while leftCandi >= threshold:\n            if self.arr[iNow] not in visited:\n                visited.add(self.arr[iNow])\n                numOfINow  = self.count(iNow, left)\n                if numOfINow >= threshold:\n                    return self.arr[iNow]\n                else:\n                    leftCandi -= numOfINow\n            iNow -= 1\n        return -1\n    \n    def count(self, i0, left):\n        num = self.arr[i0]\n        listLen = len(self.numDict[num])\n        l = 0\n        r = listLen - 1\n        if i0 == self.numDict[num][r]:\n            right  = r\n        elif i0 == self.numDict[num][l]:\n            right = l\n        else:\n            while r > l:\n                m = (r + l) // 2\n                if self.numDict[num][m] < i0:\n                    l = m + 1\n                elif self.numDict[num][m] > i0:\n                    r = m\n                else:\n                    l = m\n                    r = l -1\n            right = l\n        l = 0 \n        r = right\n        if left <= self.numDict[num][l]:\n            return right + 1\n        if left == self.numDict[num][r]:\n            return 1\n        while r > l:\n            m = (r + l) // 2\n            if self.numDict[num][m] < left:\n                l = m + 1\n            elif self.numDict[num][m] > left:\n                r = m\n            else:\n                return right - m +1\n        return right- l + 1\n        \n        \n        \n    \n    \n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n\n# class MajorityChecker:\n\n#     def __init__(self, arr: List[int]):\n#         preIndexDict = {}\n#         arrLen = len(arr)\n#         self.preIndexList = [i for i in range(arrLen)]\n#         self.arr = arr\n#         for i, num in enumerate(arr):\n#             if num in preIndexDict:\n#                 self.preIndexList[i] = preIndexDict[num]\n#             preIndexDict[num] = i\n#         self.dp = {}\n\n#     def query(self, left: int, right: int, threshold: int) -> int:\n#         leftCandi = right - left + 1\n#         iNow = right\n#         visited = set()\n#         while leftCandi >= threshold:\n#             if self.arr[iNow] not in visited:\n#                 visited.add(self.arr[iNow])\n#                 numOfINow  = self.count(iNow, left)\n#                 if numOfINow >= threshold:\n#                     return self.arr[iNow]\n#                 else:\n#                     leftCandi -= numOfINow\n#             iNow -= 1\n#         return -1\n                \n#     def count(self, i0, l):\n#         if (i0, l) in self.dp:\n#             return self.dp[(i0,l)]\n#         if self.preIndexList[i0] == i0 or self.preIndexList[i0] < l:\n#             return 1\n#         self.dp[(i0,l)] = 1 + self.count(self.preIndexList[i0], l)\n#         return self.dp[(i0,l)]\n", "import collections\nclass StNode:\n    def __init__(self, left, right):\n        self.left = None\n        self.right = None\n        self.stats = None\n        self.vals = (left, right)\n\nclass St:\n    def __init__(self, arr):\n        self.arr = arr\n        self.root = self.build(0, len(arr)-1)\n    def build(self, i, j):\n        if i == j:\n            N = StNode(i,j)\n            N.stats = collections.Counter([self.arr[i]])\n            return N\n        \n        k = (i + j) >> 1\n        \n        N = StNode(i,j)\n        \n        N.left = self.build(i,k)\n        N.right = self.build(k+1,j)\n        \n        N.stats = N.left.stats + N.right.stats\n        \n        return N\n        \n    def retrieveLargestStats(self, i, j, t):\n        \n        R = self.root.stats.copy()\n        abort = False        \n        \n        def helper(node):\n            nonlocal abort, R, i, j, t\n            if abort:\n                return\n            if not R or max(R.values()) < t:\n                abort = True\n                R = dict()\n                return\n            \n            l,r = node.vals\n            \n            if i > r or l > j:\n                R -= node.stats\n                return\n            \n            if i <= l and r <= j:\n                return\n            \n            if l == r:\n                return\n            \n            helper(node.left)\n            helper(node.right)\n        \n        helper(self.root)\n        \n        if not R:\n            return -1\n        \n        m = max(R, key=lambda x:R[x])\n        return m if R[m] >=t else -1\n        \n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.ST = St(arr)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        return self.ST.retrieveLargestStats(left, right, threshold)\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import Counter\n\nclass Node(object):\n    '''\n    Node of the segment tree.  \n    \n    self.val = [i,j] where i and j are lower and upper bound indices in array (arr)\n    self.count = Counter(arr[i:j+1])  <-- keeps track of the frequency of each value in the range [i,j] inclusive\n    '''\n    def __init__(self,val):\n        self.val = val\n        self.count = None\n\nclass Segment_Tree(object):\n    def __init__(self, arr):\n        self.arr = arr\n        self.root = self.build(0,len(arr)-1)\n        \n    def build(self, i, j):\n        '''\n        constructs segment tree where each node has:\n        \n            1. a value of the index range [i,j] (inclusive) that it covers\n            2. a counter for how many times each number appears in the range [i,j]j\n            \n        *Note, self.root will look like:\n        \n            self.root.val = [0, len(arr) - 1]\n            self.root.count = Counter(arr)\n        '''\n        \n        if i == j:\n            node = Node([i,i])\n            node.count = Counter([self.arr[i]])\n            return node\n        \n        node = Node([i,j])\n        k = (i+j)>>1\n        node.left = self.build(i,k)\n        node.right = self.build(k+1,j)\n        \n        node.count = node.left.count + node.right.count\n        \n        return node\n        \n\n    def find_most_common(self, l, r, threshold):\n        '''\n        returns a tuple of (most common element, frequency) in the range l, r\n        where 0 <= l <= r < self.arr.length\n        \n        This is done as a subtraction process:\n        \n            1. res = self.root.count.copy()  <-- equivalent to Counter(arr)\n            2. subtract values from res for ranges that are not included in l, r\n            3. During this process, if the most frequent value in res ever occurs\n               less than treshold times, then trigger the sentinel to quit out\n            4. If a range [i,j] on the tree is completely contained within [l,r] inclusive\n               then do not subtract the values in A[i:j+1] from the result\n        '''\n        \n        res = self.root.count.copy()\n        \n        sentinel = False #3\n        \n        def helper(node):\n            nonlocal res, l, r, sentinel, threshold\n            \n            if sentinel: return None #3\n            \n            if (not res) or max(res.values()) < threshold: #3\n                #there is no solution so set res = {} and escape recursive function\n                sentinel = True\n                res = {} \n                return None\n\n            i, j = node.val\n            if (j < l) or (i > r): #2\n                #this node has only values that are OUTSIDE of [left,right] so subtract them from res\n                res -= node.count\n                return None\n            \n            if (l <= i) and (j <= r): #4\n                #this node has only values that are INSIDE of [left,right] so keep the values\n                return None\n\n            helper(node.left)\n            helper(node.right)\n        \n        helper(self.root)\n        most_common = max(res, key = lambda k: res[k]) if res else (-1,-1)\n        \n        return (most_common, res[most_common]) if res else most_common\n        \n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.tree = Segment_Tree(arr)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        #Find the value (val) that occurs the most frequently in range [left,right]\n        val, freq = self.tree.find_most_common(left, right, threshold)\n        return val if freq >= threshold else -1\n\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.prearr = [[] for _ in range(max(arr)+1)]\n        \n        for i in range (len(arr)):\n                self.prearr[arr[i]].append(i) \n            \n    def query(self, left: int, right: int, threshold: int) -> int:   \n        \n        def checkmajority (k):\n            \n            #find index of left element \n            lo = 0 \n            hi= len(self.prearr[k])-1\n            \n            while (lo<hi):\n                mid = lo +((hi-lo)//2)\n                \n                if (self.prearr[k][mid]>=left):\n                    hi = mid \n                    \n                else:\n                    lo = mid+1\n                    \n            start = lo\n            \n            #find index of right element \n            lo = 0 \n            hi = len(self.prearr[k])-1\n            \n            while(lo<hi):\n                mid = lo + ((hi-lo +1)//2)\n                \n                if(self.prearr[k][mid] <= right):\n                    lo = mid\n                else:\n                    hi = mid-1 \n            end = lo \n            \n            # return the difference between indexes between the preaar element and compare it with threshold \n            \n            if ((end - start +1) >= threshold): \n                return (True)\n            \n            else:\n                return (False)\n            \n            \n        #pick random element from arr 30-50 times and check if it is majority or not\n        \n        res = False\n        a = self.arr[left:right+1]\n        \n        for _ in range (15): \n            k = random.choice(a)\n            res = res or checkmajority(k)\n            \n            if (res):\n                return(k)\n        \n        return(-1)      \n        \n        \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, A):\n        a2i = collections.defaultdict(list)\n        for i, x in enumerate(A):\n            a2i[x].append(i)\n        self.a, self.a2i = A, a2i\n    \n        \n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        track = self.a2i\n                \n        l,r = left,right\n        \n        if((r-l+1) % 2 == 0):\n            mid = l-1 + (r-l+1)//2\n            \n        else:\n            mid = l + (r-l+1)//2\n            \n        \n        if((r-mid+1) % 2 == 0):\n            mid1 = mid-1 + (r-mid+1)//2\n            \n        else:\n            mid1 = mid + (r-mid+1)//2\n        \n        if((mid-l+1) % 2 == 0):\n            mid2 = l-1 + (mid-l+1)//2\n            \n        else:\n            mid2 = l + (mid-l+1)//2\n        \n        t1 = bisect.bisect_left(track[self.a[mid]],left)\n        t2 = bisect.bisect_right(track[self.a[mid]],right)\n        \n        if(t2-t1 >= threshold):\n            return self.a[mid]\n        \n        t1 = bisect.bisect_left(track[self.a[mid1]],left)\n        t2 = bisect.bisect_right(track[self.a[mid1]],right)\n        \n        if(t2-t1 >= threshold):\n            return self.a[mid1]\n        \n        t1 = bisect.bisect_left(track[self.a[mid2]],left)\n        t2 = bisect.bisect_right(track[self.a[mid2]],right)\n        \n        if(t2-t1 >= threshold):\n            return self.a[mid2]\n        \n        return -1\n        \n       \n                \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.prearr = [[] for _ in range(max(arr)+1)]\n        \n        for i in range (len(arr)):\n            try:\n                self.prearr[arr[i]].append(i) \n            except:\n                print((arr[i],len(self.prearr),max(arr)))\n            \n    def query(self, left: int, right: int, threshold: int) -> int:   \n        prearr = self.prearr\n        \n        def checkmajority (k):\n            \n            #find index of left element \n            lo = 0 \n            hi= len(prearr[k])-1\n            \n            while (lo<hi):\n                mid = lo +((hi-lo)//2)\n                \n                if (prearr[k][mid]>=left):\n                    hi = mid \n                    \n                else:\n                    lo = mid+1\n                    \n            start = lo\n            \n            #find index of right element \n            lo = 0 \n            hi = len(prearr[k])-1\n            \n            while(lo<hi):\n                mid = lo + ((hi-lo +1)//2)\n                \n                if(prearr[k][mid] <= right):\n                    lo = mid\n                else:\n                    hi = mid-1 \n            end = lo \n            \n            # return the difference between indexes between the preaar element and compare it with threshold \n            \n            if ((end - start +1) >= threshold): \n                return (True)\n            \n            else:\n                return (False)\n            \n            \n        #pick random element from arr 30-50 times and check if it is majority or not\n        \n        res = False\n        a = self.arr[left:right+1]\n        \n        for _ in range (20): \n            k = random.choice(a)\n            res = res or checkmajority(k)\n            \n            if (res):\n                return(k)\n        \n        return(-1)      \n        \n        \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import Counter, defaultdict\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.dic = defaultdict()\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        if (left,right) in self.dic:\n            if self.dic[(left, right)][1] >= threshold:\n                return self.dic[(left, right)][0]\n            else:\n                return -1\n        sub = self.arr[left:right + 1]\n        dic = Counter(sub)\n        sum_f = 0\n        for ele, freq in list(dic.items()):\n            if freq >= threshold:\n                self.dic[(left, right)] = (ele, freq)\n                return ele\n            sum_f += freq\n            if sum_f > threshold:\n                return -1\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.prearr = [[] for _ in range(max(arr)+1)]\n        \n        for i in range (len(arr)):\n                self.prearr[arr[i]].append(i) \n            \n    def query(self, left: int, right: int, threshold: int) -> int:   \n        \n        def checkmajority (k):\n            \n            #find index of left element \n            lo = 0 \n            hi= len(self.prearr[k])-1\n            \n            while (lo<hi):\n                mid = lo +((hi-lo)//2)\n                \n                if (self.prearr[k][mid]>=left):\n                    hi = mid \n                    \n                else:\n                    lo = mid+1\n                    \n            start = lo\n            \n            #find index of right element \n            lo = 0 \n            hi = len(self.prearr[k])-1\n            \n            while(lo<hi):\n                mid = lo + ((hi-lo +1)//2)\n                \n                if(self.prearr[k][mid] <= right):\n                    lo = mid\n                else:\n                    hi = mid-1 \n            end = lo \n            \n            # return the difference between indexes between the preaar element and compare it with threshold \n            \n            if ((end - start +1) >= threshold): \n                return (True)\n            \n            else:\n                return (False)\n            \n            \n        #pick random element from arr 30-50 times and check if it is majority or not\n        \n        res = False\n        a = self.arr[left:right+1]\n        \n        for _ in range (20): \n            k = random.choice(a)\n            res = res or checkmajority(k)\n            \n            if (res):\n                return(k)\n        \n        return(-1)      \n        \n        \n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import random\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.fre = {i:[] for i in set(arr)}\n        for i in range(len(arr)):\n            self.fre[arr[i]].append(i)\n\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(50):\n            i = left + random.randint(0,right-left)\n            low = self.bsl(self.fre[self.arr[i]],left)\n            high = self.bsr(self.fre[self.arr[i]],right)\n            if low == -1 or high == -1:\n                continue\n            if high-low+1>=threshold:\n                return self.arr[i]\n        return -1\n\n    def bsl(self,arr,n):\n        low = 0\n        high = len(arr)-1\n        while low < high:\n            mid = low+(high-low)//2\n            if arr[mid]>=n:\n                high = mid\n            else:\n                low = mid+1\n        if arr[low] >= n:\n            return low\n        return -1\n\n    def bsr(self,arr,n):\n        low = 0\n        high = len(arr)-1\n        while low < high:\n            mid = low+(high-low+1)//2\n            if arr[mid]>n:\n                high = mid-1\n            else:\n                low = mid\n        if arr[low] <= n:\n            return low\n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "import random\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.fre = {i:[] for i in set(arr)}\n        for i in range(len(arr)):\n            self.fre[arr[i]].append(i)\n\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(50):\n            i = left + random.randint(0,right-left)\n            low = self.bs(self.fre[self.arr[i]],left)\n            if self.fre[self.arr[i]][low] < left:\n                low +=1\n            high = self.bs(self.fre[self.arr[i]],right)\n            if high-low+1>=threshold:\n                return self.arr[i]\n        return -1\n    \n    def bs(self,arr,n):\n        low = 0\n        high = len(arr)-1\n        while low < high:\n            mid = low+(high-low+1)//2\n            if arr[mid]<=n:\n                low = mid\n            else:\n                high = mid-1\n        return low\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "from collections import Counter\nclass Node:\n    def __init__(self, l, r, num, time, left=None, right=None):\n        self.l = l\n        self.r = r\n        self.num = num\n        self.time = time\n        self.left = left\n        self.right = right\n    \n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.t = self.build(0, len(arr)-1)\n    \n    def build(self, l, r):\n        if l == r:\n            return Node(l, r, self.arr[l], 1)\n        \n        mid = (r+l)//2\n        num, time = -1, 0\n        ln, rn = self.build(l, mid), self.build(mid+1, r)\n        for n in [ln, rn]:\n            if n:\n                if n.num == num:\n                    time += n.time\n                else:\n                    if time > n.time:\n                        time -= n.time\n                    else:\n                        num = n.num\n                        time = n.time - time\n                    \n        return Node(l, r, num, time, ln, rn)\n    \n    def trange(self, l, r, n):\n        if l > r:\n            return (-1, 0)\n        \n        if l == n.l and r == n.r:\n            return (n.num, n.time)\n        \n        mid = (n.r + n.l) // 2\n        if r < mid:\n            return self.trange(l, r, n.left)\n        elif l > mid:\n            return self.trange(l, r, n.right)\n        \n        num, time = -1, 0\n        for n, t in [self.trange(l, mid, n.left), self.trange(mid+1, r, n.right)]:\n            if n == num:\n                time += t\n            else:\n                if time > t:\n                    time -= t\n                else:\n                    num = n\n                    time = t - time\n        return num, time\n\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        x, _ = self.trange(left, right, self.t)\n        if self.arr[left:right+1].count(x) >= threshold:\n            return x\n        return -1\n", "from collections import Counter\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.min_arr_len = len(arr) // 2\n        self.main = Counter(arr)\n        self.subarrs = {}\n        max_repeats = max(self.main.values())\n        max_idx = list(self.main.values()).index(max_repeats)\n        self.rets = {(0, len(arr)-1): (max_repeats,\n                                       list(self.main.keys())[max_idx])}\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        # check if return value has already been calculated\n        if (left, right) in self.rets:\n            if self.rets[(left, right)][0] >= threshold:\n                print(\\\"Getting return val from cache...\\\")\n                return self.rets[(left, right)][1]\n\n        targarr = self.arr[left:right+1]\n        if len(targarr) > self.min_arr_len:\n            # count the new sub-array using main counter\n            # this should always be less than O(n)\n            self.subarrs[left] = {right: self.main.copy()} \n            if left > 0:\n                for num in self.arr[0:left]:\n                    self.subarrs[left][right][num] -= 1\n            if right < len(self.arr) - 1:\n                for num in self.arr[right+1:]:\n                    self.subarrs[left][right][num] -= 1\n        else:\n            # try to create subarray from existing array\n            if left in self.subarrs:\n                largest = max(self.subarrs[left].keys())\n                min_len = ((largest + 1) - left) // 2\n                if len(targarr) < (largest+1)-left and len(targarr) > min_len:\n                    self.subarrs[left][right] = self.subarrs[left][largest]\n                    for num in self.arr[right+1:largest+1]:\n                        self.subarrs[left][right][num] -= 1\n                else:\n                    self.subarrs[left][right] = Counter(targarr)\n            else:\n                self.subarrs[left] = {right: Counter(targarr)}\n            \n        # get the most repeated number and the no. of repeats\n        subarr_vals = list(self.subarrs[left][right].values())\n        max_repeats = max(subarr_vals)\n        max_idx = subarr_vals.index(max_repeats)\n        repeat_num = list(self.subarrs[left][right].keys())[max_idx]\n        # save result\n        self.rets[(left, right)] = (max_repeats, repeat_num)\n        \n        if self.rets[(left, right)][0] >= threshold:\n            return self.rets[(left, right)][1]\n        \n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)", "from bisect import bisect_left, bisect_right\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.dic = defaultdict(list)\n        for i,e in enumerate(arr):\n            self.dic[e].append(i)\n        self.nums = sorted(self.dic, key=lambda x:len(self.dic[x]), reverse=True)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        # try all nums\n        # 1 2 4 6\n        # 1 4\n        # see how many times each appears in range\n        for num in self.nums:\n            # find where first and last occurrence are\n            entry = self.dic[num]\n            if len(entry) < threshold:\n                return -1\n            l, r = bisect_left(entry, left), bisect_right(entry, right)\n            if r-l >= threshold:\n                return num\n        return -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        \n        self.idx = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            self.idx[a].append(i)\n        \n        print((self.idx))\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \n        for k,v in list(self.idx.items()):\n            l = bisect.bisect_left(v, left)\n            r = bisect.bisect_right(v, right)\n            if r-l >= threshold:\n                return k\n        \n        return -1\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.n = len(arr)\n        self.counts = [Counter() for _ in range(self.n * 2)]\n        for i, num in enumerate(arr):\n            self.counts[i + self.n][num] += 1\n        for i in range(self.n)[::-1]:\n            self.counts[i] = self.counts[i*2] + self.counts[i*2 + 1]\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        left += self.n\n        right += self.n + 1\n        c = Counter()\n        while left < right:\n            if left % 2 == 1:\n                c += self.counts[left]\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                c += self.counts[right]\n            right //= 2\n            left //= 2\n        topcount, topnum = max((ct, num) for num, ct in list(c.items()))\n        return topnum if topcount >= threshold else -1\n                \n        \n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n"]
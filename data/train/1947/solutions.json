["class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = set(A)\n        letters_required = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in letters_required or count > letters_required[j]:\n                    letters_required[j] = count\n\n        for i in A:\n            for j in letters_required:\n                if i.count(j) < letters_required[j]:\n                    s.remove(i)\n                    break\n        return list(s)", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ans=[]\n        word={}\n        for i in B:\n            for j in i:\n                if(j not in word):\n                    word[j]=i.count(j)\n                else:\n                    if(i.count(j)>word[j]):\n                        word[j]=i.count(j)\n                        \n        \n      \n        \n        for i in A:\n            x=0\n            for k in word:\n                if(word[k]>i.count(k)):\n                    x=1\n                    break;\n                \n            if(x!=1):\n                \n                ans.append(i)        \n               \n            \n                \n                   \n                        \n                    \n                        \n             \n                    \n                 \n         \n              \n                \n              \n                    \n        return ans               \n       \n               \n                  \n                      \n\n                        \n                        \n            \n", "class Solution(object):\n    def wordSubsets(self, A, B):\n        \\\"\\\"\\\"\n        :type A: List[str]\n        :type B: List[str]\n        :rtype: List[str]\n        \\\"\\\"\\\"\n        s = set(A)\n        letters_required = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in letters_required or count > letters_required[j]:\n                    letters_required[j] = count\n\n        for i in A:\n            for j in letters_required:\n                if i.count(j) < letters_required[j]:\n                    s.remove(i)\n                    break\n        return list(s)", "from collections import Counter as di\nclass Solution:\n    def wordSubsets(self, a: List[str], b: List[str]) -> List[str]:\n        d = di()\n        ans = list()\n        for i in b:\n            d2 = di(i)\n            for k, v in d2.items():\n                if d[k] < d2[k]:\n                    d[k] = v\n        \n        for i in a:\n            if len(d - di(i)) == 0:\n                ans.append(i)\n        return ans", "from collections import Counter \n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = Counter()\n        for b in B: \n            s = s | Counter(b)\n            \n        words = []\n        def is_universal(word: str):\n            word_counts = Counter(word)\n            if len(word) < len(s): \n                return False\n            for k, v in list(s.items()): \n                if k not in word_counts: \n                    return False \n                if word_counts[k] < v: \n                    return False \n            return True\n        \n        for word in A: \n            if is_universal(word): \n                words.append(word)\n        \n        return words\n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        subset = reduce(operator.or_, (Counter(w) for w in B))\n        return [a for a in A if all(a.count(c) >= subset[c] for c in subset.keys())]", "from collections import Counter\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        h = {}\n        for word in B:\n            temp = Counter(word)\n            for key, value in temp.items():\n                if key not in h:\n                    h[key] = value\n                else:\n                    h[key] = max(h[key], value)\n        res = []\n        for word in A:\n            temp = Counter(word)\n            suitable = True\n            for key, value in h.items():\n                if not (key in temp and value <= temp[key]):\n                    suitable = False\n                    break\n            if suitable:\n                res.append(word)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        if len (B) == 0:\n            return A\n        \n        from collections import Counter\n        \n        cb = Counter()\n        for b in B:\n            for char in b:\n                cb[char] = max (cb[char], b.count(char))\n\n        res = []    \n        for a in A:\n            \n            if all (a.count (c) >= cb[c] for c in cb.keys()):\n                res.append (a)\n        \n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        max_set = {}\n        result = []\n        \n        for i in B:\n            for char in i:\n                if char not in max_set:\n                    max_set[char] = i.count(char)\n                else:\n                    max_set[char] = max(i.count(char), max_set[char])\n        \n        for word in A:\n            flag = True\n            for char in max_set:\n                if word.count(char) < max_set[char]:\n                    flag = False\n                    break\n            if flag:\n                result.append(word)\n            else:\n                pass\n            \n        \n        return result\n                    \n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = set()\n        B_count = Counter()\n        for b in B:\n            word_count = Counter(b)\n            for c, v in word_count.items():\n                B_count[c] = max(B_count[c], v)\n        for a in A:\n            if len(B_count - Counter(a)) == 0:\n                res.add(a)\n        return list(res)", "class Solution:\n    \n    def subset(self, a,b):\n        base = [0] * 26\n        i = 0\n        while i < len(a) or i < len(b):\n            if i < len(a) and i < len(b):\n                base[ord(a[i])-97] -= 1\n                base[ord(b[i])-97] += 1\n            elif i < len(a):\n                base[ord(a[i])-97] -= 1\n            else: return False\n            i += 1\n        \n        for c in base:\n            if c > 0: return False\n        \n        return True\n    \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        B = list(set(B))\n        base = [0] * 26\n        for b in B:\n            cur = [0]*26\n            for c in b:\n                cur[ord(c)-97] += 1\n            for i in range(len(base)):\n                base[i] = max(base[i], cur[i])\n        \n        ret = []\n        for a in A:\n            cur = [0]*26\n            for c in a:\n                cur[ord(c)-97] += 1\n            add = True\n            for i in range(len(base)):\n                if base[i] > cur[i]:\n                    add = False\n                    break\n            if add: ret.append(a)\n        \n        return ret\n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ctr = collections.Counter()\n        for word in B:\n            ctr2 = collections.Counter(word)\n            # ctr.setdefault()\n            for key, val in ctr2.items():\n                ctr[key] = max(val, ctr[key])\n        ctr3 = collections.Counter()\n        # for key, val in collections.Counter(\n        res = []\n        for w in A:\n            ctr3 = collections.Counter(w)\n            newCtr = collections.Counter()\n            for key, val in ctr3.items():\n                if key in ctr:\n                    newCtr[key] = min(val, ctr[key])\n            if newCtr == ctr:\n                res.append(w)\n        return res", "from collections import defaultdict\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_dict = defaultdict(int)\n        for word in B:\n            curr = defaultdict(int)\n            for char in word:\n                curr[char] += 1\n            for char in curr:\n                b_dict[char] = max(b_dict[char], curr[char])\n        \n        universal = []\n        for word in A:\n            curr = defaultdict(int)\n            for char in word:\n                curr[char] += 1\n            \n            is_subset = True\n            for char in b_dict:\n                if char not in curr or curr[char] < b_dict[char]:\n                    is_subset = False\n                    break\n            if is_subset:\n                universal.append(word)\n                \n        return universal\n    \n        # len(A) = n, len(B) = m, word len = 10, time: 10m + 10n + 26 = O(m + n)\n    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ans=[]\n        word={}\n        for i in B:\n            for j in set(i):\n                c = i.count(j)\n                if(j not in word):\n                    word[j]=c\n                else:\n                    if(c>word[j]):\n                        word[j]=c\n                        \n        for i in A:\n            x=0\n            for k in word:\n                if(word[k]>i.count(k)):\n                    x=1\n                    break;\n                \n            if(x!=1):\n                ans.append(i)\n            \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cnt = collections.Counter\n        bCnt = cnt()\n        for b in B:\n            bCnt |= cnt(b)\n        return [a for a in A if not (bCnt - cnt(a))]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # 1)\n        i, A2, seen = 0, [], set()\n        while i < len(A):\n            if A[i] not in seen:\n                seen.add(A[i])\n                dct = {}\n                for char in A[i]:\n                    if char in dct:\n                        dct[char] += 1\n                    else:\n                        dct[char] = 1\n                A2.append(dct)\n                i += 1\n            else:\n                A.pop(i)\n                \n        i, seen = 0, set()\n        while i < len(B):\n            if B[i] not in seen:\n                seen.add(B[i])\n                dct = {}\n                for char in B[i]:\n                    if char in dct:\n                        dct[char] += 1\n                    else:\n                        dct[char] = 1\n                B[i] = dct\n                i += 1\n            else:\n                B.pop(i)\n        \n        # 2) merge all the dicts of B into one dict\n        while len(B) > 1:\n            for key in B[1]:\n                if key in B[0]:\n                    B[1][key] = max(B[1][key], B[0][key])\n            for key in B[0]:\n                if key not in B[1]:\n                    B[1][key] = B[0][key]\n            B.pop(0)\n        B_dct = B[0]\n        \n        # 3)\n        ans, A_len, B_len = [], len(A), len(B)\n        for i in range(A_len):\n            isSubset = True\n            for key in B_dct:\n                if key not in A2[i] or (key in A2[i] and B_dct[key] > A2[i][key]):\n                    isSubset = False\n                    break\n            if isSubset:\n                ans.append(A[i])\n        return ans", "import collections\n\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_cnt = collections.Counter()\n        for b in B:\n            b_cnt |= collections.Counter(b)\n            \n        res = []\n        for a in A:\n            if collections.Counter(a) & b_cnt == b_cnt:\n                res.append(a)\n        return res", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        subset = Counter()\n        for b in B:\n            for k, v in Counter(b).items():\n                subset[k] = max(subset[k], v)\n        result = filter(lambda a: True if not subset-Counter(a) else False, A)\n        return list(result)", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n\n        w1_set = {}\n        for word in B:\n            new_w1_set = {}\n            for c in word:\n                if c not in new_w1_set:\n                    new_w1_set[c] = 0\n                new_w1_set[c] += 1\n                \n            for c in new_w1_set:\n                if c not in w1_set:\n                    w1_set[c] = new_w1_set[c]\n                else:\n                    w1_set[c] = max(w1_set[c], new_w1_set[c])\n        \n        output = []\n        for word in A:\n            w2_set = {}\n            for c in word:\n                if c not in w2_set:\n                    w2_set[c] = 0\n                w2_set[c] += 1\n            \n            check = True\n            for c in w1_set:\n                if (c not in w2_set) or (w1_set[c] > w2_set[c]):\n                    check = False\n                    break\n            \n            if check:\n                output.append(word)\n            \n        return output\n", "import collections\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def aggregate_b(B):\n            max_occurences = collections.defaultdict(list)\n            for subset in B:\n                letter_count = collections.Counter(subset)\n                for letter, count in list(letter_count.items()):\n                    if not max_occurences[letter] or count > max_occurences[letter]:\n                        max_occurences[letter] = count\n            return max_occurences\n\n        result = []\n        max_letter_occurences = aggregate_b(B)\n        for word in A:\n            letter_count = max_letter_occurences.copy()\n            for letter in word:\n                if letter in letter_count:\n                    letter_count[letter] -= 1\n                    if letter_count[letter] == 0:\n                        del letter_count[letter]\n            if not letter_count:\n                result.append(word)\n                \n        return result\n\n\n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        total_count_B = Counter()\n        for s in B:\n            total_count_B |= Counter(s)\n                    \n        return [a for a in A if Counter(a) & total_count_B == total_count_B]\n            \n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_hash = {}\n        ans = []\n        for i in B:\n            for j in set(i):\n                if j in b_hash:\n                    b_hash[j] = max(i.count(j), b_hash[j])\n                else:\n                    b_hash[j] = i.count(j)\n        \n        for wrd in A:\n            new_b_hash = b_hash.copy()\n            for i in set(wrd):\n                if i in b_hash:\n                    new_b_hash[i] -= wrd.count(i)\n            value_flag = True\n            for i in list(new_b_hash.values()):\n                if i > 0:\n                    value_flag = False\n                    break\n            if value_flag:\n                ans.append(wrd)                \n            \n        return ans\n                \n                    \n            \n\n        \n", "from collections import Counter\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        universal_words = []\n        required_counts = {}\n        for pattern in B:\n            for char in pattern:\n                char_sum = sum(1 for i in pattern if i == char)\n                if char not in required_counts or required_counts[char] < char_sum:\n                    required_counts[char] = char_sum\n        print(required_counts)\n        for word in A:\n            universal = True\n            for char in required_counts:\n                char_count = sum(1 for i in word if i == char)\n                if char_count < required_counts[char]:\n                    universal = False\n            if universal:\n                universal_words.append(word)\n        return universal_words", "from collections import Counter\n\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \\\"\\\"\\\"\n        https://leetcode.com/problems/word-subsets/discuss/175854/C%2B%2BJavaPython-Straight-Forward\n        \\\"\\\"\\\"\n\n        count = Counter()\n\n        for b in B:\n            count |= Counter(b)\n\n        return [a for a in A if (Counter(a) & count) == count]\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ans=[]\n        word={}\n        for i in B:\n            for j in set(i):\n                if(j not in word):\n                    word[j]=i.count(j)\n                else:\n                    if(i.count(j)>word[j]):\n                        word[j]=i.count(j)\n                        \n        for i in A:\n            x=0\n            for k in word:\n                if(word[k]>i.count(k)):\n                    x=1\n                    break;\n                \n            if(x!=1):\n                ans.append(i)\n            \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        lc = [0] * 26\n        for b in B:\n            for c, count in collections.Counter(b).items():\n                i = ord(c) - ord('a')\n                lc[i] = max(lc[i], count)\n        ans = []\n        \n        for a in A:\n            uni = True\n            cter = collections.Counter(a)\n            for c, count in zip(string.ascii_lowercase, lc):\n                if count > cter[c]:\n                    uni = False\n                    break\n            if uni:\n                ans.append(a)\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        answer = list()\n        b_counter = collections.Counter()\n        for word in B:\n            counter = collections.Counter(word)\n            for letter, count in counter.items():\n                b_counter[letter] = max(b_counter[letter], count)\n\n        for word in A:\n            counter = collections.Counter(word)\n            if all(l in counter and counter[l] >= count for l, count in b_counter.items()):\n                answer.append(word)\n        \n        return answer", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        from collections import Counter\n        \n        freq = {word: Counter(word) for word in A}\n        queries = {word: Counter(word) for word in B}\n        query = {chr(i): max(queries[word].get(chr(i), 0) for word in queries) for i in range(ord('a'), ord('z') + 1)}\n        \n        ans = set()\n        \n        for k in list(freq.keys()):\n            flag = 1\n            for ch in query:\n                if query[ch] > freq[k].get(ch, 0):\n                    flag = 0\n                    break\n            \n            if flag: ans.add(k)\n        \n        return list(ans)\n            \n            \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # So we don't process the same word twice\n        seen = set()\n        # Freq of union of all words in B\n        freq_B = [0] * 26\n        for word in B:\n            if word not in seen:\n                seen.add(word)\n\n                freq_cur = [0] * 26\n                for c in word:\n                    freq_cur[ord(c)-ord('a')] += 1\n\n                for i in range(26):\n                    freq_B[i] = max(freq_B[i], freq_cur[i])\n\n        ans = []\n        for word in A:\n            freq_A = [0] * 26\n            for c in word:\n                freq_A[ord(c)-ord('a')] += 1\n\n            broke_early = False\n            for i in range(26):\n                if freq_A[i] < freq_B[i]:\n                    broke_early = True\n                    break\n            if broke_early:\n                continue\n            ans += [word]\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_union_ctr = Counter()\n        for b_element in B:\n            b_union_ctr |= Counter(b_element)\n        output = []\n        for a_element in A:\n            a_count = Counter(a_element)\n            if len(b_union_ctr - a_count) == 0:\n                output.append(a_element)\n        return output\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # Combine counts in B to save time\n        count = collections.Counter()\n        for b in B:\n            # | keeps bigger number\n            count |= collections.Counter(b)\n        return [a for a in A if (Counter(a) & count) == count]", "from functools import reduce\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cntB = [Counter(b) for b in B]\n        sumB = reduce(lambda x, y: x | y, cntB)\n        ans = []\n        for a in A:\n            cnt = Counter(a)\n            if all(sumB[s] <= cnt[s] for s in sumB):\n                ans.append(a)\n        return ans\n", "from collections import Counter\n\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        if len(B) == 0:\n            return []\n        ans = []\n        ca = [Counter(a) for a in A]\n        cb = Counter(B[0])\n        for i in range(1, len(B)):\n            lb = Counter(B[i])\n            for c in lb:\n                cb[c] = max(cb[c], lb[c])\n            \n        for i in range(len(A)):\n            isUniv = True\n            if len(cb - ca[i]) > 0:\n                continue\n            ans.append(A[i])\n        return ans\n                \n", "class Solution:\n    def issubset(self, s: str, t:str) -> bool:\n        dic = dict()\n        for i in range(len(t)):\n            dic[t[i]] = dic.get(t[i],0) + 1\n        result = True\n        i = 0\n        while (i < len(s)) and result:\n            if (s[i] not in list(dic.keys())) or (dic[s[i]] < 1):\n                result = False\n            else:\n                dic[s[i]] -= 1\n                i += 1\n                \n        return result\n    \n    def joining(self, B: List[str]) -> str:\n        result = dict()\n        for i in range(len(B)):\n            word = B[i]\n            temp = dict()\n            for j in range(len(word)):\n                temp[word[j]] = temp.get(word[j],0) + 1\n                \n            for (k,v) in list(temp.items()):\n                if (k not in list(result.keys())) or (result[k] < v):\n                    result[k] = v\n                    \n        res = ''\n        for (k,v) in list(result.items()):\n            res += k*v\n        return res\n            \n        \n                \n                \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        union = self.joining(B)\n        for word in A:\n            if self.issubset(union,word) == True:\n                res.append(word)\n                \n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        maxcb = Counter()\n        for b in B:\n            maxcb |= Counter(b)\n        return [a for a in A if Counter(a) & maxcb == maxcb]     \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        dic = {}\n        out = []\n        \n        for word in B:\n            dicWord = {}\n            for letter in word:\n                if not letter in dicWord:\n                    dicWord[letter] = 1\n                else:\n                    dicWord[letter] += 1\n            for letter in dicWord:\n                if not letter in dic:\n                    dic[letter] = dicWord[letter]\n                else:\n                    dic[letter] = max(dic[letter], dicWord[letter])\n                    \n        for word in A:\n            dicWord = {}\n            universal = True\n            for letter in word:\n                if letter in dicWord:\n                    dicWord[letter] += 1\n                else:\n                    dicWord[letter] = 1\n            \n            for letter in dic:\n                if not letter in dicWord:\n                    universal = False\n                    break\n                if dic[letter] > dicWord[letter]:\n                    universal = False\n                    break                    \n                        \n            if not universal:\n                continue\n            else:\n                out += [word]\n        \n        return out\n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        need = Counter()\n        \n        for word in B:\n            word_count = Counter(word)\n            for k, v in list(word_count.items()):\n                need[k] = max(need[k], v)\n\n        def is_subset(word):\n            word_count = Counter(word)\n            needed = need.copy()\n            \n            for c in need:\n                word_count[c] -= needed[c]\n                if word_count[c] < 0:\n                    return False\n            \n            return True\n            \n        res = []\n        for word in A:\n            if is_subset(word):\n                res.append(word)\n        \n        return res\n\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        max_b = [0] * 26\n        for i in range(len(B)):\n            local_b = [0] * 26\n            for c in B[i]:\n                local_b[ord(c) - 97] += 1\n            for i in range(26):\n                max_b[i] = max(max_b[i], local_b[i])\n        for i in range(len(A)):\n            local_a = [0] * 26\n            for c in A[i]:\n                local_a[ord(c) - 97] += 1\n            for k in range(26):\n                if local_a[k] < max_b[k]:\n                    break\n                if k == 25:\n                    res.append(A[i])\n        return res", "class Solution:\n    def wordSubsets(self, A: 'List[str]', B: 'List[str]') -> 'List[str]':\n        def count(word):\n            ans = [0] * 26\n            for c in word:\n                ans[ord(c) - ord('a')] += 1\n            return ans\n        \n        # simplify B\n        bmax = [0] * 26\n        for b in B:\n            ls = count(b)\n            for i in range(26):\n                bmax[i] = max(bmax[i], ls[i])\n        \n        ans = []\n        for a in A:\n            ls = count(a)\n            for i in range(26):\n                if ls[i] < bmax[i]:\n                    break\n            else: # execute if the for-loop ends without break\n                ans.append(a)\n        return ans", "from collections import Counter\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        c = Counter()\n        for b in B:\n            c = c | Counter(b)\n            \n        return [a for a in A if Counter(a) & c == c]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_representation = [0]*26\n        \n        def str2list(s):\n            li = [0]*26\n            for c in s:\n                li[ord(c)-ord('a')] +=1\n            return li\n        \n        def is_greater(li1, li2):\n            for i in range(26):\n                if li1[i] < li2[i]:\n                    return False\n            return True\n        \n        for s in B:\n            b_representation = [max(tmp1, tmp2) for tmp1, tmp2 in zip(b_representation, str2list(s))]\n        res = []\n        for s in A:\n            if is_greater(str2list(s),b_representation):\n                res.append(s)\n            \n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ret = []\n        bx=Counter()\n        for ib in B:\n            bx |= Counter(ib)\n        \n        for ia in A:\n            cx=Counter(ia) & bx\n            if(cx == bx):\n                ret.append(ia)\n        \n        return ret", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        counter = [0]*26\n        res = []\n        \n        for b in B:\n            temp = [0]*26\n            \n            for c in b:\n                temp[ord(c)-ord('a')] += 1\n                \n            for i in range(26):\n                counter[i] = max(counter[i], temp[i])\n\n        for a in A:\n            temp = [0]*26\n            \n            for c in a:\n                k = ord(c)-ord('a')\n                temp[k] += 1\n            \n            \n            for i in range(26):\n                if temp[i]<counter[i]:\n                    break\n            else:\n                res.append(a)\n                \n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        universal = Counter()\n        for b in B:            \n            universal |= Counter(b)\n        \n        ans = []\n        for a in A:\n            c = Counter(a)\n            c.subtract(universal)\n            if all(v >= 0 for v in c.values()):\n                ans.append(a)\n        \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        universal = Counter()\n        for b in B:            \n            universal |= Counter(b)\n            # for char, count in Counter(b).items():\n            #     universal[char] = max(universal[char], count)\n        \n        ans = []\n        for a in A:\n            c = Counter(a)\n            c.subtract(universal)\n            if all(v >= 0 for v in c.values()):\n                ans.append(a)\n        \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cnt = [0] * 26\n        for b in B:\n            cnt1 = [0] * 26\n            for c in b:\n                cnt1[ord(c) - 97] += 1\n            for i, j in enumerate(cnt1):\n                cnt[i] = max(cnt[i], j)\n        result = []\n        for a in A:\n            cnt1 = [0] * 26\n            for c in a:\n                cnt1[ord(c) - 97] += 1\n            if all(j <= cnt1[i] for i, j in enumerate(cnt)):\n                result.append(a)\n        return result        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        temp = {}\n        require = {}\n        universal = []\n        for b in B:\n            temp.clear()\n            for c in b:\n                if c in temp:\n                    temp[c] += 1\n                else:\n                    temp[c] = 1\n            for k in temp:\n                if k not in require or require[k] < temp[k]:\n                    require[k] = temp[k]\n        \n        for a in A:\n            toAdd = True\n            temp.clear()\n            for c in a:\n                if c in temp:\n                    temp[c] += 1\n                else:\n                    temp[c] = 1\n            for k in require:\n                if k not in temp or require[k] > temp[k]:\n                    toAdd = False\n                    break\n            if toAdd:\n                universal.append(a)\n            \n        \n        return universal", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        res = []\n        bwdict = Counter(B[0])\n        for bw in B[1:]:\n            tmpCounter = Counter(bw)\n            for key,val in list(tmpCounter.items()):\n                wcnt = bwdict.get(key,-1)\n                if val > wcnt:\n                    bwdict[key] = val\n        print(bwdict)\n            \n        for word in A:\n            tmpW = (word + '.')[:-1]\n            wdict = Counter(word)\n            isSub = []\n            for key,val in list(bwdict.items()):\n                wcnt = wdict.get(key,-1)\n                if val <= wcnt:\n                    isSub.append(True)\n                else:\n                    isSub.append(False)\n            if all(isSub):\n                res.append(word)\n                \n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        if not A:\n            return []\n        word_map_B = self.createMapWordB(B)\n        res = []\n        \n        for word in A:\n            if self.searchWord(word, word_map_B):\n                res.append(word)\n        return res\n    \n    def createMapWordB(self, B):\n        # Simplify B to be the combination of all letters\n        max_B = [0] * 26\n        for b in B:\n            temp_B = self.createSingleWordCount(b)\n            for i in range(26):\n                max_B[i] = max(max_B[i], temp_B[i])\n        return max_B\n        \n    def createSingleWordCount(self, word):\n        res = [0] * 26\n        for c in word:\n            idx = ord(c) - ord('a')\n            res[idx] += 1\n        return res\n        \n    def searchWord(self, word, max_B):\n        word_count = self.createSingleWordCount(word)\n        for i in range(26):\n            if word_count[i] < max_B[i]:\n                return False\n        return True", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = collections.Counter()\n        for b in B:\n            count = count | collections.Counter(b)\n        return [a for a in A if Counter(a) & count == count]\n            \n", "from functools import reduce\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        alphabet = reduce(lambda x, y: Counter(y) | x, B, Counter())\n        return [a for a in A if (Counter(a) & alphabet) == alphabet]\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            ans = [0] * 26\n            for c in word:\n                ans[ord(c) - ord('a')] += 1\n            return ans\n        \n        # simplify B\n        bmax = [0] * 26\n        for b in B:\n            ls = count(b)\n            for i in range(26):\n                bmax[i] = max(bmax[i], ls[i])\n        \n        ans = []\n        for a in A:\n            ls = count(a)\n            for i in range(26):\n                if ls[i] < bmax[i]:\n                    break\n            else: # execute if the for-loop ends without break\n                ans.append(a)\n        return ans\n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        b_word = [0] * 26\n        \n        for word in B:\n            for idx, count in enumerate(self.create_char_set(word)):\n                b_word[idx] = max(b_word[idx], count)\n        \n        for word in A:\n            a_word = self.create_char_set(word)\n            idx = 0\n            while idx < len(b_word) and a_word[idx] >= b_word[idx]:\n                idx += 1\n            if idx == len(b_word):\n                res.append(word)\n                \n        return res\n        \n        \n    \n    def create_char_set(self, word):\n        char_set = [0] * 26\n        for char in word:\n            char_set[ord(char) - ord('a')] += 1\n        return char_set\n", "class Solution:\n    def wordSubsets(self, A, B):\n        def count_word(word):\n            a = [0] * 26\n            \n            for c in word:\n                a[ord(c) - ord(\\\"a\\\")] += 1\n            \n            return a\n        \n        max_count = [0] * 26\n        \n        for w in B:\n            cur_count = count_word(w)\n            max_count = [max(cur_count[i], max_count[i]) for i in range(len(cur_count))]\n            \n        ans = []\n        for w in A:\n            if all(x>=y for x,y in zip(count_word(w), max_count)):\n                ans.append(w)\n        \n        return ans", "class Solution(object):\n    def wordSubsets(self, A, B):\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n        return ans", "from collections import defaultdict\n\nclass Solution:\n    \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        result=[]\n        if not A :\n            return result\n        if not B:\n            return A\n        C=[]\n        for j in B:\n                d=[0]*26    \n                for ch in j:\n                    d[ord(ch)-ord('a')]+=1\n                C.append(d) \n        l=[0]*26\n        # print(C)\n        for j in C:\n            for i in range(26):\n                l[i]=max(l[i],j[i])\n        # print(l)\n\n        \n        for i in A:\n            d=list(l)\n            for ch in i:\n                if d[ord(ch)-ord('a')]>0:\n                    d[ord(ch)-ord('a')] -=1\n            if sum(d)==0:\n                result.append(i)\n                        \n            \n        return result\n                    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        from collections import Counter\n        \n        freq = {word: Counter(word) for word in A}\n        queries = {word: Counter(word) for word in B}\n        query = {chr(i): max(queries[word].get(chr(i), 0) for word in queries) for i in range(ord('a'), ord('z') + 1)}\n        \n        ans = []\n        \n        for k in list(freq.keys()):\n            flag = 1\n            for ch in query:\n                if query[ch] > freq[k].get(ch, 0):\n                    flag = 0\n                    break\n            \n            if flag: ans.append(k)\n        \n        return ans\n            \n            \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        dic = {}\n        for b in B:\n            for char in b:\n                dic[char] = max(dic.get(char, 0), b.count(char))\n        \n        res = []\n        for a in A:\n            if all(a.count(k) >= dic[k] for k in dic):\n                res.append(a)\n        return res\n        \n        \n        \n        \n#https://leetcode.com/problems/word-subsets/discuss/659164/Python-90-with-comments-and-explanation\n", "class Solution:\n    def count(self, word):\n        res = [0] * 26\n        for item in word:\n            tmp = ord(item) - ord('a')\n            res[tmp] += 1\n        return res\n    \n    def satisfy(self, item, bmax):\n        tmp = self.count(item)\n        for i in range(26):\n            if tmp[i] < bmax[i]:\n                return False\n            \n        return True\n    \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bmax = [0] * 26\n        for item in B:\n            for index, val in enumerate(self.count(item)):\n                bmax[index] = max(bmax[index], val)\n          \n        res = []\n        for item in A:\n            if self.satisfy(item, bmax):\n                res.append(item)\n                \n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = Counter()\n        for b in B:\n            count = count | Counter(b)\n        return [a for a in A if Counter(a) & count == count]", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        b_word = [0] * 26\n        \n        for word in B:\n            for idx, count in enumerate(self.create_char_set(word)):\n                b_word[idx] = max(b_word[idx], count)\n        \n        for word in A:\n            a_word = self.create_char_set(word)\n            if all(a >= b for a, b in zip(a_word, b_word)):\n                res.append(word)\n                \n        return res\n        \n        \n    \n    def create_char_set(self, word):\n        char_set = [0] * 26\n        for char in word:\n            char_set[ord(char) - ord('a')] += 1\n        return char_set\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = collections.Counter()\n        for b in B:\n            # \u4e24\u4e2aCounter\u6c42\u6216\u5c31\u662f\u6bcf\u4e00\u4e2a\u5143\u7d20key\u90fd\u66f4\u65b0\u5230\u6700\u5927\u503c\u3002\n            count = count | collections.Counter(b)\n            # \u4e24\u4e2aCounter\u6c42\u4e0e\u5c31\u662f\u6bcf\u4e00\u4e2a\u5143\u7d20key\u90fd\u66f4\u65b0\u5230\u6700\u5c0f\u503c\u3002\n        return [a for a in A if Counter(a) & count == count]", "class Solution(object):\n    def wordSubsets(self, A, B):\n        def count(word):\n            res = [0]*26\n            for i in word:\n                res[ord(i)-ord('a')] +=1\n            return res\n        b_max=[0]*26\n        for b in B:\n            bb=count(b)\n            for w in range(26):\n                b_max[w]=max(b_max[w],bb[w])\n        ans = []\n        for a in A:\n            if all(x>=y for x,y in zip(count(a), b_max)):\n                ans.append(a)\n        return ans   \n             \n                        \n        \n        \n#         def count(word):\n#             ans = [0] * 26\n#             for letter in word:\n#                 ans[ord(letter) - ord('a')] += 1\n#             return ans\n\n#         bmax = [0] * 26\n#         for b in B:\n#             ls = count(b)\n#             for i in range(len(ls)):\n#                 bmax[i] = max(bmax[i], ls[i])\n           \n#             # for i, c in enumerate(count(b)):\n#             #     bmax[i] = max(bmax[i], c)\n\n#         ans = []\n#         for a in A:\n#             if all(x >= y for x, y in zip(count(a), bmax)):\n#                 ans.append(a)\n#         return ans\n", "class Solution:\n    \n    def getCharFrequency(self, word):\n        \n        f = [0] * 26        \n        for ch in word:            \n            f[ord(ch)-ord('a')] += 1\n        \n        return f\n            \n        \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        result = []\n        \n        max_freq = [0]* 26\n        \n        for i in range(len(B)):\n            curr_freq = self.getCharFrequency(B[i])\n            \n            for j in range(26):\n                max_freq[j] = max(max_freq[j], curr_freq[j])\n    \n        \n        for i in range(len(A)):\n            curr_freq = self.getCharFrequency(A[i])\n            \n            valid = True\n            \n            for j in range(26):\n                if max_freq[j] > curr_freq[j]:\n                    valid = False\n                    break\n                \n            if valid:\n                result.append(A[i])\n        \n        return result\n    \n    \n    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            result = [0]*26\n            for letter in word:\n                result[ord(letter)-ord('a')]+=1\n            return result \n        \n        bmax = [0]*26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i],c)\n                \n        result = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                result.append(a)\n        \n        return result ", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(s):\n            cnt = [0]*26\n            for c in s:\n                cnt[ord(c) - ord('a')] += 1\n            return cnt\n        \n        cnt = [0]*26\n        \n        for b in B:\n            bcnt = count(b)\n            for i,c in enumerate(bcnt):\n                cnt[i] = max(cnt[i],c)\n                \n        ans = []\n        for a in A:\n            acnt = count(a)\n            if all(x>=y for x,y in zip(acnt,cnt)):\n                ans.append(a)\n                \n        return ans\n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        d = {}\n        for a in A:\n            d[a] = Counter(a)\n        cd = defaultdict(int)\n        for b in B:\n            for i in Counter(b):\n                cd[i] = max(cd[i], Counter(b)[i])\n        ret = []\n        for k in d:\n            t = True\n            for c in cd:\n                if c not in k or d[k][c] < cd[c]:\n                    t = False\n                    break\n            if t:\n                ret.append(k)\n        return ret", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        subset = {}\n        for b in B:\n            for char in b:\n                subset[char] = max(subset.get(char, 0), b.count(char))\n        return [a for a in A if all(a.count(c) >= subset[c] for c in subset.keys())]", "from collections import Counter\nclass Solution:\n     def wordSubsets(self, A, B):\n        count = collections.Counter()\n        for b in B:\n            count = count | collections.Counter(b)\n        return [a for a in A if Counter(a) & count == count]", "import collections\n\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        dp = [0] * 26\n        for b in B:\n            dp = [max(i, j) for i, j in zip(dp, self.bow(b))]\n        print(dp)\n            \n        res = []\n        for a in A:\n            if not any([al < bl for al, bl in zip(self.bow(a), dp)]):\n                res.append(a)\n        return res\n    \n    def bow(self, text):\n        d = [0] * 26\n        for l in text:\n            d[ord(l) - ord('a')] += 1\n        return d", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cover = [0] * 26\n        for i in range(len(B)):\n            max_cnt = [0] * 26\n            for c in B[i]:\n                max_cnt[ord(c) - ord('a')] += 1\n            cover = [max(x, y) for x, y in zip(cover, max_cnt)]\n        \n        res = []\n        for i in range(len(A)):\n            cnt = [0] * 26\n            for c in A[i]:\n                cnt[ord(c) - ord('a')] += 1\n            if all([x>=y for x, y in zip(cnt, cover)]):\n                res.append(A[i])\n        \n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # O(m + n); m and n is the total amount of chars in A and B\n        def count(word):\n            counter = [0] * 26\n            for w in word:\n                counter[ord(w) - ord(\\\"a\\\")] += 1\n            return counter\n            \n        b_char_combine = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                b_char_combine[i] = max(b_char_combine[i], c)\n\n        res = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), b_char_combine)):\n                res.append(a)\n\n        return res\n            ", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = collections.Counter()\n        for b in B:\n            count = count | collections.Counter(b)\n        return [a for a in A if Counter(a) & count == count]\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cover = [0] * 26\n        for i in range(len(B)):\n            cnt = [0] * 26\n            for c in B[i]:\n                cnt[ord(c) - ord('a')] += 1\n            cover = [max(x, y) for x, y in zip(cover, cnt)]\n        \n        res = []\n        for i in range(len(A)):\n            cnt = [0] * 26\n            for c in A[i]:\n                cnt[ord(c) - ord('a')] += 1\n            if all([x>=y for x, y in zip(cnt, cover)]):\n                res.append(A[i])\n        \n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            ans = [0]*26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n            print(ans)\n        \n        bmax = [0]*26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n        \n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n                \n        return ans\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        A_dict = []\n        B_dict = {} #final dictionary of B taking max of cnt\n        ans = []\n        for ww in A:\n            temp = {}\n            for ele in ww:\n                if ele in temp:\n                    temp[ele] +=1\n                else:\n                    temp[ele] =1\n            A_dict.append(temp)\n        for ww in B:\n            temp = {}\n            for ele in ww:\n                if ele in temp:\n                    temp[ele] +=1\n                else:\n                    temp[ele] =1\n            for key,cnt in temp.items():\n                if key in B_dict:\n                    B_dict[key] = max(cnt,B_dict[key])\n                else:\n                    B_dict[key] = cnt\n        for ind,ele in enumerate(A_dict):\n            cur_dict = ele\n            flag = True\n            for key,cnt in B_dict.items():\n                if key not in cur_dict or cur_dict[key]<cnt:\n                    flag = False\n                    break\n            if flag:\n                ans.append(A[ind])\n        return ans", "class Solution:\n    def wordSubsets(self, A, B):\n        '''\n        :type A: list of str\n        :type B: list of str\n        :rtype: list of str\n        '''\n        b_count = [0] * 26\n\n        # Collecting the constraints into a character mapping\n        for word in B:\n            tmp_count = self.count(word)\n\n            for i in range(0, 26):\n                b_count[i] = max(b_count[i], tmp_count[i])\n\n        # Testing each character in A\n        output = []\n        for word in A:\n            tmp_count = self.count(word)\n\n            universal = True\n            for i in range(0, 26):\n                if tmp_count[i] < b_count[i]:\n                    universal = False\n\n            if universal:\n                output.append(word)\n\n        return output\n\n    def count(self, word):\n        output = [0] * 26\n\n        for letter in word:\n            idx = ord(letter) - ord(\\\"a\\\")\n            output[idx] += 1\n\n        return output\n\n", "class Solution:\n    \n    \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n        return ans", "from functools import reduce\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        c_b = reduce(operator.or_, (Counter(w) for w in B))\n        return [a for a in A if not c_b-Counter(a)]\n", "from collections import defaultdict\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bMap = defaultdict(int)\n        ans = []\n        \n        maxB = [0]*26\n        \n        for b in B:\n            m = self.count(b)\n            for i in range(len(m)):\n                maxB[i] = max(maxB[i], m[i])\n        \n        for a in A:\n            aMap = self.count(a)\n            c = 0\n            for i in range(len(aMap)):\n                if aMap[i] >= maxB[i]:\n                    c+=1\n            if c == 26:\n                ans.append(a)\n        \n        return ans\n                    \n            \n    def count(self, arr):\n        ans = [0]*26\n        for ch in arr:\n            ans[ord(ch)-ord('a')] += 1\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # Since a universal word needs to be superset for all words in B, we can combine all words in B\n        #   to become a new word, and words in A only need to have this one single word as its subset\n        \n        # get a list of ints of length 26 to represent how many of each letter is in a word\n        def countLetter(s):\n            res = [0] * 26\n            for c in s:\n                res[ord(c) - ord('a')] += 1\n            return res\n        \n        # get how many of each letter is in the combined letter of B, note that we only need the larger\n        #   number if one char appears in two different words. Ex: 'lo' and 'loo' will become 'loo'\n        b_count = [0] * 26\n        for b in B:\n            for i, c in enumerate(countLetter(b)):\n                b_count[i] = max(b_count[i], c)\n        \n        # get all words x with count(x) greater than b_count in every character\n        return [x for x in A if all([x >= y for x, y in zip(countLetter(x), b_count)])]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        counter = [0] * 26\n        for word in B:\n            tmp = [0] * 26\n            for c in map(lambda x : ord(x) - ord('a'), word):\n                tmp[c] += 1\n            for c in range(26):\n                counter[c] = max(counter[c], tmp[c])\n        \n        ans = []\n        for word in A:\n            tmp = [0] * 26\n            for c in map(lambda x : ord(x) - ord('a'), word):\n                tmp[c] += 1\n            if all(counter[c] <= tmp[c] for c in range(26)):\n                ans.append(word)\n        \n        return ans", "import collections\n\nclass Solution:\n  def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n    A = [(a,collections.Counter(a)) for a in A]\n    newB = {}\n    for b in B:\n      for x, c in collections.Counter(b).items():\n          newB[x] = c if x not in newB else max(newB[x], c)\n      \n    B = newB\n\n    return [a for a, counts in A\n            if all(counts[x] >= c for x,c in B.items())\n           ]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        arr1 = []\n        arr2 = []\n        for x in A:\n            arr1.append(collections.Counter(x))\n        dic = collections.defaultdict(int)\n        for y in B:\n            t = collections.Counter(y)\n            for c in t:\n                dic[c] = max(dic[c], t[c])\n        res = []\n        \n        def comp(i):\n            for c in dic:\n                if arr1[i][c] < dic[c]:\n                    return False\n            return True\n        \n        for i in range(len(A)):\n            if comp(i):\n                res.append(A[i])\n        return res\n                \n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        LETTERS = 26\n        \n        base = ord('a')\n        bCounts = [0 for _ in range(LETTERS)]\n        \n        for word in B:\n            currCounts = [0 for _ in range(LETTERS)]\n            \n            for c in word:\n                currCounts[ord(c) - base] += 1\n                \n            for i in range(LETTERS):\n                bCounts[i] = max(currCounts[i], bCounts[i])\n                \n                \n        result = []\n        \n        for word in A:\n            currCounts = [0 for _ in range(LETTERS)]\n            \n            for c in word:\n                currCounts[ord(c) - base] += 1\n            \n            valid = True\n            for i in range(LETTERS):\n                if currCounts[i] < bCounts[i]:\n                    valid = False\n                    break\n                    \n            if valid:\n                result.append(word)\n        \n        \n        \n        return result\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        m = {}\n        ret = []\n        \n        for b in B:\n            each = {}\n            for i in range(len(b)):\n                each[b[i]] = each[b[i]] + 1 if b[i] in each else 1\n                \n            for k in each:\n                if not k in m or m[k] < each[k]:\n                    m[k] = each[k]\n        \n        for a in A:\n            each = {}\n            for i in range(len(a)):\n                each[a[i]] = each[a[i]] + 1 if a[i] in each else 1\n            \n            isAdding = True\n            for k in m:\n                if not k in each or each[k] < m[k]:\n                    isAdding = False\n                    break\n            \n            if isAdding:\n                ret.append(a)\n                \n        return ret\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cnt=Counter()\n        for i in B:\n            cnt|=Counter(i)\n        res=[]\n        for i in A:\n            if(not(cnt-Counter(i))): res.append(i)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # Since a universal word needs to be superset for all words in B, we can combine all words in B\n        #   to become a new word, and words in A only need to have this one single word as its subset\n        \n        # get a list of ints of length 26 to represent how many of each letter is in a word\n        def countLetter(s):\n            res = [0] * 26\n            for c in s:\n                res[ord(c) - ord('a')] += 1\n            return res\n        \n        # get how many of each letter is in the combined letter of B, note that we only need the larger\n        #   number if one char appears in two different words. Ex: 'lo' and 'loo' will become 'loo'\n        b_count = [0] * 26\n        for b in B:\n            for i, c in enumerate(countLetter(b)):\n                b_count[i] = max(b_count[i], c)\n        \n        # get all words x with count(x) greater than b_count in every character\n        return [x for x in A if all([a_count >= b_count for a_count, b_count in zip(countLetter(x), b_count)])]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        def count(word) :\n            ans = [0]*26\n            for c in word:\n                ans[ord(c)-ord('a')] += 1\n            return ans\n        \n        B_dict = [0]*26\n        \n        for b in B :\n            for i,c in enumerate(count(b)) :\n                B_dict[i] = max(B_dict[i], c)\n\n        ans = []\n\n        for a in A:\n            a_dict = count(a)\n            \n            flag = True\n            for i, c in enumerate(count(a)) :\n                if c<B_dict[i] :\n                    flag = False\n                    break\n                    \n            if flag :\n                ans.append(a)\n                \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        A_counter = [Counter(a) for a in A]\n        B_counter = [Counter(b) for b in B]\n        b_merged = Counter()\n        for chr_ in string.ascii_lowercase:\n            b_merged[chr_] = max([bc[chr_] for bc in B_counter])\n        \n        def is_subset(ac, bc):\n            for chr_ in string.ascii_lowercase:\n                if ac[chr_] < bc[chr_]:\n                    return False\n            return True\n        \n        ans = []\n        for i,ac in enumerate(A_counter):\n            if is_subset(ac,b_merged):\n                ans.append(A[i])\n        \n        return ans", "from functools import reduce\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        c_a = [Counter(w) for w in A]\n        c_b = reduce(lambda x, y: x | y, [Counter(w) for w in B])\n        return [word for i, word in enumerate(A) if not c_b-c_a[i]]\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        min_require = [0]*26\n        std_string = \\\"abcdefghijklmnopqrstuvwxyz\\\"\n        for word in B:\n            curr_char_freq = [0]*26\n            for char in word:\n                curr_char_freq[std_string.index(char)] += 1\n            \n            min_require = [max(x1, x2) for x1,x2 in zip(min_require, curr_char_freq)]\n        \n        result = []\n        for word in A:\n            curr_char_freq = [0]*26\n            for char in word:\n                curr_char_freq[std_string.index(char)] += 1\n            \n            if False in [curr_char_freq[i] >= min_require[i] for i in range(26)]:\n                continue\n            result.append(word)\n        return result", "from functools import reduce\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_cnt = reduce(lambda a, b: Counter(a) | Counter(b), B)\n        a_cnt = Counter()\n        result = []\n\n        for word in A:\n            for w in word:\n                if w in b_cnt:\n                    a_cnt[w] += 1\n            if not b_cnt - a_cnt:\n                result.append(word)\n            a_cnt.clear()\n\n        return result\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ans,char_count,size_t = list(),Counter(),len(A)\n\n        T_A,T_B= [Counter(a) for a in A],[Counter(b) for b in B]\n        for k in T_B:\n            for c in k:\n                if k[c] > char_count[c]:\n                    char_count[c] = k[c]    \n\n        for i in range(len(T_A)):\n            if not (char_count - T_A[i] == {}): \n                continue\n            ans.append(A[i])\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        output_list = []\n        def count(word):\n            res = [0] * 26\n            for ch in word:\n                pos = ord(ch) - ord('a')\n                res[pos] = res[pos] + 1\n            return res\n        \n        b_max = [0]*26\n        for b in B:\n            res_b = count(b)\n            for i in range(26):\n                b_max[i] = max(b_max[i], res_b[i])\n        #print(b_max)\n        for a in A:\n            #Following is one simple way to compare two lists\n            '''res_a = count(a)\n            for i in range(26):\n                if b_max[i] > res_a[i]:\n                    break\n                if i == 25:\n                    output_list.append(a)'''\n            #Following is another zip function way to compare two list(or iterators)\n            if all(x>=y for x,y in zip(count(a), b_max)):\n                output_list.append(a)            \n        return output_list\n                    \n                \n            \n        \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_counts = {}\n        for word in B:\n            word_counts = {}\n            for letter in word:\n                if letter in word_counts:\n                    word_counts[letter] += 1\n                else:\n                    word_counts[letter] = 1\n            for letter in word_counts:\n                if letter in b_counts:\n                    b_counts[letter] = max(b_counts[letter], word_counts[letter])\n                else:\n                    b_counts[letter] = word_counts[letter]\n        result = []\n        for word in A:\n            a_counts = {}\n            for letter in word:\n                if letter in a_counts:\n                    a_counts[letter] += 1\n                else:\n                    a_counts[letter] = 1\n            superset = True\n            for key in b_counts:\n                if key not in a_counts or b_counts[key] > a_counts[key]:\n                    superset = False\n                    break\n            if superset:\n                result.append(word)\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_cnt = reduce(lambda a, b: Counter(a) | Counter(b), B)\n        return [a for a in A if not b_cnt - Counter(a)]", "class Solution:\n    \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def conv(w):\n            sol = [0 for _ in range(26)]\n            for c in w:\n                sol[ord(c)-ord('a')] += 1\n            return sol\n        \n        bmax = [0 for _ in range(26)]\n        for wb in B:\n            for idx, cnt in enumerate(conv(wb)):\n                bmax[idx] = max(bmax[idx], cnt)\n                \n        sol = []\n        for wa in A:\n            if all(a>=b for a, b in zip(conv(wa), bmax)):\n                sol.append(wa)\n        return sol\n            \n            \n            \n", "from collections import Counter\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        universal_word = Counter()\n        # construct the universal word for B\n        for b in B:\n            universal_word |= Counter(b)\n        \n        result = []\n        for a in A:\n            # all of universal word is contained in a\n            if not universal_word - Counter(a):\n                result.append(a)\n        \n        return result\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        m = {}\n        for i in range(26):\n            letter = chr(ord('a')+i)\n            m[letter] = 0\n            for w in B:\n                ct_curr_l = w.count(letter)\n                # for l in w:\n                #     if l == letter:\n                #         ct_curr_l+=1\n                m[letter] = max(m[letter],ct_curr_l)\n        res = []\n        for w in A:\n            A_m = {}\n            rt = True\n            for l in w:\n                if not l in A_m:\n                    A_m[l] = 0\n                A_m[l]+=1\n            for k in m:\n                if m[k]>0 and ((k not in A_m) or (A_m[k]<m[k])):\n                    rt = False\n            if rt == True:\n                res.append(w)\n        return res\n                \n                \n                \n                \n                \n                \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        def counter(c):\n            listed = [0]*26\n            for i in c:\n                x=ord(i)-97\n                listed[x]+=1\n                \n            return listed\n        \n        \n        \n        blist = [0]*26\n        for b in B:\n            temp_list = counter(b)\n            for i in range(0,26):\n                blist[i]= max(blist[i],temp_list[i])\n        listed=blist\n        l=[]\n        \n        for a in A:\n            temp_list = counter(a)\n            universal = True\n            for i in range(0,26):\n                if listed[i] > temp_list[i]:\n                    universal = False\n                    \n            if universal:\n                l.append(a)\n        \n        \n        \n        return l\n    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        if len (B) == 0:\n            return A\n        \n        from collections import Counter\n        \n        cb = Counter (B[0])\n        for i in range (1, len (B)):\n            c = Counter (B[i])\n            \n            for ch in c.keys():\n                cb[ch] = max (cb[ch], c[ch])\n\n        res = []    \n        for a in A:\n            add = True\n            ca = Counter(a)\n            \n            for keyB in cb.keys():\n                if keyB not in ca or cb[keyB] > ca[keyB]:\n                    add = False\n            \n            if add:\n                res.append (a)\n        \n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n        return ans\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = collections.Counter()\n        \n        for b in B:\n            count |= collections.Counter(b)\n        \n        return [a for a in A if collections.Counter(a) & count == count]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        output_list = []\n        def count(word):\n            res = [0] * 26\n            for ch in word:\n                pos = ord(ch) - ord('a')\n                res[pos] = res[pos] + 1\n            return res\n        \n        b_max = [0]*26\n        for b in B:\n            res_b = count(b)\n            for i in range(26):\n                b_max[i] = max(b_max[i], res_b[i])\n        #print(b_max)\n        for a in A:\n            #print(a)\n            res_a = count(a)\n            #prin\n            for i in range(26):\n                if b_max[i] > res_a[i]:\n                    break\n                if i == 25:\n                    output_list.append(a)\n        return output_list\n                    \n                \n            \n        \n        \n", "def f(c):\n    return ord(c) - ord('a')\n\nclass Solution:\n    def wordSubsets(self, A, B):\n        \n        def isSubSet(coverA, coverB):\n            for i in range(26):\n                if coverA[i] < coverB[i]:\n                    return False\n            return True\n            \n        coverB = [0] * 26\n        for b in B:\n            cover = [0] * 26\n            for c in b:\n                cover[f(c)] += 1\n            for i in range(26):\n                coverB[i] = max(coverB[i], cover[i])\n            \n        res = []\n        for a in A:\n            coverA = [0] * 26\n            for c in a:\n                coverA[f(c)] += 1\n            if isSubSet(coverA, coverB):\n                res.append(a)\n        return res\n                \n                \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        subset = {}\n        for b in B:\n            for char in b:\n                subset[char] = max(b.count(char), subset.get(char, 0))\n        \n        return [a for a in A if all(a.count(char) >= subset[char] for char in subset.keys())]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        def count(s):\n            res = [0]*26\n            for x in s:\n                res[ord(x)-ord('a')] += 1\n            return res\n        \n        bmax = [0]*26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n        \n        res = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                res.append(a)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        m = {}\n        for i in range(26):\n            letter = chr(ord('a')+i)\n            m[letter] = 0\n            for w in B:\n                ct_curr_l = 0\n                for l in w:\n                    if l == letter:\n                        ct_curr_l+=1\n                m[letter] = max(m[letter],ct_curr_l)\n        res = []\n        for w in A:\n            A_m = {}\n            rt = True\n            for l in w:\n                if not l in A_m:\n                    A_m[l] = 0\n                A_m[l]+=1\n            for k in m:\n                if m[k]>0 and ((k not in A_m) or (A_m[k]<m[k])):\n                    rt = False\n            if rt == True:\n                res.append(w)\n        return res\n                \n                \n                \n                \n                \n                \n", "# time complexity: O(26*(A+B))\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # 1st step, construct the minimal word which is a superset of all words in B\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        u = {c:0 for c in letters}\n        for w in B:\n            for c,f in list(Counter(w).items()): # char, frequency\n                u[c] = max(u[c],f)\n        \n        #2nd step, find every word a in A such that u is a subset of a\n        res = []\n        for w in A:\n            wc = Counter(w)\n            if all(f <= wc[c] for c,f in list(u.items())):\n                res.append(w)\n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        m = {}\n        for i in range(26):\n            letter = chr(ord('a')+i)\n            m[letter] = 0\n            for w in B:\n                ct_curr_l = w.count(letter)\n                m[letter] = max(m[letter],ct_curr_l)\n        res = []\n        for w in A:\n            A_m = {}\n            rt = True\n            for l in w:\n                if not l in A_m:\n                    A_m[l] = 0\n                A_m[l]+=1\n            for k in m:\n                if m[k]>0 and ((k not in A_m) or (A_m[k]<m[k])):\n                    rt = False\n            if rt == True:\n                res.append(w)\n        return res\n                \n                \n        \n                \n                \n                \n", "class Solution(object):\n    def wordSubsets(self, A, B):\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n        return ans\n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # Reduce to Single Word in B\n        # Time  complexity: O(A + B) where A and B is the total amount of information in A and B respectively.\n        # Space complexity: O(A.length + B.length)\n        def count(word):\n            ans = [0] * 26\n            for letter in word:\n                ans[ord(letter) - ord('a')] += 1\n            return ans\n\n        bmax = [0] * 26\n        for b in B:\n            for i, c in enumerate(count(b)):\n                bmax[i] = max(bmax[i], c)\n\n        ans = []\n        for a in A:\n            if all(x >= y for x, y in zip(count(a), bmax)):\n                ans.append(a)\n\n        return ans\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ss = \\\"qwertyuiopasdfghjklzxcvbnm\\\"\n        alltime = {}\n        for i in ss:\n            alltime[i] = 0\n    \n        def freq(s):\n            temp = alltime.copy()\n            for i in s:\n                temp[i] += 1\n            return temp\n        \n        a1 = []\n        for i in A:\n            a1.append(freq(i))\n        \n        a2 = []\n        for i in B:\n            a2.append(freq(i))\n        \n        for i in alltime:\n            tt = 0\n            for j in a2:\n                tt = max(tt,j[i])\n            alltime[i] = tt\n        \n        ans = []\n        for i in range(len(a1)):\n            flag = 0\n            for j in alltime:\n                if alltime[j] > a1[i][j]:\n                    flag = 1\n                    break\n            if flag == 0:\n                ans.append(A[i])\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n\n        def count(s):\n            alpha = [0] * 26\n            for w in s:\n                alpha[ord(w) - ord('a')] += 1\n            return tuple(alpha)\n        \n        def compare(a, b):\n            for i in range(26):\n                if b[i] > a[i]:\n                    return False\n            return True\n        \n        Acount = [count(a) for a in A]\n        Bcount = [0] * 26\n        \n        for b in B:\n            tmp = count(b)\n            for i in range(26):\n                Bcount[i] = max(Bcount[i], tmp[i])\n        Bcount = tuple(Bcount)\n        \n        res = []\n        \n        for i in range(len(Acount)):\n            if all(Acount[i][j] >= Bcount[j] for j in range(26)):\n                res.append(A[i])\n        return res", "class Solution:\n    def compare(self,d,d1):\n        for i in d:\n            if(i not in d1 or d[i]>d1[i]):\n                return False\n        return True\n    \n    def wordSubsets(self, a: List[str], b: List[str]) -> List[str]:\n        bgroup = {}\n        for i in b:\n            d = {}\n            for j in i:\n                if j in d:\n                    d[j]+=1\n                else:\n                    d[j] = 1\n            for j in d:\n                if j not in bgroup:\n                    bgroup[j] = d[j]\n                else:\n                    bgroup[j] = max(bgroup[j],d[j])\n        ans = []\n        for i in a:\n            d1 = {}\n            for j in i:\n                if j in d1:\n                    d1[j]+=1\n                else:\n                    d1[j] = 1\n            if(self.compare(bgroup,d1)):\n                ans.append(i)\n        return  ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        B_dt = collections.Counter(B[0])\n        for b in B[1:]:\n            B_dt = B_dt | collections.Counter(b)\n        ans = []\n        \n        for a in A:\n            if collections.Counter(a) & B_dt == B_dt:\n                ans.append(a)\n    \n        return ans\n            \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def freq(s):\n            dp=[0 for _ in range(26)]\n            for i in s:\n                dp[ord(i)-ord('a')]+=1\n            return dp\n        arr=[0 for _ in range(26)]\n        for b in B:\n            for i,j in enumerate(freq(b)):\n                # print(i,j)\n                arr[i]=max(arr[i],j)\n        ans=[]\n        for a in A:\n            flag=1\n            for i,j in enumerate(freq(a)):\n                if arr[i]>j:\n                    flag=0\n            if flag:\n                ans.append(a)\n        return ans\n                    \n                    \n            \n                \n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        superword = [0] * 26\n        result = []\n        for word in B:\n            current = [0] * 26\n            for ch in word:\n                i = ord(ch) - ord('a')\n                current[i] += 1\n            \n            for i in range(26):\n                superword[i] = max(superword[i],current[i])\n                \n        \n        for word in A:\n            current = [0] * 26\n            for ch in word:\n                i = ord(ch) - ord('a')\n                current[i] += 1\n                \n            found = True\n            for i in range(26):\n                if superword[i] > current[i]:\n                    found = False\n                    break\n                    \n            if found == True:\n                result.append(word)\n                \n        return result\n", "from collections import Counter\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = Counter()\n        for b in B:\n            count = count | Counter(b)\n        return [a for a in A if Counter(a) & count == count]", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def count(word):\n            ans=[0]*26\n            for i in word:\n                ans[ord(i)-ord('a')]+=1\n            return ans\n        bMax=[0]*26\n        for b in B:\n            ls=count(b)\n            for c in range(26):\n                bMax[c]=max(bMax[c],ls[c])\n        res=[]\n        for i in A:\n            ls=count(i)\n            for c in range(26):\n                if ls[c]<bMax[c]:\n                    break\n            else:\n                res+=[i]\n        return res", "import collections\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bCount = collections.Counter()\n        for b in B:\n            bCount = bCount | collections.Counter(b)\n        res = []\n        for a in A:\n            if collections.Counter(a) & bCount == bCount:\n                res += a,\n                \n        return res", "class Solution:\n    import collections\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        count = collections.Counter()\n        for b in B:\n            count = count | collections.Counter(b)\n        return [a for a in A if Counter(a) & count == count]", "class Solution(object):\n    def wordSubsets(self, A, B):\n        s = set(A)\n        letters_required = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in letters_required or count > letters_required[j]:\n                    letters_required[j] = count\n\n        for i in A:\n            for j in letters_required:\n                if i.count(j) < letters_required[j]:\n                    s.remove(i)\n                    break\n        return list(s)", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \\\"\\\"\\\"def checkSubset(a, B):\n            aDict = {}\n            bDict = {}\n            for b in B:\n                bSet = set(b)\n                for c in bSet:\n                    if b.count(c) > a.count(c):\n                        return False\n            return True\n        ret = []\n        for a in A:\n            if not checkSubset(a, B):\n                continue\n            else:\n                ret.append(a)\n        return ret\\\"\\\"\\\"\n        \\\"\\\"\\\"def convertB(b):\n            d = {}\n            for c in b: \n                if c not in d:\n                    d[c] = 1\n                else:\n                    d[c]+=1\n            return d \n        for i in range(len(B)):\n            B[i] = convertB(B[i])\n        def convertA(a):\n            d = {}\n            for c in a:\n                if c not in d:\n                    d[c]=1\n                else:\n                    d[c]+=1\n            return d\n        convertedA = []\n        for i in range(len(A)):\n            convertedA.append(convertA(A[i]))\n        \n        def isGoodWord(aDict):\n            for wordDict in B:\n                for c in wordDict:\n                    if c not in aDict or wordDict[c] > aDict[c]:\n                        return False\n            return True\n        ret = []\n        for i in range(len(convertedA)):\n            if isGoodWord(convertedA[i]):\n                ret.append(A[i])\n        return ret\\\"\\\"\\\"\n        bDict = {}\n        def convertB(b):\n            d = {}\n            for c in b: \n                if c not in d:\n                    d[c] = 1\n                else:\n                    d[c]+=1\n            return d \n        for i in range(len(B)):\n            B[i] = convertB(B[i])\n        for d in B:\n            for key in d:\n                if key not in bDict:\n                    bDict[key] = d[key]\n                else:\n                    if bDict[key] < d[key]:\n                        bDict[key] = d[key]\n        def convertA(a):\n            d = {}\n            for c in a:\n                if c not in d:\n                    d[c]=1\n                else:\n                    d[c]+=1\n            return d\n        def isGoodWord(aDict):\n            for key in bDict:\n                if key not in aDict or bDict[key] > aDict[key]:\n                    return False\n            return True\n        \n        convertedA = []\n        \n        ret = []\n        for i in range(len(A)):\n            convertedA.append(convertA(A[i]))\n        for i in range(len(convertedA)):\n            if isGoodWord(convertedA[i]):\n                ret.append(A[i])\n        return ret\n            \n        \n            \n                \n            \n        \n                \n                ", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        max_count = {}\n        for string in B:\n            char_count = {}\n            for ch in string:\n                char_count[ch] = char_count.get(ch,0)+1\n            \n            for ch in char_count:\n                if ch not in max_count: max_count[ch]=0\n                max_count[ch] = max(max_count[ch], char_count[ch])\n        \n        print(max_count)\n        \n        res = []\n        for string in A:\n            char_count = {}\n            for ch in string:\n                char_count[ch] = char_count.get(ch,0)+1\n\n            uni = True\n            for key in max_count:\n                if key not in char_count or max_count[key]>char_count[key]:\n                    uni = False\n                    break\n            \n            if uni:\n                res.append(string)\n        \n        return res\n            \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n                \n        b_union = {}\n        for b in B:\n            chars = {}\n            for c in b:\n                chars[c] = chars.get(c,0) + 1\n            for c in chars:\n                b_union[c] = max(b_union.get(c,0), chars[c])\n        \n        res = []\n        for a in A:\n            chars = {}\n            for c in a:\n                chars[c] = chars.get(c,0) + 1\n            isUniversal = True\n            for c in b_union:\n                if not c in chars or b_union[c]>chars[c]:\n                    isUniversal = False\n                    break\n            if isUniversal:\n                res.append(a)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        d=defaultdict(int)\n        for i in B:\n            for j in set(i):\n                d[j]=max(i.count(j),d[j])\n        l=[]\n        for i in A:\n            if(all(d[j]<=i.count(j) for j in list(d.keys()))):\n                l.append(i)\n        return l\n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        if not B:\n            return A\n        \n        \n        mapB = [0]*26\n        B = list(set(B))\n        for b in B:\n            if not b:\n                continue\n            counter = collections.Counter(b)\n            for k in b:\n                index = ord(k) - ord('a')\n                if counter[k] > mapB[index]:\n                    mapB[index] = counter[k]\n        \n        print(mapB)\n        res = []\n        for a in A:\n            temp = mapB[:] #deep copy\n            for c in a:\n                i = ord(c) - ord('a')\n                if temp[i] > 0:\n                    temp[i] -=1\n            if sum(temp) == 0:\n                res.append(a)\n                \n        return res\n                \n                \n                    \n                    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        uni = []\n        ## 1-  create a cover for B by creating a histogram of items\n        # for example if B = [\\\"cb\\\",\\\"aae\\\",\\\"ccc\\\",\\\"ab\\\",\\\"adc\\\"]\n        # its cover will be a histogram B_hist = {'c': 3, 'b': 1, 'a': 2, 'e': 1, 'd': 1}\n        B_set = set(''.join(B))\n        B_hist = {b_i: [max([b.count(b_i) for b in B]), -1] for b_i in B_set}\n        \n        ## 2- search for the universals using B_hist\n        for a in A:\n            occurances_b = 0\n            for b_i in B_set:\n                occurances_b_i = 0\n                stop = False\n                B_hist[b_i][1] = -1\n                for j in range(B_hist[b_i][0]):\n                    B_hist[b_i][1] = a.find(b_i, B_hist[b_i][1]+1)\n                    if B_hist[b_i][1] == -1:\n                        stop = True\n                        break\n                    else:\n                        occurances_b_i += 1\n                if stop == True:\n                    break   \n                if occurances_b_i == B_hist[b_i][0]:\n                    occurances_b += 1   \n            #print(a, occurances_b)\n            if occurances_b == len(B_set):\n                uni.append(a)\n                    \n        return uni", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        max_count = {}\n        for string in B:\n            char_count = {}\n            for ch in string:\n                char_count[ch] = char_count.get(ch,0)+1\n            \n            for ch in char_count:\n                if ch not in max_count: max_count[ch]=0\n                max_count[ch] = max(max_count[ch], char_count[ch])\n        \n        print(max_count)\n        \n        res = []\n        for string in A:\n            char_count = {}\n            for ch in string:\n                char_count[ch] = char_count.get(ch,0)+1\n\n            ctr = 0\n            for key in max_count:\n                if key in char_count and max_count[key]<=char_count[key]:\n                    ctr+=1\n                else: break\n            \n            if ctr == len(max_count):\n                res.append(string)\n        \n        return res\n            \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ans=[]\n        word={}\n        for i in B:\n            for j in i:\n                if(j not in word):\n                    word[j]=i.count(j)\n                else:\n                    if(i.count(j)>word[j]):\n                        word[j]=i.count(j)\n                        \n        for i in A:\n            x=0\n            for k in word:\n                if(word[k]>i.count(k)):\n                    x=1\n                    break;\n                \n            if(x!=1):\n                ans.append(i)\n            \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        max_count = {}\n        for string in B:\n            char_count = {}\n            for ch in string:\n                char_count[ch] = char_count.get(ch,0)+1\n            \n            for ch in char_count:\n                if ch not in max_count: max_count[ch]=0\n                max_count[ch] = max(max_count[ch], char_count[ch])\n        \n        print(max_count)\n        \n        res = []\n        for string in A:\n            char_count = {}\n            for ch in string:\n                char_count[ch] = char_count.get(ch,0)+1\n\n            ctr = 0\n            for key in max_count:\n                if key in char_count and max_count[key]<=char_count[key]:\n                    ctr+=1\n            \n            if ctr == len(max_count):\n                res.append(string)\n        \n        return res\n            \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        ans = []\n        wordCountA = [ self.genWordCount(word) for word in A]\n        wordCountB = [ self.genWordCount(word) for word in B]\n        reducedWordB = {}\n        for wordDict in wordCountB:\n            for key, val in wordDict.items():\n                reducedWordB[key] = max(reducedWordB[key], val) if key in reducedWordB else val\n\n        for i in range(len(A)):\n            if self.isSubset(wordCountA[i], reducedWordB):\n                ans.append(A[i])\n\n        return ans\n    \n    def genWordCount(self, word):\n        wordCount = {}\n        for c in word:\n            if c in wordCount:\n                wordCount[c] += 1\n            else:\n                wordCount[c] = 1\n        return wordCount\n    \n    def isSubset(self, dictA, dictB):\n        for key, val in dictB.items():\n            if key not in dictA or dictA[key] < val:\n                return False\n        return True", "from collections import defaultdict\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ch2cnt = defaultdict(int)\n        for b in B:\n            tmp_cnt = defaultdict(int)\n            for ch in b:\n                tmp_cnt[ch] += 1\n            for k, v in tmp_cnt.items():\n                ch2cnt[k] = max(ch2cnt[k], v)\n        res = []\n        for a in A:\n            tmp_dict = dict(ch2cnt)\n            for ch in a:\n                if ch in tmp_dict:\n                    tmp_dict[ch] -= 1\n                    if tmp_dict[ch] == 0:\n                        tmp_dict.pop(ch)\n            if len(tmp_dict) == 0:\n                res.append(a)\n        return res ", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \\\"\\\"\\\"\n        . create set for each B\n        . merge all into one big set, saving number of most entries for each char\n        \n        . for each A,\n        .. in the copy of setB, decrement and then delete char \n        .. if set becomed empty, add a to results \n        \n        .. reset copy of setB\n        \n        \n        \\\"\\\"\\\"\n        setB = {}\n        \n        temp = {}\n        for b in B:\n            for c in b:\n                temp[c] = temp.get(c, 0) + 1\n            for (k, v) in temp.items():\n                setB[k] = max(setB.get(k, 0), v)\n            temp.clear()\n        \n        res = []\n        keys = len(setB.keys())\n        for a in A:\n            temp = setB.copy()\n            tempK = keys\n            for c in a:\n                if c in temp:\n                    temp[c] -= 1\n                    if temp[c] == 0:\n                        # temp.pop(c)\n                        tempK -= 1\n                        if tempK == 0:\n                            res.append(a)\n                    \n                        \n        return res\n            \n        ", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        universe = defaultdict(int)\n        for b in B:\n            bCount = defaultdict(int)\n            for letter in b:\n                bCount[letter] += 1\n            for key in bCount:\n                universe[key] = max(universe[key],bCount[key])\n        \n        # print(universe)\n        \n        result = []\n        for a in A:\n            aCount = defaultdict(int)\n            for letter in a:\n                aCount[letter] += 1\n            isUni = True\n            for letter in universe:\n                if universe[letter] > aCount[letter]:\n                    isUni = False\n                    break\n                else:\n                    pass\n            if isUni:\n                result.append(a)\n                \n        return result", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        minFreq = {}\n        for word in B:\n            freq = Counter(word)\n            for key, value in list(freq.items()):\n                if key in minFreq:\n                    if value > minFreq[key]:\n                        minFreq[key] = value\n                else:\n                    minFreq[key] = value\n        ans = []\n        for word in A:\n            c = minFreq.copy()\n            flag = True\n            for i in range(len(word)):\n                if word[i] in c:\n                    c[word[i]] -= 1\n            for value in list(c.values()):\n                if value > 0:\n                    flag = False\n                    break\n            if flag:\n                ans.append(word)\n        return ans\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def get_b_map(words):\n            res = collections.defaultdict(int)\n            for word in words:\n                temp_dict = collections.defaultdict(int)\n                for char in word:\n                    temp_dict[char] += 1\n                    res[char] = max(res[char], temp_dict[char])\n            return res\n        \n        b_map = get_b_map(B)\n        \n        def contains(word, b_map):\n            same_freqs = 0\n            temp_dict = collections.defaultdict(int)\n            for char in word:\n                if char not in b_map:\n                    continue\n                    \n                temp_dict[char] += 1\n                if temp_dict[char] == b_map[char]:\n                    same_freqs += 1\n            return same_freqs == len(b_map)\n        \n        res = []\n        for word in A:\n            if contains(word, b_map):\n                res.append(word)\n        return res", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A, B):\n        \\\"\\\"\\\"\n        :type A: List[str]\n        :type B: List[str]\n        :rtype: List[str]\n        \\\"\\\"\\\"\n        wordsInBCounts = Counter()\n        for wordB in B:\n            counts = Counter(wordB)\n            for (key,value) in counts.items():\n                if wordsInBCounts[key] < value:\n                    wordsInBCounts[key] = value        \n        words = []        \n        for wordA in A:\n            stringALetterCounts = Counter(wordA)\n            universal = True\n            for (key,value) in wordsInBCounts.items():\n                if value > stringALetterCounts[key]:\n                    universal = False\n                    break\n            if universal:\n                words.append(wordA)\n        return words", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        d={}\n        for e in B:\n            tmp={}\n            for c in e:\n                if c not in tmp:\n                    tmp.update({c:1})\n                else:\n                    tmp[c]+=1\n            if (not d) or (not tmp):\n                d.update(tmp)\n            else:\n                for k,v in list(tmp.items()):\n                    if k in d:\n                        if v>d[k]:\n                            d[k]=v\n                    else:\n                        d.update({k:v})\n        #print(d)\n        \n        if not d:\n            return A\n        \n        ans=[]\n        for a in A:\n            tmp={}\n            f=True\n            for e in a:\n                if e not in tmp:\n                    tmp.update({e:1})\n                else:\n                    tmp[e]+=1\n            for k,v in list(d.items()):\n                if k in tmp:\n                    if v<=tmp[k]:\n                        pass\n                    else:\n                        f=False\n                        break\n                else:\n                    f=False\n                    break\n            if f:\n                ans.append(a)\n        \n        return ans\n                    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = set(A)\n        letters_required = {}\n        for b in B:\n            for c in b:\n                count = b.count(c)\n                if c not in letters_required or count > letters_required[c]:\n                    letters_required[c] = count\n        \n        for a in A:\n            for lr in letters_required:\n                if a.count(lr) < letters_required[lr]:\n                    s.remove(a)\n                    break\n        \n        return list(s)", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bLets = collections.Counter()\n        for w in B:\n            for l, cnt in collections.Counter(w).items():\n                if cnt > bLets[l]:\n                    bLets[l] = cnt\n        bTotal = sum(bLets.values())\n        bLets = bLets.most_common()\n        result = []\n        aLets = collections.Counter()\n        for w in A:\n            if len(w) >= bTotal:\n                aLets.update(w)\n                for l, cnt in bLets:\n                    if cnt > aLets[l]:\n                        break\n                else:\n                    result.append(w)\n                aLets.clear()\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        def getFrequency(s):\n            d ={}\n            for l in s:\n                d[l]=d.get(l,0)+1\n            return d\n        main={}\n        \n        for b in B:\n            f = getFrequency(b)\n            for k in f.keys():\n                main[k]=max(main.get(k,0),f[k])\n        \n        out=[]\n        for a in A:\n            \n            leto = getFrequency(a)\n            cont = False\n            for k in main.keys():\n                if leto.get(k,0) < main[k]:\n                    cont=True\n                    break\n                    \n            if not cont:\n                out.append(a)\n                \n        return out", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        dctB = {}\n        for word in B:\n            dct = {}\n            for ch in word:\n                cnt = dct.get(ch)\n                dct[ch] = 1 if not cnt else dct[ch] + 1\n            for key in dct:\n                cnt = dctB.get(key)\n                dctB[key] = dct[key] if not cnt else max(cnt, dct[key])\n\n        res = []\n        for word in A:\n            dct = {}\n            univ = True\n            for ch in word:\n                cnt = dct.get(ch)\n                dct[ch] = 1 if not cnt else dct[ch] + 1\n            for key in dctB:\n                if not dct.get(key) or dct[key] < dctB[key]:\n                    univ = False\n                    break\n            if univ:\n                res.append(word)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        dic = {}\n        res = []\n        for b in B:\n            for char in b:\n                dic[char] = max(dic.get(char, 0), b.count(char))\n        for a in A:\n            if all(a.count(k) >= dic[k] for k in dic):\n                res.append(a)\n        return res\n                \n              \n#https://leetcode.com/problems/word-subsets/discuss/659164/Python-90-with-comments-and-explanation\n", "def createHist(word):\n    hist = {}\n    for c in word:\n        if c in list(hist.keys()):\n            hist[c] += 1\n        else:\n            hist[c] = 1\n    return hist\n\n\ndef isSubset(word1, word2Hist):\n    word1Hist = createHist(word1)\n    for c in list(word2Hist.keys()):\n        if c in list(word1Hist.keys()):\n            word1Occur = word1Hist[c]\n            word2Occur = word2Hist[c]\n            if word2Occur > word1Occur:\n                return False\n        else:\n            return False\n    return True\n        \ndef isUniversal(word, bHist):\n    if isSubset(word, bHist) == False:\n        return False\n    return True\n    \ndef createMaxHistogram(arr):\n    hist = {}\n    for word in arr:\n        wordHist = createHist(word)\n        for key in list(wordHist.keys()):\n            if key in list(hist.keys()):\n                hist[key] = max(hist[key], wordHist[key])\n            else:\n                hist[key] = wordHist[key]\n    return hist\n    \n    \nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        bHist = createMaxHistogram(B)\n        for word in A:\n            if isUniversal(word, bHist):\n                res.append(word)\n        return res\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        d = collections.defaultdict(int)\n        for b in B:\n            b = collections.Counter(b)\n            for x in b:\n                if b[x] > d[x]:\n                    d[x] += b[x] - d[x]\n        uni = []\n        for a in A:\n            c = collections.Counter(a)\n            for i, n in list(d.items()):\n                if i not in c or c[i] < n:\n                    break\n            else:\n                uni.append(a)\n        return uni\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        def is_subset(b_dict, a_dict):\n            for k in b_dict:\n                if k not in a_dict or a_dict[k] < b_dict[k]:\n                    return False\n                \n            return True \n        \n        def get_dict(b):\n            counts = {}\n            for ch in b:\n                counts[ch] = counts.get(ch, 0) + 1\n            return counts\n        \n        b_dicts = [get_dict(b) for b in B]\n        max_b_dict = {}\n        \n        for b_dict in b_dicts:\n            for key in b_dict:\n                max_b_dict[key] = max(max_b_dict.get(key, 0), b_dict[key])\n\n        out = []\n        \n        for a in A:\n            a_dict = get_dict(a)\n            \n            if is_subset(max_b_dict, a_dict):\n                out.append(a)\n                \n        return out \n                \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        d = defaultdict(lambda:0)\n        for b in B:\n            temp = defaultdict(lambda:0)\n            for i in b:\n                temp[i]+=1\n            for k, v in list(temp.items()):\n                d[k] = max(v, d[k])\n        \n        # print(d)\n        output = []\n        for a in A:\n            temp = defaultdict(lambda:0)\n            for i in a:\n                temp[i]+=1\n            # print(temp)\n            add = True\n            for k , v in list(d.items()):\n                if k not in temp or v > temp[k]:\n                    add = False\n                    break\n            if add:\n                output.append(a)\n        return output\n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\ndef getCCnt(w):\n    cnt = {}\n    for c in w:\n        if not c in cnt:\n            cnt[c] = 0\n        cnt[c] += 1\n    return cnt\n\n\nclass Solution:\n\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        minCnt = {}\n        for w in B:\n            cToCnt = getCCnt(w)\n            for c, cnt in cToCnt.items():\n                if not c in minCnt:\n                    minCnt[c] = 0\n                minCnt[c] = max(minCnt[c], cnt)\n        ans = []\n        for w in A:\n            cToCnt = getCCnt(w)\n            good = 1\n            for c, cnt in minCnt.items():\n                if not (c in cToCnt and cToCnt[c] >= minCnt[c]):\n                    good = 0\n                    break\n            if good:\n                ans.append(w)\n        return ans\n\n\\\"\\\"\\\"\nsol = Solution()\nA = [\\\"amazon\\\", \\\"apple\\\", \\\"facebook\\\", \\\"google\\\", \\\"leetcode\\\"]\nB = [\\\"e\\\", \\\"o\\\"]\nB = [\\\"l\\\", \\\"e\\\"]\nB = [\\\"e\\\", \\\"oo\\\"]\nB = [\\\"lo\\\", \\\"eo\\\"]\nB = [\\\"ec\\\", \\\"oc\\\", \\\"ceo\\\"]\nprint(sol.wordSubsets(A, B))\n\\\"\\\"\\\"", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:  \n        dict2 = {}\n        for i2 in B:\n            dict3 = {}\n            for l in i2:\n                if l in dict3.keys():\n                    dict3[l] += 1\n                else:\n                    dict3[l] = 1\n                if l not in dict2.keys():\n                    dict2[l] = 0\n                if dict3[l] > dict2[l]:\n                    dict2[l] = dict3[l]\n        result = []\n        for i in A:\n            dict1 = {}\n            is_subset =True\n            for l1 in i:\n                if l1 in dict1.keys():\n                    dict1[l1] +=1\n                else:\n                    dict1[l1] = 1\n            for key in dict2.keys():\n                if key in dict1.keys():\n                    if dict1[key]<dict2[key]:\n                        is_subset = False\n                else:\n                    is_subset = False\n            if is_subset:\n                result.append(i)\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = set(A)\n        d = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in d or count > d[j]:\n                    d[j] = count\n\n        for i in A:\n            for j in d:\n                if i.count(j) < d[j]:\n                    s.remove(i)\n                    break\n        return list(s)", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bLets = collections.Counter()\n        for w in B:\n            for l, cnt in collections.Counter(w).items():\n                if cnt > bLets[l]:\n                    bLets[l] = cnt\n        bLets = bLets.most_common()\n        result = []\n        for w in A:\n            aLets = collections.Counter(w)\n            for l, cnt in bLets:\n                if cnt > aLets[l]:\n                    break\n            else:\n                result.append(w)\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        final = []\n        D = {}\n        for i in B :\n            b_counter = collections.Counter(i)\n            for j in b_counter:\n                D[j] = max(b_counter[j], D.get(j,0))\n        for i in A:\n            flag = True\n            w = collections.Counter(i)\n            for d in D:\n                if w.get(d) and w[d]>=D[d]:\n                    pass\n                else:\n                    flag = False\n                    break\n            if flag : final.append(i)\n        return final", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ret = []\n        \n        bdict = dict()\n        for word in B:\n            temp = collections.Counter(word)\n            for let, val in temp.items():\n                if let not in bdict:\n                    bdict[let] = val\n                else:\n                    bdict[let] = max(bdict[let], val)\n            \n            \n            \n        for item in A:\n            tempdict = collections.Counter(item)\n            failed = False\n            for let, val in bdict.items():\n                if let not in tempdict:\n                    failed = True\n                    break\n                elif tempdict[let] < val:\n                    failed = True\n                    break\n\n            if not failed:\n                ret.append(item)\n\n        return ret", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        B_dict = collections.defaultdict(int)\n        \n        for elem in B: \n            elem_dict = collections.Counter(elem)\n            for item in elem_dict: \n                B_dict[item] = max(B_dict[item], elem_dict[item])\n        \n        output = []\n        for elem in A:\n            found = True\n            elem_dict = collections.Counter(elem)\n            for item in B_dict:\n                if item not in elem_dict or elem_dict[item] < B_dict[item]:\n                    found = False\n                    break\n            if found:\n                output.append(elem)\n        \n        return output", "from collections import Counter\n\n\nclass Solution:\n    def parse_word(self, word):\n        return Counter(word)\n\n    def update_counter(self, orig, new):\n        for c in new:\n            orig[c] = max(new[c], orig[c])\n        \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        min_universal = Counter()\n        for b in B:\n            bc = Counter(b)\n            self.update_counter(min_universal, bc)\n\n        universals = []\n        for a in A:\n            ac = Counter(a)\n            is_universal = True\n            for c in min_universal:\n                if ac[c] < min_universal[c]:\n                    is_universal = False\n                    break\n            if is_universal:\n                universals.append(a)\n        return universals\n            \n        \n", "import collections\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        bcount = collections.defaultdict(int)\n        for s in B:\n            counter = collections.Counter(s)\n            for c in list(counter.keys()):\n                if bcount[c] < counter[c]:\n                    bcount[c] = counter[c]\n        for s in A:\n            counter = collections.Counter(s)\n            flag = True\n            for c in list(bcount.keys()):\n                if not counter[c] >= bcount[c]:\n                    flag = False\n                    break\n            if flag:\n                res.append(s)\n        return res\n                  \n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        bcounter = Counter()\n        \n        for b in B:\n            bbc = Counter(b)\n            for c in bbc:\n                if c not in bcounter or bbc[c] > bcounter[c]:\n                    bcounter[c] = bbc[c]\n        \n        ans = []\n        for a in A:\n            aac = Counter(a)\n            uni = True\n            for c in bcounter:\n                if c not in aac or aac[c] < bcounter[c]:\n                    uni = False\n                    break\n            if uni: ans.append(a)\n        return ans\n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # Create Dictionary\n        dictionary = dict()\n        for i in range(len(B)):\n            prev_dict = dict(dictionary)\n            for j in range(len(B[i])):\n                char = B[i][j]\n                if char in dictionary:\n                    dictionary[char] += 1\n                else:\n                    dictionary[char] = 1\n                if char not in prev_dict:\n                    prev_dict[char] = 0\n                    \n            for key, value in list(prev_dict.items()):\n                if dictionary[key] - prev_dict[key] > prev_dict[key]:\n                    dictionary[key] -= prev_dict[key]\n                else:\n                    dictionary[key] = prev_dict[key]\n            \n            \n                \n        answer = []\n        for i in range(len(A)):\n            # Reset Dictionary\n            current_dict = dict(dictionary)\n            # print(current_dict)\n            # Manipulate Dictionary\n            for j in range(len(A[i])):\n                char_a = A[i][j]\n                if char_a in current_dict:\n                    current_dict[char_a] -= 1\n            \n            # Check if word passes\n            include_word = True\n            for key, value in list(current_dict.items()):\n                if value > 0:\n                    include_word = False\n            \n            if include_word:\n                answer.append(A[i])\n                \n        return answer\n                    \n            \n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        total = Counter()\n\n        for word in B:\n            counts = Counter(word)\n            for ch, count in list(counts.items()):\n                total[ch] = max(total[ch], count)\n\n        result = []\n        for word in A:\n            counts = Counter(word)\n\n            is_universal = True\n            for ch, count in list(total.items()):\n                if counts[ch] < count:\n                    is_universal = False\n                    break\n\n            if is_universal:\n                result.append(word)\n\n        return result\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        #Time Complexity: O(A+B), where A and B is the total amount of letters in A and B respectively.\n        #Space O(A.length + B).\n        if not B:\n            return A\n        \n        mapB = collections.defaultdict(int) #max required number of each letter of all words in B\n        for b in B:\n            counter = collections.Counter(b)\n            for k in counter:\n                mapB[k] = max(counter[k], mapB[k])\n        \n        \n        res = []\n        for a in A:\n            countA = collections.Counter(a)\n            if all(countA[ch] >= mapB[ch] for ch in mapB ):\n                res.append(a)\n            \n            \n        return res\n                \n                \n                    \n                    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        um={}\n        result=[]\n        for b in B:\n            for letter in b:\n                if letter not in um:\n                    um[letter]=b.count(letter)\n                elif b.count(letter)>um[letter]:\n                    um[letter]=b.count(letter)\n        for a in A:\n            boola= True\n            for i,n in um.items():\n                if (i not in a) or a.count(i)<n:\n                    boola= False\n                    break\n            if boola:\n                result.append(a)\n        return result          ", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        A_cnt, B_cnt = [], collections.defaultdict(int)\n        for a in A:\n            A_cnt += [collections.Counter(a)]\n        for b in B:\n            b_cnt = collections.Counter(b)\n            for key in b_cnt:\n                B_cnt[key] = max(B_cnt[key], b_cnt[key])\n        \n        ret = []\n        for i, a in enumerate(A_cnt):\n            valid = True\n            for key in B_cnt:\n                if a[key] < B_cnt[key]:\n                    valid=False\n                    break\n            \n            if valid:\n                ret += [A[i]]\n        \n        return ret", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        # build maxCountB\n        maxCountB = {}\n        for w in B:\n            c = Counter(w)\n            for k, cnt in list(c.items()):\n                maxCountB[k] = max(maxCountB.get(k, 0), cnt)\n        \n        res = []\n        for w in A:\n            c = Counter(w)\n            isUniversal = True\n            for k, cnt in list(maxCountB.items()):\n                if k not in c or cnt > c[k]:\n                    isUniversal = False\n                    break\n            if isUniversal:\n                res.append(w)\n                \n        return res\n", "from collections import defaultdict, Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        rd = defaultdict(int)\n        for c in map(Counter, B):\n            for i in c:\n                rd[i] = max(rd[i], c[i])\n        \n        # b = \\\"\\\".join([i * rd[i] for i in rd])\n        \n        cts = {i : Counter(i) for i in A}\n        for i in rd:        \n            rdi = rd[i]\n            keep = {}\n            for c in cts:\n                if i in cts[c] and cts[c][i] >= rdi:\n                    keep[c] = cts[c] \n            cts = keep        \n        return cts        \n                    \n        \n                \n                \n            \n                \n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        # let A be length of A and B be length of B\n        # let N be length of longest word in A\n        # let M be length of longest word in B\n        \n        # time: O(AN + BM)\n        # space: O(AN + M)\n        counts_A = [Counter(a) for a in A]\n        word_B = Counter()\n        for b in B:\n            for k, v in Counter(b).items():\n                if k not in word_B or word_B[k] < v:\n                    word_B[k] = v\n        \n        \n        # time: O(AM)\n        # space: O(A)\n        ans = []\n        for i, a in enumerate(counts_A):\n            ind = 1\n            for letter in word_B.keys():\n                if letter not in a or a[letter] < word_B[letter]:\n                    ind = 0 \n                    break\n            if ind:\n                ans.append(A[i])\n        return ans", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        cnt = Counter()\n        for word in B:\n            wordcnt = Counter(word)\n            for c in wordcnt:\n                if cnt[c] < wordcnt[c]:\n                    cnt[c] = wordcnt[c]\n        ans = []\n        for word in A:\n            wordcnt = Counter(word)\n            if all(wordcnt[c] >= cnt[c] for c in cnt):\n                ans.append(word)\n        return ans\n", "from collections import defaultdict, Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        rd = defaultdict(int)\n        for c in map(Counter, B):\n            for i in c:\n                rd[i] = max(rd[i], c[i])\n        \n        # b = \\\"\\\".join([i * rd[i] for i in rd])\n        \n        cts = {i : Counter(i) for i in A}\n        for i in rd:        \n            rdi = rd[i]\n            rm = set()\n            for c in cts:\n                if i not in cts[c] or cts[c][i] < rdi:\n                    rm.add(c)\n            for r in rm:\n                cts.pop(r)\n        return cts        \n                    \n        \n                \n                \n            \n                \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        ret = []\n        \n        bdict = dict()\n        for word in B:\n            temp = collections.Counter(word)\n            for let, val in temp.items():\n                if let not in bdict:\n                    bdict[let] = val\n                else:\n                    bdict[let] = max(bdict[let], val)\n            \n        i = 0\n        while i < len(A):\n            tempdict = collections.Counter(A[i])\n            failed = False\n            for let, val in bdict.items():\n                if let not in tempdict:\n                    failed = True\n                    break\n                elif tempdict[let] < val:\n                    failed = True\n                    break\n\n            if failed:\n                del A[i]\n            else:\n                i = i + 1\n\n        return A", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bdict = dict()\n        for word in B:\n            temp = collections.Counter(word)\n            for let, val in temp.items():\n                if let not in bdict:\n                    bdict[let] = val\n                else:\n                    bdict[let] = max(bdict[let], val)\n            \n        i = 0\n        while i < len(A):\n            tempdict = collections.Counter(A[i])\n            failed = False\n            for let, val in bdict.items():\n                if let not in tempdict:\n                    failed = True\n                    break\n                elif tempdict[let] < val:\n                    failed = True\n                    break\n\n            if failed:\n                del A[i]\n            else:\n                i = i + 1\n\n        return A", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = set(A)\n        letters_required = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in letters_required or count > letters_required[j]:\n                    letters_required[j] = count\n\n        for i in A:\n            for j in letters_required:\n                if i.count(j) < letters_required[j]:\n                    s.remove(i)\n                    break\n        return list(s)\n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        A = [(Counter(a), a) for a in A]\n        B = [Counter(b) for b in B]\n        \n        # calculate universal requirements\n        req = {}\n        for cntr in B:\n            for k,v in list(cntr.items()):\n                req[k] = max(req.get(k, 0), v)\n        \n        # collect sols fulfilling requirements\n        sol = [a for cntr, a in A if all(cntr.get(k, 0) >= v for k,v in list(req.items()))]\n        return sol\n", "class Solution:\n    \\\"\\\"\\\"\n    [\\\"amazon\\\",\\\"apple\\\",\\\"facebook\\\",\\\"google\\\",\\\"leetcode\\\"]\n    [\\\"lo\\\",\\\"eo\\\"]\n    Expected: [\\\"google\\\",\\\"leetcode\\\"]\n        \n    [\\\"amazon\\\",\\\"apple\\\",\\\"facebook\\\",\\\"google\\\",\\\"leetcode\\\"]\n    [\\\"e\\\",\\\"o\\\"]\n    Expected: [\\\"facebook\\\",\\\"google\\\",\\\"leetcode\\\"]\n    \n    [\\\"amazon\\\",\\\"apple\\\",\\\"facebook\\\",\\\"google\\\",\\\"leetcode\\\"]\n    [\\\"e\\\",\\\"oo\\\"]\n    [\\\"facebook\\\",\\\"google\\\"]\n    \\\"\\\"\\\"\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        bchars = collections.defaultdict(int)\n        for b in B:\n            bcount = collections.Counter(b)\n            for key in bcount:\n                bchars[key] = max(bchars[key], bcount[key])\n        result=[]\n        for a in A:\n            achars = collections.Counter(a)\n            subset = True\n            for c in bchars:\n                if bchars[c] <= achars[c]:\n                    continue\n                else:\n                    subset = False\n                    \n            if subset:\n                result.append(a)\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        Acount = {word: collections.Counter(word) for word in A}\n        Bcount = defaultdict(int)\n        for b in B:\n            b = collections.Counter(b)\n            for k, v in b.items():\n                Bcount[k] = max(Bcount[k], v)\n        res = []\n        for word in A:\n            wCount = Acount[word]\n            isWord = True\n            for k, v in Bcount.items():\n                if k in wCount and wCount[k] >= v:\n                    continue\n                else:\n                    isWord = False\n                    break\n            if isWord:\n                res.append(word)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # b_counts = [[0]*(ord('z')-ord('a')) for _ in len(B)]\n        \n        common_counter = defaultdict(int)\n        for b_str in B:\n            b_cnt = Counter(b_str)\n            for b_let, b_let_cnt in b_cnt.items():\n                common_counter[b_let] = max(common_counter[b_let], b_let_cnt)\n                \n        result = []\n        for a_str in A:\n            a_cnt = Counter(a_str)\n            if all(a_cnt.get(c_let, 0) >= c_let_cnt for c_let, c_let_cnt in common_counter.items()):\n                result.append(a_str)\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        d = {}\n        for i in B:\n            temp = Counter(i)\n            for j in temp:\n                d[j] = max(d.get(j,0),temp[j])\n        \n        ans = []\n        for i in A:\n            temp = Counter(i)\n            flag = True\n            for j in d:\n                if(temp.get(j) and temp[j] >= d[j]):\n                    pass\n                else:\n                    flag = False\n                    break\n            if flag:\n                ans.append(i)\n        return ans\n", "import collections\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        B_count = collections.Counter()\n        for ele in B:\n            B_count |= collections.Counter(ele)\n        res = []\n        for ele in A:\n            ele_count = collections.Counter(ele)\n            for letter,count in list(B_count.items()):\n                if ele_count[letter]<count:\n                    break\n            else:\n                res.append(ele)\n        return res\n                \n        \n        \n        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b_chars = defaultdict(int)\n        for b in B:\n            chars = Counter(b)\n            for c in b:\n                b_chars[c] = max(b_chars[c], chars[c])\n        output = []\n        for a in A:\n            a_chars = Counter(a)\n            if all(a_chars[c] >= b_chars[c] for c in b_chars):\n                output.append(a)    \n        return output", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        book = collections.defaultdict(int)\n        for b in B:\n            book2 = Counter(b)\n            for bb in book2:\n                book[bb] = max(book[bb], book2[bb]) \n        \n        res = []\n        for a in A:\n            aa = Counter(a)\n            if all(k in aa and aa[k] >= book[k] for k in book):\n                res.append(a)\n        return res\n            \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        # b_counts = [[0]*(ord('z')-ord('a')) for _ in len(B)]\n        \n        b_counters = [Counter(b_str) for b_str in B]\n        common_counter = defaultdict(int)\n        for b_cnt in b_counters:\n            for b_let, b_let_cnt in b_cnt.items():\n                common_counter[b_let] = max(common_counter[b_let], b_let_cnt)\n                \n        result = []\n        for a_str in A:\n            a_cnt = Counter(a_str)\n            if all(a_cnt.get(c_let, 0) >= c_let_cnt for c_let, c_let_cnt in common_counter.items()):\n                result.append(a_str)\n        return result", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        counter_b = Counter()\n        \n        for b in B:\n            for key, freq in Counter(b).items():\n                counter_b[key] = max(counter_b[key], freq)\n            \n        ans = []\n        for a in A:\n            counter_a = Counter(a)\n            for key, freq in counter_b.items():\n                if counter_a[key] < freq:\n                    break\n            else:\n                ans.append(a)\n        \n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \n        d, ret = {}, []\n        \n        for word in B:\n            \n            b = Counter(word)\n            \n            for key, val in list(b.items()):\n                \n                if key not in d:\n                    d[key] = val\n                else:\n                    d[key] = max(d[key],  val)\n                \n        \n        for cand in A:\n            flag = True\n            a = Counter(cand)\n            \n            for key, val in list(d.items()):\n                \n                if key not in a or val > a[key]:\n                    \n                    flag = False\n            \n            if flag:\n                ret.append(cand)\n        \n        return ret\n                \n                \n                \n", "import collections as clc\n\n\nclass Solution:\n    \n    def subset(self, counter1: clc.Counter, counter2: clc.Counter) -> bool:\n        return all(cnt1 <= counter2[char] for char, cnt1 in counter1.items())\n    \n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        max_b_counter = clc.Counter()\n        for b in B:\n            for char, cnt in clc.Counter(b).items():\n                max_b_counter[char] = max(max_b_counter[char], cnt)\n        ans = []\n        for a in A:\n            if self.subset(max_b_counter, clc.Counter(a)):\n                ans.append(a)\n        return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        d = collections.Counter()\n        \n        for w in B:\n            for c,n in collections.Counter(w).items():\n                d[c] = max(n,d[c]) #max(2,1)\n        res =[]\n        for w in A:\n            t = collections.Counter(w)\n            if all(t[x]>=d[x] for x in d):\n                res.append(w)\n        return res", "from collections import Counter\n\n\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        \\\"\\\"\\\"\n        https://youtu.be/-IPzqZeVmr4?t=755\n        \\\"\\\"\\\"\n        result = []\n        b_count = Counter()\n        for b in B:\n            for char, cnt in Counter(b).items():\n                b_count[char] = max(b_count[char], cnt)\n\n        for a in A:\n            a_count = Counter(a)\n            if all(a_count[char] >= b_count[char] for char in b_count):\n                result.append(a)\n\n        return result\n", "from collections import Counter\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        res = []\n        counter_b = Counter()\n        for b in B:\n            tmp = Counter(b)\n            for t in tmp:\n                counter_b[t] = max(counter_b[t], tmp[t])\n        for a in A:\n            count = Counter(a)\n            invalid = False\n            for c in counter_b:\n                if count[c] < counter_b[c]:\n                    invalid = True\n            if not invalid:\n                res.append(a)\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        max_b_counter = defaultdict(int)\n        \n        for word in B:\n            word_counter = Counter(word)\n            \n            for char, counter in list(word_counter.items()):\n                max_b_counter[char] = max(max_b_counter[char], word_counter[char])\n        \n        result = []\n        \n        for word in A:\n            word_counter = Counter(word)\n            \n            if all([max_b_counter[char] <= word_counter[char] for char in max_b_counter]):\n                result.append(word)\n        \n        return result\n\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = set(A)\n        letters_required = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in letters_required or count > letters_required[j]:\n                    letters_required[j] = count\n\n        for i in A:\n            for j in letters_required:\n                if i.count(j) < letters_required[j]:\n                    s.remove(i)\n                    break\n        return list(s)\n        # m = {}\n        # for i in range(26):\n        #     letter = chr(ord('a')+i)\n        #     m[letter] = 0\n        #     for w in B:\n        #         ct_curr_l = 0\n        #         for l in w:\n        #             if l == letter:\n        #                 ct_curr_l+=1\n        #         m[letter] = max(m[letter],ct_curr_l)\n        # res = []\n        # for w in A:\n        #     A_m = {}\n        #     rt = True\n        #     for l in w:\n        #         if not l in A_m:\n        #             A_m[l] = 0\n        #         A_m[l]+=1\n        #     for k in m:\n        #         if m[k]>0 and ((k not in A_m) or (A_m[k]<m[k])):\n        #             rt = False\n        #     if rt == True:\n        #         res.append(w)\n        # return res\n                \n                \n        \n                \n                \n                \n", "import collections\nclass Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        #Time Complexity: O(A+B), where A and B is the total amount of letters in A and B respectively.\n        #Space O(A.length + B.length).\n        if not B:\n            return A\n        \n        mapB = defaultdict(int) #max required number of each letter of all words in B\n        for b in B:\n            counter = Counter(b)\n            for k in counter:\n                mapB[k] = max(counter[k], mapB[k])\n        \n        res = []\n        for a in A:\n            countA = Counter(a)\n            if all( [ countA[ch] >= mapB[ch] for ch in mapB ] ):\n                res.append(a)     \n            \n        return res\n                \n                \n                    \n                    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        b=collections.Counter(B[0])\n        f=collections.defaultdict(int)\n        for x in B:\n            p=Counter(x)\n            for k in list(p.keys()):\n                if k in b:\n                    b[k]=max(p[k],b[k])\n                else:\n                    b[k]=p[k]\n        res=[]\n        for word in A:\n            word_counter=collections.Counter(word)\n            add=True\n            for i in b:\n                if i not in word_counter or b[i]>word_counter[i]:\n                    add=False\n            if add:\n                res.append(word)\n        return res    \n                    \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        counter = Counter()\n        for b in B:\n            cb = Counter(b)\n            for ch in cb:\n                counter[ch] = max(counter[ch], cb[ch])\n        ans = []\n        for a in A:\n            ca = Counter(a) \n            if all(ca[ch] >= counter[ch] for ch in counter):\n                ans.append(a)\n        return ans        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        a_counts = [Counter(a) for a in A]\n        b_count = Counter()\n        for b in B:\n            for l, c in list(Counter(b).items()):\n                b_count[l] = max(b_count[l], c)\n        uni = []\n        for i, ac in enumerate(a_counts):\n            is_universal = True\n            for l, c in list(b_count.items()):\n                if ac[l] < c:\n                    is_universal = False\n                    break\n            if is_universal:\n                uni.append(A[i])\n        return uni\n", "import collections\n\nclass Solution:\n  def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n    A = [(a,collections.Counter(a)) for a in A]\n    newB = {}\n    for b in B:\n      for x, c in collections.Counter(b).items():\n          newB[x] = c if x not in newB else max(newB[x], c)\n      \n    B = newB\n    \n    ans = []\n    for a, counts in A:\n      allMatch = True\n      \n      for x,c in B.items():\n        if counts[x] < c:\n          allMatch = False\n          break\n      \n      if allMatch: ans.append(a)\n\n    return ans", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        a_counter = [Counter(a) for a in A]\n        b_counter = [Counter(b) for b in B]\n        \n        bc = {}\n        for counter in b_counter:\n            for b, frequency in counter.items():\n                if b in bc:\n                    bc[b] = max(bc[b], frequency)\n                else:\n                    bc[b] = frequency\n                    \n        def is_bc_in_ac(ai, ac):\n            if len(bc) > len(A[ai]):\n                return False\n\n            for l, frequency in bc.items():\n                if ac[l] < frequency:\n                    return False\n            return True\n        \n        res = []\n        for ai, ac in enumerate(a_counter):\n            if is_bc_in_ac(ai, ac):\n                res.append(A[ai])\n        return res", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        maxcb = Counter()\n        for b in B:\n            for ch in (cb := Counter(b)):\n                maxcb[ch] = max(maxcb[ch], cb[ch])\n        ans = []\n        for a in A:\n            ca = Counter(a) \n            if all(ca[ch] >= maxcb[ch] for ch in maxcb):\n                ans.append(a)\n        return ans        \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        hashmap=defaultdict(int)\n        for i in B:\n            c=defaultdict(int)\n            for p in i:\n                c[p]+=1\n            for n in c:\n                hashmap[n]=max(hashmap[n],c[n])\n        \n        \n        result=[]\n        for i in A:\n            count=defaultdict(int)\n            for c in i:\n                count[c]+=1\n            flag=True\n            for node in hashmap:\n                if node not in count or count[node]<hashmap[node]:\n                    flag=False\n            if flag :\n                result.append(i)\n        return result       \n                \n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        need = Counter()\n        \n        for word in B:\n            word_count = Counter(word)\n            for k, v in list(word_count.items()):\n                need[k] = max(need[k], v)\n\n        def is_subset(word):\n            word_count = Counter(word)\n\n            for c in need:\n                word_count[c] -= need[c]\n                if word_count[c] < 0:\n                    return False\n            \n            return True\n            \n        res = []\n        for word in A:\n            if is_subset(word):\n                res.append(word)\n        \n        return res\n\n", "class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        max_counts = collections.defaultdict(int)\n        for b in B:\n            counts = collections.Counter(b)\n            for char, count in list(counts.items()):\n                max_counts[char] = max(max_counts[char], count)\n                \n        universals = []\n        for a in A:\n            counts = collections.Counter(a)\n            for char, max_count in list(max_counts.items()):\n                if counts[char] < max_count:\n                    break\n            else:\n                universals.append(a)\n                \n        return universals\n"]
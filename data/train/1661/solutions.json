["from collections import deque\nimport re\n\nTOKENIZER = re.compile(r'(R+|F+|L+|\\)|\\()(\\d*)')\n\ndef parseCode(code):\n    cmds = [[]]\n    for cmd,n in TOKENIZER.findall(code):\n        s,r = cmd[0], int(n or '1') + len(cmd)-1\n        if   cmd == '(': cmds.append([])\n        elif cmd == ')': lst = cmds.pop() ; cmds[-1].extend(lst*r)\n        else:            cmds[-1] += [(s, r)]\n    return cmds[0]\n\ndef execute(code):\n\n    pos, dirs = (0,0), deque([(0,1), (1,0), (0,-1), (-1,0)])\n    seens = {pos}\n    \n    for s,r in parseCode(code):\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple( z+dz for z,dz in zip(pos, dirs[0]) )\n                seens.add(pos)\n        else:\n            dirs.rotate( (r%4) * (-1)**(s == 'R') )\n    \n    miX, maX = min(x for x,y in seens), max(x for x,y in seens)\n    miY, maY = min(y for x,y in seens), max(y for x,y in seens)\n    \n    return '\\r\\n'.join( ''.join('*' if (x,y) in seens else ' ' for y in range(miY, maY+1)) \n                        for x in range(miX, maX+1) )", "import re\n\ndef execute(code):\n    def simplify_code(code):\n        while '(' in code:\n            code = re.sub(r'\\(([^()]*)\\)(\\d*)',\n                lambda match: match.group(1) * int(match.group(2) or 1),\n                code)\n        code = re.sub(r'([FLR])(\\d+)',\n                lambda match: match.group(1) * int(match.group(2)),\n                code)\n        return code\n\n    def compute_path(simplified_code):\n        pos, dir = (0, 0), (1, 0)\n        path = [pos]\n        for cmd in simplified_code:\n            if cmd == 'F':\n                pos = tuple(a + b for a, b in zip(pos, dir))\n                path.append(pos)\n            elif cmd == 'L':\n                dir = (dir[1], -dir[0])\n            elif cmd == 'R':\n                dir = (-dir[1], dir[0])\n        return path\n\n    def compute_bounding_box(path):\n        min_x = min(pos[0] for pos in path)\n        min_y = min(pos[1] for pos in path)\n        max_x = max(pos[0] for pos in path)\n        max_y = max(pos[1] for pos in path)\n        return (min_x, min_y), (max_x, max_y)\n\n    def build_grid(path):\n        min_xy, max_xy = compute_bounding_box(path)\n        width = max_xy[0] - min_xy[0] + 1\n        height = max_xy[1] - min_xy[1] + 1\n        grid = [[' '] * width for _ in range(height)]\n        for x, y in path:\n            grid[y - min_xy[1]][x - min_xy[0]] = '*'\n        return grid\n\n    def grid_to_string(grid):\n        return '\\r\\n'.join(''.join(row) for row in grid)\n\n    code = simplify_code(code)\n    path = compute_path(code)\n    grid = build_grid(path)\n    return grid_to_string(grid)", "import re\nfrom enum import Enum\nfrom operator import itemgetter\nfrom typing import List, Tuple, Set, Generator, Match\n\n\nCell = Tuple[int, int]\n\n\nclass Direction(Enum):\n    UP = (0, 1)\n    DOWN = (0, -1)\n    RIGHT = (1, 0)\n    LEFT = (-1, 0)\n\n\ndef execute(code: str) -> str:\n    visited_cells = visit_cells(code)\n    path = draw_path(visited_cells)\n    return path\n    \n    \ndef visit_cells(code: str) -> Set[Cell]:\n    visited_cells = [(0, 0)]\n    direction = Direction.RIGHT\n    \n    for action, n_times in code_interpreter(code):\n        if action == 'F':\n            new_cells = move_forward(visited_cells[-1], direction, n_times)\n            visited_cells.extend(new_cells)\n        else:\n            direction = make_turn(direction, action, n_times)\n    return set(visited_cells)\n\n\ndef code_interpreter(code: str) -> Generator[Tuple[str, int], None, None]:\n    code = unroll_code(code)\n    for move in re.finditer(r'([LRF])(\\d*)', code):\n        action = move.group(1)\n        n_times = int(move.group(2)) if move.group(2) else 1\n        yield action, n_times\n        \n        \ndef unroll_code(code: str) -> str:\n    base_command = r'[FLR]\\d*'\n    composed = fr'\\((?P<command>({base_command})+)\\)(?P<repeat>\\d*)'\n    \n    while True:\n        prev_code = code\n        code = re.sub(composed, unroll_command, prev_code)\n        if code == prev_code:\n            break\n    return code\n\ndef unroll_command(match: Match) -> str:\n    repeat = int(match['repeat']) if match['repeat'] else 1\n    return match['command'] * repeat\n    \n\ndef move_forward(position: Cell, direction: Direction, n_moves: int) -> List[Cell]:\n    px, py = position\n    dx, dy = direction.value\n    return [(px + i * dx, py + i * dy) for i in range(1, n_moves + 1)]\n\n\ndef make_turn(start: Direction, side: str, n_turns: int) -> Direction:\n    ordering = [Direction.RIGHT, Direction.DOWN, Direction.LEFT, Direction.UP]\n    step = 1 if side == 'R' else -1\n    return ordering[(ordering.index(start) + step * n_turns) % len(ordering)]\n    \n    \ndef draw_path(visited_cells: Set[Cell]) -> str:\n    max_x, min_x, max_y, min_y = find_cells_boundaries(visited_cells)\n    \n    rectangle = list()\n    for y in range(max_y, min_y - 1, -1):\n        row = ['*' if (x, y) in visited_cells else ' ' for x in range(min_x, max_x + 1)]\n        rectangle.append(''.join(row))\n    \n    return '\\r\\n'.join(rectangle)\n    \n    \ndef find_cells_boundaries(visited_cells: Set[Cell]) -> Tuple[int, int, int, int]:\n    max_x, _ = max(visited_cells, key=itemgetter(0))\n    min_x, _ = min(visited_cells, key=itemgetter(0))\n    \n    _, max_y = max(visited_cells, key=itemgetter(1))\n    _, min_y = min(visited_cells, key=itemgetter(1))\n    return max_x, min_x, max_y, min_y\n", "def execute(code):\n    R, r, c, dr, dc = {(0, 0)}, 0, 0, 0, 1\n    D = {(1, 0):{'R':(0, -1), 'L':(0, 1)}, (-1, 0):{'R':(0, 1), 'L':(0, -1)}, (0, 1):{'R':(1, 0), 'L':(-1, 0)}, (0, -1):{'R':(-1, 0), 'L':(1, 0)}}\n    \n    while ')' in code:\n        for i, v in enumerate(code):\n            if v == '(': lastopen = i\n            if v == ')':\n                n, k = '', i + 1\n                while code[k:k+1].isdigit(): \n                    n, k = n + code[k], k + 1                \n                code = code[:lastopen] + code[lastopen+1:i] * int(n or '1') + code[k:]\n                break\n\n    for cmd in code.replace('R', ' R').replace('L', ' L').replace('F', ' F').strip().split():\n        cmd, n = cmd[:1], int(cmd[1:]) if cmd[1:] else 1\n        for _ in range(n):\n            if cmd in 'RL':             \n                dr, dc = D[(dr, dc)][cmd]\n            else:\n                r, c = r + dr, c + dc\n                R.add((r, c))\n                \n    mnr, mnc = min(r for r, _ in R), min(c for _, c in R)\n\n    R = {(r - mnr, c - mnc) for r, c in R}\n    \n    mxr, mxc = max(r for r, _ in R), max(c for _, c in R)           \n    \n    return '\\r\\n'.join(''.join(' *'[(r, c) in R] for c in range(mxc+1)) for r in range(mxr+1))", "import re\nfrom collections import defaultdict, deque\ndef execute(code):\n    dirs = deque([(0, 1), (-1, 0), (0, -1), (1, 0)])\n    yarr, xarr = [0], [0]\n    while True:\n        code, n = re.subn('\\(([^()]+)\\)(\\d*)', lambda m: m.group(1) * int(m.group(2) or 1), code)\n        if not n:\n            break\n    for c in ''.join(a * int(b or 1) for a, b in re.findall('(\\D)(\\d*)', code)):\n        if c == 'F':\n            dy, dx = dirs[0]\n            xarr.append(xarr[-1] + dx)\n            yarr.append(yarr[-1] + dy)\n        if c == 'L':\n            dirs.rotate(-1)\n        if c == 'R':\n            dirs.rotate(1)\n    xmin, xmax = min(xarr), max(xarr)\n    ymin, ymax = min(yarr), max(yarr)\n    d = dict(zip(zip(yarr, xarr), '*' * len(xarr)))\n    return '\\r\\n'.join(''.join(d.get((y, x), ' ') for x in range(xmin, xmax + 1)) for y in range(ymin, ymax + 1))", "from typing import Tuple, Optional, Union, Any, List, Dict, Callable, Iterator\nfrom enum import Enum, auto\nimport re\n\nOptFunc = Optional[Callable[[], Any]]\n\ninstructions_pattern = re.compile(r'F+\\d*|L+\\d*|R+\\d*')\n\n\nclass BufferedIterator:\n    _iter: Iterator[str]\n    _stack: List[str]\n\n    def __init__(self, it: Iterator[str]):\n        self._iter = it\n        self._stack = []\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._stack:\n            return self._stack.pop()\n        else:\n            return next(self._iter)\n\n    def push(self, s):\n        self._stack.append(s)\n\n\nclass StringBuf:\n    _text: str\n\n    def __init__(self, s: Optional[str] = None):\n        self._text = s or ''\n\n    def __str__(self):\n        return self._text\n\n    def __repr__(self):\n        return f'StringBuf({self._text!r})'\n\n    def append(self, s: str):\n        self._text += s\n\n    def prepend(self, s: str):\n        self._text = s + self._text\n\n    def __getitem__(self, idx):\n        return self._text[idx]\n\n    def __setitem__(self, idx, value):\n        if isinstance(idx, int):\n            self._text = self._text[:idx] + value + self._text[(idx + len(value)):]\n\n\nclass Rotation(Enum):\n    No = auto()\n    Left = auto()\n    Right = auto()\n\n    def switch(self, right: OptFunc = None, left: OptFunc = None, none: OptFunc = None) -> Any:\n        if self is self.Right:\n            if right is not None:\n                return right()\n        elif self is self.Left:\n            if left is not None:\n                return left()\n        elif self is self.No:\n            if none is not None:\n                return none()\n\n        return None\n\n\nclass Direction(Enum):\n    Up = 0\n    Right = 1\n    Down = 2\n    Left = 3\n\n    @staticmethod\n    def from_num(count: int) -> 'Direction':\n        return Direction((4 - (-count % 4)) % 4 if count < 0 else count % 4)\n\n    def to_num(self) -> int:\n        return self.value\n\n    def switch(self, up: OptFunc = None, right: OptFunc = None, down: OptFunc = None, left: OptFunc = None) -> Any:\n        if self is self.Up:\n            if up is not None:\n                return up()\n        elif self is self.Right:\n            if right is not None:\n                return right()\n        elif self is self.Down:\n            if down is not None:\n                return down()\n        elif self is self.Left:\n            if left is not None:\n                return left()\n\n        return None\n\n    def next(self, pos: Tuple[int, int], count: int) -> Tuple[int, int]:\n        return self.switch(\n            up=lambda: (pos[0], pos[1] - count),\n            right=lambda: (pos[0] + count, pos[1]),\n            down=lambda: (pos[0], pos[1] + count),\n            left=lambda: (pos[0] - count, pos[1]),\n        )\n\n    def change(self, rot: Rotation, count: int) -> 'Direction':\n        return rot.switch(\n            left=lambda: Direction.from_num(self.to_num() - count),\n            right=lambda: Direction.from_num(self.to_num() + count),\n            none=lambda: self,\n        )\n\n\nclass TheGridForTron:\n    _grid: List[StringBuf]\n    _size: int\n    _org: Tuple[int, int]\n    _pos: Tuple[int, int]\n    _dir: Direction\n\n    def __init__(self):\n        self._grid = [StringBuf('*')]\n        self._size = 1\n        self._org = (0, 0)\n        self._pos = (0, 0)\n        self._dir = Direction.Right\n\n    def _grow(self):\n        # Grow to left\n        diff = self._org[0] - self._pos[0]\n        if diff > 0:\n            self._org = (self._pos[0], self._org[1])\n            self._size += diff\n\n            s = ' ' * diff\n\n            for line in self._grid:\n                line.prepend(s)\n\n            return\n\n        # Grow to up\n        diff = self._org[1] - self._pos[1]\n        if diff > 0:\n            self._org = (self._org[0], self._pos[1])\n\n            s = ' ' * self._size\n            for _ in range(diff):\n                self._grid.insert(0, StringBuf(s))\n\n            return\n\n        # Grow to right\n        diff = self._pos[0] - (self._org[0] + self._size) + 1\n        if diff > 0:\n            s = ' ' * diff\n\n            self._size += diff\n            for line in self._grid:\n                line.append(s)\n\n            return\n\n        # Grow to down\n        diff = self._pos[1] - (self._org[1] + len(self._grid)) + 1\n        if diff > 0:\n            s = ' ' * self._size\n            for _ in range(diff):\n                self._grid.append(StringBuf(s))\n\n    def _trace_path(self, old: Tuple[int, int]):\n        def up():\n            pos = self._pos[0] - self._org[0]\n            org = self._org[1]\n\n            for line in self._grid[(self._pos[1] - org):(old[1] - org)]:\n                line[pos] = '*'\n\n        def right():\n            self._grid[self._pos[1] - self._org[1]][old[0] + 1 - self._org[0]] = '*' * (self._pos[0] - old[0])\n\n        def down():\n            pos = self._pos[0] - self._org[0]\n            org = self._org[1]\n\n            for line in self._grid[(old[1] + 1 - org):(self._pos[1] + 1 - org)]:\n                line[pos] = '*'\n\n        def left():\n            self._grid[self._pos[1] - self._org[1]][self._pos[0] - self._org[0]] = '*' * (old[0] - self._pos[0])\n\n        self._dir.switch(\n            up=up,\n            right=right,\n            down=down,\n            left=left,\n        )\n\n    def do_move(self, rot: Rotation, count: int):\n        if rot is Rotation.No:\n            old = self._pos\n\n            self._pos = self._dir.next(self._pos, count)\n            self._grow()\n            self._trace_path(old)\n        else:\n            self._dir = self._dir.change(rot, count)\n\n    def serialize(self) -> str:\n        return '\\r\\n'.join(map(str, self._grid))\n\n\nclass Executor:\n    _grid: TheGridForTron\n    _actions: Dict[str, Callable[[int], Any]]\n\n    def __init__(self, grid: TheGridForTron):\n        self._grid = grid\n        self._actions = {\n            'F': lambda cnt: self._grid.do_move(Rotation.No, cnt),\n            'L': lambda cnt: self._grid.do_move(Rotation.Left, cnt),\n            'R': lambda cnt: self._grid.do_move(Rotation.Right, cnt),\n        }\n\n    def do_actions(self, code: str):\n        for m in instructions_pattern.finditer(code):\n            action, count = parse_instruction(m.group())\n\n            self._actions.get(action, lambda _: None)(count)\n\n\ndef expand_code(code: BufferedIterator) -> str:\n    res: str = ''\n    sub_str: str = ''\n    in_group: bool = False\n    count: Union[None, int] = None\n\n    for ch in code:\n        if in_group:\n            try:\n                count = ((count or 0) * 10) + int(ch)\n            except ValueError:\n                code.push(ch)\n                if count is not None:\n                    sub_str *= count\n                    count = None\n\n                res += sub_str\n                sub_str = ''\n                in_group = False\n        else:\n            if ch == ')':\n                break\n\n            if ch == '(':\n                sub_str = expand_code(code)\n                in_group = True\n                continue\n\n            res += ch\n\n    if sub_str:\n        if count is not None:\n            sub_str *= count\n\n        res += sub_str\n\n    return res\n\n\ndef parse_instruction(code: str) -> Tuple[str, int]:\n    c = code[0]\n\n    count = code.lstrip(c)\n    n = len(code) - len(count)\n\n    if count:\n        n += int(count) - 1\n\n    return c, n\n\n\ndef execute(code: str) -> str:\n    grid = TheGridForTron()\n\n    Executor(grid).do_actions(expand_code(BufferedIterator(iter(code))))\n\n    return grid.serialize()\n", "def execute(code):\n    path = translatePath(createPath(transformCode(removeBrackets(code))))\n    if path == \"\":\n        return \"*\"\n    xmax = 0\n    ymax = 0\n    for coordinate in path:\n        if coordinate[0] > xmax:\n            xmax = coordinate[0]\n        if coordinate[1] > ymax:\n            ymax = coordinate[1]\n    grid = []\n    for something in range(ymax+1):\n        grid.append((xmax + 1) * [' '])\n    for visited in path:\n        grid[visited[1]][visited[0]] = '*'\n    finalstring = \"\"\n    for row in grid:\n        for elem in row:\n            finalstring += elem\n        finalstring += \"\\r\\n\"    \n    return finalstring[:-2]\ndef removeBrackets(rscommand):\n    # check for brackets\n    if rscommand.find('(') == -1:\n        return rscommand\n    found = False\n    indeks = 0\n    openbracketindex = 0\n    closingbracketindex = 0\n    while not found and indeks < len(rscommand):\n        if rscommand[indeks] == '(':\n            openbracketindex = indeks\n        if rscommand[indeks] == ')':\n            closingbracketindex = indeks\n            found = True\n        indeks += 1\n    leftpart = rscommand[:openbracketindex]\n    rightpart = rscommand[closingbracketindex + 1:]\n    middlepart = rscommand[openbracketindex+1:closingbracketindex]\n    \n    #find number in rightpart\n    factor = \"\"\n    indeks = 0\n    if len(rightpart) > 0:\n        while rightpart[indeks].isdigit():\n            factor += rightpart[indeks]\n            indeks += 1\n            if indeks == len(rightpart):\n                break    \n    \n    if indeks > 0:\n        newcommand = leftpart + int(factor)* middlepart + rightpart[indeks:]\n    else:\n        newcommand = leftpart + middlepart + rightpart\n    return removeBrackets(newcommand)\ndef createPath(command):\n    state = [0,0,\"E\"]\n    path = [[0,0]]\n    for x in command:\n        if x == 'L' or x == 'R':\n            state = makeTurn(state,x)\n        else:\n            state = moveForward(state)\n            path.append([state[0],state[1]])\n    \n    return path\ndef translatePath(path):\n    minx = 0\n    miny = 0\n    for c in path:\n        if c[0] < minx:\n            minx = c[0]\n        if c[1] < miny:\n            miny = c[1]\n    #translate path\n    for c in path:\n        c[0] = c[0] - minx\n        c[1] = c[1] - miny\n    return path \ndef moveForward(state):\n    #state[0] = x coordinate\n    #state[1] = y coordinate\n    #state[2] = direction N, S, E or W\n    if state[2] == \"N\":\n        return [state[0],state[1]-1,state[2]]\n    if state[2] == \"S\":\n        return [state[0],state[1]+1,state[2]]\n    if state[2] == \"W\":\n        return [state[0]-1,state[1],state[2]]\n    # remaing direction is east_asian_width\n    return [state[0]+1,state[1],state[2]]\ndef makeTurn(state,leftorright):\n    if leftorright == \"L\":\n        if state[2] == \"N\" :\n            return [state[0],state[1], \"W\"]\n        if state[2] == \"W\" :\n            return [state[0],state[1], \"S\"]\n        if state[2] == \"S\" :\n            return [state[0],state[1], \"E\"]\n        if state[2] == \"E\" :\n            return [state[0],state[1], \"N\"]\n    if leftorright == \"R\":\n        if state[2] == \"N\" :\n            return [state[0],state[1], \"E\"]\n        if state[2] == \"W\" :\n            return [state[0],state[1], \"N\"]\n        if state[2] == \"S\" :\n            return [state[0],state[1], \"W\"]\n        if state[2] == \"E\" :\n            return [state[0],state[1], \"S\"]\ndef transformCode(code):\n    newcode = \"\"\n    indeks = 0\n    while indeks < len(code):\n        while not code[indeks].isdigit():\n            newcode += code[indeks]\n            indeks += 1\n            if indeks == len(code):\n                break\n        if indeks == len(code):\n                break\n        #found a digit\n        factor = \"\"\n        while code[indeks].isdigit():\n            factor += code[indeks]\n            indeks += 1\n            if indeks == len(code):\n                break\n        newcode = newcode[:-1] + int(factor) * newcode[-1]\n    return newcode", "from collections import deque\nimport re\nfrom collections import namedtuple\n\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\nRIGHT = 0\nUP = 1\nLEFT = 2\nDOWN = 3\n\nDIRECTIONS = [\n    Point(1, 0),\n    Point(0, -1),\n    Point(-1, 0),\n    Point(0, 1),\n]\n\nFORWARD = 1\nBACKWARD = -1\n\ndef generate_jump_map(code):\n    jump_map = {}\n    \n    opening_bracket_stack = deque()\n    \n    for i, c in enumerate(code):\n        if c == '(':\n            opening_bracket_stack.append(i)\n        elif c == ')':\n            opening_index = opening_bracket_stack.pop()\n            jump_map[i] = opening_index\n            jump_map[opening_index] = i\n    \n    return jump_map\n\nexecution_count_pattern = re.compile(r\"\\d*\")\n\ndef code_unwrap(code):\n    jump_map = generate_jump_map(code)\n    \n    def code_unwrap_inner(code, ip, end_address):\n        while ip < end_address:\n            execution_count_str = execution_count_pattern.match(code[ip+1:]).group(0)\n            execution_count = int(execution_count_str or \"1\")\n            \n            for _ in range(execution_count):\n                if code[ip] == ')':\n                    # Recursively unwrap the inner part\n                    yield from code_unwrap_inner(code, jump_map[ip] + 1, ip)\n                elif code[ip] == '(':\n                    # Jump to the end to find out how often it has to run\n                    ip = jump_map[ip] - 1\n                else:\n                    yield code[ip]\n            ip += 1 + len(execution_count_str)\n                \n    yield from code_unwrap_inner(code, 0, len(code))\n\ndef execute(code):\n    visited = {Point(0, 0)}\n    pos = Point(0, 0)\n    direction = RIGHT\n    \n    def get_area():\n        xmin = 2**30\n        xmax = -2**30\n        ymin = 2**30\n        ymax = -2**30\n        \n        for x, y in visited:\n            xmin = min(xmin, x)\n            xmax = max(xmax, x)\n            ymin = min(ymin, y)\n            ymax = max(ymax, y)\n        \n        return xmin, xmax, ymin, ymax\n    \n    for c in code_unwrap(code):\n        if c == 'F':\n            delta = DIRECTIONS[direction]\n            pos = Point(pos.x + delta.x, pos.y + delta.y)\n            visited.add(pos)\n        elif c == 'L':\n            direction = (direction + 1) % 4\n        elif c == 'R':\n            direction = (direction - 1) % 4\n    \n    xmin, xmax, ymin, ymax = get_area()\n    \n    ret = '\\r\\n'.join(\n        ''.join(\n            '*' if (x, y) in visited else ' '\n            for x in range(xmin, xmax+1)\n        )\n        for y in range(ymin, ymax+1)\n    )\n    # print(ret)\n    return ret\n            \n    \n    \n", "def execute(code):\n    x, y = 0, 1\n    direction = 1\n    visited = {(x, y)}\n    loops = []\n    i = 0\n    while i < len(code):\n        c = code[i]\n        i += 1\n        if c == '(':\n            j = i\n            p = 1\n            while p:\n                if code[j] == '(': p += 1\n                elif code [j] == ')': p -= 1\n                j += 1\n            k = j\n            while k < len(code) and code[k].isdigit(): k += 1\n            reps = int(code[j:k]) if k > j else 1\n            if reps == 0:\n                i = k\n                continue\n            loops.append((i, reps-1))\n        elif c == ')':\n            start, reps = loops.pop()\n            if reps:\n                loops.append((start, reps-1))\n                i = start\n        elif c not in 'FLR': raise RuntimeError(f'Unknown command: {c}')\n        j = i\n        while i < len(code) and code[i].isdigit():\n            i += 1\n        steps = int(code[j:i]) if i > j else 1\n        if c == 'F':\n            for _ in range(steps):\n                x += dx[direction]\n                y += dy[direction]\n                visited.add((x, y))\n        elif c == 'R': direction = (direction + steps) % 4\n        elif c == 'L': direction = (direction - steps) % 4\n    min_x = min(x for x, y in visited)\n    min_y = min(y for x, y in visited)\n    width = max(x for x, y in visited) - min_x + 1\n    height = max(y for x, y in visited) - min_y + 1\n    grid = [[' '] * width for _ in range(height)]\n    for x, y in visited: grid[y-min_y][x-min_x] = '*'\n    return '\\r\\n'.join(''.join(row) for row in grid)\n\ndx = 0, 1, 0, -1\ndy = -1, 0, 1, 0\n", "from re import findall\n\ndirs = { 0: (1, 0), 1: (0, 1), 2: (-1, 0), 3: (0, -1)}\n\ndef find_sub(tokens):\n    start = None\n    for i in range(len(tokens)):\n        if tokens[i] == '(':\n            start = i\n        elif tokens[i][0] == ')':\n            return (start, i)\n\ndef execute(code):\n    tokens = findall('(\\(|[FRL)]|[0-9]+)', code)\n    \n    def opt(flat):\n        while '0' in flat:\n            index = flat.index('0')\n            del flat[index-1:index+1]\n        return flat\n    \n    while '(' in tokens:\n        start, end = find_sub(tokens)\n        sub = tokens[start+1:end]\n        del tokens[start+1:end+1]\n        tokens[start] = opt(sub)\n    tokens = opt(tokens)\n    \n    path, loc, dire = [(0, 0)], (0, 0), 0\n\n    def perform(op):\n        nonlocal path, loc, dire\n        if type(op) == list:\n            return perform_list(op)\n        if op == 'F':\n            loc = (loc[0] + dirs[dire][0], loc[1] + dirs[dire][1])\n            path.append(loc)\n        else:\n            d = 1 if op == 'R' else -1\n            dire = (dire + d) % 4\n    \n    def perform_list(list):\n        last = None\n        for i in list:\n            if type(i) == str and i.isdigit():        \n                for _ in range(int(i)-1):\n                    perform(last)\n            else:\n                perform(i)\n                last = i\n    \n    perform_list(tokens)\n\n    minx = min(i[0] for i in path)\n    maxx = max(i[0] for i in path)\n    miny = min(i[1] for i in path)\n    maxy = max(i[1] for i in path)\n    \n    w, h = (maxx - minx + 1), (maxy - miny + 1)\n    map = [[' ' for _ in range(w)] for _ in range(h)]\n    \n    for i in path:\n        map[i[1]-miny][i[0]-minx] = '*'\n    \n    return '\\r\\n'.join(''.join(i) for i in map)"]
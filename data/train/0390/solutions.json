["import math\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp: List[int] = [0] * (n+1)\n        candidates: List[int] = []\n        for j in range(1, int(math.sqrt(n))+1):\n            candidates.append(j*j)\n        for i in range(n):\n            if not dp[i]:\n                for can in candidates:\n                    if i + can < n:\n                        dp[i+can] = 1\n                    elif i + can == n:\n                        return 1\n        return dp[-1]", "import math\nclass Solution:\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def canWin(n):\n            bound = math.floor(math.sqrt(n))\n            if bound * bound == n:\n                return True\n            for i in range(bound, 0, -1):\n                if not canWin(n - i * i):\n                    return True\n            return False\n        return canWin(n)\n    \n    # def winnerSquareGame(self, n: int) -> bool:\n    #     result = [None] * (n + 1)\n    #     def canWin(n):\n    #         bound = math.ceil(math.sqrt(n))\n    #         if bound * bound == n:\n    #             result[n] = True\n    #             return True\n    #         if result[n] != None:\n    #             return result[n]\n    #         for i in range(1, bound):\n    #             if not canWin(n - i * i):\n    #                 result[n] = True\n    #                 return True\n    #         result[n] = False\n    #         return False\n    #     return canWin(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(n+1):\n            if dp[i]:\n                continue\n            for k in range(1, int(n**0.5)+1):\n                if i+k*k <= n:\n                    dp[i+k*k] = True\n                else:\n                    break\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        table = [False] * (n + 1)\n        \n        for index in range(n + 1):\n            table[index] = any(not table[index - (lose * lose)]\n                               for lose in range(1, 1 + math.floor(math.sqrt(index))))\n            \n        return table[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (max(n, 2)+1)\n        dp[0] = False\n        dp[1] = True\n        dp[2] = False\n        #dp[3] = True\n        #dp[4] = \n\n        squares = [i**2 for i in range(1, floor(sqrt(n))+1)]\n        \n        for i in range(3, n+1):\n            for square in squares:\n                if i - square < 0:\n                    break\n                if dp[i - square] == False:\n                    dp[i] = True\n                    break\n        #print(dp)\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n        # t f t t f t f t t f  t  f  t  t  f  t  f  t  t  f  t  f  t  t  t  t  t  t  t  t\n        \n        if n == 1:\n            return True\n        if n == 2:\n            return False\n        \n        dp = [0] * n\n        dp[0] = True\n        dp[1] = False\n        count = 2\n        \n        for i in range(2, n):\n            if (i+1) == count ** 2:\n                dp[i] = True\n                count += 1\n            else:\n                if dp[i-1] == False:\n                    dp[i] = True\n                else:\n                    cur = 0\n                    for j in range(count - 1, 1, -1):\n                        if dp[i - j ** 2] == False:\n                            dp[i] = True\n                            cur = 1\n                            break\n                    if cur == 0:\n                        dp[i] = False\n        \n        return dp[n-1]\n", "class Solution:\n  def winnerSquareGame(self, n: int) -> bool:\n    # dpi = true if exists dpj for j = 1 -> square i that dpj = false\n    # else dpi = false\n    \n    wins = [False] * (n + 1)\n    for i in range(1, n + 1):\n      j = 1\n      canWin = False\n      while j * j <= i and not canWin:\n        canWin = not wins[i - j * j]\n        j += 1\n      wins[i] = canWin\n      \n    return wins[n]\n    \n", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for i in range(n+1)]\n        dp[0] = True\n        dp[1] = True\n        for i in range(3, n+1):\n            if math.sqrt(i) == int(math.sqrt(i)):\n                dp[i] = True\n                continue\n            start = 1\n            while(start*start < i):\n                if not dp[i-start*start]:\n                    dp[i] = True\n                    break\n                start += 1\n        print(dp)\n        return dp[n]", "import math\nclass Solution:\n    squares=[]\n    dp={}\n    def util(self,n):\n        if n==0:\n            return False\n        if n in self.dp:\n            return self.dp[n]\n        \n        for i in range(1,int(math.sqrt(n))+1):\n          #  print(\\\"square we subtract is\\\",self.squares[i],\\\"in util of\\\",n,\\\"and checking if util of\\\",n-self.squares[i],\\\"is true or false\\\")\n            if not self.util(n-self.squares[i]):\n        #        print(\\\"util of\\\",n-self.squares[i],\\\"turned out to be false,so util of\\\",n,\\\"is a win!\\\")\n                self.dp[n]=True\n                return True\n       # print(\\\"all paths from util of\\\",n,\\\"led to failure, and we lost GG\\\")\n        self.dp[n]=False\n        return False\n                \n    def winnerSquareGame(self, n: int) -> bool:\n        self.squares=[]\n        for i in range(int(math.sqrt(n))+1):\n            self.squares.append(i*i)\n        return self.util(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1 or n==3 or n==4 or n==6: return True\n        if n==0 or n == 2 or n==5: return False\n        \n        dp = [0,1,0,1,1,0,1,0]\n        i = 8\n        while i<=n:\n            j = 1\n            add= False\n            while j*j <= i:\n                if dp[i-j*j]==0:\n                    dp.append(1)\n                    add = True\n                    break\n                j += 1\n            if not add: dp.append(0)\n            i += 1\n        #print(dp)\n        #print([i for i in range(n+1)])\n        return dp[n]\n            \n            \n            \n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [0 for _ in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(1, i+1):\n                if j*j > i:\n                    break\n                if dp[i-j*j] == 0:\n                    dp[i] = 1\n                    break\n        return dp[-1]", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        \n        # note range is right-end non-inclusive\n        xsqrt = int(n**0.5)\n        for i in range(xsqrt, 0, -1):\n            if not self.winnerSquareGame(n - i * i):\n                return True\n        \n        return False\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp, sqs = [False] * (n + 1), []\n        i = 1\n        while i * i <= n:\n            sqs.append(i * i)\n            i += 1\n        for i in range(1, n + 1):\n            for sq in sqs:\n                if sq > i:\n                    break\n                dp[i] = dp[i] or not dp[i - sq]\n                if dp[i]:\n                    break\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # W(a) = n - W(b) if W(a) is a square number\n        # dp[i]: for n = i, if first one can win or not\n        # if there's a \\\"k\\\" that can make dp[i - k*k] == False, then the other guy lose, and by making dp[i] = True\n        dp = [False]*(n+1)\n        for i in range(1, n+1):\n            k = 1\n            while k*k <= i:\n                if dp[i-k*k] == False:\n                    dp[i] = True\n                    break\n                k += 1\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n+1)\n        for i in range(1,n+1):\n            j = 1\n            while j*j <= i:\n                if dp[i-j*j]==False:\n                    dp[i] = True\n                    break\n                j+=1\n        return dp[n]", "from functools import lru_cache\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(maxsize=None)\n        def win(cur):\n            if cur == 0: return False            \n            for i in range(1, int(cur**0.5)+1):\n                if not win(cur - i*i):\n                    return True                \n            return False\n        \n        return win(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (160000)\n        m = 400\n        for i in range(1, m):\n            dp[i*i] = True\n        # print(dp[0:n])\n        \n        for i in range(1, n + 1):\n            for j in range(1, m):\n                if i > j * j:\n                    if not dp[i - j*j]:\n                        dp[i] = True\n                        break\n                    # dp[i] = max(-dp[i - j*j], dp[i])\n        # print(dp[0:n])\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        squares = [i**2 for i in range(1,int(sqrt(n)) + 1)]\n        A = [False for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            if i in squares: \n                A[i] = True\n                continue\n                \n            for square in squares:\n                if square > i:\n                    break\n        \n                if not A[i - square]:\n                    A[i] = True\n                    break\n        \n        return A[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n\n        @lru_cache(maxsize=None)\n        def dfs(remain):\n            if remain == 0:\n                return False\n\n            sqrt_root = int(remain**0.5)\n            for i in range(1, sqrt_root+1):\n                # if there is any chance to make the opponent lose the game in the next round,\n                #  then the current player will win.\n                if not dfs(remain - i*i):\n                    return True\n\n            return False\n\n        return dfs(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        arr = [0] * (n+1)\n        \n        arr[0] = False\n        \n        for i in range(1, n+1):\n            \n            for j in range(1, n+1):\n                square = j * j\n                \n                if square > i:\n                    break\n                elif square == i:\n                    arr[i] = True\n                    break\n                else:\n                    rest = i - square\n                    if arr[rest] == False:\n                        arr[i] = True\n                        break\n        \n        return arr[n]\n", " \nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(maxsize=None)\n        def dfs(n):\n            if n == 0:\n                return False\n            square_root = int(sqrt(n))\n            for i in range(1, square_root + 1):\n                if not dfs(n - i * i):\n                    return True\n            return False                  \n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        mem=[None]*(n+1)\n        def dp(k):    #\u6709k\u4e2a\u77f3\u5934\u65f6\uff0c\u80fd\u5426\u8d62\n            if k==0:\n                return -1\n            if mem[k]!=None:\n                return mem[k]\n            for i in range(int(math.sqrt(k)),0,-1):\n                if dp(k-i*i)<0:    #\u5982\u679c\u6211\u53d6i*i\u4e2a\u77f3\u5934\uff0c\u5269\u4e0bk-i*i\u4e2a\u77f3\u5934\u65f6\uff0c\u6211\u6700\u540e\u6ca1\u77f3\u5934\u53d6\u8f93\u4e86\uff0c\u5219\u4ee3\u8868\u6709k\n                                   # \u4e2a\u77f3\u5934\u80dc\u5229\u4e86\uff0c\u6211\u53ef\u4ee5\u53d6i*i\u4e2a\u77f3\u5934\n                    mem[k]=1\n                    return 1\n            mem[k]=-1\n            return -1\n        return dp(n)>0", "import math\nclass Solution:\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        # result = [None] * (n + 1)\n        @lru_cache(None)\n        def canWin(n):\n            bound = math.ceil(math.sqrt(n))\n            if bound * bound == n:\n                # result[n] = True\n                return True\n            # if result[n] != None:\n            #     return result[n]\n            for i in range(1, bound):\n                if not canWin(n - i * i):\n                    # result[n] = True\n                    return True\n            # result[n] = False\n            return False\n        return canWin(n)\n    \n    # def winnerSquareGame(self, n: int) -> bool:\n    #     result = [None] * (n + 1)\n    #     def canWin(n):\n    #         bound = math.ceil(math.sqrt(n))\n    #         if bound * bound == n:\n    #             result[n] = True\n    #             return True\n    #         if result[n] != None:\n    #             return result[n]\n    #         for i in range(1, bound):\n    #             if not canWin(n - i * i):\n    #                 result[n] = True\n    #                 return True\n    #         result[n] = False\n    #         return False\n    #     return canWin(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(maxsize=None)\n        def helper(i):\n            if i == 0: return False\n            sr = int(i**0.5)\n            for k in range(1, sr+1):\n                if not helper(i-k*k):\n                    return True\n            return False\n        \n        return helper(n)", "import functools\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @functools.lru_cache(maxsize = None)\n        def dfs(remaining: int) -> bool:\n            if remaining == 0:\n                return False\n            else:\n                sqroot: int = int(remaining ** 0.5)\n                for i in range(1, sqroot + 1):\n                    if dfs(remaining - i * i):\n                        continue\n                    else:\n                        return True\n                return False\n        \n        return dfs(n)", "from collections import deque\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp=[False]*(n+1)\n        dp[1]=True\n        \n        \n        for x in range(2,n+1):\n            i=1\n            while i*i<=x:\n                if not dp[x-i*i]:\n                    dp[x]=True\n                    break\n                i+=1\n                    \n        return dp[n]\n        \n        \n        \n            \n            \n            \n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        def getSquareNumbers(n: int) -> List[int]:\n            # less than or equal to n\n            return [index * index for index in range(1, 1 + math.floor(math.sqrt(n)))]\n        \n        table = [False] * (n + 1)\n        \n        for index in range(n + 1):\n            table[index] = any(not table[index - (lose * lose)]\n                               for lose in range(1, 1 + math.floor(math.sqrt(index))))\n            \n        return table[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # dp[i] if the player can win after i pile has been taken\n        # dp[i] = one of dp[j1], dp[j2], is false ... where i - j_x is a square number\n        \n        dp = [False] * (n + 1)\n        \n        for i in reversed(range(n)):\n            temp = 1\n            while i + temp * temp <= n:\n                j = i + temp * temp\n                temp += 1\n                if not dp[j]:\n                    dp[i] = True\n                    break\n        \n        return dp[0]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        #Lee code for speed comparison\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(maxsize=None)\n        def dfs(remain):\n            if remain == 0:\n                return False\n\n            sqrt_root = int(remain**0.5)\n            for i in range(1, sqrt_root+1):\n                # if there is any chance to make the opponent lose the game in the next round,\n                #  then the current player will win.\n                if not dfs(remain - i*i):\n                    return True\n\n            return False\n\n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # Solution 1: DP by myself (9532ms: 5.06%)\n        '''\n        ele = [item**2 for item in range(1, int(math.sqrt(n))+1)]\n        memo = {}\n        def helper(amount, person):\n            if amount == 0:\n                memo[(amount, person)] = False\n                return False\n            if amount<0:\n                return\n            if (amount, person) in memo:\n                return memo[(amount, person)]\n            for item in ele:\n                if item<=amount:\n                    if not helper(amount-item, -person):\n                        memo[(amount, person)] = True\n                        return True\n                else:\n                    break\n            memo[(amount, person)] = False\n            return False\n        return helper(n, 1)\n        '''\n        # Solution 2: TLE!!\n        '''\n        dp = [False]*(n+1)\n        def check(n):\n            if n==0:\n                return False\n            if n==1:\n                dp[1] = True\n                return True\n            for i in range(int(math.sqrt(n)), 0, -1):\n                if not check(n-i*i):\n                    dp[n] = True\n                    return True\n            return False\n        return check(n)\n        '''\n        # Solution 3: DP from discussion (2132ms: 44.64%)\n        dp = [False] * (n + 1)\n        for i in range(1, n+1):\n            for j in range(1, int(i**0.5)+1):\n                if not dp[i-j*j]:\n                    dp[i] = True\n                    break\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(maxsize = None)\n        def dfs(remain):\n            \n            sqrts = int(sqrt(remain))\n            if sqrts ** 2 == remain:\n                return True\n            \n            for i in range(1, sqrts + 1):\n                \n                if not dfs(remain - i*i):\n                    return True\n            return False\n        \n        return dfs(n)", "def is_winning (n):\n    winning = []\n    for val in range (0, n+1):\n        if val == 0:\n            ans = False\n        else:\n            ans = False\n            i = 1\n            while val - i * i >= 0:\n                if not winning[val - i * i]:\n                    ans = True\n                    break\n                i += 1\n        winning.append (ans)\n    return winning[n]\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        return is_winning(n)", "import functools\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @functools.lru_cache(None)\n        def can_force_win_from(m):\n            if m == 0:\n                return False\n            if m == 1:\n                return True\n\n            for root in range(1, int(m ** 0.5) + 1):\n                if not can_force_win_from(m - root * root):\n                    return True\n            return False\n        return can_force_win_from(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(maxsize=None)\n        def dfs(remain):\n            if remain == 0:\n                return False\n            sqrt_root = int(remain**0.5)\n            for i in range(1, sqrt_root+1):\n                if not dfs(remain - i*i):\n                    return True\n            return False\n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for _ in range(n+1)]\n        dp[1] = True\n        for i in range(2, n+1):  # just to make it more clear\n            k = 1\n            while k*k <= i and not dp[i]:  # try to find at least one way to win\n                dp[i] = not dp[i-k*k]\n                k += 1\n        return dp[-1]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        def is_square(num):\n            a = int(num**0.5)\n            return a * a == num\n        dp = [False] * (n + 1)\n        dp[0] = False\n        dp[1] = True\n        for i in range(2, n + 1):\n            dp[i] = False\n            if is_square(i):\n                dp[i] = True\n                continue\n            limit = int(i ** 0.5)\n            for j in range(1, limit + 1):\n                if dp[i - j * j] == False:\n                    dp[i] = True\n                    break\n        #print(dp)\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        table = [False] * (n + 1)\n        \n        for index in range(n + 1):\n            table[index] = not all(table[index - (lose * lose)]\n                               for lose in range(1, 1 + math.floor(math.sqrt(index))))\n            \n        return table[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n\n        @lru_cache(maxsize=None)\n        def dfs(remain):\n            sqrt_root = int(remain**0.5)\n            if sqrt_root ** 2 == remain:\n                return True\n\n            for i in range(1, sqrt_root+1):\n                # if there is any chance to make the opponent lose the game in the next round,\n                #  then the current player will win.\n                if not dfs(remain - i*i):\n                    return True\n\n            return False\n\n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        alice = [False]*(n+1)\n        bob = [False]*(n+1)\n                \n        for i in range(1, n+1):\n            for x in range(1, int(sqrt(i))+1):\n                if not bob[i-x*x]:\n                    alice[i] = True\n                    break\n            for x in range(1, int(sqrt(i))+1):\n                if not alice[i-x*x]:\n                    bob[i] = True\n                    break\n            \n        return alice[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        res = [0] * (n + 1)\n        res[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, int(math.sqrt(i)) + 1):\n                if not res[i-j*j]:\n                    res[i] = 1\n                    break\n        print(res)\n        return res[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(maxsize=None)\n        def dfs(remain):\n            sqrt_root = int(sqrt(remain))\n            \n            if sqrt_root ** 2 == remain:\n                return True\n            \n            for i in range(1, sqrt_root+1):\n                if not dfs(remain - i*i):\n                    return True\n    \n            return False\n    \n        \n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for _ in range(n+1)]\n        for i in range(1, n+1):\n            k = 1\n            while k*k <= i and not dp[i]:\n                dp[i] = not dp[i-k*k]\n                k += 1\n        return dp[-1]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dfs(idx):\n            if idx == 0:\n                return False\n            \n            for i in range(1,int(math.sqrt(idx))+1):\n               if dfs(idx - i*i) == False:\n                    return True\n            return False \n        return dfs(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        wins = [False for i in range(n+1)]\n        wins[1] = True ## True \u8868\u793aalice\u8d62\n        for i in range(2,n+1):\n            j = 1\n            while i - j*j >= 0:\n                if wins[i-j*j] == False:\n                    wins[i] = True\n                    break\n                j += 1\n        return wins[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for _ in range(n+1)]\n        i = 0\n        while i*i <= n:\n            dp[i*i] = True  # next round is Alice, she wins immediately\n            i += 1\n        for i in range(1, n+1):\n            k = 1\n            while k*k <= i and not dp[i]:\n                dp[i] = not dp[i-k*k]\n                k += 1\n        return dp[-1]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n\n        dp = [False for i in range(n + 1)]\n\n        for num in range(1, n + 1):\n            for j in range(1, num + 1):\n                if j * j > num:\n                    break\n                dp[num] = dp[num] or not dp[num - j * j]\n                if(dp[num]):\n                    break\n\n        print(dp)\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # \u6bcf\u6b21\u79fb\u9664\u5e73\u65b9\u6570\n        # alice\u6bcf\u6b21\u79fb\u9664\u5b8c\u4e0d\u80fd\u5269\u4f59\u5e73\u65b9\u6570\uff0c\u5426\u5219\u5c31\u8f93\n        # \u5f53\u524d\u6570\u5b57\u51cf\u53bb\u4e00\u4e2a\u5e73\u65b9\u6570\u540e\uff0c\u4e0d\u80fd\u662f\u5e73\u65b9\u6570\n        # \u4ece\u5c0f\u5230\u5927\u8ba1\u7b97\uff0cn=1\uff0c\u3002\u3002\u3002\uff0cn\n        # dp[i]: \u6709i\u4e2a\u77f3\u5934\u65f6\uff0calice\u80fd\u4e0d\u80fd\u8d62\n        # dp[i] = \u4ecei\u5411\u4e0b\u51cf\u53bb\u5e73\u65b9\u6570\uff0c\u5bf9\u5e94\u7684dp[j]\u6709\u4e00\u4e2a\u662ffalse\u5373\u53ef\n        dp = [False for _ in range(n+1)]\n        for i in range(1,n+1):\n            base = 1\n            while i-base**2>=0:\n                if not dp[i-base**2]:\n                    dp[i] = True\n                    break\n                else:\n                    base += 1\n            if i<n and ((n-i)**0.5)%1==0 and not dp[i]:\n                return True                \n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = [False]*(n+1)\n        dp[1] = True\n        for i in range(1,n+1):\n            for j in range(1,i):\n                if j*j > i: break\n                elif not dp[i-j*j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n", "import math\n\nclass Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        i = int(math.sqrt(n))\n        while i >= 1:\n            if self.winnerSquareGame(n-i*i) == False:\n                return True\n            i -= 1\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        res = [False] * (n+1)\n        \n        for i in range(1, n+1):\n            j = 1\n            while j * j <= i:\n                res[i] |= not res[i-j*j]\n                if res[i]: break\n                j += 1\n        return res[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(i):\n            if i == 0:\n                return False\n            if i == 1:\n                return True\n            for k in range(1, i+1):\n                if k * k <= i:\n                    if not dp(i-k*k):\n                        return True\n                else:\n                    break\n            return False\n        return dp(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dfs(n: int) -> bool:\n            if n == 0:\n                return False\n            if n == 1:\n                return True\n            k = 1\n            while (k * k) <= n:\n                if not dfs(n - (k*k)):\n                    return True\n                k += 1\n            return False\n        return dfs(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (160000)\n        m = 400\n        for i in range(1, m):\n            dp[i*i] = True\n        # print(dp[0:n])\n        \n        for i in range(1, n + 1):\n            for j in range(1, m):\n                if i > j * j:\n                    if not dp[i - j*j]:\n                        dp[i] = True\n                        break\n\n                else:\n                    break\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def win(n):\n            if n == 1:\n                return True\n            if n == 0:\n                return False\n            v = 1\n            while v*v <= n:\n                if not win(n - v*v):\n                    return True\n                v += 1\n            return False\n        return win(n)", "from functools import lru_cache\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(None)\n        def dp(m):\n            if m == 0:\n                return True\n            if int(math.sqrt(m)) ** 2 == m:\n                return True\n            \n            i = 1\n            while i*i <= m:\n                if not dp(m - i*i):\n                    return True\n                i += 1\n                \n            return False\n        \n        return dp(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # cost = [-1 for _ in range(n+1)]\n        \n        @lru_cache(None)\n        def helper(n):\n            if n == 0:\n                return 0\n            i = 1\n            sq = 1\n            while sq <= n:\n                if helper(n-sq) == 0:\n                    return 1\n                i += 1\n                sq = i*i\n            return 0\n        \n        return helper(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]\n        for i in range(1, n + 1):\n            s = False\n            for j in range(1, int(i ** 0.5) + 1):\n                if not dp[i - j ** 2]:\n                    s = True\n                    break\n            dp.append(s)\n        return dp[-1]", "import math\nclass Solution:\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        i = 1\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - j*j] for j in range(1, int(math.sqrt(i)) + 1))\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # time complexity: O(N*logN)\n        # space complexity: O(N)\n        dp = [False]\n        for i in range(1, n + 1):\n            s = False\n            for j in range(1, int(i ** 0.5) + 1):\n                if not dp[i - j ** 2]:\n                    s = True\n                    break\n            dp.append(s)\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for _ in range(n+1)]\n        for i in range(1, n+1):\n            for e in range(1, int(i ** 0.5)+1):\n                if not dp[i - e ** 2]:\n                    dp[i] = True\n                    break\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = [False]*(n+1)\n        dp[1] = True\n        for i in range(1, n+1):\n            x = 1\n            while x * x <= i:\n                \n                if dp[i-x*x] == False:\n                    dp[i] = True\n                    break\n                \n                x+=1\n                \n        return dp[n]\n            \n", "import math\nclass Solution:\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        i = 1\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - j*j] for j in range(1, int(math.sqrt(i)) + 1))\n        print(dp)\n        return dp[-1]", "from math import floor, sqrt\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [0 for _ in range(n+1)]\n        for i in range(1, floor(sqrt(n))+1):\n            dp[i*i] = 1\n            great = 1\n        for i in range(2, n+1):\n            if dp[i] == 0:\n                for j in range(1, great+1):\n                    res = (dp[j*j] +dp[i-j*j]) % 2\n                    # print(i, j, res)\n                    if res == 1:\n                        dp[i] = 1\n                        break\n            else:\n                great +=1\n        print(dp)\n        return True if dp[n] else False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        losers = {0}\n        for x in range(1,n+1):\n            flag = True\n            for y in range(1,int(x**0.5)+1):\n                if (x - y**2) in losers:\n                    flag = False\n                    break\n            if flag: #Its a loser position because you cant send the next player to a loser position\n                losers.add(x)\n        return False if n in losers else True\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]\n        for i in range(1, n+1):\n            for b in range(1, math.floor(math.sqrt(i))+1):\n                if not dp[i-b**2]:\n                    dp.append(True)\n                    break\n            else:\n                dp.append(False)\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        sqrs = []\n        for j in range(1, n + 1):\n            if j * j <= n:\n                sqrs.append(j * j)\n            else:\n                break\n        dp = [False] * (1 + n)\n        for s in sqrs: dp[s] = True\n        \n        for i in range(1, n + 1):\n            if dp[i]: continue\n            for s in sqrs:\n                if s > i: break\n                dp[i] = not dp[i - s]\n                if dp[i]: break\n        return dp[-1]\n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        dp[1] = True\n        for i in range(2,n+1):\n            j = 1\n            flag = False\n            while j*j <= i:\n                if not dp[i-j*j]:\n                    flag = True\n                    break\n                j += 1\n            dp[i] = flag\n                    \n        return dp[-1]", "import math\n\nclass Solution:\n    \n    cache = {}\n        \n    \n    def winnerSquareGame(self, n: int) -> bool:\n        if n in self.cache:\n            return self.cache[n]\n        for i in range(1, int(math.sqrt(n)) + 1):\n            if n - i*i == 0:\n                self.cache[n] = True\n                return True\n            if not self.winnerSquareGame(n - i*i):\n                self.cache[n] = True\n                return True\n        self.cache[n] = False\n        return False\n", "from functools import lru_cache\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n\n        @lru_cache(None)\n        def dp(k):\n            if k == 1:\n                return True\n            if k == 0:\n                return False\n            for i in range(1, k):\n                if i * i > k:\n                    break\n                if not dp(k - i * i):\n                    return True\n            return False\n        \n        return dp(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [None] * (n + 1)\n        squares = []\n        for i in range(1, n+1):\n            if i ** 2 > n:\n                break\n            squares.append(i**2)\n            dp[i**2] = True\n        for i in range(1, n + 1):\n            if dp[i] is not None:\n                continue\n            cur = True\n            for s in squares:\n                if s > i:\n                    break\n                cur = cur and dp[i - s]\n            dp[i] = not cur\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        l=[1]\n        pos=[0]*(n+1)\n        \n        for i in range(1,n+1):\n            if i==(math.sqrt(l[-1])+1)**2:\n                l.append(int((math.sqrt(l[-1])+1)**2))\n            for square_num in l:\n                if not pos[i-square_num]:\n                    pos[i]=1\n        return pos[n]", "class Solution:\n    #   1(T)   2(F)   3(T)   4(T)   5   6   7\n    def winnerSquareGame(self, n: int) -> bool:\n        mem = {}\n        squares = []\n        if int(pow(n,0.5)) == pow(n,0.5):\n            return True\n        def helper(n):\n            if n in mem:\n                return mem[n]\n            for i in range(1,int(pow(n,0.5))+1):\n                if not helper(n-i*i):  # try that move and won\n                    mem[n] = True\n                    return True\n            mem[n] = False\n            return False\n        return helper(n)\n    \n    def calcSquares(self,mem,squares,n):\n        for i in range(1,n):\n            i = pow(i,0.5)\n            if int(i) == i:\n                squares.append(i)\n                mem[i] = True", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        res = [False] * (n+1)\n        for i in range(n+1):\n            if res[i]: continue\n            j = 1\n            while i + j * j <= n:\n                res[i + j*j] = True\n                j += 1\n        return res[n]\n", "class Solution:\n    #   1(T)   2(F)   3(T)   4(T)   5   6   7\n    def winnerSquareGame(self, n: int) -> bool:\n        mem = {}\n        if int(pow(n,0.5)) == pow(n,0.5):\n            return True\n        def helper(n):\n            if n in mem:\n                return mem[n]\n            for i in range(1,int(pow(n,0.5))+1):\n                if not helper(n-i*i):  # try that move and won\n                    mem[n] = True\n                    return True\n            mem[n] = False\n            return False\n        return helper(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        s = [i**2 for i in range(1, int(n**(1/2))+1)]\n        record = {}\n        \n        def helper(i):\n            if i in record:\n                return record[i]\n            if i == 0:\n                return False\n            for j in s:\n                if j > i:\n                    record[i] = False\n                    return False\n                if not helper(i-j):\n                    record[i] = True\n                    return True\n        \n        res = helper(n)\n        #print(record)\n        return res", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        sol = [False] * (n + 1)\n        \n        for i in range(1, n+1):\n            j = pwr = 1\n            sol[i] = False \n            while pwr <= i:\n                if not sol[i-pwr]:\n                    sol[i] = True\n                    break\n                j+=1\n                pwr = j**2\n                \n        return sol[-1]\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        ans = [False]*(n+1)\n        for i in range(1, n+1):\n            ans[i] = not all(ans[i-j**2] for j in range(1, 1+int(i**.5)))\n        return ans[-1]\n", "class Solution:\n    \n    def winnerSquareGame2(self, n):\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        # \u5c1d\u8bd5\u540c\u6837\u7684\u89e3\u6cd5\uff1f\n        # solve(s), s=\u5f53\u524d\u7684\u5269\u4f59\u7684\u6570\u5b57\u4e0b\uff0cscore diff? \u9700\u8981\u7684\u6700\u5c0f\u6b65\u6570\uff1f\n        # \u5982\u679cs=0\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679cs=\u4efb\u610f\u4e00\u4e2a\u5e73\u65b9\u6570\uff0c\u5219return True, \u56e0\u4e3aalice\u53ef\u4ee5\u90fd\u62ff\u8d70\n        # \u5426\u5219\uff0calice\u53ef\u4ee5\u4ece\u4e2d\u5207\u8d70\u4efb\u610f\u5927\u5c0f\u7684\u5e73\u65b9\u6570x\uff0c\u7136\u540e\u628a\u5269\u4e0b\u7684s-x\u6254\u7ed9bob\n        \n        # \u53ea\u8981\u5176\u4e2d\u6709\u4e00\u4e2a\u5207\u5272\uff0cbob\u65e0\u6cd5\u5728s-x\u4e0b\u83b7\u80dc\uff0c\u90a3\u5c31\u662falice\u83b7\u80dc\n        # \u5982\u679cbob\u5728\u6240\u6709\u5207\u5272\u4e0b\u90fd\u83b7\u80dc\uff0c\u90a3alice lose\n        \n        # \u53ea\u4ecealice\u7684\u89d2\u5ea6\u51fa\u53d1\uff0c\u662f\u5426\u8db3\u591f\uff1f\n        cache = dict()\n        \n        def solve(s):\n            if s in cache: return cache[s]\n            if s == 0: \n                cache[s] = False\n                return False\n            \n            if pow(int(sqrt(s)), 2) == s: \n                cache[s] = True\n                return True # s is a square number and current player can take it directly, so win\n            \n            iswin = False\n            #for x in range(s-1, 0, -1): # from 1 to s-1, since s is not a square number\n            #    if pow(int(sqrt(x)), 2) == x:\n            #        if not solve(s-x):\n            #            iswin = True\n            #            break\n            for k in range(1, int(sqrt(s))+1):\n                if not solve(s - k*k):\n                    iswin = True\n                    break\n                \n            cache[s] = iswin\n            return iswin\n        return solve(n) # \u65b9\u6cd5\u662f\u5bf9\u7684\uff0c\u4f46\u662f\u8d85\u65f6\u4e86\uff0cn=31250\u7684\u65f6\u5019\n", "def canWin(n,squares,memo):\n    \n    if n in squares:\n        #print(n,True)\n        return True\n    \n    if n in memo:\n        return memo[n]\n    \n    res = False\n    for i in reversed(squares):\n        if i>n: continue\n        #if n==13: print('here',n-i)\n        if not canWin(n-i,squares,memo):\n            res = True\n            break\n            \n    memo[n] = res\n    return res\n    \n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        squares = [i**2 for i in range(1,floor(sqrt(n))+1)]\n        memo = dict()\n        #print(squares)\n        return canWin(n,squares,memo)\n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        return self.dfs(n)\n    \n    @lru_cache(None)\n    def dfs(self, remain):\n        sqrt_root = int(math.sqrt(remain))\n        for i in range(1, sqrt_root+1):\n            if not self.dfs(remain - i*i):\n                return True\n\n        return False\n\n        \n    '''\n        return self.helper(n, True)\n    \n    def helper(self, n, label):\n        value = math.sqrt(n)\n        if value == int(value):\n            return label\n        re = False\n        \n        for i in range(n,0, -1):\n            ii = math.sqrt(i)\n            if ii == int(ii):\n                print(ii, label)\n                re = self.helper(n-int(ii*ii), not label)\n        return re \n    '''", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        def dp_search(dp, n):\n            if n == 0:\n                return False\n            if n == 1:\n                return True\n            \n            if n in dp:\n                return dp[n]\n            \n            dp[n] = False\n            i = int(sqrt(n))\n            while i>=1:\n                if dp_search(dp, n-i*i)==False:\n                    dp[n] = True\n                    return True\n                i-=1\n            \n            return False\n        \n        \n        dp = {}\n        return dp_search(dp, n)\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        \n        # note range is right-end non-inclusive\n        for i in range(1, int(n**0.5) + 1):\n            if not self.winnerSquareGame(n - i * i):\n                return True\n        \n        return False\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n+1):\n            dp[i] = any(not dp[i - j ** 2] for j in range(1, int(i ** 0.5) + 1))\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        choices = [1]\n        memo = {}\n        for i in range(2,n):\n            if i*i > n:\n                break\n            choices.append(i*i)\n                \n        def find(n):\n            if n == 0:\n                return False\n            if n in memo:\n                return memo[n]\n            for i in choices:\n                if i > n:\n                    break\n                if not find(n-i):\n                    memo[n] = True\n                    return True\n            memo[n] = False\n            return False\n        return find(n)\n", "def canWin(n,squares,memo):\n    \n    if n in squares:\n        #print(n,True)\n        return True\n    \n    if n in memo:\n        return memo[n]\n    \n    res = False\n    for i in reversed(squares):\n        if i>n: continue\n        #if n==13: print('here',n-i)\n        if not canWin(n-i,squares,memo):\n            res = True\n            break\n            \n    memo[n] = res\n    return res\n    \n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        squares = [i**2 for i in range(1,floor(sqrt(n))+1)]\n        memo = dict()\n        print(squares)\n        return canWin(n,squares,memo)\n        \n", "class Solution:\n    @lru_cache(None)    \n    def winnerSquareGame(self, n: int) -> bool:\n        for i in range(1, int(sqrt(n))+1):\n            if not self.winnerSquareGame(n-i*i):\n                return True\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        memo = {0: False}\n        def dp(i):\n            if i in memo: return memo[i]\n            m = int(i ** 0.5)\n            if i ** 0.5 == m: return True\n            res = False\n            for j in range(1, m + 1):\n                res |= not dp(i - j * j)\n                if res: \n                    memo[i] = True\n                    return True\n            memo[i] = False\n            return False\n        \n        return dp(n)\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        mem={}\n        def game(n):\n            if n in mem:\n                return mem[(n)]\n            if n==0:\n                return False\n            k=1\n            mem[n]=False\n            while k*k<=n:\n                if not game(n-k*k):\n                    mem[n]=True\n                    break\n                k+=1\n            return mem[n]\n        \n        game(n)\n        return mem[n]\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        \n        # note range is right-end non-inclusive\n        xsqrt = int(n**0.5) + 1\n        for i in range(1, xsqrt):\n            if not self.winnerSquareGame(n - i * i):\n                return True\n        \n        return False\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        cost = [-1 for _ in range(n+1)]\n        \n        @lru_cache(None)\n        def helper(n):\n            if n == 0:\n                return 0\n            if cost[n] != -1:\n                return cost[n]\n            i = 1\n            sq = 1\n            while sq <= n:\n                if cost[n-sq] != -1:\n                    return cost[n-sq]\n                if helper(n-sq) == 0:\n                    cost[n-sq] = 1\n                    return 1\n                i += 1\n                sq = i*i\n            cost[n] = 0\n            return 0\n        \n        return helper(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def win(amt):\n            x = int(math.sqrt(amt))\n            for i in range(x, 0, -1):\n                if not win(amt - i*i):\n                    return True\n            return False\n        return win(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        self.memo = dict()\n        return self.dfs(n)\n\n        \n    def dfs(self, stonesRemain):\n        if stonesRemain <= 0:\n            return False\n        \n        if stonesRemain in self.memo:\n            return self.memo[stonesRemain]\n        \n        squareRoot = int(stonesRemain ** 0.5)\n        res = False\n        for i in reversed(range(1, squareRoot + 1)):\n            if not self.dfs(stonesRemain - i * i):\n                res = True\n                break\n        \n        self.memo[stonesRemain] = res\n        return res", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        x = 1\n        s = []\n        st = set()\n        dp = [False] * (n+1)\n        while x * x <= n:\n            s.append(x * x)\n            st.add(x * x)\n            dp[x * x] = True\n            x += 1\n        if n in s:\n            return True\n        for i in range(1, n+1):\n            if dp[i] == False:\n                start = 0\n                while start < len(s) and i - s[start] > 0:\n                    if dp[i - s[start]] == False:\n                        dp[i] = True\n                        break\n                    start += 1\n        return dp[n]\n                    \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        cache = {}\n        def helper(n):\n            if n in cache:\n                return cache[n]\n            s = sqrt(n)\n            if s.is_integer():\n                cache[n] = True\n                return True\n            i = 1\n            while i<s:\n                j = i*i\n                if not helper(n-j):\n                    cache[n] = True\n                    return True\n                i += 1\n            cache[n] = False\n            return False\n        return helper(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        dp[1] = True\n        for i in range(2, n + 1):\n            dp[i] = not all(dp[i - j * j] for j in range(1, int(math.sqrt(i)) + 1) if i >= j * j)\n        return dp[-1]", "import math\nfrom collections import defaultdict\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        def dfs(position, player):\n            if position in cache:\n                if cache[position] == True:\n                    return player\n                return not player\n\n            for sq in squares:\n                if sq == position:\n                    cache[position] = player\n                    return player\n                if sq > position:\n                    break\n\n                if player == dfs(position - sq, not player):\n                    cache[position] = player\n                    return player\n\n            cache[position] = not player\n            return not player\n\n        cache = defaultdict(bool)\n        max_val = int(math.sqrt(n))\n        squares = [1]\n        for i in range(2, max_val + 1):\n            squares.append(i ** 2)\n        cache[1] = True\n        cache[2] = False\n        cache[3] = True\n        cache[4] = True\n        for i in range(5, n+1):\n            cache[i] = dfs(i, True)\n        return cache[n]", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for _ in range(n+1)] # init dp[0] as False since it implies no move to make.\n        dp[1] = True # known corner case\n        for i in range(2,n+1): # for every i in [2,n]\n            sqr = int(i**0.5) # calculate upper bound for integer square root less than i\n            for j in range(1, sqr+1): # for every integer square root less than sqrt(i)\n                dp[i] |= not dp[i-j**2] # if there is any n == (i-j**2) that is doomed to lose, i should be true.\n                                        # because Alice can make that move(remove j**2 stones) and make Bob lose.\n                                        # otherwise i should be false since there is no any choice that will lead to winning.\n                if dp[i]: # Optimization due to test case TLE: if it is already true, break out.\n                    break\n        return dp[n]\n                \n                \n                \n        \n        \n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n <= 1:\n            return n == 1\n        \n        for i in range(1, n+1):\n            sq = i*i\n            if sq > n:\n                break\n            \n            if not self.winnerSquareGame(n-sq):\n                return True\n        \n        return False", "import math\n\nclass Solution:\n    # A \n    # B 15 1 4 9\n    def helper(self, n: int, dp: dict) -> bool:\n        if n in dp:\n            return dp[n]\n        if n == 0:\n            return False\n        i = 1\n        while i*i <= n:\n            if (self.helper(n-i*i, dp) == False):\n                dp[n] = True\n                return True\n            i += 1\n        dp[n] = False\n        return False\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        dp = {}\n        return self.helper(n, dp)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n==1:\n            return True\n        dp=[0,1]\n        for i in range(2,n+1):\n            root=int(i**0.5)\n            if root**2==i:\n                dp.append(1)\n            else:\n                for j in range(1,root+1):\n                    if not dp[i-j**2]:\n                        dp.append(1)\n                        break\n            if len(dp)==i:\n                dp.append(0)\n        return dp[n]      \n                \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        self.memo = dict()\n        return self.dfs(n)\n\n        \n    def dfs(self, left):\n        if left <= 0:\n            return False\n        \n        if left in self.memo:\n            return self.memo[left]\n        \n        squareRoot = int(left ** 0.5)\n        res = False\n        for i in reversed(list(range(1, squareRoot + 1))):\n            if not self.dfs(left - i * i):\n                res = True\n                break\n        \n        self.memo[left] = res\n        return res\n        \n        \n        \n                \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        if n == 0 or n == 2:\n            return False\n        if n == 1:\n            return True\n        dp = [-1] * (n+1)\n        dp[0] = 0\n        dp[1] = 1\n        dp[2] = 0\n        \n        def pick(n):\n            \n            if dp[n] != -1:\n                return dp[n]\n            i = 1\n            while i * i <= n:\n                if i * i == n:\n                    dp[n] = 1\n                    return True\n                if not pick(n-i*i):\n                    dp[n] = 1\n                    return True\n                i = i+1\n            dp[n] = 0\n            return dp[n]\n        pick(n)\n        return dp[n] == 1\n        \n                \n                \n        \n                \n                \n            \n                \n            \n            \n            \n        \n        \n        \n        \n        \n", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        return self.alice_wins(n, {})\n        \n    def alice_wins(self, n, dp):\n        if n in dp:\n            return dp[n]\n        x = 1\n        dp[n] = False\n        while x * x <= n:\n            if not self.alice_wins(n - (x * x), dp):\n                dp[n] = True\n                break\n            x += 1\n        return dp[n]\n   \n'''\nAlice tries to get to 0 first\nBob tries to get to get to 0 first/ Bob tries to not allow Alice get to zero first\n\n\n\n37\n\n\nAlice tries all perfect squares\nIf current num is perfect square, Bob picks it, else he picks 1\n'''", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        memo = {}\n        def helper(n):\n            if n in memo:\n                return memo[n]\n            if n==0:\n                return False\n            if n==1:\n                return True\n            i=1\n            while i*i<=n:\n                win = helper(n-i*i)\n                if not win:\n                    memo[n] = True\n                    return True \n                i+=1\n            memo[n] = False\n            return False\n        res = helper(n)\n        return res\n    \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(maxsize=None)\n\n        def dfs(r):\n          s = int(sqrt(r))\n          if s**2 == r: return True\n          for i in range(1, s+1):\n            if not dfs(r - i **2): return True\n          \n          return False  # There is no i such that removing i**2 stones will win the game\n          \n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = any(not dp[i - j**2] for j in range(1, int(i ** 0.5) + 1))\n        return dp[-1]\n            \n", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def winnerSquareGame(self, n: int) -> bool:\n    for i in range(1, n + 1):\n      if i * i > n:\n        break\n      if i * i == n:\n        return True\n      if not self.winnerSquareGame(n - i * i):\n        return True\n    return False\n", "from functools import lru_cache\n\nclass Solution:\n    \n    @lru_cache(None)\n    def dp(self, n):\n        if n == 0:\n            return False\n        for s in self.s:\n            if n-s >= 0:\n                if not self.dp(n-s):\n                    return True\n        return False\n        \n    \n    def winnerSquareGame(self, n: int) -> bool:\n        self.s, i = [1], 1\n        while self.s[-1] < 10**5:\n            i += 1\n            self.s.append(i*i)\n        \n        return self.dp(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(maxsize=None)\n        def dfs(r):\n          s = int(sqrt(r))\n          if s**2 == r: return True\n          for i in range(1, s+1):\n            if not dfs(r - i **2): return True\n          \n          return False  # There is no i such that removing i**2 stones will win the game\n          \n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # Approach: dfs with memoization - O(nn**0.5)\n        self.memo = dict()\n        return self.dfs(n)\n\n    def dfs(self, stonesRemain):\n        if stonesRemain <= 0:\n            return False\n        \n        if stonesRemain in self.memo:\n            return self.memo[stonesRemain]\n        \n        squareRoot = int(stonesRemain ** 0.5)\n        res = False\n        \n        # iterate from the largest square\n        for i in reversed(range(1, squareRoot + 1)):\n            posRes = self.dfs(stonesRemain - i * i)\n            # if there's a way such that opponent loses, we know\n            # that we can win with current number of stones\n            # So, we terminate early\n            if not posRes:\n                res = True\n                break\n        \n        self.memo[stonesRemain] = res\n        return res", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1, n+1):\n            for j in range(1, int(sqrt(i))+1):\n                if not dp[i-j*j]:\n                    dp[i] = True\n        \n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            if i**0.5 == int(i**0.5):\n                dp[i] = 1\n                continue\n            else:\n                for j in range(1, int(i**0.5)+1):\n                    if dp[i - j**2] == 0:\n                        dp[i] = 1\n                        break\n        return bool(dp[n])", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        mem = {}\n        def get_dp(i):\n            if i == 0:\n                return False\n            elif i not in mem:\n                root = 1\n                while True:\n                    if root*root > i:\n                        mem[i] = False\n                        break\n                    else:\n                        if not get_dp(i-root*root):\n                            mem[i] = True\n                            break\n                        root += 1\n            return mem[i]\n        return get_dp(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        roots = [i*i for i in range(1, int(sqrt(n))+1)]\n        dp = [False]*(n+1)\n        for i in range(1, n+1):\n            for j in roots:\n                if i < j:\n                    break\n                    \n                if not dp[i-j]:\n                    dp[i] = True\n        \n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(maxsize=None)\n        def dfs(remain):\n            sqrt_root = int(sqrt(remain))\n            # current player will win immediately by taking the square number tiles\n            if sqrt_root ** 2 == remain:\n                return True\n            \n            for i in range(1, sqrt_root+1):\n                # if there is any chance to make the opponent lose the game in the next round,\n                #  then the current player will win.\n                if not dfs(remain - i*i):\n                    return True\n    \n            return False\n    \n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = {}\n        \n        def rec_win(n):\n            if n == 0:\n                return False\n            if n == 1:\n                return True\n            if n in dp:\n                return dp[n]\n            for i in range(1,n):\n                if i*i > n:\n                    break\n                if not rec_win(n-i*i):\n                    dp[n] = True\n                    return True\n            dp[n] = False\n            return False\n        return rec_win(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = {0:False}\n                \n        for i in range(1, n+1):\n            \n            # get dp[i]\n            for j in range(1, int(i ** 0.5) + 1):\n                sn = j ** 2\n                if not dp[i-sn]:\n                    dp[i] = True\n                    break\n            else:\n                dp[i] = False\n                \n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        #dp = {0:False}\n        dp = [False] * (n + 1)\n        \n        for i in range(1, n+1):\n            \n            # get dp[i]\n            for j in range(1, int(i ** 0.5) + 1):\n                sn = j ** 2\n                if not dp[i-sn]:\n                    dp[i] = True\n                    break\n            else:\n                dp[i] = False\n                \n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1, len(dp)):\n            for j in range(1, int(i**0.5)+1):\n                if not dp[i-j*j]:\n                    dp[i]=True\n                    continue\n        return dp[-1]", "from functools import lru_cache\n\nclass Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        x = 1\n        while x*x <= n:\n            if not self.winnerSquareGame(n-x*x):\n                return True\n            x += 1\n        return False\n", "\nimport functools\nfrom math import sqrt\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @functools.lru_cache(maxsize=10**5)\n        def WSG(k):\n            if k == 0:\n                return False\n\n            i = int(sqrt(k))\n            while i >= 1:\n                if not WSG(k-i**2):\n                    return True\n                i -= 1\n            return False\n        return WSG(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        memo = {}\n        def isSquare(n):\n            root = int(n ** 0.5)\n            return root * root == n\n        def dfs(n):\n            if n in memo:\n                return memo[n]\n            if isSquare(n):\n                memo[n] = True\n                return memo[n]\n            root = int(n ** 0.5)\n            memo[n] = False\n            for i in range(1, root + 1):\n                if not dfs(n - i * i):\n                    memo[n] = True\n                    break\n            return memo[n]\n        return dfs(n)", "class Solution:\n    def stone_game(self, memo, n):\n        if n in memo:\n            return memo[n]\n        \n        memo[n] = False\n        for cand in range(1, int(math.sqrt(n)) + 1):\n            i = cand * cand\n            memo[n] = memo[n] or not self.stone_game(memo, n-i)\n            if memo[n]:\n                return True\n        \n        return memo[n]\n    \n                \n    def winnerSquareGame(self, n: int) -> bool:\n        '''\n        - implementation \n        '''\n        can_i_win = defaultdict(bool)\n        \n        can_i_win[1] = True\n        can_i_win[0] = False\n        self.stone_game(can_i_win, n)\n        \n        return can_i_win[n]", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n==1:\n            return True\n        s = 1\n        while s*s<=n:\n            flag = self.winnerSquareGame(n-s*s)\n            if flag == False:\n                return True\n            s+=1\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        def getSquareNumbers(n: int) -> List[int]:\n            # less than or equal to n\n            return [index * index for index in range(1, 1 + math.floor(math.sqrt(n)))]\n        \n        table = [False] * (n + 1)\n        \n        for index in range(n + 1):\n            table[index] = any(not table[index - lose] for lose in getSquareNumbers(index))\n            \n        return table[-1]", "import math\nclass Solution:\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def helper(n):\n            if n == 0:\n                return False\n            i = 1\n            while i*i <= n:\n                if not helper(n - i*i):\n                    return True\n                i += 1\n            return False\n        \n        return helper(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        winmap = {}\n        winmap[0] = False\n        winmap[1] = True\n        \n        def fill_map(n):\n            if n in winmap:\n                return winmap[n]\n            i = 1\n            winmap[n] = 0\n            while i*i <= n:\n                winmap[n] = winmap[n] or not fill_map(n-i*i) \n                if winmap[n]:\n                    break\n                i += 1\n            return winmap[n]\n        \n        for i in range(1, n):\n            fill_map(n)\n            \n        return winmap[n]\n        \n        \n        \n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        memo = {0: False}\n        def dfs(i):\n            if i not in memo:\n                memo[i] = False\n                j = 1\n                while not memo[i] and j * j <= i:\n                    memo[i] = not dfs(i - j * j)\n                    j += 1\n            return memo[i]\n        \n        return dfs(n)\n        \n        \n        \n        \n#         dp = [False] * (n + 1)\n#         for i in range(1, n + 1):\n#             j = 1\n#             while not dp[i] and j * j <= i:\n#                 dp[i] = not dp[i - j * j]\n#                 j += 1\n        \n#         return dp[n]\n                \n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        self.memo = {}\n        return self.helper(n)\n    \n    def helper(self, n):\n        if n == 0:\n            return False\n        if n in self.memo:\n            return self.memo[n]\n        i = 1\n        while i * i <= n:\n            if not self.helper(n - i * i):\n                self.memo[n] = True\n                return True\n            i += 1\n        self.memo[n] = False\n        return False\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        squares = [i * i for i in range(1, int(n ** 0.5) + 1)]\n        \n        DP = [0] * (1 + n)\n        for i in range(1, n + 1):\n            can_win = False\n            for s in squares:\n                if s > i:\n                    break\n                can_win |= not DP[i - s]\n            DP[i] = can_win\n        return DP[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # time O(n*sqrt(n)), space O(n)\n        dp = [False] * (n + 1) # dp[i] means Alice can win with i\n        dp[1] = True\n        for i in range(2, n + 1):\n            for k in range(1, int(i**0.5) + 1):\n                if dp[i - k*k] == False: # if Bob can't win, then Alice wins\n                    dp[i] = True\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        dp[1] = True\n        for i in range(2, n + 1):\n            for k in range(1, int(i**0.5) + 1):\n                if dp[i - k*k] == False:\n                    dp[i] = True\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1, n+1):\n            for j in range(1, int(sqrt(i))+1):\n                if dp[i-j**2] is False:\n                    dp[i] = True \n                    break \n        return dp[n]", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        else:\n            for i in range(1, int(n ** 0.5) + 1):\n                if not self.winnerSquareGame(n - i**2):\n                    return True  \n            return False\n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        m = {0:False, 1:True}\n        def helper(n):\n            if n in m:\n                return m[n]\n            ans, start = False, 1\n            while start*start<=n:\n                ans = ans or (not helper(n-start*start))\n                if ans:\n                    m[n]=ans\n                    return ans\n                start+=1\n            m[n]=ans\n            return ans\n        \n        return helper(n)\n", "class Solution:\n    @lru_cache(None)\n    @lru_cache(maxsize=None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        else:\n            for i in range(1, int(n ** 0.5) + 1):\n                if not self.winnerSquareGame(n - i**2):\n                    return True  \n            return False\n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1,n+1):\n            cur = int(i**0.5)\n            if cur ** 2 == i:\n                dp[i] = True\n            else:\n                f = True\n                for j in range(1,int(i**0.5)+1):\n                    f &= dp[i-j*j]\n                if not f:\n                    dp[i] = True\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        M = {}\n        M[0] = False\n        M[1] = True\n        for i in range(2, n+1):\n            M[i] = False\n            sq = int(math.sqrt(i))\n            if sq**2 == i:\n                M[i] = True\n            for j in range(1, sq + 1):\n                M[i] = M[i] or not M[i-(j*j)]\n        return M[n]\n            \n        \n", "from functools import lru_cache\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dp(num):\n            sqr = int(num ** (1/2))\n            if sqr ** 2 == num:\n                return True\n            \n            way = False\n            for i in range(1, sqr + 1):\n                way = not dp(num - i ** 2)\n                if way:\n                    return True\n            return way\n        \n        return dp(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        memo = {}\n        def dfs(n):\n            if n == 0:\n                return False\n            if n in memo:\n                return memo[n]\n            can_win = False\n            for i in range(1, int(n ** 0.5) + 1):\n                if not dfs(n - i ** 2):\n                    can_win = True\n                    break\n            memo[n] = can_win\n            return memo[n]\n        return dfs(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [0] * (n + 1)\n        squares = []\n        i = 1\n        nxt_sqrt = 1\n        nxt = 1\n        for i in range(1, n + 1):\n            if i == nxt:\n                dp[i] = 1\n                squares.append(nxt)\n                nxt_sqrt += 1\n                nxt = nxt_sqrt ** 2\n            else:\n                dp[i] = max(-dp[i - s] for s in squares)\n        return dp[n] == 1\n        \n#         squares = [i**2 for i in range(1, int(sqrt(n)) + 1)]\n\n#         for s in squares:\n#             dp[s] = 1\n\n        \n        # @lru_cache(None)\n        # def play(n):\n        #     sq = sqrt(n)\n        #     if int(sq) == sq:\n        #         return 1\n        #     best = -1\n        #     for i in range(int(sq), 0, -1):\n        #         best = max(best, -play(n - i ** 2))\n        #     return best\n        # return play(n) == 1\n", "class Solution:\n    # dp(i): remain i piles\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0: return False\n        if n == 1: return True\n        squares = [i**2 for i in range(1, int(sqrt(n))+1)]\n        @lru_cache(None)\n        def dp(i): \n            nonlocal squares\n            canWin = False\n            for sq in squares:\n                if i < sq:\n                    break\n                if i == sq:\n                    return True\n                canWin = canWin or not dp(i - sq)\n            return canWin\n        return dp(n)", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        result = [None] * (n + 1)\n        def canWin(n):\n            bound = math.ceil(math.sqrt(n))\n            if bound * bound == n:\n                result[n] = True\n                return True\n            if result[n] != None:\n                return result[n]\n            for i in range(1, bound):\n                if not canWin(n - i * i):\n                    result[n] = True\n                    return True\n            result[n] = False\n            return False\n        return canWin(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(None)\n        def rec(n):\n            if n < 2: return n == 1\n            return any(not rec(n-i*i) for i in range(int(n**0.5), 0, -1))\n        return rec(n)", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        for i in range(1, int(n ** 0.5) + 1):\n            if not self.winnerSquareGame(n - i ** 2):\n                return True\n        return False\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]\n        for i in range(1, n+1):\n            b = 1\n            winnable = False\n            while b ** 2 <= i:\n                if not dp[i-b**2]:\n                    winnable = True\n                    break\n                b += 1\n            dp.append(winnable)\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        cache = {}\n\n        def helper(number):\n            if number == 0:\n                return False\n            \n            if number not in cache:\n                flag = False\n                for i in range(1, 317):\n                    val = i ** 2\n                    if val > number:\n                        break\n\n                    if not helper(number - val):\n                        flag = True\n                        break\n                \n                cache[number] = flag\n            \n            return cache[number]\n        \n        return helper(n)", "from math import sqrt\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n+1)\n        dp[1] = True\n        \n        for m in range(2,n+1) :\n#             if sqrt(m) == int(sqrt(m)) : \n\n#                 dp[m] = True\n#                 continue \n            i = 1\n            while i**2 < m : \n                if not dp[m-i**2] : \n\n                    dp[m] = True\n                    break\n                i +=1 \n            if i**2 == m : dp[m] = True\n\n        return dp[n]\n                \n            \n        \n'''\nTrue,False, True, True, False, True, \nBrute force:\n\nBactracking method:\nproceed with removing a certain number of stones which are a square number\nand then have another state\n(stonesRemaining: int, AliceTurn: bool)\n\nso base case, if n == 0 or person can't make any moves: return not AliceTurn\n\nconstruct dp table of two dimensions \n\nat any subproblem m, if alice wins, then bob necessarily loses and vice versa \n\nn =1 \nn is a square, return True\n\nn= 2, \nn is not square so only option is take 1 stone\n(2) -> (1) -> False\n\nn= 4\nif n is a square: return True\n\nn = 7 \ndp(1) : return True meaning alice wins\ndp(n: int) -> bool :\n    if sqrt(n) == int(sqrt(n)) : return True\n    i = 1\n    while i**2 < n : \n        if dp[n-i] : return True\n        i +=1 \n    return True\n\nreturn not dp(n)\n\n'''", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        table = [False] * (n+1)\n        table[1] = True\n        for i in range(2, n+1):\n            num = 1\n            while num ** 2 <= i:\n                square = num ** 2\n                if not table[ i - square ]:\n                    table[i] = True\n                    break\n                num += 1\n                \n        return table[-1]", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1:\n            return True\n        sqrt = math.floor(math.sqrt(n))\n        if sqrt * sqrt == n:\n            return True\n        for num in range(1, sqrt+1):\n            if not self.winnerSquareGame(n-num**2):\n                return True\n        return False\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        table = [False for x in range(n+1)]\n        for x in range(1, n+1):\n            flag = False\n            c = 1\n            while c**2 <= x:\n                if not table[x-c**2]:\n                    flag = True\n                    break\n                c += 1\n            table[x] = flag\n        return table[-1]", "from functools import lru_cache\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        sq = [x*x for x in range(1, 317)]\n        dp = [False] * (n+1)\n        \n        for i in range(n+1):\n            for x in sq:\n                if i - x < 0:\n                    break\n                if dp[i - x] == False:\n                    dp[i] = True\n        \n        return dp[n]\n\n    # T F T F F\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dic =dict()\n        dic[1] = True\n        dic[2] = False\n        dic[3] = True\n        dic[4] = True\n        def helper(n):\n            if n in dic:\n                return dic[n]\n            i = int(n ** 0.5)\n            while i >= 1:\n                if not helper(n - i**2):\n                    dic[n] = True\n                    return True\n                i -=1\n            dic[n] = False\n            return False\n        return helper(n)", "from math import sqrt\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n+1)\n        dp[1] = True\n        \n        for m in range(2,n+1) :\n            if sqrt(m) == int(sqrt(m)) : \n\n                dp[m] = True\n                continue \n            i = 1\n            while i**2 < m : \n                if not dp[m-i**2] : \n                    # print(i**2, m)\n                    dp[m] = True\n                    break\n                i +=1 \n        # print(dp)\n        return dp[n]\n                \n            \n        \n'''\nTrue,False, True, True, False, True, \nBrute force:\n\nBactracking method:\nproceed with removing a certain number of stones which are a square number\nand then have another state\n(stonesRemaining: int, AliceTurn: bool)\n\nso base case, if n == 0 or person can't make any moves: return not AliceTurn\n\nconstruct dp table of two dimensions \n\nat any subproblem m, if alice wins, then bob necessarily loses and vice versa \n\nn =1 \nn is a square, return True\n\nn= 2, \nn is not square so only option is take 1 stone\n(2) -> (1) -> False\n\nn= 4\nif n is a square: return True\n\nn = 7 \ndp(1) : return True meaning alice wins\ndp(n: int) -> bool :\n    if sqrt(n) == int(sqrt(n)) : return True\n    i = 1\n    while i**2 < n : \n        if dp[n-i] : return True\n        i +=1 \n    return True\n\nreturn not dp(n)\n\n'''", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n+1):\n            for k in range(1, i+1):\n                if i - k**2 < 0: break\n                if not dp[i - k**2]: dp[i] = True;break\n            #print(dp)        \n        return dp[-1]\n", "# O(n) dp[n] = !dp[n-1] or !dp[n-4] ...\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [-1] * (n+1)\n        dp[0] = 0\n        return self.can_win(n, dp)\n    \n    def can_win(self, n, dp):\n        if dp[n] != -1:\n            return dp[n]\n        root = 1\n        cur = n - root ** 2\n        while cur >= 0:\n            dp[cur] = self.can_win(cur, dp)\n            if dp[cur] == 0:\n                dp[n] = 1\n                return 1\n            root += 1\n            cur = n - root ** 2\n        dp[n] = 0\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # This is an even simpler and more efficient way to reason about the state of \n        # f(x). Instead of defining f(x) for whether Alice wins or loses, let f(x)\n        # return True/False for if someone, Alice or Bob wins/loses given the value x.\n        # In other words, f(x) tells us whether we'll win or lose if we start with x.\n        # If \\\"we\\\" are Alice starting with x, then our opponent is Bob, if \\\"we\\\" are\n        # Bob then the opponent is Alice.\n        memo = {}\n        def f(x):\n            if x == 0:\n                return False\n            if x == 1:\n                return True\n            \n            if x in memo:\n                return memo[x]\n            \n            i = 1\n            while i * i <= x:\n                # If we choose to remove i*i and our opponent ends up losing then\n                # we win. Why? Since we are playing optimally, as long as there's a\n                # choice we can make that forces the opponent to lose, we will make\n                # that choice and guarantee the win.\n                if f(x - i * i) == False:\n                    memo[x] = True\n                    return True\n                i += 1\n            \n            # If no matter the choice we make, our opponent ends up winning, i.e\n            # f(x - i * i) == True for all i, i*i <= x, then we are guaranteed to lose\n            memo[x] = False\n            return False\n        \n        return f(n)\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # \u6bcf\u6b21\u79fb\u9664\u5e73\u65b9\u6570\n        # alice\u6bcf\u6b21\u79fb\u9664\u5b8c\u4e0d\u80fd\u5269\u4f59\u5e73\u65b9\u6570\uff0c\u5426\u5219\u5c31\u8f93\n        # \u5f53\u524d\u6570\u5b57\u51cf\u53bb\u4e00\u4e2a\u5e73\u65b9\u6570\u540e\uff0c\u4e0d\u80fd\u662f\u5e73\u65b9\u6570\n        # \u4ece\u5c0f\u5230\u5927\u8ba1\u7b97\uff0cn=1\uff0c\u3002\u3002\u3002\uff0cn\n        # dp[i]: \u6709i\u4e2a\u77f3\u5934\u65f6\uff0calice\u80fd\u4e0d\u80fd\u8d62\n        # dp[i] = \u4ecei\u5411\u4e0b\u51cf\u53bb\u5e73\u65b9\u6570\uff0c\u5bf9\u5e94\u7684dp[j]\u6709\u4e00\u4e2a\u662ffalse\u5373\u53ef\n        dp = [False for _ in range(n+1)]\n        for i in range(1,n+1):\n            base = 1\n            while i-base**2>=0:\n                if not dp[i-base**2]:\n                    dp[i] = True\n                    break\n                else:\n                    base += 1\n        return dp[n]\n", "class Solution:\n    \n    table = [-1] * 1000001\n    table[0] = False\n    table[1] = True\n    idx = 1\n    \n    def winnerSquareGame(self, n: int) -> bool:\n        \n        if n > self.idx:\n            for i in range(self.idx+1, n+1):\n                num = 1\n                while num ** 2 <= i:\n                    square = num ** 2\n                    if not self.table[ i - square ]:\n                        self.table[i] = True\n                        break\n                    num += 1\n                if self.table[i] == -1:\n                    self.table[i] = False\n            self.idx = i\n        return self.table[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n+1):\n            for k in range(1,int(i**0.5)+1):\n                if i - k**2 < 0: break\n                if not dp[i - k**2]: dp[i] = True;break\n            #print(dp)        \n        return dp[-1]\n        '''\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]   \n        '''", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        dp[1] = True \n        for i in range(2, n+1):\n            j = 1 \n            while i - j**2 >= 0:\n                if dp[i-j**2] is False:\n                    dp[i] = True\n                    break \n                j += 1 \n            \n        return dp[n]", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        result = dict()\n        def canWin(n):\n            bound = math.ceil(math.sqrt(n))\n            if bound * bound == n:\n                result[n] = True\n                return True\n            if n in result:\n                return result[n]\n            for i in range(1, bound):\n                if not canWin(n - i * i):\n                    result[n] = True\n                    return True\n            result[n] = False\n            return False\n        return canWin(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(None)\n        def dp(i):\n            if i == 0:\n                return False\n            return any(not dp(i-x*x) for x in range(floor(sqrt(i)), 0, -1))\n\n        return dp(n)\n", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n+1)\n        for i in range(1, n+1):\n            curr = 1\n            while curr**2 <= i:\n                if dp[i-curr**2] == False:\n                    dp[i] = True\n                    break\n                curr += 1\n        return dp[-1]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # if n == 1:\n        #     return True\n        # if n == 2:\n        #     return False\n        \n        dp = [0] * (n+1)\n        # dp[1] = 1\n        \n        for i in range(1, n+1):\n            base = 1\n            while i - base**2 >= 0: \n                if dp[i - base**2] == False:\n                    dp[i] = 1\n                    break\n                base += 1\n\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1:\n            return True\n        if n == 2:\n            return False\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        \n        for i in range(3, n+1):\n            base = 1\n            while i - base**2 >= 0: \n                if dp[i - base**2] == False:\n                    dp[i] = 1\n                    break\n                base += 1\n\n        return dp[-1]\n", "class Solution:\n    def __init__(self):\n        self.memo = {0: False}\n        \n    def winnerSquareGame(self, n: int) -> bool:\n        def rwsg(n,picks):\n            if n not in self.memo:\n                out = False\n                for p in picks:\n                    if p > n: break\n                    out = out or not rwsg(n-p,picks)\n                self.memo[n] = out\n            return self.memo[n]\n        picks = []\n        m = 1\n        while m*m <= n:\n            picks.append(m*m)\n            m += 1\n        rwsg(n,picks)\n        return rwsg(n,picks)", "import math\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        result = dict()\n        def canWin(n):\n            bound = math.ceil(math.sqrt(n))\n            if n in result:\n                return result[n]\n            result[n] = False\n            for i in range(1, bound + 1):\n                if n == i * i:\n                    result[n] = True\n                    return True\n                if n > i * i:\n                    if not canWin(n - i * i):\n                        result[n] = True\n                        return True\n            return result[n]\n        return canWin(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        # Square numbers: 1, 4, 9, 16, 25...\n\n        def removeSquare(n: int, memo: [int]):\n            \n            if n == 0: return False\n            if memo[n]: return memo[n]\n\n            i = 1\n            \n            while i*i <= n:\n                \n                if memo[n-(i*i)] == False: return True\n                \n                memo[n-(i*i)] = removeSquare(n-(i*i), memo)\n                \n                # If you can make a move, that will result\n                # in the case: n==0\n                # Then you can win\n                if memo[n-(i*i)] == False:\n                    return True\n                \n                i += 1\n                \n            return False\n        \n        memo = [None] * (n+1)\n        \n        return removeSquare(n, memo)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            j = 1\n            while j * j <= i:\n                if not dp[i - j * j]:\n                    dp[i] = True\n                j += 1\n        return dp[n]", "import functools\nimport math\n\n\nclass Solution:\n  def winnerSquareGame(self, n: int) -> bool:\n    @functools.lru_cache(None)\n    def dp(k):\n      if k <= 0:\n        return False\n\n      sq = math.sqrt(k)\n      if sq.is_integer():\n        return True\n\n      for m in range(1, k):\n        if m ** 2 > k:\n          break\n\n        ans = dp(k - m ** 2)\n        if not ans:\n          return True\n\n      return False\n\n    return dp(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(n):\n            if math.sqrt(n) == round(math.sqrt(n)):\n                return True\n            i = 1\n            while i**2 < n:\n                if not dp(n - i**2):\n                    return True\n                i += 1\n            return False\n        return dp(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        \n        n2p = []\n        p2n = {}\n        for x in range(n+1): \n            n2p.append(x**2)\n            p2n[x**2] = x\n        \n        #print(n2p)\n        #print(p2n)\n        \n        @lru_cache(None)\n        def recur(rem):\n            if rem == 0: return False\n            if round(math.sqrt(rem)) ** 2 == rem: return True\n            \n            \n            #print(\\\"rem\\\", rem)\n            max_rm_val = math.floor(math.sqrt(rem))**2\n            #print(\\\"val\\\", max_rm_val)\n            max_rm_ind = p2n[max_rm_val]\n            \n            for ind in range(max_rm_ind, 0, -1):\n                \n                # hope that at least one next call returns False\n                if not recur(rem - n2p[ind]): return True\n            \n            return False\n        \n        return recur(n)", "'''\n    1 - Alice\n    2 - Bob\n    3 - Alice\n    4 - Alice\n    5 - [1 (Bob), 4(Bob)]\n    6 - [1 (Alice), 4(Bob)] \n    7 - [1, 4]\n    n - Alice\n    n+1 -\n'''\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1:\n            return True\n        dp = [False] * (n+1)\n        squares = set()\n        for i in range(1, n//2+1):\n            square = i * i\n            if square <= n:\n                squares.add(square)\n                dp[square] = True   \n        for i in range(1, n+1):\n            if i not in squares:\n                possible = [not dp[i-square] for square in squares if square < i]\n                dp[i] = any(possible)\n        return dp[-1]", "\nimport functools\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @functools.lru_cache(maxsize=None)\n        def WSG(k):\n            if k == 0:\n                return False\n\n            i=1\n            while i**2 <= k:\n                if not WSG(k-i**2):\n                    return True\n                i += 1\n            return False\n        return WSG(n)", "\nclass Solution:\n  def winnerSquareGame(self, n: int) -> bool:\n    squart_num = []\n    dp = [False] * (n + 1)\n    i = 1\n\n    for i in range(1, n + 1):\n      start_index = 1\n      while True:\n        if start_index * start_index > i:\n          break\n        if not dp[i - start_index * start_index]:\n          dp[i] = True\n        start_index += 1\n\n        pass\n    if dp[n] == 1:\n      return True\n    return False\n    pass\n", "'''\n    1 - Alice\n    2 - Bob\n    3 - Alice\n    4 - Alice\n    5 - [1 (Bob), 4(Bob)]\n    6 - [1 (Alice), 4(Bob)] \n    7 - [1, 4]\n    n - Alice\n    n+1 -\n'''\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1:\n            return True\n        dp = [False] * (n+1)\n        squares = set()\n        for i in range(1, n//2+1):\n            square = i * i\n            if square <= n:\n                squares.add(square)\n                dp[square] = True   \n        # print(squares)\n        for i in range(1, n+1):\n            if i not in squares:\n                possible = [not dp[i-square] for square in squares if square < i]\n                # print(i, possible)\n                dp[i] = any(possible)\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def can_win(remain):\n            if remain == 0:\n                return False\n            \n            root = 1\n            while root**2 <= remain:\n                if not can_win(remain - root**2):\n                    return True\n                root += 1\n            return False\n        \n        return can_win(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        @lru_cache(None)\n        def test(n):\n            if n == 0:\n                return False\n        \n            for i in range(1, int(n ** 0.5) + 1):\n                sn = i ** 2\n                if not test(n - sn):\n                    return True\n        \n            return False\n        \n        return test(n)\n", "class Solution:\n    def __init__(self):\n        self.isGood = {}\n    \n    \n    def winnerSquareGame(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        \n        if n in self.isGood:\n            return self.isGood[n]\n        \n        self.isGood[n] = False\n        i = 1\n        while i*i <= n:\n            if not self.winnerSquareGame(n - i*i):\n                self.isGood[n] = True\n                return True\n            i += 1\n            \n        return self.isGood[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        memo = {}\n        memo[0] = False\n        memo[1] = True\n        def dfs(n) -> bool:\n            if n in memo:\n                return memo[n]\n            i = 1\n            while i*i <= n:\n                res = dfs(n - i*i) \n                if not res:\n                    memo[n] = True\n                    return True\n                i += 1\n            memo[n] = False\n            return False\n        return dfs(n) ", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def helper(n):\n            if n == 0:\n                return -1\n            for i in range(int(sqrt(n)), 0, -1):\n                # print(i)\n                if(helper(n - i*i) < 0):\n                    return 1\n            return -1\n        return helper(n) > 0", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        return True if n == 1 else any(not self.winnerSquareGame(n - i ** 2) for i in range(int(n ** 0.5), 0, -1))\n               \n            \n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp=[False]*(n+1)\n        dp[0]=False\n        dp[1]=True\n        for i in range(2,n+1):\n            k=1\n            while k**2<=i:\n                if dp[i-k**2]==False:\n                    dp[i]=True\n                    break\n                k+=1\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = defaultdict(bool)\n        \n        def helper(n):\n            if n == 0:\n                return False\n            \n            if n in dp:\n                return dp[n]\n            \n            for i in range(1, int(n**0.5)+1):\n                if not helper(n-i**2):\n                    dp[n] = True\n                    return True\n            \n            dp[n] = False\n            return False\n        \n        return helper(n)\n            \n", "\nimport functools\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @functools.lru_cache(maxsize=10**5)\n        def WSG(k):\n            if k == 0:\n                return False\n\n            i=1\n            while i**2 <= k:\n                if not WSG(k-i**2):\n                    return True\n                i += 1\n            return False\n        return WSG(n)", "class Solution:\n    @lru_cache(maxsize=None)\n    def winnerSquareGame(self, n: int) -> bool:\n        # if a perfect square is available, you win\n        if int(sqrt(n)) ** 2 == n:\n            return True\n\n        for i in range(1, int(sqrt(n)) + 1):\n            if not self.winnerSquareGame(n - i * i):\n                return True\n\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp=[False]*(n+1)\n        dp[0]=False\n        for i in range(1,n+1):\n            k=1\n            while k**2<=i:\n                if dp[i-k**2]==False:\n                    dp[i]=True\n                    break\n                k+=1\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [-1 for i in range(n+1)]\n        \n        def help(n):\n            if dp[n]==-1:            \n                if n<1:\n                    result = False\n                else:\n                    result = False\n                    i=1\n                    while i**2 <= n:\n                        move = i**2\n                        result = result or not(help(n-move))\n                        if result:\n                            break\n                        i+=1\n                        \n                dp[n] = result\n            return dp[n]\n        return help(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        memo = {0:False}\n        def wing(x):\n            if math.sqrt(x) == int(math.sqrt(x)):\n                return True\n            if x in memo:\n                return memo[x]\n            i = 1\n            ans = False\n            while i*i <= x:\n                if wing(x-i*i) == False:\n                    ans = True\n                    break\n                i += 1\n            memo[x] = ans\n            return ans\n        \n        return wing(n)", "class Solution:\n    @lru_cache(1024**2)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0: return False\n        for i in range(1, int(sqrt(n))+1):\n            if i*i > n: continue\n            if not self.winnerSquareGame(n - (i*i)):\n                return True\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        square = []\n        for i in range(1, n+1):\n            if i*i <= n:\n                square.append(i*i)\n            else:\n                break\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(n, state):\n            if n == 0:\n                if state == 1:\n                    return False\n                else:\n                    return True\n            \n            if state == 1:\n                tmp = False\n                for num in square:\n                    if num <= n:\n                        tmp = tmp or dp(n-num, 1-state)\n                        if tmp == True:\n                            return tmp\n                    else:\n                        break\n            else:\n                tmp = True\n                for num in square:\n                    if num <= n:\n                        tmp = tmp and dp(n-num, 1-state)\n                        if tmp == False:\n                            return tmp\n                    else:\n                        break\n                \n            return tmp\n        \n        return dp(n, 1)\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1:\n            return True\n        return any(not self.winnerSquareGame(n - i ** 2) for i in range(int(n ** 0.5), 0, -1))\n               \n            \n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, len(dp)):\n            j = 1\n            while j * j <= i:\n                if dp[i - j * j] == False:\n                    dp[i] = True\n                j += 1\n        return dp[-1]", "\nimport functools\nclass Solution:\n    @functools.lru_cache(maxsize=None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        \n        i=1\n        while i**2 <= n:\n            if not self.winnerSquareGame(n-i**2):\n                return True\n            i += 1\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [0] * (n+3)\n        dp[1] = 1 #Alice\n        dp[2] = 0 #Bob\n        \n        for i in range(3,n+1):\n            for j in range(1,int(i**0.5) + 1):\n                if j**2<=i:\n                    if dp[i-j**2]==0:\n                        dp[i] = 1\n                        break\n                        \n        print((dp[n]))\n        return dp[n]==1\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0 or n == 1: return True\n        i = 1\n        while i ** 2 < n:\n            if not self.winnerSquareGame(n - i ** 2): return True\n            i += 1\n        return i**2 == n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        lookup = {}\n        def getSquareNumbers(n: int) -> List[int]:\n            if n in lookup:\n                return lookup[n]\n            # less than or equal to n\n            lookup[n] = [index * index for index in range(1, 1 + math.floor(math.sqrt(n)))]\n            return lookup[n]\n        \n        table = [False] * (n + 1)\n        \n        for index in range(n + 1):\n            table[index] = any(not table[index - lose] for lose in getSquareNumbers(index))\n            \n        return table[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [0,1]\n        \n        for s in range(2,n+1):\n            dp.append(0)\n            i = 1\n            while i**2 <= s:\n                dp[-1] = max(dp[-1], 1-dp[s-i**2])\n                if dp[-1] == 1: break\n                i += 1\n        return dp[-1]", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n in [1, 0]: return True\n        i = 1\n        while i ** 2 < n:\n            if not self.winnerSquareGame(n - i ** 2): return True\n            i += 1\n        return i**2 == n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0 or n == 1: return True\n        i = int(sqrt(n))\n        if i ** 2 == n: return True\n        while i > 0:\n            if not self.winnerSquareGame(n - i ** 2): return True\n            i -= 1\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1,n+1):\n            j = 1\n            while j*j <= i:\n                dp[i] |= not dp[i-j*j]\n                j+=1\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dp(n,people):\n            for i in range(1,400):\n                if i*i<=n:\n                    result=dp(n-i*i,0 if people is 1 else 1)\n                    if people==0:# Alice\n                        if result:\n                            return result\n                    else:\n                        if not result:\n                            return result\n                else:\n                    break\n            if people==0:# Alice\n                return False\n            else:\n                return True\n        return dp(n,0)\n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dfs(m, p):\n            if m == 0:\n                #print(m, p, p == 1)\n                return p == 1\n            if m == 1:\n                #print(m, p, p == 0)\n                return p == 0\n            i = 1\n            while i * i <= m:\n                if p == 0 and dfs(m - i * i, 1):\n                    #print(m, p, True)\n                    return True\n                elif p == 1 and not dfs(m - i * i, 0):\n                    #print(m, p, False)\n                    return False\n                i += 1\n            #print(m, p, p == 1)\n            return p == 1\n        return dfs(n, 0)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        win = [False]\n        for i in range(n):\n            j = 1\n            can_win = False\n            while j ** 2 <= len(win):\n                if not win[-j ** 2]:\n                    can_win = True\n                    break\n                j += 1\n            win.append(can_win)\n        return win[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def get(k):\n            if not k: return False\n            return not all([get(k-i*i) for i in range(1, int(k**0.5)+1)])\n        return get(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        m = {0:False, 1:True}\n        def helper(n):\n            if n in m:\n                return m[n]\n            ans, start = False, 1\n            while start*start<=n:\n                ans = ans or (not helper(n-start*start))\n                start+=1\n            m[n]=ans\n            return ans\n        \n        return helper(n)\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        return True if n == 1 else any(not self.winnerSquareGame(n - i ** 2) for i in range(int(n ** 0.5), 0, -1))", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        return True if n == 1 else any(not self.winnerSquareGame(n - i ** 2) for i in range(int(n ** 0.5), 0, -1))\n", "class Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        return any(not self.winnerSquareGame(n - x ** 2) for x in range(int(n ** 0.5), 0, -1))", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = {0:False}\n        for i in range(0, n):\n            if i in dp and i!=0: \n                continue\n            for j in range(1, n+1):\n                if i+j*j > n:\n                    break\n                dp[i+j*j]=True\n        return False if n not in dp else dp[n]", "import math\nclass Solution:\n    squares=[0]\n    dp=[False]            \n    def winnerSquareGame(self, n: int) -> bool:\n        sqt=int(math.sqrt(n))\n        for i in range(len(self.squares),sqt+1):\n            self.squares.append(i*i)\n        \n        if n+1<=len(self.dp):\n            return self.dp[n]\n        \n        old_len=len(self.dp)\n        for i in range(old_len,n+1):\n            self.dp.append(False)\n        \n        for i in range(old_len,n+1):\n            flag=0\n           # print(\\\"in loop i\\\")\n            for j in range(1,int(math.sqrt(i))+1):\n               # print(\\\"i and j are\\\",i,j)\n                if not self.dp[i-self.squares[j]]:\n                    self.dp[i]=True\n                    flag=1\n                    break\n            if flag==0:\n                self.dp[i]=False\n       # print(dp)\n        return self.dp[n]\n                \n                \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dp(n,people):\n            for i in range(floor(math.sqrt(n)),0,-1):\n                if i*i<=n:\n                    result=dp(n-i*i,0 if people is 1 else 1)\n                    if people==0:# Alice\n                        if result:\n                            return result\n                    else:\n                        if not result:\n                            return result\n            if people==0:# Alice\n                return False\n            else:\n                return True\n        return dp(n,0)\n            \n", "class Solution:\n    @lru_cache(None)    \n    def winnerSquareGame(self, n: int) -> bool:\n        for i in reversed(range(1, int(sqrt(n))+1)):\n            if not self.winnerSquareGame(n-i*i):\n                return True\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        win = [False] * (n + 1)\n        for i in range(n):\n            if not win[i]:\n                j = 1\n                while i + j ** 2 <= n:\n                    if i + j ** 2 == n:\n                        return True\n                    win[i + j ** 2] = True\n                    j += 1\n        return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        to_ret = [False]\n        for i in range(1, n+1) :\n            for j in range(int(i**0.5), 0, -1) :\n                if not to_ret[i-j*j] :\n                    to_ret.append(True)\n                    break\n            if len(to_ret) == i :\n                to_ret.append(False)\n        return to_ret[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        base = 1\n        steps = []\n        dp = [False for i in range(n+1)]\n        for i in range(1, n+1):\n            if base * base <= i:\n                steps.append(base*base)\n                base += 1\n            for step in steps:  \n                if not dp[i-step]:\n                    dp[i] = True\n                    break\n        return dp[-1]", "from functools import lru_cache\nclass Solution:\n    @lru_cache(None)\n    def winnerSquareGame(self, n: int) -> bool:\n        k = int(math.sqrt(n))\n        if k*k ==n or n==3:\n            return True\n        if n==2:\n            return False\n        if all(self.winnerSquareGame(n-i**2) for i in range(k,0,-1)):\n            return False\n        return True\n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        def dfs(n):\n            if n == 0:\n                return False\n            if int(n ** 0.5) ** 2 == n:\n                return True\n            if n not in dic:\n                dic[n] = any(not dfs(n-i) for i in poss if i <= n)\n            return dic[n]\n        poss = []\n        dic = {}\n        for i in range(1, int(n**0.5)+1):\n            poss.append(i*i)\n        poss = poss[::-1]\n        return dfs(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        square = [i**2 for i in range(1,int(n**0.5)+1)]\n        dp = [False for i in range(n+1)]\n        dp[1] = True\n        dp[0] = False\n        \n        for i in range(2,n+1):\n            for sq in square:\n                if sq > i:\n                    break\n                if not dp[i-sq]:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = [False]*(n+1)\n        \n        for i in range(1, n+1):\n            for x in range(1, int(sqrt(i))+1):\n                if not dp[i-x*x]:\n                    dp[i] = True\n                    break\n                    \n        return dp[n]\n", "from math import sqrt\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        from functools import lru_cache\n        @lru_cache(None)\n        def df(x):\n            if int(sqrt(x)) **2 == x: return True\n            if not x: return False\n            for i in range(int(sqrt(x)),0,-1):\n                if not df(x-i*i): return True\n            return False\n        return df(n)\n", "class Solution:\n    \n    def winnerSquareGame(self, n):\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            #dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n            iswin = False\n            for k in range(1, int(sqrt(i))+1):\n                if not dp[i-k*k]:\n                    iswin = True\n                    break\n            dp[i] = iswin\n        return dp[-1]\n    \n    def winnerSquareGame1(self, n: int) -> bool:\n        # \u5c1d\u8bd5\u540c\u6837\u7684\u89e3\u6cd5\uff1f\n        # solve(s), s=\u5f53\u524d\u7684\u5269\u4f59\u7684\u6570\u5b57\u4e0b\uff0cscore diff? \u9700\u8981\u7684\u6700\u5c0f\u6b65\u6570\uff1f\n        # \u5982\u679cs=0\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679cs=\u4efb\u610f\u4e00\u4e2a\u5e73\u65b9\u6570\uff0c\u5219return True, \u56e0\u4e3aalice\u53ef\u4ee5\u90fd\u62ff\u8d70\n        # \u5426\u5219\uff0calice\u53ef\u4ee5\u4ece\u4e2d\u5207\u8d70\u4efb\u610f\u5927\u5c0f\u7684\u5e73\u65b9\u6570x\uff0c\u7136\u540e\u628a\u5269\u4e0b\u7684s-x\u6254\u7ed9bob\n        \n        # \u53ea\u8981\u5176\u4e2d\u6709\u4e00\u4e2a\u5207\u5272\uff0cbob\u65e0\u6cd5\u5728s-x\u4e0b\u83b7\u80dc\uff0c\u90a3\u5c31\u662falice\u83b7\u80dc\n        # \u5982\u679cbob\u5728\u6240\u6709\u5207\u5272\u4e0b\u90fd\u83b7\u80dc\uff0c\u90a3alice lose\n        \n        # \u53ea\u4ecealice\u7684\u89d2\u5ea6\u51fa\u53d1\uff0c\u662f\u5426\u8db3\u591f\uff1f\n        cache = dict()\n        \n        def solve(s): # \u9012\u5f52\u8c03\u7528\u672c\u8eab\uff0c\u4f1a\u82b1\u8d39\u6bd4\u8f83\u591a\u7684\u65f6\u95f4\uff01\n            if s in cache: return cache[s]\n            if s == 0: \n                cache[s] = False\n                return False\n            \n            if pow(int(sqrt(s)), 2) == s: \n                cache[s] = True\n                return True # s is a square number and current player can take it directly, so win\n            \n            iswin = False\n            #for x in range(s-1, 0, -1): # from 1 to s-1, since s is not a square number, too slow if write in this way!\n            #    if pow(int(sqrt(x)), 2) == x:\n            #        if not solve(s-x):\n            #            iswin = True\n            #            break\n            for k in range(1, int(sqrt(s))+1): # this can pass! great! 2612 ms, 37%\n                if not solve(s - k*k):\n                    iswin = True\n                    break\n                \n            cache[s] = iswin\n            return iswin\n        return solve(n) # \u65b9\u6cd5\u662f\u5bf9\u7684\uff0c\u4f46\u662f\u8d85\u65f6\u4e86\uff0cn=31250\u7684\u65f6\u5019\n", "class Solution:\n    \n    def winnerSquareGame(self, n):\n        dp = [False] * (n+1)\n        for i in range(1, n+1):\n            iswin = False\n            for k in range(1, int(sqrt(i)) + 1):\n                if not dp[i-k*k]:\n                    iswin = True\n                    break\n            dp[i] = iswin\n        return dp[-1]\n    \n    def winnerSquareGame2(self, n): # fast speed, 888ms, 77.55%\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            #dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n            iswin = False\n            for k in range(1, int(sqrt(i))+1):\n                if not dp[i-k*k]: # if there is one (one is enough) path that the other player lose, then current player win\n                    iswin = True\n                    break\n            dp[i] = iswin # when no path the other player lose, then iswin=False; otherwise, iswin=True!\n        return dp[-1]\n    \n    def winnerSquareGame1(self, n: int) -> bool:\n        # \u5c1d\u8bd5\u540c\u6837\u7684\u89e3\u6cd5\uff1f\n        # solve(s), s=\u5f53\u524d\u7684\u5269\u4f59\u7684\u6570\u5b57\u4e0b\uff0cscore diff? \u9700\u8981\u7684\u6700\u5c0f\u6b65\u6570\uff1f\n        # \u5982\u679cs=0\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679cs=\u4efb\u610f\u4e00\u4e2a\u5e73\u65b9\u6570\uff0c\u5219return True, \u56e0\u4e3aalice\u53ef\u4ee5\u90fd\u62ff\u8d70\n        # \u5426\u5219\uff0calice\u53ef\u4ee5\u4ece\u4e2d\u5207\u8d70\u4efb\u610f\u5927\u5c0f\u7684\u5e73\u65b9\u6570x\uff0c\u7136\u540e\u628a\u5269\u4e0b\u7684s-x\u6254\u7ed9bob\n        \n        # \u53ea\u8981\u5176\u4e2d\u6709\u4e00\u4e2a\u5207\u5272\uff0cbob\u65e0\u6cd5\u5728s-x\u4e0b\u83b7\u80dc\uff0c\u90a3\u5c31\u662falice\u83b7\u80dc\n        # \u5982\u679cbob\u5728\u6240\u6709\u5207\u5272\u4e0b\u90fd\u83b7\u80dc\uff0c\u90a3alice lose\n        \n        # \u53ea\u4ecealice\u7684\u89d2\u5ea6\u51fa\u53d1\uff0c\u662f\u5426\u8db3\u591f\uff1f\n        cache = dict()\n        \n        def solve(s): # \u9012\u5f52\u8c03\u7528\u672c\u8eab\uff0c\u4f1a\u82b1\u8d39\u6bd4\u8f83\u591a\u7684\u65f6\u95f4\uff01\n            if s in cache: return cache[s]\n            if s == 0: \n                cache[s] = False\n                return False\n            \n            if pow(int(sqrt(s)), 2) == s: \n                cache[s] = True\n                return True # s is a square number and current player can take it directly, so win\n            \n            iswin = False\n            #for x in range(s-1, 0, -1): # from 1 to s-1, since s is not a square number, too slow if write in this way!\n            #    if pow(int(sqrt(x)), 2) == x:\n            #        if not solve(s-x):\n            #            iswin = True\n            #            break\n            for k in range(1, int(sqrt(s))+1): # this can pass! great! 2612 ms, 37%\n                if not solve(s - k*k):\n                    iswin = True\n                    break\n                \n            cache[s] = iswin\n            return iswin\n        return solve(n) # \u65b9\u6cd5\u662f\u5bf9\u7684\uff0c\u4f46\u662f\u8d85\u65f6\u4e86\uff0cn=31250\u7684\u65f6\u5019\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        opt = [False] * (n+1)\n        for i in range(1, n+1):\n            for j in range(1, int(i**0.5)+1):\n                if not opt[i - j*j]:\n                    opt[i] = True\n                    break\n        return opt[n]\n                    \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        \n        dp = [False]*(n+1)\n        \n        for i in range(n+1):\n            # we search downwards, alice can win (i.e. = True)\n            # only we can take a square number away and hit a dp[False]\n            # otherwise it's false\n            \n            # if square, we auto win\n            if i == int(sqrt(i))**2:\n                # print('sq', i)\n                dp[i] = True\n            else:\n                for j in range(1, int(i**0.5)+1):\n                    if not dp[i-j*j]:\n                        # print(i, j*j)\n                        dp[i] = True\n                        break\n                \n        # print(dp)\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        self.sqnums = [x ** 2 for x in range(1, 317)]\n        self.cache = dict((sn, True) for sn in self.sqnums)\n        \n        def dp(n):\n            if n in self.cache:\n                return self.cache[n]\n            \n            x = int(sqrt(n))\n            while x > 0:\n                sn = self.sqnums[x-1]\n                if sn >= n:\n                    break\n\n                if not dp(n - sn):\n                    self.cache[n] = True\n                    return True\n                x -= 1\n                \n            return False\n                \n        return dp(n)\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        ans_list=[0 for _ in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,int(i**0.5)+1):\n                if ans_list[i-j*j]==0:\n                        ans_list[i]=1\n                        break\n        #print(ans_list)\n        return ans_list[-1]\n                \n            \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp=[False]*(n+1)\n        dp[1]=True\n        for i in range(1,n+1):\n            for k in range(1,int(i**0.5)+1):\n                if dp[i-k*k]==False:\n                    dp[i]=True\n                    break\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        s = [i**2 for i in range(1, int(n**(1/2))+1)]\n        dp = [0 for i in range(n+1)]\n        dp[0], dp[1] = False, True\n        \n        for i in range(2, n+1):\n            for j in s:\n                if j > i:\n                    dp[i] = False\n                    break\n                if dp[i-j] == False:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            for base in range(1, int(math.sqrt(i)) + 1):\n                take = base * base\n                if not dp[i - take]:\n                    dp[i] = True\n                    break\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dfs(stones):\n            if stones <= 0:\n                return False\n            \n            for i in reversed(list(range(1, int(sqrt(stones)) + 1))):\n                square = i*i\n                if stones - square == 0 or not dfs(stones - square):\n                    return True\n                \n            return False\n        \n        return dfs(n)\n    \n    \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp=[False]*(n+1)\n\n        for i in range(1,n+1):\n            for j in range(1,int(math.sqrt(i))+1):\n                if dp[i-j*j]==False: dp[i]=True; break\n            \n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = [False for i in range(n+1)]\n        sqs = [i*i for i in range(1,1+int(math.sqrt(n)))]\n        for i in range(n+1):\n            t = False\n            for sq in sqs:\n                if i-sq < 0:\n                    break\n                if not dp[i-sq]:\n                    t = True\n                    break\n            dp[i] = t                    \n        \n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp=[False]*(n+1)\n        for i in range(1,n+1):\n            for j in range(1,int(i**0.5)+1):\n                if dp[i-j*j]==False:\n                    dp[i]=True\n                    break\n        return dp[n]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp: List[bool] = [False for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, int(i ** 0.5) + 1):\n                if dp[i - j * j] == False:\n                    dp[i] = True\n                    break\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1,n+1):\n            for j in range(1, int(i**0.5)+1):\n                if not dp[i-j*j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        squares = [i * i for i in range(1, int(n ** 0.5) + 1)]\n        \n        DP = [0] * (1 + n)\n        for i in range(1, n + 1):\n            can_win = False\n            for s in squares:\n                if s > i:\n                    break\n                can_win |= not DP[i - s]\n                if can_win:\n                    break\n            DP[i] = can_win\n        return DP[-1]", "import math\nclass Solution:\n    squares=[]\n                \n    def winnerSquareGame(self, n: int) -> bool:\n        sqt=int(math.sqrt(n))\n        for i in range(len(self.squares),sqt+1):\n            self.squares.append(i*i)\n            \n        dp=[False]*(n+1)\n        \n        for i in range(1,n+1):\n            flag=0\n            for j in range(1,int(math.sqrt(i))+1):\n                if not dp[i-self.squares[j]]:\n                    dp[i]=True\n                    flag=1\n                    break\n            if flag==0:\n                dp[i]=False\n        print(dp)\n        return dp[n]\n                \n                \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False]*(n+1)\n        for i in range(1, n+1):\n            for k in range(1, int(i**0.5)+1):\n                if dp[i-k*k] == False:\n                    dp[i] = True\n                    break\n        return dp[n]", "from functools import lru_cache\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        sq = [x*x for x in range(1, 317)]\n        dp = [False] * (n+1)\n        \n        for i in range(n+1):\n            for x in sq:\n                if i - x < 0:\n                    break\n                if dp[i - x] == False:\n                    dp[i] = True\n                    break\n        \n        return dp[n]\n\n    # T F T F F\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def helper(i):\n            if i == 0:\n                return False\n            \n            base = int(i ** 0.5)\n            return any(not helper(i - j * j) for j in range(base, 0, -1))\n        \n        return helper(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if int(n**0.5)**2 == n:\n            return True\n        \n        sqdict = {i*i:1 for i in range(1,n+1)}\n        dp = [False for i in range(n+1)]\n        dp[:4] = [False, True, False, True]\n        \n        for i in range(4, n+1):\n            if sqdict.get(i,0) == 1:\n                dp[i] = True\n            else:\n                for j in sqdict:\n                    if j>i: break\n                    \n                    if dp[i-j] == False:\n                        dp[i] = True\n                        break\n        \n        return dp[n]\n                        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1: return True\n        dp = [None]*(n+1)\n        \n        dp[0],dp[1],dp[2] = False, True, False\n        \n        for i in range(3,n+1):\n            for j in range(1,n*n):\n                y = i - j*j\n                if y<0 : \n                    break\n                if not dp[y]:\n                    dp[i] = True\n                    break\n        return dp[-1]\n                \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False, True, False]\n        for x in range(3, n+1):\n            dp.append(False)\n            for y in range(1, n):\n                a = x - y * y\n                if a < 0: break\n                if not dp[a]:\n                    dp[x] = True\n                    break\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        #squares = [i * i for i in range(1, int(n ** 0.5) + 1)]\n        \n        DP = [0] * (1 + n)\n        for i in range(1, n + 1):\n            DP[i] = not all(DP[i - j * j] for j in range(1, int(i ** 0.5) + 1))\n        return DP[-1]", "class Solution:\n    def findWinner(self, res, sqlist, n, t, turn):\n        if turn == 'Alice':\n            if res[t] == 1:\n                res[n] = 1\n                return res\n            if res[t] == 2:\n                return res\n            if res[t] == 0:\n                ind = len(sqlist) - 1\n                while ind >= 0:\n                    temp = t - sqlist[ind]\n                    if temp >= 0:\n                        fw1 = Solution()\n                        res = fw1.findWinner(res, sqlist, n, temp, 'Bob')\n                        if res[temp] == 2:\n                            res[t] = 1\n                            res[n] = 1\n                            return res\n                    ind -= 1\n                res[t] = 2\n                return res\n        if turn == 'Bob':\n            if res[t] == 2:\n                res[n] = 1\n                return res\n            if res[t] == 1:\n                return res\n            if res[t] == 0:\n                ind = len(sqlist) - 1\n                while ind >= 0:\n                    temp = t - sqlist[ind]\n                    if temp >= 0:\n                        fw2 = Solution()\n                        res = fw2.findWinner(res, sqlist, n, temp, 'Alice')\n                        if res[temp] == 2:\n                            res[t] = 1\n                            res[n] = 2\n                            return res\n                    ind -= 1\n                res[t] = 2\n                return res\n        return res\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 0:\n            return False\n        res = []\n        for i in range(n + 1):\n            res.append(0)\n        sqlist = []\n        i = 1\n        isq = 1\n        while isq <= n:\n            sqlist.append(isq)\n            res[isq] = 1\n            i += 1\n            isq = i ** 2\n        fw = Solution()\n        finres = fw.findWinner(res, sqlist, n, n, 'Alice')\n        if finres[n] == 1:\n            return True\n        else:\n            return False", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def dfs(stones):\n            if stones < 0:\n                return False\n            \n            for i in reversed(list(range(1, int(sqrt(stones)) + 1))):\n                square = i*i\n                if stones - square == 0 or not dfs(stones - square):\n                    return True\n                \n            return False\n        \n        return dfs(n)\n    \n    \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5 + 1)))\n            \n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]\n                \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        '''\n        dp = [False] * (n + 1)\n        for i in range(1, n+1):\n            for k in range(1, i+1):\n                if i - k**2 < 0: break\n                if not dp[i - k**2]: dp[i] = True;break\n            #print(dp)        \n        return dp[-1]\n        '''\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]   ", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = any(not dp[i - j * j] for j in range(1, int(sqrt(i)) + 1))\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n):\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i ** 0.5) + 1))\n        return dp[-1]", "from functools import lru_cache\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n   \n        @lru_cache(None)\n        def dp(i):\n            sq = int(math.sqrt(i))\n            if sq**2==i:\n                return True\n            \n            ans=False\n            for m in [n**2 for n in range(1,sq+1)][::-1]:\n                ans = ans or not dp(i-m)\n                if ans:\n                    return True\n            return ans\n        \n        return dp(n)\n            \n            \n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @lru_cache(None)\n        def helper(i):\n            if i in [0, 2]:\n                return False\n            \n            base = int(i ** 0.5)\n            if base * base == i:\n                return True\n            \n            return any(not helper(i - j * j) for j in range(base, 0, -1))\n        \n        return helper(n)", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        \n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[-1]\n        \n#         if n == 0 or n == 2:\n#             return False\n#         if n == 1:\n#             return True\n#         dp = [-1] * (n+1)\n#         dp[0] = 0\n#         dp[1] = 1\n#         dp[2] = 0\n        \n#         def pick(n):\n            \n#             if dp[n] != -1:\n#                 return dp[n]\n#             i = 1\n#             while i * i <= n:\n#                 if i * i == n:\n#                     dp[n] = 1\n#                     return True\n#                 if not pick(n-i*i):\n#                     dp[n] = 1\n#                     return True\n#                 i = i+1\n#             dp[n] = 0\n#             return dp[n]\n#         pick(n)\n#         return dp[n] == 1\n        \n                \n                \n        \n                \n                \n            \n                \n            \n            \n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1) # true is on peut gagner le jeu avec i pierre\n        for i in range(1, n + 1):\n            dp[i] = not all(dp[i - k * k] for k in range(1, int(i**0.5) + 1)) # si tout gagne apr\u00e8s notre coup (quel qu'il soit), on perd\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \n        dp = [False]*(n+1)\n        for i in range(n+1):\n            for j in range(1,i+1):\n                if j*j > i: break\n                elif not dp[i-j*j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = any(not dp[i - k * k] for k in range(1, int(i**0.5) + 1))\n        return dp[n]\n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        if n == 1:\n            return True\n        num = 0\n        dp = [False] * (1 + n)\n        while num * num < n:\n            dp[num * num] = True\n            num += 1\n        if num * num == n:\n            return True\n            \n        for i in range(1, n + 1):\n            if dp[i]:\n                continue\n            j = 1\n            while j * j <= i:\n                if not dp[i - j * j]:\n                    dp[i] = True\n                    break\n                j += 1\n        return dp[n]\n                \n        \n        \n", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        def is_square(n):\n            root = math.sqrt(i)\n            return root == int(root)\n            \n            \n        dp = [False] * (n + 1)\n        squares = []\n        for i in range(1, n + 1):\n            if is_square(i):\n                squares.append(i)\n            \n            dp[i] = any(not dp[i - square] for square in squares)\n        return dp[-1]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [False for _ in range(n + 1)]\n        #dp[i] denotes can a player win when i stones are present in the pile\n        dp[1] = True\n        for i in range(2, n + 1):\n            j = 1\n            while j*j <= i:\n                if not dp[i - j*j]:\n                    dp[i] = True\n                    break\n                    \n                j += 1\n        \n        # print(dp)\n        return dp[n]", "class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        result = []\n        result.append(False)\n        for i in range(1,n+1):\n            j = 1\n            flag = True\n            while(j*j<=i):\n                if not result[i - j*j]:\n                    flag = False\n                    break\n                j += 1\n            if flag==True:\n                result.append(False)\n            else:\n                result.append(True)\n        \n        print(result)\n        return result[-1]", "from functools import lru_cache\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp = [None] * (n + 1)\n        dp[0] = False\n        i = 1\n        while i ** 2 <= n:\n            dp[i**2] = True\n            i += 1\n        # print(dp)\n        sq = 1\n        for i in range(2, n + 1):\n            if dp[i]: continue\n                \n            dp[i] = False\n            sq = int(math.sqrt(i))\n            for k in range(sq, 0, -1):\n                if not dp[i - k**2]:\n                    dp[i] = True\n                    break\n                        \n        return dp[n]\n    \n#     def winnerSquareGame(self, n: int) -> bool:\n#         def dp(i):\n#             if i == 0: return False\n#             sq = int(math.sqrt(i))\n#             if sq ** 2 == i: return True\n#             if i not in memo:\n#                 memo[i] = False\n#                 for k in range(1, sq + 1):\n#                     if not dp(i - k**2):\n#                         memo[i] = True\n#             return memo[i]\n        \n#         memo = {}\n        \n#         return dp(n)\n"]
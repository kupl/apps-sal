["class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        # assign hat to people\n        n = len(hats)\n        dic = collections.defaultdict(list)\n        for i,hat in enumerate(hats):\n            for h in hat:\n                dic[h].append(i)\n        \n        # mask for people: ways\n        bfs = {0:1}\n        target = (1<<n)-1\n        res = 0\n        for h in range(1,41):\n            new_bfs = bfs.copy()\n            for p in dic[h]:\n                for mask,cnt in list(bfs.items()):\n                    new_mask = (1<<p)|mask\n                    if new_mask!=mask:\n                        if new_mask not in new_bfs:\n                            new_bfs[new_mask]=0\n                        new_bfs[new_mask]+= cnt\n            bfs = new_bfs\n        return bfs[target]%(10**9+7) if target in bfs else 0\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        MOD = int(1e9) + 7\n        n = len(hats)\n        # dp = [[0 for _ in range(1 << n)] for _ in range(41)]\n        d = {0: 1}\n        rev = [[] for _ in range(41)]\n        for i, h in enumerate(hats):\n            for e in h:\n                rev[e].append(i)\n        for i in range(40):\n            r = rev[i+1]\n            nx = d.copy()\n            for j in d:\n                for k in r:\n                    if not (j & (1 << k)):\n                        nj = j | (1 << k)\n                        nx[nj] = (nx.get(nj, 0) + d[j])\n            d = nx\n        return d.get((1 << n) - 1, 0) % MOD", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        MOD = int(1e9) + 7\n        n = len(hats)\n        # dp = [[0 for _ in range(1 << n)] for _ in range(41)]\n        d = {0: 1}\n        rev = [[] for _ in range(41)]\n        for i, h in enumerate(hats):\n            for e in h:\n                rev[e].append(i)\n        for i in range(40):\n            r = rev[i+1]\n            nx = {}\n            for j in d:\n                nx[j] = (nx.get(j, 0) + d[j]) % MOD\n                for k in r:\n                    if not (j & (1 << k)):\n                        nx[j | (1 << k)] = (nx.get(j | (1 << k), 0) + d[j]) % MOD\n            d = nx\n        return d.get((1 << n) - 1, 0)", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        ## https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/discuss/608778/Java-Top-down-DP-%2B-Bitmask-Clean-code\n        ## hat: current hat; assignedPeople: bitmask for n people (0: this person has not been assigned a hat, 1 otherwise)\n        \n        def helper(hat, assignedPeople):\n            if assignedPeople == target_state:\n                return 1\n                \n            if hat>40: ## no remaining hat \n                return 0\n            \n            if dp[hat][assignedPeople] is not None:\n                return dp[hat][assignedPeople]\n            \n            res = 0 \n            ## case 1: do not use current hat\n            res += helper(hat+1, assignedPeople)\n            \n            ## case 2: use current hat\n            ## check every possible person that is allowed to wear the current hat\n            for person in hat2person[hat]:\n                ## if person has a hat already\n                if assignedPeople & (1<<person) != 0: continue\n                res += helper(hat+1, assignedPeople | (1<<person))\n                \n            dp[hat][assignedPeople] = res\n            return dp[hat][assignedPeople]\n            \n        n = len(hats)\n        M = 10**9+7\n        ## h2p[i] indicates the list of people who can wear i_th hat\n        hat2person = [[] for _ in range(41)] \n        for i in range(n):\n            for hat in hats[i]:\n                hat2person[hat].append(i)\n        # print(hat2person)\n        target_state = (1<<n)-1 ## all people have weared a hat\n        dp = [[None for j in range((1<<n))] for i in range(41)]\n        \n        return helper(1, 0) % M", "import functools as ft\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        const = 10**9+7\n        cache = {}\n        matr = [[False]*10 for i in range(40)]\n        maxx = -1\n        for j in range(len(hats)):\n            for i in hats[j]:\n                matr[i-1][j] = True\n                maxx = max(i-1, maxx)\n        def s(mask_p, h, n):\n            if n == 0:\n                return 1\n            if h < 0 or n > h+1:\n                return 0\n            c = str(mask_p + [h])\n            if c in cache:\n                return cache[c]\n            res = s(mask_p, h-1, n)\n            for p in range(len(matr[h])):\n                if mask_p[p] and matr[h][p]:\n                    mask_p[p] = False\n                    res += s(mask_p, h-1, n-1)\n                    mask_p[p] = True\n            cache[c] = res\n            return res\n        mask_p = [True]*len(hats) + [False]*(10-len(hats))\n        return s(mask_p, maxx, len(hats))%const", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        ownhat={}\n        n=len(hats)\n        for i in range(n):\n            hat=hats[i]\n            for h in hat:\n                if(h in ownhat):\n                    ownhat[h].append(i)\n                else:\n                    ownhat[h]=[i]\n        dp=[[-1 for i in range(pow(2,n))] for i in range(41)]\n        def dfs(ind,peoplemask,dp):\n            if(peoplemask==pow(2,n)-1):\n                return 1\n            if(ind>40):\n                return 0\n            count=0\n            if(dp[ind][peoplemask]!=-1):\n                return dp[ind][peoplemask]\n            count=dfs(ind+1,peoplemask,dp)\n            if(ind in ownhat):\n                for people in ownhat[ind]:\n                    if(peoplemask & (pow(2,people))==0):\n                        count=(count+dfs(ind+1,peoplemask | pow(2,people),dp)) % (pow(10,9)+7)\n            dp[ind][peoplemask]=count\n            return count\n        return dfs(1,0,dp)\n                \n            \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        h2p = defaultdict(list)\n        n = len(hats)\n        mod = 10**9+7\n        \n        for p, hat_list in enumerate(hats):\n            for h in hat_list:\n                h2p[h].append(p)\n        \n        '''\n        def dp(h, mask):\n            if (h, mask) in memo:\n                return memo[(h,mask)]\n            \n            if mask == (1 << n) - 1:\n                return 1\n        \n            if h > 40:\n                return 0\n            \n            ans = dp(h+1, mask)\n            \n            if h in h2p:\n                peoples = h2p[h]\n                \n                for p in peoples:\n                    if mask & (1 << p) == 0:\n                        mask |= (1 << p)\n                        ans += dp(h+1, mask)\n                        mask ^= (1 << p)\n            \n            memo[(h,mask)] = ans\n            \n            return ans\n        \n        memo = {}\n        \n        return dp(0, 0) % mod\n        '''\n        m = 1 << n\n        \n        dp = [[0] * m for _ in range(41)]\n        \n        dp[0][0] = 1\n        \n        for h in range(1, 41):\n            for mask in range(m):\n                dp[h][mask] = dp[h-1][mask]\n                \n                for p in h2p[h]:\n                    if mask & (1 << p) != 0:\n                        dp[h][mask] += dp[h-1][mask ^ (1 << p)]\n    \n        return dp[40][m-1] % mod\n                    \n", "import collections\nclass Solution(object):\n    def numberWays(self, hats):\n        lp = len(hats)\n        mod = 10**9+7\n        h_dict = collections.defaultdict(set)\n        for i,h in enumerate(hats):\n            for val in h:\n                h_dict[val].add(i)\n        key_hats = list(h_dict.keys())\n        lk = len(key_hats)\n        @lru_cache(None)\n        def arrange(idx,peo):\n            \n            if peo == (1<<lp)-1: return 1\n            if idx>=lk: return 0\n            re = arrange(idx+1,peo)\n            for nt in h_dict[key_hats[idx]]:\n                if peo&1<<nt==0:\n                    re+=arrange(idx+1,peo|1<<nt)\n            return re%mod\n        \n        return arrange(0,0)%mod\n                    \n", "# class Solution:\n#     def numberWays(self, hats: List[List[int]]) -> int:\n#         const = 10**9+7\n#         cache = {}\n#         matr = [[False]*len(hats) for i in range(40)]\n#         maxx = -1\n#         used_h = set()\n#         for j in range(len(hats)):\n#             for i in hats[j]:\n#                 matr[i-1][j] = True\n#                 maxx = max(i-1, maxx)\n#                 used_h.add(i-1)\n#         def s(mask_p, h, n):\n#             if h < 0 or n > h+1:\n#                 return 0\n#             c = str(h)+mask_p\n#             if c in cache:\n#                 return cache[c]\n#             res = s(mask_p, h-1, n)\n#             if h in used_h:\n#                 for p in range(len(matr[h])):\n#                     if mask_p[p] == \\\"1\\\" and matr[h][p]:\n#                         if n > 1:\n#                             res += s(mask_p[:p] + \\\"0\\\" + mask_p[p+1:], h-1, n-1)\n#                         else:\n#                             res += 1\n#             cache[c] = res%const\n#             return res%const\n#         mask_p = \\\"1\\\"*len(hats)\n#         return s(mask_p, maxx, len(hats))%const\n    \n    \n# class Solution:\n#     def numberWays(self, hats: List[List[int]]) -> int:\n#         const = 10**9+7\n#         matr = [0 for i in range(40)]\n#         maxx = -1\n#         used_h = set()\n#         for j in range(len(hats)):\n#             for i in hats[j]:\n#                 matr[i-1] = matr[i-1] ^ (1 << j)\n#                 maxx = max(i-1, maxx)\n#                 used_h.add(i-1)\n#         matr = matr[:maxx+1]\n#         mask_p = 2**len(hats)-1\n#         def s(mask_p, n, h, c_h, cache):\n#             if n > c_h:\n#                 return 0\n#             if cache[mask_p][h] != None:\n#                 return cache[mask_p][h]\n#             if mask_p == 0:\n#                 return 1\n#             res = 0\n#             if h in used_h:\n#                 c_h -= 1\n#                 b = bin(mask_p & matr[h])\n#                 for p in range(2, len(b)):\n#                     if b[p] == \\\"1\\\":\n#                         res += s(mask_p ^ (1 << (len(b)-p-1)), n-1, h-1, c_h, cache)\n#             res += s(mask_p, n, h-1, c_h, cache)\n#             cache[mask_p][h] = res\n#             return cache[mask_p][h]\n#         return s(mask_p, len(hats), maxx, len(used_h), [[None]*(maxx+1) for i in range(mask_p+1)])%const\n    \nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        h2p = defaultdict(list)\n        for i, hat in enumerate(hats):\n            for h in hat:\n                h2p[h].append(i)\n        n = len(hats)\n \n        # bottom up\n        dp, ndp = defaultdict(int), defaultdict(int)\n\n        for hat in range(0, 41):\n            for mask in range(1<<n):\n                if mask == 0: ndp[mask] = 1\n                else:\n                    ndp[mask] = dp[mask]\n                    for p in h2p[hat]:\n                        if mask & (1<<p):\n                            ndp[mask] += dp[mask ^ (1<<p)]\n                            ndp[mask] %= 10**9+7\n            dp, ndp = ndp, defaultdict(int)\n\n        return dp[(1<<n)-1]", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        \n        n = len(hats)\n        fullMask = (1<<n)-1\n        mp = defaultdict(list)\n        \n        for idx,i in enumerate(hats):\n            for hat in i:\n                mp[hat-1].append(idx)\n                \n         \n        mod = 10**9+7\n        \n        @lru_cache(None)\n        def dp(hat,mask):\n            if mask == fullMask:\n                return 1\n            if hat >= 40:\n                return 0\n            \n            ans = dp(hat+1,mask) % mod\n            for person in mp[hat]:\n                if not mask&(1<<person):\n                    ans += dp(hat+1,mask^(1<<person))\n                    ans %= mod\n            return ans % mod\n        \n        return dp(0,0) % mod", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        h2p = defaultdict(list)\n        for i, hat in enumerate(hats):\n            for h in hat:\n                h2p[h].append(i)\n        n = len(hats)\n \n        # bottom up\n        dp, ndp = defaultdict(int), defaultdict(int)\n\n        for hat in range(0, 41):\n            for mask in range(1<<n):\n                if mask == 0: ndp[mask] = 1\n                else:\n                    ndp[mask] = dp[mask]\n                    for p in h2p[hat]:\n                        if mask & (1<<p):\n                            ndp[mask] += dp[mask ^ (1<<p)]\n                            ndp[mask] %= 10**9+7\n            dp, ndp = ndp, defaultdict(int)\n\n        return dp[(1<<n)-1]", "# Time: O(40 * 2^n * n), where n is the number of people, n <= 10\n# Explain: There are total hat*assignedPeople = 40*2^n states in dfs(..hat, assignedPeople...) function, each state needs a loop up to n times (int p : h2p[hat]) to calculate the result.\n# Space: O(40 * 2^n)\n\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        hat_to_ppl = [[] for _ in range(41)]\n        for i, person in enumerate(hats):\n            for hat_preference in person:\n                hat_to_ppl[hat_preference].append(i)\n                \n        # Remove entries for unwanted hats\n        hat_to_ppl = list([x for x in hat_to_ppl if x])\n        \n        num_hats = len(hat_to_ppl)\n        num_ppl = len(hats)\n        \n        if num_hats < num_ppl:\n            return 0\n        \n        @functools.lru_cache(None)\n        def dp(i, mask):\n            # Mask signifies person state\n            if i == num_hats:\n                if bin(mask).count('1') == num_ppl:\n                    return 1\n                else:\n                    return 0\n                        \n            # Not using current hat             \n            res = dp(i+1, mask)\n            \n            for person in hat_to_ppl[i]:\n                # Person is not wearing a hat already                 \n                if (mask & (1<<person)) == 0:\n                    mask |= 1<<person\n                    res += dp(i+1, mask)\n                    mask ^= 1<<person\n            \n            return res % (10**9+7)\n        \n        return dp(0, 0)\n                    \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        res, n, dp, hat2persons = 0, len(hats), {}, collections.defaultdict(list)\n        for person, arr in enumerate(hats):\n            for hat in arr:\n                hat2persons[hat-1].append(person)\n        dp[0] = 1\n        for hat in range(40):\n            dp_new = dict(dp)\n            for person in hat2persons[hat]:\n                for state, cnt in dp.items():\n                    # print(f'{bin(state)}/{state}: {cnt}, {dp}: {dp[state]}')\n                    if state&(1<<person) == 0:\n                        if state|(1<<person) not in dp_new:\n                            dp_new[state|(1<<person)] = cnt\n                        else:\n                            dp_new[state|(1<<person)] += cnt\n            dp = dp_new\n        print(dp)\n        return dp[(1<<n)-1] % (10**9+7) if ((1<<n)-1) in dp else 0", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        # mask = (1<<10)-1 #-> person i is wearing a hat already\n        hat_per_map = defaultdict(list)\n        for idx,i in enumerate(hats):\n            for j in i:\n                hat_per_map[j-1].append(idx)\n        @lru_cache(None)\n        def dp(hat,mask):\n            if mask == (1<<len(hats))-1:\n                return 1\n            if hat >= 40:\n                return 0\n            \n            ans = dp(hat+1,mask) % 1000000007\n            for i in hat_per_map[hat]:\n                if not mask&(1<<i):\n                    ans += dp(hat+1,mask|(1<<i)) % 1000000007\n            return ans\n                \n        return dp(0,0)%1000000007\n                    \n", "from functools import lru_cache\nclass Solution:\n    def numberWays(self, ppl_to_hats: List[List[int]]) -> int:\n        # 10 ppl, 40 hats.\n        # each person, choose a hat which is not taken.\n        hats_to_ppl = [[] for _ in range(41)]\n        for pid, hats in enumerate(ppl_to_hats):\n            for hid in hats:\n                hats_to_ppl[hid].append(pid)\n        num_ppl = len(ppl_to_hats)\n        all_ppl_mask = (1 << num_ppl) - 1\n        MOD = 10**9+7\n        \n        @lru_cache(None)\n        def helper(ppl_assigned_bitmask, next_hid):\n            if ppl_assigned_bitmask == all_ppl_mask:\n                return 1\n            if next_hid > 40:\n                return 0\n            ways = helper(ppl_assigned_bitmask, next_hid + 1) % MOD\n            for pid in hats_to_ppl[next_hid]:\n                pid_mask = 1 << pid\n                if pid_mask & ppl_assigned_bitmask == 0:\n                    # this person can wear.\n                    ways += helper(pid_mask | ppl_assigned_bitmask, next_hid + 1)\n                    ways %= MOD\n                    \n            return ways\n        \n        ret = helper(0, 1)\n        return ret % MOD", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        from collections import defaultdict\n        from functools import lru_cache\n        ppl=defaultdict(list)\n        for i in range(len(hats)):\n            for j in hats[i]:\n                ppl[j].append(i)\n                \n                \n        @lru_cache(None)\n        def call(ht,mask):\n            if mask==(1<<len(hats))-1:\n                return 1\n            if ht>40:\n                return 0\n            ans=call(ht+1,mask)\n            for p in ppl[ht+1]:\n                if mask&(1<<p):\n                    continue\n                mask|=(1<<p)\n                ans+=call(ht+1,mask)\n                mask^=(1<<p)\n                \n            return ans%(10**9 +7)\n        return call(0,0)\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        res, n, dp, hat2persons = 0, len(hats), {}, collections.defaultdict(list)\n        for person, arr in enumerate(hats):\n            for hat in arr:\n                hat2persons[hat-1].append(person)\n        dp[0] = 1\n        for hat in range(40):\n            dp_new = dict(dp)\n            for person in hat2persons[hat]:\n                for state in range(1<<n):\n                    cnt = dp[state] if state in dp else 0\n                    if state&(1<<person) == 0:\n                        if state|(1<<person) not in dp_new:\n                            dp_new[state|(1<<person)] = cnt\n                        else:\n                            dp_new[state|(1<<person)] += cnt\n            dp = dp_new\n        return dp[(1<<n)-1] % (10**9+7)", "class Solution:\n    def numberWays(self, hats) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(hats)\n        t = 1 << n\n        people = [[] for _ in range(41)]\n        for i, hat in enumerate(hats):\n            for h in hat:\n                people[h].append(i)\n        \n        dp = [[0 for _ in range(t)] for _ in range(41)]\n\n        dp[0][0] = 1\n\n        for i in range(1,41):\n            for mask in range(t):\n                dp[i][mask] = dp[i-1][mask]\n                for p in people[i]:\n                    if (mask & 1 << p) > 0: \n                        dp[i][mask] = (dp[i][mask] + dp[i-1][mask & ~(1 << p)]) % MOD\n        \n        ans = max(dp[i][t-1] for i in range(40))\n        return dp[40][t-1]\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        res, n, dp, hat2persons = 0, len(hats), {}, collections.defaultdict(list)\n        for person, arr in enumerate(hats):\n            for hat in arr:\n                hat2persons[hat-1].append(person)\n        dp[0] = 1\n        for hat in range(40):\n            dp_new = dict(dp)\n            for person in hat2persons[hat]:\n                for state, cnt in dp.items():\n                    if state&(1<<person) == 0:\n                        if state|(1<<person) not in dp_new:\n                            dp_new[state|(1<<person)] = cnt\n                        else:\n                            dp_new[state|(1<<person)] += cnt\n            dp = dp_new\n        return dp[(1<<n)-1] % (10**9+7) if ((1<<n)-1) in dp else 0", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        htop = [[] for i in range(41)] # htop: hat to people list\n        for p, prefer_hats in enumerate(hats):\n            for h in prefer_hats:\n                htop[h].append(p)\n        htop = list([h for h in htop if h]) # filter out hats no one wants\n        \n        num_hats, num_people = len(htop), len(hats)\n        if num_hats < num_people:\n            return 0\n        \n        MOD = 10**9+7\n        @functools.lru_cache(None)\n        def dp(i, mask):\n            if bin(mask).count('1') == num_people:\n                return 1\n            if i == num_hats:\n                return 0\n            res = dp(i+1, mask) # not using the current hat\n            for p in htop[i]:\n                if mask & (1<<p) == 0:\n                    mask |= 1<<p\n                    res += dp(i+1, mask)\n                    mask ^= 1<<p\n            return res%MOD\n        return dp(0, 0)\n# class Solution:\n#     def numberWays(self, hats: List[List[int]]) -> int:        \n#         hat2ppl = defaultdict(set)        \n#         for i, hats_i in enumerate(hats):\n#             for h in hats_i:\n#                 hat2ppl[h].add(i)\n#         if len(hats) > len(hat2ppl): return 0        \n#         @lru_cache(None)\n#         def dfs(h, mask):\n#             print(h, mask)\n#             if h == 40: return            \n#             if mask == (1 << len(hats)) - 1: return 1\n#             dfs(h+1, mask)\n#             ans = 0\n#             for p in hat2ppl.get(h, set()):\n#                 x = 1 << p\n#                 if mask & x == 0:\n#                     mask |= x\n#                     ans += dfs(h+1, mask)\n#                     mask ^= x\n#             return ans % (10**9 + 7)        \n#         return dfs(0, 0) \n", "# class Solution:\n#     def numberWays(self, hats: List[List[int]]) -> int:\n#         const = 10**9+7\n#         cache = {}\n#         matr = [[False]*len(hats) for i in range(40)]\n#         maxx = -1\n#         used_h = set()\n#         for j in range(len(hats)):\n#             for i in hats[j]:\n#                 matr[i-1][j] = True\n#                 maxx = max(i-1, maxx)\n#                 used_h.add(i-1)\n#         def s(mask_p, h, n):\n#             if h < 0 or n > h+1:\n#                 return 0\n#             c = str(h)+mask_p\n#             if c in cache:\n#                 return cache[c]\n#             res = s(mask_p, h-1, n)\n#             if h in used_h:\n#                 for p in range(len(matr[h])):\n#                     if mask_p[p] == \\\"1\\\" and matr[h][p]:\n#                         if n > 1:\n#                             res += s(mask_p[:p] + \\\"0\\\" + mask_p[p+1:], h-1, n-1)\n#                         else:\n#                             res += 1\n#             cache[c] = res%const\n#             return res%const\n#         mask_p = \\\"1\\\"*len(hats)\n#         return s(mask_p, maxx, len(hats))%const\n    \n    \nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        const = 10**9+7\n        matr = [0 for i in range(40)]\n        maxx = -1\n        used_h = set()\n        for j in range(len(hats)):\n            for i in hats[j]:\n                matr[i-1] += 2**(j)\n                maxx = max(i-1, maxx)\n                used_h.add(i-1)\n        matr = matr[:maxx+1]\n        mask_p = 2**len(hats)-1\n        def s(mask_p, n, h, c_h, cache):\n            if n > c_h:\n                return 0\n            if cache[mask_p][h] != None:\n                return cache[mask_p][h]\n            if mask_p == 0:\n                return 1\n            res = 0\n            if h in used_h:\n                c_h -= 1\n                b = mask_p & matr[h]\n                i = 0\n                while b > 0:\n                    if b & 1:\n                        res += s(mask_p ^ (1 << i), n-1, h-1, c_h, cache)\n                    b = b >> 1\n                    i += 1\n                # b = bin(mask_p & matr[h])\n                # for p in range(2, len(b)):\n                #     if b[p] == \\\"1\\\":\n                #         res += s(mask_p ^ (1 << (len(b)-p-1)), n-1, h-1, c_h, cache)\n            res += s(mask_p, n, h-1, c_h, cache)\n            cache[mask_p][h] = res\n            return cache[mask_p][h]\n        return s(mask_p, len(hats), maxx, len(used_h), [[None]*(maxx+1) for i in range(mask_p+1)])%const", "class Solution:\n    def numberWays(self,hats):\n        ppl = len(hats)\n        hats_to_ppl = [[] for i in range(41)]\n        dp = [[-1 for j in range(2 ** ppl)] for i in range(41)]\n\n        for i in range(ppl):\n            for j in hats[i]:\n                hats_to_ppl[j].append(i)\n        \n        return self.dfs(1,hats_to_ppl,dp,0, (1 << ppl) -1)  \n         \n    def dfs(self,hat,hats_to_people,dp,cur_assignment,all_assignment):\n        if cur_assignment == all_assignment:\n            return 1\n        if hat > 40:\n            return 0\n        if dp[hat][cur_assignment] != -1:\n            return dp[hat][cur_assignment]\n        \n        res = self.dfs(hat + 1, hats_to_people,dp,cur_assignment,all_assignment)\n        for i in hats_to_people[hat]:\n            if ((cur_assignment >> i) & 1) == 1:\n                continue\n            res += self.dfs(hat + 1, hats_to_people,dp,cur_assignment | (1 << i), all_assignment )\n            res %= 10 ** 9 +7 \n        \n        dp[hat][cur_assignment] = res\n        return res\n        \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        h2p = collections.defaultdict(list)\n        n = len(hats)\n        MOD = 10**9+7\n        \n        for people,hat_list in enumerate(hats):\n            for h in hat_list:\n                h2p[h].append(people)\n                \n        def dp(hat,mask):\n            if (hat,mask) in memo:\n                return memo[(hat,mask)]\n            if mask == (1<<n) -1:\n                return 1\n            if hat > 40:\n                return 0\n            \n            ans = dp(hat+1,mask)\n            if hat in h2p:\n                peoples = h2p[hat]\n                for p in peoples:\n                    if mask&(1<<p) ==0:\n                        ans += dp(hat+1,mask|(1<<p))\n                        # mask|=(1<<p)\n                        # ans += dp(h+1,mask)\n                        # mask ^= (1<<p)\n            memo[(hat,mask)] = ans\n            return ans\n        \n        memo ={}\n        return dp(0,0)%MOD\n\n        \n        \n        \n        \n        \n        \n#         h2p = collections.defaultdict(list)\n#         n = len(hats) # number of people\n        \n#         for people,hat_list in enumerate(hats):\n#             for h in hat_list:\n#                 h2p[h].append(people)\n        \n#         def dp(hat,mask): # hat index and people bit mask,  since n<=10,so use people as bitmask, otherwise if uses hat will TLE\n#             if (hat,mask) in memo:return memo[(hat,mask)]\n            \n#             if mask == (1<<n)-1: # base case\n#                 return 1\n#             if h >40:return 0\n#             # not use current hat\n#             ans = dp(hat+1,mask) \n#             # use current hat\n#             if hat in h2p:\n#                 peoples = h2p[hat]\n#                 for p in peoples:\n#                     if mask & (1<<p) == 0: # means this people has not assigned a hat yet\n#                         mask |= (1<<p)\n#                         ans += dp(hat+1,mask)\n#                         mask ^= (1<<p)\n#                         # ans += dp(hat+1,mask|(1<<p))\n#             memo[(hat,mask)] = ans\n#             return ans\n#         memo = {}\n#         return dp(0,0)\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        mod = 10**9+7\n        k = len(hats)\n        persons = defaultdict(list)\n        for i, hs in enumerate(hats):\n            for h in hs:\n                persons[h].append(i)\n\n        dic = defaultdict(int)\n        dic[0] = 1\n        for hat, ps in persons.items():\n            nex = dic.copy()\n            for mask in dic:\n                for p in ps:\n                    if (mask >> p) & 1 == 0:\n                        nex[mask | (1 << p)] = (nex[mask | (1 << p)]+dic[mask])%mod\n            dic = nex\n\n        return dic[(1 << k) - 1]   ", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        MOD = int(1e9) + 7\n        n = len(hats)\n        dp = [[0 for _ in range(1 << n)] for _ in range(41)]\n        rev = [[] for _ in range(41)]\n        for i, h in enumerate(hats):\n            for e in h:\n                rev[e].append(i)\n        dp[0][0] = 1\n        for i in range(40):\n            r = rev[i+1]\n            for j in range(1 << n):\n                dp[i+1][j] += dp[i][j]\n                dp[i+1][j] %= MOD\n                for k in r:\n                    if not (j & (1 << k)):\n                        dp[i+1][j | (1 << k)] += dp[i][j]\n                        dp[i+1][j | (1 << k)] %= MOD\n        return dp[40][(1 << n) - 1]", "# class Solution:\n#     def numberWays(self, hats: List[List[int]]) -> int:\n#         htop = [[] for i in range(41)] # htop: hat to people list\n#         for p, prefer_hats in enumerate(hats):\n#             for h in prefer_hats:\n#                 htop[h].append(p)\n#         htop = list(filter(lambda h: h, htop)) # filter out hats no one wants\n        \n#         num_hats, num_people = len(htop), len(hats)\n#         if num_hats < num_people:\n#             return 0\n#         print(htop)\n#         MOD = 10**9+7\n#         @functools.lru_cache(None)\n#         def dp(i, mask):\n#             if bin(mask).count('1') == num_people:\n#                 return 1\n#             if i == num_hats:\n#                 return 0\n#             res = dp(i+1, mask) # not using the current hat\n#             for p in htop[i]:\n#                 if mask & (1<<p) == 0:\n#                     mask |= 1<<p\n#                     res += dp(i+1, mask)\n#                     mask ^= 1<<p\n#             return res%MOD\n#         return dp(0, 0)\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:        \n        hat2ppl = defaultdict(set)        \n        for p, hats_i in enumerate(hats):\n            for h in hats_i: hat2ppl[h].add(p)\n        if len(hats) > len(hat2ppl): return 0 \n        M = 10**9 + 7\n        @lru_cache(None)\n        def dfs(h, mask):\n            if h == 42: return 0            \n            if bin(mask).count('1') == len(hats): return 1            \n            ans = dfs(h+1, mask)\n            for p in hat2ppl[h]:\n                x = 1 << p\n                if mask & x == 0:\n                    mask |= x\n                    ans += dfs(h+1, mask)\n                    mask ^= x\n            return ans % M\n        return dfs(1, 0) % M", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        N = len(hats)\n        ppl = dict()\n        for i, hat in enumerate(hats):\n            for x in hat:\n                ppl.setdefault(x, []).append(i)\n                \n        @lru_cache(None)\n        def helper(h, mask):\n            \n            if mask == (1 << N) - 1: return 1  ## if mask covered all the people set bits == people\n            if h == 40: return 0 ## if all hats are being used\n            \n            ans = helper(h+1, mask)\n            \n            for p in ppl.get(h+1, []): ## loop through all the people preferring the hat\n                if mask & (1 << p):  ## if taken already continue\n                    continue\n                    \n                mask |= 1 << p  ## set bit\n                \n                ans += helper(h+1, mask)\n                \n                mask ^= 1 << p  ## reset bit\n                \n            return ans% 1_000_000_007\n        \n        return helper(0, 0)\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        dp = {}\n        n_ppl = len(hats)\n        hat_2_ppl = {}\n        for i in range(n_ppl):\n            for hat in hats[i]:\n                hat_2_ppl[hat] = hat_2_ppl.get(hat, []) + [i]\n\n        def dfs(hat, mask):\n            if mask == (1 << n_ppl) - 1:\n                return 1\n            if hat > 40:\n                return 0\n            if hat in dp and mask in dp[hat]:\n                return dp[hat][mask]\n            res = dfs(hat + 1, mask)\n            for ppl in hat_2_ppl.get(hat, []):\n                if not mask & (1 << ppl):\n                    res += dfs(hat + 1, mask | (1 << ppl))\n                    res %= 1000000000 + 7\n            dp[hat] = dp.get(hat, {})\n            dp[hat][mask] = res\n            return res\n\n        return dfs(1, 0)", "# class Solution:\n#     def numberWays(self, hats: List[List[int]]) -> int:\n#         const = 10**9+7\n#         cache = {}\n#         matr = [[False]*len(hats) for i in range(40)]\n#         maxx = -1\n#         used_h = set()\n#         for j in range(len(hats)):\n#             for i in hats[j]:\n#                 matr[i-1][j] = True\n#                 maxx = max(i-1, maxx)\n#                 used_h.add(i-1)\n#         def s(mask_p, h, n):\n#             if h < 0 or n > h+1:\n#                 return 0\n#             c = str(h)+mask_p\n#             if c in cache:\n#                 return cache[c]\n#             res = s(mask_p, h-1, n)\n#             if h in used_h:\n#                 for p in range(len(matr[h])):\n#                     if mask_p[p] == \\\"1\\\" and matr[h][p]:\n#                         if n > 1:\n#                             res += s(mask_p[:p] + \\\"0\\\" + mask_p[p+1:], h-1, n-1)\n#                         else:\n#                             res += 1\n#             cache[c] = res%const\n#             return res%const\n#         mask_p = \\\"1\\\"*len(hats)\n#         return s(mask_p, maxx, len(hats))%const\n    \n    \nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        const = 10**9+7\n        matr = [0 for i in range(40)]\n        maxx = -1\n        used_h = set()\n        for j in range(len(hats)):\n            for i in hats[j]:\n                matr[i-1] += 2**(j)\n                maxx = max(i-1, maxx)\n                used_h.add(i-1)\n        matr = matr[:maxx+1]\n        mask_p = 2**len(hats)-1\n        def s(mask_p, n, h, c_h, cache):\n            if n > c_h:\n                return 0\n            if cache[mask_p][h] != None:\n                return cache[mask_p][h]\n            if mask_p == 0:\n                return 1\n            res = 0\n            if h in used_h:\n                c_h -= 1\n                b = mask_p & matr[h]\n                i = 0\n                while b > 0:\n                    if b % 2 == 0:\n                        b /= 2\n                    else:\n                        b -= 1\n                        b /= 2\n                        res += s(mask_p - 2**(i), n-1, h-1, c_h, cache)\n                    i += 1\n                # b = bin(mask_p & matr[h])[2:]\n                # for p in range(len(b)):\n                #     if b[p] == \\\"1\\\":\n                #         res += s(mask_p - 2**(len(b)-p-1), n-1, h-1, c_h, cache)\n            res += s(mask_p, n, h-1, c_h, cache)\n            cache[mask_p][h] = res%const\n            return cache[mask_p][h]\n        return s(mask_p, len(hats), maxx, len(used_h), [[None]*(maxx+1) for i in range(mask_p+1)])", "import collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\n\u6bcf\u4e2a\u4eba\u90fd\u4e0d\u540c\u559c\u6b22\u7684\u5e3d\u5b50\uff0c\u6c42\u5206\u914d\u65b9\u6848\u6570\u91cf\n\nhats = [[3,4],[4,5],[5]]\n1\n\ndfs: \n\\t   [3,4]\n\\t     | \n\\t   [4,5]\n\n\u663e\u7136\uff1a\n\\tdp[start_person + 1][chose_hats + new_in] += dp[start_person][chose_hats + new_in]\n\\t   \nn == hats.length\n1 <= n <= 10\n1 <= hats[i].length <= 40\n\n\n'''\n\n\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        LIMIT = 10**9 + 7\n\n        n = len(hats)\n        final = 0\n        dp = collections.defaultdict(lambda: -1)\n\n        # \u666e\u901adfs\n        def dfs(row, path):\n            if row >= n:\n                return 0\n            count = 0\n            for hat in hats[row]:\n                if (1 << hat) & path:\n                    continue\n                if row == n - 1:\n                    count += 1\n                count += dfs(row + 1, path | (1 << hat))\n            return count % LIMIT\n\n        #  \u590d\u6742\u5ea6 O(2^40 * 10).\n        def dfs_dp(row, path):\n            if row >= n:\n                return 0\n            if dp[(row, path)] != -1:\n                return dp[(row, path)]\n            count = 0\n            for hat in hats[row]:\n                if (1 << hat) & path:\n                    continue\n                if row == n - 1:\n                    count += 1\n                count += dfs_dp(row + 1, path | (1 << hat))\n            dp[(row, path)] = count % LIMIT\n            return count % LIMIT \n\n        # \u4e0e\u5176person\u6620\u5c04hat, \u4e0d\u5982hat\u6620\u5c04person\n        # \u590d\u6742\u5ea6 O(2^10 * 40).\n\n        hat_map = collections.defaultdict(set)\n        for person, j in enumerate(hats):\n            for hat in j:\n                hat_map[hat].add(person)\n        hats_list = list(hat_map.keys())\n        hats_n = len(hats_list)\n        final = pow(2, n) - 1\n\n\n        def dfs_dp1(hat_index, path):\n            if hat_index >= hats_n:\n                if path == final:\n                    return 1\n                return 0\n            if dp[(hat_index, path)] != -1:\n                return dp[(hat_index, path)]\n            count = 0\n            for person in hat_map[hats_list[hat_index]]:\n                if (1 << person) & path:\n                    continue\n                count += dfs_dp1(hat_index + 1, path | (1 << person))\n            count += dfs_dp1(hat_index + 1, path)\n            dp[(hat_index, path)] = count % LIMIT \n            return count % LIMIT \n        return dfs_dp1(0, 0)\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:        \n        hat2ppl = defaultdict(set)        \n        for p, hats_i in enumerate(hats):\n            for h in hats_i: hat2ppl[h].add(p)\n\n        M = 10**9 + 7        \n        n = 1 << len(hats)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(41, 0, -1):\n            for j in range(n-1, -1, -1):\n                for p in hat2ppl[i]:       \n                    if j & (1 << p):                        \n                        dp[j] = (dp[j] + dp[j ^ (1 << p)]) % M                        \n        return dp[-1]                            ", "from functools import lru_cache\n\np = 10**9 +7 \nclass Solution:\n    \n#     def get_number_of_ways(self, hats, mask, p_id): #p_id = person_id\n#         if p_id>=len(hats):\n#             return 1\n        \n#         if dp[p_id].get(mask, None):\n#             return dp[p_id][mask]\n#         else:\n#             dp[p_id][mask] = 0\n        \n#         for i in hats[p_id]:\n#             if (mask & (1<<i))>>i :\n#                 continue\n#             temp_mask = mask | (1<<i)\n#             val = self.get_number_of_ways(hats, temp_mask, p_id+1)\n#             if val == -1:\n#                 continue\n            \n#             dp[p_id][mask] += val\n        \n#         return dp[p_id][mask]\n\n        \n    def numberWays(self, hats):\n        max_hat_id = 0\n        distinct_hats = set()\n        for person_hats in hats:\n            for i in range(len(person_hats)):\n                person_hats[i] -= 1\n                distinct_hats.add( person_hats[i])\n        hat_id_mapping = dict()\n        i = 0\n        for hat in distinct_hats:\n            hat_id_mapping[hat] = i\n            i += 1\n            \n        persons = [[] for i in range(len(distinct_hats))]\n        \n        for p_id in range(len(hats)):\n            for hat_id in hats[p_id]:\n                persons[hat_id_mapping[hat_id]].append(p_id)\n        dp = dict()\n        for i in range(len(persons)):\n            dp[i]= dict()\n        allmask = (1<<len(hats))-1\n        \n        def get_number_of_ways( mask, hat_id): #p_id = person_id\n            if mask == allmask :\n                return 1\n            if hat_id>=len(persons):\n                return 0\n            \n            if (hat_id, mask) in dp:\n                return dp[(hat_id, mask)]\n            else:\n                dp[(hat_id, mask)] = get_number_of_ways( mask, hat_id+1)\n            for i in persons[hat_id]:\n                if (mask & (1<<i))>>i :\n                    continue\n                temp_mask = mask | (1<<i)\n                val = get_number_of_ways( temp_mask, hat_id+1)\n                \n                dp[(hat_id, mask)] += val\n            \n            return dp[(hat_id, mask)]\n            \n        \n        ans = get_number_of_ways( 0, 0)\n        return ans%p\n        \n        \n        \n        \n        \n        # @lru_cache(None)\n#         def get_number_of_ways( mask, hat_id, allmask): #p_id = person_id\n#             if mask == allmask :\n#                 return 1\n#             if hat_id>=len(persons):\n#                 return 0\n            \n#             if dp[hat_id].get(mask, None):\n#                 return dp[hat_id][mask]\n#             else:\n#                 dp[hat_id][mask] = get_number_of_ways( mask, hat_id+1, allmask)\n#             for i in persons[hat_id]:\n#                 if (mask & (1<<i))>>i :\n#                     continue\n#                 temp_mask = mask | (1<<i)\n#                 val = get_number_of_ways( temp_mask, hat_id+1, allmask)\n                \n#                 dp[hat_id][mask] += val\n            \n#             return dp[hat_id][mask]\n            \n        \n        \n#         return get_number_of_ways( 0, 0, allmask) % p\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        N = len(hats)\n        for i, h in enumerate(hats):\n            hats[i] = set(h)\n        mod = (10 ** 9) + 7\n        \n        @lru_cache(None)\n        def rec(cur, mask):\n            if cur > 41:\n                return 0\n            if mask == 0:\n                return 1\n            \n            ans = 0\n            for i in range(N):\n                if (mask & (1<<i)) == 0:\n                    continue\n                if cur not in hats[i]:\n                    continue\n                ans += rec(cur+1, mask ^ (1<<i))\n            ans += rec(cur+1, mask)\n            \n            return ans\n        \n        return rec(0, (2**N)-1)%mod", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n                # O(40 * 2 ^ 10 * 10)\n        total = 1 << len(hats)\n        \n        satisfy, bound = [0] * 41, 0\n        for i, likes in enumerate(hats):\n            for hat in likes:\n                satisfy[hat] |= 1 << i\n                bound = max(bound, hat)\n\n        MOD = 10 ** 9 + 7\n        DP = [1] + [0] * (total - 1)\n        for hat in range(1, bound + 1):\n            new_DP = [0] * total\n            for state in range(total):\n                # do not use current hat\n                new_DP[state] = DP[state]\n                # use current hat\n                can_satisfy, mask = satisfy[hat] & state, 1\n                while can_satisfy != 0:\n                    if can_satisfy & 1:\n                        new_DP[state] += DP[state ^ mask]\n                    can_satisfy >>= 1\n                    mask <<= 1\n                new_DP[state] %= MOD\n            DP = new_DP\n\n        return DP[total - 1]\n            \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        N = len(hats)\n        for i, h in enumerate(hats):\n            hats[i] = set(h)\n        mod = (10 ** 9) + 7\n        \n        @lru_cache(None)\n        def rec(cur, mask):\n            if cur > 41:\n                return 0\n            if mask == 0:\n                return 1\n            \n            ans = 0\n            for i in range(N):\n                if (mask & (1<<i)) == 0:\n                    continue\n                if cur not in hats[i]:\n                    continue\n                ans += rec(cur+1, mask ^ (1<<i))\n            ans += rec(cur+1, mask)\n            while ans >= mod:\n                ans -= mod\n            return ans\n        \n        return rec(0, (2**N)-1)", "class Solution:\n    # def numberWays(self, hats: List[List[int]]) -> int:\n        # const = 10**9+7\n        # cache = {}\n        # matr = [[False]*len(hats) for i in range(40)]\n        # maxx = -1\n        # used_h = [False]*40\n        # for j in range(len(hats)):\n        #     for i in hats[j]:\n        #         matr[i-1][j] = True\n        #         maxx = max(i-1, maxx)\n        #         used_h[i-1] = True\n        # def s(mask_p, h, n):\n        #     if n > h+1 or h < 0:\n        #         return 0\n        #     c = str(h)+mask_p\n        #     if c in cache:\n        #         return cache[c]\n        #     res = s(mask_p, h-1, n)\n        #     if used_h[h]:\n        #         for p in range(len(matr[h])):\n        #             if mask_p[p] == \\\"1\\\" and matr[h][p]:\n        #                 if n > 1:\n        #                     res += s(mask_p[:p] + \\\"0\\\" + mask_p[p+1:], h-1, n-1)\n        #                 else:\n        #                     res += 1\n        #     cache[c] = res%const\n        #     return cache[c]\n        # mask_p = \\\"1\\\"*len(hats)\n        # return s(mask_p, maxx, len(hats))%const\n\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n    def _to_hat_to_people(self, person_to_hats):\n        min_hat, max_hat = None, None\n        for hats in person_to_hats:\n            for hat in hats:\n                if min_hat is None or hat < min_hat:\n                    min_hat = hat\n                if max_hat is None or hat > max_hat:\n                    max_hat = hat\n\n        number_of_hats = max_hat - min_hat + 1\n\n        hats_to_people = [[] for _ in range(number_of_hats)]\n        for person in range(len(person_to_hats)):\n            for hat in person_to_hats[person]:\n                hats_to_people[hat - min_hat].append(person)\n        return hats_to_people\n\n\n    def numberWays(self, person_to_hats):\n        hat_to_people = self._to_hat_to_people(person_to_hats)\n        def _number_of_ways(person_to_hat_presence, hat, cache):\n            if all(person_to_hat_presence):\n                return 1\n            if hat >= len(hat_to_people):\n                return 0\n            key = hat, tuple(person_to_hat_presence)\n            if key in cache:\n                return cache[key]\n            else:\n                sum = 0\n                for person in hat_to_people[hat]:\n                    if not person_to_hat_presence[person]:\n                        updated_person_to_hat_presence = person_to_hat_presence.copy()\n                        updated_person_to_hat_presence[person] = True\n                        sum += _number_of_ways(updated_person_to_hat_presence, hat + 1, cache)\n                sum += _number_of_ways(person_to_hat_presence, hat + 1, cache)\n                cache[key] = sum%(10**9+7)\n                return cache[key]\n        return _number_of_ways([False] * len(person_to_hats), 0, {})", "class Solution:\n    # def numberWays(self, hats: List[List[int]]) -> int:\n        # const = 10**9+7\n        # cache = {}\n        # matr = [[False]*len(hats) for i in range(40)]\n        # maxx = -1\n        # used_h = [False]*40\n        # for j in range(len(hats)):\n        #     for i in hats[j]:\n        #         matr[i-1][j] = True\n        #         maxx = max(i-1, maxx)\n        #         used_h[i-1] = True\n        # def s(mask_p, h, n):\n        #     if n > h+1 or h < 0:\n        #         return 0\n        #     c = str(h)+mask_p\n        #     if c in cache:\n        #         return cache[c]\n        #     res = s(mask_p, h-1, n)\n        #     if used_h[h]:\n        #         for p in range(len(matr[h])):\n        #             if mask_p[p] == \\\"1\\\" and matr[h][p]:\n        #                 if n > 1:\n        #                     res += s(mask_p[:p] + \\\"0\\\" + mask_p[p+1:], h-1, n-1)\n        #                 else:\n        #                     res += 1\n        #     cache[c] = res%const\n        #     return cache[c]\n        # mask_p = \\\"1\\\"*len(hats)\n        # return s(mask_p, maxx, len(hats))%const\n\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n    def _to_hat_to_people(self, person_to_hats):\n        min_hat, max_hat = None, None\n        for hats in person_to_hats:\n            for hat in hats:\n                if min_hat is None or hat < min_hat:\n                    min_hat = hat\n                if max_hat is None or hat > max_hat:\n                    max_hat = hat\n\n        number_of_hats = max_hat - min_hat + 1\n\n        hats_to_people = [[] for _ in range(number_of_hats)]\n        for person in range(len(person_to_hats)):\n            for hat in person_to_hats[person]:\n                hats_to_people[hat - min_hat].append(person)\n        return hats_to_people\n\n    def _number_of_ways(self, hat_to_people, person_to_hat_presence, hat, cache):\n        if all(person_to_hat_presence):\n            return 1\n        if hat >= len(hat_to_people):\n            return 0\n        key = hat, tuple(person_to_hat_presence)\n        if key in cache:\n            return cache[key]\n        else:\n            sum = 0\n            for person in hat_to_people[hat]:\n                if not person_to_hat_presence[person]:\n                    updated_person_to_hat_presence = person_to_hat_presence.copy()\n                    updated_person_to_hat_presence[person] = True\n                    sum += self._number_of_ways(hat_to_people, updated_person_to_hat_presence, hat + 1, cache)\n            sum += self._number_of_ways(hat_to_people, person_to_hat_presence, hat + 1, cache)\n            cache[key] = sum%(10**9+7)\n            return cache[key]\n\n    def numberWays(self, person_to_hats):\n        hat_to_people = self._to_hat_to_people(person_to_hats)\n        return self._number_of_ways(hat_to_people, [False] * len(person_to_hats), 0, {})", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        max_hat = max([item for hat in hats for item in hat])\n        n = len(hats)\n        dp = [[0 for _ in range(2 ** n)]  for _ in range(max_hat + 1)]\n        \n        for i in range(max_hat + 1):\n            dp[i][0] = 1\n        \n        hat_bitmaps = []\n        for i in range(n):\n            bitmap = 0\n            for j in hats[i]:\n                bitmap |= (1 << j)\n            hat_bitmaps.append(bitmap)\n                \n        \n        for i in range(1, max_hat + 1):\n            for j in range(2 ** n):\n                acc = 0\n                for k in range(n):\n                    cur_bit = (1 << k)\n                    if j & cur_bit != 0 and (1 << i) & hat_bitmaps[k] != 0:\n                        acc += dp[i-1][j - cur_bit]\n                dp[i][j] = (dp[i-1][j] + acc) % 1000000007\n    \n        return dp[max_hat][2 ** n - 1]\n    \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:        \n        hat2ppl = defaultdict(set)        \n        for p, hats_i in enumerate(hats):\n            for h in hats_i: hat2ppl[h].add(p)\n\n        M, n = 10**9 + 7, 1 << len(hats)\n        dp = [0]*n\n        dp[0] = 1\n        for h in hat2ppl:\n            for j in range(n-1, -1, -1):\n                for p in hat2ppl[h]:       \n                    if j & (1 << p):                        \n                        dp[j] = (dp[j] + dp[j ^ (1 << p)]) % M                        \n        return dp[-1]                            ", "import functools as ft\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        const = 10**9+7\n        cache = {}\n        matr = [[False]*10 for i in range(40)]\n        maxx = -1\n        for j in range(len(hats)):\n            for i in hats[j]:\n                matr[i-1][j] = True\n                maxx = max(i-1, maxx)\n        def s(mask_p, h, n):\n            if n == 0:\n                return 1\n            if h < 0 or n > h+1:\n                return 0\n            c = tuple(mask_p + [h])\n            if c in cache:\n                return cache[c]\n            res = s(mask_p, h-1, n)\n            for p in range(len(matr[h])):\n                if mask_p[p] and matr[h][p]:\n                    mask_p[p] = False\n                    res += s(mask_p, h-1, n-1)\n                    mask_p[p] = True\n            cache[c] = res\n            return res\n        mask_p = [True]*len(hats) + [False]*(10-len(hats))\n        return s(mask_p, maxx, len(hats))%const", "from functools import lru_cache\nfrom operator import iconcat\nfrom functools import reduce\n\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        hat_ids = list(set(reduce(iconcat, hats, [])))\n        n = len(hats)\n        m = len(hat_ids)\n        k = (1 << n) - 1\n\n        @lru_cache(None)\n        def dp(i, used):\n            if i == m:\n                return 1 if used == k else 0\n\n            total = dp(i + 1, used)\n            for p in range(n):\n                if used & (1 << p) == 0 and hat_ids[i] in hats[p]:\n                    total += dp(i + 1, used | (1 << p))\n            return total % MOD\n\n        return dp(0, 0)\n\n\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        self.visited = 0\n        hm = {}\n        for n,i in enumerate(hats):\n            for j in i:\n                if j not in hm:\n                    hm[j] = [n]\n                else:\n                    hm[j].append(n)\n        keys = list(hm.keys())\n        self.saved = {}\n        def helper(index):\n            if (index, self.visited) in self.saved:\n                return self.saved[(index, self.visited)]\n            \n            if self.visited == ((1 << len(hats)) - 1):\n                return 1\n            if index == len(keys):\n                return 0\n            count = 0\n\n            for i in hm[keys[index]]:\n                if not self.visited & (1 << i):\n                    self.visited |= 1 << i\n                    count += helper(index+1)\n                    self.visited ^= 1 << i\n            self.saved[(index, self.visited)] = count+ helper(index+1)\n            return self.saved[(index, self.visited)]\n        return helper(0) % (10 **9 + 7) ", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        N = len(hats)\n        @lru_cache(None)\n        def helper(mask,i):\n            # print(mask,i)\n            if i == 41:\n                if mask == 0:\n                    return 1\n                else:\n                    return 0\n            elif mask == 0:\n                return 1\n            else:\n                total = 0\n                # for pref in hats[i]:\n                #     if mask & (1 << pref):\n                #         total += helper(mask ^ (1 << pref), i+1)\n                for pers in range(N):\n                    if mask & (1 << pers) and i in hats[pers]:\n                        total += helper(mask ^ (1 << pers),i+1)\n                total += helper(mask,i+1)\n                return total\n            \n        return helper(2**N-1,1) % (10**9+7)\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        tot=len(hats)\n        h=[[False]*tot for i in range(41)]\n        for i in range(len(hats)):\n            for j in range(len(hats[i])):\n                h[hats[i][j]][i]=True\n        \n        f=[[0]*(1<<tot) for i in range(41)]\n        f[0][0] = 1\n        mod=10**9+7\n        for i in range(41):\n            for j in range(1<<tot):\n                f[i][j] = (f[i][j] + f[i - 1][j])%mod\n                for k in range(tot):\n                    if (j & (1 << k))!=0 and h[i][k]:\n                        f[i][j] = (f[i][j] + f[i - 1][j ^ (1 << k)]) % mod\n        return f[40][(1 << tot) - 1]\n", "import functools as ft\nclass Solution:\n    # def numberWays(self, hats: List[List[int]]) -> int:\n    #     cache = {}\n    #     l = len(hats)\n    #     def f(allowed, i):\n    #         if i == l:\n    #             return 1\n    #         key = (tuple(allowed), i)\n    #         if key in cache:\n    #             return cache[key]\n    #         c = 0\n    #         for hat in hats[i]:\n    #             if allowed[hat]:\n    #                 allowed[hat] = False\n    #                 c += f(allowed, i+1)\n    #                 allowed[hat] = True\n    #         cache[key] = c\n    #         return c\n    #     allowed = [True]*40\n    #     return f(allowed, 0)\n    def numberWays(self, hats: List[List[int]]) -> int:\n        const = 10**9+7\n        cache = {}\n        matr = [[False]*10 for i in range(40)]\n        for j in range(len(hats)):\n            for i in hats[j]:\n                matr[i-1][j] = True\n        def s(mask_p, h, n):\n            if n == 0:\n                return 1\n            if h < 0:\n                return 0\n            c = tuple(mask_p + [h])\n            if c in cache:\n                return cache[c]\n            res = s(mask_p, h-1, n)\n            for p in range(len(matr[h])):\n                if mask_p[p] and matr[h][p]:\n                    mask_p[p] = False\n                    res += s(mask_p, h-1, n-1)\n                    mask_p[p] = True\n            cache[c] = res\n            return res\n        mask_p = [True]*len(hats) + [False]*(10-len(hats))\n        return s(mask_p, 39, len(hats))%const", "class Solution:\n    def numberWays(self, hats):\n        ppl = len(hats)\n        hats_to_ppl = [[] for i in range(41)]\n        dp = [[-1 for j in range(2** ppl)] for i in range(41)]\n\n        for i in range(ppl):\n            for j in hats[i]:\n                hats_to_ppl[j].append(i)\n        return self.dfs(hats_to_ppl,dp,1,0,(1<<ppl)-1)\n    def dfs(self,hats_to_ppl,dp,hat,cur_assignment,all_assignment):\n        if cur_assignment == all_assignment:\n            return 1\n        if hat > 40:\n            return 0\n        if dp[hat][cur_assignment] != -1:\n            return dp[hat][cur_assignment]\n        \n        res = self.dfs(hats_to_ppl,dp,hat+1,cur_assignment,all_assignment)\n\n        for ppl in hats_to_ppl[hat]:\n            if ((cur_assignment >> ppl) & 1) == 1:\n                continue\n            res += self.dfs(hats_to_ppl,dp,hat+1, cur_assignment | (1 << ppl),all_assignment)\n            res %= 10 ** 9 + 7\n        dp[hat][cur_assignment] = res\n        return res\n        \n", "import functools as ft\nclass Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        const = 10**9+7\n        cache = {}\n        matr = [[False]*10 for i in range(40)]\n        maxx = -1\n        for j in range(len(hats)):\n            for i in hats[j]:\n                matr[i-1][j] = True\n                maxx = max(i-1, maxx)\n        def s(mask_p, h, n):\n            if n == 0:\n                return 1\n            if h < 0:\n                return 0\n            c = tuple(mask_p + [h])\n            if c in cache:\n                return cache[c]\n            res = s(mask_p, h-1, n)\n            for p in range(len(matr[h])):\n                if mask_p[p] and matr[h][p]:\n                    mask_p[p] = False\n                    res += s(mask_p, h-1, n-1)\n                    mask_p[p] = True\n            cache[c] = res\n            return res\n        mask_p = [True]*len(hats) + [False]*(10-len(hats))\n        return s(mask_p, maxx, len(hats))%const", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:        \n        hat2ppl = defaultdict(set)        \n        for p, hats_i in enumerate(hats):\n            for h in hats_i: hat2ppl[h].add(p)\n\n        M, n = 10**9 + 7, 1 << len(hats)\n        dp = [0] * n\n        dp[0] = 1\n        for h in hat2ppl:\n            for j in range(n-1, -1, -1):\n                for p in hat2ppl[h]:       \n                    if j & (1 << p):                        \n                        dp[j] = (dp[j] + dp[j ^ (1 << p)]) % M                        \n        return dp[-1]                            ", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        tot=len(hats)\n        h=[[False]*tot for i in range(41)]\n        for i in range(len(hats)):\n            for j in range(len(hats[i])):\n                h[hats[i][j]][i]=True\n        f=[[0]*(1<<tot) for i in range(41)]\n        f[0][0] = 1\n        mod=10**9+7\n        for i in range(41):\n            for j in range(1<<tot):\n                f[i][j] = (f[i][j] + f[i - 1][j])%mod\n                for k in range(tot):\n                    if (j & (1 << k))!=0 and h[i][k]:\n                        f[i][j] = (f[i][j] + f[i - 1][j ^ (1 << k)]) % mod\n        return f[40][(1 << tot) - 1]\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        ownhat={}\n        n=len(hats)\n        maxhat=-1\n        for i in range(n):\n            hat=hats[i]\n            for h in hat:\n                maxhat=max(h,maxhat)\n                if(h in ownhat):\n                    ownhat[h].append(i)\n                else:\n                    ownhat[h]=[i]\n        dp=[[-1 for i in range(pow(2,n))] for i in range(41)]\n        @lru_cache(None)\n        def dfs(ind,peoplemask):\n            if(peoplemask==pow(2,n)-1):\n                return 1\n            if(ind>maxhat):\n                return 0\n            count=0\n            # if(dp[ind][peoplemask]!=-1):\n            #     return dp[ind][peoplemask]\n            count=dfs(ind+1,peoplemask)\n            if(ind in ownhat):\n                for people in ownhat[ind]:\n                    if(peoplemask & (pow(2,people))==0):\n                        count=(count+dfs(ind+1,peoplemask | pow(2,people))) % (pow(10,9)+7)\n            # dp[ind][peoplemask]=count\n            return count\n        return dfs(1,0)\n                \n            \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        max_hat = max([item for hat in hats for item in hat])\n        n = len(hats)\n        dp = [[0 for _ in range(2 ** n)]  for _ in range(max_hat + 1)]\n        \n        for i in range(max_hat + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, max_hat + 1):\n            for j in range(2 ** n):\n                acc = 0\n                for k in range(n):\n                    cur_bit = (1 << k)\n                    if j & cur_bit != 0 and i in hats[k]:\n                        acc += dp[i-1][j - cur_bit]\n                dp[i][j] = (dp[i-1][j] + acc) % 1000000007\n    \n        return dp[max_hat][2 ** n - 1]\n    \n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        numPeople = len(hats)\n        hatDesired = defaultdict(set)\n        MAX_HATS = 0\n        BIG_NUMBER = 10**9+7\n        for index,hatPreferences in enumerate(hats):\n            for hat in hatPreferences:\n                hatDesired[hat].add(index)\n                MAX_HATS = max(MAX_HATS,hat)\n        numberWays = defaultdict(int)\n        def computeWays(assigned,currentHat):\n            if (assigned,currentHat) in numberWays:\n                return numberWays[(assigned,currentHat)]\n            else:\n                if currentHat == MAX_HATS+1:\n                    if sum(assigned) != numPeople:\n                        answer = 0\n                    else:\n                        answer = 1\n                else:\n                    answer = 0\n                    answer += computeWays(assigned,currentHat+1)##don't assign currentHat to anyone.\n                    answer %= BIG_NUMBER\n                    for index,num in enumerate(assigned):\n                        if num == 0 and index in hatDesired[currentHat]:\n                            nextList = list(assigned)\n                            nextList[index] = 1\n                            nextTuple = tuple(nextList)\n                            answer += computeWays(nextTuple,currentHat+1)\n                            answer %= BIG_NUMBER\n                numberWays[(assigned,currentHat)] = answer\n                return answer\n        return computeWays(tuple([0]*numPeople),1)##be careful about arguments you provide\n", "class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        self.hat_to_man = collections.defaultdict(set)\n        for i, lt in enumerate(hats):\n            for hat in lt:\n                self.hat_to_man[hat].add(i)\n        \n        self.hat_nums = sorted(self.hat_to_man)\n        self.hat_cnt = len(self.hat_nums)\n        self.man_cnt = len(hats)\n        self.mem = dict()\n        \n        return self.dfs(0, set())\n        \n            \n    def dfs(self, idx, used):\n        if idx >= self.hat_cnt:\n            return 0\n        \n        key = (idx, frozenset(used))\n        if key in self.mem:\n            return self.mem[key]\n        \n        hat = self.hat_nums[idx]\n        res = 0\n        for x in self.hat_to_man[hat] - used:\n            used.add(x)\n            if len(used) == self.man_cnt:\n                res += 1\n                used.remove(x)\n                continue\n            res += self.dfs(idx+1, used)\n            used.remove(x)\n            \n        res += self.dfs(idx+1, used)\n            \n        self.mem[key] = res\n        return res%(10**9+7)"]
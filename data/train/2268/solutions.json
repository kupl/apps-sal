["import sys\nsys.setrecursionlimit(10**6)\nn = int(input())\np = list(map(int, input().split()))\nc = [[] for _ in range(n)]\nis_leaf = [True for _ in range(n)]\nfor i in range(n):\n\tp[i] -= 1\n\tc[p[i]].append(i)\n\tis_leaf[p[i]] = False\n\nif sum(is_leaf) == 0:\n\tif n%2 == 0:\n\t\tprint(\"POSSIBLE\")\n\telse:\n\t\tprint(\"IMPOSSIBLE\")\n\treturn\n\nfor i in range(n):\n\tif is_leaf[i]:\n\t\tcur = i\n\t\tbreak\n\nvisited_set = {cur}\nvisited_list = [cur]\nwhile p[cur] not in visited_set:\n\tvisited_list.append(p[cur])\n\tvisited_set.add(p[cur])\n\tcur = p[cur]\n\nroot = p[cur]\n\ngrundy = [-1 for _ in range(n)]\ng_set = [set() for _ in range(n)]\n\ndef dfs(x):\n\tres = 0\n\tfor v in c[x]:\n\t\tdfs(v)\n\t\tg_set[x].add(grundy[v])\n\twhile res in g_set[x]:\n\t\tres += 1\n\tgrundy[x] = res\n\treturn res\n\nloop = [False for _ in range(n)]\nloop[root] = True\nind = len(visited_list)-1\nwhile visited_list[ind] != root:\n\tloop[visited_list[ind]] = True\n\tind -= 1\n#print(loop)\n\nfor i in range(n):\n\tif loop[i]:\n\t\tfor x in c[i]:\n\t\t\tif not loop[x]:\n\t\t\t\tdfs(x)\n\t\t\t\tg_set[i].add(grundy[x])\n\ncand = []\nnum = 0\nwhile num in g_set[root]:\n\tnum += 1\ncand.append(num)\nnum += 1\nwhile num in g_set[root]:\n\tnum += 1\ncand.append(num)\n\nfor x in cand:\n\tcur = root\n\tgrundy[root] = x\n\twhile True:\n\t\tnum = 0\n\t\twhile num in g_set[p[cur]] or num == grundy[cur]:\n\t\t\tnum += 1\n\t\tgrundy[p[cur]] = num\n\t\tif p[cur] == root:\n\t\t\tbreak\n\t\tcur = p[cur]\n\tif grundy[root] == x:\n\t\t#print(grundy)\n\t\tprint(\"POSSIBLE\")\n\t\treturn\n\nprint(\"IMPOSSIBLE\")", "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    from collections import deque\n    input = sys.stdin.readline\n\n    N = int(input())\n    P = list(map(int, input().split()))\n    adj = [[] for _ in range(N+1)]\n    adj_directed = [[] for _ in range(N+1)]\n    adj_rev = [[] for _ in range(N+1)]\n    out = [0] * (N + 1)\n    for i, p in enumerate(P):\n        adj_directed[p].append(i+1)\n        adj[p].append(i+1)\n        adj[i+1].append(p)\n        adj_rev[i+1].append(p)\n        out[p] += 1\n\n    que = deque()\n    que.append(1)\n    seen = [-1] * (N+1)\n    seen[1] = 0\n    par = [-1] * (N+1)\n    back_from = -1\n    back_to = -1\n    while que:\n        v = que.popleft()\n        for u in adj[v]:\n            if seen[u] == -1:\n                seen[u] = seen[v] + 1\n                que.append(u)\n                par[u] = v\n            else:\n                if par[v] != u:\n                    if P[v-1] == u:\n                        back_from = u\n                        back_to = v\n                        out[u] -= 1\n\n    G = [-1] * (N+1)\n    for v in range(1, N+1):\n        if out[v] == 0:\n            que.append(v)\n    while que:\n        v = que.popleft()\n        M = set()\n        for u in adj_directed[v]:\n            if v == back_from and u == back_to:\n                continue\n            M.add(G[u])\n        for i in range(N+1):\n            if i not in M:\n                G[v] = i\n                break\n        for u in adj_rev[v]:\n            if v == back_to and u == back_from:\n                continue\n            out[u] -= 1\n            if out[u] == 0:\n                que.append(u)\n\n    if G[back_from] != G[back_to]:\n        print(\"POSSIBLE\")\n        return\n\n    cycle = set()\n    v = back_from\n    while v > 0:\n        cycle.add(v)\n        v = par[v]\n    v = back_to\n    while v > 0:\n        cycle.add(v)\n        v = par[v]\n\n    v = back_from\n    seen = {v}\n    while True:\n        M = set()\n        for u in adj_directed[v]:\n            M.add(G[u])\n        for i in range(N+1):\n            if i not in M:\n                if G[v] == i:\n                    print(\"POSSIBLE\")\n                    return\n                G[v] = i\n                break\n        fin = 1\n        for u in adj_rev[v]:\n            if u in cycle and u not in seen:\n                v = u\n                seen.add(u)\n                fin = 0\n                break\n        if fin:\n            break\n    print(\"IMPOSSIBLE\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\nn = int(input())\np = list(map(int, input().split()))\nc = [[] for _ in range(n)]\nis_leaf = [True for _ in range(n)]\nfor i in range(n):\n\tp[i] -= 1\n\tc[p[i]].append(i)\n\tis_leaf[p[i]] = False\n\nif sum(is_leaf) == 0:\n\tif n%2 == 0:\n\t\tprint(\"POSSIBLE\")\n\telse:\n\t\tprint(\"IMPOSSIBLE\")\n\treturn\n\nfor i in range(n):\n\tif is_leaf[i]:\n\t\tcur = i\n\t\tbreak\n\nvisited_set = {cur}\nvisited_list = [cur]\nwhile p[cur] not in visited_set:\n\tvisited_list.append(p[cur])\n\tvisited_set.add(p[cur])\n\tcur = p[cur]\n\nroot = p[cur]\n\ngrundy = [-1 for _ in range(n)]\ng_set = [set() for _ in range(n)]\n\ndef dfs(x):\n\tres = 0\n\tfor v in c[x]:\n\t\tdfs(v)\n\t\tg_set[x].add(grundy[v])\n\twhile res in g_set[x]:\n\t\tres += 1\n\tgrundy[x] = res\n\treturn res\n\nloop = [False for _ in range(n)]\nloop[root] = True\nind = len(visited_list)-1\nwhile visited_list[ind] != root:\n\tloop[visited_list[ind]] = True\n\tind -= 1\n#print(loop)\n\nfor i in range(n):\n\tif loop[i]:\n\t\tfor x in c[i]:\n\t\t\tif not loop[x]:\n\t\t\t\tdfs(x)\n\t\t\t\tg_set[i].add(grundy[x])\n\ncand = []\nnum = 0\nwhile num in g_set[root]:\n\tnum += 1\ncand.append(num)\nnum += 1\nwhile num in g_set[root]:\n\tnum += 1\ncand.append(num)\n\nfor x in cand:\n\tcur = root\n\tgrundy[root] = x\n\twhile True:\n\t\tnum = 0\n\t\twhile num in g_set[p[cur]] or num == grundy[cur]:\n\t\t\tnum += 1\n\t\tgrundy[p[cur]] = num\n\t\tif p[cur] == root:\n\t\t\tbreak\n\t\tcur = p[cur]\n\tif grundy[root] == x:\n\t\t#print(grundy)\n\t\tprint(\"POSSIBLE\")\n\t\treturn\n\nprint(\"IMPOSSIBLE\")", "import sys\nfrom itertools import chain\nreadline = sys.stdin.readline\n\n#\u975e\u518d\u5e30\ndef scc(Edge):\n    N = len(Edge)\n    Edgeinv = [[] for _ in range(N)]\n    for vn in range(N):\n        for vf in Edge[vn]:\n            Edgeinv[vf].append(vn)\n    \n    used = [False]*N\n    dim = [len(Edge[i]) for i in range(N)]\n    order = []\n    for st in range(N):\n        if not used[st]:\n            stack = [st, 0]\n            while stack:\n                vn, i = stack[-2], stack[-1]   \n                if not i and used[vn]:\n                    stack.pop()\n                    stack.pop()\n                else:\n                    used[vn] = True\n                    if i < dim[vn]:\n                        stack[-1] += 1\n                        stack.append(Edge[vn][i])\n                        stack.append(0)\n                    else:\n                        stack.pop()\n                        order.append(stack.pop())\n    res = [None]*N\n    used = [False]*N\n    cnt = -1\n    for st in order[::-1]:\n        if not used[st]:\n            cnt += 1\n            stack = [st]\n            res[st] = cnt\n            used[st] = True\n            while stack:\n                vn = stack.pop()\n                for vf in Edgeinv[vn]:\n                    if not used[vf]:\n                        used[vf] = True\n                        res[vf] = cnt\n                        stack.append(vf)\n    M = cnt+1\n    components = [[] for _ in range(M)]\n    for i in range(N):\n        components[res[i]].append(i)\n    tEdge = [[] for _ in range(M)]\n    teset = set()\n    for vn in range(N):\n        tn = res[vn]\n        for vf in Edge[vn]:\n            tf = res[vf]\n            if tn != tf and tn*M + tf not in teset:\n                teset.add(tn*M + tf)\n                tEdge[tn].append(tf)\n    return res, components, tEdge\n\nN = int(readline())\nP = list([int(x)-1 for x in readline().split()])\n\nEdge = [[] for _ in range(N)]\nfor i in range(N):\n    Edge[P[i]].append(i)\n\nR, Com, _ = scc(Edge)\n\nLord = list(chain(*Com[::-1]))\nval = [None]*N\nfor vn in Lord:\n    if not R[vn]:\n        break\n    lvn = len(Edge[vn]) + 1\n    res = [0]*lvn\n    for vf in Edge[vn]:\n        if val[vf] < lvn:\n            res[val[vf]] += 1\n    \n    for k in range(lvn):\n        if not res[k]:\n            val[vn] = k\n            break\n\nst = Lord[-1]\nlst = len(Edge[st]) + 2\nres = [0]*lst\nfor vf in Edge[st]:\n    if val[vf] is None:\n        continue\n    if val[vf] < lst:\n        res[val[vf]] += 1\nmc = []\nfor k in range(lst):\n    if not res[k]:\n        mc.append(k)\n\nvn = st\nLs = []\nwhile vn is not None:\n    for vf in Edge[vn]:\n        if R[vf]:\n            continue\n        if vf == st:\n            vn = None\n        else:\n            Ls.append(vf)\n            vn = vf\n\nLs.reverse()\n\nans = False\nfor idx in range(2):\n    vc = val[:]\n    vc[st] = mc[idx]\n    for vn in Ls:\n        lvn = len(Edge[vn])+1\n        res = [0]*lvn\n        for vf in Edge[vn]:\n            if vc[vf] < lvn:\n                res[vc[vf]] += 1\n        \n        for k in range(lvn):\n            if not res[k]:\n                vc[vn] = k\n                break\n    \n    for vn in range(N):\n        res = [False]*vc[vn]\n        for vf in Edge[vn]:\n            if vc[vn] == vc[vf]:\n                break\n            if vc[vf] < vc[vn]:\n                res[vc[vf]] = True\n        else:\n            if not all(res):\n                break\n            continue\n        break\n    else:\n        ans = True\n    if ans:\n        break\nprint(('POSSIBLE' if ans else 'IMPOSSIBLE'))\n", "# \u7d50\u5c40\u306f\u6728+1\u8fba\nfrom collections import defaultdict\nimport heapq as hq\n\nN = int(input())\nP = list(map(lambda x:int(x)-1,input().split()))\nD = [0]*N\nfor p in P:\n  D[p] += 1\n\nchild_L = defaultdict(list)\n\nS = [p for p in range(N) if D[p] == 0]\nL = [None]*N\n\nwhile S:\n  n = S.pop()\n\n  q = child_L[n]\n  del child_L[n]\n\n  hq.heapify(q)\n  i = 0\n  while q:\n    t = hq.heappop(q)\n    if i < t:\n      break\n    else:\n      i += (i==t)\n  \n  L[n] = i\n  m = P[n]\n  child_L[m].append(i)\n  D[m] -= 1\n  if D[m] == 0:\n    S.append(m)\n\n# cycle check\ntry:\n  start = D.index(1)\nexcept ValueError:\n  print('POSSIBLE')\n  return\n\ndef helper(n):\n  q = child_L[n]\n  del child_L[n]\n  \n  hq.heapify(q)\n  i = 0\n  while q:\n    t = hq.heappop(q)\n    if i < t:\n      break\n    else:\n      i += (i==t)\n\n  j = i+1\n  while q:\n    t = hq.heappop(q)\n    if j < t:\n      break\n    else:\n      j += (j==t)\n\n  return (i,j)\n\n\ns1,s2 = helper(start)\nG = []\nn = P[start]\nwhile n != start:\n  G.append(helper(n))\n  n = P[n]\n\n\ndel N,P,D,child_L,S,L\n\n\n# \u53ef\u80fd\u306a\u521d\u671f\u5024\u3092\u305d\u308c\u305e\u308c\u30b7\u30df\u30e5\u30ec\u30fc\u30c8\n# 1\nn = s1\nfor g in G:\n  if g[0] == n:\n    n = g[1]\n  else:\n    n = g[0]\nif n != s1:\n  print('POSSIBLE')\n  return\n\n# 2\nn = s2\nfor g in G:\n  if g[0] == n:\n    n = g[1]\n  else:\n    n = g[0]\nif n == s1:\n  print('POSSIBLE')\n  return\n\nprint('IMPOSSIBLE')", "import sys\nsys.setrecursionlimit(10**6)\nn = int(input())\np = list(map(int, input().split()))\nc = [[] for _ in range(n)]\nis_leaf = [True for _ in range(n)]\nfor i in range(n):\n\tp[i] -= 1\n\tc[p[i]].append(i)\n\tis_leaf[p[i]] = False\n\nif sum(is_leaf) == 0:\n\tif n%2 == 0:\n\t\tprint(\"POSSIBLE\")\n\telse:\n\t\tprint(\"IMPOSSIBLE\")\n\treturn\n\nfor i in range(n):\n\tif is_leaf[i]:\n\t\tcur = i\n\t\tbreak\n\nvisited_set = {cur}\nvisited_list = [cur]\nwhile p[cur] not in visited_set:\n\tvisited_list.append(p[cur])\n\tvisited_set.add(p[cur])\n\tcur = p[cur]\n\nroot = p[cur]\n\ngrundy = [-1 for _ in range(n)]\ng_set = [set() for _ in range(n)]\n\ndef dfs(x):\n\tres = 0\n\tfor v in c[x]:\n\t\tdfs(v)\n\t\tg_set[x].add(grundy[v])\n\twhile res in g_set[x]:\n\t\tres += 1\n\tgrundy[x] = res\n\treturn res\n\nloop = [False for _ in range(n)]\nloop[root] = True\nind = len(visited_list)-1\nwhile visited_list[ind] != root:\n\tloop[visited_list[ind]] = True\n\tind -= 1\n#print(loop)\n\nfor i in range(n):\n\tif loop[i]:\n\t\tfor x in c[i]:\n\t\t\tif not loop[x]:\n\t\t\t\tdfs(x)\n\t\t\t\tg_set[i].add(grundy[x])\n\ncand = []\nnum = 0\nwhile num in g_set[root]:\n\tnum += 1\ncand.append(num)\nnum += 1\nwhile num in g_set[root]:\n\tnum += 1\ncand.append(num)\n\nfor x in cand:\n\tcur = root\n\tgrundy[root] = x\n\twhile True:\n\t\tnum = 0\n\t\twhile num in g_set[p[cur]] or num == grundy[cur]:\n\t\t\tnum += 1\n\t\tgrundy[p[cur]] = num\n\t\tif p[cur] == root:\n\t\t\tbreak\n\t\tcur = p[cur]\n\tif grundy[root] == x:\n\t\t#print(grundy)\n\t\tprint(\"POSSIBLE\")\n\t\treturn\n\nprint(\"IMPOSSIBLE\")", "from collections import deque\n\nN=int(input())\nIN=[[] for i in range(N)]\nOUT=[-1 for i in range(N)]\np=list(map(int,input().split()))\nfor i in range(N):\n    IN[p[i]-1].append(i)\n    OUT[i]=p[i]-1\n\ndeg=[len(IN[i]) for i in range(N)]\n\ndeq=deque([v for v in range(N) if deg[v]==0])\nres=[]\nwhile deq:\n    v=deq.popleft()\n    res.append(v)\n    deg[OUT[v]]-=1\n    if deg[OUT[v]]==0:\n        deq.append(OUT[v])\n\nif len(res)==N:\n    print(\"POSSIBLE\")\n    return\n\nstart=-1\nfor i in range(N):\n    if deg[i]>0:\n        start=i\n        break\n\ncycle=[start]\nwhile True:\n    nv=OUT[cycle[-1]]\n    if nv!=start:\n        cycle.append(nv)\n    else:\n        break\n\n\ndp=[-1]*N\nfor v in res:\n    mex=[False]*(len(IN[v])+1)\n    for pv in IN[v]:\n        if dp[pv]<=len(IN[v]):\n            mex[dp[pv]]=True\n    for i in range(len(mex)):\n        if not mex[i]:\n            dp[v]=i\n            break\n\nm0=-1\nm1=-1\nmex=[False]*(len(IN[start])+2)\nfor pv in IN[start]:\n    if dp[pv]!=-1 and dp[pv]<=len(IN[v])+1:\n        mex[dp[pv]]=True\nfor i in range(len(mex)):\n    if not mex[i]:\n        if m0==-1:\n            m0=i\n        else:\n            m1=i\n            break\n\n#m0\ndp[start]=m0\nfor i in range(1,len(cycle)):\n    v=cycle[i]\n    temp=-1\n    mex=[False]*(len(IN[v])+1)\n    for pv in IN[v]:\n        if dp[pv]<=len(IN[v]):\n            mex[dp[pv]]=True\n    for i in range(len(mex)):\n        if not mex[i]:\n            dp[v]=i\n            break\nmex=[False]*(len(IN[start])+2)\nfor pv in IN[start]:\n    if dp[pv]!=-1 and dp[pv]<=len(IN[v])+1:\n        mex[dp[pv]]=True\ncheck=-1\nfor i in range(len(mex)):\n    if not mex[i]:\n        check=i\n        break\nif check==m0:\n    print(\"POSSIBLE\")\n    return\n\nfor v in cycle:\n    dp[v]=-1\n\n#m1\ndp[start]=m1\nfor i in range(1,len(cycle)):\n    v=cycle[i]\n    temp=-1\n    mex=[False]*(len(IN[v])+1)\n    for pv in IN[v]:\n        if dp[pv]<=len(IN[v]):\n            mex[dp[pv]]=True\n    for i in range(len(mex)):\n        if not mex[i]:\n            dp[v]=i\n            break\nmex=[False]*(len(IN[start])+2)\nfor pv in IN[start]:\n    if dp[pv]!=-1 and dp[pv]<=len(IN[start])+1:\n        mex[dp[pv]]=True\ncheck=-1\nfor i in range(len(mex)):\n    if not mex[i]:\n        check=i\n        break\nif check==m1:\n    print(\"POSSIBLE\")\n    return\n\nprint(\"IMPOSSIBLE\")\n"]
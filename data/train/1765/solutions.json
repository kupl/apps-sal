["def partitions(n):\n    c = [[1]]\n    for x in range(1, n + 1):\n        c.append([0])\n        for m in range(1, x + 1):\n            c[x].append(c[x][m - 1] + c[x - m][min(m, x - m)])\n    return c[n][n]", "def partitions(n, k=1, cache={}):\n    if k > n: return 0\n    if n == k: return 1\n    if (n,k) in cache: return cache[n,k]\n    return cache.setdefault((n,k), partitions(n, k+1) + partitions(n-k, k))", "ls = [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1255,1575,1958,2436,3010,3718,4565,5604,6842,8349,10143,12310,14883,17977,21637,26015,31185,37338,44583,53174,63261,75175,89134,105558,124754,147273,173525,204226,239943,281589,329931,386155,451276,526823,614154,715220,831820,966467,1121505,1300156,1505499,1741630,2012558,2323520,2679689,3087735,3554345,4087968,4697205,5392783,6185689,7089500,8118264,9289091,10619863,12132164,13848650,15796476,18004327,20506255,23338469,26543660,30167357,34262962,38887673,44108109,49995925,56634173,64112359,72533807,82010177,92669720,104651419,118114304,133230930,150198136,169229875,190569292]\ndef partitions(n):   \n    return ls[n]", "def partitions(n):\n    part = [0] * (n + 1)\n    part[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            part[j] += part[j - i]\n    return part[-1]", "'''\n            1                   n == 1 or m == 1\nf(n,m) =     f(n,n-1)+1          m >= n\n            f(n,m-1)+f(n-m,m)   m < n\n'''\ndef partitions(n):\n    d = {}\n    for x in range(1, n+1):\n        for y in range(1, n+1):\n            if x == 1 or y == 1:\n                d[(x,y)] = 1\n            elif x <= y:\n                d[(x,y)] = d[(x,x-1)] + 1\n            else:\n                d[(x,y)] = d[(x, y-1)] + d[(x-y,y)]\n    return d[(n,n)]", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef partitions(n, start=1):\n    if n == 0:\n        return 1\n    elif n < 0:\n        return 0\n    return sum(partitions(n-i, i) for i in range(start, n+1))", "dic={}\ndef partitions(n,x=None, maxx=None):\n    x,maxx = (n,n) if x==None else (x,maxx)\n    return sum([dic[(x-i,i)] if (x-i,i) in dic else(0 if dic.update({(x-i,i):partitions(n,x-i,i)}) else dic[(x-i,i)])for i in range(1,min([maxx,x])+1)[::-1]]) if x else 1", "from functools import lru_cache\n\n@lru_cache(maxsize=16384)\ndef partition_helper(sum, largest_number):\n    if largest_number == 0: return 0\n    if sum == 0: return 1\n    if sum < 0: return 0\n    return partition_helper(sum, largest_number - 1) + partition_helper(sum - largest_number, largest_number)\n\npartitions = lambda n: partition_helper(n, n)", "from functools import lru_cache\n\n\ndef partitions(n):\n    return sum(part(n, k) for k in range(1, n+1))\n\n\n@lru_cache(maxsize=None)\ndef part(n, k):\n    return 1 if k in {1, n} else sum(part(n-k, i) for i in range(1, min(n-k, k)+1))", "summ = list()\n\n\ndef partition(n, k):\n    if n >= 0 and k >= 0 and summ[n][k] > 0:\n        return summ[n][k]\n    if n < 0:\n        return 0\n    if n <= 1 or k == 1:\n        return 1\n    summ[n][k] = partition(n, k - 1) + partition(n - k, k)\n    return summ[n][k]\n\n\ndef partitions(n):\n    n += 1\n    for i in range(n):\n        summ.append(list())\n        for j in range(n):\n            summ[i].append(-1)\n    return partition(n - 1, n - 1)"]
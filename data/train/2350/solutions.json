["\n\"\"\"\n#this code is a precomputation part.\n#it takes about 2 hours.\nclass Graph:\n  def __init__(self,n):\n    self.edge=[[0 for j in xrange(n)] for i in xrange(n)]\n    self.n=n\n\n  def addedge(self,i,j,m=1):\n    assert i!=j and 0<=i<self.n and 0<=j<self.n\n    self.edge[i][j]+=m\n    self.edge[j][i]+=m\n\n  def deledge(self,i,j,m=1):\n    assert i!=j and 0<=i<self.n and 0<=j<self.n\n    self.edge[i][j]-=m\n    self.edge[j][i]-=m\n\n  def strongconnect(self):\n    ret = True\n    n=self.n\n    for i in xrange(n):\n      for j in xrange(i+1,n):\n        if self.edge[i][j]:\n          self.deledge(i,j)\n          ret=self.connect()\n          self.addedge(i,j)\n          if ret==False:return ret\n    return True\n\n  def connect(self):\n    n=self.n\n    edge=self.edge\n    z=[0 for _ in xrange(n)]\n    def f(i):\n      assert 0<=i<n\n      if z[i]==1:return\n      z[i]=1\n      for j in xrange(n):\n        if edge[i][j]:f(j)\n    f(0)\n    return sum(z)==n\n\n  def Nconnect(self):\n    n=self.n\n    edge=self.edge\n    z=[0 for _ in xrange(n)]\n    def f(i):\n      assert 0<=i<n\n      if z[i]==1:return\n      z[i]=1\n      for j in xrange(n):\n        if edge[i][j]:f(j)\n    ret=0\n    for ver in xrange(n):\n      if z[ver]==0:\n        ret+=1\n        f(ver)\n    return ret\n\ndef search(nv,ne):\n  graph=Graph(nv)\n  init=( graph, (0,0), ne)\n  def f(state):\n    ret=0\n    g,(i,j),e=state\n    if e==0:\n      if g.strongconnect():\n        return fact(ne)\n      else:return 0\n\n    if e<g.Nconnect():\n      return 0\n    for i2 in xrange(nv):\n      for j2 in xrange(i2+1,nv):\n        if (i2,j2)>(i,j):\n          for k in xrange(1,e+1):\n            g.addedge(i2,j2,k)\n            ret += f((g,(i2,j2),e-k)) / fact(k)\n            g.deledge(i2,j2,k)\n    return ret\n  return f(init)\n\ndef fact(n):\n  assert n>=0\n  ret=1\n  for i in xrange(n):ret*=i+1\n  return ret\n\ndef comb(a,b):\n  return fact(a+b)/fact(a)/fact(b)\n  pass\n\nnnn=17\nsve=dict( ( (v,e),search(v,e) )  for v in xrange(nnn+1) for e in xrange(nnn+1) if e>=v and e+v<=nnn)\nsve[(1,0)]=1\nprint sve\n\"\"\"\n\n\noutput=\"\"\"\n{(6, 9): 10559808000, (0, 7): 0, (1, 6): 0, (0, 10): 0, (3, 7): 2142, (2, 5): 1, (1, 11): 0, (5, 8): 48094200, (6, 7): 6350400, (5, 5): 1440, (6, 10): 247973140800, (0, 17): 0, (0, 4): 0, (1, 1): 0, (4, 10): 57808440, (2, 6): 1, (5, 11): 84587745000, (4, 5): 2160, (0, 1): 0, (3, 12): 531366, (1, 12): 0, (2, 11): 1, (7, 8): 482630400, (0, 14): 0, (3, 11): 177078, (1, 15): 0, (8, 9): 45113241600, (4, 12): 2148847272, (2, 12): 1, (1, 16): 0, (1, 5): 0, (0, 11): 0, (3, 6): 690, (2, 2): 1, (1, 10): 0, (6, 11): 4928158065600, (0, 5): 0, (1, 0): 1, (0, 8): 0, (4, 11): 354158640, (3, 5): 210, (2, 7): 1, (5, 10): 7639380000, (4, 6): 25560, (5, 7): 2835000, (0, 2): 0, (1, 3): 0, (4, 8): 1433544, (2, 8): 1, (0, 15): 0, (3, 10): 58986, (1, 14): 0, (4, 13): 12970756656, (2, 13): 1, (1, 4): 0, (0, 12): 0, (3, 9): 19626, (2, 3): 1, (1, 9): 0, (2, 14): 1, (6, 8): 336268800, (0, 6): 0, (1, 7): 0, (0, 9): 0, (3, 4): 54, (2, 4): 1, (5, 9): 644550480, (4, 7): 206640, (6, 6): 43200, (5, 6): 104400, (7, 7): 1814400, (0, 16): 0, (0, 3): 0, (3, 14): 4782882, (1, 2): 0, (4, 9): 9265200, (3, 3): 6, (2, 9): 1, (5, 12): 900380296200, (4, 4): 72, (7, 10): 2379856852800, (0, 0): 1, (3, 13): 1594242, (1, 13): 0, (2, 10): 1, (7, 9): 44808422400, (0, 13): 0, (3, 8): 6510, (1, 8): 0, (8, 8): 101606400, (2, 15): 1}\n\"\"\"\nsve=eval( \"\".join( output.split(\"\\n\") ) )\n\n\ndef fact(n):\n  assert n>=0\n  ret=1\n  for i in range(n):ret*=i+1\n  return ret\n\ndef comb(a,b):\n  return fact(a+b)/fact(a)/fact(b)\n  pass\n\n\"python 2.5 cannot use fractions.\"\n\"I used fractions for local computation.\"\n#import fractions\n#fr=fractions.Fraction(1)\nmemo_ff={}\ndef powpoly(x,t):\n  ret=[1]+[0]*( len(x)-1 )\n  n=len(x)\n  for _ in range(t):\n    ret2=[0 for _ in range(n)]\n    for i in range(n):\n      for j in range(n):\n        if i+j<n:\n          ret2[i+j]+=ret[i]*x[j]\n    ret=ret2\n  return ret\n\ndef ing(x):\n  n=len(x)\n  assert x[0]==0\n  ret=[0 for _ in range(n)]\n  for t in range(0,n):\n    ret2=powpoly(x,t)\n    for i in range(n):\n      ret[i]+=fr*ret2[i]/fact(t)\n  return ret\n\n\ndef ff(Y):\n  if Y in memo_ff:\n    return memo_ff[Y]\n  t=Y[0]\n  if t==0:\n    n=Y[1]\n    ret=0\n    for (v,e) in sve:\n      if v+e>n or v==0:continue\n      val=sve[(v,e)]\n      for l1 in range(n-v+1):\n        l2=n-v-l1\n        p1=ff((2,l1,e))\n        p2=ff((3,l2,v))\n        a = fr * val * fact(n-1) / fact(v-1) / fact(l1) / fact(l2) * p1 * p2 / fact(e)\n        ret += a\n  elif t==1:\n    n=Y[1]\n    ret=0\n    for (v,e) in sve:\n      val=sve[(v,e)]\n      e-=1\n      if e==-1 or v+e>n or v==0:continue\n      for l1 in range(n-v+1):\n        l2=n-v-l1\n        p1=ff((2,l1,e))\n        p2=ff((3,l2,v))\n        ret += fr * val * fact(n) / fact(v) / fact(l1) / fact(l2) * p1 * p2 / fact(e)\n  elif t==2:\n    n=Y[1]\n    e=Y[2]\n    F=[ fr*i*ff((0,i))/fact(i) for i in range(n+1) ]\n    Fa=powpoly(F,e)\n    ret=Fa[n]*fact(n)\n  elif t==3:\n    n=Y[1]\n    v=Y[2]\n    G=[v*fr*ff((1,i))/fact(i) for i in range(n+1)]\n    Ga=ing(G)\n    ret = Ga[n]*fact(n)\n  memo_ff[Y]=ret\n  return ret\n\nmemo={}\n\ndef g(Y):\n  if Y in memo:\n    return memo[Y]\n  k,c=Y\n  if c==0:\n    return ff((0,k))\n  if 2*c>=k:return 0\n  ret=0\n  for k1 in range(1,18):\n    for k2 in range(1,18):\n      k3=k-k1-k2\n      if k3<=0:break\n      for c1 in range(18):\n        if 2*c1>=k1:break\n        for c2 in range(18):\n          if 2*c2>=k2:break\n          c3=c-1-c1-c2\n          if 2*c3>=k3:continue\n          ret += g((k1,c1)) * g((k2,c2)) * g((k3,c3)) * fact(k1+k2+k3)/fact(k1)/fact(k2)/fact(k3)*k1*k2*k3\n  r=ret/(6*c)\n  memo[Y]=r\n  return r\n\n\ndef ans(n):\n  return sum(g((n,i)) for i in range(n))\n\n\ndef brute(n):\n  m=[(i1,i2,i3) for i1 in range(n) for i2 in range(i1+1,n) for i3 in range(i2+1,n)]\n  init=[]\n  memob={}\n  def f(vs):\n    ret=0\n    if vs:\n      g=Graph(n)\n      for v in vs:\n        i1,i2,i3=v\n        g.addedge(i1,i2)\n        g.addedge(i1,i3)\n      a=g.Nconnect()\n      for notv in vs:\n        g=Graph(n)\n        for v in vs:\n          if v==notv:continue\n          i1,i2,i3=v\n          g.addedge(i1,i2)\n          g.addedge(i1,i3)\n        if g.Nconnect()==a:\n          return 0\n      if a==1:return 1\n    ret = 0\n    for v in m:\n      if len(vs)==0 or v>vs[-1]:\n        ret += f(vs+[v])\n    return ret\n  return f(init)\n\ndef brute2(n):\n  m=[(i1,i2,i3) for i1 in range(n) for i2 in range(i1+1,n) for i3 in range(i2+1,n)]\n  init=[]\n  def f(vs):\n    ret=0\n    if vs:\n      g=Graph(n)\n      for v in vs:\n        i1,i2,i3=v\n        g.addedge(i1,i2)\n        g.addedge(i1,i3)\n      a=g.Nconnect()\n      for notv in vs:\n        g=Graph(n)\n        for v in vs:\n          if v==notv:continue\n          i1,i2,i3=v\n          g.addedge(i1,i2)\n          g.addedge(i1,i3)\n        if g.Nconnect()==a or ( a==1 and g.Nconnect()==3):\n          return 0\n      if a==1:\n        return 1\n    ret = 0\n    for v in m:\n      if len(vs)==0 or v>vs[-1]:\n        ret += f(vs+[v])\n    return ret\n  return f(init)\n\ndef main():\n  t=eval(input())\n  #z=[int(ans(i)) for i in xrange(18)] it takes about 10 seconds\n  z=[0, 1, 0, 1, 6, 25, 495, 5586, 93268, 2052513, 43258365, 1167393700, 34010847486,\n      1078391538159, 38595111963499, 1476893151785520, 61479081902937000, 2761923686066698561]\n  for _ in range(t):\n    print(z[eval(input())])\n#test()\nmain()\n"]
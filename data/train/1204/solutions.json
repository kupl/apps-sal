["for t in range(int(input())):\n s = input()\n r = input()\n diff = list()\n index = list()\n cnt = 0\n for i in range(len(s)):\n  if s[i] != r[i]:\n   cnt += 1\n   index.append(i)\n for i in range(1, len(index)):\n  diff.append(index[i] - index[i - 1] - 1)\n diff.sort()\n fmin = cnt ** 2\n oper = cnt ; moves = cnt\n for i in diff:\n  moves += i\n  oper -= 1\n  fmin = min(fmin, moves * oper)\n print(fmin)", "for t in range(int(input())):\n s = input()\n r = input()\n diff = list()\n index = list()\n cnt = 0\n for i in range(len(s)):\n  if s[i] != r[i]:\n   cnt += 1\n   index.append(i)\n for i in range(1, len(index)):\n  diff.append(index[i] - index[i - 1] - 1)\n diff.sort()\n fmin = cnt ** 2\n oper = cnt ; moves = cnt\n for i in diff:\n  moves += i\n  oper -= 1\n  fmin = min(fmin, moves * oper)\n print(fmin)", "import sys\nimport math\n# from collections import defaultdict, deque\n\ndef fout(s, end='\\n'): sys.stdout.write(str(s) + end)\ndef fin(): return sys.stdin.readline().strip()\n\nt = int(fin())\nwhile t>0:\n t -= 1\n s = fin()\n r = fin()\n un = isl = 0 #unequal\n count = 0\n eqisl = []\n count2 = 0\n for i in range(len(r)):\n  if s[i] == r[i]:\n   if un == 0:\n    continue\n   count2 += 1\n   if count > 0:\n    isl += 1\n    count = 0\n  else:\n   if count2 > 0:\n    eqisl.append(count2)\n    count2 = 0\n   un += 1\n   count += 1\n if count > 0:\n  isl += 1\n eqisl.sort()\n ans = un*isl\n for i in range(len(eqisl)):\n  un += eqisl[i]\n  isl -= 1\n  ans = min(ans, un*(isl))\n print(ans)", "for _ in range(int(input())):\n S = input()\n R = input()\n N = len(S)\n groups = []\n cont = False\n for i in range(N):\n  if S[i] != R[i]:\n   if cont:\n    groups[-1][1] += 1\n   else:\n    groups.append([i, i])\n    cont = True\n  else:\n   cont = False\n # print(groups)\n k = len(groups)\n l = 0\n diff = []\n for i in range(1,k):\n  diff.append(groups[i][0] - groups[i - 1][1] - 1)\n  l += (groups[i][1] - groups[i][0] + 1)\n if len(groups) > 0:\n  l += (groups[0][1] - groups[0][0] + 1)\n diff.sort()\n mx = k * l\n for i in range(len(groups) - 1):\n  k -= 1\n  l += (diff[i])\n  mx = min(mx, k * l)\n print(mx)", "# P.S.: I understood the solution using the code of https://www.codechef.com\u00a0\u00a0\u00a0\u00a0/viewsolution/33283413 \n# the user's name is kush_07(thanks to him), but it took me some time to figure \u00a0\u00a0\u00a0\u00a0it out so i\n# have written some comments which might help you if you by any chance arrive at \u00a0\u00a0\u00a0\u00a0the solution.\nfor _ in range(int(input())):\n s=list(input())\n r=list(input())\n l=[]\n flag=0\n eq=0\n k=0\n s_1=0\n for i in range(len(s)):\n  if s[i]!=r[i]:\n   # When the group/array is not the first array to have different \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0characters \n   # this is identified using the flag variable\n   # as we don't need the elements which were before the first \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0different\n   # subarray but only need the elements between the different \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subarrays after\n   # the first subarray having different characters (subarrays here \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0refer to 'islands' \n   # mentioned in the tutorial)\n   if eq>0 and flag==1:\n    l.append(eq)\n    k+=1\n   # we are not appending the equal elements before this as this is the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0first subarray with\n   # different characters (flag==0) but we still need to count it as \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0one operation so k+=1\n   elif flag==0:\n    k+=1\n   eq=0\n   flag=1\n   # Number of characters that would require replacing\n   s_1+=1\n  else:\n   # Counting the same characters \n   eq+=1\n l.sort()\n res=0\n res=k*s_1\n for i in range(len(l)):\n  s_1=s_1+l[i]\n  k=k-1\n  res=min(res,s_1*k)\n print(res)\n   \n   \n", "try:\n t=int(input())\n for v in range(t):\n  s=input()\n  r=input()\n  i=0 \n  prev=-1\n  top=0\n  l=0\n  k=0\n  gap=[]\n  while(i<len(s)):\n   if(s[i]!=r[i]):\n    if(prev!=-1):\n     gap.append(i-prev-1)\n     top+=1 \n    k+=1\n    while(i<len(s) and s[i]!=r[i]):\n     l+=1 \n     prev=i \n     i+=1 \n   i+=1 \n  gap.sort() \n  ans=k*l \n  for i in range(top):\n   l=l+gap[i]\n   k=k-1 \n   if(ans>k*l):\n    ans = k*l\n  print(ans)\nexcept:\n pass", "t=int(input())\nfor _ in range(t):\n s=input()\n r=input()\n ans=1000000000000000\n c=0\n l=0\n k=0\n for i in range(len(s)):\n  if s[i]!=r[i]:\n   c+=1\n   l+=1\n   if c==1:\n    k+=1\n  else:\n   c=0\n a=0\n b=0\n ans=k*l\n for i in range(len(s)-1,-1,-1):\n  if s[i]!=r[i]:\n   b=i\n   break\n for i in range(len(s)):\n  if s[i]!=r[i]:\n   a=i\n   break\n gap=[];c=0\n for i in range(a,b+1):\n  if s[i]==r[i]:\n   c+=1\n  else:\n   if c!=0:\n    gap.append(c)\n    c=0\n #print(gap,k,l)\n gap.sort()\n for i in gap:\n  k-=1\n  l+=i\n  ans=min(ans,k*l)\n print(ans)\n", "# cook your dish here\ntest=int(input())\nfor _ in range(test):\n e_islands = []\n u_islands = []\n s = input()\n r = input()\n gap = 0\n size = 0\n mismatches = 0\n for i in range(len(s)):\n  if s[i] == r[i]:\n   gap += 1\n   if size != 0:\n    u_islands.append(size)\n    size = 0\n  else:\n   size += 1\n   if gap != 0:\n    e_islands.append(gap)\n    gap = 0\n   mismatches += 1\n if size != 0:\n  u_islands.append(size)\n if s[0] == r[0]:\n  e_islands = e_islands[1:]\n e_islands = sorted(e_islands)\n # print(mismatches)\n # print(e_islands)\n # print(u_islands)\n min_len = mismatches\n k = len(u_islands)\n ans = min_len * k\n for val in e_islands:\n  min_len += val\n  k -= 1\n  ans = min(ans, min_len * k)\n print(ans)\n", "for t in range(int(input())):\n e_islands = []\n u_islands = []\n s = input()\n r = input()\n gap = 0\n size = 0\n mismatches = 0\n for i in range(len(s)):\n  if s[i] == r[i]:\n   gap += 1\n   if size != 0:\n    u_islands.append(size)\n    size = 0\n  else:\n   size += 1\n   if gap != 0:\n    e_islands.append(gap)\n    gap = 0\n   mismatches += 1\n if size != 0:\n  u_islands.append(size)\n if s[0] == r[0]:\n  e_islands = e_islands[1:]\n e_islands = sorted(e_islands)\n # print(mismatches)\n # print(e_islands)\n # print(u_islands)\n min_len = mismatches\n k = len(u_islands)\n ans = min_len * k\n for val in e_islands:\n  min_len += val\n  k -= 1\n  ans = min(ans, min_len * k)\n print(ans)\n", "try:\n from collections import Counter\n from sys import stdin, stdout\n def get_ints(): return map(int, stdin.readline().strip().split())\n def get_list(): return list(map(int, stdin.readline().strip().split()))\n def get_string(): return stdin.readline().strip()\n def get_singleInt(): return int(stdin.readline())\n def main():\n  testCases=get_singleInt()\n  for i in range(testCases):\n   stringA=get_string()\n   stringB=get_string()\n   minOperationsRequired(stringA,stringB)\n\n def minOperationsRequired(stringA,stringB):\n  #minL is positions where stringA[i]!=stringB[i]\n  minL=0\n  maxK=0\n  #gapsList that contains ranges where elements are equal\n  gapsList=[]\n  length=len(stringA)\n  #finding minL\n  for i in range(length):\n   if stringA[i]!=stringB[i]:\n    minL=minL+1\n  #A=abbbbaabb\n  #B=aaaaaaaaa\n  #finding maxK\n  flag=0\n  for i in range(length):\n   if stringA[i]!=stringB[i]:\n    if flag==0:\n     maxK=maxK+1\n    flag=1\n   else:\n    flag=0\n  #finding gapsList\n  fl=1\n  glE=0\n  for i in range(length):\n   if stringA[i]==stringB[i]:\n    if fl==0:\n     glE=glE+1\n   else:\n    if glE>0:\n     gapsList.append(glE)\n    fl=0\n    glE=0\n  gapsList=sorted(gapsList)\n  #Calculating minCost\n  minCost=minL*maxK\n  for i in range(len(gapsList)):\n   minL=minL+gapsList[i]\n   maxK=maxK-1\n   minCost=min(minCost,minL*maxK)\n  stdout.write(str(minCost)+\"\\n\")\n\n def __starting_point():\n  main()\n\nexcept Exception:\n pass\n__starting_point()", "for t in range(int(input())):\n e_islands = []\n u_islands = []\n s = input()\n r = input()\n gap = 0\n size = 0\n mismatches = 0\n for i in range(len(s)):\n  if s[i] == r[i]:\n   gap += 1\n   if size != 0:\n    u_islands.append(size)\n    size = 0\n  else:\n   size += 1\n   if gap != 0:\n    e_islands.append(gap)\n    gap = 0\n   mismatches += 1\n if size != 0:\n  u_islands.append(size)\n if s[0] == r[0]:\n  e_islands = e_islands[1:]\n e_islands = sorted(e_islands)\n # print(mismatches)\n # print(e_islands)\n # print(u_islands)\n min_len = mismatches\n k = len(u_islands)\n ans = min_len * k\n for val in e_islands:\n  min_len += val\n  k -= 1\n  ans = min(ans, min_len * k)\n print(ans)\n", "# cook your dish here\nt = int(input())\nwhile (t!=0):\n s = input()\n r = input()\n n = len(s)\n k = 0\n c = 0\n crlen = 0\n ans = 0\n j = 0\n a = []\n for i in range(0,n,1):\n  if ( s[i] != r[i] ):\n   if(crlen > 0 and j == 1):\n    a.append(crlen)\n    k = k + 1 \n   elif (j == 0):\n    k = k + 1\n   crlen = 0\n   j = 1\n   c = c + 1\n   \n  else :\n   crlen = crlen + 1\n a.sort()\n ans = c * k\n for i in a:\n  c = c + i\n  k = k - 1\n  ans = min(ans,c*k)\n print(ans) \n t=t-1;\n", "import heapq\ndef minops(s,r):\n letter=0\n heap=[]\n k=0\n for i in range(len(s)):\n  if(s[i]!=r[i]):\n   letter+=1\n   if(i+1==len(s) or s[i+1]==r[i+1]):\n    k+=1\n    g=0\n  elif(k!=0):\n   g+=1\n   if(i+1!=len(s) and s[i+1]!=r[i+1]):\n    heapq.heappush(heap,g)\n mini=k*letter\n while(k>0 and len(heap)>0):\n  k-=1\n  gap=heapq.heappop(heap)\n  letter+=gap\n  if(k*letter<mini):\n   mini=k*letter\n return mini\nt=int(input())\nfor _ in range(t):\n s=input()\n r=input()\n print(minops(s,r))\n", "# cook your dish here\nfor i in range(int(input())):\n s = input()\n r = input()\n k, l, f = 0, 0, 0\n ff = []\n farhan = False\n for i in range(len(s)):\n  if s[i] == r[i]:\n   if farhan:\n    f += 1\n  else:\n   if not farhan:\n    k += 1\n   farhan = True\n   l += 1\n   if f > 0:\n    k += 1\n    ff.append(f)\n    f = 0\n ff.sort()\n sol = k*l\n for i in range(len(ff)):\n  l += ff[i]\n  k -= 1\n  sol = min(sol, k*l)\n print(sol)", "for i in range(int(input())):\n s = input()\n r = input()\n k, l, f = 0, 0, 0\n ff = []\n farhan = False\n for i in range(len(s)):\n  if s[i] == r[i]:\n   if farhan:\n    f += 1\n  else:\n   if not farhan:\n    k += 1\n   farhan = True\n   l += 1\n   if f > 0:\n    k += 1\n    ff.append(f)\n    f = 0\n ff.sort()\n sol = k*l\n for i in range(len(ff)):\n  l += ff[i]\n  k -= 1\n  sol = min(sol, k*l)\n print(sol)", "# cook your dish here\nfor i in range(int(input())):\n s=input()\n s1=input()\n k,l,g=0,0,0\n gp=[]\n f=False\n for i in range(len(s)):\n  if s[i]==s1[i]:\n   if f:\n    g+=1\n  else:\n   if not f:\n    k+=1\n   f=True\n   l+=1\n   if g>0:\n    k+=1\n    gp.append(g)\n    g=0\n gp.sort()\n res=k*l\n for i in range(len(gp)):\n  l+=gp[i]\n  k-=1\n  res=min(res,k*l)\n print(res)", "for _ in range(int(input())):\n s = input()\n ss = input()\n ind = [i for i in range(len(s)) if s[i] != ss[i]]\n a = [ind[i + 1] - ind[i] - 1 for i in range(len(ind) - 1)]\n a.sort()\n ig, ire = len(ind), len(ind)\n b = [ig * ire]\n for i in a:\n  ig -= 1\n  ire += i\n  b.append(ig * ire)\n print(min(b))\n", "T = int(input())\nfor j in range(T):\n s = input()\n r = input()\n t = []\n c = None\n n, k = 0, 0\n for i in range(len(s)):\n  if r[i] != s[i]:\n   n += 1\n   if c:\n    t.append(c)\n    k += 1\n   c = 0\n  else:\n   if c != None:\n    c += 1\n k += 1\n t.sort()\n m = k * n\n for i,j in enumerate(t):\n  k -= 1\n  n += j\n  m = min(m, k * n)\n print(m)", "a=int(input())\nfor w in range(a):\n b=input()\n c=input()\n d=len(b)\n e=[]\n r=0\n t=0\n p=0\n i=0\n z=0\n y=1 \n for k in range(d):\n  if(b[k]!=c[k]):\n   r=r+1\n   t=1\n   if(i!=y):\n    z=z+1\n    y=0\n   if(p>0):\n    e.append(p)\n    p=0 \n  elif(t==1 and b[k]==c[k]):\n   p=p+1\n   y=1 \n e.sort()\n n=r*z\n j=len(e)\n for it in range(j):\n  r=r+e[it]\n  z=z-1\n  if((r*z)<n):\n   n=z*r\n print(n) ", "a=int(input())\nfor w in range(a):\n b=input()\n c=input()\n d=len(b)\n e=[]\n r=0\n t=0\n p=0\n i=0\n z=0\n y=1\n for k in range(d):\n  if(b[k]!=c[k]):\n   r=r+1\n   t=1\n   if(i!=y):\n    z=z+1\n    y=0\n   if(p>0):\n    e.append(p)\n    p=0 \n  elif(t==1 and b[k]==c[k]):\n   p=p+1\n   y=1 \n e.sort()\n n=r*z\n j=len(e)\n for it in range(j):\n  r=r+e[it]\n  z=z-1\n  if((r*z)<n):\n   n=z*r\n\n print(n)", "# cook your dish here\nimport sys\ninput = sys.stdin.readlines\nprint = sys.stdout.write\nt = input()\nfor case in range(1,int(t[0])*2,2):\n s = t[case]\n r = t[case+1]\n unlike = []\n curr=None\n l = 0\n k = 0\n for i in range(len(s)-1):\n  if r[i]!=s[i]:\n   l += 1\n   if curr:\n    unlike.append(curr)\n    k+=1\n   curr = 0\n  else:\n   if curr!=None:\n    curr += 1\n k += 1\n unlike.sort()\n mini = k*l\n for i,j in enumerate(unlike):\n  k-=1\n  l+=j\n  mini = min(mini,k*l)\n print(str(mini)+'\\n')", "for _ in range(int(input())):\n s = input()\n r = input()\n unlike = []\n curr=None\n l = 0\n k = 0\n for i in range(len(s)):\n  if r[i]!=s[i]:\n   l += 1\n   if curr:\n    unlike.append(curr)\n    k+=1\n   curr = 0\n  else:\n   if curr!=None:\n    curr += 1\n k += 1\n unlike.sort()\n mini = k*l\n for i,j in enumerate(unlike):\n  k-=1\n  l+=j\n  mini = min(mini,k*l)\n print(mini)", "for i in range(int(input())):\n s=input()\n r=input()\n n=len(r)\n gap=[]\n t=0\n l=0\n for i in range(0,n):\n  if s[i]==r[i]:\n   t+=1\n  else:\n   gap.append(t)\n   l+=1 \n   t=0\n\n gap.append(t) \n gp=len(gap)-1\n gap=gap[1:-1]\n gap.sort()\n x=l*gp\n for i in range(len(gap)):\n  gp-=1\n  l+=gap[i]\n  y=gp*l\n  if y<x:\n   x=y\n print(min(x,n)) \n \n"]
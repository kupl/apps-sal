["# cook your dish here\nimport sys,collections\ninput=sys.stdin.readline\ndef main():\n T=int(input())\n for _ in range(T):\n  N,K=map(int,input().split())\n  Tree={}\n  for j in range(N):\n   Tree[j]=[]\n   \n  for i in range(N-1):\n   u,v=map(int,input().split())\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A=list(map(int,input().split()))\n \n  vis=[0 for i in range(N)] #to mark visited vertices 0 for visited and \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 for not visited\n  maxval=[[0,0] for i in range(N)] #Nx2 list where each i stores max \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value till now and its count \n  minval=[0 for i in range(N)] #Nx2 list where each i stores min value \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0till now \n  lfnode=[] #list to store leaf nodes\n  \n  #Appending node 1\n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 #not a leaf node\n     v=A[i]\n     Q.append(i)\n \n     #Comparing maximum value of parent node\n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     #Comparing minimum value of parent node\n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 #For answer if 0 then NO else YES\n \n  K1=len(bin(K))-2 #length of K\n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print(\"YES\")\n  else:\n   print(\"NO\")\nmain()", "# cook your dish here\nimport sys,collections\ninput=sys.stdin.readline\ndef main():\n T=int(input())\n for _ in range(T):\n  N,K=map(int,input().split())\n  Tree={}\n  for j in range(N):\n   Tree[j]=[]\n   \n  for i in range(N-1):\n   u,v=map(int,input().split())\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A=list(map(int,input().split()))\n \n  vis=[0 for i in range(N)] #to mark visited vertices 0 for visited and \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 for not visited\n  maxval=[[0,0] for i in range(N)] #Nx2 list where each i stores max \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value till now and its count \n  minval=[0 for i in range(N)] #Nx2 list where each i stores min value \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0till now \n  lfnode=[] #list to store leaf nodes\n  \n  #Appending node 1\n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 #not a leaf node\n     v=A[i]\n     Q.append(i)\n \n     #Comparing maximum value of parent node\n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     #Comparing minimum value of parent node\n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 #For answer if 0 then NO else YES\n \n  K1=len(bin(K))-2 #length of K\n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print(\"YES\")\n  else:\n   print(\"NO\")\nmain()", "import sys,collections\ninput=sys.stdin.readline\ndef main():\n T=int(input())\n for _ in range(T):\n  N,K=map(int,input().split())\n  Tree={}\n  for j in range(N):\n   Tree[j]=[]\n   \n  for i in range(N-1):\n   u,v=map(int,input().split())\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A=list(map(int,input().split()))\n \n  vis=[0 for i in range(N)] #to mark visited vertices 0 for visited and \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 for not visited\n  maxval=[[0,0] for i in range(N)] #Nx2 list where each i stores max \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value till now and its count \n  minval=[0 for i in range(N)] #Nx2 list where each i stores min value \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0till now \n  lfnode=[] #list to store leaf nodes\n  \n  #Appending node 1\n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 #not a leaf node\n     v=A[i]\n     Q.append(i)\n \n     #Comparing maximum value of parent node\n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     #Comparing minimum value of parent node\n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 #For answer if 0 then NO else YES\n \n  K1=len(bin(K))-2 #length of K\n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print(\"YES\")\n  else:\n   print(\"NO\")\nmain()", "import sys,collections\ninput = sys.stdin.readline \n\ndef solve():\n T = int(input())\n for _ in range(T):\n  N,K = list(map(int,input().split()))\n  \n  Tree = {}\n  for j in range(N):\n   Tree[j] = []\n   \n  for i in range(N-1):\n   u,v = list(map(int, input().split()))\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A = list(map(int, input().split()))\n  \n  vis = [0 for i in range(N)]\n  maxval = [[0,0] for i in range(N)]\n  minval = [0 for i in range(N)]\n  lfnode = []\n  \n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 \n     v=A[i]\n     Q.append(i)\n \n     \n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     \n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 \n \n  K1=len(bin(K))-2 \n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print(\"YES\")\n  else:\n   print(\"NO\")\n  \n \nsolve() \n", "import sys,collections\ninput = sys.stdin.readline \n\ndef solve():\n T = int(input())\n for _ in range(T):\n  N,K = list(map(int,input().split()))\n  \n  Tree = {}\n  for j in range(N):\n   Tree[j] = []\n   \n  for i in range(N-1):\n   u,v = list(map(int, input().split()))\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A = list(map(int, input().split()))\n  \n  vis = [0 for i in range(N)]\n  maxval = [[0,0] for i in range(N)]\n  minval = [0 for i in range(N)]\n  lfnode = []\n  \n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 \n     v=A[i]\n     Q.append(i)\n \n     \n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     \n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 \n \n  K1=len(bin(K))-2 \n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print(\"YES\")\n  else:\n   print(\"NO\")\n  \n \nsolve() \n", "import sys,collections\ninput=sys.stdin.readline\ndef main1():\n T=int(input())\n for _ in range(T):\n  N,K=map(int,input().split())\n  Tree={} \n  for j in range(N):\n   Tree[j]=[]\n   \n  for i in range(N-1):\n   u,v=map(int,input().split())\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A=list(map(int,input().split()))\n \n  vis=[0 for i in range(N)] \n  maxval=[[0,0] for i in range(N)] \n  minval=[0 for i in range(N)] \n  lfnode=[] \n  \n  #Appending node 1\n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 \n     v=A[i]\n     Q.append(i)\n \n     \n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     \n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 \n \n  K1=len(bin(K))-2 \n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print(\"YES\")\n  else:\n   print(\"NO\")\n  \n \nmain1() "]
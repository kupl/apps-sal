["import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.numbers = [1]\n        self.lastZero = 0\n\n    def add(self, num: int) -> None:\n        if num != 0:\n            self.numbers.append(self.numbers[-1] * num)\n        else:\n            self.numbers = [1]\n            \n\n    def getProduct(self, k: int) -> int:\n        if k < len(self.numbers):\n            return self.numbers[-1] // self.numbers[-k - 1]\n        else:\n            return 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.preprod = [1]\n\n    def add(self, num: int) -> None:\n        if not num:\n            self.preprod = [1]\n        else:\n            self.preprod.append(self.preprod[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.preprod):\n            return 0\n        return self.preprod[-1] // self.preprod[-k-1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n\n# 20\n\n#[2, 10, 40]\n\n# \n\n# \n# 3 0  2 , 5 ,4\n\n# 3, 0, 2 ,5 ,4, 0\n\n\n\n# []\n\n\n\n# [1]\n# return 0\n# 0  0  40  20  4 0 1\n", "class ProductOfNumbers:\n    \n    prod_list = []\n    \n    def __init__(self):\n        pass\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.prod_list = []\n        else:\n            if len(self.prod_list) == 0:\n                self.prod_list.append(num)\n            else:\n                new_prod = self.prod_list[-1]*num\n                self.prod_list.append(new_prod)\n\n    def getProduct(self, k: int) -> int:\n        if len(self.prod_list) == 0:\n            return 0\n        \n        if k > len(self.prod_list):\n            return 0\n        elif k == len(self.prod_list):\n            return self.prod_list[-1]\n        else:\n            if self.prod_list[-k] == 0:\n                return 0\n            else:\n                return self.prod_list[-1]//self.prod_list[-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import numpy as np\n\n\nclass ProductOfNumbers:\n    def __init__(self):\n        self.current_list_of_numbers: list = []\n        self.prefix = []\n\n    def add(self, num: int) -> None:\n        if len(self.current_list_of_numbers) == 0:\n            self.prefix = [num]\n            self.current_list_of_numbers.append(num)\n        else:\n\n            self.prefix = np.array(self.prefix) * num\n            self.prefix = np.append(self.prefix, [int(num)], 0)\n            self.current_list_of_numbers.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return self.prefix[len(self.prefix) - k]", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.zeros =[]\n        self.product = 1\n        self.allProducts = {} #index -> product at that index\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.zeros.append(len(self.nums))\n        else:\n            self.product *= num\n    \n        self.nums.append(num)\n        self.allProducts[len(self.nums) - 1] = self.product\n\n    def getProduct(self, k: int) -> int:\n        for i in self.zeros:\n            if len(self.nums) - k <= i <= len(self.nums) - 1:\n                return 0\n        if k == len(self.nums):\n            return self.product\n        return int(self.product / self.allProducts[len(self.nums) - 1 - k])\n    \n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import numpy as np\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.prods = np.array([])\n        \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        self.prods = (self.prods * num).astype(int)\n        self.prods = np.append(self.prods, num)\n\n    def getProduct(self, k: int) -> int:\n        return self.prods[-k]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prefixproducts = [1]\n\n    def add(self, num: int) -> None:\n        if num==0:\n            for i in range(len(self.prefixproducts)):\n                self.prefixproducts[i] = 0\n            self.prefixproducts.append(0)\n        else:\n            if self.prefixproducts[-1]!=0:\n                self.prefixproducts.append(self.prefixproducts[-1]*num)\n            else:\n                self.prefixproducts.append(num)\n\n    def getProduct(self, k: int) -> int:\n        if self.prefixproducts[-(k+1)] == 0:\n            if self.prefixproducts[-k] == 0:\n                return 0\n            else:\n                return self.prefixproducts[-1]\n        else:\n            return self.prefixproducts[-1]//self.prefixproducts[-(k+1)]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = [1]\n        self.run = 1\n        \n\n    def add(self, num: int) -> None:\n        if num != 0:\n            self.run *= num\n        else:\n            n = len(self.arr)\n            for i in range(n):\n                self.arr[i] = 0\n        self.arr.append(self.run)\n        \n\n    def getProduct(self, k: int) -> int:\n        # print('for k ', k)\n        # print('arr is ', self.arr)\n        pre = 1\n        n = len(self.arr)\n        before = n - k - 1\n        if before >= 0:\n            pre = self.arr[before]\n        \n        if pre == 0:\n            return 0\n        return int(self.arr[-1] / pre)\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.a = []\n\n    def add(self, num: int) -> None:\n        x = [0]*101\n        x[num] += 1\n        if len(self.a) > 0:\n            for i in range(101):\n                x[i] += self.a[-1][i] \n        \n        self.a.append(x)\n\n    def getProduct(self, k: int) -> int:\n        res = 1\n        \n        for i in range(101):\n            cnt = self.a[-1][i] \n            if len(self.a) > k:\n                cnt -= self.a[-(k+1)][i] \n            res *= pow(i,cnt)\n        return res\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import bisect \nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.time = 0\n        self.d = collections.defaultdict(list)\n\n    def add(self, num: int) -> None:\n        self.time += 1\n        self.d[num].append((self.time, len(self.d[num])))\n\n    def getProduct(self, k: int) -> int:\n        res = 1\n        for num in range(101):\n            i = bisect.bisect_right(self.d[num], (self.time-k+1,-1), )\n            res *= num**(len(self.d[num]) - i)\n        return res\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from functools import lru_cache, reduce\nfrom operator import mul\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = []\n        self.size = 0\n\n    def add(self, num: int) -> None:\n        self.arr.append(num)\n        self.size += 1\n        self.getProduct.cache_clear()\n    \n    @lru_cache\n    def getProduct(self, k: int) -> int:\n        return reduce(mul,self.arr[self.size-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.array = [0] \n        self.prods = [0]\n        self.state = True # border \n        self.recent_zero = 0\n\n    def add(self, num: int) -> None: \n        self.array.append(num)\n        \n        if self.state == True:\n            self.prods.append(num)\n            if num != 0:\n                self.state = False\n            else:\n                self.recent_zero = len(self.array)-1 \n            \n        else:\n            if num == 0:\n                self.state = True\n                self.prods.append(num)\n                self.recent_zero = len(self.array)-1\n            else:\n                self.prods.append(num*self.prods[-1])\n\n    def getProduct(self, k: int) -> int:\n        n = len(self.prods)\n        if n-(k+1) < self.recent_zero:\n            return 0\n        else:\n            if self.prods[n-(k+1)] ==0:\n                return self.prods[-1]\n            return self.prods[-1]//self.prods[n-(k+1)]\n\n    \n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = [1]\n\n    def add(self, num: int) -> None:\n        self.arr = [1] if num == 0 else self.arr + [num * self.arr[-1]]\n\n    def getProduct(self, k: int) -> int:\n        return 0 if len(self.arr) <= k else int(self.arr[-1] / self.arr[-k - 1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.n = 0\n        self.d = {}\n\n    def add(self, num: int) -> None:\n        n = self.n\n        self.d[(n, n)] = num\n        self.n+=1\n\n    def getProduct(self, k: int) -> int:\n        return self.h(self.n-k, self.n-1)\n        \n    def h(self, i, j):\n        d = self.d\n        h = self.h\n        if (i,j) in d:\n            return d[(i,j)]\n        m = (i+j)//2\n        x = h(i,m)*h(m+1,j)\n        d[(i,j)] = x\n        return x\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.data = []\n        self.product_cache = {}\n\n    def add(self, num: int) -> None:\n        self.data.append(num)\n\n    def getProduct(self, k: int) -> int:\n        product = self.product_cache.get((len(self.data) - k, len(self.data) - 1))\n        if product is not None:\n            return product\n        product = 1\n        for i in self.data[-k:]:\n            product = product * i\n        self.product_cache[(len(self.data) - k, len(self.data) - 1)] = product\n        return product\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.cache = {}\n        \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        self.cache = {}\n        \n\n    def getProduct(self, k: int) -> int:\n        if k in self.cache:\n            return self.cache[k]\n        n = self.nums[-k:]\n        ret = 1\n        for e in n:\n            ret *= e\n        self.cache[k] = ret\n        return ret\n        \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.l = []\n        self.cache = {}\n\n    def add(self, num: int) -> None:\n        self.l.append(num)\n        self.cache = {}\n\n    def getProduct(self, k: int) -> int:\n        if k in self.cache:\n            return self.cache[k]\n        \n        elif k - 1 in self.cache:\n            return self.cache[k - 1] * self.l[-k]\n        \n        else:\n\n            prod = 1\n            for num in self.l[-k:]:\n                prod *= num\n            \n            self.cache[k] = prod\n            \n        return prod\n        \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.listOfProds = []\n        self.results = {}\n        \n    def add(self, num: int) -> None:\n        self.listOfProds.append(num)\n        self.results = {}\n        return None\n\n    def getProduct(self, k: int) -> int:\n        if k in self.results:\n            return self.results[k]\n        outProd = 1\n        for i in self.listOfProds[-1*k:]:\n            outProd = outProd * i\n        self.results[k] = outProd\n        return outProd\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.data = []\n        self.product = []\n\n    def add(self, num: int) -> None:\n        self.data.append(num)\n        if len(self.data) % 10 == 0:\n            self.product.append(self.getLastTenProduct())\n    \n    def getLastTenProduct(self) -> int:\n        res = 1\n        for i in range(len(self.data) - 1, len(self.data) - 11, -1):\n            res *= self.data[i]\n        return res\n\n    def getProduct(self, k: int) -> int:\n        remain = k % 10\n        tenth = k // 10\n        res = 1\n        for i in range(len(self.product) - 1, len(self.product) - tenth - 1, -1):\n            res *= self.product[i]\n\n        for i in range(\n            len(self.data) - tenth * 10 - 1,\n            len(self.data) - tenth * 10 - remain - 1,\n            -1\n        ):\n            res *= self.data[i]\n        return res\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.product = [1]\n        self.list = []\n        self.zero = False\n    def add(self, num: int):\n        self.list.append(num)\n        if not num:\n            self.zero = True\n            self.product.append(0)\n        else:\n            if self.zero:  \n                self.product.append(num)\n                self.zero = False\n            else:\n                self.product.append(num * self.product[-1])\n            \n    def getProduct(self, k: int) -> int:\n        # print(\\\"product\\\", self.product)\n        # print(\\\"list\\\", self.list)\n        # print(\\\"k =\\\", k)\n        if not all(self.product[-k:-1]):\n            return 0\n        else:\n            if not self.product[-k-1]:\n                return int(self.product[-1])\n            else:\n                return int(self.product[-1] / self.product[-k-1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.data = []\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.data = []\n        self.data.append(num)\n\n    def getProduct(self, k: int) -> int:\n        count = 0\n        if k > len(self.data):\n            return 0\n        res = self.data[-k:]\n        return math.prod(res)\n            \n            \n            \n            \n            \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.list = []\n        self.mul_list = []\n        self.n = -1\n        \n    def add(self, num: int) -> None:\n        self.list.append(num)\n        self.n += 1 # len(s) - 1\n        if self.mul_list:\n            self.mul_list.append(self.mul_list[-1] * num)\n        else:\n            self.mul_list.append(num)\n        \n        if num == 0:\n            self.mul_list = []\n           \n    def getProduct(self, k: int) -> int:\n        if len(self.mul_list) == k:\n            return self.mul_list[-1]\n        elif len(self.mul_list) >= k+1:\n            return (self.mul_list[-1] // self.mul_list[-(k+1)])\n        else :\n            return 0\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from functools import reduce\nfrom math import prod\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.nums=list()\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        return\n        if not self.nums:\n            self.nums.append(num)\n            return\n        last_number = self.nums[-1]*num\n        self.nums.append(last_number)\n        \n    def getProduct(self, k: int) -> int:\n        last_k_nums = self.nums[-1*k:]\n        return prod(last_k_nums)\n        #return reduce((lambda x, y: x* y), last_k_nums)\n        #return self.nums[k`]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n    def __init__(self):\n        self.arr = []\n\n    def add(self, num: int) -> None:\n        self.arr.append(num)\n\n    def getProduct(self, k: int) -> int:\n        \n        return math.prod(self.arr[-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.list = []\n\n    def add(self, num: int) -> None:\n        self.list.append(num)\n        \n        \n\n    def getProduct(self, k: int) -> int:\n        return math.prod(self.list[len(self.list) - k:])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n    \n\n    def __init__(self):\n        self.nums=[]\n        \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        stop=len(self.nums)-k\n        return(math.prod(self.nums[stop:]))\n       \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n\n", "class ProductOfNumbers:\n    \n\n    def __init__(self):\n        self.nums=[]\n        \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        stop=len(self.nums)-k\n        return(math.prod(self.nums[stop:]))\n        #return (reduce((lambda x,y : x*y),self.nums[stop:]))\n       \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = []\n\n    def add(self, num: int) -> None:\n        self.arr.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return math.prod(self.arr[len(self.arr)-k:])\n        \n       \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.mylist=[]\n        \n\n    def add(self, num: int) -> None:\n        self.mylist.append(num)\n        # print(self.mylist)\n\n    def getProduct(self, k: int) -> int:\n        this_list=self.mylist[-k:]\n        # print(k,this_list,math.prod(this_list) )\n        return math.prod(this_list) \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = []\n\n    def add(self, num: int) -> None:\n        self.arr.append(num)\n\n    def getProduct(self, k: int) -> int:\n        # prod = 1\n        # for num in self.arr[-k:]:\n        #     if num == 0:\n        #         return 0\n        #     prod *= num\n        # return prod\n        return prod(self.arr[-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "\nimport math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.a = []\n\n    def add(self, num: int) -> None:\n        self.a.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        return math.prod(self.a[-k:])\n        \n            \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []  \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n\n    def getProduct(self, k: int) -> int:\n        # prod = 1\n        # for num in self.nums[-k:]:\n        #     prod *= num\n        # return prod\n        return math.prod(self.nums[-k:])\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.product = []\n        self.n = 0\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            i = self.n-1\n            self.product.append(0)\n            while(i >= 0 and self.product[i] != 0):\n                self.product[i] = 0\n                i -= 1\n        else:\n            if self.n == 0 or self.product[-1] == 0:\n                self.product.append(num)\n            else:\n                self.product.append(num*self.product[-1])\n        self.n += 1\n        # print(self.product)\n\n    def getProduct(self, k: int) -> int:\n        if k == self.n:\n            if self.product[0] == 0: return 0\n            else: return self.product[-1]\n\n        if self.product[self.n-k] == 0:\n            return 0\n        elif self.product[self.n-k-1] == 0:\n            return self.product[-1]\n        else:\n            return self.product[-1]//self.product[self.n-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.usable_array = []\n\n    def add(self, num: int) -> None:\n        self.usable_array.append(num)\n\n    def getProduct(self, k: int) -> int:\n        if type(k) != int:\n            self.usable_array = ProductOfNumbers()\n        #product = 1\n        product = math.prod(self.usable_array[-k:])\n        return product\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n    from numpy import prod\n    def __init__(self):\n        self.numbers= []\n        \n    def add(self, num: int) -> None:\n        self.numbers.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return prod(self.numbers[len(self.numbers)- k : len(self.numbers)])\n        # for i in self.numbers[]:\n        #     prod =prod*i\n        # return prod\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.numList=[]\n\n    def add(self, num: int) -> None:\n        self.numList.append(num)\n\n    def getProduct(self, k: int) -> int:\n        prodList=self.numList[(-1*k):]\n        \n        #prod=1\n        #length=len(self.numList)\n        #for i in range(length-k, length):\n        #    prod = prod * self.numList[i]\n            \n        return math.prod(prodList)\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return math.prod(self.nums[len(self.nums) - k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return prod(self.nums[-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        return prod(self.nums[-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.numbers = []\n\n    def add(self, num: int) -> None:\n        self.numbers.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return math.prod(self.numbers[-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.store=[]\n\n    def add(self, num: int) -> None:\n        self.store.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return prod(self.store[-k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:    \n    def __init__(self):\n        self.lisst = []\n\n    def add(self, num: int) -> None:\n        self.lisst += [num]\n\n    def getProduct(self, k: int) -> int:\n        return prod(self.lisst[len(self.lisst) - k:])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.product_list = []\n\n    def add(self, num: int) -> None:\n        self.product_list.append(num)\n\n    def getProduct(self, k: int) -> int:\n        return prod(self.product_list[-k:])\n            \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = [1]\n        self.prod = [1]\n        self.pz_list = [-1]\n        self.prev_zero = -1\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        if num > 0:\n            self.pz_list.append(self.prev_zero)\n            if self.prod[-1] != 0:\n                self.prod.append(self.prod[-1] * num)\n            else:\n                self.prod.append(num)\n        else:\n            self.prev_zero = len(self.nums) - 1\n            self.pz_list.append(self.prev_zero)\n            self.prod.append(1)\n            \n    def getProduct(self, k: int) -> int:\n        if len(self.nums) - 1 - self.pz_list[-1] < k:\n            return 0\n        else:\n            return self.prod[-1] // self.prod[-1 * k -1] \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.l = []\n\n    def add(self, num: int) -> None:\n        self.l.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        return math.prod(self.l[len(self.l)-k:len(self.l)])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = [1]\n        self.latest_zero_position = None\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.latest_zero_position = len(self.products)\n            num = 1\n        self.products.append(self.products[-1] * num)\n        \n    def getProduct(self, k: int) -> int:\n        if self.latest_zero_position != None:\n            if self.latest_zero_position >= len(self.products) - k:\n                return 0\n        \n        return self.products[-1] // self.products[-k - 1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.len = 0\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.nums = []\n            self.len = 0\n        elif num == 1:\n            self.len += 1\n            if len(self.nums) and isinstance(self.nums[-1], list):\n                self.nums[-1][0] += 1\n            else:\n                self.nums.append([1])\n        else:\n            self.len += 1\n            self.nums.append(num)\n\n    def getProduct(self, k: int) -> int:\n        if k > self.len:\n            return 0\n        prod, idx = 1, len(self.nums)-1\n        while k > 0:\n            #print(k, idx)\n            if isinstance(self.nums[idx], list):\n                k -= self.nums[idx][0]\n            else:\n                prod *= self.nums[idx]\n                k -= 1\n            idx -= 1\n        return prod\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = [1]\n        self.zero = -1\n\n    def add(self, num: int) -> None:\n        \n        if num == 0:\n            self.arr.append(self.arr[-1])\n            self.zero = len(self.arr)-1\n        else:\n            self.arr.append(self.arr[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        \n        if self.zero != -1 and self.zero >= len(self.arr) - k:\n            return 0\n        \n        return self.arr[-1] // self.arr[-k-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.stack = []\n        self.acc = []\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.stack = []\n            return\n        if self.stack:\n            self.stack.append(self.stack[-1] * num)\n        else:\n            self.stack.append(num)\n            \n        \n\n    def getProduct(self, k: int) -> int:\n        if k > len(self.stack):\n            return 0\n        if k == len(self.stack):\n            return self.stack[-1]\n        return self.stack[-1]//self.stack[-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = [1]\n        self.last_zero = -40001\n        \n    def add(self, num: int) -> None:\n        if num == 0:\n            self.last_zero = len(self.products) - 1\n        if not self.products:\n            self.products.append(num)\n        else:\n            self.products.append(self.products[-1] * max(1,num))\n        \n\n    def getProduct(self, k: int) -> int:\n        if self.last_zero >= len(self.products) - k - 1:\n            return 0\n        result = int(self.products[-1]/self.products[len(self.products) - k - 1])\n        return result\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.product = []\n        self.n = 0\n        self.zero = -1\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.product.append(0)\n            self.zero = self.n\n        else:\n            if self.n == 0 or self.product[-1] == 0:\n                self.product.append(num)\n            else:\n                self.product.append(num*self.product[-1])\n        self.n += 1\n        # print(self.product)\n\n    def getProduct(self, k: int) -> int:\n        if self.zero >= self.n-k: return 0\n        if k == self.n or self.n-k-1 == self.zero:\n            return self.product[-1]\n        return self.product[-1]//self.product[self.n-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = [1, ]\n        self.max_k = 0\n        self.step = 0\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.max_k = self.step\n        else:\n            self.products.append(self.products[-1] * num)\n            self.step += 1\n\n    def getProduct(self, k: int) -> int:\n        if k > self.step - self.max_k:\n            return 0\n        return int(self.products[-1] / self.products[self.step - k])", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = [1]\n        self.zeroes = []\n        self.index = 1\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.zeroes.append(self.index)\n            self.index += 1\n            self.products.append(self.products[-1])\n        else:\n            self.products.append(self.products[-1] * num)\n            self.index += 1\n        \n\n    def getProduct(self, k: int) -> int:\n        if self.zeroes and self.zeroes[-1] >= self.index - k:\n            return 0\n        else:\n            return int(self.products[-1] / self.products[-(k + 1)])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.dp = [1]\n        self.lastZero = -1\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.lastZero = len(self.dp)\n            num = 1\n        self.dp.append(num*self.dp[-1])\n        \n\n    def getProduct(self, k: int) -> int:\n        if len(self.dp)-k<=self.lastZero:\n            return 0\n        if len(self.dp)-k-1 < 0: return self.dp[-1]\n        return self.dp[-1]//self.dp[-k-1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.d = {}\n        self.nulls = []\n        self.index = 0\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.nulls.append(self.index)\n            num = 1\n            \n        if self.index == 0:\n            self.d[self.index] = num\n        else:\n            self.d[self.index] = self.d[self.index - 1] * num        \n                    \n        self.index += 1     \n            \n\n    def getProduct(self, k: int) -> int:\n\n        \n        if self.nulls and self.nulls[-1] > self.index - k - 1:\n            return 0\n        if self.index - k == 0:\n            return self.d[self.index - 1]\n        \n        return self.d[self.index-1] // self.d[self.index - k-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import numpy as np\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.data = [1]\n \n    def add(self, num: int) -> None:\n        if num == 0:\n            self.data = [1]\n        else:\n            self.data.append(num * self.data[-1])\n \n    def getProduct(self, k: int) -> int:\n        if k >= len(self.data):\n            return 0\n        return self.data[-1] // self.data[ - k - 1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.hash={}\n\n    def add(self, num: int) -> None:\n        curr=len(self.hash)\n        if num==0:self.hash[curr]=(curr,1)\n        else:\n            product=1 if curr==0 or self.hash[curr-1][1]==0 else self.hash[curr-1][1]\n            prev=self.hash[curr-1][0] if len(self.hash) else -1\n            self.hash[curr]=(prev,product*num)\n        \n\n    def getProduct(self, k: int) -> int:\n        prev=self.hash[len(self.hash)-1][0]\n        low,up=(len(self.hash)-1)-k+1,len(self.hash)-1\n        if low<=prev<=up:return 0\n        top=len(self.hash)-1-k\n        end=len(self.hash)-1\n        return int(self.hash[end][1]/self.hash[top][1]) if k!=len(self.hash) else self.hash[k-1][1]\n        \n        \n        \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class Node:\n    def __init__(self, previous, value):\n        self.previous = previous\n        self.value = value\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.endNode = None\n        self.lastZero = None\n        self.size = 0\n        self.products = None\n\n    def add(self, num: int) -> int:\n        if (num == 0):\n            self.lastZero = self.size\n            \n        self.size += 1\n        \n        self.products = dict()\n        \n        self.endNode = Node(self.endNode, num)\n\n    def getProduct(self, k: int) -> None:\n        if self.lastZero and self.size - k < self.lastZero:\n            return 0\n        \n        if k in self.products:\n            return self.products[k]\n        \n        product = 1\n        currentNode = self.endNode\n        for i in range(0, k):\n            product *= currentNode.value\n            currentNode = currentNode.previous\n            \n        self.products[k] = product\n        return product\n            \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.runningProduct = []\n        self.zeroStack = []\n        self.addedZero = False\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.runningProduct.append(num)\n            self.addedZero = True\n            self.zeroStack.append(len(self.runningProduct)-1)\n        else:\n            if self.addedZero or len(self.runningProduct) == 0:\n                self.runningProduct.append(num)\n            else:\n                currentProduct = num * self.runningProduct[-1]\n                self.runningProduct.append(currentProduct)\n            self.addedZero = False\n\n    def getProduct(self, k: int) -> int:\n        totalIndex = len(self.runningProduct) - 1\n        if self.zeroStack and self.zeroStack[-1] > (totalIndex - k):\n            return 0\n        elif (totalIndex - k) == -1 or self.runningProduct[totalIndex-k] == 0:\n            return int(self.runningProduct[-1])\n        else:\n            return int(self.runningProduct[-1] / self.runningProduct[totalIndex-k])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prods = []\n        self.zeros = []\n        \n    def add(self, num: int) -> None:\n        zero = 1 if num == 0 else 0\n        if not self.zeros: self.zeros.append(zero)\n        else: self.zeros.append(self.zeros[-1] + zero)\n        \n        prod = max(1, num)\n        if self.prods: self.prods.append(self.prods[-1] * prod)\n        else: self.prods.append(prod)\n\n    def getProduct(self, k: int) -> int:\n        has_zero = False\n        if len(self.zeros) == k: has_zero = self.zeros[-1] > 0\n        else: has_zero = (self.zeros[-1] - self.zeros[-k-1]) > 0\n        if has_zero: return 0\n        \n        if len(self.prods) == k: return self.prods[-1]\n        return self.prods[-1] // self.prods[-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.p = [1]\n        self.last0i = -1\n\n    def add(self, num: int) -> None:\n        p = self.p\n        N = len(p)\n        if num == 0:\n            self.last0i = N\n            num = 1\n        p.append(p[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        p = self.p\n        si = len(p) - k\n        if si <= self.last0i:\n            return 0\n        else:\n            return p[-1] // p[si - 1]\n\n\\\"\\\"\\\"\ns = ProductOfNumbers()\ns.add(3)\ns.add(0)\ns.add(2)\ns.add(5)\ns.add(4)\nprint(s.getProduct(2))\nprint(s.getProduct(3))\nprint(s.getProduct(4))\ns.add(8)\nprint(s.getProduct(2))\n\\\"\\\"\\\"", "from functools import reduce\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.list = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.list = [1]\n        else:\n            result = self.list[-1]*num\n            self.list.append(result)\n\n    def getProduct2(self, k: int) -> int:\n        return reduce(lambda x,y:  x*y, self.list[-k:])\n    \n    def getProduct(self, k: int) -> int:\n        if len(self.list) <= k:\n            return 0\n        \n        ind = -1 - k \n        if self.list[ind] == 0:\n            return 0\n        else:\n            return self.list[-1]//self.list[ind]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n\n\n#[3,0,2,2,5,4]\n#[3, 0, 1, 2,  4, 20, 80]\n#last 2 list[-1]/list[(-2-1)] => 80/4 = 20  \n#last 3  => 80/2 = 40\n#last 4 => 80/ 1 = 80\n# last 5 => list[-6] == 0 => 0\n# last 6 => 0 \n\n# [2,3,4,5,6]\n# l = 5 \n# [2, 6, 24, 120, 720]\n# last 2 => 30\n# last 3 => 720/6 = 120 \n# last 4 => 720/2 = 360 \n# last 5 => list[-1]\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.lst = []\n        self.running = []\n        self.last0index = -1\n        self.size = 0\n\n    def add(self, num: int) -> None:\n        self.size += 1\n        if not self.lst and num != 0:\n            self.running.append(num)\n        elif num == 0: \n            self.running.append(1)\n        elif self.lst[-1] == 0:\n            self.running.append(num)\n        else:\n            self.running.append(num*self.running[-1])\n        self.lst.append(num)\n\n        if num == 0: self.last0index = self.size\n\n    def getProduct(self, k: int) -> int:\n        # print(self.running)\n        if self.size == 1: return self.lst[0]\n        if k > self.size: return -1\n        if self.size - k < self.last0index: return 0\n        if self.size == k: return self.running[-1]\n\n        return int(self.running[-1] / self.running[self.size-k-1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.res = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.res = [1]\n        else:\n            self.res.append(self.res[-1]*num)\n        \n\n    def getProduct(self, k: int) -> int:\n        if len(self.res) <= k:\n            return 0\n        else:\n            return self.res[-1]//self.res[-1-k]\n        \n        \n            \n        \n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.data = []\n        self.prod = [1]\n\n    def add(self, num: int) -> None:\n        self.data.append(num)\n        if num != 0 and self.prod[-1] != 0:\n            self.prod.append(self.prod[-1]*num)\n        elif num == 0:\n            self.prod = (len(self.prod))*[0]\n            self.prod.append(1)\n\n    def getProduct(self, k: int) -> int:\n        return self.prod[-1]//self.prod[-1-k] if self.prod[-1-k] else 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prods = []\n        self.stamp = []\n        \n\n    def add(self, num: int) -> None:\n        self.prods.append(num)\n        self.stamp.append(1)\n        \n        [3, 0, 2, 5, 4]\n        [1, 1, 1, 1, 1]\n        \n\n    def getProduct(self, k: int) -> int:\n        if k <= 0:\n            return 1\n        \n        index = len(self.prods) - k\n        if self.stamp[index] == k:\n            return self.prods[index]\n        \n        value = self.prods[index] * self.getProduct(k - self.stamp[index])\n        \n        self.stamp[index] = k\n        self.prods[index] = value\n        \n        return value\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.last_zero = -1\n        self.product_agg = []\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.last_zero = len(self.product_agg)\n            self.product_agg.append(num)\n        else:\n            if self.last_zero == len(self.product_agg) - 1:\n                self.product_agg.append(num)\n            else:\n                self.product_agg.append(num * self.product_agg[len(self.product_agg) - 1])\n\n    def getProduct(self, k: int) -> int:\n        diff_num = len(self.product_agg) - k -1\n        \n        if self.last_zero != -1 and self.last_zero > diff_num:\n            return 0\n        if diff_num >= 0 and self.product_agg[diff_num] > 0:\n            return self.product_agg[len(self.product_agg)-1] // self.product_agg[diff_num]\n        \n        return self.product_agg[len(self.product_agg) - 1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.data = []\n        self.prod = [1]\n\n    def add(self, num: int) -> None:\n        self.data.append(num)\n        if num != 0 and self.prod[-1] != 0:\n            self.prod.append(self.prod[-1]*num)\n        elif num == 0:\n            self.prod = (len(self.prod))*[0]\n            self.prod.append(1)\n            # elif self.prod[-1] == 0:\n            #     self.prod.append(num)\n        # elif num:\n        #     self.prod.append(num)\n        # else:\n        #     self.prod.append(1)\n\n    def getProduct(self, k: int) -> int:\n        # print(self.prod)\n        return self.prod[-1]//self.prod[-1-k] if self.prod[-1-k] else 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.product = []\n        self.last_zero = -1\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        if num == 0:\n            self.product = [0]*len(self.product)\n            self.last_zero = len(self.nums)-1\n        else:\n            if num != 1:\n                for i in range(len(self.product)-1, self.last_zero, -1):\n                    self.product[i] *= num\n        self.product.append(num)\n\n    def getProduct(self, k: int) -> int:\n        if len(self.product) < k:\n            return None\n        return self.product[-k]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.numbers = []\n        self.history = {}\n\n    def add(self, num: int) -> None:\n        self.numbers.append(num)\n        self.history = {}\n        \n    def getProduct(self, k: int) -> int:     \n        if k not in self.history:\n            self.history[k] = (self.numbers[len(self.numbers)-k] * self.getProduct(k-1) if self.numbers[len(self.numbers)-k] else 0 ) if k else 1\n        \n        return self.history[k]  \n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import bisect\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = []\n        self.zero_idx = []\n        \n\n    def add(self, num: int) -> None:\n        n = len(self.arr)\n        if num == 0:\n            self.arr = [0] * (n + 1)\n            self.zero_idx.append(n)\n        \n        else:\n            if n == 0 or self.arr[-1] == 0:\n                self.arr.append(num)\n            else:\n                self.arr.append(num * self.arr[-1])\n        \n\n    def getProduct(self, k: int) -> int:\n        # check if there is any zeros in the range\n        i = len(self.arr) - k\n        x = bisect.bisect_right(self.zero_idx, i - 1, 0, len(self.zero_idx))\n        \n        # no zero found\n        if x == len(self.zero_idx):\n            if k == len(self.arr):\n                return self.arr[-1]\n            else:\n                if self.arr[len(self.arr) - k - 1]:\n                    return self.arr[-1] // self.arr[len(self.arr) - k - 1]\n                \n                return self.arr[-1]\n        else:\n            return 0\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    \n    # [3, 0, 0, 2, 5, 4]\n    # [(3, 1, -1), (0, 3, 1), (0, 1, 2), (2,1,2), (5,2,2), (4,10,2)]\n    def __init__(self):\n        self.nums = []\n\n    def add(self, num: int) -> None:\n        if not self.nums:\n            last_zero = -1 if num else 0\n            self.nums.append([num, 1, last_zero])\n            return\n            \n        (last_val, last_product, last_zero) = self.nums[-1]\n        \n        last_zero = last_zero if num else len(self.nums)\n        last_product = last_product * last_val or 1\n        \n        self.nums.append([num, last_product, last_zero])\n        \n    def getProduct(self, k: int) -> int:\n        right_ind = len(self.nums) - 1\n        left_ind = right_ind - k + 1\n        \n        if left_ind < 0:\n            left_ind = 0\n            \n        (right_val, right_product, right_last_zero) = self.nums[right_ind]            \n        (left_val, left_product, left_last_zero) = self.nums[left_ind]     \n        \n        if right_last_zero < left_ind:\n            return right_val * right_product // left_product\n        return 0\n        \n        \n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr =  [1]\n        \n    def add(self, num: int) -> None:\n        if not num :\n            self.arr =[1]\n        else:\n            self.arr.append(self.arr[-1]*num)\n        \n        \n    def getProduct(self, k: int) -> int: \n        if k>=len(self.arr):\n            return 0\n        return self.arr[-1]//self.arr[-k-1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n\n    def add(self, num: int) -> None:\n        i = len(self.nums)\n        self.nums.append( (num, i+1) )\n        \n\n    def getProduct(self, k: int) -> int:\n        def update(i):\n            cur, done = self.nums[i]\n            if done < len(self.nums):\n                update(done)\n                cur *= self.nums[done][0]\n                self.nums[i] = cur, len(self.nums)\n            \n        count = len(self.nums)\n        i = count -k\n        cur, done = self.nums[i]\n        if done < count:\n            update(i)\n        return self.nums[i][0]\n         \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.numlist = []\n        self.cumprod = []\n        self.zeros = []\n\n    def add(self, num: int) -> None:\n        self.numlist.append(num)\n        if self.cumprod == [] or self.cumprod[-1] == 0: \n            self.cumprod.append(num)\n        else: \n            new = self.cumprod[-1] * num\n            self.cumprod.append(new)\n        if num == 0: \n            self.zeros.append(len(self.cumprod)-1) \n\n    def getProduct(self, k: int) -> int:\n        if self.zeros != [] and len(self.cumprod) - k <= self.zeros[-1]: \n            return 0\n        else:\n            if k == len(self.cumprod):\n                return self.cumprod[k-1]\n            else:\n                ii = len(self.cumprod) - k\n                return self.numlist[ii] * self.cumprod[-1] // self.cumprod[ii]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.product = [1]\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.product = [1]\n        else:\n            \n            self.product.append(self.product[-1] * num)\n      # [1 , 3, 4, .... k, 3 , 2, 1] \n    def getProduct(self, k: int) -> int:\n        n = len(self.product) - 1\n        \n        return self.product[n] // self.product[n - k] if k <= n else 0\n    \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.A = [1]\n\n    def add(self, a):\n        if a == 0:\n            self.A = [1]\n        else:\n            self.A.append(self.A[-1] * a)\n\n    def getProduct(self, k):\n        if k >= len(self.A): return 0\n        return self.A[-1] // self.A[-k - 1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.a=[]\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.a = []\n        elif self.a :\n            self.a.append(self.a[-1]*num)\n        else:\n            self.a.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        if k > len(self.a):\n            return 0\n        if k == len(self.a):\n            return self.a[-1]\n        return self.a[-1]//self.a[-(k+1)]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "'''\n\n3,0,2,5,4,    8\n\nk=1, 4\nk=2, 20\nk=3,40\nk=4,0\nk=5,0\n\nd:\n\n'''\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.size = 0\n        self.d = {}\n        self.lastZero = -1\n        \n\n    def add(self, num: int) -> None:\n        self.size += 1\n        if self.size <= 1 or self.d[self.size - 1] == 0:\n            self.d[self.size] = num\n        else:\n            self.d[self.size] = num * self.d[self.size - 1]\n        \n        if num == 0:\n            self.lastZero = self.size\n\n        \n\n    def getProduct(self, k: int) -> int:\n\n        if self.size - k < self.lastZero: \n            return 0\n        if self.size - k <= 0 or self.d[self.size - k] == 0: \n            return self.d[self.size]\n        return self.d[self.size] // self.d[self.size - k]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.prefixes_products = []\n        \n    def add(self, num: int) -> None:        \n        if num == 0:\n            self.prefixes_products.clear()\n            return\n        \n        if not self.prefixes_products:\n            self.prefixes_products.append(num)\n        else:\n            self.prefixes_products.append(num*self.prev)\n\n        self.prev = self.prefixes_products[-1]\n                \n    def getProduct(self, k: int) -> int:\n        if len(self.prefixes_products) == k:\n            return self.prev\n        elif len(self.prefixes_products) < k:\n            return 0\n        else:\n            return self.prev//self.prefixes_products[len(self.prefixes_products)-k-1]\n        \n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.idx = 0\n        self.pos2Prod = {}\n        self.zeroPos = []\n        self.currProd = 1\n        \n    def add(self, num: int) -> None:\n        \n        if num == 0:\n            self.zeroPos.append(self.idx)\n            num = 1\n            \n        self.pos2Prod[self.idx] = self.currProd * num\n        self.currProd = self.currProd * num      \n        self.idx += 1\n        \n        \n    def getProduct(self, k: int) -> int:\n        tailIdx = self.idx - 1\n        headIdx = tailIdx - k \n        if self.zeroPos and self.zeroPos[-1] > headIdx:\n            return 0\n        else:\n            return self.pos2Prod[tailIdx] // (self.pos2Prod[headIdx] if headIdx >=0 else 1)\n        \n        \n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prods = []\n        self.currentProd = 1\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.prods = []\n            self.currentProd = 0\n        else:\n            if self.currentProd:\n                self.currentProd *= num\n            else:\n                self.currentProd = num\n                \n            self.prods.append(self.currentProd)\n        \n\n    def getProduct(self, k: int) -> int:\n        if len(self.prods) < k:\n            return 0\n        elif len(self.prods) == k:\n            return int(self.currentProd)\n        else:\n            return int(self.currentProd / self.prods[-k-1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = []\n\n    def add(self, num: int) -> None:\n        if not num:\n            self.arr = []\n        else:\n            prev_prod = self.arr[-1] if self.arr else 1\n            self.arr.append(num*prev_prod)\n        return\n\n    def getProduct(self, k: int) -> int:\n        if len(self.arr) < k:\n            return 0\n        elif len(self.arr) == k:\n            return self.arr[-1]\n        else:\n            return self.arr[-1]//self.arr[-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = [1]\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.nums =  [1]\n        else:\n            self.nums.append(self.nums[-1]*num)\n        \n\n    def getProduct(self, k: int) -> int:\n        if len(self.nums) <= k:\n            return 0\n        return self.nums[-1]//self.nums[-k-1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.cur = 0\n        self.prod = [1]\n        self.last_zero = -1\n        \n\n    def add(self, num: int) -> None:\n        if num != 0:\n            self.prod.append(self.prod[-1] * num)\n        else:\n            self.prod.append(self.prod[-1])\n            self.last_zero = self.cur\n        self.cur += 1\n\n    def getProduct(self, k: int) -> int:\n        if self.cur - k > self.last_zero:\n            return int(self.prod[-1] / self.prod[-k-1])\n        else:\n            return 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prefix = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.prefix = [1]\n        else:\n            self.prefix.append(self.prefix[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        if k > len(self.prefix) - 1:\n            return 0\n        return int(self.prefix[-1]/self.prefix[-k - 1])\n    # k = 1, self.prefix[-1]/self.prefix[-2]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import queue as Q\nclass Node:\n    def __init__(self):\n        self.prev = None\n        self.value = None\nclass ProductOfNumbers:\n    \n    \n    \n    def __init__(self):\n        self.tail = None\n        self.maxVal = float('-inf')\n\n    def add(self, num: int) -> None:\n        \n        if num > self.maxVal:\n            self.maxVal = num\n        \n        if self.tail == None:\n            self.tail = Node()\n            self.tail.value = num\n            return\n        \n        temp = self.tail\n        newNode = Node()\n        newNode.value = num\n        newNode.prev = temp\n        self.tail = newNode\n        \n\n    def getProduct(self, k: int) -> int:\n        if self.maxVal == 1:\n            return 1\n        \n        result = 1\n        count = 0\n        temp = self.tail\n        while count < k:\n            result*=temp.value\n            if result == 0:\n                return 0\n            temp = temp.prev\n            count += 1\n        return result\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.z = []\n        self.s = 1\n        self.l = []\n        self.m = [1]\n        self.ind = -1\n\n    def add(self, num: int) -> None:\n        self.ind += 1\n        self.l.append(num)\n        self.s *= num\n        self.m.append(self.s)\n        if num == 0:\n            self.z.append(self.ind)\n            self.s = 1\n            self.m[-1] = 1\n        # print(num, self.l,self.m,self.s)\n\n    def getProduct(self, k: int) -> int:\n        if len(self.z) and self.z[-1] > self.ind - k:\n            return 0\n        else:\n            # print(k,self.z[-1],self.ind)\n            # print(self.m)\n            return int(self.m[-1] // self.m[-k-1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.A=[1]\n\n    def add(self, num: int) -> None:\n        if not num:\n            self.A = [1]\n        else:\n            self.A.append(self.A[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        \n        if k>=len(self.A):\n            return 0\n        return self.A[-1]//self.A[-1-k]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums=[]\n        self.suffixProduct=[]\n        self.zeros=set()\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        if num==0:\n            self.zeros.add(len(self.nums)-1)\n            num=1\n        if len(self.suffixProduct)>0:\n            self.suffixProduct.append(self.suffixProduct[-1]*num)\n        else:\n            self.suffixProduct.append(num)\n\n    def getProduct(self, k: int) -> int:\n        if k==1:\n            return self.nums[-1]\n        l = len(self.suffixProduct)-1\n        # print(l,k,self.zeros)\n        # for j in range(l, l-k, -1):\n        #     if j in self.zeros:\n        #         return 0\n        for zi in self.zeros:\n            if zi >l-k and zi <=l:\n                return 0\n        if len(self.suffixProduct) == -1*(-k):\n            dd = 1\n        else:\n            dd = self.suffixProduct[-1-k]\n        return int(self.suffixProduct[-1] / dd)\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = []\n        self.zero_point = -1\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.products.append(0)\n            self.zero_point = len(self.products)\n        elif not self.products or self.products[-1] == 0:\n            self.products.append(num)\n        else:\n            self.products.append(self.products[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        if len(self.products) - self.zero_point < k:\n            ret = 0\n        elif len(self.products) - self.zero_point == k or len(self.products) == k:\n            ret = self.products[-1]\n        else:\n            ret = self.products[-1] // self.products[-k-1]\n        return ret\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.curr_prod = None\n        self.product_array = []\n        self.zero_idx = set()\n\n    def add(self, num: int) -> None:  \n        self.nums.append(num)\n        if self.curr_prod == None or self.curr_prod == 0:\n            self.product_array.append(num)\n        else:\n            self.product_array.append(self.curr_prod * num)\n        self.curr_prod = self.product_array[-1]\n        if num == 0:\n            self.zero_idx.add(len(self.nums) - 1)\n\n    def getProduct(self, k: int) -> int:    \n        if k == 1:\n            return self.nums[-1]\n        n = len(self.nums)\n        for idx in self.zero_idx:\n            if idx > n - k - 1 and idx < n:\n                return 0\n        if self.product_array[n - k - 1] == 0 or k == n:\n            return self.product_array[n - 1]\n        else:\n            return int(self.product_array[n - 1] / self.product_array[n - k - 1])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.A = [1]\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.A = [1]\n        else:\n            self.A.append(self.A[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.A): return 0\n        return self.A[-1] // self.A[-k - 1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = []\n        \n\n    def add(self, num: int) -> None:\n        \n        if num == 0:\n            self.products = []    \n        else:\n            self.products.append(num if not len(self.products) else self.products[-1] * num)\n           \n    def getProduct(self, k: int) -> int:\n        if k > len(self.products):\n            return 0\n        elif k == len(self.products):\n            return self.products[-1]\n        else:\n            return self.products[-1] // self.products[-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.total_list = []\n        self.cumul_list = [1]\n    def add(self, num: int) -> None:\n        self.total_list.append(num)\n        if num == 0:\n            self.cumul_list= [1]\n        else:\n            self.cumul_list.append(self.cumul_list[len(self.cumul_list)-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        if k < len(self.cumul_list):\n            return int(self.cumul_list[len(self.cumul_list)-1] / self.cumul_list[len(self.cumul_list) - k - 1])\n        else:\n            return 0\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.max_zero_idx = -1\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.max_zero_idx = max(self.max_zero_idx, len(self.nums))\n        \n        if not self.nums:\n            self.nums.append(num)\n        else:\n            prev_prod = self.nums[-1] if self.nums[-1] != 0 else 1\n            self.nums.append(num * prev_prod)\n\n    def getProduct(self, k: int) -> int:\n        left, right = len(self.nums) - 1 - k, len(self.nums) - 1\n        if left == self.max_zero_idx:\n            return self.nums[right]\n        elif left > self.max_zero_idx:\n            return self.nums[right] // self.nums[left]\n        else:\n            return 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.a=[] \n\n    def add(self, num: int) -> None:\n        if num==0:\n            self.a=[]\n            return\n        if not self.a:\n            self.a.append(num)\n            return\n        self.a.append(self.a[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        if k > len(self.a):\n            return 0\n        if k == len(self.a):\n            return self.a[-1]\n        return self.a[-1]//self.a[-1-k]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.prefixes_products = []\n        \n    def add(self, num: int) -> None:        \n        if num == 0:\n            self.prefixes_products = []\n            self.prev = 0\n            return\n        \n        if not self.prefixes_products:\n            self.prefixes_products.append(num)\n        else:\n            self.prefixes_products.append(num*self.prev)\n\n        self.prev = self.prefixes_products[-1]\n                \n    def getProduct(self, k: int) -> int:\n        if len(self.prefixes_products) == k:\n            return self.prev\n        if len(self.prefixes_products) < k:\n            return 0\n    \n        return self.prev//self.prefixes_products[len(self.prefixes_products)-k-1]\n        \n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from collections import deque\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self._stack = []\n        # self._prod = 1\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self._stack = []\n        elif not self._stack:\n            self._stack = [num]\n        else:\n            self._stack.append(self._stack[-1]*num)\n        \n\n    def getProduct(self, k: int) -> int:\n        if k > (n:=len(self._stack)):\n            return 0\n        elif k == n:\n            return self._stack[-1]\n        else:\n            return (self._stack[-1]) // self._stack[n-k-1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.products = []\n        self.lastZero = -1\n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        if(num == 0):\n            self.lastZero = len(self.nums)\n            self.products.append(0)\n        elif len(self.products) == 0:\n            self.products.append(num)\n        else:\n            if self.products[-1] == 0:\n                self.products.append(num)\n            else:\n                self.products.append(self.products[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if self.lastZero != -1 and k == len(self.nums):\n            return 0\n        if len(self.nums) - k >= self.lastZero:\n            divisor = 1\n            if k + 1 <= len(self.nums) and self.products[-k - 1] != 0:\n                divisor = self.products[-k - 1]\n            return int(self.products[-1]/divisor)\n        else:\n            return 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.nums = [1]\n        else:\n            self.nums.append(num * self.nums[-1])\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.nums):\n            return 0\n        return self.nums[-1] // self.nums[-k - 1]\n    \n\nclass SlidingWindow:\n    def __init__(self, k: int):\n        self.k = k\n        self.q = deque()\n        self.zero_cnt = 0\n    \n    def add(self, val: int) -> None:\n        if val == 0:\n            self.zero_cnt = self.k\n            self.q.append(1)\n        else:\n            self.zero_cnt -= 1\n            prev = self.q[-1] if self.q else 1\n            self.q.append(prev * val)\n            if len(self.q) > self.k:\n                if self.zero_cnt <= 0:\n                    self.q[-1] /= self.q[0]\n                self.q.popleft()\n\n    def getProduct(self) -> int:\n        if self.zero_cnt > 0:\n            return 0\n        return self.q[-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from functools import reduce\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.running_product = []\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.running_product = []\n        elif len(self.running_product) == 0:\n            self.running_product.append(num)\n        else:\n            self.running_product.append(num * self.running_product[-1])\n        return None\n\n    def getProduct(self, k: int) -> int:\n        if k > len(self.running_product):\n            return 0\n        elif k == len(self.running_product):\n            return self.running_product[-1]\n        else:\n            return self.running_product[-1] // self.running_product[-k-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.vec = []\n        # self.runningProd = []\n        \n\n    def add(self, num: int) -> None:\n        \n        if num==0:\n            self.vec=[]\n        \n        else:\n            if self.vec:\n                curr = self.vec[-1]\n            else:\n                curr = 1\n        \n            self.vec.append(num*curr)\n        \n\n    def getProduct(self, k: int) -> int:\n        \n        if len(self.vec)<k:\n            return 0\n        elif len(self.vec)==k:\n            return self.vec[-1]\n        else:\n            return self.vec[-1]//self.vec[-k-1]\n        \n        # outval = self.vec[-1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.preprod = [1]\n\n    def add(self, num: int) -> None:\n        if not num:\n            self.preprod = [1]\n        else:\n            self.preprod.append(self.preprod[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.preprod):\n            return 0\n        return self.preprod[-1] // self.preprod[-k-1]    \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.k1=[1]\n\n    def add(self, num: int) -> None:\n        if num!=0:\n            self.k1.append(self.k1[-1]*num)\n        else:\n            self.k1=[1]\n\n    def getProduct(self, k: int) -> int:\n        if k>=len(self.k1):\n            return 0\n        return (self.k1[-1]//self.k1[-1-k])\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = []\n    \n    def add(self, num: int) -> None:\n        if num == 0:\n            self.arr = []\n            return\n        if not self.arr :\n            self.arr.append(num)\n            return\n        self.arr.append(self.arr[-1] * num)\n        \n    def getProduct(self, k: int) -> int:\n        if k > len(self.arr):\n            return 0\n        if k == len(self.arr):\n            return self.arr[-1]\n        return self.arr[-1] //self.arr[-k-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.nums = [1]\n        else:\n            self.nums.append(num * self.nums[-1])\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.nums):\n            return 0\n        return self.nums[-1] // self.nums[-k - 1]\n    \n\nclass SlidingWindow:\n    def __init__(self, k: int):\n        self.k = k\n        self.q = deque()\n        self.zero_cnt = 0\n    \n    def add(self, val: int) -> None:\n        if val == 0:\n            self.zero_cnt = self.k\n            self.q.append(1)\n        else:\n            self.zero_cnt -= 1\n            prev = self.q[-1] if self.q else 1\n            self.q.append(prev * val)\n            if len(self.q) > self.k:\n                if self.zero_cnt <= 0:\n                    self.q[-1] /= self.q[0]\n                self.q.popleft()\n\n    def getProduct(self) -> int:\n        if self.zero_cnt > 0:\n            return 0\n        return self.q[-1]\n    \nwindow = SlidingWindow(3)\nwindow.add(1) # [1]\nwindow.add(2) # [1, 2]\nassert window.getProduct() == 2\nwindow.add(3) # [1, 2, 3]\nassert window.getProduct() == 6\nwindow.add(4) # [2, 3, 4]\nassert window.getProduct() == 24\nwindow.add(5) # [3, 4, 5]\nassert window.getProduct() == 60\n\n\nwindow = SlidingWindow(3)\nwindow.add(3)\nwindow.add(0)\nwindow.add(2)\nwindow.add(5)\nassert window.getProduct() == 0\nwindow.add(4)\nassert window.getProduct() == 40\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from collections import deque\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.running_products = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.running_products = [1]\n        else:\n            self.running_products.append(self.running_products[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if len(self.running_products) < k + 1:\n            return 0\n        return int(self.running_products[-1] / self.running_products[-k - 1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.ll=[]\n        self.dd=[1]#indexing form 1 not from 0\n        self.count=[0]\n        \n    def add(self, num: int) -> None:\n        self.ll.append(num)\n        val=self.dd[-1]*num\n        if (val==0):\n            temp=self.count[-1]\n            self.count.append(temp+1)\n            val=self.dd[-1]\n            self.dd.append(val)\n        else:\n            self.dd.append(val)\n            temp=self.count[-1]\n            self.count.append(temp)\n\n    def getProduct(self, k: int) -> int:\n        upp=len(self.count)-1\n        low=upp-k+1\n        \n        if (low==1):\n            if (self.count[upp]==0):\n                return self.dd[upp]\n            else:\n                return (0)\n        else:\n            if (self.count[upp]-self.count[low-1] == 0):\n                return (self.dd[upp]//self.dd[low-1])\n            else:\n                return(0)\n            \n            \n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prefix_prod = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.prefix_prod = [0] * len(self.prefix_prod) + [1]\n        else:\n            self.prefix_prod.append(self.prefix_prod[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        n = len(self.prefix_prod)\n        if self.prefix_prod[n - k - 1] == 0:\n            return 0\n        else:\n            return self.prefix_prod[n - 1] // self.prefix_prod[n - k - 1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.prefix_prod = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.prefix_prod = [0] * len(self.prefix_prod) + [1]\n        else:\n            if self.prefix_prod[-1] == 0:\n                self.prefix_prod.append(num)\n            else:\n                self.prefix_prod.append(self.prefix_prod[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        n = len(self.prefix_prod)\n        if self.prefix_prod[n - k - 1] == 0:\n            return 0\n        else:\n            return self.prefix_prod[n - 1] // self.prefix_prod[n - k - 1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.k1=[]\n        self.mul=1\n\n    def add(self, num: int) -> None:\n        if num!=0:\n            self.mul*=num\n            self.k1.append(self.mul)\n        else:\n            self.mul=1\n            self.k1=[]\n\n    def getProduct(self, k: int) -> int:\n        if k>len(self.k1):\n            return 0\n        elif k==len(self.k1):\n            return self.k1[-1]\n        else:\n            return (self.k1[-1]//self.k1[-1-k])\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.array = []\n        \n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.array = []\n        else:\n            self.array.append(self.array[-1] * num if self.array else num)\n            \n            \n\n    def getProduct(self, k: int) -> int:\n        if len(self.array) < k:\n            return 0\n        \n        if len(self.array) == k:\n            return self.array[-1]\n        \n        return self.array[-1]//self.array[-k-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from collections import deque\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.q = deque()\n        self.running_products = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.q = deque()\n            self.running_products = [1]\n        else:\n            self.running_products.append(self.running_products[-1] * num)\n            self.q.append(num)        \n\n    def getProduct(self, k: int) -> int:\n        if len(self.q) < k:\n            return 0\n        return int(self.running_products[-1] / self.running_products[-k - 1])\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n    \n    def __init__(self):\n        self.lis=[1]\n    \n        \n\n    def add(self, num: int) -> None:\n        if num==0:\n            self.lis=[1]\n        else:\n            self.lis.append(self.lis[len(self.lis)-1]*num)\n        \n\n    def getProduct(self, k: int) -> int:\n        \n        s=len(self.lis)\n        \n        if s-k-1<0:\n            return 0;\n        \n        return int(self.lis[s-1]/self.lis[s-k-1])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.products = []\n        self.tmp = 1\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.products = []\n            self.tmp = 1\n        else:\n            self.tmp *= num\n            self.products.append(self.tmp)\n\n    def getProduct(self, k: int) -> int:\n        if len(self.products) < k:\n            return 0\n        elif len(self.products) == k:\n            return self.products[-1]\n        else:\n            return self.products[-1] // self.products[-k-1]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.__list = []\n        self.__product = []\n    def add(self, num: int) -> None:\n        self.__list.append(num)\n        if num == 0:\n            self.__product = []\n        else:\n            if not self.__product:\n                self.__product = [1]\n\n            self.__product.insert(0, self.__product[0] * num)\n\n    def getProduct(self, k: int) -> int:\n        p = self.__product\n        try:\n            return p[0] // p[k]\n        except IndexError:\n            return 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.last = -1\n        self.pre = [1] * 500000\n        self.n = 0\n        \n    def add(self, num: int) -> None:\n        if num == 0:\n            self.pre[self.n] = 1\n            self.last = self.n\n        else:\n            if self.n == 0:\n                self.pre[self.n] = num\n            else:\n                self.pre[self.n] = self.pre[self.n - 1] * num\n        self.n += 1\n        \n    def getProduct(self, k: int) -> int:\n        l = self.n - k\n        if self.last >= l:\n            return 0\n        # print(self.n - 1, l, self.last)\n        return self.pre[self.n - 1] // self.pre[l - 1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from sortedcontainers import SortedList\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = list()\n        self.prod = list()\n        self.zeros = SortedList()\n        \n\n    def add(self, n:int) -> None:\n        num = 0\n        if n == 0:\n            num = 1\n            self.zeros.add(len(self.prod))\n        else:\n            num = n\n        \n        \n        self.arr.append(num)\n        if len(self.prod) == 0:\n            self.prod.append(num)\n        else:\n            self.prod.append(num * self.prod[-1])\n\n    def getProduct(self, k: int) -> int:\n        \n        idx = len(self.prod)-k\n        \n        if self.zeros.bisect_left(idx) != len(self.zeros):\n            return 0\n        \n        if k == len(self.prod):\n            return self.prod[-1]\n        else:\n            return int(self.prod[-1]/self.prod[len(self.prod)-k-1])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n    def __init__(self):\n        self.index = 0\n        self.prefix = []\n        self.zeroes = []\n        \n    def add(self, num: int) -> None:\n        if num == 0:\n            self.zeroes.append(self.index)\n            num = 1\n            \n        if not self.prefix:\n            self.prefix.append(num)\n        else:\n            self.prefix.append(self.prefix[-1] * num)\n        self.index += 1\n        \n    def getProduct(self, k: int) -> int:\n        #print(self.index, k)\n        if self.zeroes and self.index - k <= self.zeroes[-1]:\n            return 0\n        elif k == len(self.prefix):\n            return self.prefix[-1]\n        else:\n            return self.prefix[-1] // self.prefix[self.index - k - 1]\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.l = list()\n        self.last_zero = 0\n        self.start_ones = 0\n        \n    def add(self, num: int) -> None:\n        \n        if num == 1:\n            self.start_ones +=1\n        else:\n            self.start_ones = 0\n        self.l.insert(0,num)\n        \n        if num == 0:\n            self.last_zero = 0\n        else:\n            self.last_zero += 1\n\n    def getProduct(self, k: int) -> int:\n        \n        \n        if self.last_zero and self.last_zero < k:\n            return 0\n        \n        if self.start_ones > k:\n            return 1\n        \n        r = k\n        if self.start_ones > 0:\n            r -= self.start_ones - 1\n        \n        prod = 1\n        idx = 0\n        #print(self.start_ones,k)\n        for idx in range(r):\n            #print('->',self.l[idx])\n            prod *= self.l[idx] if idx < len(self.l) else 1\n        return prod\n\n\\\"\\\"\\\"\n[\\\"ProductOfNumbers\\\",\\\"add\\\",\\\"getProduct\\\",\\\"getProduct\\\",\\\"add\\\",\\\"getProduct\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"getProduct\\\",\\\"getProduct\\\",\\\"getProduct\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\"]\n[[],[1],[1],[1],[59],[2],[59],[34],[95],[1],[1],[1],[64],[0],[11]]\n[null,null,1,1,null,59,null,null,null,95,95,95,null,null,null]\n\\\"\\\"\\\"    \n    \n# [\\\"ProductOfNumbers\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"add\\\",\\\"getProduct\\\",\\\"getProduct\\\",\\\"getProduct\\\",\\\"getProduct\\\",\\\"add\\\"]\n# [[],[2],[4],[1],[7],[4],[1],[4],[2],[3],[5],[6],[8],[4]]\n# [null,null,null,null,null,null,null,null,null,8,224,224,1792,null]\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.cache = {}\n        \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        \n\n    def getProduct(self, k: int) -> int:\n        tkey = (len(self.nums),k)\n        prod = self.cache.get(tkey, None)\n        if not prod:\n            prod = 1 \n            for n in self.nums[-k:]:\n                if n == 0:\n                    self.cache[tkey] = 0\n                    return 0\n                if n == 1:\n                    continue\n                prod *= n\n            self.cache[tkey] = prod\n        return prod\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.cum_prod = []\n        self.arr = []\n        self.n = 0\n        self.zero_flags = []\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.zero_flags.append(self.n)\n        if len(self.arr) > 0:\n            if self.arr[-1] == 0:\n                self.cum_prod.append(num)\n            else:\n                self.cum_prod.append(num * self.cum_prod[-1])\n        else:\n            self.cum_prod.append(num)\n        self.arr.append(num)\n        self.n += 1\n\n    def getProduct(self, k: int) -> int:\n        if len(self.zero_flags) > 0 and max(self.zero_flags) > self.n-k-1:\n            return 0\n        if len(self.cum_prod) == k:\n            return self.cum_prod[-1]\n        den = self.cum_prod[self.n-k-1]\n        if den == 0:\n            return self.cum_prod[-1]\n        return self.cum_prod[-1]//den\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.c=[1 for i in range(40000)]\n        self.size=0\n        self.z=-1\n        \n    def add(self, num: int) -> None:\n        if(num==0):\n            num=1\n            self.z=self.size\n        if(self.size==0):\n            self.c[0]=num\n            self.size+=1\n            return\n        self.c[self.size]*=self.c[self.size-1]*num\n        self.size+=1\n\n    def getProduct(self, k: int) -> int:\n        if(self.size-self.z<=k):\n            return 0\n        return self.c[self.size-1]//self.c[self.size-k-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.arr = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.arr = [1]\n        else:\n            self.arr.append(self.arr[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        if k > len(self.arr)-1: \n            return 0\n        else:\n            return int(self.arr[-1]/self.arr[-k-1])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.array = []\n        self.product = []\n\n    def add(self, num: int) -> None:\n        self.array.append(num)\n        if len(self.product) > 0:\n            i = 0\n            if num == 0:\n                self.product = [0] * len(self.product)\n            else:\n                while num != 1 and i < len(self.product) and self.product[i] != 0:\n                    self.product[i] *= num\n                    i += 1\n            self.product.insert(0, num)\n        elif len(self.product) == 0:\n            self.product.append(num)\n\n        \n    def getProduct(self, k: int) -> int:\n        return self.product[k - 1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.queue = [1]\n        self.zeroes = []\n\n    def add(self, num: int) -> None:\n        prev = 1 if not self.queue or self.queue[-1]==0 else self.queue[-1]\n        self.queue.append(prev*num)\n        if num == 0: self.zeroes.append(len(self.queue)-1)\n\n    def getProduct(self, k: int) -> int:\n        p = max (0, len(self.queue)-k-1)\n        for idx in self.zeroes:\n            if p < idx < len(self.queue): \n                return 0\n        #print(self.queue,self.queue[p])\n        if self.queue[p] != 0:\n            return self.queue[-1] // self.queue[p]\n        return self.queue[-1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "from sortedcontainers import SortedList\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.product = []\n        self.zero_index = []\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.zero_index.append(len(self.product))\n\n        if len(self.product) == 0:\n            self.product.append(num)\n            return\n        tail = self.product[len(self.product) - 1]\n        if tail == 0:\n            self.product.append(num)\n        else:\n            self.product.append(num * tail)\n\n    # TODO: essentially need to get the closest 0 that's greater than len(self.product) - k - 1\n    def getProduct(self, k: int) -> int:\n        to_look = len(self.product) - k - 1\n\n        if to_look < 0:\n            if not self.zero_index:\n                return self.product[len(self.product)-1]\n            else:\n                return 0\n        \n        # now check whether or not there is a zero after the to_look index\n        sorted_list = SortedList(self.zero_index)\n        to_be_inserted = sorted_list.bisect_left(to_look+1)\n        # TODO: i think this logic here is kind of wrong\n        if to_be_inserted != 0 and to_be_inserted < len(self.zero_index):\n            return 0\n        elif to_be_inserted == 0:\n            if self.zero_index:\n                return 0\n\n        # check whether or not to_look_index is 0 or not\n        if self.product[to_look] == 0:\n            return self.product[len(self.product)-1]\n\n        return self.product[len(self.product)-1] // self.product[to_look]\n\n\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.cum_prod = []\n        self.arr = []\n        self.n = 0\n        self.zero_flags = []\n\n    def add(self, num: int) -> None:\n        #print(\\\"self.arr\\\", self.arr)\n        if num == 0:\n            self.zero_flags.append(self.n)\n        if len(self.arr) > 0:\n            if self.arr[-1] == 0:\n                self.cum_prod.append(num)\n            else:\n                self.cum_prod.append(num * self.cum_prod[-1])\n        else:\n            self.cum_prod.append(num)\n        self.arr.append(num)\n        self.n += 1\n\n    def getProduct(self, k: int) -> int:\n        #print(\\\"self.cum_prod\\\", self.cum_prod)\n        #print(\\\"0 flags \\\", self.zero_flags)\n        if len(self.zero_flags) > 0 and max(self.zero_flags) > self.n-k-1:\n            return 0\n        if len(self.cum_prod) == k:\n            return self.cum_prod[-1]\n        den = self.cum_prod[self.n-k-1]\n        if den == 0:\n            return self.cum_prod[-1]\n        return self.cum_prod[-1]//den\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        \n        self.arr = []\n        self.ZeroIdx = []\n\n    def add(self, num: int) -> None:\n        \n        n = len(self.arr)\n        \n        if num == 0:\n            self.ZeroIdx.append(n)\n            num = 1\n            \n        if n == 0:\n            self.arr.append(num)\n        else:\n            self.arr.append(self.arr[-1]*num)\n\n    def getProduct(self, k: int) -> int:\n        \n        if k == 0:\n            return 0\n        \n        #0 1 2 3 4\n        \n        n = len(self.arr)\n        \n        for idx in self.ZeroIdx:\n            if idx >= n-k:\n                return 0\n        \n        #print(self.arr)\n        \n        n = len(self.arr) \n        #print(n, k, self.arr[n-1], self.arr[n-k-1])\n        if n == k:\n            return self.arr[n-1]\n        else:\n            return self.arr[n-1]//self.arr[n-k-1]\n            \n        \n        \n        \n        \n        \n    \n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.numbers = []\n        self.cache = {}\n\n    def add(self, num: int) -> None:\n        self.numbers.append(num)\n        self.cache = {}\n\n    def getProduct(self, k: int) -> int:\n        if k not in self.cache:\n            self.cache[k] = math.prod(self.numbers[-k:])\n        return self.cache[k]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.length = 0\n        self.prefix = [1]\n        self.zeroPosition = []\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.zeroPosition.append(self.length)\n            self.prefix.append(self.prefix[-1])\n        else:\n            self.prefix.append(self.prefix[-1] * num)\n        self.length += 1\n\n    def getProduct(self, k: int) -> int:\n        for p in self.zeroPosition:\n            if self.length - k <= p <= self.length - 1:\n                return 0\n        return int(self.prefix[-1] / self.prefix[len(self.prefix) - k - 1])\n        \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "import numpy as np\n\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.nums = []\n        self.prods = np.array([])\n        \n\n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        self.prods = self.prods * num\n        self.prods = np.append(self.prods, num)\n\n    def getProduct(self, k: int) -> int:\n        return int(self.prods[-k])\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n\n    def __init__(self):\n        self.hundreds = list()  \n        self.nums = []\n        self.hund_prods = 1\n        self.hund_res = 0\n        \n        \n    def add(self, num: int) -> None:\n        self.nums.append(num)\n        self.hund_prods *= num\n        self.hund_res += 1\n        if self.hund_res % 100 == 0:\n            self.hundreds.append(self.hund_prods)\n            self.hund_res = 0\n            self.hund_prods = 1\n\n    def prod(self, f, t):\n        ret = 1\n        for x in self.nums[f:t]:\n            ret *= x\n        return ret\n    \n    def getProduct(self, k: int) -> int:\n        prod_tail = 1\n        if k < 100 + self.hund_res:\n            return self.prod(len(self.nums) - k, len(self.nums))\n        else:\n            account = self.hund_res\n            p1 = self.prod(len(self.nums) - self.hund_res, len(self.nums))\n            idx = -1\n            while k - account > 100:\n                account += 100\n                p1 = p1 * self.hundreds[idx]\n                idx = idx -1\n            while account <= k:\n                p1 = p1 * self.nums[-account]\n                account += 1\n            return p1\n                \n            \n            \n            \n            \n            \n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n"]
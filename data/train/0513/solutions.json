["import bisect\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v):\n    pos=bisect.bisect_left(dp,arr[v])\n    changes.append((pos,dp[pos]))\n    dp[pos]=arr[v]\n    ans[v]=bisect.bisect_left(dp,10**18)\n    for u in g[v]:\n        if checked[u]==0:\n            checked[u]=1\n            dfs(u)\n    pos,val=changes.pop()\n    dp[pos]=val\n\n\nn=int(input())\narr=[0]+list(map(int,input().split()))\ng=[[] for _ in range(n+1)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    g[a].append(b)\n    g[b].append(a)\nans=[0]*(n+1)\nchecked=[0]*(n+1)\nchecked[1]=1\ndp=[10**18 for _ in range(n+1)]\nchanges=[]\ndfs(1)\nfor i in range(1,n+1):\n    print(ans[i])", "from bisect import bisect_left\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(200001)\n\nN = int(input())\n\na = list(map(int,input().split()))\n\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n    u,v = map(int,input().split())\n    u -= 1\n    v -= 1\n    graph[u].append(v)\n    graph[v].append(u)\n\nINF = 10**11\nans = [0]*N\ndp = []###INF\u306f\u7a7a\u6b04\u3068\u3057\u3066\u6271\u3063\u3066\u826f\u3044\nstack = deque([])\n\ndef LISonTree(num,pre):\n    ###num: \u9802\u70b9\u756a\u53f7\n    ###pre: 1\u3064\u524d\u306b\u3044\u305f\u9802\u70b9\u756a\u53f7\n    p = bisect_left(dp,a[num])\n\n    ###\n    #print(p)\n    ###\n\n    if p >= len(dp):\n        stack.appendleft((len(dp),INF))\n        dp.append(a[num])\n    else:\n        stack.appendleft((p,dp[p]))\n        dp[p] = a[num]\n        \n    \n    q = bisect_left(dp,INF)\n    ans[num] = q\n\n    ###\n    #print(num,'dp',dp)\n    #print(num,'ans',ans)\n    ###\n\n    for x in graph[num]:\n        if x == pre:\n            continue\n        LISonTree(x,num)\n    \n    changed_p, changed_v = stack.popleft()\n\n    dp[changed_p] = changed_v\n\n    ###\n    #print(num,'dp',dp)\n    ###\n\nLISonTree(0,-1)\n#print(ans)\n\nfor y in ans:\n    print(y)", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    from bisect import bisect_left\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    G = [[] for _ in range(N)]\n\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        G[u].append(v)\n        G[v].append(u)\n\n    root = 0\n    stack = [root]\n    visited = set()\n    visited.add(root)\n    done = set()\n    vs = []\n\n    ans = [0] * N\n    memo = [None] * N\n    memo[root] = (0, A[root])\n\n    INF = 10 ** 10\n    dp = [INF] * N\n\n    while stack:\n        now_ = stack[-1]\n        if now_ in done:\n            j, a = memo[now_]\n            dp[j] = a\n            stack.pop()\n            vs.append(now_)\n        else:\n            for next_ in G[now_][::-1]:\n                if next_ in visited:\n                    continue\n                visited.add(next_)\n                stack.append(next_)\n            done.add(now_)\n\n            tmp = bisect_left(dp, A[now_])\n            memo[now_] = (tmp, dp[tmp])\n            dp[tmp] = A[now_]\n            ans[now_] = bisect_left(dp, INF)\n\n    # print (vs)\n    print (*ans, sep = '\\n')\n\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations\ndef run():\n    N = int(input())\n    A = [0] + list(map(int, sysread().split()))\n    to = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u,v = map(int, sysread().split())\n        to[u].append(v)\n        to[v].append(u)\n    seen = [False] * (N+1)\n    dp = [float('inf')] * (N+2)\n    dp[0] = -float('inf')\n    ddp2 = [0]\n    paths = []\n    actions = []# (idx, pre, pro)\n    ans = [0] * (N+1)\n    def dfs(node, parent=None):\n\n        a = A[node]\n        seen[node] = True\n        if parent == None:\n            actions.append((1, dp[1], a, 1))\n            dp[1] = a\n            ddp2[0] += 1\n        else:\n            idx = bin_search(dp, a)\n            if dp[idx] == float('inf'):\n                actions.append((idx, dp[idx], a, 1))\n                ddp2[0] += 1\n            else:\n                actions.append((idx, dp[idx], a, 0))\n            dp[idx] = a\n        ans[node] = ddp2[0]\n        for next in to[node]:\n            if not seen[next]:\n                dfs(next, node)\n\n        idx, pre, pro, change = actions.pop()\n        dp[idx] = pre\n        ddp2[0] -= change\n\n    dfs(1)\n    for s in ans[1:]:\n        print(s)\n    return None\n\ndef bin_search(A, x):\n    '''\n    return index which is lowest in values more than or equal to x\n    '''\n    low = 0\n    high = len(A) - 1\n    c = (low + high) // 2\n    if A[-1] < x: return float('inf')\n    while high - low > 1:\n        if A[c] < x:\n            low = c\n            c = (low + high) // 2\n\n        elif A[c] > x:\n            high = c\n            c = (high + low) // 2\n        else:\n            return c\n    return high\n\ndef __starting_point():\n    run()\n__starting_point()", "from bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10 ** 9)\nn = int(input())\na = list(map(int, input().split()))\n\nresult = [-1 for _ in range(n)]\ntree = [[] for _ in range(n)]\nfor _i in range(n-1):\n    u, v = map(int, input().split())\n    u, v = u-1, v-1\n    tree[u].append(v)\n    tree[v].append(u)\nINF = float('inf')\ndp = [INF for _i in range(n+1)]\n\n\ndef dfs(p, x):\n    i = bisect_left(dp, a[p])\n    old = dp[i]\n    dp[i] = a[p]\n    result[p] = bisect_left(dp, INF)\n    for j in tree[p]:\n        if j != x:\n            dfs(j, p)\n    dp[i] = old\n    \n\ndfs(0, -1)\n\nfor i in result:\n    print(i)", "n = int(input())\na = list(map(int, input().split()))\n\nuv = [[] for _ in range(n)]\nfor _ in range(n-1):\n    i, j = map(int, input().split())\n    uv[i-1].append(j-1)\n    uv[j-1].append(i-1)\n\n# DFS\n# \u9802\u70b9i\u304c\u672a\u63a2\u7d22\u306e\u6642\u3001ans[i] = -1\nans = [-1 for _ in range(n)]\nans[0] = 1\n# dp[i] = \u9577\u3055i+1\u306eLIS\u306e\u6700\u5f8c\u5c3e\u306e\u6700\u5c0f\u5024\ndp = [a[0]]\n# history[(i, j)]\u306e\u3068\u304d\u3001\u5909\u66f4\u524d\u306fdp[i] = j\n# stack\u3068\u3057\u3066\u4f7f\u7528\nhistory = []\n# \u9802\u70b9parents[i] = i\u306e\u89aa\nparents = [-1 for _ in range(n)]\n\ntodo = []\nfor i in uv[0]:\n    todo.append(i)\n    parents[i] = 0\n\nwhile True:\n    i = todo.pop(-1)\n    \n    # ans[i]\u3092\u6c42\u3081\u308b\n    if dp[-1] < a[i]:\n        dp.append(a[i])\n        history.append((-1, 0))\n    else:\n        # dp\u306e\u5909\u66f4\u70b9\u3092\u4e8c\u5206\u63a2\u7d22\n        start = 0\n        stop = len(dp) - 1\n        flag = True\n        while start < stop:\n            center = (start + stop) // 2\n            if dp[center] < a[i]:\n                start = center + 1\n            elif dp[center] > a[i]:\n                stop = center\n            else:\n                flag = False\n                break\n        if flag and dp[start] > a[i]:\n            history.append((start, dp[start]))\n            dp[start] = a[i]\n        else:\n            history.append((-2, 0))\n    ans[i] = len(dp)\n\n    # todo\u306b\u8ffd\u52a0\n    for j in uv[i]:\n        if ans[j] == -1:\n            todo.append(j)\n            parents[j] = i\n\n    if len(todo) == 0:\n        break\n\n    # back\n    j = i\n    while parents[todo[-1]] != j:\n        k = history.pop(-1)\n        if k[0] == -2:\n            None\n        elif k[0] == -1:\n            dp.pop(-1)\n        else:\n            dp[k[0]] = k[1]\n        j = parents[j]\n\nfor i in ans:\n    print(i)", "import sys\nimport bisect\nimport collections\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    UV = [[int(x) for x in input().split()] for _ in range(N - 1)]\n\n    T = [[] for j in range(N + 1)]\n\n    for u, v in UV:\n        T[u].append(v)\n        T[v].append(u)\n\n    s = collections.deque()\n\n    lis = []\n    s.append([1, lis])\n\n    v = set()\n\n    ans = [0] * (N + 1)\n    memo = [[] for j in range(N + 1)]\n\n    while s:\n        c = s[-1]\n        ci, clis = c[0], c[1]\n\n        # lis\u51e6\u7406\n        if ci not in v:\n            if len(clis) == 0:\n                clis.append(A[ci - 1])\n                memo[ci].append(-1)\n            else:\n                if clis[-1] < A[ci - 1]:\n                    clis.append(A[ci - 1])\n                    memo[ci].append(-1)\n                else:\n                    i = bisect.bisect_left(clis, A[ci - 1])\n                    memo[ci].append(i)\n                    memo[ci].append(clis[i])\n                    clis[i] = A[ci - 1]\n\n            v.add(ci)\n            ans[ci] = len(clis)\n\n        if len(T[ci]) >= 1:\n            n = T[ci].pop()\n            if n in v:\n                continue\n            s.append([n, clis])\n            continue\n\n        if memo[ci][0] == -1:\n            if len(clis) >= 1:\n                clis.pop()\n        else:\n            clis[memo[ci][0]] = memo[ci][1]\n\n        s.pop()\n\n    for i in range(1, N + 1):\n        print((ans[i]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nI = [int(_) for _ in open(0).read().split()]\nN = I[0]\nA = [0] + I[1:1 + N]\nU = [0] + I[1 + N::2]\nV = [1] + I[2 + N::2]\nG = [set() for _ in range(N + 1)]\nfor u, v in zip(U, V):\n    G[u].add(v)\n    G[v].add(u)\nans = [10**10] * (N + 1)\nstack = [(0, 1, 1, A[1], 0)]\ndp = [-10 ** 10] + [10 ** 10] * N\nwhile stack:\n    i, j, p, q, d = stack.pop()\n    if d:\n        dp[p] = q\n        continue\n    stack += [(j, i, p, dp[p], 1)]\n    dp[p] = q\n    ans[j] = bisect.bisect_left(dp, 10 ** 10) - 1\n    while G[j]:\n        k = G[j].pop()\n        if i == k:\n            continue\n        q = A[k]\n        p = bisect.bisect_left(dp, q)\n        stack += [(j, k, p, q, 0)]\nprint(*ans[1:], sep='\\n')\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**7)\nfrom pprint import pprint as pp\nfrom pprint import pformat as pf\n\nimport math\nimport bisect\n\nclass Tree:\n    \"\"\"\n    node id starts from 1\n    \"\"\"\n\n    DUMMY = 0 # used as dummy_node_id and dummy_node_value\n\n    def __init__(self, num_node, node_values):\n        self.node_values = [-1] + node_values # [0] is dummy\n        self.edges = [None] * (num_node + 1) # [0] is dummy, var[a] = set of links\n        for i, _ in enumerate(self.edges):\n            self.edges[i] = set()\n        self.seq = [self.DUMMY] * num_node\n\n        self.dp = [math.inf] * (num_node + 1)\n        self.dp[0] = -1 * math.inf\n        self.ans = [0] * (num_node + 1) # [0] is dummy\n\n\n    def node_values(self, node_values):\n        self.node_values = [-1] + node_values # [0] is dummy\n\n    def make_edge(self, a, b):\n        self.edges[a].add(b)\n        self.edges[b].add(a)\n\n    def dps(self, node_id, prev=0, depth=0):\n        # process\n        value = self.node_values[node_id]\n        key = bisect.bisect_left(self.dp, value)\n        old_value = self.dp[key]\n        self.dp[key] = value\n        self.ans[node_id] = max(key, self.ans[prev])\n        # recursive\n        for to in self.edges[node_id]:\n            if to == prev:\n                continue\n            self.dps(to, node_id, depth + 1)\n        # recursive back\n        self.dp[key] = old_value\n\ndef __starting_point():\n    num_node = int(input())\n    node_values = list(map(int, input().split()))\n    tree = Tree(num_node, node_values)\n    for i in range(num_node - 1):\n        frm, to = list(map(int, input().split()))\n        tree.make_edge(frm, to)\n    tree.dps(1)\n    for a in tree.ans[1:]:\n        print(a)\n\n\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**8)\nN = int(input())\nA = list(map(int,input().split()))\nUV = [tuple(map(int,input().split())) for i in range(N-1)]\nes = [[] for _ in range(N)]\nfor u,v in UV:\n    u,v = u-1,v-1\n    es[u].append(v)\n    es[v].append(u)\n\nfrom bisect import bisect_left\nlis = [A[0]]\nstack = []\nans = [1] * N\ndef dfs(v,p=-1):\n    for to in es[v]:\n        if to==p: continue\n        i = bisect_left(lis, A[to])\n        if i == len(lis):\n            stack.append((i,-1))\n            lis.append(A[to])\n        else:\n            stack.append((i,lis[i]))\n            lis[i] = A[to]\n        ans[to] = len(lis)\n\n        dfs(to,v)\n\n        i,a = stack.pop()\n        if a < 0:\n            lis.pop()\n        else:\n            lis[i] = a\n\ndfs(0)\nprint(*ans, sep='\\n')", "import sys\nimport bisect  # \u4e8c\u5206\u6cd5\n\n\nMAX_N = 200005\nINF = 10**9 + 5\n\nsys.setrecursionlimit(MAX_N)\n\nN = int(sys.stdin.readline())\nA = [int(x) for x in sys.stdin.readline().split()]\nE = [[] for _ in range(N)]  # \u8fba\u306e\u60c5\u5831\n\nfor _ in range(N-1):\n    u, v = map(int, sys.stdin.readline().split())\n    E[u-1].append(v-1)\n    E[v-1].append(u-1)\n\nlis = [INF] * N\nans = [0] * N \n\ndef dfs(u,r=-1):\n\n    # u \u3092\u8a2a\u308c\u305f\u3068\u304d\u306e\u51e6\u7406\n    i = bisect.bisect_left(lis, A[u])  # \n    old = lis[i]  # \u66f8\u304d\u63db\u3048\u524d\u306e\u5024\u3092\u4e00\u6642\u4fdd\u5b58\n    lis[i] = A[u]\n\n    for v in E[u]:\n        if v == r: continue  # \u89aa\u306f\u7121\u8996\n\n        dfs(v,u)\n    \n    ans[u] = bisect.bisect_left(lis,INF-1)\n    lis[i] = old  # \u66f8\u304d\u63db\u3048\u524d\u306e\u72b6\u614b\u306b\u623b\u3059\n\ndfs(0)\nfor i in range(N):\n    print(ans[i])", "# LIS on Tree\n\nfrom collections import deque\nimport bisect\nimport sys\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nV = list(map(int, input().split()))\nV.insert(0, 0)\nvisited = [False for i in range(N+1)]\ninf = 10**18\ndp = [inf for i in range(N+1)]\nans = [-1 for i in range(N+1)]\nstack = deque()\n\nG = [[] for i in range(N+1)]\nfor _ in range(N-1):\n    u, v = map(int, input().split())\n    G[u].append(v)\n    G[v].append(u)\n\n\ndef dfs(s_node):\n    visited[s_node] = True\n    # dp\u5024\u306e\u66f4\u65b0\n    value = V[s_node]\n    index = bisect.bisect_left(dp, value)\n    old_value = dp[index]\n    dp[index] = value\n    ans[s_node] = bisect.bisect_right(dp, inf-1)\n    stack.append((index, old_value, value))\n    for child in G[s_node]:\n        if visited[child] == False:\n            dfs(child)\n    # \u5e30\u308a\u304c\u3051\u306b\u30d0\u30c3\u30af\u30c8\u30e9\u30c3\u30af\u3092\u884c\u3046\n    index, old_value, value = stack.pop()\n    dp[index] = old_value\n\n\ndfs(1)\n\nfor i in range(1, N+1):\n    print(ans[i])", "import sys\nsys.setrecursionlimit(1000000)\nfrom bisect import bisect, bisect_left\ndef dfs(vertex):\n  visited[vertex] = True\n  value = a[vertex]\n  j = bisect(dp, value)\n  previous = dp[j]\n  if dp[j-1] != value: # strict increasing\n    dp[j] = value\n  ans[vertex] = bisect_left(dp, float(\"inf\"))-1\n  for node in adjacent[vertex]:\n    if not visited[node]:\n      dfs(node)\n  dp[j] = previous\n  return\nn = int(input())\na = list(map(int, input().split()))\nadjacent = {i: [] for i in range(n)}\nfor _ in range(n-1):\n  node1, node2 = map(int, input().split())\n  node1 -= 1\n  node2 -= 1\n  adjacent[node1].append(node2)\n  adjacent[node2].append(node1)\nvisited = [False]*n\nans = [0]*n\ndp = [float(\"inf\") for _ in range(n+1)]\ndp[0] = float(\"-inf\")\ndfs(0)\n[print(value) for value in ans]", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nN = int(input())\nA = list(map(int, input().split()))\nG = [[] for _ in range(N)]\n\nfor i in range(N-1):\n  a,b = list(map(int, input().split()))\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n\nINF = 10**9+1\n\n#a = [~0,0]\nq = [0]    # ~0=-1\u306a\u306e\u3060\u304c\u3001\u3068\u306b\u304b\u304f0\u3092\u6253\u3061\u6d88\u3059\u65b9\u5411\u3092\u3084\u308b\u3088\u3001\u3068\u8a00\u3046\u3053\u3068\u3002\u3046\u307e\u3044\u3002\ndp = [INF]*N  # LIS\nans = [0]*N   # i\u306b\u304a\u3051\u308bLIS\u306e\u9577\u3055\nlis_len = 0   # \u6301\u3061\u56de\u3063\u3066\u308bLIS\u9577\u3055\u5909\u6570\u3002dp\u3092search\u3057\u3066\u3082\u6c42\u307e\u308b\u3051\u3069\u3001\u5b89\u6613\u306b\u91ce\u90ce\nidx = [-1]*N  # i\u306e\u3068\u304d\u306e\u64cd\u4f5c\u3057\u305fIDX\nold = [-1]*N  # i\u306e\u3068\u304d\u306b\u64cd\u4f5c\u3059\u308b\u524d\u306e\u5024\u3002Rollback\u3059\u308b\u6642\u306b\u4f7f\u3046\nprev = [-1]*N # \u81ea\u5206\u306e\u547c\u3073\u51fa\u3057\u3082\u3068\u3002\u30b0\u30e9\u30d5\u306e\u884c\u3063\u3066\u3053\u3044\u3092\u6291\u6b62\u3059\u308b\u305f\u3081\u3002\n\nss = 0\nfrom bisect import bisect_left\nwhile q:\n  now = q.pop()\n  # \u666e\u901a\u306edfs\n  if now >= 0:\n    a = A[now]\n    # LIS\u7ba1\u7406\u306edp\u306b\u4eca\u56de\u64cd\u4f5c\u3059\u308b\u5bfe\u8c61\u306eIDX\u3092\u63a2\u7d22\n    idx[now] = bisect_left(dp,a)\n    # \u64cd\u4f5c\u524d\u306e\u5024\u3068IDX\u3092\u4fdd\u5b58\u3059\u308b\n    iv = idx[now]\n    old[now] = dp[idx[now]]\n    x = old[now]\n    # LIS\u7ba1\u7406dp\u306eVALUE\u304cINF\u3060\u3063\u305f\u3089\u3001\u4eca\u56de\u3067\u9577\u3055\u304c\u4f38\u3073\u308b\u3063\u3066\u3053\u3068\n    if x == INF:\n      lis_len += 1\n    dp[iv] = a\n    ans[now] = lis_len\n\n    for nxt in G[now]:\n      if nxt == prev[now]:\n        continue\n      prev[nxt] = now\n      #q.append(~nxt)\n      #q.append(nxt)\n      q.append((-1)*nxt)\n      q.append(nxt)\n  # now\u304c\u30bc\u30ed\u4ee5\u4e0b\u306a\u306e\u3067\u3001DP\u3092\u4e00\u3064Rollback\u3059\u308b\u52d5\u304d\u3092\u3059\u308b\u3002\n  else:\n    #v = ~v # \u30d3\u30c3\u30c8\u53cd\u8ee2\u3060\u304c\u3001\u3053\u308c\u3067\u5143\u306eNOW\u3092\u5fa9\u5143\u3059\u308b\n    now = (-1)*now\n    dp[idx[now]] = old[now]\n    x = dp[idx[now]] \n    if x == INF:\n      lis_len -= 1\n    \n#print(*ans,sep=\"\\n\")\nfor a in ans:\n  print(a)\n", "# \u6728\u306b\u3088\u3063\u3066LIS\u3092\u4f5c\u308a\u3001dfs\u3067\u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u305d\u306e\u524d\u306e\u72b6\u614b\u307e\u3067\u5fa9\u5143\u3059\u308b\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina1(x):\n    return int(x) - 1\n\n\ndef read_ints(mina=False):\n    if mina:\n        return list(map(mina1, read().split()))\n    else:\n        return list(map(int, read().split()))\n\n\ndef read_a_int():\n    return int(read())\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nN = read_a_int()\nA = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in ra(N - 1):\n    u, v = read_ints(mina=True)\n    tree[u].append(v)\n    tree[v].append(u)\n\nLIS = []\nans = [0] * N  # \u5404\u30ce\u30fc\u30c9\u306elen(LIS)\u3092\u8a18\u9332\n\n\ndef dfs(now, p):  # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3001\u89aa\n    a = A[now]\n    # LIS\u306e\u66f4\u65b0\n    idx = bisect_left(LIS, a)\n    is_append = False\n    if idx == len(LIS):\n        LIS.append(a)\n        is_append = True\n    else:\n        old = LIS[idx]   # \u306a\u3093\u306e\u5024\u3060\u3063\u305f\u304b\u6301\u3063\u3066\u304a\u304f\n        LIS[idx] = a  # a\u306b\u66f4\u65b0\n\n    ans[now] = len(LIS)  # \u7b54\u3048\u3092\u8a18\u9332\n    # \u6b21\u306e\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\n    for to in tree[now]:\n        if to == p:\n            continue\n        dfs(to, now)\n\n    # \u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u5fa9\u5143\n    if is_append:\n        del LIS[idx]\n    else:\n        LIS[idx] = old\n\n\ndfs(0, -1)\nprint(*ans, sep='\\n')\n", "# coding: utf-8\nimport sys\nfrom bisect import bisect_left, bisect_right, insort\nsys.setrecursionlimit(10 ** 7)\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nA = [0] + lr()  # 1-indexed\ngraph = [[] for _ in range(N+1)]  # 1-indexed\nfor _ in range(N-1):\n    a, b = lr()\n    graph[a].append(b)\n    graph[b].append(a)\n\nanswer = [0] * (N+1)  # 1-indexed\nINF = 10 ** 10\nparent = [-1] * (N+1)\n\ndef dfs(n):\n    \"\"\"answer\u306e\u30ea\u30b9\u30c8\u3092\u66f4\u65b0\u3057\u3066\u304b\u3089dfs\u3057\u3066\u3001old\u3067\u623b\u3059\"\"\"\n    i = bisect_left(dp, INF)\n    answer[n] = i\n    for c in graph[n]:\n        if c == parent[n]:\n            continue\n        parent[c] = n\n        i = bisect_left(dp, A[c])\n        old = dp[i]\n        dp[i] = A[c]\n        dfs(c)\n        dp[i] = old\n\ndp = [INF] * (N+1)\ndp[0] = A[1]\ndfs(1)\nfor a in answer[1:]:\n    print(a)\n", "N=int(input())\nA=list(map(int,input().split()))\nUV=[list(map(int,input().split())) for i in range(N-1)]\nc=[[] for i in range(N)]\nfor i,j in UV:\n    c[i-1].append(j-1)\n    c[j-1].append(i-1)\nv=[0]*N\nd=[10**9+1]*N\nstk=[]\nans=[0]*N\nfrom bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10**9)\ndef dfs(p,l):\n    i=bisect_left(d,A[p])\n    stk.append((i,d[i]))\n    d[i]=A[p]\n    if i==l:\n        l+=1\n    ans[p]=l\n    for n in c[p]:\n        if v[n]==0:\n            v[n]=1\n            dfs(n,l)\n    i,x=stk.pop()\n    d[i]=x\nv[0]=1\ndfs(0,0)\nprint(*ans,sep='\\n')", "#!python3\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\nimport numpy as np\n\n\nINF = 10 ** 10\n\n# input\nN = int(input())\nA = list(map(int, input().split()))\nuv = [list(map(int, input().split())) for _ in range(N - 1)]\n\n# link\nlink = [[] for _ in range(N + 1)]\nfor u, v in uv:\n    link[u].append(v)\n    link[v].append(u)\n\n\ndef dfs(l, dp, pre, v):\n    # LIS\n    idx = np.searchsorted(dp, A[v - 1])\n    l[v] = max(idx, l[pre])\n    bef = dp[idx]\n    dp[idx] = A[v - 1]\n    \n    for x in link[v]:\n        if x != pre:\n            dfs(l, dp, v, x)\n\n    dp[idx] = bef\n\n\ndef main():\n    l = [0] * (N + 1)\n    dp = np.full(N + 1, INF)\n    dp[0] = 0\n    dfs(l, dp, 0, 1)\n    for ans in l[1:]:\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\nfrom bisect import bisect_left as bl\ndef main(n,a):\n  ans=[0]*n\n  ki=[[] for _ in range(n)]\n  for _ in range(n-1):\n    u,v=map(int,input().split())\n    u,v=u-1,v-1\n    ki[u].append(v)\n    ki[v].append(u)\n  inf=float('inf')\n  p={}\n  dp=[inf]*(n+1)\n  dp[0]=0\n  # dp[i]:\u9577\u3055i\u306eLIS\u306e\u672b\u5c3e\u306e\u6570\u5024\u306e\u6700\u5c0f\u5024\n  maxa=max(a)+1\n\n  def dfs(v,p,dp):\n    x=a[v]\n    idx=bl(dp,x)\n    tmp=dp[idx]\n    dp[idx]=x\n    # ans[v]=idx \u3053\u3063\u3061\u3060\u3068\u9802\u70b9v\u3067\u7d42\u308f\u308bLIS\u306e\u9577\u3055\u306b\u306a\u308b\u3002\u4e0b\u304c\u6b63\u3057\u3044\n    ans[v]=bl(dp,maxa)-1\n    for nv in ki[v]:\n      if nv==p:continue\n      dfs(nv,v,dp)\n    dp[idx]=tmp\n  dfs(0,-1,dp)\n  print(*ans,sep='\\n')\n\nn=int(input())\na=list(map(int,input().split()))\nmain(n,a)\n", "#MLE\u6ce8\u610f\uff010\u30841\u306e\u30b1\u30fc\u30b9\u306b\u6ce8\u610f\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n    from math import gcd\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    adj = [[] for _ in range(n)] #\u9802\u70b9\u6570, \u5834\u5408\u306b\u3088\u3063\u3066\u5909\u3048\u308b\n    for _ in range(n-1):\n        c,b = list(map(int, input().split()))\n        adj[c-1].append(b-1)\n        adj[b-1].append(c-1)\n\n    # \u9802\u70b91\u3082\u542b\u3080\n    res = [0]*n\n    res[0] = 1\n\n    def dfs(v, par, L):\n        if v != 0:\n            if a[v] > L[-1]:\n                temp = -1\n                L.append(a[v])\n            else:\n                temp = bisect_left(L, a[v])\n                pre = L[temp]\n                L[temp] = a[v]\n        res[v] = len(L)\n        for nv in adj[v]:\n            if nv == par:\n                continue\n            dfs(nv, v, L)\n        if v != 0:\n            if temp == -1:\n                L.pop(-1)\n            else:\n                L[temp] = pre\n\n    L = [a[0]]\n    dfs(0, -1, L)\n    for i in range(n):\n        print((res[i]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\n\nN = int(input())\nA = list(map(int, input().split()))\n\nedges = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    fr, to = map(int, input().split())\n    edges[fr].append(to)\n    edges[to].append(fr)\n\norder = []\nparent = [-1] * (N + 1)\nst = [1]\nwhile st:\n    now = st.pop()\n    order.append(now)\n    if now > 0:\n        st.append(-now)\n        for to in edges[now]:\n            if to == parent[now]:\n                continue\n            st.append(to)\n            parent[to] = now\n\nL = [-10**18]\nans = [-1] * (N + 1)\nst = [(-1, -1)] * (N + 1)\n\nfor now in order:\n    if now < 0:\n        val, idx = st[-now]\n        if val == -1:\n            L.pop()\n        if val > 0:\n            L[idx] = val\n        continue\n\n    a = A[now - 1]\n    i = bisect_left(L, a)\n\n    if len(L) == i:\n        L.append(a)\n    else:\n        st[now] = (L[i], i)\n        if L[i] > a:\n            L[i] = a\n\n    ans[now] = len(L) - 1\n\nprint(*ans[1:], sep='\\n')\n", "from bisect import bisect_left\nfrom collections import defaultdict as dd\nN = int(input())\nAs = list(map(int, input().split()))\nEs = dd(dict)\nfor _ in range(N-1):\n    f, t = list(map(int, input().split()))\n    Es[f-1][t-1] = Es[t-1][f-1] = 1\n\nINF = float('inf')\nRET = 0\nPROC = 1\n\nstack = []\nlismin = [INF] * N\nanss = [INF] * N\nvisited = [False] * N\n\nstack.append((RET, 0, INF))\nstack.append((PROC, 0, 0))\nwhile stack:\n    cmd, *v = stack.pop()\n    if cmd == RET:\n        i, backup = v\n        lismin[i] = backup\n    else:\n        node, i = v\n        lismin[i] = As[node]\n        anss[node] = bisect_left(lismin, INF)\n        visited[node] = True\n        for to in list(Es[node].keys()):\n            if not visited[to]:\n                x = bisect_left(lismin, As[to])\n                stack.append((RET, x, lismin[x]))\n                stack.append((PROC, to, x))\nfor ans in anss:\n    print(ans)\n\n", "from bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\ndef solve(G, a, lis, pre, p, ans):\n    target = a[p]\n    idx = bisect_left(lis, target)\n    frm = lis[idx]\n    to = target\n    lis[idx] = to\n    ans[p] = bisect_left(lis, float(\"inf\"))\n    for v in G[p]:\n        if v == pre:\n            continue\n        solve(G, a, lis, p, v, ans)\n    lis[idx] = frm\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    G = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        u, v = u-1, v-1\n        G[u].append(v)\n        G[v].append(u)\n    lis = [float(\"inf\")]*(n+1)\n    ans = [None]*n\n    solve(G, a, lis, -1, 0, ans)\n    for v in ans:\n        print(v)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(200000)\nfrom collections import deque\nfrom bisect import bisect_left\n\nN = int(input())\nA = list(map(int, input().split()))\nadj = [[] for i in range(N)]\nfor i in range(N - 1):\n\tu, v = map(int, input().split())\n\tadj[u - 1].append(v - 1)\n\tadj[v - 1].append(u - 1)\n\n\nINF = 10 ** 10\ndone = [False] * N\ndone[0] = True\nlisdp = [INF] * N\nlisdp[0] = A[0]\nchange = [[-1, INF] for i in range(N)] #index, original\nchange[0] = [0, INF]\nlisl = [0] * N\nlisl[0] = 1\n\ndef dfs(v):\n\tfor nv in adj[v]:\n\t\tif done[nv]:\n\t\t\tcontinue\n\t\tdone[nv] = True\n\t\tind = bisect_left(lisdp, A[nv])\n\t\tori = lisdp[ind]\n\t\tchange[nv] = [ind, ori]\n\t\tif ori == INF:\n\t\t\tlisl[nv] = lisl[v] + 1\n\t\telse:\n\t\t\tlisl[nv] = lisl[v]\n\t\tlisdp[ind] = A[nv]\n\t\tdfs(nv)\n\tlisdp[change[v][0]] = change[v][1]\n\ndfs(0)\nfor i in range(N):\n\tprint(lisl[i])\t", "#import numpy as np\n#import math\n#from decimal import *\n#from numba import njit\nfrom bisect import bisect_left\n\n#@njit\ndef main():\n    N = int(input())\n    a = list(map(int, input().split()))\n    edges = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u,v = list(map(int, input().split()))\n        edges[u] += v,\n        edges[v] += u,\n\n    ans = [0]*(N+1)\n    lastLis = []\n    visited = [False]*(N+1)\n    parent = {}\n    n = 1\n    stack = []\n    while True:\n        #print(n, lastLis, stack)\n        if not visited[n]:\n            if len(lastLis) == 0 or a[n-1] > lastLis[-1]:\n                lastLis.append(a[n-1])\n                stack += (len(lastLis)-1, -1),\n            else:\n                index = bisect_left(lastLis, a[n-1])\n                stack += (index, lastLis[index]),\n                lastLis[index] = a[n-1]\n            ans[n] = len(lastLis)\n            visited[n] = True\n        hasNext = False\n        for d in edges[n]:\n            if not visited[d]:\n                parent[d] = n\n                n = d\n                hasNext = True\n        if not hasNext:\n            if n == 1:\n                n = 0\n                break\n            n = parent[n]\n            # \u5dfb\u304d\u623b\u3057\n            index, value = stack.pop(len(stack)-1)\n            if value < 0:\n                lastLis.pop(index)\n            else:\n                lastLis[index] = value\n\n    for i in range(1, len(ans)):\n        print((ans[i]))\n\n\n\n\nmain()\n", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10000000)\n\nfrom bisect import bisect_left,bisect_right\nn=int(input())\na=list(map(int,input().split()))\nedge=[[]for i in range(n)]\nfor i in range(n-1):\n  u,v=map(int,input().split())\n  edge[u-1].append(v-1)\n  edge[v-1].append(u-1)\nans=[-1]*n\ndp=[10**18]*n\n\n#\u30aa\u30a4\u30e9\u30fc\u30c4\u30a2\u30fc\n#n=\u9802\u70b9\u6570\u3001s=\u59cb\u70b9\u3001edge=\u96a3\u63a5\u30ea\u30b9\u30c8\ndef EulerTour(n,s,e):\n  EulerTour_list=[]\n  def EulerTour_dfs(i,root):\n    EulerTour_list.append(i)\n    idx=bisect_left(dp,a[i])\n    bef=dp[idx]\n    dp[idx]=a[i]\n    ans[i]=bisect_left(dp,10**18)\n    for j in e[i]:\n      if j!=root:\n        EulerTour_dfs(j,i)\n    if root!=-1:\n      EulerTour_list.append(root)\n      dp[idx]=bef\n  EulerTour_dfs(s,-1)\n  return EulerTour_list\n\nEulerTour(n,0,edge)\nprint(*ans,sep=\"\\n\")\n", "from collections import deque\nimport sys\nimport bisect\ndef input(): return sys.stdin.readline().rstrip()\n\nn=int(input())\nA=[0]+list(map(int, input().split()))\n\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nvisited = [-1] * (n+1)\nvisited[0] = 0\nvisited[1] = 1\n\nd = deque()\nd.append(1)\ndp=[10**10]*(n+1)\ndp[0]=0\ndp[1]=A[1]\nupdate_task=[() for _ in range(n+1)]\nupdate_task[1]=(1,0)\nwhile d:\n    v = d[-1]\n    if graph[v] == []:\n        d.pop()\n        index,atai=update_task[v]\n        dp[index]=atai\n    else:\n        i = graph[v].pop()\n        if visited[i] != -1:\n            continue\n        bis = bisect.bisect_left(dp, A[i])\n        update_task[i]=(bis,dp[bis])\n        dp[bis] = A[i]\n        visited[i] = bisect.bisect_left(dp, 10**10-100)-1\n        d.append(i)\n\nprint(*visited[1:], sep=\"\\n\")", "from sys import setrecursionlimit\nfrom bisect import bisect_left\n\nsetrecursionlimit(10 ** 6)\nINF = float(\"inf\")\n\nN, *I = map(int, open(0).read().split())\nA, UV = I[:N], I[N:]\n\nE = [[] for _ in range(N + 1)]\nfor u, v in zip(*[iter(UV)] * 2):\n    E[u - 1].append(v - 1)\n    E[v - 1].append(u - 1)\n\ndp = [INF] * N\nans = [0] * N\ndef dfs(cur, visited):\n    idx = bisect_left(dp, A[cur])\n    pre = dp[idx]\n    dp[idx] = A[cur]\n    ans[cur] = bisect_left(dp, INF)\n    for c in E[cur]:\n        if c != visited:\n            dfs(c, cur)\n    dp[idx] = pre\n\ndfs(0, -1)\nfor a in ans:\n    print(a)", "import sys\nfrom bisect import bisect_left\ndef main():\n    sys.setrecursionlimit(202020)\n    N = int(input())\n    A = [0] + list(map(int, input().split()))\n    G = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = list(map(int, input().split()))\n        G[u].append(v)\n        G[v].append(u)\n    L = [A[1]]\n    Ans = [0] * (N+1)\n    def dfs(v):\n        Ans[v] = len(L)\n        for u in G[v]:\n            G[u].remove(v)\n            Au = A[u]\n            if Au > L[-1]:\n                L.append(Au)\n                dfs(u)\n                del L[-1]\n            else:\n                idx = bisect_left(L, Au)\n                old = L[idx]\n                L[idx] = Au\n                dfs(u)\n                L[idx] = old\n    dfs(1)\n    print((\"\\n\".join(map(str, Ans[1:]))))\n\nmain()\n", "n=int(input())\nA=list(map(int,input().split()))\ng=[[]for i in range(n)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    g[a].append(b)\n    g[b].append(a)\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nlastdp=[10**9+1]*n\nrecode=[[10**9+1]for i in range(n)]\nans=[0]*n\nfrom bisect import bisect_left\ndef rec(me,parent):\n    nonlocal lastdp\n    a=A[me]\n    point=bisect_left(lastdp,a)\n    recode[point].append(a)\n    lastdp[point]=a\n    tmpans=bisect_left(lastdp,10**9+1)\n    ans[me]=tmpans\n\n    for child in g[me]:\n        if child!=parent:\n            rec(child,me)\n\n    recode[point].pop()\n    lastdp[point]=recode[point][-1]\n    return\n\nrec(0,-1)\nprint(*ans,sep='\\n')\n", "import sys\nfrom bisect import bisect_left as bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(2 * 10**6)\n\n\ndef inpl():\n    return list(map(int, input().split()))\n\n\nclass solve:\n    def __init__(self, N):\n        self.ans = [0] * N\n        self.DP = []\n\n    def recur(self, i, pi=-1):\n        # DP\u30c6\u30fc\u30d6\u30eb\u3092\u66f4\u65b0\u3057\u3001\u7b54\u3048\u3092\u6c42\u3081\u308b\u3002\n        # \u307e\u305f\u3001\u5dfb\u304d\u623b\u3059\u5024\u3092\u899a\u3048\u308b\u3002\n        rev_i = bisect(self.DP, self.A[i])\n        if rev_i == len(self.DP):\n            self.DP.append(self.A[i])\n            rev_v = None\n        else:\n            rev_v = self.DP[rev_i]\n            self.DP[rev_i] = self.A[i]\n\n        self.ans[i] = len(self.DP)\n\n        for nv in self.edges[i]:\n            if nv != pi:\n                self.recur(nv, i)\n\n        # \u5dfb\u304d\u623b\u3059\u3002.\n        if rev_v is None:\n            self.DP.pop()\n        else:\n            self.DP[rev_i] = rev_v\n\n        return\n\n\ndef main():\n    N = int(input())\n    S = solve(N)\n    S.A = inpl()\n    S.edges = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = inpl()\n        S.edges[u - 1].append(v - 1)\n        S.edges[v - 1].append(u - 1)\n\n    S.recur(0)\n\n    print(*S.ans, sep='\\n')\n    # print(edges)\n    # print(parent)\n    # print(DPs)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom bisect import bisect_left\nsys.setrecursionlimit(1000000)\nINF = pow(10, 10)\n\nchanged = []\ninput = sys.stdin.readline\nN = int(input())\nA = [int(a) for a in input().split()]\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v = map(int, input().split())\n    Edge[u-1].append(v-1)\n    Edge[v-1].append(u-1)\nLIS = [INF] * N\n\ndef dfs(i, pre, Ans):\n    changeID = bisect_left(LIS, A[i])\n    changed.append((changeID, LIS[changeID]))\n    LIS[changeID] = min(A[i], LIS[changeID])\n    #print(i, LIS)\n    #print(changed)\n    Ans[i] = bisect_left(LIS, INF) \n    for nextN in Edge[i]:\n        if nextN != pre: dfs(nextN, i, Ans)\n    backID, backV = changed.pop()\n    LIS[backID] = backV\n    return 0\n\ndef solve():\n    Ans = [1] * N\n    dfs(0, 0, Ans)\n    print(\"\\n\".join(map(str, Ans)))\n    \n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "from bisect import bisect_left\n\nINF = 10 ** 9\n\nN = int(input())\nAs = list(map(int, input().split()))\n\nadj = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v = map(int, input().split())\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\nans = [0] * N\nLIS = [INF] * (N+1)\nrewinder = []\n\nparent = [-1] * N\nstack = [0]\nwhile stack:\n    node = stack.pop()\n    for next_node in adj[node]:\n        if ans[next_node] == 0:\n            parent[next_node] = node\n            stack.append(next_node)\n\n    while rewinder and rewinder[-1][0] != parent[node]:\n        _, index, prev_value = rewinder.pop()\n        LIS[index] = prev_value\n    \n    index = bisect_left(LIS, As[node])\n    rewinder.append((node, index, LIS[index]))\n    LIS[index] = As[node]\n\n    ans[node] = bisect_left(LIS, INF)\n\nprint(*ans, sep = '\\n')", "import bisect\nimport sys\nsys.setrecursionlimit(10**7)\n\nn = int(input())\na = [0]+list(map(int,input().split()))\nt = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    u,v = map(int,input().split())\n    t[u].append(v)\n    t[v].append(u)\n\nm = 10**18\ndp = [m]*(n+1)\nans = [1]*(n+1)\nchecked = [False]*(n+1)\nchecked[1] = True\nchanges = []\n\ndef search(x):\n    ind = bisect.bisect_left(dp,a[x])\n    changes.append((ind,dp[ind]))\n    dp[ind] = a[x]\n    ans[x] = bisect.bisect_left(dp,m)\n    \n    for i in t[x]:\n        if not checked[i]:\n            checked[i] = True\n            search(i)\n    \n    b,c = changes.pop()\n    dp[b] = c\n    \nsearch(1)\nfor i in ans[1:]:\n    print(i)", "import sys\nimport math\nfrom decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nfrom collections import deque\ndef I(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI2(N): return [list(map(int, sys.stdin.readline().split())) for i in range(N)]\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return sys.stdin.readline().split()\ndef LS2(N): return [sys.stdin.readline().split() for i in range(N)]\ndef FILL(i,h): return [i for j in range(h)]\ndef FILL2(i,h,w): return [FILL(i,w) for j in range(h)]\ndef FILL3(i,h,w,d): return [FILL2(i,w,d) for j in range(h)]\ndef FILL4(i,h,w,d,d2): return [FILL3(i,w,d,d2) for j in range(h)]\ndef sisha(num,digit): return Decimal(str(num)).quantize(Decimal(digit),rounding=ROUND_HALF_UP)\n#'0.01'\u3084'1E1'\u306a\u3069\u3067\u6307\u5b9a\u3001\u6574\u6570\u306b\u623b\u3059\u306a\u3089int\u3092\u304b\u307e\u3059\nMOD = 1000000007\nINF = float(\"inf\")\nsys.setrecursionlimit(10**6+10)\n#input = sys.stdin.readline\nfrom bisect import bisect_left\n\ndef dfs(i,before):\n    nonlocal seq\n    nonlocal ans\n    added  = 0\n\n    #\u73fe\u5728\u5730\u306eA\u306e\u5024\u3092\u3001\u4ee5\u524d\u307e\u3067\u306eseq\u30ea\u30b9\u30c8\u306e\u3069\u3053\u306b\u8ffd\u52a0\u3059\u308b\u304b\u6c7a\u3081\u308b\n    pos = bisect_left(seq,a[i-1])\n    old = seq[pos]\n    seq[pos]=a[i-1]\n    ans[i-1]=bisect_left(seq,INF)\n\n    #\u96a3\u63a5\u3059\u308b\u9802\u70b9\u306b\u95a2\u3057\u3066\u518d\u5e30\n    for u in to[i]:\n        if u==before:\n            continue\n        dfs(u,i)\n\n    #seq\u914d\u5217\u3092\u3082\u3068\u306b\u623b\u3059\n    seq[pos]=old\n\n\nN = I()\na = LI()\nto = [[] for i in range(N+1)]\nto[0] += [1]\nfor i in range(N-1):\n    u,v = MI()\n    to[u].append(v)\n    to[v].append(u)\nseq = [INF]*N\nans = [-1]*N\n\ndfs(1,-1)\n[print(i) for i in ans]\n", "import sys\nsys.setrecursionlimit(10**8)\nfrom bisect import bisect_left, bisect_right\nN = int(input())\nA = list(map(int, input().split()))\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n    a,b = map(int, input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,LIS):\n    if len(edge[v])==0:\n        return\n    for u in edge[v]:\n        if visited[u]==False:\n            visited[u]=True\n            if A[u] > LIS[-1]:\n                LIS.append(A[u])\n                ans[u] = len(LIS)\n                dfs(u,LIS)\n                LIS.pop()\n            else:\n                ind = bisect_left(LIS,A[u])\n                stack = LIS[ind]\n                LIS[ind] = A[u]\n                ans[u] = len(LIS)\n                dfs(u,LIS)\n                LIS[ind] = stack\n    return\n\nans = [0]*N\nvisited = [False]*N\nvisited[0]=True\nLIS = [A[0]]\nans[0] = 1\ndfs(0,LIS)\nprint(*ans, sep='\\n')", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nfrom bisect import bisect_left\n\nN = int(input())\nA = list(map(int, input().split()))\n\nG = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append(v)\n    G[v].append(u)\n\n\nroot = 0\n\nans = [0] * N\ncheck = [False] * N\ncheck[root] = True\n\nmemo = [None] * N\n\nINF = 10 ** 10\ndp = [INF] * N\n\ndef dfs(x):\n    tmp = bisect_left(dp, A[x])\n    memo[x] = (tmp, dp[tmp])\n    dp[tmp] = A[x]\n    ans[x] = bisect_left(dp, INF)\n    for next_ in G[x]:\n        if check[next_]:\n            continue\n        check[next_] = True\n        dfs(next_)\n    j, a = memo[x]\n    dp[j] = a\n\ndfs(root)\n\nprint (*ans, sep = '\\n')\n\n", "## \u307e\u304d\u3082\u3069\u3057\uff1f\nma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nceil = math.ceil\nimport sys\nsys.setrecursionlimit(10**6)\nn = ni()\nA = lma()\ntree = [[] for i in range(n)]\nINF = 10**10\nfor i in range(n-1):\n    u,v = ma();u-=1;v-=1\n    tree[u].append(v)\n    tree[v].append(u)\n#print(tree)\ndef isok(num,val):##\u9069\u5b9c\u5909\u66f4\n    return num<val\ndef bisect(ls,val): ##val\u306e\u95a2\u6570isok(x,val)\u304cTrue\u3068\u306a\u308b\u4e00\u756a\u53f3\u306eindex \u3092\u8fd4\u3059 \u5168\u90e8False\u306a\u3089-1,True\u306a\u3089len(ls)-1\n    ok = -1\n    ng = len(ls)\n    x = (ok+ng)//2\n    while ng-ok>1:\n        num = ls[x]\n        if isok(num,val):\n            ok = x\n        else:\n            ng = x\n        x = (ok+ng)//2\n    return ok ##\u4e00\u756a\u53f3\u306eTrue\u306eindex  True\u306e\u500b\u6570\u306fok+1\u3053\ndef LIS_1(x,ls,right):##right ::\u3053\u308c\u307e\u3067\u308f\u304b\u3063\u3066\u3044\u308b\u53f3\u7aef\n    idx = bisect(ls,x)+1\n    if idx+1>right:\n        ret= idx+1\n    else:\n        ret=right\n    rewind_idxval.append((idx,ls[idx]))\n    ls[idx]=x\n    #print(x,ls)\n    return ret\ndef DFS_LIS(prev,ls,right):\n    ans[prev]= LIS_1(A[prev],ls,right)\n    for node in tree[prev]:\n        if not visited[node]:\n            visited[node]=True\n            DFS_LIS(node,ls,ans[prev])\n    #rewind\n    idx,pval = rewind_idxval.pop()\n    ls[idx] = pval\n\nans = [0]*n\ns = 0\nright=0\nrewind_idxval=collections.deque()\nvisited=[False]*n\nvisited[s]=True\nls=[INF]*n\nDFS_LIS(s,ls,right)\n#print(ls)\nfor a in ans :\n    print(a)\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nimport bisect\nINF = 2**31 - 1\n\nn = int(input())\nA = list(map(int, input().split()))\nT = [[] for _ in range(n)]\nfor _ in range(n-1):\n  u, v = map(int, input().split())\n  u -= 1\n  v -= 1\n  T[u].append(v)\n  T[v].append(u)\nstack = []\nL = [INF]*n\nans = [0]*n\ndef dfs(v, par=-1):\n  a = A[v]\n  idx = bisect.bisect_left(L, a)\n  stack.append((idx, L[idx]))\n  L[idx] = a\n  ans[v] = bisect.bisect_left(L, INF)\n  for nv in T[v]:\n    if nv != par:\n      dfs(nv, v)\n  b, c = stack.pop()\n  L[b] = c\ndfs(0)\nprint(*ans, sep=\"\\n\")", "import sys\nimport bisect\nsys.setrecursionlimit(10**6)\n\nn = int(input())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n)]\nfor i in range(n - 1):\n    u, v = map(lambda x: int(x) - 1, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nrooted = [[] for _ in range(n)]\nque = [(0, -1)]\nwhile que:\n    node, parent = que.pop()\n    for child in graph[node]:\n        if child != parent:\n            rooted[node].append(child)\n            # rooted[child].append(node)\n            que.append((child, node))\n            # print(child + 1, node + 1)\n\ntable = [float('inf')] * n\nlis = [None] * n\ndef dfs(node, length=0):\n    p = bisect.bisect_left(table, a[node])\n    table[p], old = a[node], table[p]\n    length = max(p + 1, length)\n    for child in rooted[node]:\n        dfs(child, length)\n    table[p] = old\n    lis[node] = length\n\ndfs(0)\nprint(*map(str, lis), sep=\"\\n\")\n", "# F - LIS on Tree\nimport bisect\nimport sys\nsys.setrecursionlimit(10**7)\n\nINF = 10**18\n\nn = int(input())\na = list(int(x) for x in input().split())\ng = [[] for _ in range(n)]\nfor _ in range(n-1):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    g[u].append(v)\n    g[v].append(u)\n\ndef dfs(now, par):\n    idx = bisect.bisect_left(dp, a[now])    \n    tmp = dp[idx]\n    dp[idx] = a[now]\n    # \u89aa\u306eLIS\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u305d\u306e\u5024\u3067\u66f4\u65b0\n    if ans[par] <= idx:\n        ans[now] = idx\n    # \u305d\u3046\u3067\u306a\u3051\u308c\u3070\u89aa\u306eLIS\u3092\u5f15\u304d\u7d99\u3050\n    else:\n        ans[now] = ans[par]\n\n    for i in g[now]:\n        if i!=par:\n            # \u6b21\u306b\u307f\u308b\u9802\u70b9\u3068\u3001\u81ea\u5206\uff08\u89aa\uff09\u306e\u60c5\u5831\u3092\u6e21\u3059\n            dfs(i, now)\n    dp[idx] = tmp\n\nans = [0] * n\ndp = [-INF] + [INF] * n\ndfs(0, -1)\nfor a in ans:\n    print(a)\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nfrom bisect import bisect_left\n\nN = int(input())\nA = list(map(int, input().split()))\n\nG = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append(v)\n    G[v].append(u)\n\nroot = 0\nstack = [root]\nvisited = set()\nvisited.add(root)\ndone = set()\nvs = []\n\nans = [0] * N\nmemo = [None] * N\nmemo[root] = (0, A[root])\n\nINF = 10 ** 10\ndp = [INF] * N\n\nwhile stack:\n    now_ = stack[-1]\n    if now_ in done:\n        j, a = memo[now_]\n        dp[j] = a\n        stack.pop()\n        vs.append(now_)\n    else:\n        for next_ in G[now_][::-1]:\n            if next_ in visited:\n                continue\n            visited.add(next_)\n            stack.append(next_)\n        done.add(now_)\n\n        tmp = bisect_left(dp, A[now_])\n        memo[now_] = (tmp, dp[tmp])\n        dp[tmp] = A[now_]\n        ans[now_] = bisect_left(dp, INF)\n\n# print (vs)\nprint (*ans, sep = '\\n')", "import sys\nfrom collections import defaultdict\nfrom bisect import bisect_left\nsys.setrecursionlimit(1000000)\ninput=sys.stdin.readline\n\n\nN = int(input())\n*a, = list(map(int, input().split()))\nd = defaultdict(list)\nfor _ in range(N-1):\n    u, v = list(map(int, input().split()))\n    d[u].append(v)\n    d[v].append(u)\n\nINF = 10**20\nl = [INF]*(N)\nq = []\nans = [0]*(N+1)\n\ndef dfs(s, root):\n    v = bisect_left(l, a[s-1])\n    q.append((v, l[v]))\n    l[v] = a[s-1]\n    ans[s] = bisect_left(l, INF)\n\n    for t in d[s]:\n        if t==root:continue\n        dfs(t, s)\n    \n    ba, bb = q.pop()\n    l[ba] = bb\n\ndfs(1, 0)\nfor i in range(1, N+1):\n    print((ans[i]))\n", "import sys\nimport math\nimport heapq\nimport bisect\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return map(int, sys.stdin.readline().split())\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\n\n\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1):\n        res.append(res[i-1]*i % DVSR)\n    return res\n\n\nN = II()\nAS = list(LI())\n\nMP = {}\n\nMX = 10**10\nLIS = [10**10]*N\nRES = [1]*N\nfor i in range(N-1):\n    a, b = LI()\n    a -= 1\n    b -= 1\n    if not a in MP:\n        MP[a] = []\n    if not b in MP:\n        MP[b] = []\n    MP[a].append(b)\n    MP[b].append(a)\n\n\ndef dfs(v, mp, lis, p):\n    for u in mp[v]:\n        if u != p:\n            i = bisect.bisect_left(lis, AS[u])\n            bef = lis[i]\n            lis[i] = AS[u]\n            longest = bisect.bisect_left(lis, MX)\n            RES[u] = longest\n            dfs(u, mp, lis, v)\n            lis[i] = bef\n\n\nLIS[0] = AS[0]\ndfs(0, MP, LIS, -1)\n\nprint(*RES, sep='\\n')\n", "import bisect\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v):\n #DFS\u306e\u884c\u304d(\u5b50\u30ce\u30fc\u30c9\u306b\u4e0b\u3063\u3066\u3044\u304f\u3068\u304d)\u306e\u51e6\u7406\n pos=bisect.bisect_left(dp,arr[v]) #\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3067\u66f4\u65b0\u3059\u308b\u5834\u6240\u30922\u5206\u63a2\u7d22\u306b\u3088\u308a\u6c42\u3081\u308b\n changes.append((pos,dp[pos])) #\u66f4\u65b0\u3057\u305f\u8981\u7d20\u3068\u305d\u306e\u5024\u3092\u8a18\u9332\u3057\u3066\u304a\u304f\n dp[pos]=arr[v]\n ans[v]=bisect.bisect_left(dp,10**18) #1\u304b\u3089v\u307e\u3067\u306e\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u306e\u9577\u3055\u306f\u3001\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u306e10**18\u4ee5\u5916\u306e\u5024\u306e\u500b\u6570\u306b\u7b49\u3057\u3044\n for u in g[v]:\n   if checked[u]==0:\n     checked[u]=1\n     dfs(u)\n #DFS\u306e\u623b\u308a(\u89aa\u30ce\u30fc\u30c9\u306b\u4e0a\u3063\u3066\u3044\u304f\u3068\u304d)\u306e\u51e6\u7406\n pos,val=changes.pop() #\u9802\u70b9v\u3067\u66f4\u65b0\u3057\u305f\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u306e\u5024\u3092\u5143\u306b\u623b\u3059\n dp[pos]=val\n\nn=int(input())\narr=[0]+list(map(int,input().split()))\ng=[[] for _ in range(n+1)]\nfor _ in range(n-1):\n a,b=map(int,input().split())\n g[a].append(b)\n g[b].append(a)\nans=[0]*(n+1)\nchecked=[0]*(n+1)\nchecked[1]=1\ndp=[10**18 for _ in range(n+1)] #\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3092\u6c42\u3081\u308b\u306e\u306b\u3001\u5341\u5206\u5927\u304d\u306a\u5024\u3067\u521d\u671f\u5316\u3057\u3066\u304a\u304f\nchanges=[]\ndfs(1)\nfor i in range(1,n+1):\n print(ans[i])", "import sys\nsys.setrecursionlimit(1000000)\nfrom bisect import bisect, bisect_left\ndef longest_subsequence(sequence):\n  subsequence = [float(\"inf\") for _ in range(len(sequence)+1)]\n  subsequence[0] = float(\"-inf\")\n  for value in sequence:\n    j = bisect(subsequence, value)\n    if subsequence[j-1] != value: # strict increasing\n      subsequence[j] = value\n  return bisect_left(dp, float(\"inf\"))-1\n# print(longest_subsequence([9, 13, 2, 10, 4, 13, 11, 13]))\n# return\ndef dfs(vertex):\n  visited[vertex] = True\n  value = a[vertex]\n  j = bisect(subsequence, value)\n  previous = subsequence[j]\n  if subsequence[j-1] != value: # strict increasing\n    subsequence[j] = value\n  ans[vertex] = bisect_left(subsequence, float(\"inf\"))-1\n  for node in adjacent[vertex]:\n    if not visited[node]:\n      dfs(node)\n  subsequence[j] = previous\n  return\nn = int(input())\na = list(map(int, input().split()))\nadjacent = {i: [] for i in range(n)}\nfor _ in range(n-1):\n  node1, node2 = map(int, input().split())\n  node1 -= 1\n  node2 -= 1\n  adjacent[node1].append(node2)\n  adjacent[node2].append(node1)\nvisited = [False]*n\nans = [0]*n\nsubsequence = [float(\"inf\") for _ in range(n+1)]\nsubsequence[0] = float(\"-inf\")\ndfs(0)\n[print(value) for value in ans]", "import sys\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**6)\n\n\ndef main():\n    N = int(input())\n    As = list(map(int, input().split()))\n\n    query = (list(map(int, readline().strip().split())) for _ in range(N-1))\n\n    tree = [[] for _ in range(N)]\n    for u, v in query:\n        tree[u-1].append(v-1)\n        tree[v-1].append(u-1)\n\n    inf = 10 ** 18\n    dp = [inf] * (N+1)\n    ans = [0] * N\n\n    def dfs(node, parent):\n        v = As[node]\n        lb = binary_search(dp, v)\n        old = dp[lb]\n        dp[lb] = v\n        ans[node] = binary_search(dp, inf)\n        for child in tree[node]:\n            if child == parent:\n                continue\n            dfs(child, node)\n        dp[lb] = old\n\n    dfs(0, 0)\n\n    for k in range(N):\n        print((ans[k]))\n\n\ndef binary_search(seq, v):\n    left = 0\n    right = len(seq) - 1\n    center = right // 2\n\n    while left != right:\n        if v <= seq[center]:\n            right = center\n        else:\n            left = center+1\n        center = (right + left) // 2\n\n    return center\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nimport bisect\nimport sys\n\nsys.setrecursionlimit(200000)\n\nN = int(input())\na = list(map(int, input().split()))\nuvs = [list(map(int, input().split())) for _ in range(N-1)]\nshortest = [10e+10 for _ in range(N)]\nshortest[0] = 0\n\nroutes = [[] for _ in range(N)]\n\nfor uv in uvs:\n    routes[uv[0]-1].append(uv[1]-1)\n    routes[uv[1]-1].append(uv[0]-1)\n\nlis = [10e+100 for _ in range(N)]\nminimum = [10e+100 for _ in range(N)]\nseen = [False for _ in range(N)]\nseen[0] = True\n\ndef function(checking):\n    insert_posi = bisect.bisect_left(lis, a[checking])\n    preserved = lis[insert_posi]\n    lis[insert_posi] = a[checking]\n    minimum[checking] = bisect.bisect_left(lis, 10e+50)\n    for route in routes[checking]:\n        if seen[route] == False:\n            seen[route] = True\n            shortest[route] = shortest[checking]+1\n            function(route)\n    lis[insert_posi] = preserved\n    return\n        \nfunction(0)\n\n[print(x) for x in minimum]", "import sys\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\ndef main():\n    N = int(input())\n    As = list(map(int, input().split()))\n\n    edges = (list(map(int, readline().strip().split())) for _ in range(N-1))\n\n    tree = [[] for _ in range(N)]\n    for u, v in edges:\n        tree[u-1].append(v-1)\n        tree[v-1].append(u-1)\n\n    inf = 10 ** 18\n    dp = [inf] * (N+1)\n    ans = [0] * N\n\n    def dfs(node, parent):\n        v = As[node]\n        lb = binary_search(dp, v)\n        old = dp[lb]\n        dp[lb] = v\n        ans[node] = binary_search(dp, inf)\n        for child in tree[node]:\n            if child == parent:\n                continue\n            dfs(child, node)\n        dp[lb] = old\n\n    dfs(0, 0)\n\n    for k in range(N):\n        print((ans[k]))\n\n\ndef binary_search(seq, v):\n    left = 0\n    right = len(seq) - 1\n    center = right // 2\n\n    while left != right:\n        if v <= seq[center]:\n            right = center\n        else:\n            left = center+1\n        center = (right + left) // 2\n\n    return center\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\nfrom bisect import bisect_left\nINF=10**18\ndef dfs(v,p,max_):\n    b=bisect_left(dp,a[v])\n    memo=(b,dp[b])\n    dp[b]=a[v]\n    if b>max_:\n        max_=b\n    ans[v]=max_\n    for nv in G[v]:\n        if nv==p:\n            continue\n        dfs(nv,v,max_)\n    dp[memo[0]]=memo[1]\n\nN=int(input())\na=list(map(int,input().split()))\nG=[[] for i in range(N)]\nfor i in range(N-1):\n    u,v=map(lambda x:int(x)-1,input().split())\n    G[u].append(v)\n    G[v].append(u)\ndp=[INF]*(N+1)\ndp[0]=-1\nans=[-1]*N\ndfs(0,-1,0)\nprint(*ans,sep='\\n')", "# \u5199\u7d4c\n# https://atcoder.jp/contests/abc165/submissions/12655073\nfrom bisect import bisect_left, bisect_right\nimport sys\n\ndef resolve():\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**9)\n    INF = float('inf') \n    N = int(input())\n    As = list(map(int, input().split()))\n    adjL = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        u, v = u-1, v-1\n        adjL[u].append(v)\n        adjL[v].append(u)\n    \n    dp = [-INF]\n    anss = [0] * N\n    def dfs(vNow, vPar):\n        A = As[vNow]\n        if dp[-1] < A:\n            dp.append(A)\n            tp = 0\n        else:\n            i = bisect_left(dp, A)\n            tp = 1\n            iOld, AOld, = i, dp[i]\n            dp[i] = A\n        anss[vNow] = len(dp) - 1\n    \n        for v2 in adjL[vNow]:\n            if v2 == vPar: continue\n            dfs(v2, vNow)\n    \n        if tp == 0:\n            dp.pop()\n        else:\n            dp[iOld] = AOld\n    \n    dfs(0, -1)\n\n    print('\\n'.join(map(str, anss)))\nresolve()", "from collections import deque\nfrom bisect import bisect_left as bile\n\ndef main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    sys.setrecursionlimit(10**6)\n    n = int(input())\n    arr = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    ans = [0]*n\n    inf = 1e18\n    dp = [inf]*(n+10)\n    parent = [-1]*n\n    def dfs(s):\n        idx = bile(dp, arr[s])\n        tmp = dp[idx]\n        dp[idx] = arr[s]\n        ans[s] = bile(dp, inf)\n\n        for v in adj[s]:\n            if v == parent[s]:\n                continue\n            parent[v] = s\n            dfs(v)\n        dp[idx] = tmp\n        return ans\n        \n    ans = dfs(0)\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\n\n\ndef main():\n    N = int(input())\n    As = list(map(int, input().split()))\n\n    edges = (list(map(int, readline().strip().split())) for _ in range(N-1))\n\n    tree = [[] for _ in range(N)]\n    for u, v in edges:\n        tree[u-1].append(v-1)\n        tree[v-1].append(u-1)\n\n    inf = 10 ** 12\n    dp = [inf] * (N+1)\n    ans = [0] * N\n\n    def dfs(node, parent):\n        v = As[node]\n        lb = bisect_left(dp, v)\n        old = dp[lb]\n        dp[lb] = v\n        ans[node] = bisect_left(dp, inf)\n        for child in tree[node]:\n            if child == parent:\n                continue\n            dfs(child, node)\n        dp[lb] = old\n\n    dfs(0, 0)\n\n    for k in range(N):\n        print((ans[k]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom bisect import bisect_left\nsys.setrecursionlimit(10**7)\ndef input():return sys.stdin.readline().strip()\n\ndef main():\n    N = int(input())\n    A = tuple(map(int, input().split()))\n\n    to = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        to[u].append(v)\n        to[v].append(u)\n    \n    ans = [0] * N\n    dp = []\n    def dfs(now, pre):\n        a = A[now]\n        idx = bisect_left(dp, a)\n\n        if idx == len(dp):\n            old = -1\n            dp.append(a)\n        else:\n            old = dp[idx]\n            dp[idx] = a\n        \n        ans[now] = len(dp)\n\n        \n        for nv in to[now]:\n            if nv != pre:\n                dfs(nv, now)\n        \n\n        if old == -1:\n            dp.pop()\n        else:\n            dp[idx] = old\n\n    \n    dfs(0, -1)\n\n    print(*ans, sep=\"\\n\")\n        \n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(100000000)\n\nfrom bisect import bisect_left,bisect_right\nn=int(input())\na=list(map(int,input().split()))\nG=[[]for i in range(n)]\nfor i in range(n-1):\n  u,v=map(int,input().split())\n  G[u-1].append(v-1)\n  G[v-1].append(u-1)\n\nlis=[a[0]]\nstack=[]\nans=[1]*n\ndef dfs(cur,p=-1):\n  for nx in G[cur]:\n    if nx==p:continue\n    idx=bisect_left(lis,a[nx])\n    if idx==len(lis):\n      stack.append((idx,-1))\n      lis.append(a[nx])\n    else:\n      stack.append((idx,lis[idx]))\n      lis[idx]=a[nx]\n    \n    ans[nx]=len(lis)\n\n    dfs(nx,cur)\n\n    idx,v=stack.pop()\n    if v<0:\n      lis.pop()\n    else:\n      lis[idx]=v\n\ndfs(0)\nprint(*ans,sep=\"\\n\")", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\nfrom bisect import bisect_left\nINF = float(\"inf\")\n\n\nfrom collections import defaultdict\n\n\nclass Graph(object):\n    def __init__(self, N):\n        self.N = N\n        self.E = defaultdict(list)\n\n    def add_edge(self, f, t, w=1):\n        self.E[f].append((t, w))\n        self.E[t].append((f, w))\n\n\ndef solve(N: int, a: \"List[int]\", u: \"List[int]\", v: \"List[int]\"):\n\n    g = Graph(N)\n    for x, y in zip(u, v):\n        g.add_edge(x-1, y-1)\n\n    ans = [0]*N\n\n    dp = [INF]*N\n    event = []\n    var = {\"last\": 0}\n\n    def dfs(curr, par):\n        i = bisect_left(dp, a[curr])\n        if dp[i] > a[curr]:\n            if dp[i] == INF:\n                var[\"last\"] = i\n            event.append((curr, i, dp[i]))\n            dp[i] = a[curr]\n\n        ans[curr] = var[\"last\"]+1\n\n        for child, w in g.E[curr]:\n            if child == par:\n                continue\n            dfs(child, curr)\n\n        c, i, v = event[-1]\n        if c == curr:\n            dp[i] = v\n            if v == INF:\n                var[\"last\"] = i-1\n            event.pop()\n\n    dfs(0, -1)\n    print(*ans, sep=\"\\n\")\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    a = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    u = [int()] * (N - 1)  # type: \"List[int]\"\n    v = [int()] * (N - 1)  # type: \"List[int]\"\n    for i in range(N - 1):\n        u[i] = int(next(tokens))\n        v[i] = int(next(tokens))\n    solve(N, a, u, v)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nfrom bisect import bisect_left\nimport sys\ndef input():return sys.stdin.readline().strip()\n\ndef main():\n    N = int(input())\n    A = tuple(map(int, input().split()))\n\n    to = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        to[a].append(b)\n        to[b].append(a)\n    \n    # bfs\n    INF = 10 ** 18\n    dp = [INF] * N\n    ans = [0] * N\n\n    def dfs(s):\n        stack = deque()\n        pop = stack.pop\n        push = stack.append\n\n        push((s, -1, None))\n\n        while stack:\n            now, pre, old = pop()\n\n            # \u5fa9\u5143\n            if now == -1:\n                dp[pre] = old\n                continue\n            \n            a = A[now]\n            idx = bisect_left(dp, a)\n            old = dp[idx]\n            dp[idx] = a\n\n            ans_idx = bisect_left(dp, INF)\n            ans[now] = ans_idx\n\n            # \u5fa9\u5143\u7528 \u9802\u70b9\n            # (\u30d5\u30e9\u30b0, \u5909\u66f4\u3057\u305fidx, \u524d\u306e\u5024)\n            push((-1, idx, old))\n            \n            for nv in to[now]:\n                if nv != pre:\n                    push((nv, now, None))\n    \n    dfs(0)\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u6728\u306b\u3088\u3063\u3066LIS\u3092\u4f5c\u308a\u3001dfs\u3067\u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u305d\u306e\u524d\u306e\u72b6\u614b\u307e\u3067\u5fa9\u5143\u3059\u308b\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina1(x): return int(x) - 1\n\n\ndef read_ints(tozero=False):\n    if tozero == False:\n        return list(map(int, read().split()))\n    else:\n        return list(map(mina1, read().split()))\n\n\ndef read_a_int():\n    return int(read())\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nN = read_a_int()\nA = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in ra(N - 1):\n    u, v = read_ints(True)\n    tree[u].append(v)\n    tree[v].append(u)\n\nLIS = []\nans = [0] * N  # \u5404\u30ce\u30fc\u30c9\u306elen(LIS)\u3092\u8a18\u9332\n\n\ndef dfs(now, p):  # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3001\u89aa\n    a = A[now]\n    # LIS\u306e\u66f4\u65b0\n    idx = bisect_left(LIS, a)\n    is_append = False\n    if idx == len(LIS):\n        LIS.append(a)\n        is_append = True\n    else:\n        old = LIS[idx]   # \u306a\u3093\u306e\u5024\u3060\u3063\u305f\u304b\u6301\u3063\u3066\u304a\u304f\n        LIS[idx] = a  # a\u306b\u66f4\u65b0\n\n    ans[now] = len(LIS)  # \u7b54\u3048\u3092\u8a18\u9332\n    # \u6b21\u306e\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\n    for to in tree[now]:\n        if to == p:\n            continue\n        dfs(to, now)\n\n    # \u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u5fa9\u5143\n    if is_append:\n        del LIS[idx]\n    else:\n        LIS[idx] = old\n\n\ndfs(0, -1)\nprint(*ans, sep='\\n')\n", "from bisect import bisect_left\n\nn = int(input())\nA = [0] + list(map(int, input().split()))\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[v].append(u)\n    graph[u].append(v)\n\nstart = 1\n\nstack = [1]\npar = [-1] * (n + 1)\nans = [0] * (n + 1)\nused = [False] * (n + 1)\ninfi = 10 ** 20\nLIS = [infi] * (n + 1)\nLIS[0] = -infi\nposition = [(-1, -1)] * (n + 1)\n\n\ndef hantei(val, L):\n    pos = bisect_left(L, val)\n    pre = L[pos]\n    L[pos] = val\n    cnt = bisect_left(L, infi)\n    return L, pos, pre, cnt\n\n\nwhile stack:\n    v = stack[-1]\n    if not used[v]:\n        LIS, pos, pre, cnt = hantei(A[v], LIS)\n        position[v] = (pos, pre)\n        ans[v] = cnt - 1\n    used[v] = True\n    if not graph[v]:\n        _ = stack.pop()\n        basho, atai = position[v]\n        LIS[basho] = atai\n        continue\n    u = graph[v].pop()\n    if u == par[v]:\n        continue\n    par[u] = v\n    stack.append(u)\n\nprint(*ans[1:], sep=\"\\n\")\n", "from collections import deque\nfrom bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10**7)\nn=int(input())\na=list(map(int,input().split()))\nedge=[[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v=map(int,input().split())\n    u-=1\n    v-=1\n    edge[u].append(v)\n    edge[v].append(u)\nstack=deque([])\ninf=10**18\nlis=[inf]*(n+1)\nans=[0 for _ in range(n)]\nvisited=[True]*n\n#print(edge)\ndef dfs(s):\n    visited[s]=False\n    idx=bisect_left(lis,a[s])\n    stack.append((idx,lis[idx]))\n    lis[idx]=a[s]\n    ans[s]=bisect_left(lis,inf)\n    for x in edge[s]:\n        if visited[x]:\n            dfs(x)\n    idx,val=stack.pop()\n    lis[idx]=val\ndfs(0)\n#print(lis)\nfor i in range(n):\n    print(ans[i])", "from bisect import bisect_left as bl\nimport sys\nsys.setrecursionlimit(10**6)\nn=int(input())\na=list(map(int,input().split()))\nt=[[]for i in range(n)]\nfor i in range(n-1):\n    u,v=list(map(int,input().split()))\n    t[u-1].append(v-1)\n    t[v-1].append(u-1)\nb=[0]*n\ndp=[float(\"inf\")]*n\ndef f(c,d):\n    h=bl(dp,a[c])\n    g=dp[h]\n    dp[h]=min(dp[h],a[c])\n    b[c]=bl(dp,float(\"INF\"))\n    for i in t[c]:\n        if i!=d:f(i,c)\n    dp[h]=g\nf(0,-1)\nfor i in b:\n    print(i)\n", "from collections import deque\nimport bisect\n\nN=int(input())\nA=list(map(int,input().split()))\nans=[0]*N\nEdge=[[] for _ in range(N)]\nloute=[str(0)]*N\nfor i in range(N-1):\n    u,v=map(int,input().split())\n    Edge[u-1].append(v-1)\n    Edge[v-1].append(u-1)\n  \ntmp=deque(str(0))\nCHN=deque()\nLIS=[10**18]*N\nlabel=[False]*N\nwhile tmp:\n    T0=int(tmp[-1])\n    if label[T0]:\n        tmp.pop()\n        pos,Val=CHN.pop()\n        LIS[pos]=Val\n        continue\n\n    pos=bisect.bisect_left(LIS,A[T0])\n    CHN.append((pos,LIS[pos]))\n    LIS[pos]=A[T0]\n    ans[T0]=bisect.bisect_left(LIS,10**18)\n\n    if Edge[T0]:\n        for i in Edge[T0]:\n            if label[i]==False:\n                tmp.append(i)\n        label[T0]=True\n    else:\n        label[T0]=True\n    \nfor i in range(N):\n    print(ans[i])", "\nimport sys\nsys.setrecursionlimit(10 ** 7)\nfrom bisect import bisect_left\ndef resolve():\n    def dfs(s, parent):\n        a = A[s]\n        i = bisect_left(dp, a)\n        v = dp[i]\n        dp[i] = a\n        ans[s] = bisect_left(dp, INF)\n        for to in G[s]:\n            if to == parent:\n                continue\n            dfs(to, s)\n        # \u9802\u70b9s\u3067\u306e\u7d50\u679c\u3092\u3082\u3068\u306b\u623b\u3059\n        dp[i] = v\n        return\n\n\n    N = int(input())\n    A = tuple(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = map(lambda x:int(x)-1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n\n    INF = 10 ** 18\n    dp = [INF] * N\n    ans = [0] * N\n\n    dfs(0, -1)\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# \u6728\u306b\u3088\u3063\u3066LIS\u3092\u4f5c\u308a\u3001dfs\u3067\u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u305d\u306e\u524d\u306e\u72b6\u614b\u307e\u3067\u5fa9\u5143\u3059\u308b\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina1(x):\n    return int(x) - 1\n\n\ndef read_ints(mina=None):\n    ret = map(int, read().split())\n    if mina == None:\n        return list(ret)\n    else:\n        return list(map(lambda x: x - mina, ret))\n\n\ndef read_a_int():\n    return int(read())\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nN = read_a_int()\nA = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in ra(N - 1):\n    u, v = read_ints(mina=1)\n    tree[u].append(v)\n    tree[v].append(u)\n\nLIS = []\nans = [0] * N  # \u5404\u30ce\u30fc\u30c9\u306elen(LIS)\u3092\u8a18\u9332\n\n\ndef dfs(now, p):  # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3001\u89aa\n    a = A[now]\n    # LIS\u306e\u66f4\u65b0\n    idx = bisect_left(LIS, a)\n    is_append = False\n    if idx == len(LIS):\n        LIS.append(a)\n        is_append = True\n    else:\n        old = LIS[idx]   # \u306a\u3093\u306e\u5024\u3060\u3063\u305f\u304b\u6301\u3063\u3066\u304a\u304f\n        LIS[idx] = a  # a\u306b\u66f4\u65b0\n\n    ans[now] = len(LIS)  # \u7b54\u3048\u3092\u8a18\u9332\n    # \u6b21\u306e\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\n    for to in tree[now]:\n        if to == p:\n            continue\n        dfs(to, now)\n\n    # \u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u5fa9\u5143\n    if is_append:\n        del LIS[idx]\n    else:\n        LIS[idx] = old\n\n\ndfs(0, -1)\nprint(*ans, sep='\\n')\n", "from bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nA = list(map(int, input().split()))\n\nedges = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    fr, to = map(lambda a: int(a) - 1, input().split())\n    edges[fr].append(to)\n    edges[to].append(fr)\n\nans = [0] * N\nL = [-10**18]\n\ndef search(now, pr):\n    a = A[now]\n    i = bisect_left(L, a)\n    isAppended = False\n    prevValue = -1\n\n    if i == len(L):\n        L.append(a)\n        isAppended = True\n    else:\n        prevValue = L[i]\n        if L[i] > a:\n            L[i] = a\n\n    ans[now] = len(L) - 1\n\n    for to in edges[now]:\n        if to == pr:\n            continue\n        search(to, now)\n\n    if isAppended:\n        L.pop()\n    else:\n        L[i] = prevValue\n\nsearch(0, -1)\nprint(*ans, sep='\\n')\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    from collections import deque\n    from bisect import bisect_left\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    tree = [[] for _ in [0]*N]\n    for u, v in [map(int, input().split()) for _ in [0]*(N-1)]:\n        tree[u-1].append(v-1)\n        tree[v-1].append(u-1)\n    \n    dp = [1001001001] * (N+1)\n    dp[0] = -1001001001\n    ans = [0] * N\n    def dfs(now, p=-1):\n        idx = bisect_left(dp, a[now])\n        old = dp[idx]\n        dp[idx] = a[now]\n        ans[now] = idx\n        if p != -1 and ans[now] < ans[p]:\n            ans[now] = ans[p]\n        for child in tree[now]:\n            if child == p: continue\n            dfs(child, now)\n        dp[idx] = old\n    dfs(0)\n\n    print(*ans, sep='\\n')\n\nmain()", "import sys\nsys.setrecursionlimit(100000000)\nfrom  bisect import bisect_left\ninput = sys.stdin.readline\nINF = 1 << 30\n\nMAXN = 200005\nG = [[] for _ in range(MAXN)]\ndp = [INF] * MAXN\nstack = []\nans = [None] * MAXN\ndef dfs(v,A,p = -1):\n    idx = bisect_left(dp,A[v])\n    stack.append((idx,dp[idx]))\n    dp[idx] = A[v]\n    ans[v] = bisect_left(dp,INF)\n    for e in G[v]:\n        if e == p:\n            continue\n        dfs(e,A,v)\n    idx,p = stack.pop()\n    dp[idx] = p\n\ndef main():\n    N = int(input())\n    A = list(map(int,input().split()))\n    for _ in range(N - 1):\n        a,b = list(map(int,input().split()))\n        a -= 1\n        b -= 1\n        G[a].append(b)\n        G[b].append(a)\n    dfs(0,A)\n    print(('\\n'.join(map(str,ans[:N]))))\ndef __starting_point():\n    main()\n    \n\n    \n    \n\n__starting_point()", "import sys\nsys.setrecursionlimit(10101000)##?\nn=int(input())\n*a,=list(map(int, input().split()))\nt=[[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v=list(map(int, input().split()))\n    u-=1;v-=1\n    t[u].append(v);t[v].append(u)\n    \nINF=10**10\neps=0.1\nhis=[(-1,-1)]*(n+1)\nlis=[INF]*(n+1)\nans = [-1]*n\nfrom bisect import bisect_right,bisect_left\ndef dfs(v):\n    l=bisect_left(lis,a[v])#?\n    his[v]=(l,lis[l])\n    lis[l]=a[v]\n    ans[v]=bisect_left(lis,INF)\n    for u in t[v]:\n        if ans[u]<0:\n            dfs(u)\n    ll,pre=his[v]\n    lis[ll]=pre\ndfs(0)\nfor ai in ans:print(ai)\n", "import sys\nimport bisect\nimport copy\nsys.setrecursionlimit(10 ** 6)\ndef input():\n    return sys.stdin.readline()[:-1]\ninf = 10**9+1\n\ndef dfs(v,prev = -1):\n    x = As[v]\n    if len(LIS) == 0 or x > LIS[-1]:\n        old = inf\n        i = len(LIS)\n        LIS.append(x)\n    else:\n        i = bisect.bisect_left(LIS, x)\n        old = LIS[i]\n        LIS[i] = x\n\n    a = len(LIS)\n    ans_array[v] = a\n    for u in graph[v]:\n        if u == prev:\n            continue\n        dfs(u,v)\n    if old == inf:\n        LIS.pop(-1)\n    else:\n        LIS[i] = old\n\nN = int(input())\nAs = list(map(int,input().split()))\ngraph = [[] for _ in range(N)]\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\nLIS = []\nans_array = [0] * N\ndfs(0)\nfor i in range(N):\n    print((ans_array[i]))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom bisect import bisect_left\ndef main(N,a,tr):\n  ans=[0]*N\n  dp=[float('inf')]*(N+1)\n  dp[0]=0\n  maxa=max(a)+1\n  def dfs(p,v,dp):\n    i=bisect_left(dp,a[v])\n    tmp=dp[i]\n    dp[i]=a[v]\n    ans[v]=bisect_left(dp,maxa)-1\n    for nv in tr[v]:\n      if nv!=p:\n        dfs(v,nv,dp)\n    dp[i]=tmp\n  dfs(-1,0,dp)\n  print(*ans,sep='\\n')\ndef __starting_point():\n  N=int(input())\n  a=list(map(int,input().split()))\n  tr=[[] for _ in range(N)]\n  for _ in range(N-1):\n    u,v=map(int,input().split())\n    u,v=u-1,v-1\n    tr[u].append(v)\n    tr[v].append(u)\n  main(N,a,tr)\n\n__starting_point()", "from bisect import bisect_left\n\nN=int(input())\n*A,=map(int,input().split())\nINF=10**20\nG=[[] for _ in range(N)]\nab = [tuple(map(int,input().split())) for _ in range(N-1)]\nfor a,b in ab:\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n  \ndef dfs(a0):\n    seen =[0]*len(G)\n    todo = [~a0, a0]\n    while todo:\n        a = todo.pop()\n        if a >= 0:\n            seen[a] = 1\n            idx = bisect_left(lis,A[a])\n            his[a] = (idx,lis[idx])\n            lis[idx] = A[a]\n            dp[a] = bisect_left(lis,INF)\n            for b in G[a]:\n                if seen[b]: continue\n                todo.append(~b)\n                todo.append(b)\n        else:\n          idx,val = his[~a]\n          lis[idx] = val\n    return\n  \nlis = [INF]*N\ndp = [0]*N\nhis = {}\ndfs(0)\nprint(*dp,sep=\"\\n\")", "import sys\nfrom bisect import bisect_left\nsys.setrecursionlimit(10**7)\ndef input():return sys.stdin.readline().strip()\n\ndef main():\n    N = int(input())\n    A = tuple(map(int, input().split()))\n\n    to = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        to[u].append(v)\n        to[v].append(u)\n\n    INF = 10 ** 18    \n    ans = [0] * N\n    dp = [INF] * N\n    def dfs(now, pre):\n        a = A[now]\n        idx = bisect_left(dp, a)\n\n        old = dp[idx]\n        dp[idx] = a\n\n        ans_idx = bisect_left(dp, INF)\n        ans[now] = ans_idx\n\n        \n        for nv in to[now]:\n            if nv != pre:\n                dfs(nv, now)\n        \n\n        dp[idx] = old\n    \n    dfs(0, -1)\n\n    print(*ans, sep=\"\\n\")\n        \n\ndef __starting_point():\n    main()\n__starting_point()", "import collections\nimport bisect\nimport sys\n\nsys.setrecursionlimit(10 ** 8)\n\ndef f(v):\n    state[v] = 1\n    a=As[v]\n    idx = bisect.bisect_left(D,a)\n    stack.append( (idx,D[idx]) ) # push\n    D[idx] = a\n    \n    ans[v] = bisect.bisect_left(D,float('inf'))\n\n    for u in V[v]:\n        if state[u] == 0:\n            f(u)\n\n    # \u5dfb\u304d\u623b\u3057\n    i_pre,d_pre=stack.pop()\n    D[i_pre] = d_pre\n\n\n\nN=int(input())\nAs=list(map(int,input().split()))\n\nD=[float('inf')]*N\nstack=collections.deque([])\nans=[0]*N\nstate=[0]*N\n\nV=[[] for _ in range(N)]\nfor _ in range(N-1):\n    u,v=map(int,input().split())\n    V[u-1].append(v-1)\n    V[v-1].append(u-1)\n\nf(0)\n\nprint(*ans,sep='\\n')", "# \u6728\u306b\u3088\u3063\u3066LIS\u3092\u4f5c\u308a\u3001dfs\u3067\u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u305d\u306e\u524d\u306e\u72b6\u614b\u307e\u3067\u5fa9\u5143\u3059\u308b\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina1(x):\n    return int(x) - 1\n\n\ndef read_ints(mina=None):\n    ret = map(int, read().split())\n    if mina == None:\n        return list(ret)\n    else:\n        return list(map(lambda x: x - mina, ret))\n\n\ndef read_a_int():\n    return int(read())\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nN = read_a_int()\nA = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in ra(N - 1):\n    u, v = read_ints(mina=1)\n    tree[u].append(v)\n    tree[v].append(u)\n\nLIS = []\nans = [0] * N  # \u5404\u30ce\u30fc\u30c9\u306elen(LIS)\u3092\u8a18\u9332\n\n\ndef dfs(now, p):  # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3001\u89aa\n    a = A[now]\n    # LIS\u306e\u66f4\u65b0\n    idx = bisect_left(LIS, a)\n    is_append = False\n    if idx == len(LIS):\n        LIS.append(a)\n        is_append = True\n    else:\n        old = LIS[idx]   # \u306a\u3093\u306e\u5024\u3060\u3063\u305f\u304b\u6301\u3063\u3066\u304a\u304f\n        LIS[idx] = a  # a\u306b\u66f4\u65b0\n\n    ans[now] = len(LIS)  # \u7b54\u3048\u3092\u8a18\u9332\n    # \u6b21\u306e\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\n    for to in tree[now]:\n        if to == p:\n            continue\n        dfs(to, now)\n\n    # \u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u5fa9\u5143\n    if is_append:\n        del LIS[idx]\n    else:\n        LIS[idx] = old\n\n\ndfs(0, -1)\nprint(*ans, sep='\\n')\n", "# \u6728\u306b\u3088\u3063\u3066LIS\u3092\u4f5c\u308a\u3001dfs\u3067\u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u305d\u306e\u524d\u306e\u72b6\u614b\u307e\u3067\u5fa9\u5143\u3059\u308b\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina1(x):\n    return int(x) - 1\n\n\ndef read_ints(mina=None):\n    ret = map(int, read().split())\n    if mina == None:\n        return list(ret)\n    else:\n        return list(map(mina1, ret))\n\n\ndef read_a_int():\n    return int(read())\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nN = read_a_int()\nA = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in ra(N - 1):\n    u, v = read_ints(mina=1)\n    tree[u].append(v)\n    tree[v].append(u)\n\nLIS = []\nans = [0] * N  # \u5404\u30ce\u30fc\u30c9\u306elen(LIS)\u3092\u8a18\u9332\n\n\ndef dfs(now, p):  # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3001\u89aa\n    a = A[now]\n    # LIS\u306e\u66f4\u65b0\n    idx = bisect_left(LIS, a)\n    is_append = False\n    if idx == len(LIS):\n        LIS.append(a)\n        is_append = True\n    else:\n        old = LIS[idx]   # \u306a\u3093\u306e\u5024\u3060\u3063\u305f\u304b\u6301\u3063\u3066\u304a\u304f\n        LIS[idx] = a  # a\u306b\u66f4\u65b0\n\n    ans[now] = len(LIS)  # \u7b54\u3048\u3092\u8a18\u9332\n    # \u6b21\u306e\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\n    for to in tree[now]:\n        if to == p:\n            continue\n        dfs(to, now)\n\n    # \u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u5fa9\u5143\n    if is_append:\n        del LIS[idx]\n    else:\n        LIS[idx] = old\n\n\ndfs(0, -1)\nprint(*ans, sep='\\n')\n", "import bisect\nn = int(input())\n*A, = map(int, input().split())\nG = [[] for i in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    G[x - 1].append(y - 1)\n    G[y - 1].append(x - 1)\ninf = 10**10\nDP = [inf for i in range(n)]\nL = [0 for i in range(n)]\nQ = [(-1, 0, None)]\nwhile Q:\n    p, x, b = Q.pop()\n    if x == -1:\n        DP[p] = b\n        continue\n    i = bisect.bisect_left(DP, A[x])\n    Q.append((i, -1, DP[i]))\n    DP[i] = A[x]\n    L[x] = bisect.bisect_left(DP, inf)\n    for y in G[x]:\n        if y != p:\n            Q.append((x, y, None))\nprint(*L, sep='\\n')\n", "# \u6728\u306b\u3088\u3063\u3066LIS\u3092\u4f5c\u308a\u3001dfs\u3067\u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u305d\u306e\u524d\u306e\u72b6\u614b\u307e\u3067\u5fa9\u5143\u3059\u308b\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina1(x):\n    return int(x) - 1\n\n\ndef read_ints(mina=None):\n    ret = map(int, read().split())\n    if mina == None:\n        return list(ret)\n    else:\n        return list(map(lambda x: x - 1, ret))\n\n\ndef read_a_int():\n    return int(read())\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nN = read_a_int()\nA = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in ra(N - 1):\n    u, v = read_ints(mina=1)\n    tree[u].append(v)\n    tree[v].append(u)\n\nLIS = []\nans = [0] * N  # \u5404\u30ce\u30fc\u30c9\u306elen(LIS)\u3092\u8a18\u9332\n\n\ndef dfs(now, p):  # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u3001\u89aa\n    a = A[now]\n    # LIS\u306e\u66f4\u65b0\n    idx = bisect_left(LIS, a)\n    is_append = False\n    if idx == len(LIS):\n        LIS.append(a)\n        is_append = True\n    else:\n        old = LIS[idx]   # \u306a\u3093\u306e\u5024\u3060\u3063\u305f\u304b\u6301\u3063\u3066\u304a\u304f\n        LIS[idx] = a  # a\u306b\u66f4\u65b0\n\n    ans[now] = len(LIS)  # \u7b54\u3048\u3092\u8a18\u9332\n    # \u6b21\u306e\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\n    for to in tree[now]:\n        if to == p:\n            continue\n        dfs(to, now)\n\n    # \u629c\u3051\u308b\u3068\u304d\u306bLIS\u3092\u5fa9\u5143\n    if is_append:\n        del LIS[idx]\n    else:\n        LIS[idx] = old\n\n\ndfs(0, -1)\nprint(*ans, sep='\\n')\n", "\nimport math\nimport bisect\n\nn = int(input())\nalist = [0]+list(map(int,input().split()))\nuv_list = []\nfor i in range(n-1):\n    u,v = list(map(int,input().split()))\n    if u > v:\n        u, v = v, u\n    uv_list.append([u,v])\n\ntree = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    uv = uv_list[i]\n    tree[uv[0]].append(uv[1])\n    tree[uv[1]].append(uv[0])\n    \n\nqueue = [1]\nused = [0]*(n+1)\nans = [0]*(n+1)\ndp = []\nstack = []\nwhile queue != []:\n    cur = queue[-1]\n\n    if used[cur] == 0:\n        if cur == 1:\n            dp.append(alist[cur])\n            stack.append([len(dp)-1,None])\n        else:\n            if alist[cur] > dp[-1]:\n                dp.append(alist[cur])\n                stack.append([len(dp)-1,None])\n            else:\n                offset = bisect.bisect_left(dp,alist[cur])\n                stack.append([offset,dp[offset]])\n                dp[offset] = alist[cur]\n        ans[cur] = len(dp)\n\n    if tree[cur] != [] and used[cur] == 0:\n        for child in tree[cur]:\n            if used[child] == 0:\n                queue.append(child)\n    else:\n        queue.pop()\n\n        #reverse\n        back = stack.pop()\n        if back[1] == None:\n            dp.pop()\n        else:\n            dp[back[0]] = back[1]\n    used[cur] = 1\nfor i in range(n):\n    print((ans[i+1]))\n", "def main():\n\n    from bisect import bisect_left as bl\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    ab = [list(map(int, input().split())) for _ in [0]*(n-1)]\n    g = [set() for _ in [0]*n]\n    ans = [0]*n\n    [g[a-1].add(b-1) for a, b in ab]\n    [g[b-1].add(a-1) for a, b in ab]\n    visited = [False]*n\n\n    q = [0]\n    lis = []\n    while q:\n        i = q.pop()\n        ai = a[i]\n        if not visited[i]:\n            b = bl(lis, ai)\n            if b == len(lis):\n                visited[i] = \"push\"\n                lis.append(ai)\n            else:\n                visited[i] = [b, lis[b]]\n                lis[b] = ai\n            ans[i] = len(lis)\n        if not g[i]:\n            if visited[i] == \"push\":\n                lis.pop()\n            else:\n                lis[visited[i][0]] = visited[i][1]\n        else:\n            q.append(i)\n            j = g[i].pop()\n            g[j].remove(i)\n            q.append(j)\n    for i in ans:\n        print(i)\n\n\nmain()", "import bisect\n\ndef dfs(graph, root, A, res, lis):\n    stack = [(root,)]\n    while stack:\n        # print(stack)\n        state = stack[-1]\n        del stack[-1]\n        u = state[0]\n        if res[u] == -1:\n            a = A[u]\n            p = bisect.bisect_left(lis, a)\n            if p == len(lis):\n                stack.append((u, -1))\n                lis.append(a)\n            else:\n                stack.append((u, p, lis[p]))\n                lis[p] = a\n            res[u] = len(lis)\n            for v in graph[u]:\n                if res[v] == -1:\n                    stack.append((v,))\n        else:\n            p = state[1]\n            if p >= 0:\n                lis[p] = state[2]\n            else:\n                del lis[-1]\n\nn = int(input())\nA = [int(x) for x in input().split()]\ngraph = [[] for i in range(n)]\nfor i in range(n - 1):\n    u, v = [int(x) - 1 for x in input().split()]\n    graph[u].append(v)\n    graph[v].append(u)\nres = [-1] * n\ndfs(graph, 0, A, res, [])\nprint(*res, sep='\\n')", "import bisect\nn = int(input())\n*A, = map(int, input().split())\nG = [[] for i in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    G[x - 1].append(y - 1)\n    G[y - 1].append(x - 1)\ninf = 10**10\nDP = [inf for i in range(n)]\nL = [0 for i in range(n)]\nV = [False for i in range(n)]\nQ = [(0, -1)]\nwhile Q:\n    x, a = Q.pop()\n    if a == -1:\n        V[x] = True\n        i = bisect.bisect_left(DP, A[x])\n        Q.append((i, DP[i]))\n        DP[i] = A[x]\n        L[x] = bisect.bisect_left(DP, inf)\n        for y in G[x]:\n            if not V[y]:\n                Q.append((y, -1))\n    else:\n        DP[x] = a\nprint(*L, sep='\\n')\n", "#F\nimport sys\nsys.setrecursionlimit(10**8)\nfrom bisect import bisect_left, bisect_right\nN = int(input())\na = list(map(int, input().split()))\nlists=[[] for i in range(N)]\nfor i in range(N-1):\n    u, v = map(int, input().split())\n    lists[u-1].append(v-1)\n    lists[v-1].append(u-1)\n\ndef search(v,LIS):\n    if len(lists[v])==0:\n        return\n    for u in lists[v]:\n        if check[u] == False:\n            check[u] = True\n            if a[u] > LIS[-1]:\n                LIS.append(a[u])\n                ans[u] = len(LIS)\n                search(u,LIS)\n                LIS.pop()\n            else:\n                ind = bisect_left(LIS,a[u])\n                stack = LIS[ind]\n                LIS[ind]=a[u]\n                ans[u] = len(LIS)\n                search(u,LIS)\n                LIS[ind]=stack\n    return\n\nans = [0]*N\ncheck = [False]*N\ncheck[0]=True\nLIS = [a[0]]\nans[0]=1\nsearch(0,LIS)\nprint(*ans, sep=\"\\n\")", "from bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10**7)\n\nN = int(input())\na = list(map(int, input().split()))\n\nG = [[] for i in range(N)]\nfor i in range(N-1):\n    uv = list(map(lambda x: int(x)-1, input().split()))\n    G[uv[0]].append(uv[1])\n    G[uv[1]].append(uv[0])\n\ndp = [10 ** 10 for _ in range(N+1)]\ndp[0] = -1\nans = [-1] * N\n\ndef dfs(v, p, max_):\n    i = bisect_left(dp, a[v])\n    memo = (i, dp[i])\n    dp[i] = a[v]\n\n    if i > max_:\n        max_ = i\n    ans[v] = max_\n\n    for nv in G[v]:\n        if nv == p:\n            continue\n        dfs(nv, v, max_)\n    dp[memo[0]] = memo[1]\n\ndfs(0, -1, 0)\n\nprint(*ans, sep='\\n')\n", "import sys\nsys.setrecursionlimit(2147483647)\n\nn=int(input())\na=list(map(int,input().split()))\n\ntree=[[] for _ in range(n)]\nfor _ in range(n-1):\n    aa,bb=list(map(int,input().split()))\n    tree[aa-1].append(bb-1)\n    tree[bb-1].append(aa-1)\n\nans=[0]*n\nimport bisect\n\n#bisect.bisect_left(a, 4) #\u88ab\u3063\u305f\u3089\u5de6\u5074\u306eindex\u3092\u8fd4\u3059\n#bisect.bisect_right(a, 4)#\u88ab\u3063\u305f\u3089\u53f3\u5074\u306eindex\u3092\u8fd4\u3059\n\ndef lisOnTree(x,lis):\n    nonlocal ans,tree,a,n\n    i=bisect.bisect_left(lis, a[x])\n    if i==len(lis):\n        lis.append(a[x])\n        flag=\"append\"\n    else:\n        flag=(i,lis[i])\n        lis[i]=a[x]\n    #print(x,lis)\n    ans[x]=len(lis)\n    for item in tree[x]:\n        if ans[item]==0:\n            lisOnTree(item,lis)\n    if flag==\"append\":\n        lis.pop()\n    else:\n        lis[flag[0]]=flag[1]\n\nlisOnTree(0,[])\n\nfor item in ans:\n    print(item)\n\n\n    \n\n\n"]
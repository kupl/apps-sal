["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        \n        def lca(root=root):\n            if root:\n                n1, d1 = lca(root.left)\n                n2, d2 = lca(root.right)\n                if d1 == d2:\n                    return (root, d1 + 1)\n                else:\n                    return (n1, 1 + d1) if d1 > d2 else (n2, 1 + d2)\n            return (None, -1)\n        \n        return lca()[0]\n                        \n                        \n                \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        \n        def traverse(node):\n            if not node:\n                return 0, None\n            hl, lcal = traverse(node.left)\n            hr, lcar = traverse(node.right)\n            if hl < hr:\n                return hr + 1, lcar\n            elif hl > hr:\n                return hl + 1, lcal\n            else:\n                return hl + 1, node\n            \n        return traverse(root)[1]\n        \n        \n        \n        \n                \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        \n        # get all paths\n        paths = []\n        def dfs(n, ps):\n            nonlocal paths\n            \n            if not n:\n                return\n            if not n.left and not n.right:\n                paths.append((len(ps), ps + [n]))\n            if n.left:\n                dfs(n.left, ps + [n])\n            if n.right:\n                dfs(n.right, ps + [n])\n                \n        dfs(root, [])\n        # print(paths)\n        \n        # get longest paths\n        paths = sorted(paths, key=lambda x: x[0], reverse=True)\n        longest = []\n        depth, path = paths[0]\n        for d, p in paths:\n            if d == depth:\n                longest.append(p)\n        # print([[x.val for x in xs] for xs in longest])\n        \n        # get the lowest common parent node\n        if len(longest) == 1:\n            return path[-1]\n        for i in range(len(path)):\n            if any(path[i] != p[i] for p in longest):\n                break\n        return path[i-1]\n                \n        \n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        \n        def helper(node):\n            # at each node, return depth, lca\n            if not node: return 0, None\n            h1, lca1 = helper(node.left)\n            h2, lca2 = helper(node.right)\n            if h1 > h2: return h1+1, lca1\n            if h2 > h1: return h2+1, lca2\n            if h1 == h2: return h1+1, node\n        \n        return helper(root)[1]\n            \n", "from typing import Tuple\n\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def lcaDeepestLeavesRecursive(node: TreeNode) -> Tuple[int, TreeNode]:\n            if node is None:\n                return (0, None)\n            else:\n                depthL, nodeL = lcaDeepestLeavesRecursive(node.left)\n                depthR, nodeR = lcaDeepestLeavesRecursive(node.right)\n                if depthL > depthR:\n                    return (depthL + 1, nodeL)\n                elif depthL < depthR:\n                    return (depthR + 1, nodeR)\n                else:\n                    return (depthL + 1, node)\n\n        return lcaDeepestLeavesRecursive(root)[1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self): \n        self.max_depth = 0\n        self.ancestor = None\n        \n        \n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        if not root: \n            return root\n        \n        self.dfs(root, 0)\n        return self.ancestor\n        \n    \n    def dfs(self, node: TreeNode, curr_depth) -> int:   \n        # return current deepest from that node? \n        curr_deepest_L, curr_deepest_R = curr_depth, curr_depth\n        \n        if not node.left and not node.right:\n            if curr_depth > self.max_depth:\n                self.max_depth = curr_depth\n                self.ancestor = node\n            return curr_depth\n        \n        if node.left:\n            curr_deepest_L = self.dfs(node.left, curr_depth + 1)\n        if node.right: \n            curr_deepest_R = self.dfs(node.right, curr_depth + 1)\n        \n        if curr_deepest_L == curr_deepest_R == self.max_depth: \n            self.ancestor = node\n        \n        return max(curr_deepest_L, curr_deepest_R)\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def get_depth(root):\n            if not root: return 0\n            else:\n                return max(get_depth(root.left), get_depth(root.right))+1\n        max_depth = get_depth(root)\n        \n        # print(max_depth)\n        def dfs(root, depth):\n            if not root: return root\n            if get_depth(root.left) == get_depth(root.right) == depth-1:\n                return root\n            return dfs(root.left, depth-1) or dfs(root.right, depth-1)\n        \n        return dfs(root, max_depth)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\\tdef lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n\\t\\treturn self.helper(root)[1]\n\\tdef helper(self,root):\n\\t\\tif not root:\n\\t\\t\\treturn (0,None)\n\\t\\tlevleft,lcal=self.helper(root.left)\n\\t\\tlevright,lcar=self.helper(root.right)\n\\t\\tif levleft>levright:\n\\t\\t\\treturn (levleft+1,lcal)\n\\t\\telif levleft<levright:\n\\t\\t\\treturn (levright+1,lcar)\n\\t\\treturn (levleft+1,root)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def traverse(root, level):\n            if root:\n                if not root.left and not root.right:\n                    return level, root\n                else:\n                    left_level, left_lca = traverse(root.left, level + 1)\n                    right_level, right_lca = traverse(root.right, level + 1)\n                    if left_level == right_level:\n                        return left_level, root\n                    elif left_level > right_level:\n                        return left_level, left_lca\n                    else:\n                        return right_level, right_lca\n            return float('-inf'), None\n\n        deepest_level, lca = traverse(root, 0)\n        return lca", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        dic = {}\n        explore = [root]\n        nextlevel = []\n        while explore:\n            leaf = explore\n            for node in explore:\n                if node.left:\n                    dic[node.left] = node\n                    nextlevel.append(node.left)\n                if node.right:\n                    dic[node.right] = node\n                    nextlevel.append(node.right)\n            explore, nextlevel = nextlevel, []\n        \n        newleaf = set()\n        while len(leaf) > 1:\n            for node in leaf:\n                newleaf.add(dic[node])\n            \n            leaf, newleaf = newleaf, set()\n        \n        for res in leaf:\n            return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n#   1\n# /   \\\\\n# 2    3\n\n# [1, 2,null, null,3, null, null]\n\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n      return self.helper(root)[0]\n        \n    def helper(self, root):\n        if not root:\n            return None, 0\n        n1, l1 = self.helper(root.left)\n        n2, l2 = self.helper(root.right)\n\n        if l1 > l2:\n            return n1, l1+1\n        elif l1 < l2:\n            return n2, l2+1\n        else:\n            return root, l1+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        node0, node1 = None, None\n        q = [root]\n        while q:\n            node0, node1 = q[0], q[-1]\n            q = [child for node in q for child in (node.left, node.right) if child]\n        if node0 == node1:\n            return node0\n        result = None\n        # NodeWithStatus = collections.namedtuple('NodeWithStatus', ['node','status'])\n        def lca(root: TreeNode) -> bool:\n            nonlocal result\n            if root is None:\n                return False\n            left = lca(root.left)\n            right = lca(root.right)\n            if left and right:\n                result = root\n            return (root == node0 or root == node1) or left or right\n        lca(root)\n        return result\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        \n        def getDepth(root):\n            if not root: return 0\n            return 1 + max(getDepth(root.left), getDepth(root.right))\n        \n        maxDepth = getDepth(root)\n        #print(maxDepth)\n        def helper(root, d):\n            nonlocal ans, maxDepth\n            if not root: return 0\n            \n            left = helper(root.left, d+1)\n            right = helper(root.right, d+1)\n            \n            if left == right and left == maxDepth-d-1:\n                ans = root\n            \n            return 1 + max(left, right)\n        \n        ans = None\n        helper(root, 0)\n        return ans\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import defaultdict\n\n\nclass Solution:\n    def __init__(self):\n        self.deepest = -1\n        self.m = defaultdict(list)\n        \n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        self.dfs(root, 0)\n        \n        if self.deepest == -1:\n            return None\n        if len(self.m[self.deepest]) == 1:\n            return self.m[self.deepest][0]\n        return self.lca(root, self.m[self.deepest])\n    \n    def dfs(self, node, level):\n        if node is None:\n            return\n        if level not in self.m:\n            self.m[level] = []\n        self.deepest = max(self.deepest, level)\n        self.m[level].append(node)\n        self.dfs(node.left, level+1)\n        self.dfs(node.right, level+1)\n        \n    def lca(self, x, nodes):\n        if x is None:\n            return x\n        for node in nodes:\n            if node == x:\n                return x\n        left = self.lca(x.left, nodes)\n        right = self.lca(x.right, nodes)\n        if left is not None and right is not None:\n            return x\n        return left if left is not None else right", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.mapper = {}\n\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n\n        self.traverse_tree(root, [])\n        \n        for key, vals in self.mapper.items():\n            print(f'{key}: {[item.val for item in vals]}')\n        \n        lst_of_nodes = list(self.mapper.values())\n        if len(lst_of_nodes) == 1:\n            return lst_of_nodes[0][-1]\n        \n        common = None\n        length = max(map(len, lst_of_nodes))\n        \n        for i in range(length):\n            curr = None\n            for nodes in lst_of_nodes:\n                if len(nodes) < length:\n                    continue\n                if not curr:\n                    curr = nodes[i]\n                    continue\n                if curr == nodes[i]:\n                    continue\n                else:\n                    return common\n            common = curr\n        return common\n                \n        \n                \n\n                \n        \n    def traverse_tree(self, node: TreeNode, ancestors: list) -> None:\n        if not node:\n            return\n        new_lst = ancestors.copy()\n        new_lst.append(node)\n        if not node.left and not node.right:\n            self.mapper[node.val] = new_lst\n        \n        self.traverse_tree(node.left, new_lst)\n        self.traverse_tree(node.right, new_lst)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def height(root):\n            if not root:\n                return 0\n            return 1+max(height(root.left),height(root.right))\n        if height(root.left)==height(root.right):\n            return root\n        elif height(root.left)>height(root.right):\n            return self.lcaDeepestLeaves(root.left)\n        return self.lcaDeepestLeaves(root.right)"]
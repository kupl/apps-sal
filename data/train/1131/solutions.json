["for _ in range(int(input())):\n    n,k=[int(x) for x in input().split()]\n    a=list(map(int,input().split()))\n    dp=[0]*(max(a)+1)\n    for _ in range(n):\n        dp[a[_]]+=1\n    for _ in range(1,len(dp)):\n        if dp[_]>k:\n            print(_,end=\" \")\n    print()", "from collections import Counter\r\nfor _ in range(int(input())):\r\n    a,b=map(int,input().split())\r\n    ar=list(map(int,input().split()))\r\n    ar=Counter(ar)\r\n    dr=[]\r\n    for i in ar:\r\n        if(ar[i]>b):\r\n            dr.append(i)\r\n    dr.sort()\r\n    print(*dr)", "t = int(input())\nfor _ in range(t):\n    n,k = map(int,input().split())\n    l = list(map(int,input().split()))\n    l.sort()\n    count = 1\n    a = []\n    for i in range(n-1):\n        if l[i]==l[i+1]:\n            count += 1\n        else:\n            if count > k:\n                a.append(l[i])\n                count = 1\n    if count >k:\n        a.append(l[-1])\n    print(*a)", "# cook your dish here\nimport itertools as it\nfor case in range(int(input())):\n    n,k=map(int,input().split())\n    array=list(map(int,input().split()))\n    array.sort()\n    new_map=list(map(str,array))\n    store=it.groupby(new_map,key=None)\n    new_dict={item:len(list(length)) for item,length in store}\n    \n    for i,j in new_dict.items():\n        if j>k:\n            print(i,end=\" \")\n    \n        \n        \n        \n    \n", "# cook your dish here\nt = int(input())\nwhile t:\n    n, k = map(int, input().split())\n    arr = [int(i) for i in input().split()]\n    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    z = []\n    for i in d:\n        if d[i] > k:\n            z.append(i)\n    z.sort()\n    print(*z)\n    t -= 1", "# cook your dish here\nt = int(input())\nwhile t:\n    n, k = map(int, input().split())\n    arr = [int(i) for i in input().split()]\n    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    z = []\n    for i in d:\n        if d[i] > k:\n            z.append(i)\n    z.sort()\n    print(*z)\n    t -= 1", "for _ in range(int(input())):\n    n,k=[int(x) for x in input().split()]\n    a=list(map(int,input().split()))\n    dp=[0]*(max(a)+1)\n    for _ in range(n):\n        dp[a[_]]+=1\n    for _ in range(1,len(dp)):\n        if dp[_]>k:\n            print(_,end=\" \")\n    print()        \n        ", "t=int(input())\nfor i in range(t):\n    n,k=list(map(int,input().split()))\n    arr=[int(x) for x in input().split()]\n    d={}\n    for i in arr:\n        if i in d:\n            d[i]=d[i]+1\n        else:\n            d[i]=1\n    l=[]\n    for i in list(d.keys()):\n        if d[i]>k:\n            l.append(i)\n    l.sort()\n    print(*l)\n", "import sys\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\ninp = lambda: list(map(int,sys.stdin.readline().rstrip(\"\\r\\n\").split()))\r\n#______________________________________________________________________________________________________\r\n# from math import *\r\n# from bisect import *\r\n# from heapq import *\r\n# from collections import defaultdict as dd\r\n# from collections import OrderedDict as odict\r\nfrom collections import Counter as cc\r\n# from collections import deque\r\n# sys.setrecursionlimit(2*(10**5)+100) this is must for dfs\r\nmod = 10**9+7; md = 998244353\r\n# ______________________________________________________________________________________________________\r\n# segment tree for range minimum query\r\n# sys.setrecursionlimit(10**5)\r\n# n = int(input())\r\n# a = list(map(int,input().split()))\r\n# st = [float('inf') for i in range(4*len(a))]\r\n# def build(a,ind,start,end):\r\n# \tif start == end:\r\n# \t\tst[ind] = a[start]\r\n# \telse:\r\n# \t\tmid = (start+end)//2\r\n# \t\tbuild(a,2*ind+1,start,mid)\r\n# \t\tbuild(a,2*ind+2,mid+1,end)\r\n# \t\tst[ind] = min(st[2*ind+1],st[2*ind+2])\r\n# build(a,0,0,n-1)\r\n# def query(ind,l,r,start,end):\r\n# \tif start>r or end<l:\r\n# \t\treturn float('inf')\r\n# \tif l<=start<=end<=r:\r\n# \t\treturn st[ind]\r\n# \tmid = (start+end)//2\r\n# \treturn min(query(2*ind+1,l,r,start,mid),query(2*ind+2,l,r,mid+1,end))\r\n# ______________________________________________________________________________________________________\r\n# Checking prime in O(root(N))\r\n# def isprime(n):\r\n#     if (n % 2 == 0 and n > 2) or n == 1: return 0\r\n#     else:\r\n#         s = int(n**(0.5)) + 1\r\n#         for i in range(3, s, 2):\r\n#             if n % i == 0:\r\n#                 return 0\r\n#         return 1\r\n# def lcm(a,b):\r\n#   return (a*b)//gcd(a,b)\r\n# ______________________________________________________________________________________________________\r\n# nCr under mod\r\n# def C(n,r,mod):\r\n#   if r>n:\r\n#       return 0\r\n#   num = den = 1\r\n#   for i in range(r):\r\n#       num = (num*(n-i))%mod\r\n#       den = (den*(i+1))%mod\r\n#   return (num*pow(den,mod-2,mod))%mod\r\n# M = 10**5 +10\r\n# ______________________________________________________________________________________________________\r\n# For smallest prime factor of a number\r\n# M = 1000010\r\n# pfc = [i for i in range(M)]\r\n# def pfcs(M):\r\n#   for i in range(2,M):\r\n#       if pfc[i]==i:\r\n#           for j in range(i+i,M,i):\r\n#               if pfc[j]==j:\r\n#                   pfc[j] = i\r\n#   return\r\n# pfcs(M)\r\n# ______________________________________________________________________________________________________\r\ntc = 1\r\ntc, = inp()\r\nfor _ in range(tc):\r\n\tn,k = inp()\r\n\ta = inp()\r\n\tb = cc(a)\r\n\tans = []\r\n\tfor i in b.keys():\r\n\t\tif b[i]>k:\r\n\t\t\tans.append(i)\r\n\tans.sort()\r\n\tprint(*ans)", "from collections import Counter\r\n\r\nfor _ in range(int(input())):\r\n    n, k = map(int, input().split())\r\n    a = list(map(int, input().split()))\r\n\r\n    c = Counter(a)\r\n\r\n    x = []\r\n    for i in c:\r\n        if c[i] > k:\r\n            x.append(i)\r\n\r\n    print(*sorted(x))", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nfor _ in range(int(inp())):\n    n, s = mp()\n    a = lmp()\n    md = {}\n    for i in a:\n        if i in md: md[i]+=1\n        else: md[i]=1\n    ansl = []\n    for k, v in md.items():\n        if v>s: ansl.append(k)\n    print(*sorted(ansl))", "from sys import*\r\ninput=stdin.readline\r\nt=int(input())\r\nfor _ in range(t):\r\n    n,k=map(int,input().split())\r\n    l=[int(x) for x in input().split()]\r\n    mp={}\r\n    for items in l:\r\n        try:\r\n            mp[items]+=1\r\n        except:\r\n            mp[items]=1\r\n    l=list(set(l))\r\n    l.sort()\r\n    for items in l:\r\n        if mp[items]>k:\r\n            print(items,end=\" \")\r\n    print() \r\n  ", "# cook your dish here\nfrom collections import Counter\n\nfor j in range(int(input())):\n    n,k = map(int,input().split())\n    a=[int(x) for x in input().split()]\n    z=Counter(a)\n    p=[]\n    for i in z:\n        if z[i]>k:\n            p.append(i)\n    print(*sorted(p))"]
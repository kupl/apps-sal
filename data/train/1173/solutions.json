["import itertools\nfrom collections import defaultdict as dfd\ndef sumPairs(arr, n):\n s = 0\n for i in range(n-1,-1,-1): \n  s += i*arr[i]-(n-1-i)*arr[i]\n return s\n\ndef subarrayXor(arr, n, m):\n ans = 0\n xorArr =[0 for _ in range(n)]\n mp = dfd(list)\n xorArr[0] = arr[0]\n for i in range(1, n): \n  xorArr[i] = xorArr[i - 1] ^ arr[i]\n for i in range(n):\n  mp[xorArr[i]].append(i)\n a = sorted(mp.items())\n #print(xorArr)\n #print(a)\n for i in a:\n  diffs=0\n  if(i[0]!=0):\n   l = len(i[1])-1\n   ans += sumPairs(i[1],len(i[1]))-((l*(l+1))//2)\n   \n  else:\n   l = len(i[1])-1\n   ans += sumPairs(i[1],len(i[1]))-((l*(l+1))//2)\n   ans += sum(i[1])\n return ans\n\nfor _ in range(int(input())):\n n = int(input())\n arr = list(map(int,input().split()))\n print(subarrayXor(arr,len(arr),0))", "# cook your dish here\nfor i in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n sum=0\n count=0\n for i in range(0,n):\n  sum=a[i]\n  for j in range(i+1,n):\n   sum=sum^a[j]\n   #print(sum)\n   if(sum==0):\n    count=count+(j-i)\n   \n print(count)", "import random, math\nfrom copy import deepcopy as dc\nfrom bisect import bisect_left, bisect_right\n\n\n\n# Function to call the actual solution\ndef solution(li):\n ma = {}\n st = {}\n ma[0] = 1\n st[0] = 1\n s = 0\n c = 0\n for i in range(len(li)):\n  s ^= li[i]\n  c += (ma.get(s, 0)*(i+1)) - st.get(s, 0)\n  ma[s] = ma.get(s, 0) + 1\n  st[s] = st.get(s, 0) + i + 2\n return c\n\n\n# Function to take input\ndef input_test():\n for _ in range(int(input())):\n  n = int(input())\n  # a, b = map(int, input().strip().split(\" \"))\n  # a, b, c = map(int, input().strip().split(\" \"))\n  li = list(map(int, input().strip().split(\" \")))\n  out = solution(li)\n  print(out)\n\n# Function to check test my code\ndef test():\n pass\n\n\ninput_test()\n# test()\n", "# cook your dish here\nfrom functools import reduce\nfrom operator import xor \n\nfor _ in range(int(input())):\n n = int( input() )\n a = list( map( int, input().split() ) )\n \n ans = 0\n \n for i in range(1, n):\n  for j in range(i):\n   res = reduce(xor, a[j:j+n-i+1])\n   #print(res, a[j:j+n-i+1])\n   if( res == 0 ):\n    ans += n-i\n    \n print(ans)", "# cook your dish here\nt=int(input())\nwhile t:\n t-=1\n n=int(input())\n a=list(map(int,input().split()))\n dp=[a[0]]\n cnt=0\n value,rang=dict(),dict()\n value[dp[0]]=0\n rang[dp[0]]=0\n for i in range(1,n):\n  dp.append(dp[i-1]^a[i])\n  value[dp[i]]=0\n  rang[dp[i]]=0\n \n for i in range(n):\n  if value[dp[i]] >0:\n   if dp[i]==0:\n    cnt+=i\n    cnt+=(i-1)*value[dp[i]]-rang[dp[i]]\n    value[dp[i]]+=1\n    rang[dp[i]]+=i\n   else:\n    cnt+=(i-1)*value[dp[i]]-rang[dp[i]]\n    value[dp[i]]+=1\n    rang[dp[i]]+=i\n    \n  else:\n   if dp[i]==0:\n    cnt+=i\n   value[dp[i]]+=1\n   rang[dp[i]]+=i\n \n print(cnt)", "t=int(input())\nfor _ in range(t):\n n=int(input())\n l=list(map(int,input().split()))\n ans=0\n \n \n m=[0]*n\n for i in range(n):\n  if i==0:\n   m[i]=l[i]\n  else:\n   m[i]=m[i-1]^l[i]\n d={}\n c=0\n for i in l:\n  c=c^i\n \n for i in range(n-1,-1,-1):\n  try:\n   x=d[l[i]^c]\n   ans+=x[0]-x[1]*i\n  except:\n   pass\n  try:\n   d[m[i]]=[d[m[i]][0]+i,d[m[i]][1]+1]\n  except:\n   d[m[i]]=[i,1]\n  c=c^l[i]\n print(ans)\n", "t=int(input())\nfor _ in range(t):\n n=int(input())\n l=list(map(int,input().split()))\n ans=0\n for i in range(n):\n  x=0\n  for j in range(i+1,n):\n   x^=l[j]\n   if x==l[i]:\n    ans+=j-i\n\n print(ans)\n  \n", "import math\n\nfor _ in range(int(input())):\n N = int(input())\n Arr = [int(o) for o in input().split()]\n res = 0\n xor_array = [0]*1000000\n length = [0]*1000000\n x = [0]*1000000\n xor_val = 0\n xor_array[0] = 1\n x[0] = -1\n for i in range(N):\n  cnt = 0\n  xor_val = xor_val^Arr[i]\n  if xor_array[xor_val]:\n   cnt = i-x[xor_val]\n   length[xor_val] = length[xor_val] + ((xor_array[xor_val]*cnt)-1)\n   res += length[xor_val]\n  x[xor_val] = i\n  xor_array[xor_val] += 1\n print(res)", "t = int(input())\n\nfor _ in range(t):\n n = int(input())\n arr = list(map(int, input().strip().split()))\n\n prefix_xor = [arr[0]]\n for i in range(1, len(arr)):\n  prefix_xor.append(prefix_xor[-1] ^ arr[i])\n\n xor_map = {0: [1, 0]}\n total_triplets = 0\n\n for index, elem in enumerate(prefix_xor):\n  if elem not in xor_map:\n   xor_map[elem] = [1, index+1]\n  else:\n   cnt, sum_all_pos = xor_map[elem][0], xor_map[elem][1]\n   total_triplets += cnt * (index+1) - cnt - sum_all_pos\n   xor_map[elem][0] += 1\n   xor_map[elem][1] += (index+1)\n\n print(total_triplets)\n", "# cook your dish here\nx=int(input())\nfor m in range(x):\n y=int(input())\n l=list(map(int,input().split(\" \")))\n count=0\n for i in range(y-1):\n  f=l[i]\n  for j in range(i+1,y):\n   f=f^l[j]\n   if f==0:\n    count+=j-i\n print(count)", "# cook your dish here\n# import atexit\n# import io\n# import sys\n#\n#\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n#\n#\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n#\n# # Brute force approach\n# R = lambda :map(int,input().split())\n# t = int(input())\n# for i in range(t):\n#     n = int(input())\n#     lst = list(R())\n#     cnt = 0\n#     for i in range(n):\n#         temp = 0\n#         for j in range(i,n):\n#             temp^=lst[j]\n#             if temp==0:\n#                 cnt+=j-i\n#\n#     print(cnt)\ndef sumPairs(arr,n):\n sum = 0\n for i in range(n-1,-1,-1):\n  sum+= i*arr[i]-(n-1-i)*arr[i]\n return sum-((n*(n-1))//2)\n\nR = lambda :list(map(int,input().split()))\nt = int(input())\nfor _ in range(t):\n n = int(input())\n xs = list(map(int,input().split()))\n xor = 0\n dict = {0: [0]}\n count = 0\n i = 0\n # for i in range(1,len(xs)):\n #     xs[i]=xs[i-1]^xs[i]\n # print(xs)\n for x in xs:\n  xor = xor ^ x\n  if xor not in dict:\n   dict[xor] = [i + 1]\n  else:\n   # for j in dict[xor]:\n   #     count += (i + 1) - j - 1\n   dict[xor].append(i + 1)\n  i+=1\n ans = 0\n for i in list(dict.values()):\n  if len(i)==1:\n   continue\n  else:\n   ans+=(sumPairs(i,len(i)))\n\n\n # print(dict)\n print(ans)\n", "for _ in range(int(input())):\n n=int(input())\n a=list(map(int, input().split()))\n xorsum=[]\n xor=0\n xorsum.append(xor)\n for i in range(len(a)):\n  xor^=a[i]\n  xorsum.append(xor)\n  \n xordict=dict()\n for i in range(len(xorsum)):\n  if xorsum[i] in xordict:\n   xordict[xorsum[i]].append(i)\n  else:\n   xordict[xorsum[i]] = [i]\n ans=0\n for key in xordict:\n  for i in range(1,len(xordict[key])):\n   x=(i*xordict[key][i])-(i)-(sum(xordict[key][:i]))\n   ans+=x\n print(ans)", "for _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n c = 0\n s = set()\n for i in range(0, n - 1):\n  for k in range(1, n):\n   \n   # check\n   x = 0\n   for y in a[i: k + 1]:\n    x ^= y\n   if x == 0:\n    \n    # update set\n    for j in range(i + 1, k + 1):\n     if (i, j, k) not in s:\n      s.add((i, j, k))\n      c += 1\n   \n print(c)", "# cook your dish here\n# cook your dish here\nt=int(input())\nwhile t>0:\n n=int(input())\n inp=[int(i) for i in input().split()]\n #print(inp)\n t=t-1\n xorarr=[0]*n\n xorarr[0]=inp[0]\n mydict=dict()\n mydict[xorarr[0]]=1\n for i in range(1,n):\n  xorarr[i]=xorarr[i-1]^inp[i]\n  if xorarr[i] not in mydict:\n   mydict[xorarr[i]]=1\n  else:\n   mydict[xorarr[i]]=mydict[xorarr[i]]+1\n #print(xorarr)\n #print(mydict)\n mydicts=dict()\n sums=0\n for i in range(n):\n  if xorarr[i]==0:\n   sums=sums+i\n   \n  if xorarr[i] not in mydicts:\n   val=0-i*(mydict[xorarr[i]]-1)\n   mydicts[xorarr[i]]=[1,val]\n   \n  else:\n   val=(2*mydicts[xorarr[i]][0]-mydict[xorarr[i]]+1)*i\n   mydicts[xorarr[i]][0]+=1\n   mydicts[xorarr[i]][1]+=val \n #print(mydicts)\n \n for i in list(mydicts.keys()):\n  sums=sums+mydicts[i][1]-(mydict[i]*(mydict[i]-1)/2)\n  \n print(int(sums))\n #print(mydicts)\n", "import itertools \n \ndef findsubsets(s, n): \n return tuple(itertools.combinations(s, n)) \ndef xorfunc(low, hi ,a):\n xor1=0\n for i in range(low,hi+1):\n  xor1^=a[i]\n if xor1==0:\n  return hi-low\n else:\n  return 0\n \n \n \nt=int(input())\nfor i in range(t):\n n=int(input())\n a=input()\n a=a.split()\n a=[int(it) for it in a]\n xor=0\n xorsum=[]\n for i in a:\n  xor^=i\n  xorsum.append(xor)\n  \n interlist=[i for i in range(n)]\n interlist2=findsubsets(interlist,2)\n \n interlist2=[xorfunc(i,j,a) for i,j in interlist2]\n print(sum(interlist2))", "# cook your dish here\ntest_cases = int(input())\nfor test in range(test_cases):\n n = int(input())\n seq = list(map(int, input().split()))\n \n triplets = 0\n res = [0 for _ in range(n+1)]\n for i in range(1, n+1):\n  res[i] = res[i-1] ^ seq[i-1]\n \n xors = {}\n for i in range(n+1):\n  if res[i] not in xors:\n   xors[res[i]] = [i]\n  else:\n   xors[res[i]].append(i)\n \n #print(xors)\n for key in xors.keys():\n  if len(xors[key]) > 1:\n   for i in range(len(xors[key])-1):\n    for j in range(i+1, len(xors[key])):\n     triplets += int(xors[key][j] - xors[key][i] - 1)\n print(triplets)", "# cook your dish here\ntest_cases = int(input())\nfor test in range(test_cases):\n n = int(input())\n seq = list(map(int, input().split()))\n \n triplets = 0\n res = [0 for _ in range(n)]\n for i in range(n-1):\n  res[i] = seq[i]\n  for j in range(i+1, n):\n   res[j] = res[j-1] ^ seq[j]\n   if res[j] == 0:\n    triplets += (j - i)\n print(triplets)\n", "# cook your dish here\ntest_cases = int(input())\nfor test in range(test_cases):\n n = int(input())\n seq = list(map(int, input().split()))\n \n triplets = 0\n for i in range(n):\n  res = [0 for _ in range(n)]\n  res[i] = seq[i]\n  for j in range(i+1, n):\n   res[j] = res[j-1] ^ seq[j]\n   if res[j] == 0:\n    triplets += (j - i)\n print(triplets)\n", "from collections import defaultdict\ndef solve(C,N):\n cnt=defaultdict(list)\n cnt[0].append(-1)\n r=0\n for i in range(len(C)):\n  r=r^C[i]\n  cnt[r].append(i)\n res=0\n for l in cnt:\n  x=len(cnt[l])-1\n  neg=x\n  y=0\n  for k in range(len(cnt[l]))[::-1]:\n   y+=x*cnt[l][k]-neg\n   x-=2 \n   neg-=1\n  res+=y\n return res\n\ndef main():\n for _ in range(int(input())):\n  N=int(input())\n  C=list(map(int,input().split()))\n  print(solve(C,N))\nmain()", "from collections import defaultdict\ndef solve(C,N):\n ar=[(0,-1)]\n cnt=defaultdict(list)\n cnt[0].append(-1)\n r=0\n for i in range(len(C)):\n  r=r^C[i]\n  cnt[r].append(i)\n # print(cnt)\n res=0\n for l in cnt:\n  for k in range(len(cnt[l])-1):\n   for j in range(k+1,len(cnt[l])):\n    # print(l,cnt[l][k],cnt[l][j],abs(cnt[l][k]-cnt[l][j])-1)\n    res+=abs(cnt[l][k]-cnt[l][j])-1\n return res\n\ndef main():\n for _ in range(int(input())):\n  N=int(input())\n  C=list(map(int,input().split()))\n  print(solve(C,N))\nmain()", "for testcase in range(int(input())):\n n= int(input())\n a = [0] + list(map(int, input().split()))\n sum = [0]*(2000020)\n cnt = [0]*(2000020)\n s = 0\n ans = 0\n cnt[0] = 1\n sum[0] = 1\n for i in range(1, len(a)):\n  s ^= a[i]\n  ans += i*cnt[s] - sum[s]\n  cnt[s] += 1\n  sum[s] += i+1\n print(ans)", "for _ in range(int(input())):\n n= int(input())\n a = [0] + list(map(int, input().split()))\n sum = [0]*(2000020)\n cnt = [0]*(2000020)\n s = 0\n ans = 0\n cnt[0] = 1\n sum[0] = 1\n for i in range(1, len(a)):\n  s ^= a[i]\n  ans += i*cnt[s] - sum[s]\n  cnt[s] += 1\n  sum[s] += i+1\n print(ans)\n"]
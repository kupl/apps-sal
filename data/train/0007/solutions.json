["import sys\ndef I():\n    return sys.stdin.readline().rstrip()\n\nclass Heap:\n    def __init__( self ):\n        self.l = [ -1 ]\n        self.n = 0\n    def n( self ):\n        return self.n\n    def top( self ):\n        return self.l[ 1 ]\n    def ins( self, x ):\n        self.l.append( x )\n        n = len( self.l ) - 1\n        i = n\n        while i > 1:\n            j = i // 2\n            if self.l[ j ] > self.l[ i ]:\n                self.l[ j ], self.l[ i ] = self.l[ i ], self.l[ j ]\n                i = j\n            else:\n                break\n    def pop( self ):\n        r = self.l[ 1 ]\n        l = self.l.pop()\n        n = len( self.l ) - 1\n        if n:\n            self.l[ 1 ] = l\n            i = 1\n            while True:\n                j = i * 2\n                k = j + 1\n                if k < len( self.l ) and self.l[ i ] > max( self.l[ j ], self.l[ k ] ):\n                    if self.l[ j ] == min( self.l[ j ], self.l[ k ] ):\n                        self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\n                        i = j\n                    else:\n                        self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\n                        i = k\n                elif k < len( self.l ) and self.l[ i ] > self.l[ k ]:\n                    self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\n                    i = k\n                elif j < len( self.l ) and self.l[ i ] > self.l[ j ]:\n                    self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\n                    i = j\n                else:\n                    break\n        return r\n\nt = int( I() )\nfor _ in range( t ):\n    n = int( I() )\n    voter = [ list( map( int, I().split() ) ) for _ in range( n ) ]\n    h = Heap()\n    d = {}\n    for m, p in voter:\n        if m not in d:\n            d[ m ] = []\n        d[ m ].append( p )\n    need = {}\n    c = 0\n    sk = sorted( d.keys() )\n    for m in sk:\n        need[ m ] = max( 0, m - c )\n        c += len( d[ m ] )\n    c = 0\n    ans = 0\n    for m in sk[::-1]:\n        for p in d[ m ]:\n            h.ins( p )\n        while c < need[ m ]:\n            c += 1\n            ans += h.pop()\n    print( ans )\n", "import heapq\nimport sys\ninput = sys.stdin.readline\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    info = [list(map(int, input().split())) for i in range(n)]\n    info = sorted(info)\n    cnt = [0] * n\n    for i in range(n):\n        ind = info[i][0]\n        cnt[ind] += 1\n    ruiseki_cnt = [0] * (n+1)\n    for i in range(n):\n        ruiseki_cnt[i+1] = ruiseki_cnt[i] + cnt[i]\n    # print(cnt)\n    # print(ruiseki_cnt)\n    need = [0] * n\n    for i in range(1,n):\n        if cnt[i] != 0 and i > ruiseki_cnt[i]:\n            need[i] = min(i - ruiseki_cnt[i], i)\n    # print(need)\n    info = sorted(info, reverse = True)\n    #print(info)\n\n    num = n - 1\n    pos = 0\n    q = []\n    used_cnt = 0\n    ans = 0\n    while True:\n        if num == -1:\n            break\n        while True:\n            if pos < n and info[pos][0] >= num:\n                heapq.heappush(q, info[pos][1])\n                pos += 1\n            else:\n                break\n        if need[num] - used_cnt > 0:\n            tmp = need[num] - used_cnt\n            for _ in range(tmp):\n                ans += heapq.heappop(q)\n            used_cnt += tmp\n        num -= 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\nimport heapq\nfrom itertools import accumulate\n\nt=int(input())\n\nfor test in range(t):\n    n=int(input())\n    M=[[] for i in range(n)]\n    MCOUNT=[0]*(n)\n\n    for i in range(n):\n        m,p=list(map(int,input().split()))\n        M[m].append(p)\n        MCOUNT[m]+=1\n\n    #print(M)\n    #print(MCOUNT)\n\n    ACC=list(accumulate(MCOUNT))\n\n    #print(ACC)\n    HQ=[]\n    ANS=0\n    use=0\n\n    for i in range(n-1,-1,-1):\n        for j in M[i]:\n            heapq.heappush(HQ,j)\n\n        #print(HQ)\n            \n        while ACC[i-1]+use<i:\n            x=heapq.heappop(HQ)\n            ANS+=x\n            use+=1\n\n\n\n    print(ANS)\n            \n            \n        \n        \n        \n\n    \n\n    \n", "import sys\nfrom heapq import heappop, heappush\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n \nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    mp = []\n    for i in range(n):\n        mi, pi = list(map(int, input().split()))\n        mp.append((mi, pi))\n    mp.sort()\n    \n    prices = []\n    cost = 0\n    bribed = 0\n    i = n - 1\n    while i >= 0:\n        currM = mp[i][0]\n        heappush(prices, mp[i][1])\n        while i >= 1 and mp[i-1][0] == currM:\n            i -= 1\n            heappush(prices, mp[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heappop(prices)\n            bribed += 1\n        i -= 1\n    \n    print(cost)\n", "import sys\ninput = sys.stdin.readline\nimport heapq as hq\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  vt = [list(map(int,input().split())) for i in range(n)]\n  vt.sort(reverse=True)\n  q = []\n  hq.heapify(q)\n  ans = 0\n  cnt = 0\n  for i in range(n):\n    hq.heappush(q,vt[i][1])\n    if vt[i][0] >= n-i+cnt:\n      ans += hq.heappop(q)\n      cnt += 1\n  print(ans)", "import sys\nimport heapq as hq\n\nreadline = sys.stdin.readline\nread = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    vot = [tuple(nm()) for _ in range(n)]\n    vot.sort(key = lambda x: (-x[0], x[1]))\n    q = list()\n    c = 0\n    cost = 0\n    for i in range(n):\n        hq.heappush(q, vot[i][1])\n        while n - i - 1 + c < vot[i][0]:\n            cost += hq.heappop(q)\n            c += 1\n    print(cost)\n    return\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n", "import sys\nimport heapq as hp\n#sys.stdin = open('in', 'r')\nt = int(sys.stdin.readline())\nfor ti in range(t):\n    n = int(sys.stdin.readline())\n    a = [tuple(map(int, sys.stdin.readline().split())) for i in range(n)]\n    a.sort(key = lambda x: (x[0], -x[1]))\n    c = 0\n    h = []\n    res = 0\n    for i in range(n-1,-1,-1):\n        hp.heappush(h, a[i][1])\n        while c + i < a[i][0]:\n            res += hp.heappop(h)\n            c += 1\n    print(res)\n\n\n#sys.stdout.write('YES\\n')\n#sys.stdout.write(f'{res}\\n')\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\n')\n", "import sys\nfrom heapq import *\n#sys.stdin = open('in', 'r')\nt = int(sys.stdin.readline())\nfor ti in range(t):\n    n = int(sys.stdin.readline())\n    a = [tuple(map(int, sys.stdin.readline().split())) for i in range(n)]\n    a.sort(key = lambda x: (x[0], -x[1]))\n    c = 0\n    h = []\n    res = 0\n    for i in range(n-1,-1,-1):\n        heappush(h, a[i][1])\n        while c + i < a[i][0]:\n            res += heappop(h)\n            c += 1\n    print(res)\n\n\n#sys.stdout.write('YES\\n')\n#sys.stdout.write(f'{res}\\n')\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\n')\n"]
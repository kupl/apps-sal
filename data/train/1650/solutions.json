["from itertools import combinations_with_replacement\n\ndef find_all(sum_dig, digs):\n    combs = combinations_with_replacement(list(range(1, 10)), digs)\n    target = [''.join(str (x) for x in list(comb)) for comb in combs if sum(comb) == sum_dig]\n    if not target:\n        return []\n    return [len(target), int(target[0]), int(target[-1])]\n", "def find_all(s, d):\n    xs = [x for x in digs(d) if sum(x) == s]\n    if not xs:\n        return []\n    else:\n        reduce_int = lambda xs: int(''.join(map(str, xs)))\n        min = reduce_int(xs[0])\n        max = reduce_int(xs[-1])    \n        return [len(xs), min, max]\n\ndef digs(d, start=1):\n    \"\"\"\n    >>> list(digs(3, start=9))\n    [[9, 9, 9]]\n    >>> list(digs(2, start=8))\n    [[8, 8], [8, 9], [9, 9]]\n    \"\"\"\n    if d == 1:\n        for x in range(start, 10):\n            yield [x]\n    else:\n        for x in range(start, 10):\n            for y in digs(d - 1, x):\n                yield [x] + y", "from itertools import combinations_with_replacement\n\ndef find_all(sum_dig, digs):\n    x = [int(''.join(x)) for x in combinations_with_replacement('123456789', digs) if sum(map(int, x)) == sum_dig]\n    return [len(x), min(x), max(x)] if len(x) > 0 else []\n", "def next_contig_number(n):\n    n = [int(x) for x in str(n+1)]\n    \n    for i in range(1, len(n)):\n        n[i] = max(n[i], n[i-1])\n    \n    return int(\"\".join(map(str, n)))\n\ndef find_all(sum_dig, digs):\n    count = 0\n    smallest = float(\"Inf\")\n    largest = float(\"-Inf\")\n    \n    n = 10**(digs-1)\n    limit = 10**(digs) - 1\n    \n    while (n < limit):\n        n = next_contig_number(n)\n\n        total = 0\n        for x in map(int, str(n)):\n            total += x\n            if total > sum_dig: break\n\n        if total == sum_dig:\n            count += 1\n            smallest = min(smallest, n)\n            largest = max(largest, n)\n    \n    return [count, smallest, largest] if count else []", "def ways(t, n, d):\n    return [e for l in [[int(str(i)+str(e)) for e in ways(t-i, n-1, [k for k in d if k>= i])] for i in d] for e in l] if n > 1 else [t] if t in d else []\n\ndef find_all(target, n):\n    r = ways(target, n, [1,2,3,4,5,6,7,8,9])\n    return [len(r), min(r), max(r)] if r else []", "def find_all(sum_dig, digits):\n    if sum_dig > digits * 9:\n        return []\n    \n    num = [1] * digits\n    res = []\n    \n    while num[0] != 10:\n        if sum(num) == sum_dig:\n            res.append(int(''.join(map(str, num))))\n        \n        for i in range(digits-1, -1, -1):\n            num[i] += 1\n            if num[i] != 10:\n                break\n        \n        for i in range(1, digits):\n            if num[i] == 10:\n                num = num[:i] + [ num[i-1] ] * (digits-i)\n                break\n    \n    return [ len(res), res[0], res[-1] ]", "def num_ways(sum_dig, digs, ceiling=8):\n    if sum_dig < 0: return 0\n    if sum_dig == 0:    return 1\n    if sum_dig > digs * ceiling:    return 0\n    if sum_dig == 1:    return 1\n    if digs == 1:\n        return 1 if 0 <= sum_dig <= ceiling else 0\n    targ_num = 0\n    for i in range(10):\n        targ_num += num_ways(sum_dig-i*digs, digs-1, ceiling=ceiling-i)\n    return targ_num\n\n\n\ndef find_all(sum_dig, digs):\n    min_sum = digs\n    max_sum = digs * 9\n    if sum_dig < min_sum or sum_dig > max_sum:\n        return []\n    min_list = [1 for i in range(digs)]\n    min_sum_dig = sum_dig - digs\n    for i in reversed(list(range(digs))):\n        if min_sum_dig <= 8:\n            min_list[i] += min_sum_dig\n            break\n        else:\n            min_list[i] += 8\n            min_sum_dig -= 8\n    min_num = int(''.join([str(i) for i in min_list]))\n    max_base = int(sum_dig/digs)\n    max_list = [max_base for i in range(digs)]\n    for i in range(sum_dig%digs):\n        max_list[-1-i] += 1\n    max_num = int(''.join([str(i) for i in max_list]))\n    num_way = num_ways(sum_dig-digs, digs)\n    return [num_way, min_num, max_num]\n\n\n\n", "def find_all(sum_dig, digs):\n    if sum_dig > 9*digs: return []\n    all = [x for x in growing_digits(digs-1) if digit_sum(x) == sum_dig]\n    return [len(all), all[0], all[-1]]\n    \ndef digit_sum(num):\n    ''' returns the sum of the digits of a number '''\n    return sum(int(digit) for digit in str(num))\n\ndef growing_digits(order, start=1):\n    ''' A little recursive generator magic\n        returns all numbers of order+1 digits\n        such that the digits are non-decreasing\n    '''\n    for l in range(start,10):\n        if order==0:\n            yield l\n        else:\n            for r in growing_digits(order-1, start=l):\n                yield l*10**order+r", "def find_all(sum_dig, digs):\n    mn = float(\"inf\")\n    mx = -float(\"inf\")\n    def rec(i,sm,path):\n        nonlocal mn,mx\n        if i>=digs:\n            if sum_dig==sm:\n                num = int(\"\".join(path))\n                mn = min(mn,num)\n                mx = max(mn,num)\n                return 1\n            else:\n                return 0\n        j = 1\n        if path:\n            j = int(path[-1])\n        res = 0\n        for k in range(j,10):\n            res+=rec(i+1,sm+k,path+[str(k)])\n        return res\n    cnt = rec(0,0,[])\n    if mn==float(\"inf\") or mx==-float(\"inf\"):\n        return []\n    return [cnt,mn,mx]", "def find_all(sum_dig, digs):\n    def rec(ds = digs, min_dig = 1, sum_prev = 0):\n        for i in range(min_dig, 10):\n            sum_cur = sum_prev + i\n            if ds == 1:\n                if sum_cur == sum_dig: \n                    yield str(i)\n            elif sum_cur < sum_dig:\n                for r in rec(ds - 1, i, sum_cur):\n                     yield str(i) + r\n    results = [int(s) for s in rec()]\n    return [len(results), min(results), max(results)] if results else []"]
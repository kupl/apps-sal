["class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        \n        def bitFlip(row):\n            \n            for i,r in enumerate(row):\n                row[i] = 1-r\n                \n            return row\n        \n        # [print(a) for a in A]\n        #For any rows with a leading 0 flip them\n        for i,row in enumerate(A):\n            if row[0] == 0:\n                A[i] = bitFlip(row)\n        # print('After Flip')\n        # [print(a) for a in A]\n        \n        #For each col past the 0th flip it if has more zeros than 1s\n        for j in range(1,len(A[0])):\n            count = 0\n            for i in range(0,len(A)):\n                count += A[i][j]\n            if count <= len(A)//2:\n                for i in range(0,len(A)):\n                    A[i][j] = 1-A[i][j]\n                    \n        def score(row): #Returns the max score for this row\n\n#             mul = 1\n#             res = 0\n#             for r in reversed(row):\n#                 res += r*mul\n#                 mul *= 2\n            \n#             return res\n        \n            return sum([ r*2**i for i,r in enumerate(reversed(row))])\n          \n        return sum([ score(row) for row in A])\n            \n", "class Solution:\n    def matrixScore(self, A):\n            M, N = len(A), len(A[0])\n            res = (1 << N - 1) * M\n            for j in range(1, N):\n                cur = sum(A[i][j] == A[i][0] for i in range(M))\n                res += max(cur, M - cur) * (1 << N - 1 - j)\n            return res", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        for i in range(len(A)):\n            if A[i][0] == 0:\n                A[i] = [j^1 for j in A[i]]\n\n        A = list(map(list, zip(*A)))        \n\n        for i in range(len(A)):\n            if sum(A[i]) < len(A[i])/2:\n                A[i] = [j^1 for j in A[i]]\n\n        A = list(map(list, zip(*A)))  \n\n        summ = 0\n        for i in A:\n            summ += int(\\\"\\\".join(str(x) for x in i), 2) \n\n        return summ   ", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n      maxsum = 0\n      power = len(A[0])\n      for row in A:\n        for i in range(power):\n          maxsum += 2**(power - 1 - i)*row[i]\n      while True:\n        change = False\n        crow = False\n        num = 0\n        cursum = maxsum\n        localsum = maxsum\n        for row in range(len(A)):\n          for i in range(power):\n            term = 2**(power-1-i)\n            if A[row][i] == 1:\n              cursum -= term\n            else:\n              cursum += term\n          if cursum > maxsum:\n            change = True\n            maxsum = cursum\n            crow = True\n            num = row\n          cursum = localsum\n        for col in range(power):\n          term = 2**(power - 1- col)\n          for row in range(len(A)):\n            if A[row][col] == 1:\n              cursum -= term\n            else:\n              cursum += term\n          if cursum > maxsum:\n            change = True\n            maxsum = cursum\n            crow = False\n            num = col\n          cursum = localsum\n        if change:\n          if crow:\n            for i in range(power):\n              A[num][i] = A[num][i] + (1 - 2*A[num][i])\n          else:  \n            for row in range(len(A)):\n              A[row][num] = A[row][num] + (1-2*A[row][num])\n        if not change:\n          return maxsum\n", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        M, N = len(A), len(A[0])\n        ans = (1<<N-1)*M\n        for j in range(1, N):\n            count = sum(A[i][j]==A[i][0] for i in range(M))\n            ans += max(count, M-count)<<N-j-1\n        return ans\n            \n            \n            \n", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        '''\n        top priority would be the first column should be all 1s\n        so toggle each row to make sure the first cell is 1\n        and examine each column from left to right\n        toggle if needed to make sure sum of each column is bigger than otherwise\n        '''\n        \n        def toggle_row(row):\n            for j in range(len(A[0])):\n                if A[row][j]==1:\n                    A[row][j]=0\n                else:\n                    A[row][j]=1\n                    \n        def toggle_col(col):\n            for i in range(len(A)):\n                if A[i][col]==1:\n                    A[i][col]=0\n                else:\n                    A[i][col]=1\n        \n        for i in range(len(A)):\n            if A[i][0]==0:\n                toggle_row(i)\n                \n        for j in range(1, len(A[0])):\n            # get col sum\n            col_sum=0\n            for i in range(len(A)):\n                col_sum += A[i][j]\n            if col_sum < len(A) /2:\n                toggle_col(j)\n                \n        # convert into binary and calculate result\n        res=0\n        for row in A:\n            row_s=''\n            for i in row:\n                row_s += str(i)\n            decimal=int(row_s, 2)\n            res += decimal\n        return res\n            \n", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        m, n, ans = len(A), len(A[0]), 0\n        for c in range(n):\n            col = sum(A[r][c] == A[r][0] for r in range(m))\n            ans += max(col, m-col) * 2 ** (n-1-c)\n        return ans", "class Solution(object):\n    def matrixScore(self, A):\n        \\\"\\\"\\\"\n        :type A: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        def flip_row(arr):\n            if arr[0] == 0:\n                arr = [1-arr[i] for i in range(len(arr))]\n            return arr\n        \n        def flip_cols(arr):\n            flipped_arr = [1-arr[i] for i in range(len(arr))]\n            num_ones_orig = 0\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    num_ones_orig += 1\n            num_ones_flipped = 0\n            for i in range(len(flipped_arr)):\n                if flipped_arr[i] == 1:\n                    num_ones_flipped += 1\n            if num_ones_orig > num_ones_flipped:\n                return arr\n            return flipped_arr\n                \n        # flip rows\n        for i in range(len(A)):\n            A[i] = flip_row(A[i])\n            \n        # flip cols\n        for j in range(1, len(A[0])):\n            res_flipped = flip_cols([A[i][j] for i in range(len(A))])\n            for x in range(len(A)):\n                A[x][j] = res_flipped[x]\n        \n        sum_total = 0\n        for i in range(len(A)):\n            binary_number = \\\"\\\".join([str(elem) for elem in A[i]])\n            int_number = int(binary_number, 2)\n            sum_total += int_number\n        \n        return sum_total", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        total = 0\n        \n        for i in range(len(A)):\n            if A[i][0] == 0:\n                for j in range(len(A[0])):\n                    A[i][j] = 1 - A[i][j]\n        for i in range(len(A[0])):\n            colZero = 0\n            colOne = 0            \n            for j in range(len(A)):\n                if A[j][i] == 1:\n                    colOne+=1\n                else:\n                    colZero+=1\n            total += max(colOne,colZero) * 2**(len(A[0])-1-i)\n        return total", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        N, M = len(A), len(A[0])\n        res = 0\n        for jj in range(M):\n            num = 0\n            for ii in range(N):\n                num += A[ii][jj] ^ A[ii][0]\n            res += max(num, N - num) * 2 ** (M - jj - 1)\n        return res\n", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        m, n = len(A), len(A[0])\n        \n        f = [0] * m\n        \n        for i in range(m):\n            if A[i][0] == 0:\n                f[i] = 1\n        \n        ans = 2 ** (n - 1) * m\n        \n        for j in range(1, n):\n            cnt = sum(f[i] ^ A[i][j] for i in range(m))\n            cnt = max(cnt, m - cnt)\n            \n            ans += 2 ** (n - 1 - j) * cnt\n        \n        return ans\n", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        w = len(A[0])\n        h = len(A)\n        max_row = int(2 ** w) - 1\n        \n        def max_col(ci):\n            return h * c_val(ci)\n        \n        def c_val(ci):\n            return 2 ** (w - ci - 1)\n        \n        row_sum = [sum(v * c_val(ci) for ci, v in enumerate(l)) for l in A]\n        col_sum = [sum(A[ri][ci] * c_val(ci) for ri in range(h)) for ci in range(w)]    \n        \n        flipped = True\n        while flipped:\n            flipped = False\n            # Check row sums\n            for ri, r in enumerate(row_sum):\n                if r < max_row - r:\n                    flipped = True\n                    for ci in range(w):\n                        A[ri][ci] = 1 - A[ri][ci] \n                        row_sum[ri] = max_row - r\n                        if A[ri][ci] == 1:\n                            col_sum[ci] += c_val(ci)\n                        else:\n                            col_sum[ci] -= c_val(ci)\n            # Check col sums\n            for ci, c in enumerate(col_sum):\n                if c < max_col(ci) - c:\n                    flipped = True\n                    for ri in range(h):\n                        A[ri][ci] = 1 - A[ri][ci]\n                        col_sum[ci] = max_col(ci) - c\n                        if A[ri][ci] == 1:\n                            row_sum[ri] += c_val(ci)\n                        else:\n                            row_sum[ri] -= c_val(ci)\n        return sum(row_sum)\n                \n                        \n", "class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        R, C = len(A), len(A[0])\n        ans = 0\n        for c in range(C):\n            col = 0\n            for r in range(R):\n                col += A[r][c] ^ A[r][0]\n            ans += max(col, R - col) * 2 ** (C - 1 - c)\n        return ans\n"]
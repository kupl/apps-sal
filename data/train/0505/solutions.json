["class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        if not s: return s\n        l=0\n        r=0\n        res=''\n        for i,c in enumerate(s):\n            if c=='(':\n                l+=1\n            if c==')':\n                if l==r:\n                    continue\n                else:\n                    r+=1\n            res+=c\n        s=res\n        l=0\n        r=0\n        res=''\n        for i in range(len(s)-1,-1,-1):\n            c=s[i]\n            if c==')':\n                r+=1\n            if c=='(':\n                if l==r:\n                    continue\n                else:\n                    l+=1\n            res=c+res\n        return res", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        stack = []\n        to_remove = set()\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    to_remove.add(i)\n        print(to_remove)\n        to_remove |= set(stack)\n        print(to_remove)\n        \n        return ''.join(c for i, c in enumerate(s) if i not in to_remove)\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        # ())()\n        # (()\n        # (()()\n        # ()(()\n        \n        # Strategy: If sum over string at any point is negative, remove close paren immediately\n        #           Keep track of open parens in string. If sum returns to 0, forget parens and restart, since this is valid so far.\n        #           At the end remove (sum of string) parens from beginning.\n        \n        # s = lee(t(c)o)de)\n        # total = 0\n        # new_s = \n        # recent_opens = []\n        \n        total = 0\n        new_s = ''\n        recent_opens = []  # List of indices in new_s of open parens\n        for char in s:\n            if char == '(':\n                total += 1\n                new_s = ''.join((new_s, char))\n\n                recent_opens.append(len(new_s) - 1)\n            elif char == ')':\n                total -= 1\n\n                if total >= 0:\n                    new_s = ''.join((new_s, char))\n                    recent_opens.pop()\n                    \n                else:\n                    total = 0\n                    \n            else:\n                new_s = ''.join((new_s, char))     \n\n        # Remove extra open parens, if any\n        if total > 0:\n            for count, index in enumerate(recent_opens):\n                total -= 1\n                \n                new_s = ''.join((new_s[:index - count], new_s[index - count + 1:]))\n                \n                if total <= 0:\n                    break\n                    \n        return new_s", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        open_bracket = set()\n        redundant_indices = set()\n        for i in range(len(s)):\n            if s[i] == '(':\n                open_bracket.add(i)\n            elif s[i] == ')' and len(open_bracket) > 0:\n                open_bracket.remove(max(open_bracket))\n            elif s[i] == ')' and len(open_bracket) == 0:\n                redundant_indices.add(i)\n                \n        if open_bracket:\n            for bracket in open_bracket:\n                redundant_indices.add(bracket)\n        result = ''\n        for i in range(len(s)):\n            if i not in redundant_indices:\n                result += s[i]\n        return result", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        res=[]\n        stack=[]\n        \n        for ele in s:\n            if ele not in '()':\n                res.append(ele)\n            elif ele=='(':\n                stack.append(ele)\n                res.append(ele)\n            elif ele==')':\n                 if stack!=[] and stack[-1]=='(':\n                        res.append(ele)\n                        stack.pop()\n        if stack==[]:\n            return ''.join(res)\n        else:\n            i=len(res)-1\n            while stack:\n                if res[i]==stack[-1]:\n                    stack.pop()\n                    res=res[:i]+res[i+1:]\n                i=i-1\n            return ''.join(res)\n            \n                \n                        \n                    \n                \n            \n            \n            \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        \n        \n        stack = []\n        \n        from collections import defaultdict\n        data_dict = defaultdict(list)\n        \n        #here, we record what parentheses need to be removed\n        for index in range(0,len(s)):\n            char = s[index]\n            \n            if char == '(':\n                data_dict['('].append(index)\n                stack.append('(')\n            \n            if char == ')':\n                if '(' in stack:\n                    stack.pop()\n                    data_dict['('].pop()\n                else:\n                    stack.append(')')\n                    data_dict[')'].append(index)\n        \n        \n        s_list = list(s)\n        \n        #now we remove the extra parentheses\n        for char in stack:\n            parentheses_index_list = data_dict[char]\n            remove_char_index = parentheses_index_list.pop()\n            s_list.pop(remove_char_index)\n            \n            #change_index\n            if char == '(':\n                parentheses_index_list = data_dict[')']\n                for index in range(0,len(parentheses_index_list)):\n                    position_in_s = parentheses_index_list[index]\n                    if position_in_s>remove_char_index:\n                        position_in_s -= 1\n                        parentheses_index_list[index] = position_in_s\n            else:\n                parentheses_index_list = data_dict['(']\n                for index in range(0,len(parentheses_index_list)):\n                    position_in_s = parentheses_index_list[index]\n                    if position_in_s>remove_char_index:\n                        position_in_s -= 1\n                        parentheses_index_list[index] = position_in_s\n                \n        return_s = ''\n        for char in s_list:\n            return_s += char\n        \n        return return_s\n        \n        \n                    \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        c, st, st2,  res = 0, [], [], []\n        for j, ss in enumerate(s):\n            if ss == '(':\n                st.append(j)\n            elif ss == ')':\n                if st:\n                    st.pop()\n                else:\n                    st2.append(j)\n            else: continue\n        \n        for j, ss in enumerate(s):\n            if (ss == '(' and j in st) or (ss == ')' and j in st2) : continue \n            res.append(ss)\n                    \n        return ''.join(res)\n             \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        c, st, st2,  res = 0, [], [], []\n        for j, ss in enumerate(s):\n            if ss == '(':\n                st.append(j)\n            elif ss == ')':\n                if st:\n                    st.pop()\n                else:\n                    st2.append(j)\n            else: continue\n        \n        print((st, st2))   \n        for j, ss in enumerate(s):\n            if (ss == '(' and j in st) or (ss == ')' and j in st2) : continue \n            res.append(ss)\n                    \n        return ''.join(res)\n             \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        to_remove = set()\n        stack = []\n        \n        for i,c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if len(stack):\n                    stack.pop()\n                    continue\n                to_remove.add(i)\n        \n        for i in stack:\n            to_remove.add(i)\n        \n        st = ''\n        for i,c in enumerate(s):\n            if i not in to_remove:\n                st += c\n        \n        return ''.join(st)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        # leftIndex, rightIndex = [],[]\n        # for index, item in enumerate(s):\n        #     if item == '(': leftIndex.append(index)\n        #     if item == ')': rightIndex.append(index)\n        # print(leftIndex,rightIndex)\n        stack = []\n        p = []\n        for index, item in enumerate(s):\n            if item == '(':\n                stack.append(index)\n            elif item == ')' and stack:\n                p.append([stack.pop(), index])\n        # s = [i for i in s.replace(')','_').replace('(','_')]\n        # for [l,r] in p:\n        #     s[l] = '('\n        #     s[r] = ')'\n        # return ''.join(s).replace('_','')\n    \n        s = s.replace(')','_').replace('(','_')\n        for [l,r] in p:\n            s = s[:l] +'(' + s[l+1:r]+')'+s[r+1:]\n        return s.replace('_','')\n        \n        \n    \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        index_to_remove = set()\n        \n        for index, item in enumerate(s):\n            if item == '(':\n                stack.append(index)\n            elif item == ')':\n                if not stack:\n                    index_to_remove.add(index)\n                else:\n                    stack.pop()\n                    \n        print(stack)\n        print(index_to_remove)\n        \n        string_builder = []\n        \n        for index,item in enumerate(s):\n            if index not in stack and index not in index_to_remove:\n                string_builder.append(item)\n                \n        return ''.join(string_builder)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        # O(n) time and O(n) space - use stack to keep track of parentheses\n        stack = []\n        updated_s = []\n        for ch in s:\n            if ch not in {'(',')'}:\n                updated_s.append(ch)\n            elif ch == '(':\n                stack.append((ch,len(updated_s)))\n                updated_s.append(ch)\n            else:\n                if stack:\n                    updated_s.append(ch)\n                    stack = stack[:-1]\n\n        if stack:\n            for i in stack[::-1]:\n                updated_s = updated_s[:i[1]] + updated_s[i[1]+1:]\n        return ''.join(updated_s)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        # O(n) time and O(n) space - use stack to keep track of parentheses\n        stack = []\n        updated_s = []\n        for ch in s:\n            if ch not in {'(',')'}:\n                updated_s.append(ch)\n            elif ch == '(':\n                stack.append(len(updated_s))\n                updated_s.append(ch)\n            else:\n                if stack:\n                    updated_s.append(ch)\n                    stack = stack[:-1]\n\n        if stack:\n            for i in stack[::-1]:\n                updated_s = updated_s[:i] + updated_s[i+1:]\n        return ''.join(updated_s)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        level = 0\n        result = list(s)\n        open_pos = []\n        close_pos = []\n        for i, c in enumerate(s):\n            if c == '(':\n                level += 1\n                open_pos.append(i)\n            elif c == ')':\n                open_idx = None\n                if open_pos:\n                    open_idx = open_pos.pop()\n                if level == 0:\n                    # destroy the opening one\n                    if open_idx:\n                        result[open_idx] = '_'\n                    result[i] = '_'\n                else:\n                    level -= 1\n        \n        return ''.join([x for i, x in enumerate(result) if x != '_' and not i in open_pos])\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        cnt_left = 0\n        rev_left = []\n        rev_right = set()\n        \n        for i, c in enumerate(s):\n            if c == ')':\n                if cnt_left == 0:\n                    rev_right.add(i)\n                else:\n                    rev_left.pop()\n                    cnt_left -= 1\n            elif c =='(':\n                rev_left.append(i)\n                cnt_left += 1\n        rev = rev_right.union(set(rev_left))\n        \n        res = []\n        for i in range(len(s)):\n            if i not in rev_right and i not in rev_left:\n                res.append(s[i])\n        return ''.join(res) \n                \n                \n            \n        \n        \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        cleaned = {}\n        stack = []\n        for i, ch in enumerate(s):\n            if ch == ')':\n                if len(stack):\n                    cleaned[i] = ')'\n                    stack.pop()\n                else:\n                    cleaned[i] = ''\n                continue\n\n            if ch == '(':\n                stack.append(i)\n\n            cleaned[i] = ch\n\n        output = []\n        for item in cleaned.items():\n            if item[0] not in stack:\n                output.append(item[1])\n\n        return ''.join(output)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        l = list(s)\n        stack = []\n        i = 0\n        while i < len(l):\n            if l[i] == '(':\n                stack.append(i)\n            elif l[i] == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    del l[i]\n                    i -= 1\n            i += 1\n        \n        return ''.join([c for i, c in enumerate(l) if i not in stack])\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n\n        stackparen = []\n        stackindex = []\n        result = ''\n        result1 = ''\n        i = 0\n        j = 0\n\n        while i <= len(s) - 1:\n            if s[i] == ')' and len(stackparen) == 0:\n                i += 1\n                continue\n            if s[i] == '(':\n                stackparen.append(s[i])\n                stackindex.append(j)\n            if s[i] == ')' and len(stackparen) > 0:\n                stackparen.pop()\n                stackindex.pop()\n            result += s[i]\n            j += 1\n            i += 1\n\n        for j, i in enumerate(result):\n            if j not in stackindex:\n                result1 += result[j]\n        return result1", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        stackparen = []\n        stackindex = []\n        result = ''\n        result1 = ''\n        i = 0\n        j = 0\n\n        while i <= len(s) -1:\n\n            if s[i] == ')' and len(stackparen) == 0:\n                i += 1\n                continue\n            if  s[i] == '(':\n                stackparen.append(s[i])\n                stackindex.append(j)\n            if  s[i] == ')' and len(stackparen) > 0:\n                stackparen.pop()\n                stackindex.pop()\n            result += s[i]\n            j += 1\n            i += 1\n\n        for j,i in enumerate(result):\n            if j not in stackindex:\n                result1 += result[j]\n        return result1", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n\n        p_stack = []\n\n        new_string = ''\n\n        def add_char(s: str, new: str) -> str:\n            added = s + new\n            return added\n\n        def tmp_change(s: str, chg: int) -> str:\n            new = s[:chg] + '0' + s[chg+1:]\n            return new\n\n        def end_change(s: str) -> str:\n            new = ''\n            for i in range(0, len(s)):\n                if s[i] != '0':\n                    new = add_char(new, s[i])\n            return new\n\n        for i in range(0, len(s)):\n            if s[i] == '(':\n                p_stack.append(i)\n                new_string = add_char(new_string, s[i])\n            elif s[i] == ')':\n                if len(p_stack) > 0:\n                    p_stack.pop()\n                    new_string = add_char(new_string, s[i])\n                else:\n                    new_string = add_char(new_string, '0')\n            else:\n                new_string = add_char(new_string, s[i])\n\n        #at this point we should have a new string built, but it may have excessive ( at the end, so we need to check the stack\n\n        if p_stack != []:\n            #remove the items from string\n            for i in p_stack:\n                new_string = tmp_change(new_string, i)\n\n\n\n            print(new_string)    \n\n        no_zeroes=end_change(new_string)\n\n        # print('wow')\n        print(no_zeroes)\n        return no_zeroes", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        pt = {'(': [], ')': []}\n        \n        for i in range(len(s)):\n            if s[i].isalpha() and s[i].islower():\n                continue\n            elif s[i] == '(':\n                pt['('].append(i)\n            elif s[i] == ')':\n                pt[')'].append(i)\n        \n        to_remove = []\n\n        while pt['('] and pt[')']:\n            if pt['('][0] < pt[')'][0]:\n                del pt['('][0]\n                del pt[')'][0]\n            else:\n                to_remove.append(pt[')'][0])\n                del pt[')'][0]\n        \n        if pt['(']:\n            to_remove.extend(pt['('])\n        if pt[')']:\n            to_remove.extend(pt[')'])\n        \n        res = ''\n        prev = 0\n        for i in to_remove:\n            res += s[prev:i]\n            prev = i + 1\n        res += s[prev:]\n            \n        return res\n            \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        left,right = 0,0\n        result = []\n        for i,c in enumerate(s):\n            if c == '(':\n                left += 1\n                result.append(c)\n            elif c == ')':\n                if right + 1 > left:\n                    continue\n                else:\n                    right += 1\n                    result.append(c)\n            else:\n                result.append(c)\n        while left > right:\n            i = len(result) - result[::-1].index('(') - 1\n            result = result[:i]+result[i+1:]\n            left -= 1\n        \n        return ''.join(result)\n                \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        parens = []\n        to_remove = set()\n        for i in range(len(s)):\n            c = s[i]\n            if c == ')':\n                if not parens:\n                    to_remove.add(i)\n                else:\n                    parens.pop()\n            elif c == '(':\n                parens.append(i)\n        string = ''\n        for i in range(len(s)):\n            if i in to_remove or i in parens:\n                continue\n            else:\n                string += s[i]\n        return string", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        out = []\n        left_pos = []\n        l = 0\n        for c in s:\n            if c != '(' and c != ')':\n                out.append(c)\n                l += 1\n            elif c=='(':\n                out.append(c)\n                stack.append(c)\n                left_pos.append(l)\n                l += 1\n            else:\n                if stack:\n                    out.append(c)\n                    stack = stack[:-1]\n                    left_pos = left_pos[:-1]\n                    l += 1\n        out_string = ''\n        # left_pos = set(left_pos)\n        for i in range(len(out)):\n            if i not in left_pos:\n                out_string += out[i]\n        return out_string", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stacklp = []\n        stackrp = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stacklp.append(i)\n            elif s[i] == ')':\n                if stacklp != []:\n                    stacklp.pop()\n                else:\n                    stackrp.append(i)\n                    \n        stack = sorted(stacklp +stackrp)\n        res = ''\n        for i in range(len(s)):\n            if i not in stack:\n                res = res + s[i]\n            \n        return res\n        \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        if len(s) == 0:\n            return s\n        \n        stack = []  # save indexes of parenthesis\n        out_s = ''\n        i = 0\n        \n        for c in s:\n            if c == ')':\n                if len(stack) > 0:\n                    stack.pop()\n                    out_s += c\n                    i += 1\n            elif c == '(':\n                stack.append(i)\n                out_s += c\n                i += 1\n            else:\n                out_s += c\n                i += 1\n\n        if len(stack)>0:\n            out_s = [out_s[i] for i in range(len(out_s)) if i not in stack]\n\n        return out_s", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        skip = []\n        for i, c in enumerate(s):\n            if c in '()':\n                if c=='(':\n                    stack.append(i)\n                else:\n                    if stack:\n                        stack.pop()\n                    else:\n                        skip.append(i)\n\n        while stack:\n            skip.append(stack.pop())\n\n        t = []\n        for i, c in enumerate(s):\n            if i not in skip:\n                t.append(c)\n        return ''.join(t)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        cnt_left = 0\n        rev_left, rev_right = [], []\n        \n        for i, c in enumerate(s):\n            if c == ')':\n                if cnt_left == 0:\n                    rev_right.append(i)\n                else:\n                    rev_left.pop()\n                    cnt_left -= 1\n            elif c =='(':\n                rev_left.append(i)\n                cnt_left += 1\n        res = ''\n        for i in range(len(s)):\n            if i not in rev_right and i not in rev_left:\n                res += s[i]\n        return res \n                \n            \n        \n        \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack, index, res = [], [], ''\n        for i in range(len(s)):\n            if s[i] == '(': stack.append((i, s[i]))\n            elif s[i] == ')':\n                if not stack: index.append(i)\n                elif stack[-1][1] == '(': stack.pop()\n        \n        while stack:\n            index.append(stack.pop()[0])\n            \n        for i in range(len(s)):\n            if i not in index: res += s[i]\n        \n        return res\n#         left, right, index = 0, 0, []\n#         remove_left, remove_right = 0, 0\n#         for i in range(len(s)):\n#             if s[i] == '(': left += 1\n#             elif s[i] == ')': right += 1\n#             if right > left: \n#                 remove_right += 1\n#                 right -= 1\n#                 index.append(i)\n                \n#         remove_left = left - right\n\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        open_q = list()\n        drop = list()\n        \n        for idx in range(len(s)):\n            if s[idx] not in ['(', ')']:\n                continue\n                \n            if s[idx] == '(':\n                open_q.append(idx)\n            \n            else:\n                \n                if open_q:\n                    open_q.pop()\n                \n                else:\n                    drop.append(idx)\n                    \n        if open_q:\n            drop.extend(open_q)\n        \n        res = ''\n        for idx in range(len(s)):\n            if idx not in drop:\n                res += s[idx]\n        \n        return res\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        remove = []\n        \n        for i in range(len(s)):\n            if s[i] not in '()':\n                continue\n            elif s[i] == '(':\n                stack.append(i)\n            else:\n                if s[i] == ')' and not stack:\n                    remove.append(i)\n                else:\n                    stack.pop()\n        stack.extend(remove)\n        \n        output = []\n        for i, v in enumerate(s):\n            if i not in stack:\n                output.append(v)\n        return ''.join(output)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        if not s:\n            return s\n        \n        stack = list()\n        remove = list()\n        \n        for idx, char in enumerate(s):\n            \n            if char == '(':\n                stack.append(idx)\n            \n            elif char == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    remove.append(idx)\n        \n        remove += stack\n        \n        return ''.join([char for idx, char in enumerate(s) if idx not in remove])", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        to_remove = []\n        stack = []\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            if char == ')':\n                if not stack:\n                    to_remove.append(i)\n                else:\n                    stack.pop()\n        if stack:\n            to_remove.extend(stack)\n        \n        output = [char for i, char in enumerate(s) if i not in to_remove]\n        return ''.join(output)", "from collections import deque\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        # forward pass to find invalid closed paren\n        toremove = []\n        openP = deque()\n        for i in range(len(s)):\n            if s[i] == '(':\n                openP.append(i)\n            elif s[i] == ')':\n                if len(openP) > 0:\n                    openP.pop()\n                else:\n                    toremove.append(i)\n        # backward pass\n        closeP = deque()\n        for i in range(len(s)):\n            if s[len(s) - i - 1] == ')':\n                closeP.append(len(s) - i - 1)\n            elif s[len(s) - i - 1] == '(':\n                if len(closeP) > 0:\n                    closeP.pop()\n                else:\n                    toremove.append(len(s) - i - 1)\n        ret = ''\n        for i in range(len(s)):\n            if i not in toremove:\n                ret += s[i]\n        return ret\n            \n                \n", "class Stack:\n\n    def __init__(self):\n        self.stack = collections.deque()\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def empty(self):\n        try:\n            item = self.stack.pop()\n            self.stack.append(item)\n            return False\n        except IndexError:\n            return True\n\nclass Solution:\n        \n    def minRemoveToMakeValid(self, s: str) -> str:\n\n        stack = Stack()\n\n        remove_indices = [ ]\n\n        for i, char in enumerate(s):\n\n            if char == '(':\n                stack.push(i)\n\n            if char == ')':\n                if stack.empty():\n                    remove_indices.append(i)\n                else:\n                    stack.pop( )\n                    \n        while not stack.empty():\n            remove_indices.append(stack.pop())\n\n        res = ''\n        j = 0\n        for i in range(len(s)):\n            if j < len(remove_indices):\n                if i not in remove_indices:\n                    res += s[i]\n                else:\n                    j += 1\n            else:\n                res += s[i]\n\n        return res\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        ans = ''\n        stack = []\n        to_delete_idx = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append('(')\n                to_delete_idx.append(i)\n            if s[i] == ')':\n                if not stack or stack[-1]==')':\n                    stack.append(')')\n                    to_delete_idx.append(i)\n                else:\n                    stack.pop()\n                    to_delete_idx.pop()\n        for i in range(len(s)):\n            if i not in to_delete_idx:\n                ans += s[i]\n                \n        return ans\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        N = len(s)\n        if N == 1 and s[0] in ('(',')'):\n            return s.replace(s[0],'')\n        index = []\n        stack = []\n        \n        for i,c in enumerate(s):\n            if c == '(':\n                index.append(i)\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    index.append(i)\n                    stack.append(c)\n                elif stack[-1] == '(':\n                    index.pop()\n                    stack.pop()\n                else:\n                    index.append(i)\n                    stack.append(c)\n            else:\n                continue\n        res = ''\n        #print (index)\n        for i in range(N):\n            if i not in index:\n                res += s[i]\n        \n        return res\n                    \n                \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        q = []\n        ans = []\n        \n        for i in range(len(s)):\n            if (s[i] == '('):\n                q.append(i)\n            elif (s[i] == ')'):\n                \n                if (len(q) == 0):\n                    ans.append(i)\n                else:\n                    q = q[:-1]\n                    \n        if (len(q)!=0):\n            ans = ans + q\n            \n        new_s = ''\n        for i in range(len(s)):\n            if (not (i in ans)):\n                new_s = new_s + s[i]\n                \n        return new_s\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        OPEN = '('\n        CLOSE = ')'\n        stack = []\n        \n        for i, c in enumerate(s):\n            if c == OPEN:\n                stack.append(i)\n            \n            if stack and (c == CLOSE) and (s[stack[-1]] == OPEN):\n                stack.pop()\n                continue\n            \n            if c == CLOSE:\n                stack.append(i)\n                \n        output = ''\n        for i, c in enumerate(s):\n            if i not in stack:\n                output += c\n        \n        return output\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        torem = []\n        for i in range(len(s)):\n            if s[i] == '(' or s[i] == '[' or s[i] == '{':\n                stack.append(i)\n            elif s[i] == ')':\n                if len(stack) > 0 and s[stack[-1]] == '(':\n                    stack = stack[:-1]\n                else:\n                    torem.append(i)\n            elif s[i] == ']':\n                if len(stack) > 0 and s[stack[-1]] == '[':\n                    stack = stack[:-1]\n                else:\n                    torem.append(i)\n            elif s[i] == '}':\n                if len(stack) > 0 and s[stack[-1]] == '{':\n                    stack = stack[:-1]\n                else:\n                    torem.append(i)\n        stack.extend(torem)\n        temp = [i for j, i in enumerate(list(s)) if j not in stack]\n        return ''.join(temp)\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        st =[]\n        remove = defaultdict(int)\n        for ind,ch in enumerate(s):\n            if ch is '(':\n                st.append(ind)\n            elif ch is ')':\n                if st:\n                    st.pop()\n                else :\n                    remove[ind]+=1\n        print(remove)\n        if st:\n            dic = {elem:1 for elem in st}\n            remove.update(dic)\n            \n        print(remove)\n        \n        ans = ''\n        for ind,ch in enumerate(s):\n             if remove[ind] == 0:\n                    ans+=ch\n                    \n        return ans   ", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        toRemove = []\n        output = []\n        for i, c in enumerate(s):\n            if c not in '()':\n                continue    \n            if len(toRemove) == 0:\n                toRemove.append((c,i))\n            elif c == ')' and toRemove[-1][0] == '(':\n                \n                toRemove.pop()\n            else:\n                toRemove.append((c,i))  \n        s_dict = {i: c for i, c in enumerate(s)}\n        for pair in toRemove:\n            del s_dict[pair[1]]\n        output = [v for k, v in list(s_dict.items())]\n        return ''.join(output)\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        new_str = ''\n        left = 0\n        right = 0\n        \n        for i in s:\n            if i != '(' and i != ')':\n                new_str += i\n                continue\n            if i == '(':\n                left += 1\n                new_str += i\n                continue\n            if i == ')':\n                if left > 0:\n                    left -= 1\n                    new_str += i\n        \n        final_str = ''\n        for i in range(len(new_str)-1, -1, -1):\n            if new_str[i] != '(' and new_str[i] != ')':\n                final_str += new_str[i]\n                continue\n            if new_str[i] == ')':\n                right += 1\n                final_str += new_str[i]\n                continue\n            if new_str[i] == '(':\n                if right > 0:\n                    right -= 1\n                    final_str += new_str[i]\n                    \n        return final_str[::-1]", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        s = self.remove_invalid(s)\n        s = self.remove_invalid(s[::-1], ')')\n        return s[::-1]\n\n    def remove_invalid(self, s, end='('):\n        new_s = ''\n        count = 0\n        for i in range(len(s)):\n            if s[i] not in ('(', ')'):\n                new_s += s[i]\n                continue\n            count += 1 if s[i] == end else -1\n            if count < 0:\n                count = 0\n            else:\n                new_s += s[i]\n        return new_s", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        sl = list(s)\n        \n        def sweep(begin, end, step, open_symbol, close_symbol):\n            level = 0\n            k = begin\n            for i in range(begin, end, step):\n                if sl[i] == open_symbol:\n                    level = max(level, 0) + 1\n                elif sl[i] == close_symbol:\n                    level -= 1\n                if not (level < 0 and sl[i] == close_symbol):\n                    sl[k] = sl[i]\n                    k += step\n            return k - step\n        \n        level = 0\n        r = sweep(0, len(s), 1, '(', ')')\n        l = sweep(r, -1, -1, ')', '(')\n        return ''.join(sl[l:r + 1])", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        paren_arr = []\n        \n        paren_stack = []\n        \n        index = 0\n        \n        for c in s:\n            if(c != ')' and c != '('):\n                continue\n            elif(c == '('):\n                paren_arr.append(c)\n                paren_stack.append((c, index))\n                index += 1\n            else:\n                paren_arr.append(c)\n                if(len(paren_stack) > 0 and paren_stack[-1][0] == '('):\n                    paren_stack.pop()\n                else:\n                    paren_stack.append((c, index))\n                \n                index += 1\n        \n        for e in paren_stack:\n            paren_arr[e[1]] = '-'\n        \n        s_arr = []\n        \n        index = 0\n        \n        while(index < len(paren_arr) and paren_arr[index] == '-'):\n            index += 1\n        \n        for c in s:\n            if(c != ')' and c != '('):\n                s_arr.append(c)\n            else:\n                if(index < len(paren_arr) and c == paren_arr[index]):\n                    s_arr.append(c)\n                    index += 1\n                    while(index < len(paren_arr) and paren_arr[index] == '-'):\n                        index += 1\n        \n        return ''.join(s_arr)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        l, stack= 0, []\n        for i in s:\n            if i not in ('()'):\n                stack.append(i)\n            elif i == '(':\n                l += 1\n                stack.append('(')\n            else:\n                if l == 0:\n                    continue\n                else:\n                    stack.append(')')\n                    l -= 1\n        i = len(stack) - 1\n        while l > 0 and i >=0:\n            if stack[i] == '(':\n                stack[i] = ''\n                l -= 1\n            i -= 1\n        return ''.join(stack)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        result = []\n        capacity = s.count(')')\n        print(capacity)\n        opened = 0\n        for char in s:\n            if char == '(':\n                if opened == capacity: continue\n                opened +=1\n            elif char == ')':\n                capacity -=1\n                if not opened: continue\n                opened-=1\n            print((result.append(char)))\n            print('done')\n        return ''.join(result)\n        \n            \n", "class Item:\n    def __init__(self, value, index):\n        self.value = value\n        self.index = index\n\nclass Stack:\n    def __init__(self):\n        self._stack = []\n        self._top_index = 0\n    \n    def top(self):\n        if self._top_index <= 0:\n            return None\n        return self._stack[self._top_index - 1]\n    \n    def pop(self):\n        item = self._stack.pop()\n        self._top_index -= 1\n        return item\n    \n    def push(self, item):\n        self._stack.append(item)\n        self._top_index += 1\n\n    def __iter__(self):\n        self.index = 0\n        return self\n\n    def __next__(self):\n        if self.index >= len(self._stack):\n            raise StopIteration\n        value = self._stack[self.index]\n        self.index += 1\n        return value\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = Stack()\n        \n        for index, c in enumerate(s):\n            if c == '(':\n                item = Item('(', index)\n                stack.push(item)\n            elif c == ')':\n                if stack.top() and stack.top().value == '(':\n                    stack.pop()\n                else:\n                    item = Item(')', index)\n                    stack.push(item)\n\n        prev_index = 0\n        result = ''\n        for item in stack:\n            result += s[prev_index:item.index]\n            prev_index = item.index + 1\n        result += s[prev_index:]\n        \n        return result", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        sum = 0\n        i = 0\n        ans = ''\n        opens = []\n        while(i < len(s)):\n            if s[i] == '(':\n                sum+=1\n            elif s[i] == ')':\n                sum-=1\n            if sum < 0:\n                sum = 0\n                i+=1\n            else:\n                ans+=s[i]\n                if ans[-1] == '(':\n                    opens.append(len(ans)-1)\n                i+=1\n        if sum == 0:\n            return ans\n        while(sum > 0):\n            # find last index\n            index = opens[-1]\n            opens = opens[:-1]\n            ans = ans[:index] + ans[index+1:]\n            sum-=1\n        return ans\n            \n            \n                \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        if len(s) == 0:\n            return s\n        \n        paranthesis_balance = 0\n        ends = []\n        \n        for i, char in enumerate(s):\n            if char == '(':\n                paranthesis_balance += 1\n            elif char == ')' and paranthesis_balance > 0:\n                ends.append(i)\n                paranthesis_balance -= 1\n            else:\n                continue        \n        \n        starts = []\n        paranthesis_balance = 0\n        \n        for i, char in enumerate(reversed(s)):\n            if char == ')':\n                paranthesis_balance += 1\n            elif char == '(' and paranthesis_balance > 0:\n                starts.append(len(s) - i - 1)\n                paranthesis_balance -= 1\n            else:\n                continue        \n\n        \n        balanced_str = []\n        \n        starts_i = 0\n        starts = [*reversed(starts)]\n        ends_i = 0\n        for i in range(len(s)):\n            if starts_i < len(starts) and i == starts[starts_i]:\n                starts_i += 1\n                balanced_str.append('(')\n            elif ends_i < len(ends) and i == ends[ends_i]:\n                ends_i += 1\n                balanced_str.append(')')\n            elif s[i] not in {'(', ')'}:\n                balanced_str.append(s[i])\n            \n        return ''.join(balanced_str)\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        res = ''\n        for c in s:\n            if c!=')': res += c\n            else:\n                if '(' in res:\n                    idx = res.rfind('(')\n                    res = res[:idx]+'L'+res[idx+1:]\n                    res+=')'\n        res = res.replace('(', '')\n        res = res.replace('L', '(')\n        return res\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        to_remove = []\n        stack = []\n        \n        for i,c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if len(stack):\n                    stack.pop()\n                    continue\n                to_remove.append(i)\n        \n        to_remove.extend(stack)\n        \n        s = list(s)\n        for i in to_remove:\n            s[i] = ''\n        \n        return ''.join(s)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \n        def validParentheses(s, left_closed=False):\n            i = 0\n            res = ''\n            while i < len(s):\n                _i = 1\n                _s = s[i]\n                if _s == '(':\n                    _res, __i, closed = validParentheses(s[i+1:], True)\n                    _i += __i\n                    if closed:\n                        _s += _res\n                    else:\n                        _s = _res\n                elif _s == ')':\n                    if left_closed:\n                        return res+')', i + 1, True\n                    else:\n                        _s = ''\n                else:\n                    pass\n                res += _s\n                i += _i\n            return res, i, False\n        \n        return validParentheses(s, False)[0]", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        par_stack = []\n        for i, ch in enumerate(s):\n            if ch == '(' or ch == ')':\n                par_stack.append((i, ch))\n                while len(par_stack) >= 2 and par_stack[-1][1] == ')' and par_stack[-2][1] == '(':\n                    par_stack.pop()\n                    par_stack.pop()\n        \n        invalid = {x[0]: True for x in par_stack}\n        ret = [ch for i, ch in enumerate(s) if i not in invalid]\n        return ''.join(ret)", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        mystack_bracket, mystack_letter = [], []\n        pos = 0\n        for i in s:\n            if i == '(':\n                mystack_bracket.append((i, pos))\n                #print(\\\"1\\\", mystack_bracket)\n            elif i == ')':\n                if len(mystack_bracket) !=0 :\n                    y = mystack_bracket.pop()\n                    mystack_letter.append(y)\n                    mystack_letter.append((i, pos))\n                    #print(\\\"2:\\\",mystack_letter)\n            else:\n                mystack_letter.append((i, pos))\n                #print(\\\"3:\\\",mystack_letter)\n                \n            pos += 1\n        \n \n        return ''.join(i for i,j in sorted(mystack_letter, key=lambda mystack_letter: mystack_letter[1]) ) \n        \n        \n        \n        \n        \n            \n        \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        count = 0\n        ans = ''\n        \n        for idx in range(len(s)):\n            if s[idx] == '(':\n                count += 1\n                ans += s[idx]\n                \n            elif s[idx] == ')':\n                if count > 0:\n                    count -= 1\n                    ans += s[idx]\n            \n            else:\n                ans += s[idx]\n         \n        idx = len(ans) - 1\n        while count > 0:\n            if ans[idx] == '(':\n                ans = ans[:idx] + ans[idx + 1:]\n                count -= 1\n            idx -= 1\n        \n        return ans", "from collections import deque\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        def process_s(s):\n            chs = deque([])\n            opening_p_count = 0\n            for ch in s:\n                if ch == '(':\n                    opening_p_count += 1\n                elif ch == ')':\n                    if opening_p_count == 0:\n                        continue\n                    opening_p_count -= 1\n                chs.append(ch)\n                \n            final_chs = deque([])\n            closing_p_count = 0\n            for i in range(len(chs) - 1, -1, -1):\n                ch = chs[i]\n                if ch == '(':\n                    if closing_p_count == 0:\n                        continue\n                    closing_p_count -= 1\n                elif ch == ')':\n                    closing_p_count += 1\n                final_chs.appendleft(ch)\n                \n            return ''.join(final_chs)\n                        \n        return process_s(s)\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        if len(s) == 0:\n            return s\n        \n        paranthesis_balance = 0\n        ends = []\n        \n        for i, char in enumerate(s):\n            if char == '(':\n                paranthesis_balance += 1\n            elif char == ')' and paranthesis_balance > 0:\n                ends.append(i)\n                paranthesis_balance -= 1\n            else:\n                continue        \n        \n        starts = []\n        paranthesis_balance = 0\n        \n        for i, char in enumerate(reversed(s)):\n            if char == ')':\n                paranthesis_balance += 1\n            elif char == '(' and paranthesis_balance > 0:\n                starts.append(len(s) - i - 1)\n                paranthesis_balance -= 1\n            else:\n                continue\n\n        \n        balanced_str = []\n        \n        starts_i = len(starts) - 1\n        ends_i = 0\n        for i in range(len(s)):\n            if starts_i >= 0 and i == starts[starts_i]:\n                starts_i -= 1\n                balanced_str.append('(')\n            elif ends_i < len(ends) and i == ends[ends_i]:\n                ends_i += 1\n                balanced_str.append(')')\n            elif s[i] not in {'(', ')'}:\n                balanced_str.append(s[i])\n            \n        return ''.join(balanced_str)\n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        counter = 0\n        newS = ''\n        for c in s:\n            if c == '(':\n                counter += 1\n            elif c == ')':\n                if counter == 0:\n                    continue\n                counter -= 1\n            newS += c\n            \n        result = ''\n        for c in newS[::-1]:\n            if c == '(' and counter > 0:\n                counter -= 1\n            else:\n                result = c + result\n        return result\n                \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        counter = 0\n        newS = ''\n        for c in s:\n            if c == ')':\n                if counter > 0:\n                    counter -= 1\n                    newS += c\n            elif c == '(':\n                counter += 1\n                newS += c\n            else:\n                newS += c\n        ans = ''\n        for c in newS[::-1]:\n            if c == '(' and counter > 0:\n                counter -= 1\n            else:\n                ans = c + ans\n                \n        \n        return ans\n                \n", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        left = 0\n        for i in s:\n            if i == '(':\n                left += 1\n            elif i == ')':\n                if left > 0:\n                    left -= 1\n                else:\n                    continue\n            stack.append(i)\n                \n        if left == 0:\n            return ''.join(stack)\n        \n        ans = ''\n        while stack:\n            val = stack.pop()\n            if left > 0 and val == '(':\n                left -= 1\n                continue\n            ans = val + ans\n        \n        return ans", "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        c, st, st2,  res = 0, [], set(), []\n        for j, ss in enumerate(s):\n            if ss == '(':\n                st.append(j)\n            elif ss == ')':\n                if st:\n                    st.pop()\n                else:\n                    st2.add(j)\n            else: continue\n        \n        for j, ss in enumerate(s):\n            if (ss == '(' and j in st) or (ss == ')' and j in st2) : continue \n            res.append(ss)\n                    \n        return ''.join(res)\n             \n"]
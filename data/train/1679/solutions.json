["# cook your dish here\nfor _ in range(int(input())):\n    l,n,x=map(int,input().split())\n    m=[]\n    pw1 = (1 << 17);  \n    pw2 = (1 << 18);  \n    if (n == 1) :  \n        m.append(x)\n    elif (n == 2 and x == 0) : \n        m.append(-1)\n    elif (n == 2) : \n        m.append(x)\n        m.append(0)\n    else : \n        ans = 0;  \n        for i in range(1, n - 2) : \n            m.append(i)\n            ans = ans ^ i;     \n        if (ans == x) : \n            m.append(pw1+pw2)\n            m.append(pw1)\n            m.append(pw2)\n        else:\n            m.append(pw1)\n            m.append((pw1 ^ x) ^ ans)\n            m.append(0)\n    p=(m)*l\n    for i in range(0,l):\n        print(p[i],end=' ')\n    print()    \n        ", "# cook your dish here\nfor _ in range(int(input())):\n    l,n,x=map(int,input().split())\n    m=[]\n    pw1 = (1 << 17);  \n    pw2 = (1 << 18);  \n    if (n == 1) :  \n        m.append(x)\n    elif (n == 2 and x == 0) : \n        m.append(-1)\n    elif (n == 2) : \n        m.append(x)\n        m.append(0)\n    else : \n        ans = 0;  \n        for i in range(1, n - 2) : \n            m.append(i)\n            ans = ans ^ i;     \n        if (ans == x) : \n            m.append(pw1+pw2)\n            m.append(pw1)\n            m.append(pw2)\n        else:\n            m.append(pw1)\n            m.append((pw1 ^ x) ^ ans)\n            m.append(0)\n    p=(m)*l\n    for i in range(0,l):\n        print(p[i],end=' ')\n    print()    \n        ", "# cook your dish here\ndef main():\n    for _ in range(int(input())):\n        n,k,x=map(int,input().split())\n        if k==1:\n            for i in range(n):\n                print(x,end=\" \")\n            print()\n        else:\n            def compxor(n) :  \n                if n % 4 == 0 :\n                    return n\n                if n % 4 == 1 :\n                    return 1  \n                if n % 4 == 2 :\n                    return n + 1\n                return 0\n            q=x^(compxor(k-1))\n##            print(q)\n            l=[i for i in range(1,k)]\n            l.append(q)\n##            print(l)\n            if n<=len(l):\n                print(\" \".join(map(str,l[:n])))\n            else:\n                j=0\n                for i in range(n):\n                    print(l[j],end=\" \")\n                    if j==len(l)-1:\n                        j=0\n                    else:\n                        j+=1\n                print()                \n\nmain()\n\n", "# cook your dish here\nfor ad in range(int(input())):\n    n,k,x=list(map(int,input().split()))\n    l=[0]*(k-1)\n    l.append(x)\n    l=l*(n//k)+l\n    l=l[:n]\n    for i in range(n):\n        print(l[i],end=\" \")\n    print()", "\r\nfrom math import radians\r\nfrom heapq import heapify, heappush, heappop\r\nimport bisect\r\nfrom math import pi\r\nfrom collections import deque\r\nfrom math import factorial\r\nfrom math import log, ceil\r\nfrom collections import defaultdict\r\nfrom math import *\r\nfrom sys import stdin, stdout\r\nimport itertools\r\nimport os\r\nimport sys\r\nimport threading\r\nfrom collections import deque, Counter, OrderedDict, defaultdict\r\nfrom heapq import *\r\n# from math import ceil, floor, log, sqrt, factorial, pow, pi, gcd\r\n# from bisect import bisect_left,bisect_right\r\n# from decimal import *,threading\r\nfrom fractions import Fraction\r\nmod = int(pow(10, 9)+7)\r\n# mod = 998244353\r\n\r\n\r\ndef ii(): return int(input())\r\n\r\n\r\ndef si(): return str(input())\r\n\r\n\r\ndef mi(): return map(int, input().split())\r\n\r\n\r\ndef li1(): return list(mi())\r\n\r\n\r\ndef fii(): return int(stdin.readline())\r\n\r\n\r\ndef fsi(): return str(stdin.readline())\r\n\r\n\r\ndef fmi(): return map(int, stdin.readline().split())\r\n\r\n\r\ndef fli(): return list(fmi())\r\n\r\n\r\nabd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12,\r\n       'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24,\r\n       'z': 25}\r\n\r\n\r\ndef getKey(item): return item[0]\r\n\r\n\r\ndef sort2(l): return sorted(l, key=getKey)\r\n\r\n\r\ndef d2(n, m, num): return [[num for x in range(m)] for y in range(n)]\r\n\r\n\r\ndef isPowerOfTwo(x): return (x and (not (x & (x - 1))))\r\n\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\", \"\")\r\n\r\n\r\ndef ntl(n): return [int(i) for i in str(n)]\r\n\r\n\r\ndef powerMod(x, y, p):\r\n    res = 1\r\n    x %= p\r\n    while y > 0:\r\n        if y & 1:\r\n            res = (res * x) % p\r\n        y = y >> 1\r\n        x = (x * x) % p\r\n    return res\r\n\r\n\r\ngraph = defaultdict(list)\r\nvisited = [0] * 1000000\r\ncol = [-1] * 1000000\r\n\r\n\r\ndef bfs(d, v):\r\n    q = []\r\n    q.append(v)\r\n    visited[v] = 1\r\n    while len(q) != 0:\r\n        x = q[0]\r\n        q.pop(0)\r\n        for i in d[x]:\r\n            if visited[i] != 1:\r\n                visited[i] = 1\r\n                q.append(i)\r\n        print(x)\r\n\r\n\r\ndef make_graph(e):\r\n    d = {}\r\n    for i in range(e):\r\n        x, y = mi()\r\n        if x not in d:\r\n            d[x] = [y]\r\n        else:\r\n            d[x].append(y)\r\n        if y not in d:\r\n            d[y] = [x]\r\n        else:\r\n            d[y].append(x)\r\n    return d\r\n\r\n\r\ndef gr2(n):\r\n    d = defaultdict(list)\r\n    for i in range(n):\r\n        x, y = mi()\r\n        d[x].append(y)\r\n    return d\r\n\r\n\r\ndef connected_components(graph):\r\n    seen = set()\r\n\r\n    def dfs(v):\r\n        vs = set([v])\r\n        component = []\r\n        while vs:\r\n            v = vs.pop()\r\n            seen.add(v)\r\n            vs |= set(graph[v]) - seen\r\n            component.append(v)\r\n        return component\r\n\r\n    ans = []\r\n    for v in graph:\r\n        if v not in seen:\r\n            d = dfs(v)\r\n            ans.append(d)\r\n    return ans\r\n\r\n\r\ndef primeFactors(n):\r\n    s = set()\r\n    while n % 2 == 0:\r\n        s.add(2)\r\n        n = n // 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):\r\n        while n % i == 0:\r\n            s.add(i)\r\n            n = n // i\r\n    if n > 2:\r\n        s.add(n)\r\n    return s\r\n\r\n\r\ndef find_all(a_str, sub):\r\n    start = 0\r\n    while True:\r\n        start = a_str.find(sub, start)\r\n        if start == -1:\r\n            return\r\n        yield start\r\n        start += len(sub)\r\n\r\n\r\ndef SieveOfEratosthenes(n, isPrime):\r\n    isPrime[0] = isPrime[1] = False\r\n    for i in range(2, n):\r\n        isPrime[i] = True\r\n    p = 2\r\n    while (p * p <= n):\r\n        if (isPrime[p] == True):\r\n            i = p * p\r\n            while (i <= n):\r\n                isPrime[i] = False\r\n                i += p\r\n        p += 1\r\n    return isPrime\r\n\r\n\r\ndef dijkstra(edges, f, t):\r\n    g = defaultdict(list)\r\n    for l, r, c in edges:\r\n        g[l].append((c, r))\r\n\r\n    q, seen, mins = [(0, f, ())], set(), {f: 0}\r\n    while q:\r\n        (cost, v1, path) = heappop(q)\r\n        if v1 not in seen:\r\n            seen.add(v1)\r\n            path = (v1, path)\r\n            if v1 == t:\r\n                return (cost, path)\r\n\r\n            for c, v2 in g.get(v1, ()):\r\n                if v2 in seen:\r\n                    continue\r\n                prev = mins.get(v2, None)\r\n                next = cost + c\r\n                if prev is None or next < prev:\r\n                    mins[v2] = next\r\n                    heappush(q, (next, v2, path))\r\n    return float(\"inf\")\r\n\r\n\r\ndef binsearch(a, l, r, x):\r\n    while l <= r:\r\n        mid = l + (r-1)//2\r\n        if a[mid]:\r\n            return mid\r\n        elif a[mid] > x:\r\n            l = mid-1\r\n        else:\r\n            r = mid+1\r\n    return -1\r\n\r\n\r\n# def input():\r\n#    return stdin.buffer.readline()\r\n\r\n\r\ndef readTree(n):\r\n    adj = [set() for _ in range(n)]\r\n    for _ in range(n-1):\r\n        u, v = map(int, input().split())\r\n        adj[u-1].add(v-1)\r\n        adj[v-1].add(u-1)\r\n    return adj\r\n\r\n\r\ndef treeOrderByDepth(n, adj, root=0):\r\n    parent = [-2] + [-1]*(n-1)\r\n    ordered = []\r\n    q = deque()\r\n    q.append(root)\r\n    depth = [0] * n\r\n    while q:\r\n        c = q.popleft()\r\n        ordered.append(c)\r\n        for a in adj[c]:\r\n            if parent[a] == -1:\r\n                parent[a] = c\r\n                depth[a] = depth[c] + 1\r\n                q.append(a)\r\n    return (ordered, parent, depth)\r\n\r\n\r\nfor _ in range(ii()):\r\n    n,k,x=mi()\r\n    l=[]\r\n    for i in range(n):\r\n        if i%k==0:\r\n            l.append(x)\r\n        else:\r\n            l.append(0)\r\n    print(*l)", "# cook your dish here\ndef main():\n    for _ in range(int(input())):\n        n,k,x=map(int,input().split())\n        if k==1:\n            for i in range(n):\n                print(x,end=\" \")\n            print()\n        else:\n            def compxor(n) :  \n                if n % 4 == 0 : \n                    return n \n                if n % 4 == 1 : \n                    return 1  \n                if n % 4 == 2 : \n                    return n + 1\n                return 0\n            q=x^(compxor(k-1))\n            l=[i for i in range(1,k)]\n            l.append(q)\n            if n<=len(l):\n                print(\" \".join(map(str,l[:n])))\n            else:\n                j=0\n                for i in range(n):\n                    print(l[j],end=\" \")\n                    if j==len(l)-1:\n                        j=0\n                    else:\n                        j+=1\n                print()                \n\nmain()", "# cook your dish here\nt = int(input())\n\nwhile(t>0):\n    t-=1\n    n, k, x = list(map(int, input().split()))\n    while(n>0):\n        n-=1\n        print(x, end=' ')\n        for i in range(k-1):\n            if(n>0):\n                print(0, end=' ')\n                n-=1\n    print('\\n')", "# cook your dish here\nt = int(input())\nwhile t:\n    n, k, x = list(map(int, input().split()))\n    arr = [x]\n    for i in range(k-1):\n        arr.append(0)\n    j = 0\n    for i in range(n):\n        print(arr[j], end = \" \")\n        j += 1\n        if j == k:\n            j = 0\n    print()\n    t -= 1", "from math import ceil\r\n\r\nfor T in range(int(input())):\r\n    N, K, X = map(int, input().split())\r\n    print(' '.join(map(str, (([X] + [0] * (K - 1)) * ceil(N/K))[:N])))", "from math import ceil\r\n\r\ndef raavan(N, K, X):\r\n    return ' '.join(map(str, (([X] + [0] * (K - 1)) * ceil(N/K))[:N]))\r\n\r\nfor T in range(int(input())):\r\n    N, K, X = map(int, input().split())\r\n    print(raavan(N, K, X))", "t = int(input())\r\n\r\nwhile(t>0):\r\n    t-=1\r\n    n, k, x = list(map(int, input().split()))\r\n    while(n>0):\r\n        n-=1\r\n        print(x, end=' ')\r\n        for i in range(k-1):\r\n            if(n>0):\r\n                print(0, end=' ')\r\n                n-=1\r\n    print('\\n')", "t=int(input())\nfor i in range(t):\n    n,k,x=map(int,input().split())\n    X=[x]\n    for i in range(0,k-1):\n        X.append(0)\n    i=0\n    v=[]\n    j=0\n    while(j<n):\n        v.append(X[i])\n        i+=1\n        if i==len(X):\n            i=0\n        j+=1\n    print(*v)\n        ", "\"\"\"\n\n    Author - AYUSHMAN CHAHAR #\n\n\"\"\"\n\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\n#import numpy\nfrom itertools import combinations\nfrom itertools import permutations\nfrom collections import deque\nfrom atexit import register\nfrom collections import Counter\nfrom functools import reduce\nsys.setrecursionlimit(10000000)\n\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n  \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n \ndef main():\n    \n\tfor _ in range(int(eval(input()))):\n\t\tn, length, xored = list(map(int, input().split()))\n\t\tans = [-1] * n\n\t\ttempl = [0] * (length - 1)\n\t\ttempl.append(xored)\n\t\t#print(templ)\n\t\ttemp = n % length\n\t\tfor i in range(len(templ)):\n\t\t\ttempl.append(templ[i])\n\t\tstart = 0\n\t\tfor i in range(len(ans)):\n\t\t\tans[i] += (templ[start] + 1)\n\t\t\t#print(ans)\n\t\t\t#print(templ[start])\n\t\t\tstart += 1\n\t\t\tif start == len(templ):\n\t\t\t\tstart = 0\n\t\tprint(*ans) \n\t\t\ndef __starting_point():\n    sync_with_stdio(False)\n    main()\n \n\n__starting_point()", "t = int(input())\r\n\r\nwhile(t>0):\r\n    t-=1\r\n    n, k, x = list(map(int, input().split()))\r\n    while(n>0):\r\n        n-=1\r\n        print(x, end=' ')\r\n        for i in range(k-1):\r\n            if(n>0):\r\n                print(0, end=' ')\r\n                n-=1\r\n    print('\\n')", "# cook your dish here\n # Let's hack this code.\n\nfrom sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\nmod = 1000000007\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\n\ndef printIn(ob):\n    return stdout.write(str(ob))\n\ndef powerLL(n, p):\n    result = 1\n    while (p):\n        if (p&1):\n            result = result * n % mod\n        p = int(p / 2)\n        n = n * n % mod\n    return result\n\n#--------------------------------------\n\ndef myCode():\n    n,k,x = In()\n    res = []\n    j = 0\n    if k == 1:\n        res = [x for i in range(n)]\n    else:\n        while j<n:\n            i = 0\n            while j<n and i<k:\n                if i == k-1:\n                    res.append(x)\n                else:\n                    res.append(0)\n                i+=1\n                j+=1\n    for i in range(n):\n        print(res[i],end=' ')\n    print(\"\")\n    \ndef main():\n    for t in range(I()):\n        myCode()\ndef __starting_point():\n    main()\n\n__starting_point()", "# cook your dish here\nfor _ in range(int(input())):\n    n ,k ,x = list(map(int,input().split()))\n    l = [0]*n\n    for i in range(0,n,k):\n        l[i] = x\n    l = list(map(str,l))\n    print(' '.join(l))\n\n            \n        ", "# cook your dish here\nfor _ in range(int(input())):\n    n,k,x=map(int,input().split())\n    a=[]\n    if k%2==0:\n        for i in range(1,k):\n            a.append(0)\n        a.append(x)\n    else:\n        for i in range(1,k):\n            a.append(0)\n        a.append(x)\n    b=[]\n    j=0\n    for i in range(n):\n        if j==len(a):\n            j=0\n        b.append(a[j])\n        j=j+1\n    for i in b:\n        print(i,\"\",end=\"\")\n    print()", "for _ in range(int(input())):\n    n,k,x = map(int, input().split())\n    \n    a = n*[0]\n    \n    for i in range(0,n,k):\n        a[i] = x\n    print(*a)    ", "# cook your dish here\nfor k in range(int(input())):\n\tleng, cont, val = map(int, input().split())\n\ttemp = cont*[0]\n\ttemp[0] = val\n\tans0 = (leng//cont)*temp + temp[:leng%cont]\n\tans = ' '.join([str(x) for x in ans0])\n\tprint(ans)", "for i in range(int(input())):\n    n,k,x=map(int,input().split())\n    a=[]\n    for i in range(n):\n        if((i+1)%k!=0):\n            a.append(0)\n        else:\n            a.append(x)\n    print(*a)", "for _ in range(int(input())):\n    n,k,x = map(int, input().split())\n    if k==1:\n        for _ in range(n):\n            print(x,end=\" \")\n        print()\n        continue\n    for i in range(n):\n        if i%k==0:\n            print(x, end=\" \")\n        else:\n            print(0, end=\" \")\n    print()", "# cook your dish here\nfor _ in range(int(input())):\n\tn,k,x=map(int,input().split())\n\tlst=list()\n\twhile(len(lst)!=n):\n\t\tlst.append(x)\n\t\tif(len(lst)==n):\n\t\t\tbreak\n\t\tfor i in range(k-1):\n\t\t\tlst.append(0)\n\t\t\tif(len(lst)==n):\n\t\t\t\tbreak\n\t\t#print(lst)\n\tprint(*lst,end=\" \")\n\tprint()", "# cook your dish here\nfor _ in range(int(input())):\n    n,k,x=map(int,input().split())\n    for i in range(n):\n        if (i+1)%k==0 and i!=(n-1):\n            print(x,end=' ')\n        elif i==n-1:\n            print(x if n%k==0 else 0)\n        else:\n            print(0,end=' ')", "# cook your dish here\nfor _ in range(int(input())):\n    n,k,x = map(int,input().split())\n    a = []\n    if( k == 1):\n        for i in range(n):\n            print(x,end = ' ')\n    else:\n        a.append(x)\n        for i in range(k - 1):\n            a.append(0)\n        j = 0\n        p = 0\n        for i in range(n):\n            if( i < len(a) - 1):\n                print( a[i], end = ' ')\n            else:\n                j = i % len(a)\n                print( a[j] , end = ' ')\n    print()", "# cook your dish here\nfrom sys import stdin,stdout\nfrom math import gcd,sqrt,ceil\nfrom copy import deepcopy\nii1=lambda:int(stdin.readline().strip())\nis1=lambda:stdin.readline().strip()\niia=lambda:list(map(int,stdin.readline().strip().split()))\nisa=lambda:stdin.readline().strip().split()\nmod=1000000007\ndef power(base,power,modulus):\n    res = 1\n    while power:\n        if power&1:\n            res=(res*base)%modulus\n        base=(base*base)%modulus\n        power//=2\n    return res\nma=1152921504606846976\nt=ii1()\nfor i in range(t):\n    n,k,x=map(int,input().split())\n    for i in range(1,n+1):\n        if i%k==0:\n            print(x,end=' ')\n        else:\n            print(0,end=' ')\n    print()\n"]
["import sys\n\ndef powc(x,n,m):\n  res = 1\n  xx=x\n  while n:\n    if n&1:\n      res = (res*xx)%m\n    xx=xx*xx%m\n    n >>= 1\n  return res\n\ndef circles(u):\n  r = 0\n  S = [(u,-1,0)]\n  Visited[u] = 0\n  for s in S:\n    for e in V[s[0]]:\n      if e[0] != s[1]:\n        if Visited[e[0]]==-1: \n          Visited[e[0]] = s[2]^e[1]\n          S.append((e[0], s[0], s[2]^e[1])) \n        elif Visited[e[0]] != s[2]^e[1]:\n          return -1\n        else:\n          r += s[0]<e[0]\n  return r\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n  is_bad = False\n  empty = 0\n  n,Q = list(map(int, sys.stdin.readline().split()))\n  for _ in range(n-1):\n    sys.stdin.readline() \n  paths = []\n  V=list(map(list,[[]]*n))\n  for q in range(Q):\n    u,v,x = list(map(int, sys.stdin.readline().split()))\n    u-=1\n    v-=1\n    if (v,x^1) in V[u]:\n      is_bad = True\n    elif (v,x) in V[u]:\n      empty += 1\n    elif u!=v:\n      V[u].append((v,x))\n      V[v].append((u,x))\n    elif x==1:\n      is_bad = True\n    else:\n      empty += 1\n    paths.append((u,v,x))\n  if is_bad:\n    print(0)\n  elif n<=1:\n    print(1)\n  else:\n    Visited = [-1]*n\n    components = 0\n    for i in range(n):\n      if Visited[i]==-1:\n        components += 1\n        c = circles(i)\n        if c==-1:\n          is_bad = True\n          break\n        empty += c\n    if is_bad:\n      print(0)\n    else:\n      print(powc(2,n-1-(Q-empty),10**9+7)) \n", "import sys\n\ndef powc(x,n,m):\n  res = 1\n  xx=x\n  while n:\n    if n&1:\n      res = (res*xx)%m\n    xx=xx*xx%m\n    n >>= 1\n  return res\n\ndef circles(u):\n  r = 0\n  S = [(u,-1,0)]\n  Been = [-1]*n\n  Been[u] = 0\n  for s in S:\n    Visited[s[0]] = 1\n    for e in V[s[0]]:\n      if e[0] != s[1]:\n        if Been[e[0]]==-1: \n          Been[e[0]] = s[2]^e[1]\n          S.append((e[0], s[0], s[2]^e[1])) \n        elif Been[e[0]] != s[2]^e[1]:\n          return -1\n        else:\n          r += s[0]<e[0]\n  return r\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n  is_bad = False\n  empty = 0\n  n,Q = list(map(int, sys.stdin.readline().split()))\n  for _ in range(n-1):\n    sys.stdin.readline() \n  paths = []\n  V=list(map(list,[[]]*n))\n  E = []\n  for q in range(Q):\n    u,v,x = list(map(int, sys.stdin.readline().split()))\n    u-=1\n    v-=1\n    if (v,x^1) in V[u]:\n      is_bad = True\n    elif (v,x) in V[u]:\n      empty += 1\n    elif u!=v:\n      E.append((u,v,x))\n      V[u].append((v,x))\n      V[v].append((u,x))\n    elif x==1:\n      is_bad = True\n    else:\n      empty += 1\n    paths.append((u,v,x))\n  if is_bad:\n    print(0)\n  elif n<=1:\n    print(1)\n  else:\n    Visited = [0]*n\n    components = 0\n    for i in range(n):\n      if Visited[i]==0:\n        components += 1\n        c = circles(i)\n        if c==-1:\n          is_bad = True\n          break\n        empty += c\n    if is_bad:\n      print(0)\n    else:\n      print(powc(2,n-1-(Q-empty),10**9+7)) \n", "import sys\n\ndef powc(x,n,m):\n  res = 1\n  xx=x\n  while n:\n    if n&1:\n      res = (res*xx)%m\n    xx=xx*xx%m\n    n >>= 1\n  return res\n\ndef circles(u):\n  r = 0\n  S = [(u,-1,0)]\n  Been = [-1]*n\n  for s in S:\n    if Been[s[0]]!=-1:\n      if Been[s[0]][1] != s[2]:\n        return -1\n      r += 1\n      continue\n    Been[s[0]] = (0,s[2])\n    Visited[s[0]] = 1\n    for e in V[s[0]]:\n      if e[0] != s[1]:\n        if Been[e[0]]==-1: \n          S.append((e[0], s[0], s[2]^e[1])) \n  return r\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n  is_bad = False\n  empty = 0\n  n,Q = list(map(int, sys.stdin.readline().split()))\n  for _ in range(n-1):\n    sys.stdin.readline() \n  paths = []\n  V=list(map(list,[[]]*n))\n  E = []\n  for q in range(Q):\n    u,v,x = list(map(int, sys.stdin.readline().split()))\n    u-=1\n    v-=1\n    if (v,x^1) in V[u]:\n      is_bad = True\n    elif (v,x) in V[u]:\n      empty += 1\n    elif u!=v:\n      E.append((u,v,x))\n      V[u].append((v,x))\n      V[v].append((u,x))\n    elif x==1:\n      is_bad = True\n    else:\n      empty += 1\n    paths.append((u,v,x))\n  if is_bad:\n    print(0)\n  elif n<=1:\n    print(1)\n  else:\n    Visited = [0]*n\n    components = 0\n    for i in range(n):\n      if Visited[i]==0:\n        components += 1\n        c = circles(i)\n        if c==-1:\n          is_bad = True\n          break\n        empty += c\n    if is_bad:\n      print(0)\n    else:\n      print(powc(2,n-1-(Q-empty),10**9+7)) \n", "import sys\n\ndef powc(x,n,m):\n  res = 1\n  xx=x\n  while n:\n    if n&1:\n      res = (res*xx)%m\n    xx=xx*xx%m\n    n >>= 1\n  return res\n\ndef findRoot():\n  S = [(0,-1)]\n  for u in S:\n    for w in V[u[0]]:\n      if w[0]!=u[1]:\n        S.append((w[0],u[0]))\n  S = [(S[-1][0],-1,0)]\n  D = [0]*n\n  for u in S:\n    for w in V[u[0]]:\n      if w[0]!=u[1]:\n        D[w[0]]=u[2]+1\n        S.append((w[0],u[0],u[2]+1))\n  d = S[-1][2]\n  size = d\n  u = S[-1][0]\n  while size/2<d:\n    for w in V[u]:\n      if D[w[0]]+1==D[u]:\n        u = w[0]\n        d -= 1\n        break \n  return u\n  \nclass Node:\n  def __init__(self, value, edge, parent = None):\n    self.value = value\n    self.edge = edge\n    if parent:\n      parent.addChild(self)\n    else:\n      self.parent = None\n    self.children = []\n  def addChild(self, node):\n    node.parent = self\n    self.children.append(node)\n  def __repr__(self):\n    r = repr(self.value)\n    for v in self.children:\n      r += ' ' + repr(v)\n    return r\n\n\ndef hangTree(root):\n  global NodesArray\n  NodesArray = [None]*n\n  S=[(root, Node(root,-1),-1)]\n  NodesArray[root] = S[0][1]\n  for u in S:\n    for v in V[u[0]]:\n      if v[0] != u[2]:\n        node = Node(v[0],v[1],u[1])\n        NodesArray[v[0]] = node\n        S.append((v[0],node,u[0]))\n\ndef findPath2(u,v):\n  n0 = NodesArray[u]\n  n1 = NodesArray[v]\n  q = [0]*n\n  while n0.parent:\n    q[n0.edge] ^= 1\n    n0 = n0.parent\n  while n1.parent:\n    q[n1.edge] ^= 1\n    n1 = n1.parent\n  return q\n         \nT = int(sys.stdin.readline())\nfor _ in range(T):\n  n,Q = list(map(int,sys.stdin.readline().split()))\n  V = list(map(list,[[]]*n))\n  W = [0]*n\n  for i in range(n-1):\n    u,v = list(map(int,sys.stdin.readline().split()))\n    u-=1\n    v-=1\n    V[u].append((v,i))\n    V[v].append((u,i))\n    W[u] += 1\n    W[v] += 1\n  easy = n==1\n  root = findRoot()\n  hangTree(root)\n  M = []\n  for _ in range(Q):\n    u,v,x = list(map(int,sys.stdin.readline().split()))\n    if not easy:\n      q = findPath2(u-1,v-1)\n      q[-1] = x\n      M.append(q)\n  if easy:\n    print(1)\n    continue\n  empty = [0]*n\n  bad = [0]*n\n  bad[-1] = 1\n  is_there_bad = False\n  empty_cnt = 0\n  i = 0\n  for q in M:\n    i += 1\n    if q == empty:\n      empty_cnt += 1\n      continue\n    if q == bad:\n      is_there_bad = True\n      break\n    o = q.index(1)\n    for next in range(i,Q):\n      if M[next][o]==1:\n        for k in range(n):\n          M[next][k] ^= q[k]\n  if is_there_bad:\n    print(0)\n  else:\n    print(powc(2,n-1-Q+empty_cnt,10**9+7))\n", "import sys\n\ndef powc(x,n,m):\n  res = 1\n  xx=x\n  while n:\n    if n&1:\n      res = (res*xx)%m\n    xx=xx*xx%m\n    n >>= 1\n  return res\n\n\ndef findPath(u,v,x):\n  S = [(u,v,x)]\n  for s in S:\n    if s[0]==v:\n      return s[2]\n    for e in V[s[0]]: \n      if e[0] != s[1]:\n        S.append((e[0],s[0],s[2]^e[1]))\n  return None\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n  is_bad = False\n  empty = 0\n  n,Q = list(map(int, sys.stdin.readline().split(' ')))\n  for _ in range(n-1):\n    sys.stdin.readline() \n  paths = []\n  V=list(map(list,[[]]*n))\n  E = []\n  for q in range(Q):\n    u,v,x = list(map(int, sys.stdin.readline().split(' ')))\n    u-=1\n    v-=1\n    if (v,x^1) in V[u]:\n      is_bad = True\n    elif (v,x) in V[u]:\n      empty += 1\n    else:\n      E.append((u,v,x))\n      V[u].append((v,x))\n      V[v].append((u,x))\n    paths.append((u,v,x))\n  if is_bad:\n    print(0)\n  else:\n    while E:\n      e = E.pop()\n      x = findPath(e[0],e[1],e[2]) \n      V[e[0]].remove((e[1],e[2]))\n      V[e[1]].remove((e[0],e[2]))\n      if x==1:\n        is_bad = True\n        break\n      if x==0:\n        empty += 1\n    if is_bad:\n      print(0)\n    else:\n      print(powc(2,n-1-(Q-empty),10**9+7))\n", "def modpow(a,x):\n\tif(x==0):\n\t\treturn 1;\n\telif(x%2==0):\n\t\tt=modpow(a,x/2);\n\t\treturn (t*t)%(1000000007);\n\telse:\n\t\tt=modpow(a,x/2);\n\t\treturn (t*t*a)%(1000000007);\n\t\t\n\t\t\t\t\t\nT=eval(input());\nans=[0]*T;\nfor j in range(T):\n\t[N,Q]=[int(x) for x in (input()).split()];\n\tfor i in range(N-1):\n\t\tinput();\n\tcomp=list(range(N+1));\n\trevcomp=[];\n\tfor i in range(N+1):\n\t\trevcomp.append([i]);\t\n\tsumcomp=[0]*(N+1);\n\tflag=True;\n\trank=0;\n\tfor i in range(Q):\n\t\tif(not(flag)):\n\t\t\tinput();\n\t\telse:\t\n\t\t\t[u,v,x]=[int(x) for x in (input()).split()];\n\t\t\tif(comp[u]==comp[v]):\n\t\t\t\tif(not((sumcomp[u]+sumcomp[v])%2==(x%2))):\n\t\t\t\t\tflag=False;\n\t\t\telse:\n\t\t\t\trank=rank+1;\n\t\t\t\tn1=len(revcomp[comp[u]]);\n\t\t\t\tn2=len(revcomp[comp[v]]);\n\t\t\t\tif(n1<n2):\n\t\t\t\t\toldsu=sumcomp[u];\n\t\t\t\t\tl=revcomp[comp[v]];\n\t\t\t\t\tfor w in revcomp[comp[u]]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[v];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[v]+x+oldsu)%2;\n\t\t\t\t\t#revcomp[comp[u]]=[];\t\n\t\t\t\telse:\n\t\t\t\t\toldsv=sumcomp[v];\n\t\t\t\t\tl=revcomp[comp[u]];\n\t\t\t\t\tfor w in revcomp[comp[v]]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[u];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[u]+x+oldsv)%2;\n\t\t\t\t\t#revcomp[comp[v]]=[];\t\n\tif(not(flag)):\n\t\tans[j]=0;\n\telse:\n\t\tans[j]=modpow(2,(N-rank-1));\n\nfor j in range(T):\n\tprint((ans[j]));\t\t\t\n", "def modpow(a,x):\n\tif(x==0):\n\t\treturn 1;\n\telif(x%2==0):\n\t\tt=modpow(a,x/2);\n\t\treturn (t*t)%(1000000007);\n\telse:\n\t\tt=modpow(a,x/2);\n\t\treturn (t*t*a)%(1000000007);\n\t\t\n\t\t\t\n\t\t\n\t\t\t\nT=eval(input());\nans=[0]*T;\nfor j in range(T):\n\t[N,Q]=[int(x) for x in (input()).split()];\n\tfor i in range(N-1):\n\t\tinput();\n\tcomp=list(range(N+1));\n\trevcomp=[];\n\tfor i in range(N+1):\n\t\trevcomp.append([i]);\t\n\tsumcomp=[0]*(N+1);\n\tflag=True;\n\trank=0;\n\tfor i in range(Q):\n\t\tif(not(flag)):\n\t\t\tinput();\n\t\telse:\t\n\t\t\t[u,v,x]=[int(x) for x in (input()).split()];\n\t\t\tif(comp[u]==comp[v]):\n\t\t\t\tif(not((sumcomp[u]+sumcomp[v])%2==(x%2))):\n\t\t\t\t\tflag=False;\n\t\t\telse:\n\t\t\t\trank=rank+1;\n\t\t\t\tn1=len(revcomp[comp[u]]);\n\t\t\t\tn2=len(revcomp[comp[v]]);\n\t\t\t\tif(n1<n2):\n\t\t\t\t\toldsu=sumcomp[u];\n\t\t\t\t\tl=revcomp[comp[v]];\n\t\t\t\t\tfor w in revcomp[u]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[v];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[v]+x+oldsu)%2;\n\t\t\t\telse:\n\t\t\t\t\toldsv=sumcomp[v];\n\t\t\t\t\tl=revcomp[comp[u]];\n\t\t\t\t\tfor w in revcomp[v]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[u];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[u]+x+oldsv)%2;\n\tif(not(flag)):\n\t\tans[j]=0;\n\telse:\n\t\tans[j]=modpow(2,(N-rank-1));\n\nfor j in range(T):\n\tprint((ans[j]));\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\n\n", "T=eval(input());\nans=[0]*T;\nfor j in range(T):\n\t[N,Q]=[int(x) for x in (input()).split()];\n\tfor i in range(N-1):\n\t\tinput();\n\tcomp=list(range(N+1));\n\trevcomp=[];\n\tfor i in range(N+1):\n\t\trevcomp.append([i]);\t\n\tsumcomp=[0]*(N+1);\n\tflag=True;\n\trank=0;\n\tfor i in range(Q):\n\t\tif(not(flag)):\n\t\t\tinput();\n\t\telse:\t\n\t\t\t[u,v,x]=[int(x) for x in (input()).split()];\n\t\t\tif(comp[u]==comp[v]):\n\t\t\t\tif(not((sumcomp[u]+sumcomp[v])%2==(x%2))):\n\t\t\t\t\tflag=False;\n\t\t\telse:\n\t\t\t\trank=rank+1;\n\t\t\t\tn1=len(revcomp[comp[u]]);\n\t\t\t\tn2=len(revcomp[comp[v]]);\n\t\t\t\tif(n1<n2):\n\t\t\t\t\toldsu=sumcomp[u];\n\t\t\t\t\tl=revcomp[comp[v]];\n\t\t\t\t\tfor w in revcomp[u]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[v];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[v]+x+oldsu)%2;\n\t\t\t\telse:\n\t\t\t\t\toldsv=sumcomp[v];\n\t\t\t\t\tl=revcomp[comp[u]];\n\t\t\t\t\tfor w in revcomp[v]:\n\t\t\t\t\t\tl.append(w);\n\t\t\t\t\t\tcomp[w]=comp[u];\n\t\t\t\t\t\tsumcomp[w]=(sumcomp[w]+sumcomp[u]+x+oldsv)%2;\n\tif(not(flag)):\n\t\tans[j]=0;\n\telse:\n\t\tans[j]=2**(N-rank-1);\n\nfor j in range(T):\n\tprint((ans[j]));\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\n\n"]
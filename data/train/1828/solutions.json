["class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if len(barcodes) < 2:\n            return barcodes\n        \n        sorted_codes = sorted(barcodes)\n        halfway = len(barcodes)//2\n        ans =  [0] * (halfway * 2)\n        ans[::2], ans[1::2] = sorted_codes[-halfway:], sorted_codes[:halfway]\n            \n        if len(barcodes) % 2 == 1:\n            prev = None\n            mid = sorted_codes[halfway]\n            for i in range(len(ans) - 1):\n                if ans[i] == mid:\n                    i += 1\n                elif ans[i] != prev:\n                    ans.insert(i, mid)\n                    break\n                prev = ans[i]\n        return ans\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        barcodes.sort()\n        n = len(barcodes)\n        result = list()\n        \n        if n%2 == 0:\n            for x, y in zip(barcodes[:n//2], barcodes[n//2:]):\n                result.extend([y,x])\n        else:\n            midVal = barcodes[n//2]\n            isAdded = False\n            prev = -1\n            for x,y in zip(barcodes[:n//2], barcodes[n//2+1:]):\n                if isAdded == False and prev != midVal and y != midVal:\n                    result.append(midVal)\n                    isAdded = True\n                result.extend([y, x])\n                prev = x\n            if isAdded == False:\n                result.append(midVal)\n        return result", "from collections import Counter\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        barcodes = Counter(barcodes)\n        a = []\n        for i,j in barcodes.most_common():\n            a.extend([i]*j)\n        l = len(a)\n        res = [0]*l\n        j=0\n        for i in range(0,l,2):\n            res[i]=a[j]\n            j+=1\n        for i in range(1,l,2):\n            res[i]=a[j]\n            j+=1\n        return res\n            \n", "from heapq import heappush,heappop\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        hashmap = {}\n        for i in range(len(barcodes)):\n            key = barcodes[i]\n            if key not in hashmap:\n                hashmap[key] = 1\n            else:\n                hashmap[key] = hashmap[key]+1\n        h = []\n        for key,val in list(hashmap.items()):\n            heappush(h,(-val,key))\n        result = [ ]\n        tlist = []\n        while h:\n            pending_lst = []\n            for i in range(2):\n                if h:\n                    frequency, char = heappop(h)\n                    positive_frequency = -frequency\n                    if positive_frequency > 0:\n                        pending_lst.append((positive_frequency-1, char))\n                        if result and char == result[-1]:\n                            continue\n                        result.append(char)\n            if not h and not pending_lst:\n                break\n            for frequency, char in pending_lst:\n                heappush(h, (-frequency, char))\n        return result\n                    \n        \n        \n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        # https://leetcode.com/problems/distant-barcodes/discuss/801339/Easy-to-Read-and-Understand-Python-Solution-with-Comments!\n        # Get the counts of all of our barcode elements.\n        cnts = collections.Counter(barcodes)\n\\t\\t# Put the -'ve counts along with themselves into a min heap.\n\\t\\t# For those new to this we use -'ve because this is a min heap, so largest cnt pop'd first.\n        heap = [(-v, k) for k,v in cnts.items()]\n        heapq.heapify(heap)\n        res = []\n        # While we have elements on our heap.\n        while heap:\n\\t\\t    # pop the top element.\n            cnt1, num1 = heapq.heappop(heap)\n\\t\\t\\t# If the top element was the last we used, we need something different.\n            if res and res[-1] == num1:\n\\t\\t\\t    # pop the next highest cnt element. \n                cnt, num = heapq.heappop(heap)\n                res.append(num)\n                cnt += 1\n\\t\\t\\t\\t# If there's still elements left we put them back on the heap.\n                if cnt != 0:\n                    heapq.heappush(heap, (cnt, num))\n\\t\\t\\t\\t# We can also add the first that we popped, and push it back on the heap as well.\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n\\t\\t\\t# else we just add the highest cnt element and put the remaining back on.\n            else:\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n            \n        return res\n    \n# Run time O(NlogN), space O(N)", "from collections import Counter\nimport heapq\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        count = Counter(barcodes)\n        pq = []\n        \n        for tup in count.items():\n            heapq.heappush(pq,(-tup[1],tup[0]))\n            \n        res = []\n        \n        prev_freq,prev_char = 0,None\n        \n        while pq:\n            \n            freq,num = heapq.heappop(pq)\n            \n            if -prev_freq > 0 and prev_char:\n                heapq.heappush(pq,(prev_freq,prev_char))\n            \n            res.append(num)\n            prev_freq = freq+1\n            prev_char = num\n            \n        \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        mp = collections.defaultdict(int)\n        for b in barcodes:\n            mp[b]+=1\n        heap = []\n        for k,v in list(mp.items()):\n            heapq.heappush(heap,(-v,k))\n        idx = 0\n        n = len(barcodes)\n        ans = [0]*n\n        while heap:\n            f,v = heapq.heappop(heap)\n            f=-f\n            while f>0:\n                ans[idx]=v\n                idx+=2\n                f-=1\n                if idx>=n: \n                    idx=1\n        return ans\n\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        max_v = max(len(barcodes), max(barcodes))+1\n        freq = [0]*max_v\n        for v in barcodes:\n            freq[v]+=1\n        sortedList=[[] for _ in range(max_v)]\n        for v, f in enumerate(freq):\n            if f > 0:\n                sortedList[-f].extend([v]*f)\n        result = []\n        for index in sortedList:\n            for mi in index:\n                    result.append(mi)\n        barcodes = result\n        res = [\\\"\\\"]*len(barcodes)\n        i = 0\n        j = 0\n        while j < len(barcodes):\n            res[i] = barcodes[j]\n            i=i+2\n            j=j+1\n            if i > len(res)-1:\n                i=1\n        return res\n        \n        ", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count = {}\n        for code in barcodes:\n            if code in count:\n                count[code] += 1\n            else:\n                count[code] = 1\n        count = {k: v for k, v in sorted(count.items(), key=lambda item: item[1],reverse=True)}\n\n        it = iter(count.keys())\n        cur = next(it)\n        i = 0\n        while i < len(barcodes):\n            while count[cur] == 0:\n                cur = next(it)\n            barcodes[i] = cur\n            count[cur] -= 1\n            i += 2\n        i = 1\n        while i < len(barcodes):\n            while count[cur] == 0:\n                cur = next(it)\n            barcodes[i] = cur\n            count[cur] -= 1\n            i += 2\n        return barcodes", "class Solution:\n    def rearrangeBarcodes(self, A: List[int]) -> List[int]:\n        c=collections.Counter(A)\n        A.sort(key=lambda x:(c[x],x))\n        \n        A[1::2],A[::2]=A[:len(A)//2],A[len(A)//2:]\n        return A\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        dicta = collections.defaultdict(int)\n        max_word = 0\n        for i in barcodes:\n            dicta[i]+=1\n            if dicta[i]>dicta[max_word]:\n                max_word = i\n        \n        n=len(barcodes)\n        ans = [0 for i in range(n)]\n        idx=0\n        \n        for i in range(dicta[max_word]):\n            ans[idx] = max_word\n            idx+=2    \n        del dicta[max_word]\n        #print(ans)\n        #idx=1\n        for let in dicta:\n            for i in range(dicta[let]):\n                if idx>=n:\n                    idx=1\n                ans[idx]=let\n                idx+=2\n        \n        return ans\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count = defaultdict(int)\n        for i in barcodes:\n            count[i] -= 1\n        h = []\n        for i in count:\n            heappush(h, (count[i], i))\n        # even\n        out = [0 for _ in range(len(barcodes))]\n        freq, code = heappop(h)\n        for i in range(0, len(barcodes), 2):\n            out[i] = code\n            freq += 1\n            if not freq and h:\n                freq, code = heappop(h)\n        \n        if not freq and h:\n            freq, code = heappop(h)\n        \n        # odd\n        for i in range(1, len(barcodes), 2):\n            out[i] = code\n            freq += 1\n            if not freq and h:\n                freq, code = heappop(h)\n                \n        return out\n", "from collections import Counter\nfrom heapq import heapify, heappop\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        c = Counter(barcodes)\n        h = []\n        for k, count in list(c.items()):\n            h.append((-count, k))\n        heapify(h)\n        \n        res = [0] * len(barcodes)\n        index = 0\n        while h:\n            count, num = heappop(h)\n            count = -count\n            while count:\n                if index >= len(barcodes):\n                    index = 1\n                res[index] = num\n                index += 2\n                count -= 1\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter = collections.Counter(barcodes)\n        data = [[] for i in range(len(barcodes)+1)]\n        \n        for i in counter:\n            data[counter[i]].append(i)\n            \n        res = [None for k in range(len(barcodes))]\n        temp = 0\n        for j in range(len(data)-1, 0, -1):\n            if len(data[j]) == 0:\n                continue\n            for char in data[j]:\n                times = j\n                while(times > 0):\n                    res[temp] = char\n                    temp += 2\n                    times -= 1\n                    if temp >= len(res):\n                        temp = 1\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        dicta = [0]*10001\n        max_word = 0\n        for i in barcodes:\n            dicta[i]+=1\n            if dicta[i]>dicta[max_word]:\n                max_word = i\n        \n        #n=len(barcodes)\n        ans = [0 for i in range(len(barcodes))]\n        idx=0\n        \n        for i in range(dicta[max_word]):\n            ans[idx] = max_word\n            idx+=2    \n        dicta[max_word]=0\n        \n        for j in range(10001):\n            if dicta[j]>0:\n                for i in range(dicta[j]):\n                    if idx>=len(barcodes):\n                        idx=1\n                    ans[idx]=j\n                    idx+=2\n        \n        return ans\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        n = len(barcodes)\n        \n        counter = Counter(barcodes)\n        \n        sorted_barcodes = sorted(barcodes,key=lambda x: (counter[x],x))\n        \n        res = [0] * n\n        \n        res[1::2],res[::2] = sorted_barcodes[:n//2],sorted_barcodes[n//2:]\n        \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count = {}\n        for code in barcodes:\n            if code in count:\n                count[code] += 1\n            else:\n                count[code] = 1\n        count = {k: v for k, v in sorted(count.items(), key=lambda item: item[1],reverse=True)}\n        def nextCode(last: int) -> int:\n            for k in count.keys():\n                if count[k] > 0:\n                    count[k] -= 1\n                    return k\n        it = iter(count.keys())\n        cur = next(it)\n        i = 0\n        while i < len(barcodes):\n            while count[cur] == 0:\n                cur = next(it)\n            barcodes[i] = cur\n            count[cur] -= 1\n            i += 2\n        i = 1\n        while i < len(barcodes):\n            while count[cur] == 0:\n                cur = next(it)\n            barcodes[i] = cur\n            count[cur] -= 1\n            i += 2\n        return barcodes", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        n=len(barcodes)\n        if n==1:\n            return barcodes\n        ans=[]\n        barcodes.sort()\n        if n%2==0:\n            for x,y in zip(barcodes[:n//2],barcodes[n//2:]):\n                ans.extend([y,x])\n        else:\n            mid=barcodes[n//2]\n            added,x_last=0,-1 # added: flag indicating if the middle element is added to the result\n            for x,y in zip(barcodes[:n//2],barcodes[n//2+1:]):\n                if not added and x_last!=mid and y!=mid: \n                    ans.append(mid)\n                    added=1\n                ans.extend([y,x])\n                x_last=x\n            if not added:\n                ans.append(mid)\n        return ans\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        record=dict()\n        for bar in barcodes:\n            record[bar]=record.get(bar,0)+1\n        record=sorted([(k,v) for k,v in record.items()], key=lambda x: x[1], reverse=True)\n        max_count=record[0][1]\n        read=[]\n        for k,v in record:\n            read+=[k]*v\n        L=len(read)\n        res=[[] for _ in range(max_count)]\n        for idx in range(L):\n            res[idx%max_count].append(read[idx])\n        ress=[]\n        for r in res:\n            ress+=r\n        return ress", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        len_ = len(barcodes)\n        freq = collections.Counter()\n        maxFreqCode = 0\n        for code in barcodes:\n            freq[code] += 1\n            if freq[code] > freq[maxFreqCode]:\n                maxFreqCode = code\n        \n        i = 0\n        ans = [0] * len_\n        \n        for _ in range(freq[maxFreqCode]):\n            ans[i] = maxFreqCode\n            i += 2\n        freq[maxFreqCode] = 0    \n        \n        for code in freq:    \n            for _ in range(freq[code]):\n                if i >= len_:\n                    i = 1\n                ans[i] = code\n                i += 2\n            freq[code] = 0    \n            \n        return ans", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        i, n = 0, len(barcodes)\n        res = [0] * n\n        for k, v in collections.Counter(barcodes).most_common():\n            for _ in range(v):\n                res[i] = k\n                i += 2\n                if i >= n: i = 1\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes):\n        cnt = dict()\n        for v in barcodes:\n            cnt[v] = cnt.get(v, 0) + 1\n        N = len(barcodes)\n        barcodes.sort(key = lambda v: (cnt[v], v), reverse = True)\n        A = [0] * N\n        A[::2], A[1::2] = barcodes[:(N+1)//2], barcodes[(N+1)//2:]\n        return A", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count = collections.Counter(barcodes)\n        barcodes.sort(key=lambda a: (count[a], a))\n        barcodes[1::2], barcodes[::2] = barcodes[0:len(barcodes) // 2], barcodes[len(barcodes) // 2:]\n        return barcodes", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        dt = collections.Counter(barcodes)\n        hp = []\n        for code, freq in list(dt.items()):\n            heapq.heappush(hp, (-freq, code))\n        res = []\n        while len(hp) > 1:\n            freq1, bar1 = heapq.heappop(hp)\n            freq2, bar2 = heapq.heappop(hp)\n            res.append(bar1)\n            res.append(bar2)\n            if freq1 < -1:\n                heapq.heappush(hp, (freq1+1, bar1))\n            \n            if freq2 < -1:\n                heapq.heappush(hp, (freq2+1, bar2))\n        \n        if hp:\n            res.append(heapq.heappop(hp)[1])\n        \n        return res\n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        m = [0 for _ in range(10001)]\n        max_cnt = 0\n        max_n = 0\n        for n in barcodes:\n            m[n] += 1\n            if m[n] > max_cnt:\n                max_cnt = m[n]\n                max_n = n \n                \n        res = [0 for _ in range(len(barcodes))]\n        pos = 0\n        for i in range(10001):\n            n = max_n if i == 0 else i\n            \n            while m[n] > 0:\n                m[n] -= 1\n                \n                res[pos] = n\n                pos = pos + 2 if pos + 2 < len(barcodes) else 1\n                \n                \n        return res ", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        import heapq\n        from collections import Counter\n\n        cnt = Counter(barcodes)\n        items = [(-v, k) for k, v in cnt.items()]\n\n        heapq.heapify(items)\n        res = []\n\n        while len(items) > 1:\n\n            v1, k1 = heapq.heappop(items)\n            v1 += 1\n\n            v2, k2 = heapq.heappop(items)\n            v2 += 1\n\n            res.extend([k1, k2])\n\n            if v1 != 0:\n                heapq.heappush(items, (v1, k1))\n\n            if v2 != 0:\n                heapq.heappush(items, (v2, k2))\n                \n        if len(items) == 1:\n            res.append(items[0][1])\n\n        return res", "from collections import Counter\nimport heapq as q\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        c = Counter(barcodes)\n        \n        xs = []\n        for k, v in list(c.items()):\n            q.heappush(xs, (-v, k))\n        \n        r = []\n        while len(xs) > 1:\n            av, ak = q.heappop(xs)\n            bv, bk = q.heappop(xs)\n            \n            r.append(ak)\n            r.append(bk)\n            \n            av += 1\n            bv += 1\n            if av < 0:\n                q.heappush(xs, (av, ak))\n            if bv < 0:\n                q.heappush(xs, (bv, bk))\n        \n        \n        if len(xs) == 0: return r\n        \n        av, ak = q.heappop(xs)\n        \n        r.append(ak)\n        \n        return r\n        \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        c=collections.Counter(barcodes)\n        heap=[]\n        for cha,time in list(c.items()):\n            heapq.heappush(heap,(-time,cha))  \n        res=[]\n        while heap:\n            n=len(heap)\n            if n>=2:\n                t1,c1=heapq.heappop(heap)\n                res.append(c1)\n                t2,c2=heapq.heappop(heap)\n                res.append(c2)\n                if t1+1<0:\n                    heapq.heappush(heap,(t1+1,c1))\n                if t2+1<0:\n                    heapq.heappush(heap,(t2+1,c2))\n            else:\n                t,c=heapq.heappop(heap)\n                res.append(c)\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        i, n = 0, len(barcodes)\n        res = [0] * n\n        for k, v in collections.Counter(barcodes).most_common():\n            for _ in range(v):\n                res[i] = k\n                i += 2\n                if i >= n: i = 1\n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        h=[]\n        c=collections.Counter(barcodes)\n        for i in c:\n            heapq.heappush(h,(-c[i],i))\n        res=[]\n        if len(barcodes)<2:\n            return str(barcodes[0])\n        while h:\n            val1,char1=heapq.heappop(h)\n            char2=''\n            if h:\n                val2,char2=heapq.heappop(h)\n            res.append(char1)\n            res.append(char2)\n            \n            if val1*(-1) > 1:\n                heapq.heappush(h,(val1+1,char1))\n            if val2*(-1)>1:\n                heapq.heappush(h,(val2+1,char2))\n        return res                        \n            \n            \n            \n", "from heapq import heappush,heappop\nfrom collections import defaultdict\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = defaultdict(int)\n        for code in barcodes:\n            freq[code] += 1\n           \n        maxH, res = [], []\n        for num, count in freq.items():\n            heappush(maxH, (-count, num))\n        \n        while maxH:\n            count1, num1 = heappop(maxH)\n            count1 += 1\n            res.append(num1)\n            if maxH:\n                count2, num2 = heappop(maxH)\n                res.append(num2)\n                count2 += 1\n                if count2 < 0:\n                    heappush(maxH, (count2, num2))\n            if count1 < 0:  \n                heappush(maxH, (count1, num1))\n        \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter = Counter(barcodes)\n        heap = [(-v, c) for c, v in counter.items()]\n        heapq.heapify(heap)\n        res = []\n        while heap:\n            popped = []\n            for _ in range(2):\n                if not heap: return res\n                v, c = heapq.heappop(heap)\n                res.append(c)\n                if v<-1:\n                    popped.append([v+1, c])\n            \n            for v, c in popped:\n                heapq.heappush(heap, (v, c))\n                    \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes):\n        cnt = dict()\n        for v in barcodes:\n            cnt[v] = cnt.get(v, 0) + 1\n        N = len(barcodes)\n        barcodes.sort(key = lambda v: (-cnt[v], v))\n        A = [0] * N\n        A[::2], A[1::2] = barcodes[:(N+1)//2], barcodes[(N+1)//2:]\n        return A", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        d = defaultdict(int)\n        heap = []\n        res = []\n        for bc in barcodes:\n            d[bc] += 1\n        \n        for key, val in d.items():\n            heapq.heappush(heap,(-val,key))\n        while heap:\n            cur = heapq.heappop(heap)\n            if res and res[-1] == cur[1]:\n                tmp = heapq.heappop(heap)\n                res.append(tmp[1])\n                val = 1 + tmp[0]\n                if val != 0:\n                    heapq.heappush(heap,(val, tmp[1]))\n                heapq.heappush(heap,(cur))\n\n            else:\n                res.append(cur[1])\n                v = cur[0] + 1\n                if v != 0:\n                    heapq.heappush(heap,(v, cur[1]))\n        return res", "from collections import Counter, deque\nfrom heapq import *\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count = Counter(barcodes)\n        res = []\n        maxHeap = []\n        for num, freq in list(count.items()):\n            heappush(maxHeap,(-freq, num))\n        q = deque([])\n        while maxHeap:\n            negCnt, num = heappop(maxHeap)\n            res.append(num)\n            \n            q.append((negCnt, num))\n            if len(q) == 2:\n                negCnt, num = q.popleft()\n                negCnt += 1\n                if negCnt < 0:\n                    heappush(maxHeap, (negCnt, num))\n        \n        return res\n                \n        \n", "import heapq as hq\nfrom collections import Counter\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter = Counter(barcodes)\n        cqueue = [(-v, k) for k, v in list(counter.items())]\n        hq.heapify(cqueue)\n        res = []\n        while len(cqueue) > 0:\n            neg_count, barcode = hq.heappop(cqueue)\n\n            if len(res) != 0 and res[-1] == barcode:\n                neg_count_2, barcode_2 = hq.heappop(cqueue)\n                hq.heappush(cqueue, (neg_count, barcode))\n                neg_count, barcode = neg_count_2, barcode_2\n            res.append(barcode)\n\n            if neg_count != -1:\n                hq.heappush(cqueue, (neg_count + 1, barcode))\n        \n        return res\n                \n        \n", "import heapq\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count = {}\n        for i in barcodes:\n            if i not in count:\n                count[i] = 0\n            count[i] += 1\n            \n        heap = [(-v,k) for k,v in list(count.items())]\n        heapq.heapify(heap)\n        \n        op = [None]\n        i = 0\n        \n        while heap:\n            temp = []\n            while True:\n                maxVal, maxKey = heapq.heappop(heap)\n                if maxKey == op[-1]:\n                    temp.append((maxVal, maxKey))\n                else:\n                    break\n            \n            op.append(maxKey)\n            \n            currVal = maxVal+1\n            if currVal<0:\n                heapq.heappush(heap,(currVal,maxKey))\n                \n            while temp:\n                val,key = temp.pop()\n                heapq.heappush(heap,(val,key))\n            # print(\\\"This is heap:\\\",heap)        \n        return op[1:]\n        \n                \n                \n                \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        '''\n        Method\n        \n        \n        1). Create a count the frequency\n        2) use that count to create a min heap by taking the neg values of the count\n        3) use the two highest count nums in the heap to change the barcode indicies\n        4) at the same time, decrement said values by adding 1 and keep a check to see when the heap is empty\n        5) at the end, make sure the heap is empty as there may be 1 extra value due to an odd num\n        \n        '''\n        \n        \n        count = defaultdict(int)\n        \n        for i in barcodes:\n            count[i] += 1\n            \n            \n        heap= []\n        \n        for key, val in list(count.items()):\n            heap.append([-val, key])\n            \n        heapq.heapify(heap)\n        idx = 0\n        \n        while len(heap) > 1:\n            one = heapq.heappop(heap)\n            two = heapq.heappop(heap)\n            \n            barcodes[idx] = one[1]\n            idx += 1\n            barcodes[idx] = two[1]\n            idx += 1\n            \n            one[0] += 1\n            two[0] += 1\n            \n            \n            if one[0] != 0:\n                heapq.heappush(heap, one)\n            if two[0] != 0:\n                heapq.heappush(heap, two)\n                \n            \n        if heap:\n            barcodes[idx] = heapq.heappop(heap)[1]\n            \n        return barcodes\n                \n            \n\n", "from heapq import heappush, heappop, heapify\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        # 1. Heap: O(N log N) Time, O(N) Space\n#         counter = defaultdict(int)\n#         for n in barcodes:\n#             counter[n] += 1\n        \n#         maxHeap = []\n#         for n, val in counter.items():\n#             heappush(maxHeap, [-val, n])\n        \n#         prev = None\n#         for i in range(len(barcodes)):\n#             val, id = heappop(maxHeap)\n#             if val < 0:\n#                 temp = [val + 1, id]\n#             else:\n#                 temp = None\n            \n#             barcodes[i] = id\n            \n#             if prev:\n#                 heappush(maxHeap, prev)\n#             prev = temp\n#         return barcodes\n\n        # 2. Bucket Sort\n        counter = Counter(barcodes)\n        i = 0\n        for n, count in counter.most_common():\n            for _ in range(count):\n                barcodes[i] = n\n                i += 2\n                if i >= len(barcodes):\n                    i = 1\n        return barcodes\n            \n        \n        \n", "class Solution:\n    def update(self, freq, key, heap):\n        if freq > 1:\n            heappush(heap, (-1 * (freq - 1), key))\n            \n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq_map = defaultdict(int)\n        heap = []\n        res = []\n        for n in barcodes:\n            freq_map[n] += 1\n        \n        for key in list(freq_map.keys()):\n            heappush(heap, (-1 * freq_map[key], key))\n        \n        while len(heap) > 0:\n            freq_a, key_a = heappop(heap)\n            res.append(key_a)\n            \n            if len(heap) == 0:\n                break\n            freq_b, key_b = heappop(heap)\n            res.append(key_b)\n            self.update(-1 * freq_a, key_a, heap)\n            self.update(-1 * freq_b, key_b, heap)\n        return res\n", "import heapq\nfrom collections import Counter\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counts = Counter(barcodes)\n        arr = [[-v, k] for k, v in list(counts.items())]\n        heapq.heapify(arr)\n        newBarcodes = []\n        while len(arr) != 0:\n            elem1 = heapq.heappop(arr)\n            newBarcodes.append(elem1[1])\n            if len(arr) == 0:\n                return newBarcodes\n            elem2 = heapq.heappop(arr)\n            newBarcodes.append(elem2[1])\n            elem1[0] += 1\n            if elem1[0] < 0:\n                heapq.heappush(arr, elem1)\n            elem2[0] += 1\n            if elem2[0] < 0:\n                heapq.heappush(arr, elem2)\n        return newBarcodes\n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        h=collections.Counter(barcodes)\n        heap=[(-value,key) for key,value in list(h.items())]\n        heapq.heapify(heap)\n        a=[]\n        while heap:\n            x=heapq.heappop(heap)\n            if heap==[]:\n                a.append(x[1])\n                return a\n            y=heapq.heappop(heap)\n            a.append(x[1])\n            a.append(y[1])\n            if x[0]+1!=0:\n                heapq.heappush(heap,(x[0]+1,x[1]))\n            if y[0]+1!=0:\n                heapq.heappush(heap,(y[0]+1,y[1]))\n        return a\n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = {}\n        \n        # create frq\n        for b in barcodes:\n            if b in freq:\n                freq[b] += 1\n            else:\n                freq[b] = 1\n        \n        descBarcode = sorted([(k, v) for (k, v) in list(freq.items())], key=lambda i: i[1], reverse=True)\n        # print(descBarcode)\n        \n        newBarcode = []\n        maxIncrements = descBarcode[0][1] # -1\n        \n        curIndex, curIncrements = 1, 0\n        for num, count in descBarcode:\n            if not newBarcode:\n                newBarcode = [num] * count\n            else:\n                while count > 0:\n                    # print(f\\\"Inserting {num} at {curIndex}\\\", newBarcode)\n                    newBarcode.insert( curIndex, num )\n                    curIndex += 2\n                    maxIncrements += 1\n                    if curIncrements > maxIncrements or curIndex > len(newBarcode):\n                        curIndex = 1\n                        maxIncrements = 0\n                    count -= 1\n        \n        # for i in range(len(newBarcode)):\n        #     if i > 0 and newBarcode[i] == newBarcode[i-1]:\n        #         newBarcode.pop(i)\n        #         newBarcode.insert(0, newBarcode[i-1])\n        # # print(newBarcode)\n        return newBarcode\n                \n        \n        \n                \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if len(barcodes) < 2:\n            return barcodes\n        \n        counter = collections.Counter(barcodes)\n        \n        heap = []\n        \n        for k,v in counter.items():\n            heapq.heappush(heap,(-v,k))\n        result = []\n        while len(heap) > 1:\n            count1,key1 = heapq.heappop(heap)\n            count2,key2 = heapq.heappop(heap)\n            result.append(key1)\n            result.append(key2)\n            count1 +=1\n            count2+=1\n            if count1 < 0:\n                heapq.heappush(heap,(count1,key1))\n            if count2 < 0:\n                heapq.heappush(heap,(count2,key2))\n        \n        print(heap)\n        if len(heap) > 0:\n            count,key = heapq.heappop(heap)\n            result.append(key)\n            return result\n        else:\n            return result", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = [0] * 10001\n        maxFreqCode = 0\n        for code in barcodes:\n            freq[code] += 1\n            if freq[code] > freq[maxFreqCode]:\n                maxFreqCode = code\n        i, n = 0, len(barcodes)\n        ans = [0] * n\n        for code in range(10001):    \n            if code == 0:\n                code = maxFreqCode\n            for _ in range(freq[code]):\n                if i >= n:\n                    i = 1\n                ans[i] = code\n                i += 2\n            freq[code] = 0    \n        return ans", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = {}\n        \n        # create frq\n        for b in barcodes:\n            if b in freq:\n                freq[b] += 1\n            else:\n                freq[b] = 1\n        \n        frqBarcode = [(k, v) for (k, v) in list(freq.items())]\n        maxNum, maxIncrements = max(frqBarcode, key=lambda i: i[1])\n        \n        newBarcode = [maxNum] * maxIncrements\n        \n        curIndex, curIncrements = 1, 0\n        for num, count in frqBarcode:\n            if num == maxNum:\n                continue\n            while count > 0:\n                newBarcode.insert( curIndex, num )\n                curIndex += 2\n                maxIncrements += 1\n                if curIncrements > maxIncrements or curIndex > len(newBarcode):\n                    curIndex = 1\n                    maxIncrements = 0\n                count -= 1\n\n        return newBarcode\n                \n        \n        \n                \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        h=[]\n        d=defaultdict(int)\n        for ele in barcodes:\n            d[ele]+=1\n            \n        for key, val in d.items():\n            heappush(h, (-1*val, key))\n        res=[]\n        prev=()\n        while h:\n            ele=heappop(h)\n            freq=ele[0]*-1\n            res.append(ele[1])\n            if prev!=():\n                heappush(h, prev)\n            if freq!=1:\n                prev=(-1*(freq-1), ele[1])\n            else:\n                prev=()\n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        hq = [(-v, i) for i, v in collections.Counter(barcodes).items()]\n        heapq.heapify(hq)\n        \n        res = []\n        while hq:\n            temp = []\n            for _ in range(min(len(hq), 2)):\n                val, number = heapq.heappop(hq)\n                temp.append((val, number))\n                res.append(number)\n            \n            for _ in range(len(temp)):\n                val, number = temp.pop()\n                if val < -1:\n                    heapq.heappush(hq,(val+1, number))\n        \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = {}\n        \n        # create frq\n        for b in barcodes:\n            if b in freq:\n                freq[b] += 1\n            else:\n                freq[b] = 1\n        \n        descBarcode = sorted([(k, v) for (k, v) in list(freq.items())], key=lambda i: i[1], reverse=True)\n        \n        newBarcode = []\n        maxIncrements = descBarcode[0][1] # -1\n        \n        curIndex, curIncrements = 1, 0\n        for num, count in descBarcode:\n            if not newBarcode:\n                newBarcode = [num] * count\n            else:\n                while count > 0:\n                    newBarcode.insert( curIndex, num )\n                    curIndex += 2\n                    maxIncrements += 1\n                    if curIncrements > maxIncrements or curIndex > len(newBarcode):\n                        curIndex = 1\n                        maxIncrements = 0\n                    count -= 1\n\n        return newBarcode\n                \n        \n        \n                \n", "from collections import Counter\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freqs = Counter(barcodes)\n        result = [-1] * len(barcodes)\n        i = 0\n        for bc, c in sorted(freqs.items(), key=lambda x: -x[1]):\n            for _ in range(c):\n                if i >= len(result):\n                    i = 1\n                result[i] = bc\n                i += 2\n        return result", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        if len(barcodes) <= 1:\n            return barcodes\n        \n        def helper(barcodes, k):\n            \n            freqCount = collections.defaultdict(int)\n            for ele in barcodes:\n                freqCount[ele] += 1\n                \n            result = []\n            cooldown = collections.deque()\n            heap = []\n            for key, value in freqCount.items():\n                heapq.heappush(heap, (-value, key))\n                \n            while len(heap) > 0:\n                \n                count, element = heapq.heappop(heap)\n                count *= -1\n                \n                result.append(element)\n                cooldown.append((count - 1, element))\n                if len(cooldown) < k:\n                    continue\n                cooldownCount, cooldownElement = cooldown.popleft()\n                if cooldownCount > 0:\n                    heapq.heappush(heap, (-cooldownCount, cooldownElement))\n                    \n            return result\n        \n        return helper(barcodes, 2)", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counts = {k: 0 for k in barcodes}\n        for n in barcodes:\n            counts[n] += 1\n        # barcode = []\n        # def backtrack(size):\n        #     if len(barcode) == size:\n        #         return True\n        #     for k in counts:\n        #         if counts[k] > 0:\n        #             if len(barcode) == 0 or barcode[-1] != k:\n        #                 barcode.append(k)\n        #                 counts[k] -= 1\n        #                 if backtrack(size):\n        #                     return True\n        #                 else:\n        #                     barcode.pop()\n        #                     counts[k] += 1\n        #     return False\n        # backtrack(len(barcodes))\n        # return barcode\n        barcodes.sort()\n        barcode = []\n        \n        heap = [(-y,x) for x,y in list(counts.items())]\n        heapq.heapify(heap)\n        print(heap)\n        \n        while len(heap) > 0:\n            freq,digit = heapq.heappop(heap)\n            if len(barcode) == 0 or barcode[-1] != digit:\n                barcode.append(digit)\n                if freq < -1:\n                    freq += 1\n                    heapq.heappush(heap,(freq,digit))\n            else:\n                nextFreq,nextDig = heapq.heappop(heap)\n                barcode.append(nextDig)\n                heapq.heappush(heap,(freq,digit))\n                if nextFreq < -1:\n                    nextFreq += 1\n                    heapq.heappush(heap,(nextFreq,nextDig))\n                    \n        \n        \n        return barcode\n            \n                \n                \n                    \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        cnts = collections.defaultdict(int)\n        for n in barcodes:\n            cnts[n] += 1\n        \n        barcodes.sort(key = lambda x : (cnts[x], x))\n        n = len(barcodes)\n        first, second = barcodes[:n//2], barcodes[n//2:]\n        res = []\n        f, s = 0, 0\n        #print(barcodes)\n        #print(first, second)\n        while f < len(first) or s < len(second):\n            if s < len(second):\n                res.append(second[s])\n                s += 1\n            if f < len(first):\n                res.append(first[f])\n                f += 1\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        q = [[-v, k] for k, v in collections.Counter(barcodes).items()]\n        heapq.heapify(q)\n        result = []\n        while q:\n            if result and result[-1] == q[0][1]:\n                tmp = heapq.heappop(q)\n                item = heapq.heappop(q)\n                result.append(item[1])\n                item[0] += 1\n                if item[0] < 0:\n                    heapq.heappush(q, item)\n                heapq.heappush(q, tmp)\n            else:\n                item = heapq.heappop(q)\n                result.append(item[1])\n                item[0] += 1\n                if item[0] < 0:\n                    heapq.heappush(q, item)\n        return result", "from collections import Counter, defaultdict\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter = Counter(barcodes)\n        memo = defaultdict(list)\n        rest = 0\n        for e, c in counter.most_common():\n            memo[c].append(e)\n            rest += c\n        ret = []\n        while rest:\n            rest -= 1\n            for c in sorted(memo.keys(), reverse=True):\n                for idx, e in enumerate(memo[c]):\n                    if ret and ret[-1] == e:\n                        continue                \n                    ret.append(e)\n                    del memo[c][idx]\n                    if not memo[c]:\n                        del memo[c]\n                    memo[c-1].append(e)\n                    break\n                if rest == len(barcodes) - len(ret):\n                    break\n                    \n        return ret", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\nfrom math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\\\"\\\"\\\"\nstartSI\nnextSI\ntotalUsed\n\ncurEnd = si + (cnt - 1) * (m+1)\nif curEnd >= nextSI:\n    nextSI = curEnd + 1\n\nif startSI\n\ntotalUsed += cnt\n\n123123144 -> 143124123 -> 12312412455\n14312412355\n\n\n\\\"\\\"\\\"\n\nfrom math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\nfrom math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\n\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\nclass Solution:\n\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        h = []\n        N = len(barcodes)\n        ans = []\n        cnts = {}\n        for c in barcodes:\n            if not c in cnts:\n                cnts[c] = 0\n            cnts[c] += 1\n        for c, cnt in cnts.items():\n            heappush(h, (-cnt, c))\n        while len(h):\n            negCnt, c = heappop(h)\n            if len(ans) and c == ans[-1]:\n                negCnt2, c2 = heappop(h)\n                ans.append(c2)\n                newCnt2 = -negCnt2 - 1\n                if newCnt2:\n                    heappush(h, (-newCnt2, c2))\n                heappush(h, (negCnt, c))\n            else:\n                ans.append(c)\n                newCnt = -negCnt - 1\n                if newCnt:\n                    heappush(h, (-newCnt, c))\n        return ans\n\n\\\"\\\"\\\"\nS = Solution()\nl = [1, 1, 1, 2, 2, 2]\nl = [1, 1, 1, 1, 2, 2, 3, 3]\nprint(S.rearrangeBarcodes(l))\n\\\"\\\"\\\"", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if len(barcodes) <= 1:\n            return barcodes\n        counts = defaultdict(int)\n        for b in barcodes:\n            counts[b] += 1\n        max_count = 0\n        max_b = 0\n        for b, c in counts.items():\n            if c > max_count:\n                max_count = c\n                max_b = b\n        everything_else = [b for b in barcodes if b != max_b]\n        arranged = [max_b] * max_count\n        # Split everything once\n        i = 1\n        while i <= len(arranged) and len(everything_else) != 0:\n            arranged.insert(i, everything_else.pop(0))\n            i += 2\n        # Add everything else\n        def can_add_at(i, b):\n            if i == 0:\n                return arranged[i] != b\n            elif i == len(arranged):\n                return arranged[-1] != b\n            else:\n                return arranged[i] != b and arranged[i-1] != b\n        i = 0\n        while len(everything_else) != 0:\n            if can_add_at(i, everything_else[0]):\n                arranged.insert(i, everything_else.pop(0))\n            i += 1\n        return arranged", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        queue = deque()\n        heap = []\n        d = {}\n        res = []\n        time = 0\n        \n        for code in barcodes:\n            d[code] = d.get(code, 0) - 1\n        \n        for k, v in d.items():\n            heapq.heappush(heap, (v, k))\n        \n        while heap or queue:\n            if heap:\n                count, code = heapq.heappop(heap)\n                count += 1\n                res.append(code)\n\n                if count < 0:\n                    queue.append([time + 1, (count, code)])\n            \n            if queue and queue[0][0] <= time:\n                heapq.heappush(heap, queue.popleft()[1])\n            \n            time += 1\n        \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        i, n = 0, len(barcodes)\n        \n        res = [0] * n\n        \n        for k, v in collections.Counter(barcodes).most_common():\n            for _ in range(v):\n                res[i] = k\n                i += 2\n                if i >= n: \n                    i = 1\n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        import heapq\n        n=len(barcodes)\n        d={}\n        for x in barcodes:\n            if(d.get(x)!=None):\n                d[x]+=1\n            else:\n                d[x]=1\n        barcodes=[]\n        for x in list(d.keys()):\n            heapq.heappush(barcodes,(-d[x],x))\n        ans=[]\n        for x in range(n):\n            temp=[]\n            if(ans==[]):\n                curr=heapq.heappop(barcodes)\n                ans.append(curr[1])\n                if(curr[0]!=-1):\n                    heapq.heappush(barcodes,(curr[0]+1,curr[1]))\n                # print(barcodes)\n            else:\n                while(True):\n                    # print(barcodes,ans)\n                    curr=heapq.heappop(barcodes)\n                    if(ans[-1]!=curr[1]):\n                        ans.append(curr[1])\n                        if(curr[0]!=-1):\n                            heapq.heappush(barcodes,(curr[0]+1,curr[1]))\n                        break\n                    else:\n                        temp.append(curr)\n                while(len(temp)):\n                    heapq.heappush(barcodes,temp.pop())\n        return ans\n\n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        l=barcodes[::]\n        n=len(l)\n        c=Counter(l)\n        c=list(sorted(list(c.items()),key=lambda x:-x[1]))\n        nl=[0]*n\n        y=0\n        x=c[y][1]\n        val=c[y][0]\n        for i in range(0,n,2):\n            nl[i]=val\n            x-=1\n            if x==0:\n                y+=1\n                if y<len(c):\n                    x=c[y][1]\n                    val=c[y][0]        \n        for i in range(1,n,2):\n            nl[i]=val\n            x-=1\n            if x==0:\n                y+=1\n                if y<len(c):\n                    x=c[y][1]\n                    val=c[y][0]\n        return nl\n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        i, n = 0, len(barcodes)\n        res = [0] * n\n        for k, v in collections.Counter(barcodes).most_common():\n            for _ in range(v):\n                res[i] = k\n                i += 2\n                if i >= n: i = 1\n                # print(res)\n        return res", "import heapq\nfrom collections import Counter\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        ans = []\n        c = Counter(barcodes)\n        heap = []\n        for b in c:\n            heapq.heappush(heap, (-c[b], b))\n        while(heap):\n            temp = heapq.heappop(heap)\n            if(ans and ans[-1] == temp[1]):\n                temp2 = heapq.heappop(heap)\n                ans.append(temp2[1])\n                heapq.heappush(heap, (temp[0], temp[1]))\n                if(temp2[0] < -1):\n                    heapq.heappush(heap, (temp2[0]+1, temp2[1]))\n            else:\n                ans.append(temp[1])\n                if(temp[0] < -1):\n                    heapq.heappush(heap, (temp[0]+1, temp[1]))\n        return ans", "from collections import Counter, defaultdict\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter = Counter(barcodes)\n        memo = defaultdict(list)\n        rest = 0\n        for e, c in counter.most_common():\n            memo[c].append(e)\n            rest += c\n        ret = []\n        while rest:\n            rest -= 1\n            for c in sorted(memo.keys(), reverse=True):\n                for idx, e in enumerate(memo[c]):\n                    if ret and ret[-1] == e:\n                        continue                \n                    ret.append(e)\n                    del memo[c][idx]\n                    if not memo[c]:\n                        del memo[c]\n                    memo[c-1].append(e)\n                    break\n                if rest == len(barcodes) - len(ret):\n                    break\n                    \n                    \n        return ret", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        d=collections.Counter(barcodes)\n        res=[]\n        pq=[]\n        for no,f in list(d.items()):\n            heapq.heappush(pq,[-f,no])\n        temp=[]    \n        while len(pq)!=0 or temp!=0:\n            if(len(pq)!=0):\n                f,no=heapq.heappop(pq)\n                if(temp!=[]):\n                    heapq.heappush(pq,temp)\n                    temp=[]\n            else:\n                if(temp!=[]):\n                    f,no=temp\n                    temp=[]\n                else:\n                    break\n            f=f*-1\n            f=f-1\n            res.append(no)\n            if(f!=0):\n                if(len(pq)==0):\n                    heapq.heappush(pq,[-f,no])\n                elif -f>pq[0][0]:\n                    heapq.heappush(pq,[-f,no])\n                else:\n                    temp=[-f,no]\n                    \n                \n        return res        \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        d = Counter(barcodes)\n        cand = barcodes[0]\n        maxi = d[cand]\n        \n        for idx,(k,v) in enumerate(d.items()):\n            \n            if v > maxi:\n                maxi = v\n                cand = k\n        \n        res =[None for i in range(len(barcodes))]\n        pos = 0\n        for i in range(maxi):\n            res[pos] = cand\n            pos+=2\n        \n        del d[cand]\n        \n        for idx,(k,v) in enumerate(d.items()):\n            \n            for j in range(v):\n                if pos >= len(res):\n                    pos = 1\n                    \n                res[pos] = k\n                pos+=2\n        \n        return res\n                \n            \n            \n        \n", "import heapq\nfrom collections import Counter\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n            c = Counter(barcodes)\n            heap = []\n            res = []\n            for key, val in list(c.items()):\n                heap.append((-val, key))\n                \n            heapq.heapify(heap)\n            prevCnt = 0\n            \n            while heap:\n                cnt, code = heapq.heappop(heap)\n                cnt = -cnt\n                res.append(code)\n                if prevCnt>0: heapq.heappush(heap, (-prevCnt, prevCode))\n                prevCnt = cnt-1\n                prevCode = code\n                \n            return res\n                \n", "import collections\nfrom heapq import heappush, heappop\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        elementCountMap = collections.Counter(barcodes)\n        elementStack = []\n        for element, count in list(elementCountMap.items()):\n            heappush(elementStack, [-count, element])\n        \n        result = []\n        \n        previousElement = None\n        \n        while elementStack:\n            tmp = None\n            count, element = heappop(elementStack)\n            if element == previousElement:\n                tmp = [count, element]\n                count, element = heappop(elementStack)\n                \n            result.append(element)\n            previousElement = element\n            count += 1\n            if count < 0:\n                heappush(elementStack, [count, element])\n            \n            if tmp:\n                heappush(elementStack, tmp)\n                \n        return result\n", "import heapq\nfrom collections import Counter\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        maxheap=[]\n        K=0\n        map1=Counter(barcodes)\n        index=0\n        for k,v in list(map1.items()):\n            heappush(maxheap,(-v,k))\n        \n        res=[0]*len(barcodes)\n        while len(maxheap)>0:\n            \n            element=heappop(maxheap)\n            \n            res[index]=element[1]\n            if len(maxheap)==0:\n                break\n            index+=1\n            \n            element2=heappop(maxheap)\n            \n            res[index]= element2[1]\n            \n            self.updateMap(map1,maxheap,element)\n            self.updateMap(map1,maxheap,element2)\n            \n            index+=1\n        return res\n    def updateMap(self,map1,maxheap,element):\n        if map1[element[1]]==1:\n            del map1[element[1]]\n        else:\n            map1[element[1]]=map1[element[1]]-1\n\n            heappush(maxheap,(-map1[element[1]],element[1]))\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        count=Counter(barcodes)\n        heap=[(-count[x],x) for x in list(count.keys())]\n        heapq.heapify(heap)\n        out=[]\n        while len(heap)>1:\n            count1, code1=heapq.heappop(heap)\n            count2, code2=heapq.heappop(heap)\n            out.extend([code1,code2])\n            count1+=1\n            count2+=1\n            if count1<0: heapq.heappush(heap, (count1,code1))\n            if count2<0: heapq.heappush(heap, (count2,code2))\n        if heap:\n            count1,code1=heapq.heappop(heap)\n            out+=[code1]\n        return out\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        cnts = collections.Counter(barcodes)\n        heap = [(-v, k) for k,v in list(cnts.items())]\n        heapq.heapify(heap)\n        res = []\n        \n        while heap:\n            cnt1, num1 = heapq.heappop(heap)\n            if res and res[-1] == num1:\n                cnt, num = heapq.heappop(heap)\n                res.append(num)\n                cnt += 1\n                if cnt != 0:\n                    heapq.heappush(heap, (cnt, num))\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n            else:\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n            \n        return res\n    \n# Run time O(NlogN), space O(N)\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        d = defaultdict(lambda:0)\n        for b in barcodes:\n            d[b] += 1\n        \n        #heap = [(d[b],b) for b in barcodes]\n        counter = 0\n        heap = []\n        for b in d:\n            heap.append((-d[b],counter,b))\n            counter += 1\n        heapify(heap)\n        result = []\n        while heap:\n            count1,tmp,b1 = heappop(heap)\n            result.append(b1)\n            if not heap:\n                return result\n            \n            count2,tmp,b2 = heappop(heap)\n            result.append(b2)\n            \n            count1 += 1\n            count2 += 1\n            \n            if count1:\n                heappush(heap, (count1,counter,b1))\n                counter += 1\n            if count2:\n                heappush(heap, (count2,counter,b2))\n                counter += 1\n        return result", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = dict()\n        \n        for i in range(len(barcodes)):\n            freq[barcodes[i]] = freq.get(barcodes[i], 0)+1\n        \n        heap = list()\n        reverse = collections.defaultdict(list)\n        \n        for el in freq:\n            heap.append(-freq[el])\n            reverse[freq[el]].append(el)\n        \n        heapq.heapify(heap)\n        \n        temp_list = list()\n        answer = list()\n        \n        while True:\n            if len(temp_list)>1:\n                temp = temp_list.pop(0)\n                if temp[0]>0:\n                    heapq.heappush(heap, -temp[0])\n                    reverse[temp[0]].append(temp[1])\n            \n            if len(heap)>0:\n                cur_freq = -heapq.heappop(heap)\n                cur_el = reverse[cur_freq].pop(0)\n                answer.append(cur_el)\n                temp_list.append([cur_freq-1, cur_el])\n            else:\n                break\n            \n        while len(temp_list)>0:\n            temp = temp_list.pop(0)\n            if temp[0]>0:\n                answer.append(temp[1])\n                \n        return answer\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n\n        count = collections.Counter(barcodes)\n        \n        ans = [0] * len(barcodes)\n        \n        index = 0\n        for key, freq in count.most_common():\n            \n            for _ in range(freq):\n                if index >= len(barcodes):\n                    index = 1\n                ans[index] = key\n                index += 2\n                \n        return ans\n                \n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        import heapq\n        from collections import defaultdict\n        \n        d = defaultdict(int)\n        \n        for i in barcodes:\n            d[i] += 1\n        h = []\n        for i in d:\n            h.append((-d[i], i))\n        heapq.heapify(h)\n        ans = []\n        \n        while(len(h) > 1):\n            c1, val1 = heapq.heappop(h)\n            c2, val2 = heapq.heappop(h)\n            \n            c1 += 1\n            c2 += 1\n            \n            ans.append(val1)\n            ans.append(val2)\n            \n            if c1:\n                heapq.heappush(h, (c1, val1))\n            if c2:\n                heapq.heappush(h, (c2, val2))\n                \n        if h:\n            ans.append(heapq.heappop(h)[1])\n        \n        return ans\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        c = Counter(barcodes)\n        heap = []\n        ans = []\n        for k, v in c.items():\n            heapq.heappush(heap, (-v, k))\n        while heap:\n            # print(heap)\n            most, d1 = heapq.heappop(heap)\n            if ans and ans[-1]==d1:\n                more, d2 = heapq.heappop(heap)\n                ans.append(d2)\n                if more < -1:\n                    heapq.heappush(heap, (more+1, d2))\n                heapq.heappush(heap, (most, d1))\n                continue\n            ans.append(d1)\n            if most < -1:\n                heapq.heappush(heap, (most+1, d1))\n        # print('done')\n        return ans", "import collections\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        dic={}\n        lst=[0]*len(barcodes)\n        for i in barcodes:\n            if(i in dic):\n                dic[i]+=1\n            else:\n                dic[i]=1\n        sorted_x = sorted(dic.items(), key=lambda kv: kv[1],reverse=True)\n        sorted_dict = collections.OrderedDict(sorted_x)\n        var=0\n        for i,j in sorted_dict.items():\n            for _ in range(j):\n                lst[var]=i\n                var+=2\n                if(var>=len(barcodes)):\n                    var=1\n        return(lst)", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if not barcodes:\n            return []\n        res = [None] * len(barcodes)\n        barCount = collections.defaultdict(int)\n        for barcode in barcodes:\n            barCount[barcode] += 1\n        mostFreq = max(barCount, key = barCount.get)\n        i = 0\n        for _ in range(barCount[mostFreq]):\n            res[i] = mostFreq\n            i += 2\n        if i >= len(barcodes):\n            i = 1\n        barSet = set(barcodes)\n        barSet.remove(mostFreq)\n        for key in barSet:\n            if key == mostFreq:\n                continue\n            for _ in range(barCount[key]):\n                res[i] = key\n                i += 2\n                if i >= len(barcodes):\n                    i = 1\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        cnts = collections.defaultdict(int)\n        for n in barcodes:\n            cnts[n] += 1\n        barcodes.sort(key = lambda x : (cnts[x], x))\n        n = len(barcodes)\n        first, second = barcodes[:n//2], barcodes[n//2:]\n        res = []\n        f, s = 0, 0\n        while f < len(first) or s < len(second):\n            if s < len(second):\n                res.append(second[s])\n                s += 1\n            if f < len(first):\n                res.append(first[f])\n                f += 1\n        return res\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter = Counter(barcodes)\n        keys = sorted(list(counter.keys()), key = lambda k:counter[k], reverse=True)\n        numbers = []\n        for key in keys:\n            numbers.extend([key]*counter[key])\n        ans = [0]*len(numbers)\n        N = len(numbers)\n        ans[::2] = numbers[:(N+1)//2]\n        ans[1::2] = numbers[(N+1)//2:]\n        return ans\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        cnt = Counter(barcodes)\n        M = 0\n        \n        for k, v in cnt.items():\n            if v>M:\n                mark = k\n                M = v\n        \n        barcodes.sort()\n        pos = defaultdict(list)\n        j = 0\n        \n        for i in range(len(barcodes)):\n            if barcodes[i]!=mark:\n                pos[j].append(barcodes[i])\n                j = (j+1)%M\n        \n        ans = []\n        \n        for i in range(M):\n            ans += [mark]+pos[i]\n        \n        return ans", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        count = Counter(barcodes)\n        pq = []\n        for c in count:\n            heappush(pq, [-count[c],c])\n        # print(pq)\n        output = []\n        prev = None\n        \n        while pq:\n            \n            # if output and output[-1] == pq[0]:\n            #     toPush = heappop(pq)\n                \n            c, v = heappop(pq)\n            c += 1\n            output.append(v)\n            \n            if prev:\n                heappush(pq, prev)\n                prev = None\n            \n            if c != 0:\n                prev = [c, v]\n        \n        return output\n", "class Solution:\n    def rearrangeBarcodes(self, a: List[int]) -> List[int]:\n        count = collections.Counter(a)\n        a.sort(key=lambda x: (count[x], x))\n        a[1::2], a[::2] = a[:len(a)//2], a[len(a)//2:]\n        return a", "class Solution:\n    def rearrangeBarcodes(self, A: List[int]) -> List[int]:\n        count = collections.Counter(A)\n        A.sort(key=lambda a: (count[a], a))\n        A[1::2], A[::2] = A[0:len(A) // 2], A[len(A) // 2:]\n        return A\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        counter = collections.Counter(barcodes)\n        \n        pq = []\n        \n        for key,value in counter.items():\n            heapq.heappush(pq,(-value,key))\n        \n        temp_list = []\n            \n        result = []\n        \n        while pq:\n            \n            k = 2\n        \n            while pq and k > 0:\n                \n                #print(pq)\n                \n                count, curr = heapq.heappop(pq)\n                count = count * -1\n                \n                result.append(curr)\n                \n                if count > 1:\n                    temp_list.append((count-1,curr))\n            \n                k -= 1\n            \n            if len(temp_list) == 0 and len(pq) == 0:\n                break\n            \n            while temp_list:\n                \n                count, curr = temp_list.pop()\n                \n                heapq.heappush(pq,(-count,curr))\n            \n        return result", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counter_dict = collections.Counter(barcodes)\n        kk_heap = []\n        for it in list(counter_dict.items()):\n            heapq.heappush(kk_heap, [-it[1], it[0]])\n                    \n        last_kk = None\n        res = []\n        \n        while kk_heap:\n            if len(kk_heap) == 1:\n                res.append(kk_heap[0][1])\n                break\n                \n            choose_from = [heapq.heappop(kk_heap), heapq.heappop(kk_heap)]\n            idx = 0 if last_kk != choose_from[0][1] else 1\n            kk = choose_from[idx][1]\n            \n            res.append(kk)\n            choose_from[idx][0] += 1\n            for cf in choose_from:\n                if cf[0]:\n                    heapq.heappush(kk_heap, cf)\n            last_kk = kk\n            \n        return res\n        \n", "class Solution:\n    def rearrangeBarcodes(self, S: List[int]) -> List[int]:\n        if not S:\n            return []\n        \n        d = collections.Counter(S)\n        heap = []\n        for key,value in list(d.items()):\n            heapq.heappush(heap,[-value,key])\n            \n        res = []\n        pre = heapq.heappop(heap)\n        res.append(pre[1])\n        \n        while heap:\n            cur = heapq.heappop(heap)\n            res.append(cur[1])\n            \n            pre[0] += 1\n            if pre[0] < 0:\n                heapq.heappush(heap,pre)\n                \n            pre = cur\n            \n        if len(res) != len(S):\n            return []\n        else:\n            return res\n            \n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        cnts = collections.Counter(barcodes)\n        heap = [(-v, k) for k,v in list(cnts.items())]\n        heapq.heapify(heap)\n        res = []\n        \n        while heap:\n            cnt1, num1 = heapq.heappop(heap)\n            if res and res[-1] == num1:\n                cnt, num = heapq.heappop(heap)\n                res.append(num)\n                cnt += 1\n                if cnt != 0:\n                    heapq.heappush(heap, (cnt, num))\n                heapq.heappush(heap, (cnt1, num1))\n            else:\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n            \n        return res\n    \n# Run time O(NlogN), space O(N)\n", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        cnts = collections.Counter(barcodes)\n        heap = [(-v, k) for k,v in cnts.items()]\n        heapq.heapify(heap)\n        res = []\n        \n        while heap:\n            cnt1, num1 = heapq.heappop(heap)\n            if res and res[-1] == num1:\n                cnt, num = heapq.heappop(heap)\n                res.append(num)\n                cnt += 1\n                if cnt != 0:\n                    heapq.heappush(heap, (cnt, num))\n                heapq.heappush(heap, (cnt1, num1))\n            else:\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n            \n        return res", "from collections import Counter\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        counts = Counter(barcodes)\n        n = len(barcodes)\n        res = [0] * n\n        i = 0\n        for k,v in counts.most_common():\n            while v>0:\n                res[i] = k\n                i += 2\n                v -= 1\n                if i>n-1:\n                    i = 1\n        return res\n", "from collections import Counter\nimport itertools\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        barcodes = [(freq, k) for k, freq in Counter(barcodes).items()]\n        barcodes.sort(reverse=True)\n        barcodes = list(itertools.chain.from_iterable([[k]*f for f, k in barcodes]))\n        res=[\\\"\\\"]*len(barcodes)\n        i = 0\n        j = 0\n        while j < len(barcodes):\n            res[i] = barcodes[j]\n            i=i+2\n            j=j+1\n            if i > len(res)-1:\n                i=1\n        return res\n        \n        ", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        import collections\n        import heapq\n        \n        c_dic = collections.Counter(barcodes)\n        hp = []\n        for key in c_dic:\n            heapq.heappush(hp, (-c_dic[key],key))\n            \n        res = []\n        while hp:\n            collect = []\n            if res:\n                while hp[0][1] == res[-1]:\n                    cur = heapq.heappop(hp)\n                    collect.append(cur)\n            \n            cur = heapq.heappop(hp)   \n            res.append(cur[1])\n            if cur[0] != -1:\n                heapq.heappush(hp, (cur[0]+1, cur[1]))\n                \n            for nodes in collect:\n                heapq.heappush(hp, nodes)\n                \n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        c=collections.Counter(barcodes)\n        heap=[]\n        for cha,time in c.items():\n            heapq.heappush(heap,(-time,cha))  \n        res=[]\n        while heap:\n            n=len(heap)\n            if n>=2:\n                t1,c1=heapq.heappop(heap)\n                res.append(c1)\n                t2,c2=heapq.heappop(heap)\n                res.append(c2)\n                if t1+1<0:\n                    heapq.heappush(heap,(t1+1,c1))\n                if t2+1<0:\n                    heapq.heappush(heap,(t2+1,c2))\n            else:\n                t,c=heapq.heappop(heap)\n                res.append(c)\n        return res", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        cb = collections.Counter(barcodes)\n        for kk,l in cb.most_common():\n            out = [[kk] for _ in range(l)]\n            break\n        i = 0\n        for k in cb:\n            if k != kk:\n                for v in range(cb[k]):\n                    out[i%l].append(k)\n                    i += 1\n        output = []\n        for o in out:\n            output += o\n        return output", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if len(barcodes) <= 1:\n            return barcodes\n        \n        heap, res = [], []\n        counter = collections.Counter(barcodes)\n        for val, cnt in counter.items():\n            heapq.heappush(heap, (-cnt, val))\n        \n        res = []\n        while len(heap) > 1:\n            cnt1, val1 = heapq.heappop(heap)\n            cnt2, val2 = heapq.heappop(heap)\n            res.extend([val1, val2])\n            cnt1 += 1\n            cnt2 += 1\n            if cnt1: heapq.heappush(heap, (cnt1, val1))\n            if cnt2: heapq.heappush(heap, (cnt2, val2))\n        \n        if heap:\n            res.append(heap[0][1])\n        return res ", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        freq = collections.Counter(barcodes)\n        heap = []\n        for k, v in freq.items():\n            heapq.heappush(heap, (-v, k))\n        ans = []\n        while heap:\n            freq, num = heapq.heappop(heap)\n            if not ans:\n                ans.append(num)\n                freq += 1\n                if freq < 0:\n                    heapq.heappush(heap, (freq, num))\n            else:\n                if num == ans[-1]:\n                    nextFreq, nextNum = heapq.heappop(heap)\n                    ans.append(nextNum)\n                    nextFreq += 1\n                    if nextFreq < 0:\n                        heapq.heappush(heap, (nextFreq, nextNum))\n                    heapq.heappush(heap, (freq, num))\n                else:\n                    ans.append(num)\n                    freq += 1\n                    if freq < 0:\n                        heapq.heappush(heap, (freq, num))\n        return ans", "from collections import Counter\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if barcodes is None or len(barcodes) == 0:\n            return []\n        if len(barcodes) == 1:\n            return barcodes\n\n        counter = Counter(barcodes)\n        num_occurrences = sorted(counter, key = lambda x: counter.get(x), reverse=True)\n        elements = dict()\n\n        for elem in num_occurrences:\n            elements[elem] = counter[elem]\n\n        output = [None] * len(barcodes)\n        item_index = 0\n        index = 0\n        value = num_occurrences[0]\n        value_index= 0\n        for i in range(len(barcodes)):\n            while output[index] is not None or output[index - 1] == value:\n                index += 1\n                index %= len(barcodes)\n            output[index] = value\n            item_index += 1\n            index += 1\n            index %= len(barcodes)\n            if elements[value] == 1:\n                value_index += 1\n                if value_index >= len(num_occurrences):\n                    return output\n                value = num_occurrences[value_index]\n            else:\n                elements[value] -= 1\n\n        return output", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \n        # Get the counts of all of our barcode elements.\n        cnts = collections.Counter(barcodes)\n\\t\\t# Put the -'ve counts along with themselves into a min heap.\n\\t\\t# For those new to this we use -'ve because this is a min heap, so largest cnt pop'd first.\n        heap = [(-v, k) for k,v in cnts.items()]\n        heapq.heapify(heap)\n        res = []\n        # While we have elements on our heap.\n        while heap:\n\\t\\t    # pop the top element.\n            cnt1, num1 = heapq.heappop(heap)\n\\t\\t\\t# If the top element was the last we used, we need something different.\n            if res and res[-1] == num1:\n\\t\\t\\t    # pop the next highest cnt element. \n                cnt, num = heapq.heappop(heap)\n                res.append(num)\n                cnt += 1\n\\t\\t\\t\\t# If there's still elements left we put them back on the heap.\n                if cnt != 0:\n                    heapq.heappush(heap, (cnt, num))\n\\t\\t\\t\\t# We can also add the first that we popped, and push it back on the heap as well.\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n\\t\\t\\t# else we just add the highest cnt element and put the remaining back on.\n            else:\n                res.append(num1)\n                cnt1 += 1\n                if cnt1 != 0:\n                    heapq.heappush(heap, (cnt1, num1))\n            \n        return res\n    \n# Run time O(NlogN), space O(N)", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if barcodes is None or len(barcodes) ==0:\n            return []\n        \n        n = len(barcodes)\n        dict_t ={}\n        \n        for i in range(n):\n            temp = barcodes[i]\n            dict_t[temp] = dict_t.get(temp, 0)+1 \n            \n        hp =[]\n        \n        for key, value in dict_t.items():\n            heapq.heappush(hp, (-value, key))\n        \n        result =[]\n        \n        count1 = 0 \n        count2 = 0 \n        while hp:\n            count1, key1 = heapq.heappop(hp)\n            if hp:\n                count2, key2 = heapq.heappop(hp)\n            \n            if count1 < 0 and count2 < 0:\n                result.append(key1)\n                result.append(key2)\n                count1 += 1 \n                count2 += 1\n            elif count1 <0 and count2 ==0:\n                result.append(key1)\n                count1 +=1 \n                \n            if count1 <0:\n                heapq.heappush(hp, (count1, key1))\n            if count2 <0:\n                heapq.heappush(hp, (count2, key2))\n        \n        return result", "class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        # Construct max heap\n        \n        hash_map = dict()\n        heap = list()\n        result = [0] * len(barcodes)\n        index = 0\n        \n        for bar_code in barcodes:\n            hash_map[bar_code] = hash_map.get(bar_code,0)+1\n        \n        # {1 : 3, 2 : 3}\n        print(hash_map)\n        for code,freq in hash_map.items():\n            heap.append((-freq, code))\n        \n        heapq.heapify(heap)\n        \n        while heap:\n            freq, code = heapq.heappop(heap)\n            freq = abs(freq)\n            while freq > 0:\n                if index >= len(barcodes):\n                    index = 1\n                result[index] = code\n                index += 2\n                freq -= 1\n        return result"]
["from collections import deque\n\nN, M = list(map(int, input().split()))\nadj = [[1 for _ in range(N + 1)] for _ in range(N + 1)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    adj[a][b] = 0\n    adj[b][a] = 0\nadj_inv = [[] for _ in range(N + 1)]\nfor i in range(1, N+1):\n    for j in range(i+1, N+1):\n        if adj[i][j] == 1:\n            adj_inv[i].append(j)\n            adj_inv[j].append(i)\n\nseen = [0] * (N+1)\nnum = []\nfor i in range(1, N+1):\n    if seen[i] == 0:\n        plus = 0\n        minus = 0\n        que = deque()\n        que.append(i)\n        seen[i] = 1\n        plus += 1\n        while que:\n            v = que.pop()\n            u_list = adj_inv[v]\n            for u in u_list:\n                if seen[u] == 0:\n                    que.append(u)\n                    seen[u] = -seen[v]\n                    if seen[u] == 1:\n                        plus += 1\n                    else:\n                        minus += 1\n                else:\n                    if seen[u] == seen[v]:\n                        print((-1))\n                        return\n        num.append((min(plus, minus), max(plus, minus)))\n\nmin_sum = 0\nadd = []\nfor i in range(len(num)):\n    min_sum += num[i][0]\n    add.append(num[i][1] - num[i][0])\n\ndp = [[0 for _ in range((N // 2) + 1)] for _ in range(len(add) + 1)]\ndp[0][min_sum] = 1\nfor i in range(len(add)):\n    for j in range(min_sum, (N // 2) + 1):\n        if dp[i][j] == 1:\n            if j + add[i] <= (N // 2):\n                dp[i+1][j+add[i]] = 1\n            dp[i+1][j] = 1\n\ndp_last = dp[-1]\nfor i in range(len(dp_last)-1, -1, -1):\n    if dp_last[i] == 1:\n        N1 = i\n        break\n\nprint(((N1 * (N1 - 1)) // 2 + ((N - N1) * (N - N1 - 1)) // 2))\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nclass Graph:\n    def __init__(self, nvert, edges):\n        self.adj = [[False] * nvert for i in range(nvert)]\n        for e in edges:\n            u, v = e\n            self.adj[u][v] = True\n            self.adj[v][u] = True\n\n    def __str__(self):\n        return str(self.adj)\n\n    # \u7bc0\u70b9\u6570\n    def nvertices(self):\n        return len(self.adj)\n\n    # \u88dc\u30b0\u30e9\u30d5\n    def complement(self):\n        nv = len(self.adj)\n        g  = Graph(nv, [])\n        for u in range(nv):\n            for v in range(nv):\n                if u == v: continue\n                g.adj[u][v] = not self.adj[u][v]\n                g.adj[v][u] = not self.adj[v][u]\n        return g\n\n    # \u9023\u7d50\u6210\u5206\u3067\u3042\u308b\u30b0\u30e9\u30d5\u306e\u30ea\u30b9\u30c8\n    def connectedcomps(self):\n        self.visited = [False] * self.nvertices()\n        ccs = []\n        for v in range(self.nvertices()):\n            if not self.visited[v]:\n                vs = []\n                self.__connectedcomp(v, vs)\n                cc = self.inducedsubgraph(vs)\n                ccs.append(cc)\n        self.visited = None\n        return ccs\n\n    # v\u3092\u542b\u3080\u9023\u7d50\u6210\u5206 (\u7bc0\u70b9\u306e\u30ea\u30b9\u30c8)\n    def __connectedcomp(self, v, vs):\n        if self.visited[v]: return\n        self.visited[v] = True\n        vs.append(v)\n        for u in range(self.nvertices()):\n            if self.adj[v][u]:\n                self.__connectedcomp(u, vs)\n\n    # \u8a98\u5c0e\u90e8\u5206\u30b0\u30e9\u30d5\n    def inducedsubgraph(self, vs):\n        n = len(vs)\n        # [3, 1, 4] -> {3:0, 1:1, 4:2}\n        m = {}\n        for i in range(n):\n            m[vs[i]] = i\n\n        sg = Graph(n, [])\n        for v in vs:\n            for u in range(self.nvertices()):\n                if self.adj[v][u]:\n                    sg.adj[m[v]][m[u]] = True\n                    sg.adj[m[u]][m[v]] = True\n        return sg\n\n    # 2\u90e8\u30b0\u30e9\u30d5\u306a\u3089\u30702\u30b0\u30eb\u30fc\u30d7\u306e\u5404\u7bc0\u70b9\u6570\u306e\u7d44\u30022\u90e8\u30b0\u30e9\u30d5\u3067\u306a\u3051\u308c\u3070False\n    # \u7d44\u3092\u8fd4\u3059\u3068\u304d\u306f(\u5927,\u5c0f)\u306e\u9806\n    def isbipartite(self):\n        self.color = [None] * self.nvertices()\n        self.color[0] = 0\n        if not self.__isbipartite(0):\n            return False\n        m = sum(1 for c in self.color if c == 0)\n        n = sum(1 for c in self.color if c == 1)\n        assert m + n == self.nvertices()\n        return (max(m, n), min(m, n))\n\n    def __isbipartite(self, v):\n        for u in range(self.nvertices()):\n            if self.adj[v][u]:\n                if self.color[u] == None:\n                    self.color[u] = 1 - self.color[v]\n                    if not self.__isbipartite(u):\n                        return False\n                elif self.color[u] != 1 - self.color[v]:\n                    return False\n        return True\n\n\n# \u5165\u529b\nN, M = [int(w) for w in input().split()]\nedges = []\nfor i in range(M):\n    a, b = [int(w) for w in input().split()]\n    edges.append((a - 1, b - 1))\n\n# \u5165\u529b\u3055\u308c\u305f\u30b0\u30e9\u30d5\u306e\u88dc\u30b0\u30e9\u30d5 g \u304c2\u90e8\u30b0\u30e9\u30d5\ng = Graph(N, edges).complement()\nccs = g.connectedcomps()\nbs  = [cc.isbipartite() for cc in ccs]\nif not all(bs):\n    print(-1)\n    return\n\n# (\u9023\u7d50\u6210\u5206\u304c\u8907\u6570\u3042\u308b\u5834\u5408),\n# 2\u30b0\u30eb\u30fc\u30d7\u306e\u7bc0\u70b9\u6570\u306e\u5dee\u304c\u6700\u5c0f\u3068\u306a\u308b\u3088\u3046\u306a\u5206\u3051\u65b9\u3092\u6c42\u3081\u308b\ndiffs = [t[0] - t[1] for t in bs]\nsums = {0}\nfor d in diffs:\n    newsums = set()\n    for s in sums:\n        newsums.add(s + d)\n    sums.update(newsums)\n\nhalfdiff = sum(diffs)/2\nnearlyhalfdiff = min((abs(s - halfdiff), s) for s in sums)[1]\n\n# \u7bc0\u70b9\u6570\u306e\u5dee\u3092\u6700\u5c0f\u306b\u3059\u308b\u3068\uff0c\u305d\u306e\u5dee\u306fdiff\u306b\u306a\u308b\ndiff = abs(sum(diffs) - 2 * nearlyhalfdiff)\n\n# \u30b0\u30eb\u30fc\u30d7\u306e\u7bc0\u70b9\u6570 (x, y)\nx = (N - diff) // 2\ny = N - x\n\n# \u5b8c\u5168\u30b0\u30e9\u30d5\u306e\u8fba\u6570\nx = x * (x - 1) // 2\ny = y * (y - 1) // 2\n\nprint(x + y)", "N,M = map(int,input().split())\n\nE = [[False]*N for _ in range(N)]\n\nfor n in range(N):\n  E[n][n] = True\n\nfor _ in range(M):\n  a,b = map(int,input().split())\n  a,b = a-1,b-1\n  E[a][b] = True\n  E[b][a] = True\n\n\nunvisited = set(range(N))\ncolor = [None]*N\ncomponents = []\n\nwhile unvisited:\n  v0 = next(iter(unvisited))\n  count = [0,0]\n\n  stack = [(v0,False)]\n  while stack:\n    v,c = stack.pop()\n    if color[v] is None:\n      color[v] = c\n      unvisited.discard(v)\n      count[c] += 1\n      for u,f in enumerate(E[v]):\n        if not f:\n          stack.append((u, not c))\n\n    elif color[v] != c:\n      print(-1)\n      return\n\n  components.append(count)\n\n# DP\nL = N//2+1\ndp = [False]*L\n\n\ndp[0] = True\n\nfor a,b in components:\n  ndp = [False]*L\n  for i,f in enumerate(dp):\n    if f:\n      if i+a < L:\n        ndp[i+a] = True\n      if i+b < L:\n        ndp[i+b] = True\n  dp = ndp\n\nfor i,f in zip(reversed(range(L)), reversed(dp)):\n  if f:\n    break\nj = N - i\n\nprint(i*(i-1)//2 + j*(j-1)//2)", "import queue\nN,M=list(map(int,input().split()))\nG=[[1 for i in range(N)] for i in range(N)]\nH=[[] for i in range(N)]\nfor i in range(N):\n    G[i][i]-=1\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    G[a-1][b-1]-=1\n    G[b-1][a-1]-=1\nfor i in range(N):\n    for j in range(N):\n        if G[i][j]==1:\n            H[i].append(j)\nA=[[[],[]]]\nk=0\nq=queue.Queue()\nreached=[0 for i in range(N)]\ndist=[-1 for i in range(N)]\nfor i in range(N):\n    if reached[i]==1:\n        continue\n    q.put(i)\n    reached[i]=1\n    dist[i]=0\n    while(not(q.empty())):\n        r=q.get()\n        A[k][dist[r]].append(r)\n        for p in H[r]:\n            if reached[p]==0:\n                q.put(p)\n                dist[p]=(dist[r]+1)%2\n                reached[p]=1\n    k+=1\n    A.append([[],[]])\nfor i in range(k):\n    for j in range(2):\n        for x in A[i][j]:\n            for y in A[i][j]:\n                if x==y:\n                    continue\n                if G[x][y]==1:\n                    print((-1))\n                    return\nB=[]\nfor i in range(k):\n    B.append((len(A[i][0]),len(A[i][1])))\ndp=[[0 for i in range(N+1)] for i in range(k+1)]\ndp[0][0]=1\nfor i in range(1,k+1):\n    for j in range(N+1):\n        if dp[i-1][j]==0:\n            continue\n        dp[i][j+B[i-1][0]]=1\n        dp[i][j+B[i-1][1]]=1\ndelta=N\nfor i in range(N+1):\n    if dp[k][i]==1:\n        tmp=abs(N-2*i)\n        if tmp<delta:\n            delta=tmp\nX=(N+delta)//2\nY=(N-delta)//2\nprint(((X*(X-1)+Y*(Y-1))//2))\n", "N,M=list(map(int,input().split()))\nROAD=[None]*M\n\nfor i in range(M):\n    ROAD[i]=tuple(sorted(list(map(int,input().split()))))\n  \nimport itertools\n\nNOROAD=list(itertools.combinations(list(range(1,N+1)),2))\n\nNOROAD=set(NOROAD) - set(ROAD)\n\nGroup=[[i,[]] for i in range(N+1)]\n\ndef find(x):\n    while Group[x][0] != x:\n        x=Group[x][0]\n    return x\n\n\nfor i in NOROAD:\n    a,b=i\n    #print(a,b)\n    Group[a][1]+=[b]\n    Group[b][1]+=[a]\n\n    if find(a) != find(b):\n        Group[find(a)][0]=min(find(a),find(b))\n        Group[find(b)][0]=min(find(a),find(b))\n        Group[a][0]=min(find(a),find(b))\n        Group[b][0]=min(find(a),find(b))\n\nGroupSORT=[[i,j[1]] for i,j in enumerate(Group)]\nGroupSORT.sort(key=lambda x:len(x[1]))\nNUMBERING=[[find(i),\"none\"] for i in range(N+1)]\nCHECK=[0 for i in range(N+1)]\n\nfor i in range(N):\n    if CHECK[find(GroupSORT[i][0])]==0:\n        \n        NUMBERING[GroupSORT[i][0]][1]=0\n        CHECK[find(GroupSORT[i][0])]=1\n\nCONDITION=1\n#print(NUMBERING)\n\n\nrepeat_condition=1\nwhile repeat_condition==1:\n\n    repeat_condition=0\n\n    for i in range(1,N+1):\n        if NUMBERING[i][1]==0:\n            for j in Group[i][1]:\n                if NUMBERING[j][1]==0:\n                    CONDITION=0\n                    break\n                elif NUMBERING[j][1]==\"none\":\n                    NUMBERING[j][1]=1\n                    repeat_condition=1\n\n        if NUMBERING[i][1]==1:\n            for j in Group[i][1]:\n                if NUMBERING[j][1]==1:\n                    CONDITION=0\n                    break\n                elif NUMBERING[j][1]==\"none\":\n                    NUMBERING[j][1]=0\n                    repeat_condition=1\n\n\nimport sys\nif CONDITION==0:\n    print((-1))\n    return\n\nNUMBERS=set()\nfor i in range(1,len(NUMBERING)):\n    NUMBERS=NUMBERS|{NUMBERING[i][0]}\n\ncount=[]\nfor i in NUMBERS:\n    count+=[(i,NUMBERING.count([i,0]),NUMBERING.count([i,1]))]\n\nDP=[set() for i in range(len(count))]\nDP[0]={count[0][1],count[0][2]}\n\nfor i in range(1,len(count)):\n    for k in DP[i-1]:\n        DP[i]=DP[i]|{k+count[i][1],k+count[i][2]}\n\nDIVIDE=list(DP[len(count)-1])\n#print(DIVIDE)\nfor i in range(len(DIVIDE)):\n    DIVIDE[i]=abs(DIVIDE[i]-N/2)\n\nx=int(min(DIVIDE)+N/2)\n\nprint((x*(x-1)//2+(N-x)*(N-x-1)//2))\n", "# import math\n# n,k = list(map(int,input().split()))\n# print(math.ceil((n-1)/(k-1)))\n\nn,m = list(map(int,input().split()))\nroad = {}\nwhole = []\nfor i in range(1,n+1):\n    whole.append(i)\n    road[i] = set()\nwhole = set(whole)\n\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    road[a].add(b)\n    road[b].add(a)\n\ntaka = []\nhashi = []\nused = set()\nno = 0\nfor x in road:\n    l = set()\n    r = set()\n    l1 = []\n    r1 = []\n    if x in used:\n        continue\n    else:\n        l.add(x)\n        l1.append(x)\n        used.add(x)\n        for y in whole - road[x]:\n            if y not in used:\n                r.add(y)\n                r1.append(y)\n                used.add(y)\n    while l1 != [] or r1 != []:\n        while r1 != []:\n            t = r1.pop()\n            for y in whole-road[t]-used-l:\n                l.add(y)\n                l1.append(y)\n                used.add(y)\n        while l1 != []:\n            t = l1.pop()\n            for y in whole-road[t]-used-r:\n                    r.add(y)\n                    r1.append(y)\n                    used.add(y)\n    r = list(r)\n    l = list(l)\n\n    for i in range(len(l)):\n        for j in range(i+1,len(l)):\n            if l[j] not in road[l[i]]:\n                no = 1\n                break\n        if no == 1:break\n    if no == 1:break\n    for i in range(len(r)):\n        for j in range(i+1,len(r)):\n            if r[j] not in road[r[i]]:\n                no = 1\n                break\n        if no == 1:break\n    if no == 1:break\n\n    taka.append(len(l))\n    hashi.append(len(r))\n\nif no == 1:print((-1))\nelse:\n    res = [abs(taka[i]-hashi[i]) for i in range(len(taka))]\n    res.sort(reverse=-1)\n    delta = 0\n    for x in res:\n        if delta>0:delta-=x\n        else:delta+=x\n    left = (n+delta)/2\n    right = (n-delta)/2\n    result = int((left*(left-1)+right*(right-1))/2)\n    print(result)\n\n\n", "import sys\nsys.setrecursionlimit(10**7)\nn,m = map(int,input().split())\nG = [[1]*n for i in range(n)]\nfor i in range(m):\n  a,b = map(int,input().split())\n  a -=1;b-=1\n  G[a][b] = G[b][a] = 0\ncolors = [-1 for i in range(n)]\npossible = True\nni = []\ndef dfs(x,y):\n  colors[x] = y\n  k[y] += 1\n  for l in range(n):\n    if l == x or G[x][l] == 0:\n      continue\n    if colors[l] == -1:\n      dfs(l,1-y)\n    elif colors[l] != 1-y:\n      nonlocal possible\n      possible = False\nfor i in range(n):\n  k = [0,0]\n  if colors[i] != -1:\n    continue\n  dfs(i,0)\n  ni.append([k[0],k[1]])\nif possible == False:\n  print(-1)\n  return\ndp =[0]*701\ndp[0] = 1\nfor i in ni:\n  for j in range(700,-1,-1):\n    if dp[j]:\n      dp[j] = 0\n      dp[j+i[0]] = 1\n      dp[j+i[1]] = 1\nans = float(\"inf\")\nfor i in range(0,701):\n  if dp[i]:\n    tmp = (n-i)*(n-i-1)//2 + i*(i-1)//2\n    ans = min(tmp,ans)\nprint(ans)", "# \u554f\u984c\u306e\u8da3\u65e8\uff1a\u3067\u304d\u308b\u3060\u3051\u8fba\u304c\u5c11\u306a\u304f\u306a\u308b\u3088\u3046\u306b2\u3064\u306e\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u5206\u3051\u305f\u3044\n# \u307e\u305a\u30012\u3064\u306e\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u5206\u3051\u3089\u308c\u308b\u306e\u304b\u3092\u8abf\u3079\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n# \u3053\u308c\u304c\u4e0d\u53ef\u80fd\u3067\u3042\u308c\u3070-1\u3092\u51fa\u529b\u3057\u3066\u5373\u5ea7\u306b\u7d42\u4e86\u3002\n# \u5206\u3051\u3089\u308c\u308b\u5834\u5408\u306f\u3001\u3067\u304d\u308b\u3060\u3051\u8857\u306e\u6570\u3092\u5747\u7b49\u306b\u3057\u305f\u3044\u3002\n\n# \u4ee5\u4e0b\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8003\u3048\u308b\u3002\n# \u307e\u305a\u304a\u4e92\u3044\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306e\u7d44A,B\u3092\u9078\u3076\u3002\n# \u3059\u308b\u3068\u3001A\u306b\u3057\u304b\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u8857\u3001B\u306b\u3057\u304b\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u8857\u3001\n# \u4e21\u65b9\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u8857\u306e3\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u304b\u308c\u308b\u3002\n# \u6700\u521d\u306e2\u30b0\u30eb\u30fc\u30d7\u306b\u3064\u3044\u3066\u306f\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304f\u3002\n# \u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\u304c\u7a7a\u3067\u306a\u3044\u5834\u5408\u306f\u3001\u3053\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5bfe\u3057\u3066\u307e\u305f\u540c\u69d8\u306e\u51e6\u7406\u3092\u884c\u3046\u3002\n# \u8857\u304c\u306a\u304f\u306a\u308b\u304b\u3001\u4e21\u65b9\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u8857\u306e\u30b0\u30eb\u30fc\u30d7\u304c\n# \u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u306a\u3063\u305f\u6642\u70b9\u3067\u7d42\u4e86\u3002\n\n# \u4e0a\u8a18\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u308a\u3001\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u306e\u5217\u3068\u6700\u5f8c\u306b\u6b8b\u3063\u305f\u8857\u306e\u6570\u304c\u6c42\u3081\u3089\u308c\u308b\u3002\n# \u3053\u308c\u3092\u3082\u3068\u306b\u3001\u52d5\u7684\u8a08\u753b\u6cd5\u3067\u8003\u3048\u3089\u308c\u308b\u8857\u306e\u632f\u308a\u5206\u3051\u65b9\u3092\u5168\u3066\u6d17\u3044\u51fa\u3059\u3002\n# \u6700\u3082\u5747\u7b49\u306b\u8fd1\u304f\u632f\u308a\u5206\u3051\u305f\u5834\u5408\u306b\u3064\u3044\u3066\u3001\u5b8c\u5168\u30b0\u30e9\u30d5\u306e\u8fba\u6570\u3092\u8a08\u7b97\u3057\u3066\n# \u51fa\u529b\u3059\u308c\u3070\u554f\u984c\u304c\u89e3\u3051\u308b\u3002\n\ndef main():\n    from sys import stdin\n    input = stdin.readline\n    n, m = list(map(int, input().split()))\n    ab = [list(map(int, input().split())) for _ in [0]*m]\n\n    rest = n  # \u6b8b\u308a\u306e\u8fba\n    g = [set() for _ in [0]*n]\n    [g[a-1].add(b-1) for a, b in ab]\n    [g[b-1].add(a-1) for a, b in ab]\n    s = set([i for i in range(n)])\n\n    a_list, b_list = [], []\n    while True:\n        if m == rest*(rest-1)//2:\n            break\n        a = [-1, 10**10]\n        for i in s:\n            length = len(g[i])\n            if length < a[1]:\n                a = [i, length]\n        a = a[0]\n        b = [-1, 10**10]\n        for i in s-g[a]-{a}:\n            length = len(g[i])\n            if length < b[1]:\n                b = [i, length]\n        b = b[0]\n        a_set, b_set = {a}, {b}\n        s.remove(a)\n        s.remove(b)\n        rest -= 2\n        remain = set()  # \u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\n        for i in s:\n            flag_a = True\n            for j in a_set:\n                if j not in g[i]:\n                    flag_a = False\n                else:\n                    g[i].remove(j)\n                    g[j].remove(i)\n                    m -= 1\n            flag_b = True\n            for j in b_set:\n                if j not in g[i]:\n                    flag_b = False\n                else:\n                    g[i].remove(j)\n                    g[j].remove(i)\n                    m -= 1\n            if flag_a+flag_b == 0:\n                print((-1))\n                return\n            elif flag_a*flag_b == 0:\n                q = {i}\n                flag = flag_a  # True\u2192A\u3001False\u2192B\n                while q:\n                    qq = set()\n                    while q:\n                        i = q.pop()\n                        if flag:\n                            a_set.add(i)\n                        else:\n                            b_set.add(i)\n                        for j in remain:\n                            if j not in g[i]:\n                                qq.add(j)\n                            else:\n                                g[i].remove(j)\n                                g[j].remove(i)\n                                m -= 1\n                        for j in q:\n                            g[i].remove(j)\n                            g[j].remove(i)\n                            m -= 1\n                    for i in qq:\n                        remain.remove(i)\n                    flag ^= True\n                    q = qq\n            else:\n                remain.add(i)\n        for i in (a_set | b_set)-{a}-{b}:\n            s.remove(i)\n            rest -= 1\n\n        a_list.append(len(a_set))\n        b_list.append(len(b_set))\n\n    k = len(a_list)\n    dp = [False]*(n+1)\n    dp[0] = True\n\n    for i in range(k):\n        a, b = a_list[i], b_list[i]\n        dp2 = [False]*(n+1)\n        for j in range(n-max(a, b)+1):\n            dp2[j+a] |= dp[j]\n            dp2[j+b] |= dp[j]\n        dp = dp2\n\n    ans = 10**10\n    for j in range(rest+1):\n        for i in range(n-j+1):\n            if dp[i]:\n                p = i+j\n                q = n-p\n                ans = min(ans, p*(p-1)//2+q*(q-1)//2)\n\n    print(ans)\n\n\nmain()\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m = LI()\n    a = [LI_() for _ in range(m)]\n    ss = [set() for _ in range(n)]\n    for b,c in a:\n        ss[b].add(c)\n        ss[c].add(b)\n    ts = [set(list(range(n))) - set([_]) for _ in range(n)]\n    for i in range(n):\n        ts[i] -= ss[i]\n\n    d = []\n    u = set()\n    for i in range(n):\n        if i in u:\n            continue\n        ab = set([i])\n        nb = set([i])\n        ac = set()\n        nc = set()\n        f = True\n        while f:\n            f = False\n            k = set()\n            nc = set()\n            for j in nb:\n                nc |= ts[j]\n            nc -= ac\n            ac |= nc\n            nb = set()\n            for j in nc:\n                nb |= ts[j]\n            nb -= ab\n            ab |= nb\n            if nb:\n                f = True\n        if ab & ac:\n            return -1\n        d.append((len(ab),len(ac)))\n        u |= ab\n        u |= ac\n    r = set([0])\n    for b,c in d:\n        t = set()\n        for k in r:\n            t.add(k+b)\n            t.add(k+c)\n        r = t\n    rr = inf\n    for t in r:\n        nt = n - t\n        if t == 0 or nt == 0:\n            continue\n        tr = t * (t-1) // 2\n        tr += nt * (nt-1) // 2\n        if rr > tr:\n            rr = tr\n    return rr\n\n\nprint(main())\n\n", "from collections import deque\nN, M = map(int, input().split())\nG0 = [set([i]) for i in range(N)]\n\nA = set(range(N))\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    G0[a-1].add(b-1)\n    G0[b-1].add(a-1)\n\nG = [A - g for g in G0]\n\nb = 1\nc = [-1]*N\nfor i in range(N):\n    if c[i] != -1:\n        continue\n    p = 0; s = 0\n    que = deque([i])\n    c[i] = 0\n    while que:\n        v = que.popleft()\n        s += 1\n        if c[v] == 0:\n            p += 1\n        for w in G[v]:\n            if c[w] == -1:\n                c[w] = c[v]^1\n                que.append(w)\n            elif c[w] == c[v]:\n                print(-1)\n                return\n    b = (b << p) | (b << (s-p))\n\nans = 10**18\nfor i in range(N+1):\n    if (b >> i) & 1:\n        ans = min(ans, i*(i-1)//2 + (N-i)*(N-i-1)//2)\nprint(ans)", "from collections import Counter\nimport numpy as np\n\nclass DisjointSet:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0]*size\n    \n    def find(self, x):\n        stack = []\n        parent = self.parent\n        while parent[x] != x:\n            stack.append(x)\n            x = parent[x]\n        for y in stack:\n            parent[y] = x\n        return x\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        \n        if self.rank[xr] > self.rank[yr]:\n            self.parent[yr] = xr\n        elif self.rank[xr] < self.rank[yr]:\n            self.parent[xr] = yr\n        elif xr != yr:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n\ndef check_bipartiteness(n_vertices, edges):\n    ds = DisjointSet(2*n_vertices)\n\n    for a,b in edges:\n        ds.union(a, b+n_vertices)\n        ds.union(b, a+n_vertices)\n    \n    next_color = 0\n    color = [-1]*(2*n_vertices)\n    for v in range(n_vertices):\n        ra = ds.find(v)\n        rb = ds.find(v+n_vertices)\n        if ra == rb:\n            return None\n        if color[ra] < 0:\n            color[ra] = next_color\n            color[rb] = next_color+1\n            next_color += 2\n        color[v] = color[ra]\n        color[v+n_vertices] = color[rb]\n    return color[:n_vertices]\n\n\n\nn,m = list(map(int,input().split()))\n\nmat = [[True]*t for t in range(n)]\n\nfor _ in range(m):\n    a,b = list(map(int,input().split()))\n    if a < b:\n        a,b = b,a\n    mat[a-1][b-1] = False\n\nedges = ((a,b) for a in range(n) for b in range(a) if mat[a][b])\n\ncolors = check_bipartiteness(n, edges)\nif colors is None:\n    print((-1))\n    return\n\ncnt = Counter(colors)\ndp = np.zeros(n,dtype=bool)\ndp[0] = True\n\nfor i in range(n):\n    a,b = cnt[i*2],cnt[i*2+1]\n    if a == 0 and b == 0:\n        break\n    d = abs(a-b)\n    if d == 0:\n        continue\n    ndp = np.zeros(n,dtype=bool)\n    ndp[d:] = dp[:-d]\n    ndp[:-d] |= dp[d:]\n    ndp[:d] |= dp[d-1::-1]\n    dp = ndp\nx = list(dp).index(True)\n\na = (n-x)//2\nb = n-a\n\nprint((a*(a-1)//2 + b*(b-1)//2))\n", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\ngraph1 = [[False]*N for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph1[a-1][b-1] = True\n    graph1[b-1][a-1] = True\n\ngraph = [[] for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if i!=j and not graph1[i][j]:\n            graph[i].append(j)\n\n\nchecked = [-1]*N\nColor = [None]*N\n\ndef bfs(start):\n    q = [start]\n    checked[start] = start\n    Color[start] = 0\n    color = 0\n    Cs = [1, 0]\n    while q:\n        qq = []\n        color ^= 1\n        for p in q:\n            for np in graph[p]:\n                if checked[np] == -1:\n                    checked[np] = start\n                    Color[np] = color\n                    qq.append(np)\n                    Cs[color] += 1\n                elif checked[np] == start and color != Color[np]:\n                    return [-1, -1]\n        q = qq\n    return Cs\n\ndef main():\n    Dif = []\n    for i in range(N):\n        if checked[i] == -1:\n            a, b = bfs(i)\n            if a == -1:\n                print(-1)\n                return\n            Dif.append(abs(a-b))\n    dp = [False]*(N+1)\n    dp[0] = True\n    for d in Dif:\n        for j in reversed(range(d, N+1)):\n            dp[j] = dp[j] or dp[j-d]\n\n    min_dif = 10**15\n    S = sum(Dif)\n    for j in range(N+1):\n        if dp[j]:\n            min_dif = min(min_dif, abs(S-j*2))\n    \n    t1 = (N+min_dif)//2\n    t2 = (N-min_dif)//2\n    print(t1*(t1-1)//2 + t2*(t2-1)//2)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom itertools import combinations\nn,m = map(int,input().split())\nab = [list(map(int,input().split())) for i in range(m)]\ng2d = [[1 for i in range(n+1)] for j in range(n+1)]\nfor i in range(1,n+1):\n  g2d[i][i] = 0\nfor a,b in ab:\n  g2d[a][b] = 0\n  g2d[b][a] = 0\ngraph = [[] for i in range(n+1)]\nfor i in range(1,n+1):\n  for j in range(1,n+1):\n    if g2d[i][j]:\n      graph[i].append(j)\n      graph[j].append(i)\nvis = [-1]*(n+1)\noddeven = []\nfor i in range(1,n+1):\n  if vis[i] == -1:\n    stack = [i]\n    vis[i] = 0\n    odd = 0\n    even = 1\n    while stack:\n      x = stack.pop()\n      for y in graph[x]:\n        if vis[y] == -1:\n          vis[y] = vis[x]+1\n          if vis[y]%2:\n            odd += 1\n          else:\n            even += 1\n          stack.append(y)\n        elif (vis[y]-vis[x])%2 == 0:\n          print(-1)\n          return\n    oddeven.append(abs(odd-even))\nt = len(oddeven)\ns = sum(oddeven)\ndp = 1<<s\nfor x in oddeven:\n  dp = (dp<<abs(x)) | (dp>>abs(x))\nfor i in range(s+1):\n  if (dp&1<<(s-i))|(dp&1<<(s+i)):\n    ex = i\n    break\nA,B = (n+ex)//2,(n-ex)//2\nprint(A*(A-1)//2+B*(B-1)//2)", "# \u554f\u984c\u306e\u8da3\u65e8\uff1a\u3067\u304d\u308b\u3060\u3051\u8fba\u304c\u5c11\u306a\u304f\u306a\u308b\u3088\u3046\u306b2\u3064\u306e\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u5206\u3051\u305f\u3044\n# \u307e\u305a\u30012\u3064\u306e\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u5206\u3051\u3089\u308c\u308b\u306e\u304b\u3092\u8abf\u3079\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n# \u3053\u308c\u304c\u4e0d\u53ef\u80fd\u3067\u3042\u308c\u3070-1\u3092\u51fa\u529b\u3057\u3066\u5373\u5ea7\u306b\u7d42\u4e86\u3002\n# \u5206\u3051\u3089\u308c\u308b\u5834\u5408\u306f\u3001\u3067\u304d\u308b\u3060\u3051\u8857\u306e\u6570\u3092\u5747\u7b49\u306b\u3057\u305f\u3044\u3002\n\n# \u4ee5\u4e0b\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8003\u3048\u308b\u3002\n# \u307e\u305a\u304a\u4e92\u3044\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306e\u7d44A,B\u3092\u9078\u3076\u3002\n# \u3059\u308b\u3068\u3001A\u306b\u3057\u304b\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u8857\u3001B\u306b\u3057\u304b\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u8857\u3001\n# \u4e21\u65b9\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u8857\u306e3\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u304b\u308c\u308b\u3002\n# \u6700\u521d\u306e2\u30b0\u30eb\u30fc\u30d7\u306b\u3064\u3044\u3066\u306f\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304f\u3002\n# \u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\u304c\u7a7a\u3067\u306a\u3044\u5834\u5408\u306f\u3001\u3053\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5bfe\u3057\u3066\u307e\u305f\u540c\u69d8\u306e\u51e6\u7406\u3092\u884c\u3046\u3002\n# \u8857\u304c\u306a\u304f\u306a\u308b\u304b\u3001\u4e21\u65b9\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u8857\u306e\u30b0\u30eb\u30fc\u30d7\u304c\n# \u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u306a\u3063\u305f\u6642\u70b9\u3067\u7d42\u4e86\u3002\n\n# \u4e0a\u8a18\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u308a\u3001\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u306e\u5217\u3068\u6700\u5f8c\u306b\u6b8b\u3063\u305f\u8857\u306e\u6570\u304c\u6c42\u3081\u3089\u308c\u308b\u3002\n# \u3053\u308c\u3092\u3082\u3068\u306b\u3001\u52d5\u7684\u8a08\u753b\u6cd5\u3067\u8003\u3048\u3089\u308c\u308b\u8857\u306e\u632f\u308a\u5206\u3051\u65b9\u3092\u5168\u3066\u6d17\u3044\u51fa\u3059\u3002\n# \u6700\u3082\u5747\u7b49\u306b\u8fd1\u304f\u632f\u308a\u5206\u3051\u305f\u5834\u5408\u306b\u3064\u3044\u3066\u3001\u5b8c\u5168\u30b0\u30e9\u30d5\u306e\u8fba\u6570\u3092\u8a08\u7b97\u3057\u3066\n# \u51fa\u529b\u3059\u308c\u3070\u554f\u984c\u304c\u89e3\u3051\u308b\u3002\n\ndef main():\n    from sys import stdin\n    input = stdin.readline\n    n, m = map(int, input().split())\n    ab = [list(map(int, input().split())) for _ in [0]*m]\n\n    rest = n  # \u6b8b\u308a\u306e\u8fba\n    g = [set() for _ in [0]*n]\n    [g[a-1].add(b-1) for a, b in ab]\n    [g[b-1].add(a-1) for a, b in ab]\n    s = set([i for i in range(n)])\n\n    a_list, b_list = [], []\n    while True:\n        if m == rest*(rest-1)//2:\n            break\n        a = [-1, 10**10]\n        for i in s:\n            length = len(g[i])\n            if length < a[1]:\n                a = [i, length]\n        a = a[0]\n        b = [-1, 10**10]\n        for i in s-g[a]-{a}:\n            length = len(g[i])\n            if length < b[1]:\n                b = [i, length]\n        b = b[0]\n        a_set, b_set = {a}, {b}\n        s.remove(a)\n        s.remove(b)\n        rest -= 2\n        remain = set()  # \u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\n        for i in s:\n            flag_a = True\n            for j in a_set:\n                if j not in g[i]:\n                    flag_a = False\n                else:\n                    g[i].remove(j)\n                    g[j].remove(i)\n                    m -= 1\n            flag_b = True\n            for j in b_set:\n                if j not in g[i]:\n                    flag_b = False\n                else:\n                    g[i].remove(j)\n                    g[j].remove(i)\n                    m -= 1\n            if flag_a+flag_b == 0:\n                print(-1)\n                return\n            elif flag_a*flag_b == 0:\n                q = {i}\n                flag = flag_a  # True\u2192A\u3001False\u2192B\n                while q:\n                    qq = set()\n                    while q:\n                        i = q.pop()\n                        if flag:\n                            a_set.add(i)\n                        else:\n                            b_set.add(i)\n                        for j in remain:\n                            if j not in g[i]:\n                                qq.add(j)\n                            else:\n                                g[i].remove(j)\n                                g[j].remove(i)\n                                m -= 1\n                        for j in q:\n                            g[i].remove(j)\n                            g[j].remove(i)\n                            m -= 1\n                    for i in qq:\n                        remain.remove(i)\n                    flag ^= True\n                    q = qq\n            else:\n                remain.add(i)\n        for i in (a_set | b_set)-{a}-{b}:\n            s.remove(i)\n            rest -= 1\n\n        a_list.append(len(a_set))\n        b_list.append(len(b_set))\n\n    k = len(a_list)\n    dp = [False]*(n+1)\n    dp[0] = True\n\n    for i in range(k):\n        a, b = a_list[i], b_list[i]\n        dp2 = [False]*(n+1)\n        for j in range(n-max(a, b)+1):\n            dp2[j+a] |= dp[j]\n            dp2[j+b] |= dp[j]\n        dp = dp2\n\n    ans = 10**10\n    for j in range(rest+1):\n        for i in range(n-j+1):\n            if dp[i]:\n                p = i+j\n                q = n-p\n                ans = min(ans, p*(p-1)//2+q*(q-1)//2)\n    print(ans)\n\n\nmain()", "import sys\nn, m = list(map(int, input().split()))\nN = 2000\nG = [[0] * N for i in range(N)]\ndp = [[0] * N for i in range(N)]\ncol = [0] * N\ncnt = [0] * 2\nvisit = [0] * N\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a - 1, b - 1\n    G[a][b], G[b][a] = 1, 1\n\n\ndef dfs(u, c):\n    visit[u] = 1\n    col[u] = c\n    cnt[c] += 1\n\n    for v in range(n):\n        if v == u or G[u][v] == 1:\n            continue\n\n        if visit[v] == 1 and col[v] == c:\n            return False\n\n        if not visit[v] and not dfs(v, c ^ 1):\n            return False\n\n    return True\n\n\nnum = 0\ndp[0][0] = 1\nfor i in range(n):\n    if not visit[i]:\n        num += 1\n\n        cnt[0], cnt[1] = 0, 0\n\n        if not dfs(i, 0):\n            print((-1))\n            return\n\n        for j in range(n):\n            for k in range(2):\n                if j >= cnt[k]:\n                    dp[num][j] |= dp[num - 1][j - cnt[k]]\n\nans = m\nfor i in range(n):\n    if dp[num][i]:\n        ans = min(ans, i * (i - 1) // 2 + (n - i) * (n - i - 1) // 2)\n\nprint(ans)\n\n\n", "import queue\nN,M=list(map(int,input().split()))\nG=[[1 for i in range(N)] for i in range(N)]\nH=[[] for i in range(N)]\nfor i in range(N):\n    G[i][i]-=1\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    G[a-1][b-1]-=1\n    G[b-1][a-1]-=1\nfor i in range(N):\n    for j in range(N):\n        if G[i][j]==1:\n            H[i].append(j)\nA=[[[],[]]]\nk=0\nq=queue.Queue()\nreached=[0 for i in range(N)]\ndist=[-1 for i in range(N)]\nfor i in range(N):\n    if reached[i]==1:\n        continue\n    q.put(i)\n    reached[i]=1\n    dist[i]=0\n    while(not(q.empty())):\n        r=q.get()\n        A[k][dist[r]].append(r)\n        for p in H[r]:\n            if reached[p]==0:\n                q.put(p)\n                dist[p]=(dist[r]+1)%2\n                reached[p]=1\n    k+=1\n    A.append([[],[]])\nfor i in range(k):\n    for j in range(2):\n        for x in A[i][j]:\n            for y in A[i][j]:\n                if x==y:\n                    continue\n                if G[x][y]==1:\n                    print((-1))\n                    return\nB=[]\nfor i in range(k):\n    B.append((len(A[i][0]),len(A[i][1])))\ndp=[[0 for i in range(N+1)] for i in range(k+1)]\ndp[0][0]=1\nfor i in range(1,k+1):\n    for j in range(N+1):\n        if dp[i-1][j]==0:\n            continue\n        dp[i][j+B[i-1][0]]=1\n        dp[i][j+B[i-1][1]]=1\ndelta=N\nfor i in range(N+1):\n    if dp[k][i]==1:\n        tmp=abs(N-2*i)\n        if tmp<delta:\n            delta=tmp\nX=(N+delta)//2\nY=(N-delta)//2\nprint(((X*(X-1)+Y*(Y-1))//2))\n", "import sys\nimport math\n\ninput = sys.stdin.readline\nN, M = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\nconnected = [set() for _ in range(N)]\nfor a, b in AB:\n    a -= 1\n    b -= 1\n    connected[a].add(b)\n    connected[b].add(a)\nfor i in range(N):\n    connected[i].add(i)\n\nwhole_set = set(range(N))\nunconnected = [whole_set-connected[i] for i in range(N)]\nassign = [-1] * N\nass_q = []\ng = 0\nfor i in range(N):\n    if len(unconnected[i]) != 0:\n        assign[i] = g\n        for j in unconnected[i]:\n            assign[j] = (assign[i] + 1) % 2 + g\n            ass_q.append(j)\n        break\nwhile len(ass_q) > 0:\n    i = ass_q.pop()\n    for j in unconnected[i]:\n        if assign[j] == -1:\n            assign[j] = (assign[i] + 1) % 2 + g\n            ass_q.append(j)\n        elif assign[j] == assign[i]:\n            print((-1))\n            return\n    if len(ass_q) == 0:\n        g += 2\n        for i in range(N):\n            if len(unconnected[i]) > 0 and assign[i] == -1:\n                assign[i] = g\n                for j in unconnected[i]:\n                    assign[j] = (assign[i] + 1) % 2 + g\n                    ass_q.append(j)\n                break\n\n\ngroups = [(assign.count(g_), assign.count(g_+1)) for g_ in range(0, g, 2)]\nans = math.inf\nnot_assign = assign.count(-1)\nfor b in range(pow(2, len(groups))):\n    taka, hashi = 0, 0\n    for i in range(len(groups)):\n        taka += groups[i][(b>>i)&1]\n        hashi += groups[i][((~b)>>i)&1]\n    for _ in range(not_assign):\n        if taka < hashi:\n            taka += 1\n        else:\n            hashi += 1\n    ans = min(ans, (taka*(taka-1))//2 + (hashi*(hashi-1))//2)\nprint(ans)\n", "# E\nfrom collections import deque\nimport numpy as np\n\nN, M = map(int, input().split())\nG = dict()\nfor i in range(1, N+1):\n    G[i] = dict()\n    for j in range(1, N+1):\n        if i != j:\n            G[i][j] = 1\n            \nfor _ in range(M):\n    a, b = map(int, input().split())\n    _ = G[a].pop(b)\n    _ = G[b].pop(a)\n    \nres_con = []\n\ndone_list = [1] + [0]*N\n\n\n\ncore = 1\n\nwhile core != 0:\n    \n    # BFS\n    queue = deque([core])    \n    res_flag = True\n    \n    size_a = 1\n    size_b = 0\n\n    done_list[core] = 1\n    while len(queue) > 0:\n        a = queue.popleft()\n        for b in G[a].keys():\n            if done_list[b] == done_list[a]:\n                res_flag = False\n                break\n            elif done_list[b] == 0:\n                done_list[b] = -1*done_list[a]\n                if done_list[a] == 1:\n                    size_b += 1\n                else:\n                    size_a += 1\n                queue.append(b)\n    \n    res_con.append([size_a, size_b])\n    \n        \n    if res_flag == False:\n        break\n        \n    \n    core = 0\n    for i in range(1, N+1):\n        if done_list[i] == 0:\n            core = i\n            break\n            \n# summarize\nif res_flag == False:\n    res = 0\nelse:\n    res_can_s = np.array([0])\n    for rr in res_con:\n        a = rr[0]\n        b = rr[1]\n        res_can_s = np.unique(np.concatenate([res_can_s + a, res_can_s + b]))\n    res = ((res_can_s*(res_can_s - 1) // 2) + ((N - res_can_s)*(N - res_can_s - 1) // 2)).min()\n\nif res_flag == False:\n    print(-1)\nelse:\n    print(res)", "import sys\nreadline = sys.stdin.readline\n\npopcntsum = ((1<<1024) - 1)\nFa = [0] + [popcntsum//((1<<(1<<(i-1)))+1) for i in range(1,11)]\nFb = [0] + [Fa[i]<<(1<<(i-1)) for i in range(1,11)]\nfila1 = Fa[1]\nfilb1 = Fb[1]\nfila2 = Fa[2]\nfilb2 = Fb[2]\nfila3 = Fa[3]\nfilb3 = Fb[3]\nfila4 = Fa[4]\nfilb4 = Fb[4]\nfila5 = Fa[5]\nfilb5 = Fb[5]\nfila6 = Fa[6]\nfilb6 = Fb[6]\nfila7 = Fa[7]\nfilb7 = Fb[7]\nfila8 = Fa[8]\nfilb8 = Fb[8]\nfila9 = Fa[9]\nfilb9 = Fb[9]\nfila10 = Fa[10]\nfilb10 = Fb[10]\ndef popcount(x):\n    x = (x&fila1) + ((x&filb1)>>1)\n    x = (x&fila2) + ((x&filb2)>>2)\n    x = (x&fila3) + ((x&filb3)>>4)\n    x = (x&fila4) + ((x&filb4)>>8)\n    x = (x&fila5) + ((x&filb5)>>16)\n    x = (x&fila6) + ((x&filb6)>>32)\n    x = (x&fila7) + ((x&filb7)>>64)\n    x = (x&fila8) + ((x&filb8)>>128)\n    x = (x&fila9) + ((x&filb9)>>256)\n    x = (x&fila10) + ((x&filb10)>>512)\n    return x\n\n\ndef check(S):\n    if S == 0:\n        return []\n    if S < 0:\n        return None\n    G1 = [G[i]&S for i in range(N)]\n    M = popcount(S)\n    if M**2 == sum(G1[i] for i in range(N) if S&(1<<i)):\n        return [(0, 1)]*M\n    st = 0\n    A = 0\n    for i in range(N):\n        if (1<<i) & S:\n            st = i\n            A = 1<<i\n            break\n    B = 0\n    for i in range(N):\n        if not (1<<i) & S:\n            continue\n        if not (G[st] & (1<<i)):\n            B = 1<<i\n            break\n    T = (((1<<N)-1)^S)|A|B\n    na = 1\n    nb = popcount(B)\n    T2 = None\n    while T2 != T:\n        T2 = T\n        for i in range(N):\n            if (1<<i) & T:\n                continue\n            fa = (na == popcount(G1[i]&A))\n            fb = (nb == popcount(G1[i]&B))\n            if fa and fb:\n                continue\n            if fa:\n                A |= 1<<i\n                T |= 1<<i\n                na += 1\n                continue\n            if fb:\n                B |= 1<<i\n                T |= 1<<i\n                nb += 1\n                continue\n            return None\n    S2 = ((1<<N)-1) ^ T\n    \n    if na > nb:\n        na, nb = nb, na\n    ss = check(S2)\n    if ss is None:\n        return None\n    return ss + [(na, nb)] \n\n\nN, M = map(int, readline().split())\nG = [1<<i for i in range(N)]\nfor _ in range(M):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    G[a] |= 1<<b\n    G[b] |= 1<<a\nss = check((1<<N)-1)\nif ss is None:\n    print(-1)\nelse:\n    SA, SB = list(map(list, zip(*ss)))\n    res = 1\n    for sa, sb in zip(SA, SB):\n        res = (res<<sa)|(res<<sb)\n    ans = 10**9+7\n    for i in range(N+1):\n        if not (1<<i)&res:\n            continue\n        ans = min(ans, (i-1)*i//2 + (N-i-1)*(N-i)//2)\n    print(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,m = list(map(int, input().split()))\nmt = [[True]*n for _ in range(n)]\nfor i in range(m):\n    a,b = map(int, input().split())\n    a -= 1\n    b -= 1\n    mt[a][b] = False\n    mt[b][a] = False\nfor i in range(n):\n    mt[i][i] = False\nns = [[] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        if mt[i][j]:\n            ns[i].append(j)\n            \n# \u4e8c\u90e8\u30b0\u30e9\u30d5\u5224\u5b9a bipertite\ndef is_bip(ns):\n    cs = [None]*n\n    vs = []\n    for start in range(n):\n        if cs[start] is not None:\n            continue\n        v0 = v1 = 0\n        q = [start]\n        cs[start] = 1\n        v1 += 1\n        while q:\n            u = q.pop()\n            c = cs[u]\n            cc = int(not c)\n            for v in ns[u]:\n                if cs[v] is None:\n                    cs[v] = cc\n                    if cc==0:\n                        v0 += 1\n                    else:\n                        v1 += 1\n                    q.append(v)\n                elif cs[v]==c:\n#                     print(cs)\n                    return False, None\n        vs.append((v0,v1))\n    return True, vs\nres, vs = is_bip(ns)\nif not res:\n    ans = -1\nelse:\n    dp = 1\n    for v0,v1 in vs:\n        dp = (dp<<v0) | (dp<<v1)\n#         for i in range(n,-1,-1):\n#             if i-v0>=0:\n#                 dp[i] |= dp[i-v0]\n#             if i-v1>=0:\n#                 dp[i] |= dp[i-v1]\n#             print(dp)\n    ans = float(\"inf\")\n    for i in range(1,n+1):\n        if dp>>i&1:\n            ans = min(ans, i*(i-1)//2+(n-i)*(n-i-1)//2)\nprint(ans)", "\"\"\"\nE\u554f\u984c\n\u7e4b\u304c\u3063\u3066\u3044\u308b\u90fd\u5e02\u540c\u58eb\u306f\u540c\u3058\u5dde\u306b\u3042\u3063\u3066\u3082\u9055\u3046\u5dde\u306b\u3042\u3063\u3066\u3082\u3088\u3044\u2192\u8003\u3048\u306b\u304f\u3044\n\u2192\u300c\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306f\u5fc5\u305a\u9055\u3046\u5dde\u306b\u3042\u308b\u300d\u306e\u307b\u3046\u304c\u8003\u3048\u3084\u3059\u3044\n\u2192\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306b\u3059\u3079\u3066\u8fba\u3092\u5f35\u3063\u3066\u4e8c\u90e8\u30b0\u30e9\u30d5\u304c\u69cb\u6210\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u305d\u3046\uff1f\n\uff08\u5fc5\u8981\u6761\u4ef6\u3067\u306f\u3042\u308b\u3051\u3069\u5341\u5206\u6761\u4ef6\u3067\u3042\u308b\u304b\u3069\u3046\u304b\u306f\u308f\u304b\u3089\u306a\u3044\uff09\n\u2192\u3053\u306e\u6761\u4ef6\u3060\u3068\u540c\u3058\u5dde\u306b\u3042\u308b\u306a\u3089\u5fc5\u305a\u4efb\u610f\u306e\u4e8c\u90fd\u5e02\u9593\u306f\u7e4b\u304c\u3063\u3066\u3044\u308b\u306e\u3067\u5341\u5206\u6761\u4ef6\u3082\u6e80\u305f\u3057\u3066\u305d\u3046\uff01\n\uff08\u2235\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306b\u8fba\u3092\u5f35\u3063\u305f\u6642\u540c\u3058\u5dde\u5185\u306b\u8fba\u3092\u6301\u305f\u306a\u3044\u305f\u3081\uff09\n\n\uff08\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306b\u8fba\u3092\u5f35\u3063\u305f\uff09\u30b0\u30e9\u30d5\u304c\u9023\u7d50\u21d2\u90fd\u5e02\u306e\u9078\u3073\u65b9\u306f\u9ad8\u30051\u901a\u308a\n\u9023\u7d50\u3067\u306a\u3044\u306a\u3089\u8907\u6570\u306e\u9078\u3073\u65b9\u304c\u5b58\u5728\u3059\u308b\n\u2192\u6700\u5c0f\u3068\u306a\u308b\u3088\u3046\u306a\u9078\u3073\u65b9\u306f\u3069\u306e\u3088\u3046\u306b\u6c7a\u3081\u308c\u3070\u3088\u3044\u304b\uff1f\n\u2192\u305d\u308c\u305e\u308c\u306e\u9023\u7d50\u6210\u5206\u3054\u3068\u306b\u3001\u7247\u65b9\u306bai\u90fd\u5e02\u3001\u3082\u3046\u7247\u65b9\u306bbi\u90fd\u5e02\u632f\u308a\u5206\u3051\u3089\u308c\u308b\u3068\u3059\u308b\u3068\nL = [[a1, b1], [a2, b2], ... , [ak, bk]]\n\u3068\u3067\u304d\u3066\u3001(sum(A)+sum(B) == n)\ns = \u03a3[i = 1 to k](ai\u304bbi\u306e\u3069\u3061\u3089\u304b\u3092\u9078\u3093\u3067\u8db3\u3059)\u3000\u3068\u3057\u305f\u3068\u304d\u306b\n\u3082\u3063\u3068\u3082s\u304cn//2\u306b\u8fd1\u304f\u306a\u308b\u3088\u3046\u306bs\u3092\u9078\u3079\u3070\u3088\u304f\u3001\u3053\u308c\u306fdp\u3067O(nk)\u3067\u3067\u304d\u308b\n\"\"\"\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nimport numpy as np\n\nn, m = map(int, input().split())\nG = [{i for i in range(n) if i != j} for j in range(n)]\nfor _ in range(m):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  G[a].remove(b)\n  G[b].remove(a)\n\nseen = [-1]*n\nL = []\ndef is_bipartite(v, color):\n  seen[v] = color\n  L[-1][color] += 1\n  for i in G[v]:\n    if seen[i] != -1:\n      if seen[i] == color:\n        return False\n    else:\n      if not is_bipartite(i, color^1):\n        return False\n  return True\n\nfor i in range(n):\n  if seen[i] == -1:\n    L.append([0, 0])\n    if not is_bipartite(i, 0):\n      print(-1)\n      break\nelse:\n  dp = np.zeros((len(L)+1, n+1), dtype=bool)\n  dp[0, 0] = True\n  for i, ab in enumerate(L):\n    a, b = ab\n    dp[i+1, a:] |= dp[i, :n+1-a]\n    dp[i+1, b:] |= dp[i, :n+1-b]\n  temp = n//2\n  dp = dp[-1].tolist()\n  while not dp[temp]:\n    temp += 1\n  r = n - temp\n  print(temp*(temp-1)//2 + r*(r-1)//2)", "from collections import deque\n\nN, M = list(map(int, input().split()))\nadjL = [set(range(N)) for _ in range(N)]\nfor v in range(N):\n    adjL[v].remove(v)\nfor _ in range(M):\n    A, B = list(map(int, input().split()))\n    A, B = A-1, B-1\n    adjL[A].remove(B)\n    adjL[B].remove(A)\n\ndef getSizes(adjList):\n    def bfs(vSt):\n        colors[vSt] = 1\n        nums[1] += 1\n        Q = deque([vSt])\n        while Q:\n            vNow = Q.popleft()\n            color = colors[vNow]\n            for v2 in adjList[vNow]:\n                if colors[v2] == color:\n                    return False\n                elif colors[v2] == 0:\n                    colors[v2] = -color\n                    nums[-color] += 1\n                    Q.append(v2)\n        return True\n\n    numV = len(adjList)\n    colors = [0] * numV\n    anss = []\n    for vSt in range(numV):\n        if colors[vSt] != 0: continue\n        nums = {-1: 0, 1: 0}\n        if not bfs(vSt):\n            return []\n        anss.append((nums[-1], nums[1]))\n    return anss\n\nsizes = getSizes(adjL)\n\nif not sizes:\n    print((-1))\nelse:\n    bitset = 1<<N\n    for A, B in sizes:\n        bitset = (bitset>>A) | (bitset>>B)\n\n    minDiff = N\n    iMinDiff = -1\n    for i in reversed(list(range(N+1))):\n        if bitset & 1:\n            diff = abs(i-N/2)\n            if diff < minDiff:\n                minDiff = diff\n                iMinDiff = i\n        bitset >>= 1\n\n    print((iMinDiff*(iMinDiff-1)//2 + (N-iMinDiff)*(N-iMinDiff-1)//2))\n", "from collections import deque\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(m)]\n\nmatrix = [[0]*n for i in range(n)]\nfor i in range(m):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    matrix[a][b] = 1\n    matrix[b][a] = 1\n\ngraph = [[] for i in range(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        if matrix[i][j] == 0:\n            graph[i].append(j)\n            graph[j].append(i)\n\n\ndef coloring(graph):\n    n = len(graph)\n    visited = [-1] * n\n    ans = []\n    for i in range(n):\n        if visited[i] >= 0:\n            continue\n        visited[i] = 0\n        q = deque([i]) \n        num = [1, 0]\n        while q:\n            _from = q.pop()\n            for to in graph[_from]:\n                if visited[to] == visited[_from]:\n                    return [[-1, -1]]\n                if visited[to] >= 0:\n                    continue\n                visited[to] = visited[_from] ^ 1\n                num[visited[to]] += 1\n                q.append(to)\n        ans.append(num)\n    return ans\n\nnum = coloring(graph)\nif num[0][0] == -1:\n    print(-1)\n    return\n\ndp = [[False]*(n+1) for _ in range(len(num) + 1)]\ndp[0][0] = True\n\nfor i in range(len(num)):\n    a, b = num[i]\n    for j in range(n+1):\n        if j-a >= 0:\n            dp[i+1][j] = dp[i][j-a] or dp[i+1][j]\n        if j-b >= 0:\n            dp[i+1][j] = dp[i][j-b] or dp[i+1][j]\n\nans = 10**20\nfor i, boolian in enumerate(dp[len(num)]):\n    if boolian:\n        tmp_ans = i * (i-1) // 2 + (n-i) * (n-i-1) // 2 \n        ans = min(tmp_ans, ans)\nprint(ans)", "from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n: int) -> None:\n        '\u6728\u306e\u521d\u671f\u5316\u3092\u3059\u308b'\n        self.p = [-1] * n\n        self.rank = [1]*n\n        self.size = [1] * n\n\n    def find(self, x: int) -> int:\n        'x \u306e\u89aa\u3092\u8fd4\u3059'\n        if self.p[x] == -1:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x: int, y: int) -> bool:\n        'rank\u306e\u4f4e\u3044\u89aa\u3092\u9ad8\u3044\u65b9\u306e\u306e\u89aa\u306b\u3059\u308b'\n        if not self.same(x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] > self.rank[y]:\n                x, y = y, x\n            elif self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n            self.p[x] = y\n            self.size[y] += self.size[x]\n            return True\n        else:\n            return False\n\n    def same(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n\n\nn, m = list(map(int, input().split()))\npath = [[1]*n for _ in range(n)]\nfor j in range(n):\n    path[j][j] = 0\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    path[a][b] = 0\n    path[b][a] = 0\n\nuf = UnionFind(2*n)\n\nfor i in range(n):\n    for j in range(n):\n        if path[i][j] == 1:\n            uf.unite(i, j+n)\n            uf.unite(i+n, j)\n\nfor i in range(n):\n    if uf.same(i, i+n):\n        print((-1))\n        return\n\ndeltas: List[int] = []\n\nview = [1]*n\n\nfor i in range(n):\n    if view[i] == 0:\n        continue\n    delta = 0\n    for j in range(n):\n        if uf.same(i, j):\n            view[j] = 0\n            delta += 1\n        elif uf.same(i, j+n):\n            view[j] = 0\n            delta -= 1\n    delta = abs(delta)\n    deltas.append(delta)\ndp = [0]*(n+10)\ndp[0] = 1\nfor delta in deltas:\n    dpnxt = [0]*(n+10)\n    for i in range(n+1):\n        if i+delta <= n:\n            dpnxt[i+delta] += dp[i]\n        dpnxt[abs(i-delta)] += dp[i]\n    dp = dpnxt.copy()\n\nfor i in range(n+1):\n    if dp[i]:\n        print(((n+i)//2*((n+i-1)//2)//2 + (n-i)//2*((n-i-1)//2)//2))\n        return\n", "from collections import deque\nN, M = map(int, input().split())\nG0 = [set([i]) for i in range(N)]\n\nA = set(range(N))\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    G0[a-1].add(b-1)\n    G0[b-1].add(a-1)\n\nG = [A - g for g in G0]\n\nb = 1 << (N//2)\nc = [-1]*N\nfor i in range(N):\n    if c[i] != -1:\n        continue\n    p = 0; s = 0\n    que = deque([i])\n    c[i] = 0\n    while que:\n        v = que.popleft()\n        s += 1\n        if c[v] == 0:\n            p += 1\n        for w in G[v]:\n            if c[w] == -1:\n                c[w] = c[v]^1\n                que.append(w)\n            elif c[w] == c[v]:\n                print(-1)\n                return\n    b = (b >> p) | (b >> (s-p))\n\np = N//2 - ((b & -b).bit_length()-1)\nq = N - p\nprint(p*(p-1)//2 + q*(q-1)//2)", "import sys\nN,M=map(int,input().split())\ndata=[[0]*(N+1) for i in range(N+1)]\nfor i in range(M):\n    A,B=map(int,input().split())\n    data[A][B]=1\n    data[B][A]=1\nfor i in range(1,N+1):\n    data[i][i]=1\nlst=[-1]*(N+1)\nddd=[]\nfor i in range(1,N+1):\n    if lst[i]!=-1:\n        continue\n    else:\n        lst[i]=0\n        que=[i]\n        count=[1,0]\n        while que:\n            h=[]\n            for u in que:\n                for j in range(1,N+1):\n                    if data[u][j]==1:\n                        continue\n                    else:\n                        if lst[j]==-1:\n                            lst[j]=lst[u]^1\n                            count[lst[j]]+=1\n                            h.append(j)\n                        elif lst[j]^lst[u]==0:\n                            print(-1)\n                            return\n            que=h\n        ddd.append(count)\ndp=[0]*(N+1)\ndp[0]=1\nfor u in ddd:\n    v=u[0]\n    h=[0]*(N+1)\n    for i in range(v,N+1):\n        if dp[i-v]==1:\n            h[i]=1\n    v=u[1]\n    for i in range(v,N+1):\n        if dp[i-v]==1:\n            h[i]=1\n    dp=h\nans=0\nfor i in range(N+1):\n    if dp[i]==1:\n        if abs(N-2*ans)>abs(N-2*i):\n            ans=i\nqqq=N-ans\nif qqq==0 or ans==0:\n    print(N*(N-1)//2)\nelse:\n    print(ans*(ans-1)//2+qqq*(qqq-1)//2)", "\ndef main(n,m,ab):\n    g=[set(j for j in range(n) if j!=i) for i in range(n)]\n    for i,(a,b) in enumerate(ab):\n        a,b=a-1,b-1\n        g[a].discard(b)\n        g[b].discard(a)\n    xy=[]\n    mi=set(range(n))\n    seen=[-1]*n\n    while mi:\n        v=mi.pop()\n        todo=[[v,-1]]\n        seen[v]=0\n        xyi=[0,0]\n        xyi[0]+=1\n        while todo:\n            v,p=todo.pop()\n            for nv in g[v]:\n                if nv==p:continue\n                if seen[nv]==-1:\n                    seen[nv]=(seen[v]+1)%2\n                    xyi[seen[nv]]+=1\n                    mi.discard(nv)\n                    todo.append([nv,v])\n                elif seen[nv]!=(seen[v]+1)%2:return -1\n        xy.append(xyi)\n    abl=[0]*(n+1)\n    abl[0]=1\n    for x,y in xy:\n        for i in range(n,-1,-1):\n            if abl[i]>0:\n                abl[i]=0\n                abl[i+x]=1\n                abl[i+y]=1\n    ans=m\n    for i,x in enumerate(abl):\n        if x==0:continue\n        j=n-i\n        ans=min(ans,(i*(i-1))//2+(j*(j-1))//2)\n    return ans\n\nn,m=map(int,input().split())\nab=[list(map(int,input().split())) for _ in range(m)]\nprint(main(n,m,ab))", "N,M=map(int,input().split())\nedge=[set([]) for i in range(N)]\nfor i in range(M):\n    a,b=map(int,input().split())\n    edge[a-1].add(b-1)\n    edge[b-1].add(a-1)\n\ncedge=[[] for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if j not in edge[i] and j!=i:\n            cedge[i].append(j)\n\nans=[]\ndef is_bipartgraph():\n    color=[0]*N\n    used=[False]*N\n    for i in range(N):\n        if not used[i]:\n            stack=[(i,1)]\n            black=0\n            white=0\n            while stack:\n                v,c=stack.pop()\n                if not used[v]:\n                    color[v]=c\n                    black+=(c==1)\n                    white+=(c==-1)\n                    used[v]=True\n                    for nv in cedge[v]:\n                        if color[nv]==color[v]:\n                            return False\n                        elif color[nv]==0:\n                            stack.append((nv,-c))\n            ans.append([black,white])\n    return True\n\nif is_bipartgraph():\n    dp=[[False for i in range(0,N+1)] for j in range(len(ans))]\n    a,b=ans[0]\n    dp[0][a],dp[0][b]=True,True\n    for i in range(1,len(ans)):\n        a,b=ans[i]\n        for j in range(0,N+1):\n            test=False\n            if j>=a:\n                test=test|dp[i-1][j-a]\n            if j>=b:\n                test=test|dp[i-1][j-b]\n            dp[i][j]=test\n    ans=0\n    for i in range(0,N+1):\n        if dp[-1][i] and abs(ans-N/2)>abs(i-N/2):\n            ans=i\n    ans2=N-ans\n    print(ans*(ans-1)//2+ans2*(ans2-1)//2)\nelse:\n    print(-1)", "def main():\n    n, m = list(map(int, input().split()))\n    ab = [list(map(int, input().split())) for _ in [0]*m]\n\n    n_hozon = n\n    g = [set() for _ in [0]*n]\n    [g[a-1].add(b-1) for a, b in ab]\n    [g[b-1].add(a-1) for a, b in ab]\n    s = set([i for i in range(n)])\n\n    # \u984c\u610f\uff1a\u3067\u304d\u308b\u3060\u3051\u8fba\u304c\u5c11\u306a\u304f\u306a\u308b\u3088\u3046\u306b2\u3064\u306e\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u5206\u3051\u305f\u3044\n    # \u307e\u305a\u30012\u3064\u306e\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\u5206\u3051\u3089\u308c\u308b\u306e\u304b\u3092\u8abf\u3079\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n    # \u3053\u308c\u304c\u4e0d\u53ef\u80fd\u3067\u3042\u308c\u3070-1\u3092\u51fa\u529b\u3057\u3066\u5373\u5ea7\u306b\u7d42\u4e86\u3002\n\n    # \u5206\u3051\u3089\u308c\u308b\u306e\u3067\u3042\u308c\u3070\u3001\u3067\u304d\u308b\u3060\u3051\u8857\u306e\u6570\u3092\u5747\u7b49\u306b\u3057\u305f\u3044\u3002\n    # \u4ee5\u4e0b\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8003\u3048\u308b\u3002\n    # \u307e\u305a\u304a\u4e92\u3044\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u90fd\u5e02\u306e\u7d44A,B\u3092\u9078\u3076\u3002\n    # \u3059\u308b\u3068\u3001A\u306b\u3057\u304b\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u8857\u3001B\u306b\u3057\u304b\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u8857\u3001\n    # \u4e21\u65b9\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u8857\u306e3\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u304b\u308c\u308b\u3002\n    # \u3053\u306e\u3046\u3061\u3001\u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u3064\u3044\u3066\u3001\n    # \u6700\u521d\u306b\u623b\u3063\u3066\u540c\u69d8\u306e\u51e6\u7406\u3092\u884c\u3046\u3002\n    # \u8857\u304c\u306a\u304f\u306a\u308b\u304b\u3001\u4e21\u65b9\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u8857\u306e\u30b0\u30eb\u30fc\u30d7\u304c\u5b8c\u5168\u30b0\u30e9\u30d5\u306b\n    # \u306a\u3063\u305f\u6642\u70b9\u3067\u7d42\u4e86\u3002\n\n    # \u4e0a\u8a18\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u308a\u3001(A,B)\u306e\u5217\u3068\u6700\u5f8c\u306b\u6b8b\u3063\u305f\u8857\u306e\u6570\u304c\u6c42\u3081\u3089\u308c\u308b\u3002\n    # \u3053\u308c\u3092\u3082\u3068\u306b\u3001\u52d5\u7684\u8a08\u753b\u6cd5\u3067\u8003\u3048\u3089\u308c\u308b\u8857\u306e\u632f\u308a\u5206\u3051\u65b9\u3092\u5168\u3066\u6d17\u3044\u51fa\u3059\u3002\n    # \u6700\u3082\u5747\u7b49\u306b\u8fd1\u304f\u632f\u308a\u5206\u3051\u305f\u5834\u5408\u306b\u3064\u3044\u3066\u3001\u5b8c\u5168\u30b0\u30e9\u30d5\u306e\u8fba\u6570\u3092\u8a08\u7b97\u3057\u3066\n    # \u51fa\u529b\u3059\u308c\u3070\u554f\u984c\u304c\u89e3\u3051\u308b\u3002\n    a_list, b_list = [], []\n    while True:\n        #print(n, m)\n        # print(s)\n        # print(g)\n        # \u5b8c\u5168\u30b0\u30e9\u30d5\u304b\u3069\u3046\u304b\n        #print(n, m, g, s)\n        if m == n*(n-1)//2:\n            break\n        a = [-1, 10**10]\n        for i in s:\n            l = len(g[i])\n            if l < a[1]:\n                a = [i, l]\n        a = a[0]\n        b = [-1, 10**10]\n        for i in s-g[a]-{a}:\n            l = len(g[i])\n            if l < b[1]:\n                b = [i, l]\n        b = b[0]\n        #print(a, b)\n        a_set, b_set = {a}, {b}\n        s.remove(a)\n        s.remove(b)\n        n -= 2\n        remain = set()\n        for i in s:\n            flag_a = True\n            for j in a_set:\n                if j not in g[i]:\n                    flag_a = False\n                else:\n                    g[i].remove(j)\n                    g[j].remove(i)\n                    m -= 1\n            flag_b = True\n            for j in b_set:\n                if j not in g[i]:\n                    flag_b = False\n                else:\n                    g[i].remove(j)\n                    g[j].remove(i)\n                    m -= 1\n            #print(i, flag_a, flag_b)\n            if flag_a == flag_b == False:\n                print((-1))\n                return\n            elif flag_a == False or flag_b == False:\n                # print(remain)\n                q = {i}\n                flag = flag_a  # True\u2192A\u306b\u5165\u308c\u308b\n                while q:\n                    #print(q, \"q\")\n                    qq = set()\n                    while q:\n                        i = q.pop()\n                        if flag:\n                            a_set.add(i)\n                        else:\n                            b_set.add(i)\n                        for j in remain:\n                            if j not in g[i]:\n                                qq.add(j)\n                            else:\n                                g[i].remove(j)\n                                g[j].remove(i)\n                                m -= 1\n                        for j in q:\n                            g[i].remove(j)\n                            g[j].remove(i)\n                            m -= 1\n                    for i in qq:\n                        remain.remove(i)\n                    flag ^= True\n                    q = qq\n            else:\n                remain.add(i)\n            # print(g)\n        for i in (a_set | b_set)-{a}-{b}:\n            s.remove(i)\n            n -= 1\n\n        a_list.append(len(a_set))\n        b_list.append(len(b_set))\n\n    m = n\n    n = n_hozon\n    k = len(a_list)\n\n    if k == 1:\n        dp = [False]*(n+1)\n        a = a_list[0]\n        b = b_list[0]\n        ans = 10**10\n        for i in range(m+1):\n            ans = min(ans, (a+i)*(a+i-1)//2+(n-a-i)*(n-a-i-1)//2)\n        print(ans)\n        return\n\n    dp = [False]*(n+1)\n    dp[0] = True\n\n    for i in range(k):\n        a, b = a_list[i], b_list[i]\n        maxab = max(a, b)\n        dp2 = [False]*(n+1)\n        for j in range(n-maxab+1):\n            dp2[j+a] |= dp[j]\n            dp2[j+b] |= dp[j]\n        dp = dp2\n\n    dp2 = [False]*(n+1)\n    for j in range(m+1):\n        for i in range(n-j+1):\n            dp2[i+j] |= dp[i]\n    ans = 10**10\n\n    for i in range(n+1):\n        if dp2[i] is False:\n            continue\n        j = n-i\n        ans = min(ans, i*(i-1)//2+j*(j-1)//2)\n    print(ans)\n\n\nmain()\n", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,m = list(map(int,readline().split()))\n\n# \u88dc\u30b0\u30e9\u30d5\ng = [[1]*n for _ in range(n)]\nfor i in range(n): g[i][i] = 0\n\nfor _ in range(m):\n    a,b = list(map(int,readline().split()))\n    g[a-1][b-1] = g[b-1][a-1] = 0\n\nused = [-1]*n\ndp = 1\nok = 1\nfor i in range(n):\n    if used[i]==-1:\n        used[i] = 0\n        st = [i]\n        a = b = 0\n        while st:\n            v = st.pop()\n            c = used[v]\n            if c: a += 1\n            else: b += 1\n            for k in range(n):\n                if g[v][k] == 1:\n                    if used[k] == -1:\n                        used[k] = 1-c\n                        st.append(k)\n                    elif used[k] == c:\n                        ok = 0\n                        break\n    \n        dp = (dp<<a)|(dp<<b)\n        #print(a,b)\n        if not ok:\n            dp = 0\n            break\n\n#print(bin(dp)[2:][::-1])\n\nans = -1\nfor i in range(n//2+1):\n    if dp>>i&1:\n        ans = i*(i-1)//2 + (n-i)*(n-i-1)//2\n\nprint(ans)\n", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,m = map(int, input().split())\nG = [[1]*n for i in range(n)]\nfor i in range(n):\n    G[i][i] = 0\nfor i in range(m):\n    a,b = map(int, input().split())\n    a,b = a-1,b-1\n    G[a][b] = 0\n    G[b][a] = 0\n\nfrom collections import deque\n\nused = [0]*n\ntmp = []\n\ndef bfs(start):\n    if used[start]:\n        return True\n    d = {-1:0, 1:0}\n    que = deque()\n    que.append((start, 1))\n    while que:\n        cur, flag = que.popleft()\n        if used[cur] == flag:\n            continue\n        elif used[cur]:\n            return False\n        used[cur] = flag\n        d[flag] += 1\n        for to in range(n):\n            if G[cur][to] and used[to] == 0:\n                que.append((to, -flag))\n    tmp.append(list(d.values()))\n    return True\n\nif not all(bfs(i) for i in range(n)):\n    print(-1)\nelse:\n    s = set([0])\n    target = (n+1)//2\n    for l in tmp:\n        t = set()\n        for a in l:\n            for b in s:\n                if a+b <= target:\n                    t.add(a+b)\n        s = t\n    k = max(s)\n    l = n-k\n    ans = k*(k-1)//2 + l*(l-1)//2\n    print(ans)", "def dfs(links, fixed, s):\n    q = [(s, 0)]\n    cnt = [0, 0]\n    while q:\n        v, c = q.pop()\n        if fixed[v] > -1:\n            if fixed[v] != c:\n                return False\n            continue\n        fixed[v] = c\n        cnt[c] += 1\n        for u in links[v]:\n            q.append((u, c ^ 1))\n    return (max(cnt), min(cnt))\n\n\ndef is_bipartite(n, links):\n    fixed = [-1] * n\n    l, r = 0, 0\n    can = []\n    for i in range(n):\n        if fixed[i] > -1:\n            continue\n        cnt = dfs(links, fixed, i)\n        if cnt == False:\n            return -1\n        can.append(cnt)\n\n    can.sort(reverse=True)\n    for cnt in can:\n        j = 0 if cnt[0] > cnt[1] else 1\n        if l > r:\n            j ^= 1\n        l += cnt[j]\n        r += cnt[j ^ 1]\n    return (l * (l - 1) + r * (r - 1)) // 2\n\n\nn, m = list(map(int, input().split()))\nlinks = [set(range(n)) - {i} for i in range(n)]\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    links[a].remove(b)\n    links[b].remove(a)\nprint((is_bipartite(n, links)))\n", "N,M=list(map(int,input().split()))\nedge=[set([]) for i in range(N)]\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    edge[a-1].add(b-1)\n    edge[b-1].add(a-1)\n\ncedge=[[] for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if j not in edge[i] and j!=i:\n            cedge[i].append(j)\n\nans=[]\ndef is_bipartgraph():\n    color=[0]*N\n    used=[False]*N\n    for i in range(N):\n        if not used[i]:\n            stack=[(i,1)]\n            black=0\n            white=0\n            while stack:\n                v,c=stack.pop()\n                color[v]=c\n                black+=(not used[v])*(c==1)\n                white+=(not used[v])*(c==-1)\n                used[v]=True\n                for nv in cedge[v]:\n                    if color[nv]==color[v]:\n                        return False\n                    elif color[nv]==0:\n                        stack.append((nv,-c))\n            ans.append([black,white])\n    return True\n\nif is_bipartgraph():\n    dp=[[False for i in range(0,N+1)] for j in range(len(ans))]\n    a,b=ans[0]\n    dp[0][a],dp[0][b]=True,True\n    for i in range(1,len(ans)):\n        a,b=ans[i]\n        for j in range(0,N+1):\n            test=False\n            if j>=a:\n                test=test|dp[i-1][j-a]\n            if j>=b:\n                test=test|dp[i-1][j-b]\n            dp[i][j]=test\n    ans=0\n    for i in range(0,N+1):\n        if dp[-1][i] and abs(ans-N/2)>abs(i-N/2):\n            ans=i\n    ans2=N-ans\n    print((ans*(ans-1)//2+ans2*(ans2-1)//2))\nelse:\n    print((-1))\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nclass UnionFind:\n    def __init__(self, n):\n        self.state = [-1] * n\n        self.size_table = [1] * n\n        # cnt\u306f\u30b0\u30eb\u30fc\u30d7\u6570\n        # self.cnt = n\n\n    def root(self, u):\n        v = self.state[u]\n        if v < 0: return u\n        self.state[u] = res = self.root(v)\n        return res\n\n    def merge(self, u, v):\n        ru = self.root(u)\n        rv = self.root(v)\n        if ru == rv: return\n        du = self.state[ru]\n        dv = self.state[rv]\n        if du > dv: ru, rv = rv, ru\n        if du == dv: self.state[ru] -= 1\n        self.state[rv] = ru\n        # self.cnt -= 1\n        self.size_table[ru] += self.size_table[rv]\n        return\n\n    # \u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n    def size(self, u):\n        return self.size_table[self.root(u)]\n\ndef ng():\n    for u in range(n):\n        for v in range(n):\n            if v == u: continue\n            if to[u][v]: continue\n            if uf.root(u)==uf.root(v):return True\n    return False\n\nn,m=MI()\nto=[[False]*n for _ in range(n)]\nfor _ in range(m):\n    u,v=MI1()\n    to[u][v]=to[v][u]=True\n\nuf=UnionFind(n)\nuncon=[-1]*n\nfor u in range(n):\n    pv=-1\n    for v in range(n):\n        if v==u:continue\n        if to[u][v]:continue\n        if pv==-1:pv=v\n        else:uf.merge(pv,v)\n    uncon[u]=pv\n\n#print(uf.state)\n#print(uf.size_table)\n#print(uncon)\n\nif ng():\n    print(-1)\n    return\n\nfin=[False]*n\nfree=0\nss=[]\nfor u in range(n):\n    if uncon[u]==-1:\n        free+=1\n        continue\n    r0=uf.root(u)\n    if fin[r0]:continue\n    r1=uf.root(uncon[u])\n    fin[r0]=fin[r1]=True\n    ss.append(abs(uf.size_table[r0]-uf.size_table[r1]))\ncur=1<<1000\nfor s in ss:cur=cur<<s|cur>>s\ncur>>=1000\nd=(cur&-cur).bit_length()-1\nd=max(0,d-free)\ns0=(n-d)//2\ns1=n-s0\nprint(s0*(s0-1)//2+s1*(s1-1)//2)\n", "n,m,*A=map(int,open(0).read().split())\ng=[[1]*n for _ in [0]*n]\nfor a,b in zip(A[::2],A[1::2]):\n    g[a-1][b-1]=g[b-1][a-1]=0\nU=[1]*n\nD=1\ndef dfs(v):\n    nonlocal D\n    R[U[v]]+=1\n    for k in range(n):\n        if g[v][k]*(k-v):\n            D *= U[k]!=U[v]\n            if U[k]>0:\n                U[k]=~U[v]\n                dfs(k)\nfor i in range(n):\n    if U[i]>0:\n        R=[0,0];U[i]=0\n        dfs(i);\n        D=(D<<R[0])|(D<<R[1])\na=-1\nfor i in range(n//2+1):\n    if D>>i&1:a=(i*(i-1)+(n-i)*(n-i-1))//2\nprint(a)", "import sys\ninput = sys.stdin.readline\n\n\ndef is_bipartite(graph, s):\n    \"\"\"\u4e8c\u90e8\u30b0\u30e9\u30d5\u5224\u5b9a\u3059\u308b\"\"\"\n    n = len(graph)\n    col = [-1] * n\n    col[s] = 0\n    stack = [s]\n    used[s] = True\n    while stack:\n        v = stack.pop()\n        for nxt_v in graph[v]:\n            used[nxt_v] = True\n            if col[nxt_v] == -1:\n                col[nxt_v] = col[v] ^ 1\n                stack.append(nxt_v)\n            elif col[nxt_v] ^ col[v] == 0:\n                return False\n    return True\n\ndef color_bipartite(graph, s):\n    \"\"\"\u4e8c\u90e8\u30b0\u30e9\u30d5\u3092\u5f69\u8272\u3059\u308b\"\"\"\n    n = len(graph)\n    col = [-1] * n\n    col[s] = 0\n    stack = [s]\n    while stack:\n        v = stack.pop()\n        for nxt_v in graph[v]:\n            if col[nxt_v] == -1:\n                col[nxt_v] = col[v] ^ 1\n                stack.append(nxt_v)\n    return col\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(m)]\n\ngraph = [set() for i in range(n)]\nfor a, b in info:\n    a -= 1\n    b -= 1\n    graph[a].add(b)\n    graph[b].add(a)\n\ncomp_graph = [[] for i in range(n)]\nfor a in range(n):\n    for b in range(n):\n        if b in graph[a] or a == b:\n            continue\n        comp_graph[a].append(b)\n        \n\ncnt0 = []\ncnt1 = []\nused = [False] * n\nfor i in range(n):\n    if used[i]:\n        continue\n    used[i] = True\n    if not is_bipartite(comp_graph, i):\n        print(-1)\n        return\n    col = color_bipartite(comp_graph, i)\n    cnt0.append(col.count(0))\n    cnt1.append(col.count(1))\n\ndp = [[False] * (n + 1) for i in range(len(cnt0) + 1)]\ndp[0][0] = True\nfor i in range(len(cnt0)):\n    wei0 = cnt0[i]\n    wei1 = cnt1[i]\n    for w in range(n + 1):\n        if w + wei0 < n + 1:\n            dp[i + 1][w + wei0] = (dp[i][w] or dp[i + 1][w + wei0])\n        if w + wei1 < n + 1:\n            dp[i + 1][w + wei1] = (dp[i][w] or dp[i + 1][w + wei1])\n\nans = 10 ** 18\nfor num in range(n + 1):\n    if dp[-1][num]:\n        c0 = num\n        c1 = n - num\n        res = c0 * (c0 - 1) // 2 + c1 * (c1 - 1) // 2\n        ans = min(ans, res)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\ne = [set([x for x in range(1, N + 1) if i != x]) for i in range(N + 1)]\nfor _ in range(M):\n  u, v = map(int, input().split())\n  e[u].discard(v)\n  e[v].discard(u)\n\ncl = [0] * (N + 1)\ndp = [0] * (N + 1)\ndp[0] = 1\nfor x in range(1, N + 1):\n  if cl[x]: continue\n  s = [x]\n  qs = []\n  cl[x] = 1\n  while len(s):\n    p = s.pop()\n    qs.append(p)\n    for q in e[p]:\n      if cl[q]:\n        if cl[q] % 2 == cl[p] % 2:\n          print(-1)\n          return\n        continue\n      cl[q] = cl[p] % 2 + 1\n      s.append(q)\n  predp = dp[: ]\n  for i in range(N, -1, -1):\n    if dp[i] == 0: continue\n    u = 0\n    v = 0\n    for q in qs:\n      u += cl[q] % 2\n      v += cl[q] % 2 == 0\n    dp[i] -= predp[i]\n    dp[i + u] += 1\n    dp[i + v] += 1\n  #print(dp)\nres = N * (N - 1) // 2\nfor i in range(1, N + 1):\n  if dp[i] == 0: continue\n  u = i * (i - 1) // 2\n  v = (N - i) * (N - i - 1) // 2\n  res = min(res, u + v)\nprint(res)", "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\nmod=10**9+7\n\n\n\"\"\"\nA,B\u306e2\u3064\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\uff0e\u5404\u30b0\u30eb\u30fc\u30d7\u5185\u306e\u5168\u3066\u306e\u70b9\u3078\u6700\u77ed\u8ddd\u96e2\u304c1\u3068\u306a\u308b.\n\u9006\u306b\uff0c\u6700\u77ed\u8ddd\u96e2\u304c1\u51fa\u306a\u3051\u308c\u3070\u7570\u306a\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u914d\u5c5e\u3055\u308c\u308b.\n\u5168\u70b9\u9593\u8ddd\u96e2\u306f\u308f\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c8\u3067\u6c42\u3081\u308b\uff0e\n\u3053\u308c\u306f2-SAT\u304b\u306a\uff0ca,b\u306e\u8ddd\u96e2\u304c1\u3067\u306f\u306a\u3044\u2192a,b\u306f\u9055\u3046\u30b0\u30eb\u30fc\u30d7\u306b\u5165\u308b\u2192(a\u2228b)\u2227(not_a \u2228 not_b)\n\u3053\u308c\u3092\u2227\u3067\u3064\u306a\u3052\u3066\u3044\u3051\u3070\u826f\u3044\uff0e\n\n\u3069\u3061\u3089\u306b\u5165\u3063\u3066\u3082\u826f\u3044\u70b9(\u5168\u3066\u306e\u70b9\u3068\u306e\u8ddd\u96e2\u304c1)\uff0c\u3068\u3044\u3046\u306e\u304c\u3042\u308b\uff0c\u3053\u308c\u306fA,B\u306e\u500b\u6570\u306e\u30d0\u30e9\u30f3\u30b9\u3092\u898b\u3066\uff0c\u5c11\u306a\u3044\u65b9\u306b\u5165\u308c\u3066\u3044\u304f\uff0e\n\u3053\u308c\u306f2SAT\u3060\u306801\u306e\u3069\u3061\u3089\u3067\u3082\u826f\u3044\u5024\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u8a08\u7b97\u304b\u3089\u4e88\u3081\u907f\u3051\u3066\u304a\u304f.\n\n\n\u3053\u308c\u4ee5\u5916\u306b\u3082\u6c17\u3092\u3064\u3051\u308b\u30d1\u30bf\u30fc\u30f3\u304c\u3042\u3063\u3066\uff0c\na\u3068b,a\u3068c\nd\u3068e,d\u3068f\n\u304c\u540c\u3058\u5834\u6240\u306b\u306a\u3089\u306a\u3044\u3068\u3044\u3046\u6761\u4ef6\u306e\u3068\u304d\uff0c\naef-bcd\n\u306e\u304a\u3088\u3046\u306b\u5206\u3051\u305f\u3044\u304c\nad-bcef\n\u306e\u3088\u3046\u306b\u3082\u5206\u3051\u3089\u308c\u3066\u3057\u307e\u3046\uff0e\n\nuf\u3068\u304b\u3067\u4e0a\u624b\u3044\u611f\u3058\u306b\u7ba1\u7406\u3067\u304d\u308b\u304b\u306a?\n\"\"\"\n\nfrom collections import defaultdict\nclass UnionFind:\n    def __init__(self, N: int):\n        \"\"\"\n        N:\u8981\u7d20\u6570\n        root:\u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8.\n             \u305f\u3060\u3057, root[x] < 0 \u306a\u3089\u305d\u306e\u9802\u70b9\u304c\u6839\u3067-root[x]\u304c\u6728\u306e\u8981\u7d20\u6570.\n        rank:\u30e9\u30f3\u30af\n        \"\"\"\n        self.N = N\n        self.root = [-1] * N\n        self.rank = [0] * N\n\n    def __repr__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    def find(self, x: int):\n        \"\"\"\u9802\u70b9x\u306e\u6839\u3092\u898b\u3064\u3051\u308b\"\"\"\n        if self.root[x] < 0:\n            return x\n        else:\n            while self.root[x] >= 0:\n                x = self.root[x]\n            return x\n\n    def union(self, x: int, y: int):\n        \"\"\"x,y\u304c\u5c5e\u3059\u308b\u6728\u3092union\"\"\"\n        # \u6839\u3092\u6bd4\u8f03\u3059\u308b\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044.\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\u306frank\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b.\n        # rank\u304c\u540c\u3058\u6642\u306frank\u30921\u5897\u3084\u3059\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def same(self, x: int, y: int):\n        \"\"\"x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\"\"\"\n        return self.find(x) == self.find(y)\n\n    def count(self, x):\n        \"\"\"\u9802\u70b9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\"\"\"\n        return - self.root[self.find(x)]\n\n    def members(self, x):\n        \"\"\"x\u304c\u5c5e\u3059\u308b\u6728\u306e\u8981\u7d20\u3092\u5217\u6319\"\"\"\n        _root = self.find(x)\n        return [i for i in range(self.N) if self.find == _root]\n\n    def roots(self):\n        \"\"\"\u68ee\u306e\u6839\u3092\u5217\u6319\"\"\"\n        return [i for i, x in enumerate(self.root) if x < 0]\n\n    def group_count(self):\n        \"\"\"\u9023\u7d50\u6210\u5206\u306e\u6570\"\"\"\n        return len(self.roots())\n\n    def all_group_members(self):\n        \"\"\"{\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306e\u30c7\u30d5\u30a9\u30eb\u30c8\u30c7\u30a3\u30af\u30c8\u3092\u8fd4\u3059\"\"\"\n        dd = defaultdict(list)\n        for i in range(N):\n            root=self.find(i)\n            dd[root].append(i)\n        return dd\n\n\nclass Scc_graph:\n\n    def __init__(self, N):\n        self.N = N\n        self.edges = []\n\n    def csr(self):\n        start = [0]*(self.N+1)\n        elist = [0]*len(self.edges)\n        for v, w in self.edges:\n            start[v+1] += 1\n        for i in range(1, self.N+1):\n            start[i] += start[i-1]\n        counter = start.copy()\n        for v, w in self.edges:\n            elist[counter[v]] = w\n            counter[v] += 1\n        self.start = start\n        self.elist = elist\n\n    def add_edge(self, v, w):\n        self.edges.append((v, w))\n\n    def scc_ids(self):\n        self.csr()\n        N = self.N\n        now_ord = group_num = 0\n        visited = []\n        low = [0]*N\n        order = [-1]*N\n        ids = [0]*N\n        parent = [-1]*N\n        stack = []\n        for i in range(N):\n            if order[i] == -1:\n                stack.append(~i)\n                stack.append(i)\n                while stack:\n                    v = stack.pop()\n                    if v >= 0:\n                        if order[v] == -1:\n                            low[v] = order[v] = now_ord\n                            now_ord += 1\n                            visited.append(v)\n                            for i in range(self.start[v], self.start[v+1]):\n                                to = self.elist[i]\n                                if order[to] == -1:\n                                    stack.append(~to)\n                                    stack.append(to)\n                                    parent[to] = v\n                                else:\n                                    low[v] = min(low[v], order[to])\n                    else:\n                        v = ~v\n                        if low[v] == order[v]:\n                            while True:\n                                u = visited.pop()\n                                order[u] = N\n                                ids[u] = group_num\n                                if u == v:\n                                    break\n                            group_num += 1\n                        if parent[v] != -1:\n                            low[parent[v]] = min(low[parent[v]], low[v])\n        for i, x in enumerate(ids):\n            ids[i] = group_num-1-x\n\n        return group_num, ids\n\n    def scc(self):\n        group_num, ids = self.scc_ids()\n        groups = [[] for _ in range(group_num)]\n        for i, x in enumerate(ids):\n            groups[x].append(i)\n        return groups\n\n\nclass Two_sat:\n    def __init__(self, N):\n        self.N = N\n        self.answer = []\n        self.scc = Scc_graph(2*N)\n\n    \"\"\"\n    A[i]=a,A[j]=b\n    (a\u2228b)\u3092\u8ffd\u52a0\u3057\u305f\u3044\u3068\u304d\uff0c(f,g)=(1,1)\n    \u5426\u5b9a\u3057\u305f\u3082\u306e\u3092\u5165\u308c\u305f\u3044\u6642f\u3084g\u30920\u306b\u5909\u66f4\u3059\u308b\n    \"\"\"\n    def add_clause(self, i, f, j, g):\n        # assert 0 <= i < self.N\n        # assert 0 <= j < self.N\n        self.scc.add_edge(2*i+(f == 0), 2*j+(g == 1))\n        self.scc.add_edge(2*j+(g == 0), 2*i+(f == 1))\n\n    def satisfiable(self):\n        _, ids = self.scc.scc_ids()\n        self.answer.clear()\n        for i in range(self.N):\n            if ids[2 * i] == ids[2 * i + 1]:\n                self.answer.clear()\n                return False\n            self.answer.append(ids[2*i] < ids[2*i+1])\n        return True\n\n# def warshall_floyd(d):\n#     #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n#     N=len(d)\n#     for k in range(N):\n#         for i in range(N):\n#             for j in range(N):\n#                 d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n#     return d\n#################################################\n\n\nN,M=MI()\ninf = N+5\nd=[[inf]*N for _ in range(N)]\nfor i in range(N):\n    d[i][i]=0\n\nfor _ in range(M):\n    a,b=MI()\n    a-=1\n    b-=1\n    d[a][b]=1\n    d[b][a]=1\n\n# \u8ddd\u96e2\u304c1\u304b\u5426\u304b\u3060\u3051\u308f\u304b\u308c\u3070\u826f\u3044\u306e\u3067\uff0c\u3053\u308c\u3044\u3089\u306a\u3044\n# d=warshall_floyd(d)\n\n# for i in range(N):\n#     print(d[i])\n\ndef calc(x):\n    return (x*(x-1))//2\n\nuf=UnionFind(N)\nfor i in range(N):\n    for j in range(i+1,N):\n        if d[i][j]>1:\n            uf.union(i,j)\n            # print(i,j)\n\nroots=uf.roots()\nNr=len(roots)\nG=[[]for _ in range(Nr)]\n\nfrom collections import defaultdict\ndd = defaultdict(int)\ncnt=0\nfor v in roots:\n    dd[v]=cnt\n    cnt+=1\n    \n# print(roots,Nr)\n\nfor i in range(N):\n    r=uf.find(i)\n    rnum=dd[r]\n    \n    # print(i,r,rnum)\n    G[rnum].append(i)\n\n\n\nallOK=0#A,B\u3069\u3061\u3089\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5165\u308c\u3066\u3082\u554f\u984c\u306a\u3044\u3082\u306e\n\n\"\"\"\n\u3068\u308a\u3042\u3048\u305a\uff0c\u9023\u7d50\u6210\u5206\u6bce\u306b2SAT\u3059\u308b\uff0e\na\u500b,b\u500b(a<=b)\n\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u3089\u308c\u308b\u3068\u3057\u3066\uff0c\u3053\u308c\u3092A,B\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u3069\u3046\u3075\u308a\u5206\u3051\u308b\u304b.\n= (a,b)2\u3064\u306e\u6570\u5b57\u306e\u7d44\u307f\u304c\u5927\u91cf\u306b\u3042\u3063\u3066\uff0c\u305d\u308c\u3089\u3092\u632f\u308a\u5206\u3051\u3066\u5dee\u304c\u5c0f\u3055\u304f\u306a\u308b\u3088\u3046\u306b\u9811\u5f35\u308c\u3070\u826f\u3044\u306f\u305a\n\n\u4e21\u65b9\u306ba\u3092\u52a0\u7b97\u3057\u3066\uff0c\u5dee\u5206(b-a)\u3092\u8a18\u61b6\u3057\u3066\u304a\u304d\uff0c\u3042\u3068\u3067\u3069\u3063\u3061\u306b\u632f\u308a\u5206\u3051\u308b\u304b\u8003\u3048\u308b\n\"\"\"\nD=[]#A,B\u30b0\u30eb\u30fc\u30d7\u306e\u5dee\nS1=0\nS2=0\n\n\n\nfor g in G:\n    Ng=len(g)\n    if Ng==1:\n        allOK+=1\n        continue\n    \n    g.sort()\n    ts=Two_sat(Ng)\n    \n    # print(g)\n    \n    for i in range(Ng):\n        for j in range(i+1,Ng):\n            a=g[i]\n            b=g[j]\n            if d[a][b]!=1:\n                ts.add_clause(i,0,j,0)\n                ts.add_clause(i,1,j,1)\n            \n    if not ts.satisfiable():\n        print((-1))\n        return\n        \n    a=sum(ts.answer)\n    b=Ng-a\n    \n    S1+=min(a,b)\n    S2+=min(a,b)\n    \n    if a!=b:\n        D.append(abs(a-b))\n    \n    \n# \u3042\u3068\u306fD\u3092\u3069\u3046\u5272\u308a\u632f\u308b\u304b\uff0e\n# \u3053\u308c\u306f\uff0cD\u5185\u306e\u6570\u5b57\u3092+/-\u306e\u3069\u3061\u3089\u304b\u7b26\u53f7\u3092\u9078\u3093\u3067\u8db3\u3057\u3066\u3044\u304d\uff0c\u305d\u306e\u7d50\u679c\u30920\u306b\u8fd1\u3065\u3051\u305f\u3044\u3068\u3044\u3046\u554f\u984c\u306b\u5e30\u7740\uff0e\u6570\u5b57\u304c\u5c0f\u3055\u3044\u306e\u3067dp\u3067\u3067\u304d\u308b.\nNd=len(D)\n\ngeta=1000\ndp=[[0]*(geta*2+1) for _ in range(Nd+1)]\ndp[0][geta]=1\nfor i,num in enumerate(D):\n    for j in range(geta*2+1):\n        if dp[i][j]:\n            dp[i+1][j-num]=1\n            dp[i+1][j+num]=1\n            \ndiff=geta\nfor j in range(geta+1):\n    if dp[-1][j]:\n        diff=min(diff,\n                 abs(j-geta))\n        \n# print(D)\n# print(diff)\n\nSd=sum(D)\ns11=(Sd-diff)//2\ns12=Sd-s11\n\n\n# S1<=S2\nS1+=s11\nS2+=s12\n\nds=S2-S1\nif ds>allOK:\n    ans=calc(S2)+calc(S1+allOK)\nelse:\n    aa=N//2\n    bb=N-aa\n    ans=calc(aa)+calc(bb)\n    \n    \n# \nprint(ans)\n    \n\n\n\n\n\n\n\n", "import sys\nN, M = list(map(int,input().split()))\n\nI = [[0 for _ in range(N)] for _ in range(N)]\nfor _ in range(M):\n  a, b = list(map(int,input().split()))\n  a -= 1\n  b -= 1\n  I[a][b] = 1\n  I[b][a] = 1\nfor a in range(N):\n  I[a][a] = 1\n# 0\u3092\u8fba\u3068\u3059\u308b\u30b0\u30e9\u30d5\u304c\u4e8c\u90e8\u30b0\u30e9\u30d5\u304b\u5426\u304b\u5224\u5b9a\n#print(*I, sep=\"\\n\")  \n  \n# \u5404\u9023\u7d50\u6210\u5206\u306e\u9802\u70b9\u6570\nR = []\nB = []\n\nvis = set()\n\ndef dfs(s, c):# 0\u3092\u8fba\u3068\u3059\u308b\u30b0\u30e9\u30d5\u304c\u4e8c\u90e8\u30b0\u30e9\u30d5\u304b\u5426\u304b\u3092\u3001\u59cb\u70b9s, \u521d\u671f\u8272c\u306eBFS\u3067\u5224\u5b9a\n  adj = I[s]\n  tmp = True\n  r_ct = 0\n  b_ct = 0\n  clr[s] = c\n  for p in range(N):\n    if adj[p] == 1: # \u96a3\u63a5\u3057\u3066\u306a\u3044\n      continue\n    if p in vis: \n      if clr[p] != 1-c:\n        #print(s, p)\n        return False\n      continue\n    else:\n      vis.add(p)\n      if not dfs(p, 1-c):\n        return False\n  return True\n  \n  \n  \n# \u4e8c\u90e8\u30b0\u30e9\u30d5\u304b\u3044\u306a\u304b\u3068\u3001\u5404\u9023\u7d50\u6210\u5206\u306e\u8272\u3054\u3068\u306e\u6570\u3092\u5224\u5b9a\nvis = set()\nans = 0\nused_edge = 0\nfor s in range(N):\n  if s in vis: continue\n  R.append(0)\n  B.append(0)\n  clr = {}\n  vis.add(s)\n  if not dfs(s, 0):\n    print((-1)); return;\n  #print(clr)\n  for p in clr:\n    if clr[p] == 0:\n      R[-1] += 1\n    else:\n      B[-1] += 1\n  for p in clr:\n    for q in clr:\n      if p != q and I[p][q] == 1: \n        used_edge += 1\n        if clr[p] == clr[q]:\n          ans += 1\n  #print(ans)\n        \n#print(R)\n#print(B)\n      \n# \u6700\u5927\u5024 : a_i*b_j\u306e\u975e\u5bfe\u89d2\u548c\u306e\u534a\u5206\u3067\u3001a_i\u306e\u548c\u304cN/2\u306b\u6700\u3082\u8fd1\u3044\u5834\u5408\nDP = 1\nfor i in range(len(R)):\n  DP = (DP << R[i]) | (DP << B[i])\n\ni = 0\nex = []\nwhile DP > 0:\n  if DP % 2 == 1:\n    ex.append(i)\n  i += 1\n  DP >>= 1\n#print(ex)  \nex.sort(key = lambda x: abs(2*x-N))\n#print(ex[0])\ntmp = ex[0] * (N - ex[0])\nfor i in range(len(R)):\n  tmp -= R[i]*B[i]\n#print(used_edge)\n#print(tmp)\n#print(2*M - used_edge)\nans //= 2\nans += (2*M - used_edge)//2 - tmp\n  \nprint(ans)\n  \n  \n\n  \n  \n", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nG = [set() for _ in range(N)]\nfor _ in range(M):\n    A, B = map(int, input().split())\n    A -= 1\n    B -= 1\n    G[A].add(B)\n    G[B].add(A)\n\nG_comp = [[] for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if i != j and j not in G[i]:\n            G_comp[i].append(j)\n\ncolor = [-1] * N\nA = []\ndp = set([0])\nfor i in range(N):\n    if color[i] != -1:\n        continue\n    cnt = [1, 0]\n    color[i] = 0\n    stack = [i]\n    while stack:\n        v = stack.pop()\n        for u in G_comp[v]:\n            if color[u] == -1:\n                color[u] = 1 - color[v]\n                stack.append(u)\n                cnt[color[u]] += 1\n            if color[u] == color[v]:\n                print(-1)\n                return\n    ndp = set()\n    for a in dp:\n        ndp.add(a + cnt[0])\n        ndp.add(a + cnt[1])\n    dp = ndp\nans = float('inf')\nfor a in dp:\n    ans = min(ans, a * (a - 1) // 2 + (N - a) * (N - a - 1) // 2)\nprint(ans)"]
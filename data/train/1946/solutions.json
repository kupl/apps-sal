["from collections import defaultdict, deque\n from heapq import merge\n from itertools import islice\n \n class Twitter:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.id2tweets = defaultdict(deque)\n         self.id2follows = defaultdict(set)\n         self.uid = 0\n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         self.id2tweets[userId].appendleft((self.uid, tweetId))\n         self.uid -= 1\n         #print(userId, 'POST', tweetId, self.id2tweets)\n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         #print('GET', userId, self.id2tweets, self.id2follows)\n         tweets = heapq.merge(*(self.id2tweets[u] for u in self.id2follows[userId] | {userId}))\n         return [tweet_id for _, tweet_id in islice(tweets, 10)]\n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         self.id2follows[followerId].add(followeeId)\n         #print(followerId, 'FOLLOW', followeeId, self.id2follows)\n \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         self.id2follows[followerId].discard(followeeId)\n         #print(followerId, 'UNFOLLOW', followeeId, self.id2follows)\n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)", "class Twitter(object):\n \n     def __init__(self):\n         self.timer = itertools.count(step=-1)\n         self.tweets = collections.defaultdict(collections.deque)\n         self.followees = collections.defaultdict(set)\n \n     def postTweet(self, userId, tweetId):\n         self.tweets[userId].appendleft((next(self.timer), tweetId))\n \n     def getNewsFeed(self, userId):\n         tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\n         return [t for _, t in itertools.islice(tweets, 10)]\n \n     def follow(self, followerId, followeeId):\n         self.followees[followerId].add(followeeId)\n \n     def unfollow(self, followerId, followeeId):\n         self.followees[followerId].discard(followeeId)\n         \n \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)\n", "class User:\n     \n     def __init__(self,uid):\n         self.uid=uid\n         self.news =[]\n         self.followee=set()\n         \n     def follow(self,followId):\n         self.followee.add(followId)\n     \n     def unfollow(self,followId):\n         if followId in self.followee:\n             self.followee.remove(followId)\n             \n     def post(self,newsId):\n         \n         self.news.append(newsId)\n         \n class Twitter:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.user={}\n         self.tweet={}\n         self.tweetOrder=0\n         \n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         if userId not in self.user:\n             self.user[userId]=User(userId)\n         self.tweet[self.tweetOrder]=tweetId\n         self.user[userId].post(self.tweetOrder)\n         self.tweetOrder+=1\n         \n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         if userId not in self.user:\n             return []\n         newsFeed=[]\n         relatedUser=[self.user[userId]]+[self.user[id] for id in self.user[userId].followee]\n         for person in relatedUser:\n             length=len(person.news)\n             for i in range(min(10,length)):\n                 if len(newsFeed)<10:\n                     heapq.heappush(newsFeed,person.news[length-1-i])\n                 else:\n                     heapq.heappushpop(newsFeed,person.news[length-1-i])\n         res=[]\n         while newsFeed:\n             res.append(heapq.heappop(newsFeed))\n         return [self.tweet[tweetOrder] for tweetOrder in res[::-1]]\n         \n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId != followeeId:\n             if followerId not in self.user:\n                 self.user[followerId]=User(followerId)\n             if followeeId not in self.user:\n                 self.user[followeeId]=User(followeeId)\n             self.user[followerId].follow(followeeId)\n         \n \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId in self.user and followeeId in self.user:\n             self.user[followerId].unfollow(followeeId)\n         \n \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)", "import heapq\n class Twitter:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.users = {}\n         self.twitters = {}\n         self.time = 0\n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         if userId in self.twitters:\n             self.twitters[userId].append([-self.time, tweetId])\n             self.time += 1\n         else:\n             self.twitters[userId] = [[-self.time, tweetId]]\n             self.time+= 1\n        \n         if userId not in self.users:\n             self.users[userId] = set([])\n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         \n         if userId not in self.users:\n             return([])\n             \n         userIds = self.users[userId]\n         \n         if not userIds:\n             userIds = set([])\n         userIds.add(userId)\n         newsArr = []\n         for uId in userIds:\n             if uId not in self.twitters:\n                 newsArr.append([])\n             else:\n                 newsArr.append(self.twitters[uId][::-1])\n         out = []\n         heap = []\n         for i in range(len(newsArr)):\n             if newsArr[i]:\n                 heapq.heappush(heap, [newsArr[i][0][0], newsArr[i][0][1], i, 0])\n         while len(out) < 10:\n             if len(heap) == 0:\n                 break\n             time,tId, arr, index = heapq.heappop(heap)\n             out.append(tId)\n             if index+1 < len(newsArr[arr]):\n                 heapq.heappush(heap, [newsArr[arr][index+1][0],newsArr[arr][index+1][1],arr, index+1])\n                 \n         \n         return([num for num in out])\n         \n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n    \n         if followerId in self.users:\n             self.users[followerId].add(followeeId)        \n         else:\n             self.users[followerId] = set([])\n             self.users[followerId].add(followeeId) \n             \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId in self.users:\n             if followeeId in self.users[followerId]:\n                 self.users[followerId].remove(followeeId)\n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)", "from heapq import heappush, heappop\n \n class Twitter:\n     time_stamp = 0\n     class User:\n         def __init__(self, user_id):\n             self.user_id = user_id\n             self.followers = set()\n             self.follow(user_id)\n             self.tweet_head = None\n             \n         def follow(self, follower_id):\n             self.followers.add(follower_id)\n         \n         def unfollow(self, follower_id):\n             if follower_id in self.followers:\n                 self.followers.remove(follower_id)\n                 \n         def post(self, new_tweet):\n             nxt = self.tweet_head\n             self.tweet_head, new_tweet.next = new_tweet, nxt\n     \n     class Tweet:\n         def __init__(self, tw_id, ts):\n             self.tweet_id = tw_id\n             self.timestamp = ts\n             self.next = None            \n     \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.user_map = {}\n         \n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         if userId not in self.user_map:\n             self.user_map[userId] = self.User(userId)\n         user = self.user_map[userId]\n         user.post(self.Tweet(tweetId, self.time_stamp))\n         self.time_stamp += 1\n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         ans, pq = [], []\n         if userId not in self.user_map:\n             return ans\n         user = self.user_map[userId]\n         for follower in user.followers:\n             tw = self.user_map[follower].tweet_head\n             if tw:\n                 heappush(pq, (-tw.timestamp, tw))\n         n = 10\n         while pq and n > 0:\n             ts, tw = heappop(pq)\n             ans.append(tw.tweet_id)\n             nxt = tw.next\n             if nxt:                \n                 heappush(pq, (-nxt.timestamp, nxt))\n             n -= 1\n         return ans\n             \n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId not in self.user_map:\n             self.user_map[followerId] = self.User(followerId)            \n         if followeeId not in self.user_map:\n             self.user_map[followeeId] = self.User(followeeId)\n         self.user_map[followerId].follow(followeeId)\n \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId not in self.user_map or followeeId not in self.user_map or followerId == followeeId:\n             return\n         self.user_map[followerId].unfollow(followeeId)\n \n         \n \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)", "import queue\n import heapq\n     \n class Twitter:\n     def _addUser(self, userId):\n         if userId not in self.tweets:\n             self.tweets[userId] = []\n         if userId not in self.graph:\n             self.graph[userId] = set([userId])\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.graph = {}\n         self.tweets = {}\n         self.now = 0\n         \n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         self.now -= 1\n         self._addUser(userId)\n         self.tweets[userId].append((self.now, tweetId))\n         self.follow(userId, userId)\n         \n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         self._addUser(userId)\n         h = []\n         for followee in self.graph[userId]:\n             numtweets = len(self.tweets[followee])\n             if numtweets > 10:\n                 for tweet in self.tweets[followee][numtweets - 10:]:\n                     h.append(tweet)\n             else:\n                 for tweet in self.tweets[followee]:\n                     h.append(tweet)\n         heapq.heapify(h)\n         lst = []\n         while len(h) > 0 and len(lst) < 10:\n             elem = heapq.heappop(h)\n             lst.append(elem[1])\n         return lst\n                 \n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         self._addUser(followerId)\n         self._addUser(followeeId)\n         self.graph[followerId].add(followeeId)\n         \n \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         self._addUser(followerId)\n         if followeeId != followerId:\n             self.graph[followerId].discard(followeeId)\n \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)", "## Basic Ideas: Two hashmap + PriorityQueue\n ##     tweet_dict. id -> tweet_list\n ##     follow_dict: id -> id set\n ##\n ## Notice: people may follow themselves\n ##\n ## Assumption: people tweet with post id always grows\n ##\n ## Complexity: getNewsFeed\n ##       Time O(n*log(n)) Space O(n). n = total tweets involved\n import collections, copy\n class Twitter:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.id = 0\n         self.tweet_dict = collections.defaultdict(lambda: [])\n         self.follow_dict = collections.defaultdict(lambda: set([]))\n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         self.tweet_dict[userId].append((self.id, tweetId))\n         self.id += 1\n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         q = []\n         # min heap\n         heapq.heapify(q)\n         for (id, tweetId) in self.tweet_dict[userId]:\n             heapq.heappush(q, (id, tweetId))\n             if len(q) > 10: heapq.heappop(q)\n         for followee in self.follow_dict[userId]:\n             for (id, tweetId) in self.tweet_dict[followee]:\n                 heapq.heappush(q, (id, tweetId))\n                 if len(q) > 10: heapq.heappop(q)\n         res = []\n         while len(q) != 0:\n             (id, tweetId) = heapq.heappop(q)\n             res.insert(0, tweetId)\n         return res\n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId == followeeId: return\n         if followeeId not in self.follow_dict[followerId]:\n             self.follow_dict[followerId].add(followeeId)\n \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         if followerId == followeeId: return\n         if followeeId in self.follow_dict[followerId]:\n             self.follow_dict[followerId].remove(followeeId)\n \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)", "class Twitter:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         # e.g. [{\"user1\":\"tweet1\"}, {\"user2\":\"tweet2\"},...] - fast tweets access\n         self.tweets = []\n         \n         # e.g. {\"user1\":[0,2,4,5], \"user2\":[1,3]} - fast user-tweets access\n         self.userTweets = {}\n         \n         # e.g. {\"user1\":[0,1,2,3,4,5]}\n         self.feeds = {}\n         \n         # e.g. {user2:[1]}\n         self.followers = {}\n         self.followees = {}\n         # eg. {(user1,user2):True}\n         self.relations = {}\n \n     def postTweet(self, userId, tweetId):\n         \"\"\"\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         \"\"\"\n         # create tweet\n         self.tweets.append({\"userId\":userId, \"tweetId\":tweetId})\n         lastIndex = len(self.tweets)-1\n         \n         # create user tweet list\n         if userId not in self.userTweets:\n             self.userTweets[userId] = []\n         self.userTweets[userId].append(lastIndex)\n         \n         # update feeds\n         followers = self.followers.get(userId, [])\n         for followerId in [userId]+followers:\n             # add tweet, reverse sort, cut recent 10\n             self.feeds[followerId] = ([tweetId] + self.feeds.get(followerId, []))[:10]\n \n     def getNewsFeed(self, userId):\n         \"\"\"\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         \"\"\"\n         return self.feeds.get(userId, [])\n         \n \n     def follow(self, followerId, followeeId):\n         \"\"\"\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"        \n         # no-op case\n         if (followerId, followeeId) in self.relations or followerId == followeeId:\n             return\n         else:\n             self.relations[(followerId, followeeId)] = True\n         \n         #  add follower, create new list if not exist\n         if followeeId not in self.followers:\n             self.followers[followeeId] = []\n         self.followers[followeeId].append(followerId)\n         \n         # add followee\n         if followerId not in self.followees:\n             self.followees[followerId] = []\n         self.followees[followerId].append(followeeId)\n          \n         # update user's feed\n         self.updateFeed(followerId)        \n \n     def unfollow(self, followerId, followeeId):\n         \"\"\"\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         \"\"\"\n         # no-op case\n         if (followerId, followeeId) not in self.relations:\n             return\n         else:\n             del self.relations[(followerId, followeeId)]\n         \n         # remove relation        \n         self.followers[followeeId].remove(followerId)\n         self.followees[followerId].remove(followeeId)\n         \n         # skip update if followee didn't tweet\n         if not self.userTweets.get(followeeId, []):\n             return\n         \n         # full rebuild feed\n         self.updateFeed(followerId)\n         \n     def updateFeed(self, userId):\n         # full rebuild feed\n         followers = self.followees.get(userId, [])\n         indexes = []\n         for followeeId in [userId]+followers:\n             if self.userTweets.get(followeeId, []):\n                 indexes += self.userTweets.get(followeeId, [])\n                 indexes = sorted(indexes, reverse=True)[0:10]        \n                 \n         # set new feed\n         self.feeds[userId] = [self.tweets[idx]['tweetId'] for idx in indexes]     \n         \n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)\n"]
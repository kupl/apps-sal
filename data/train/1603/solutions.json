["# Bartek Kostka\n#  You are not prepared!\n\n#include \"bits/stdc++.h\"\n\nn = int(input())\nW = {}\nfor i in range(n):\n    adr = input()\n    adr = adr.split(\"/\")\n    if adr[-1] == '':\n        adr[-1] = '?'\n    domena = \"/\".join(adr[:3])\n    adres = \"/\".join(adr[3:])\n    #print(domena, adres)\n    if domena not in W:\n        W[domena] = set()\n    W[domena].add(adres)\n\nE = {}\nfor key, ele in list(W.items()):\n    #print(key, ele)\n    lele = \"#\".join(sorted(list(ele)))\n    if lele not in E:\n        E[lele] = []\n    E[lele].append(key)\n\nres = 0\nfor key, ele in list(E.items()):\n    if len(ele) > 1:\n        res += 1\n\nprint(res)\nfor key, ele in list(E.items()):\n    if len(ele) > 1:\n        print(\" \".join(ele))\n", "n = int(input())\n\nd = dict()\n\nfor _ in range(n):\n    s = input()\n    slash = s.find('/', 7)\n    if slash == -1:\n        slash = len(s)\n    host = s[:slash]\n    query = s[slash:]\n    d.setdefault(host, set()).add(query)\n    \nd1 = dict()\nfor k, v in d.items():\n    f = frozenset(v)\n    d1.setdefault(f, set()).add(k)\n    \nres = {k: v for k, v in d1.items() if len(v) > 1}\nprint(len(res))\nfor block in res.values():\n    print(' '.join(block))", "import sys\nfrom collections import defaultdict\n\n# sys.stdin = open(\"ivo.in\")\nn = int(sys.stdin.readline())\n\nh = defaultdict(set)\nfor iter in range(n):\n  entry = sys.stdin.readline().rstrip() + \"/\"\n  path_start = 7 + entry[7:].index('/')\n  hostname = entry[:path_start]\n  path = entry[path_start:]\n  h[hostname].add(path)\n\nres = defaultdict(list)\nfor k, v in h.items():\n  res[frozenset(v)].append(k)\n\noutput = []\nfor v in res.values():\n  if len(v) > 1:\n    output.append(\" \".join(v))\n\nprint(len(output))\nfor u in output:\n  print(u)", "\nimport sys\n\nfrom urllib.parse import urlparse\nimport itertools as itt\n\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n\n    links = [sys.stdin.readline().strip() for i in range(n)]\n\n\n\n    host_queries = {}\n\n\n    for link in links:\n        p = urlparse(link)\n\n        host = \"http://\" + p.netloc\n        query = p.path\n\n        if not host in host_queries:\n            host_queries[host] = set()\n\n        host_queries[host].add(query)\n\n\n    hosts = list(host_queries.keys())\n\n    hosts = list(sorted(hosts, key=lambda h: \"-\".join(sorted(host_queries[h]))))\n\n    groups = []\n    for key, group in itt.groupby(hosts, key=lambda h: \"-\".join(sorted(host_queries[h]))):\n        g = list(group)\n\n\n        if len(g) < 2:\n            continue\n\n        groups.append(g)\n\n    print(len(groups))\n    for g in groups:\n        print(\" \".join(g))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nhosts = dict()\nfor i in range(n):\n    inp = input()\n    pos = inp.find(\"/\", 7)\n    if pos == -1: pos = len(inp)\n    hostName = inp[:pos]\n    path = inp[pos:]\n    if hostName not in hosts:\n        hosts[hostName] = set()\n    hosts[hostName].add(path)\n\ngroups = dict()\nfor name in hosts.keys():\n    paths = tuple(sorted(hosts[name]))\n    if paths not in groups:\n        groups[paths] = []\n    groups[paths].append(name)\n\nans = []\nfor group in groups.values():\n    if len(group) > 1:\n        ans.append(group)\n\nprint(len(ans))\nfor group in ans:\n    print(\" \".join(group))", "3\n\nimport functools\nimport itertools\nimport operator\n\n\ndef split(address):\n\taddress = address[7:]\n\tp = address.find('/')\n\tif p == -1:\n\t\treturn address, ''\n\n\treturn address[:p], address[p:]\n\n\ndef set_key(addr1, addr2):\n\tpages1, pages2 = addr1[1], addr2[1]\n\tl1 = len(pages1)\n\tl2 = len(pages2)\n\tif l1 != l2:\n\t\treturn l2 - l1\n\n\tfor page1, page2 in zip(pages1, pages2):\n\t\tif page1 < page2: return -1\n\t\tif page1 > page2: return 1\n\n\treturn 0;\n\n\ndef solve(addresses):\n\taddresses = list(map(split, addresses))\n\n\tm = dict()\n\tfor domain, page in addresses:\n\t\tif domain in m:\n\t\t\tm[domain].add(page)\n\t\telse:\n\t\t\tm[domain] = {page}\n\n\tl = [(domain, sorted(pages)) for domain, pages in list(m.items())]\n\n\tl.sort(key=functools.cmp_to_key(set_key))\n\n\tgroups = []\n\n\tgb = itertools.groupby(l, key=operator.itemgetter(1))\n\tfor key, group in gb:\n\t\tgroup_domains = ['http://'+d for d,ps in group]\n\t\tif(len(group_domains) > 1):\n\t\t\tgroups.append(group_domains)\n\n\t# print(groups)\n\treturn groups\n\n\ndef main():\n\tn = int(input())\n\taddresses = [None]*n\n\n\tfor i in range(n):\n\t\taddresses[i] = input()\n\n\tgroups = solve(addresses)\n\n\tprint(len(groups))\n\tfor group in groups:\n\t\tprint(' '.join(group))\n\n\ndef test():\n\t# addresses = \"\"\"\n\t# \thttp://abacaba.ru/test\n\t# \thttp://abacaba.ru/\n\t# \thttp://abacaba.com\n\t# \thttp://abacaba.com/test\n\t# \thttp://abacaba.de/\n\t# \thttp://abacaba.ru/test\n\t# \thttp://abacaba.de/test\n\t# \thttp://abacaba.com/\n\t# \thttp://abacaba.com/t\n\t# \thttp://abacaba.com/test\n\t# \t\"\"\".split()\n\t# addresses = \"\"\"\n\t# \thttp://c\n\t# \thttp://ccc.bbbb/aba..b\n\t# \thttp://cba.com\n\t# \thttp://a.c/aba..b/a\n\t# \thttp://abc/\n\t# \thttp://a.c/\n\t# \thttp://ccc.bbbb\n\t# \thttp://ab.ac.bc.aa/\n\t# \thttp://a.a.a/\n\t# \thttp://ccc.bbbb/\n\t# \thttp://cba.com/\n\t# \thttp://cba.com/aba..b\n\t# \thttp://a.a.a/aba..b/a\n\t# \thttp://abc/aba..b/a\n\t# \t\"\"\".split()\n\n\timport random\n\timport string\n\n\tn = 100000\n\n\taddresses = []\n\tfor i in range(n):\n\t\tdomain = ''.join([random.choice(string.ascii_lowercase) for dummy in range(5)])\n\t\tpage = ''.join([random.choice(string.ascii_lowercase) for dummy in range(5)])\n\t\taddresses.append('http://{}/{}'.format(domain, page))\n\n\tprint('Solving...')\n\ts = solve(addresses)\n\tprint(s)\n\n\ndef __starting_point():\n\t# test()\n\tmain()\n\n__starting_point()", "n = int(input())\nd = dict()\nfor i in range(n):\n    s = input().strip()\n    s = s[7:]\n    f = s.find('/')\n    if f != -1:\n        a = s[:f]\n        b = s[f:]\n    else:\n        a = s\n        b = ''\n    if a in d:\n        d[a].add(b)\n    else:\n        d[a] = {b}\nans = dict()\nfor i in d:\n    x = sorted(d[i])\n    x = list(x)\n    x = '*'.join(x)\n    d[i] = x\n    if x in ans:\n        ans[x].append(i)\n    else:\n        ans[x] = [i]\nans2 = []\nansc = 0\nfor i in ans:\n    if len(ans[i]) > 1:\n        ansc += 1\n        ans2.append(' '.join(map(lambda x: 'http://'+x, ans[i])))\nprint(ansc)\nfor i in ans2:\n    print(i)", "import re\n\nurl_parser = re.compile(r\"^http://([^/]+)(.*)\")\nwhile True:\n\ttry:\n\t\tk = int(input())\n\texcept EOFError:\n\t\tbreak\n\t\n\td = {}\n\tfor _ in range(k):\n\t\thostname, path = url_parser.findall(input())[0]\n\t\tif hostname in d:\n\t\t\td[hostname].add(path)\n\t\telse:\n\t\t\td[hostname] = set((path,))\n\t\n\td_reverse = {}\t\n\tfor hostname, pathset in d.items():\n\t\tthumb = \"_\".join(sorted(pathset))\n\t\tif thumb in d_reverse:\n\t\t\td_reverse[thumb].append(hostname)\n\t\telse:\n\t\t\td_reverse[thumb] = [hostname]\n\t\n\tans = [line for line in d_reverse.values() if len(line)>1]\n\tprint(len(ans))\n\tfor line in ans:\n\t\tprint(\" \".join(map(lambda x:\"http://\"+x, line)))", "n = int(input())\n\ndomains = {}\nfor _ in range(n):\n    request = input()[7:]\n\n    domain, sep, path = request.partition('/')\n\n    if domain in domains:\n        domains[domain].add(sep + path)\n    else:\n        domains[domain] = {sep + path}\n\npath_hashes = []\nfor domain, paths in list(domains.items()):\n    path_hashes.append(('|'.join(sorted(paths)), domain))\n\nsorted_hashes = sorted(path_hashes, key=lambda x: x[0])\n\nprevious_hash = None\nprevious_domains = []\ngroups = []\n\nfor path_hash, domain in sorted_hashes:\n    if previous_hash == path_hash:\n        previous_domains.append(domain)\n    else:\n        previous_hash = path_hash\n        if len(previous_domains) > 1:\n            groups.append(previous_domains)\n        previous_domains = [domain]\n\nif len(previous_domains) > 1:\n    groups.append(previous_domains)\n\nprint(len(groups))\nprint('\\n'.join([' '.join(['http://' + y for y in x]) for x in groups]))\n", "n=int(input())\nd={}; D={}; ans=[]\nfor _ in range(n): s=input()+'/'; t=s.find('/',7); d.setdefault(s[:t],set()).add(s[t:])\nfor k in d: D.setdefault(frozenset(d[k]),[]).append(k)\n[ans.append(D[k]) for k in D if len(D[k])>1]\nprint(len(ans))\nprint('\\n'.join(map(' '.join,ans)))", "\nP = 910519\nMOD =   32416190071\np = [1]\nfor i in range(1, 200010):\n    p.append((P * p[i - 1]) % MOD)\nn = int(input())\ns = list(set([input() for i in range(n)]))\nn = len(s)\nname = ['' for i in range(n)]\npath = ['' for i in range(n)]\nmp = {}\nfor i in range(n):\n    link = s[i]\n    j = link[7:].find('/')\n    if j != -1:\n        path[i] = link[j + 7:]\n        name[i] = link[:j + 7]\n    else:\n        name[i] = link\nfor i in range(n):\n    if path[i] not in mp:\n        mp[path[i]] = len(mp)\nh = {name[i] : 0 for i in range(n)}\nfor i in range(n):\n    h[name[i]] += p[mp[path[i]]]\ngp = {}\nfor key, val in list(h.items()):\n    if val in gp:\n        gp[val].append(key)\n    else:\n        gp[val] = [key]\nans = []\nfor key, val in list(gp.items()):\n    if len(val) > 1:\n        ans.append(val)\nprint(len(ans))\nfor a in ans:\n    print(' '.join(a))\n", "from itertools import groupby\nweb_addresses_number = int(input())\nprephix = \"http://\"\ndef split_address(address):\n    host = \"\"\n    path = \"\"\n    address = address[7:]\n    i = 0\n    while i < len(address) and address[i] != '/':\n        host += address[i]\n        i += 1\n    while i < len(address):\n        path += address[i]\n        i += 1\n    return (host, path)\nhosts = {}\nfor i in range(web_addresses_number):\n    host, path = split_address(input())\n    if host in hosts:\n        hosts[host].add(path)\n    else:\n        hosts[host] = {path}\ngroups = []\nhosts = {host:\"+\".join(sorted(hosts[host])) for host in hosts}\ngroping = groupby(sorted(hosts, key = lambda host: hosts[host]), key = lambda host: hosts[host])\nfor key, group in groping:\n    g = list(group)\n    if len(g) > 1:\n        groups.append(g)\nprint(len(groups))\n[print(\" \".join(map(lambda host: prephix + host, group))) for group in groups]\n", "n=int(input())\nd={}\nD={}\nfor i in range(n):\n    h,*p=(input()[7:]+'/').split('/')\n    d.setdefault(h,set()).add('/'.join(p))\nfor x in d: \n    t=tuple(sorted(d[x]))\n    D.setdefault(t,[]).append(x)\n\ndef ans():\n    for x in D:\n        if len(D[x])>1:\n            yield 'http://'+' http://'.join(D[x])\n\nprint(sum(1 for x in D if len(D[x])>1))\nprint('\\n'.join(ans()))", "n=int(input())\nd={}\nD={}\nfor i in range(n):\n    h,*p=(input()[7:]+'/').split('/')\n    d.setdefault(h,set()).add('/'.join(p))\nfor x in d: D.setdefault(frozenset(d[x]),[]).append(x)\n\ndef ans():\n    for x in D:\n        if len(D[x])>1:\n            yield 'http://'+' http://'.join(D[x])\n\nprint(sum(1 for x in D if len(D[x])>1))\nprint('\\n'.join(ans()))", "import sys\n\nd = dict()\nb='/'\nfor line in sys.stdin:\n\tline=line[:-1].split(b)\n\n\thost,coso=b.join(line[:3]), b.join(line[3:])\n\n\tif len(line)>3: coso='/'+coso\n\tif len(line)>1:\n\n\t\tif host in d: d[host].append(\"I\"+coso)\n\t\telse: d[host]=[\"I\"+coso]\n\nfor host in d:\n\tb = ','\n\td[host]=sorted(set(d[host]))\n\td[host]=b.join(d[host])\n\nd2=dict()\n\nfor host in d:\n\tif d[host] in d2: d2[d[host]].append(host)\n\telse:\td2[d[host]]=[host]\n\nprint(sum([len(d2[x])>1 for x in d2]))\n\nfor x in d2:\n\tif len(d2[x])>1:\n\t\tfor i in d2[x]: sys.stdout.write(i+' ')\n\t\tsys.stdout.write('\\n')\n", "import sys\n\nd = dict()\nb='/'\nfor line in sys.stdin:\n\tline=line[:-1].split(b)\n\n\thost,coso=b.join(line[:3]), b.join(line[3:])\n\n\tif len(line)>3: coso='/'+coso\n\tif len(line)>1:\n\n\t\tif host in d: d[host].append(\"I\"+coso)\n\t\telse: d[host]=[\"I\"+coso]\n\nfor host in d:\n\tb = ','\n\td[host]=sorted(set(d[host]))\n\td[host]=b.join(d[host])\n\nd2=dict()\n\nfor host in d:\n\tif d[host] in d2: d2[d[host]].append(host)\n\telse:\td2[d[host]]=[host]\n\nprint(sum([len(d2[x])>1 for x in d2]))\n\nfor x in d2:\n\tans = \"\"\n\tif len(d2[x])>1:\n\t\tfor i in d2[x]: ans+=i+' '\n\t\tprint (ans)\n", "import sys\nn = int(input())\n\ndomains = {}\nfor full_request in sys.stdin:\n    request = full_request[7:-1]\n\n    domain, sep, path = request.partition('/')\n\n    if domain in domains:\n        domains[domain].add(sep + path)\n    else:\n        domains[domain] = {sep + path}\n\npath_hashes = []\nfor domain, paths in list(domains.items()):\n    path_hashes.append(('|'.join(sorted(paths)), domain))\n\nsorted_hashes = sorted(path_hashes, key=lambda x: x[0])\n\nprevious_hash = None\nprevious_domains = []\ngroups = []\n\nfor path_hash, domain in sorted_hashes:\n    if previous_hash == path_hash:\n        previous_domains.append(domain)\n    else:\n        previous_hash = path_hash\n        if len(previous_domains) > 1:\n            groups.append(previous_domains)\n        previous_domains = [domain]\n\nif len(previous_domains) > 1:\n    groups.append(previous_domains)\n\nprint(len(groups))\nprint('\\n'.join([' '.join(['http://' + y for y in x]) for x in groups]))\n", "n=int(input())\n\nd={}; D={}; ans=[]\n\nfor _ in range(n): s=input()+'/'; t=s.find('/',7); d.setdefault(s[:t],set()).add(s[t:])\n\nfor k in d: D.setdefault(frozenset(d[k]),[]).append(k)\n\n{ans.append(D[k]) for k in D if len(D[k])>1}\n\nprint(len(ans))\n\nprint('\\n'.join(map(' '.join,ans)))\n\n\n\n# Made By Mostafa_Khaled\n"]
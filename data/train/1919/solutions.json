["class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         n = numCourses  \n         graph = {}\n         for post, pre in prerequisites:\n             if pre in graph:\n                 graph[pre].append(post)\n             else:\n                 graph[pre] = [post]\n         \n         WHITE = 0 # never explored. NOT CHECKED\n         GREY = 1 # in the stack, exploring. CHECKING\n         BLACK = 2 # finished explored and we know for a fact there's no loop originated from this. CHECKED\n         state = [WHITE for _ in range(0, n)]\n         \n         res = []\n         \n         def dfs(i):\n             state[i] = GREY\n             for child in graph.get(i, []):\n                 if state[child] == GREY:\n                     return False\n                 elif state[child] == WHITE:\n                     if not dfs(child):\n                         return False\n             state[i] = BLACK\n             res.insert(0, i)\n             return True\n         \n         for i in range(0, n):\n             if state[i] != BLACK:\n                 if not dfs(i):\n                     return []\n         return res\n", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         if numCourses <= 1:\n             return [0]\n         \n         if not prerequisites:\n             return [i for i in range(numCourses)]\n         \n         # create graph first\n         graph = [[] for _ in range(numCourses)]\n         for pair in prerequisites:\n             x,y = pair\n             graph[x].append(y)\n         \n         # call topo order\n         visited, visiting, topo = set(), set(), []\n         for i in range(numCourses):\n             if i not in visited:\n                 if not self.topoOrder(graph, i, visited, visiting, topo):\n                     return []\n         return topo\n             \n     def topoOrder(self, graph, start, visited, visiting, topo):\n         visited.add(start)\n         visiting.add(start)\n         adj_verts = graph[start]\n         for vert in adj_verts:\n             if vert in visiting:\n                 return False\n             elif vert not in visited:\n                 if not self.topoOrder(graph, vert, visited, visiting, topo):\n                     return False\n         if start in visiting:\n             visiting.remove(start)\n         topo.append(start)\n         return True\n             \n             \n", "class Solution:\n     def findOrder(self,numCourses,prerequisites):\n         graph=[[] for i in range(0,numCourses)];\n         for edge in prerequisites:\n             graph[edge[1]].append(edge[0]);\n \n         #print(graph);\n         mark=[0]*numCourses;\n         order=[];\n         for i in range(0,numCourses):\n             if mark[i]==0:\n                 if not self.DFS(graph,i,mark,order):\n                     return [];\n \n         res=[];\n         for i in range(len(order)-1,-1,-1):\n             res.append(order[i]);\n             \n         return res;\n \n \n \n     def DFS(self,graph,index,mark,order):\n         mark[index]=1;\n         for vertex in graph[index]:\n             if mark[vertex]==0:\n                 if not self.DFS(graph,vertex,mark,order):\n                     return False;\n             elif mark[vertex]==1:\n                 return False;\n \n         mark[index]=2;\n         order.append(index);\n         return True;\n", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         nums = [[] for _ in range(numCourses)]\n         du = [0] * numCourses\n         for end, start in prerequisites:\n             nums[start].append(end)\n             du[end] += 1\n         result = []\n         def dfs(idx):\n             du[idx] -= 1\n             result.append(idx)\n             for i in nums[idx]:\n                 du[i] -= 1\n                 if du[i] == 0:\n                     dfs(i)\n         for i in range(numCourses):\n             if du[i] == 0:\n                 dfs(i)\n         if len(result) == numCourses:\n             return result\n         return []\n \n", "class Solution:\n     # @param {integer} numCourses\n     # @param {integer[][]} prerequisites\n     # @return {integer[]}\n     def findOrder(self, numCourses, prerequisites):\n         # use DFS to parse the course structure\n         self.graph = collections.defaultdict(list) # a graph for all courses\n         self.res = [] # start from empty\n         for pair in prerequisites:\n             self.graph[pair[0]].append(pair[1]) \n         self.visited = [0 for x in range(numCourses)] # DAG detection \n         for x in range(numCourses):\n             if not self.DFS(x):\n                 return []\n              # continue to search the whole graph\n         return self.res\n     \n     def DFS(self, node):\n         if self.visited[node] == -1: # cycle detected\n             return False\n         if self.visited[node] == 1:\n             return True # has been finished, and been added to self.res\n         self.visited[node] = -1 # mark as visited\n         for x in self.graph[node]:\n             if not self.DFS(x):\n                 return False\n         self.visited[node] = 1 # mark as finished\n         self.res.append(node) # add to solution as the course depenedent on previous ones\n         return True", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         \n         def dfs( v, edgesOut, seen, pCounts ):\n             if seen[v] == 1:\n                 return []\n             else:\n                 if pCounts[v] > 0:\n                     return []\n                 else:\n                     seen[v] = 1\n                     order = [v]\n                     for e in edgesOut[v]:\n                         pCounts[e] -= 1\n                     for e in edgesOut[v]:\n                         order += dfs( e, edgesOut, seen, pCounts )\n                     return order\n         \n         seen = [0] * numCourses\n         pCounts = [0] * numCourses\n         edgesOut = [[] for __ in range(numCourses)]\n         for (a,b) in prerequisites:\n             edgesOut[b].append(a)\n             pCounts[a] += 1\n         \n         order = []\n         for v in range(numCourses):\n             order += dfs( v, edgesOut, seen, pCounts )\n         \n         if len(order) < numCourses:\n             return []\n         else:\n             return order\n         \n         \n         \n         \n         \n             \n", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         \n         def dfs( v, edgesOut, seen, pCounts ):\n             if seen[v] == 1:\n                 return []\n             else:\n                 if pCounts[v] > 0:\n                     return []\n                 else:\n                     seen[v] = 1\n                     order = [v]\n                     for e in edgesOut[v]:\n                         pCounts[e] -= 1\n                     for e in edgesOut[v]:\n                         order += dfs( e, edgesOut, seen, pCounts )\n                     return order\n         \n         seen = [0] * numCourses\n         pCounts = [0] * numCourses\n         edgesOut = [[] for __ in range(numCourses)]\n         edgesIn = [[] for __ in range(numCourses)]\n         for (a,b) in prerequisites:\n             edgesOut[b].append(a)\n             edgesIn[a].append(b)\n             pCounts[a] += 1\n         \n         order = []\n         for v in range(numCourses):\n             order += dfs( v, edgesOut, seen, pCounts )\n         \n         if len(order) < numCourses:\n             return []\n         else:\n             return order\n         \n         \n         \n         \n         \n             \n", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n             # use DFS to parse the course structure\n             self.graph = collections.defaultdict(list) # a graph for all courses\n             self.res = [] # start from empty\n             for pair in prerequisites:\n                 self.graph[pair[0]].append(pair[1]) \n             self.visited = [0 for x in range(numCourses)] # DAG detection \n             for x in range(numCourses):\n                 if not self.DFS(x):\n                     return []\n                  # continue to search the whole graph\n             return self.res\n         \n     def DFS(self, node):\n         if self.visited[node] == -1: # cycle detected\n             return False\n         if self.visited[node] == 1:\n             return True # has been finished, and been added to self.res\n         self.visited[node] = -1 # mark as visited\n         for x in self.graph[node]:\n             if not self.DFS(x):\n                 return False\n         self.visited[node] = 1 # mark as finished\n         self.res.append(node) # add to solution as the course depenedent on previous ones\n         return True", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         from collections import deque\n         class Vert(object):\n             def __init__(self):\n                 self.visited = 0\n                 self.adjList = []\n                 self.invAdjList = []\n                 self.inDegree = 0\n                 self.outDegree = 0\n         \n         #initialization\n         verts = []\n         for _ in range(numCourses):\n             verts.append(Vert())\n \n         for prereq in prerequisites:\n             pre = prereq[1]\n             post = prereq[0]\n             verts[pre].adjList.append(post)\n             verts[pre].outDegree += 1\n             verts[post].invAdjList.append(pre)\n             verts[post].inDegree += 1\n \n         #we use DFS\n         #note that BFS is to preOrder what DFS is to postOrder\n         coursesToLearn = deque()\n \n         def visitCourse(index):\n             \"\"\"verts, coursesToLearn, visited\"\"\"\n             if verts[index].visited == 2:\n                 return 0 #\u8fd4\u56de\u6761\u4ef61: \u4e0d\u5fc5\u8981, \u53ea\u662f\u4e3a\u4e86\u4e0d\u91cd\u590d\u5de5\u4f5c\n \n             #\u5224\u65ad\u5df2\u8bbf\u95ee\u8bb0\u53f7: \u5224\u65ad\u662f\u5426\u5b58\u5728loop\n             elif verts[index].visited == 1:\n                 return 1# the diagram is cyclic\n             \n             #\u8bbe\u7f6e\u5df2\u8bbf\u95ee\u8bb0\u53f7: \u5224\u65ad\u662f\u5426\u5b58\u5728loop\n             verts[index].visited = 1\n \n             # recursion\u4e3b\u4f53\n             for i in verts[index].adjList:\n                 if visitCourse(i) == 1:\n                     return 1\n \n             # \u8fd4\u56de\u6761\u4ef62: \u8bbf\u95ee\u5b8c\u6240\u6709children\n             verts[index].visited = 2\n             coursesToLearn.appendleft(index)\n             return 0\n         \n         for i in range(numCourses):\n             if verts[i].visited == 0:\n                 if visitCourse(i) == 1:\n                     break\n         if len(coursesToLearn) == numCourses:\n             return list(coursesToLearn)\n         else:\n             return []\n", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         graph = [[] for _ in range(numCourses)]\n         visit = [0 for _ in range(numCourses)]\n         result = []\n         for x in prerequisites:\n             graph[x[1]].append(x[0])\n         print(graph)    \n         def dfs(i):\n             if visit[i]==-1:\n                 return []\n             if visit[i]==1:\n                 return result\n             visit[i]=-1\n             for x in graph[i]:\n                 if [] == dfs(x):\n                     return []\n             visit[i] = 1\n             result.append(i)\n             return result\n             \n         for x in range(numCourses):\n             if [] == dfs(x):\n                 return []\n         return result[::-1]   \n                 \n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n", "from collections import defaultdict\n \n NOT_VISITED, VISITING, VISITED = 'NOT_VISITED', 'VISITING', 'VISITED'\n \n \n class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         al = {i: [] for i in range(numCourses)}\n         for cn, pn in prerequisites:\n             al[cn].append(pn)\n         vst = defaultdict(lambda: NOT_VISITED)\n         srt = []\n \n         def dfs(cn):\n             '''\n             Adds to topo sort if no cycle found\n             '''\n             if vst[cn] == VISITING:\n                 return False\n             elif vst[cn] == VISITED:\n                 return True\n \n             vst[cn] = VISITING\n \n             for pre in al[cn]:\n                 if not dfs(pre):\n                     return False  # cycle found, no such topo sort\n \n             vst[cn] = VISITED\n             srt.append(cn)\n \n             return True\n \n         for cn in range(numCourses):\n             if not dfs(cn):\n                 return []  # cycle found, no such topo sort\n \n         return srt\n", "class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         graph=[[]for _ in range(numCourses)]\n         degree=[0 for _ in range(numCourses)]\n         \n         for f,i  in prerequisites:\n             degree[f]+=1\n             graph[i].append(f)\n         res=[]\n         print(degree)\n         now_can_learn=[j for j in range(numCourses) if degree[j] == 0]\n         while (len(now_can_learn)>0):\n             curr=now_can_learn.pop()\n             res.append(curr)\n             for j in graph[curr]:\n                 degree[j] -=1\n                 if degree[j]==0:\n                     now_can_learn.append(j)\n         return res if len(res)==numCourses else []\n         \n         \n                         \n", "import queue\n \n class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         \"\"\"\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         graph = {}\n         for course, prereq in prerequisites:\n             graph[prereq] = graph[prereq] + [course] if prereq in graph else [course]\n         degree = [0] * numCourses\n         for course, _ in prerequisites:\n             degree[course] += 1\n         q = queue.Queue()\n         for i in range(numCourses):\n             if degree[i] == 0:\n                 q.put(i)\n         res = []\n         while not q.empty():\n             pre = q.get()\n             if pre in graph:\n                 for course in graph[pre]:\n                     degree[course] -= 1\n                     if degree[course] == 0:\n                         q.put(course)\n             res.append(pre)\n         return res if len(res) == numCourses else []"]
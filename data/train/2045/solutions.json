["n, m = map(int, input().split())\np, d = [0] * (n + 2), [0] * (n + 2)\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    while l < x:\n        if d[l]:\n            k = d[l]\n            d[l] = x - l\n            l += k\n        else:\n            d[l], p[l] = x - l, x\n            l += 1\n    l += 1\n    r += 1\n    while d[r]: r += d[r]\n    while l < r:\n        if d[l]:\n            k = d[l]\n            d[l] = r - l\n            l += k\n        else:\n            d[l], p[l] = r - l, x\n            l += 1\nprint(' '.join(map(str, p[1: -1])))", "n, m = map(int, input().split())\np, d = [0] * (n + 2), list(range(1, n + 3))\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    while l < x:\n        if p[l]: \n            k = d[l]\n            d[l] = x\n            l = k\n        else: \n            d[l], p[l] = x, x\n            l += 1\n    l += 1\n    r += 1\n    while p[r]: r = d[r]\n    while l < r:\n        if p[l]: \n            k = d[l]\n            d[l] = r\n            l = k\n        else:\n            d[l], p[l] = r, x\n            l += 1\nprint(' '.join(map(str, p[1: -1])))", "def main():\n    mode=\"filee\"\n    if mode==\"file\":f=open(\"test.txt\",\"r\")\n    get = lambda :[int(x) for x in (f.readline() if mode==\"file\" else input()).split()]\n    [n,m]=get()\n    k=[0 for i in range(n)]\n    g=[z+1 for z in range(n+1)]\n    for i in range(m):\n        [m,n,p]=get()\n        j=m-1\n        while j<=n-1:\n            if k[j]==0 and j!=p-1:k[j]=p\n            tmp=g[j]\n            if j<p-1:\n                g[j]=p-1\n            else:\n                g[j]=n\n            #print(j+1,tmp,g[j])\n            j=tmp\n    for i in k:\n        print (i,end=' ')\n\n    if mode==\"file\":f.close()\n\n\ndef __starting_point():\n    main()\n#copied...\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    alive, winner = list(range(1, n + 3)), [0] * (n + 2)\n    for _ in range(m):\n        l, r, x = list(map(int, input().split()))\n        while l < x:\n            if winner[l]:\n                alive[l], l = x, alive[l]\n            else:\n                alive[l] = winner[l] = x\n                l += 1\n        l += 1\n        r += 1\n        while winner[r]:\n            r = alive[r]\n        while l < r:\n            if winner[l]:\n                alive[l], l = r, alive[l]\n            else:\n                alive[l], winner[l] = r, x\n                l += 1\n    print(' '.join(map(str, winner[1: -1])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    alive, winner = list(range(1, n + 3)), [0] * (n + 2)\n    for _ in range(m):\n        l, r, x = list(map(int, input().split()))\n        while l < x:\n            if winner[l]:\n                alive[l], l = x, alive[l]\n            else:\n                alive[l] = winner[l] = x\n                l += 1\n        l += 1\n        r += 1\n        while l < r:\n            if winner[l]:\n                alive[l], l = r, alive[l]\n            else:\n                alive[l], winner[l] = r, x\n                l += 1\n    print(' '.join(map(str, winner[1: -1])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\np, d = [0] * (n + 2), list(range(1, n + 3))\nfor i in range(m):\n    l, r, x = list(map(int, input().split()))\n    while l < x:\n        if p[l]: \n            k = d[l]\n            d[l] = x\n            l = k\n        else: \n            d[l], p[l] = x, x\n            l += 1\n    l += 1\n    r += 1\n    while p[r]: r = d[r]\n    while l < r:\n        if p[l]: \n            k = d[l]\n            d[l] = r\n            l = k\n        else:\n            d[l], p[l] = r, x\n            l += 1\nprint(' '.join(map(str, p[1: -1])))\n", "import os\nn,m = list(map(int,input().split()))\n\nparent = list(range(0,n+1))\nanswer = list(range(0,n))\n\ndef getParent(x):\n    while parent[x] != x:\n        x = parent[x]\n        parent[x] = parent[parent[x]]\n    return parent[x]\n\n\nfor i in range(m):\n    l, r, x = list(map(int,input().split()))\n    cnt = getParent(l-1)\n    while cnt <= (r-1):\n        if cnt == (x-1):\n            cnt = cnt + 1\n        else:\n            parent[cnt] = cnt+1\n            answer[cnt] = x-1\n        cnt = getParent(cnt)\n    # print(parent)\n    # print(answer)\nc = 0\ns = \"\"\nfor i in answer:\n    if c == i:\n        s += \"0 \"\n    else:\n        s += str(i+1) + \" \"\n    c = c+1\nos.write(1,str.encode(s))\n\n\n\n", "n, m = map(int, input().split())\n\np, d = [0] * (n + 2), list(range(1, n + 3))\n\nfor i in range(m):\n\n    l, r, x = map(int, input().split())\n\n    while l < x:\n\n        if p[l]: \n\n            k = d[l]\n\n            d[l] = x\n\n            l = k\n\n        else: \n\n            d[l], p[l] = x, x\n\n            l += 1\n\n    l += 1\n\n    r += 1\n\n    while p[r]: r = d[r]\n\n    while l < r:\n\n        if p[l]: \n\n            k = d[l]\n\n            d[l] = r\n\n            l = k\n\n        else:\n\n            d[l], p[l] = r, x\n\n            l += 1\n\nprint(' '.join(map(str, p[1: -1])))", "def main():\n    n, m = list(map(int, input().split()))\n    alive, winner = list(range(1, n + 3)), [0] * (n + 2)\n    for _ in range(m):\n        l, r, x = list(map(int, input().split()))\n        while l < x:\n            if winner[l]:\n                alive[l], l = x, alive[l]\n            else:\n                alive[l] = winner[l] = x\n                l += 1\n        l += 1\n        r += 1\n        while winner[r]:\n            r = alive[r]\n        while l < r:\n            if winner[l]:\n                alive[l], l = r, alive[l]\n            else:\n                alive[l], winner[l] = r, x\n                l += 1\n    print(' '.join(map(str, winner[1: -1])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "nKnights, nFights = map(int,input().split())\nanext = [i + 1 for i in range(nKnights + 1)]\nresult = [0] * nKnights\nfor _ in range(nFights):\n    l, r, x = map(int,input().split())\n    i = l\n    while i <= r:\n        if result[i-1]==0 and i!=x:\n            result[i-1] = x\n        temp = anext[i]\n        if i < x:\n            anext[i] = x\n        else:\n            anext[i] = r + 1\n        i = temp\nprint(*result)", "def prog():\n    n,m = map(int,input().split())\n    res,anext = [0]*n,[i+1 for i in range(n+2)]\n    from sys import stdin\n    for _ in range(m):\n        l,r,x = map(int,stdin.readline().split())\n        i=l\n        while i<=r:\n            if res[i-1]==0 and i!=x:\n                res[i-1]=x\n            save = anext[i]\n            if i<x:\n                anext[i]=x\n            else:\n                anext[i]=r+1\n            i=save\n    print(*res)\nprog()", "def prog():\n    n,m = map(int,input().split())\n    res,anext = [0]*n,[i+1 for i in range(n+2)]\n    from sys import stdin\n    for _ in range(m):\n        l,r,x = map(int,stdin.readline().split())\n        i=l\n        while i<=r:\n            if res[i-1]==0 and i!=x:\n                res[i-1]=x\n            save = anext[i]\n            if i<x:\n                anext[i]=x\n            else:\n                anext[i]=r+1\n            i=save\n    print(*res)\nprog()", "def ans():\n    n,m = list(map(int,input().split()))\n    res,alive = [0]*n,[(i+1) for i in range(n+2)]\n    from sys import stdin\n    for _ in range(m):\n        l,r,x = list(map(int,stdin.readline().split()))\n        i=l\n        while i<=r:\n            if res[i-1]==0 and i!=x:\n                res[i-1] = x\n            temp = alive[i]\n            if i < x:\n                alive[i] = x\n            else:\n                alive[i] = r+1\n            i = temp\n    print(*res)\nans()\n", "import sys\n\nclass SegmTree():\n    def __init__(self, array=None, size=None):\n        if array is not None:\n            size = len(array)\n        N = 1\n        while N < size:\n            N <<= 1\n        self.N = N\n        self.tree = [0] * (2*self.N)\n        if array is not None:\n            for i in range(size):\n                self.tree[i+self.N] = array[i]\n            self.build()\n\n    def build(self):\n        for i in range(self.N - 1, 0, -1):\n            self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]\n\n    def add(self, i, value=1):\n        i += self.N\n        while i > 0:\n            self.tree[i] += value\n            i >>= 1    \n    \n    def find_nonzeros(self, l, r):\n        N = self.N\n        l += N\n        r += N\n        cand = []\n        while l < r:\n            if l & 1:\n                if self.tree[l]:\n                    cand.append(l)\n                l += 1\n            if r & 1:\n                r -= 1\n                if self.tree[r]:\n                    cand.append(r)\n            l >>= 1\n            r >>= 1\n        ans = []\n        while cand:\n            i = cand.pop()\n            if i < N:\n                i <<= 1\n                if self.tree[i]:\n                    cand.append(i)\n                if self.tree[i|1]:\n                    cand.append(i|1)\n            else:\n                ans.append(i - N)\n        return ans\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn, m = list(map(int, input().split()))\nst = SegmTree([1]*n)\nans = [0] * n\nfor _ in range(m):\n    l, r, x = list(map(int, input().split()))\n    l -= 1\n    x -= 1\n    for i in st.find_nonzeros(l, r):\n        if i != x:\n            ans[i] = x + 1\n            st.add(i, -1)\nprint(*ans)\n    \n# inf.close()\n", "#!/usr/bin/env python3\nimport os\nimport sys\nfrom atexit import register\nfrom io import StringIO\n\n# Buffered output, at least 2x faster.\nsys.stdout = StringIO()\nregister(lambda: os.write(1, sys.stdout.getvalue().encode()))\n\n###############################################################################\nimport math\n###############################################################################\nn,m = [int(k) for k in input().split()]\nt = [0] * (4*n)\n\ndef update(x, l, r, v, tl, tr):\n    if r < l: return\n    if t[v] != 0: return\n    if l == tl and r == tr:\n        t[v] = x\n    else:\n        tm = (tl+tr)>>1\n        update(x, l, min(tm, r), 2*v, tl, tm)\n        update(x, max(tm+1, l), r, 2*v+1, tm+1, tr)\n\ndef query(i):\n    v = 1\n    tl = 1\n    tr = n\n    while tl != tr:\n        tm = (tl+tr)>>1\n        if i <= tm:\n            v = v<<1\n            tr = tm\n        else:\n            v = (v<<1)+1\n            tl = tm+1\n    k = 0\n    while v != 0:\n       k = k or t[v]\n       v = v >> 1\n    return k\n\nfor _ in range(m):\n    l,r,x = [int(k) for k in input().split()]\n    update(x, l, x-1, 1, 1, n)\n    update(x, x+1, r, 1, 1, n)\nprint(' '.join([str(query(k)) for k in range(1, n+1)]))\n", "# -*- coding: utf-8 -*-\n\n# Baqir Khan\n# Software Engineer (Backend)\n\nfrom sys import stdin\n\ninp = stdin.readline\n\nn, m = list(map(int, inp().split()))\nans = [0] * (n + 1)\nalive = [(i + 1) for i in range(n + 2)]\n\nwhile m:\n    m -= 1\n    l, r, x = list(map(int, inp().split()))\n    i = l\n    while i <= r:\n        if ans[i] == 0 and i != x:\n            ans[i] = x\n        temp = alive[i]\n        if i < x:\n            alive[i] = x\n        else:\n            alive[i] = r + 1\n        i = temp\n\nprint(*ans[1:])\n", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nn,m=map(int,input().split())\nans=[0 for i in range(n)]\nnextl=[i+1 for i in range(n+2)]\nfor j in range(m):\n\tl,r,x=map(int,input().split())\n\ti=l\n\twhile i<=r:\n\t\tif ans[i-1]==0 and i!=x:\n\t\t\tans[i-1]=x\n\t\ta=nextl[i]\n\t\tif i<x:\n\t\t\tnextl[i]=x\n\t\telse:\n\t\t\tnextl[i]=r+1\n\t\ti=a\nprint(*ans)", "#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now----------------------------------------------------\nimport bisect \nn,m=list(map(int,input().split()))\nnex=[i+1 for i in range(n)]\nans=[0]*n\nfor i in range(m):\n    l,r,x=list(map(int,input().split()))\n    j=l-1\n    while(j<r):\n        if ans[j]==0 and j!=x-1:\n            ans[j]=x\n        a=nex[j]\n        if j<x-1:\n            nex[j]=x-1\n        else:\n            nex[j]=r\n        j=a\nprint(*ans)\n    \n", "import sys\ninput = sys.stdin.readline\n\ndef inint():\n    return(int(input()))\n\ndef inlst():\n    return(list(map(int,input().split())))\n\n# returns a List of Characters, which is easier to use in Python as Strings are Immutable\ndef instr():\n    s = input()\n    return(list(s[:len(s) - 1]))\n\ndef invar():\n    return(list(map(int,input().split())))\n\n############ ---- Input function template ---- ############\n\ndef isOdd(num):\n  return (num & 1) == 1\n\nn, m = invar()\n\n# build function\ntree = [{'round_num':m, 'winner':-1} for _ in range(2*n+1, 0, -1)]\n\ndef modify(left, right, pair):\n  left += n\n  right += n\n  while left <= right:\n    if isOdd(left):\n      tree[left] = pair\n\n    if not isOdd(right):\n      tree[right] = pair\n\n    left = int((left+1)/2)\n    right = int((right-1)/2)\n\n\ndef query(pos):\n  pos += n\n  min = 1000000\n  winner = -1\n  while pos > 0:\n    if tree[pos]['round_num'] < min:\n      winner = tree[pos]['winner']\n      min = tree[pos]['round_num']\n\n    pos >>= 1\n\n  return winner + 1 if winner > -1 else 0\n\nrounds = []\nfor _ in range(m):\n  li, ri, xi = invar()\n  rounds.append({'left':li-1, 'right':ri-1, 'winner':xi-1})\n\nfor idx in range(m-1, -1, -1):\n  round = rounds[idx]\n  if round['winner'] > 0: modify(round['left'], round['winner']-1, {'round_num': idx, 'winner':round['winner']})\n  if round['winner'] < n: modify(round['winner']+1, round['right'], {'round_num': idx, 'winner':round['winner']})\n\nprint(*[query(i) for i in range(n)])\n", "import sys\ninput = sys.stdin.readline\n\ndef inint():\n    return(int(input()))\n\ndef inlst():\n    return(list(map(int,input().split())))\n\n# returns a List of Characters, which is easier to use in Python as Strings are Immutable\ndef instr():\n    s = input()\n    return(list(s[:len(s) - 1]))\n\ndef invar():\n    return(list(map(int,input().split())))\n\n############ ---- Input function template ---- ############\n\ndef isOdd(num):\n  return (num & 1) == 1\n\nn, m = invar()\n\n# build function\n# 2n+1 is needed as 1-index would be used\ntree = [{'round_num':m, 'winner':-1} for _ in range(2*n+1, 0, -1)]\n\ndef modify(left, right, pair):\n  left += n\n  right += n\n  while left <= right:\n    if isOdd(left):\n      tree[left] = pair\n\n    if not isOdd(right):\n      tree[right] = pair\n\n    left = int((left+1)/2)\n    right = int((right-1)/2)\n\n\ndef query(pos):\n  pos += n\n  min = 1000000\n  winner = -1\n  \n  while pos > 0:\n    if tree[pos]['round_num'] < min:\n      winner = tree[pos]['winner']\n      min = tree[pos]['round_num']\n    pos >>= 1\n\n  return winner if winner > -1 else 0\n\nrounds = []\nfor _ in range(m):\n  li, ri, xi = invar()\n  rounds.append({'left':li, 'right':ri, 'winner':xi})\n\n# iterating input in reverse order\nfor idx in range(m-1, -1, -1):\n  round = rounds[idx]\n  # update winner for all the knights in tournament. except for winner itself\n  if round['winner'] > 0: modify(round['left'], round['winner']-1, {'round_num': idx, 'winner':round['winner']})\n  if round['winner'] < n: modify(round['winner']+1, round['right'], {'round_num': idx, 'winner':round['winner']})\n\nprint(*[query(i) for i in range(1, n+1)])\n", "#!/usr/bin/env python\n#pyrival orz\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\"\"\"\n    for _ in range(int(input())):\n    n,m=map(int,input().split())\n    n=int(input())\n    a = [int(x) for x in input().split()]\n\"\"\"\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\ndef main():\n    n,m=map(int,input().split())\n    ans=[0]*n\n    st=SortedList([i for i in range(n)])\n    for _ in range(m):\n        l,r,x=map(int,input().split())\n        idx=st.bisect_left(l-1)\n        # print(l,r,x)\n        while idx<len(st):\n            cur=st[idx]\n            if cur>=r:\n                break\n            # print(cur)\n            ans[cur]=x\n            st.discard(cur)\n        ans[x-1]=0\n        st.add(x-1)\n    print(*ans)\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\ndef __starting_point():\n    main()\n__starting_point()", "from sys import stdin, stdout, setrecursionlimit\nfrom collections import deque, defaultdict, Counter\nfrom heapq import heappush, heappop\nimport math\n\nrl = lambda: stdin.readline()\nrll = lambda: stdin.readline().split()\nrli = lambda: map(int, stdin.readline().split())\nrlf = lambda: map(float, stdin.readline().split())\n\nINF, NINF = float('inf'), float('-inf')\n\nclass SegTree:\n\tdef __init__(self, size):\n\t\tself.n = size\n\t\tself.T = [[INF, INF] for _ in range(4*self.n)]\n\n\tdef _update_range(self, v, tl, tr, l, r, val):\n\t\tif l > r or tl > tr: return\n\t\t# print(f\"l, r = {l, r}, tl, tr = {tl, tr}\")\n\t\tif l == tl and r == tr:\n\t\t\t# self.T[v].append(val)\n\t\t\tif self.T[v] == [INF, INF]:\n\t\t\t\tself.T[v] = val\n\t\telse:\n\t\t\tmid = (tl + tr)//2\n\t\t\tself._update_range(2*v, tl, mid, l, min(r, mid), val)\n\t\t\tself._update_range(2*v+1, mid+1, tr, max(l, mid+1), r, val)\n\n\tdef update_range(self, l, r, val):\n\t\tself._update_range(1, 0, self.n-1, l, r, val)\n\n\n\tdef qry(self, index):\n\t\treturn self._qry(1, 0, self.n-1, index)\n\n\tdef _qry(self, v, tl, tr, index):\n\t\tif tl == tr:\n\t\t\tif self.T[v]:\n\t\t\t\treturn self.T[v]\n\t\t\telse:\n\t\t\t\treturn (INF, INF)\n\t\telse:\n\t\t\tmid = (tl + tr)//2\n\t\t\tcurr_x, curr_time = INF, INF\n\t\t\tif self.T[v]:\n\t\t\t \tcurr_x, curr_time = self.T[v]\n\t\t\tif index <= mid:\n\t\t\t\tprev_x, prev_time = self._qry(2*v, tl, mid, index)\n\t\t\telse:\n\t\t\t\tprev_x, prev_time = self._qry(2*v+1, mid+1, tr, index)\n\t\t\tif curr_time < prev_time:\n\t\t\t\treturn (curr_x, curr_time)\n\t\t\telse:\n\t\t\t\treturn (prev_x, prev_time)\n\ndef main():\n\t# n = number of knights\n\t# m = number of fights\n\tn, m = rli()\n\tans = [0 for _ in range(n)]\n\tST = SegTree(n)\n\tfor time in range(m):\n\t\tl, r, x = rli()\n\t\tl -= 1\n\t\tr -= 1\n\t\tx -= 1\n\t\tST.update_range(l, x-1, (x, time))\n\t\tST.update_range(x+1, r, (x, time))\n\n\tfor i in range(n):\n\t\tk, _ = ST.qry(i)\n\t\tans[i] = k + 1 if k < INF else 0\n\tprint(\" \".join(str(x) for x in ans))\n\tstdout.close()\n\ndef __starting_point():\n\tmain()\n__starting_point()", "# Fast IO (only use in integer input)\n\nimport os,io\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nn,m = list(map(int,input().split()))\nconquerer = ['0'] * n\nnextKnight = []\nfor i in range(n):\n    nextKnight.append(i)\n\nfor _ in range(m):\n    l,r,x = list(map(int,input().split()))\n    pathList = []\n    index = l - 1\n    maxIndex = r\n    while index < r:\n        while index < n and nextKnight[index] != index:\n            pathList.append(index)\n            index = nextKnight[index]\n        if index < r and index != x - 1:\n            conquerer[index] = str(x)\n            pathList.append(index)\n        if index >= r:\n            maxIndex = index\n        index += 1\n    for elem in pathList:\n        if elem < x - 1:\n            nextKnight[elem] = x - 1\n        else:\n            nextKnight[elem] = maxIndex\n\nprint(' '.join(conquerer))\n", "import sys\n\nI = lambda: int(input())\nreadline = lambda: sys.stdin.readline().strip('\\n')\nRM = readmap  = lambda x=int: list(map(x,readline().split(' ')))\n\nn,m = RM()\nconq = ['0']*(n+1)\nnxt = list(range(1,n+2))#contains the nxt person alive for each person\nfor _ in range(m):\n    l,r,m = RM()\n    cur = l\n    while cur<=r:\n        if conq[cur]=='0' and cur!=m:   conq[cur]=str(m)\n        nx = nxt[cur]\n        nxt[cur] = [r+1,m][cur<m]#right most of the segment or the conqueror\n        cur = nx\n\nprint(' '.join(conq[1:]))\n", "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nfrom collections import Counter\nimport math\n#n,m=map(int,input().split())\nfrom collections import Counter\n#for i in range(n):\nimport math\n#for _ in range(int(input())):\n#n = int(input())\n#for _ in range(int(input())):\n#n = int(input())\nimport bisect\n'''for _ in range(int(input())):\n\n    n=int(input())\n\n    n,k=map(int, input().split())\n\n    arr = list(map(int, input().split()))'''\n\n#n = int(input())\nm=0\nn,k=list(map(int, input().split()))\nans=[0]*n\njump=[i+1 for i in range(n+2)]\nfor _ in range(k):\n    l,r,x= list(map(int, input().split()))\n    i=l\n    while i<=r:\n        if ans[i-1]==0 and i!=x:\n            ans[i-1]=x\n        var=jump[i]\n        if i<x:\n            jump[i]=x\n        else:\n            jump[i]=r+1\n        i=var\n    #print(ans)\n\nprint(*ans)\n\n\n\n\n\n\n"]
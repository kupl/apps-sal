["import sys\ninput = sys.stdin.readline\nimport bisect\n\nt=int(input())\n\nfor testcases in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n    m=int(input())\n    PS=[tuple(map(int,input().split())) for i in range(m)]\n\n    PS.sort()\n    K=[PS[-1]]\n\n    for a,b in PS[::-1][1:]:\n        if b<=K[-1][1]:\n            continue\n        else:\n            K.append((a,b))\n\n    K.reverse()\n\n    ANS=1\n    count=0\n    countmax=n+1\n    LEN=len(K)\n    for a in A:\n        x=bisect.bisect_left(K,(a,0))\n        if x==LEN:\n            print(-1)\n            break\n        elif K[x][1]>=count+1 and countmax>=count+1:\n            count+=1\n            countmax=min(countmax,K[x][1])\n        else:\n            ANS+=1\n            count=1\n            countmax=K[x][1]\n\n        #print(a,count,countmax,ANS)\n    else:\n        print(ANS)\n            \n        \n        \n", "import sys\ninput = sys.stdin.readline\nT = int(input())\nAns = []\nfor _ in range(T):\n    N = int(input())  # \u30e2\u30f3\u30b9\u30bf\u30fc\u306e\u6570\n    A = list(map(int, input().split()))  # \u30e2\u30f3\u30b9\u30bf\u30fc\u306e\u30d1\u30ef\u30fc\n    M = int(input())  # \u30d2\u30fc\u30ed\u30fc\u306e\u6570\n    PS = [list(map(int, input().split())) for _ in range(M)]  # \u30d1\u30ef\u30fc\u3068\u8010\u4e45\n    # \u30e2\u30f3\u30b9\u30bf\u30fc\u306e\u30d1\u30ef\u30fc\u304c\u30d2\u30fc\u30ed\u30fc\u306e\u30d1\u30ef\u30fc\u3088\u308a\u5927\u304d\u3044\u3068\u30d2\u30fc\u30ed\u30fc\u306e\u8ca0\u3051\n    # S \u306f 1 \u65e5\u306b\u5012\u305b\u308b\u30e2\u30f3\u30b9\u30bf\u30fc\u306e\u6570\u306e\u4e0a\u9650\n\n    # L[n] := n \u4f53\u5012\u305b\u308b\u30d2\u30fc\u30ed\u30fc\u306e\u6700\u5927\u30d1\u30ef\u30fc\n    L = [0] * (N+1)\n    for p, s in PS:\n        L[s] = max(L[s], p)\n    for i in range(N-1, -1, -1):\n        L[i] = max(L[i], L[i+1])\n    ans = 1\n    cnt = 1\n    ma = 0\n    if L[1] < max(A):\n        Ans.append(-1)\n        continue\n    for a in A:\n        ma = max(ma, a)\n        if L[cnt] < ma:\n            cnt = 1\n            ans += 1\n            ma = a\n        cnt += 1\n    Ans.append(ans)\n\nprint(\"\\n\".join(map(str, Ans)))\n", "3\n\nimport os\nimport sys\n\n\ndef main():\n    T = read_int()\n    for _ in range(T):\n        N = read_int()\n        A = read_ints()\n        M = read_int()\n        H = [tuple(read_ints()) for _ in range(M)]\n        print(solve(N, A, M, H))\n\n\ndef solve(N, A, M, H):\n    H.sort(key=lambda h: (h[1], -h[0]))\n    spow = [0] * (N + 1)\n    s0 = 0\n    for p, s in H:\n        if s0 == s:\n            continue\n        spow[s] = p\n        s0 = s\n\n    maxp = 0\n    for d in range(N, -1, -1):\n        maxp = max(maxp, spow[d])\n        spow[d] = maxp\n\n    ans = 0\n    maxa = A[0]\n    if A[0] > spow[1]:\n        return -1\n    start = 0\n    for i, a in enumerate(A[1:]):\n        if a > spow[1]:\n            return -1\n        i += 1\n        days = i - start + 1\n        maxa = max(maxa, a)\n        if spow[days] < maxa:\n            ans += 1\n            maxa = a\n            start = i\n    return ans + 1\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor rew in range(q):\n\tn = int(input())\n\tmonster = list(map(int,input().split()))\n\tm = int(input())\n\trycerz = [list(map(int,input().split())) for i in range(m)]\n\trycerz.sort()\n\trycerz.reverse()\n\tp = [a[0] for a in rycerz]\n\ts = [a[1] for a in rycerz]\n\tmaxendu = [-1] * m\n\tmaxendu[0] = s[0]\n\tif max(p) < max(monster):\n\t\tprint(-1)\n\telse:\n\t\tfor i in range(1, m):\n\t\t\tmaxendu[i] = max(maxendu[i-1], s[i])\n\t\tdays = 0\n\t\tpoz = 0\n\t\twhile True:\n\t\t\tif poz >= n:\n\t\t\t\tprint(days)\n\t\t\t\tbreak\n\t\t\tbest_potwor = -1\n\t\t\tkroki = 0\n\t\t\twhile True:\n\t\t\t\tif poz + kroki >= n:\n\t\t\t\t\tbreak\n\t\t\t\tbest_potwor = max(monster[poz + kroki], best_potwor)\n\t\t\t\t#tyle krokow robimy i taki best potwor\n\t\t\t\tl = 0\n\t\t\t\tpr = m - 1\n\t\t\t\twhile abs(pr-l) > 0:\n\t\t\t\t\tsr = (l + pr + 1) // 2\n\t\t\t\t\tif p[sr] >= best_potwor:\n\t\t\t\t\t\tl = sr\n\t\t\t\t\telse:\n\t\t\t\t\t\tpr = sr - 1\n\t\t\t\tsr = (pr + l) // 2\n\t\t\t\tif maxendu[sr] >= kroki + 1:\n\t\t\t\t\tkroki += 1\n\t\t\t\telse:\n\t\t\t\t\tkroki -= 1\n\t\t\t\t\tbreak\n\t\t\tdays += 1\n\t\t\tpoz += kroki\n\t\t\tpoz += 1", "import sys\nimport bisect\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = 10**9\n\nclass RMQ:\n    def __init__(self, a):\n        self.n = len(a)\n        self.size = 2**(self.n - 1).bit_length()\n        self.data = [0] * (2*self.size-1)\n        self.initialize(a)\n\n    # Initialize data\n    def initialize(self, a):\n        for i in range(self.n):\n            self.data[self.size + i - 1] = a[i]\n        for i in range(self.size-2, -1, -1):\n            self.data[i] = max(self.data[i*2 + 1], self.data[i*2 + 2])\n\n    # Update ak as x\n    def update(self, k, x):\n        k += self.size - 1\n        self.data[k] = x\n        while k > 0:\n            k = (k - 1) // 2\n            self.data[k] = max(self.data[2*k+1], self.data[2*k+2])\n\n    # max value in [l, r)\n    def query(self, l, r):\n        L = l + self.size; R = r + self.size\n        s = 0\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = max(s, self.data[R-1])\n            if L & 1:\n                s = max(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(item) for item in input().split()]\n    m = int(input())\n    brave = []\n    for j in range(m):\n        pp, ss = [int(item) for item in input().split()]\n        brave.append((pp, ss))\n    brave.sort(reverse=True)\n    p = []\n    s = []\n    for pp, ss in brave:\n        p.append(pp)\n        s.append(ss)\n    s_rmq = RMQ(s)\n    a_rmq = RMQ(a)\n    p.reverse()\n    s.reverse()\n    max_step = max(s)\n    days = 0\n    curr = 0\n    while curr < n:\n        # Search step size\n        l = 0; r = min(n - curr, max_step) + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            max_monster = a_rmq.query(curr, curr+mid)\n            index = m - bisect.bisect_left(p, max_monster)\n            walkable = s_rmq.query(0, index)\n            if walkable >= mid:\n                l = mid\n            else:\n                r = mid\n        if l == 0:\n            days = -1\n            break\n        else:\n            days += 1\n            curr += l\n    print(days)", "import sys\nfor _ in range(int(input())):\n    n = int(sys.stdin.readline())\n    mons = list(map(int, sys.stdin.readline().split()))\n    m = int(sys.stdin.readline())\n    _heros = sorted((tuple(map(int, sys.stdin.readline().split())) for _ in range(m)), reverse=True)\n    max_s = 0\n    pows = []\n    endu = []\n    for i in range(m):\n        if max_s >= _heros[i][1]:\n            continue\n        max_s = max(max_s, _heros[i][1])\n        pows.append(_heros[i][0])\n        endu.append(_heros[i][1])\n\n    pows.append(0)\n    endu.append(10**9)\n    i = 0\n    for ans in range(1, 10**9):\n        hero_i = 0\n        power = pows[0]\n        mons_power = 0\n\n        if power < mons[i]:\n            print(-1)\n            break\n        for j in range(1, n-i+1):\n            if endu[hero_i] < j:\n                hero_i += 1\n                power = pows[hero_i]\n\n            mons_power = max(mons_power, mons[i])\n            if power < mons_power:\n                break\n            i += 1\n        else:\n            print(ans)\n            break\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import stdin\n\ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\n\n# range = xrange\n# input = raw_input\n\n\ndef main():\n    t=iin()\n    while t:\n        t-=1\n        n=iin()\n        a=lin()\n        m=iin()\n        h=[lin()[::-1] for i in range(m)]\n        h.sort(reverse=True)\n        a1=[[j,i] for i,j in enumerate(a)]\n        a2=[-1]*n\n        a1.sort()\n        i=0\n        j=0\n        while j<n and i<m:\n            if h[i][1]>=a1[j][0]:\n                a2[a1[j][1]]=i\n                j+=1\n            else:\n                i+=1\n        if -1 in a2:\n            print(-1)\n        else:\n            dp=[1]*n\n            for i in range(1,n):\n                ad=[0]\n                ch=0\n                if h[a2[i]][0]>dp[i-1]:\n                    if h[a2[i]][1]>=h[a2[i-1]][1]:\n                        ad.append(dp[i-1])\n                        ch+=1\n                if h[a2[i-1]][0]>dp[i-1]:\n                    if h[a2[i-1]][1]>=h[a2[i]][1]:\n                        ad.append(dp[i-1])\n                        if ch==0:\n                            a2[i]=a2[i-1]\n                dp[i]+=max(ad)\n            print(dp.count(1))\n            # print(dp,a2,h)\n\n\n\n\n\n\n\n\n\n\n\n\n\nmain()\n# try:\n#     main()\n# except Exception as e: print(e)\n", "import sys\ninput = lambda: sys.stdin.readline().strip()\nprint = lambda s: sys.stdout.write(s)\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    ls1 = list(map(int, input().split()))\n    m = int(input())\n    ls2 = []\n    for i in range(m):\n        ls2.append(tuple(map(int, input().split())))\n    if max(ls1)>max(i[0] for i in ls2):\n        print('-1\\n')\n    else:\n        temp = {}\n        for i in range(1, n+1):\n            temp[i] = 0\n        for i in ls2:\n            try:\n                temp[i[1]] = max(temp[i[1]], i[0])\n            except:\n                temp[i[1]] = i[0]\n        d = {}\n        d[n] = temp[n]\n        for k in range(n-1, 0, -1):\n            d[k] = max(d[k+1], temp[k])\n        i = 0\n        cnt = 1\n        ans = 1\n        M = ls1[0]\n        while True:\n            if d[cnt]>=M:\n                cnt+=1\n                i+=1\n                if i==n:\n                    break\n                M = max(M, ls1[i])\n            else:\n                ans+=1\n                cnt = 1\n                M = ls1[i]\n        print(str(ans)+'\\n')\n", "import math\nimport sys\nfrom bisect import bisect_right as bs\nfor _ in range(int(input())):\n    n=int(sys.stdin.readline())\n    a=list(map(int,sys.stdin.readline().split()))\n    m=int(input())\n    ma=-1\n    h=[0]*(n+1)\n    for i in range(m):\n        x,y=list(map(int,sys.stdin.readline().split()))\n        ma=max(ma,x)\n        h[y]=max(h[y],x)\n    \n    for i in range(n-1,0,-1):\n        h[i]=max(h[i+1],h[i])\n    # print(h)    \n    if ma<max(a):\n        print(-1)\n    else:\n        ma=-1\n        prev=0\n        ans=1\n        i=0\n        while i<n:\n            ma=max(a[i],ma)\n            # print(ma,i,ans)\n            if h[i-prev+1]<ma:\n                prev=i\n                ans+=1\n                ma=-1\n            else:\n                i+=1\n        print(ans)        \n", "from collections import *\nfrom bisect import bisect_left as bl\nimport sys\ninput = sys.stdin.readline\n \n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input())\ndef stli():return [int(i) for i in input().rstrip('\\n')]\n \n \n \n \nfor _ in range(val()):\n    n = val()\n    a = li()\n    # print(a)\n    m = val()\n    h = []\n    visited = defaultdict(int)\n    for i in range(m):\n        x,y = li()\n        visited[x] = max(visited[x],y)\n    h = []\n    for i in visited:\n        h.append([i,visited[i]])\n    h.sort(reverse = 1)\n    endurance = {}\n    m = len(h)\n    currmax = -float('inf')\n    for i in range(m):\n        if h[i][1]>currmax:\n            currmax = max(currmax,h[i][1])\n            endurance[h[i][0]] = currmax\n        \n \n    power = sorted(list(endurance))\n    # print(power,endurance)\n    totdays = 0\n    i = 0\n    while i<n:\n        ind = bl(power,a[i])\n        if ind == len(power):\n            totdays = -1\n            break\n \n        cou = 0\n        while i<n:\n            while ind<len(power) and  a[i]>power[ind]:\n                ind+=1\n            if ind == len(power):\n                totdays = -1\n                break\n            if endurance[power[ind]] <= cou:\n                break\n            i+=1\n            cou += 1\n\n        if totdays == -1:break\n        totdays += 1\n    print(totdays)", "from collections import *\nfrom bisect import bisect_left as bl\nimport sys\ninput = sys.stdin.readline\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef val():return int(input())\n \nfor _ in range(val()):\n    n = val();a = li();m = val();h = [];visited = defaultdict(int)\n    for i in range(m):\n        x,y = li()\n        visited[x] = max(visited[x],y)\n    \n    endurance, currmax, h = {}, -float('inf'), sorted([[i,visited[i]] for i in visited],key = lambda x:x[0],reverse = 1)\n    \n    for i in range(len(h)):\n        if h[i][1]>currmax:\n            currmax = max(currmax,h[i][1])\n            endurance[h[i][0]] = currmax\n \n    power = sorted(list(endurance))\n\n    totdays = i = 0\n    while i<n:\n        ind = bl(power,a[i])\n        if ind == len(power):\n            totdays = -1\n            break\n        cou = 0\n        while i<n:\n            while ind<len(power) and  a[i]>power[ind]:ind+=1\n            if ind == len(power):\n                totdays = -1;break\n            if endurance[power[ind]] <= cou:break\n            i+=1\n            cou += 1\n        if totdays == -1:break\n        \n        totdays += 1\n    \n    print(totdays)", "import sys\ninput = sys.stdin.readline\nT = int(input())\nAns = []\nfor _ in range(T):\n    N = int(input()) \n    A = list(map(int, input().split()))\n    M = int(input()) \n    PS = [list(map(int, input().split())) for _ in range(M)]\n    L = [0] * (N+1)\n    for p, s in PS:\n        L[s] = max(L[s], p)\n    for i in range(N-1, -1, -1):\n        L[i] = max(L[i], L[i+1])\n    ans = 1\n    cnt = 1\n    ma = 0\n    if L[1] < max(A):\n        Ans.append(-1)\n        continue\n    for a in A:\n        ma = max(ma, a)\n        if L[cnt] < ma:\n            cnt = 1\n            ans += 1\n            ma = a\n        cnt += 1\n    Ans.append(ans)\n \nprint(\"\\n\".join(map(str, Ans)))", "import sys\nsin = sys.stdin\nt = int(sin.readline())\nfor _ in range(t):\n    n = int(sin.readline())\n    monpows = [int(x) for x in sin.readline().split()]\n    m = int(sin.readline())\n    endtopow = dict()\n    maxhero = 0\n    for _ in range(m):\n        h = [int(x) for x in sin.readline().split()]\n        maxhero = max(maxhero, h[0])\n        if h[1] in endtopow:\n            endtopow[h[1]] = max(h[0], endtopow[h[1]])\n        else:\n            endtopow[h[1]] = h[0]\n    endurances = [0 for x in range(n+2)]\n    for i in range(len(endurances) - 2, -1, -1):\n        if i in endtopow:\n            endurances[i] = max(endurances[i+1], endtopow[i])\n        else:\n            endurances[i] = endurances[i+1]\n    days = 0\n    msofar = 0\n    maxpow = 0\n    i = 0\n    cant = False\n    while i < n:\n        maxpow = max(maxpow, monpows[i])\n        if maxpow > maxhero:\n            cant = True\n            break\n        if maxpow <= endurances[msofar + 1]:\n            i += 1\n            msofar += 1\n        else:\n            msofar = 0\n            maxpow = 0\n            days += 1\n    days += 1\n    if not cant:\n        print(days)\n    else:\n        print(-1)\n", "t = int(input())\nfor _ in range(t):\n    # print()\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    b = [tuple(map(int, input().split())) for __ in range(m)]\n    ans = 1\n    # mx[i] stores the max power of the hero that can go i steps\n    mx = [0] * (n + 1)\n    for p, s in b:\n        mx[s] = max(mx[s], p)\n    for i in range(n-1, -1, -1):\n        mx[i] = max(mx[i], mx[i+1])\n\n    # print(a)\n    # print(b)\n    if mx[1] < max(a):\n        print(-1)\n    else:\n        index = 1\n        ma = 0\n        for mon in a:\n            ma = max(mon, ma)\n            if mx[index] < ma:\n                index = 1\n                ans += 1\n                ma = mon\n            index += 1\n        # ind = 0\n        # while ind < n:\n        #     temp = 0\n        #     for i in range(m):\n        #         l = 0\n        #         if b[i][0] <= temp:\n        #             break\n        #         if ind + temp == n:\n        #             break\n        #         # print(a[ind:len(a)])\n        #         end = min(ind+b[i][0], len(a))\n        #         for j in range(ind, end):\n        #             if a[j] > b[i][1]:\n        #                 break\n        #             l += 1\n        #         if l > temp:\n        #             temp = l\n        #     # print(temp, ind)\n        #     ind += temp\n        #     ans += 1\n        #     # print(a, temp)\n        print(ans)\n", "import sys\ndef I():\n        return sys.stdin.readline().rstrip()\nfor _ in range(int(I())):\n    n = int(I())\n    a = list( map( int, I().split() ) )\n    m = int(I())\n    pl = sorted([ list( map( int, I().split() ) ) for _ in range( m ) ])\n    pln, mxs = [], 0\n    for x in pl[::-1]:\n        if x[ 1 ] > mxs:\n            pln.append( x )\n        mxs = max( mxs, x[ 1 ] )\n    pl = pln[::-1]\n    m = len( pl )\n    p, s = list(map( list, list(zip( *pl )) ))\n    if max( a ) > max( p ):\n        print( -1 )\n    else:\n        days = 0\n        c = 0\n        d2 = 1\n        while d2 <= m:\n            d2 *= 2\n        d2 //= 2\n        while c < n:\n            days += 1\n            mx = 0\n            inday = 0\n            while c < n:\n                mx = max( mx, a[ c ] )\n                inday += 1\n                pi = -1\n                d = d2\n                while d:\n                    np = pi + d\n                    if np < m and p[ np ] < mx:\n                        pi = np\n                    d //= 2\n                pi += 1\n                if pi < m and s[ pi ] >= inday:\n                    c += 1\n                else:\n                    break\n        print( days )\n", "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    h = [tuple(map(int, input().split())) for i in range(m)]\n    h.sort(reverse=True)\n    new_h = []\n    prev = 0\n    for p, s in h:\n        if s > prev:\n            new_h.append((p, s))\n            prev = s\n\n    h = new_h\n    hum = 0\n    res = 1\n    cur = 0\n    maxp = 0\n    for mon in a:\n        maxp = max(mon, maxp)\n        cur += 1\n        if mon > h[0][0]:\n            res = -1\n            break\n        if hum < len(h) and cur > h[hum][1]:\n            hum += 1\n        if hum == len(h) or maxp > h[hum][0]:\n            res += 1\n            hum = 0\n            cur = 1\n            maxp = mon\n\n    print(res)\n\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom bisect import bisect_left\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass SegTree:\n\n    def __init__(self, n, func, intv, A=[]):\n\n        self.n = n\n        self.func = func\n        self.intv = intv\n        n2 = 1\n        while n2 < n:\n            n2 <<= 1\n        self.n2 = n2\n        self.tree = [self.intv] * (n2 << 1)\n        if A:\n            for i in range(n):\n                self.tree[n2+i] = A[i]\n            for i in range(n2-1, -1, -1):\n                self.tree[i] = self.func(self.tree[i*2], self.tree[i*2+1])\n\n    def update(self, i, x):\n\n        i += self.n2\n        self.tree[i] = x\n        while i > 0:\n            i >>= 1\n            self.tree[i] = self.func(self.tree[i*2], self.tree[i*2+1])\n\n    def query(self, a, b):\n\n        l = a + self.n2\n        r = b + self.n2\n        s = self.intv\n        while l < r:\n            if r & 1:\n                r -= 1\n                s = self.func(s, self.tree[r])\n            if l & 1:\n                s = self.func(s, self.tree[l])\n                l += 1\n            l >>= 1\n            r >>= 1\n        return s\n\n    def get(self, i):\n        return self.tree[i+self.n2]\n\n    def all(self):\n        return self.tree[1]\n\ndef bisearch_max(mn, mx, func):\n\n    ok = mn\n    ng = mx\n    while ok+1 < ng:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef check(m):\n    mx = st.query(cur, m)\n    idx = bisect_left(P, mx)\n    if idx == M:\n        return False\n    _, s = PS[idx]\n    scnt = m - cur\n    return s >= scnt\n\nans = []\nfor _ in range(INT()):\n    N = INT()\n    A = LIST()\n    M = INT()\n    PS = []\n    for i in range(M):\n        p, s = MAP()\n        PS.append((p, s))\n\n    PS.sort()\n    for i in range(M-1, 0, -1):\n        if PS[i][1] > PS[i-1][1]:\n            PS[i-1] = (PS[i-1][0], PS[i][1])\n    P, _ = list(zip(*PS))\n    \n    st = SegTree(N, max, 0, A)\n    cur = day = 0\n    while cur < N:\n        res = bisearch_max(cur, N+1, check)\n        if res == cur:\n            ans.append(str(-1))\n            break\n        cur = res\n        day += 1\n    else:\n        ans.append(str(day))\n\nprint('\\n'.join(ans))\n", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nANS = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    m = int(input())\n    ps = [list(map(int, input().split())) for _ in range(m)]\n    p = [0] * (n+1)\n    for i in range(m):\n        p[ps[i][1]] = max(p[ps[i][1]], ps[i][0])\n    for i in range(n)[::-1]:\n        p[i] = max(p[i], p[i + 1])\n    if p[1] < max(a):\n        ANS.append(-1)\n        continue\n    ans = 0\n    mx = 0\n    cnt = 0\n    i = 0\n    for x in a:\n        cnt += 1\n        mx = max(mx, x)\n        if p[cnt] < mx:\n            ans += 1\n            mx = x\n            cnt = 1\n    if cnt:\n        ans += 1\n    ANS.append(ans)\n\nprint('\\n'.join(map(str, ANS)))\n", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nANS = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    m = int(input())\n    ps = [list(map(int, input().split())) for _ in range(m)]\n    p = [0] * (n+1)\n    for i in range(m):\n        p[ps[i][1]] = max(p[ps[i][1]], ps[i][0])\n    for i in range(n)[::-1]:\n        p[i] = max(p[i], p[i + 1])\n    if p[1] < max(a):\n        print(-1)\n        continue\n    ans = 0\n    mx = 0\n    cnt = 0\n    i = 0\n    for x in a:\n        cnt += 1\n        mx = max(mx, x)\n        if p[cnt] < mx:\n            ans += 1\n            mx = x\n            cnt = 1\n    if cnt:\n        ans += 1\n    print(ans)\n\n"]
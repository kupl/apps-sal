["n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = [0] * n\nstk = [0]\nfor i in range(1, n):\n    while len(stk) > 1 and c[stk[1]] - c[stk[0]] <= a[i] * (b[stk[0]] -\n            b[stk[1]]):\n        del stk[0]\n    c[i] = c[stk[0]] + a[i] * b[stk[0]]\n    while len(stk) > 1 and ((c[stk[-1]] - c[stk[-2]]) * (b[stk[-1]] - b[i]) >\n            (b[stk[-2]] - b[stk[-1]]) * (c[i] - c[stk[-1]])):\n        del stk[-1]\n    stk.append(i)\nprint(c[n - 1])\n", "n = int(input())\n\na = [0 for i in range(0, n + 1)]\nb = [0 for i in range(0, n + 1)]\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndp = [0 for i in range(0, n + 1)]\n\nc = [[0 for i in range(0, 3)] for j in range(0, n + 1)]\n\nstack = []\nstack.append(0)\nstack.append(1)\n\ndp[0] = 0\ndp[1] = a[1] * b[0]\n\ndef intersection(x, y):\n    return int((dp[y] - dp[x]) / (b[x] - b[y]))\n\nlast = 0\nc[last] = [0, intersection(0, 1), 0]\nlast+=1\nc[last] = [intersection(0, 1), 1000000001, 1]\nlast1=0\nfor i in range(2, n):\n\n    while (last1 >= 0):\n        if (c[last1][0] <= a[i] and c[last1][1] >= a[i]):\n            dp[i] = dp[c[last1][2]] + b[c[last1][2]] * a[i]\n            #print(i,dp[i])\n            break\n        elif c[last1][0] > a[i]:\n            last1 -= 1\n        else:\n            last1 += 1\n\n    while stack:\n        top = stack[-1]\n        if len(stack) >= 2:\n            second_top = stack[-2]\n            if intersection(second_top, i) < intersection(top,second_top):\n                stack.pop()\n                last -= 1\n            else:\n                break\n        else:\n            break\n\n    stack.append(i)\n    last += 1\n    c[last] = [intersection(top, i),1000000001,i]\n    c[last-1]= [c[last-1][0],intersection(top,i),c[last-1][2]]\n\nprint(dp[n-1])", "N = 100100\n\ndef main():\n    n = int(input())\n    d=[0]*N\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    m,c=[0]*N,[0]*N\n    m[0] = b[0]\n    c[0] = d[0]\n    \n    z = 1\n    p = 0\n    for i in range(1,n):\n        p = min(p,z)\n        while(p+1<z and m[p+1]*a[i]+c[p+1]<=m[p]*a[i]+c[p]):\n            p=p+1\n        d[i] = m[p]*a[i]+c[p]\n        while(z>=2 and (c[z-2]-c[z-1])*(b[i]-m[z-1])>=(c[z-1]-d[i])*(m[z-1]-m[z-2]) ):\n            z=z-1\n        m[z],c[z]=b[i],d[i]\n        z=z+1\n    #for j in range(n):print(d[j])\n    print(d[n-1])\n\nmain()\n", "read = lambda: map(int, input().split())\nn = int(input())\na = list(read())\nb = list(read())\ndp = [0] * n\nst = [0]\ndef f1():\n    i0, i1 = st[0], st[1]\n    b1 = dp[i1] - dp[i0]\n    k1 = b[i0] - b[i1]\n    return b1 <= a[i] * k1\ndef f2():\n    i1, i2 = st[-1], st[-2]\n    k1, k2 = b[i1] - b[i], b[i2] - b[i1]\n    b1, b2 = dp[i] - dp[i1], dp[i1] - dp[i2]\n    return b2 * k1 > b1 * k2\nfor i in range(1, n):\n    while len(st) > 1 and f1(): st.pop(0)\n    dp[i] = dp[st[0]] + a[i] * b[st[0]]\n    while len(st) > 1 and f2(): st.pop()\n    st.append(i)\nprint(dp[n - 1])", "read = lambda: list(map(int, input().split()))\nn = int(input())\na = list(read())\nb = list(read())\ndp = [0] * n\nch = [0]\n\n\ndef get(i, x):\n    return b[i] * x + dp[i]\n\n\ndef f1():\n    if len(ch) < 2:\n        return 0\n    return get(ch[0], a[i]) >= get(ch[1], a[i])\n\n\ndef f2():\n    if len(ch) < 2:\n        return 0\n    i1 = ch[-1]\n    x = (dp[i1] - dp[i]) / (b[i] - b[i1])\n    return get(ch[-2], x) <= get(i, x)\n\n\nfor i in range(1, n):\n    while f1():\n        ch.pop(0)\n    dp[i] = get(ch[0], a[i])\n    while f2():\n        ch.pop()\n    ch.append(i)\nprint(dp[n - 1])\n", "f = lambda: list(map(int, input().split()))\ng = lambda j: a[i] * b[j] + t[j]\nh = lambda j, k: (t[i] - t[j]) * (b[j] - b[k]) < (t[j] - t[k]) * (b[i] - b[j])\n\nn = int(input())\na, b = f(), f()\nt = [0] * n\np = [0]\nfor i in range(1, n):\n    while len(p) > 1 and g(p[1]) < g(p[0]): p.pop(0)\n    t[i] = g(p[0])\n    while len(p) > 1 and h(p[-2], p[-1]): p.pop()\n    p.append(i)\nprint(t[-1])", "N = 100100\n\ndef main():\n    n = int(input())\n    d=[0]*N\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    m,c=[0]*N,[0]*N\n    m[0] = b[0]\n    c[0] = d[0]\n    \n    z = 1\n    p = 0\n    for i in range(1,n):\n        p = min(p,z)\n        while(p+1<z and m[p+1]*a[i]+c[p+1]<=m[p]*a[i]+c[p]):\n            p=p+1\n        d[i] = m[p]*a[i]+c[p]\n        while(z>=2 and (c[z-2]-c[z-1])*(b[i]-m[z-1])>=(c[z-1]-d[i])*(m[z-1]-m[z-2]) ):\n            z=z-1\n        m[z],c[z]=b[i],d[i]\n        z=z+1\n    #for j in range(n):print(d[j])\n    print(d[n-1])\n\nmain()\n\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\na = list(map(int, input().split(' ')))\nb = list(map(int, input().split(' ')))\nc = [0]*n\nst = [0]*n\nfirst=0\nsecond=0    \nfor i in range(1,n):\n    #Delete from front until the value of lines is increasing w.r.to value a[i]\n    while(second-first>0 and a[i] * b[st[first]] + c[st[first]] >= a[i] * b[st[first+1]] + c[st[first+1]]):\n    \tfirst = first + 1;\n    c[i] = a[i] * b[st[first]] + c[st[first]];\n    #Delete from back until the intersection of lines last two lines in stack is to the left of the new line and the last line \n    while(second-first>0 and (b[st[second]] - b[i])*(c[st[second]] - c[st[second-1]]) > (c[i] - c[st[second]])*(b[st[second-1]] - b[st[second]])):\n    \tsecond = second-1;\n    second = second+1\n    st[second] = i;\nprint(c[n-1]);", "from collections import deque\n\nclass line:\n    def __init__(self, k, b):\n        self.k = k\n        self.b = b\n\n    def get(self, x):\n        return self.k * x + self.b\n\ndef check(l1, l2, nl):\n    return (nl.b - l2.b) * (l1.k - l2.k) - (nl.k - l2.k) * (l1.b - l2.b) <= 0\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nans = 0\n\nhull = deque()\nhull.append(line(b[0], 0))\nfor i in range(1, n):\n    arg = a[i]\n    while len(hull) > 1 and hull[0].get(arg) >= hull[1].get(arg):\n        hull.popleft()\n    ans = hull[0].get(arg)\n    nl = line(b[i], ans)\n    while len(hull) > 1 and check(hull[-2], hull[-1], nl):\n        hull.pop()\n    hull.append(nl)\n\nprint(ans)\n\n", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ndp=[0]*(n)\nst=[0]\nfor i in range(1,n):\n    while len(st)>1 and dp[st[0]] + b[st[0]]*a[i]>dp[st[1]] + b[st[1]]*a[i]:\n        st.pop(0)\n    dp[i]=dp[st[0]] + b[st[0]]*a[i]\n    while len(st)>1 and (dp[st[-2]] - dp[st[-1]])*(b[st[-2]] - b[i]) < (dp[st[-2]] - dp[i])*(b[st[-2]] - b[st[-1]]):\n        st.pop()\n    st.append(i)\nprint(dp[-1])    \n", "aa, bb, dp = [], [], []\n\ndef dot(i, a):\n    return dp[i] + a*bb[i]\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    b = list(map(int, input().split(' ')))\n\n    for k in range(n):\n        dp.append(0)\n        aa.append(a[k])\n        bb.append(b[k])\n\n    st, i, j = [0 for _ in range(n) ], 0,  0\n\n    for k in range(1,n):\n        while(j - i > 0 and dot(st[i],a[k]) >= dot(st[i+1],a[k])):\n            i+=1\n        dp[k] = a[k]*b[st[i]] + dp[st[i]]\n        while(j - i > 0 and (b[st[j]] - b[k])*(dp[st[j]] - dp[st[j-1]]) > (dp[k] - dp[st[j]])*(b[st[j-1]] - b[st[j]])):\n            j-=1\n        j+=1\n        st[j] = k\n\n\n    print(dp[-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "def dot(a, b, c):\n    return a + c*b\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    b = list(map(int, input().split(' ')))\n    dp = [ 0 for _ in range(n) ]\n    st = [0 for _ in range(n) ]\n    i, j = 0,  0\n\n    for k in range(1,n):\n        while(j - i > 0 and dot(dp[st[i]],b[st[i]],a[k]) >= dot(dp[st[i+1]],b[st[i+1]],a[k])):\n            i+=1\n        dp[k] = a[k]*b[st[i]] + dp[st[i]]\n        while(j - i > 0 and (b[st[j]] - b[k])*(dp[st[j]] - dp[st[j-1]]) > (dp[k] - dp[st[j]])*(b[st[j-1]] - b[st[j]])):\n            j-=1\n        j+=1\n        st[j] = k\n\n\n    print(dp[-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "def cross(i, j, k, b, cost):\n    # k, i, j\n    return (cost[i] - cost[j]) * (b[i] - b[k]) - (b[i] - b[j]) * (cost[i] - cost[k])\n\n\ndef dot(i, j, a, b, cost):\n    return cost[j] + a[i] * b[j]\n\n\ndef CF319C():\n    N = int(input())\n    a = tuple(map(int, input().split()))\n    b = tuple(map(int, input().split()))\n\n    cost = [0] * N\n    hull = [0] * N  # Make hull considering total minimum cost and charge of individual trees\n\n    left = 0\n    right = 1 # Index of items in hull\n    for i in range(1, N):\n        # Find the last cut tree which incurs minimum cost for ith tree\n        while left + 1 < right and dot(i, hull[left], a, b, cost) >= dot(i, hull[left + 1], a, b, cost):\n            # Only increase left when it decreases cutting cost\n            left += 1\n\n        cost[i] = dot(i, hull[left], a, b, cost)\n\n        while right >= 2 and cross(hull[right], hull[right - 1], i, b, cost) >= 0:\n            right -= 1\n        if left >= right: left = right - 1\n        right += 1\n        hull[right] = i\n\n    return cost[-1]\n\n\ndef __starting_point():\n    res = CF319C()\n    print(res)\n__starting_point()", "def cross(i, j, k, b, cost):\n    # k, i, j\n    return (cost[i] - cost[j]) * (b[i] - b[k]) - (b[i] - b[j]) * (cost[i] - cost[k])\n\n\ndef dot(i, j, a, b, cost):\n    return cost[j] + a[i] * b[j]\n\n\ndef CF319C():\n    N = int(input())\n    a = tuple(map(int, input().split()))\n    b = tuple(map(int, input().split()))\n\n    cost = [0] * N\n    hull = [0] * N  # Make hull considering total minimum cost and charge of individual trees\n\n    left = 0\n    right = 1 # Index of items in hull\n    for i in range(1, N):\n        # Find the last cut tree which incurs minimum cost for ith tree\n        while left + 1 < right and dot(i, hull[left], a, b, cost) >= dot(i, hull[left + 1], a, b, cost):\n            # Only increase left when it decreases cutting cost\n            left += 1\n\n        cost[i] = dot(i, hull[left], a, b, cost)\n\n        while right >= 2 and cross(hull[right], hull[right - 1], i, b, cost) >= 0:\n            right -= 1\n\n        right += 1\n        hull[right] = i\n\n    return cost[-1]\n\n\ndef __starting_point():\n    res = CF319C()\n    print(res)\n__starting_point()", "# referenced dukkha\n\ndef cross(i, j, k, b, cost):\n    return (cost[i] - cost[j]) * (b[i] - b[k]) - (b[i] - b[j]) * (cost[i] - cost[k])\n\n\ndef dot(i, j, a, b, cost):\n    return cost[j] + a[i] * b[j]\n\n\ndef CF319C():\n    N = int(input())\n    a = tuple(map(int, input().split()))\n    b = tuple(map(int, input().split()))\n\n    cost = [0] * N\n    hull = [0] * N  # Make hull considering total minimum cost and charge of individual trees\n\n    left = 0\n    right = 1 # Index of items in hull\n    for i in range(1, N):\n        # Find the last cut tree which incurs minimum cost for ith tree\n        while left + 1 < right and dot(i, hull[left], a, b, cost) >= dot(i, hull[left + 1], a, b, cost):\n            # Only increase left when it decreases cutting cost\n            left += 1\n\n        cost[i] = dot(i, hull[left], a, b, cost)\n\n        while right >= 2 and cross(hull[right], hull[right - 1], i, b, cost) >= 0:\n            right -= 1\n\n        right += 1\n        hull[right] = i\n\n    return cost[-1]\n\n\ndef __starting_point():\n    res = CF319C()\n    print(res)\n__starting_point()", "#d_n= [C_m+A_n*B_m] for m in range()\n#A=[ ->> ]\n#B=[ <<- ]\n\ndef intersection(p,q):\n    return (q[1]-p[1])/(p[0]-q[0])\n\ndef tree_cutting(n,A,B):\n    I=[[0,0] for _ in range(n)]\n    C=[0 for _ in range(n)]\n    \n    C[0]=0\n    I[0][0]=-float(\"inf\")\n    I[0][1]=float(\"inf\")\n    C[1]=C[0]+A[1]*B[0]\n    hull=[[B[0],C[0]],[B[1],C[1]]]\n    I[0][1]=intersection(hull[-1],hull[-2])\n    I[1][0]=I[0][1]\n    I[1][1]=float(\"inf\")\n    curr=1\n    k=0\n    for i in range(2,n):\n        k=min(k,curr)-1\n        while True:\n            k+=1\n            if I[k][0]<=A[i] and A[i]<=I[k][1]:\n                j=k\n                break\n        C[i]=hull[k][1]+A[i]*hull[k][0]\n        p=[B[i],C[i]]\n\n        while intersection(p,hull[-2])<=intersection(hull[-1],hull[-2]):\n            hull.pop()\n            curr-=1\n            if len(hull)<2: break\n        if B[i]!=hull[-1][0]:\n            hull.append(p)\n            I[curr][1]=intersection(hull[-1],hull[-2])\n            curr+=1\n            I[curr][0]=intersection(hull[-1],hull[-2])\n            I[curr][1]=+float(\"inf\")\n        else:\n            I[curr][1]=+float(\"inf\")\n    return C[n-1]\n\ndef __starting_point():\n    n=int(input())\n    A=list(map(int,input().strip().split()))\n    B=list(map(int,input().strip().split()))\n    print(tree_cutting(n,A,B))\n__starting_point()", "n=int(input())\nA=list(map(int,input().strip().split()))\nB=list(map(int,input().strip().split()))\nC=[0 for _ in range(n)]\nhullx=[0 for _ in range(n)]\nhully=[0 for _ in range(n)]    \n    \nsz=-1\np=0\n\ndef intersection(p,q):\n    nonlocal hullx,hully\n    return (hully[q]-hully[p])/(hullx[p]-hullx[q])\ndef insert(B,C):\n    nonlocal sz,p,hullx,hully\n    sz+=1\n    hullx[sz]=B\n    hully[sz]=C\n    while sz>1 and intersection(sz-1,sz-2)>=intersection(sz-1,sz):\n        hullx[sz-1]=hullx[sz]\n        hully[sz-1]=hully[sz]\n        sz-=1\ndef query(x):\n    nonlocal sz,p,B,C\n    p=min(sz,p)\n    while sz>0 and p<sz and intersection(p,p+1)<=x: p+=1\n    return hully[p]+hullx[p]*x\n\n\nC[0]=0\ninsert(B[0],0)\n\nfor i in range(1,n):\n    C[i]=query(A[i])\n    insert(B[i],C[i])\nprint(C[n-1])\n", "n=int(input())\nA=list(map(int,input().strip().split()))\nB=list(map(int,input().strip().split()))\nC=[0 for _ in range(n)]\nhullx=[0 for _ in range(n)]\nhully=[0 for _ in range(n)]    \n    \nsz=-1\np=0\n\ndef intersection(p,q):\n    nonlocal hullx,hully\n    return (hully[q]-hully[p])/(hullx[p]-hullx[q])\ndef insert(B,C):\n    nonlocal sz,p,hullx,hully\n    sz+=1\n    hullx[sz]=B\n    hully[sz]=C\n    while sz>1 and intersection(sz-1,sz-2)>=intersection(sz-1,sz):\n        hullx[sz-1]=hullx[sz]\n        hully[sz-1]=hully[sz]\n        sz-=1\ndef query(x):\n    nonlocal sz,p,B,C\n    p=min(sz,p)\n    while sz>0 and p<sz and intersection(p,p+1)<=x: p+=1\n    return hully[p]+hullx[p]*x\n\n\nC[0]=0\ninsert(B[0],0)\n\nfor i in range(1,n):\n    C[i]=query(A[i])\n    insert(B[i],C[i])\n    \nprint(C[n-1])\n", "n=int(input())\nA=list(map(int,input().strip().split()))\nB=list(map(int,input().strip().split()))\n\ndef tree_cutting(n,A,B):\n    C=[0 for _ in range(n)]\n    hullx=[0 for _ in range(n)]\n    hully=[0 for _ in range(n)]    \n    \n    sz=0\n    p=0\n\n    C[0]=0\n    hullx[0]=B[0]\n    hully[0]=C[0]\n\n    for i in range(1,n):\n        p=min(sz,p)\n        while sz>0 and p<sz and (hully[p+1]-hully[p])/(hullx[p]-hullx[p+1])<=A[i]:\n            p+=1\n        C[i]=hully[p]+hullx[p]*A[i]\n        sz+=1\n        hullx[sz]=B[i]\n        hully[sz]=C[i]\n        while sz>1 and (hully[sz-2]-hully[sz-1])/(hullx[sz-1]-hullx[sz-2])>=(hully[sz-2]-hully[sz])/(hullx[sz]-hullx[sz-2]):\n            hullx[sz-1]=hullx[sz]\n            hully[sz-1]=hully[sz]\n            sz-=1\n    return C[n-1]\n    \nprint(tree_cutting(n,A,B))\n"]
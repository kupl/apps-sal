["class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # 1, 2, 2, 3, 3, 4, 6, 7, 8\n        # 1 2 3\n        #   2 3 4\n        #         6 7 8\n        \n        # W length Q\n        # how many opened\n        # # of the element is current opened one\n        \n        q = deque()\n        opened = 0\n        last = 0\n        counter = Counter(hand)\n        for n in sorted(counter):\n            count = counter[n]\n            if n > last + 1 and opened > 0:\n                return False\n            \n            if n == last + 1 and count < opened:\n                return False\n            \n            \n            q.append(count - opened)\n            opened = count\n            \n            if len(q) == W:\n                opened -= q.popleft()\n            \n            last = n\n        return not opened", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        \n        counter = collections.Counter(hand)\n        \n        for num in hand:\n            if counter[num - 1] > 0 or counter[num] == 0:\n                continue\n                \n            curr = num\n            cnt = 0\n            while cnt < W:\n                if counter[curr] == 0:\n                    return False\n                counter[curr] -= 1\n                curr += 1\n                cnt += 1\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W != 0:\n            return False\n        heap = [(key,val) for key,val in list(Counter(hand).items())]\n        heapq.heapify(heap)\n        while heap:\n            pre,prec = None, None\n            temp = deque()\n            for _ in range(W):\n                if not heap:\n                    return False\n                num,count = heapq.heappop(heap)\n                if not pre:\n                    pre,prec = num,count\n                    continue\n                if num != pre+1 or count < prec:\n                    return False\n                pre = num\n                if count > prec:\n                    temp.append((num,count-prec))\n            while temp:\n                heapq.heappush(heap,temp.pop())\n        return True\n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        while count:\n            key = min(count)\n            for k in range(key, key+W):\n                check = count[k]\n                if not check:\n                    return False\n                else:\n                    count[k] -= 1\n                if check == 1:\n                    del count[k]\n        return True", "from collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        N = len(hand)\n        if N%W != 0:\n            return False\n                \n        counter = Counter(hand)\n        while counter:\n            first = min(counter.keys())\n            for i in range(first, first+W):\n                if i not in counter:\n                    return False\n                counter[i] -= 1\n                if counter[i] == 0:\n                    del counter[i]\n                    \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = Counter(hand)\n        while c:\n            x = min(c.keys())\n            for i in range(x,x+W):\n                if i not in c: return False\n                c[i] -= 1\n                if c[i] == 0: del c[i]\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True\n            \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand) % W != 0:\n            return False\n     \n        dic = defaultdict(int)\n        for i in range(len(hand)):\n            dic[ hand[i] ] += 1\n        \n        \n        \n        for i in range(0, len(hand), W):\n            \n            start = min(dic.keys())\n            dic[start] -= 1\n            if dic[start] == 0:\n                del dic[start]\n            for i in range(1, W):\n                start += 1\n                if start not in dic:\n                    return False\n                dic[start] -= 1\n                if dic[start] == 0:\n                    del dic[start]    \n            \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        cnt = collections.Counter(hand)\n        while cnt:\n            m = min(cnt)\n            for i in range(m, m + W):\n                if i not in cnt:\n                    return False\n                elif cnt[i] == 1:\n                    del cnt[i]\n                else:\n                    cnt[i] -= 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = Counter(hand)\n        while c:\n            i = min(c)\n            for j in range(i, i + W):\n                if not c[j]:\n                    return False\n                c[j] -= 1\n                if not c[j]:\n                    del c[j]\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # counter = collections.Counter(hand)\n        d = collections.defaultdict(lambda:0)\n        for h in hand:\n            d[h]+=1\n            \n        # start = min(hand)\n        \n        while d:\n            # print(d.keys())\n            start = min(d.keys())\n            for i in range(start, start+W):\n                if not d[i]:\n                    return False\n                d[i]-=1\n                if not d[i]:\n                    del d[i]\n        \n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        L = len(hand)\n        if L % W != 0:\n            return False\n        count = Counter(hand)\n        Nparts = L // W\n        \n        for i in range(Nparts):\n            i_min = min(count.keys())\n            for j in range(W):\n                if (i_min + j) not in count:\n                    return False\n                count[i_min + j]  -= 1\n                if count[i_min + j] == 0:\n                    del count[i_min + j]\n        return True \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        dp = defaultdict(list)\n        for e in sorted(hand):\n            dp[e].append(dp[e-1].pop()+1) if len(dp[e-1]) != 0 else dp[e].append(1)\n            if dp[e] and dp[e][-1]==W: dp[e].pop()\n        return all(len(e)==0 for e in list(dp.values()))\n        # c = Counter(hand)\n        # while c:\n        #     x = min(c.keys())\n        #     for i in range(x,x+W):\n        #         if i not in c: return False\n        #         c[i] -= 1\n        #         if c[i] == 0: del c[i]\n        # return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n#         hand.sort()\n        \n#         mask = 0\n        \n#         i = 0\n#         while i < len(hand):\n#             lst = -1\n#             k = 0\n#             j = 0\n#             for j in range(len(hand)):\n#                 if mask & (1 << j) > 0:\n#                     continue\n#                 elif lst == -1 or lst == hand[j] - 1:\n#                     mask = mask | (1 << j)\n#                     lst = hand[j]\n#                     k += 1\n#                     i += 1\n#                     if k == W:\n#                         break \n            \n#             if k != W:\n#                 return False\n                \n#         return True\n\n            counter = collections.Counter(hand)\n            \n            while counter:\n                m = min(counter)\n                for k in range(m, m+W):\n                    \n                    if not counter[k]:\n                        return False\n                    \n                    counter[k] -= 1\n                    \n                    if counter[k] == 0:\n                        del counter[k]\n            return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W:\n            return False\n        \n        C = Counter(hand)\n        #print (C)\n        for i in range(n//W):\n            mn = min(C.keys())\n            for j in range(mn, mn + W):\n                if j not in C:\n                    return False\n                else:\n                    C[j] -= 1\n                    if C[j] == 0:\n                        del C[j]\n                    \n        return True\n", "from collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = Counter(hand)\n        while len(c) > 0:\n            curr = min(c)\n            v = c[curr]\n            del(c[curr])\n            for i in range(1,W):\n                if curr + i not in c or c[curr + i] < v:\n                    return False\n                else:\n                    c[curr + i] -= v\n                    if c[curr + i] == 0:\n                        del(c[curr+i])\n        \n        return True\n            \n            \n                        \n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True", "from collections import OrderedDict \n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        numHash = {}\n        for n in hand:\n            if n not in numHash:\n                numHash[n] = 1\n            else:\n                numHash[n] += 1\n                \n        while numHash:\n            num = min(numHash)\n            for n in range(W):\n                nextNum = num + n\n                \n                if nextNum in numHash:\n                    numHash[nextNum] -= 1\n                    if numHash[nextNum] == 0:\n                        del numHash[nextNum]\n                else:\n                    return False\n        return True\n        \n        \n", "from collections import OrderedDict\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True\n#         d = OrderedDict()\n        \n#         hand.sort()\n        \n#         # print(hand)\n#         for val in hand:\n#             if val in d:\n#                 d[val] += 1\n#             else:\n#                 d.setdefault(val, 1)\n            \n#         i = 0\n#         length = len(d)\n#         items = list(d.items())\n#         items = list(map(list, items))\n#         while i <= length-W:\n#             k, v = items[i]\n#             if v == 0:\n#                 i += 1\n#                 continue\n#             temp = W\n#             j = i\n#             prev = k\n#             if j >= len(items):\n#                 return False\n#             while temp > 0:\n#                 if items[j][0] != prev:\n#                     return False\n#                 else:\n#                     items[j][1] -= 1\n#                 j += 1\n#                 prev = prev + 1\n#                 temp -= 1\n#                 if temp != 0 and j >= len(items):\n#                     return False\n        \n#         for i in range(length-W, length):\n#             k, v = items[i]\n#             if v != 0:\n#                 return False\n#         return True\n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if(len(hand) % W != 0):\n            return False\n        count = Counter(hand)\n        while(count):\n            min_v = min(count.keys())\n            for i in range(min_v, min_v+W):\n                if(count[i] == 0):\n                    return False\n                count[i]-=1\n                if(count[i] == 0):\n                    del count[i]\n                    \n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        \n        while(count):\n            m = min(count)\n            for k in range(m, m + W):\n                v = count[k]\n                if not v:\n                    return False\n                if v == 1:\n                    del count[k]\n                    \n                    \n                else:\n                    count[k] = v - 1\n                    \n                    \n        return True", "from collections import defaultdict\nclass Solution(object):\n    def isNStraightHand(self, hand, W):\n        dic = dict()\n        for val in hand:\n            dic[val] = dic.get(val, 0) + 1\n        \n        while dic:\n            min_val = min(dic.keys())\n            for i in range(min_val, min_val+W):\n                v = dic.get(i, 0)\n                if v == 0:\n                    return False\n                dic[i] -= 1\n                if dic[i] == 0:\n                    dic.pop(i)\n                \n        return True", "\nclass Solution:\n    # WA\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if W ** 2 != len(hand):\n            return False\n        hand.sort()\n        for i in range(0, len(hand), W):\n            for j in range(1, W):\n                if hand[i + j] - hand[i + j - 1] != 1:\n                    return False\n        return True\n                \nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        from collections import Counter\n        ct = Counter(hand)\n        hand = sorted(ct.items())\n        # print(hand)\n        i = 0\n        while i < len(hand):\n            if hand[i][1] == 0:\n                i += 1\n                continue\n            hand[i] = (hand[i][0], hand[i][1] - 1)\n            k = hand[i][0]\n            # print(k)\n            for j in range(1, W):\n                k += 1\n                if i + j < len(hand) and hand[i + j][0] == k:\n                    # print(k)\n                    hand[i + j] = (hand[i + j][0], hand[i + j][1] - 1)\n                else:\n                    return False\n        return True\n                    \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        import collections\n        count = collections.Counter(hand)\n        while count:\n            num = min(count.keys())\n            val = count[num]\n            for j in range(W):\n                if count[num+j] < val:\n                    return False\n                elif count[num+j] == val:\n                    del count[num+j]\n                else:    \n                    count[num+j] -= val\n                \n            \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # Time: O(n*n/w)\n        # Space: O(n)\n        \n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for j in range(m, m + W):\n                if not count[j]:\n                    return False\n                if count[j] == 1:\n                    del count[j]\n                else:\n                    count[j] -= 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!= 0:\n            return False    \n        freq = Counter(hand)\n        \n        while freq:\n            m = min(freq)\n            for i in range(m, m+W):\n                v = freq[i]\n                if not v: return False\n                if v == 1:\n                    del freq[i]\n                else:\n                    freq[i] -= 1\n        return True\n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0: return False\n        count = collections.Counter(hand)\n        while count:\n            x = min(count)\n            for k in range(x,x+W):\n                v = count[k]\n                if not v: return False\n                if v == 1: del count[k]\n                else: count[k] = v-1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        count = Counter(hand)\n        for i in range(len(hand) // W):\n            num, group_count = min(count.keys()), 0\n            while group_count < W:\n                count[num] -= 1\n                if count[num] == 0:\n                    del count[num]\n                elif count[num] < 0:\n                    return False\n                group_count += 1\n                num += 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0: return False\n        counter = defaultdict(int)\n        for elem in hand:\n            counter[elem] += 1\n        while len(counter) > 0:\n            curr = min(counter.keys())\n            counter[curr] -= 1\n            if counter[curr] == 0:\n                del counter[curr]\n            for i in range(1,W):\n                curr += 1\n                if curr in counter:\n                    counter[curr] -= 1\n                    if counter[curr] == 0:\n                        del counter[curr]\n                else:\n                    return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = collections.Counter(hand)\n        \n        while counter:\n            starter = min(counter.keys())\n            for i in range(W):\n                if starter + i not in counter:\n                    return False\n                else:\n                    counter[starter+i] -= 1\n                    if counter[starter+i] == 0:\n                        del counter[starter+i]\n                        \n        \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        count = Counter(hand)\n        for i in range(len(hand) // W):\n            num = min(count.keys())\n            for j in range(W):\n                count[num+j] -= 1\n                if count[num+j] == 0:\n                    del count[num+j]\n                elif count[num+j] < 0:\n                    return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!= 0:\n            return False    \n        freq = Counter(hand)\n        \n        while freq:\n            m = min(freq)\n            for i in range(m, m+W):\n                v = freq[i]\n                if not v: return False\n                if v == 1:\n                    del freq[i]\n                else:\n                    freq[i] = v -1\n        return True\n        \n", "class Solution:\n    \n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0: return False\n        \n        hand = sorted(hand)\n                \n        failed = False\n        while hand and not failed:\n            group = [hand[0]]\n            del hand[0]\n                        \n            idx = 0\n            while len(group) < W and idx < len(hand):\n                if group[-1] + 1 == hand[idx]: \n                    group.append(hand[idx])\n                    del hand[idx]\n                else:\n                    idx += 1\n                        \n            if len(group) < W: failed = True\n                    \n        return not failed\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        maps = Counter(hand)\n        while maps:\n            k = min(maps.keys())\n            count = maps[k]\n            for i in range(k, k + W): \n                if i not in maps or maps[i] < count:\n                    return False\n                maps[i] -= count\n                if maps[i] == 0:\n                    maps.pop(i)\n                    \n        return True\n", "from collections import OrderedDict \n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        numHash = {}\n        \n        for n in hand:\n            if n not in numHash:\n                numHash[n] = 1\n            else:\n                numHash[n] += 1\n        numHash = OrderedDict(sorted(numHash.items()))\n        while len(numHash) > 0:\n            num = list(numHash.keys())[0]\n            for n in range(W):\n                nextNum = num + n\n                \n                if nextNum in numHash:\n                    numHash[nextNum] -= 1\n                    if numHash[nextNum] == 0:\n                        del numHash[nextNum]\n                else:\n                    return False\n        return True\n        \n        \n", "class Solution(object):\n    def isNStraightHand(self, hand, W):\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = collections.Counter(hand)\n        \n        while counter:\n            num = min(counter)\n            \n            for _ in range(W):\n                if num not in counter:\n                    return False\n                \n                counter[num] -= 1\n                if counter[num] == 0:\n                    del counter[num]\n                \n                num += 1\n                \n        return True\n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        dic = Counter(hand)\n        \n        while dic:\n            small = min(dic.keys())\n            for i in range(small, small + W):\n                if dic[i] ==0 :\n                    return False\n                dic[i] -= 1\n                if dic[i] ==0:\n                    del dic[i]\n        return True\n                    \n        \n            \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        count = Counter(hand)\n        # min_keys = sorted(count.keys())\n        for i in range(len(hand) // W):\n            # base = min_keys[0]\n            base = min(count)\n            for num in range(base, base+W):\n                count[num] -= 1\n                if count[num] == 0:\n                    # min_keys.remove(num)\n                    del count[num]\n                elif count[num] < 0:\n                    return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W: return False\n        counter = Counter(hand)\n        keys = set(counter.keys())\n        while counter:\n            key = min(keys)\n            while key in keys:\n                for w in range(W):\n                    if key+w not in counter:\n                        return False\n                    counter[key+w] -= 1\n                    if counter[key+w] == 0:\n                        del counter[key+w]\n                        keys.remove(key+w)\n        \n        return True\n    \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        #if len(hand) != W**2:\n        #    return False\n        \n        counted = {}\n        for i in hand:\n            if i not in counted:\n                counted[i] = 0\n            counted[i] += 1\n        \n        def containStrait(numbers, counted, W):\n            #print(numbers, counted)\n            if len(counted) == 0:\n                return True\n            if len(numbers) < W:\n                return False\n            \n            if numbers[W - 1] - numbers[0] > W:\n                return False\n                #counted.pop(numbers[0])\n                #numbers.remove(numbers[0])\n                #return containStrait(numbers, counted, W, count)\n            else:\n                for i in reversed(range(W)):\n                    counted[numbers[i]] -= 1\n                    if counted[numbers[i]] == 0:\n                        counted.pop(numbers[i])\n                        numbers.remove(numbers[i])\n                #count -= 1\n            return containStrait(numbers, counted, W)\n        \n        numbers = sorted(counted.keys())\n        return containStrait(numbers, counted, W)", "import collections\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if W<1:\n            return False\n        \n        if len(hand)%W != 0:\n            return False\n        \n        counter = collections.Counter(hand)\n        sorted(counter.items(), key=lambda i: i[0])\n        \n        dic = {}\n        dic = collections.OrderedDict(sorted(dict(counter).items()))\n        \n        while dic:\n        \n            dic_list = list(dic.keys())\n\n            base = dic_list[0]\n\n            for i in range(W):\n                if base+i not in dic:\n                    return False\n                dic[base+i] -= 1\n                if dic[base+i]==0:\n                    dic.pop(base+i, None)                \n         \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        counter = Counter(hand)\n        heap_hands=[]\n        groups=[]\n        for k, v in counter.items():\n            heapq.heappush(heap_hands,(k,v))\n        \n        while(heap_hands):\n            count=0\n            sub_group=[]\n            remaining_elements=[]\n            while(count<W):\n                if not heap_hands:\n                    return False\n                popped_elem=heapq.heappop(heap_hands)\n                if popped_elem[1]-1>0:\n                    remaining_elements.append(popped_elem)\n                if not sub_group:\n                    sub_group.append(popped_elem[0])\n                else:\n                    if popped_elem[0]-1 == sub_group[-1]:\n                        sub_group.append(popped_elem[0])\n                    else:\n                        return False\n                count+=1\n\n            groups+=sub_group\n            for elem in remaining_elements:\n                heapq.heappush(heap_hands,(elem[0],elem[1]-1))\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counted = {}\n        for i in hand:\n            if i not in counted:\n                counted[i] = 0\n            counted[i] += 1\n        \n        def containStrait(numbers, counted, W):\n            if len(counted) == 0:\n                return True\n            if len(numbers) < W:\n                return False\n            \n            if numbers[W - 1] - numbers[0] > W:\n                return False\n            else:\n                for i in reversed(range(W)):\n                    counted[numbers[i]] -= 1\n                    if counted[numbers[i]] == 0:\n                        counted.pop(numbers[i])\n                        numbers.remove(numbers[i])\n            return containStrait(numbers, counted, W)\n        \n        numbers = sorted(counted.keys())\n        return containStrait(numbers, counted, W)", "from collections import Counter\n\nclass Solution:\n    '''def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)<W or len(hand)%W!=0:\n            return False\n        count = Counter(hand)\n\n        while count:\n            sublist = []\n            item = min(count)\n            sublist.append(item)\n            if count[item]==1:\n                del count[item]\n            else:\n                count[item]-=1\n            while len(sublist)<W:\n                item+=1\n                if item not in count:\n                    return False\n                sublist.append(item+1)\n                if count[item]==1:\n                    del count[item]\n                else:\n                    count[item]-=1\n        return True'''\n        \n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # no need to store the subist themselves \n        if len(hand)<W or len(hand)%W!=0:\n            return False\n        count = Counter(hand)\n\n        while count:\n            item = min(count)\n            if count[item]==1:\n                del count[item]\n            else:\n                count[item]-=1\n            i= 1\n            while i<W:\n                item+=1\n                i+=1\n                if item not in count:\n                    return False\n                if count[item]==1:\n                    del count[item]\n                else:\n                    count[item]-=1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for i in range(m, m+W):\n                if not count[i]:\n                    return False\n                if count[i] == 1:\n                    del(count[i])\n                else:\n                    count[i] -= 1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        #if len(hand) != W**2:\n        #    return False\n        \n        counted = {}\n        for i in hand:\n            if i not in counted:\n                counted[i] = 0\n            counted[i] += 1\n        \n        def containStrait(numbers, counted, W):\n            #print(numbers, counted)\n            if len(counted) == 0:\n                return True\n            if len(numbers) < W:\n                return False\n            \n            if numbers[W - 1] - numbers[0] > W:\n                counted.pop(numbers[0])\n                numbers.remove(numbers[0])\n                #return containStrait(numbers, counted, W, count)\n            else:\n                for i in reversed(range(W)):\n                    counted[numbers[i]] -= 1\n                    if counted[numbers[i]] == 0:\n                        counted.pop(numbers[i])\n                        numbers.remove(numbers[i])\n                #count -= 1\n            return containStrait(numbers, counted, W)\n        \n        numbers = sorted(counted.keys())\n        return containStrait(numbers, counted, W)", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        \n        if len(hand)%W!=0:\n            return False\n        \n        while hand:\n            z = min(hand)\n            for t in range(z,z+W):\n                try:\n                    hand.remove(t)\n                except:\n                    return False\n        \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        #if len(hand) != W**2:\n        #    return False\n        \n        counted = {}\n        for i in hand:\n            if i not in counted:\n                counted[i] = 0\n            counted[i] += 1\n        \n        def containStrait(numbers, counted, W):\n            #print(numbers, counted)\n            if len(counted) == 0:\n                return True\n            if len(numbers) < W:\n                return False\n            \n            if numbers[W - 1] - numbers[0] > W:\n                counted.pop(numbers[0])\n                numbers.remove(numbers[0])\n                #return containStrait(numbers, counted, W, count)\n            else:\n                min_count = sys.maxsize\n                for i in reversed(range(W)):\n                    if counted[numbers[i]] < min_count:\n                        min_count = counted[numbers[i]]\n                    \n                for i in reversed(range(W)):\n                    counted[numbers[i]] -= min_count\n                    if counted[numbers[i]] == 0:\n                        counted.pop(numbers[i])\n                        numbers.remove(numbers[i])\n                #count -= 1\n            return containStrait(numbers, counted, W)\n        \n        numbers = sorted(counted.keys())\n        return containStrait(numbers, counted, W)", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        dp = defaultdict(list)\n        \n        for e in sorted(hand):\n            dp[e].append(dp[e-1].pop()+1) if len(dp[e-1]) != 0 else dp[e].append(1)\n            if dp[e] and dp[e][-1]==W: dp[e].pop()\n                \n            \n                \n        return all(len(e)==0 for e in list(dp.values()))\n        # c = Counter(hand)\n        # while c:\n        #     x = min(c.keys())\n        #     for i in range(x,x+W):\n        #         if i not in c: return False\n        #         c[i] -= 1\n        #         if c[i] == 0: del c[i]\n        # return True\n", "\nfrom collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W != 0:\n            return False\n        count_dict = Counter(hand)\n        while count_dict:\n            m = min(count_dict)\n            for i in range(m,m+W):\n                if i not in count_dict:\n                    return False\n                elif count_dict[i] == 1:\n                    del(count_dict[i])\n                else:\n                    count_dict[i]-=1\n        return True\n                \n                    \n\n                    \n", "class Solution:\n    def isNStraightHand(self, nums: List[int], W: int) -> bool:\n        n = len(nums)\n\n        if n % W != 0:\n            return False\n\n        nums.sort()\n\n        dic = OrderedDict()\n\n        for num in nums:\n            dic[num] = dic.get(num, 0) + 1\n\n        while dic:\n            m = min(dic)\n            for i in range(m, m+W):\n                val = dic.get(i)\n\n                if not val:\n                    return False\n                if val == 1:\n                    del dic[i]\n                else:\n                    dic[i] -= 1\n        return True\n\n", "import collections\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        handCounter = Counter()\n        for number in hand:\n            handCounter[number] += 1\n        while len(handCounter) != 0:\n            m = min(handCounter.keys())\n            for i in range(m, m+W):\n                if i not in handCounter:\n                    return False\n                handCounter[i] -= 1\n                if handCounter[i] == 0:\n                    del handCounter[i]\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n\n        cardCount = {}\n\n        for card in hand:\n            if not card in cardCount:\n                cardCount[card] = 0\n            cardCount[card] += 1\n\n        k = len(hand) // W\n\n        for i in range(k):\n            start = min(cardCount.keys())\n            \n            for j in range(W):\n                if not start + j in cardCount:\n                    return False\n\n            for j in range(W):\n                cardCount[start + j] -= 1\n                if cardCount[start + j] == 0:\n                    cardCount.pop(start + j)\n\n        return True\n\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False    # if v is zero \n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True\n", "from collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        counter = Counter(hand)\n        # print (counter)\n        \n        while counter:\n            \n            key = min(counter)\n            for x in range(key, key + W):\n                if counter[x] < 1:\n                    return False\n                counter[x] -= 1\n                if counter[x] == 0:\n                    del counter[x]\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        \n        def helper(hand):\n            # print(hand)\n            if not hand: return\n            if len(hand) % W != 0: \n                self.ans = False\n                return\n            n = len(hand)\n            i, k = 0, 0\n            prev = hand[0]-1\n            new_hand = []\n            while i < n and k < W:\n                if hand[i] == prev:\n                    new_hand.append(hand[i])\n                else:\n                    if hand[i] != prev + 1:\n                        self.ans = False\n                        return\n                    else:\n                        prev += 1\n                        k += 1\n                i += 1\n            \n            new_hand += hand[i:]\n            if not new_hand:\n                self.ans = True\n                return\n            return helper(new_hand)\n    \n        helper(hand)\n        return self.ans", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        result = []\n        while count:\n            m = min(count)\n            straights = []\n            for i in range(m, m + W):\n                if i in count:\n                    straights.append(i)\n                    count[i] -= 1\n                    if count[i] == 0:\n                        del count[i]\n                else:\n                    return False\n            result.append(straights)\n        print(result)\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        counter = collections.Counter(hand)\n        while counter:\n            smallest = min(counter)\n            for j in range(smallest, smallest+W):\n                if j not in counter:\n                    return False\n                counter[j] -= 1\n                if counter[j] == 0:\n                    del counter[j]\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        dic = collections.OrderedDict(sorted(count.items()))\n        while dic:\n            m = next(iter(dic))\n            #print(m)\n            for k in range(m, m+W):\n                v = dic.get(k)\n                print(v,k)\n                if not v: \n                    return False\n                if v == 1:\n                    del dic[k]\n                else:\n                    dic[k] = v - 1\n\n        return True", "class Solution:\n    def isNStraightHand(self, nums: List[int], W: int) -> bool:\n        n = len(nums)\n\n        if n % W != 0:\n            return False\n\n        nums.sort()\n\n        dic = OrderedDict()\n\n        for num in nums:\n            dic[num] = dic.get(num, 0) + 1\n\n        while len(list(dic.keys())) > 0:\n            m = min(dic)\n            for i in range(m, m+W):\n                val = dic.get(i)\n\n                if not val:\n                    return False\n                if val == 1:\n                    del dic[i]\n                else:\n                    dic[i] -= 1\n        return True\n\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = collections.Counter(hand)\n        s = set(hand)\n        \n        while s:\n            minv = min(s)\n            for i in range(minv, minv + W):\n                if i not in counter or counter[i] == 0:\n                    return False\n                counter[i] -= 1\n                if counter[i] == 0:\n                    s.remove(i)\n        \n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = Counter(hand)\n        while c:\n            j = min(c)\n            for i in range(j,j+W):\n                if not c[i]:\n                    return False\n                if c[i] == 1:\n                    del c[i]\n                else:\n                    c[i] -= 1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = collections.Counter(hand)\n        s = set(hand)\n        \n        while s:\n            minv = min(s)\n            for i in range(minv, minv + W):\n                if i not in counter:\n                    return False\n                counter[i] -= 1\n                if counter[i] == 0:\n                    del counter[i]\n                    s.remove(i)\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        # digits = collections.defaultdict(int)\n        # for d in hand:\n            # digits[d] += 1\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            # k, v = sorted(digits.items())[0]\n            for k in range(m, m+W):\n                v = count[k]\n                if not v:\n                    return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] -= 1\n        return True\n            \n            \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m + W):\n                if not count[k]:\n                    return False\n                if count[k] == 1:\n                    del count[k]\n                else:\n                    count[k] -= 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand) % W != 0:\n            return False\n        \n        counter = Counter(hand)\n        \n        while counter:\n            start = min(counter)\n            \n            for n in range(start, start + W):\n                if n in counter:\n                    counter[n] -= 1\n                    if counter[n] == 0:\n                        del counter[n]\n                else:\n                    return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0: \n            return False\n        \n        hand = sorted(hand)\n        counts = collections.Counter(hand) # key: card, val: freq\n        print(counts)\n        # tree map: ordered hashmap\n        while sum(counts.values()) > 0:\n            start_card = min(counts)\n            print(start_card)\n            \n            for card in range(start_card, start_card + W):\n                # check each group in one for-loop\n                if card not in counts:\n                    return False\n                counts[card] -= 1\n                if counts[card] == 0:\n                    del counts[card]\n        \n            # counts[start_card] -= 1\n            # if counts[start_card] == 0:\n            #     del counts[start_card]\n                \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand = collections.Counter(hand)\n        while True:\n            if len(hand) == 0:\n                return True\n            m = min(hand)\n            for c in range(m, m + W):\n                if c not in hand:\n                    return False\n                if hand[c] == 1:\n                    del hand[c]\n                else:\n                    hand[c] -= 1\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        dic = collections.OrderedDict(sorted(collections.Counter(hand).items()))\n        while dic:\n            m = next(iter(dic))\n            #print(m)\n            for k in range(m, m+W):\n                v = dic.get(k)\n                #print(v,k)\n                if not v: \n                    return False\n                if v == 1:\n                    del dic[k]\n                else:\n                    dic[k] = v - 1\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0: return False\n        count = collections.Counter(hand)\n        while n > 0:\n            a = min(count)\n            for i in range(W):\n                if count[a + i] <= 0:\n                    return False\n                count[a + i] -= 1\n                if count[a + i] == 0:\n                    del count[a + i]\n            n -= W\n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        '''\n        O(n log n): sort the hand, every time we see dont have a consecutive value\n                 or hit length W, we start a new group\n                 \n        '''\n        counter = Counter(hand)\n        count = W\n        while counter:\n            if count == W:\n                count = 0\n                val = min(counter)\n            else:\n                val += 1\n                if not counter[val]:\n                    return False                    \n            counter[val] -= 1\n            if not counter[val]:\n                del counter[val]\n            count += 1\n        return count == W\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand or len(hand)%W != 0:\n            return False\n        hand_dict = self.get_hand_dict(hand)\n        return self.is_n_straigh_hand(hand_dict, W)\n        \n    def is_n_straigh_hand(self, hand_dict, W):\n        while hand_dict:\n            start_hand = min(hand_dict)\n            count = hand_dict[start_hand]\n            for i in range(start_hand, W + start_hand):\n                if i not in hand_dict:\n                    return False\n                else:\n                    hand_dict[i] -= count\n                    if hand_dict[i] == 0:\n                        del hand_dict[i]\n                    elif hand_dict[i] < 0:\n                        return False\n        return True\n    \n    def get_hand_dict(self, hand):\n        hand_dict = {}\n        for h in hand:\n            hand_dict[h] = hand_dict.get(h, 0)\n            hand_dict[h] += 1\n        return hand_dict\n    \n#         if not hand or len(hand)%W != 0:\n#             return False\n#         result = [[] * W for _ in range(len(hand)//W)]\n#         hand_dict = self.get_dict(hand)\n#         return self.is_n_straight_hand(hand_dict, W, result)\n    \n#     def is_n_straight_hand(self, hand_dict, W, result):\n#         while hand_dict:\n#             min_hand = min(hand_dict)\n#             count = hand_dict[min_hand]\n#             for i in range(min_hand, min_hand + W):\n#                 if i not in hand_dict:\n#                     return False\n#                 hand_dict[i] -= count\n#                 if hand_dict[i] == 0:\n#                     del hand_dict[i]\n#                 elif hand_dict[i] < 0:\n#                     return False\n#         return True\n                    \n            \n    \n#     def get_dict(self, hand):\n#         hand_dict = {}\n#         for i in hand:\n#             hand_dict[i] = hand_dict.get(i, 0) + 1\n#         return hand_dict\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            mins = min(count)\n            for i in range(mins, mins + W):\n                if not count[i]:\n                    return False\n                if count[i] == 1:\n                    del count[i]\n                else:\n                    count[i] -= 1\n        return True\n        # heapq.heapify(hand)\n        # while hand:\n        #     mins = hand[0]\n        #     #print(hand)\n        #     for i in range(mins, mins + W):\n        #         #print(i)\n        #         if i in hand:\n        #             hand.remove(i)\n        #             heapq.heapify(hand)\n        #         else:\n        #             return False\n        # return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        N = len(hand)\n        \n        if N % W != 0:\n            return False\n        \n        \n        counts = collections.Counter(hand)\n        \n        while counts:\n            card = min(counts.keys())\n            \n\n            for _ in range(W):\n                if card not in counts:\n                    return False\n\n                counts[card] -= 1\n                if counts[card] == 0:\n                    del counts[card]\n\n                card += 1\n        \n        \n        return True\n    \n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        cs = Counter(hand)\n        \n        while cs:\n            card = next(card for card in cs if card-1 not in cs)-1\n            \n            l = -1\n            while (l:=l+1) < W and cs[(card:=card+1)]:\n                cs[card] -= 1\n                if cs[card] == 0: del cs[card]\n            \n            if l != W:\n                return False\n        \n        return True  \n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        \n        while count:\n            minCount = min(count)\n            \n            for i in range(minCount, minCount+W):\n                if not count[i]: # if i not in count:\n                    return False\n                if count[i] == 1:\n                    del count[i]\n                else:\n                    count[i] -= 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand)%W:\n            return False\n        \n        counter = dict()\n        for h in hand:\n            temp = counter.get(h, 0)\n            temp+=1\n            counter[h] = temp\n        \n        \n        while counter:\n            start = min(counter.keys())\n            for k in range(start, start+W):\n                v = counter.get(k)\n                \n                if not v:\n                    return False\n                if v==1:\n                    del counter[k]\n                else:\n                    counter[k] = v-1\n        return True\n                    \n", "# \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N * (N/W))O(N\u2217(N/W))\uff0c\u5176\u4e2d NN \u662f hand \u7684\u957f\u5ea6\uff0c(N / W)(N/W) \u662f min(count) \u7684\u590d\u6742\u5ea6\u3002\n# \u5728 Java \u4e2d\u4f7f\u7528 TreeMap \u53ef\u4ee5\u5c06 (N / W)(N/W) \u964d\u4f4e\u5230 \\\\log NlogN\u3002\n\n# \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(N)O(N)\u3002\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True\n\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        result = []\n        while count:\n            m = min(count)\n            straights = []\n            for i in range(m, m + W):\n                if i in count:\n                    straights.append(i)\n                    count[i] -= 1\n                    if count[i] == 0:\n                        del count[i]\n                else:\n                    return False\n                \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand or len(hand)%W != 0:\n            return False\n        hand_dict = self.get_hand_dict(hand)\n        return self.is_n_straigh_hand(hand_dict, W)\n        \n    def is_n_straigh_hand(self, hand_dict, W):\n        while hand_dict:\n            start_hand = min(hand_dict)\n            for i in range(start_hand, W + start_hand):\n                if i not in hand_dict:\n                    return False\n                else:\n                    hand_dict[i] -= 1\n                    if hand_dict[i] == 0:\n                        del hand_dict[i]\n        return True\n    \n    def get_hand_dict(self, hand):\n        hand_dict = {}\n        for h in hand:\n            hand_dict[h] = hand_dict.get(h, 0)\n            hand_dict[h] += 1\n        return hand_dict\n    \n#         if not hand or len(hand)%W != 0:\n#             return False\n#         result = [[] * W for _ in range(len(hand)//W)]\n#         hand_dict = self.get_dict(hand)\n#         return self.is_n_straight_hand(hand_dict, W, result)\n    \n#     def is_n_straight_hand(self, hand_dict, W, result):\n#         while hand_dict:\n#             min_hand = min(hand_dict)\n#             count = hand_dict[min_hand]\n#             for i in range(min_hand, min_hand + W):\n#                 if i not in hand_dict:\n#                     return False\n#                 hand_dict[i] -= count\n#                 if hand_dict[i] == 0:\n#                     del hand_dict[i]\n#                 elif hand_dict[i] < 0:\n#                     return False\n#         return True\n                    \n            \n    \n#     def get_dict(self, hand):\n#         hand_dict = {}\n#         for i in hand:\n#             hand_dict[i] = hand_dict.get(i, 0) + 1\n#         return hand_dict\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0: \n            return False\n        \n        counts = collections.Counter(hand) # key: card, val: freq\n\n        while sum(counts.values()) > 0:\n            start_card = min(counts)\n            print(start_card)\n            \n            for card in range(start_card, start_card + W):\n                # check each group in one for-loop\n                if card not in counts:\n                    return False\n                counts[card] -= 1\n                if counts[card] == 0:\n                    del counts[card]\n                \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0: \n            return False\n        \n        counts = collections.Counter(hand) # key: card, val: freq\n\n        # tree map: ordered hashmap\n        while sum(counts.values()) > 0:\n            start_card = min(counts)\n            print(start_card)\n            \n            for card in range(start_card, start_card + W):\n                # check each group in one for-loop\n                if card not in counts:\n                    return False\n                counts[card] -= 1\n                if counts[card] == 0:\n                    del counts[card]\n                \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m + W):\n                v = count[k]\n                if not v:\n                    return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0:\n            return False\n        c = collections.Counter(hand)\n        while c:\n            k = min(c)\n            v = c[k]\n            del c[k]\n            for i in range(1,W):\n                if c[k+i] < v:\n                    return False\n                else:\n                    c[k+i] -= v\n                    if c[k+i] == 0:\n                        del c[k+i]\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        card_dict = dict()\n        #min_heap = heapq()\n        for card in hand:\n            if card in card_dict:\n                card_dict[card] = card_dict[card] + 1\n                \n            else:\n                card_dict[card] = 1\n                #min_heap.push(card)\n                \n        while(len(card_dict) > 0):\n            min_ele = min(card_dict.keys())\n            for i in range(W):\n                if not min_ele in card_dict:\n                    return False\n                \n                elif card_dict[min_ele] > 1:\n                    card_dict[min_ele] = card_dict[min_ele] - 1\n                    \n                else:\n                    del card_dict[min_ele]\n                     \n                min_ele = min_ele + 1\n                    \n        return True\n        \n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        result = []\n        while count:\n            m = min(count)\n            straights = []\n            for i in range(m, m + W):\n                if i in count:\n                    #straights.append(i)\n                    count[i] -= 1\n                    if count[i] == 0:\n                        del count[i]\n                else:\n                    return False\n            #result.append(straights)\n        #print(result)\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        hand.sort()\n        flag = 0\n        while len(hand) > 0 and flag == 0:\n            temp = []\n            start = hand[0]\n            temp.append(start)\n            for i in range(1,W):\n                if start+i in hand:\n                    temp.append(start+i)\n                else:\n                    flag = 1\n                    break     \n            for x in temp:\n                hand.remove(x)\n            \n        if flag == 0:\n            return True\n        else:\n            return False", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            mins = min(count)\n            for i in range(mins, mins + W):\n                if not count[i]:\n                    return False\n                if count[i] == 1:\n                    del count[i]\n                else:\n                    count[i] -= 1\n        return True\n        heapq.heapify(hand)\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        count = Counter(hand)\n        result = []\n        while count:\n            m = min(count)\n            straights = []\n            for i in range(m, m + W):\n                if i in count:\n                    #straights.append(i)\n                    count[i] -= 1\n                    if count[i] == 0:\n                        del count[i]\n                else:\n                    return False\n            #result.append(straights)\n        #print(result)\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        hand.sort()\n        flag = 0\n        while len(hand) > 0 and flag == 0:\n            temp = []\n            start = hand[0]\n            temp.append(start)\n            print(start)\n            for i in range(1,W):\n                if start+i in hand:\n                    temp.append(start+i)\n                else:\n                    flag = 1\n                    break     \n            for x in temp:\n                hand.remove(x)\n            \n        if flag == 0:\n            return True\n        else:\n            return False", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        count = Counter(hand)\n        \n        while (count):\n            init = min(count.keys())\n            if count[init] ==1: \n                del count[init]\n            else:\n                count[init]= count[init]-1\n            for i in range(1, W):\n\n                v = count[init+1]\n                if (init+1) in count.keys():\n                    \n                    if v==1: \n                        del count[init+1]\n                    else:\n                        count[init+1]= v-1\n                else:\n                    return False\n                init = init+1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand) % W != 0:\n            \n            return False\n         \n        freq_dict = collections.Counter(hand)\n        \n        while freq_dict:\n            \n            min_num = min(freq_dict)\n            \n            for i in range(min_num, min_num + W):\n                \n                freq = freq_dict[i]\n                       \n                if freq == 0:\n                    \n                    return False\n                \n                elif freq == 1:\n                    \n                    del freq_dict[i]\n                \n                else:\n                    \n                    freq_dict[i] -= 1\n                    \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        dic = collections.Counter(hand)\n        while dic:\n            m = next(iter(dic))\n            #print(m)\n            for k in range(m, m+W):\n                v = dic.get(k)\n                #print(v,k)\n                if not v: \n                    return False\n                if v == 1:\n                    del dic[k]\n                else:\n                    dic[k] = v - 1\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True\n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        '''\n        O(n)\n        '''\n        counter = Counter(hand)\n        count = W\n        while counter:\n            if count == W:\n                count = 0\n                val = min(counter)\n            else:\n                val += 1\n                if not counter[val]:\n                    return False                    \n            counter[val] -= 1\n            if not counter[val]:\n                del counter[val]\n            count += 1\n        return count == W\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        counter = Counter(hand)\n        for i in range(len(hand) // W):\n            minimum = min(counter.keys())\n            for number in range(minimum, minimum + W):\n                if number not in counter:\n                    return False\n                counter[number] -= 1\n                if counter[number] == 0:\n                    del counter[number]\n        return True\n            \n            \n        \n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand)%W!=0:\n            return False\n        \n        hand.sort()\n        \n        last=-1\n        j=0\n        changed=False\n        while hand:\n            if hand[0]==last+1 or last==-1:\n                changed=False\n                last=hand.pop(0)\n                j+=1\n                if j%W==0:\n                    last=-1\n            elif not changed:\n                for i in range(1, len(hand)):\n                    if hand[i]<=last+1:\n                        hand[i],hand[0]=hand[0],hand[i]\n                    else:\n                        break\n                \n                changed=True\n            else:\n                return False\n                \n        return True\n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v  = count[k]\n                if not v:\n                    return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] -= 1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = collections.Counter(hand)\n        \n        while counter:\n            num = min(counter)\n            \n            for _ in range(W):\n                if num not in counter:\n                    return False\n                \n                counter[num] -= 1\n                \n                if counter[num] == 0:\n                    del counter[num]\n                    \n                num += 1\n                    \n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        \n        parts = len(hand) / W\n        \n        cnt = Counter(hand)\n        cnt = sorted(cnt.items())\n        #print(cnt)\n        heapq.heapify(cnt)\n        #print(cnt)\n\n        while cnt:\n            #print(cnt)\n            hand = []\n            while len(hand) != W:\n                if not cnt:\n                    return False\n\n                (card, count) = heapq.heappop(cnt)\n                if hand:\n                    (last_card, last_count) = hand[-1]\n                    if last_card != card - 1:\n                        return False\n                hand.append((card, count))\n\n            #print(hand)\n            for (card, count) in hand:\n                count -= 1\n                if count:\n                    heapq.heappush(cnt, (card, count))\n\n        return True", "import heapq\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        l = len(hand)\n        if l == 0 or l % W != 0:\n            return False\n        \n        counter = collections.Counter(hand)\n        \n        \n        \n        pos = 0\n        while pos < l:\n  \n            currMin = min(counter.keys())\n            counter[currMin] -= 1\n            pos += 1\n            if counter[currMin] == 0:\n                del counter[currMin]\n        \n            for i in range(W-1):\n                nextDraw = currMin + i + 1\n                if nextDraw in counter and counter[nextDraw] > 0:\n                    counter[nextDraw] -= 1\n                    pos += 1\n                    if counter[nextDraw] == 0:\n                        del counter[nextDraw]\n                else:\n                    return False\n                \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        l=len(hand)\n        if l%W!=0:\n            return False\n        d={}\n        for i in range(l):\n            if hand[i] not in d:\n                d[hand[i]]=1\n            else:\n                d[hand[i]]+=1\n        while d:\n            num=min(d)\n            j=1\n            while num+1 in d and j!=W:\n                j+=1\n                num=num+1\n            if j==W:\n                num=min(d)\n                for k in range(W):\n                    if d[num]==1:\n                        del d[num]\n                    else:\n                        d[num]-=1\n                    num+=1\n            else:\n                return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            mins = min(count)\n            for i in range(mins, mins + W):\n                if not count[i]:\n                    return False\n                if count[i] == 1:\n                    del count[i]\n                else:\n                    count[i] -= 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        l=len(hand)\n        if l%W!=0:\n            return False\n        d=collections.Counter(hand)\n        while d:\n            num=min(d)\n            j=1\n            while num+1 in d and j!=W:\n                j+=1\n                num=num+1\n            if j==W:\n                num=min(d)\n                for k in range(W):\n                    if d[num]==1:\n                        del d[num]\n                    else:\n                        d[num]-=1\n                    num+=1\n            else:\n                return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v:\n                    return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        \n        hand = sorted(hand)\n        # print(hand)\n        \n        for split in range(len(hand) // W):\n            min_val = min(hand)\n            hand.remove(min_val)\n            for i in range(1, W):\n                if min_val + 1 not in hand:\n                    return False\n                else:\n                    min_val += 1\n                    hand.remove(min_val)\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        # input checking\n        if len(hand) % W != 0 or not W:\n            return False\n        \n        avail = collections.Counter(hand)\n        while avail:\n            curr = min(avail)\n            for i in range(W):\n                if avail[curr+i]:\n                    avail[curr+i] -= 1\n                    if not avail[curr+i]:\n                        del avail[curr+i]\n                else:\n                    return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand, W):\n        if len(hand) % W != 0:\n            return False\n\n        hand = sorted(hand)\n        cnt = {}\n\n        for card in hand:\n            if card not in cnt:\n                cnt[card] = 0\n            cnt[card] += 1\n\n        cur_len = 0\n        last_val = -1\n        num_sub_hands = 0\n\n        unique_vals = sorted(set(hand))\n        flag = True\n\n        loops = 0\n\n        while len(cnt) and flag and num_sub_hands < len(hand) // W:\n            flag = False\n            # pass by value\n            tmp = sorted(set(unique_vals))\n\n            for element in tmp:\n                loops += 1\n                if last_val == -1 or element == last_val + 1:\n                    last_val = element\n                    cnt[element] -= 1\n                    cur_len += 1\n                    flag = True\n                if cnt[element] == 0:\n                    del cnt[element]\n                    unique_vals.remove(element)\n                if cur_len == W:\n                    last_val = -1\n                    cur_len = 0\n                    num_sub_hands += 1\n                    break\n\n        return len(cnt) == 0 and num_sub_hands == len(hand) // W", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        dic = collections.Counter(hand)\n        \n        print((dic, min(dic), dic[10]))\n        \n        while dic:\n            m = min(dic)\n            \n            for num in range(m,m+W):\n                \n                if dic[num] == 0:\n                    return False\n                \n                if dic[num] == 1:\n                    del dic[num]\n                else:\n                    dic[num] = dic[num] - 1\n                \n        return True\n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand = sorted(hand)\n        forward = list(range(1,len(hand)))\n        forward.append(None)\n        backward = [None]\n        backward.extend(list(range(0,len(hand)-1)))\n        \n        ptr = 0\n        while ptr is not None:\n            firstSkipped = None\n            for i in range(W):\n                if ptr is None:\n                    return False\n                currHand = hand[ptr]\n                prev = backward[ptr]\n                forw = forward[ptr]\n                if prev is not None:\n                    forward[prev] = forw\n                    \n                if forw is not None:\n                    backward[forw] = prev\n                forward[ptr] = backward[ptr] = None\n                ptr = forw\n                \n                while ptr is not None and hand[ptr] == currHand:\n                    if firstSkipped is None:\n                        firstSkipped = ptr\n                    ptr = forward[ptr]\n                \n                if ptr is not None and i != W-1 and hand[ptr] - 1!= currHand:\n                    return False\n                    \n            if firstSkipped is not None:\n                ptr = firstSkipped\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if(len(hand)%W != 0):\n            return False\n        \n        data = collections.Counter(hand)\n        while(data):\n            m = min(data)\n            for k in range(m, m+W):\n                v = data[k]\n                if(not v):\n                    return False\n                if(v == 1):\n                    del data[k]\n                else:\n                    data[k] -= 1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        l = len(hand)\n        if l % W != 0:\n            return False\n        cards = Counter(hand)\n        keys = sorted(list(cards.keys()))\n        start = keys[0]\n        start_idx = 0\n        for _ in range(l//W):\n            cards[start] -= 1\n            for i in range(start+1, start+W):\n                if i not in keys or cards[i] == 0:\n                    return False\n                else:\n                    cards[i] -= 1\n            while cards[start] == 0 and start_idx < len(keys)-1:\n                start_idx += 1\n                start = keys[start_idx]\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n\n        counts = defaultdict(int)\n        for number in hand:\n            counts[number] += 1\n\n        ordered_numbers = sorted(counts.keys())\n        while counts:\n            group = []\n            for number in ordered_numbers:\n\n                if number not in counts:\n                    continue\n\n                if counts[number] > 0:\n                    if group:\n                        if group[-1] != number - 1:\n                            return False\n                    group.append(number)\n                    counts[number] -= 1\n                else:\n                    del counts[number]\n                if len(group) == W:\n                    break\n            if group and len(group) != W:\n                return False\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        d=collections.defaultdict(int)\n        for i in hand:\n            d[i]+=1\n        while(d):\n            l=list(d)\n            heapq.heapify(l)\n            prev=None\n            for i in range(W):\n                if len(l)==0:\n                    return False\n                ele=heapq.heappop(l)\n                if prev is not None:\n                    if ele-prev>1:\n                        return False\n                prev=ele\n                if d[ele]==1:\n                    del d[ele]\n                else:\n                    d[ele]-=1\n        return True\n        \n            \n            \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand = sorted(hand)\n        indices = {}\n        for index in reversed(list(range(len(hand)))):\n            num = hand[index]\n            if num not in indices:\n                indices[num] = [index]\n            else:\n                indices[num].append(index)\n        while len(indices) != 0:\n            first = None\n            for num in hand:\n                if num in indices:\n                    first = num\n                    break\n            for i in range(W):\n                num = first + i\n                if num in indices:\n                    indices[num].pop()\n                    if len(indices[num]) == 0: del indices[num]\n                else:\n                    return False\n        return True\n                    \n                \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand or not W:\n            return False\n        _map = defaultdict(list)\n        for i in range(len(hand)):\n            _map[hand[i]] += [i]\n            \n        while _map:\n            hand = [k for k, _ in list(_map.items())]\n            top = min(hand)\n            _map[top].pop()\n            if not _map[top]:\n                del _map[top]\n            i = 1\n            while hand and i < W:\n                top += 1\n                if top not in _map:\n                    return False\n                _map[top].pop()\n                if not _map[top]:\n                    del _map[top]\n                i += 1\n            if i < W:\n                return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        l = len(hand)\n        if l%W!=0:\n            return False\n        if W == 1:\n            return True\n        ct = Counter(hand)\n        lst = sorted(list(ct.keys()))\n        for l in lst:\n            if l-1 not in lst and l+1 not in lst:\n                return False\n        while lst:\n            # print(lst)\n            begin = lst[0]\n            ct[begin]-=1\n            if ct[begin]==0:\n                lst.pop(0)\n            for i in range(1, W):\n                if begin+i not in ct:\n                    return False\n                else:\n                    ct[begin+i]-=1\n                    if ct[begin+i]==0:\n                        lst.remove(begin+i)\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n\n        if len(hand) % W!=0:\n            return False\n\n        if len(hand)==0:\n            return True\n\n        hand = sorted(hand)\n\n        '''\n        hand_dict = {}\n\n        for h in hand:\n            if h in hand_dict:\n                hand_dict[h]+=1\n            else:\n                hand_dict[h]=1\n\n        print(hand_dict)\n        '''\n\n        \n    \n        seed = hand[0]\n\n        for i in range(1,W):\n\n            #print(seed, seed+i)\n            \n            if seed+i not in hand:\n                return False\n\n        for i in range(0,W):\n            hand.remove(seed+i)\n            \n        #print(hand)\n\n        return self.isNStraightHand(hand, W)\n\n", "from collections import OrderedDict\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if W==1:\n            return True\n        if len(hand)%W:\n            return False\n        hand.sort()\n        od=OrderedDict()\n        for h in hand:\n            if h in od:\n                od[h]+=1\n            else:\n                od[h]=1\n        k=list(od.keys())[0]\n        n=list(od.values())[0]\n        while True:\n            for i in range(W):\n                if k+i in od and od[k+i]>=n:\n                    od[k+i]-=n\n                    if od[k+i]==0:\n                        del od[k+i]\n                else:\n                    return False\n            if len(od)==0:\n                break\n            k=list(od.keys())[0]\n            n=list(od.values())[0]\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        \n        # we count the frequencies of each card and put it in an ordered dict\n        counter = collections.Counter(hand)\n        d = collections.OrderedDict(sorted(counter.items()))\n        count = 0 # track the number of keys whose value is down to 0\n        while count < len(d): \n            group = []\n            # go through the ordered dict and put consecutive cards in a group\n            # the loop breaks once the size of the group reaches W\n            for card in d.keys():\n                if d[card] == 0:\n                    continue\n                if not group or (len(group) < W and group[-1] + 1 == card):\n                    group.append(card)\n                    d[card] -= 1\n                    if d[card] == 0:\n                        count += 1\n                if len(group) == W:\n                    break\n            else:\n                return False\n            \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand)% W !=0:\n            return False\n        \n        while(hand!=[]):\n            minele = min(hand)\n            for i in range(0, W):\n                try:\n                    #print(minele+i)\n                    hand.remove(minele+i)\n                except:\n                    return False\n        return True\n            \n       \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!=0:\n            return False\n        else:\n            while hand!=[]:\n                f = min(hand)\n                for i in range(0,W):\n                    try:\n                        hand.remove(f+i)\n                    except:\n                        return False\n            return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # Edge case: len(hand)%W!=0 that means it's not possible to split into W sized groups.\n        # we can try to arrange them in form of HashMap, \n        # 1:1, 2:2, 3:3, 4:4 \n        # if we sort them and try to find the counts, if count[i-1]>count[i] then FALSE\n        # [1,2,3,6,2,3,4,7,8]\n        # {1:1, 2:2, 3:2, 4:1, 6:1,7:1,8:1}\n        if len(hand)%W!=0:\n            return False\n        else:\n            while(hand!=[]):\n                minele = min(hand)\n                for i in range(0, W):\n                    try:\n                        hand.remove(minele+i)\n                    except:\n                        return False\n            return True\n", "import heapq\nimport collections\n\nclass Solution:\n    def isNStraightHand(self, hand, W) -> bool:\n        if len(hand) % W != 0:\n            return False\n\n        counter_map = collections.Counter(hand)\n        counter = 0\n        heapq.heapify(hand)\n\n        while hand:\n            min_val = heapq.heappop(hand)\n            next_val = min_val + 1\n            counter += 1\n            while counter < W and counter_map.get(next_val, 0) > 0:\n                counter_map[next_val] -= 1\n                hand.remove(next_val)\n                counter += 1\n                next_val += 1\n\n            # Cannot split anymore\n            if counter < W:\n                return False\n\n            # resetting counter\n            counter = 0\n            heapq.heapify(hand)\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) < W or len(hand) % W != 0:\n            return False\n        d = {}\n        for i in hand:\n            d[i] = d.get(i,0) +1\n        keys = sorted(list(d.keys()))\n        for i in keys:\n            if d[i] == 0:\n                continue\n            while d[i] > 0:\n                for j in range(i,i+W):\n                    if j not in keys or d[j] <=0:\n                        return False\n                    else:\n                        d[j] = d[j] -1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = collections.Counter(hand)\n        for i in sorted(c):\n            if c[i] > 0:\n                for j in range(W)[::-1]:\n                    c[i + j] -= c[i]\n                    if c[i + j] < 0:\n                        return False\n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W:\n            return False\n        cnt = Counter(hand)\n        cards = sorted(cnt)\n        while True:\n            first = cards.pop()\n            if not cnt[first]:\n                continue\n            amount = cnt[first]\n            del cnt[first]\n            for i in range(first - 1, first - W, -1):\n                if not cnt[i]:\n                    return False\n                cnt[i] -= amount\n                if cnt[i] < 0:\n                    return False\n                elif cnt[i] == 0:\n                    del cnt[i]\n            if not cnt:\n                return True\n        return False # never happen", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        dic = {k: v for k, v in sorted(count.items())}\n        while dic:\n            m = next(iter(dic))\n            #print(m)\n            for k in range(m, m+W):\n                v = dic.get(k)\n                #print(v,k)\n                if not v: \n                    return False\n                if v == 1:\n                    del dic[k]\n                else:\n                    dic[k] = v - 1\n\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0:\n            return False\n        \n        counter = Counter(hand)\n        \n        nums = sorted(counter.keys())\n        \n        for num in nums:\n            count = counter[num]\n            if count == 0:\n                continue\n            min_count = count\n            for i in range(W):\n                if count[num+i] < min_count:\n                    return False\n                count[num+i] -= min_count\n        return True\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        #[1,2,3,2,3,4]\n        #[1,2,2,3,3,4]\n        \n        if len(hand) % W != 0:\n            return False\n        \n        counter = Counter(hand)\n        q = []\n        for num, freq in list(counter.items()):\n            heapq.heappush(q, (num, freq))\n\n        while q and len(q) >= W:\n            tmp = []\n            for i in range(W):\n                x = heapq.heappop(q)\n                if tmp and tmp[-1][0]+1 != x[0]:\n                    return False\n                tmp.append(x)\n            for num, freq in tmp:\n                if freq > 1:\n                    heapq.heappush(q, (num, freq-1))\n        return 0 == len(q)\n            \n\n            \n            \n    def isNStraightHand4(self, hand: List[int], W: int) -> bool:\n        #[1,2,3,2,3,4]\n        #[1,2,2,3,3,4]\n        \n        if len(hand) % W != 0:\n            return False\n\n        hand.sort()\n        q = []\n        for num in hand:\n            if q and q[-1][0] == num:\n                q[-1][1] += 1\n            else:\n                q.append([num, 1])\n\n        #[[3,3]]\n        #\n        n = len(hand)\n        while n > 0:\n            if len(q) < W:\n                return False\n            for i in range(1, W):\n                if q[i][0] != q[i-1][0] + 1:\n                    return False\n            j = 0\n            #print(j)\n            for i in range(W):\n                #print(i)\n                if q[j][1] == 1:\n                    q.pop(j)\n                else:\n                    q[j][1] -= 1\n                    j += 1\n            n -= W\n        return len(q) == 0\n\n    def isNStraightHand3(self, hand: List[int], W: int) -> bool:\n        counter = Counter(hand)\n        while counter:\n            m = min(counter)\n            for k in range(m, m+W):\n                v = counter[k]\n                if not v: return False\n                if v == 1:\n                    del counter[k]\n                else:\n                    counter[k] = v - 1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n  \n        hand.sort()\n        while(len(hand)>0):\n        \n            val=hand.pop(0)\n            for j in range(W-1):\n                try:\n                    val+=1\n                    indx=hand.index(val)\n                    hand.pop(indx)\n                except:\n                    return False\n        return True\n                    \n", "## time - O(MlogM + M), space - O(M)\nfrom collections import Counter, deque\nclass Solution:\n    def isNStraightHand(self, hand, W):\n        cnts = Counter(hand)\n        for num in sorted(cnts):\n        \n            tmp = cnts[num]\n            if tmp > 0:\n                for j in range(num, num+W):\n                    cnts[j] -= tmp\n                    if cnts[j] < 0:\n                        return False\n        return True\n #for example, hand = [1,2,3,6,2,3,4,7,8], W = 3\n#cnts: {1:1,2:2,3:2,4:1,6:1,7:1,8:1}\n#=>{1:0,2:1,3:1,4:1,6:1,7:1,8:1}\n#=>{1:0,2:0,3:0,4:0,6:1,7:1,8:1}\n#=>{1:0,2:0,3:0,4:0,6:0,7:0,8:0}\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count_map = Counter()\n        for num in hand:\n            count_map[num] += 1\n        test = sorted(count_map)\n        sorted_hand = sorted(dict.fromkeys(hand))\n        while len(sorted_hand) > 0:\n            while len(sorted_hand) > 0 and count_map[sorted_hand[0]] == 0:\n                sorted_hand.pop(0)\n            if len(sorted_hand) > 0:\n                for key in range(sorted_hand[0], sorted_hand[0]+W):\n                    if key in count_map:\n                        count_map[key] -= 1\n                        if count_map[key] < 0:\n                            return False\n                    else:\n                        return False\n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        cards = Counter(hand)\n        for card in sorted(hand):\n            if cards[card] > 0:\n                for i in range(W):\n                    if card + i not in cards or cards[card + i] == 0:\n                        return False\n                    cards[card + i] -= 1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) == 0:\n            return False\n        if len(hand) % W > 0:\n            return False\n        count = {}\n        for n in hand:\n            if n not in count:\n                count[n] = 1\n            else:\n                count[n] += 1\n                \n        total = sum(count.values())\n        for n in sorted(hand):\n            if total == 0:\n                break\n            if count[n] == 0:\n                continue\n            for i in range(W):\n                target = n + i\n                if target in count and count[target] > 0:\n                    count[target] -= 1\n                    total -= 1\n                else:\n                    return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        while hand:\n            curr = hand[0]\n            try:\n                for i in range(W):\n                    hand.remove(curr)\n                    curr += 1\n            except:\n                return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        while hand:\n            try:\n                base = hand[0]\n                for i in range(W):\n                    hand.remove(base + i)\n            except:\n                return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W:\n            return False\n        \n        C = Counter(hand)\n        keys = sorted(C.keys())\n        #output = []\n        for i in range(n//W):\n            mn = keys[0]\n        #    straight = []\n            for j in range(mn, mn + W):\n                if j not in keys:\n                    return False\n                else:\n                    C[j] -= 1\n        #            straight.append(j)\n                    if C[j] == 0:\n                        del C[j]\n                        keys.remove(j)\n        #    output.append(straight)\n        #print (output)\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!=0:\n            return False\n        \n        hand=sorted(hand)\n        dct={}\n        for x in hand:\n            if x not in dct:\n                dct[x]=1\n            else:\n                dct[x]+=1\n                \n        while len(hand)>0:\n            group=[hand[0]]\n            check=hand[0]\n            hand.remove(check)\n            while len(group)<W:\n                if check+1 not in dct or dct[check+1]<1:\n                    return False\n                group.append(check+1)\n                hand.remove(check+1)\n                dct[check+1]-=1\n                check+=1\n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = Counter(hand)\n        for key in sorted(counter):\n            if counter[key] > 0:\n                for i in range(1, W):\n                    counter[key + i] -= counter[key]\n                    if counter[key + i] < 0:\n                        return False\n                counter[key] = 0\n        return True", "class Solution:\n  # 204 ms\n  def isNStraightHand(self, hand, W):\n    nums = len(hand)\n    if nums % W: return False\n    elif W == 1: return True\n    else:\n      heapify(hand)\n      arrange = deque() # collect group\n      lastOp = [0,-1] # lastOp = [i, h]: record the operation of last time\n      groups = 0 # count group\n      while hand:\n        h = heappop(hand)\n        i = 0\n        # if the same card as last time, escalate i\n        if h == lastOp[1]: i = lastOp[0] + 1\n        # add new group\n        if len(arrange) < i+1:\n          arrange.append([])\n          groups += 1\n        # num of group should be nums//W\n        if groups > nums//W: return False\n        # if not consecutive, False\n        if len(arrange[i]) and arrange[i][-1] +1 != h:\n          return False\n        else:\n          # arrange new card if group size is less than W\n          arrange[i].append(h)\n          lastOp = [i, h]\n        # pop group if size is full\n        if len(arrange[i]) == W:\n          arrange.popleft()\n          lastOp = [0, -1]\n\n    return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand:\n            return False\n        if len(hand) % W != 0:\n            return False\n  \n        hand.sort()\n        n = len(hand)\n        dic = Counter(hand)\n        cards = list(dic.keys())\n        cards.sort()\n  \n  \n        for c in cards:\n            num = dic[c]\n            if num == 0:\n                continue\n            for i in range(1, W):\n                if (c + i) in dic and dic[c+i] >= num:\n                    dic[c+i] -= num\n                else:\n                    return False\n  \n        return True", "class Solution:\n  # 204 ms\n  def isNStraightHand(self, hand, W):\n    nums = len(hand)\n    if nums % W: return False\n    elif W == 1: return True\n    else:\n      heapify(hand)\n      arrange = deque() # collect group\n      lastOp = [0,-1] # lastOp = [i, h]: record the operation of last time\n      groups = 0 # count group\n      while hand:\n        h = heappop(hand)\n        i = 0\n        # if the same card as last time, escalate i\n        if h == lastOp[1]: i = lastOp[0] + 1\n        # add new group\n        if len(arrange) < i+1:\n          arrange.append([])\n          groups += 1\n        # num of group should be nums//W\n        if groups > nums//W: return False\n        # arrange new card if group size is less than W\n        if len(arrange[i]) < W:\n          arrange[i].append(h)\n          lastOp = [i, h]\n        # not consecutive, False\n        if len(arrange[i]) > 1 and arrange[i][-2] + 1 != arrange[i][-1]:\n          return False\n        # pop group if size is full\n        if len(arrange[i]) == W:\n          arrange.popleft()\n          lastOp = [0, -1]\n\n    return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = Counter(hand)\n        for i in sorted(count):\n            if count[i] > 0:\n                for j in range(W-1, -1, -1):\n                    count[i+j] -= count[i]\n                    if count[i+j] < 0:\n                        return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        heapq.heapify(hand)\n        \n        while hand:\n            last_item = heapq.heappop(hand)\n            leftover = []\n            \n            for _ in range(W - 1):\n                if not hand:\n                    return False\n                \n                next_item = heapq.heappop(hand)\n                \n                while next_item == last_item:\n                    leftover.append(next_item)\n                    if not hand:\n                        return False\n                    next_item = heapq.heappop(hand)\n                    \n                if next_item > last_item + 1:\n                    return False\n                \n                last_item = next_item\n                \n            for item in leftover:\n                heapq.heappush(hand, item)\n                \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W: return False\n        if W==1: return True\n        counts=collections.Counter(hand)\n        for num in sorted(hand):\n            if not counts[num]: continue\n            for next in range(num,num+W):\n                if next not in counts or not counts[next]: return False\n                counts[next]-=1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        \n        #use dictionary to do quick look-up\n        dic = {}\n        \n        for num in hand:\n            if num not in dic:\n                dic[num] = 1\n            else:\n                dic[num] += 1\n        \n        hand.sort()\n        \n        while len(hand) > 0:\n            smallest = hand[0]\n            dic[smallest] -= 1\n            for i in range(1,W):\n                check = smallest + i\n                if check not in dic:\n                    return False\n                else:\n                    if dic[check] <= 0:\n                        return False\n                    else:\n                        dic[check] -= 1\n                        hand.remove(check)\n            hand.remove(smallest)\n            \n        return True\n            \n            \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        hand.sort()\n        \n        count = {}\n        for h in hand:\n            if h not in count:\n                count[h] = 1\n            else:\n                count[h] += 1\n        \n        key = list(count.keys())\n        print(count)\n        \n        head = 0\n        while head < len(key):\n            this_key = key[head]\n            if count[this_key] == 0:\n                head += 1\n                continue\n            tail = head + 1\n            \n            while tail < len(key) and tail < head + W:\n                if count[key[tail]] >= count[this_key] and key[tail] == key[tail - 1] + 1:\n                    count[key[tail]] -= count[this_key]\n                else:\n                    return False\n                tail += 1\n            if tail < head + W:\n                return False\n            count[this_key] = 0\n            head += 1\n            \n        return True", "class Solution:\n  def isNStraightHand(self, hand, W):\n    nums = len(hand)\n    if nums % W: return False\n    elif W == 1: return True\n    else:\n      heapify(hand)\n      arrange = [[] for _ in range(nums//W)] \n      start = 0\n      while hand:\n        h = heappop(hand)\n        i = start\n        while True:\n        #  print(h, i, arrange)\n          if len(arrange[i]) == W:\n            i += 1\n            start = i\n          if len(arrange[i]) == 0 or (arrange[i] and arrange[i][-1] != h):\n            arrange[i].append(h)\n          elif arrange[i] and arrange[i][-1] == h:\n            if i+1 == len(arrange):\n              return False\n            i += 1\n            continue\n          if len(arrange[i]) > 1 and arrange[i][-2] + 1 != arrange[i][-1]:\n            return False\n          else:\n            break\n\n          #  return \n    return True #arrange", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        straights, pq, = [], []\n        for h in hand:\n            heapq.heappush(pq, h)\n        while len(pq) > 0:\n            straight, dump = [], []\n            while len(pq) > 0 and len(straight) < W:\n                pop = heapq.heappop(pq)\n                if len(straight) == 0 or pop == straight[-1] + 1:\n                    straight.append(pop)\n                else:\n                    dump.append(pop)\n            straights.append(straight) \n            if len(straight) < W:\n                return []\n            else:\n                for d in dump:\n                    heapq.heappush(pq, d)\n        \n        #print(\\\"hel\\\")\n        #print(straights)   \n        return len(straights) > 0 ", "class Solution:\n  # 184 ms\n    def isNStraightHand(self, h, W):       \n        l = len(h)\n        if l % W != 0:\n            return False    \n        heapify(h)\n        c = Counter(h)\n        \n        for _ in range(l // W):\n          x = heappop(h)\n          while c[x] == 0:\n            x = heappop(h)\n            \n          for _ in range(W):\n            if c[x] == 0:\n              return False\n            c[x] -= 1\n            x += 1\n                \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        c = collections.Counter(hand)\n        for i in sorted(c):\n            if c[i] > 0:\n                for j in range(W)[::-1]:\n                    c[i + j] -= c[i]\n                    \n                    if c[i + j] < 0:\n                        return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W != 0:\n            return False\n        i = 0\n        hand.sort()\n        while hand:\n            for j in range(1, W):\n                if hand[i]+j not in hand:\n                        return False  \n                hand.pop(hand.index(hand[i]+j))\n            hand.pop(i)\n        return True", "class Solution:\n  # 204 ms\n  def isNStraightHand(self, hand, W):\n    nums = len(hand)\n    if nums % W: return False\n    elif W == 1: return True\n    else:\n      heapify(hand)\n      arrange = deque() # collect group\n      lastOp = [0,-1] # lastOp = [i, h]: record the operation of last time\n      groups = 0 # count group\n      while hand:\n        h = heappop(hand)\n        i = 0\n        # if the same card as last time, escalate i\n        if h == lastOp[1]: i = lastOp[0] + 1\n        # add new group\n        if len(arrange) < i+1:\n          arrange.append([])\n          groups += 1\n        # num of group should be nums//W\n        if groups > nums//W: return False\n        # not consecutive, False\n        if len(arrange[i]) and arrange[i][-1] +1 != h:\n          return False\n        else:\n          # arrange new card if group size is less than W\n          arrange[i].append(h)\n          lastOp = [i, h]\n        # pop group if size is full\n        if len(arrange[i]) == W:\n          arrange.popleft()\n          lastOp = [0, -1]\n\n    return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        hand.sort()\n        while hand:\n            start = hand[0]\n            hand.remove(start)\n            for i in range(W-1):\n                start += 1\n                if start in hand:\n                    hand.remove(start)\n                else:\n                    return False\n        return len(hand) == 0\n        \n\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W:\n            return False\n        hand.sort()\n        while hand:\n            try :\n                base = hand[0]\n                for i in range(W):\n                    hand.remove(base + i)\n            except:\n                return False\n\n        return True\n\n\n\n\n\n\n        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        from collections import Counter\n        c = Counter(sorted(hand))\n        for i in c:\n            if c[i] == 0:\n                continue\n            for j in range(1, W):\n                if c[i + j] >= c[i]:\n                    c[i + j] -= c[i]\n                else:\n                    return False\n            c[i] -= c[i]\n        return True", "class Solution:\n    def isNStraightHand(self, h: List[int], W: int) -> bool:\n        \n        l = len(h)\n        if l % W != 0:\n            return False\n        \n        heapify(h)\n        c = Counter(h)\n        \n        for _ in range(l // W):\n            \n            x = heappop(h)\n            while c[x] == 0:\n                x = heappop(h)\n            \n            for _ in range(W):\n                \n                if c[x] == 0:\n                    return False\n                c[x] -= 1\n                x += 1\n                \n        return True", "import collections\nimport heapq\nclass Solution:\n    def checkConsecutives(self, nums):\n        pos = 0\n        while pos < len(nums)-1:\n            if nums[pos][0]+1 != nums[pos+1][0]:\n                return False\n            pos += 1\n        return True\n    \n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!=0:\n            return False\n        \n        min_heap = []\n        heapq.heapify(min_heap)\n        num_dict = collections.Counter(hand)\n        for key, val in list(num_dict.items()):\n            heapq.heappush(min_heap, (key, val))\n            \n        while min_heap:\n            consec = []\n            for _ in range(W):\n                if not min_heap:\n                    return False\n                consec.append(list(heapq.heappop(min_heap)))\n            \n            if self.checkConsecutives(consec):\n                pos = 0\n                while pos<len(consec):\n                    if consec[pos][1]-1<=0:\n                        consec.pop(pos)\n                        continue\n                    else:\n                        consec[pos][1] -= 1\n                    pos += 1\n                pos = 0\n                while pos<len(consec):\n                    heapq.heappush(min_heap, tuple(consec[pos]))\n                    pos += 1\n            else:\n                return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W:\n            return False\n        \n        C = Counter(hand)\n        keys = sorted(C.keys())\n        output = []\n        for i in range(n//W):\n            mn = keys[0]\n            straight = []\n            for j in range(mn, mn + W):\n                if j not in keys:\n                    return False\n                else:\n                    C[j] -= 1\n                    straight.append(j)\n                    if C[j] == 0:\n                        del C[j]\n                        keys.remove(j)\n            output.append(straight)\n        print (output)\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand or len(hand) % W != 0: return False\n        \n        counter = Counter(hand)\n        for c in sorted(counter):\n            if counter[c] > 0:\n                for i in range(W)[::-1]:\n                    counter[c+i] -= counter[c]\n                    if counter[c+i] < 0: return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        if len(hand)%W==0:\n            while len(hand)!=0:\n                head=hand.pop(0)\n                for i in range(1,W):\n                    if head+i in hand:\n                        hand.remove(head+i)\n                    else:\n                        return False\n            return True\n                    \n        else:\n            return False", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!=0:\n            return False\n        \n        hand=sorted(hand)\n        dct={}\n        for x in hand:\n            if x not in dct:\n                dct[x]=1\n            else:\n                dct[x]+=1\n                \n        '''\n        below is O(N^2)? so TOO SLOW\n        see https://leetcode.com/problems/hand-of-straights/discuss/135598/C%2B%2BJavaPython-O(MlogM)-Complexity\n        for O(NlogN) soln\n        '''        \n        while len(hand)>0:\n            group=[hand[0]]\n            check=hand[0]\n            hand.remove(check)\n            while len(group)<W:\n                if check+1 not in dct or dct[check+1]<1:\n                    return False\n                group.append(check+1)\n                hand.remove(check+1)\n                dct[check+1]-=1\n                check+=1\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        if len(hand) % W !=0:\n            return False\n        \n        else:\n            for i in range(len(hand) // W):\n                tmp=hand.pop(0)\n                for j in range(W-1):\n                    if tmp+j+1 in hand:\n                        hand.pop(hand.index(tmp+j+1))\n                    else:\n                        return False\n            print(hand)\n            if len(hand) == 0:\n                return True\n            else:\n                return False\n                        \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand: return W==0\n        if len(hand)%W!=0: return False\n        hand.sort()\n        \n        def isnstraighthand(li):\n            if not li: return True\n            start = li[0]\n            for i in range(start,start+W):\n                if i not in li:\n                    return False\n                else:\n                    li.remove(i)\n            return isnstraighthand(li)\n        \n        return isnstraighthand(hand)\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if (len(hand) % W != 0):\n            return False\n        hand.sort()\n        length = len(hand)\n        count = 0\n        group = []\n        while(1):\n            for i in range(W-1):\n                if ((hand[0]+i+1) in hand):\n                    count += 1\n                    hand.pop(hand.index(hand[0]+i+1))          \n                else:\n                    return False\n            hand.pop(0)\n            if len(hand) == 0:\n                return True", "class Solution:\n    import heapq\n    # https://www.youtube.com/watch?v=Zz7BWDY5kvM&list=UUSYPN_WIvDy4spjxzdevk6Q\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if W == 1:\n            return True\n        if len(hand) % W:\n            return False\n        hand.sort()\n        heap = []\n        for n in hand:\n            if not heap:\n                heapq.heappush(heap, (n, 1))\n            else:\n                curr, size = heap[0]\n                if n == curr:\n                    heapq.heappush(heap, (curr, 1))\n                elif n == curr + 1:\n                    heapq.heappop(heap)\n                    size += 1\n                    if size < W:\n                        heapq.heappush(heap, (n, size))\n                else:\n                    return False\n        return bool(not heap)\n", "from collections import OrderedDict \n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        if len(hand) % W != 0:\n            return False\n        \n        card_counts = OrderedDict()     \n        \n        for i in range(len(hand)):\n            card_counts[hand[i]] = card_counts.get(hand[i], 0) + 1\n        \n        \n        keys = sorted(card_counts.keys())\n                \n        while card_counts:\n            min_val =  keys[0]\n            for hand in range(min_val, min_val+W):\n                #print(hand[i])\n                #print(card_counts)\n                if hand not in card_counts:\n                    return False\n                \n                count = card_counts[hand]\n                if count == 1:\n                    keys.pop(0)\n                    del card_counts[hand]\n                else:\n                    card_counts[hand] -= 1\n        \n        \n        return True", "class Solution:\n    import heapq\n    def isNStraightHand(self, hand, W):\n        heapq.heapify(hand)\n        while len(hand) > 0:\n            put_back =  []\n            count = 0\n            prev = hand[0] - 1\n            while count < W:\n                if len(hand) == 0:\n                    return False\n                v = heapq.heappop(hand)\n                if v != prev + 1:\n                    put_back.append(v)\n                else:\n                    prev = v\n                    count += 1\n\n            for element in put_back:\n                heapq.heappush(hand, element)\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hmap = {}\n        for h in hand : \n            if h not in hmap : hmap[h] = 0\n            hmap[h] +=1\n        \n        cards = sorted(list(hmap.keys()))\n        #print(hmap,cards)\n        \n        for card in cards :\n            #print(hmap)\n            while card in hmap :\n                for n in range(card,card+W) :\n                    if n not in hmap : \n                        #print(hmap,\\\"pop\\\",n,card)\n                        return False\n                    else : \n                        hmap[n] -=1\n                        if hmap[n] == 0 : \n                            \n                            del(hmap[n])\n                            #print(hmap,\\\"pop\\\",n,card)\n        #print(hmap,\\\"k\\\")\n        if hmap : return False \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if not hand: return False\n        \n        hand = sorted(hand)\n        queue, rs, group = [], [], []\n        while hand:\n            card = hand.pop(0)\n            if not group or group[-1] == card - 1:\n                group.append(card)\n                if len(group) == W:\n                    hand = queue + hand \n                    rs.append(group)\n                    group, queue = [], []\n            else:\n                queue.append(card)\n        \n        if not group and not queue:\n            return True \n        else:\n            return False", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand)\n        if n % W != 0:\n            return False\n        hand.sort()\n        for i in range(n // W):\n            start = hand[0]\n            hand.remove(start)\n            for j in range(W - 1):\n                if start + j + 1 in hand:\n                    hand.remove(start + j + 1)\n                else:\n                    return False\n        return True", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        n = len(hand) \n        if n % W != 0:\n            return False\n        \n        \n        occurmap = Counter(hand)\n        \n         \n        tots = 0\n        hand.sort()\n        # print('hnd is ', hand)\n        for i in range(n):\n            v = hand[i]\n            if occurmap[v-1] > 0 or occurmap[v] <= 0:\n                continue\n            # print('first value is ', v) \n            \n            count = 1\n            occurmap[v] -= 1\n            while count < W and occurmap[v+1] > 0:\n                count += 1\n                occurmap[v+1] -= 1\n                v = v+1\n            # print(occurmap)\n            # print('for ', v)\n            # print('count is ', count)\n            if count == W:\n                tots += 1\n            \n        # print('tots is ', tots)\n        if tots * W == n:\n            return True\n        return False\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if ((len(hand) % W) != 0):\n            return False\n        sorted_hand = hand\n        sorted_hand.sort()\n        num_groups = int(len(hand)/W)\n        for i in range (num_groups):\n            num = sorted_hand[0]\n            sorted_hand.remove(num)\n            for j in range (W-1):\n                num += 1\n                if num in sorted_hand:\n                    sorted_hand.remove(num)\n                else:\n                    return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand.sort()\n        while hand:\n            try:\n                base = hand[0]\n                for i in range(W):\n                    hand.remove(base+i)\n            except:\n                return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        \n        counter, smallest = self.counter(hand)\n        \n        for _ in range(len(hand) // W):\n            if smallest is None:\n                smallest = min(counter)\n            curr = smallest\n            counter[curr] -= 1\n            if counter[curr] == 0:\n                del counter[curr]\n                smallest = None\n            for _ in range(W - 1):\n                curr = curr + 1\n                if curr not in counter:\n                    return False\n                else:\n                    counter[curr] -= 1\n                    if counter[curr] == 0:\n                        del counter[curr]\n                    elif smallest is None:\n                        smallest = curr\n        return True\n\n    def counter(self, array):\n        smallest = None\n        counter = {}\n        for el in array:\n            if el in counter:\n                counter[el] += 1\n            else:\n                counter[el] = 1\n                if smallest is None or el < smallest:\n                    smallest = el\n        return counter, smallest\n\n\n\n\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # Q: repititions allowed? yes \n        # Q: negative numbers allowed? no \n        # brute force: make a hashmap with the key as hand[i] and value as frequency: O(n)\n        # maintain a sorted list of indexes: O(n*log(n))\n        # make a pass over the sorted list of indexes, and move to next when the frequency goes to 0 -> O(n)\n        # time complexity = O(n*log(n))\n        if (W==1):\n            return True \n        sorted_indexes = []\n        frequency_map = {}\n        for h in hand: \n            if h not in list(frequency_map.keys()):\n                frequency_map[h] = 1\n                # add to sorted list \n                self.addToSortedList(h, sorted_indexes)       \n            else: \n                frequency_map[h] += 1\n                \n        print((sorted_indexes, frequency_map))\n        # using frequency_map, and sorted_indexes, check if consecutive lists can be made \n        index = 0\n        while index < len(sorted_indexes):\n            # start the current W length list with sorted_indexes[index]        \n            for ele in range(sorted_indexes[index], sorted_indexes[index]+W):\n                if ele not in list(frequency_map.keys()) or frequency_map[ele] == 0:\n                    return False\n                \n                frequency_map[ele] -= 1\n            while (index < len(sorted_indexes) and frequency_map[sorted_indexes[index]] == 0):\n                # remove the element from frequency_map\n                frequency_map.pop(sorted_indexes[index])\n                index += 1\n                \n        return len(list(frequency_map.keys())) == 0 \n        \n    def addToSortedList(self, value: int, sorted_list: List[int]):\n        # values are not repeated in the sorted list \n        if (len(sorted_list) == 0):\n            sorted_list.append(value)\n            return\n        #print(\\\"---> val:\\\" + str(value))\n        low = 0 \n        high = len(sorted_list) - 1\n        while (low < high):\n            mid = math.floor((low+high)/2)\n            #print(mid, low, high)\n            if value < sorted_list[mid]:\n                high = mid - 1\n            elif value > sorted_list[mid]:\n                low = mid + 1\n        #print(value, low, high, sorted_list)\n        if high < 0:\n            sorted_list.insert(0, value)\n        elif value > sorted_list[high]:\n            sorted_list.insert(high+1, value)\n        else:\n            sorted_list.insert(high, value)\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        ogLen = len(hand)\n        if W == 1:\n            return True\n        \n        counter = Counter(hand)\n        counted = [(key, counter[key]) for key in counter]\n        counted.sort()\n        \n        print(counted)\n        \n        heapify(counted)\n        \n        groups = []\n        \n        \n        \n        \n        group = []\n        group.append(heappop(counted))\n        \n        tempStorage = set()\n        \n        while counted:\n            \n            n0 = group[-1]\n            \n            # print(n0[0], counted[0][0], group)\n            \n            if n0[0]+1 == counted[0][0]:\n                n1 = heappop(counted)\n                \n            elif counted[0][0] > n0[0]+1:\n                \n                group = []\n                group.append(heappop(counted))\n                continue\n            \n            group.append(n1)\n            \n            if len(group) == W:\n                # print(\\\"adding group\\\", group)\n                groups.append(group)\n                \n                for val, count in group:\n                    count -= 1\n                    if count != 0:\n                        heappush(counted, (val, count))\n                \n                # print(\\\"heap now: \\\", counted)\n                group = []\n                if counted:\n                    group.append(heappop(counted))\n\n        print((len(groups)*W, ogLen))\n                \n        return len(groups)*W == ogLen\n            \n            \n            \n            \n            \n", "from collections import defaultdict\n\nclass Solution:\n    def isNStraightHand(self, hand: List[int], k: int) -> bool:\n        if len(hand) < k or len(hand) % k != 0:\n            return False\n        if k == 1:\n            return True\n        hand.sort()\n        \n        queue = deque(hand)\n        q2 = deque()\n        \n        currVal = -1\n        currNum = 0\n        for i in range(len(hand) // k):\n            while currNum < k:\n                if not queue:\n                    return False\n                if currVal == -1:\n                    currVal = queue.popleft()\n                    currNum += 1\n                    continue\n                val = queue.popleft()\n                if val == currVal + 1:\n                    currVal = val\n                    currNum += 1\n                elif val > currVal + 1:\n                    return False\n                elif val == currVal:\n                    q2.append(val)\n\n            queue = q2 + queue\n            q2 = deque()\n            currVal = -1\n            currNum = 0\n        return True\n        \n        \n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        cs = Counter(hand)\n        \n        for card in hand: \n            if not cs[card] or cs[(card:=card-1)]:\n                continue\n            \n            l = -1\n            while (l:=l+1) < W and cs[(card:=card+1)]:\n                cs[card] -= 1\n                if cs[card] == 0: del cs[card]\n            \n            if l != W:\n                return False\n        \n        return True  \n        \n", "from collections import defaultdict\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        if W == 1:\n            return True\n        \n        hand.sort()\n        freq = defaultdict(int)\n        for c in hand:\n            freq[c] += 1\n\n        while len(freq) != 0:\n            keys = list(freq.keys())\n            if len(keys) < W:\n                return False\n            for i in range(W-1):\n                if keys[i] + 1 != keys[i+1]:\n                    return False\n                freq[keys[i]] -= 1\n                if freq[keys[i]] == 0:\n                    freq.pop(keys[i])\n                if i == W-2:\n                    freq[keys[i+1]] -= 1\n                    if freq[keys[i+1]] == 0:\n                        freq.pop(keys[i+1])\n        \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n\n        if (len(hand) % W) != 0:\n            return False\n        \n        hand.sort()\n        c = Counter(hand)\n        \n        for i in range(len(hand) // W):\n            \n            if len(hand) < W:\n                return False\n            \n            keys = list(c.keys())\n            key = keys[0]\n            \n            for j in range(W):\n                if key not in c:\n                    return False\n                \n                if c[key] == 1:\n                    del c[key]\n                    key += 1\n                    \n                else:\n                    c[key] -= 1\n                    key += 1\n                    \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], w: int) -> bool:\n        d={}\n        for i in hand:\n            if(i not in d):\n                d[i]=1\n            else:\n                d[i]+=1\n        d=sorted(list(d.items()),key= lambda x:x[0])\n        d1={}\n        for i in d:\n            d1[i[0]]=i[1]\n        \n        while(len(d1)>0):\n            r=list(d1.keys())[0]\n         \n            for i in range(r,r+w):\n                if(i not in d1):\n                    return False\n                count=d1[i]\n                if(count==1):\n                    d1.pop(i)\n                else:\n                    d1[i]=d1[i]-1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        d = {}\n        for i in hand:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        \n        sd = {k: v for k, v in sorted(list(d.items()), key=lambda item: item[0])}\n        \n        while sd:\n            keys = list(sd.keys())\n            i = keys[0]\n            sd[i] -= 1\n            if sd[i] == 0: del sd[i]\n            count = 1\n            while count < W:\n                if (i+count) not in sd:\n                    return False\n                else:\n                    sd[i+count] -= 1\n                    if sd[i+count] == 0: del sd[i+count]\n                count += 1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W != 0:\n            return False\n        hand.sort()\n        count = collections.Counter(hand)\n        while count:\n            key = list(count.keys())[0]\n            for i in range(W):\n                if count[key+i] > 0:\n                    count[key+i] -= 1\n                    if count[key+i] == 0:\n                        del count[key+i]\n                else:\n                    return False\n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        from collections import Counter\n        \n        i = 0\n        hand.sort()\n        hand_count = Counter(hand)\n        \n        while i < len(hand):\n            if hand[i] not in hand_count:\n                i += 1\n            else: \n                cur = hand[i]\n                for j in range(W):\n                    if not hand_count[cur+j]:\n                        return False\n\n                    hand_count[cur+j] -= 1\n\n                    if hand_count[cur+j] == 0:\n                        del hand_count[cur+j]\n\n                i += 1\n\n            \n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        hand = sorted(hand)\n        counter = collections.Counter(hand)\n        while counter:\n            m = min(counter)\n            for i in range(W):\n                num = m + i\n                if num in counter:\n                    counter[num] -= 1\n                    if counter[num] == 0: del counter[num]\n                else:\n                    return False\n        return True\n                    \n                \n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W != 0:\n            return False\n        hand_count = {}\n        for x in hand:\n            if x not in hand_count:\n                hand_count[x] = 1\n            else: \n                hand_count[x] += 1\n                \n        while len(hand_count) > 0:\n            min_key = min(hand_count.keys())\n            min_key_count = hand_count[min_key]\n            for i in range(W):\n                key = min_key + i \n                if key not in hand_count:\n                    return False\n                hand_count[key] -= min_key_count\n                if hand_count[key] == 0:\n                    del hand_count[key]\n                elif hand_count[key] < 0:\n                    return False\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        \n        while count:\n            n = min(count.keys())\n            n_count = count[n]\n            for x in range(n + 1, n + W):\n                if count[x] < n_count:\n                    return False\n                count[x] -= n_count\n                if count[x] == 0:\n                    count.pop(x)\n            count.pop(n)\n        \n        return True\n            \n            \n", "from collections import Counter\nclass Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        count = collections.Counter(hand)\n        while count:\n            m = min(count)\n            for k in range(m, m+W):\n                v = count[k]\n                if not v: return False\n                if v == 1:\n                    del count[k]\n                else:\n                    count[k] = v - 1\n\n        return True", "class Solution(object):\n    def isNStraightHand(self, hand, W):\n        if len(hand) % W != 0: return False\n        count = collections.Counter(hand)\n        while count:\n            m = min(count.keys())\n            num = count[m]\n            for k in range(m, m+W):\n                v = count[k]\n                if v < num: return False\n                if v == num:\n                    del count[k]\n                else:\n                    count[k] = v - num\n\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        \n        counter = collections.Counter(hand)\n        \n        while counter:\n            m = min(counter)\n            for k in range(m, m+W):\n                v = counter[k]\n                if not v: return False\n                if v == 1:\n                    del counter[k]\n                else:\n                    counter[k] = v -1\n        return True\n", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        if len(hand)%W!=0:\n            return False\n        \n        dicts={}\n        for n in hand:\n            dicts[n]=dicts.get(n,0)+1\n        \n        while dicts:\n            # print(min(dicts),max(dicts))\n            m=min(dicts)\n            for k in range(m,m+W):\n                # print('m-m+W:',m,m+W)\n                if k not in dicts: return False\n                elif dicts[k]==1:\n                    del dicts[k]\n                else:\n                    dicts[k]-=1\n                    \n        return True", "class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        counter = collections.Counter(hand)\n        while counter:\n            num = min(counter)\n            for i in range(num, num + W):\n                if i not in counter:\n                    return False\n                elif counter[i] == 1:\n                    del counter[i]\n                else:\n                    counter[i] -= 1\n                    \n        return True", "class Solution:\n    def isNStraightHand(self, nums: List[int], k: int) -> bool:\n        \n        n = len(nums)\n        \n        if n % k != 0:\n            return False\n        \n        cnt = Counter(nums)\n        no = min(cnt.keys())\n        while cnt: \n            for j in range(k):\n                if cnt[no] == 0:\n                    return False\n                \n                cnt[no] -= 1\n                if cnt[no] == 0:\n                    cnt.pop(no)\n                \n                no += 1\n            \n            if cnt:\n                no = min(cnt.keys())\n           \n        \n        return True\n            \n                \n                \n                    \n                    \n                \n        \n"]
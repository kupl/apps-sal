["def find_word(board, word):\n    grid = [l+[''] for l in board] + [[''] * (len(board[0]) + 1)]\n    def rc(x, y, i):\n        if i == len(word): return True\n        if grid[x][y] != word[i]: return False\n        grid[x][y] = ''\n        r = any(rc(x + u, y + v, i + 1)\n                for u in range(-1, 2)\n                for v in range(-1, 2))\n        grid[x][y] = word[i]\n        return r\n    return any(rc(x, y, 0)\n               for x in range(len(board))\n               for y in range(len(board[x])))", "def find_word(board, word):\n    def make(i, j, string, f=1, visited=None):\n        if not visited : visited = []\n        visited = [[k, l] for k, l in visited if board[k][l] in string]\n        if [i, j] in visited or not word.startswith(string): return False\n        if not f:\n            if 0 <= i < len(board) and 0 <= j < len(board) : string += board[i][j]\n            else : return string == word\n        if string == word : return True\n        visited.append([i, j])\n        return any([make(i, j + 1, string, 0, visited),\n                    make(i, j - 1, string, 0, visited),\n                    make(i - 1, j, string, 0, visited),\n                    make(i + 1, j, string, 0, visited),\n                    make(i - 1, j + 1, string, 0, visited),\n                    make(i - 1, j - 1, string, 0, visited),\n                    make(i + 1, j + 1, string, 0, visited),\n                    make(i + 1, j - 1, string, 0, visited)])\n    return any(make(i, k, l) for i, j in enumerate(board) for k, l in enumerate(j) if l == word[0])", "def find_word(board, word, trail=None):\n    if not word:\n        return True\n    if not trail:\n        board = {(row, col): item for row, line in enumerate(board) for col, item in enumerate(line)}\n        valid_first = [k for k, v in list(board.items()) if v == word[0]]\n        return any(find_word(board, word[1:], [coord]) for coord in valid_first)\n    else:\n        x, y = trail[-1]\n        neighbors = [(x-1, y-1), (x-1, y), (x-1, y+1), (x, y-1), (x, y+1), (x+1, y-1), (x+1, y), (x+1, y+1)]\n        valid_next = [p for p in neighbors if p in board and p not in trail and board[p] == word[0]]\n        return any(find_word(board, word[1:], trail + [coord]) for coord in valid_next)\n", "def find_word(board, word):    \n    P = {(i,j):e for j, r in enumerate(board) for i, e in enumerate(r)}\n\n    chains, word = [[p] for p in P if P[p] == word[0]], word[1:]\n        \n    while word and chains:\n        c, word, newchains = word[0], word[1:], []\n        for chain in chains:\n            i, j = chain[-1]\n            neighbours = [(i+a, j+b) for a in range(-1, 2) for b in range(-1, 2)]\n            newchains += [chain +[p] for p in neighbours if c == P.get(p, None) and p not in chain]\n        chains = newchains\n\n    return len(chains) > 0", "from collections import defaultdict\n\nMOVES = {(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,1), (1,-1) ,(-1,-1)}\n\ndef find_word(board, word):\n    dct = defaultdict(set)\n    for x,r in enumerate(board):\n        for y,c in enumerate(r): dct[c].add((x,y))\n            \n    paths = [ [pos] for pos in dct[word[0]] ]\n    for c in word[1:]:\n        if not paths or c not in dct: return False\n        paths = [path[:] + [nextPos] for path in paths \n                                     for nextPos in { pos for pos in dct[c] - set(path) \n                                                          if tuple( z2-z1 for z1,z2 in zip(pos, path[-1])) in MOVES }]\n    return bool(paths)", "def find_neighbors(row_c, col_c, board, word, path):\n    if len(path) == len(word):\n        return True, path\n    y_d = [i for i in range(max(0, row_c - 1), min(len(board), row_c + 2))]\n    x_d = [i for i in range(max(0, col_c - 1), min(len(board), col_c + 2))]\n    neighbors = [(y, x) for y in y_d for x in x_d]\n    for index in neighbors:\n        if index not in path and board[index[0]][index[1]] == word[len(path)]:\n            path.append(index)\n            result = find_neighbors(index[0], index[1], board, word, path)\n            if result[0]:\n                return True, path\n            else:\n                path = result[1]\n            path = path[:-1]\n    return False, path\n\n\ndef find_word(board, word):\n    for row_c, row in enumerate(board):\n        for col_c, l in enumerate(row):\n            path = []\n            if l in word and find_neighbors(row_c, col_c, board, word, path)[0]:\n                return True\n    return False", "def find_word(board, s):\n    \n    def seekFrom(x,y):\n        bd[x][y] = ''\n        ret = next(dfs(x,y), False)\n        bd[x][y] = s[0]\n        return ret\n    \n    def dfs(x,y,i=1):\n        if i==len(s): yield True\n        else:\n            candidates = ( (x+dx,y+dy) for dx in range(-1,2) for dy in range(-1,2) \n                                       if (dx or dy) and 0<=x+dx<len(bd) and 0<=y+dy<len(bd[0]) and bd[x+dx][y+dy]==s[i] )\n            for a,b in candidates:\n                bd[a][b] = ''\n                yield from dfs(a,b,i+1)\n                bd[a][b] = s[i]\n    \n    bd = list(map(list, board))\n    return any( seekFrom(x,y) for x,r in enumerate(board) for y,c in enumerate(r) if c==s[0] )", "import numpy as np\n\ndef find_word(board, word, seen=[]):\n    board = np.array(board)\n    inds = np.argwhere(board == word[0])\n    if seen:\n        inds = inds[[list(ind) not in seen for ind in inds]]\n        last = seen[-1] \n        inds = inds[[max(row) == 1 for row in abs(inds - last)]]\n\n    if len(word) == 1:\n        return len(inds) > 0\n    return any(find_word(board, word[1:], seen=seen + [list(ind)]) for ind in inds)\n", "def check_valid(letter_locations, board, word):\n    if len(letter_locations) == len(word): return True\n    (x,y) = letter_locations[-1]\n    next_char = word[len(letter_locations)]\n    valid = False\n    for i in range(-1,2):\n        for j in range(-1,2):\n            if i == 0 and j == 0: continue\n            if y+i < 0 or x+j < 0 or y+i >= len(board) or x+j >= len(board[0]): continue\n            if board[y+i][x+j] == next_char and (x+j,y+i) not in letter_locations:\n                letter_locations.append((x+j,y+i))\n                valid = valid or check_valid(letter_locations, board, word)\n                letter_locations.pop()\n    return valid\n\ndef find_word(board, word):\n    valid = False\n    if word == \"\": return True\n    for y, row in enumerate(board):\n        for x, letter in enumerate(row):\n            if letter == word[0]:\n                valid = valid or check_valid([(x,y)], board, word)\n    return valid", "def find_word(board, word, cursor = None):\n    if not word:\n        return True\n    workboard = [row[:] for row in board]\n    sy, sx, ey, ex = 0, 0, len(board), len(board[0])\n    if cursor:\n        cx, cy = cursor\n        workboard[cy][cx] = \"-\"\n        sy = max(sy, cy - 1)\n        sx = max(sx, cx - 1)\n        ey = min(ey, cy + 2)\n        ex = min(ex, cx + 2)\n    for     y, row  in enumerate(workboard[:ey][sy:]):\n        for x, cell in enumerate(      row[:ex][sx:]):\n            if cell == word[0] and find_word(workboard, word[1:], (x + sx, y + sy)):\n                return True\n    return False"]
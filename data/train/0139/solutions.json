["class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        def isSorted(arr, i, j):\n            return all(arr[k] <= arr[k+1] for k in range(i, j))\n        ans = 0\n        ranges = [[0, len(A)-1]]\n        for col in zip(*A):\n            if not ranges:\n                break\n            if all(isSorted(col, i, j) for i, j in ranges):\n                tmp = []\n                for i, j in ranges:\n                    start = i\n                    for k in range(i, j+1):\n                        if col[k] != col[start]:\n                            if k - start > 1:\n                                tmp.append([start, k-1])\n                            start = k   \n                    if j + 1 - start > 1:\n                        tmp.append([start, j])\n                    start = k   \n                ranges[:] = tmp\n            else:    \n                ans += 1\n        return ans\n            \n", "class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        D = set()\n        \n        while True:\n            changes = False\n            last_str = ''\n            for i, ch in enumerate(A[0]):\n                if i not in D:\n                    last_str += ch\n            for x in A[1:]:\n                this_str = ''\n                this_idx = []\n                for i, ch in enumerate(x):\n                    if i not in D:\n                        this_str += ch\n                        this_idx.append(i)\n                while this_str < last_str:\n                    for i in range(len(this_str)):\n                        if this_str[i] < last_str[i]:\n                            D.add(this_idx[i])\n                            this_idx = this_idx[:i] + this_idx[i+1:]\n                            this_str = this_str[:i] + this_str[i+1:]\n                            last_str = last_str[:i] + last_str[i+1:]\n                            changes = True\n                            break\n                last_str = this_str\n            if not changes:\n                break\n        return len(D)", "class Solution:\n    def checkLexOrder (self, A: List[str]):\n        if A == sorted(A):\n            return True\n        else:\n            return False\n    def findDelIndices (self, A: List[str]):\n        iter_ = len(A[0])\n        to_be_del = []\n        temp = ['']*len(A)\n        for i in range(iter_):\n            if self.checkLexOrder([x[i] for x in A]) == True:\n                temp = [temp[j]+A[j][i] for j in range(len(A))]\n            else:\n                temp_ = [temp[j]+A[j][i] for j in range(len(A))]\n                if self.checkLexOrder(temp_) == True:\n                    temp = [temp[j]+A[j][i] for j in range(len(A))]\n                else:\n                    to_be_del.append(i)\n        return len(to_be_del)   \n    def minDeletionSize(self, A: List[str]) -> int:\n        if self.checkLexOrder(A):\n            return 0\n        else:\n            return self.findDelIndices(A)\n                \n        \n        \n", "import copy\nclass Solution:\n    def checkLexOrder (self, A: List[str]):\n        if A == sorted(A):\n            return True\n        else:\n            return False\n    def findDelIndices (self, A: List[str]):\n        iter_ = len(A[0])\n        to_be_del = []\n        temp = ['']*len(A)\n        for i in range(iter_):\n            if self.checkLexOrder([x[i] for x in A]) == True:\n                temp = [temp[j]+A[j][i] for j in range(len(A))]\n            else:\n                temp_ = [temp[j]+A[j][i] for j in range(len(A))]\n                if self.checkLexOrder(temp_) == True:\n                    temp = [temp[j]+A[j][i] for j in range(len(A))]\n                else:\n                    to_be_del.append(i)\n        return len(to_be_del)   \n    def minDeletionSize(self, A: List[str]) -> int:\n        if self.checkLexOrder(A):\n            return 0\n        else:\n            return self.findDelIndices(A)\n                \n        \n        \n", "class Solution:\n    def isArrSorted(self, a) -> tuple((bool, bool)):\n        is_exp_sorted = True\n        is_eq_sorted = True\n\n        for i, l in enumerate(a):\n            if i == len(a) - 1:\n                break\n            \n            if not l < a[i+1]:\n                is_exp_sorted = False\n            if not l <= a[i+1]:\n                is_eq_sorted = False\n        return (is_exp_sorted, is_eq_sorted)\n\n    def minDeletionSize(self, A: List[str]) -> int:\n        deletion_count = 0\n        \n        built_A = [''] * len(A)\n        \n        for i in range(0, len(A[0])):\n            letters_at_i = [s[i] for s in A]\n            is_exp_sorted, is_eq_sorted = self.isArrSorted(letters_at_i)\n            # print(is_exp_sorted, is_eq_sorted)\n            \n            if is_exp_sorted:\n                break\n            \n            test_A = [built_A[oi] + o[i] for oi, o in enumerate(A)]\n            # print(test_A)\n            if list(sorted(test_A)) == test_A:\n                built_A = test_A\n                continue\n            else:\n                deletion_count += 1\n        \n        return deletion_count\n", "class Solution:\n  def minDeletionSize(self, words: List[str]) -> int:\n    n = len( words )\n    if n==0:\n      return 0\n    w = len( words[0] )\n    intervals = [[0,n]]\n    del_cols = 0\n    for col in range(w):\n      next_intervals = []\n      del_this_col = 0\n      for start,end in intervals:\n        cprev = words[start][col]\n        iprev = start\n        for i in range(start+1,end):\n          c = words[i][col]\n          if c>cprev:\n            ## create new interval\n            ## reset cprev and iprev\n            next_intervals.append( [iprev,i] )\n            cprev = c\n            iprev = i\n          elif c<cprev:\n            del_this_col = 1\n            del_cols += 1\n            break\n          pass\n        if del_this_col:\n          break\n        ## add another last interval\n        next_intervals.append( [iprev, end] )\n        pass\n      if not del_this_col:\n        intervals = next_intervals\n      pass\n    return del_cols", "class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        L = len(A)\n        N = len(A[0])\n        sort_groups = [[i for i in range(L)]]\n        count = 0\n        \n        for i in range(N):\n            \n            new_groups = []\n            in_order = True\n        \n            for group in sort_groups:\n                new_group = []\n                curr_ord = 0\n        \n                for g_idx in group:\n                    \n                    char = A[g_idx][i]\n                    if ord(char) > curr_ord:\n                        if curr_ord != 0:\n                            new_groups.append(new_group)\n                        new_group = [g_idx]\n                        curr_ord = ord(char)\n                        \n                    elif ord(char) == curr_ord:\n                        new_group.append(g_idx)\n                        \n                        \n                    # remove a column\n                    else:\n                        in_order = False\n                        break\n                \n                if not in_order:\n                    break\n                \n                if new_group != []:\n                    new_groups.append(new_group)\n                    \n            if in_order:\n                sort_groups = new_groups\n            \n            else:\n                count += 1\n                \n        return count", "class Solution:\n    def minDeletionSize(self, A):\n        m, n = len(A), len(A[0])\n        first = [False] * m\n        res = 0\n        for j in range(n):\n            for i in range(1, m):\n                if not first[i] and A[i][j] < A[i - 1][j]:\n                    res += 1\n                    break\n            else:\n                for i in range(1, m):\n                    if A[i][j] > A[i - 1][j]:\n                        first[i] = True\n        return res        ", "class Solution:\n    def minDeletionSize(self, A):\n        m, n = len(A), len(A[0])\n        first = [-1] * m\n        res = 0\n        for j in range(n):\n            for i in range(1, m):\n                if first[i] == -1 and A[i][j] < A[i - 1][j]:\n                    res += 1\n                    break\n            else:\n                for i in range(1, m):\n                    if A[i][j] > A[i - 1][j] and first[i] == -1:\n                        first[i] = j\n        return res        "]
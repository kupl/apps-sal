["class Solution:\n     def numRabbits(self, answers):\n         cnts = collections.Counter(answers)\n         return sum(-v % (k+1) + v for k, v in cnts.items())", "class Solution:\n     def numRabbits(self, answers):\n         if not answers: return 0\n         \n         answers.sort()        \n         ht = dict( list(zip(list(set(answers)), [0]*len(set(answers)))) )\n         for e in answers:\n             ht[e] += 1\n         \n         min_count = 0\n         for e in set(answers):\n             group, count = e, ht[e]\n             \n             if count <= group + 1:\n                 min_count += group + 1\n             else:\n                 #apply pigeonhole principle\n                 a, b = divmod(count, group + 1)\n                 min_count += (a + (b>0)) * (group + 1)\n         \n         return min_count\n             \n", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         if not answers:\n             return 0\n         count = collections.Counter(answers)\n         res = 0\n         for key, value in count.items():\n             if key == 0:\n                 res += count[0]\n             else:\n                 if key+1 > value:\n                     res += (key+1)\n                 else:\n                     if value % (key+1) == 0:\n                         res += value\n                     else:\n                         res += (key+1)*(value//(key+1)+1)\n         return res", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         if not answers:\n             return 0\n \n         rabbits = 0\n         answers = sorted(answers)\n         n = len(answers)\n         not_count = 0\n         iteration = 1\n         prev_value = 0\n \n         for i in range(n):\n             if iteration >= not_count \\\n                     or prev_value != answers[i]:\n                 rabbits += answers[i] + 1\n                 iteration = 0\n                 not_count = answers[i] + 1\n                 prev_value = answers[i]\n \n             iteration += 1\n \n         return rabbits", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         rabbit = {}\n         for n in set(answers):\n             rabbit[n] = answers.count(n)\n         res = 0\n         for i in rabbit.keys():\n             res += math.ceil(rabbit[i]/(i+1)) * (i+1)\n         return res", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         answers.sort()\n         answers_len = len(answers)\n         result = 0\n         index = 0\n         while True:\n             if index >= answers_len:\n                 break\n             if answers[index] == 0:\n                 result += 1\n                 index += 1\n                 if index >= answers_len:\n                     break\n             else:\n                 result += answers[index] + 1\n                 this_answer = answers[index]\n                 index += 1\n                 if index >= answers_len:\n                     break\n                 # skip at most answers[index] following answers\n                 for _ in range(this_answer):\n                     if answers[index] == this_answer:\n                         index += 1\n                         if index >= answers_len:\n                             break\n         return result", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         countArr = {}\n         \n         for i in answers:\n             if i not in countArr.keys():\n                 countArr[i] = 1\n             else:\n                 countArr[i] += 1\n         \n         minColors = 0\n         for i in countArr.keys():\n             minColors += math.ceil(countArr[i] / (i+1))*(i+1)\n \n         \n         return minColors", "import math\n class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         \n         colorGroup = collections.defaultdict(int)\n         for answer in answers:\n             colorGroup[answer] += 1\n         toReturn = 0\n         for key in colorGroup:\n             claimedBuddies, claimer = key, colorGroup[key]\n             ## print(claimedBuddies)\n             ## print(claimer)\n             toReturn += math.ceil(claimer/(claimedBuddies+1))*(claimedBuddies+1)\n             ## print(toReturn)\n             ## print()\n         return toReturn", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         answers = sorted(answers)\n         j = 0\n         sum = 0\n         while (answers[0] == 0):\n             answers.pop(0)\n             sum = sum + 1\n         \n         size = len(answers)\n     \n         #print(answers)\n         while(j < size):\n             #print(j)\n             val = answers[j]\n             inc = 0\n             while (j < size and val == answers[j] and inc < val+1):\n                 inc = inc + 1\n                 j = j+1\n             #print(\"adding value\", val+1, j)\n             sum = sum + val + 1\n             \n         \n         return sum", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         total = 0\n         d = collections.defaultdict(int)\n         for ans in answers:\n             d[ans] += 1\n         for k, v in d.items():\n             total += math.ceil(v/(k+1)) * (k+1)\n         return total", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         counter = [0 for i in range(1000)]\n         for i in answers:\n             counter[i] += 1\n         num = 0\n         for k, v in enumerate(counter):\n             d, m = divmod(v, k + 1)\n             if d > 0:\n                 num += (k + 1) * d\n             if m > 0:\n                 num += k + 1\n         return num\n             \n", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         dic = dict()\n         for answer in answers:\n             if answer in dic:\n                 dic[answer] += 1\n             else:\n                 dic[answer] = 1\n         ans = 0\n         for answer in dic:\n             ans += math.ceil(dic[answer] / (answer + 1)) * (answer + 1)\n         return ans", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         if answers==[]:\n             return 0\n         d={}\n         for n in answers:\n             if n in d:\n                 d[n]+=1\n             else:\n                 d[n]=1\n         total=0\n         # \u60f3\u6e05\u695a\u5404\u79cd\u53ef\u80fd\u7684\u8fb9\u754c\u60c5\u51b5\n         for n in d:\n             if d[n]%(n+1)==0:\n                 total+=d[n]\n             else:\n                 total+=((d[n]//(n+1))+1)*(n+1)\n                 \n         return total", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         N = max(answers)\n         \n         bincount = [0] * (N + 1)\n         for a in answers:\n             bincount[a] += 1\n             \n         min_number_rabbits = 0\n         for i in range(N + 1):\n             if bincount[i] == 0:\n                 continue\n             group_size = i + 1\n             nb_groups = math.ceil(bincount[i] / group_size)\n             min_number_rabbits += nb_groups * group_size\n             \n         return min_number_rabbits", "class Solution:\n     def numRabbits(self, answers):\n         \"\"\"\n         :type answers: List[int]\n         :rtype: int\n         \"\"\"\n         return sum( count + (-count)%(i+1)  for i, count in collections.Counter(answers).items())"]
["class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        biggest = A[0]\n        newbiggest = A[0]\n        lenL = 1\n        total = 1\n        for itr in A[1:]:\n            total += 1\n            if itr < biggest:\n                lenL = total\n                biggest = newbiggest\n            else:\n                if itr > newbiggest:\n                    newbiggest = itr\n        return lenL\n\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        res = 0\n        v = A[0]\n        max_sofar = v\n        for i in range(len(A)):\n            max_sofar = max(max_sofar, A[i])\n            if A[i] < v:\n                v = max_sofar\n                res = i\n                \n        return res+1\n    # \u5982\u679c\u4e2d\u95f4\u6709\u4e00\u4e2a\u6570\u5b57\u53d8\u5927\uff0c\u6211\u4e0d\u66f4\u65b0v\uff0c v\u53ea\u662f\u4e4b\u524d\u6700\u5927\u7684\u6570\n    # [32,57,24,19,0,24,49,67,87,87]  \u5982\u679c\u6211\u4e0d\u66f4\u65b0v\uff0c32 \u4f1a\u4e00\u76f4\u6700\u5927\uff0c\u90a3\u4e4849 \u5c31\u5f52\u5728\u53f3\u8fb9\u4e86\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        a = [A[0]]\n        b = [0 for i in range(len(A))]\n        for i in range(1, len(A)):\n            a.append(max(a[i - 1], A[i]))\n        \n        b[-1] = A[-1]\n        for i in range(len(A) - 2, -1, -1):\n            b[i] = min(b[i + 1], A[i])\n            \n        for i in range(len(A) - 1):\n            if a[i] <= b[i + 1]:\n                return i + 1\n        return -1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        mini = [float('-inf')]*n\n        maxi = [float('inf')]*n\n        mini[0] = A[0]\n        maxi[n - 1] = A[n - 1]\n        for i in range(1, n):\n            mini[i] = max(mini[i - 1], A[i])\n        \n        for i in range(n-2, -1, -1):\n            maxi[i] = min(maxi[i + 1], A[i])\n        \n        # print(mini)\n        # print(maxi)\n        for i in range(n - 1):\n            if mini[i] <= maxi[i + 1]:\n                return i + 1\n        \n        return 0", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        N = len(A)\n        maxleft = [None] * N\n        minright = [None] * N\n\n        m = A[0]\n        for i in range(N):\n            m = max(m, A[i])\n            maxleft[i] = m\n        \n        m = A[-1]\n        for i in range(N -1, -1, -1):\n            m = min(m, A[i])\n            minright[i] = m\n            \n        for i in range(1, N):\n            if maxleft[i-1] <= minright[i]:\n                return i\n            \n            \n#         # https://leetcode.com/problems/partition-array-into-disjoint-intervals/discuss/175904/Explained-Python-simple-O(N)-time-O(1)-space\n        \n#         # The idea is, v is nothing but the max value of the left half and max_so_far is a nonlocal maximum of the entire array. So by selecting elements only lesser than max of left side (v), we set V to the first element.\n        \n#         disjoint = 0\n#         v = A[disjoint]\n#         max_so_far = v\n#         for i in range(len(A)):\n#             max_so_far = max(max_so_far, A[i])\n#             if A[i] < v: \n#                 disjoint = i\n#                 v = max_so_far\n#         return disjoint + 1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        large = [0] * n\n        small = [0] * n\n        l, s = -sys.maxsize, sys.maxsize\n        for i in range(n):\n            l = max(l, A[i])\n            s = min(s, A[n-1-i])\n            large[i] = l\n            small[n-1-i] = s\n        for i in range(n):   \n            if large[i] <= small[i+1]: return i+1\n        return -1    \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left = [A[0]]\n        for i in range(1, len(A)):\n            left.append(max(left[-1], A[i]))\n        right = [A[-1]]\n        for i in range(len(A) - 2, -1, -1):\n            right.append(min(right[-1], A[i]))\n        for i in range(1, len(A)):\n            if left[i - 1] <= right[-i - 1]:\n                return i\n            \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        left = [0 for i in range(n)]\n        right = [0 for i in range(n)]\n        left[0], right[n-1] = A[0], A[n-1]\n        for i in range(1, n):\n            left[i] = max(left[i-1], A[i])\n        for i in range(n-2, -1, -1):\n            right[i] = min(right[i+1], A[i])\n        print(left, right)\n        for i in range(n-1):\n            if left[i] <= right[i+1]:\n                return i+1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        run_max = [float('-inf')]\n        run_min = [float('inf')]\n        # get run_max\n        p = 1\n        while p < len(A):\n            run_max.append(max(run_max[-1], A[p-1]))\n            p += 1\n        # get run_min\n        p = len(A) - 2\n        while p > -1:\n            run_min.append(min(run_min[-1], A[p+1]))\n            p -= 1\n        run_min = run_min[::-1]\n        \n        # find the pos that satisfies the condition.\n        res = -1\n        p = 0\n        done = False\n        while p < len(A) - 1 and not done:\n            if A[p] <= run_min[p] and run_max[p] <= run_min[p]:\n                res = p + 1\n                done = True\n                \n            p += 1\n        return  res\n    \n    \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left_max = []\n        right_min = []\n        for i in range(len(A)):\n            if i == 0:\n                left_max.append(A[i])\n            else:\n                left_max.append(max(A[i], left_max[-1]))\n        for i in range(len(A)-1, -1, -1):\n            if i == len(A) - 1:\n                right_min.append(A[i])\n            else:\n                right_min.append(min(A[i], right_min[-1]))\n        right_min.reverse()\n        \n        for i in range(len(A)-1):\n            lm = left_max[i]\n            rm = right_min[i+1]\n            if lm <= rm:\n                return i+1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        max_left, min_right = [None]*n, [None]*n\n\n        max_left[0] = A[0]\n        for i in range(1, n):\n            max_left[i] = max(max_left[i-1], A[i])\n\n        min_right[-1] = A[-1]\n        for i in range(n-2, -1, -1):\n            min_right[i] = min(min_right[i+1], A[i])\n\n        for i in range(1, n):\n            if max_left[i-1] <= min_right[i]:\n                return i", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        l, r = 0, len(A) - 1\n        leftMax = A[l]\n        rightMin = A[r]\n        minHash = {}\n        \n        while l < r:\n            leftMax = max(leftMax, A[l])\n            rightMin = min(rightMin, A[r])\n            \n            if rightMin >= leftMax:\n                r -= 1\n            else:\n                l += 1\n        \n        for i in range(r, len(A)):\n            if A[i] not in minHash:\n                minHash[A[i]] = []\n            minHash[A[i]].append(i)\n        minHash = sorted(list(minHash.items()), key=lambda x: x[0])\n        \n        #print (leftMax, rightMin, minHash)\n        i, res = 0, 1\n        while i < len(minHash) and minHash[i][0] < leftMax:\n            positions = minHash[i][1]\n            res = max(positions[-1]+1, res)\n            i += 1\n\n        return res\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        mx=[-1]*len(A)\n        mn=[-1]*len(A)\n        for i in range(len(A)):\n            if i==0:\n                mx[i]=A[i]\n            else:\n                mx[i]=max(A[i],mx[i-1])\n        for j in range(len(A)-1,-1,-1):\n            if j==len(A)-1:\n                mn[j]=A[j]\n            else:\n                mn[j]=min(A[j],mn[j+1])\n        #print(mx,mn)\n        for i in range(len(A)-1):\n            #print(mx[i],mn[i+1])\n            if mx[i]<=mn[i+1]:\n                #print('yo')\n                return i+1\n        return len(A)-1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        memo = [[0 for _ in range(n)] for _ in range(2)]\n        left, right = 0, (1<<31)-1\n        i, j = 0, n-1\n        while i < n and j >= 0:\n            right = min(right, A[j])\n            left = max(left, A[i])\n            memo[0][i] = left\n            memo[1][j] = right\n            i += 1\n            j -= 1\n        i, j = 0, 1\n        while j < n and memo[0][i] > memo[1][j]:\n            i, j = i+1, j+1\n        return j", "from collections import Counter\n\nclass Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        \n        c = Counter(A)\n        d = Counter()\n        \n        keys = sorted(c.keys())\n        \n        d[keys[0]] = 0\n        for i in range(1, len(keys)):\n            d[keys[i]] = c[keys[i-1]] + d[keys[i-1]]\n            \n        lesscount, mx = 0, -float('inf')\n        \n        \n        equal = 0\n        \n        for i in range(len(A)):\n            # mx = max(mx, A[i])\n            \n            if A[i] < mx:\n                lesscount += 1 \n            elif A[i] == mx:\n                equal += 1\n            else:\n                mx = A[i]\n                lesscount += equal\n                equal = 1\n                \n\n            # print(A[i], mx, lesscount, equal, d[mx])   \n            if lesscount == d[mx]:\n                return i + 1\n            \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left = [0 for i in range(len(A))]\n        left[0] = A[0]\n        for i in range(1, len(A)):\n            left[i] = max(left[i-1], A[i])\n        right = [0 for i in range(len(A))]\n        right[-1] = A[-1]\n        for i in reversed(range(len(A)-1)):\n            right[i] = min(right[i+1], A[i])\n        for i in range(len(A)-1):\n            if left[i] <= right[i+1]:\n                return i+1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        N = len(A)\n        maxLeft = dict()\n        minRight = dict()\n        \n        if N == 2 and A[0] <= A[1]:\n            return 1\n\n        maxLeft[0] = A[0]\n        for i in range(1, N - 1):\n            maxLeft[i] = max(maxLeft[i - 1], A[i])\n            \n        minRight[N - 1] = A[-1]\n        for i in range(N - 2, 0, -1):\n            minRight[i] = min(minRight[i + 1], A[i])\n            \n        print({ 'maxLeft': maxLeft })\n        print({ 'minRight': minRight })\n        \n        for i in range(N - 1):\n            if maxLeft[i] <= minRight[i + 1]:\n                return i + 1\n            \n        return -1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        mx=[-1]*len(A)\n        mn=[-1]*len(A)\n        for i in range(len(A)):\n            if i==0:\n                mx[i]=A[i]\n            else:\n                mx[i]=max(A[i],mx[i-1])\n        for j in range(len(A)-1,-1,-1):\n            if j==len(A)-1:\n                mn[j]=A[j]\n            else:\n                mn[j]=min(A[j],mn[j+1])\n        #print(mx,mn)\n        for i in range(len(A)-1):\n            print(mx[i],mn[i+1])\n            if mx[i]<=mn[i+1]:\n                #print('yo')\n                return i+1\n        return len(A)-1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        length = len(A)\n        leftMax = A[0]\n        currMax = leftMax\n        ret = 0\n        \n        for i in range(1, length):\n            currMax = max(A[i], currMax)\n            if leftMax > A[i]:\n                leftMax = currMax\n                ret = i\n        \n        return ret + 1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        maxval = A[0]\n        v = A[0]\n        disjoint = 0\n        for i in range(len(A)):\n            maxval = max(maxval,A[i])\n            if A[i]<v:\n                disjoint = i\n                v = maxval\n                \n        return disjoint+1\n                \n        \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        split_index = 0\n        local_max = A[0]\n        max_num = local_max\n        \n        for i in range(len(A)):\n            if A[i] < local_max:\n                split_index = i\n                local_max = max_num\n            else:\n                max_num = max(max_num,A[i])\n        return split_index + 1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        minA=[A[0],]\n        for i in A[1:]:\n            minA.append(max(i,minA[-1]))\n        minB=[A[-1],]\n        for i in A[:-1][::-1]:\n            minB.append(min(minB[-1],i))\n        minB=minB[::-1]\n        for i in range(1,len(A)):\n            if minA[i-1]<=minB[i]:\n                return i\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        max_left = float('-inf')\n        min_right = A[-1]\n        left = []\n        right = [A[-1]]\n        \n        for i in range(len(A)):\n            max_left = max(max_left, A[i])\n            left.append(max_left)\n            \n        for i in range(len(A) - 2, -1, -1):\n            min_right = min(min_right, A[i + 1])\n            right.append(min_right)\n        right.reverse()\n        #print(left)\n        #print(right)\n        for i in range(len(left)):\n            if left[i] <= right[i]:\n                return i + 1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left = [0]*len(A)\n        for i in range(len(A)):\n            if i == 0:\n                left[i] = A[i]\n            else:\n                if A[i] > left[i-1]:\n                    left[i] = A[i]\n                else:\n                    left[i] = left[i-1]\n        \n        A_reversed = A[::-1]\n        right = [0]*len(A)\n        for i in range(len(A)):\n            if i == 0:\n                right[i] = A_reversed[i]\n            else:\n                if A_reversed[i] < right[i-1]:\n                    right[i] = A_reversed[i]\n                else:\n                    right[i] = right[i-1]\n        right = right[::-1]\n        \n        print(left, right)\n        for i in range(len(left)-1):\n            if left[i] <= right[i+1]:\n                return i+1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        d = [0] * n\n        d[n-1] = A[n-1]\n        for i in range(len(A)-2,-1,-1):\n            d[i] = min(A[i],d[i+1])\n        # print(d)\n        mx = A[0]\n        for i in range(1,n):\n            if mx <= d[i]:\n                return i\n            else:\n                mx = max(mx,A[i])\n            \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        least = [float('inf')] * len(A)\n        for i in range(len(A)-1, -1, -1):\n            if i == len(A) - 1:\n                least[i] = A[i]\n            else:\n                least[i] = min(least[i+1], A[i])\n        greatest = A[0]    \n        for i in range(1, len(A)):\n            if greatest <= least[i]:\n                break\n            greatest = max(greatest, A[i])\n        return i\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        l = [0] * len(A)\n        r = [0] * len(A)\n        \n        for i in range(len(l)):\n            l[i] = max(A[i],l[i-1])\n        r[-1] = A[-1]\n        for i in range(len(r)-2,-1,-1):\n            r[i] = min(A[i],r[i+1])\n            \n        print(l)\n        print(r)\n        for i in range(len(l)):\n            if l[i] <= r[i+1]:\n                return i+1\n        return len(l)", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        ans = 1\n        all_max = A[0]\n        curr_max = 0\n        for i in range(len(A)):\n            curr_max = max(curr_max, A[i])\n            if all_max > A[i]:\n                all_max = curr_max\n                ans = i + 1\n        return ans", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        '''\n        [5,0,3,8,6]\n         mn=[5,0,0,0]\n         mx=[5,5,5,8,8]\n        \n        [1,1,1,0,6,12]\n        mx=[1,1,1,1,6,12]\n        '''\n        ml=0\n        mx=-1e9\n        mxsofar=1e9\n        for i,a in enumerate(A):\n            mx=max(a,mx)\n            if a<mxsofar:\n                ml=i+1\n                mxsofar=mx\n                #print(\\\"a=%d,mx=%d,mxsofar %d\\\"%(a,mx,mxsofar))\n            \n        return ml", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        right = 1\n        maxLeft = A[0]\n        \n        sortedRight = sorted(range(right, len(A)), key=lambda k: A[k])\n        \n        while A[sortedRight[0]] < maxLeft:\n            right = sortedRight[0] + 1\n            maxLeft = max(A[:right])\n            sortedRight = sorted(range(right, len(A)), key=lambda k: A[k])\n        \n        return right", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left = [0]*len(A)\n        left[0] = A[0]\n        for i in range(1,len(A)):\n            left[i] = max(A[i],left[i-1])\n        right = [0]*len(A)\n        right[-1] = A[-1]\n        for i in range(len(A)-2,-1,-1):\n            right[i] = min(A[i],right[i+1])\n        print((*left))\n        print((*right))\n        for i in range(1, len(A)):\n            if right[i] >= left[i-1]:\n                return i\n        \n#         N = len(A)\n#         maxleft = [None] * N\n#         minright = [None] * N\n\n#         m = A[0]\n#         for i in range(N):\n#             m = max(m, A[i])\n#             maxleft[i] = m\n\n#         m = A[-1]\n#         for i in range(N-1, -1, -1):\n#             m = min(m, A[i])\n#             minright[i] = m\n#         print(*maxleft)\n#         print(*minright)\n#         for i in range(1, N):\n#             if maxleft[i-1] <= minright[i]:\n#                 return i\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        # O(N**2) with sapce O(1)\n        n = len(A)\n        \n            \n            \n        # O(n) with space O(n)\n        m = n - 1\n        left_max = [0] * m\n        left_max[0] = A[0]\n        right_min = [0] * m\n        right_min[-1] = A[-1]\n        \n        for i in range(1,n-1):\n            left_max[i] = max(left_max[i-1], A[i])\n        \n        \n        for i in reversed(range(1,m)):\n            right_min[i-1] = min(right_min[i], A[i])\n        for i in range(m):\n            if left_max[i] <= right_min[i]:\n                return i + 1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        # O(N**2) with sapce O(1)\n        n = len(A)\n        \n            \n            \n        # O(n) with space O(n)\n        m = n - 1\n        left_max = [0] * m\n        left_max[0] = A[0]\n        right_min = [0] * m\n        right_min[-1] = A[-1]\n        \n        for i in range(1,n-1):\n            left_max[i] = max(left_max[i-1], A[i])\n        \n        \n        for i in reversed(range(1,m)):\n            right_min[i-1] = min(right_min[i], A[i])\n        \n        print(left_max)\n        print(right_min)\n        for i in range(m):\n            if left_max[i] <= right_min[i]:\n                return i + 1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n\n        bound = r = 0\n        gmax = lmax = A[0]\n        while r < len(A):\n            if A[r] >= gmax:\n                lmax = max(lmax, A[r])\n                r += 1\n            else:\n                bound = r\n                gmax = max(gmax, lmax)\n                r += 1\n\n        return bound+1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        h = {}\n        right = float('inf')\n\n        for j in range(len(A)-1,-1,-1):\n            right = min(right, A[j])\n            h[j] = right\n        \n        left = float('-inf')\n        for i in range(len(A)-1):\n            left = max(left, A[i])\n            if left <= h[i+1]:\n                return i + 1\n        \n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        cnt = collections.Counter(A)\n        cur = 0\n        minn = min(cnt.keys())\n        for i in range(len(A)):\n            cur = max(cur, A[i])\n            cnt[A[i]] -= 1\n            if cnt[A[i]] == 0:\n                del cnt[A[i]]\n                if minn == A[i]:\n                    minn = min(cnt.keys())\n            if minn >= cur:\n                return i + 1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        l = [A[0]]\n        r = [A[-1]]\n\n        for i, v in enumerate(A):\n            if i == 0:\n                continue\n\n            l.append(max(l[i-1], A[i]))\n            r.append(min(r[i-1], A[len(A) - i - 1]))\n\n        r.reverse()\n        for i in range(1, len(l)):\n            if l[i-1] <= r[i]:\n                return i", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        \n        partidx = 0\n        left_max = A[0]\n        seen_max = A[0]\n        for i in range(1, n):\n            seen_max = max(seen_max, A[i])\n            if A[i] < left_max:\n                partidx = i\n                left_max = seen_max\n        return partidx + 1\n            \n        \n        \n        \n        # left = [0 for i in range(n)]\n        # right = [0 for i in range(n)]\n        # left[0], right[n-1] = A[0], A[n-1]\n        # for i in range(1, n):\n        #     left[i] = max(left[i-1], A[i])\n        # for i in range(n-2, -1, -1):\n        #     right[i] = min(right[i+1], A[i])\n        # print(left, right)\n        # for i in range(n-1):\n        #     if left[i] <= right[i+1]:\n        #         return i+1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        i = 1\n        l_max = A[i-1]\n        r_min = min(A[i:])\n\n        while l_max > r_min:\n            i += 1\n            l_max = max(l_max, A[i-1])\n            if A[i-1] == r_min:\n                r_min = min(A[i:])\n            \n        return i", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        ma = [0] * n\n        mi = [0] * n\n        \n        mi[-1] = A[-1]\n        for i in range(n-2, -1, -1):\n            mi[i] = min(A[i+1], mi[i+1])\n        \n        ma[0] = A[0]\n        for i in range(1, n):\n            ma[i] = max(A[i], ma[i-1])\n        \n        # print(mi)\n        # print(ma)\n        \n        for i in range(n-1):\n            if mi[i] >= ma[i]:\n                return i + 1\n        return n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        max_left = [None] * len(A)\n        min_right = [None] * len(A)\n        \n        m = A[0]\n        for i in range(len(A)):\n            m = max(m, A[i])\n            max_left[i] = m\n\n        m = A[-1]\n        for i in range(len(A)-1, -1, -1):\n            m = min(m, A[i])\n            min_right[i] = m\n\n        for i in range(1, len(A)):\n            if max_left[i-1] <= min_right[i]:\n                return i", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        max_left = list()\n        min_right = list()\n        \n        for i in range(len(A)):\n            left = A[i]\n            if i == 0:\n                max_left.append(left)\n            elif max_left[i-1] > left:\n                max_left.append(max_left[i-1])\n            else:\n                max_left.append(left)\n                \n            right = A[len(A) - 1 - i]\n            if i == 0:\n                min_right.append(right)\n            elif min_right[i-1] < right:\n                min_right.append(min_right[i-1])\n            else:\n                min_right.append(right)\n\n        for i in range(len(A)):\n            if max_left[i] <= min_right[len(A) - i - 2]:\n                return i+1\n        return 0", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        p = [None]*len(A)\n        q = [None]*len(A)\n        \n        for i,v in enumerate(A):\n            if i == 0:\n                p[0] = v\n            else:\n                p[i] = max(p[i-1],v)\n        \n        for i,v in enumerate(reversed(A)):\n            if i == 0:\n                q[len(A)-1] = v\n            else:\n                q[len(A)-1-i] = min(q[len(A)-i],v)\n        \n        # print(p,q)\n        for i in range(len(A)-1):\n            if p[i] <= q[i+1]:\n                return i+1\n        \n        return len(A)", "from sortedcontainers import SortedList\n\nclass Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left, right = SortedList(), SortedList(A)\n        for i in range(len(A)-1):\n            left.add(A[i])\n            right.discard(A[i])\n            if left[-1] <= right[0]:\n                break\n        return i + 1\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        i = 1\n        l_max = A[i-1]\n\n        d = Counter(A[i:])\n        a_dict = OrderedDict(sorted(d.items()))\n        r_min = next(iter(a_dict.items()))[0]\n\n        while l_max > r_min:\n            i += 1\n            l_max = max(l_max, A[i-1])\n            if a_dict[A[i-1]] > 1:\n                a_dict[A[i-1]] -= 1\n            else:\n                del a_dict[A[i-1]]\n                r_min = next(iter(a_dict.items()))[0]\n                \n        return i", "# n^2 time to look at all subarrays\n# n time to iterate backwards ?\nclass Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        min_right = min(A)\n        max_left = 0\n        \n        min_from_right = []\n        current_min_right = A[-1]\n        for i in range(len(A) - 1, -1, -1):\n            current_min_right = min(A[i], current_min_right)\n            min_from_right.insert(0, current_min_right)\n        \n        for i in range(len(A)):\n            current = A[i]\n            max_left = max(max_left, current)\n            min_right = min_from_right[i + 1] if i < len(A) else 0\n            if max_left <= min_right:\n                return i + 1\n\n#         def check_partitions(a, b):\n#             max_a = 0\n#             for num in a:\n#                 max_a = max(max_a, num)\n#             min_b = maxsize\n#             for num in b:\n#                 min_b = min(min_b, num)\n#             if max_a <= min_b and len(a) > 0 and len(b) > 0:\n#                 return len(a)\n#             return -1\n        \n#         min_left = maxsize\n#         for i in range(1, len(A) + 1):\n#             cand = check_partitions(A[0:i], A[i: len(A)])\n#             if cand != -1:\n#                 min_left = min(min_left, cand)\n        \n#         return min_left\n", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        \n        maxlefts = []\n        minrights = []\n        \n        m = A[0]\n        for n in A:\n            m = max(m, n)\n            maxlefts.append(m)\n        \n        m = A[len(A) - 1]\n        for n in A[::-1]:\n            m = min(m, n)\n            minrights.insert(0, m)\n        \n        for i in range(1, len(A)):\n            if maxlefts[i - 1] <= minrights[i]: return i", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        res = 0\n        v = A[0]\n        max_sofar = v\n        for i in range(len(A)):\n            max_sofar = max(max_sofar, A[i])\n            if A[i] < v:\n                v = max_sofar\n                res = i\n                \n        return res+1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        # biggest = A[0]\n        # newbiggest = A[0]\n        # lenL = 1\n        # total = 1\n        # for itr in A[1:]:\n        #     total += 1\n        #     if itr < biggest:\n        #         lenL = total\n        #         biggest = newbiggest\n        #     else:\n        #         if itr > newbiggest:\n        #             newbiggest = itr\n        # return lenL\n        disjoint = 0\n        v = A[disjoint]\n        max_so_far = v\n        for i in range(len(A)):\n            max_so_far = max(max_so_far, A[i])\n            if A[i] < v: \n                disjoint = i\n                v = max_so_far\n        return disjoint + 1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        n = len(A)\n        mins = [float('inf')]*(n-1)+[A[-1]]\n        for i in range(n-2, -1, -1):\n            mins[i] = min(A[i], mins[i+1])\n\n        maxi = 0\n        for i in range(n-1):\n            maxi = max(maxi, A[i])\n            if maxi<=mins[i+1]:\n                return i+1\n        return -1", "class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        left_maxes = A[:]\n        right_mins = A[:]\n        \n        for i in range(1, len(left_maxes)):\n            if left_maxes[i] < left_maxes[i - 1]:\n                left_maxes[i] = left_maxes[i - 1]\n        \n        for i in range(len(right_mins) - 2, -1, -1):\n            if right_mins[i] > right_mins[i + 1]:\n                right_mins[i] = right_mins[i + 1]\n        \n        for i in range(1, len(A)):\n            if left_maxes[i - 1] <= right_mins[i]:\n                return i\n        \n                \n"]
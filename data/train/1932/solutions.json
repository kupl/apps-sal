["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        def count(node):\n            if not node:\n                return 0\n            return 1 + count(node.left) + count(node.right)\n        xNode = [0, 0]\n        def process(node):\n            if node:\n                if node.val == x:\n                    xNode[0] = count(node.left)\n                    xNode[1] = count(node.right)\n                else:\n                    process(node.left)\n                    process(node.right)\n            return\n        \n        process(root)\n        player2 = max(xNode[0], xNode[1], n - (xNode[0] + xNode[1] + 1)) # the maximum nodes I can color\n        return player2 > n // 2", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.lcnt, self.rcnt = 0, 0\n        \n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        \n        rootCnt = self.dfs(root, x)\n        \n        return max([rootCnt - self.lcnt - self.rcnt - 1, self.lcnt, self.rcnt]) > n / 2\n        \n    \n    \n    def dfs(self, node: TreeNode, x: int) -> int:\n        if not node:\n            return 0\n        left = self.dfs(node.left, x)\n        right = self.dfs(node.right, x)\n        \n        if node.val == x:\n            self.lcnt = left\n            self.rcnt = right\n        \n        return 1 + left + right", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        # build undirected graph so we can treat both parent and child nodes as\n        # neighbors for easy traversal\n        graph = collections.defaultdict(list)\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.left:\n                graph[node.val].append(node.left.val)\n                graph[node.left.val].append(node.val)\n                stack.append(node.left)\n            if node.right:\n                graph[node.val].append(node.right.val)\n                graph[node.right.val].append(node.val)\n                stack.append(node.right)\n        \n        # for each possible y, we do DFS from x to find how many nodes our \n        # opponent can reach from x. Note that our opponent will not be able to\n        # reach any nodes in the subtree rooted at y. If our opponent cannot \n        # reach at least half of all nodes (i.e. n//2), we will win for sure.\n        for y in range(1, n+1):\n            if y != x:\n                visited = set()\n                stack = [x]\n                while stack:\n                    val = stack.pop()\n                    visited.add(val)\n                    for nei in graph[val]:\n                        if nei not in visited and nei != y:\n                            stack.append(nei)\n\n                if len(visited) <= n//2:\n                    return True\n        \n        return False\n                        \n                    \n            \n                \n        \n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        c = [0,0]\n        def count(root):\n            if not root:\n                return 0\n            l,r = count(root.left),count(root.right)\n            if root.val == x:\n                c[0],c[1] = l,r\n            return l + r + 1\n        \n        return count(root)/2 < max(max(c),n - sum(c) - 1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        candidates = []\n        def dfs(node):\n            if not node:\n                return 0\n \n            l = dfs(node.left)\n            r = dfs(node.right)\n            if node.val == x:\n                l and candidates.append(l)\n                r and candidates.append(r)\n            return 1 + l + r\n        # candidates now contain left and right subtree of the   node with val x\n        # Get the length of subtree of parent node\n        dfs(root)\n        # print(candidates)\n        # if root.val != x:\n        candidates.append(n - (1 + sum(candidates)))\n        return any(mine > (n-mine) for mine in candidates)\n        \n  \n                \n                \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        def countNodes(node):\n            left = 0\n            if node == None:\n                return 0\n            if node.left:\n                left = countNodes(node.left)\n            right = 0\n            if node.right:\n                right = countNodes(node.right)\n            return left+right+1\n        \n        def searchNode(node, x):\n            if node.val == x:\n                return node\n            if node.left:\n                tmp = searchNode(node.left, x)\n                if tmp:\n                    return tmp\n            if node.right:\n                tmp = searchNode(node.right, x)\n                if tmp:\n                    return tmp\n            return None\n        \n        node = searchNode(root, x)\n        left = countNodes(node.left)\n        right = countNodes(node.right)\n        parent = n - left - right -1\n        if parent > n-parent or left > n- left or right > n - right:\n            return True\n        return False", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root, n, x):\n        \\\"\\\"\\\"\n        :type root: TreeNode\n        :type n: int\n        :type x: int\n        :rtype: bool\n        \\\"\\\"\\\"\n        self.l, self.r = None, None\n        def numNodes(root):\n            if not root:\n                return 0 \n            l = numNodes(root.left)\n            r = numNodes(root.right)\n            if root.val == x:\n                self.l = l\n                self.r = r\n            return l+r+1\n        \n        numNodes(root)\n        max_score = max(self.l, self.r, n-self.l-self.r-1)\n        \n        return max_score > n/2", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        c = [0, 0]\n        \n        def count(node):\n            if not node: return 0\n            l, r = count(node.left), count(node.right)\n            \n            if node.val == x:\n                c[0], c[1] = l, r\n                \n            return l + r + 1\n        \n        return count(root) / 2 < max(max(c), n - sum(c) - 1)\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        graph = defaultdict(list)\n        \n        def dfs(s):\n            if not s:\n                return\n            for child in [s.left, s.right]:\n                if not child:\n                    continue\n                graph[child.val].append(s.val)\n                graph[s.val].append(child.val)\n                dfs(child)\n        dfs(root)\n        \n        visited = set()\n        visited.add(x)\n        \n        def dfs_graph(u):\n            res = 1\n            visited.add(u)\n            for nei in graph[u]:\n                if nei not in visited:\n                    res += dfs_graph(nei)\n            return res\n        \n        candidates = [dfs_graph(nei) for nei in graph[x]]\n        if not candidates:\n            return False\n        res = max(candidates)\n        \n        if res > n - res:\n            return True\n        else:\n            return False", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        c = [0,0]\n        def count(root):\n            if not root: return 0\n            l,r = count(root.left),count(root.right)\n            if root.val == x:\n                c[0],c[1] = l,r\n                \n            return l + r + 1\n        return count(root)/2 < max(max(c),n - sum(c) - 1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        # for all possible y, we need to check if we can win\n        # we can return early if we can do that\n        \n        # now what to do after selecting a y\n        # we have three choices:\n        # select left, right or parent \n        # we can simulate what happens in each case\n        # we can return True if any of those choices\n        # return True\n        # we also have to simulate what happens if it is not\n        # our turn, in that case, we have to choose the minimum\n        # i.e. return false if anything is false\n        # since we are trying to maximize our profit\n        \n        \n        # we also need a way to simulate which node is colored what \n        # atleast temporarily\n        \n        # we can store a tuple for nodes\n        # if 0, uncolored\n        # if 1, blue\n        # if -1, red\n        \n        # exit conditions\n        # if no nodes left to be colored\n        # \n        \n        if not root:\n            return False\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        def convert_tree_to_graph(root, parent=None):\n            if not root:\n                return None\n            if parent:\n                # creating bi-directional edges\n                graph[parent].append(root)\n                graph[root].append(parent)\n            if root.left:\n                convert_tree_to_graph(root.left, root)\n            if root.right:\n                convert_tree_to_graph(root.right, root)\n                    \n        convert_tree_to_graph(root)\n    \n        # now we have the graph, we just need to find the node that player 1 selected\n        # and count its trees in each direction\n        node = None\n        for g, v in list(graph.items()):\n            if g.val == x:\n                node = g\n                break\n        \n        def count_nodes_in_subtree(node, visited):\n            #return count\n            if node in visited or node.val==x:\n                return 0\n            visited.add(node)\n            count = 0\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    count += count_nodes_in_subtree(neighbor, visited)\n            return count + 1 \n                    \n        subtrees = []\n        max_subtree = -1\n        #print (node, subtrees)\n        for subtree in graph[node]:\n            ans = count_nodes_in_subtree(subtree, set())\n            subtrees.append(ans)\n            max_subtree = max(max_subtree, ans)\n        \n        return n - max_subtree < max_subtree\n            \n            \n        if not subtrees:\n            return False\n        \n        if len(subtrees)== 1 and subtrees[0]>1 : # only 1 subtree and we chose it\n            return True \n        \n        \n        \n        return False\n            \n        \n        \n        \n                    \n                    \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        #https://leetcode.com/problems/binary-tree-coloring-game/discuss/797574/Python-3-or-DFS-or-One-pass-and-Three-pass-or-Explanation\n        \n        if not root:\n            return False\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        def convert_tree_to_graph(root, parent=None):\n            if not root:\n                return None\n            if parent:\n                # creating bi-directional edges\n                graph[parent].append(root)\n                graph[root].append(parent)\n            if root.left:\n                convert_tree_to_graph(root.left, root)\n            if root.right:\n                convert_tree_to_graph(root.right, root)\n                    \n        convert_tree_to_graph(root)\n    \n        # now we have the graph, we just need to find the node that player 1 selected\n        # and count its trees in each direction\n        node = None\n        for g, v in list(graph.items()):\n            if g.val == x:\n                node = g\n                break\n        \n        def count_nodes_in_subtree(node, visited):\n            #return count\n            if node in visited or node.val==x:\n                return 0\n            visited.add(node)\n            count = 0\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    count += count_nodes_in_subtree(neighbor, visited)\n            return count + 1 \n                    \n        subtrees = []\n        max_subtree = -1\n        #print (node, subtrees)\n        for subtree in graph[node]:\n            ans = count_nodes_in_subtree(subtree, set())\n            subtrees.append(ans)\n            max_subtree = max(max_subtree, ans)\n        \n        return n - max_subtree < max_subtree\n        \n        \n        if not subtrees:\n            return False\n        \n        if len(subtrees)== 1 and subtrees[0]>1 : # only 1 subtree and we chose it\n            return True \n        \n        return False\n            \n        \n        \n        \n                    \n                    \n        \n        \n"]
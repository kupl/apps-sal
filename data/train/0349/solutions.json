["class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         count = collections.Counter(nums);#count is a dict [3,4,2]--> {2:1,3:1,4:1}\n         prev = None;\n         avoid = using = 0;\n         for k in sorted(count):\n             temp = max(avoid,using)\n             if k - 1 != prev:\n                 using = k * count[k] + temp\n                 avoid = temp\n             else:\n                 using = k * count[k] + avoid\n                 avoid = temp\n \n             prev = k\n         return max(avoid,using)", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if (nums == []):\n             return 0\n         if (len(nums) == 1):\n             return nums[0]\n         \n         nums.sort()\n         numsp = nums[0]\n         choose = [0,nums[0]]\n         for i in range(1,len(nums)):\n           numsc = nums[i]\n           if (numsc == numsp):\n               choose[1] += numsc\n               continue\n           elif(numsc == numsp+1):\n               temp = choose[0]\n               choose[0] = max(choose)\n               choose[1] = temp+numsc\n               numsp = numsc\n           else:\n               choose[0] = max(choose)\n               choose[1] = choose[0]+numsc\n               numsp = numsc\n               \n         return max(choose)", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         nums.sort()\n         nums.append(-1) #end symbol\n         prev_max, cur_max = 0, 0\n         prev = -1\n         j, i = 0, 0\n         while i < len(nums):\n             if nums[i] == nums[j]:\n                 i += 1\n                 continue\n             dif = i - j\n             temp = dif*nums[j]\n             if nums[j] == prev + 1:\n                 prev_max, cur_max = cur_max, max(temp + prev_max, cur_max)\n             else:\n                 prev_max, cur_max = cur_max, temp + cur_max\n             prev = nums[j]\n             j = i\n             i += 1\n         return cur_max", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0: return 0\n         upper = max(nums)\n         ordered = [0]*(upper+1)\n         for i in nums: ordered[i]+=i\n             \n         ans = [0]*(upper+1)\n         ans[1] = ordered[1]    \n         for i in range (2,upper+1):\n             ans[i] = max(ans[i-1],ans[i-2]+ordered[i])\n         \n         return ans[upper]", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         from collections import Counter\n         c = Counter(nums)\n         n = len(nums)\n         pick = {-math.inf:0}\n         miss = {-math.inf:0}\n         prev = -math.inf\n         for (num, freq) in sorted(c.items()):\n             if prev == num - 1:\n                 pick[num] = miss[num-1] + num*freq\n                 miss[num] = max(miss[num-1], pick[num-1])\n             else:\n                 pick[num] = max(miss[prev], pick[prev]) + num*freq\n                 miss[num] = max(miss[prev], pick[prev])\n             prev = num\n             # print(num, pick, miss)\n         return max(pick[prev], miss[prev])", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0:\n             return 0\n         \n         nums.sort()\n         a = [0]*len(nums)\n         b = [0]*len(nums)\n         k = -1\n         a[-1] = nums[-1]\n         b[-1] = 0\n         for i in range(len(nums)-2, -1, -1):\n             print(nums[i], nums[i+1])\n             if nums[i] == nums[i+1]-1:\n                 a[i] = max(a[k], b[k])+nums[i] if k!=-1 else nums[i]\n                 b[i] = max(a[i+1], b[i+1])\n             elif nums[i] == nums[i+1]:\n                 a[i] = a[i+1]+nums[i]\n                 b[i] = b[i+1]\n             else:\n                 a[i] = max(a[i+1], b[i+1])+nums[i]\n                 b[i] = max(a[i+1], b[i+1])\n             if nums[i] < nums[i+1]:\n                 k = i+1\n \n         return(max(a[0], b[0]))", "class Solution:\n     def deleteAndEarn(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"        \n         # build a count array for nums\n         if len(nums)==0:\n             return 0\n         \n         nums.sort()\n         count = collections.Counter(nums)\n                 \n         take = [0]*(1+nums[-1])\n         delete = [0]*(1+nums[-1])\n         try:\n             take[1] = count[1]\n         except KeyError:\n             take[1] = 0\n \n         for i in range(2,nums[-1]+1):\n             print(i)\n             try:\n                 delete[i] = max(take[i-1], delete[i-1])\n                 take[i] = i*count[i] + max(take[i-2], delete[i-1])\n             except KeyError:\n                 continue\n \n         print(take)\n         print(delete)\n         res = max(take[-1],delete[-1])\n         return res"]
["from sys import stdin\r\nfrom math import ceil, gcd\r\n\r\n# Input data\r\n#stdin = open(\"input\", \"r\")\r\n\r\n\r\ndef dfs(src, visit):\r\n    visit[src] = 1\r\n    for nbr in d[src]:\r\n        if visit[nbr] == 0:\r\n            dfs(nbr, visit)\r\n\r\nfor _ in range(int(stdin.readline())):\r\n    n, m = list(map(int, stdin.readline().split()))\r\n    d = {}\r\n    for i in range(m):\r\n        u, v = list(map(int, stdin.readline().split()))\r\n        if u in d:\r\n            d[u].append(v)\r\n        else:\r\n            d[u] = [v]\r\n        if v in d:\r\n            d[v].append(u)\r\n        else:\r\n            d[v] = [u]\r\n    visited = {}\r\n    for i in range(n):\r\n        visited[i] = 0\r\n    ans = 0\r\n    for i in range(n):\r\n        if visited[i] == 0:\r\n            ans += 1\r\n            if i in d:\r\n                dfs(i, visited)\r\n    print(ans)\r\n", "class Graph: \r\n\tdef __init__(self,V): \r\n\t\tself.V = V \r\n\t\tself.adj = [[] for i in range(V)] \r\n\tdef DFSUtil(self, temp, v, visited): \r\n\t\tvisited[v] = True\r\n\t\ttemp.append(v) \r\n\t\tfor i in self.adj[v]: \r\n\t\t\tif visited[i] == False: \r\n\t\t\t\ttemp = self.DFSUtil(temp, i, visited) \r\n\t\treturn temp \r\n\tdef addEdge(self, v, w): \r\n\t\tself.adj[v].append(w) \r\n\t\tself.adj[w].append(v)\r\n\tdef connectedComponents(self): \r\n\t\tvisited = [] \r\n\t\tcc = [] \r\n\t\tfor i in range(self.V): \r\n\t\t\tvisited.append(False) \r\n\t\tfor v in range(self.V): \r\n\t\t\tif visited[v] == False: \r\n\t\t\t\ttemp = [] \r\n\t\t\t\tcc.append(self.DFSUtil(temp, v, visited)) \r\n\t\treturn cc \r\nfor _ in range(int(input())):\r\n    n,m=list(map(int,input().split()))\r\n    g=Graph(n)\r\n    for i in range(m):\r\n        u,v=list(map(int,input().split()))\r\n        g.addEdge(u,v)\r\n    print(len(g.connectedComponents()))\r\n", "# cook your dish here\nfrom sys import stdin,stdout\nclass Graph:\n    def __init__(self , V):\n        self.V = V\n        self.adj = [[] for i in range(V)]\n\n    def DFSUtil(self , temp , v , visited):\n        visited[v] = True\n        temp.append(v)\n        for i in self.adj[v]:\n            if visited[i] == False:\n                temp = self.DFSUtil(temp , i , visited)\n        return temp\n    def addEdge(self , v , w):\n        self.adj[v].append(w)\n        self.adj[w].append(v)\n\n    def connectedComponents(self):\n        visited = []\n        cc = []\n        for i in range(self.V):\n            visited.append(False)\n        for v in range(self.V):\n            if visited[v] == False:\n                temp = []\n                cc.append(self.DFSUtil(temp , v , visited))\n        return cc\nfor ii in range(int(input())):\n    x=1293781029873019827309128730918273\n    n,m = map(int , input().split())\n    g = Graph(n)\n    for i in range(m):\n        nn , mm = map(int , input().split())\n        g.addEdge(nn , mm)\n    c = g.connectedComponents()\n    print(len(c))", "for t in range(int(input())):\r\n    total=0\r\n    def check(n,store):\r\n        nonlocal edges,q,points\r\n        if n in store:\r\n            return\r\n        for i in range(q):\r\n            if n==edges[i][0]:\r\n                edges[i][0]=-1\r\n                x=edges[i][1]\r\n                edges[i][1]=-1\r\n                if x in points:\r\n                    check(x,store+[n])\r\n            elif n==edges[i][1]:\r\n                edges[i][1] = -1\r\n                x = edges[i][0]\r\n                edges[i][0] = -1\r\n                if x in points:\r\n                    check(x,store+[n])\r\n        points.remove(n)\r\n    n,q=list(map(int,input().split()))\r\n    edges=[]\r\n    points=[i for i in range(n)]\r\n    for i in range(q):\r\n        x=input().split()\r\n        edges.append([int(x[0]),int(x[1])])\r\n    for i in range(n):\r\n        if i in points:\r\n            total+=1\r\n            check(i,[])\r\n    print(total)\r\n", "from collections import deque,defaultdict\r\n\r\ndef addEdge(graph,u,v): \r\n\r\n    graph[u].append(v) \r\n    \r\n    \r\ndef bfs(graph, start):\r\n    # keep track of all visited nodes\r\n    explored = []\r\n    # keep track of nodes to be checked\r\n    queue = deque([start])\r\n\r\n    # keep looping until there are nodes still to be checked\r\n    while queue:\r\n        # pop shallowest node (first node) from queue\r\n        node = queue.popleft()\r\n        if node not in explored:\r\n            # add node to list of checked nodes\r\n            explored.append(node)\r\n            neighbours = graph[node]\r\n\r\n            # add neighbours of node to queue\r\n            for neighbour in neighbours:\r\n                queue.append(neighbour)\r\n    return explored\r\n \r\n       \r\ndef delete(graph,n)    :\r\n       try :\r\n           del graph[n]   \r\n       except KeyError :\r\n            pass   \r\n       for i in graph :\r\n           try :\r\n               graph[i].remove(n)\r\n           except ValueError :\r\n               continue     \r\n                      \r\n    \r\nfor _ in range( int(input())):\r\n    n,m=list(map(int,input().split()))\r\n    graph=defaultdict(list)\r\n    for i in range(m):\r\n        u,v=list(map(str,input().split())) \r\n        addEdge(graph,u,v)\r\n        addEdge(graph,v,u)        \r\n    cnt=0  \r\n    \r\n    dele=[]\r\n    for i in range(n):\r\n        if str(i)in dele :\r\n            \r\n            continue\r\n        else :      \r\n            path=bfs(graph,str(i))\r\n            for j in path :\r\n                delete(graph,j)\r\n                dele.append(j)\r\n            \r\n        cnt+=1\r\n     \r\n       \r\n    print(cnt)    \r\n", "# cook your dish here\nimport sys \nsys.setrecursionlimit(10**5)\nfrom collections import defaultdict\n\ng = defaultdict(list)\n\ndef dfs(u,visited):\n    visited[u] = True \n    for v in g[u]:\n        if not visited[v]:\n            dfs(v,visited)\n            \n\nfor _ in range(int(input())):\n    (n,m) = map(int,input().split())\n    g.clear()\n    \n    for _ in range(m):\n        (u,v) = map(int,input().split())\n        g[u].append(v)\n        g[v].append(u)\n    \n    visited = [False]*n \n    ans = 0 \n    for i in range(n):\n        if not visited[i]:\n            ans += 1\n            dfs(i,visited)\n    print(ans)", "class DSU(object):\r\n    def __init__(self, n):\r\n        self.parents = [i for i in range(n)]\r\n    \r\n    def find(self,x):\r\n        if self.parents[x] != x:\r\n            self.parents[x] = self.find(self.parents[x])\r\n        return self.parents[x]\r\n    \r\n    def union(self, x, y):\r\n        rootA, rootB = self.find(x), self.find(y)\r\n        if rootA != rootB:\r\n            self.parents[rootA] = rootB\r\n\r\ndef solve():\r\n\tn,m=map(int,input().split())\r\n\tdsu=DSU(n)\r\n\tfor i in range(m):\r\n\t\tx,y=map(int,input().split())\r\n\t\tdsu.union(x,y)\r\n\tcnt=0\r\n\tfor i,x in enumerate(dsu.parents):\r\n\t\tcnt+=(i==x)\r\n\tprint(cnt)\r\n\r\nt=int(input())\r\nwhile t:\r\n\tsolve()\r\n\tt-=1", "from collections import *\r\nfor _ in range(int(input())):\r\n    graph=defaultdict(list)\r\n    def edge(x,y):\r\n        graph[x].append(y)\r\n    def deltafun(s,visited):\r\n        visited[s]=1\r\n        for i in graph[s]:\r\n            if visited[i]==0:\r\n                deltafun(i,visited)\r\n        \r\n    def delta(s):\r\n        visited=[0]*n\r\n        ans=0\r\n        for i in range(n):\r\n            if visited[i]==0:\r\n                deltafun(i,visited)\r\n                ans+=1\r\n        return ans        \r\n        \r\n    n,m=list(map(int,input().split()))\r\n    for i in range(m):\r\n        a,b=list(map(int,input().split()))\r\n        edge(a,b)\r\n        edge(b,a)\r\n    print(delta(0))    \r\n", "class Graph:\n    def __init__(self,V): \n        self.V = V \n        self.adj = [[] for i in range(V)] \n  \n    def DFSUtil(self, temp, v, visited): \n        visited[v] = True\n        temp.append(v) \n        for i in self.adj[v]: \n            if visited[i] == False: \n                temp = self.DFSUtil(temp, i, visited) \n        return temp \n    def addEdge(self, v, w): \n        self.adj[v].append(w) \n        self.adj[w].append(v) \n    def connectedComponents(self): \n        visited = [] \n        cc = [] \n        for i in range(self.V): \n            visited.append(False) \n        for v in range(self.V): \n            if visited[v] == False: \n                temp = [] \n                cc.append(self.DFSUtil(temp, v, visited)) \n        return cc \n\n#g = Graph(5); \n#g.addEdge(1, 0) \n#g.addEdge(2, 3) \n#g.addEdge(3, 4) \n#cc = g.connectedComponents() \n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    g = Graph(n)\n    for i in range(m):\n        a, b = map(int, input().split())\n        g.addEdge(a, b)\n    cc = g.connectedComponents()\n    print(len(cc))", "from collections import defaultdict \r\ndef dfs(node):\r\n    visit[node]=True\r\n    nonlocal flag\r\n    flag=1\r\n    for i in g[node]:\r\n        if visit[i]==False:\r\n            dfs(i)\r\n\r\nfor _ in range(int(input())):\r\n    n,m=list(map(int,input().split()))\r\n    g = defaultdict(list)\r\n    for i in range(m):\r\n        u,v=list(map(int,input().split()))\r\n        g[u].append(v)\r\n        g[v].append(u)\r\n    flag=0\r\n    c=0\r\n    visit=[False]*(n+1)\r\n    for i in range(0,n):\r\n        if visit[i]==False:\r\n            flag=0\r\n            dfs(i)\r\n            if flag==1:\r\n                c+=1\r\n    print(c)\r\n        \r\n    \r\n", "# cook your dish here\nfrom collections import defaultdict\nl=[]\n\n\ndef DFSUtil(d, temp, v, visited):\n    visited[v] = True\n    temp.append(v)\n    for i in d[v]:\n        if visited[i] == False:\n            # Update the list\n            temp = DFSUtil(d,temp, i, visited)\n    return temp\ndef connectedComponents(n):\n    visited = []\n    cc = []\n    for i in range(n):\n        visited.append(False)\n    for v in range(n):\n        if visited[v] == False:\n            temp = []\n            cc.append(DFSUtil(d,temp, v, visited))\n    return cc\nfor _ in range(int(input())):\n    n,m=list(map(int,input().split()))\n    d=defaultdict(list)\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        d[x].append(y)\n        d[y].append(x)\n    l.append(len(connectedComponents(n)))\nfor i in l:\n    print(i)\n\n", "# cook your dish here\n'''\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n'''\n\"\"\"*****     *****\n *******   *******\n********* *********\n*******************\n *****************\n  ****TITLI******\n   *************\n    ***********\n     *********\n      *******\n       *****\n        ***\n         *\"\"\"\nimport sys\nfrom sys import stdin,stdout\nimport math\nimport time\nimport random\nfrom functools import lru_cache\nfrom collections import Counter\nimport heapq\n#@lru_cache(maxsize=None) #for optimizing the execution time of callable objects/functions(placed above callable functions)\ndef Update(X,AX,BX,CX,DX,k,n):\n    for i in range(k,n):\n        tem=(((AX*X[i-2])+(BX*X[i-1])+CX)%DX)+1\n        X.append(tem)\ndef my_function():\n  print(\"Hello from a function\")\n        \n        \n        \n        \n\"\"\"def changeme( mylist ):\n   \"This changes a passed list into this function\"\n   mylist.append([1,2,3,4]);\n   print \"Values inside the function: \", mylist\n   returnd=[art[i+1]-art[i] for i in range(na-1)]\n        y=list(set(d))\n        ns=float('-inf')\n        p=1\n        while p<na:\n                d=art[p]-art[p-1]\n                smy=1\n                while p<na and(art[p]-art[p-1]==d):\n                       p+=1\n                       smy+=1\n                       ns=max(ns,smy)\n           s,v=map(int,input().split())\n            addEdge(adj,s,v)\n        DFS(adj,0,n)\n\ndef DFS_REC(adj,s,visited):\n    visited[s]=True\n    for s in adj[s]:\n        if not visited[s]:\n            DFS_REC(adj,s,visited)\ndef DFS(adj,src,n):\n    visited=[False]*n\n    ans=0\n    for i in range(n):\n        if not visited[i]:\n            ans+=1\n            DFS_REC(adj,i,visited)\n    print(ans)\ndef addEdge(adj,u,v):\n    adj[u].append(v)\n    adj[v].append(u)\"\"\"\ndef a(adj,s,visited):\n    visited[s]=True\n    for s in adj[s]:\n        if not visited[s]:\n            a(adj,s,visited)\ndef b(adj,src,n):\n    visited=[False]*n\n    ans=0\n    for i in range(n):\n        if not visited[i]:\n            ans+=1\n            a(adj,i,visited)\n    print(ans)\n\n\n\n\ndef e(adj,s,v):\n    adj[s].append(v)\n    adj[v].append(s)\n\ntry:\n    for _ in range(int(input())):\n        n,m=list(map(int,input().split()))\n        adj=[[] for i in range(n+1)]\n        for i in range(m):\n            s,v=list(map(int,input().split()))\n            e(adj,s,v)\n        b(adj,0,n)\n       \n       \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   \n       \n       \n   \n       \n       \n       \n               \n        \nexcept EOFError as e:\n    print(e)\n", "# cook your dish here\nclass Graph:\n    def __init__(self,V): \n        self.V = V \n        self.adj = [[] for i in range(V)] \n  \n    def dfs(self, temp, v, visited): \n        visited[v] = True\n        temp.append(v) \n        \n        for i in self.adj[v]: \n            if visited[i] == False:\n                temp = self.dfs(temp, i, visited) \n        return temp \n        \n    def addEdge(self, v, w): \n        self.adj[v].append(w) \n        self.adj[w].append(v) \n        \n    def connectedComponents(self): \n        visited = [] \n        cc = [] \n        for i in range(self.V): \n            visited.append(False) \n        for v in range(self.V): \n            if visited[v] == False: \n                temp = [] \n                cc.append(self.dfs(temp, v, visited)) \n        return cc \n        \nfor _ in range(int(input())):\n    N, M = map(int, input().split())\n    g = Graph(N)\n    for i in range(M):\n        a, b = map(int, input().split())\n        g.addEdge(a, b)\n    print(len(g.connectedComponents()))", "\r\nfrom collections import defaultdict\r\n\r\ndef solve(L, n):\r\n    vis = [False]*n\r\n    def dfs(s):\r\n        vis[s] = True\r\n        for i in L[s]:\r\n            if not vis[i]:\r\n                dfs(i)\r\n\r\n    ans = 0\r\n    for i in range(n):\r\n        if not vis[i]:\r\n            ans += 1\r\n            dfs(i)\r\n    return ans\r\n\r\nt = int(input())\r\n\r\nfor i in range(t):\r\n    n, m = map(int, input().split())\r\n    adjList = defaultdict(list)\r\n\r\n    for k in range(m):\r\n        a, b = map(int, input().split())\r\n        adjList[a].append(b)\r\n        adjList[b].append(a)\r\n\r\n    print(solve(adjList, n))", "from collections import defaultdict\nclass graph():\n    def __init__(self, n):\n        self.v = n\n        self.adj = defaultdict(list)\n    def addedge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def connected(self):\n        vis = [False]*self.v\n        c = []\n        for v in range(self.v):\n            if vis[v] == False:\n                temp = []\n                c.append(self.util(temp, v, vis))\n        return c\n    \n    def util(self, temp, v, vis):\n        vis[v] = True\n        temp.append(v)\n        for i in self.adj[v]:\n            if vis[i] == False:\n                temp = self.util(temp, i, vis)\n        return temp\n        \nt = int(input())\nwhile t>0:\n    t = t-1\n    n, m = list(map(int, input().split()))\n    gr = graph(n)\n    for i in range(m):\n        u, v = list(map(int, input().split()))\n        gr.addedge(u, v)\n    c  = gr.connected()\n    print(len(c))", "class Graph: \n\tdef __init__(self,V):self.V = V;self.adj = [[] for i in range(V)] \n\tdef DFSUtil(self, temp, v, visited): \n\t\tvisited[v] = True;temp.append(v) \n\t\tfor i in self.adj[v]: \n\t\t\tif visited[i] == False:temp = self.DFSUtil(temp, i, visited) \n\t\treturn temp \n\tdef addEdge(self, v, w):self.adj[v].append(w);self.adj[w].append(v) \n\tdef connectedComponents(self): \n\t\tvisited = [];cc = [] \n\t\tfor i in range(self.V):visited.append(False) \n\t\tfor v in range(self.V): \n\t\t\tif visited[v] == False:temp = [];cc.append(self.DFSUtil(temp, v, visited)) \n\t\treturn cc \nfor _ in range(int(input())):\n    n,m = map(int,input().split());g = Graph(n)\n    for i in range(m):a,b = map(int,input().split());g.addEdge(a,b)\n    print(len(g.connectedComponents()))", "# Python program to print connected \n# components in an undirected graph \nclass Graph: \n\t\n\t# init function to declare class variables \n\tdef __init__(self,V): \n\t\tself.V = V \n\t\tself.adj = [[] for i in range(V)] \n\n\tdef DFSUtil(self, temp, v, visited): \n\n\t\t# Mark the current vertex as visited \n\t\tvisited[v] = True\n\n\t\t# Store the vertex to list \n\t\ttemp.append(v) \n\n\t\t# Repeat for all vertices adjacent \n\t\t# to this vertex v \n\t\tfor i in self.adj[v]: \n\t\t\tif visited[i] == False: \n\t\t\t\t\n\t\t\t\t# Update the list \n\t\t\t\ttemp = self.DFSUtil(temp, i, visited) \n\t\treturn temp \n\n\t# method to add an undirected edge \n\tdef addEdge(self, v, w): \n\t\tself.adj[v].append(w) \n\t\tself.adj[w].append(v) \n\n\t# Method to retrieve connected components \n\t# in an undirected graph \n\tdef connectedComponents(self): \n\t\tvisited = [] \n\t\tcc = [] \n\t\tfor i in range(self.V): \n\t\t\tvisited.append(False) \n\t\tfor v in range(self.V): \n\t\t\tif visited[v] == False: \n\t\t\t\ttemp = [] \n\t\t\t\tcc.append(self.DFSUtil(temp, v, visited)) \n\t\treturn cc \n\n\nfor _ in range(int(input())):\n    n,m = list(map(int,input().split()))\n    g = Graph(n)\n    for i in range(m):\n        a,b = list(map(int,input().split()))\n        g.addEdge(a,b)\n    #print(g.connectedComponents())\n    print(len(g.connectedComponents()))\n\n", "class Graph: \n    def __init__(self,V): \n        self.V = V \n        self.adj = [[] for i in range(V)] \n  \n    def DFSUtil(self, temp, v, visited): \n  \n        # Mark the current vertex as visited \n        visited[v] = True\n  \n        # Store the vertex to list \n        temp.append(v) \n  \n        # Repeat for all vertices adjacent \n        # to this vertex v \n        for i in self.adj[v]: \n            if visited[i] == False: \n                  \n                # Update the list \n                temp = self.DFSUtil(temp, i, visited) \n        return temp \n    \n    def addEdge(self, v, w): \n        self.adj[v].append(w) \n        self.adj[w].append(v) \n  \n    # Method to retrieve connected components \n    # in an undirected graph \n    def connectedComponents(self): \n        visited = [] \n        cc = [] \n        for i in range(self.V): \n            visited.append(False) \n        for v in range(self.V): \n            if visited[v] == False: \n                temp = [] \n                cc.append(self.DFSUtil(temp, v, visited)) \n        return cc \n  \n# Driver Code \nfor _ in range(int(input())):\n      \n    n, m = map(int, input().split())\n    g = Graph(n); \n    for _ in range(m):\n        x, y = map(int, input().split())\n        g.addEdge(x, y) \n    \n    cc = g.connectedComponents() \n    print(len(cc)) ", "# cook your dish here\ndef dfs(s):\n\tif v[s]==1:\n\t\treturn\n\tv[s] = 1\n\tfor k in adj[s]:\n\t\tdfs(k)\ntest = int(input())\nfor t in range(test):\n\tn,m = map(int, input().split())\n\tv = [0 for i in range(n)]\n\tadj = [[] for i in range(n)]\n\tfor i in range(m):\n\t\ta,b = map(int, input().split())\n\t\tadj[a].append(b)\n\t\tadj[b].append(a)\n\tcount = 0\n\twhile(0 in v):\n\t\tnode = v.index(0)\n\t\tdfs(node)\n\t\tcount += 1\n\tprint(count)", "class Graph: \r\n      \r\n    # init function to declare class variables \r\n    def __init__(self,V): \r\n        self.V = V \r\n        self.adj = [[] for i in range(V)] \r\n  \r\n    def DFSUtil(self, temp, v, visited): \r\n  \r\n        # Mark the current vertex as visited \r\n        visited[v] = True\r\n  \r\n        # Store the vertex to list \r\n        temp.append(v) \r\n  \r\n        # Repeat for all vertices adjacent \r\n        # to this vertex v \r\n        for i in self.adj[v]: \r\n            if visited[i] == False: \r\n                  \r\n                # Update the list \r\n                temp = self.DFSUtil(temp, i, visited) \r\n        return temp \r\n  \r\n    # method to add an undirected edge \r\n    def addEdge(self, v, w): \r\n        self.adj[v].append(w) \r\n        self.adj[w].append(v) \r\n  \r\n    # Method to retrieve connected components \r\n    # in an undirected graph \r\n    def connectedComponents(self): \r\n        visited = [] \r\n        cc = [] \r\n        for i in range(self.V): \r\n            visited.append(False) \r\n        for v in range(self.V): \r\n            if visited[v] == False: \r\n                temp = [] \r\n                cc.append(self.DFSUtil(temp, v, visited)) \r\n        return len(cc) \r\n  \r\n# Driver Code \r\ndef __starting_point(): \r\n      \r\n    # Create a graph given in the above diagram \r\n    # 5 vertices numbered from 0 to 4 \r\n    t = int(input())\r\n    for _ in range(t):\r\n        n,m=list(map(int , input().strip().split()))\r\n        \r\n        g = Graph(n); \r\n        for _ in range(m):\r\n            a,b=list(map(int , input().strip().split()))\r\n            g.addEdge(a, b)\r\n        \r\n        \r\n        cc = g.connectedComponents() \r\n        #print(\"Following are connected components\") \r\n        print(cc) \n__starting_point()", "# cook your dish here\nfrom collections import defaultdict\nclass Graph:\n    def __init__(self,n):\n        self.n=n\n        self.edge=defaultdict(list)\n    def addegde(self,u,v):\n        self.edge[u].append(v)\n        self.edge[v].append(u)\n    def dfsUtil(self,i,visited):\n        visited[i]=True\n        for j in self.edge[i]:\n            if visited[j]==False:\n                self.dfsUtil(j,visited)\n    def dfs(self):\n        visited=[False]*self.n\n        s=0\n        for i in range(self.n):\n            if visited[i]==False:\n                s+=1\n                self.dfsUtil(i,visited)\n        return s\nfor _ in range(int(input())):\n    m,n=map(int,input().split())\n    g=Graph(m)\n    for i in range(n):\n        a,b=map(int,input().split())\n        g.addegde(a,b)\n    print(g.dfs())", "# Python3 program to print DFS traversal\n# from a given given graph\nfrom collections import defaultdict\n\nviz = [0]*1005\n# This class represents a directed graph using\n# adjacency list representation\n\n\nclass Graph:\n\n    # Constructor\n    def __init__(self):\n\n        # default dictionary to store graph\n        self.graph = defaultdict(list)\n\n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    # A function used by DFS\n    def DFSUtil(self, v, visited):\n        nonlocal viz\n        # Mark the current node as visited\n        # and print it\n        visited[v] = True\n        viz[v]=1\n        # print(v, end=' ')\n\n        # Recur for all the vertices\n        # adjacent to this vertex\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited)\n\n    # The function to do DFS traversal. It uses\n    # recursive DFSUtil()\n    def DFS(self, v,visited):\n\n        # Mark all the vertices as not visited\n        # visited = [False] * (max(self.graph)+1)\n\n        # Call the recursive helper function\n        # to print DFS traversal\n        self.DFSUtil(v, visited)\n\n        return visited\n\n# Driver code\n\n\n# Create a graph given\n# in the above diagram\nfor _ in range(int(input())):\n    \n    g = Graph()\n    n, m = list(map(int, input().split()))\n    vizi=[False]*(n+1)\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        g.addEdge(a, b)\n        g.addEdge(b, a)\n\n    cnt = 0\n    for i in range(n):\n        if vizi[i] == False:\n            cnt += 1\n            vizi=g.DFS(i,vizi)\n\n    print(cnt)\n\n# print(\"Following is DFS from (starting from vertex 2)\")\n# g.DFS(2)\n\n# This code is contributed by Neelam Yadav\n", "# Python3 program to print DFS traversal\n# from a given given graph\nfrom collections import defaultdict\n\nviz = [0]*1005\n# This class represents a directed graph using\n# adjacency list representation\n\n\nclass Graph:\n\n    # Constructor\n    def __init__(self):\n\n        # default dictionary to store graph\n        self.graph = defaultdict(list)\n\n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    # A function used by DFS\n    def DFSUtil(self, v, visited):\n        nonlocal viz\n        # Mark the current node as visited\n        # and print it\n        visited[v] = True\n        viz[v]=1\n        # print(v, end=' ')\n\n        # Recur for all the vertices\n        # adjacent to this vertex\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited)\n\n    # The function to do DFS traversal. It uses\n    # recursive DFSUtil()\n    def DFS(self, v,visited):\n\n        # Mark all the vertices as not visited\n        # visited = [False] * (max(self.graph)+1)\n\n        # Call the recursive helper function\n        # to print DFS traversal\n        self.DFSUtil(v, visited)\n\n        return visited\n\n# Driver code\n\n\n# Create a graph given\n# in the above diagram\nfor _ in range(int(input())):\n    \n    g = Graph()\n    n, m = list(map(int, input().split()))\n    vizi=[False]*(n+1)\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        g.addEdge(a, b)\n        g.addEdge(b, a)\n\n    cnt = 0\n    for i in range(n):\n        if vizi[i] == False:\n            cnt += 1\n            vizi=g.DFS(i,vizi)\n\n    print(cnt)\n\n# print(\"Following is DFS from (starting from vertex 2)\")\n# g.DFS(2)\n\n# This code is contributed by Neelam Yadav\n", "# cook your dish here\n#Author : Ashutosh Wagh, Codechef : ashutosh0903\n\nclass Graph: \n    def __init__(self,V): \n        self.V = V \n        self.adj = [[] for i in range(V)] \n  \n    def DFSUtil(self, temp, v, visited): \n        visited[v] = True\n        temp.append(v)\n        for i in self.adj[v]: \n            if visited[i] == False: \n                temp = self.DFSUtil(temp, i, visited) \n        return temp \n \n    def addEdge(self, v, w): \n        self.adj[v].append(w) \n        self.adj[w].append(v) \n  \n    def connectedComponents(self): \n        visited = [] \n        cc = [] \n        for i in range(self.V): \n            visited.append(False) \n        for v in range(self.V): \n            if visited[v] == False: \n                temp = [] \n                cc.append(self.DFSUtil(temp, v, visited)) \n        return len(cc)\n        \nfor _ in range(int(input())) :\n    n,m = list(map(int,input().split()))\n    g = Graph(n)\n    for i in range(m) :\n        a,b = list(map(int,input().split()))\n        g.addEdge(a,b)\n    ans = g.connectedComponents()\n    print(ans)\n", "def dfs(u):\r\n    visited[u] = 1\r\n    for i in graph[u]:\r\n        if visited[i] == 0:\r\n            dfs(i)\r\n\r\nfor _ in range(int(input())):\r\n    N, M = map(int, input().split())\r\n    graph = [[] for i in range(N)]\r\n    for i in range(M):\r\n        u, v = map(int, input().split())\r\n        graph[u].append(v)\r\n        graph[v].append(u)\r\n    ccnum = 0\r\n    visited = [0] * N\r\n    for pp in range(N):\r\n        if visited[pp] == 0:\r\n            dfs(pp)\r\n            ccnum += 1\r\n    print(ccnum)"]
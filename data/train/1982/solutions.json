["class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        group = [None] * (N + 1)\n        group[dislikes[0][0]] = 1\n        group[dislikes[0][1]] = -1\n        group1 = set([1])\n        group2 = set()\n        counter = 2\n        for i, j in dislikes[1:]:\n            if group[i] and group[j]:\n                if group[i] == group[j]:\n                    return False\n                if group[i] in group1:\n                    if group[j] in group1 or -group[j] in group2:\n                        return False\n                    group2.add(group[j])\n                elif group[i] in group2:\n                    if group[j] in group2 or -group[j] in group1:\n                        return False\n                    group1.add(group[j])\n                elif group[j] in group1:\n                    if group[i] in group1 or -group[i] in group2:\n                        return False\n                    group2.add(group[i])\n                elif group[j] in group2:\n                    if group[i] in group2 or -group[i] in group1:\n                        return False\n                    group1.add(group[i])\n            elif not group[i] and not group[j]:\n                group[i], group[j] = counter, -counter\n                counter += 1\n            elif group[i]:\n                group[j] = -group[i]\n            elif group[j]:\n                group[i] = -group[j]\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        edge = [[] for _ in range(N + 1)]\n        for u, v in dislikes:\n            edge[u].append(v)\n            edge[v].append(u)\n        color = [0] * (N + 1)\n        for i in range(1, N + 1):\n            if color[i] == 0:\n                q = [i]\n                color[i] = 1\n                while q:\n                    cur = q.pop()\n                    cur_c = color[cur]\n                    for node in edge[cur]:\n                        if color[node] == 0:\n                            color[node] = cur_c * -1\n                            q.append(node)\n                        elif color[node] == cur_c:\n                            return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = collections.defaultdict(list)\n        for i, j in dislikes:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        color = dict()\n        \n        for i in range(1,N+1):\n            if i not in color:\n                if not self.dfs(i, color, graph, c=0):\n                    return False\n        # print(color)        \n        return True        \n    \n    def dfs(self, idx, color, graph, c):\n        # print((idx,c))\n        color[idx] = c\n        newc = 0 if c == 1 else 1\n        for i in graph[idx]:\n            if i not in color:\n                if not self.dfs(i, color, graph, newc):\n                    return False\n            else:\n                if color[i] == color[idx]:\n                    return False\n        return True   \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(list)\n        for u,v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = {}\n        for i in range(1,N+1):\n            if i not in color:\n                ret = self.dfs(graph,i,color,'R')\n                if not ret:\n                    return False\n        return True\n    \n    def dfs(self,graph,i,color,currentColor) -> bool:\n        color[i] = currentColor\n        complementaryColor = 'R' if currentColor=='B' else 'B'\n        for neighbor in graph[i]:\n            if neighbor in color:\n                if color[neighbor]==currentColor:\n                    return False\n            else:\n                res = self.dfs(graph,neighbor,color,complementaryColor)\n                if not res:\n                    return False\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        groups = [0] * (N+1)\n        adj = collections.defaultdict(list)\n        for [i, j] in dislikes:\n            adj[i].append(j)\n            adj[j].append(i)\n        \n        def dfs(i):\n            for nei in adj[i]:\n                if groups[nei]:\n                    if groups[nei] == groups[i]:\n                        return False\n                else:\n                    groups[nei] = -groups[i]\n                    if not dfs(nei):\n                        return False\n            return True\n        \n        for i in range(N):\n            if not groups[i]:\n                groups[i] = 1\n                if not dfs(i):\n                    return False\n        return True\n                \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N==1 or not dislikes:\n            return True\n        x={i:[] for i in range(1,N+1)}\n        for i,j in dislikes:\n            x[i].append(j)\n            x[j].append(i)\n        colour=[-1]*N\n        for i in range(1,N+1):\n            if colour[i-1]==-1:\n                colour[i-1]=0\n                q=[i]\n                while q:\n                    node=q.pop()\n                    for j in x[node]:\n                        if colour[node-1]==colour[j-1]:\n                            return False\n                        if colour[j-1]==-1:\n                            colour[j-1]=colour[node-1]^1\n                            q.append(j)\n        return True", "\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, start, seen):\n        q = [(start, 1)]\n        while len(q) > 0:\n            pop, color = q.pop(0)\n            if pop in seen:\n                if seen[pop] != color:\n                    return False\n                continue\n            seen[pop] = color\n            vertices = connections[pop]\n            for v in vertices:\n                q.append((v, -color))\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        self.ans = True    \n    \n        def dfs(p, d, ld, l):\n            if not self.ans:\n                return\n\n            if not p in ld:\n                ld[p] = l\n            else:\n                if ld[p] != l:\n                    self.ans = False\n                return\n                        \n            for n in d[p]:\n                dfs(n, d, ld, (l + 1) % 2)\n        \n        i = 0\n        d = {}\n        while i < len(dislikes):\n            [a, b] = dislikes[i]\n            if a in d:\n                d[a].append(b)\n            else:\n                d[a] = [b]\n            if b in d:\n                d[b].append(a)\n            else:\n                d[b] = [a]\n            i += 1\n                \n        \n        ld = {}\n        for k in d:\n            if not k in ld:\n                dfs(k, d, ld, 0)\n                if not self.ans: \n                    break\n                    \n        return self.ans\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = collections.defaultdict(list)\n\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        people = list(graph.keys())\n        belongs = [None] * (N+1)\n        WHITE, GRAY, BLACK = 0, 1, 2\n        color = [WHITE] * (N+1)\n        queue = collections.deque()\n\n        for u in people:\n            if color[u] == WHITE:\n                color[u] = GRAY\n                queue.append(u)\n                belongs[u] = 1\n\n                while queue:\n                    v = queue.popleft()\n\n                    for w in graph[v]:\n                        if color[w] == WHITE:\n                            color[w] = GRAY\n                            queue.append(w)\n                            belongs[w] = belongs[v] * -1\n                        elif belongs[w] == belongs[v]:\n                            return False\n\n                    color[v] = BLACK\n\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N == 0:\n            return False\n        \n        dlikelist = [[] for i in range(N)]\n        for p in dislikes:\n            dlikelist[p[0]-1].append(p[1]-1)\n            dlikelist[p[1]-1].append(p[0]-1) #Dislike is mutual\n            \n        seen = [-1] * N\n        group = [-1] * N\n        parent = [-1] * N\n        \n        def dfs(src):\n            seen[src] = 1\n            if parent[src] == -1:\n                group[src] = 0\n            else:\n                group[src] = 1 -group[parent[src]]\n            \n            for p in dlikelist[src]:\n                if seen[p] == -1:\n                    parent[p] = src\n                    if dfs(p) == False:\n                        return   False\n                else:\n                    if group[p] == group[src]:\n                        return False\n            return True\n            \n\n        for i in range(N):\n            if seen[i] == -1:\n                if dfs(i) == False:\n                    return False\n        return True\n        \n        \n        \n", "def dfs(adjList, teams, node):\n    teams[node] = 1\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        team = teams[node]\n        for adjNode in adjList[node]:\n            if adjNode in teams and teams[adjNode] == team:\n                return False\n            if adjNode not in teams:\n                teams[adjNode] = 1 - team\n                stack.append(adjNode)\n    return True\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        adjList = {i: [] for i in range(1, N + 1)}\n        for dislike in dislikes:\n            x = dislike[0]\n            y = dislike[1]\n            adjList[x].append(y)\n            adjList[y].append(x)\n            \n        teams = {}\n        for i in range(1, N + 1):\n            if i not in teams:\n                if not dfs(adjList, teams, i):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        g = [[] for _ in range(N)]\n        for p in dislikes:\n            p[0] -= 1\n            p[1] -= 1\n            g[p[0]].append(p[1])\n            g[p[1]].append(p[0])\n            \n        col = [0] * N\n        def dfs(v, c):\n            col[v] = c\n            for to in g[v]:\n                if col[to] == c:\n                    return False\n                elif col[to] == 0 and not dfs(to, 3 - c):\n                    return False\n            return True\n        for i in range(N):\n            if col[i] == 0 and not dfs(i, 1):\n                return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        pairs = {}\n        for a,b in dislikes:\n            if not a in pairs:\n                pairs[a] = set()\n            if not b in pairs:\n                pairs[b] = set()\n            pairs[a].add(b)\n            pairs[b].add(a)\n        seen = set()\n        for i in range(1,N+1):\n            if i in seen:\n                continue\n            curr = set([i])\n            A, B = set(), set()\n            A.add(i)\n            flag = 1\n            while len(curr):\n                _next = set()\n                for c in curr:\n                    if c not in pairs:\n                        continue\n                    for n in pairs[c]:\n                        if flag == 1 and n in A:\n                            return False\n                        if flag == 0 and n in B:\n                            return False\n                        if n in seen:\n                            continue\n                        if flag:\n                            B.add(n)\n                        else:\n                            A.add(n)\n                        seen.add(n)\n                        _next.add(n)\n                curr = _next\n                flag ^= 1\n        return True\n                \n                \n", "import collections\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def dfs(curr, curr_color):\n            color[curr] = curr_color\n            for next in graph[curr]:\n                if color[next] == None:\n                    dfs(next, not curr_color)\n                elif color[next] == curr_color:\n                    return False\n            return True\n        \n        graph = collections.defaultdict(list)\n        color = [None] * (N + 1)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        for n in range(1, N + 1):\n            if color[n] == None:\n                if not dfs(n, True):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:        \n        # build graph\n        graph = [set() for _ in range(N+1)]\n        for a,b in dislikes: \n            graph[a-1].add(b-1)\n            graph[b-1].add(a-1)\n        \n        colors = [0] * N\n        q = []\n        for i in range(N):\n            if colors[i] != 0: continue\n            q.append(i)\n            colors[i] = 1\n            while q:\n                cur = q.pop()\n                for nxt in graph[cur]:\n                    if colors[nxt] == colors[cur]: return False\n                    if colors[nxt] == 0:\n                        colors[nxt] = -colors[cur]\n                        q.append(nxt)\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        coloring = {i:-1 for i in range(1, N+1)}\n        edges = defaultdict(list)\n        for a,b in dislikes:\n            edges[a].append(b)\n            edges[b].append(a)\n        def dfs(node, color):\n            if coloring[node] != -1:\n                return coloring[node] == color\n            coloring[node] = color\n            for hater in edges[node]:\n                if not dfs(hater, 1-color): return False\n            return True\n        return all([coloring[node]!=-1 or dfs(node, 0) for node in range(1, N+1)])\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        group = [None] * (N + 1)\n        group[dislikes[0][0]] = 1\n        group[dislikes[0][1]] = -1\n        counter = 2\n        for i, j in dislikes[1:]:\n            if group[i] and group[j]:\n                if group[i] == group[j]:\n                    return False\n                if group[i] * group[j] > 0:\n                    l = group[j]\n                    for k in range(N + 1):\n                        if group[k] == l:\n                            group[k] = -group[i]\n                        if group[k] == -l:\n                            group[k] = group[i]\n            if not group[i] and not group[j]:\n                group[i], group[j] = counter, -counter\n                counter += 1\n                continue\n            if group[i]:\n                group[j] = -group[i]\n            if group[j]:\n                group[i] = -group[j]\n        return True", "from collections import defaultdict, deque\n\nclass Solution:\n    # Time: O(E) | Space: O(V+E)\n    def create_adjacency_list(self, dislikes):\n        adjacency_list = defaultdict(list)\n        # undirected graph (a dislikes b -> b also dislikes a)\n        for i , j in dislikes:\n            adjacency_list[i].append(j) # since vertices numbered from 1 to N\n            adjacency_list[j].append(i) # imp for undirected graph\n        return adjacency_list\n    \n    # BFS solution\n    # Time: O(V+E) | Space: O(V+E)\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # create adjacency list\n        adjacency_list = self.create_adjacency_list(dislikes)\n        \n        print(adjacency_list)\n        \n        # initialize colors ( for bipartite segregation, alos serves as visited flag)\n        color = {vertex:-1 for vertex in adjacency_list}\n        print(color)\n        \n        # initialize bfs queue\n        queue = deque()\n        \n        # call bfs on every connected component\n        for vertex in adjacency_list: # remember - adjacency_list is a dict\n            if color[vertex] == -1:\n                # bfs\n                # color the source (visited) add it to queue \n                color[vertex] = 0\n                queue.append(vertex)\n                \n                # main bfs loop\n                while queue:\n                    current_node = queue.popleft()\n                    for neighbor in adjacency_list[current_node]:\n                        if color[neighbor] == color[current_node]:\n                            return False\n                        if color[neighbor] == -1:\n                            # not colored (visited)\n                            # color of neighbor should be opposite of current node for it to be bipartite\n                            # color the neighbor and add it to queue\n                            color[neighbor] = 1-color[current_node]\n                            queue.append(neighbor)\n            \n        # if we reach here we have a valid bipartite graph\n        return True\n                            \n                    \n        \n        \n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N, dislikes):\n        #graph = [[] * (N+1)]\n        graph = [[] for _ in range(N+1)]\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = dict()\n        def dfs(node):\n            for nei in graph[node]:\n                if nei in color:\n                    if color[nei] == color[node]:\n                        return False\n                else:\n                    color[nei] = color[node] ^ 1\n                    if not dfs(nei):\n                        return False\n            return True\n        for node in range(1, N+1):\n            if node not in color:\n                color[node] = 0\n                if not dfs(node):\n                    return False\n        return True", "from collections import defaultdict\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def dfs(node, group, groups):\n            if node not in groups:\n                groups[node] = group\n            elif group != groups[node]:\n                return True\n            elif group == groups[node]:\n                return False\n\n            for next_node in graph[node]:\n                fail = dfs(next_node, not groups[node], groups)\n                if fail == True:\n                    return True\n\n            return False\n    \n        graph = defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n            \n        groups = {}\n        \n        for node in graph:\n            if node not in groups:\n                fail = dfs(node, True, groups)\n                if fail:\n                    return False\n        \n        return True\n                    \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        gr = [[] for _ in range(N+1)]\n        A = set()\n        B = set()\n        \n        for x in dislikes:\n            gr[x[0]].append(x[1])\n            gr[x[1]].append(x[0])\n\n        done = set()\n        qu = []\n        \n        for v in range(1, N):\n            if v not in done:\n                qu.append(v)\n                A.add(v)\n                \n            while qu:\n                y = qu.pop(0)\n                if y not in done:\n                    if y in A:\n                        for x1 in gr[y]:\n                            B.add(x1)\n                            qu.append(x1)\n                    else:\n                        for x1 in gr[y]:\n                            A.add(x1)\n                            qu.append(x1)\n\n                    done.add(y)\n\n                if  A.isdisjoint(B) == False:\n                    return False\n        \n        return A.isdisjoint(B)\n                \n                \n        \n        \n        \n        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if len(dislikes) == 0:\n            return True\n        seenA = set()\n        seenB = set()\n        seen = set()\n        ref = dict()\n        stack = []\n        for i in range(1, N+1):\n            ref[i] = []\n        for l in dislikes:\n            s, t = l[0], l[1]\n            ref[s].append(t)\n            ref[t].append(s)\n        erase = []\n        for i in ref:\n            if len(ref[i]) == 0:\n                erase.append(i)\n        for i in erase:\n            ref.pop(i)\n        stack = list(ref.keys())\n        while len(stack) != 0:\n            i = stack.pop(0)\n            if i in seen:\n                continue\n            target = seenA if i in seenA else seenB\n            other = seenB if i in seenA else seenA\n            target.add(i)\n            seen.add(i)\n            for j in ref[i]:\n                stack.insert(0, j)\n                if j in target:\n                    return False\n                else:\n                    other.add(j)\n        return True\n                \n        \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # build adjacency list\n        adjList = {p : [] for p in range(1, N + 1)}\n        for p1, p2 in dislikes:\n            adjList[p1].append(p2)\n            adjList[p2].append(p1)\n        \n        visited = set()\n        # for each connected component, try to partition perople into two groups\n        for person in range(1, N + 1):\n            if person not in visited:\n                # BFS\n                # initialize two groups \n                groups = [set([person]), set()]\n                curList = [person]\n                level = 0\n                while curList:\n                    next = []\n                    curGroup = groups[level % 2]\n                    theOtherGroup = groups[(level + 1) % 2]\n                    for p in curList:\n                        visited.add(p)\n                        for neighbor in adjList[p]:\n                            # if the neighbor is already in the same group of this person\n                            if neighbor in curGroup:\n                                return False\n                            if neighbor not in theOtherGroup:\n                                theOtherGroup.add(neighbor)\n                                next.append(neighbor)\n\n                    curList = next\n                    level += 1\n            \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[] for _ in range(N+1)]\n        for a, b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)    \n        visited = [0] * (N+1)\n        \n        def go(node, prev, color):\n            if visited[node] != 0:\n                return visited[node] == color\n            visited[node] = color\n            for t in graph[node]:\n                if t == prev:\n                    continue\n                if not go(t, node, -color):\n                    return False\n            return True\n        \n        for i in range(1, N+1):\n            if visited[i] == 0 and not go(i, 0, 1):\n                return False\n        return True\n", "from collections import defaultdict\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        edges = defaultdict(list)\n        for p, c in dislikes:\n            edges[p].append(c)\n            edges[c].append(p)\n        def dfs(i):\n            colour = visited[i]\n            for c in edges[i]:\n                if c in visited:\n                    if visited[c] != -colour:\n                        return False\n                else:\n                    visited[c] = -colour\n                    if not dfs(c):\n                        return False\n            return True\n        \n        visited = {}\n        for i in range(1, N+1):\n            if i not in visited:\n                visited[i] = 1\n                if not dfs(i):\n                    return False\n        return True", "\\\"\\\"\\\"\n50\n[[21,47],[4,41],[2,41],[36,42],[32,45],[26,28],[32,44],[5,41],[29,44],[10,46],[1,6],[7,42],[46,49],[17,46],[32,35],[11,48],[37,48],[37,43],[8,41],[16,22],[41,43],[11,27],[22,44],[22,28],[18,37],[5,11],[18,46],[22,48],[1,17],[2,32],[21,37],[7,22],[23,41],[30,39],[6,41],[10,22],[36,41],[22,25],[1,12],[2,11],[45,46],[2,22],[1,38],[47,50],[11,15],[2,37],[1,43],[30,45],[4,32],[28,37],[1,21],[23,37],[5,37],[29,40],[6,42],[3,11],[40,42],[26,49],[41,50],[13,41],[20,47],[15,26],[47,49],[5,30],[4,42],[10,30],[6,29],[20,42],[4,37],[28,42],[1,16],[8,32],[16,29],[31,47],[15,47],[1,5],[7,37],[14,47],[30,48],[1,10],[26,43],[15,46],[42,45],[18,42],[25,42],[38,41],[32,39],[6,30],[29,33],[34,37],[26,38],[3,22],[18,47],[42,48],[22,49],[26,34],[22,36],[29,36],[11,25],[41,44],[6,46],[13,22],[11,16],[10,37],[42,43],[12,32],[1,48],[26,40],[22,50],[17,26],[4,22],[11,14],[26,39],[7,11],[23,26],[1,20],[32,33],[30,33],[1,25],[2,30],[2,46],[26,45],[47,48],[5,29],[3,37],[22,34],[20,22],[9,47],[1,4],[36,46],[30,49],[1,9],[3,26],[25,41],[14,29],[1,35],[23,42],[21,32],[24,46],[3,32],[9,42],[33,37],[7,30],[29,45],[27,30],[1,7],[33,42],[17,47],[12,47],[19,41],[3,42],[24,26],[20,29],[11,23],[22,40],[9,37],[31,32],[23,46],[11,38],[27,29],[17,37],[23,30],[14,42],[28,30],[29,31],[1,8],[1,36],[42,50],[21,41],[11,18],[39,41],[32,34],[6,37],[30,38],[21,46],[16,37],[22,24],[17,32],[23,29],[3,30],[8,30],[41,48],[1,39],[8,47],[30,44],[9,46],[22,45],[7,26],[35,42],[1,27],[17,30],[20,46],[18,29],[3,29],[4,30],[3,46]]\nreturn T\n\\\"\\\"\\\"\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        g = collections.defaultdict(list)\n        for p1, p2 in dislikes:\n            g[p1].append(p2)\n            g[p2].append(p1)\n        colored = {}\n        # print(g)\n        def check(p, color):\n            if p in colored:\n                if not colored[p] == color:\n                    print(p, color, colored)\n                    return False\n                else:\n                    return True\n            colored[p] = color\n            for nb in g[p]:\n                if not check(nb, -color):\n                    return False\n            return True\n        for p in range(1, N + 1):\n            if p not in colored and not check(p, 1):\n                # print(p, colored)\n                return False\n        return True", "class UnionFind:\n    def __init__(self):\n        self.reps = {}\n        self.ranks = {}\n    \n    def makeset(self, x):\n        self.reps[x] = x\n        self.ranks[x] = 0\n    \n    def find(self, x):\n        if self.reps[x] != x:\n            self.reps[x] = self.find(self.reps[x])\n        return self.reps[x]\n    \n    def union(self, x, y):\n        rep_x = self.find(x)\n        rep_y = self.find(y)\n        if self.ranks[rep_x] > self.ranks[rep_y]:\n            self.reps[rep_y] = rep_x\n        elif self.ranks[rep_x] == self.ranks[rep_y]:\n            self.reps[rep_y] = rep_x\n            self.ranks[rep_x] += 1\n        else:\n            self.reps[rep_x] = rep_y\n\nclass Solution:\n    # Union find to determine if graph is bipartite or 2 color alg would work here\n    # 20 min to think of union find alg until look up the answer start: 10:33\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # they've given us a list of edges to work with \n        unionfind = UnionFind()\n        for i in range(N):        \n            unionfind.makeset(i+1)\n        graph = {}\n        for (u, v) in dislikes:\n            graph.setdefault(u, [])\n            graph[u].append(v)\n            graph.setdefault(v, [])\n            graph[v].append(u)\n        \n        for person in graph:\n            for enemy in graph[person]:\n                # intution is this:\n                # every one in graph[person] should be in the same bipartite group\n                rep_u = unionfind.find(person)\n                rep_v = unionfind.find(enemy)\n                if rep_u != rep_v:\n                    unionfind.union(graph[person][0], enemy)\n                else:\n                    return False\n        \n        return True\n        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def visit(a, depth):     \n            if a in depths:\n                return (depth - depths[a]) % 2 == 0\n\n            depths[a] = depth\n            return all(visit(b, depth + 1) for b in d[a])\n\n        d = collections.defaultdict(set)\n        depths = {}\n        for a,b in dislikes:\n            d[a].add(b)\n            d[b].add(a)\n\n        return all(a in depths or visit(a, 0) for a in d)\n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        dislike_graph = {}\n        for i in range(1, N+1):\n            dislike_graph[i] = []\n            \n        for pair in dislikes:\n            a, b = pair\n            dislike_graph[a].append(b)\n            dislike_graph[b].append(a)\n            \n        \n        visited = [False]*(N+1)\n        color={}\n        \n        def dfs(i):\n            if visited[i]:\n                return True\n            \n            visited[i] = True\n            for nbs in dislike_graph[i]:\n                if nbs in color:\n                    if color[nbs]==color[i]:\n                        return False\n                else:\n                    color[nbs] = -color[i]\n                    if not dfs(nbs):\n                        return False\n            return True\n        \n\n        for i in range(1, N+1):\n            if visited[i]:\n                continue\n            color[i] = 1\n            if not dfs(i):\n                return False\n        \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        NOT_COLORED, BLUE, GREEN = 0, 1, -1\n        \n        if N == 1 or not dislikes:\n            return True\n        \n        dislike_table = collections.defaultdict(list)\n        color_table = [NOT_COLORED for _ in range(N+1)]\n        \n        for i, j in dislikes:  ###undirected graph\n            dislike_table[i].append(j)\n            dislike_table[j].append(i)\n        \n        def dfs(node, color):\n            color_table[node] = color\n            for adj in dislike_table[node]:\n                \n                if color_table[adj] == color:\n                    return False\n                if color_table[adj] == NOT_COLORED and not dfs(adj, -color):\n                    return False\n                \n            return True\n        \n        \n        for person_id in range(1, N+1):\n            if color_table[person_id] == NOT_COLORED and not dfs(person_id, BLUE):\n                return False\n            \n        return True\n        \n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adj = defaultdict(set)\n        for u,v in dislikes:\n            adj[u].add(v)\n            adj[v].add(u)\n        color = [-1] * (N + 1)\n        for i in range(1,N+1):\n            if color[i] == -1:\n                color[i] = 0\n                Q = [i]\n                while Q:\n                    new = []\n                    for cur in Q:\n                        for nxt in adj[cur]:\n                            if color[nxt] == color[cur]:\n                                return False\n                            if color[nxt] == -1:\n                                color[nxt] = 1- color[cur]\n                                new.append(nxt)\n                    Q = new\n        return True", "from collections import defaultdict, deque\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for dislike in dislikes:\n            graph[dislike[0]].add(dislike[1])\n            graph[dislike[1]].add(dislike[0])\n        \n        colors = [-1 for i in range(N + 1)]\n        queue = deque()\n        for i in range(1, N):\n            if colors[i] == -1:\n                queue.append(i)\n                colors[i] = 0\n                while len(queue) > 0:\n                    cur = queue.popleft()\n                    for neighbor in graph[cur]:\n                        if colors[neighbor] == -1:\n                            colors[neighbor] = 1 - colors[cur]\n                            queue.append(neighbor)\n                        elif colors[neighbor] == colors[cur]:\n                                return False\n                    \n        return True", "# 886. Possible Bipartition\n\nimport collections\nclass Solution:\n    \n    def __init__(self):\n        self.colors = []\n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        not_colored = 2\n        self.colors = [not_colored] * (N + 1)\n        \n        graph = collections.defaultdict(list)\n        \n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n            \n        for n in range(1, N): \n            if colors[n] == not_colored and not self.dfs(graph, n, 1):\n                return False\n            \n        return True\n        \n    def dfs(self, graph, vertex, color):\n        self.colors[vertex] = color\n        \n        for u in graph[vertex]:\n            if self.colors[vertex] == colors[u]:\n                return False\n            if self.colors[u] == 2 and not self.dfs(graph, u, not color):\n                return False\n        \n        return True\n    \n    \n\\\"\\\"\\\"\n    1st approach: BFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    780 ms, faster than 28.52%\n\\\"\\\"\\\"\n\n\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n\n        connections = collections.defaultdict(list)\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, start, seen):\n        q = [(start, 1)]\n        while len(q) > 0:\n            pop, color = q.pop(0)\n            if pop in seen:\n                if seen[pop] != color:\n                    return False\n                continue\n            seen[pop] = color\n            vertices = connections[pop]\n            for v in vertices:\n                q.append((v, -color))\n        return True\n\n\n\\\"\\\"\\\"\n    2nd approach: recursive DFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    660 ms, faster than 53.79%\n\\\"\\\"\\\"\n\n\nclass Solution2(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, 1, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, node, color, seen):\n        if node in seen:\n            if seen[node] != color:\n                return False\n            return True\n        seen[node] = color\n        vertices = connections[node]\n        for v in vertices:\n            if self.check(connections, v, -color, seen) == False:\n                return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        NOT_COLORED, RED, BLUE = 0, 1, -1 \n        colors = {p: NOT_COLORED for p in range(1, N + 1)}\n        graph = collections.defaultdict(list)\n        \n        def dfs(person, color):\n            colors[person] = color\n            for neighbor in graph[person]:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == NOT_COLORED and not dfs(neighbor, -color):\n                    return False\n            return True\n        \n        for x, y in dislikes:\n            graph[x].append(y)\n            graph[y].append(x)\n        \n        for i in range(1, N + 1):\n            if colors[i] == NOT_COLORED and not dfs(i, RED):\n                return False\n        \n        return True\n            \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = collections.defaultdict(set)\n        for i, j in dislikes:\n            graph[i].add(j)\n            graph[j].add(i)\n        \n        color = dict()\n        \n        for i in range(1,N+1):\n            if i not in color:\n                if not self.dfs(i, color, graph, c=0):\n                    return False\n        # print(color)        \n        return True        \n    \n    def dfs(self, idx, color, graph, c):\n        # print((idx,c))\n        color[idx] = c\n        newc = 0 if c == 1 else 1\n        for i in graph[idx]:\n            if i not in color:\n                if not self.dfs(i, color, graph, newc):\n                    return False\n            else:\n                if color[i] == color[idx]:\n                    return False\n        return True   \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        edges = collections.defaultdict(list)\n        for d in dislikes:\n            edges[d[0]].append(d[1])\n            edges[d[1]].append(d[0])\n        \n        def dfs(i,col):\n            if i in color:\n                if color[i]!=col: return False\n                else: return True\n            else: color[i] = col\n            \n            new = 1 if col==0 else 0\n            for e in edges[i]:\n                if not dfs(e,new): return False\n            return True\n            \n        \n        color = {}\n        for i in range(N):\n            if i not in color and not dfs(i,0): return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        edges = {i:[] for i in range(1, N + 1)}\n        for a, b in dislikes:\n            edges[a].append(b)\n            edges[b].append(a)\n        \n        groups = {}\n        stack = []\n        for i in range(1, N + 1):\n            if i in groups:\n                continue\n            stack.append(i)\n            groups[i] = 0\n            while stack:\n                cur = stack.pop()\n                for dis in edges[cur]:\n                    if dis not in groups:\n                        stack.append(dis)\n                        groups[dis] = groups[cur] ^ 1     \n                    elif groups[dis] == groups[cur]:\n                        return False\n        return True\n                       \n                    \n                     \n                \n                \n                \n                \n", "from collections import deque\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = {i:[] for i in range(1,N+1)}\n        for a,b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n        self.is_possible = True\n        self.visited = [0]*(N+1)\n        self.color = [0]*(N+1)\n        for i in range(1,N+1):\n            if not self.visited[i]:\n                self.color[i] = 1\n                self.traverse(graph, i)\n        return self.is_possible\n    \n    def traverse(self, graph, node):\n        queue = deque([node])\n        while queue:\n            node = queue.popleft()\n            self.visited[node] = 1\n            color = self.color[node]\n            for neigh in graph[node]:\n                if color == self.color[neigh]:\n                    self.is_possible = False\n                    return\n                if not self.visited[neigh] and not neigh in queue:\n                    self.color[neigh] = -color\n                    queue.append(neigh)\n", "class Solution:\n    # Essentially check whether the graph is bipartitable and dislikes indicate the edges.\n    # Build the adjacent graph first.\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adjacents = collections.defaultdict(list)\n        for a, b in dislikes:\n            adjacents[a].append(b)\n            adjacents[b].append(a)\n        # bipartite check\n        colored = {}\n        for i in range(N):\n            if i not in colored:\n                colored[i] = 0\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for neighbor in adjacents[node]:\n                        if neighbor not in colored:\n                            colored[neighbor] = 1 - colored[node]\n                            stack.append(neighbor)\n                        if colored[neighbor] == colored[node]:  # conflict color\n                            return False\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        color = [-1 for _ in range(N + 1)]\n        g = collections.defaultdict(set)\n        for a, b in dislikes:\n            g[a].add(b)\n            g[b].add(a)\n        visited = set()\n        for i in range(1, N + 1):\n            if i not in visited:\n                q = collections.deque()\n                q.append(i)\n                visited.add(i)\n                color[i] = 0\n                while q:\n                    size = len(q)\n                    while size > 0:\n                        node = q.popleft()\n                        for nei in g[node]:\n                            if nei not in visited:\n                                q.append(nei)\n                                visited.add(nei)\n                                color[nei] = 1 - color[node]\n                            else:\n                                if color[nei] != 1 - color[node]:\n                                    return False\n                        size -= 1\n        return len(set(color)) == 3", "# 886. Possible Bipartition\n\nimport collections\nclass Solution:\n    \n    def __init__(self):\n        self.colors = []\n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        not_colored = 2\n        self.colors = [not_colored] * (N + 1)\n        \n        graph = collections.defaultdict(list)\n        \n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n            \n        for n in range(1, N): \n            if colors[n] == not_colored and not self.dfs(graph, n, 1):\n                return False\n            \n        return True\n        \n    def dfs(self, graph, vertex, color):\n        self.colors[vertex] = color\n        \n        for u in graph[vertex]:\n            if colors[vertex] == colors[u]:\n                return False\n            if colors[u] == 2 and not self.dfs(graph, u, not color):\n                return False\n        \n        return True\n    \n    \n\\\"\\\"\\\"\n    1st approach: BFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    780 ms, faster than 28.52%\n\\\"\\\"\\\"\n\n\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n\n        connections = collections.defaultdict(list)\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, start, seen):\n        q = [(start, 1)]\n        while len(q) > 0:\n            pop, color = q.pop(0)\n            if pop in seen:\n                if seen[pop] != color:\n                    return False\n                continue\n            seen[pop] = color\n            vertices = connections[pop]\n            for v in vertices:\n                q.append((v, -color))\n        return True\n\n\n\\\"\\\"\\\"\n    2nd approach: recursive DFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    660 ms, faster than 53.79%\n\\\"\\\"\\\"\n\n\nclass Solution2(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, 1, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, node, color, seen):\n        if node in seen:\n            if seen[node] != color:\n                return False\n            return True\n        seen[node] = color\n        vertices = connections[node]\n        for v in vertices:\n            if self.check(connections, v, -color, seen) == False:\n                return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adjL = defaultdict(list)\n        for u, v in dislikes:\n            adjL[u].append(v)\n            adjL[v].append(u)\n        \n        memo = [-1]*(N+1) #-1: not seen, 0: group 1, 1: group 2\n        def df(src, shouldBe):\n            if memo[src]!=-1:\n                return memo[src]==shouldBe\n            memo[src] = shouldBe\n            for dst in adjL[src]:\n                if not df(dst, shouldBe^1):\n                    return False\n            return True\n        \n        for i in range(1, N+1):\n            if memo[i]==-1 and not df(i, 0):\n                return False\n        return True\n        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        graph = {i : [] for i in range(1, N + 1)}\n        \n        for dislike in dislikes:\n            u, v = dislike\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = collections.defaultdict(int)\n        queue = collections.deque([])\n        color = 0\n        for i in range(1, N + 1):\n            if i not in visited:\n                queue.append(i)\n                visited[i] = 0\n            while queue:\n                node = queue.popleft()\n                clr = visited[node]\n                for nei in graph[node]:\n                    if nei not in visited:\n                        visited[nei] = ~clr\n                        queue.append(nei)\n                    else:\n                        if visited[nei] == clr:\n                            return False\n        return True\n                        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        x={i:[] for i in range(1,N+1)}\n        for i,j in dislikes:\n            x[i].append(j)\n            x[j].append(i)\n        colour=[-1]*N\n        for i in range(1,N+1):\n            if colour[i-1]==-1:\n                colour[i-1]=0\n                q=[i]\n                while q:\n                    node=q.pop(0)\n                    for j in x[node]:\n                        if colour[node-1]==colour[j-1]:\n                            return False\n                        if colour[j-1]==-1:\n                            colour[j-1]=colour[node-1]^1\n                            q.append(j)\n        return True", "import collections\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # build graph\n        graph = collections.defaultdict(list)\n        for fr, to in dislikes:\n            graph[fr].append(to)\n            graph[to].append(fr)\n\n        group = collections.defaultdict(bool) # true group and false group\n        curr_group = True\n        for i in range(1, N+1):\n            if i not in group:\n                q = collections.deque([i])\n                group[i] = curr_group\n                while q:\n                    for _ in range(len(q)):\n                        node = q.popleft()\n                        # look at neighbors\n                        for nei in graph[node]:\n                            if nei in group and group[nei] == curr_group:\n                                return False\n                            elif nei not in group:\n                                q.append(nei)\n                                group[nei] = not curr_group\n                    curr_group = not curr_group\n        return True\n", "# 886. Possible Bipartition\n\nclass Solution1:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        g = collections.defaultdict(list)\n        for u, v in dislikes:\n            g[u].append(v)\n            g[v].append(u)\n            \n        color = {}\n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c^1) for nei in g[node])\n        \n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)\n    \n    \n\\\"\\\"\\\"\n    1st approach: BFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    780 ms, faster than 28.52%\n\\\"\\\"\\\"\n\n\nclass Solution2(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, start, seen):\n        q = [(start, 1)]\n        while len(q) > 0:\n            pop, color = q.pop(0)\n            if pop in seen:\n                if seen[pop] != color:\n                    return False\n                continue\n            seen[pop] = color\n            vertices = connections[pop]\n            for v in vertices:\n                q.append((v, -color))\n        return True\n\n\n\\\"\\\"\\\"\n    2nd approach: recursive DFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    660 ms, faster than 53.79%\n\\\"\\\"\\\"\n\n\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, 1, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, node, color, seen):\n        if node in seen:\n            if seen[node] != color:\n                return False\n            return True\n        seen[node] = color\n        vertices = connections[node]\n        for v in vertices:\n            if self.check(connections, v, -color, seen) == False:\n                return False\n        return True", "from queue import Queue\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        self.g = self.build_graph(dislikes)\n        \n        self.visited = set()\n        self.colors = dict()\n        \n        \n        \n        for u in self.g.keys():\n            q = Queue()\n            q.put(u)\n            if u not in self.colors:\n                self.colors[u] = 0\n            \n            while not q.empty():        \n                cur = q.get()\n                self.visited.add(cur)\n                \n                for v in self.g[cur]:\n                    if v in self.colors and self.colors[v] == self.colors[cur]:\n                        return False\n                    \n                    if v not in self.visited:\n                        self.colors[v] = self.colors[cur] ^ 1\n                        self.visited.add(v)\n                        q.put(v)\n                \n        \n        return True\n    \n            \n        \n    def build_graph(self, dislikes):\n        g = collections.defaultdict(set)\n        \n        for u,v in dislikes:\n            g[u].add(v)\n            g[v].add(u)\n        \n        return g", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = []\n        for person in range(N+1):\n            graph.append([])\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        seen = {}\n        for i in range(1, N+1):\n            if i not in seen:\n                if self.bfs(graph, i, seen) == False:\n                    return False\n        return True\n    \n    def bfs(self, graph, person, seen):\n        q = [(person, 1)]\n        while q:\n            person, color = q.pop(0)\n            if person in seen:\n                if seen[person] != color:\n                    return False\n                continue\n            seen[person] = color\n            vertices = graph[person]\n            for v in vertices:\n                q.append((v, -color))\n        return True", "import collections\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def dfs(curr, current_color):\n            color[curr] = current_color\n            for next in graph[curr]:\n                if color[next] == None:\n                    dfs(next, not current_color)\n                elif color[next] == current_color:\n                    return False\n            return True\n\n        color = [None] * (N + 1)\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        for n in range(1, N + 1):\n            if color[n] == None:\n                if not dfs(n, True):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        colors = [0] * (N + 1)\n        \n        from collections import defaultdict\n        g = defaultdict(set)\n        for dislike in dislikes:\n            g[dislike[0]].add(dislike[1])\n            g[dislike[1]].add(dislike[0])\n            \n        from collections import deque\n        q = deque()\n        \n        for i in range(1, N + 1):\n            if i not in g:\n                colors[i] = 1\n                \n            if colors[i]:\n                continue\n            \n            colors[i] = 1\n            q.append(i)\n            while q:\n                cur = q.popleft()\n                for neighbor in g[cur]:\n                    if colors[neighbor]:\n                        if colors[neighbor] == colors[cur]:\n                            return False\n                        continue\n                    colors[neighbor] = 1 if colors[cur] == -1 else -1\n                    q.append(neighbor)\n                    \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        '''\n        def dfs(curr, curr_color):\n            color[curr] = curr_color\n            for next in graph[curr]:\n                dfs(next, not curr_color)\n        '''\n        \n        curr_color = True\n        graph = collections.defaultdict(list)\n        color = [None]  * (N+1)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        for n in range(1, N+1):\n            if color[n] == None:\n                color[n] = curr_color\n                queue = collections.deque([n])\n                while queue:\n                    for _ in range(len(queue)):\n                        curr = queue.popleft()\n                        for next in graph[curr]:\n                            if color[next] == None:\n                                color[next] = not curr_color\n                                queue.append(next)\n                            elif color[next] == curr_color:\n                                return False\n                    curr_color = not curr_color\n        return True", "class Solution:\n    def possibleBipartition(self, N, dislikes):\n        NOT_COLORED, BLUE, GREEN = 0, 1, -1 # Constant defined for color drawing to person\n        def helper( person_id, color ):\n            color_table[person_id] = color # Draw person_id as color\n            for the_other in dislike_table[ person_id ]: # Draw the_other, with opposite color, in dislike table of current person_id\n                if color_table[the_other] == color: # the_other has the same color of current person_id\n                    return False\n                if color_table[the_other] == NOT_COLORED and (not helper( the_other, -color)):\n                    # Other people can not be colored with two different colors. \n\\t\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\n                    return False\n                    \n            return True\n\\t\\t\n        \n        # each person maintain a list of dislike\n        dislike_table = collections.defaultdict( list )\n        \n        # cell_#0 is dummy just for the convenience of indexing from 1 to N\n        color_table = [ NOT_COLORED for _ in range(N+1) ]\n        \n        for p1, p2 in dislikes:\n            \n            # P1 and P2 dislike each other\n            dislike_table[p1].append( p2 )\n            dislike_table[p2].append( p1 )\n            \n        \n        # Try to draw dislike pair with different colors in DFS\n        for person_id in range(1, N+1):\n            \n            if color_table[person_id] == NOT_COLORED and (not helper( person_id, BLUE)):\n                # Other people can not be colored with two different colors. \n\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\n                return False \n        \n        return True\n", "# from collections import defaultdict\n# class Solution:\n#     def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n#         graph = defaultdict(set)\n        \n#         for relation in dislikes:\n#             graph[relation[0]].add(relation[1])\n#             graph[relation[1]].add(relation[0])\n            \nclass Solution:\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        if len(dislikes) < 3:\n            return True\n        \n        graph = collections.defaultdict(list)\n        color = {}    # -1 means red, 1 blue, 0 no color\n        nodes = set()\n        for x, y in dislikes:\n            graph[x].append(y)\n            graph[y].append(x)\n            nodes.add(x)\n            nodes.add(y)\n                    \n        for node in nodes:\n            if node not in color:\n                color[node] = 1\n                q = collections.deque([node])\n                while q:\n                    cur = q.popleft()\n                    cur_color = color[cur]\n                    for nei in graph[cur]:\n                        if nei not in color:\n                            color[nei] = -cur_color\n                            q.append(nei)\n                        if color[nei] == cur_color:\n                            return False\n                        elif color[nei] == -cur_color:  # visited\n                            continue\n                        #color[nei] = -cur_color\n                        \n        return True\n            \n        \n            \n        \n        ", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes: return True\n        \n        v = collections.defaultdict(int)\n        for a, b in dislikes:\n            v[a] += 1\n            v[b] += 1\n        \n        d = []\n        for a, b in dislikes:\n            if v[a] == 1 and v[b] == 1:\n                continue\n            d.append([a, b])\n            \n        d.sort(key = lambda x:x[0])\n        c1, c2 = set(), set()\n        c1.add(d[0][0])\n        c2.add(d[0][1])\n        for a, b in d[1:]:\n            if (a in c1 and b in c1) or (a in c2 and b in c2):\n                return False\n            if a in c1:\n                c2.add(b)\n            elif a in c2:\n                c1.add(b)\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(lambda: [])\n        for a, b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n        visited = {}\n        def visit(index: int, a: int) -> bool:\n            if a in visited:\n                return (index - visited[a]) % 2 == 0\n            visited[a] = index\n            for b in graph[a]:\n                if not visit(index + 1, b): return False\n            return True\n        for a in range(1, N + 1):\n            if a not in visited and not visit(0, a): return False\n        return True\n    \n    def possibleBipartition1(self, N: int, dislikes: List[List[int]]) -> bool:\n        if len(dislikes) == 0: return True\n        group1 = defaultdict(lambda: 0)\n        group2 = defaultdict(lambda: 0)\n        def bothInGroup(group: set, a: int, b: int) -> bool:\n            return group[a] > 0 and group[b] > 0\n        \n        def helper(group1Person: int, group2Person: int, index: int) -> bool:\n            #print(\\\"helper\\\", index)\n            group1[group1Person] += 1\n            group2[group2Person] += 1\n            #print(list(filter(lambda x: x[1] > 0, group1.items())))\n            #print(list(filter(lambda x: x[1] > 0, group2.items())))\n            if index == len(dislikes): return True\n            a, b = dislikes[index]\n            #print(\\\"loop\\\", index, a, b)\n            if bothInGroup(group1, a, b) or bothInGroup(group2, a, b):\n                group1[group1Person] -= 1\n                group2[group2Person] -= 1\n                return False\n            if group1[a] > 0 or group2[b] > 0:\n                if helper(a, b, index + 1): return True\n            elif group2[a] > 0 or group1[b] > 0:\n                if helper(b, a, index + 1): return True\n            else:\n                if helper(a, b, index + 1): return True\n                if helper(b, a, index + 1): return True\n            group1[group1Person] -= 1\n            group2[group2Person] -= 1\n            return False\n        \n        return helper(dislikes[0][0], dislikes[0][1], 1)", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N, dislikes):\n        graph = defaultdict(set)\n        for u, v in dislikes:\n            graph[u].add(v)\n            graph[v].add(u)\n        color = dict()\n        def dfs(node):\n            for nei in graph[node]:\n                if nei in color:\n                    if color[nei] == color[node]:\n                        return False\n                else:\n                    color[nei] = color[node] ^ 1\n                    if not dfs(nei):\n                        return False\n            return True\n        for node in range(1, N+1):\n            if node not in color:\n                color[node] = 0\n                if not dfs(node):\n                    return False\n        return True\n    \n# class Solution:\n#     def possibleBipartition(self, N, dislikes):\n#         graph = [[] for _ in range(N+1)]\n#         for u, v in dislikes:\n#             graph[u].append(v)\n#             graph[v].append(u)\n#         color = dict()\n#         def dfs(node):\n#             for nei in graph[node]:\n#                 if nei in color:\n#                     if color[nei] == color[node]:\n#                         return False\n#                 else:\n#                     color[nei] = color[node] ^ 1\n#                     if not dfs(nei):\n#                         return False\n#             return True\n#         for node in range(1, N+1):\n#             if node not in color:\n#                 color[node] = 0\n#                 if not dfs(node):\n#                     return False\n#         return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        self.color = {}\n        self.adj = {}\n        for x,y in dislikes:\n            if x not in self.adj:\n                self.adj[x] = []\n            if y not in self.adj:\n                self.adj[y] = []\n            self.adj[x].append(y)\n            self.adj[y].append(x)\n            \n        self.flag = True\n        def visit(x,c):\n            self.color[x] = c\n            if c == 0:\n                n_c = 1\n            else:\n                n_c = 0\n            for y in self.adj[x]:\n                if y not in self.color:\n                    visit(y,n_c)\n                else:\n                    if self.color[y] == c:\n                        self.flag = False\n        for x,y in dislikes:\n            if x not in self.color:\n                visit(x,0)\n            if y not in self.color:\n                visit(y,0)\n        return self.flag\n", "from collections import deque\nclass Solution:\n    \n    def expandColorBFS(self, start, graph, colors):\n        if colors[start] != 0:\n            return True\n        q = deque()\n        q.append(start)\n        colors[start] = -1\n        while q:\n            cur = q.popleft()\n            for neighbour in graph[cur]:\n                if colors[neighbour] == 0:\n                    q.append(neighbour)\n                    colors[neighbour] = -colors[cur]\n                elif colors[cur] == colors[neighbour]:\n                    return False\n        return True\n    \n    def expandColorDFS(self, cur, graph, colors, cur_color):\n        if colors[cur] != -1:\n            return cur_color == colors[cur]\n        colors[cur] = cur_color\n        neighbour_color = 0 if colors[cur] == 1 else 1\n        for neighbour in graph[cur]:\n            if not self.expandColorDFS(neighbour, graph, colors, neighbour_color):\n                return False\n        return True\n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # -1 unvisited, 0 and 1 are the 2 groups\n        colors = [0 for _ in range(N+1)]\n        graph = defaultdict(set)\n        for dislike in dislikes:\n            graph[dislike[0]].add(dislike[1])\n            graph[dislike[1]].add(dislike[0])\n        \n        for idx in range(1, N+1):\n            if not self.expandColorBFS(idx, graph, colors):\n                return False\n        \n        return True\n        \n        # for each dislike a,b\n        # if we want a's group to differ from b's group\n", "from collections import deque\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]):\n        graph = defaultdict(deque)\n        group = Counter()\n        visited = Counter()\n        for u,v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        for j in range(1,n):\n            if(visited[j]==0):\n                stack = deque([j])\n                while(stack):\n                    ele = stack.pop()\n                    for i in graph[ele]:\n                        if(visited[i]==0):\n                            stack.append(i)\n                            visited[i] = 1\n                            group[i] = 1-group[ele]\n                        else:\n                            if(group[i]!=1-group[ele]):\n                                return False\n        return True", "from collections import deque\nclass Solution:\n    \n    def expandColorBFS(self, start, graph, colors):\n        if colors[start] != -1:\n            return True\n        q = deque()\n        q.append(start)\n        colors[start] = 0\n        while q:\n            cur = q.popleft()\n            for neighbour in graph[cur]:\n                if colors[neighbour] == -1:\n                    q.append(neighbour)\n                    colors[neighbour] = 0 if colors[cur] == 1 else 1\n                elif colors[cur] == colors[neighbour]:\n                    return False\n        return True\n    \n    def expandColorDFS(self, cur, graph, colors, cur_color):\n        if colors[cur] != -1:\n            return cur_color == colors[cur]\n        colors[cur] = cur_color\n        neighbour_color = 0 if colors[cur] == 1 else 1\n        for neighbour in graph[cur]:\n            if not self.expandColorDFS(neighbour, graph, colors, neighbour_color):\n                return False\n        return True\n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # -1 unvisited, 0 and 1 are the 2 groups\n        colors = [-1 for _ in range(N+1)]\n        graph = defaultdict(set)\n        for dislike in dislikes:\n            graph[dislike[0]].add(dislike[1])\n            graph[dislike[1]].add(dislike[0])\n        \n        for idx in range(1, N+1):\n            if colors[idx] == -1:\n                if not self.expandColorDFS(idx, graph, colors, 0):\n                    return False\n        \n        return True\n        \n        # for each dislike a,b\n        # if we want a's group to differ from b's group\n", "class Solution:\n    def possibleBipartition(self, N, dislikes):\n        graph = defaultdict(list)\n        for u,v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)          \n        def dfs(graph, colorGraph, node, color):\n            colorGraph[node] = color\n            for adj in graph[node]:\n                if colorGraph[adj] == color:\n                    return False\n                if colorGraph[adj] == 0:\n                    if not dfs(graph, colorGraph, adj, -color):\n                        return False\n            return True     \n        colorGraph=[0]*(N+1)  \n        for i in range(1,N):\n            if colorGraph[i] == 0:\n                if not dfs(graph, colorGraph, i, 1):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(list)\n        for a, b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        colour = {}\n        def dfs(node, c = 0):\n            if node in colour:\n                return colour[node] == c\n            colour[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n        \n        return all(dfs(node) \n                   for node in range(1, N + 1) \n                   if node not in colour)\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N == 1 or not dislikes:\n            return True\n        \n        g = defaultdict(set)\n        for a, b in dislikes:\n            g[a].add(b)\n            g[b].add(a)\n        \n        color = [-1] * (N + 1)\n        \n        def dfs(i, c):\n            color[i] = c\n            for nxt in g[i]:\n                if color[nxt] != -1 and color[nxt] == c:\n                    return False\n                if color[nxt] == -1 and not dfs(nxt, c ^ 1):\n                    return False\n            return True\n        \n        for i in range(1, N + 1):\n            if color[i] == -1 and not dfs(i, 0):\n                return False\n        \n        return True\n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        groups=defaultdict(list)\n        for a,b in dislikes:\n            groups[a].append(b)\n            groups[b].append(a)\n        \n        colors={}\n        def dfs(node,c=0):\n            if node in colors:\n                return colors[node]==c\n            colors[node]=c\n            return all(dfs(nei,1-c) for nei in groups[node])\n        \n        return all(dfs(node) for node in range(1,N+1) if node not in colors)", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adj=defaultdict(list)\n        for u,v in dislikes:\n            adj[u].append(v)\n            adj[v].append(u)\n        colors={}\n        def dfs(node,color):\n            if node in colors:\n                return colors[node]==color\n            colors[node]=color\n            return all(dfs(u,1-color) for u in adj[node])\n        return all(dfs(u,0) for u in range(1,N+1) if u not in colors )\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        \n        for e in dislikes:\n            u, v = e\n            graph[u].add(v)\n            \n            # TODO map in both directons? I think so\n            graph[v].add(u)\n\n        print(graph)\n\n\n\n        visited = set()\n\n        a = set()\n        b = set()\n\n        for n in range(1, N):\n            queue = deque([n])\n                        \n            while queue:\n                u = queue.popleft()\n\n                if u in visited:\n                    continue\n\n                visited.add(u)\n                \n                if len(graph[u] & a) == 0:\n                    a.add(u)\n                elif len(graph[u] & b) == 0:\n                    b.add(u)\n                else:\n                    return False\n\n                for v in graph[u]:\n                    if v in visited:\n                        continue\n\n                    queue.append(v)\n\n        print(a, b)\n        \n        return True", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        graph = defaultdict(list)\n        \n        for _from, to in dislikes:\n            graph[_from].append(to)\n            graph[to].append(_from)\n            \n        colors = {}\n        \n        for i in range(1,N+1):\n            if i not in colors and i <= len(graph)-1:\n                stack = [(i, True)]\n                \n                while stack:\n                    keys, color = stack.pop()\n                    colors[keys] = color\n                    \n                    for adj in graph[keys]:\n                        if adj in colors:\n                            if colors[adj] == colors[keys]:\n\n                                return False\n                        else:\n                            stack.append((adj, not colors[keys]))\n        return all([colors[i] != all(colors[j] for j in graph[i]) for i in colors if graph[i]!=[]])\n        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        \\\"\\\"\\\"\n          put everyone in an unassigned set\n          pick arbitrary unassigned person put them into arbitrary group\n            DFS walk dislikes links assigning people to correct group, fail if impossible\n\n          return true if we succeed\n\n          extra space: O(N + dislikes.length)\n              O(N)  to store unassigned people\n              O(dislikes.length)  to map people to their dislikes\n              stack with at most O(dislikes.length)\n\n          time: O(N + dislikes.length)\n             O(dislikes.length) walk once to map people to dislikes\n                     handle\n             O(N) each person added to a group once\n             O(dislikes.length) each person's dislikes handled once when they're added to group\np        \\\"\\\"\\\"\n        unassigned = set(range(1, N+1))\n        personal_dislikes = {}\n        def add_dislike(a, b):\n            dis = personal_dislikes.get(a, [])\n            dis.append(b)\n            personal_dislikes[a] = dis\n\n        for [a, b] in dislikes:\n            add_dislike(a, b)\n            add_dislike(b, a)\n\n        # map members to `True` or `False` to represent two groups\n        group = {}\n        while len(unassigned) > 0:\n            person = unassigned.pop()\n            group[person] = True\n            if person not in personal_dislikes:\n                continue\n            stack = [(False, enemy) for enemy in personal_dislikes[person]]\n            while stack:\n                group_choice, p = stack.pop()\n                if p in group:\n                    if group[p] != group_choice:\n                        return False\n                else:\n                    group[p] = group_choice\n                    unassigned.remove(p)\n                    for enemy in personal_dislikes[p]:\n                        stack.append( (not group_choice, enemy) )\n\n        return True\n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes: \n            return True\n        \n        g = defaultdict(list)    \n        for x, y in dislikes:\n            g[x].append(y)\n            g[y].append(x)\n            \n        groups = {}\n        def dfs(curr, i):\n            if curr in groups:\n                return groups[curr] == i\n            \n            groups[curr] = i\n            return all(dfs(nb, not i) for nb in g[curr])\n        \n        return all(dfs(x, groups.get(x, False)) for x, _ in dislikes)", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        G, colors = defaultdict(list), defaultdict(lambda : 0)\n        for u,v in dislikes:\n            G[u].append(v)\n            G[v].append(u)\n        \n        def dfs(u, color):\n            if u in colors:\n                return colors[u] == color\n            colors[u] = color\n            return all((dfs(v, -color) for v in G[u]))\n        \n        \n        return all((dfs(v, 1) for v in range(1, N+1) if v not in colors))\n        \n", "def is_bipartite(graph):\n    n = len(graph)\n    color = [-1] * n\n\n    for start in range(n):\n        if color[start] == -1:\n            color[start] = 0\n            stack = [start]\n\n            while stack:\n                parent = stack.pop()\n\n                for child in graph[parent]:\n                    if color[child] == -1:\n                        color[child] = 1 - color[parent]\n                        stack.append(child)\n                    elif color[parent] == color[child]:\n                        return False\n\n    return True\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[] for _ in range(N)]\n        for u, v in dislikes:\n            u -= 1\n            v -= 1\n            graph[u].append(v)\n            graph[v].append(u)\n        return is_bipartite(graph)", "class Solution:\n    def createGraph(self,N,dislikes):\n        # create undirected graph, edgeList\n        adjList = {}\n        \n        # get base adjList\n        baseSet = set()\n        \n        for vertex in range(1,N+1):\n            adjList[vertex] = set()\n            \n        # remove non valid edges\n        for v,v1 in dislikes:\n            adjList[v].add(v1)\n            adjList[v1].add(v)\n        \n        for i in adjList.keys(): print(i , \\\" \\\" , adjList[i])\n        return adjList\n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adjList = self.createGraph(N,dislikes)\n        \n        def dfs(currentLoc,adjList,colored,color):\n            colored[currentLoc] = color\n            \n            for adj in adjList[currentLoc]:\n                if adj not in colored:\n                    if not dfs(adj,adjList,colored, not color): return False\n                else:\n                    if colored[adj] == color: return False\n                    \n            return True\n                    \n                    \n                \n        colored = {}\n        color = 1\n        for i in range(1,N+1):\n            if i not in colored:\n                if not dfs(i,adjList,colored,color): return False\n        return True\n        \n            \n            \n            \n            \n            \n            \n            \n\n        \n        \n        \n        \n            \n        ", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        h=collections.defaultdict(list)\n        if dislikes==[]:\n            return True\n        for i in dislikes:\n            h[i[0]].append(i[1])\n            h[i[1]].append(i[0])\n        k=set()\n        for j in list(h.keys()):\n            if j in k:\n                continue\n            v=set()\n            c=set()\n            q=deque()\n            q.append((j,1))\n            while q:\n                x=q.popleft()\n                if x[0] in v:\n                    if x[0] in c:\n                        if x[1]==1:\n                            continue\n                        else:\n                            return False\n                    else:\n                        if x[1]==2:\n                            continue\n                        else:\n                            return False\n                v.add(x[0])\n                k.add(x[0])\n                if x[1]==1:\n                    c.add(x[0])\n                for i in h[x[0]]:\n                    if x[1]==1:\n                        q.append((i,2))\n                    else:\n                        q.append((i,1))\n        return True\n", "# benchmarking accepted solution\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)", "class Solution:\n    def odd_cycle_exists(self, person_to_disliked_persons, person_visited, person, level):\n        if (person_visited[person]):\n            if (level - 1 != person_visited[person]):\n                return (level - person_visited[person]) % 2\n        else:\n            person_visited[person] = level\n            level += 1\n            \n            \n            for next_person in person_to_disliked_persons[person]:\n                if (self.odd_cycle_exists(person_to_disliked_persons, person_visited, next_person, level)):\n                    return True\n                \n        return False\n    \n    \n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        N += 1\n        person_visited = [0] * N\n        person_to_disliked_persons = [set() for i in range(N)]\n        \n        \n        for dislike in dislikes:\n            person_to_disliked_persons[dislike[0]].add(dislike[1])\n            person_to_disliked_persons[dislike[1]].add(dislike[0])\n            \n            \n        for i in range(1, N):\n            if (person_visited[i] == 0 and self.odd_cycle_exists(person_to_disliked_persons, person_visited, i, 1)):\n                return False\n            \n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if len(dislikes) == 0:\n            return True\n        colors = [None]*N\n        G = {}\n        for edge in dislikes:\n            if edge[0]-1 not in G:\n                G[edge[0]-1] = [edge[1]-1]\n            else:\n                G[edge[0]-1].append(edge[1]-1)\n            if edge[1]-1 not in G:\n                G[edge[1]-1] = [edge[0]-1]\n            else:\n                G[edge[1]-1].append(edge[0]-1)\n        def dfs(node, clr):\n            colors[node] = clr\n            if node not in G:\n                return True\n            for adj in G[node]:\n                if colors[adj] is None:\n                    if not dfs(adj, not clr):\n                        return False\n                elif colors[adj] == clr: \n                    return False\n            return True\n        for i in range(N):\n            if colors[i] is None:\n                if not dfs(i, True):\n                    return False\n        return True\n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n       \n        g = defaultdict(list)    \n        for x, y in dislikes:\n            g[x].append(y)\n            g[y].append(x)\n            \n        groups = {}\n        def dfs(curr, i):\n            if curr in groups:\n                return groups[curr] == i\n            \n            groups[curr] = i\n            return all(dfs(nb, not i) for nb in g[curr])\n        \n        return all(dfs(x, groups.get(x, False)) for x, _ in dislikes)", "class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:        \n        self.graph = [[] for i in range(n)]\n        for u, v in dislikes:\n            self.graph[u-1].append(v-1)\n            self.graph[v-1].append(u-1)\n        \n        self.groups = [None for i in range(n)]\n        \n        for i in range(n):\n            if self.groups[i] == None:\n                if not self.bfs(i):\n                    return False\n                \n        return True\n        \n    \n    def bfs(self, node):\n        queue = [node]\n        self.groups[node] = 0\n        \n        while queue:\n            q = queue.pop(0)\n            for node in self.graph[q]:\n                if self.groups[node] == None:\n                    self.groups[node] = self.groups[q]^1\n                    queue.append(node)\n                elif self.groups[node] == self.groups[q]:\n                    return False\n                    \n        return True", "\nfrom collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(list)\n        for i in range(len(dislikes)):\n            graph[dislikes[i][0]].append(dislikes[i][1])\n            graph[dislikes[i][1]].append(dislikes[i][0])\n            \n            \n        color = {}\n        \n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(n, c^1) for n in graph[node])\n        \n        return all(dfs(x) for x in range(1, N+1) if x not in color)", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        graph = collections.defaultdict(list)\n        for w, v in dislikes:\n            graph[w].append(v)\n            graph[v].append(w)\n        \n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n        \n        for node in range(1, N + 1):\n            if node not in color:\n                if dfs(node) == False:\n                    return False\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def method1(dislikes):\n            class UF:\n                def __init__(self, size):\n                    self.p=list(range(size))\n                    \n                def find(self,x):\n                    if x!=self.p[x]:\n                        self.p[x]=self.find(self.p[x])\n                    return self.p[x]\n                \n                def union(self,x,y):\n                    self.p[self.find(x)]=self.find(y)\n                    \n                def find_all(self):\n                    for i in range(len(self.p)):\n                        self.find(i) \n               \n            if N<2 or not dislikes:\n                return True\n            \n            dislikes=set(map(tuple,dislikes))\n            #print(dislikes)\n            uf=UF(N)\n            for i in range(1,N+1):\n                for j in range(i+1,N+1):\n                    if (i,j) not in dislikes and (j,i) not in dislikes :\n                        #print(i,j)\n                        uf.union(i-1,j-1)\n                    \n            #uf.find_all()\n            #print(uf.p)\n            \n            return len(set(uf.p))==2\n        #return method1(dislikes)\n    \n        def method2():\n            RED=0\n            BLUE=1\n            \n            graph=collections.defaultdict(list)\n            for u,v in dislikes:\n                graph[u].append(v)\n                graph[v].append(u)\n                \n            color={}\n            def dfs(node,c):\n                if node in color:\n                    return color[node]==c\n                color[node]=c\n                c=BLUE if c==RED else RED\n                return all(dfs(nei,c) for nei in graph[node])\n            \n            return all(dfs(node,RED) for node in range(1,N+1) if node not in color)\n        \n        return method2()\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def bfs(i):\n            queue = collections.deque([(i, 0)])\n            color[i] = 0\n            while queue:\n                person, c = queue.pop()\n                for p in graph[person]:\n                    if color[p] == c: return False\n                    if color[p] == -1:\n                        color[p] = 1 - c\n                        queue.appendleft((p, 1 - c))\n            return True\n        \n        graph = {i: [] for i in range(1, N + 1)}\n        color = {i: -1 for i in range(1, N + 1)}\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        for i in range(1, N + 1):\n            if color[i] == -1 and not bfs(i): return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def method1(dislikes):\n            class UF:\n                def __init__(self, size):\n                    self.p=list(range(size))\n                    \n                def find(self,x):\n                    if x!=self.p[x]:\n                        self.p[x]=self.find(self.p[x])\n                    return self.p[x]\n                \n                def union(self,x,y):\n                    self.p[self.find(x)]=self.find(y)\n                    \n                def find_all(self):\n                    for i in range(len(self.p)):\n                        self.find(i) \n               \n            if N<2 or not dislikes:\n                return True\n            \n            dislikes=set(map(tuple,dislikes))\n            #print(dislikes)\n            uf=UF(N)\n            for i in range(1,N+1):\n                for j in range(i+1,N+1):\n                    if (i,j) not in dislikes and (j,i) not in dislikes :\n                        #print(i,j)\n                        uf.union(i-1,j-1)\n                    \n            #uf.find_all()\n            #print(uf.p)\n            \n            return len(set(uf.p))==2\n        #return method1(dislikes)\n    \n        def method2():\n            graph=collections.defaultdict(list)\n            for u,v in dislikes:\n                graph[u].append(v)\n                graph[v].append(u)\n                \n            color={}\n            def dfs(node,c=0):\n                if node in color:\n                    return color[node]==c\n                color[node]=c\n                return all(dfs(nei,c^1) for nei in graph[node])\n            \n            return all(dfs(node) for node in range(1,N+1) if node not in color)\n        \n        return method2()\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        #TODO\n        # every connected component must be bipartite\n        if len(dislikes) == 0:\n            return True\n        graph = {}\n        for d in dislikes:\n            graph[d[0]] = graph.get(d[0], [])\n            graph[d[1]] = graph.get(d[1], [])\n            graph[d[0]].append(d[1])\n            graph[d[1]].append(d[0])\n        colors = {}\n    \n        # DFS\n        def dfs(node, c=0):\n            if node in colors:\n                return colors[node] == c\n            \n            colors[node] = c\n            nc = c ^ 1\n            if graph.get(node):\n                return all(dfs(neigh, nc) for neigh in graph[node])\n            return True\n        \n        return all(dfs(i, 0) for i in range(1, N+1) if i not in colors)\n            \n        \n        # BFS\n        '''visited_set = set()\n        for i in range(1, N+1):\n            if i in visited_set:\n                continue\n            colors[i] = 0\n            nodes = [i]\n            visited_set.add(i)\n            while True:\n                # at node i\n                new_nodes = []\n                for node in nodes:\n                    neighbors = graph.get(node)\n                    if neighbors is None:\n                        continue\n                    c = colors[node]\n                    nc = c ^ 1\n                    for j in neighbors:\n                        if j not in colors:\n                            colors[j] = nc\n                            new_nodes.append(j)\n                            visited_set.add(j)\n                            continue\n                        if colors[j] != nc:\n                            return False\n                nodes = new_nodes\n                if len(nodes) == 0:\n                    break\n        \n        return True'''", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adj_list = [[] for i in range(N)]\n        for a,b in dislikes:\n            adj_list[a-1].append(b-1)\n            adj_list[b-1].append(a-1)\n        \n        # 0=>uncolored, 1=>first color, 2=>second color\n        colors = [0 for i in range(N)]\n        \n        for i in range(N):\n            if colors[i] != 0:\n                continue\n                \n            # new disconnected graph\n            q = [i]\n            exp_color = 1\n            while len(q) > 0:\n                k = len(q)\n                for j in range(k):\n                    node = q.pop(0)\n                    if colors[node] != 0 and colors[node] != exp_color:\n                        return False\n                    if colors[node] == exp_color:\n                        continue\n                    colors[node] = exp_color\n                    for x in adj_list[node]:\n                        q.append(x)\n                        \n                exp_color = 3-exp_color\n                \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        c=[-1 for i in range(N)]\n        if(len(dislikes)==0):\n            return True\n        dislikes.sort()\n        el=[[] for i in range(N)]\n        for i in dislikes:\n            el[i[0]-1].append(i[1]-1)\n            el[i[1]-1].append(i[0]-1)\n        x=dislikes[0][0]\n        vis=[i for i in range(N)]\n        vis.remove(x)\n        c[x]=0\n        d=[x]\n        while(d!=[]):\n            f=[]\n            for i in d:\n                for j in el[i]:\n                    if(c[j]==-1):\n                        vis.remove(j)\n                        c[j]=1-c[i]\n                        f.append(j)\n                    elif(c[j]!=1-c[i]):\n                        return False\n                    else:\n                        continue\n            d=f\n            if(d==[])and(len(vis)!=0):\n                d=[vis.pop()]\n                c[d[0]]=0\n        return True\n                    \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = collections.defaultdict(list)\n        \n        \n        for a,b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n            \n        color = {}\n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            \n            color[node] = c\n            \n            return all(dfs(n, c^1) for n in graph[node])\n        \n        return all(dfs(n) for n in range(1, N+1) if n not in color)", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = collections.defaultdict(set)\n\n        for x, y in dislikes:\n            graph[x].add(y)\n            graph[y].add(x)\n            \n        color = {}\n        def dfs(x, c = 0):\n            if x in color:\n                return color[x] == c\n            color[x] = c\n            return all(dfs(nei, c^1) for nei in graph[x])\n            \n        return all(dfs(x) for x in range(1, N+1) if x not in color)\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        colour = [None]*(N+1)\n        graph = [[] for i in range(N+1)]\n        \n        for v,u in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node,col):\n            nonlocal colour\n            nonlocal graph\n            if not colour[node] :\n                colour[node] = col\n            elif colour[node] == col:\n                return True\n            else:\n                return False\n            for i in graph[node]:\n                if not dfs(i,(col+1)%2):\n                    return False\n            return True\n        for i in range(1,N+1):\n            if not colour[i] and not dfs(i,0):\n                return False\n        return True\n                \n            \n        \n        \n        \n\n                \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        edges = defaultdict(list)\n        for start, end in dislikes:\n            edges[start].append(end)\n            edges[end].append(start)\n        \n        colored = {}\n        \n        for i in range(1, 1+N):\n            if i not in colored:\n                color = 1\n                if not self.get_colors(edges, i, color, colored):\n                    return False\n        return True\n    \n    def get_colors(self, edges, start, color, colored):\n        q = [(start, color)]\n        \n        while len(q)>0:\n            node, col = q.pop(0)\n            \n            if node in colored:\n                if colored[node] != col:\n                    return False\n                continue\n            colored[node] = col\n            new_col = 0 if col==1 else 1\n            for vert in edges[node]:\n                q.append((vert, new_col))\n            \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N < 2:\n          return True\n\n        # We can look at this as a graph problem, where we connect all the \n        # numbers with all the numbers they dislike.\n        #\n        # If we have any cycles of odd length, then we return False\n        #\n        graph = {i: [] for i in range(1, N + 1)}\n        for a,b in dislikes:\n          graph[a].append(b)\n          graph[b].append(a)\n\n        # part table to assign partition to each number\n        part = [None for _ in range(N + 1)]\n        def dfs(i, p):\n          part[i] = p\n          for j in graph[i]:\n            if part[j] == p:\n              return False\n            if part[j] is None and not dfs(j, p ^ 1):\n              return False\n          return True\n\n        for i in graph:\n          if part[i] is None and not dfs(i, 1):\n            return False\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        colors = [''] * N\n        edges = [[] for _ in range(N)]\n        for p1, p2 in dislikes:\n            edges[p1-1].append(p2-1)\n            edges[p2-1].append(p1-1)\n\n        def dfs(i, d):\n            colors[i] = 'r' if d == 0 else 'b'\n            for p in edges[i]:\n                if colors[p] != '':\n                    if colors[p] == 'r' and d == 0: return False\n                    if colors[p] == 'b' and d == 1: return False\n                elif not dfs(p, (d+1)%2): return False\n            return True\n        for i in range(N):\n            if colors[i] == '':\n                if not dfs(i, 0):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        dislike_graph = collections.defaultdict(list)\n        \n        for dislike in dislikes:\n            a, b = dislike[0], dislike[1]\n            dislike_graph[a].append(b)\n            dislike_graph[b].append(a)\n\n        groups = [0]*(N+1)\n        \n        def can_split(cur, group):\n            groups[cur] = group\n\n            for neighbor in dislike_graph[cur]:\n                if groups[neighbor] == group or \\\\\n                (groups[neighbor] == 0 and not can_split(neighbor, -1*group)):\n                    return False\n            \n            return True\n        \n        for i in range(1, N+1):\n            if i not in dislike_graph:\n                continue\n            if groups[i] == 0 and not can_split(i, 1):\n\n                return False\n        \n        return True\n        ", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        #TODO\n        # every connected component must be bipartite\n        if len(dislikes) == 0:\n            return True\n        graph = {}\n        for d in dislikes:\n            graph[d[0]] = graph.get(d[0], [])\n            graph[d[1]] = graph.get(d[1], [])\n            graph[d[0]].append(d[1])\n            graph[d[1]].append(d[0])\n        colors = {}\n        \n        visited_set = set()\n        for i in range(1, N+1):\n            if i in visited_set:\n                continue\n            colors[i] = 0\n            nodes = [i]\n            visited_set.add(i)\n            while True:\n                # at node i\n                new_nodes = []\n                for node in nodes:\n                    neighbors = graph.get(node)\n                    if neighbors is None:\n                        continue\n                    c = colors[node]\n                    nc = c ^ 1\n                    for j in neighbors:\n                        if j not in colors:\n                            colors[j] = nc\n                            new_nodes.append(j)\n                            visited_set.add(j)\n                            continue\n                        if colors[j] != nc:\n                            return False\n                nodes = new_nodes\n                if len(nodes) == 0:\n                    break\n        \n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        Dislike = collections.defaultdict(list)\n        for dislike in dislikes:\n            Dislike[dislike[0]-1].append(dislike[1]-1)\n            Dislike[dislike[1]-1].append(dislike[0]-1)\n        color = [-1 for i in range(N)]\n        while -1 in color:\n            uncolored = color.index(-1)\n            q = collections.deque([uncolored])\n            while q:\n                i = q.popleft()\n                if color[i] == -1:\n                    color[i] = 0\n                for d in Dislike[i]:\n                    if color[d] == -1:\n                        q.append(d)\n                        color[d] = color[i] ^ 1\n                    elif color[d] == color[i]:\n                        return False\n        return True", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for pair in dislikes:\n            graph[pair[0]].add(pair[1])\n            graph[pair[1]].add(pair[0])\n        colors = [0] * ((N) + 1)\n        \n        visited = set()\n        def check(i):\n            stack = [i]\n            colors[i] = -1\n            while stack:\n                popped = stack.pop()\n                color = colors[popped]\n                visited.add(popped)\n                for enemy in graph[popped]:\n                    if colors[enemy] == color:\n                        return False\n                    colors[enemy] = -color\n                    if enemy not in visited:\n                        stack.append(enemy)\n            return True\n        for i in range(1, N+1):\n            if i in visited:\n                continue\n            if not check(i):\n                return False\n        return True\n        \n        \n                \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if(not dislikes):\n            return True\n        from random import sample\n        adjmat={}\n        for a,b in dislikes:\n            adjmat[a]=adjmat.get(a,[])+[b]\n            adjmat[b]=adjmat.get(b,[])+[a]\n        color={i:-1 for i in range(1,N+1)}\n        unvisited={i for i in range(1,N+1)}\n        result=True\n        while(unvisited and result):\n            queue=[sample(unvisited,k=1)[0]]\n            color[queue[0]]=1\n            while(queue and result):\n                curr=queue.pop()\n                unvisited.discard(curr)\n                currcolor=color[curr]\n                adjcolor=0\n                if(currcolor==0):\n                    adjcolor=1\n                if(adjmat.get(curr,0)==0):\n                    continue\n                for i in adjmat[curr]:\n                    if i in unvisited:\n                        queue.append(i)\n                    if(color[i]==-1):\n                        color[i]=adjcolor\n                    elif(color[i]==currcolor):\n                        result=False\n                        break\n        return result\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        relations = [None] * N\n        for x in range(len(relations)):\n            relations[x] = []\n        \n        for x in dislikes:\n            a = min(x) -1\n            b = max(x) -1\n            relations[a].append(b)\n            relations[b].append(a)\n            \n        # print(relations)\n            \n        colors = [0] * (N)\n        for i,v in enumerate(relations):\n            q = []\n            if colors[i] == 0: q.append((i, 1))\n            while q:\n                (curr, selectedColor) = q.pop(0)\n                if colors[curr] != 0:\n                    if colors[curr] != selectedColor: return False\n                    continue\n                colors[curr] = selectedColor\n                for n in relations[curr]:\n                    q.append((n, -selectedColor))\n        return True\n                    \n                \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[] for _ in range(N)]\n        for pair in dislikes:\n            graph[pair[0]-1].append(pair[1]-1)\n            graph[pair[1]-1].append(pair[0]-1)\n          \n        visited = {}\n        def dfs(node, color):\n            nonlocal visited\n            visited[node] = color\n            \n            for child in graph[node]:\n                if not child in visited:\n                    if not dfs(child, not color):\n                        return False\n                else:\n                    if visited[child] == color:\n                        return False\n            return True\n        for i in range(N):\n            if not i in visited:\n                if not dfs(i, False):\n                    return False\n        return True\n                        \n            \n            \n", "class Solution1:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        g = collections.defaultdict(list)\n        for u, v in dislikes:\n            g[u].append(v)\n            g[v].append(u)\n            \n        color = {}\n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c^1) for nei in g[node])\n        \n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)\n    \n    \n\\\"\\\"\\\"\n    1st approach: BFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    780 ms, faster than 28.52%\n\\\"\\\"\\\"\n\n\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, start, seen):\n        q = [(start, 1)]\n        while len(q) > 0:\n            pop, color = q.pop(0)\n            if pop in seen:\n                if seen[pop] != color:\n                    return False\n                continue\n            seen[pop] = color\n            vertices = connections[pop]\n            for v in vertices:\n                q.append((v, -color))\n        return True\n\n\n\\\"\\\"\\\"\n    2nd approach: recursive DFS + nodes coloring\n\n    Time    O(V+E)\n    Space   O(V+E)\n    660 ms, faster than 53.79%\n\\\"\\\"\\\"\n\n\nclass Solution2(object):\n    def possibleBipartition(self, N, dislikes):\n        \\\"\\\"\\\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \\\"\\\"\\\"\n        connections = []\n        for _ in range(N+1):\n            connections.append([])\n\n        for a, b in dislikes:\n            connections[a].append(b)\n            connections[b].append(a)\n\n        seen = {}\n        for i in range(len(connections)):\n            if i not in seen:\n                if self.check(connections, i, 1, seen) == False:\n                    return False\n        return True\n\n    def check(self, connections, node, color, seen):\n        if node in seen:\n            if seen[node] != color:\n                return False\n            return True\n        seen[node] = color\n        vertices = connections[node]\n        for v in vertices:\n            if self.check(connections, v, -color, seen) == False:\n                return False\n        return True", "class Solution:\n    def search(self, graph, key, visited):\n        stateList = [[key, 1]]\n        while stateList:\n            index, color = stateList.pop(0)\n            if index in visited:\n                if visited[index] != color:\n                    return False\n                continue\n            visited[index] = color\n            links = graph[index]\n            for link in links:\n                stateList.append([link, -color])\n        return True\n            \n    def generateGraph(self, dislikes):\n        graph = {}\n        for a, b in dislikes:\n            if a not in graph:\n                graph[a] = []\n            if b not in graph:\n                graph[b] = []\n            graph[a].append(b)\n            graph[b].append(a)\n        return graph\n    \n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = self.generateGraph(dislikes)\n        \n        visited = {}\n        for key in graph:\n            if key not in visited:\n                if not self.search(graph, key, visited):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        \n        for i,j in dislikes:\n            g[i-1].append(j-1)\n            g[j-1].append(i-1)\n            \n        color = [-1]*N\n        \n        for i in range(N):\n            if color[i] == -1:\n                color[i] = 0\n                queue = [i]\n                \n            while queue:\n                u = queue.pop(0)\n                \n                for j in g[u]:\n                    \n                    if color[j] == color[u]:\n                        return False\n                    \n                    if color[j] == -1:\n                        queue.append(j)\n                        color[j] = 1-color[u]\n                        \n        return True\n                \n        \n        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        d={}\n        for a,b in dislikes:\n            if a not in d:\n                d[a]=[]\n            d[a].append(b)\n            if b not in d:\n                d[b]=[]\n            d[b].append(a)\n\n        vals=[-1]*(N+1)\n        for i in range(1,N+1):\n            if vals[i]!=-1:\n                continue\n            vals[i]=0\n            queue=[i]\n            while(queue):\n                temp=[]\n                for e in queue:\n                    for child in d.get(e,[]):\n                        if vals[e]==vals[child]:\n                            return False\n                        if vals[child]==-1:\n                            vals[child]=1-vals[e]\n                            temp.append(child)\n                queue=temp\n        return True\n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        pref = defaultdict(set)\n        for dis in dislikes:\n            a,b = dis\n            pref[a].add(b)\n            pref[b].add(a)\n        \n        to_visit = set(range(1,N+1))\n        \n        while to_visit:\n            cur = to_visit.pop()\n            \n            if cur not in pref:\n                pass\n            else:\n                \n                r1 = set([cur])\n                r2 = pref[cur]\n                #to_visit = to_visit.difference(r2)\n                L1 = r2.copy()\n                L2 = set()\n                \n                while L1:\n                    #print(r1,r2,to_visit,L1)\n                    for l in L1:\n                        to_visit.remove(l)\n                        L = pref[l]\n                        if l in r1:\n                            if L.intersection(r1):\n                                return False\n                            else:\n                                r2 = r2.union(L)\n                        if l in r2:\n                            if L.intersection(r2):\n                                return False\n                            else:\n                                r1 = r1.union(L)\n                        L2 = L2.union(L)\n                    L2 = L2.intersection(to_visit)\n                    L1 = L2\n                    L2 = set()\n                #print(r1,r2)\n        return True\n\n", "import collections\n\nclass Solution:\n    def possibleBipartition(self, N, dislikes):\n        NOT_COLORED, BLUE, GREEN = 0, 1, -1 # Constant defined for color drawing to person\n        def helper( person_id, color ):\n            color_table[person_id] = color # Draw person_id as color\n            for the_other in dislike_table[ person_id ]: # Draw the_other, with opposite color, in dislike table of current person_id\n                if color_table[the_other] == color: # the_other has the same color of current person_id\n                    return False\n                if color_table[the_other] == NOT_COLORED and (not helper( the_other, -color)):\n                    # Other people can not be colored with two different colors. \n\\t\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\n                    return False\n            return True\n\n        dislike_table = collections.defaultdict( list )\n        \n        # cell_#0 is dummy just for the convenience of indexing from 1 to N\n        color_table = [ NOT_COLORED for _ in range(N+1) ]\n        \n        for p1, p2 in dislikes:\n            \n            # P1 and P2 dislike each other\n            dislike_table[p1].append( p2 )\n            dislike_table[p2].append( p1 )\n            \n        \n        # Try to draw dislike pair with different colors in DFS\n        for person_id in range(1, N+1):\n            \n            if color_table[person_id] == NOT_COLORED and (not helper( person_id, BLUE)):\n                # Other people can not be colored with two different colors. \n\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\n                return False \n        \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def dfs(s):\n            nonlocal doable\n            visited[s] = 1\n            for w in adjlist[s]:\n                if visited[w] == -1:\n                    visited[w] = 1\n                    parent[w] = s\n                    color[w] = 1 - color[s]\n                    dfs(w)\n                else:\n                    if w != parent[s]:\n                        # Odd-length cycles in graph are not amicable, but even-length cycles are ok.\n                        # In dfs, back-edge having same color is sign of impossible \n                        # In BFS cross-edge across consecutive levels is ok, but not on the same level.\n                        # The distance[] helps to decide this\n                        if color[w] == color[s]:\n                            doable = False\n        n = N \n        doable = True\n        visited = {x:-1 for x in range(1,n+1)}\n        parent = {x:None for x in range(n)}\n        # adjlist = {x:[] for x in range(1,n+1)}\n        adjlist = {x:set() for x in range(1,n+1)}\n        for dislike in dislikes:\n            [s,d] = dislike\n            # adjacency-list implementation\n            # adjlist[d].append(s)\n            # adjlist[s].append(d)\n            # adjacency-map implementation \n            # https://algocoding.wordpress.com/2014/08/24/adjacency-list-representation-of-a-graph-python-java/\n            adjlist[d].add(s)\n            adjlist[s].add(d)\n            # adjlist[d].setdefault(s,2)\n            # adjlist[s].setdefault(d,1)\n        color = {x:0 for x in range(n)}\n        print(\\\"adjlist is {}\\\".format(adjlist))\n        for i in range(1,n):\n            if visited[i] == -1:\n                dfs(i)\n        return doable\n        \n                        \n                    ", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [list() for i in range(N)] \n        for dislike in dislikes:\n            x = dislike[0]\n            y = dislike[1]\n            graph[x-1].append(y-1)\n            graph[y-1].append(x - 1)\n        #print(graph)\n        \n        \n        parent = list(range(N))\n        def find(p):\n            if p!=parent[p]:\n                parent[p] = find(parent[p])\n            return parent[p]\n        \n        def union(p,q):\n            pr = find(p)\n            qr = find(q)\n            if pr!=qr:\n                parent[pr] = qr\n            return \n        \n        for i in range(N):\n            if not graph[i]:\n                continue\n            x = find(i)\n            y = find(graph[i][0])\n            if x == y:\n                return False\n            for j in range(1,len(graph[i])):\n                z = find(graph[i][j])\n                if z == x:\n                    return False\n                union(y, z)\n        \n        return True\n", "class Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)\n                       \n\n            \n\n        \n        \n        \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        edges = {ii: [] for ii in range(1, N + 1)}\n        for ii, jj in dislikes:\n            edges[ii].append(jj)\n            edges[jj].append(ii)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all([dfs(ii, c ^ 1) for ii in edges[node]])\n        return all([dfs(ii) for ii in range(1, N + 1) if ii not in color])\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # Solution taken from leetcode solution\n        # Insight: I was thinking about the fact that we need to test whether\n        # 1 or the other color works for every unvisited node. But, since the\n        # graph is an undirected graph, there cannot be an unvisited node that\n        # is connected to a visited node once the dfs ends for a connected\n        # component\n        \n        # Process edges into adjacency list\n        self.g = collections.defaultdict(list)\n        for num1, num2 in dislikes:\n            self.g[num1].append(num2)\n            self.g[num2].append(num1)\n            \n            \n        self.color = {}\n        def dfs(node, c):\n            if node in self.color:\n                return self.color[node] == c\n            else:\n                self.color[node] = c\n                for dest in self.g[node]:\n                    # `1-c` to swap between 0 and 1\n                    res = dfs(dest, 1-c)\n                    if not res:\n                        return False\n            return True\n        \n        for node in self.g:\n            if node not in self.color:\n                res = dfs(node, 0)\n                if not res:\n                    return False\n                \n        return True\n", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, n, dislikes):\n        self.visited = {}\n        self.graph = defaultdict(list)\n        for p1, p2 in dislikes:\n            self.graph[p1].append(p2)\n            self.graph[p2].append(p1)\n        for personId in range(len(self.graph)):\n            if personId not in self.visited:\n                if not self.dfs(personId, 1): #color the personId 1\n                    return False\n        return True\n        \n    def dfs(self, personId, color): #color personId as color. all its dislikers as opposite color. return true if possible. false otherwise\n        if personId in self.visited:\n            return self.visited[personId]==color\n\n        self.visited[personId] = color\n        for neighbor in self.graph[personId]:            \n            if not self.dfs(neighbor, -color): #color the neighbor -1*color. opposite to personId\n                return False\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N <= 1:\n            return True\n        \n        def paint(node, color):\n            if colors[node] != -1:\n                return colors[node] != color\n            \n            colors[node] = color\n            \n            for adj_node in g[node]:\n                if paint(adj_node, (color + 1) % 2):\n                    return True\n                \n            return False\n        \n        \n        g = collections.defaultdict(list)\n        \n        for a, b in dislikes:\n            g[a].append(b)\n            g[b].append(a)\n            \n        colors = dict.fromkeys(g, -1)\n            \n        for n in g:\n            if colors[n] == -1:\n                if paint(n, 0):\n                    return False\n                \n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N <= 1:\n            return True\n        \n        def paint(node, color):\n            if colors[node] is not None:\n                return colors[node] != color\n            \n            colors[node] = color\n            \n            new_color = not color\n            \n            for adj_node in g[node]:\n                if paint(adj_node, new_color):\n                    return True\n                \n            return False\n        \n        \n        g = collections.defaultdict(list)\n        \n        for a, b in dislikes:\n            g[a].append(b)\n            g[b].append(a)\n            \n        colors = dict.fromkeys(g, None)\n            \n        for n in g:\n            if colors[n] is None:\n                if paint(n, False):\n                    return False\n                \n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        g = collections.defaultdict(list)\n        for u, v in dislikes:\n            g[u].append(v)\n            g[v].append(u)\n        \n        parent = [i for i in range(N+1)]\n        def find(n):\n            if n == parent[n]:\n                return n\n            parent[n] = find(parent[n])\n            return parent[n]\n        def union(n1, n2):\n            r1, r2 = find(n1), find(n2)\n            if r1 != r2:\n                parent[r1] = r2\n        \n        for k in g:\n            for node in g[k]:\n                if find(k) == find(node):\n                    return False\n                union(g[k][0], node)\n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def bfs(n):\n            q = [(n, 1)]\n            while q:\n                x, color = q.pop()\n                state[x] = color\n                for i in graph[x]:\n                    if state[i] == 0: \n                        q.append((i, -color))\n                    if state[i] == color: return False\n            return True\n        \n        # build graph\n        graph = [set() for _ in range(N+1)]\n        for a,b in dislikes: \n            graph[a-1].add(b-1)\n            graph[b-1].add(a-1)\n        \n        state = [0]*N\n        for i in range(N):  \n            if state[i] != 0: continue\n            if not bfs(i): \n                return False        \n        return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if len(dislikes) == 0:\n            return True\n        \n        nodeMap = {}\n        \n        for a, b in dislikes:\n            if a not in nodeMap:\n                nodeMap[a] = Node(a)\n            \n            if b not in nodeMap:\n                nodeMap[b] = Node(b)\n            \n            nodeMap[a].connections.append(nodeMap[b])\n            nodeMap[b].connections.append(nodeMap[a])\n        \n        visited = set()\n        colored = {}\n        \n        def dfs(queue: List[Node]) -> bool:\n            if len(queue) == 0:\n                return True\n            \n            node = queue.pop()\n            #print(node)\n            \n            if node in visited:\n                return dfs(queue)\n            \n            visited.add(node)\n            \n            color = 1\n            if node in colored:\n                color = colored[node]\n            \n            for connect in node.connections:\n                if connect in colored:\n                    if colored[connect] == color:\n                        return False\n                else:\n                    colored[connect] = 1 - color\n                \n                if connect not in visited:\n                    queue.append(connect)\n            return dfs(queue)\n        \n        for key,val in list(nodeMap.items()):\n            #print(val)\n            if val in visited:\n                continue\n            else:\n                res = dfs([val])\n                if not res:\n                    return False\n        return True\n            \nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.connections = []\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def bfsColoring(g, src, colors):\n            queue = [src]\n            colors[src] = 0\n            \n            while queue:\n                u = queue.pop(0)\n                for v in g[u]:\n                    if colors[v] != -1 and colors[v] != 1-colors[u]:\n                        return False\n                    elif colors[v] == -1:\n                        colors[v] = 1-colors[u]\n                        queue.append(v)\n            print(colors)\n            return True\n            \n        \n        g = collections.defaultdict(set)\n        \n        for dis in dislikes:\n            g[dis[0]].add(dis[1])\n            g[dis[1]].add(dis[0])\n            \n        colors = [-1 for _ in range(N+1)]\n        for i in range(1, N+1):\n            if colors[i] == -1:\n                if not bfsColoring(g, i, colors):\n                    return False\n        print(colors)\n        if -1 in set(colors[1:]):\n            return False\n        return True\n\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[] for i in range(N)]\n        for dislike in dislikes:\n            graph[dislike[0]-1].append(dislike[1]-1)\n            graph[dislike[1]-1].append(dislike[0]-1)\n        \n        visited = [False for i in range(N)]\n        groups = [set([]), set([])]\n        def dfs(root, group):\n            groups[group].add(root)\n            visited[root] = True\n            for d in graph[root]:\n                if d in groups[group]:\n                    return False\n                if not visited[d] and not dfs(d, 1 - group):\n                    return False\n            return True\n        \n        for i in range(N):\n            if not visited[i] and not dfs(i, 0):\n                return False\n        return True\n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(list)\n        for u,v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)          \n        def dfs(graph, color, node, col):\n            color[node] = col\n            for neigh in graph[node]:\n                if color[neigh] == col:\n                    return False\n                if color[neigh] == 0:\n                    if not dfs(graph, color, neigh, -col):\n                        return False\n            return True     \n        color = [0] * (N+1)  \n        for i in range(1,N):\n            if color[i] == 0:\n                if not dfs(graph, color, i, 1):\n                    return False\n        return True", "import queue\n\ndef bfs_step(queue, colors, graph, queued):\n    node = queue.get()\n    color1 = colors[node]\n    for edge in graph[node]:\n        if colors[edge] == -1:\n            colors[edge] = 1 - color1\n        if colors[edge] == color1:\n            return False\n        if not queued[edge]:\n            queue.put(edge)\n            queued[edge] = 1\n    return True\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        q = queue.SimpleQueue()\n        colors = [-1 for i in range(N+1)]\n        graph = [[] for i in range(N+1)]\n        queued = [0 for i in range(N+1)]\n        for edge in dislikes:\n            i, j = edge\n            graph[i].append(j)\n            graph[j].append(i)\n        for i in range(N):\n            if colors[i] != -1:\n                continue\n            colors[i] = 1\n            if not queued[i]:\n                q.put(i)\n                queued[i] = 1\n            while not q.empty():\n                if not bfs_step(q, colors, graph, queued):\n                    return False\n        return True\n                \n                \n            \n        \n            \n", "class Solution:\n  def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n    # build graph\n    graph = collections.defaultdict(list)\n    for f, to in dislikes:\n      graph[f].append(to)\n      graph[to].append(f)\n      \n    group = collections.defaultdict(bool) # true group and false group\n    curr_group = True\n    for i in range(1, N+1):\n      if i not in group:\n        q = collections.deque([i])\n        group[i] = curr_group\n        while q:\n          for _ in range(len(q)):\n            node = q.popleft()\n            # look at neighbors\n            for nei in graph[node]:\n              if nei in group and group[nei] == curr_group:\n                return False\n              elif nei not in group:\n                q.append(nei)\n                group[nei] = not curr_group\n          curr_group = not curr_group\n    return True\n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[] for _ in range(N+1)]\n        # print(graph)\n        \n        for dislike in dislikes:\n            # if graph[dislike[0]] == None:\n            #     graph[dislike[0]] = []\n            # if graph[dislike[1]] == None:\n            #     graph[dislike[1]] = []\n             \n            graph[dislike[0]].append(dislike[1])\n            graph[dislike[1]].append(dislike[0])\n                \n        \n        \n        \n        color = {}\n        \n        for p in range(N):\n            if p in color:\n                continue\n            color[p] = True\n            \n            stack = [p]\n            while stack:\n                p1 = stack.pop()\n                for p2 in graph[p1]:\n                    if p2 in color:\n                        if color[p2] == color[p1]:\n                            return False\n                    else:\n                        color[p2] = not color[p1]\n                        stack.append(p2)\n                        \n        return True\n                        \n                \n", "class Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n        def dfs(node, c = 0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node)\n                   for node in range(1, N+1)\n                   if node not in color)", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def make_graph(dislikes):\n            graph = defaultdict(list)\n            for dl in dislikes:\n                graph[dl[1]].append(dl[0])\n                graph[dl[0]].append(dl[1])\n            return graph\n        \n        graph = make_graph(dislikes)\n        visited = {}\n        \n#         def dfs(node, c=0):\n#             if node in color:\n#                 return color[node] == c\n#             color[node] = c\n#             return all(dfs(nei, c^1) for nei in graph[node])\n#         return all(dfs(node) for node in range(1, N+1) if node not in color)\n    \n        for i in range(1, N+1):\n            if i in visited:\n                continue\n            visited[i] = 'red'\n            stack = [[i, visited[i]]]\n            \n         \n            while stack:\n                num, pos = stack.pop(0)\n                for next_num in graph[num]:\n                    if next_num in visited:\n                        if visited[next_num] == pos:\n                      \n                            return False\n                    else:\n                        if pos == 'blue': \n                            next_pos = 'red' \n                        else:\n                            next_pos = 'blue' \n                        visited[next_num] = next_pos\n                        stack.append([next_num, next_pos])\n        return True\n                        \n                \n                    \n            \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def dfs(p1, color=1):\n            colors[color].add(p1)\n            for p2 in G[p1]:\n                if p2 in colors[color] or (p2 not in colors[-color] and not dfs(p2, -color)):\n                    return False\n            return True\n        G, colors = [[] for _ in range(N)], {-1: set(), 1: set()}\n        for p1, p2 in dislikes:\n            G[p1-1].append(p2-1)\n            G[p2-1].append(p1-1)\n        for p in range(N):\n            if p not in colors[1] and p not in colors[-1] and not dfs(p):\n                return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def make_graph(dislikes):\n            graph = defaultdict(list)\n            for dl in dislikes:\n                graph[dl[1]].append(dl[0])\n                graph[dl[0]].append(dl[1])\n            return graph\n        \n        graph = make_graph(dislikes)\n        color = {}\n        \n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c^1) for nei in graph[node])\n        return all(dfs(node) for node in range(1, N+1) if node not in color)\n    \n        for i in range(1, N+1):\n            if i in visited:\n                continue\n            visited[i] = 'red'\n            stack = [[i, visited[i]]]\n            \n         \n            while stack:\n                num, pos = stack.pop(0)\n                for next_num in graph[num]:\n                    if next_num in visited:\n                        if visited[next_num] == pos:\n                            print((next_num, num, pos))\n                            return False\n                    else:\n                        if pos == 'blue': \n                            next_pos = 'red' \n                        else:\n                            next_pos = 'blue' \n                        visited[next_num] = next_pos\n                        stack.append([next_num, next_pos])\n        return True\n                        \n                \n                    \n            \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        dislikes.sort()\n        graph = [[] for _ in range(N+1)]\n        \n        disjoint = [None for _ in range(N+1)]\n        \n        for a, b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        self.graph = graph\n        self.disjoint = disjoint\n        \n        for i in range(1, N+1):\n            if not self.dfs(i):\n                return False\n        \n        return True\n    \n    def dfs(self, start, color=None):    \n        if self.disjoint[start] is not None:\n            return color is None or self.disjoint[start] == color\n        \n        color = True if color is None else color\n        self.disjoint[start] = color\n        for other in self.graph[start]:\n            if not self.dfs(other, not color):\n                return False\n        return True\n        \n                \n            \n                \n            \n        \n        \n", "class Solution:\n    def isbi(self,i,color):\n        q=[]\n        q.append(i)\n        color[i]=1\n        while q:\n            curr=q.pop(0)\n            for j in self.graph[curr]:\n                if color[j]==color[curr]:\n                    return False\n                if color[j]==-1:\n                    color[j]=1-color[curr]\n                    q.append(j)\n        return True\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        self.graph=collections.defaultdict(list)\n        for v,u in dislikes:\n            self.graph[v].append(u)\n            self.graph[u].append(v)\n        color=[-1]*(N+1)\n        for i in range(1,N+1):\n            if color[i]==-1:\n                if not self.isbi(i,color):\n                    return False\n        return True", "from collections import defaultdict\nclass Solution:\n    def possibleBipartition(self, N, dislikes):\n        G = defaultdict(set)\n        for u, v in dislikes:\n            G[u].add(v)\n            G[v].add(u)\n        color = dict()\n        def dfs(node, c):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in G[node])\n        return all(dfs(node, 0) for node in range(1, N+1) if node not in color)\n", "\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        # build a graph of it\n        graph = collections.defaultdict(set)\n        for u, v in dislikes: \n            graph[u].add(v)\n            graph[v].add(u)\n        \n        group_map = {}\n        def dfs(node, is_one): \n            if node in group_map: \n                return is_one == group_map[node]\n            else:\n                group_map[node] = is_one\n            return all(dfs(nei, not is_one) for nei in graph[node])\n            \n        return all(dfs(node, True) for node in range(1, N+1) if node not in group_map)\n                            \n                \n                \n                \n                \n            \n            \n            \n        \n            \n            \n            \n            \n            \n                \n            \n                \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        color = {}\n        \n        graph = collections.defaultdict(list)\n        for pair in dislikes:\n            p1, p2 = pair[0], pair[1]\n            graph[p1].append(p2)\n            graph[p2].append(p1)\n        \n        def dfs(node):\n            for nei in graph[node]:\n                if nei in color:\n                    if color[nei] == color[node]:\n                        return False\n                else:\n                    color[nei] = 1 - color[node]\n                    if not dfs(nei):\n                        return False\n            return True\n        \n        for i in range(N):\n            if i not in color:\n                color[i] = 1\n                if not dfs(i):\n                    return False\n        return True\n", "from collections import deque\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        adj = [[] for i in range(N)]\n        \n        for a,b in dislikes:\n            adj[a-1].append(b-1)\n            adj[b-1].append(a-1)\n            \n        color_array = [-1]*N\n        \n        queue = deque()\n        \n        for i in range(N):\n            if color_array[i]==-1:\n                color_array[i] = 1\n                queue.append(i)\n                while queue:\n                    u = queue.popleft()\n                    for i in adj[u]:\n                        if color_array[i]==-1:\n                            color_array[i] = 1-color_array[u]\n                            queue.append(i)\n\n                        else:\n                            if color_array[u]==color_array[i]:\n                                return False\n        return True\n                \n", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        def bfs(i):\n            stack = []\n            color[i] = 0\n            stack.append(i)\n            while stack:\n                cur = stack.pop()\n                for nei in dislike_adj[cur]:\n                    if color[nei] == color[cur]:\n                        return False\n                    if color[nei] == -1 and color[nei] != color[cur]:\n                        stack.append(nei)\n                        color[nei] = 1 - color[cur]\n            return True\n        \n        dislike_adj = collections.defaultdict(list)\n        color = {}\n        for d in dislikes:\n            first = d[0]\n            second = d[1]\n            dislike_adj[first].append(second)\n            dislike_adj[second].append(first)\n        for i in range(1, N+1):\n            color[i] = color.get(i, -1)\n        for i in range(1, N+1):\n            if color[i] == -1:\n                if not bfs(i):\n                    return False\n        return True", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N == 0:\n            return True\n        seen = {}\n        adj = {i: [] for i in range(N+1) }\n        for edge in dislikes: \n            #print('adj  ', adj, 'edge.. ', edge)\n            adj[edge[0]].append(edge[1])\n            adj[edge[1]].append(edge[0])\n\n      \n        def try_marking_all_edges(seen, node, adj, color) -> bool:\n            if node in seen:\n                return seen[node] == color\n            seen[node] = color\n            #print(\\\"try_marking_all_edges()\\\", node, \\\"->\\\", adj[node], \\\" seen \\\", seen)\n            other_group = color ^ 1\n            for a in adj[node]:\n                if not try_marking_all_edges(seen, a, adj, other_group):\n                    return False\n            return True\n    \n        for node in adj:\n            if node not in seen:\n                if not try_marking_all_edges(seen, node, adj, 0):\n                    return False\n            if not try_marking_all_edges(seen, node, adj, seen[node]):\n                return False\n        return True  \n\n            \n            \n    def possibleBipartition3(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N == 0:\n            return True\n        seen = {}\n        adj = {i: [] for i in range(N+1) }\n        for edge in dislikes: \n            ##print('adj  ', adj, 'edge.. ', edge)\n            adj[edge[0]].append(edge[1])\n            adj[edge[1]].append(edge[0])\n            \n        def try_marking_all_edges(seen, node, adj) -> bool:\n            #print(\\\"try_marking_all_edges()\\\", node, \\\"->\\\", adj[node])\n            other_group = 2 if seen[node] == 1 else 1\n            for a in adj[node]:\n                if a not in seen:\n                    seen[a] = other_group\n                    continue\n                if seen[a] != other_group:\n                    return False\n            return True\n     \n        print('adj  ', adj) \n     \n        for edge in dislikes:\n            print(edge, \\\"->\\\", seen)\n            if not edge[0] in seen and not edge[1] in seen:\n                seen[edge[0]] = 1\n                seen[edge[1]] = 2\n            elif edge[0] in seen and not edge[1] in seen:\n                first_group = seen[edge[0]]\n                seen[edge[1]] = 2 if first_group == 1 else 1\n            elif edge[1] in seen and not edge[0] in seen:\n                first_group = seen[edge[1]]\n                seen[edge[0]] = 2 if first_group == 1 else 1\n            else:\n                if seen[edge[0]] == seen[edge[1]]:\n                    return False\n            if not try_marking_all_edges(seen, edge[0], adj): \n                return False\n            if not try_marking_all_edges(seen, edge[1], adj):\n                return False\n            #print(edge, \\\"->>> \\\", seen)   \n\n\n        return True    \n            \n            \n        \n    \n    def possibleBipartition2(self, N: int, dislikes: List[List[int]]) -> bool:\n        if N == 0:\n            return True\n        seen = {}\n        for edge in dislikes: \n            if not edge[0] in seen and not edge[1] in seen:\n                seen[edge[0]] = 1\n                seen[edge[1]] = 2\n            elif edge[0] in seen and not edge[1] in seen:\n                first_group = seen[edge[0]]\n                seen[edge[1]] = 2 if first_group == 1 else 1\n            elif edge[1] in seen and not edge[0] in seen:\n                first_group = seen[edge[1]]\n                seen[edge[0]] = 2 if first_group == 1 else 1\n            else:\n                if seen[edge[0]] == seen[edge[1]]:\n                    return False\n        return True\n                \n            \n        \n        ", "class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        from collections import defaultdict\n        def build_graph():\n            graph = defaultdict(set)\n            for u, v in dislikes:\n                graph[u].add(v)\n                graph[v].add(u)\n            return graph\n        \n        \n        def dfs(node, next_color):\n            if node in color: return color[node] == next_color\n            color[node] = next_color\n            for nei in graph[node]:\n                if not dfs(nei, next_color^1):\n                    return False\n            return True\n            \n        graph = build_graph()\n        color = {}\n        for node in graph:\n            if node not in color:\n                if not dfs(node, 0): return False\n        return True", "class Solution:\n\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n\n        graph = {i: set() for i in range(1, N + 1)}\n        for u, v in dislikes:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        colours = {}\n\n        for u in graph:\n            colours.setdefault(u, False)\n\n            st = [u]\n            while st:\n                a = st.pop()\n                ca = colours[a]\n\n                for v in graph[a]:\n                    cv = colours.get(v)\n                    if cv is not None:\n                        if cv == ca:\n                            return False\n                    else:\n                        colours[v] = not ca\n                        st.append(v)\n        return True", "def dfs(adjList, visited, node):\n    teams = {node: 1}\n    visited.add(node)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        team = teams[node]\n        for adjNode in adjList[node]:\n            if adjNode in teams and teams[adjNode] == team:\n                return False\n            if adjNode not in teams:\n                teams[adjNode] = 1 - team\n                visited.add(adjNode)\n                stack.append(adjNode)\n    return True\n\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        adjList = {i: [] for i in range(1, N + 1)}\n        for dislike in dislikes:\n            x = dislike[0]\n            y = dislike[1]\n            adjList[x].append(y)\n            adjList[y].append(x)\n            \n        visited = set()\n        for i in range(1, N + 1):\n            if i not in visited:\n                if not dfs(adjList, visited, i):\n                    return False\n        return True"]
["from math import ceil\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  pf = []\n  for i in range(2, ceil(n**0.5)+1):\n    while n % i == 0:\n      pf.append(i)\n      n //= i\n  if n > 1:\n    pf.append(n)\n  if len(pf) == 2 and pf[0] != pf[1]:\n    print(pf[0], pf[1], pf[0]*pf[1])\n    print(1)\n  else:\n    pg = []\n    fac = []\n    nfac = []\n    while len(pf) > 0:\n      p = pf[-1]\n      mul = 0\n      while len(pf) > 0 and pf[-1] == p:\n        pf.pop()\n        mul += 1\n      pg.append([mul, p])\n    pg.sort()\n    pg = pg[::-1]\n    # print(pg)\n    cur = 0\n    if pg[0][0] == 1:\n      a = pg[0][1]\n      b = pg[1][1]\n      c = pg[2][1]\n      fac = [a, a*b*c, a*b, b, b*c, c, a*c]\n      cur = 3\n    else:\n      fac = [pg[0][1]**i for i in range(1, pg[0][0]+1)]\n      cur = 1\n    while cur < len(pg):\n      mul = pg[cur][0]\n      p = pg[cur][1]\n      nfac = []\n      for i in range(len(fac)):\n        if i == 0:\n          nfac += [fac[i]*(p**j) for j in range(mul, -1, -1)]\n        else:\n          nfac += [fac[i]*(p**j) for j in range(mul+1)]\n      nfac += [p**i for i in range(1, mul+1)]\n      fac = nfac\n      cur += 1\n    print(\" \".join([str(i) for i in fac]))\n    print(0)\n", "\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\ndef isPrimeMR(n):\n    d = n - 1\n    d = d // (d & -d)\n    L = [2, 7, 61] if n < 1<<32 else [2, 3, 5, 7, 11, 13, 17] if n < 1<<48 else [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for a in L:\n        t = d\n        y = pow(a, t, n)\n        if y == 1: continue\n        while y != n - 1:\n            y = y * y % n\n            if y == 1 or t == n - 1: return 0\n            t <<= 1\n    return 1\ndef findFactorRho(n):\n    m = 1 << n.bit_length() // 8\n    for c in range(1, 99):\n        f = lambda x: (x * x + c) % n\n        y, r, q, g = 2, 1, 1, 1\n        while g == 1:\n            x = y\n            for i in range(r):\n                y = f(y)\n            k = 0\n            while k < r and g == 1:\n                ys = y\n                for i in range(min(m, r - k)):\n                    y = f(y)\n                    q = q * abs(x - y) % n\n                g = gcd(q, n)\n                k += m\n            r <<= 1\n        if g == n:\n            g = 1\n            while g == 1:\n                ys = f(ys)\n                g = gcd(abs(x - ys), n)\n        if g < n:\n            if isPrimeMR(g): return g\n            elif isPrimeMR(n // g): return n // g\n            return findFactorRho(g)\ndef primeFactor(n):\n    i = 2\n    ret = {}\n    rhoFlg = 0\n    while i * i <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n        if k: ret[i] = k\n        i += i % 2 + (3 if i % 3 == 1 else 1)\n        if i == 101 and n >= 2 ** 20:\n            while n > 1:\n                if isPrimeMR(n):\n                    ret[n], n = 1, 1\n                else:\n                    rhoFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                    ret[j] = k\n\n    if n > 1: ret[n] = 1\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n    return ret\n\ndef divisors(pf):\n    ret = [1]\n    for p in pf:\n        ret_prev = ret\n        ret = []\n        for i in range(pf[p]+1):\n            for r in ret_prev:\n                ret.append(r * (p ** i))\n    return sorted(ret)\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    pf = primeFactor(N)\n    dv = divisors(pf)\n    if len(pf) == 2 and len(dv) == 4:\n        print(*dv[1:])\n        print(1)\n        continue\n    \n    if len(pf) == 1:\n        print(*dv[1:])\n        print(0)\n        continue\n    \n    lpf = list(pf)\n    # print(\"lpf =\", lpf)\n    \n    X = [[] for _ in range(len(pf))]\n    S = {1}\n    if len(lpf) == 2:\n        X[0].append(lpf[0] * lpf[1])\n        X[1].append(N)\n        S.add(lpf[0] * lpf[1])\n        S.add(N)\n        for i, p in enumerate(lpf):\n            for j in range(1, pf[p] + 1):\n                X[i].append(p ** j)\n                S.add(p ** j)\n    else:\n        for i, p in enumerate(lpf):\n            # print(\"i, p, pf[p] =\", i, p, pf[p])\n            X[i].append(lpf[i-1] * p)\n            S.add(lpf[i-1] * p)\n            for j in range(1, pf[p] + 1):\n                X[i].append(p ** j)\n                S.add(p ** j)\n    for a in dv:\n        if a not in S:\n            for i, p in enumerate(lpf):\n                if a % p == 0:\n                    X[i].append(a)\n                    break\n    # print(\"X =\", X)\n    ANS = []\n    for x in X:\n        for y in x:\n            ANS.append(y)\n    print(*ANS)\n    print(0)\n", "t = int(input())\nfor _ in range(t):\n    works = 0\n    n = int(input())\n    ps = []\n    for i in range(2,4*10**4):\n        c = 0\n        while n % i == 0:\n            c += 1\n            n //= i\n        if c:\n            ps.append((i,c))\n    if n > 1:\n        ps.append((n,1))\n    if len(ps) >= 3:\n        base = [0] * (2 * len(ps))\n        lists = [[] for i in range(2 * len(ps))]\n        for i in range(len(ps)):\n            base[2*i] = ps[i][0]\n            base[2*i+1] = ps[i][0] * ps[(i + 1)%len(ps)][0]\n            factors = [1]\n\n        for p,pp in ps:\n            mult = [pow(p,i) for i in range(pp+1)]\n            new = []\n            for m in mult:\n                for f in factors:\n                    new.append(m*f)\n            factors = new\n        \n        for v in factors:\n            if v in base:\n                lists[base.index(v)] += [v]\n            else:\n                for u in range(2*len(ps)):\n                    if v % base[u] ==0:\n                        lists[u] += [v]\n                        break\n    \n        out=sum(lists,[])\n    elif len(ps) == 2:\n        p, q = ps\n        if p[1] < q[1]:\n            p,q=q,p\n        p, pp = p\n        q, qq = q\n        if pp == 1 and qq == 1:\n            works = 1\n            out = [p,p*q,q]\n        else:\n            base = [p,p*q,q,p*p*q]\n            lists = [[],[],[],[]]\n            for i in range(pp + 1):\n                for j in range(qq + 1):\n                    v = pow(p,i) * pow(q,j)\n                    if v in base:\n                        lists[base.index(v)] += [v]\n                    else:\n                        for u in range(4):\n                            if v % base[u]==0:\n                                lists[u] += [v]\n                                break\n            out=sum(lists,[])\n            \n    else:\n        out = []\n        for i in range(1, ps[0][1]+1):\n            out.append(pow(ps[0][0],i))\n    print(' '.join(map(str,out)))\n    print(works)\n", "import itertools\ny=lambda:int(input())\np=[1]*32000\nfor i in range(180):\n    if p[i]:\n        for j in range(2*i+2,len(p),i+2):p[j]=0\nq=[i+2 for i in range(len(p))if p[i]]\nfor _ in range(y()):\n    n=y();d=[];e=set()\n    for i in q:\n        if n%i<1:\n            n//=i;d.append([i,1])\n            while n%i<1:n//=i;d[-1][1]+=1\n    if n>1:d.append([n,1])\n    l=len(d)\n    for i in itertools.product(*(range(i[1]+1)for i in d)):\n        p=1\n        for j in range(l):p*=d[j][0]**i[j]\n        e.add(p)\n    e.remove(1)\n    \n    b=l==2 and d[0][1]+d[1][1]==2\n    if l<2 or b:f=list(e)\n    elif l<3:\n        s=d[1][1]>1\n        v=d[s][0]*d[1-s][0]\n        f=[v]\n        e.remove(v)\n        k=set()\n        for i in e:\n            if i%d[1-s][0]<1:k.add(i);f.append(i)\n        v=(d[s][0]**2)*d[1-s][0]\n        f.remove(v)\n        f.append(v)\n        e-=k\n        for i in e:f.append(i)\n    else:\n        v=d[0][0]*d[-1][0]\n        f=[v]\n        e.remove(v)\n        for i in range(l):\n            v=d[i][0]*d[i-1][0]\n            f.remove(v)\n            f.append(v)\n            k=set()\n            for j in e:\n                if j%d[i][0]<1:k.add(j);f.append(j)\n            e-=k\n    print(' '.join(map(str,f)))\n    print(int(b))", "import sys\ninput=sys.stdin.readline\nt=int(input())\nfor you in range(t):\n    n=int(input())\n    z=n\n    primes=[]\n    i=2\n    while(i*i<=z):\n        if(z%i==0):\n            primes.append(i)\n            while(z%i==0):\n                z=z//i\n        i+=1\n    if(z!=1):\n        primes.append(z)\n    hashi=dict()\n    for i in primes:\n        hashi[i]=[]\n    hashinew=dict()\n    new=[]\n    k=len(primes)\n    hasho=dict()\n    if(k>2):\n        for i in range(k):\n            new.append(primes[i]*primes[(i+1)%k])\n            hasho[primes[i]*primes[(i+1)%k]]=1\n    if(k==2):\n        hasho[primes[0]*primes[1]]=1\n    i=2\n    while(i*i<=n):\n        if(n%i==0):\n            num1=i\n            num2=n//i\n            if(num1 not in hasho):\n                for j in primes:\n                    if(num1%j==0):\n                        break\n                hashi[j].append(num1)\n            if(num2!=num1 and num2 not in hasho):\n                for j in primes:\n                    if(num2%j==0):\n                        break\n                hashi[j].append(num2)\n        i+=1\n    for j in primes:\n        if(n%j==0):\n            break\n    hashi[j].append(n)\n    done=dict()\n    if(len(primes)==1):\n        for i in hashi[primes[0]]:\n            print(i,end=\" \")\n        print()\n        print(0)\n        continue\n    if(len(primes)==2):\n        if(primes[0]*primes[1]==n):\n            print(primes[0],primes[1],n)\n            print(1)\n        else:\n            for i in hashi[primes[0]]:\n                print(i,end=\" \")\n            for i in hashi[primes[1]]:\n                print(i,end=\" \")\n            print(primes[0]*primes[1],end=\" \")\n            print()\n            print(0)\n        continue\n    for i in range(k):\n        for j in hashi[primes[i]]:\n            print(j,end=\" \")\n        ko=primes[i]*primes[(i+1)%k]\n        print(ko,end=\" \")\n    print()\n    print(0)\n", "import sys\ninput=lambda:sys.stdin.readline().rstrip()\n\ndef gcd(a, b):\n  while b: a, b = b, a % b\n  return a\ndef isPrimeMR(n):\n  d = n - 1\n  d = d // (d & -d)\n  L = [2, 3, 61]\n  for a in L:\n    t = d\n    y = pow(a, t, n)\n    if y == 1: continue\n    while y != n - 1:\n      y = (y * y) % n\n      if y == 1 or t == n - 1: return 0\n      t <<= 1\n  return 1\ndef findFactorRho(n):\n  m = 1 << n.bit_length() // 8\n  for c in range(1, 99):\n    f = lambda x: (x * x + c) % n\n    y, r, q, g = 2, 1, 1, 1\n    while g == 1:\n      x = y\n      for i in range(r):\n        y = f(y)\n      k = 0\n      while k < r and g == 1:\n        ys = y\n        for i in range(min(m, r - k)):\n          y = f(y)\n          q = q * abs(x - y) % n\n        g = gcd(q, n)\n        k += m\n      r <<= 1\n    if g == n:\n      g = 1\n      while g == 1:\n        ys = f(ys)\n        g = gcd(abs(x - ys), n)\n    if g < n:\n      if isPrimeMR(g): return g\n      elif isPrimeMR(n // g): return n // g\n      return findFactorRho(g)\ndef primeFactor(n):\n  i = 2\n  ret = {}\n  rhoFlg = 0\n  while i*i <= n:\n    k = 0\n    while n % i == 0:\n      n //= i\n      k += 1\n    if k: ret[i] = k\n    i += 1 + i % 2\n    if i == 101 and n >= 2 ** 20:\n      while n > 1:\n        if isPrimeMR(n):\n          ret[n], n = 1, 1\n        else:\n          rhoFlg = 1\n          j = findFactorRho(n)\n          k = 0\n          while n % j == 0:\n            n //= j\n            k += 1\n          ret[j] = k\n\n  if n > 1: ret[n] = 1\n  if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n  return ret\n\nfor _ in range(int(input())):\n  n=int(input())\n  ret=primeFactor(n)\n  m=len(ret)\n  s=1\n  a=[]\n  for i in ret:\n    a.append(i)\n    s*=ret[i]+1\n  ans=[]\n  for i in range(m):\n    s//=ret[a[i]]+1\n    for j in range(1,ret[a[i]]+1):\n      for k in range(s):\n        x=a[i]**j\n        for l in range(i+1,m):\n          k,t=divmod(k,ret[a[l]]+1)\n          x*=a[l]**t\n        ans.append(x)\n  if gcd(ans[0],ans[-1])==1:\n    del ans[ans.index(ans[0]*ans[-1])]\n    ans.append(ans[0]*ans[-1])\n  anss=0\n  for i in range(len(ans)-1):\n    if gcd(ans[i],ans[i+1])==1:anss+=1\n  print(*ans)\n  print(anss)", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\n\ndef isprime(n):\n    for j in range(2, int(n ** 0.5) + 1):\n        if n % j == 0:return 0\n    return 1\n\nfor _ in range(val()):\n    n = val()\n\n    l1 = factors(n)[1:]\n    l = []\n    for j in l1:\n        if isprime(j):l.append(j)\n    l1 = set(l1)\n    l1 -= set(l)\n    # print(l, l1)\n    d = defaultdict(set)\n    for j in range(len(l)):\n        for i in sorted(list(l1)):\n            if i % l[j] == 0 and i % l[j - 1] == 0:\n                d[tuple(sorted([l[j], l[j - 1]]))].add(i)\n                l1.remove(i)\n                break\n    # print(l, l1)\n    for j in range(len(l)):\n        for i in sorted(list(l1)):\n            if i % l[j] == 0 and i % l[j - 1] == 0:\n                d[tuple(sorted([l[j], l[j - 1]]))].add(i)\n                l1.remove(i)\n    # print(l, l1, d)\n\n    only = defaultdict(list)\n    for j in range(len(l)):\n        for i in sorted(list(l1)):\n            if i % l[j] == 0:\n                only[l[j]].append(i)\n                l1.remove(i)\n    \n    fin = []\n    if len(l) == 2:\n        fin.append(l[0])\n        for j in only[l[0]]:fin.append(j)\n        for i in range(len(l)):\n            for j in list(d[tuple(sorted([l[i], l[(i + 1)  % len(l)]]))]):\n                fin.append(j)\n                d[tuple(sorted([l[i], l[(i + 1)  % len(l)]]))].remove(j)\n                if i != len(l) - 1:break\n            if i != len(l) - 1:\n                fin.append(l[i + 1])\n                for j in only[l[i + 1]]:\n                    fin.append(j)\n\n\n\n\n    else:\n        fin.append(l[0])\n        for j in only[l[0]]:fin.append(j)\n        for i in range(len(l)):\n            for j in d[tuple(sorted([l[i], l[(i + 1)  % len(l)]]))]:\n                fin.append(j)\n            if i != len(l) - 1:\n                fin.append(l[i + 1])\n                for j in only[l[i + 1]]:\n                    fin.append(j)\n\n\n    ans = 0\n    for i in range(len(fin)):\n        if math.gcd(fin[i], fin[i - 1]) == 1:ans += 1\n    print(*fin)\n    print(ans)", "from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    pier = []\n    i = 2\n    nn = n\n    while True:\n        if nn%i == 0:\n            pier.append(i)\n            nn//=i\n        else:\n            i+= 1\n        if i**2 > n:\n            break\n    if nn != 1:\n        pier.append(nn)\n    pier_unique = list(set(pier))\n    dzielniki = [1]\n    for p in pier_unique:\n        pot = p\n        addition = []\n        while n%pot == 0:\n            addition1 = [d*pot for d in dzielniki]\n            addition += addition1\n            pot *= p\n        dzielniki += addition\n    dzielniki = dzielniki[1:]\n    k = len(pier_unique)\n    if k == 1:\n        print(*dzielniki)\n        print(0)\n    elif k >= 3:\n        dzielniki = set(dzielniki)\n        odp = []\n        for i in range(k):\n            dzielniki.remove(pier_unique[i-1]*pier_unique[i])\n        for i in range(k):\n            odp.append(pier_unique[i-1]*pier_unique[i])\n            to_rem = []\n            for dz in dzielniki:\n                if dz%pier_unique[i] == 0:\n                    to_rem.append(dz)\n                    odp.append(dz)\n            for to in to_rem:\n                dzielniki.remove(to)\n        print(*odp)\n        print(0)\n    else:\n        p = pier_unique[0]\n        q = pier_unique[1]\n        if n == p*q:\n            print(p,q,p*q)\n            print(1)\n        else:\n            test = p**2\n            if n%test != 0:\n                p,q= q,p\n            #p^2 dzieli n\n            dzielniki = set(dzielniki)\n            dzielniki.remove(p*q)\n            dzielniki.remove(p*p*q)\n            odp = [p*q]\n            to_rem = []\n            for dzu in dzielniki:\n                if dzu%p == 0:\n                    to_rem.append(dzu)\n                    odp.append(dzu)\n            for tu in to_rem:\n                dzielniki.remove(tu)\n            odp.append(p*p*q)\n            for dzu in dzielniki:\n                odp.append(dzu)\n            print(*odp)\n            print(0)\n\n", "from sys import stdin, stdout\nimport math\nimport bisect\n\ndef gcd(a,b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\ndef solve(n):\n    dv = [n]\n    x = 2\n    while x*x <= n:\n        if n%x == 0:\n            dv.append(x)\n            if x != n//x:\n                dv.append(n//x)\n        x += 1\n    dv = sorted(dv)\n    ans = [0]*len(dv) \n\n    ans[0], ans[-1] = dv[0], dv[-1]\n    seen = {dv[0], dv[-1]}\n    cur_prime = dv[0]\n    min_prime = dv[0]\n    while len(seen) < len(dv):\n        for x in dv:\n            if x in seen: continue\n            if min_prime == -1:\n                min_prime = x\n\n            if cur_prime == -1:\n                if ans[len(seen)-2]%x == 0:\n                    cur_prime = x\n                    ans[len(seen)-1] = x\n                    seen.add(x)\n            else:\n                if x%cur_prime == 0:\n                    ans[len(seen)-1] = x\n                    seen.add(x)\n        if cur_prime == -1:\n            cur_prime = min_prime\n        else:\n            cur_prime = -1\n        min_prime = -1\n    cnt = 0\n    for i in range(1, len(ans)):\n        if gcd(ans[i], ans[i-1]) == 1:\n            cnt += 1\n    print(\" \".join(map(str, ans)))\n    print(cnt)\n\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    solve(n)\n\n#for i in range(2, 50):\n#    solve(i)\n", "# prime power always 0\n# two prime powers?\n#\n# == 1 prime factor\n#   trivial\n# == 2 prime factors\n#   p^a q^b\n#   if a + b > 2: then fine\n#   p*q\n#   (remaining with p)\n#   p*p*q\n#   (remaining with q)\n# >= 3 prime factors is fine\n#   what ordering?\n#   p*q*r\n#   (all left with p)\n#   p*q\n#   (all left with q)\n#   q*r\n#   (all left with r)\n\nfrom collections import defaultdict as dd, deque\n\ndef factor(n):\n    factors = dd(int)\n    d = 2\n    while d*d <= n:\n        while n%d == 0:\n            factors[d] += 1\n            n //= d\n        d += 1\n    if n != 1:\n        factors[n] += 1\n    return factors\n\ndef divisors(n) : \n    i = 1\n    factors = []\n    while i*i <= n: \n        if n % i == 0: \n            # If divisors are equal, print only one \n            if n//i == i: \n                factors.append(i)\n            else : \n                factors.append(i)\n                factors.append(n//i)\n        i += 1\n    return factors\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    F = factor(n)\n    D = set(divisors(n))\n    D.remove(1)\n    if len(F) == 1:\n        print(*list(D))\n        print(0)\n        continue\n    if len(F) == 2:\n        p,q = list(F)\n        exp = sum(F.values())\n        if exp > 2:\n            res = []\n            D.remove(p*q)\n            D.remove(p*p*q)\n\n            divP = {d for d in D if d%p == 0}\n            divQ = D - divP\n            print(p*q, *divP, p*p*q, *divQ)\n            print(0)\n        else:\n            print(p, p*q, q)\n            print(1)\n        continue\n    first = 1\n    for prime in F:\n        first *= prime\n    D.remove(first)\n    Flist = list(F)\n    res = [first]\n    for i in range(len(Flist)-1):\n        p,q = Flist[i-1],Flist[i]\n        D.remove(p*q)\n    for i in range(len(Flist)-1):\n        p,q = Flist[i-1],Flist[i]\n        div = {d for d in D if d%p == 0}\n        D -= div\n        res.extend(div)\n        res.append(p*q)\n    res.extend(D)\n    print(*res)\n    print(0)\n", "from itertools import product\ndef p_factorization_t(n):\n    if n == 1: return []\n    pf_cnt = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i == 0:\n            cnt = 0\n            while temp%i == 0:\n                cnt += 1\n                temp //= i\n            pf_cnt.append((i,cnt))\n\n    if temp != 1: pf_cnt.append((temp,1))\n    return pf_cnt\n\n\ndef main():\n    ansl = []\n    for _ in range(int(input())):\n        n = int(input())\n        facs = p_factorization_t(n)\n        # print(facs)\n        if len(facs) == 1:\n            p,cnt = facs[0]\n            al = []\n            for i in range(1,cnt+1):\n                al.append(pow(p,i))\n            print(*al)\n            print(0)\n\n        ff = []\n        pd = {}\n        ps = []\n        for p,cnt in facs:\n            row = []\n            for i in range(0,cnt+1):\n                row.append(pow(p,i))\n            ff.append(row)\n            pd[p] = []\n            ps.append(p)\n\n        vals = [1]\n        for row in ff:\n            new_vals = []\n            for v in vals:\n                for p in row:\n                    new_vals.append(p*v)\n                    if p != 1:\n                        pd[row[1]].append(v*p)\n            vals = new_vals[:]\n        \n\n        if len(facs) >= 3:\n            al = []\n            for i in range(len(ps)):\n                cval = -1\n                if i > 0:\n                    cval = (ps[i]*ps[i-1])\n                    al.append(cval)\n                else:\n                    cval = (ps[i]*ps[-1])\n                for v in pd[ps[i]]:\n                    if v != cval:\n                        al.append(v)\n            print(*al)\n            print(0)\n\n        elif len(facs) == 2:\n            al = []\n            for i in range(len(ps)):\n                cval = -1\n                if i > 0:\n                    cval = (ps[i]*ps[i-1])\n                    al.append(cval)\n                else:\n                    cval = (ps[i]*ps[-1])\n                for v in pd[ps[i]]:\n                    if v != cval:\n                        al.append(v)\n            print(*al)\n            if facs[0][1] == 1 and facs[1][1] == 1:\n                print(1)\n            else:\n                print(0)\n\n        # elif len(facs) == 2:\n\n\n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def gen(i, cur):\n    nonlocal dvs, used\n    if i == len(kk):\n        if (ohne != 1 or cur != 1) and (ok or not used[cur * ohne]):\n            dvs.append(cur * ohne)\n        return\n    gen(i + 1, cur)\n    for j in range(kk[i]):\n        cur *= pp[i]\n        gen(i + 1, cur)\n\n\ngans = []\nfor _ in range(int(input())):\n    n = int(input())\n    pp = []\n    kk = []\n    i = 2\n    cnt = []\n    while i * i <= n:\n        if n % i == 0:\n            pp.append(i)\n            kk.append(0)\n            while n % i == 0:\n                kk[-1] += 1\n                n //= i\n        i += 1\n    if n != 1:\n        pp.append(n)\n        kk.append(1)\n    dvs = []\n    ohne = 1\n    ok = True\n    gen(0, 1)\n    if len(pp) == 1:\n        gans.append(' '.join(map(str, dvs)))\n        gans.append(str(0))\n    elif len(pp) == 2 and kk[0] == kk[1] == 1:\n        gans.append(' '.join(map(str, dvs)))\n        gans.append(str(1))\n    elif len(pp) == 2:\n        used = dict()\n        for i in range(len(dvs)):\n            used[dvs[i]] = False\n        ans = []\n        ok = False\n        used[pp[0] * pp[1]] = True\n        aaa = [pp[0] * pp[1]]\n        if kk[0] > 1:\n            used[pp[0] * pp[0] * pp[1]] = True\n            aaa.append(pp[0] * pp[0] * pp[1])\n        else:\n            used[pp[0] * pp[1] * pp[1]] = True\n            aaa.append(pp[0] * pp[1] * pp[1])\n        for i in range(len(pp)):\n            dvs = []\n            ans.append(aaa[i])\n            kk[i] -= 1\n            ohne = pp[i]\n            gen(0, 1)\n            for j in range(len(dvs)):\n                used[dvs[j]] = True\n                ans.append(dvs[j])\n        gans.append(' '.join(map(str, ans)))\n        gans.append(str(0))\n    else:\n        used = dict()\n        for i in range(len(dvs)):\n            used[dvs[i]] = False\n        ans = []\n        ok = False\n        for i in range(len(pp)):\n            used[pp[i - 1] * pp[i]] = True\n        for i in range(len(pp)):\n            dvs = []\n            ans.append(pp[i - 1] * pp[i])\n            kk[i] -= 1\n            ohne = pp[i]\n            gen(0, 1)\n            for j in range(len(dvs)):\n                used[dvs[j]] = True\n                ans.append(dvs[j])\n        gans.append(' '.join(map(str, ans)))\n        gans.append(str(0))\nprint('\\n'.join(gans))\n"]
["class Solution:\n     def FindValid(self):\n         a=\"123456789\"\n         d,val={},{}\n         for i in range(9):\n             for j in range(9):\n                 temp=self.board[i][j]\n                 if temp!='.':\n                     d[(\"r\",i)]=d.get((\"r\",i),[])+[temp]\n                     d[(\"c\",j)]=d.get((\"c\",j),[])+[temp]\n                     d[(i//3,j//3)]=d.get((i//3,j//3),[])+[temp]\n                 else:\n                     val[(i,j)]=[]\n         for (i,j) in list(val.keys()):\n             invalid=d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i//3,j//3),[])\n             val[(i,j)]=[ele for ele in a if  ele not in invalid]\n         return val\n     def CheckingSolution(self,ele,Pos,Updata):\n         self.board[Pos[0]][Pos[1]]=ele\n         del self.val[Pos]\n         i,j=Pos\n         for invalid in list(self.val.keys()):\n             if ele in self.val[invalid]:\n                 if invalid[0]==i or invalid[1]==j or (invalid[0]//3,invalid[1]//3)==(i//3,j//3):\n                     Updata[invalid]=ele\n                     self.val[invalid].remove(ele)\n                     if len(self.val[invalid])==0:\n                         return False\n         return True\n     def Sudo(self,Pos,Updata):\n         self.board[Pos[0]][Pos[1]]=\".\"\n         for i in Updata:\n             if i not in self.val:\n                 self.val[i]=Updata[i]\n             else:\n                 self.val[i].append(Updata[i])\n     def FindSolution(self):\n         if len(self.val)==0:\n             return True\n         Pos=min(list(self.val.keys()),key=lambda x:len(self.val[x]))\n         nums=self.val[Pos]\n         for ele in nums:\n             updata={Pos:self.val[Pos]}\n             if self.CheckingSolution(ele,Pos,updata):\n                 if self.FindSolution():\n                     return True\n             self.Sudo(Pos,updata)\n         return False\n \n     def solveSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         \"\"\"\n         self.board=board\n         self.val=self.FindValid()\n         self.FindSolution()\n", "import random\n \n \n class Solution:\n \n     def readSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: bool\n         \"\"\"\n         line = [set(['1', '2', '3', '4', '5', '6', '7', '8', '9']) for _ in range(9)]\n         row = [set(['1', '2', '3', '4', '5', '6', '7', '8', '9']) for _ in range(9)]\n         box = [set(['1', '2', '3', '4', '5', '6', '7', '8', '9']) for _ in range(9)]\n         unfilled = []\n         for x in range(9):\n             for y in range(9):\n                 data = board[x][y]\n                 z = x // 3 + 3 * (y // 3)\n                 if data != '.':\n                     line[x].remove(data)\n                     row[y].remove(data)\n                     box[z].remove(data)\n                 else:\n                     unfilled.append((x, y))\n         return line, row, box, unfilled\n \n     def solveSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         \"\"\"\n         line, row, box, unfilled = self.readSudoku(board)\n         possible = {}\n         guess = {}\n         i = 0\n         while 0 <= i < len(unfilled):\n             (x, y) = unfilled[i]\n             z = x // 3 + 3 * (y // 3)\n             if (x, y) not in possible:\n                 possible[(x, y)] = line[x] & row[y] & box[z]\n             if possible[(x, y)]:\n                 guess[(x,y)] = random.choice(list(possible[(x, y)]))\n                 board[x][y] = guess[(x,y)]\n                 line[x].remove(guess[(x,y)])\n                 row[y].remove(guess[(x,y)])\n                 box[z].remove(guess[(x,y)])\n                 i += 1\n             else:\n                 del possible[unfilled[i]]\n                 i -= 1\n                 (x, y) = unfilled[i]\n                 z = x // 3 + 3 * (y // 3)\n                 possible[(x, y)].remove(guess[(x,y)])\n                 line[x].add(guess[(x,y)])\n                 row[y].add(guess[(x,y)])\n                 box[z].add(guess[(x,y)])", "class Solution(object):\n     def __init__(self):\n         self.filled = []\n \n     def solveSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         \"\"\"\n         pln = []\n         for i in range(9):\n             pln.append([])\n             self.filled.append([])\n             for j in range(9):\n                 if board[i][j].isdigit():\n                     self.filled[-1].append(True)\n                     pln[i].append([])\n                 else:\n                     self.filled[-1].append(False)\n                     pln[i].append([k for k in range(10)])\n                     pln[i][-1].remove(0)\n \n         for i in range(9):\n             for j in range(9):\n                 if board[i][j].isdigit():\n                     self.updatePln(pln, int(board[i][j]), i, j)\n \n         result = self.loopSolution(pln, board)\n         return\n     \n     def updatePln(self, pln, temp, i, j):                    \n         for k in range(9):\n             a= pln[i][k]\n             if temp in pln[i][k]: \n                 pln[i][k].remove(temp)\n             if temp in pln[k][j]: \n                 pln[k][j].remove(temp)\n             num = int(i/3)*3+int(j/3)\n             if temp in pln[int(num/3)*3+int(k/3)][num%3*3+k%3]:\n                 pln[int(num/3)*3+int(k/3)][num%3*3+k%3].remove(temp)\n \n     def loopSolution(self, pln, board):\n         while True:\n             row, column, minSize = 10, 10, 10\n             for i in range(9):\n                 for j in range(9):\n                     if not self.filled[i][j] and len(pln[i][j])==0: \n                         return False\n                     if len(pln[i][j])>0 and len(pln[i][j])<minSize:\n                         row, column = i, j\n                         minSize = len(pln[i][j])\n             if minSize == 10:\n                 return True\n             else:\n                 for i in range(minSize):\n                     self.filled[row][column] = True\n                     temp_pln = []\n                     for ele in pln:\n                         temp_pln.append([])\n                         for ele2 in ele:\n                             temp_pln[-1].append(ele2[:])\n                     self.updatePln(temp_pln, temp_pln[row][column][i], row, column)\n                     temp_pln[row][column] = []\n                     if self.loopSolution(temp_pln, board):\n                         board[row][column] = str(pln[row][column][i])\n                         return True\n                     self.filled[row][column] = False\n                 return False", "# Solution! DFS\n class Solution:\n # @param board, a 9x9 2D array\n # Solve the Sudoku by modifying the input board in-place.\n # Do not return any value.\n     def solveSudoku(self, board):\n         res = self.dfs(board)\n         # board = copy.copy(res)\n         for n, row in enumerate(res):\n             board[n] = row #''.join(row)\n \n     def dfs(self, board):\n         stack = [board]\n         while stack:\n             s = stack.pop()\n             result = self.fill_board(s)\n             if result == 'complete':\n                 return s\n             for r in result:\n                 stack.append(r)\n             \n     def fill_board(self, board):\n         digits = set('123456789')\n         choice, best = {}, []\n         for j in range(9):\n             for i in range(9):\n                 if board[j][i] == '.':\n                     square = {board[j//3*3+y][i//3*3+x]\n                               for y in range(3) for x in range(3)}\n                     row = {board[j][x] for x in range(9)}\n                     col = {board[y][i] for y in range(9)}\n                     rest = digits.difference(square, row, col)\n                     if len(rest) == 1:\n                         board[j][i] = rest.pop()\n                         return self.fill_board(board)\n                     elif len(rest) == 0:\n                         return ''\n                     else:\n                         choice[(j, i)] = rest\n         if not choice:\n             return 'complete'\n         y, x = min(choice, key=lambda k: len(choice[k]))\n         for n in choice[(y, x)]:\n             b = copy.deepcopy(board)\n             b[y][x] = n\n             best.append(b)\n         return best", "class Solution:\n     def reduceSingleOption(self, board, emptyGrid, valid):\n         m = 1\n         while m == 1:\n             m = 10\n             for k in range(len(emptyGrid) - 1, -1, -1):\n                 i, j = emptyGrid[k]\n                 option = set.intersection(valid[i],\n                                           valid[j + 9],\n                                           valid[(i // 3) * 3 + j // 3 + 18])\n                 if not option:\n                     return\n                 if len(option) < m:\n                     m = len(option)\n                 if len(option) == 1:\n                     option = option.pop()\n                     board[i][j] = str(option)\n                     emptyGrid.pop(k)\n                     valid[i].remove(option)\n                     valid[j + 9].remove(option)\n                     valid[(i // 3) * 3 + j // 3 + 18].remove(option)\n \n     def dfs(self, board, emptyGrid, valid, ans):\n         if len(ans) == len(emptyGrid):\n             return\n         i, j = emptyGrid[len(ans)]\n         options = set.intersection(valid[i],\n                                    valid[j + 9],\n                                    valid[(i // 3) * 3 + j // 3 + 18])\n         if len(options) == 0:\n             return\n         else:\n             for temp in options:\n                 print(i, j, temp)\n                 ans.append(temp)\n                 valid[i].remove(temp)\n                 valid[j + 9].remove(temp)\n                 valid[(i // 3) * 3 + j // 3 + 18].remove(temp)\n                 self.dfs(board, emptyGrid, valid, ans)\n                 if len(ans) == len(emptyGrid):\n                     break\n                 temp = ans.pop()\n                 valid[i].add(temp)\n                 valid[j + 9].add(temp)\n                 valid[(i // 3) * 3 + j // 3 + 18].add(temp)\n \n \n     def solveSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         \"\"\"\n         valid = [set(range(1, 10)) for _ in range(27)]\n         emptyGrid = []\n         for i in range(9):\n             for j in range(9):\n                 c = board[i][j]\n                 if c != '.':\n                     n = int(c)\n                     valid[i].remove(n)\n                     valid[j + 9].remove(n)\n                     valid[(i // 3) * 3 + j // 3 + 18].remove(n)\n                 else:\n                     emptyGrid.append((i, j))\n         self.reduceSingleOption(board, emptyGrid, valid)\n         ans = []\n         self.dfs(board, emptyGrid, valid, ans)\n         print(ans)\n         for k in range(len(emptyGrid)):\n             i, j = emptyGrid[k]\n             board[i][j] = str(ans[k])", "class Solution:\n     full_values = set('123456789')\n \n     def findValues(self, board, row, col):\n         row_start = row // 3 * 3\n         col_start = col // 3 * 3\n         values = self.full_values - (set(board[row]) | {board[i][col] for i in range(9)} | \\\n                     {board[i][j] for i in range(row_start, row_start+3) for j in range(col_start, col_start+3)})\n \n         return values\n \n     def solver(self, board):\n         \n         done = True\n         for row in board:\n             if '.' in row:\n                 done = False\n         \n         if done:\n             return True\n       \n         row_num = len(board)\n         col_num = len(board[0])\n                 \n         #candidate values of each pos\n         candidates = [[0 for x in range(row_num)] for y in range(col_num)] \n         #number of candidates of each pos, key is num of candidates, values are list of (row, col)\n         NumOfCandidatesDict = [[] for i in range(9)]\n         \n         for row in range(row_num):\n             for col in range(col_num):\n                 if board[row][col] == '.':\n                     candidates[row][col] = self.findValues(board, row, col)\n \n                     #Not able to solve it\n                     if (len(candidates[row][col]) == 0):\n                         return False\n                     elif len(candidates[row][col]) == 1:\n                         board[row][col] = candidates[row][col].pop()\n                         ret = self.solver(board)\n                         if ret:\n                             return True\n                         else:\n                             board[row][col] = '.'\n                             return False\n                     else:\n                         NumOfCandidatesDict[len(candidates[row][col])].append([row, col])\n         \n        \n         for i in range(2, 10):\n             if len(NumOfCandidatesDict[i]) > 0:\n                 row, col = NumOfCandidatesDict[i][0]\n \n                 for value in candidates[row][col]:\n                     board[row][col] = value\n                     if self.solver(board):\n                         return True\n                 board[row][col] = '.'\n                 return False       \n         \n         return False\n     \n     def solveSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         \"\"\"\n         self.solver(board)", "class Solution:\n     def solveSudoku(self, board):\n         \"\"\"\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         \"\"\"\n         self.board = board\n         self.val = self.PossibleValue()\n         self.Solver()\n     def PossibleValue(self):\n         nums = \"123456789\"\n         d,val={},{}\n         for i in range(9):\n             for j in range(9):\n                 element = self.board[i][j]\n                 if element!=\".\":\n                     d[(\"r\",i)]=d.get((\"r\",i),[])+[element]\n                     d[(\"c\",j)]=d.get((\"c\",j),[])+[element]\n                     d[(i//3,j//3)]=d.get((i//3,j//3),[])+[element]\n                 else:\n                     val[(i,j)]=[]\n         for (i,j) in val.keys():\n             temp=d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i//3,j//3),[])\n             val[(i,j)]=[x for x in nums if x not in temp]\n         return val\n     def Solver(self):\n         if len(self.val)==0:\n             return True\n         kee = min(self.val.keys(),key=lambda x: len(self.val[x]))\n         possible_nums = self.val[kee]\n         #update = {}\n         for n in possible_nums:\n             update = {kee:self.val[kee]}\n             if self.ValidOne(n,kee,update):\n                 if self.Solver():\n                     return True\n             #self.val[kee]=possible_nums\n             self.undo(kee,update)\n         return False\n     def ValidOne(self,n,kee,update):\n         self.board[kee[0]][kee[1]]=n\n         del self.val[kee]\n         i,j = kee\n         for index in self.val:\n             if (i==index[0] or j==index[1] or (i//3,j//3)==(index[0]//3,index[1]//3)) and (n in self.val[index]):\n                 update[index] = n\n                 self.val[index].remove(n)\n                 if len(self.val[index])==0:return False\n         return True\n     def undo(self,kee,update):\n         self.board[kee[0]][kee[1]]=\".\"\n         for x in update:\n             if x not in self.val:\n                 self.val[x]= update[x]\n             else:\n                 self.val[x].append(update[x])\n         return None"]
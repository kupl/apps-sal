["class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        def dp(i, j):\n            if i==0: return 2*j\n            # if j==0: return 0\n            if j==1: return 2\n            if (i, j) in memo: return memo[(i, j)]\n            base = x**i\n            q, r = divmod(j, base)\n            if r==0: return q*i\n            memo[(i, j)]=min(q*i+dp(i-1, r), (q+1)*i+dp(i-1, base-r))\n            return memo[(i, j)]\n        \n        memo = {}\n        return dp(ceil(log(target, x)), target)-1", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        @lru_cache(None)\n        def calc(goal):\n            if x == goal:\n                return 0\n            if x > goal:\n                return min(goal*2 - 1, (x - goal) * 2)\n            \n            sums = x\n            times = 0\n            while sums < goal:\n                times += 1\n                sums *= x\n            \n            if sums == goal:\n                return times\n            \n            if sums - goal < goal:\n                return min(calc(sums - goal) + times + 1, calc(goal - (sums // x)) + times)\n            \n            return calc(goal - (sums // x)) + times            \n            \n        return calc(target)", "from functools import lru_cache\nclass Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        @lru_cache(None)\n        def search(t: int) -> int:\n            if x == t:\n                return 0\n            if t < x:\n                d1, d2 = t, x - t\n                return min(2 * d1 - 1, 2 * d2)\n            k1 = int(math.log(t, x))\n            y1 = x ** k1\n            if y1 == t:\n                return k1 - 1\n            total = k1 + search(t - y1)\n            k2 = k1 + 1\n            y2 = x ** k2\n            if y2 <= 2 * t - y1:\n                total = min(total, k2 + search(y2 - t))\n            return total\n        \n        return search(target)", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        q, s = [], set()\n        q.append((0, target))\n        while q:\n            c, t = heapq.heappop(q)\n            if t == 0: return c - 1\n            if t in s: continue\n            s.add(t)\n            n = int(log(t) / log(x)) \n            l = t - x**n\n            heapq.heappush(q, (c+(2 if n==0 else n), l))\n            r = x**(n+1) - t\n            heapq.heappush(q, (c + n + 1, r))\n", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        import math\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def f(x, target, depth):\n            # print('  ' * depth, '\u5f00\u59cb\u8ba1\u7b97', x, target)\n            if target == 1:\n                return 1\n\n            res = target * 2 - 1\n            if target < x:\n                if x - target < target:\n                    res = min(res, 1 + f(x, x - target, depth + 1))\n            else:\n                y = math.log(target, x)\n                y_lower = int(y)\n                p = pow(x, y_lower)\n                cnt = target // p\n                remain = target - cnt * p\n                if y > y_lower:\n                    res = min(res, y_lower * cnt + f(x, remain, depth + 1))\n                    if p * x - target < target:\n                        res = min(res, y_lower + 1 + f(x, p * x - target, depth + 1))\n                else:\n                    res = y_lower - 1\n            return res\n\n        return f(x, target, 0)", "class Solution:\n    def leastOpsExpressTarget(self, x, y):\n        pos = neg = k = 0\n        while y:\n            y, cur = divmod(y, x)\n            if k:\n                pos, neg = min(cur * k + pos, (cur + 1) * k + neg), min((x - cur) * k + pos, (x - cur - 1) * k + neg)\n            else:\n                pos, neg = cur * 2, (x - cur) * 2\n            k += 1\n        return min(pos, k + neg) - 1", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        \n        cost = list(range(40))\n        cost[0] = 2\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dp(i, target) :\n            if target == 0 : return 0\n            if target == 1 : return cost[i]\n            \n            if i >= 39 : return float('inf')\n            \n            t, r = divmod(target, x)\n            return min(r * cost[i] + dp(i + 1, t), (x - r) * cost[i] + dp(i + 1, t + 1))\n        \n        return dp(0, target) - 1\n        \n        \n", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        \n        cost = list(range(32))\n        cost[0] = 2\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dp(i, target) :\n            if target == 0 : return 0\n            if target == 1 : return cost[i]\n            \n            if i >= 31 : return float('inf')\n            \n            t, r = divmod(target, x)\n            return min(r * cost[i] + dp(i + 1, t), (x - r) * cost[i] + dp(i + 1, t + 1))\n        \n        return dp(0, target) - 1\n        \n        \n", "from functools import lru_cache\nclass Solution:\n    @lru_cache(None)\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        if x == target:\n            return 0\n        if x > target:\n            return min(target*2-1,(x-target)*2)\n        sums, cnt = x, 0\n        while sums < target:\n            sums *= x \n            cnt += 1\n        if sums == target:\n            return cnt\n        left, right = float('inf'), float('inf')\n        if sums - target < target:\n            right = self.leastOpsExpressTarget(x, sums-target) + cnt + 1\n        left = self.leastOpsExpressTarget(x, target-sums//x) + cnt\n        return min(left,right)", "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        dp = {}\n        def dfs(i, target):\n            if i in dp and target in dp[i]:\n                return dp[i][target]\n            if target == 0:\n                return 0\n            if i >= 32:\n                return float('inf')\n            div = x ** i\n            res = target % div\n            ret = min(dfs(i + 1, target - res) + res * x // div * (i - 1),\n                       dfs(i + 1, target - res + div) + (div - res) * x // div * (i - 1))\n            if res == 0:\n                ret = min(ret, target // div * i)\n            dp[i] = dp.get(i, {})\n            dp[i][target] = ret\n            return ret\n        res = target % x\n        return min(dfs(2, target - res) + res * 2, dfs(2, target - res + x) + (x - res) * 2) - 1", "#\nfrom functools import lru_cache\n\nclass Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        cost = list(range(40))\n        cost[0] = 2\n\n        @lru_cache(None)\n        def dp(i, targ):\n            if targ == 0: return 0\n            if targ == 1: return cost[i]\n            if i >= 39: return float('inf')\n\n            t, r = divmod(targ, x)\n            return min(r * cost[i] + dp(i+1, t),\n                       (x-r) * cost[i] + dp(i+1, t+1))\n\n        return dp(0, target) - 1"]
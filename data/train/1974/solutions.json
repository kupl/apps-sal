["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root==None:\n             return []\n         stack=[]\n         stack_left=[1]\n         while stack_left!=[]:\n             stack.append(root.val)\n             if root.left!=None and root.right==None:\n                 root=root.left\n             elif root.left==None and root.right!=None:\n                 root=root.right\n             elif root.left!=None and root.right!=None:\n                 stack_left.append(root.left)\n                 root=root.right\n             else:\n                 if stack_left==[1]:\n                     stack_left=[]\n                 else:\n                     root=stack_left.pop()\n         #print(stack)\n         stack.reverse()\n         return stack\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         ans = []\n         if (root == None): return ans\n         self.helper(root,ans)\n         return ans\n     \n     def helper(self,root,ans):\n         if (root == None):\n             return\n         self.helper(root.left,ans)\n         self.helper(root.right,ans)\n         ans.append(root.val)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         st, ans = [], []\n         cur, last = root, None\n         while cur or st:\n             while cur:\n                 st.append(cur)\n                 cur = cur.left\n             cur = st[-1]\n             if not cur.right or cur.right == last:\n                 ans.append(cur.val)\n                 st.pop()\n                 last = cur\n                 cur = None\n             else:\n                 cur = cur.right\n         return ans\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def __init__(self):\n         self.l=[]\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root == None:\n             return []\n         self.postorderTraversal(root.left)\n         self.postorderTraversal(root.right)\n         self.l.append(root.val)\n         return self.l", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         path = []\n         \n         def postOrder(root):\n             if not root:\n                 return\n             postOrder(root.left)\n             postOrder(root.right)\n             path.append(root.val)\n             \n         postOrder(root)\n         return path", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         trav = []\n         self.post(root, trav)\n         return trav\n     \n     def post(self, node, trav):\n         if not node: return\n         self.post(node.left, trav)\n         self.post(node.right, trav)\n         trav.append(node.val)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root == None:\n             return []\n         else:\n             return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return []\n         stack_left = [1]\n         stack = []\n         while stack_left:\n             stack.append(root.val)\n             if not root.left and root.right:\n                 root = root.right\n             elif root.left and not root.right:\n                 root = root.left\n             elif root.left and root.right:\n                 stack_left.append(root.left)\n                 root = root.right\n             else:\n                 if stack_left == [1]:\n                     stack_left = []\n                 else:\n                     root = stack_left.pop()\n         stack.reverse()\n         return stack", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         self.post_traversal = []\n         if root is None:\n             return self.post_traversal\n         self.postorderTraversals(root)\n         return  self.post_traversal\n \n     def postorderTraversals(self, root):\n         if root.left:\n             self.postorderTraversals(root.left)\n         if root.right:\n             self.postorderTraversals(root.right)\n         self.post_traversal.append(root.val)\n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         res = []\n         self.dfs(root,res)\n         return res\n     \n     def dfs(self,root,res):\n         if root:\n             self.dfs(root.left,res)\n             self.dfs(root.right,res)\n             res.append(root.val)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         res,stack=[],[(root,False)]\n         while stack:\n             node,flag=stack.pop()\n             if node:\n                 if flag:\n                     res.append(node.val)\n                 else:\n                     stack.append((node,True))\n                     stack.append((node.right,False))\n                     stack.append((node.left,False))\n         return res\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         res = []\n         if not root:\n             return res\n         stack = []\n         cur = root\n         while cur or stack:\n             while cur:\n                 stack.append((cur, 0))\n                 cur = cur.left\n             node, flag = stack[-1]\n             if flag:\n                 node, _ = stack.pop()\n                 res.append(node.val)\n             else:\n                 cur = node.right\n                 stack[-1] = (node, 1)\n         return res", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return []\n \n         stack = [root]\n         result = []\n \n         while stack:\n             node = stack.pop()\n             if node.left or node.right:\n                 stack.append(TreeNode(node.val))\n                 if node.right:\n                     stack.append(node.right)\n                 if node.left:\n                     stack.append(node.left)\n             else:\n                 result.append(node.val)\n \n         return result        "]
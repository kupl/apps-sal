["class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        res = 0\n        freqs = [f + 1 for f in Counter(tiles).values()]\n        for t in itertools.product(*map(range, freqs)):\n            n = sum(t)\n            subtotal = math.factorial(n)\n            for freq in t:\n                subtotal //= math.factorial(freq)\n            res += subtotal\n        return res - 1", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n\n        return len(set(x for i in range(1,len(tiles)+1) for x in itertools.permutations(tiles,i)))\n        \n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        def freq(tiles):\n            d = {}\n            for c in tiles:\n                if c in d:\n                    d[c] += 1\n                else:\n                    d[c] = 1\n            return d\n        \n        def build(d, s):\n            new_d = {}\n            for key, value in d.items():\n                if key == s:\n                    new_d[key] = value - 1\n                else:\n                    new_d[key] = value\n            return new_d\n        \n        def generate(options):\n            sol = []\n            for key, value in options.items():\n                if value > 0:\n                    sol.append(key)\n                    fringe = generate(build(options, key))\n                    sol += fringe\n                    sol += [key + f for f in fringe]\n            return sol        \n        \n        return len(set(generate(freq(tiles))))", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        #self.seen=set()\n        @lru_cache(None)\n        def find(s):\n            if len(s)<=1:\n                return set([s])\n            \n            ret=set()\n            for i in range(len(s)):\n                head=s[i]\n                tails=find(s[:i]+s[i+1:])\n                ret=ret.union(tails)\n                for tail in tails:\n                    for j in range(len(tail)+1):\n                        temp=tail[:j]+head+tail[j:]\n                        ret.add(temp)\n            return ret\n        res=find(tiles)\n        #print(res)\n        return len(set(res))\n                        \n            \n", "from collections import Counter\n\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        c_all, visited = Counter(tiles), set()\n        stack = [(x, Counter([x])) for x in c_all]\n        \n        while stack:\n            element, c = stack.pop()\n            if element not in visited:\n                stack.extend([(element + x, c + Counter([x])) for x in c_all - c])\n                visited.add(element)\n                \n        return len(visited)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        pos = set()\n        def choose(s, n, pref=''):\n            if n == 0:\n                pos.add(pref)\n            \n            for i in range(len(s)):\n                choose(s[:i] + s[i+1:], n-1, pref + s[i])\n        \n        for i in range(1, len(tiles)+1):\n            choose(tiles, i)\n        return len(pos)\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        words = set()\n        curr = ''\n        tile_count = {}\n        for x in tiles:\n            if x not in tile_count:\n                tile_count[x] = 0\n            tile_count[x] += 1\n        \n        def walk(curr, tiles, words):\n            #print(tiles, curr)\n            for tile in tiles:\n                if tiles[tile] > 0:\n                    temp = curr + tile\n                    #print('Temp', temp)\n                    temp_tiles = tiles.copy()\n                    temp_tiles[tile] -= 1\n                    words.add(temp)\n                    walk(temp, temp_tiles, words)\n        for tile in tile_count:\n            walk('', tile_count, words)\n        return len(words)", "class Solution:\n    def __init__(self):\n        self.total = 0\n        self.string = []\n        self.dict_ = {}\n        self.arr = []\n        self.n = 0\n    \n    def perm(self):\n        if(self.n==len(self.string)):\n            #print(string)\n            self.total+=1\n            #print(self.total)\n        \n        for i in range(len(self.arr)):\n            if(self.arr[i][1]>0):\n                self.arr[i][1]-=1\n                self.string.append(self.arr[i][0])\n                self.perm()\n                self.string.pop()\n                self.arr[i][1]+=1\n    \n    \n    def numTilePossibilities(self, tiles: str) -> int:\n        for string in tiles:\n            if string in self.dict_:\n                self.dict_[string]+=1\n            else:\n                self.dict_[string] = 1\n                \n        for key in self.dict_:\n            temp = [key,self.dict_[key]]\n            self.arr.append(temp)\n                \n        #print(self.arr)\n        \n        for i in range(1,len(tiles)+1):\n            self.n = i\n            #print(self.n)\n            self.perm()\n        #self.perm() \n        return self.total\n            \n            \n        \n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        combination_set = self.generateTilePossibilities(tiles)\n        return len(combination_set)\n\n    def generateTilePossibilities(self, tiles: str):\n        n = len(tiles)\n        combination_set = set()\n        for index in range(n):\n            combination_set.add(tiles[index])\n        if n > 1:\n            for index in range(n):\n                tiles_without_n = tiles[0:index] + tiles[index + 1:]\n                additional_combinations = self.generateTilePossibilities(\n                    tiles_without_n)\n                combination_set.add(tiles_without_n)\n                for combination in additional_combinations:\n                    combination_set.add(combination)\n                    for second_index in range(len(combination)):\n                        new_tile_combination = combination[\n                            0:second_index] + tiles[index] + combination[\n                                second_index:]\n                        combination_set.add(new_tile_combination)\n        return combination_set\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        \n        def count(tiles):\n            #print(tiles)\n            counter = set()\n            if len(tiles) == 1:\n                counter.add(tiles)\n            elif len(tiles) == 2:\n                counter.add(tiles)\n                counter.add(tiles[::-1])\n                counter.add(tiles[0])\n                counter.add(tiles[1])\n            else:\n                for idx, i in enumerate(tiles):\n                    x = count(tiles[:idx] + tiles[idx+1:])\n                    extra = set()\n                    for j in x:\n                        extra.add(tiles[idx] + j)\n                        extra.add(j + tiles[idx])\n                        for k in range(1, len(j)-1):\n                            extra.add(j[:k] + tiles[idx] + j[k+1:])\n                    x.update(extra)\n                    counter.update(x)\n            #print(counter)\n            return counter\n        \n        return len(count(tiles))\n", "\nclass Solution:\n    def __init__(self):\n        self.seen = set()\n        self.result = set()\n\n    def numTilePossibilities(self, tiles: str) -> int:\n        self.dfs(tiles, 0, [])\n        return len(self.result) - 1\n\n    def dfs(self, string, idx, path):\n        \n        st = ''.join(path)\n\n        if st not in self.seen:\n            self.result.update((''.join(p) for p in permutations(st)))\n            self.seen.add(st)\n        \n        for i in range(idx, len(string)):\n            self.dfs(string, i + 1, path + [string[i]])", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        d = {}\n        for i in range(len(tiles)):\n            if (tiles[i] in d):\n                d[tiles[i]] += 1\n            else:\n                d[tiles[i]] = 1\n        def countnum(d):\n            if (d == {}):\n                return 0\n            c = 0\n            s = set(d.items())\n            for k, v in s:\n                d[k] -= 1\n                if (d[k] == 0):\n                    del(d[k])\n                c += 1 + countnum(d)\n                if (k in d):\n                    d[k] += 1\n                else:\n                    d[k] = 1\n            return c\n        return countnum(d)\n                \n        \n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        res = set()\n        def dfs(path, t):\n            if path not in res:\n                if path:\n                    res.add(path)\n                for i in range(len(t)):\n                    dfs(path+t[i], t[:i] + t[i+1:])\n                \n        dfs('', tiles)\n        return len(res)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n\n        res = set()\n        def backtrack(path, curr):\n            if path not in res:\n                if path:\n                    res.add(path)\n                for i in range(len(curr)):\n                    backtrack(path + curr[i], curr[:i] + curr[i+1:])\n        \n        backtrack('', tiles)\n        return len(res)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        d=set()\n        for i in range(len(tiles)):\n            for x in list(permutations(tiles,i+1)):\n                d.add(''.join(x))\n        print(d)\n        return len(d)\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        result = set()\n        maxx = len(tiles)\n        def dfs(result,tiles,current_sequence=''):\n            result.add(current_sequence)\n            for t in tiles:\n                tiles_c = tiles.replace(t,'',1)\n                dfs(result,tiles_c,current_sequence+t)\n        dfs(result,tiles)\n        return len(result)-1", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        setter = set()\n        res = []\n        for r in range(1,len(tiles)+1): \n            res.append(list(itertools.permutations(tiles,r)))\n        result = []\n        for re in res: \n            result.append(list(set(re)))\n        leng = 0 \n        for i in result: \n            leng += len(i)\n        return leng            \n", "class Solution:\n    \n    def numTilePossibilities(self, tiles: str) -> int:\n        tile_counts = collections.Counter(tiles)\n        len_counts  = [1] + [0] * len(tiles)\n        \n        for tile in tile_counts:\n            new_len_counts  = [0] * (len(tiles) + 1)\n            num_tiles       = tile_counts[tile]\n            \n            for num_inserted in range(num_tiles + 1):\n                for old_len, old_len_count in enumerate(len_counts):\n                    new_len = old_len + num_inserted\n                    if new_len > len(tiles):\n                        break\n                    num_patterns = math.comb(new_len, num_inserted)\n                    new_len_counts[new_len] += old_len_count * num_patterns\n                    \n            len_counts = new_len_counts\n        \n        return sum(len_counts) - 1\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        result = set()\n        maxx = len(tiles)\n        def dfs(result,tiles,current_sequence=''):\n            if len(current_sequence) <= maxx and current_sequence!='':\n                result.add(current_sequence)\n            for t in tiles:\n                tiles_c = tiles.replace(t,'',1)\n                dfs(result,tiles_c,current_sequence+t)\n        dfs(result,tiles)\n        return len(result)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        result = set()\n        maxx = len(tiles)\n        def dfs(result,tiles,current_sequence=''):\n            if current_sequence!='':\n                result.add(current_sequence)\n            for t in tiles:\n                tiles_c = tiles.replace(t,'',1)\n                dfs(result,tiles_c,current_sequence+t)\n        dfs(result,tiles)\n        return len(result)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        count = {}\n        \n        for i in tiles:\n            if i not in count:\n                count[i] = 0\n            count[i]+=1\n        \n        op = set()\n        for ch in count:\n            tempString = ch\n            op.add(tempString)\n            count[ch]-=1\n            tempCount = count.copy()\n            buildString(tempString,tempCount,op)\n            count[ch]+=1\n            \n        return len(op)\n            \ndef buildString(currString,count,op):\n    flag = True\n    for i in count:\n        if count[i]!=0:\n            flag = False\n            break\n    if flag:\n        return\n    \n    for ch in count:\n        if count[ch]==0:\n            continue\n        tempString = currString\n        tempString+=ch\n        \n        op.add(tempString)\n        count[ch]-=1\n        \n        tempCount = count.copy()\n        buildString(tempString,tempCount,op)\n        count[ch]+=1\n        \n        \n        \n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def dfs(state):\n            res.append(state.copy())\n            for i in range(len(state)):\n                if state[i]<full_state[i]:\n                    state[i] += 1\n                    dfs(state)\n                    state[i] -= 1\n        \n        memo = collections.Counter(tiles)\n        full_state = list(memo.values())\n        state = [0 for _ in range(len(memo))]\n        res = []\n        dfs(state)\n        return len(res)-1", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        res = {}\n        def dfs(seq, tiles):\n            if seq not in res and seq != '':\n                res[seq] = 1\n            for i in range(len(tiles)):\n                dfs(seq+tiles[i], tiles[:i]+tiles[i+1:])\n        dfs('', tiles)\n        return len(res)\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def dfs(path, t):\n            if path:\n                result.add(path)\n                \n            for i in range(len(t)):\n                dfs(path + t[i], t[:i]+t[i+1:])\n        \n        result = set()\n        dfs('', tiles)\n        return len(result)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def backtracking(idx=0,seq='',remaining=tiles):\n            for i, tile in enumerate(remaining):\n                res.add(seq+tile)\n                backtracking(idx+1, seq+tile, remaining[:i]+remaining[i+1:])\n                \n        res = set()\n        backtracking()\n        return len(res)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def dfs(elements):\n            if prev_elements:\n                result.add(''.join(prev_elements))\n            \n            for e in elements:\n                next_elements = elements[:]\n                next_elements.remove(e)\n                \n                prev_elements.append(e)\n                dfs(next_elements)\n                prev_elements.pop()\n            \n        result = set()\n        prev_elements = []\n        \n        dfs(list(tiles))\n        \n        return len(result)\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        seqs = set()\n        visits = [False] * len(tiles)\n\n        def dfs(seq: str, depth: int):\n            if seq:\n                seqs.add(seq)\n            if depth == len(tiles) - 1:\n                return\n\n            for i in range(len(tiles)):\n                if not visits[i]:\n                    visits[i] = True\n                    dfs(seq + tiles[i], depth + 1)\n                    visits[i] = False\n\n        dfs('', -1)\n        return len(seqs)", "class Solution:\n    def get_permute(self, opts, cur_sol):\n        for i in range(len(opts)):\n            c = opts[i]\n            cur_sol.append(c)\n            self.solutions.add(''.join(cur_sol))\n            opts2 = opts\n            opts2 = opts2[:i] + opts2[i+1:]\n            self.get_permute(opts2, cur_sol)\n            cur_sol.pop()\n        \n    def numTilePossibilities(self, tiles: str) -> int:\n        self.solutions = set()\n        self.get_permute(tiles, [])\n        return len(self.solutions)", "# This is a mathematical problem.\n# Get the frequencies of different characters [f_0, f_1, ..., f_n].\n# For each possible choice of frequency [i_0, i_1, ..., i_n] (0 <= i_k <= f_k, k = 0, 1, ..., n),\n# the number of distinct sequences is (i_0 + i_1 + ... + i_n)! / ( i_0! * i_1! * ... * i_n!).\n\n# To get numbers of occurrences you can just run\n\n#         freq = count.values()\n# for this problem you only need to iterate over freq, so you don't even need to convert it to list.\n# Kind of depends on your taste, but for calculating digits you have the option of using divmod:\n\n#             for f in freq:\n#                 i, mod = divmod(i, f + 1)\n#                 digits.append(mod)\n\n\n\nimport collections, math\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        freq = collections.Counter(tiles)\n        prod = 1\n        for f in freq.values():\n            prod *= f + 1\n        res = 0\n        for i in range(1, prod):\n            digits = []\n            for f in freq.values():\n                digits.append(i % (f + 1))\n                i = i // (f + 1)\n            tmp = math.factorial(sum(digits))\n            for d in digits:\n                tmp //= math.factorial(d)\n            res += tmp\n        return res", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        result = set()\n        vis = [0]*len(tiles)\n        \n        def dfs(res,depth):\n            if res:\n                result.add(res)\n            if depth == len(tiles)-1:\n                result.add(res)\n            \n            for i in range(len(tiles)):\n                if not vis[i]:\n                    vis[i] = 1\n                    dfs(res+tiles[i],depth+1)\n                    vis[i] = 0\n        \n        dfs('',-1)\n        return len(result)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def solve(s,visited):\n            seen.add(s)\n            if len(s) == len(tiles):return 0\n            for i , v in enumerate(tiles):\n                if i not in visited:\n                    solve(s + v,visited | {i})\n            return len(seen)\n        seen = set()\n        return solve('',set()) - 1\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        result = set()\n        \n        def dfs_helper(path, t):\n            if path:\n                result.add(path)\n            for i in range(len(t)):\n                dfs_helper(path + t[i], t[:i] + t[i+1:])\n          \n        dfs_helper('',tiles)\n        return len(result)\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        ans = 0\n        s = set()\n        def tot(curr, rem):\n            nonlocal s    \n            if curr[-1]:\n                s.add(tuple(curr[-1]))\n            for i in range(len(rem)):\n                    el = curr[-1]\n                    if rem[i] == el:\n                        continue\n                    tot(curr+[el + [rem[i]]], rem[:i] + rem[i+1:])\n        tot([[]], tiles)\n        return len(s)", "class Solution:\n    \n    def subsets(self, tiles, buff, buff_index, boolean, s):\n        if tuple(buff[:buff_index]) not in s:  \n            # print(buff[:buff_index])\n            s.add(tuple(buff[:buff_index]))\n            self.count += 1\n        if len(buff) == buff_index: return  \n        \n        for i in range(0, len(tiles)):\n            if not boolean[i]:\n                buff[buff_index] = tiles[i]\n                boolean[i] = True\n                self.subsets(tiles, buff, buff_index+1, boolean, s)\n                boolean[i] = False\n                \n    def numTilePossibilities(self, tiles: str) -> int:\n        self.count = 0\n        buff = [None]*len(tiles)\n        boolean = [False]*len(tiles)\n        s = set()\n        self.subsets(tiles, buff, 0, boolean, s)\n        return self.count-1\n        \n", "class Solution:\n    def numTilePossibilities(self, tiles):\n        res=set()\n        \n        def helper(t,curr,k):\n            if k==len(curr):\n                res.add(curr)\n                return # return so that the loop below doesn't continue when you meet the length requirement\n            \n            for i in range(len(t)):\n                # call helper with everything but the current value\n                helper(t[:i]+t[i+1:], curr+t[i], k)\n                \n        # start at size 1 and move until size len(tiles), +1 because range doesn't include the endpoint\n        for i in range(1,len(tiles)+1):\n            helper(tiles,'',i)\n            \n        return((len(res)))     \n", "class Solution:\n\n    def make_tile(self, curr, used, letters, size):\n        \n        if len(curr) == size:\n            \n            # print(curr)\n            \n            self.res += 1\n            \n            return\n        \n        i = 0\n            \n        while i < len(letters):\n            \n            if i not in used:\n                \n                used.add(i)\n            \n                curr.append(letters[i])\n\n                self.make_tile(curr, used, letters, size)\n\n                curr.pop(-1)\n\n                used.remove(i)\n                \n                while i + 1 < len(letters) and letters[i] == letters[i + 1]:\n\n                    i += 1\n                \n            i += 1\n            \n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        self.res = 0\n        \n        letters = sorted(tiles)\n        \n        for size in range(1, len(tiles) + 1):\n            \n            self.make_tile([], set(), letters, size)\n            \n        return self.res", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def next_permutation(a):\n            for i in range(len(a) - 1, 0, -1):\n                if a[i] > a[i - 1]:\n                    ps = i\n                    for j in range(i + 1, len(a)):\n                        if a[j] > a[i - 1] and a[ps] > a[j]:\n                            ps = j\n                    a[ps], a[i - 1] = a[i - 1], a[ps]\n                    p1 = i\n                    p2 = len(a) - 1\n                    while p1 < p2:\n                        a[p1], a[p2] = a[p2], a[p1]\n                        p1 += 1\n                        p2 -= 1\n                    return True\n            return False\n                    \n        n = 1\n        for i in range(1, len(tiles) + 1):\n            n *= i\n        a = set()\n        perm = []\n        for i in range(len(tiles)):\n            perm.append(i)\n        for _ in range(n):\n            cur = ''\n            for i in range(len(tiles)):\n                cur += tiles[perm[i]]\n            for i in range(len(tiles)):\n                a.add(cur[:i + 1])\n            next_permutation(perm)\n        return len(a)", "from collections import Counter\n\nclass Solution:\n    def __init__(self):\n        self.sum_ = 0\n        \n    def recurse_count(self, letter_count):\n        if len(letter_count)==0:\n            return            \n        for letter in letter_count:\n            self.recurse_count(letter_count - Counter(letter))\n            self.sum_ += 1\n        return\n    \n    def numTilePossibilities(self, tiles: str) -> int:\n        letter_count = Counter(tiles)\n        self.recurse_count(letter_count)\n        return self.sum_            ", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n\n        \n        def recur(tiles):\n            if not tiles: return set()\n            ans = set()\n            temp = ''\n            while tiles:\n                v = tiles[0]\n                ans.add(v)\n                new = recur(temp+tiles[1:])\n                ans.update(new)\n                for k in new: ans.add(v+k)\n                temp+=tiles[0]\n                tiles = tiles[1:]\n            return ans\n            \n        ans = recur(tiles)\n        # print(ans)\n        return len(ans)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        #sequence can be of length 0 to len(tiles)\n        result = set()   \n        def backtrack(left_tiles, curr_seq):#k is our desired length \n            if len(curr_seq) == k:#reached our desired length \n                result.add(''.join(curr_seq))\n                return \n            else:\n                for i in range(len(left_tiles)):\n                    curr_seq.append(left_tiles[i])\n                    backtrack(left_tiles[:i] + left_tiles[i+1:], curr_seq)\n                    curr_seq.pop()\n                    \n                    \n        for k in range(1, len(tiles)+1):\n            backtrack(tiles, [])\n        return len(result)\n\n                    \n\n                \n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n\n        \n        def recur(tiles):\n            if not tiles: return set()\n            ans = set()\n            for i,v in enumerate(tiles):\n                ans.add(v)\n                new = recur(tiles[:i]+tiles[i+1:])\n                ans.update(new)\n                for k in new: ans.add(v+k)\n            return ans\n            \n        ans = recur(tiles)\n        # print(ans)\n        return len(ans)", "class Solution:\n    def counts(self, collect):\n        answer = 1\n        for char in collect:\n            if collect[char]:\n                answer += self.counts(collect - collections.Counter(char))\n        return answer\n    def numTilePossibilities(self, c):\n        return self.counts(collections.Counter(c)) - 1    ", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        tiles = ''.join(sorted(tiles))\n        memo = {}\n        def helper(s, k):\n            if (s, k) not in memo:\n                if k == 0:\n                    memo[(s,k)] = 1\n                else:\n                    last, ans = '', 0\n                    for i in range(len(s)):\n                        if s[i] != last:\n                            last = s[i]\n                            ans += helper(s[:i]+s[i+1:], k-1)\n                    memo[(s,k)] = ans\n            return memo[(s,k)]\n\n        ret = 0\n        for k in range(1, len(tiles)+1):\n            ret += helper(tiles, k)\n        return ret", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def perm(k, a):\n            if k == 0:\n                return []\n            elif k == 1:\n                return [x for x in a]\n            else:\n                return [a[i] + y for i in range(len(a)) for y in perm(k-1, a[:i] + a[i+1:])]\n        \n        out = set()\n        for i in range(1, len(tiles)+1):\n            for x in perm(i, tiles):\n                out.add(x)\n        \n        return len(out)\n    \n\n# complexity: N = len(t), N*N!\n# space complexity: O(N!)\n", "from collections import Counter\n\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n\n        counter = Counter(tiles)\n        \n        def dfs(counter):\n            result = len(counter)\n            print(result)\n            \n            for character in counter:\n                temp = counter.copy()\n                if temp[character] == 1:\n                    del temp[character]\n                else:\n                    temp[character] -= 1\n                \n                result += dfs(temp)\n            \n            return result\n        \n        result = dfs(counter)\n        \n        return result\n            \n            \n        \n        \n        \n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        output = set()\n        \n        def helper(result, options):\n            if not options:\n                return\n            for idx, o in enumerate(options):\n                tmp = options[:]\n                tmp.pop(idx)\n                output.add(''.join(result + [o]))\n                helper(result + [o], tmp)\n            \n        helper([], list(tiles))\n        \n        return len(output)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def helper(curr, tiles):\n            for i in range(len(tiles)):\n                curr.append(tiles[i])\n                pos.add(str(curr))\n                c = tiles.copy()\n                c.pop(i)\n                helper(curr.copy(), c)\n                curr.pop()\n            \n        tiles = list(tiles)\n        pos = set()\n                \n        helper([], tiles)\n        return len(pos)\n        \n                \n            \n            \n", "class Solution:\n    def poss(self, tiles:str) -> set:\n        if len(tiles) == 1:\n            return set([tiles[0]])\n        output = set()\n        for i in range(len(tiles)):\n            elem = tiles[i]\n            res = self.poss(tiles[:i]+tiles[i+1:])\n            output = output.union(res)\n            for elem in res:\n                output.add(tiles[i]+elem)\n        return output\n            \n    \n    def numTilePossibilities(self, tiles: str) -> int:\n        if len(tiles) == 0:\n            return 0\n        return len(self.poss(tiles))", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        seen = set()\n        ans = set()\n        \n        \n        \n        def backtrack(tiles,seen,curr):\n            if curr != '' and curr not in ans:\n                ans.add(curr)\n                \n            for i in range(len(tiles)):\n                if i not in seen:\n                    seen.add(i)\n                    backtrack(tiles,seen,curr+tiles[i])\n                    seen.remove(i)\n\n        backtrack(tiles,seen,'')\n        return len(ans)", "from itertools import permutations\n\n\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        total = 0\n        for size in range(1, len(tiles) + 1):\n            total += len(set(permutations(tiles, size)))\n            \n        return total\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        def backtrack(i, c):\n            if i == n:\n                return\n            \n            for k in c:\n                if c[k] > 0:\n                    self.ans += 1\n                    backtrack(i + 1, c - Counter(k))\n            \n                    \n            \n            \n        n = len(tiles)\n        counter = Counter(tiles)\n        self.ans = 0\n        backtrack(0, counter)\n        return self.ans\n", "class Solution:\n    def __init__(self):\n        self.res = set()\n        \n    def backtrack(self,tiles,curr,indices):\n        \n        for i in range(len(tiles)):\n            if i not in set(indices):\n                curr+=tiles[i]\n                indices.append(i)\n                self.res.add(curr)\n                \n                if len(curr)<len(tiles):\n                    self.backtrack(tiles,curr,indices)\n                curr = curr[:-1]\n                indices.pop()\n                \n                \n        \n        \n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        self.backtrack(tiles,'',[])\n        \n        return len(self.res)", "def possible(tiles):\n    variants = set()\n    if len(tiles) == 1:\n        variants.add(tiles[0])\n    else:\n        for i in range(len(tiles)):\n            t = possible(tiles[:i]+tiles[i+1:])\n            variants.update(t)\n            for j in t:\n                variants.add(tiles[i]+j)\n    return variants\n    \n\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        return len(possible(tiles))\n        \n            \n", "from itertools import combinations as C\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        num = 0\n        for i in range(1, len(tiles)+1):\n            l = set(permutations(tiles, i))\n            num += len(l)\n        return num", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        if len(tiles) < 2:\n            return len(tiles)\n        nodes = []\n        for letter in tiles:\n            nodes.append(Node(letter))\n        for node in nodes:\n            for other_node in nodes:\n                if node != other_node:\n                    node.edges.append(other_node)\n        paths = set()\n        seen = set()\n        for node in nodes:\n            self.backtrack(node, seen, node.char, paths)\n        print(paths)\n        return len(paths)\n        \n    def backtrack(self, node, seen: set, path: str, paths: set):\n        if node in seen:\n            return\n        path += node.char\n        if path and path not in paths:\n            paths.add(path)\n        for neighbor in node.edges:\n            seen.add(node)\n            self.backtrack(neighbor, seen, path, paths)\n            seen.remove(node)\n        \nclass Node:\n    def __init__(self, char: str):\n        self.char = char\n        self.edges = []", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        possibilities = set()\n        \n        def swap(arr, l, r):\n            if l == r: return\n            arr[l], arr[r] = arr[r], arr[l]\n        \n        def add_permutation(arr):\n            nonlocal possibilities\n            \n            for i in range(len(arr)):\n                possibilities.add(''.join(arr[:i+1]))\n        \n        def build_permutations(arr, start = 0):\n            \n            if start >= len(arr):\n                add_permutation(arr)\n                return\n            \n            for i in range(start, len(arr)):\n                swap(arr, i, start)\n                build_permutations(arr, start + 1)\n                swap(arr, i, start)\n        \n        build_permutations(list(tiles))\n        return len(possibilities)", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        if len(tiles) < 2:\n            return len(tiles)\n        nodes = []\n        for letter in tiles:\n            nodes.append(Node(letter))\n        for node in nodes:\n            for other_node in nodes:\n                if node != other_node:\n                    node.edges.append(other_node)\n        paths = set()\n        seen = set()\n        for node in nodes:\n            self.backtrack(node, seen, node.char, paths)\n        return len(paths)\n        \n    def backtrack(self, node, seen: set, path: str, paths: set):\n        if node in seen:\n            return\n        path += node.char\n        if path and path not in paths:\n            paths.add(path)\n        for neighbor in node.edges:\n            seen.add(node)\n            self.backtrack(neighbor, seen, path, paths)\n            seen.remove(node)\n        \nclass Node:\n    def __init__(self, char: str):\n        self.char = char\n        self.edges = []", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        count=0\n        for i in range(1,len(tiles)+1):\n            count+=len(set(permutations(tiles,i)))\n        return count", "class Solution:\n    result = 0\n    \n    def numTilePossibilities(self, tiles: str) -> int:\n        counter = Counter(tiles)\n        self.dfs(counter, [])\n        return self.result\n        \n    def dfs(self, counter, curr):\n        if curr:\n            self.result += 1\n        for x in counter:\n            curr1 = curr.copy()\n            counter1 = counter.copy()\n            curr1.append(x)\n            counter1[x] -= 1\n            if counter1[x] == 0:\n                del counter1[x]\n            self.dfs(counter1, curr1)    \n", "class Solution:\n    def numTilePossibilities(self, s: str) -> int:\n        ans, C = 0, Counter(s)                \n        def dfs(C, cur):\n            nonlocal ans\n            if cur: ans += 1\n            if not C: return\n            C1 = C.copy()\n            for x in C:\n                cur.append(x); C1[x] -= 1\n                if C1[x] == 0: del C1[x]\n                dfs(C1, cur)\n                cur.pop(); C1[x] += 1        \n        dfs(C, cur=[])\n        return ans", "class Solution:\n    memos = dict()\n    \n    def numTilePossibilities(self, tiles: str) -> int:\n        tiles = ''.join(sorted(tiles))\n        uniques = self.step(tiles)\n        return len(uniques) - 1\n    \n    def step(self, tiles: str) -> set:\n        if len(tiles) == 0:\n            return {''}\n        if tiles not in self.memos:\n            uniques = set()\n            for i in range(len(tiles)):\n                c = tiles[i]\n                substr = tiles[:i] + tiles[i + 1:]\n                substrs_set = self.step(substr)\n                for substr in substrs_set:\n                    uniques.add(substr)\n                    for j in range(len(substr) + 1):\n                        new_str = substr[:j] + c + substr[j:]\n                        uniques.add(new_str)\n            self.memos[tiles] = uniques\n        return self.memos[tiles]\n", "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        res = set()\n\n        def seq(s, l):\n            if len(l) == 0:\n                res.add(s)\n                return\n            seq(s, l[1 : ])\n            for i in range(len(l)):\n                seq(s + l[i], l[ : i] + l[i + 1 : ])\n\n        seq('', list(tiles))\n\n        return len(res) - 1", "from collections import Counter\n\nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \n        def permutation(num, tiles_counter):\n            if num == 1:\n                return len(list(tiles_counter))\n            rs = 0\n            for c in +tiles_counter:\n                rs += permutation(num-1, tiles_counter - Counter({c:1}))\n            return rs\n        \n        \n        total = 0\n        for i in range(1, len(tiles) + 1):\n            total += permutation(i, Counter(tiles))\n            \n            \n    \n        return total"]
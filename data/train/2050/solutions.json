["\"\"\"\nCodeforces Contest 260 Div 1 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef main():\n    n,k = read()\n    s = set()\n    for i in range(n): s.add(read(0))\n    s = list(s)\n    s.sort()\n    s = treeify(s)\n    res = solve(s)\n    if res == 0: # neither: second player win\n        print(\"Second\")\n    if res == 1: # odd: first player win if k is odd\n        print(\"First\" if k % 2 else \"Second\")\n    if res == 2: # even: second player win\n        print(\"Second\")\n    if res == 3: # both: first player win\n        print(\"First\")\n\ndef treeify(s):\n    res = [[] for _ in range(26)]\n    for i in s:\n        if i: res[ord(i[0]) - 97].append(i[1:])\n    fin = []\n    for i in range(26):\n        if res[i]: fin.append(treeify(res[i]))\n    return fin\n\ndef solve(s, parity=2):\n    for i in range(len(s)):\n        if isinstance(s[i], list): s[i] = solve(s[i], 3-parity)\n    if not s: return parity # no possible move: current parity\n    if 0 in s: return 3 # any neither: both\n    if 1 in s and 2 in s: return 3 # any odd and any even: both\n    if 1 in s: return 1 # any odd: odd\n    if 2 in s: return 2 # any even: even\n    return 0 # all both: neither\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return map(int, inputs.split())\n\ndef write(s=\"\\n\"):\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nmain()", "N = 100000\nZ = 26\n\n#\u522b\u7528\u8fd9\u73a9\u610f\u513f: trie = [[0] * Z] * N \u5de8\u5751\uff01https://www.cnblogs.com/PyLearn/p/7795552.html\n\ntrie = [[0 for i in range(Z)] for j in range(N)]\nn = 0\nk = 0\nnodeNum = 0\n\ndef insertNode():\n\tu = 0\n\tstring = input()\n\tnonlocal nodeNum\n\t\n\tfor i in range(len(string)):\n\t\tc = ord(string[i]) - ord('a')\n\t\tif trie[u][c] == 0:\n\t\t\tnodeNum += 1\n\t\t\ttrie[u][c] = nodeNum\t\n\t\tu = trie[u][c]\n\t\t# print(u)\n\t\nstateWin = [False for i in range(N)]\t\nstateLose = [False for i in range(N)]\t\n\t\ndef dfs(u):\n\tleaf = True\n\tfor c in range(Z):\n\t\tif (trie[u][c]) != 0:\n\t\t\tleaf = False\n\t\t\tdfs(trie[u][c])\n\t\t\tstateWin[u] |= (not(stateWin[trie[u][c]]))\n\t\t\tstateLose[u] |= (not(stateLose[trie[u][c]]))\n\tif leaf == True:\n\t\tstateWin[u] = False\n\t\tstateLose[u] = True\n\nn,k = map(int,input().split())\n\nfor i in range(n):\n\tinsertNode()\n\ndfs(0)\n\n\n# print(stateWin[0])\n# print(stateLose[0])\n\nif (stateWin[0] and (stateLose[0] or (k % 2 == 1) )):\n\tprint(\"First\")\nelse:\n\tprint(\"Second\")", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2/11/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef make_trie(A):\n    trie = {}\n    for word in A:\n        t = trie\n        for w in word:\n            if w not in t:\n                t[w] = {}\n            t = t[w]\n        # t['#'] = True\n    \n    return trie\n\n\ndef game(trie):\n    if not trie:\n        return False\n    \n    return not all([game(t) for k, t in trie.items()])\n\n\ndef can_lose(trie):\n    if not trie:\n        return True\n    \n    return any([not can_lose(t) for k, t in trie.items()])\n\n\ndef solve(N, K, A):\n    trie = make_trie(A)\n    win = game(trie)\n    \n    if not win:\n        return False\n    \n    if K == 1:\n        return True\n    \n    if can_lose(trie):\n        return True\n    \n    return K % 2 == 1\n    \n    \nN, K = map(int, input().split())\nA = []\nfor i in range(N):\n    s = input()\n    A.append(s)\n    \nprint('First' if solve(N, K, A) else 'Second')", "# https://codeforces.com/contest/455/problem/B\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\n\nclass Trie:\n\n    def __init__(self):\n        self.arr = {}\n\n    def insert(self, word):\n        root = self\n        for x in word:\n            if x not in root.arr:\n                root.arr[x] = Trie()\n            root = root.arr[x]\n\n    def dfs(self):\n        if not len(self.arr):\n            return False, True\n        win, lose = False, False\n        for x in self.arr:\n            w, l = self.arr[x].dfs()\n            win = win or not w\n            lose = lose or not l\n        return win, lose\n\ndef answer(flag):\n    print(\"First\" if flag else \"Second\")\n\nT = Trie()\nn, k = list(map(int, input().split()))\nfor _ in range(n):\n    T.insert(input())\nwin, lose = T.dfs()\n\nif k == 1:\n    answer(win)\nelif not win:\n    answer(win)\nelif lose:\n    answer(win)\nelif k&1:\n    answer(win)\nelse:\n    answer(not win)\n", "# https://codeforces.com/contest/455/problem/B\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\n\nclass Trie:\n\n    def __init__(self):\n        self.arr = {}\n\n    def insert(self, word):\n        for x in word:\n            if x not in self.arr:\n                self.arr[x] = Trie()\n            self = self.arr[x]\n\n    def dfs(self):\n        if not len(self.arr):\n            return False, True\n        win, lose = False, False\n        for x in self.arr:\n            w, l = self.arr[x].dfs()\n            win = win or not w\n            lose = lose or not l\n        return win, lose\n\ndef answer(flag):\n    print(\"First\" if flag else \"Second\")\n\nT = Trie()\nn, k = list(map(int, input().split()))\nfor _ in range(n):\n    T.insert(input())\nwin, lose = T.dfs()\n\nif k == 1 or (not win) or lose or k&1:\n    answer(win)\nelse:\n    answer(not win)\n", "import math\nimport sys\nfrom itertools import permutations\ninput = sys.stdin.readline\n\n\nclass Node:\n\n    def __init__(self):\n        self.children = [None]*26\n        self.isEnd = False\n        self.win = False\n        self.lose = False\n\nclass Trie:\n\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, key):\n        cur = self.root\n        for i in range(len(key)):\n            if cur.children[ord(key[i])-ord('a')]==None:\n                cur.children[ord(key[i])-ord('a')]=Node()\n            cur = cur.children[ord(key[i])-ord('a')]\n        \n        cur.isEnd = True\n    \n    def search(self, key):\n        cur = self.root\n        for i in range(len(key)):\n            if cur.children[ord(key[i])-ord('a')]==None:\n                return False\n            cur = cur.children[ord(key[i])-ord('a')]\n        \n        if cur!=None and cur.isEnd:\n            return True\n\n        return False\n    \n    def assignWin(self, cur):\n        \n        flag = True\n        for i in range(26):\n            if cur.children[i]!=None:\n                flag=False\n                self.assignWin(cur.children[i])\n        \n        if flag:\n            cur.win=False\n            cur.lose=True\n        else:\n            for i in range(26):\n                if cur.children[i]!=None:\n                    cur.win = cur.win or (not cur.children[i].win)\n                    cur.lose = cur.lose or (not cur.children[i].lose)\n       \n\ndef __starting_point():\n    \n    t=Trie()\n\n    n,k=list(map(int,input().split()))\n    for i in range(n):\n        s=input()\n        if s[-1]==\"\\n\":\n            s= s[:-1]\n        t.insert(s)\n    \n    t.assignWin(t.root)\n    \n    if not t.root.win:\n        print(\"Second\")\n    else:\n        if t.root.lose:\n            print(\"First\")\n        else:\n            if k%2==1:\n                print(\"First\")\n            else:\n                print(\"Second\")\n\n__starting_point()", "from sys import stdin, setrecursionlimit\n\nsetrecursionlimit(200000)\n\nn,k = [int(x) for x in stdin.readline().split()]\n\ntree = {}\n\nfor x in range(n):\n  s = stdin.readline().strip()\n\n  cur = tree\n  \n  for x in s:\n    if not x in cur:\n      cur[x] = {}\n\n    cur = cur[x]\n\ndef forced(tree):\n  if not tree:\n    return (False,True)\n  else:\n    win = False\n    lose = False\n    for x in tree:\n      a,b = forced(tree[x])\n      if not a:\n        win = True\n      if not b:\n        lose = True\n    return (win,lose)\n\na,b = forced(tree)\n\nif a == 0:\n  print('Second')\nelif a == 1 and b == 1:\n  print('First')\nelse:\n  if k%2 == 0:\n    print('Second')\n  else:\n    print('First')\n"]
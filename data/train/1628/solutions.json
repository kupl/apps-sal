["def proper_fractions(n):\n    phi = n > 1 and n\n    for p in range(2, int(n ** .5) + 1):\n        if not n % p:\n            phi -= phi // p\n            while not n % p:\n                n //= p\n    if n > 1: phi -= phi // n\n    return phi", "def proper_fractions(n):\n    #find all prime factors (without repetitions) of n\n    factors=set()\n    i=2\n    input=n\n    while i*i<=input:\n        if input%i==0:\n            factors.add(i)\n            input=input//i\n        else:\n            i=i+1\n    factors.add(input)\n    #use Euler totient formula to find the amount of numbers coprime to n that are smaller than n\n    result=n\n    for j in factors:\n        result=result*(1-(1/j))\n    return int(result)\n            \n", "def euler(n):\n    res = 1.0*n\n    p = 2\n    while p*p <= n:\n        if n%p == 0:\n            while n%p == 0:\n                n = n/p\n            res *= (1.0 - (1.0/p) )\n        p += 1\n    \n    if n > 1:\n        res *= (1.0 - (1.0/n) )\n    \n    return int(res)\n\ndef proper_fractions(d):\n    if d == 1:\n        return 0\n    return euler(d)", "def proper_fractions(n):\n    phi = n > 1 and n\n    for p in range(2, int(n ** 0.5) + 1):\n        if not n % p:\n            phi -= phi // p\n            while not n % p:\n                n //= p\n    if n > 1: phi -= phi // n\n    return phi", "from fractions import Fraction\n\n# Euler's totient function\n# Prime factors search can be easily optimize but it's already really fast anyway\ndef proper_fractions(n):\n    res = Fraction(n)\n    for i in range(2, int(n**0.5)+1):\n        if n%i: continue\n        while not n%i: n //= i\n        res *= Fraction(i-1, i)\n        if n == 1: break\n    else: res *= Fraction(n-1, n)\n    return res", "def proper_fractions(n):\n    if n<3: return n-1\n    s,t,i =[],1,2\n    while True:\n        while n%i==0:t,s,n= t*(i if i in s else i-1),s+[i],n//i\n        if i*i > n:return t*(n-1) if n>1 else t\n        i+=1", "import math;\n\ndef Factor(n):\n    a, d = [], 2;\n    while d * d <= n:\n        if n % d == 0:\n            a.append(d);\n            n //= d;\n        else:\n           d += 1;\n    if n > 1:\n       a.append(n);\n    return a;\n\ndef proper_fractions(n):\n    if(n == 1):\n        return 0;\n    used, k = [], 1;\n    for i in Factor(n):\n        if(i not in used):\n            used.append(i);\n            k *= math.pow(i, Factor(n).count(i)) - math.pow(i, Factor(n).count(i) - 1);\n    return k;", "def unique_prime_factors(n): # Generate only one instance of each prime factor, save time ^_^\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef proper_fractions(n):\n    if n == 1:\n        return 0\n    output = n\n    for p in unique_prime_factors(n): # We can now use Euler's totient function to solve directly!\n        output //= p\n        output *= (p-1)\n    return output", "import math\ndef proper_fractions(n) : \n    divisors,final,unique,i  = [],[],[],1\n    while i <= math.sqrt(n):          \n        if (n % i == 0) : \n            if (n / i == i) :divisors.append(i)                 \n            else :divisors.extend([i , n/i])                \n        i = i + 1\n    divisors.sort()\n    if len(divisors)<=2:return n-1\n    divisors.pop(0),divisors.pop()    \n    for num,item in enumerate(divisors):\n        for x in divisors[0:num]:\n            if not(item%x):break\n        else:unique.append(item)\n\n    for num,item in enumerate(unique):\n        cache = n/item\n        for x in unique[0:num]:\n            cache = cache-(cache/x)\n        final.append(cache)\n    return(n-sum(final))", "def proper_fractions(n):\n    if n == 1: return 0\n    res = n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            while n % i == 0:\n                n /= i\n            res -= res / i\n        i += 1\n    if n > 1:\n        res -= res / n\n    return int(res)\n"]
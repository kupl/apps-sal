["from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        start_k = 0\n        start = 0\n        elem_dict = defaultdict(int)\n        \n        ans = 0\n        \n        for elem in A:\n            elem_dict[elem] += 1\n            \n            if len(elem_dict) > K:\n                del elem_dict[A[start_k]]\n                start_k+=1\n                start = start_k\n                \n                \n            if len(elem_dict) == K:\n                while elem_dict[A[start_k]] > 1:\n                    elem_dict[A[start_k]]-=1\n                    start_k+=1\n                    \n                ans = ans + start_k - start + 1\n                \n        return ans\n                \n                \n                \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        if K > len(A):\n            return 0\n\n        result = checker = windowStart = 0\n        hashMap = {}\n        a_length = len(A)\n\n        for windowEnd in range(a_length):\n            curr_str = A[windowEnd]\n            \n            if curr_str in hashMap:\n                hashMap[curr_str] += 1\n            else:\n                hashMap[curr_str] = 1\n\n            if len(hashMap) > K:\n                del hashMap[A[checker]]\n                checker += 1\n                windowStart = checker\n            if len(hashMap) == K:\n                while hashMap[A[checker]] > 1:\n                    hashMap[A[checker]] -= 1\n                    checker += 1\n                result += checker - windowStart +1\n        return result", "from collections import OrderedDict\n\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        counter = OrderedDict()\n        \n        count = 0\n        j = 0\n        for i, n in enumerate(A):\n            counter[n] = i\n            counter.move_to_end(n)\n            \n            while len(counter) > K:\n                j = counter.popitem(last=False)[1] + 1\n                \n            if len(counter) == K:\n                count += next(iter(counter.values())) - j + 1\n                \n        return count", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        # seems like you need 3 pointers, shink from either side\n        ans, ctr, lb, count = 0, {}, 0, 0\n        for i, val in enumerate(A): \n            if val not in ctr: \n                ctr[val] = 0\n            ctr[val] += 1\n            \n            # try to code it up first    \n            while len(ctr) > K:\n                ctr[A[lb]] -= 1\n                if ctr[A[lb]] == 0: \n                    del ctr[A[lb]]\n                lb += 1\n    \n            if len(ctr) == K: \n                p2, count, ctr1 = lb, 0, collections.Counter()\n                while len(ctr) == K:\n                    count += 1\n                    ctr[A[p2]] -=1\n                    if ctr[A[p2]] == 0:\n                        del ctr[A[p2]]\n                    ctr1[A[p2]] += 1\n                    p2 += 1\n                ans += count\n                for k, v in ctr1.items(): \n                    # recover step, kind of lame\n                    ctr[k] = ctr.get(k, 0) + v\n        return ans\n                \nclass Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n\n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n\nclass Solution(object):\n    def subarraysWithKDistinct(self, A, K):\n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n\n        for right, x in enumerate(A):\n            window1.add(x)\n            window2.add(x)\n\n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n\n            ans += left2 - left1\n\n        return ans", "class Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n\n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n\nclass Solution(object):\n    def subarraysWithKDistinct(self, A, K):\n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n\n        for right, x in enumerate(A):\n            window1.add(x)\n            window2.add(x)\n\n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n\n            ans += left2 - left1\n\n        return ans", "# class Solution:\n#     def subarraysWithKDistinct(self, s: List[int], k: int) -> int:\n#         # [1,2,1,2,3], K=2\n#         #  ^\n#         #    ^\n#         #  3\n#         n=len(s)\n#         if n<k:\n#             return 0\n        \n#         if k==0:\n#             return 1\n        \n#         seen={}\n#         cnt=0\n        \n#         i=0\n#         j=0\n        \n#         while i<n and j<n:\n#             if s[j] not in seen:\n#                 seen[s[j]]=1\n#             else:\n#                 seen[s[j]]+=1\n            \n#             while len(seen)>k:\n#                 seen[s[i]]-=1\n#                 if not seen[s[i]]:\n#                     del seen[s[i]]\n#                 i+=1\n                \n#             seen1=seen.copy()\n#             i1=i   \n#             while len(seen1)==k:\n#                 cnt+=1\n#                 seen1[s[i1]]-=1\n#                 if not seen1[s[i1]]:\n#                     del seen1[s[i1]]\n#                 i1+=1\n                \n#             j+=1\n\n#         return cnt\nclass Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n\n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n\nclass Solution(object):\n    def subarraysWithKDistinct(self, A, K):\n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n\n        for right, x in enumerate(A):\n            window1.add(x)\n            window2.add(x)\n\n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n\n            ans += left2 - left1\n\n        return ans                \n                    \n                \n                \n            \n        \n        \n        \n        \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        from collections import Counter\n        def atMost(k):\n            count = Counter()\n            ans = i = 0\n            for j in range(len(A)):\n                if not count[A[j]]:\n                    k -= 1\n                count[A[j]] += 1\n                while k < 0:\n                    count[A[i]] -= 1\n                    if not count[A[i]]:\n                        k += 1\n                    i += 1\n                ans += j - i + 1\n            return ans\n        return atMost(K) - atMost(K - 1)", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        one = self.atMostK(A, K)\n        two = self.atMostK(A, K-1)\n        print((one, two))\n        return one-two\n        \n    def atMostK(self,nums, k):\n        mapping = defaultdict(int)\n        ans = 0 \n        left = 0 \n        for right in range(len(nums)):\n            mapping[nums[right]]+=1\n            if mapping[nums[right]] == 1:\n                k-=1\n                \n            \n            while k <0:\n                mapping[nums[left]] -=1\n                if mapping[nums[left]] == 0:\n                    k+=1\n                left+=1\n                \n            ans+=right-left+1\n            \n        return ans \n        \n        \n                \n                \n            \n                \n        \n        \n", "class Solution:\n    from collections import Counter\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMostK(K):\n            i = 0\n            count = 0\n            counts = Counter()\n            for j in range(len(A)):\n                if counts[A[j]] == 0:\n                    K -= 1\n                counts[A[j]] += 1\n                while K < 0:\n                    counts[A[i]] -= 1\n                    if counts[A[i]] == 0:\n                        K += 1\n                    i += 1\n                count += j - i + 1\n            return count\n        return atMostK(K) - atMostK(K - 1)", "class Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n    \n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n            \nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n\n        for right, x in enumerate(A):\n            window1.add(x)\n            window2.add(x)\n\n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n\n            ans += left2 - left1\n\n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        start = 0\n        first_uni = 0\n        re = 0\n        dd = {}\n        \n        for i, cur in enumerate(A):\n            dd[cur]  = dd.get(cur, 0) + 1\n            \n            if len(dd) == K + 1:\n                dd.pop(A[first_uni])\n                first_uni += 1\n                start = first_uni\n            \n            if len(dd) == K:\n                while first_uni <= i and dd[A[first_uni]] != 1:\n                    dd[A[first_uni]] -= 1\n                    first_uni += 1\n                re += first_uni - start +1\n        \n        return re\n\n\n", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        '''\n        1 2 1 2 3\n        i       j\n\n        2 1 1 1 2\n        i j\n        '''\n        N = len(A)\n        \n        def atMost(k):\n            if k == 0: return 0\n            \n            ret = i = j = 0\n            cnt = Counter()\n            \n            while i < N:\n                x = A[i]\n                while j < N and (len(cnt) < k or A[j] in cnt):\n                    cnt[A[j]] += 1\n                    j += 1\n\n                ret += j - i\n                \n                cnt[x] -= 1\n                if cnt[x] == 0: del cnt[x]\n                i += 1\n            \n            return ret\n                \n        return atMost(K) - atMost(K-1)", "class Solution:\n    def subarraysWithKDistinct(self, s: List[int], K: int) -> int:\n        obj = defaultdict(int)\n        first = 0\n        second = 0\n        answer = 0\n        for i in range(len(s)):\n            obj[s[i]] += 1\n            if len(obj) == K + 1:\n                # remove the distinct at second, move second, first\n                del obj[s[second]]\n                second += 1\n                first = second\n            if len(obj) == K:\n                # update second and answer (Notice: K >= 1)\n                while obj[s[second]] > 1:\n                    obj[s[second]] -= 1\n                    second += 1\n                answer += second-first+1\n\n        return(answer)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        length = len(A)\n        \n        class counter:\n            def __init__(self):\n                self.c = Counter()\n            \n            def addValue(self, num):\n                self.c[num] += 1\n            \n            def removeValue(self, num):\n                self.c[num] -= 1\n                if self.c[num] == 0:\n                    del self.c[num]\n                \n        def subarraysWithAtLeast(k):\n            # print(\\\"---------\\\")\n            start = 0\n            c = counter()\n            ret = 0\n            for i in range(length):\n                cur = A[i]\n                c.addValue(cur)\n                if len(c.c) < k:\n                    ret += i - start + 1\n                    continue\n                while len(c.c) > k:\n                    tmp = A[start]\n                    c.removeValue(tmp)\n                    start += 1\n                assert len(c.c) == k\n                # print(A[start: i+1])\n                ret += i - start + 1\n            return ret\n        \n        # print(subarraysWithAtLeast(K))\n        # print(subarraysWithAtLeast(K-1))\n        return subarraysWithAtLeast(K) - subarraysWithAtLeast(K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        int_dict = {} ## Stores the last appearence of each integer\n        int_sorted_list = [] ## List of intergers that have already appeared, in the order of their last appearance\n        current = 0\n        l = len(A)\n        count = 0\n        while current < l:\n            if int_dict.get(A[current]) != None:\n                int_sorted_list.remove(A[current])\n            int_dict[A[current]] = current\n            int_sorted_list.append(A[current])\n            if len(int_sorted_list) > K + 1:\n                del int_dict[int_sorted_list[0]]\n                del int_sorted_list[0]\n            if len(int_sorted_list) > K:\n                count += int_dict[int_sorted_list[-K]] - int_dict[int_sorted_list[-K - 1]] \n            elif len(int_sorted_list) == K:\n                count += int_dict[int_sorted_list[-K]] + 1\n            current += 1\n        return count\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atmostK(k):\n            count = Counter()\n            res = 0\n            left = 0\n            right =  0\n            for right in range(len(A)):\n                # not in the map,k-=1\n                if count[A[right]]==0:\n                    k-=1\n                count[A[right]]+=1\n                while k < 0:\n                    count[A[left]]-=1\n                    if count[A[left]]==0:\n                          k+=1\n                    left+=1\n                res += right-left+1\n            return res\n        return atmostK(K)-atmostK(K-1)\n            \n", "# 992. Subarrays with K Different Integers\n\nclass Window:\n    def __init__ (self):\n        self.count = {}\n\n    def add (self, elem):\n        self.count.setdefault (elem, 0)\n        self.count[elem] += 1\n\n    def remove (self, elem):\n        self.count[elem] -= 1\n        if self.count[elem] == 0:\n            del self.count[elem]\n\n    def added_size (self, elem):\n        return len (self.count) + bool (elem not in self.count)\n\ndef count_below (arr, k):\n    if k == 0:\n        return 0\n    else:\n        right = 0\n        satisfactory = 0\n        window = Window ()\n        for left in range (len (arr)):\n            while right < len (arr) and window.added_size (arr [right]) <= k:\n                window.add (arr [right])\n                right += 1\n            satisfactory += (right - left)\n            window.remove (arr [left])\n        return satisfactory\n\ndef subarrays_with_k_distinct (arr, k):\n    assert k >= 1\n    return count_below (arr, k) - count_below (arr, k-1)\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return subarrays_with_k_distinct(A, K)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        result = 0\n        i, j = 0, 0\n        cnt = collections.Counter()\n        l = 0\n        n = len(A)\n        while j < n:\n            if len(cnt) != K:\n                cnt[A[j]] += 1\n                if len(cnt) == K:\n                    l = 1\n                    while cnt[A[i]] > 1:\n                        cnt[A[i]] -= 1\n                        i += 1\n                        l += 1\n                    result += l    \n                    # print(j ,l)\n            else:\n                if A[j] in cnt:\n                    cnt[A[j]] += 1\n                    while cnt[A[i]] > 1:\n                        cnt[A[i]] -= 1\n                        i += 1\n                        l += 1\n                    # print(j, l)\n                    result += l                        \n                else:\n                    cnt[A[i]] -= 1\n                    if cnt[A[i]] == 0:\n                        cnt.pop(A[i])\n                    cnt[A[j]] += 1\n                    i += 1\n                    l = 1\n                    while cnt[A[i]] > 1:\n                        cnt[A[i]] -= 1\n                        i += 1\n                        l += 1\n                    # print(j, l)\n                    result += l\n            j += 1\n        return result", "class Window:\n    def __init__(self):\n        self.counter = collections.Counter()\n    \n    def add(self, x):\n        self.counter[x] += 1\n    \n    def remove(self, x):\n        self.counter[x] -= 1\n        if self.counter[x] == 0:\n            self.counter.pop(x)\n    \n    def __len__(self):\n        return len(self.counter)\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        left1, left2 = 0, 0\n        result = 0\n        \n        for right, num in enumerate(A):\n            window1.add(num)\n            window2.add(num)\n            \n            # At most K distinct elements\n            while len(window1) > K:\n                window1.remove(A[left1])\n                left1 += 1\n            \n            # At most K-1 distinct elements\n            while len(window2) >= K:\n                window2.remove(A[left2])\n                left2 += 1\n            \n            # At most K - At most (K-1) will give you exact K elements\n            result += left2 - left1\n    \n        return result", "class Accumulator:\n    def __init__(self):\n        self.KeyToCount={}\n        self.q=deque()\n    def append(self, value):\n        self.q.append(value)\n        self.KeyToCount[value]=self.KeyToCount.get(value,0)+1\n    def popleft(self):\n        v=self.q.popleft()\n        if self.KeyToCount[v]==1:\n            del self.KeyToCount[v]\n        else:\n            self.KeyToCount[v]-=1\n    def distinctCount(self):\n        return len(self.KeyToCount)\n    \nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n=len(A)\n        nextHiIdx=0\n        nextLoIdx=0\n        loAcc=Accumulator()\n        hiAcc=Accumulator()\n        lo=[None]*n\n        hi=[None]*n\n        for i in range(n):\n            if i>=1:\n                hiAcc.popleft()\n                loAcc.popleft()\n            while nextLoIdx<n and loAcc.distinctCount()<K:\n                loAcc.append(A[nextLoIdx])\n                nextLoIdx+=1\n            while nextHiIdx<n and hiAcc.distinctCount()<=K:\n                hiAcc.append(A[nextHiIdx])\n                nextHiIdx+=1\n            if loAcc.distinctCount()==K:\n                lo[i]=nextLoIdx-1\n            if hiAcc.distinctCount()==K+1:\n                hi[i]=nextHiIdx-1\n            elif  hiAcc.distinctCount()==K and nextHiIdx==n:\n                hi[i]=nextHiIdx\n        return sum(hi[i]-lo[i] for i in range(n) if hi[i]!=None)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        def atMost(K):\n            N = len(A)\n            ct = collections.Counter()\n            ans = 0\n            i = 0\n            for j in range(N):\n                ct[A[j]] += 1\n                if len(ct) <= K:\n                    ans += j - i + 1\n                else:\n                    while len(ct) > K:\n                        ct[A[i]] -= 1\n                        if ct[A[i]] == 0: del ct[A[i]]\n                        i += 1\n                    ans += j - i + 1\n            return ans\n        \n        return atMost(K) - atMost(K-1)\n", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        res = 0\n        left1, left2 = 0, 0\n\n        for i in range(len(A)):\n            window1.add(A[i])\n            window2.add(A[i])\n            while window1.size() > K:\n                window1.remove(A[left1])\n                left1 += 1\n            while window2.size() > K-1:\n                window2.remove(A[left2])\n                left2 += 1\n            res += left2 - left1\n        return res\n\n\nclass Window:\n    def __init__(self):\n        self.counter = Counter()\n\n    def add(self, x):\n        self.counter[x] += 1\n\n    def remove(self, x):\n        self.counter[x] -= 1\n        if self.counter[x] == 0:\n            del self.counter[x]\n\n    def size(self):\n        return len(self.counter)", "class Solution:\n    def subarraysWithKDistinct(self, A: 'List[int]', K: 'int') -> 'int':\n        return self.subarraysWithKMax(A,K) - self.subarraysWithKMax(A,K-1)\n    \n    def subarraysWithKMax(self, A, K):\n        k = 0\n        count = dict()\n        i, start = 0, 0\n        res = 0\n        while i < len(A):\n            if A[i] not in count:\n                k+=1\n                count[A[i]] = 1\n            else:\n                count[A[i]] += 1\n            i+=1\n            \n            while start<i and k>K:\n                count[A[start]] -= 1\n                if count[A[start]] == 0:\n                    del count[A[start]]\n                    k -= 1\n                start += 1\n            res += i-start\n        return res\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMostK(A, K) - self.atMostK(A, K-1)\n        \n    def atMostK(self, A, K):\n        counter = collections.Counter()\n        res = i = 0\n        for j in range(len(A)):\n            if counter[A[j]] == 0: K -= 1\n            counter[A[j]] += 1\n            while K < 0:\n                counter[A[i]] -= 1\n                if counter[A[i]] == 0: K += 1\n                i += 1\n            res += j - i + 1\n        return res", "from collections import Counter\n\nclass Window:\n    def __init__(self):\n        self.count = Counter()\n        self.nonzero = 0\n        \n    def add(self, val):\n        self.count[val] += 1\n        if self.count[val] == 1:\n            self.nonzero += 1\n    \n    def remove(self, val):\n        self.count[val] -= 1\n        if self.count[val] == 0:\n           self.nonzero -= 1 \n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        ans = 0\n        l1, l2 = 0, 0\n        w1, w2 = Window(), Window()\n        for r, val in enumerate(A):\n            w1.add(val)\n            w2.add(val)\n            while w1.nonzero > K:\n                w1.remove(A[l1])\n                l1 += 1\n            while w2.nonzero >= K:\n                w2.remove(A[l2])\n                l2 += 1\n            ans += l2 - l1\n        return ans\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        class UniqueCounter(object):    \n            def __init__(self):\n                self.non_zero = 0\n                self.counts = collections.defaultdict(int)\n                \n            def add(self, x):\n                if self.counts[x] == 0:\n                    self.non_zero += 1\n                self.counts[x] += 1\n                \n            def remove(self, x):\n                self.counts[x] -= 1\n                if self.counts[x] == 0:\n                    self.non_zero -= 1\n\n            def count(self):\n                return self.non_zero\n                \n        def subarrays_with_max_K(A, K):\n            j = 0\n            uc = UniqueCounter()\n            uc.add(A[0])\n            answer = 0\n            for i in range(len(A)):\n                while j < len(A) and uc.count() <= K:\n                    j += 1\n                    if j < len(A):\n                        uc.add(A[j])\n                answer += j - i\n                uc.remove(A[i])\n            return answer\n            \n        return subarrays_with_max_K(A, K) - subarrays_with_max_K(A, K - 1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atmostK(k):\n            count = Counter()\n            res = 0\n            left = 0\n            right =  0\n            for right in range(len(A)):\n                if count[A[right]]==0:\n                    k-=1\n                count[A[right]]+=1\n                while k < 0:\n                    count[A[left]]-=1\n                    if count[A[left]]==0:\n                          k+=1\n                    left+=1\n                res += right-left+1\n            return res\n        return atmostK(K)-atmostK(K-1)\n            \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        last_seen = {}\n        start = end = 0\n        ans = 0\n        for i, x in enumerate(A):\n            last_seen[x] = i\n            while len(last_seen)>K:\n                if last_seen[A[start]]==start:\n                    del last_seen[A[start]]\n                start += 1\n            while A[end] not in last_seen or last_seen[A[end]]!=end:\n                end += 1\n            if len(last_seen)==K: ans += end - start + 1\n        return ans\n", "from collections import Counter\n\ndef solve(A, K):\n    count = Counter()\n    front = iter(A)\n    \n    ans = 0\n    size = 0\n    for k in A:\n        count[k] += 1\n        size += 1\n        while len(count) > K:\n            key = next(front)\n            count[key] -= 1\n            size -= 1\n            if count[key] == 0:\n                del count[key]\n        ans += size\n    return ans\n            \n            \nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return solve(A, K) - solve(A, K-1)", "class Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n\n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n\n        \n        for _, x in enumerate(A):\n            #print(right, x)\n            window1.add(x)\n            window2.add(x)\n\n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n\n            ans += left2 - left1\n\n        return ans       ", "class Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n            \nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        ans = le1 = le2 = 0\n        \n        for ri, val in enumerate(A):\n            window1.add(val)\n            window2.add(val)\n            \n            while window1.nonzero > K:\n                window1.remove(A[le1])\n                le1 += 1\n            while window2.nonzero >= K:\n                window2.remove(A[le2])\n                le2 += 1\n            \n            ans += le2 - le1\n        return ans\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n < 1:\n            return 0\n\n        result = 0\n        fc = Counter()\n        c = Counter()\n        l = 0\n        fr = 0\n        r = 0\n        while l < n:\n            while fr < n and len(fc) < K:\n                fc[A[fr]] += 1\n                fr += 1\n            while r < n:\n                if A[r] not in c and len(c) >= K:\n                    break\n                c[A[r]] += 1\n                r += 1\n            #print(c, l, fr, r)\n            if len(c) == K:\n                result += r - fr + 1\n            fc[A[l]] -= 1\n            if fc[A[l]] == 0:\n                del fc[A[l]]\n            c[A[l]] -= 1\n            if c[A[l]] == 0:\n                del c[A[l]]\n            l += 1\n            print('c', l, r)\n\n        return result", "from collections import Counter\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.at_most(A, K) - self.at_most(A, K-1)\n    \n    def at_most(self, a, k):\n        res = 0\n        start = 0\n        c = Counter()\n        for end, elem in enumerate(a):\n            if c[elem] == 0:\n                k -= 1\n            c[elem] += 1\n            \n            while start <= end and k < 0:\n                c[a[start]] -= 1\n                if c[a[start]] == 0:\n                    k += 1\n                start += 1\n            \n            res += end - start + 1\n            \n        return res", "from collections import Counter\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMostK(A, K):\n            counts = Counter()\n            left, result = 0, 0\n            \n            for right in range(len(A)):\n                if counts[A[right]] == 0:\n                    K -= 1\n                    \n                counts[A[right]] += 1\n                \n                while K < 0:\n                    counts[A[left]] -= 1\n                    \n                    if counts[A[left]] == 0:\n                        K += 1\n                        \n                    left += 1\n                    \n                result += right - left + 1\n                \n            return result\n        \n        return atMostK(A, K) - atMostK(A, K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n          return self.atMostK(A, K) - self.atMostK(A, K - 1)\n\n    def atMostK(self, A, K):\n        count = collections.Counter()\n        res = i = 0\n        for j in range(len(A)):\n            if count[A[j]] == 0: K -= 1\n            count[A[j]] += 1\n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0: K += 1\n                i += 1\n            res += j - i + 1\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        \n        #Important\n        #https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window\n        \n        print((self.atmost_counts(A, K), self.atmost_counts(A, K-1)))\n        return self.atmost_counts(A, K) - self.atmost_counts(A, K-1)\n                \n    \n    def atmost_counts(self, A, K):\n        \n        counter = collections.Counter()\n        \n        res = i = 0\n        \n        for j in range(len(A)):\n            \n            if counter[A[j]] == 0:\n                K -= 1\n                \n            counter[A[j]] += 1\n            \n            while K < 0:\n                counter[A[i]] -= 1\n                if counter[A[i]] == 0: \n                    K += 1\n                i += 1\n            res += j - i + 1\n        return res\n                \n            \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        if not A:\n            return 0\n        \n        l = len(A)\n        end = 0\n        left1 = 0\n        left2 = 0\n        map1 = collections.defaultdict(int)\n        map2 = collections.defaultdict(int)\n        ans = 0\n        \n        while end < l:\n            ch = A[end]\n            \n            map1[ch] += 1\n            map2[ch] += 1\n            \n            while len(map1) > K and left1 < l:\n                temp1 = A[left1]\n                map1[temp1] -= 1\n                if map1[temp1] == 0:\n                    del map1[temp1]\n                \n                left1 += 1\n                \n            while len(map2) >= K and left2 < l:\n                temp2 = A[left2]\n                map2[temp2] -= 1\n                if map2[temp2] == 0:\n                    del map2[temp2]\n                \n                left2 += 1\n            \n            ans += left2 - left1\n            end += 1\n        \n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        hashmap = {}\n        l = 0\n        count = 0\n        ans = 0\n        sums = 1\n        for r in range(n):\n            if A[r] in hashmap:\n                hashmap[A[r]] += 1\n            else:\n                hashmap[A[r]] = 1\n            if hashmap[A[r]] == 1:\n                count += 1\n            while count > K or hashmap[A[l]] > 1:\n                if count > K:\n                    sums = 1\n                else:\n                    sums += 1\n                hashmap[A[l]] -= 1\n                if hashmap[A[l]] == 0:\n                    count -= 1\n                l += 1\n            if count == K:\n                ans += sums\n        return ans", "class Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n        \n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n    \n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n        \n        for right, x in enumerate(A):\n            window1.add(x)\n            window2.add(x)\n            \n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n            \n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n                \n            ans += left2 - left1\n            \n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        def helper(A,K):\n\n            d = defaultdict(int)\n            begin = 0\n            end = 0\n            ans = float('-inf')\n            count = 0\n            res = 0\n            # move from the right pointer\n            while end < len(A):\n\n                char = A[end]\n                d[char] += 1\n                if d[char] == 1:\n                    count += 1\n\n                end += 1\n\n                while count > K:\n                    temp = A[begin]\n                    d[temp] -= 1\n                    if d[temp] == 0:\n                        count -= 1\n                    begin += 1\n\n                res += end - begin + 1\n\n            return res\n        return helper(A,K) - helper(A,K-1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: 'List[int]', K: 'int') -> 'int':\n        return self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K-1)\n    \n    def subarraysWithAtMostKDistinct(self, s, k):\n        lookup = collections.defaultdict(int)\n        l, r, counter, res = 0, 0, 0, 0\n        while r < len(s):\n            lookup[s[r]] += 1\n            if lookup[s[r]] == 1:\n                counter += 1\n            r += 1   \n            while l < r and counter > k:\n                lookup[s[l]] -= 1\n                if lookup[s[l]] == 0:\n                    counter -= 1\n                l += 1\n            res += r - l    #the number of subarrays ending with s[r-1] **\n        return res\n", "\nclass Window:\n    def __init__(self):\n        self.num = 0\n        self.dic = collections.defaultdict(int)\n        \n    def add(self, v: int) -> int:\n        if self.dic[v] == 0:\n            self.num += 1\n        self.dic[v] += 1\n        return self.num\n        \n    def remove(self, v: int) -> int:\n        self.dic[v] -= 1\n        if self.dic[v] == 0:\n            self.num -= 1\n        return self.num\n\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        wk = Window()\n        wm = Window()\n        \n        sk = 0\n        sm = 0\n        e  = 0\n        ans = 0\n        \n        while e < len(A):\n            ce = A[e]\n            nk = wk.add(ce)\n            nm = wm.add(ce)\n            \n            if nk < K:\n                e += 1\n            elif nk == K:\n                while nm != K-1:\n                    nm = wm.remove(A[sm])\n                    sm += 1\n                ans += sm - sk\n                e += 1\n            else:\n                while nk != K:\n                    nk = wk.remove(A[sk])\n                    sk += 1\n                while nm != K-1:\n                    nm = wm.remove(A[sm])\n                    sm += 1\n                ans += sm - sk\n                e += 1\n                \n        return ans\n                \n            \n            \n", "class Window:\n    def __init__(self):\n        self.count = collections.Counter()\n        self.nonzero = 0\n\n    def add(self, x):\n        self.count[x] += 1\n        if self.count[x] == 1:\n            self.nonzero += 1\n\n    def remove(self, x):\n        self.count[x] -= 1\n        if self.count[x] == 0:\n            self.nonzero -= 1\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        ans = left1 = left2 = 0\n\n        \n        for x in A:\n            #print(right, x)\n            window1.add(x)\n            window2.add(x)\n\n            while window1.nonzero > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.nonzero >= K:\n                window2.remove(A[left2])\n                left2 += 1\n\n            ans += left2 - left1\n\n        return ans       ", "from collections import Counter\nclass Solution:\n    def subarraysWithKDistinct(self, A, K: int) -> int:\n        def atMostK(nums, k):\n            print(nums, k)\n            res, left = 0, 0\n            counter = Counter()\n            for right, v in enumerate(nums):\n                if counter[v] == 0:\n                    k -= 1\n                counter[v] += 1\n                while k < 0:\n                    counter[A[left]] -= 1\n                    if counter[A[left]] == 0:\n                        k += 1\n                    left += 1\n                res += right - left\n                # print(counter, res)\n            return res\n        return atMostK(A, K) - atMostK(A, K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        def atMostK(kk):\n            counter = collections.Counter()\n            res = ii = 0\n            for jj in range(len(A)):\n                if counter[A[jj]] == 0:\n                    kk -= 1\n                counter[A[jj]] += 1\n                while kk < 0:\n                    counter[A[ii]] -= 1\n                    if counter[A[ii]] == 0:\n                        kk += 1\n                    ii += 1\n                res += jj - ii + 1\n            return res\n        return atMostK(K) - atMostK(K - 1)\n", "from collections import defaultdict as dd\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        i = j = 0\n        d = dd(int)\n        res = 0\n        while j < n:\n            # Step 1: find j1\n            while j < n and len(d) < K:\n                d[A[j]] += 1\n                j += 1\n            i1, j1 = i, j\n            # Step 2: find i\n            d[A[i]] -= 1\n            while d[A[i]] > 0:\n                i += 1\n                d[A[i]] -= 1\n            # Step 3: find j\n            while j < n and A[j] in d:\n                j += 1\n            if len(d) == K:\n                res += (i-i1+1)*(j-j1+1)\n            # print(i1, i, j1, j)\n            d.pop(A[i])\n            i += 1\n            j = j1\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:        \n        def atMostK(A, K):\n            ans, curr = 0, 0\n            cnt = defaultdict(int)\n            i = 0\n            for j, num in enumerate(A):\n                if num not in cnt:\n                    K -= 1\n                cnt[num] += 1\n                while K<0:\n                    cnt[A[i]] -= 1\n                    if cnt[A[i]] == 0:\n                        del cnt[A[i]]\n                        K += 1\n                    i += 1\n                ans += j - i + 1\n            return ans\n        return atMostK(A, K) - atMostK(A, K-1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.at_most_K(A, K) - self.at_most_K(A, K - 1)\n        \n    \n    def at_most_K(self, A, k):\n        left = 0\n        counter = collections.Counter()\n        diff = 0\n        result = 0\n        for right in range(len(A)):\n            counter[A[right]] += 1\n            if counter[A[right]] == 1:\n                diff += 1\n            while diff > k:\n                counter[A[left]] -= 1\n                if counter[A[left]] == 0:\n                    diff -= 1\n                left += 1\n            result += right - left + 1\n        return result", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\n\n    def atMostK(self, A, K):\n        count = collections.Counter()\n        res = i = 0\n        for j in range(len(A)):\n            if count[A[j]] == 0: K -= 1\n            count[A[j]] += 1\n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0: K += 1\n                i += 1\n            res += j - i + 1\n        return res", "\nfrom typing import Dict, Set, List, Tuple\nfrom collections import defaultdict\nfrom pprint import pprint\n\n\nclass Window:\n    def __init__(self):\n        self._counter = {}\n        self._distinct_num = 0\n\n    def add(self,num):\n        if num in self._counter:\n            self._counter[num] += 1\n        else:\n            self._distinct_num += 1\n            self._counter[num] = 1\n\n    def remove(self,num):\n        self._counter[num] -= 1\n        if self._counter[num] == 0:\n            self._distinct_num -= 1\n            del self._counter[num]\n\n    @property\n    def nums(self):\n        return self._distinct_num\n\n\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n\n        w1 = Window()\n        w2 = Window()\n        x = y = z = 0\n        # w1 \u4e2d\u5305\u542b A[x:z] \u4e2d\u6240\u6709\u7684\u6570\u5b57\uff0c\u800c\u4e14 w1 \u4e2d\u4e0d\u91cd\u5408\u7684\u6570\u5b57\u6570\u91cf\u4e3a K\n        # w2 \u4e2d\u5305\u542b A[y:z] \u4e2d\u6240\u6709\u7684\u6570\u5b57\uff0c\u800c\u4e14 w2 \u4e2d\u4e0d\u91cd\u5408\u7684\u6570\u5b57\u6570\u91cf\u4e3a K - 1\n        # if x <= i < y; then A[i:z] \u4e2d\u7684\u4e0d\u91cd\u5408\u7684\u6570\u5b57\u6570\u91cf\u4e3a K\n\n        result = 0\n        while z < len(A):\n            w1.add(A[z])\n            w2.add(A[z])\n            z += 1\n\n            while w1.nums > K:\n                w1.remove(A[x])\n                x += 1\n            while w2.nums > K - 1:\n                w2.remove(A[y])\n                y += 1\n\n            if w1.nums == K:\n                assert w2.nums == K - 1\n\n            result += (y-x)\n        return result\n", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n < K:\n            return 0\n        \n        # 3 pointer sliding window\n        # p1 points to the 1st unique integer, start of the window\n        # p2 points to the first occurrance of the Kth unique integer after p1\n        # p3 points the the first occurrance of the next unique integer after p2, of end of string at n\n        # Given such a window, we add (p3-p2) to the count\n        # Then move p1 by 1. Check if that reduces the number of integers to K-1. If no, add p3-p2 again.\n        # If yes, then move p2 until the count goes up to K again. If p2 lands on p3 when doing this,\n        # then need to move p3 to the next integer. If p3 is already at EOS, return\n        \n        # To maintain the number of unique integers in a window, we'll use a hashmap\n        # Be careful, we need this dict to contain only nonzero count entries. So if a count becomes zero, delete it!\n        count = defaultdict(int)\n        p1 = 0; p2 = 0; p3 = 0\n        count[A[0]] += 1\n        ans = 0\n        while p2 < n:  # IMP!!! note the <=, not < \n            # Move p2 until the number of unique integers in the window hits K\n            remaining = K-len(count)\n            while remaining > 0:\n                p2 += 1\n                if p2 == n:\n                    return ans\n                count[A[p2]] += 1\n                if count[A[p2]] == 1:\n                    remaining -= 1\n            # p2 now points to the first instance of the Kth integer after p1\n            # Now move p3 to the next unique integer after p2\n            # print(\\\"count: {}, A[{}]: {}, {}\\\".format(count, p3, A[p3], A[p3] in count))\n            while p3 < n and A[p3] in count:\n                p3 += 1\n            # p3 is either n or points to the (K+1)th integer after p1\n            # Now, keep adding (p3-p2) to the count and advancing p1 until we no longer have K integers in this window\n            while len(count) == K:\n                ans += (p3-p2)\n                # print(\\\"p1:{}, p2:{}, p3:{}, count:{}\\\".format(p1, p2, p3, count))\n                p1 += 1\n                count[A[p1-1]] -= 1\n                if count[A[p1-1]] == 0:\n                    del count[A[p1-1]]\n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        checkSet = OrderedDict()\n        windowStart = 0 \n        count = 0\n        ans = []\n        for i, n in enumerate(A):\n            checkSet[n] = i\n            checkSet.move_to_end(n)\n            while len(checkSet) > K:\n                windowStart = checkSet.popitem(last=False)[1] + 1\n            if len(checkSet) == K:\n                count += next(iter(list(checkSet.items())))[1]- windowStart +1\n        return count\n            \n                \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], k: int) -> int:\n           dic={};n=len(A);left=0;right=0;cnt=0\n           for i in range(n):\n               if A[i] in dic:\n                    dic[A[i]]+=1 \n               else:\n                  dic[A[i]]=1\n               l=len(dic) \n               if l==k+1:\n                    del dic[A[right]]\n                    right+=1\n                    left=right\n                    l-=1\n               if l==k:\n                 while dic[A[right]]>1:\n                    dic[A[right]]-=1 \n                    right+=1\n                 cnt+=right-left+1\n           return cnt \n                    \n", "\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        left1 = 0\n        left2 = 0\n        w1 = {}\n        w2 = {}\n        count = 0\n        for right, x in enumerate(A):\n            \n            if x in w1:\n                w1[x] += 1\n            else:\n                w1[x] = 1\n                \n            if x in w2:\n                w2[x] += 1\n            else:\n                w2[x] = 1       \n            while len(w1) > K:\n                if w1[A[left1]] == 1:\n                    w1.pop(A[left1])\n                elif w1[A[left1]] > 1:\n                    w1[A[left1]] -= 1\n                left1 += 1\n            \n            while len(w2) >= K:\n                if w2[A[left2]] == 1:\n                    w2.pop(A[left2])\n                elif w2[A[left2]] > 1:\n                    w2[A[left2]] -= 1\n                left2 += 1\n            \n            count += left2 - left1\n        return count", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n < K:\n            return 0\n        \n        # 3 pointer sliding window\n        # p1 points to the 1st unique integer, start of the window\n        # p2 points to the first occurrance of the Kth unique integer after p1\n        # p3 points the the first occurrance of the next unique integer after p2, of end of string at n\n        # Given such a window, we add (p3-p2) to the count\n        # Then move p1 by 1. Check if that reduces the number of integers to K-1. If no, add p3-p2 again.\n        # If yes, then move p2 until the count goes up to K again. If p2 lands on p3 when doing this,\n        # then need to move p3 to the next integer. If p3 is already at EOS, return\n        \n        # To maintain the number of unique integers in a window, we'll use a hashmap\n        # Be careful, we need this dict to contain only nonzero count entries. So if a count becomes zero, delete it!\n        count = defaultdict(int)\n        p1 = 0; p2 = 0; p3 = 0\n        count[A[0]] += 1\n        ans = 0\n        while p3 <= n:  # IMP!!! note the <=, not < \n            # Move p2 until the number of unique integers in the window hits K\n            remaining = K-len(count)\n            while remaining > 0:\n                p2 += 1\n                if p2 == n:\n                    return ans\n                count[A[p2]] += 1\n                if count[A[p2]] == 1:\n                    remaining -= 1\n            # p2 now points to the first instance of the Kth integer after p1\n            # Now move p3 to the next unique integer after p2\n            # print(\\\"count: {}, A[{}]: {}, {}\\\".format(count, p3, A[p3], A[p3] in count))\n            while p3 < n and A[p3] in count:\n                p3 += 1\n            # p3 is either n or points to the (K+1)th integer after p1\n            # Now, keep adding (p3-p2) to the count and advancing p1 until we no longer have K integers in this window\n            while len(count) == K:\n                ans += (p3-p2)\n                # print(\\\"p1:{}, p2:{}, p3:{}, count:{}\\\".format(p1, p2, p3, count))\n                p1 += 1\n                count[A[p1-1]] -= 1\n                if count[A[p1-1]] == 0:\n                    del count[A[p1-1]]\n        return ans", "class Solution:\n    \n    def _identify_limit(self, A, current_limit, K,  char_count_after_limit):\n        # unique_chars = {i for i in char_count_after_limit if char_count_after_limit[i] > 0}\n        # print(unique_chars)\n        temp_char = A[current_limit]\n        while char_count_after_limit.get(temp_char, 0) > 1 : \n            # print(\\\"WHILE\\\", char_count_after_limit)\n            char_count_after_limit[temp_char] = char_count_after_limit[temp_char] - 1\n            current_limit += 1\n            temp_char = A[current_limit]\n            \n\n        return  current_limit , char_count_after_limit\n    \n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        char_info = {item : [] for item in set(A)} \n        unique_char_count = {}\n        unique_char = set()\n        start_idx = 0 \n        end_idx = 0\n        num_substr = 0\n        current_subarray = []\n        current_valid_count = 0 \n        # In any valid subarray what is the index upto which left index could be moved without making subarray bad \n        # Whenever end_idx is moved to right keeping subarray good compute limit_idx again \n        limit_idx = 0\n        while end_idx < len(A) + 1 : \n            if len(unique_char_count) == K : \n                limit_idx, unique_char_count = self._identify_limit(A, limit_idx, K, unique_char_count)\n                num_substr += limit_idx - start_idx + 1\n                if end_idx < len(A):\n                    current_char = A[end_idx]\n                    unique_char_count[current_char] = unique_char_count.get(current_char, 0) + 1\n                end_idx += 1 \n            elif len(unique_char_count) > K: \n                # Remove limit_idx from stats\n                current_char = A[limit_idx]\n                unique_char_count.pop(current_char)\n                start_idx = limit_idx + 1\n                limit_idx = start_idx \n            else: \n                if end_idx < len(A):\n                    current_char = A[end_idx]\n                    unique_char_count[current_char] = unique_char_count.get(current_char, 0) + 1\n                end_idx += 1 \n        return num_substr\n\n    \n    \n    #         counter1, counter2 = collections.Counter(), collections.Counter()\n#         slow = fast = res = 0\n\n#         for _, a in enumerate(A):\n#             counter1[a], counter2[a] = counter1[a] + 1, counter2[a] + 1\n#             while len(counter2) == K:\n#                 counter2[A[fast]] -= 1\n#                 if not counter2[A[fast]]: del counter2[A[fast]]\n#                 fast += 1\n#             while len(counter1) > K:\n#                 counter1[A[slow]] -= 1\n#                 if not counter1[A[slow]]: del counter1[A[slow]]\n#                 slow += 1\n#             res += fast - slow\n\n#         return res\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        d, t = defaultdict(int), defaultdict(int)\n        \n        a, b = K, K\n        left, right = 0, 0\n        res = 0\n        \n        for i, ele in enumerate(A):\n            a -= (1 if d[ele] == 0 else 0)\n            b -= (1 if t[ele] == 0 else 0)\n            d[ele] += 1\n            t[ele] += 1\n            while a < 0:\n                a += (1 if d[A[left]] == 1 else 0)\n                d[A[left]] -= 1\n                left += 1\n            while b <= 0:\n                b += (1 if t[A[right]] == 1 else 0)\n                t[A[right]] -= 1\n                right += 1\n            res += right - left\n        \n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: 'List[int]', K: 'int') -> 'int':\n        freq = {}\n        start = 0\n        start_k = 0\n        res = 0\n        for i, x in enumerate(A):\n            freq[x] = freq.get(x, 0) + 1\n            if len(freq) == K + 1:\n                # remove the distinct at start_k, move start_k, start\n                del freq[A[start_k]]\n                start_k += 1\n                start = start_k\n            if len(freq) == K:\n                # update start_k and res (Notice: K >= 1)\n                while freq[A[start_k]] > 1:\n                    freq[A[start_k]] -= 1\n                    start_k += 1\n                res += start_k - start + 1\n        return res", "from collections import defaultdict\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        total = 0\n        l1 = 0\n        l2 = 0\n        memo1 = defaultdict(int)\n        memo2 = defaultdict(int)\n        \n        for r, c in enumerate(A):\n            \n            memo1[c] += 1\n            memo2[c] += 1\n            \n            while(len(memo1)>K):\n                memo1[A[l1]] -= 1\n                if(memo1[A[l1]]==0):\n                    del memo1[A[l1]]\n                l1 += 1\n                \n            while(len(memo2)>=K):\n                memo2[A[l2]] -= 1\n                if(memo2[A[l2]]==0):\n                    del memo2[A[l2]]\n                l2 += 1\n            \n            total +=  l2 - l1\n            \n        return total\n            \n", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n < K:\n            return 0\n        \n        # 3 pointer sliding window\n        # p1 points to the 1st unique integer, start of the window\n        # p2 points to the first occurrance of the Kth unique integer after p1\n        # p3 points the the first occurrance of the next unique integer after p2, of end of string at n\n        # Given such a window, we add (p3-p2) to the count\n        # Then move p1 by 1. Check if that reduces the number of integers to K-1. If no, add p3-p2 again.\n        # If yes, then move p2 until the count goes up to K again. If p2 lands on p3 when doing this,\n        # then need to move p3 to the next integer. If p3 is already at EOS, return\n        \n        # To maintain the number of unique integers in a window, we'll use a hashmap\n        # Be careful, we need this dict to contain only nonzero count entries. So if a count becomes zero, delete it!\n        count = defaultdict(int)\n        p1 = 0; p2 = 0; p3 = 0\n        count[A[0]] += 1\n        ans = 0\n        while p2 < n:  # IMPORTANT: Use p2 rather than p3, because we want to execute as long as p2 can expand, even if p3 is already at n\n            # Move p2 until the number of unique integers in the window hits K\n            remaining = K-len(count)\n            while remaining > 0:\n                p2 += 1\n                if p2 == n:\n                    return ans\n                count[A[p2]] += 1\n                if count[A[p2]] == 1:\n                    remaining -= 1\n            # p2 now points to the first instance of the Kth integer after p1\n            # Now move p3 to the next unique integer after p2\n            # print(\\\"count: {}, A[{}]: {}, {}\\\".format(count, p3, A[p3], A[p3] in count))\n            while p3 < n and A[p3] in count:\n                p3 += 1\n            # p3 is either n or points to the (K+1)th integer after p1\n            # Now, keep adding (p3-p2) to the count and advancing p1 until we no longer have K integers in this window\n            while len(count) == K:\n                ans += (p3-p2)\n                # print(\\\"p1:{}, p2:{}, p3:{}, count:{}\\\".format(p1, p2, p3, count))\n                p1 += 1\n                count[A[p1-1]] -= 1\n                if count[A[p1-1]] == 0:\n                    del count[A[p1-1]]\n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        \n        def help(k):\n            res = 0\n            left = 0\n            d = {}\n            for i, ele in enumerate(A):\n                d[ele] = d.get(ele, 0) + 1\n                while len(d) > k:\n                    d[A[left]] -= 1\n                    if d[A[left]] == 0:\n                        del d[A[left]]\n                    left += 1\n                res += i - left\n            return res\n        \n        return help(K) - help(K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        \n        def atmost(k):  \n            i = 0\n            res = 0\n            d = defaultdict(int)\n            \n            for j, a in enumerate(A):\n                if d[a] == 0: k-=1\n                d[a]+=1\n                while k < 0:\n                    d[A[i]]-=1\n                    if d[A[i]] == 0: k+=1\n                    i+=1\n                res += j-i+1\n                \n            return res\n        \n        return atmost(K) - atmost(K-1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMost(A: List[int], K: int) -> int:\n            d = collections.defaultdict(int)\n            i = ret = 0\n            for j in range(len(A)):\n                d[A[j]] += 1\n                while len(d) > K:\n                    d[A[i]] -= 1\n                    if d[A[i]] == 0:\n                        del d[A[i]]\n                    i += 1\n                ret += j - i + 1\n            return ret \n        return atMost(A, K) - atMost(A, K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        if K > len(A):\n            return 0\n        \n        result = checker = windowStart = 0\n        hashMap = {}\n        a_length = len(A)\n        \n        for windowEnd in range(a_length):\n                curr_digit = A[windowEnd]\n                if curr_digit in hashMap:\n                    hashMap[curr_digit] += 1\n                else:\n                    hashMap[curr_digit] = 1\n                \n                if len(hashMap) > K:\n                    del hashMap[A[checker]]\n                    checker += 1\n                    windowStart = checker\n                if len(hashMap) == K:\n                    while hashMap[A[checker]] > 1:\n                        hashMap[A[checker]] -= 1\n                        checker += 1\n                    result += checker - windowStart +1\n        return result", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def getAtMost(K):\n            freq = defaultdict(int)\n\n            subarray_count = 0\n            left = 0\n\n            for right, num in enumerate(A):\n                freq[num] += 1\n\n                while len(freq) > K:\n                    freq[A[left]] -= 1\n\n                    if freq[A[left]] == 0:\n                        del freq[A[left]]\n\n                    left += 1\n                    \n                subarray_count += right - left + 1\n            \n            return subarray_count\n                \n        return getAtMost(K) - getAtMost(K-1)\n\n", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        if K == 0:\n            return 0\n        res1 = self.helper(A, K)\n        res2 = self.helper(A, K - 1)\n\n        return res1 - res2\n\n    def helper(self, a, k):\n\n        if k == 0:\n            return 0\n\n        count = defaultdict(int)\n\n        result = 0\n        l = 0\n        r = 0\n\n        while r < len(a):\n            count[a[r]] += 1\n\n            while len(count) > k:\n                count[a[l]] -= 1\n                if count[a[l]] == 0:\n                    count.pop(a[l])\n                l += 1\n\n            result += r - l + 1\n            r += 1\n\n        return result\n", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        cnt1, cnt2 = dict(), dict()\n        res, i1, i2 = 0, 0, 0\n        for v in A:\n            cnt1[v] = cnt1.get(v, 0) + 1\n            cnt2[v] = cnt2.get(v, 0) + 1\n            while len(cnt1) > K:\n                cnt1[A[i1]] -= 1\n                if cnt1[A[i1]] == 0: del cnt1[A[i1]]\n                i1 += 1\n            while len(cnt2) >= K:\n                cnt2[A[i2]] -= 1\n                if cnt2[A[i2]] == 0: del cnt2[A[i2]]\n                i2 += 1\n            res += i2 - i1\n        return res\n    \nclass Solution:\n    def subarraysWithKDistinct(self, A, K):\n        cnt1, cnt2 = dict(), dict()\n        res, i1, i2 = 0, 0, 0\n        for v in A:\n            cnt1[v] = cnt1.get(v, 0) + 1\n            cnt2[v] = cnt2.get(v, 0) + 1\n            while len(cnt1) > K:\n                X = A[i1]\n                cnt1[X] -= 1\n                if cnt1[X] == 0: del cnt1[X]\n                i1 += 1\n            while len(cnt2) > K-1:\n                X = A[i2]\n                cnt2[X] -= 1\n                if cnt2[X] == 0: del cnt2[X]\n                i2 += 1\n            res += i2 - i1\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        return self.at_most(A, K) - self.at_most(A, K - 1)\n    \n    \n    def at_most(self, A, K):\n        if K == 0:\n            return 0\n        \n        window = {}\n        left = 0\n        ret = 0\n        \n        for right in range(len(A)):\n            window[A[right]] = window.get(A[right], 0) + 1\n            \n            while left < right and len(window) > K:\n                window[A[left]] -= 1\n                \n                if window[A[left]] == 0:\n                    del window[A[left]]\n                \n                left += 1\n            \n            ret += (right - left + 1)\n        \n        return ret\n            \n", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        res = 0\n        left = right = 0\n        window = Counter()\n        \n        while right < len(A) and len(window) < K:\n            window[A[right]] += 1\n            right += 1\n        \n        if len(window) < K:\n            return 0\n        \n        while right < len(A) and len(window) == K:\n            rmarker = right\n            while right < len(A) and A[right] in window:\n                right += 1\n            \n            rcount = right - rmarker + 1\n            \n            lmarker = left\n            while window[A[left]] > 1:\n                window[A[left]] -= 1\n                left += 1\n            \n            lcount = left - lmarker + 1\n            \n            res += lcount * rcount\n            \n            window[A[left]] -= 1\n            del window[A[left]]\n            left += 1\n            right = rmarker\n            while right < len(A) and len(window) < K:\n                window[A[right]] += 1\n                right += 1\n        \n        while len(window) == K:\n            window[A[left]] -= 1\n            res += 1\n            if not window[A[left]]:\n                del window[A[left]]\n            left += 1\n        \n        return res\n", "from collections import defaultdict as dd\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        i = j = 0\n        d = dd(int)\n        res = 0\n        while j < n:\n            # Step 1: find j1\n            while j < n and len(d) < K:\n                d[A[j]] += 1\n                j += 1\n            i1, j1 = i, j\n            # Step 2: find i\n            d[A[i]] -= 1\n            while d[A[i]] > 0:\n                i += 1\n                d[A[i]] -= 1\n            # Step 3: find j\n            while j < n and A[j] in d:\n                j += 1\n            if len(d) == K:\n                res += (i-i1+1)*(j-j1+1)\n            print(i1, i, j1, j)\n            d.pop(A[i])\n            i += 1\n            j = j1\n        return res", "class Solution:\n    def helper(self,A,B):\n        count = 0\n        left = 0\n        right = 0\n        d = {}\n        \n        while right<len(A):\n            if A[right] not in d:\n                d[A[right]] = 0\n            d[A[right]] += 1\n            \n            while len(d)>B:\n                d[A[left]] -= 1\n                if d[A[left]] == 0:\n                    d.pop(A[left])\n                left += 1\n            \n            count += right-left+1\n            right += 1\n        \n        return count    \n                    \n                \n    \n    def subarraysWithKDistinct(self, A: List[int], B: int) -> int:\n        return self.helper(A,B)-self.helper(A,B-1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        dd = {}\n        first_uni = 0\n        start = 0\n        re = 0\n        \n        for i in range(len(A)):\n            dd[A[i]] = dd.get(A[i], 0) + 1\n            \n            if len(dd) == K + 1:\n                dd.pop(A[first_uni])\n                first_uni += 1\n                start = first_uni\n                \n            if len(dd) == K:\n                while dd[A[first_uni]] > 1:\n                    dd[A[first_uni]] -= 1\n                    first_uni += 1\n                re += first_uni - start + 1\n            \n        return re\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def subarraysWithDictinctAtMost(A: List[int],K:int) -> int:\n            left,right = 0,0\n            ans = 0\n            counter = dict()\n            while right < len(A):\n                if A[right] not in counter:\n                   counter[A[right]] = 0\n                counter[A[right]] += 1\n                while len(counter)>K:\n                   counter[A[left]] -= 1\n                   if counter[A[left]] == 0:\n                      counter.pop(A[left])\n                   left += 1\n            \n                ans += right-left+1\n                right += 1\n            return ans\n        return subarraysWithDictinctAtMost(A,K)-subarraysWithDictinctAtMost(A,K-1)\n              \n", "class Solution:\n    def atMostK(self, arr, k):\n        d = {}\n        l, r = 0, 0\n        count = 0\n        while r < len(arr):\n            if arr[r] not in d:\n                d[arr[r]] = 0\n            d[arr[r]] += 1\n\n            while len(d) > k:\n                d[arr[l]] -= 1\n                if d[arr[l]] == 0:\n                    d.pop(arr[l])\n                l += 1\n\n            count += r - l + 1\n            r += 1\n        return count\n    \n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMostK(A, K) - self.atMostK(A,K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        def atMost(A, K):\n            left = res = 0\n            hash_map={}\n            \n            for right in range(len(A)):\n                hash_map[A[right]] = hash_map.get(A[right],0) + 1\n                \n                while len(hash_map) > K:\n                    hash_map[A[left]] -= 1\n                    if hash_map[A[left]] ==0:\n                        del hash_map[A[left]] \n                    left += 1\n                res += right - left + 1\n            return res\n        \n        return atMost(A,K) - atMost(A, K-1)\n            \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n < K:\n            return 0\n        left = 0\n        right = 0\n        totalCount = 0\n        dp = [0 for i in range(20001)]\n        result = 0\n        \n        for right in range(n):\n            if dp[A[right]] == 0:\n                totalCount += 1\n            dp[A[right]] += 1\n            \n            while totalCount >= K:\n                if totalCount == K:\n                    result += 1\n                    \n                dp[A[left]] -= 1\n                if dp[A[left]] == 0:\n                    totalCount -=1 \n                left += 1\n            \n            while totalCount <= K and left > 0:\n                left -= 1\n                if dp[A[left]] == 0:\n                    totalCount += 1\n                dp[A[left]] += 1\n        return result", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A, K):\n        def atMostK(K):\n            cnt, res, i = defaultdict(int), 0, 0\n            for j, val in enumerate(A):\n                cnt[val] += 1\n                while len(cnt) > K:\n                    X = A[i]\n                    cnt[X] -= 1\n                    if not cnt[X]: cnt.pop(X)\n                    i += 1\n                res += j - i + 1\n            return res       \n        return atMostK(K) - atMostK(K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMost(k):\n            counter=collections.defaultdict(int)\n            i=res=0\n            for j,v in enumerate(A):\n                counter[v]+=1\n                while len(counter)>k:\n                    counter[A[i]]-=1\n                    if counter[A[i]]==0:\n                        del counter[A[i]]\n                    i+=1\n                res+=j-i+1\n            return res\n        \n        return atMost(K)-atMost(K-1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMost(A, K) - self.atMost(A,K-1)\n    \n    def atMost(self, A, K):\n        if K == 0: return 0\n        hi, res = 0, 0\n        n = len(A)\n        count = collections.defaultdict(int)\n        for lo in range(n):\n            while hi < n  and (len(count) < K or A[hi] in count):\n                count[A[hi]] += 1\n                hi += 1\n            res += hi - lo\n            count[A[lo]] -= 1\n            if count[A[lo]] == 0:\n                count.pop(A[lo])\n        return res\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def at_most_k(arr, k):\n            start = 0\n            counter = Counter()\n            uniques = 0\n            res = 0\n            for i in range(len(A)):\n                counter[A[i]] += 1\n                if counter[A[i]] == 1:\n                    uniques += 1\n                \n                while uniques>k:\n                    counter[A[start]] -= 1\n                    if counter[A[start]] == 0:\n                        uniques -= 1\n                    \n                    start += 1\n                    \n                res += i-start\n            \n            return res\n        \n        return at_most_k(A, K)-at_most_k(A, K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        keyCounter = defaultdict(int)\n        ALen = len(A)\n        l = 0\n        r = 0\n        ans = 0\n        KNow = 0\n        while r <= ALen:\n            if KNow == K:\n                ans += 1\n                temp = 0\n                while r+temp < ALen and keyCounter[A[r+temp]] > 0:\n                    ans += 1\n                    temp += 1\n                if keyCounter[A[l]] > 0:\n                    keyCounter[A[l]] -= 1\n                if keyCounter[A[l]] == 0:\n                    KNow -= 1\n                l += 1\n            elif KNow < K:     \n                if r == ALen:\n                    return ans\n                if keyCounter[A[r]] == 0:\n                    KNow += 1\n                keyCounter[A[r]] += 1\n                r += 1\n            else:\n                if keyCounter[A[l]] > 0:\n                    keyCounter[A[l]] -= 1\n                if keyCounter[A[l]] == 0:\n                    KNow -= 1\n                l += 1\n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        result = 0\n        i, j = 0, 0\n        cnt = collections.Counter()\n        l = 0\n        n = len(A)\n        while j < n:\n            cnt[A[j]] += 1\n            j += 1\n            if len(cnt) == K:\n                l = 1\n                while cnt[A[i]] > 1:\n                    cnt[A[i]] -= 1\n                    i += 1\n                    l += 1\n                result += l    \n                break\n        while j < n:\n            if A[j] not in cnt:\n                cnt.pop(A[i])\n                i += 1\n                l = 1\n            cnt[A[j]] += 1\n            while cnt[A[i]] > 1:\n                cnt[A[i]] -= 1\n                i += 1\n                l += 1\n            # print(j, l)\n            result += l\n            j += 1\n        return result", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n < K:\n            return 0\n        \n        # 3 pointer sliding window\n        # p1 points to the 1st unique integer, start of the window\n        # p2 points to the first occurrance of the Kth unique integer after p1\n        # p3 points the the first occurrance of the next unique integer after p2, of end of string at n\n        # Given such a window, we add (p3-p2) to the count\n        # Then move p1 by 1. Check if that reduces the number of integers to K-1. If no, add p3-p2 again.\n        # If yes, then move p2 until the count goes up to K again. If p2 lands on p3 when doing this,\n        # then need to move p3 to the next integer. If p3 is already at EOS, return\n        \n        # To maintain the number of unique integers in a window, we'll use a hashmap\n        # Be careful, we need this dict to contain only nonzero count entries. So if a count becomes zero, delete it!\n        count = defaultdict(int)\n        p1 = 0; p2 = 0; p3 = 0\n        count[A[0]] += 1\n        ans = 0\n        while p2 < n:\n            # Move p2 until the number of unique integers in the window hits K\n            remaining = K-len(count)\n            while remaining > 0:\n                p2 += 1\n                if p2 == n:\n                    return ans\n                count[A[p2]] += 1\n                if count[A[p2]] == 1:\n                    remaining -= 1\n            # p2 now points to the first instance of the Kth integer after p1\n            # Now move p3 to the next unique integer after p2\n            # print(\\\"count: {}, A[{}]: {}, {}\\\".format(count, p3, A[p3], A[p3] in count))\n            while p3 < n and A[p3] in count:\n                p3 += 1\n            # p3 is either n or points to the (K+1)th integer after p1\n            # Now, keep adding (p3-p2) to the count and advancing p1 until we no longer have K integers in this window\n            while len(count) == K:\n                ans += (p3-p2)\n                # print(\\\"p1:{}, p2:{}, p3:{}, count:{}\\\".format(p1, p2, p3, count))\n                p1 += 1\n                count[A[p1-1]] -= 1\n                if count[A[p1-1]] == 0:\n                    del count[A[p1-1]]\n        return ans", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n\n        def longest_with_atmostk(s,k):\n            start=0\n            counts=defaultdict(int) #keep count of each character\n            n_chars=0 #store the length of the string from start to current index\n            max_len=0 #maximum possible length\n            for i in range(len(s)):\n                if counts[s[i]]==0: #if the character is never seen before increase length of the current string\n\n                    n_chars+=1 \n                counts[s[i]]+=1  #increase the count of the current character\n                while n_chars>k: #if there is no repeating characters the length of the string should be i-start+1\n                    if counts[s[start]]>0: #if the start \n                        counts[s[start]]-=1\n                        if counts[s[start]]==0:\n                            n_chars-=1\n                    start+=1\n                max_len+=i-start+1\n\n            return max_len\n\n        \n        return longest_with_atmostk(A,K)-longest_with_atmostk(A,K-1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMost(A,K) - self.atMost(A,K - 1)\n    \n    def atMost(self,A,K):\n        count = collections.Counter()\n        res = i = 0\n        for j in range(len(A)):\n            if count[A[j]] == 0:\n                K -= 1\n            count[A[j]] += 1\n            \n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0:\n                    K += 1\n                i += 1\n            res += j - i + 1\n        return res\n        \n        \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMost(A, K) - self.atMost(A, K-1)\n    \n    def atMost(self, A, k):\n        left = res = 0 \n        freq = collections.Counter()\n        for right in range(len(A)):\n            if freq[A[right]] == 0:\n                k-= 1\n            freq[A[right]] += 1\n            \n            while k < 0:\n                freq[A[left]] -= 1\n                if freq[A[left]] == 0:\n                    k += 1\n                left += 1 \n                \n            res += right - left + 1\n        \n        return res ", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        def atMostK(A, K):\n            count = collections.Counter()\n            res , l , window_count= 0, 0, 0 \n            for r,c in enumerate(A):\n                if count[c] == 0: window_count += 1\n                count[c] += 1\n                while window_count > K:\n                    count[A[l]] -= 1\n                    if count[A[l]] == 0: window_count -= 1\n                    l += 1\n                res += r - l + 1\n            return res        \n        return atMostK(A, K) - atMostK(A, K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.helper(A, K) - self.helper(A, K-1)\n        \n    def helper(self, A, K):\n        counter = collections.Counter()\n        p1 = p2 = 0\n        res = 0\n        while p2 < len(A):\n            if counter[A[p2]] == 0:\n                K -= 1\n            counter[A[p2]] += 1\n            while K < 0:\n                counter[A[p1]] -= 1\n                if counter[A[p1]] == 0:\n                    K += 1\n                p1 += 1\n            p2 += 1\n            res += p2 - p1\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMost(K):\n            res, lo, seen = 0, 0, Counter()\n            for hi in range(len(A)):\n                if seen[A[hi]] == 0: K -= 1\n                seen[A[hi]] += 1\n                while K < 0:\n                    seen[A[lo]] -= 1\n                    if seen[A[lo]] == 0: K += 1\n                    lo += 1\n                res += hi - lo + 1\n            return res\n        \n        return atMost(K) - atMost(K-1)\n", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        def atMostK(A, K):\n            count = collections.Counter()\n            res , l  ,  window_count= 0, 0, 0 \n            for r,c in enumerate(A):\n                if count[c] == 0: window_count += 1\n                count[c] += 1\n                while window_count > K:\n                    count[A[l]] -= 1\n                    if count[A[l]] == 0: window_count -= 1\n                    l += 1\n                res += r - l + 1\n            return res        \n        return atMostK(A, K) - atMostK(A, K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        counter1, counter2 = collections.Counter(), collections.Counter()\n        slow = fast = res = 0\n\n        for a in A:\n            counter1[a], counter2[a] = counter1[a] + 1, counter2[a] + 1\n            while len(counter2) == K:\n                counter2[A[fast]] -= 1\n                if not counter2[A[fast]]: del counter2[A[fast]]\n                fast += 1\n            while len(counter1) > K:\n                counter1[A[slow]] -= 1\n                if not counter1[A[slow]]: del counter1[A[slow]]\n                slow += 1\n            res += fast - slow\n\n        return res\n\n", "import collections\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        counter = collections.defaultdict(int)\n        result = 0\n        start = startK = 0\n        \n        for high, num in enumerate(A):\n            \n            counter[num] += 1\n                \n            if len(counter) == K + 1:\n                del counter[A[startK]]\n                startK += 1\n                start = startK\n            if len(counter) == K:\n                while counter[A[startK]] > 1:\n                    counter[A[startK]] -= 1\n                    startK += 1\n                result += startK - start + 1\n                \n        return result\n                    \n                \n            \n", "class Solution:\n    def subarraysWithAtMostK(self, A: List[int], K: int) ->int:\n        result = i = 0\n        count = collections.Counter()\n        \n        for j in range(len(A)):\n            if count[A[j]] == 0: K -= 1\n            count[A[j]] += 1\n        \n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0: K +=1\n                i += 1\n            result += j - i + 1\n        \n        return result\n        \n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.subarraysWithAtMostK(A, K) - self.subarraysWithAtMostK(A, K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        def atMostK(K):\n            count = collections.Counter()\n            res = i = 0\n            for j in range(len(A)):\n                if count[A[j]] == 0: K -= 1\n                count[A[j]] += 1\n                while K < 0:\n                    count[A[i]] -= 1\n                    if count[A[i]] == 0: K += 1\n                    i += 1\n                res += j - i + 1\n            return res\n        \n        return atMostK(K) - atMostK(K - 1)\n\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMost(A,K) - self.atMost(A,K - 1)\n    \n    def atMost(self,A,K):\n        count = collections.Counter()\n        res = i = 0\n        for j in range(len(A)):\n            if count[A[j]] == 0:\n                K -= 1\n            count[A[j]] += 1\n            \n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0:\n                    K += 1\n                i += 1\n                \n            res += j - i + 1\n        return res\n", "import collections\nclass Solution:\n    def atMostK(self, A, K):\n        count = collections.Counter()\n        i, ans = 0, 0 # i is left pointer of window, j is right\n        for j in range(len(A)):\n            if count[A[j]] == 0:\n                K -= 1  # K keeps track of # of different chars in the window\n            count[A[j]] += 1\n            while K < 0: # when there are too many different chars, contract window\n                count[A[i]] -= 1\n                if count[A[i]] == 0: # when A[i] is no longer in the window\n                    K += 1\n                i += 1\n            ans += j - i + 1 # for each new A[j], we add j - i + 1 substrings\n        return ans\n        \n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\n        \n        \n    # exactly(K) = atMost(K) - atMost(K-1)\n    # why j - i + 1? For [a, b, c, d] and K = 3, for atMostK, a -> [a], b -> [b], [a, b], c -> [c], [b, c], [a, b, c], d -> [d], [c, d], [b, c, d] every time we look at a new item we add the length of window to total count\n", "from collections import Counter\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        W1 = Counter()\n        W2 = Counter()\n        l1 = 0\n        l2 = 0\n        res = 0\n        \n        for i in range(len(A)):\n            W1[A[i]] += 1\n            W2[A[i]] += 1\n            \n            while len(W1) > K:\n                W1[A[l1]] -= 1\n                if W1[A[l1]] == 0:\n                    del W1[A[l1]]\n                l1 += 1\n            \n            while len(W2) > K-1:\n                W2[A[l2]] -= 1\n                if W2[A[l2]] == 0:\n                    del W2[A[l2]]\n                l2 += 1\n            \n            res += l2 - l1\n        return res", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Counter()\n        window2 = Counter()\n        l1 = 0\n        l2 = 0\n        total = 0\n        \n        for r, c in enumerate(A):\n            window1[c] += 1\n            window2[c] += 1\n            \n            while(len(window1)>K):\n                window1[A[l1]] -= 1\n                if window1[A[l1]] == 0: del window1[A[l1]]\n                l1 += 1\n            while(len(window2)>K-1):\n                window2[A[l2]] -= 1\n                if window2[A[l2]] == 0: del window2[A[l2]]\n                l2 += 1\n                \n            total += l2 - l1\n        return total\n       \n            \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\n        \n    def atMostK(self, A, k):\n        start = 0\n        end = 0\n        \n        res = 0\n        \n        chars = collections.Counter()\n        \n        distinct = 0\n        \n        while end < len(A):\n            if chars[A[end]] == 0:\n                distinct += 1\n            \n            chars[A[end]] += 1\n            \n            while distinct > k:\n                chars[A[start]] -= 1\n                if chars[A[start]] == 0:\n                    distinct -= 1\n                \n                start += 1\n            \n            res += end - start + 1\n            end += 1\n            \n        return res", "class Solution:\n    \n    def _identify_limit(self, A, current_limit, K,  char_count_after_limit):\n        char_count_after_limit = {k: v for k, v in char_count_after_limit.items()}\n        unique_chars = {i for i in char_count_after_limit if char_count_after_limit[i] > 0}\n        # print(unique_chars)\n        while len(unique_chars) == K : \n            # print(\\\"WHILE\\\", char_count_after_limit)\n            temp_char = A[current_limit]\n            char_count_after_limit[temp_char] = char_count_after_limit[temp_char] - 1\n            if char_count_after_limit[temp_char] == 0: \n                unique_chars.remove(temp_char)\n            current_limit += 1\n            \n        char_count_after_limit[A[current_limit - 1]] = char_count_after_limit[A[current_limit - 1]] + 1\n        return  current_limit - 1, char_count_after_limit\n    \n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        # char_info = {item : [] for item in set(A)} \n        # unique_char_count = {}\n        # unique_char = set()\n        # start_idx = 0 \n        # end_idx = 0\n        # num_substr = 0\n        # current_subarray = []\n        # current_valid_count = 0 \n        # # In any valid subarray what is the index upto which left index could be moved without making subarray bad \n        # # Whenever end_idx is moved to right keeping subarray good compute limit_idx again \n        # limit_idx = 0\n        # while end_idx < len(A) + 1 : \n        #     if len(unique_char) == K : \n        #         # temp_unique_char = {i for i in unique_char}\n        #         # temp_char_count = {k:v for k, v in unique_char_count.items()}\n        #         # temp_start_idx = start_idx \n        #         # while len(temp_unique_char) == K:\n        #         #     temp_char = A[temp_start_idx]\n        #         #     temp_char_count[temp_char] = temp_char_count[temp_char] - 1\n        #         #     if temp_char_count[temp_char] == 0: \n        #         #         temp_unique_char.remove(temp_char)\n        #         #     temp_start_idx += 1\n        #         #     num_substr += 1\n        #         # if end_idx < len(A):\n        #         #     current_char = A[end_idx]\n        #         #     unique_char.add(current_char)\n        #         #     unique_char_count[current_char] = unique_char_count.get(current_char, 0) + 1\n        #         # print(\\\"PREV\\\", unique_char_count)\n        #         limit_idx, unique_char_count = self._identify_limit(A, limit_idx, K, unique_char_count)\n        #         num_substr += limit_idx - start_idx + 1\n        #         # print(start_idx, limit_idx, end_idx- 1)\n        #         # print(unique_char_count)\n        #         if end_idx < len(A):\n        #             current_char = A[end_idx]\n        #             unique_char.add(current_char)\n        #             unique_char_count[current_char] = unique_char_count.get(current_char, 0) + 1\n        #         end_idx += 1 \n        #     elif len(unique_char) > K: \n        #         # Remove limit_idx from stats\n        #         current_char = A[limit_idx]\n        #         unique_char.remove(current_char)\n        #         unique_char_count[current_char] = 0\n        #         start_idx = limit_idx + 1\n        #         limit_idx = start_idx \n        #     else: \n        #         if end_idx < len(A):\n        #             current_char = A[end_idx]\n        #             unique_char.add(current_char)\n        #             unique_char_count[current_char] = unique_char_count.get(current_char, 0) + 1\n        #         end_idx += 1 \n        # return num_substr\n        counter1, counter2 = collections.Counter(), collections.Counter()\n        slow = fast = res = 0\n\n        for _, a in enumerate(A):\n            counter1[a], counter2[a] = counter1[a] + 1, counter2[a] + 1\n            while len(counter2) == K:\n                counter2[A[fast]] -= 1\n                if not counter2[A[fast]]: del counter2[A[fast]]\n                fast += 1\n            while len(counter1) > K:\n                counter1[A[slow]] -= 1\n                if not counter1[A[slow]]: del counter1[A[slow]]\n                slow += 1\n            res += fast - slow\n\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        return self.atMostK(A, K - 1) - self.atMostK(A, K)\n\n    def atMostK(self, A, K):\n        count = collections.Counter()\n        ans = 0\n        i = 0\n        for j in range(len(A)):\n            count[A[j]] += 1 \n            while len(count) > K:\n                count[A[i]] -= 1 \n                if count[A[i]] == 0:\n                    del count[A[i]]\n                i+= 1 \n            ans += i - j + 1 \n        return ans ", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        sum = 0\n        begin = 0\n        end = 0\n        s = collections.defaultdict(int)\n        lA = len(A)\n        for i in range(lA):\n            if len(s) >= K:\n                s[A[i]] += 1\n                if s[A[i]] > 1:\n                    newend = end\n                    while s[A[newend]] > 1:\n                        s[A[newend]] -= 1\n                        newend += 1\n                    end = newend\n                else:\n                    begin = end\n                    while s[A[begin]] > 1:\n                        s[A[begin]] -= 1\n                        begin += 1\n                    s[A[begin]] -= 1\n                    begin += 1\n                    end = begin\n                    while s[A[end]] > 1:\n                        s[A[end]] -= 1\n                        end += 1\n                sum += (end - begin + 1)\n            else:\n                s[A[i]] += 1\n                if len(s) == K:\n                    while s[A[end]] > 1:\n                        s[A[end]] -= 1\n                        end += 1\n                    sum += (end - begin + 1)\n        return sum\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMostK(k):\n            count = Counter()\n            ans = left = 0\n            for i, a in enumerate(A):\n                if count[a] == 0:\n                    k -= 1\n                count[a] += 1\n                while k < 0:\n                    count[A[left]] -= 1\n                    if count[A[left]] == 0:\n                        k += 1\n                    left += 1\n                ans += i - left + 1\n            return ans\n        return atMostK(K) - atMostK(K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\n\n    def atMostK(self, A, K):\n        ctr = collections.Counter()\n        res = i = 0\n        for j in range(len(A)):\n            if ctr[A[j]] == 0:\n                K -= 1\n            ctr[A[j]] += 1\n            while K < 0:\n                ctr[A[i]] -= 1\n                if ctr[A[i]] == 0:\n                    K += 1\n                i += 1\n            res += j - i + 1\n        return res\n        \n#         count = collections.Counter()\n#         res = i = 0\n#         for j in range(len(A)):\n#             if count[A[j]] == 0: K -= 1\n#             count[A[j]] += 1\n#             while K < 0:\n#                 count[A[i]] -= 1\n#                 if count[A[i]] == 0: K += 1\n#                 i += 1\n#             res += j - i + 1\n#         return res\n", "from collections import Counter\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.helper(A, K) - self.helper(A, K-1)\n    def helper(self, A, K):\n        currSum = 0 \n        d = Counter() \n        i = 0 \n        for j in range(len(A)): \n            d[A[j]] += 1\n            while(len(d) > K): \n                d[A[i]] -= 1\n                if not d[A[i]]: del d[A[i]]\n                i+= 1\n            currSum += ((j-i)+1)\n        return currSum\n#         mapp={}\n#         n=len(A)\n#         j=0\n#         ans=0\n        \n#         for i,c in enumerate(A):\n#             mapp[c]=i # last position of c\n#             while (len(mapp)>K):\n#                 if j==mapp[A[j]]:\n#                     del mapp[A[j]]\n#                 j+=1\n#             ans+=i-j+1\n#         return ans\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        # exactly k = at most k - at most k - 1\n        \n        def at_most(x):\n            left = 0\n            counts = Counter()\n            res = 0\n            for right, num in enumerate(A):\n                counts[num] += 1\n                \n                while len(counts) > x:\n                    counts[A[left]] -= 1\n                    if counts[A[left]] == 0:\n                        del counts[A[left]]\n                    left += 1\n                \n                res += right - left + 1\n            \n            return res\n        \n        return at_most(K) - at_most(K - 1)", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\n\n    def atMostK(self, s, k):        \n        if not s:\n            return 0\n        N = len(s)\n        left, right = 0, 0\n        ret = 0\n        counter = collections.Counter()\n        counter[s[right]] += 1\n        while right < N:\n            if len(counter) > k:\n                counter[s[left]] -= 1\n                if counter[s[left]] == 0:\n                    del counter[s[left]]\n                left += 1\n            else:\n                right += 1\n                ret +=  right - left\n                if right < N:\n                    counter[s[right]] += 1\n            \n        return ret", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def at_most(K):\n            window = Counter()\n            left = right = 0\n            res = 0\n            while right < len(A):\n                window[A[right]] += 1\n                while len(window) > K:\n                    window[A[left]] -= 1\n                    if not window[A[left]]:\n                        del window[A[left]]\n                    left += 1\n                \n                res += right - left + 1\n                right += 1\n            \n            return res\n        \n        return at_most(K) - at_most(K - 1)\n", "from collections import Counter\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        equalCt, lessCt = Counter(), Counter()\n        equalPt, lessPt = 0, 0\n        res = 0\n\n        def add_to_counter(x, co):\n            co[x] += 1\n        def subtr_from_counter(x, co):\n            co[x] -= 1\n            if co[x] == 0:\n                del co[x]\n\n        for right, num in enumerate(A):\n            add_to_counter(num, equalCt)\n            add_to_counter(num, lessCt)\n\n            while len(equalCt) > K:\n                subtr_from_counter(A[equalPt],equalCt)\n                equalPt += 1\n\n            while len(lessCt) >= K:\n                subtr_from_counter(A[lessPt], lessCt)\n                lessPt += 1\n            res += (lessPt - equalPt)\n\n        return res\n", "from collections import Counter\n\n\ndef subarraysWithAtMostK(arr: list, k: int) -> int:\n    start = 0\n    counter = Counter()\n    res = 0\n\n    for end in range(len(arr)):\n        num = arr[end]\n        counter[num] += 1\n\n        # more than k distinct numbers\n        # need to shrink\n        while len(counter) > k:\n            to_remove = arr[start]\n            counter[to_remove] -= 1\n            if counter[to_remove] == 0:  # remove if frequency reduces to zero\n                del counter[to_remove]\n            start += 1\n\n        res += end - start + 1\n\n    return res\n\n\ndef subarraysWithKDistinct(arr: list, k: int) -> int:\n    # exactly k => atmost(k) - atmost(k - 1)\n    return subarraysWithAtMostK(arr, k) - subarraysWithAtMostK(arr,  k - 1)\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return subarraysWithKDistinct(A, K)\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.helper(A, K) - self.helper(A, K-1)\n        \n    def helper(self, A, K):\n        counter = collections.Counter()\n        p1 = p2 = 0\n        res = 0\n        while p2 < len(A):\n            if counter[A[p2]] == 0:\n                K -= 1\n            counter[A[p2]] += 1\n            while K < 0:\n                counter[A[p1]] -= 1\n                if counter[A[p1]] == 0:\n                    K += 1\n                p1 += 1\n            res += p2 - p1 + 1\n            p2 += 1\n        print(counter)\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def atMost(A: List[int], K: int):\n            cache=collections.Counter()\n            res,i=0,0\n            for j in range(len(A)):\n                cache[A[j]]+=1\n                while len(cache)>K:\n                    cache[A[i]]-=1\n                    if cache[A[i]]==0:\n                        del cache[A[i]]\n                    i+=1\n                res+=j-i+1\n            return res\n        return atMost(A,K)-atMost(A,K-1)\n", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window = Counter()\n        res = 0\n        left = right = 0\n        while True:\n            while right < len(A) and len(window) < K:\n                window[A[right]] += 1\n                right += 1\n            \n            if len(window) < K:\n                return res\n            \n            j = right\n            while j < len(A) and A[j] in window:\n                j += 1\n            \n            res += j - right + 1\n            window[A[left]] -= 1\n            if not window[A[left]]:\n                del window[A[left]]\n            left += 1\n        \n        return res\n", "class Window:\n    def __init__(self):\n        self.counter = Counter()\n        self.unique = 0\n\n    def add(self, value: int):\n        self.counter[value] += 1\n        if self.counter[value] == 1:\n            self.unique += 1\n\n    def remove(self, value: int):\n        self.counter[value] -= 1\n        if self.counter[value] == 0:\n            self.unique -= 1\n\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        left1 = left2 = answer = 0\n\n        for right in A:\n            window1.add(right)\n            window2.add(right)\n\n            while window1.unique > K:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.unique >= K:\n                window2.remove(A[left2])\n                left2 += 1\n            answer += left2 - left1\n        return answer\n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.subarraysWithAtmostKDistinct(A, K) - self.subarraysWithAtmostKDistinct(A, K-1)\n    def subarraysWithAtmostKDistinct(self, A, K):\n        l, r, count, res = 0, 0, 0, 0\n        hashmap = [0] * 20001\n        while r < len(A):\n            hashmap[A[r]] += 1\n            if hashmap[A[r]] == 1:\n                count += 1\n            while count > K:\n                hashmap[A[l]] -= 1\n                if hashmap[A[l]] == 0:\n                    count -= 1\n                l += 1\n            res += r - l+ 1\n            r += 1\n        return res", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def remove(m, n):\n            if m[n] == 1:\n                del m[n]\n            else:\n                m[n] -= 1\n        m1, m2 = collections.Counter(), collections.Counter()\n        res = 0\n        i1 = i2 = -1\n        for i0, n in enumerate(A):\n            while i1 + 1 < len(A) and len(m1) < K:\n                i1 += 1\n                m1[A[i1]] += 1\n            if len(m1) < K:\n                return res\n            \n            while i2 + 1 < len(A) and len(m2) < K + 1:\n                i2 += 1\n                m2[A[i2]] += 1\n            \n            \n            res += i2 - i1 + int(len(m2) == K)\n            remove(m1, n)\n            remove(m2, n)\n        return res\n            \n            \n            \n            \n                \n                    \n                \n\n            \n        \n        \n        \n        \n                                        \n", "from collections import Counter\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K-1)\n    \n    def subarraysWithAtMostKDistinct(self, A, K):\n        window = Counter()\n        j = 0\n        res = 0\n        for i in range(len(A)):\n            c = A[i]\n            \n            window[c] += 1\n            \n            while len(window) > K:\n                last = A[j]\n                window[last] -= 1\n                if window[last] == 0:\n                    del window[last]\n                j += 1\n            # print(j, i)\n            res += i-j + 1\n        return res", "from collections import Counter\n\ndef solve(A, K):\n    count = Counter()\n    front = iter(A)\n    \n    ans = 0\n    size = 0\n    for k in A:\n        count[k] += 1\n        size += 1\n        \n        while len(count) > K:\n            key = next(front)\n            count[key] -= 1\n            size -= 1\n            if count[key] == 0:\n                del count[key]\n\n        ans += size\n    \n    return ans\n            \n            \nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        cx = Counter()\n        cy = Counter()\n        \n        fx = iter(A)\n        fy = iter(A)\n        \n        sx = 0\n        sy = 0\n        \n        ans = 0\n        for k in A:\n            cx[k] += 1\n            cy[k] += 1\n            sx += 1\n            sy+= 1\n            \n            while len(cx) > K:\n                key = next(fx)\n                cx[key] -= 1\n                sx -= 1\n                if cx[key] == 0:\n                    del cx[key]\n                    \n            while len(cy) > K - 1:\n                key = next(fy)\n                cy[key] -= 1\n                sy -= 1\n                if cy[key] == 0:\n                    del cy[key]\n                    \n            ans += sx - sy\n            \n        return ans\n                \n            \n                \n                \n                \n                \n                \n                \n", "class Solution:\n    def subarraysWithKDistinct(self, A, K):\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\n\n    def atMostK(self, A, K):\n        count = collections.Counter()\n        res = left = right = distinct = 0\n        while right < len(A):\n            count[A[right]] += 1\n            if count[A[right]] == 1:\n                distinct += 1\n            while distinct > K:\n                count[A[left]] -= 1\n                if count[A[left]] == 0:\n                    distinct -= 1\n                left += 1\n            res += (right - left) + 1\n            right += 1\n        return res\n    '''\n        for j in range(len(A)):\n            if count[A[j]] == 0: K -= 1\n            count[A[j]] += 1\n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0: K += 1\n                i += 1\n            res += j - i + 1\n    '''", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        good_start, bad_start = -1, -1\n        good_count, bad_count = {}, {}\n        \n        \n        def add(count, element):\n            if element not in count:\n                count[element] = 0\n            count[element] += 1\n\n        def remove(count, element):\n            count[element] -= 1\n            if count[element] == 0:\n                del count[element]      \n    \n        def find_good_start(A, K, cur_pos, index, good_count):\n            if len(good_count) == K:\n                return index\n            cur = index\n            while cur < cur_pos and len(good_count) > K:\n                cur += 1\n                remove(good_count, A[cur])\n            return cur\n\n        total = 0\n        for i in range(len(A)):\n            cur = A[i]\n            add(good_count, cur)\n            add(bad_count, cur)\n            if len(good_count) >= K:\n                good_start = find_good_start(A, K, i, good_start, good_count)\n                bad_start = find_good_start(A, K-1, i, bad_start, bad_count)\n                if len(good_count) == K and len(bad_count) == K-1:\n                    total +=  bad_start - good_start\n        return total", "import collections\n\nclass Window:\n    def __init__(self):\n        self.num = 0\n        self.dic = collections.Counter()\n        \n    def add(self, v: int) -> int:\n        if self.dic[v] == 0:\n            self.num += 1\n        self.dic[v] += 1\n        return self.num\n        \n    def remove(self, v: int) -> int:\n        self.dic[v] -= 1\n        if self.dic[v] == 0:\n            self.num -= 1\n        return self.num\n\n\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        wk = Window()\n        wm = Window()\n        \n        sk = 0\n        sm = 0\n        e  = 0\n        ans = 0\n        \n        while e < len(A):\n            ce = A[e]\n            nk = wk.add(ce)\n            nm = wm.add(ce)\n            \n            if nk < K:\n                e += 1\n            elif nk == K:\n                while nm != K-1:\n                    nm = wm.remove(A[sm])\n                    sm += 1\n                ans += sm - sk\n                e += 1\n            else:\n                while nk != K:\n                    nk = wk.remove(A[sk])\n                    sk += 1\n                while nm != K-1:\n                    nm = wm.remove(A[sm])\n                    sm += 1\n                ans += sm - sk\n                e += 1\n                \n        return ans\n                \n            \n            \n", "class Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        m1, m2 = collections.Counter(), collections.Counter()\n        def remove(m, n):\n            m[n] -= 1\n            if not m[n]:\n                del m[n]\n            \n        res = 0\n        left = right = -1\n        for i, n in enumerate(A):\n            # print((i, n))\n            while left < len(A) - 1 and len(m1) < K:\n                left += 1\n                m1[A[left]] +=1\n            \n            # print('left, m1', left, m1)\n            if len(m1) < K:\n                return res\n            \n            while right < len(A) - 1 and len(m2) <= K:\n                right += 1\n                m2[A[right]] += 1\n            # print('right, m2', right, m2)\n            \n            res += right - left + (len(m2) == K)\n            # print(A[left:right + 1], 'left, right', left, right, res)\n            remove(m1, n)\n            remove(m2, n)\n        return res\n                \n\n            \n        \n        \n        \n        \n                                        \n", "from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        def subArray(k):\n            right = 0\n            left = 0\n            freq = collections.defaultdict(int)\n            count = 0\n            while right < len(A):\n                freq[A[right]] += 1\n                right += 1\n                \n                while len(freq) > k:\n                    freq[A[left]] -= 1\n                    if freq[A[left]] == 0:\n                        del freq[A[left]]\n                    left += 1\n                count += right - left\n            return count\n        output = 0   \n        output += subArray(K) - subArray(K-1)\n        return output\n", "from collections import Counter\n\ndef solve(A, K):\n    count = Counter()\n    front = iter(A)\n    size = 0\n    \n    ans = 0\n    for k in A:\n        count[k] += 1\n        size += 1\n        \n        while len(count) > K:\n            key = next(front)\n            count[key] -= 1\n            size -= 1\n            if count[key] == 0:\n                del count[key]\n\n        ans += size\n    \n    return ans\n            \n            \nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        return solve(A, K) - solve(A, K - 1)\n            \n                \n                \n                \n                \n                \n                \n"]
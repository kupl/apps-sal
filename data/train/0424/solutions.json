["class Solution:\n    def largestOverlap(self, A, B) -> int:\n        leng = len(A[0])\n\n        # convert A, B to binary\n        a = 0\n        b = 0\n        for i in range(0, leng * leng):\n            row = int(i % leng)\n            col = int(i / leng)\n            a = (a << 1) + A[col][row]\n            b = (b << 1) + B[col][row]\n\n        maxsum = 0\n        for i in range(-leng + 1, leng):\n            if i < 0:\n                mask = ('0' * abs(i) + '1' * (leng - abs(i))) * leng\n                bp = (b & int(mask, 2)) << abs(i)\n            elif i > 0:\n                mask = ('1' * (leng - abs(i)) + '0' * abs(i)) * leng\n                bp = (b & int(mask, 2)) >> abs(i)\n            else:\n                bp = b\n\n            for j in range(-leng + 1, leng):\n                if j < 0:\n                    bpp = bp >> (leng * abs(j))\n                elif j > 0:\n                    bpp = (bp << (leng * abs(j))) & ((2 ** (leng * leng)) - 1)\n                else:\n                    bpp = bp\n                maxsum = max(maxsum, bin(a & bpp).count('1'))\n\n        return maxsum", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        N = len(A)\n        ct = Counter()\n        for i, row in enumerate(A):\n            for j, col in enumerate(row):\n                if col:\n                    for i2, row2 in enumerate(B):\n                        for j2, col2 in enumerate(row2):\n                            if col2:\n                                ct[i - i2, j - j2] += 1\n        return max(ct.values() or [0])", "class Solution(object):\n    def largestOverlap(self, A, B):\n        count = [0] * (2*len(A)-1)**2\n        for i, row in enumerate(A):\n            for j, v in enumerate(row):\n                if not v:\n                    continue\n                for i2, row2 in enumerate(B):\n                    for j2, v2 in enumerate(row2):\n                        if not v2:\n                            continue\n                        count[(len(A)-1+i-i2)*(2*len(A)-1) +\n                              len(A)-1+j-j2] += 1\n        return max(count)", "import collections\nclass Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        count = collections.Counter()\n        for i, rowa in enumerate(A):\n            for j in range(len(rowa)):\n                if rowa[j]:\n                    for m, rowb in enumerate(B):\n                        for n in range(len(rowb)):\n                            if rowb[n]:\n                                count[i-m, j-n] += 1\n        return max(list(count.values()) or [0])\n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        N = len(A)\n        ct = Counter()\n        for i, row in enumerate(A):\n            for j, col in enumerate(row):\n                if col:\n                    for i2, row2 in enumerate(B):\n                        for j2, col2 in enumerate(row2):\n                            if col2:\n                                 ct[i - i2, j - j2] += 1\n        # print(ct)\n        return max(ct.values() or [0])", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        dic = {}\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                pos = A[i][j]\n                if pos != 1: continue\n                for x in range(len(B)):\n                    for y in range(len(B[x])):\n                        pos = B[x][y]\n                        if pos != 1: continue\n                        xdiff, ydiff = y - j, x - i\n                        if (xdiff,  ydiff) not in dic:\n                            dic[(xdiff,  ydiff)] = 1\n                        else: dic[(xdiff,  ydiff)] += 1\n        if len(dic) == 0: return 0\n        return max(dic.values())", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        \n        \n        # get non-zeros\n        def nonzero_cells(matrix):\n            ones = []\n            for r in range(len(matrix)):\n                for c in range(len(matrix[r])):\n                    if matrix[r][c] == 1:\n                        ones.append((r, c))\n            return ones\n        \n        a = nonzero_cells(A)\n        b = nonzero_cells(B)\n        overlap_vectors = defaultdict(int)\n        \n        max_overlap = 0\n        for x_a, y_a in a:\n            for x_b, y_b in b:\n                overlap_vector = ((x_b - x_a, y_b - y_a))\n                overlap_vectors[overlap_vector] += 1\n                max_overlap = max(max_overlap, overlap_vectors[overlap_vector])\n        \n        return max_overlap", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        counts, best = {}, 0\n        size = len(A[0])\n        for x1 in range(size):\n            for y1 in range(size):\n                if A[y1][x1] == 1:\n                    for x2 in range(size):\n                        for y2 in range(size):\n                            if B[y2][x2] == 1:\n                                diff = (x2-x1, y2-y1)\n                                counts[diff] = counts.get(diff, 0) + 1\n                                best = counts[diff] if counts[diff] > best else best\n        return best\n", "#\n# @lc app=leetcode id=835 lang=python3\n#\n# [835] Image Overlap\n#\n\n# @lc code=start\nfrom functools import lru_cache\nfrom copy import deepcopy\n\n@lru_cache(None)\ndef countBits(n):\n    return 0 if n == 0 else (n & 1) + countBits(n >> 1)\n\nclass Solution:\n    def stateCompress(self, img):\n        n, m = len(img), len(img[0])\n        rows = [0 for _ in range(n)]\n        for i, row in enumerate(img):\n            for e in row:\n                rows[i] = (rows[i] << 1) + e\n        return n, m, rows\n    \n    \n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        n, m, rA = self.stateCompress(A)\n        _, _, rB = self.stateCompress(B)\n\n        def shift(arr1, arr2, l):\n            return sum(countBits(e1 & e2) for e1, e2 in zip(arr1[:l], arr2[n-l:n]))\n\n        maxOverLap = 0\n        tA = deepcopy(rA)\n        tB = deepcopy(rB)\n        \n        for dc in range(m):\n            for dr in range(1, n + 1):\n                maxOverLap = max(maxOverLap, shift(tA, rB, dr))\n                maxOverLap = max(maxOverLap, shift(tB, rA, dr))\n            tA = [ e >> 1 for e in tA]\n            tB = [ e >> 1 for e in tB] \n        return maxOverLap\n                \n                \n# @lc code=end\n\n", "#\n# @lc app=leetcode id=835 lang=python3\n#\n# [835] Image Overlap\n#\n\n# @lc code=start\nfrom functools import lru_cache\nfrom copy import deepcopy\n\n@lru_cache(None)\ndef countBits(n):\n    if n == 0:\n        return 0\n    return (n & 1) + countBits(n >> 1)\n\nclass Solution:\n    def stateCompress(self, img):\n        n, m = len(img), len(img[0])\n        rows = [0 for _ in range(n)]\n        for i, row in enumerate(img):\n            for e in row:\n                rows[i] = (rows[i] << 1) + e\n        return n, m, rows\n    \n    \n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        n, m, rA = self.stateCompress(A)\n        _, _, rB = self.stateCompress(B)\n\n        def shift(arr1, arr2, l):\n            return sum(countBits(e1 & e2) for e1, e2 in zip(arr1[:l], arr2[n-l:n]))\n\n        maxOverLap = 0\n        tA = deepcopy(rA)\n        tB = deepcopy(rB)\n        \n        for dc in range(m):\n            for dr in range(1, n + 1):\n                maxOverLap = max(maxOverLap, shift(tA, rB, dr))\n                maxOverLap = max(maxOverLap, shift(tB, rA, dr))\n            tA = [ e >> 1 for e in tA]\n            tB = [ e >> 1 for e in tB] \n        return maxOverLap\n                \n                \n# @lc code=end\n\n", "class Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        n = len(img1)\n        \n        s1 = set()\n        s2 = set()\n        \n        for j,row in enumerate(img1):\n            for i,v in enumerate(row):\n                if v == 1:\n                    s1.add((j,i))\n        for j,row in enumerate(img2):\n            for i,v in enumerate(row):\n                if v == 1:\n                    s2.add((j,i))\n        \n        d = {}\n        \n        for x in s1:\n            for y in s2:\n                v0 = x[0]-y[0]\n                v1 = x[1]-y[1]\n                \n                vv = (v0,v1)\n                if vv in d:\n                    d[vv] += 1\n                else:\n                    d[vv] = 1\n        \n        dl = sorted(list(d.items()), key=lambda x:x[1])\n        \n        if not len(dl):\n            return 0\n        \n        return dl[-1][1]", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        # Opcion 1\n        # Dejo A fija \n        # Genero todas las variaciones de B\n        # Cruzo una por una con A con AND y cuento los 1 por cada matriz\n        # Me quedo con el maximo\n        # Optimizo: Puedo cortar cuando encuentro un overlap que sea igual a la cantidad de 1 de mi matriz A\n        \n        # Opcion 2 \n        # Dejo A fija\n        # Itero por B y armo una lista de elementos con sus indices\n        # Luego por cada uno, lo superpongo con cada indice del otro \n        def get_movement(a, b):\n            x = a[0] - b[0]\n            y = a[1] - b[1]\n            return (x, y)\n        # def check_movement(move):\n        #     counter = 0\n        #     for val in B_elements:\n        #         x = (val[0] + move[0])\n        #         y = (val[1] + move[1])\n        #         if (x,y) in A_elements:\n        #             counter += 1\n        #     return counter\n        \n        A_elements = []\n        B_elements = []\n        dimension = None\n        for i, row in enumerate(A):\n            for j, val in enumerate(row):\n                if val == 1:\n                    A_elements.append((i,j))\n                if B[i][j] == 1:\n                    B_elements.append((i,j))\n        dimension = i + 1\n        maximo = 0\n        A_len = len(A_elements)\n        B_len = len(B_elements)\n        maximo_posible = min(A_len, B_len)\n        # moved = set()\n        moved = {}\n        for elem_A in A_elements:\n            for elem_B in B_elements:\n                move = get_movement(elem_A, elem_B)\n                if move not in list(moved.keys()):\n                    moved[move] = 1\n                else:\n                    moved[move] += 1\n                \n                if moved[move] > maximo:\n                    maximo = moved[move]\n                    if maximo >= maximo_posible:\n                        break\n                # if not move in moved:\n                #     moved.add(move)\n                #     res = check_movement(move)\n                #     if res > maximo:\n                #         maximo = res\n                #         if maximo >= maximo_posible:\n                #             break\n\n        return maximo\n\n", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        # Opcion 1\n        # Dejo A fija \n        # Genero todas las variaciones de B\n        # Cruzo una por una con A con AND y cuento los 1 por cada matriz\n        # Me quedo con el maximo\n        # Optimizo: Puedo cortar cuando encuentro un overlap que sea igual a la cantidad de 1 de mi matriz A\n        \n        # Opcion 2 \n        # Dejo A fija\n        # Itero por B y armo una lista de elementos con sus indices\n        # Luego por cada uno, lo superpongo con cada indice del otro \n        def get_movement(a, b):\n            x = a[0] - b[0]\n            y = a[1] - b[1]\n            return (x, y)\n        def check_movement(move):\n            counter = 0\n            for val in B_elements:\n                x = (val[0] + move[0])\n                y = (val[1] + move[1])\n                if (x,y) in A_elements:\n                    counter += 1\n            return counter\n        \n        A_elements = set()\n        B_elements = []\n        dimension = None\n        for i, row in enumerate(A):\n            for j, val in enumerate(row):\n                if val == 1:\n                    A_elements.add((i,j))\n                if B[i][j] == 1:\n                    B_elements.append((i,j))\n        dimension = i + 1\n        maximo = 0\n        A_len = len(A_elements)\n        B_len = len(B_elements)\n        maximo_posible = min(A_len, B_len)\n        # moved = set()\n        moved = {}\n        for elem_A in A_elements:\n            for elem_B in B_elements:\n                move = get_movement(elem_A, elem_B)\n                if move not in list(moved.keys()):\n                    moved[move] = 1\n                else:\n                    moved[move] += 1\n                \n                if moved[move] > maximo:\n                    maximo = moved[move]\n                    if maximo >= maximo_posible:\n                        break\n                # if not move in moved:\n                #     moved.add(move)\n                #     res = check_movement(move)\n                #     if res > maximo:\n                #         maximo = res\n                #         if maximo >= maximo_posible:\n                #             break\n        print(moved)\n        return maximo\n\n", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        offset_map = {}\n        max_overlap = 0\n        for row in range (0, len(A)):\n            offset_map[row] = {}\n            offset_map[row * -1] = {}\n            for col in range (0, len(A[row])):\n                r_row = row\n                r_col = col\n                if not offset_map[r_row] or not r_col in offset_map[r_row] or not offset_map[r_row][r_col]:\n                    overlap = self.shift_and_count(A, B, r_row, r_col)\n                    overlap = max(overlap, self.shift_and_count(B, A, r_row, r_col))\n                    max_overlap = max(overlap, max_overlap)\n                    offset_map[r_row][r_col] = overlap\n        return max_overlap\n                        \n    def shift_and_count(self, A: List[List[int]], B: List[List[int]], row_shift: int, col_shift: int) -> int:\n        result = 0\n        for row in range(len(A)):\n            new_row = row - row_shift\n            if new_row >= 0 and new_row < len(A):\n                for col in range(len(A[row])):\n                    new_col = col - col_shift\n                    if ((new_col >= 0 and new_col < len(A[row]))):\n                        if (A[new_row][new_col] == 1) and B[row][col] == 1:\n                            result += 1\n                            \n        return result\n    \n    def overlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        overlap = 0\n        if len(A) != len(B):\n            raise ValueError\n        for row in range(0, len(A)):\n            for col in range(0, len(A[row])):\n                if len(A[row]) != len(B[row]):\n                    raise ValueError\n                if A[row][col] == 1 and B[row][col] == 1:\n                    overlap += 1\n        return overlap\n    \n    \n", "def mat_to_set(A):\n    return {(i, j) for i, row in enumerate(A) for j, bit in enumerate(row) if bit}\n\nclass Solution:\n    def largestOverlap(self, A, B) -> int:\n        N = len(A)\n        A, B = mat_to_set(A), mat_to_set(B)\n        \n        if len(A) > len(B):\n            A, B = B, A\n    \n        max_overlap = 0\n        for di in range(1 - N, N):\n            for dj in range(1 - N, N):\n                overlap = 0\n                for i, j in A:\n                    if (i + di, j + dj) in B:\n                        overlap += 1\n                max_overlap = max(max_overlap, overlap)\n\n        return max_overlap", "def mat_to_set(A):\n    return {(i, j) for i, row in enumerate(A) for j, bit in enumerate(row) if bit}\n\ndef overlap(A, B, di, dj):\n    count = 0\n    for i, j in A:\n        if (i + di, j + dj) in B:\n            count += 1\n    return count\n\nclass Solution:\n    def largestOverlap(self, A, B) -> int:\n        offsets = range(1 - len(A), len(A))\n        A, B = mat_to_set(A), mat_to_set(B)\n        \n        if len(A) > len(B):\n            A, B = B, A\n    \n        return max(overlap(A, B, di, dj) for di in offsets for dj in offsets)", "def mat_to_set(A):\n    return {(i, j) for i, row in enumerate(A) for j, bit in enumerate(row) if bit}\n\nclass Solution:\n    def largestOverlap(self, A, B) -> int:\n        offsets = range(1 - len(A), len(A))\n        A, B = mat_to_set(A), mat_to_set(B)\n        \n        if len(A) > len(B):\n            A, B = B, A\n            \n        def overlap(di, dj):\n            count = 0\n            for i, j in A:\n                if (i + di, j + dj) in B:\n                    count += 1\n            return count\n    \n        return max(overlap(di, dj) for di in offsets for dj in offsets)", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        max_count = 0\n        \n        a_coords = self.coordinates(A)\n        b_coords = self.coordinates(B)\n        \n        for v in range(-1 * (len(A) - 1), len(A)):\n            for h in range(-1 * (len(A[0]) - 1), len(A[0])):\n                overlap_count = 0\n                for r, c in a_coords:                    \n                    if (r + v, c + h) in b_coords:\n                        overlap_count += 1\n            \n                max_count = max(max_count, overlap_count)\n                \n        return max_count\n        \n    def coordinates(self, image):\n        coords = set()\n        for r, row in enumerate(image):\n            for c, value in enumerate(row):\n                if value == 1:\n                    coords.add((r, c))\n        return coords", "#\n# @lc app=leetcode id=835 lang=python3\n#\n# [835] Image Overlap\n#\n\n# @lc code=start\nfrom functools import lru_cache\n\n@lru_cache\ndef countBits(n):\n    if n == 0:\n        return 0\n    return (n & 1) + countBits(n >> 1)\n\nclass Solution:\n    def stateCompress(self, img):\n        n, m = len(img), len(img[0])\n        rows = [0 for _ in range(n)]\n        for i, row in enumerate(img):\n            for j, e in enumerate(row):\n                rows[i] = (rows[i] << 1) + e\n        return n, m, rows\n    \n    \n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        n, m, rA = self.stateCompress(A)\n        _, _, rB = self.stateCompress(B)\n\n        @lru_cache\n        def shift(xAs, xAe, xBs, xBe, dy):\n            if dy > 0:\n                ret = list(countBits((e1 << dy) & e2) for e1, e2 in zip(rA[xAs:xAe], rB[xBs:xBe]))\n                return ret\n            else:\n                dy = -dy\n                ret = list(countBits((e1 >> dy) & e2) for e1, e2 in zip(rA[xAs:xAe], rB[xBs:xBe]))\n                return ret\n\n        print((rA, rB))\n        maxOverLap = 0\n        for dr in range(n):\n            for dc in range(m):\n                maxOverLap = max(maxOverLap, sum(shift(dr, n, 0, n - dr, dc)))\n                maxOverLap = max(maxOverLap, sum(shift(0, dr, n - dr, n, dc)))\n                maxOverLap = max(maxOverLap, sum(shift(dr, n, 0, n - dr, -dc)))\n                maxOverLap = max(maxOverLap, sum(shift(0, dr, n - dr, n, -dc)))\n        return maxOverLap\n                \n                \n# @lc code=end\n\n", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        # define the iteration scheme\n        size = len(A)\n        shifts = [ii for ii in range(size)]\n\n        # count overlap\n        max_overlap = 0\n        for x in shifts:\n            for y in shifts:\n                max_overlap = max(\n                    self.shift_and_count(x_shift=x, y_shift=y, array_reference=A, array_to_be_shifted=B), max_overlap\n                )\n                max_overlap = max(\n                    self.shift_and_count(x_shift=x, y_shift=y, array_reference=B, array_to_be_shifted=A), max_overlap\n                )\n        return max_overlap\n\n    def shift_and_count(\n            self, x_shift: int, y_shift: int, array_reference: List[List[int]], array_to_be_shifted: List[List[int]]\n    ) -> int:\n        if x_shift > 0:\n            array_to_be_shifted = self.shift_left(array=array_to_be_shifted, shifts=x_shift)\n        if y_shift > 0:\n            array_to_be_shifted = self.shift_up(array=array_to_be_shifted, shifts=y_shift)\n\n        return self.overlap(array_a=array_reference, array_b=array_to_be_shifted)\n\n    def overlap(self, array_a: List[List[int]], array_b: List[List[int]], value: int = 1) -> int:\n        common_values = 0\n        for row_a, row_b in zip(array_a, array_b):\n            for a, b in zip(row_a, row_b):\n                if a == b == value:\n                    common_values += 1\n\n        return common_values\n\n    def shift_up(self, array: List[List[int]], shifts: int, fill_value: int = 0) -> List[List[int]]:\n        a = array[shifts:]\n        for _ in range(shifts):\n            a.append([fill_value] * len(array[0]))\n\n        return a\n\n    def shift_left(self, array: List[List[int]], shifts: int, fill_value: int = 0) -> List[List[int]]:\n        a = []\n        for sublist in array:\n            last_elements = [fill_value] * shifts\n            sublist = sublist[shifts:] + last_elements\n            a.append(sublist)\n\n        return a\n", "#\n# @lc app=leetcode id=835 lang=python3\n#\n# [835] Image Overlap\n#\n\n# @lc code=start\nfrom functools import lru_cache\n\n@lru_cache\ndef countBits(n):\n    if n == 0:\n        return 0\n    return (n & 1) + countBits(n >> 1)\n\nclass Solution:\n    def stateCompress(self, img):\n        n, m = len(img), len(img[0])\n        rows = [0 for _ in range(n)]\n        for i, row in enumerate(img):\n            for j, e in enumerate(row):\n                rows[i] = (rows[i] << 1) + e\n        return n, m, rows\n    \n    \n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        n, m, rA = self.stateCompress(A)\n        _, _, rB = self.stateCompress(B)\n\n\n        def shift(xAs, xAe, xBs, xBe, dy):\n            if dy > 0:\n                return (countBits((e1 << dy) & e2) for e1, e2 in zip(rA[xAs:xAe], rB[xBs:xBe]))\n            else:\n                dy = -dy\n                return (countBits((e1 >> dy) & e2) for e1, e2 in zip(rA[xAs:xAe], rB[xBs:xBe]))\n\n        print((rA, rB))\n        maxOverLap = 0\n        for dr in range(n):\n            for dc in range(m):\n                maxOverLap = max(maxOverLap, sum(shift(dr, n, 0, n - dr, dc)))\n                maxOverLap = max(maxOverLap, sum(shift(0, dr, n - dr, n, dc)))\n                maxOverLap = max(maxOverLap, sum(shift(dr, n, 0, n - dr, -dc)))\n                maxOverLap = max(maxOverLap, sum(shift(0, dr, n - dr, n, -dc)))\n        return maxOverLap\n                \n                \n# @lc code=end\n\n", "#\n# @lc app=leetcode id=835 lang=python3\n#\n# [835] Image Overlap\n#\n\n# @lc code=start\nfrom functools import lru_cache\n\n@lru_cache\ndef countBits(n):\n    if n == 0:\n        return 0\n    return (n & 1) + countBits(n >> 1)\n\nclass Solution:\n    def stateCompress(self, img):\n        n, m = len(img), len(img[0])\n        rows = [0 for _ in range(n)]\n        for i, row in enumerate(img):\n            for j, e in enumerate(row):\n                rows[i] = (rows[i] << 1) + e\n        return n, m, rows\n    \n    \n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        n, m, rA = self.stateCompress(A)\n        _, _, rB = self.stateCompress(B)\n\n\n        def shift(xAs, xAe, xBs, xBe, dy):\n            if dy > 0:\n                return sum(countBits((e1 << dy) & e2) for e1, e2 in zip(rA[xAs:xAe], rB[xBs:xBe]))\n            else:\n                dy = -dy\n                return sum(countBits((e1 >> dy) & e2) for e1, e2 in zip(rA[xAs:xAe], rB[xBs:xBe]))\n\n        print((rA, rB))\n        maxOverLap = 0\n        for dr in range(n):\n            for dc in range(m):\n                maxOverLap = max(maxOverLap, shift(dr, n, 0, n - dr, dc))\n                maxOverLap = max(maxOverLap, shift(0, dr, n - dr, n, dc))\n                maxOverLap = max(maxOverLap, shift(dr, n, 0, n - dr, -dc))\n                maxOverLap = max(maxOverLap, shift(0, dr, n - dr, n, -dc))\n        return maxOverLap\n                \n                \n# @lc code=end\n\n", "def matrix_to_set(A):\n    return {(i, j) for i, row in enumerate(A)\n                   for j, pixel in enumerate(row) if pixel}\n\nclass Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        N = len(A)\n        set_a, set_b = matrix_to_set(A), matrix_to_set(B)\n        \n        if len(set_b) < len(set_a):\n            set_b, set_a = set_a, set_b\n    \n        return max(sum((i + di, j + dj) in set_b for i, j in set_a)\n                   for di in range(-N + 1, N)\n                   for dj in range(-N + 1, N)) \n", "class Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        N = len(img1)\n        if N == 1:\n            return 1 if img1[0][0] == 1 and img2[0][0] == 1 else 0\n        max_slide = N\n        sliders = set()\n        for i in range(N):\n            for j in range(N):\n                sliders.add((i, j))\n                sliders.add((-i, j))\n                sliders.add((i, -j))\n                sliders.add((-i, -j))\n        \n        def slide_and_count(slide):\n            res = 0\n            left, down = slide\n            for i in range(min(N, N-left)):\n                i2 = i + left\n                for j in range(min(N, N-down)):\n                    j2 = j + down\n                    if i2 < 0 or j2 < 0:\n                        continue\n                    try:\n                        if img1[i][j] == 1 and img2[i2][j2] == 1:\n                            res += 1\n                    except:\n                        pass\n                    \n            print(slide, res)\n            return res\n        \n        return max(slide_and_count(slide) for slide in sliders)", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        return max(self.largestOverlapAtoB(A, B), self.largestOverlapAtoB(B, A))\n        \n    def largestOverlapAtoB(self, A, B):\n        shift_row = 0\n        shift_col = 0\n        overlap = 0\n        for shift_row in range(len(A[0])):\n            for shift_col in range(len(A[0])):\n                shifted_A = self.shiftMatrix(A, shift_row, shift_col)\n                overlap = max(overlap, self.findOverlap(B, shifted_A))\n        return overlap\n        \n    def findOverlap(self, A, B):\n        lenght = len(A[0])\n        overlap = 0\n        for ii in range(lenght):\n            for jj in range(lenght):\n                if A[ii][jj] == B[ii][jj] and A[ii][jj] == 1:\n                    overlap += 1\n        return overlap\n    \n    def shiftMatrix(self, M, shift_row, shift_col):\n        lenght = len(M[0])\n        out = []\n        for _ in range(shift_row):\n            out.append(lenght * [0])\n        for ix_r in range(shift_row, lenght):\n            out_row = []\n            for _ in range(shift_col):\n                out_row.append(0)\n            for ix_c in range(shift_col, lenght):\n                out_row.append(M[ix_r - shift_row][ix_c - shift_col])\n                \n            out.append(out_row)\n        \n        return out\n                    \n                    \n", "\ndef check_overlap(side, down, A, B):\n    overlap = 0\n    for i in range(len(A)):\n        for j in range(len(A)):\n            try:\n                overlap += A[i+side][j+down] & B[i][j]\n            except:\n                pass\n            \n    return overlap\n\nclass Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        max_overlap = 0\n        for i in range(len(A)):\n            for j in range(len(A)):\n                max_overlap = max(max_overlap, check_overlap(i, j, A, B))\n                max_overlap = max(max_overlap, check_overlap(i, j, B, A))\n                \n        return max_overlap", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        def check_overlap(side_x, down_x, A, B):# A is shifted\n            overlap = 0\n            for i in range(len(A)):\n                for j in range(len(A)):\n                    try:\n                        overlap += A[i+side_x][j+down_x] & B[i][j]\n                    except:\n                        pass\n            \n            return overlap\n        \n        max_overlap = 0\n        for i in range(len(A)):\n            for j in range(len(A)):\n                max_overlap = max(max_overlap, check_overlap(i, j, A, B))\n                max_overlap = max(max_overlap, check_overlap(i, j, B, A))\n                \n        return max_overlap", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        \n        def match(m1, m2):\n            prod = 0\n            for r1, r2 in zip(m1, m2):\n                for v1, v2 in zip(r1, r2):\n                    prod += v1 * v2\n            return prod\n        \n        pad = [0] * (3 * (len(A) - 1))\n        largeA = [pad] * (len(A) - 1)\n        for i in range(len(A)):\n            largeA.append([0] * (len(A)-1) + A[i] + [0] * (len(A)-1))\n        largeA += [pad] * (len(A) - 1)\n        maxProd = 0\n        #print(largeA)\n        for i in range(len(largeA) - len(A) + 1):\n            for j in range(len(largeA) - len(A) + 1):\n                subA = []\n                for r in largeA[i:len(A) + i]:\n                    subA.append(r[j:len(A) + j])\n                prod = match(subA, B)\n                if prod > maxProd:\n                    maxProd = prod\n        return maxProd\n            \n            \n                \n", "from typing import List\n\nclass Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        # help function to count overlaps in A (shifted) and B:\n        def check_overlap(side_x, down_x, A, B):\n            overlap = 0\n            for i in range(len(A)):\n                for j in range(len(A)):\n                    try:\n                        overlap += A[i+side_x][j+down_x] & B[i][j]\n                    except:\n                        pass\n            \n            return overlap\n        \n        # try all options:\n        max_overlap = 0\n        for i in range(len(A)):\n            for j in range(len(A)):\n                max_overlap = max(max_overlap, check_overlap(i, j, A, B))\n                max_overlap = max(max_overlap, check_overlap(i, j, B, A))\n                \n        return max_overlap", "class Solution:\n    # Naming assumes row major.\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        # move A through all the valid positions in B's coordinate space.\n        a_1_locations = set()\n        b_1_locations = set()\n\n        for grid, locations in [ (A, a_1_locations), (B, b_1_locations) ]:\n            for i, col in enumerate(grid):\n                for j, val in enumerate(col):\n                    if val == 1:\n                        locations.add((i,j))\n\n        max_overlap = 0\n        max_abs_x1_offset = len(A)\n        max_abs_x2_offset = len(A[0])\n        a_offsets = itertools.product(range(-1 * max_abs_x1_offset, max_abs_x1_offset),\n                                      range(-1 * max_abs_x2_offset, max_abs_x2_offset))\n        \n        for a_offset_x, a_offset_y in a_offsets:\n            a_1_locations_offset = set(map( lambda location: (location[0] + a_offset_x, location[1] + a_offset_y),\n                                        a_1_locations ))\n            overlap = len(a_1_locations_offset & b_1_locations)\n            if overlap > max_overlap: max_overlap = overlap\n\n        return max_overlap", "class Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        A = [(i, j) for i, row in enumerate(img1) for j, item in enumerate(row) if item]\n        B = [(i, j) for i, row in enumerate(img2) for j, item in enumerate(row) if item]\n        count = collections.Counter((ax-bx, ay-by) for ax, ay in A for bx, by in B)\n        return max(list(count.values()) or [0])\n", "class Solution:\n    def getCoordinate(self, A: List[List[int]]):\n        list_a = []\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if A[i][j] == 1:\n                    list_a.append(i*100 + j)\n        return list_a\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        list_a = self.getCoordinate(A)\n        list_b = self.getCoordinate(B)\n        \n        diff = [a - b for a in list_a for b in list_b]\n        \n        counter = {}\n        for v in diff:\n            if counter.get(v, None) == None:\n                counter[v] = 1\n            else:\n                counter[v] += 1\n        \n        max_value = 0\n        for key in list(counter.keys()):\n            if counter[key] > max_value:\n                max_value = counter[key]\n        return max_value\n", "class Solution:\n    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:\n        index_A = [(i, j) for i, row in enumerate(A) for j, item in enumerate(row) if item]\n        index_B = [(i, j) for i, row in enumerate(B) for j, item in enumerate(row) if item]\n        \n        cnt = collections.Counter([(ax-bx, ay-by)for ax, ay in index_A for bx, by in index_B])\n        \n        if len(cnt) == 0:\n            return 0 \n        return max(cnt.values())", "class Solution:\n    def largestOverlap(self, A, B):\n        A = [(i, j) for i, row in enumerate(A) for j, item in enumerate(row) if item]\n        B = [(i, j) for i, row in enumerate(B) for j, item in enumerate(row) if item]\n        \n        count = {}\n        for ax, ay in A:\n            for bx, by in B:\n                delta = (ax-bx, ay-by)\n                if not delta in count: count[delta]=0\n                count[delta]+=1\n        return max(count.values()) if count else 0"]
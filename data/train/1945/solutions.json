["class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        dict_ = {}\n        for row in matrix:\n            curr_tuple = tuple(row)\n            dict_[curr_tuple] = 1 + dict_.get(curr_tuple,0)\n        visited = set()\n        max_same = 0\n        for row in matrix:\n            curr_tuple = tuple(row)\n            if curr_tuple in visited:\n                continue\n            visited.add(curr_tuple)\n            inverse = [1] * len(row)\n            for i in range (len(row)):\n                if row[i]:\n                    inverse[i] = 0\n            curr_inv = tuple(inverse)\n            visited.add(curr_inv)\n            curr_sum = 0\n            curr_sum = dict_[curr_tuple]\n            if curr_inv in dict_:\n                curr_sum += dict_[curr_inv]\n            if curr_sum > max_same:\n                max_same = curr_sum\n        return max_same\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        pattern_dict = {}\n        for row in matrix:\n            if row[0] == 0:\n                key = tuple(row)\n            else:\n                newrow = [1-x for x in row]\n                key = tuple(newrow)\n            if key in pattern_dict:\n                pattern_dict[key] += 1\n            else:\n                pattern_dict[key] = 1\n        maxnum = 0\n        for _, num in pattern_dict.items():\n            maxnum = max(maxnum, num)\n        return maxnum", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ## row by row store bit sequence\n        ## row by row store sequence that is xor of it (xor with all 1s)\n        ## hash map to track\n        \n        if len(matrix) == 0: \n            return 0\n        \n        cols = len(matrix[0])\n        allOnes = 0\n        for i in range(0, cols): \n            allOnes <<= 1\n            allOnes |= 1\n        \n        freq = {}\n        count = 0\n        for i in range(0, len(matrix)): \n            \n            rowNumber = 0\n            for j in range(0, len(matrix[i])): \n                rowNumber = rowNumber<<1\n                rowNumber = rowNumber|matrix[i][j]\n                \n\n            xorRowNumber = rowNumber^allOnes\n            \n            if rowNumber in freq:\n                freq[rowNumber] += 1\n                count = max(count, freq[rowNumber])\n            elif xorRowNumber in freq:\n                freq[xorRowNumber] += 1\n                count = max(count, freq[xorRowNumber])\n            else:\n                freq[rowNumber] = 1\n                count = max(count, freq[rowNumber])\n                \n        return count\n                \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n#         iMax = len(matrix)\n#         jMax = matrix[0]\n#         flipCounter = [0 for _ in range(jMax)]\n        \n        \n        counterDict = defaultdict(int)\n        for row in matrix:\n            str0 = \\\"\\\"\n            str1 = \\\"\\\"\n            for num in row:\n                str0 += str(num)\n                str1 += str(abs(num-1))\n            counterDict[str0] += 1\n            counterDict[str1] += 1\n        return max(counterDict.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        dic={}\n        for i in range(len(matrix)):\n            a=''\n            b=''\n            for j in range(len(matrix[0])):\n                a=a+'%d'%matrix[i][j]\n                b=b+'%d'%(1-matrix[i][j])\n       #     print(a,b,dic)\n            if a not in dic:\n                dic[a]=1\n            else:\n                dic[a]+=1\n            if b not in dic:\n                dic[b]=1\n            else:\n                dic[b]+=1\n        m=0\n        #print(dic)\n        for k in dic.keys():\n            m=max(m,dic[k])\n        return m", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        counter = {}\n        for row in matrix:\n            key = tuple(x^row[0] for x in row)\n            counter[key] = counter.get(key, 0)+1\n        return max(counter.values())", "import collections\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        # return max(collections.Counter(tuple(x ^ r[0] for x in r) for r in matrix).values())\n        values = {}\n        for row in matrix:\n            s1, s2 = '', ''\n            for c in row:\n                s1 += str(c ^ 0)\n                s2 += str(c ^ 1)\n            print((s1, s2))\n            if values.get(s1, 0):\n                values[s1] += 1\n            elif values.get(s2, 0):\n                values[s2] += 1\n            else:\n                values[s1] = 1\n        return max(values.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        values = {}\n        for row in matrix:\n            s1, s2 = '', ''\n            for c in row:\n                s1 += str(c ^ 0)\n                s2 += str(c ^ 1)\n            print((s1, s2))\n            if values.get(s1, 0):\n                values[s1] += 1\n            elif values.get(s2, 0):\n                values[s2] += 1\n            else:\n                values[s1] = 1\n        return max(values.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n      dicts = {}\n      for row in matrix:\n        bin_rep = ''.join([str(x) for x in row])\n        if bin_rep not in dicts: dicts[bin_rep] = 1\n        else: dicts[bin_rep] += 1\n        rev_bin_rep = ''.join([str(x^1) for x in row])\n        if rev_bin_rep not in dicts: dicts[rev_bin_rep] = 1\n        else: dicts[rev_bin_rep] += 1\n        #print (bin_rep, rev_bin_rep)\n      res = 0\n      #print (dicts)\n      for key,value in dicts.items():\n        res = max(res, value)\n      return res", "class Solution:\n    def maxEqualRowsAfterFlips(self, ma: List[List[int]]) -> int:\n        n=len(ma)\n        m=len(ma[0])\n        di={}\n        for i in range(n):\n            s=''\n            ss=''\n            for j in range(m):\n                s=s+str(ma[i][j])\n                ss=ss+str(1-ma[i][j])\n            di[s]=di.get(s,0)+1\n            di[ss]=di.get(ss,0)+1\n        return max(list(di.values()))", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        values = {}\n        for row in matrix:\n            s1, s2 = '', ''\n            for c in row:\n                s1 += str(c ^ 0)\n                s2 += str(c ^ 1)\n            print((s1, s2))\n            values[s1] = values.get(s1, 0) + 1\n            values[s2] = values.get(s2, 0) + 1\n        return max(values.values())\n", "import collections\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        return max(collections.Counter(tuple(x ^ r[0] for x in r) for r in matrix).values())\n        # values = {}\n        # for row in matrix:\n        #     s1, s2 = '', ''\n        #     for c in row:\n        #         s1 += str(c ^ 0)\n        #         s2 += str(c ^ 1)\n        #     print(s1, s2)\n        #     if values.get(s1, 0):\n        #         values[s1] += 1\n        #     elif values.get(s2, 0):\n        #         values[s2] += 1\n        #     else:\n        #         values[s1] = 1\n        # return max(values.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        def find_minor(row):\n            one = row.count(1)\n            if one * 2 == len(row):\n                return tuple(i for i, val in enumerate(row) if val == row[-1])\n            elif one * 2 > len(row):\n                return tuple(i for i, val in enumerate(row) if val == 0)\n            return tuple(i for i, val in enumerate(row) if val == 1)\n        counts = collections.Counter()\n\n        for i, row in enumerate(matrix):\n            counts[find_minor(row)] += 1\n        return max(counts.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        n=len(matrix)\n        m=len(matrix[0])\n        mx=1\n        for i in range(n):\n            c=[0 for i in range(m)]\n            for j in range(m):\n                if(matrix[i][j]==0):\n                    c[j]=1\n                else:\n                    c[j]=0\n            count=1\n            for j in range(n):\n                if(i!=j)and(c==matrix[j])or(matrix[i]==matrix[j]):\n                    count+=1\n            mx=max(mx,count)\n        return mx-1\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \n        n = len(matrix)\n        m = len(matrix[0])\n        res = 0\n        for i in range(n):\n            flip = [1-matrix[i][j] for j in range(m) ]\n            \n            cnt = 0\n            for k in range(n):\n                if matrix[i] == matrix[k] or flip ==  matrix[k]:\n                    cnt += 1\n                    \n            res = max(res, cnt)\n        \n        return res\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \n        counter = collections.Counter()\n        \n        for row in matrix:\n            flipper = {1: 0, 0: 1}\n            \n            if row[0] == 0:\n                row = [flipper[col] for col in row]\n            \n            counter[tuple(row)] += 1\n            \n        return max(counter.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        hashmap = {}\n        for i in range(m):\n            order = \\\"\\\"\n            first = matrix[i][0]\n            \n            for j in range(1, n):\n                if matrix[i][j] == first:\n                    order += \\\"1\\\"\n                \n                else:\n                    order += \\\"0\\\"\n            \n            hashmap[order] = hashmap.get(order, 0) + 1\n        \n        return max(hashmap.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        rows = {}\n        max_value = 0\n        n = len(matrix)\n        m = len(matrix[0])\n        for i in range(n):\n            a = []\n            b = []\n            for j in range(m):\n                if matrix[i][j]==0:\n                    a.append(j)\n                else:\n                    b.append(j)\n            a = tuple(a)\n            b = tuple(b)\n            if a not in rows:\n                rows[a] = 0\n            if b not in rows:\n                rows[b] = 0\n            rows[a]+=1\n            rows[b]+=1\n            max_value = max(max_value, rows[a], rows[b])\n        return max_value\n                    \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, mat: List[List[int]]) -> int:\n        \n        dic = defaultdict(lambda : 0)\n        for r in range(len(mat)):\n            row = mat[r]\n            ones = 0\n            zeros = 0\n            for i in range(len(row)):\n                if row[i] == 0:\n                    ones = ones<<1\n                    zeros = zeros<<1\n                    ones |= 1\n                else:\n                    zeros = zeros<<1\n                    ones = ones<<1\n                    zeros |= 1\n            dic[zeros] += 1\n            dic[ones] += 1\n        return max(dic.values()) ", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cache = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1 - c)\n            cache[str(vals)] += 1\n            cache[str(trans)] += 1\n        return max(cache.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        rows = {}\n        max_value = 0\n        n = len(matrix)\n        for i in range(n):\n            if matrix[i][0]==1:\n                a = tuple(matrix[i])\n            else:\n                a = tuple([1-c for c in matrix[i]])\n           # for j in range(m):\n          #      if matrix[i]  # [j]==0:\n              #      a+=str(j)\n           #     else:\n          #          b+=str(j)\n            #a = tuple(a)\n            #b = tuple(b)\n            if a not in rows:\n                rows[a] = 0\n           # if b not in rows:\n         #       rows[b] = 0\n            rows[a]+=1\n         \n        # rows[b]+=1\n            max_value = max(max_value, rows[a])\n        return max_value\n                    \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        rows = {}\n        max_value = 0\n        n = len(matrix)\n        for i in range(n):\n            if matrix[i][0]==0:\n                a = tuple(matrix[i])\n            else:\n                a = tuple([1-c for c in matrix[i]])\n           # for j in range(m):\n          #      if matrix[i]  # [j]==0:\n              #      a+=str(j)\n           #     else:\n          #          b+=str(j)\n            #a = tuple(a)\n            #b = tuple(b)\n            if a not in rows:\n                rows[a] = 0\n           # if b not in rows:\n         #       rows[b] = 0\n            rows[a]+=1\n         \n        # rows[b]+=1\n            max_value = max(max_value, rows[a])\n        return max_value\n                    \n", "from collections import Counter\n\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        c = Counter()\n        for row in matrix:\n            c.update([tuple(row)])\n            c.update([tuple(flip(row))])\n        return max(c.values())\n\ndef flip(bits):\n    return [1 if bit == 0 else 0 for bit in bits]", "import collections\nclass Solution:\n    def maxEqualRowsAfterFlips(self, A) -> int:\n        return max(collections.Counter(tuple(x ^ r[0] for x in r) for r in A).values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        \n        res = 0\n        n, m = len(matrix), len(matrix[0])\n        \n        for i in range(n):\n            count = 0\n            flip = [0 for _ in range(m)]\n            \n            for j in range(m):\n                flip[j] = 1 - matrix[i][j]\n            \n            for k in range(i, n):\n                if matrix[k] == matrix[i] or matrix[k] == flip:\n                    count += 1\n            \n            res = max(res, count)\n        \n        return res", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        f=defaultdict(int)\n        n=len(matrix[0])\n        for i in matrix:\n            p,q=[],[]\n            for j in range(n):\n                if i[j]==0:p.append(j)\n                else:q.append(j)\n            f[tuple(p)]+=1\n            f[tuple(q)]+=1\n        return max(f.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        map = collections.defaultdict(int)\n        for row in matrix:\n            map[\\\"\\\".join([str(j) for j in row])] += 1\n            map[\\\"\\\".join([str(1-j) for j in row])] += 1\n        return max(map.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        for i,row in enumerate(matrix):\n            matrix[i]=tuple(x^row[0] for x in row)\n        return max(Counter(matrix).values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cntMap = {}\n        flipper = {1: 0, 0: 1}\n        max_val = 0\n        for row in matrix:\n            r, tran = \\\"\\\", \\\"\\\"\n            for k in row:\n                r += str(k)\n                tran += str(flipper[k])\n            key = r\n            cntMap.setdefault(r, 0)\n            cntMap.setdefault(tran, 0)\n            cntMap[r] += 1\n            cntMap[tran] += 1\n            max_val = max(max_val, cntMap[r])\n            max_val = max(max_val, cntMap[tran])\n\n        return max_val\n                \n        ", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        rows = {}\n        max_value = 0\n        n = len(matrix)\n        m = len(matrix[0])\n        for i in range(n):\n            a = ''\n            b = ''\n            for j in range(m):\n                if matrix[i][j]==0:\n                    a+=str(j)\n                else:\n                    b+=str(j)\n            #a = tuple(a)\n            #b = tuple(b)\n            if a not in rows:\n                rows[a] = 0\n            if b not in rows:\n                rows[b] = 0\n            rows[a]+=1\n            rows[b]+=1\n            max_value = max(max_value, rows[a], rows[b])\n        return max_value\n                    \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, x: List[List[int]]) -> int:\n        f=defaultdict(int)\n        n=len(x[0])\n        for i in x:\n            p=q=0\n            v=1\n            for j in range(n):\n                if i[j]==0:p|=v\n                else:q|=v\n                v=v<<1\n            f[p]+=1\n            f[q]+=1\n        return max(f.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        noninv = {}\n        \n        for row in matrix:\n            row = repr(row)\n            if row in noninv:\n                noninv[row] += 1\n            else:\n                noninv[row] = 1\n            \n        count = 0\n        for row in matrix:\n            revrow = [i^1 for i in row]\n            revrow = repr(revrow)\n            row = repr(row)\n            \n            if revrow in noninv:\n                count = max(count, noninv[row] + noninv[revrow])\n            else:\n                count = max(count, noninv[row])\n            \n        return count\n        \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        counter = collections.Counter()\n        flipper = {1: 0, 0: 1}\n        \n        for row in matrix:\n            if row[0] == 0:\n                row = [flipper[col] for col in row]\n                \n            counter[tuple(row)] += 1\n            \n        return max(counter.values())", "from collections import defaultdict\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        '''\n        # Analysis:\n            \n        \n        '''\n        lookup = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1 - c)\n            lookup[str(vals)] += 1\n            lookup[str(trans)] += 1\n        return max(lookup.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        dict_ = {}\n        for row in matrix:\n            curr_tuple = tuple(row)\n            dict_[curr_tuple] = 1 + dict_.get(curr_tuple,0)\n        \n        max_same = 0\n        for row in matrix:\n            curr_tuple = tuple(row)\n            inverse = [1] * len(row)\n            for i in range (len(row)):\n                if row[i]:\n                    inverse[i] = 0\n            curr_inv = tuple(inverse)\n            curr_sum = 0\n            curr_sum = dict_[curr_tuple]\n            if curr_inv in dict_:\n                curr_sum += dict_[curr_inv]\n            if curr_sum > max_same:\n                max_same = curr_sum\n        return max_same\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, mat: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(mat), len(mat[0])\n        ones = [[0]*n for i in range(m)]\n        zeros = [[0]*n for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    zeros[i][j] = 1\n                else:\n                    ones[i][j] = 1\n\n        for i in range(m):\n            for target in [ones[i], zeros[i]]:\n                count = 1\n                for k in range(m):\n                    if k == i: continue\n                    if ones[k] == target or zeros[k] == target:\n                        count += 1\n                ans = max(ans, count)\n        return ans ", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d = {}\n        for arr in matrix:\n            if arr[0] == 0:\n                k = \\\"\\\".join(str(a) for a in arr)\n            else:\n                k = \\\"\\\".join(\\\"1\\\" if a==0 else \\\"0\\\" for a in arr)\n            if k in d:\n                d[k] += 1\n            else:\n                d[k] = 1\n        return max(d.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        def reverse_row(row):\n            res = [0] * len(row)\n            for i, val in enumerate(row):\n                res[i] = 1 - row[i]\n            return res\n                \n        d = {}\n        for row in matrix:\n            rev_row = reverse_row(row)\n\n            if tuple(row) in d:\n                d[tuple(row)] += 1\n            elif tuple(rev_row) in d:\n                d[tuple(rev_row)] += 1\n            else:\n                d[tuple(row)] = 1\n\n        res = sorted(d.items(), key=lambda x: x[1], reverse=1)\n        return res[0][1]", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        counter = collections.defaultdict(int)\n        \n        for row in matrix:\n            if row[0] == 1:\n                row = [1 - num for num in row]\n            counter[tuple(row)] += 1\n        \n        return max(counter.values())\n", "#https://www.cnblogs.com/seyjs/p/11026157.html\n\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        memo = collections.defaultdict(lambda : 0)\n        for line in matrix:\n            if line[0]==0:\n                memo[tuple(line)] += 1\n            else:\n                line = [1 if i==0 else 0 for i in line]\n                memo[tuple(line)] += 1\n        return max(memo.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        def flip(row):\n            return [1-r for r in row]\n        \n        record=dict()\n        for row in matrix:\n            record[tuple(row)]=record.get(tuple(row),0)+1\n            record[tuple(flip(row))]=record.get(tuple(flip(row)),0)+1\n        return max(record.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        groups = {}\n        for row in matrix:\n            tuple_row = tuple(row)\n            if tuple_row not in groups:\n                groups[tuple_row] = 1\n            else:\n                groups[tuple_row] += 1\n        max_equal = 0\n        for row in groups.keys():\n            rev_row = tuple([1-x for x in row])\n            group_max = groups[row]\n            if row != rev_row and rev_row in groups:\n                group_max += groups[rev_row]\n            max_equal = max(max_equal, group_max)\n            \n        return max_equal", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        columnsToFlipOneForEqualRow = {}\n        columnsToFlipZeroForEqualRow = {}\n        self.height = len(matrix)\n        self.width = len(matrix[0])\n        \n        for y in range(self.height):\n            row = matrix[y]\n            columnsToFlipOneForEqualRow[y] = []\n            columnsToFlipZeroForEqualRow[y] = []\n            \n            for x in range(self.width):\n                element = row[x]\n                \n                if element == 0:\n                    columnsToFlipOneForEqualRow[y].append(x)\n                else:\n                    columnsToFlipZeroForEqualRow[y].append(x)\n                    \n        patterns = {}\n        \n        for index in range(self.height):\n            first = str(columnsToFlipOneForEqualRow[index])\n            second = str(columnsToFlipZeroForEqualRow[index])\n            \n            if first not in patterns:\n                patterns[first] = 0\n                \n            if second not in patterns:\n                patterns[second] = 0\n                \n            patterns[first] += 1\n            patterns[second] += 1\n            \n        return max(patterns.values())\n", "class Solution:\n    def convert_to_tuple(self, lst):\n        if lst[0] == 0:\n            return tuple(lst)\n        else:\n            return tuple([int(not x) for x in lst])\n    \n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        from collections import defaultdict\n        row_counts = defaultdict(int)\n        \n        for row in matrix:\n            row_counts[self.convert_to_tuple(row)] += 1\n            \n        return max(row_counts.values())\n        \n        \n", "import collections\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ans = 1\n        orig = collections.defaultdict(int)\n        orig_to_xor = {}\n        for row in matrix:\n            curr_orig = 0\n            curr_xor = 0\n            for i, c in enumerate(row):\n                curr_orig ^= c<<i\n                curr_xor ^= (1-c)<<i\n            orig[curr_orig] += 1\n            orig_to_xor[curr_orig] = curr_xor\n        for curr_orig, curr_xor in orig_to_xor.items():\n            ans = max(orig[curr_orig] + orig[curr_xor], ans) if curr_orig!=curr_xor else max(orig[curr_orig], ans)\n        return ans", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\nclass Solution:\n\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        N = len(matrix)\n        M = len(matrix[0])\n        sigCnt = {}\n        for i in range(N):\n            if matrix[i][0]:\n                for c in range(M):\n                    matrix[i][c] = 1 - matrix[i][c]\n            sig = \\\"\\\".join(map(str, matrix[i]))\n            if not sig in sigCnt:\n                sigCnt[sig] = 0\n            sigCnt[sig] += 1\n        return max(sigCnt.values())\n\n\\\"\\\"\\\"\ns = Solution()\nl = [[0, 1], [1, 1]]\nl = [[0, 1], [1, 0]]\nl = [[0, 0, 0], [0, 0, 1], [1, 1, 0]]\nprint(s.maxEqualRowsAfterFlips(l))\n\\\"\\\"\\\"\n", "from collections import Counter\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix):\n        counter = Counter()\n        flip = {1: 0, 0: 1}\n        \n        for row in matrix:\n            if row[0] == 0 :\n                row = [flip[col] for col in row]\n                \n            counter[tuple(row)] += 1\n            \n        return max(counter.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        seen = defaultdict(int)\n        \n        for row in matrix:\n            comp = row[0] == 1\n            \n            temp = []\n            \n            for num in row:\n                if comp:\n                    temp.append(str(num ^ 1))\n                else:\n                    temp.append(str(num))\n            \n            seen[''.join(temp)] += 1\n    \n        return max(seen.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            if matrix[i][0] == 1:\n                for j in range(n):\n                    matrix[i][j] ^= 1\n        cnt = Counter(list(map(tuple, matrix)))\n        return max(cnt.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, mat: List[List[int]]) -> int:\n        \n        \n        s=collections.defaultdict(lambda: 0)\n        m=len(mat)\n        n=len(mat[0])\n        st=\\\"\\\"\n        maxi=0\n        for i in range(m):\n            for j in range(n-1):\n                if(mat[i][j]==mat[i][j+1]):\n                    st+='1'\n                else: \n                    st+='0'\n            s[st]+=1\n            maxi=max(maxi, s[st])\n            st=\\\"\\\"\n        return maxi\n        \n        \n    ", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        memo = collections.defaultdict(lambda : 0)\n        M = len(matrix)\n        N = len(matrix[0])\n        for line in matrix:\n            if line[0]==0:\n                memo[tuple(line)] += 1\n            else:\n                line = [1 if i==0 else 0 for i in line]\n                memo[tuple(line)] += 1\n        return max(memo.values())\n            \n#         print (dict(memo))\n#         # return 0\n#         res = 0\n#         for key, val in memo.items():\n#             res = max(res, val)\n#             # if key[0]==0 or key[1]==0 or key[0]==key[1]:\n#             #     res = max(res, val)\n#             if key[0]!=key[1] and (key[1], key[0]) in memo and  memo[(key[1], key[0])]!=0:\n#                 res = max(res, memo[key]+memo[(key[1], key[0])])\n#             # else:\n#             #     res = max(res, val)\n#         return res\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        '''\n        Find the maxmimum number of rows in rows[]\n        where rows[i] = rows[i+1]\n        '''\n        ans = 0\n        for i, r in enumerate(matrix):\n            count = 0\n            flip = [1-x for x in r]\n            for j in range(i, len(matrix)):\n                if r == matrix[j] or flip == matrix[j]:\n                    count += 1\n            ans = max(ans, count)\n        return ans\n            \n\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cache = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1 - c)\n            cache[str(vals)] += 1\n            cache[str(trans)] += 1\n        return max(cache.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        return max(Counter(tuple(num^r[0] for num in r) for r in matrix).values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, g: List[List[int]]) -> int:\n        # want to find number of rows that are identical or exactly opposite\n        # i.e. after flipping cols these can be all 1's or all 0's\n\n        # pass 1: iterate grid rows\n        # store vectors in dict hashmap {vector : freq}\n        # remember that dict keys must be immutable, hence tuple\n\n        # pass 2: iterate dict keys\n        # create inverse (XOR), check frequency of exact match + inverse\n        # take the max over all rows, return\n        # O(M + MN) time, O(M) space\n\n        rows, cols, d = len(g), len(g[0]), {}\n        for row in range(rows):\n            vct = tuple(g[row])\n            d[vct] = d.setdefault(vct, 0) + 1\n\n        res = 0\n        for vct in d:\n            inv = tuple(el ^ 1 for el in vct)\n\n            if inv in d: matches = d[vct] + d[inv]\n            else:        matches = d[vct]\n\n            res = max(res, matches)\n        return res", "class Solution:\n    def maxEqualRowsAfterFlips(self, g: List[List[int]]) -> int:\n        # want to find number of rows that are identical or exactly opposite\n        # i.e. after flipping cols these can be all 1's or all 0's\n\n        # pass 1: iterate grid rows\n        # store vectors in dict hashmap {vector : freq}\n        # pass 2: iterate grid rows\n        # create inverse (XOR), check frequency of exact match + inverse\n        # take the max over all rows, return\n        # O(M + MN) time, O(M) space\n\n        rows, cols, d = len(g), len(g[0]), {}\n\n        for row in range(rows):\n            vct = tuple(g[row])\n            d[vct] = d.setdefault(vct, 0) + 1\n\n        res = 0\n        for row in range(rows):\n            vct = tuple(g[row])\n            inv = tuple(el ^ 1 for el in g[row])\n\n            matches = 0\n            if vct in d: matches += d[vct]\n            if inv in d: matches += d[inv]\n\n            res = max(res, matches)\n        return res", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        seen = set()\n        n = len(matrix)\n        ans = 0\n        for i in range(n):\n            m = 0\n            for j in range(i,n):\n                if j in seen: continue\n                if matrix[i]==matrix[j] or all(a!=b for a,b in zip(matrix[i], matrix[j])):\n                    seen.add(j)\n                    m+=1\n                    ans = max(ans, m)\n        return ans", "class Solution:\n    def maxEqualRowsAfterFlips(self, m: List[List[int]]) -> int:\n        m=[tuple(i) for i in m]\n        h=defaultdict(int)\n        for i in m:\n            if i in h:\n                h[i]+=1\n            else:\n                h[i]=1\n            t=tuple(1-x for x in i)\n            if t in h:\n                h[t]+=1\n            else:\n                h[t]=1\n        return max(h.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, x: List[List[int]]) -> int:\n        f=defaultdict(int)\n        n=len(x[0])\n        for i in x:\n            p,q=[],[]\n            for j in range(n):\n                if i[j]==0:p.append(j)\n                else:q.append(j)\n            f[tuple(p)]+=1\n            f[tuple(q)]+=1\n        return max(f.values())", "class Solution(object):\n    def maxEqualRowsAfterFlips(self, matrix):\n        patterns = collections.Counter()\n        for row in matrix:\n            patterns[tuple(row)]+=1\n            flip = [1-c for c in row]\n            patterns[tuple(flip)]+=1\n        return max(patterns.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        firstcell = matrix[0][0]\n        vals = {}\n        \n        for row in matrix:\n            firstrowcell = row[0]\n            mark = [0, 0]\n            mark[firstrowcell]     = firstcell\n            mark[1 - firstrowcell] = 1 - firstcell\n            \n            num = 0\n            for cell in row:\n                num = num * 2 + mark[cell]\n                \n            vals[num] = 1 + vals.get(num, 0)\n            \n        maxcount = 0\n        for val, count in vals.items():\n            maxcount = max(count, maxcount)\n            \n        return maxcount", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cache = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1 - c)\n            cache[str(vals)] += 1\n            cache[str(trans)] += 1\n        return max(cache.values())\n       \n    \n    '''\n    \nCounter({(0, 0, 0): 1})\n===\nCounter({(0, 0, 0): 1, (1, 1, 1): 1})\n=========\nCounter({(0, 0, 0): 1, (1, 1, 1): 1, (0, 0, 1): 1})\n=========\nCounter({(0, 0, 0): 1, (1, 1, 1): 1, (0, 0, 1): 1, (1, 1, 0): 1})\n=========\nCounter({(1, 1, 0): 2, (0, 0, 0): 1, (1, 1, 1): 1, (0, 0, 1): 1})\n=========\nCounter({(0, 0, 1): 2, (1, 1, 0): 2, (0, 0, 0): 1, (1, 1, 1): 1})\n=========\n    '''\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        def flipped(r):\n            return [1-c for c in r]\n            \n        d=defaultdict(int)\n        for r in matrix:\n            s = ''.join(map(str,r))\n            d[s] += 1\n            s = ''.join(map(str,flipped(r)))\n            d[s] += 1\n        return max(d.values())\n    \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        record = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1-c)\n            record[str(vals)]+=1\n            record[str(trans)] += 1\n        return max(record.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \n        max_count = 1\n        \n        swap_matrix = [[1 - val for val in row] for row in matrix]\n        \n        for idx, row in enumerate(matrix):\n            count = 1\n            for nxt_rw in range(idx + 1, len(matrix)):\n                if matrix[nxt_rw] == row or matrix[nxt_rw] == swap_matrix[idx]:\n                    count += 1\n            max_count = max(count, max_count)\n        \n        return max_count", "class Solution:\n    def flip_row(self, row):\n        for i, val in enumerate(row):\n            if val == 0:\n                row[i] = 1\n            else:\n                row[i] = 0\n        return row\n       \n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        # O(n^2) time, O(n) space\n        seen = defaultdict(int)\n        for i, row in enumerate(matrix):\n            if tuple(row) in seen or tuple(self.flip_row(row)) in seen:\n                seen[tuple(row)] += 1\n            else:\n                seen[tuple(row)] += 1\n    \n        result = 0\n        for val in seen.values():\n            result = max(result, val)\n        \n        return result", "class Solution:\n    def flip_row(self, row):\n        for i, val in enumerate(row):\n            if val == 0:\n                row[i] = 1\n            else:\n                row[i] = 0\n        return row\n       \n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        # each row: maintain list of indices to flip to 1 or 0 for equality\n        # then need to find greatest intersection out of all those\n        seen = defaultdict(int)\n        for i, row in enumerate(matrix):\n            if tuple(row) in seen or tuple(self.flip_row(row)) in seen:\n                seen[tuple(row)] += 1\n            else:\n                seen[tuple(row)] += 1\n    \n        result = 0\n        for val in seen.values():\n            result = max(result, val)\n        \n        return result", "class Solution:\n    def flip_row(self, row):\n        for i, val in enumerate(row):\n            row[i] = row[i] ^ 1\n        return row\n       \n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        # O(n^2) time, O(n) space\n        seen = defaultdict(int)\n        for i, row in enumerate(matrix):\n            if tuple(row) in seen or tuple(self.flip_row(row)) in seen:\n                seen[tuple(row)] += 1\n            else:\n                seen[tuple(row)] += 1\n    \n        result = 0\n        for val in seen.values():\n            result = max(result, val)\n        \n        return result", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        patterns = collections.Counter()\n        for row in matrix:\n            patterns[tuple(row)]+=1\n            flip = [1-c for c in row]\n            patterns[tuple(flip)]+=1\n        return max(patterns.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        # If all elements in serveral rows are the same after some number of flipping\n        # Because we flip the whole columns, all the cells in one column will be changed\n        # The rows should have the same opposite elements for those columns originally\n        # So we can record the number of row before flipping and after flipping\n        # The maximum number of rows is the answer\n        record = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1-c)\n            record[str(vals)] += 1\n            record[str(trans)] += 1\n        return max(record.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cache = defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for num in row:\n                vals.append(num)\n                trans.append(1 - num)\n            cache[str(vals)] += 1\n            cache[str(trans)] += 1\n\n        return max(cache.values())\n", "import time\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        flip = []\n        flip2 = []\n        ma = 0\n        for i in matrix:\n            temp = [j for j in range(len(i)) if i[j]==0]\n            temp2 = [j for j in range(len(i)) if i[j]==1]\n            flip.append(temp)\n            flip2.append(temp2)\n        for i in flip:\n            if flip.count(i)+flip2.count(i) > ma:\n                ma = flip.count(i)+flip2.count(i)            \n       \n        return ma", "import collections\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ans = 1\n        orig = collections.defaultdict(int)\n        orig_to_xor = {}\n        for row in matrix:\n            curr_orig = int(''.join([str(c) for c in row]), 2)\n            curr_xor = int(''.join([str(1-c) for c in row]), 2)\n            orig[curr_orig] += 1\n            orig_to_xor[curr_orig] = curr_xor\n        for curr_orig, curr_xor in orig_to_xor.items():\n            ans = max(orig[curr_orig] + orig[curr_xor], ans) if curr_orig!=curr_xor else max(orig[curr_orig], ans)\n        return ans", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        positions = {}\n        max_rows = 0\n        for i in range(len(matrix)):\n            zeros = []\n            ones = []\n            for j, coin in enumerate(matrix[i]):\n                if coin == 0:\n                    zeros.append(j)\n                else:\n                    ones.append(j)\n            zeros = tuple(zeros)\n            ones = tuple(ones)\n            if 0 in zeros:\n                key = (zeros, ones)\n            else:\n                key = (ones, zeros)\n            positions[key] = positions.get(key, 0) + 1\n            max_rows = max(max_rows, positions[key])\n        return max_rows", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d=Counter()\n        for r in matrix:\n            normal=[]\n            reverse=[]\n            for v in r:\n                normal.append('1' if v else '0')\n                reverse.append('0' if v else '1')\n            d[''.join(normal)]+=1\n            d[''.join(reverse)]+=1\n        return max(d.values())", "import time\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        flip = []\n        flip2=[]\n        ma = 0\n        for i in matrix:\n            temp = []\n            temp2 = []\n            for k in range(len(i)):\n                if i[k] == 0:\n                    temp += [k]\n                else:\n                    temp2 += [k]\n            flip.append(temp)\n            flip2.append(temp2)\n        for i in flip:\n            if flip.count(i) + flip2.count(i)> ma:\n                ma = flip.count(i)  + flip2.count(i)\n       \n        return ma", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        dict_ = {}\n        for row in matrix:\n            curr_tuple = tuple(row)\n            dict_[curr_tuple] = 1 + dict_.get(curr_tuple,0)\n        visited = set()\n        max_same = 0\n        for row in matrix:\n            curr_tuple = tuple(row)\n            if curr_tuple in visited:\n                continue\n            visited.add(curr_tuple)\n            inverse = [1] * len(row)\n            for i in range (len(row)):\n                if row[i]:\n                    inverse[i] = 0\n            curr_inv = tuple(inverse)\n            curr_sum = 0\n            curr_sum = dict_[curr_tuple]\n            if curr_inv in dict_:\n                curr_sum += dict_[curr_inv]\n            if curr_sum > max_same:\n                max_same = curr_sum\n        return max_same\n", "from collections import defaultdict\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d = defaultdict(int)\n        for row in matrix:\n            ori = ''\n            inverse =''\n            for c in row:\n                ori += str(c)\n                inverse += str(1 - c)\n                \n            d[ori] += 1\n            d[inverse] += 1\n        lis = list(d.values())\n        return max(lis)\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \n        if not matrix:\n            return 0\n        \n        n = len(matrix)\n        m = len(matrix[0])\n        all_1 = [1] * m\n        \n        dic = {}\n        for li in matrix:\n            if li[0] == 0:\n                li = [1 if i == 0 else 0 for i in li]\n            s = ''.join([str(i) for i in li])\n            if s in dic:\n                dic[s] +=1\n            else:\n                dic[s] = 1\n                \n        return max(dic.values())\n        \n        \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        f=defaultdict(int)\n        n=len(matrix[0])\n        for i in matrix:\n            p,q=[],[]\n            for j in range(n):\n                if i[j]==0:\n                    # track location of 0\n                    p.append(j)\n                else:\n                    # track location of 1\n                    q.append(j)\n            f[tuple(p)]+=1\n            f[tuple(q)]+=1\n        return max(f.values())", "import time\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ma = 0\n        for i in matrix:\n            flipped = [1-j for j in i]\n            c = matrix.count(i)+matrix.count(flipped)\n            if c > ma:\n                ma = c\n       \n        return ma", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ma = 0\n        for i in matrix:\n            c = matrix.count(i)+matrix.count([1-x for x in i])\n            if c > ma:\n                ma = c\n       \n        return ma", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        flips_for_row = {}\n        for row in matrix:\n            curr_tuple = str([ i for i in range(len(row)) if row[i] == 1 ])\n            if curr_tuple in flips_for_row:\n                flips_for_row[curr_tuple] = flips_for_row[curr_tuple] + 1\n            else:\n                flips_for_row[curr_tuple] = 1\n            curr_tuple = str([ i for i in range(len(row)) if row[i] == 0 ])\n            if curr_tuple in flips_for_row:\n                flips_for_row[curr_tuple] = flips_for_row[curr_tuple] + 1\n            else:\n                flips_for_row[curr_tuple] = 1\n        return max(flips_for_row.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        map = collections.defaultdict(int)\n        for i in range(n):\n            origin = \\\"\\\".join([str(j) for j in matrix[i]])\n            reverse = \\\"\\\".join([str(1-j) for j in matrix[i]])\n            map[origin] += 1\n            map[reverse] += 1\n        return max(map.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        row = len(matrix)\n        col = len(matrix[0])\n        ht = {}\n        '''\n        create a hash table, keys is the pos list of 0 and pos list of 1 in a row\n        because they represent for #col needed to change\n        count #keys\n        ans = max value of keys\n        '''\n        for r in range(row):\n            need = [[],[]]\n            for c in range(col):\n                if matrix[r][c] == 0:\n                    need[0].append(c)\n                else:\n                    need[1].append(c)\n            #list type cannot be a key, so convert to str\n            a = str(need[0])\n            b = str(need[1])\n            if a in ht:\n                ht[a] +=1\n            else:\n                ht[a] = 1\n            if b in ht:\n                ht[b] += 1\n            else:\n                ht[b] = 1\n                \n        val = list(ht.values())\n        ans = max(val) \n        return ans\n                \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        patterns = collections.Counter()\n        for row in matrix:\n            patterns[tuple(row)]+=1\n        \n           \n            flip = [1-c for c in row]\n            patterns[tuple(flip)]+=1\n            \n        return max(patterns.values())\n    \n    \n    '''\n    \nCounter({(0, 0, 0): 1})\n===\nCounter({(0, 0, 0): 1, (1, 1, 1): 1})\n=========\nCounter({(0, 0, 0): 1, (1, 1, 1): 1, (0, 0, 1): 1})\n=========\nCounter({(0, 0, 0): 1, (1, 1, 1): 1, (0, 0, 1): 1, (1, 1, 0): 1})\n=========\nCounter({(1, 1, 0): 2, (0, 0, 0): 1, (1, 1, 1): 1, (0, 0, 1): 1})\n=========\nCounter({(0, 0, 1): 2, (1, 1, 0): 2, (0, 0, 0): 1, (1, 1, 1): 1})\n=========\n    '''\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        row = len(matrix)\n        col = len(matrix[0])\n        ht = {}\n        for r in range(row):\n            need = [[],[]]\n            for c in range(col):\n                if matrix[r][c] == 0:\n                    need[0].append(c)\n                else:\n                    need[1].append(c)\n            a = str(need[0])\n            b = str(need[1])\n            if a in ht:\n                ht[a] +=1\n            else:\n                ht[a] = 1\n            if b in ht:\n                ht[b] += 1\n            else:\n                ht[b] = 1\n        val = list(ht.values())\n        ans = max(val) \n        return ans\n                \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ma = 0\n        for i in matrix:\n            flip = [1-x for x in i]\n            c=0\n            for j in matrix:\n                if j == i or j == flip:\n                    c+=1            \n            if c > ma:\n                ma = c\n       \n        return ma", "from collections import defaultdict\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d = defaultdict(int)\n        mx = 1\n        for row in matrix:\n            ori = ''\n            inverse =''\n            for c in row:\n                ori += str(c)\n                inverse += str(1 - c)\n            d[ori] += 1\n            d[inverse] += 1\n            mx = max(mx,d[ori],d[inverse])\n        return mx\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        cnt = defaultdict(int)\n        \n        for i in range(m):\n            s1, s2 = '', ''\n            \n            for j in range(n):\n                s1 += str(matrix[i][j])\n                s2 += str(1^matrix[i][j])\n            \n            cnt[s1] += 1\n            cnt[s2] += 1\n        \n        return max(list(cnt.values()))", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix):\n        cache = collections.defaultdict(int)\n        for row in matrix:\n            vals = []\n            trans = []\n            for c in row:\n                vals.append(c)\n                trans.append(1 - c)\n            cache[str(vals)] += 1\n            cache[str(trans)] += 1\n        print(cache)\n        return max(cache.values())\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        flipper = int(''.join([str(bit) for bit in [1] * len(matrix[1])]), 2)\n        bits = [int(''.join([str(bit) for bit in row]), 2) for row in matrix]\n        \n        mx = 1\n        for bit1 in bits:\n            count = sum(\n                1 for bit in bits if bit == bit1 or bit1 ^ flipper == bit\n            )\n                    \n            mx = max(mx, count)\n        \n        return mx", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \n        def flip(arr):\n            for i in range(len(arr)):\n                if arr[i] == 1:\n                    arr[i] = \\\"#\\\"\n                if arr[i] == 0:\n                    arr[i] = 1\n            for i in range(len(arr)):\n                if arr[i] == \\\"#\\\":\n                    arr[i] = 0\n            return arr\n        \n        d = {}\n        for i in matrix:\n            if tuple(i) in d:\n                d[(tuple(i))] += 1\n            elif tuple(flip(i)) in d:\n                d[(tuple(i))] += 1\n            else:\n                d[(tuple(i))] = 1\n        \n        return max(list(d.values()))", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        rm = {}\n        for row in matrix:\n            r1 = '#'.join([str(x) for x in row])\n            r2 = '#'.join([('1' if x == 0 else '0') for x in row])\n            if r1 in rm:\n                rm[r1] += 1\n            elif r2 in rm:\n                rm[r2] += 1\n            else:\n                # r1 not in rm and r2 not in rm\n                rm[r1] = 1\n        return max(rm.values())", "from collections import defaultdict\nclass Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d = defaultdict(int)\n        for row in matrix:\n            ori = []\n            inverse =[]\n            for c in row:\n                ori.append(str(c))\n                inverse.append(str(1 - c))\n            d[''.join(ori)] += 1\n            d[''.join(inverse)] += 1\n        lis = list(d.values())\n        return max(lis)\n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        # pattern for each row\n        count = {}\n        for i in range(len(matrix)):\n            row = []\n            for j in range(len(matrix[0])):\n                row.append(matrix[i][j]^matrix[i][0])\n            k = ''.join(map(str, row))\n            if k not in count:\n                count[k] = 1\n            else:\n                count[k] += 1\n        res = 0\n        for k, v in count.items():\n            res = max(res, v)\n        return res", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \n        cache = collections.defaultdict(int)\n        for row in matrix:\n            values = []\n            flips = []\n            for col in row:\n                values.append(col)\n                flips.append(1 - col)\n            cache[str(values)] += 1\n            cache[str(flips)] += 1\n        return max(cache.values())\n", "class Tree(object):\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.data = -1\n\n    def insert(self, zero, n, row: List[int], i: int, counts: List[int]) -> int:\n        if len(row) == n:\n            if self.data == -1:\n                self.data = i\n                counts[self.data] = 1 + counts[i]\n                return i + 1\n            else:\n                counts[self.data] += 1\n                return i    \n        elif row[n] == zero:\n            if self.left is None:\n                self.left = Tree()\n            return self.left.insert(zero, n+1, row, i, counts)\n        else: # row[1] == one\n            if self.right is None:\n                self.right = Tree()\n            return self.right.insert(zero, n+1, row, i, counts)\n\nclass Solution:\n       \n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:     \n        firstcell = matrix[0][0]\n        vals = Tree()\n        counts = [0] * 300\n        nextfree = 0\n        \n        for row in matrix:\n            firstrowcell = row[0]\n            nextfree = vals.insert(firstcell if firstrowcell == 0 else 1 - firstcell, 0, row, nextfree, counts)\n            \n        return max(counts)", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        mod = 10 ** 9 + 7\n        d = collections.defaultdict(int)\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            t1 = 0\n            t2 = 0\n            for j in range(n):\n                t1 = ((t1 << 1) + matrix[i][j]) % mod\n                t2 = ((t2 << 1) + 1 - matrix[i][j]) % mod\n            d[t1] += 1\n            d[t2] += 1\n        #print(d)\n        return max(d.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        def encode(row):\n            i, l = row[0], 0\n            result = ''\n            result2 = ''\n            for j in row:\n                if j == i:\n                    l += 1\n                else:\n                    result += f'{i}{l}'\n                    result2 += f'{(i + 1) % 2}{l}'\n                    i = j\n                    l = 1\n            result += f'{i}{l}'\n            result2 += f'{(i + 1) % 2}{l}'\n            return result, result2\n        \n        m, n = len(matrix), len(matrix[0])\n        g = {}\n        for i in range(m):\n            a, b = encode(matrix[i])\n            if a in g:\n                g[a] += 1\n            else:\n                if b in g:\n                    g[b] += 1\n                else:\n                    g[a] = g.get(a, 0) + 1\n        return max(g.values())        ", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ans = 0\n        orig = [int(''.join([str(c) for c in row]), 2) for row in matrix]\n        xor = [int(''.join([str(1-c) for c in row]), 2) for row in matrix]\n        for i in range(len(matrix)):\n            curr = 1\n            for j in range(i+1, len(matrix)):\n                is_complement = xor[i] == orig[j]\n                is_equal = orig[i] == orig[j]\n                curr += int(is_complement or is_equal)\n            ans = max(curr, ans)\n        return ans", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d = defaultdict(int)\n        for row in matrix:\n            a = \\\"\\\"\n            b = \\\"\\\"\n            for num in row:\n                a += str(num)\n                b += str(num^1)\n            d[a] += 1\n            d[b] += 1\n            \n        return max(d.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        ans = 0\n        orig = []\n        xor = []\n        for row in matrix:\n            curr_orig = ''\n            curr_xor = ''\n            for c in row:\n                curr_orig += str(c)\n                curr_xor += str(1-c)\n            orig.append(int(curr_orig, 2))\n            xor.append(int(curr_xor, 2))\n        for i in range(len(matrix)):\n            curr = 1\n            for j in range(i+1, len(matrix)):\n                is_complement = xor[i] == orig[j]\n                is_equal = orig[i] == orig[j]\n                curr += int(is_complement or is_equal)\n            ans = max(curr, ans)\n        return ans", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        hashTab = defaultdict(int)\n\n        rows, cols = len(matrix), len(matrix[0])\n        \n        allOnes = int('1'*cols, 2)\n\n        maxSizeGroup = 0\n        \n        for row in matrix:\n            val = reduce(lambda a, x: a << 1 ^ x, row)\n            \n            if val not in hashTab:\n                val ^= allOnes\n            \n            hashTab[val] += 1\n            maxSizeGroup = max(maxSizeGroup, hashTab[val])\n\n        return maxSizeGroup", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        options = {\\\"\\\": 0}\n        best = \\\"\\\"\n        for i in range(len(matrix)):\n          option0 = \\\"\\\"\n          option1 = \\\"\\\"\n          for j in range(len(matrix[i])):\n            if matrix[i][j] == 1:\n              option0 = \\\",\\\".join([option0, str(j)])\n            else:\n               option1 = \\\",\\\".join([option1, str(j)])\n          for option in [option0, option1]:\n            if option in options:\n              options[option] += 1\n            else:\n              options[option] = 1\n            if options[option] > options[best]:\n              best = option\n        return options[best]", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        counts = defaultdict(int)\n        \n        for row in matrix:\n            counts[tuple(row) if row[0] else tuple(x ^ 1 for x in row)] += 1\n        \n        return max(counts.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        options = {tuple([]): 0}\n        best = tuple([])\n        for i in range(len(matrix)):\n          option0 = []\n          option1 = []\n          for j in range(len(matrix[i])):\n            if matrix[i][j] == 1:\n              option0.append(j)\n            else:\n               option1.append(j)\n          for option in [tuple(option0), tuple(option1)]:\n            if option in options:\n              options[option] += 1\n            else:\n              options[option] = 1\n            if options[option] > options[best]:\n              best = option\n        return options[best]", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        d=Counter()\n        for r in matrix:\n            normal=[]\n            reverse=[]\n            for v in r:\n                normal.append(str(v))\n                reverse.append(str(1-v))\n            d[''.join(normal)]+=1\n            d[''.join(reverse)]+=1\n        return max(d.values())", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        n = len(matrix[0])\n        matrix = [ [str(elem) for elem in row] for row in matrix]\n        int_rep_of_matrix = [int(''.join(row),2) for row in matrix]\n        \n        list_of_k = list(int_rep_of_matrix)\n        all_ones = 2**(n)-1\n        for elem in int_rep_of_matrix:\n            list_of_k.append(elem^all_ones)\n        \n        answer = 0\n        for k in list_of_k:\n            current_answer = 0\n            for matrix_row in int_rep_of_matrix:\n                if matrix_row^k == 0 or  matrix_row^k==all_ones:\n                    current_answer += 1\n            answer = max(answer,current_answer)\n        return answer\n                    \n                \n        \n", "class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cntMap = collections.Counter()\n        flipper = {1: 0, 0: 1}\n        max_val = 0\n        for row in matrix:\n            r, tran = \\\"\\\", \\\"\\\"\n            for k in row:\n                r += str(k)\n                tran += str(flipper[k])\n            key = r\n            cntMap[r] += 1\n            cntMap[tran] += 1\n            max_val = max(max_val, cntMap[r])\n            max_val = max(max_val, cntMap[tran])\n\n        return max_val\n                \n        "]
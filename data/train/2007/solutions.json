["import sys\nfrom itertools import *\nfrom math import *\ndef solve():\n    n, m = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    print(ss)\n\n\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()", "import sys\nfrom itertools import *\nfrom math import *\ndef solve():\n    n, m = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    ss, ll = 0, int(2.1e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    print(ss)\n\n\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()", "import sys\nfrom itertools import *\nfrom math import *\ndef solve():\n    n, m = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    ss, ll = 0, int(2.1e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    print(ss)\n\n\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()", "def can(d,a,b):\n    d1=d\n    mi=a[-1]\n    ma=a[-1]\n    while len(a)>0 and len(b)>0:\n        if b[-1]<=mi:\n            if abs(b[-1]-ma)<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n        elif b[-1]>=ma:\n            if abs(b[-1]-mi)<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n        else:\n            if abs(ma-mi)+min(abs(b[-1]-mi),abs(b[-1]-ma))<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n    return len(a)==0  \nn,m=list(map(int,input().split()))\ns=list(map(int,input().split()))[::-1]\ns1=list(map(int,input().split()))[::-1]\nhigh=(10**12)+1\nlow=0\nwhile high-low>1:\n    mid=(high+low)//2\n    if can(mid,s1.copy(),s.copy()):\n        high=mid\n    else:\n        low=mid\nif can(low,s1,s):\n    print(low)\nelse:\n    print(high)\n    \n", "def can(d,a,b):\n    d1=d\n    mi=a[-1]\n    ma=a[-1]\n    while len(a)>0 and len(b)>0:\n        if b[-1]<=mi:\n            if abs(b[-1]-ma)<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n        elif b[-1]>=ma:\n            if abs(b[-1]-mi)<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n        else:\n            if abs(ma-mi)+min(abs(b[-1]-mi),abs(b[-1]-ma))<=d1:\n                a.pop()\n                if len(a)==0:\n                    break\n                ma=a[-1]\n            else:\n                b.pop()\n                mi=a[-1]\n                ma=a[-1]\n    return len(a)==0  \nn,m=list(map(int,input().split()))\ns=list(map(int,input().split()))[::-1]\ns1=list(map(int,input().split()))[::-1]\nhigh=(10**11)+1\nlow=0\nwhile high-low>1:\n    mid=(high+low)//2\n    if can(mid,s1.copy(),s.copy()):\n        high=mid\n    else:\n        low=mid\nif can(low,s1,s):\n    print(low)\nelse:\n    print(high)\n    \n", "def can(d,a,b):\n    d1=d\n    mi=a[-1]\n    ma=a[-1]\n    x=len(a)-1\n    y=len(b)-1\n    while x>=0 and y>=0:\n        if b[y]<=mi:\n            if abs(b[y]-ma)<=d1:\n                x-=1\n                if x==-1:\n                    break\n                ma=a[x]\n            else:\n                y-=1\n                mi=a[x]\n                ma=a[x]\n        elif b[y]>=ma:\n            if abs(b[y]-mi)<=d1:\n                x-=1\n                if x==-1:\n                    break\n                ma=a[x]\n            else:\n                y-=1\n                mi=a[x]\n                ma=a[x]\n        else:\n            if abs(ma-mi)+min(abs(b[y]-mi),abs(b[y]-ma))<=d1:\n                x-=1\n                if x==-1:\n                    break\n                ma=a[x]\n            else:\n                y-=1\n                mi=a[x]\n                ma=a[x]\n    return x==-1 \nn,m=list(map(int,input().split()))\ns=list(map(int,input().split()))[::-1]\ns1=list(map(int,input().split()))[::-1]\nhigh=(10**10)*3\nlow=0\nwhile high-low>1:\n    mid=(high+low)//2\n    if can(mid,s1,s):\n        high=mid\n    else:\n        low=mid\nif can(low,s1,s):\n    print(low)\nelse:\n    print(high)\n    \n", "import sys\nfrom itertools import *\nfrom math import *\ndef solve():\n    n, m = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    ss, ll = 0, int(2.1e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright:\n                pidx += 1\n            hidx += 1\n        if pidx != len(p):\n            works = False\n        if works:\n            ll = avg\n        else:\n            ss = avg + 1\n    print(ss)\n \n \n\nsolve()\n"]
["import heapq\n\ndef coor_neighbor(coor, dxs, dys):\n    x, y = coor\n    for dx in dxs:\n        for dy in dys:\n            yield x + dx, y + dy\n\n\ndef coor_bottoms(coor):\n    return coor_neighbor(coor, (-1, 0, 1), (-1, ))\n\n\ndef coor_tops(coor):\n    return coor_neighbor(coor, (-1, 0, 1), (1, ))\n\n\ndef coor_sibs(coor):\n    return coor_neighbor(coor, (-2, -1, 1, 2), (0, ))\n\n\nclass Figure:\n\n    def __init__(self, coors):\n        self._coors = dict()\n        self._stables_min = []\n        self._stables_max = []\n        self._pushed = set()\n        self._dropped = set()\n\n        cubes = dict()\n        self._bots = dict()\n        self._tops = dict()\n        for idx, coor in enumerate(coors):\n            cubes[coor] = idx\n            self._coors[idx] = coor\n            self._bots[idx] = set()\n            self._tops[idx] = set()\n\n        coor_set = set(coors)\n        for idx, coor in enumerate(coors):\n            for bottom in coor_bottoms(coor):\n                if bottom in coor_set:\n                    self._bots[idx].add(cubes[bottom])\n            for top in coor_tops(coor):\n                if top in coor_set:\n                    self._tops[idx].add(cubes[top])\n\n        for idx in self._coors:\n            if self.isdroppable(idx):\n                self.push(idx)\n\n    def sibs(self, idx):\n        for top_idx in self._tops[idx]:\n            for sib_idx in self._bots[top_idx]:\n                if sib_idx not in self._dropped:\n                    yield sib_idx\n\n    def bottom_count(self, idx):\n        return len(self._bots[idx])\n\n    def isdroppable(self, idx):\n        return all(len(self._bots[top_idx]) > 1 for top_idx in self._tops[idx])\n\n    def push(self, idx):\n        if idx not in self._pushed:\n            heapq.heappush(self._stables_min, idx)\n            heapq.heappush(self._stables_max, -idx)\n            self._pushed.add(idx)\n\n    def unpush(self, idx):\n        if idx in self._pushed:\n            self._pushed.remove(idx)\n\n    def drop(self, idx):\n        if idx not in self._pushed:\n            return False\n        self._pushed.remove(idx)\n        self._dropped.add(idx)\n\n        for bot_idx in self._bots[idx]:\n            self._tops[bot_idx].remove(idx)\n        for top_idx in self._tops[idx]:\n            self._bots[top_idx].remove(idx)\n\n        coor = self._coors[idx]\n        for bot_idx in self._bots[idx]:\n            if self.isdroppable(bot_idx):\n                self.push(bot_idx)\n        for sib_idx in self.sibs(idx):\n            if not self.isdroppable(sib_idx):\n                self.unpush(sib_idx)\n        return True\n\n    def drop_min(self):\n        while True:\n            if not self._stables_min:\n                return None\n            min_idx = heapq.heappop(self._stables_min)\n            if self.drop(min_idx):\n                return min_idx\n\n    def drop_max(self):\n        while True:\n            if not self._stables_max:\n                return None\n            max_idx = - heapq.heappop(self._stables_max)\n            if self.drop(max_idx):\n                return max_idx\n\n    def __bool__(self):\n        return len(self._coors) != len(self._dropped)\n\n\ndef input_tuple():\n    return tuple(map(int, input().split()))\n\n\ndef result_add(result, base, num):\n    return (result * base + num) % (10 ** 9 + 9)\n\n\nN = int(input())\ncoors = [input_tuple() for _ in range(N)]\n\nfigure = Figure(coors)\nresult = 0\nwhile True:\n    if not figure:\n        break\n    result = result_add(result, N, figure.drop_max())\n    if not figure:\n        break\n    result = result_add(result, N, figure.drop_min())\nprint(result)\n"]
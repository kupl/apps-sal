["class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        dp = [-1] * len(s)\n        return self.dfs(s, k, 0, dp)\n    \n    def dfs(self, s: str, k: int, start: int, dp: List[int]) -> int:\n        if start == len(s):\n            return 1\n        if s[start] == '0':\n            return 0\n        if dp[start] != -1:\n            return dp[start]\n        \n        res, num = 0, 0\n        \n        for i in range(start, len(s)):\n            num = num * 10 + (ord(s[i]) - ord('0'))\n            \n            if num > k:\n                break \n            \n            res += self.dfs(s, k, i + 1, dp)\n            res %= 10**9 + 7\n            \n        dp[start] = res\n        return res", "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        n = len(s)\n        b = ord('0')\n        MOD = 10 ** 9 + 7\n        dp = collections.deque([0] * 10)\n        dp[0] = 1\n        for i in range(n - 1, -1, -1):\n            if s[i] == '0':\n                dp.pop()\n                dp.appendleft(0)\n                continue\n            num = 0\n            cnt = 0\n            for j in range(i, n):\n                num = num * 10 + ord(s[j]) - b\n                if num <= k:\n                    cnt += dp[j - i] % MOD\n                else:\n                    break\n            dp.appendleft(cnt % MOD)\n            dp.pop()\n        return dp[0]\n                    \n                \n", "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(s)\n        @lru_cache(None)\n        def dp(i):\n            if i == n:\n                return 1\n            if s[i] == '0':\n                return 0\n            num = 0\n            ans = 0\n            for j in range(i, n):\n                num = num * 10 + ord(s[j]) - ord('0')\n                if num > k:\n                    break\n                ans += dp(j+1)\n            return ans % MOD\n        \n        return dp(0)\n", "class Solution:\n    def numberOfArrays(self, S: str, K: int) -> int:\n        import sys\n        sys.setrecursionlimit(10**9+7)\n        \n        @lru_cache(None)\n        def ways(idx):\n            if idx == len(S): return 1\n            if S[idx] == '0': return 0\n            \n            ans = 0\n            num = 0\n            for i in range(idx, len(S)):\n                num = num*10 + (ord(S[i]) - ord('0'))\n                if num > K: break\n                \n                ans = (ans + ways(i+1)) % 1000000007\n            return ans\n    \n        return ways(0)\n", "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        n = len(s)\n        b = ord('0')\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def dp(i):\n            if i == n:\n                return 1\n            if s[i] == '0':\n                return 0\n            cnt = 0\n            num = ord(s[i]) - b\n            while num <= k:\n                cnt += dp(i + 1) % MOD\n                i += 1\n                if i < n:\n                    num = num * 10 + ord(s[i]) - b\n                else:\n                    break\n            return cnt % MOD\n        \n        return dp(0)\n                    \n                \n", "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        import sys\n        sys.setrecursionlimit(10**9+7)\n        \n        @lru_cache(None)\n        def ways(idx):\n            if idx == len(s): return 1\n            if s[idx] == '0': return 0\n            \n            ans = 0\n            num = 0\n            for i in range(idx, len(s)):\n                num = num*10 + (ord(s[i]) - ord('0'))\n                if num > k: break\n                \n                ans = (ans + ways(i+1)) % 1000000007\n            return ans\n    \n        return ways(0)\n", "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        dp = [-1] * len(s)\n        return self.dfs(s, k, 0, dp)\n    \n    def dfs(self, s: str, k: int, start: int, dp: List[int]) -> int:\n        if start == len(s):\n            return 1\n        if s[start] == '0':\n            return 0\n        if dp[start] != -1:\n            return dp[start]\n        \n        res, num = 0, 0\n        \n        for i in range(start, len(s)):\n            num = num * 10 + (ord(s[i]) - ord('0'))\n            \n            if num > k:\n                break \n            \n            res += self.dfs(s, k, i + 1, dp)\n            res %= 10**9 + 7\n            \n        dp[start] = res\n        return res\n", "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        \n        cache = {}\n        n = len(s)\n        mod = 10 ** 9 + 7\n        \n        def process(i):\n            if i == n:\n                return 1\n            else:\n                if s[i] == '0':\n                    return 0\n                else:\n                    if not i in cache:\n                        ans = 0\n                        x = 0\n                        j = 0\n                        while i+j < n:\n                            x = x * 10 + (ord(s[i+j]) - 48)\n                            if x <= k:\n                                ans += process(i+j+1)\n                                j += 1\n                            else:\n                                break\n                        cache[i] = ans % mod\n                    return cache[i]\n        \n        return process(0)\n                        \n        \n", "MOD = int(1e9 + 7)\n\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        dp = [-1 for _ in s]\n        n = len(s)\n        \n        def recurse(i: int) -> int:\n            if i == n:\n                return 1\n            \n            if dp[i] != -1:\n                return dp[i]\n            \n            result = 0\n            val = 0\n            for j in range(i, n):\n                val = 10 * val + (ord(s[j]) - ord('0'))\n                if val > k:\n                    break\n                elif j == n - 1 or s[j + 1] != '0':\n                    result = (result + recurse(j + 1)) % MOD\n            dp[i] = result\n            return result\n        \n        return recurse(0)\n                \n    \n\n"]
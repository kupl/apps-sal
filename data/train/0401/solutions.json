["#5:09\n'''\nnums = [3,6,5,1,8]\nsum_nums = 23\nmod3_sum_nums = 2\nmod3_dict = {0:[3,6], 1:[1], 2:[5,8]}\nhelper([5,8], [1]) -> 5\n\n\n\n\n\n'''\n\nfrom collections import defaultdict\nclass Solution:\n    def helper(self, l1, l2):\n        if len(l1) < 1 and len(l2) <2:\n            sum_remove = 0\n        elif len(l1) < 1:\n            sum_remove = min(l2)\n            l2.remove(sum_remove)\n            sum_remove += min(l2)\n            \n        elif len(l2) <2:\n            sum_remove = min(l1)\n            \n        else:\n            sum_remove1 = min(l1)\n            sum_remove2 = min(l2)\n            l2.remove(sum_remove2)\n            sum_remove2 += min(l2)\n            sum_remove = min(sum_remove1, sum_remove2)\n        \n        return sum_remove\n            \n            \n    def maxSumDivThree(self, nums: List[int]) -> int:\n        sum_nums = sum(nums)\n        mod3_sum_nums = sum_nums%3\n        if mod3_sum_nums == 0:\n            return sum_nums\n        \n        mod3_dict = defaultdict(list)\n        for i,num in enumerate(nums):\n            mod3_dict[num%3].append(num)\n         \n        \n        if mod3_sum_nums ==1:\n            sum_remove = self.helper(mod3_dict[1], mod3_dict[2])\n            \n        else:\n            sum_remove = self.helper(mod3_dict[2], mod3_dict[1])\n        \n        if sum_remove >0:\n            return sum_nums - sum_remove\n        else:\n            return 0\n            \n        \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        if sum(nums) % 3 == 0:\n            return sum(nums)\n        \n        mod1 = [num for num in nums if num % 3 == 1]\n        mod2 = [num for num in nums if num % 3 == 2]\n        mod1_min = min(mod1 or [float('inf')])\n        mod2_min = min(mod2 or [float('inf')])\n        \n        if mod1_min != float('inf'):\n            mod1.remove(mod1_min)\n        \n        if mod2_min != float('inf'):\n            mod2.remove(mod2_min)\n        \n        possibilities = [ \n            sum(nums) - mod1_min,\n            sum(nums) - mod2_min,\n            sum(nums) - mod1_min - min(mod1 or [float('inf')]),\n            sum(nums) - mod2_min - min(mod2 or [float('inf')]),\n        ]\n        \n        \n        \n        return max([\n            pos for pos in possibilities if pos % 3 == 0\n        ] or [0])", "\n# 1262. Greatest Sum Divisible by Three\n\n# Explanation: seen[i] means the current maximum possible sum that sum % 3 = i\n# Complexity: Time O(N), Space O(1)\n\nclass Solution1:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0, 0, 0]\n        for a in nums:\n            for i in seen[:]: # \u8fd9\u91cc\u5fc5\u987b\u7528 [:] \u5426\u5219 \u4e0b\u4e00\u6b21\u8fed\u4ee3\u4f1a\u4f7f\u7528\u66f4\u65b0\u540e\u7684\u503c \u8ba1\u7b97\u7ed3\u679c\u4e0d\u5bf9\n                seen[(i + a) % 3] = max(seen[(i + a) % 3], i + a)\n                # print(a, i, seen)\n        return seen[0]\n    \n# Divide the whole list into three parts: mod_0, mod_1, mod_2.\n# Think about the sum of the original list, if it mods 3 == 0, then we can just return the sum.\n# If tot_sum % 3 == 1, then we should remove one smallest element from mod_1 or two smallest ones from mod_2.\n# If tot_sum % 3 == 2, then we should remove one smallest element from mod_2 or two smallest ones from mod_1.\n\nclass Solution: # \uff08\u6ca1\u660e\u767d\u3002\u3002\uff09\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        mod_1, mod_2,res,remove = [], [], 0, float('inf')\n        for i in nums:\n            if i % 3 == 0: res += i\n            if i % 3 == 1: mod_1 += [i]\n            if i % 3 == 2: mod_2 += [i]\n        mod_1.sort(reverse = True)\n        mod_2.sort(reverse = True)\n        tmp = sum(mod_1) + sum(mod_2)\n        if tmp % 3 == 0:\n            return res + tmp\n        elif tmp% 3 == 1:\n            if len(mod_1): \n                remove = min(remove, mod_1[-1])\n            if len(mod_2) > 1: \n                remove = min(mod_2[-1] + mod_2[-2], remove)\n        elif tmp % 3 == 2:\n            if len(mod_2): \n                remove = min(remove, mod_2[-1])\n            if len(mod_1) > 1: \n                remove = min(mod_1[-1] + mod_1[-2], remove)\n        return res + tmp - remove", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        dp = [ [0 for _ in range(3)] for _ in range(len(nums))]\n        dp[0][nums[0]%3] = nums[0]\n        for i in range(1, len(nums)):\n            for j in range(3):\n                dp[i][j] = dp[i-1][j]\n            currNum = nums[i]\n            for j in range(3):\n                curr = dp[i-1][j] + nums[i]\n                k = curr %3\n                dp[i][k] = max(dp[i][k], curr)\n        return dp[len(nums)-1][0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for j in range(3)] for i in range(n)]\n        dp[0][nums[0]%3] = nums[0]\n        for i in range(1, n):\n            for j in range(3):\n                dp[i][j] = dp[i-1][j]\n                if (j-nums[i]) % 3 == 0:\n                    dp[i][j] = max(dp[i-1][(j-nums[i]) % 3] + nums[i], dp[i-1][j])\n                else:\n                    if dp[i-1][(j-nums[i]) % 3] > 0:\n                        dp[i][j] = max(dp[i-1][(j-nums[i]) % 3] + nums[i], dp[i-1][j])\n        # print([i[0] for i in dp])\n        # print([i[1] for i in dp])\n        # print([i[2] for i in dp])\n        return dp[n-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        zero, one, two = [0]*(n+1),[0]*(n+1),[0]*(n+1)\n        one[0] = two[0] = float('-inf')\n        for i in range(1,n+1):\n            if nums[i-1]%3 == 0:\n                zero[i] = zero[i-1]+nums[i-1]\n                one[i] = one[i-1]+nums[i-1] if one[i-1]>0 else 0\n                two[i] = two[i-1]+nums[i-1] if two[i-1]>0 else 0\n            elif nums[i-1]%3 == 1:\n                zero[i] = max(two[i-1]+nums[i-1],zero[i-1])\n                two[i] = max(two[i-1],one[i-1]+nums[i-1])\n                one[i] = max(one[i-1],zero[i-1]+nums[i-1])\n            else:\n                zero[i] = max(one[i-1]+nums[i-1],zero[i-1])\n                two[i] = max(zero[i-1]+nums[i-1],two[i-1])\n                one[i] = max(two[i-1]+nums[i-1],one[i-1])\n        return zero[-1]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n==0:\n            return 0\n        dp = [0,0,0]\n        for num in nums:\n            for i in dp[:]:\n                dp[(i+num)%3] = max(dp[(i+num)%3], i+num)\n        return dp[0]\n    \n    # def maxSumDivThree(self, A):\n    #     seen = [0, 0, 0]\n    #     for a in A:\n    #         for i in seen[:]:\n    #             seen[(i + a) % 3] = max(seen[(i + a) % 3], i + a)\n    #     return seen[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [[0, -1, -1] for _ in range(len(nums)+1)]\n        for i in range(1, len(nums)+1):\n            r = nums[i-1] % 3\n            for s in range(3):\n                if dp[i-1][s] >= 0:\n                    dp[i][(r+s)%3] = max(dp[i-1][(r+s)%3], dp[i-1][s]+nums[i-1])\n                dp[i][s] = max(dp[i-1][s], dp[i][s])\n        \n        return dp[len(nums)][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        m = sum(nums)\n        N = len(nums)\n        \n        @lru_cache(None)\n        def dp(i,p): # best sumsofar at i\n            if i == N:\n                return 0 if p == 0 else -float('inf') \n            \n            a = dp(i+1, p)\n            b = dp(i+1, (p+nums[i])%3)+nums[i]\n            return max(a,b)\n        \n        return dp(0,0)", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0,0,0]\n        for n in nums:\n            for i in seen[:]:\n                seen[(n + i) % 3] = max(seen[(n + i) % 3], i + n)\n        \n        return seen[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        dp = [[0]*3 for _ in range(n)]\n        \n        for i, x in enumerate(nums):\n            m = x % 3\n            if i > 0:\n                dp[i] = dp[i-1][::]\n                # for j in range(3):\n                #     if dp[i][(j-m)%3] > 0:\n                #         dp[i][j] = max(dp[i][j], dp[i][(x-m)%3] + x)\n                rot = [dp[i][(x-m)%3] for x in range(3)]\n\n                for j in range(3):\n                    if rot[j] > 0:\n                        dp[i][j] = max(dp[i][j], rot[j] + x) # can add to it\n                        \n            dp[i][m] = max(dp[i][m], x) # better to start anew with current element\n            \n                \n        print(dp)\n        return dp[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:        \n        dp=[[0]*3 for i in range(len(nums))]\n        for i in range(len(dp)):\n            dp[i]=list(dp[i-1])\n            for k in range(3):\n                index=((dp[i-1][k] if i-1>=0 else 0)+nums[i])%3\n                dp[i][index]=max((dp[i-1][k] if i-1>=0 else 0)+nums[i],dp[i][index])\n        return dp[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        # dp 0/1 problem\n        dp = [ [-float('inf')] * len(nums) for _ in range(3)]\n        \n        for i, n in enumerate(nums):\n            if i == 0:\n                dp[n%3][0] = n\n            \n            else:\n                for rem in range(3):\n                    # choose / don't choose\n                    dp[(n+rem)%3][i] = max(dp[rem][i-1] + n, dp[(n+rem)%3][i-1]) \n                # how about just n itself\n                dp[n%3][i] = max(n, dp[n%3][i])\n          \n\n        return dp[0][-1] if dp[0][-1] != -float('inf') else 0\n \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n==0:\n            return 0\n        dp = [[0]*3 for i in range(n)]\n        dp[0][nums[0]%3]=nums[0]\n        for i in range(1,n):\n            t1 = nums[i]%3\n            dp[i][0] = max(dp[i-1][(3-t1)%3]+nums[i], dp[i-1][0]) if dp[i-1][(3-t1)%3]!=0 else dp[i-1][0]\n            dp[i][1] = max(dp[i-1][(3-t1+1)%3]+nums[i],dp[i-1][1]) if dp[i-1][(3-t1+1)%3]!=0 else dp[i-1][1]\n            dp[i][2] = max(dp[i-1][(3-t1+2)%3]+nums[i], dp[i-1][2]) if dp[i-1][(3-t1+2)%3]!=0 else dp[i-1][2]\n            dp[i][t1] = max(nums[i], dp[i][t1])\n        \n        return dp[-1][0]\n                \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [[0, 0, 0]] * (len(nums) + 1)\n        for i in range(len(nums)):\n            cand = dp[i] + [n + nums[i] for n in dp[i]]\n            for c in cand:\n                j = c % 3\n                dp[i + 1][j] = max(dp[i + 1][j], c)\n        return dp[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        memo = {}\n        self.helper(0,nums,memo)\n        return memo[(0,0)]\n        \n    def helper(self,index,nums,memo):\n        if index == len(nums):\n            memo[(index,0)] = 0\n            memo[(index,1)] = 0\n            memo[(index,2)] = 0\n        else:\n            self.helper(index + 1,nums,memo)\n            for i in range (3):\n                if (i != 0) and (memo[(index + 1, i)] == 0):\n                    memo[(index,(i + nums[index]) % 3)] = max(0,memo[(index + 1,(i + nums[index]) % 3)])\n                else:\n                    new_mod = (nums[index] + memo[(index + 1, i)]) % 3\n                    new_sum = max(nums[index] + memo[(index + 1,i)],memo[(index + 1,new_mod)])\n                    memo[(index,new_mod)] = new_sum\n            return", "\n\n\n\n\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        res = 0\n        total = sum(nums)\n        \n        #only consider removing numbers that are not already divisible by 3\n        remove = tuple(sorted(n for n in nums if n%3))\n        \n        q = collections.deque([(total, 0)]) #total and bitmasked removed numbers\n        visited = set([0])\n        \n        while q:\n            \n            t, r = q.popleft()\n            \n            if not t%3:\n                res = max(res, t)\n                continue\n\n            if t <= res:\n                continue\n\n            for i in range(len(remove)):\n                if not (1 << i) & r:\n                    b = (1 << i) | r\n                    if b not in visited:\n                        visited.add(b)\n                        q.append((t-remove[i], b))\n        \n        return res", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        snum = sum(nums)\n        if not snum%3: return snum\n        ones, twos = [], []\n        nums.sort()\n        for k, v in enumerate(nums):\n            if v%3 == 1: \n                ones += [nums[k]] \n            if v%3 == 2:\n                twos += [nums[k]]\n        if snum%3 == 1:\n            snum = max(snum - ones[0], snum - sum(twos[:2])) if len(twos) >=2 else snum - ones[0]\n        if snum%3 == 2:\n            snum = max(snum - twos[0], snum - sum(ones[:2])) if len(ones) >=2 else snum - twos[0]\n        return snum\n        \n        \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        #nums=[2,6,2,2,7]\n        nums.sort()\n        \n        quotient = []   # *3\n        remainder = []\n        ret = 0\n        \n        for num in nums:\n            quotient.append(num//3*3)\n            remainder.append(num%3)\n            ret += num\n        \n        #print(nums)\n        #print(quotient)\n        #print(remainder)\n        \n        remainder_sum = ret%3\n        #print(remainder_sum)\n        if remainder_sum == 0:\n            return ret\n        elif remainder_sum == 1:\n            # compare min remainder 1 and 2\n            remainder1 = 0\n            remainder1_count = 0\n            remainder2 = 0\n            remainder2_count = 0\n            for i in range(len(nums)):\n                if remainder[i] == 1:\n                    if remainder1_count >= 1:\n                        continue\n                    remainder1_count += 1\n                    remainder1 += nums[i]\n                if remainder[i] == 2:\n                    if remainder2_count >= 2:\n                        continue\n                    remainder2_count += 1\n                    remainder2 += nums[i]    \n                if remainder2_count >= 1 and remainder1_count >= 2:\n                    break\n                \n            if remainder2_count == 2 and remainder1_count == 1:\n                return ret - min(remainder1, remainder2)\n            elif remainder2_count == 2:\n                return ret - remainder2\n            elif remainder1_count == 1:\n                return ret - remainder1\n            else:\n                return 0\n        else:\n            # compare min remainder 1 and 2\n            remainder1 = 0\n            remainder1_count = 0\n            remainder2 = 0\n            remainder2_count = 0\n            for i in range(len(nums)):\n                if remainder[i] == 1:\n                    if remainder1_count >= 2:\n                        continue\n                    remainder1_count += 1\n                    remainder1 += nums[i]\n                if remainder[i] == 2:\n                    if remainder2_count >= 1:\n                        continue\n                    remainder2_count += 1\n                    remainder2 += nums[i]    \n                if remainder2_count >= 1 and remainder1_count >= 2:\n                    break\n                \n            if remainder2_count == 1 and remainder1_count == 2:\n                return ret - min(remainder1, remainder2)\n            elif remainder2_count == 1:\n                return ret - remainder2\n            elif remainder1_count == 2:\n                return ret - remainder1\n            else:\n                return 0\n                \n            return 0\n            \n        return 0", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        mod_one = [-1, -1]\n        mod_two = [-1, -1]\n        total_sum = 0\n        for x in nums:\n            total_sum += x\n            if x % 3 == 1:\n                if mod_one[0] == -1 or x < mod_one[0]:\n                    mod_one[1] = mod_one[0]\n                    mod_one[0] = x\n                elif mod_one[1] == -1 or x < mod_one[1]:\n                    mod_one[1] = x\n            elif x % 3 == 2:\n                if mod_two[0] == -1 or x < mod_two[0]:\n                    mod_two[1] = mod_two[0]\n                    mod_two[0] = x\n                elif mod_two[1] == -1 or x < mod_two[1]:\n                    mod_two[1] = x\n        \n        if total_sum % 3 == 0:\n            return total_sum\n        elif total_sum % 3 == 1:\n            if mod_one[0] != -1 and (mod_two[0] == -1 or mod_two[1] == -1 or mod_one[0] < sum(mod_two)):\n                return total_sum - mod_one[0]\n            elif mod_two[0] != -1 and mod_two[1] != -1:\n                return total_sum - sum(mod_two)\n            else:\n                return 0\n        else:\n            if mod_two[0] != -1 and (mod_one[0] == -1 or mod_one[1] == -1 or mod_two[0] < sum(mod_one)):\n                return total_sum - mod_two[0]\n            elif mod_one[0] != -1 and mod_one[1] != -1:\n                return total_sum - sum(mod_one)\n            else:\n                return 0", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        mod_1, mod_2,res,remove = [], [], 0, float('inf')\n        for i in nums:\n            if i%3 == 0: res += i\n            if i%3 == 1: mod_1 += [i]\n            if i %3 == 2: mod_2 += [i]\n        mod_1.sort(reverse = True)\n        mod_2.sort(reverse = True)\n        tmp = sum(mod_1) +sum(mod_2)\n        if tmp % 3 == 0:\n            return res + tmp\n        elif tmp% 3 == 1:\n            if len(mod_1): remove = min(remove,mod_1[-1])\n            if len(mod_2) > 1: remove = min(mod_2[-1]+mod_2[-2],remove)\n        elif tmp % 3 == 2:\n            if len(mod_2): remove = min(remove,mod_2[-1])\n            if len(mod_1) > 1: remove = min(mod_1[-1]+mod_1[-2],remove)\n        return res + tmp - remove\n                \n", "\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        mod_1, mod_2,res,remove = [], [], 0, float('inf')\n        for i in nums:\n            if i%3 == 0: res += i\n            if i%3 == 1: mod_1 += [i]\n            if i %3 == 2: mod_2 += [i]\n        mod_1.sort(reverse = True)\n        mod_2.sort(reverse = True)\n        tmp = sum(mod_1) +sum(mod_2)\n        if tmp % 3 == 0:\n            return res + tmp\n        elif tmp% 3 == 1:\n            if len(mod_1): remove = min(remove,mod_1[-1])\n            if len(mod_2) > 1: remove = min(mod_2[-1]+mod_2[-2],remove)\n        elif tmp % 3 == 2:\n            if len(mod_2): remove = min(remove,mod_2[-1])\n            if len(mod_1) > 1: remove = min(mod_1[-1]+mod_1[-2],remove)\n        return res + tmp - remove", "def s(l1, l1_start_idx, l2, l2_start_idx):\n    if len(l1) < l1_start_idx or len(l2) < l2_start_idx:\n        return 0\n    \n    res = sum(l1[0:l1_start_idx]) + sum(l2[0:l2_start_idx])\n    \n    l1_end = l1_start_idx + 3 * ((len(l1) - l1_start_idx) // 3)\n    res += sum(l1[l1_start_idx:l1_end])\n    \n    l2_end = l2_start_idx + 3 * ((len(l2) - l2_start_idx) // 3)\n    res += sum(l2[l2_start_idx:l2_end])\n    \n    return res\n\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        res = 0\n        ones = []\n        twos = []\n        for n in nums:\n            mod = n % 3\n            if mod == 0:\n                res += n\n            elif mod == 1:\n                ones.append(n)\n            elif mod == 2:\n                twos.append(n)\n        ones.sort(reverse = True)\n        twos.sort(reverse = True)\n        \n        counter = 0\n        ones_sum = [0]\n        for x in ones:\n            counter += x\n            ones_sum.append(counter)\n        \n        counter = 0\n        twos_sum = [0]\n        for x in twos:\n            counter += x\n            twos_sum.append(counter)\n\n        m = 0\n        for i in range(0, min(len(ones), len(twos)) + 1):\n            one_end = i + ((len(ones) - i) // 3 ) * 3\n            two_end = i + ((len(twos) - i) // 3 ) * 3\n            x = ones_sum[one_end] + twos_sum[two_end]\n            m = max(m, x)\n        \n        res += m\n            \n        return res", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        l0 = [i for i in nums if i % 3 == 0]\n        l1 = [i for i in nums if i % 3 == 1]\n        l2 = [i for i in nums if i % 3 == 2]\n        \n        print((l0, l1, l2))\n        \n        total_sum = sum(nums)\n        \n        res = total_sum\n        \n        if total_sum % 3 != 0:\n            \n            if total_sum % 3 == 1:\n                res1 = sum(l0) + sum(l1[1:]) + sum(l2)\n                res2 = sum(l0) + sum(l1) + sum(l2[2:])\n\n            elif total_sum % 3 == 2:\n                res1 = sum(l0) + sum(l1[2:]) + sum(l2)\n                res2 = sum(l0) + sum(l1) + sum(l2[1:])\n            \n            if res1 % 3 == 0 and res2%3 == 0:\n                res = max(res1, res2)\n            elif res1 % 3 == 0:\n                res = res1\n            else:\n                res = res2\n        \n        return res\n", "class Solution:\n    def maxSumDivThree(self, nums):\n\n        total =     sum(nums)\n        mod_total = total % 3 \n\n        if mod_total == 0:\n            return total\n\n        else:\n\n            def min_n(nums, n):\n                if len(nums) < n: return 10**6\n                sum_n = 0\n                for i in range(n):\n                    min_current = min(nums)\n                    min_current_ind = nums.index(min_current)\n                    sum_n += nums.pop(min_current_ind)\n                return sum_n\n\n            mod_1 = [e for e in nums if e % 3 == 1]\n            mod_2 = [e for e in nums if e % 3 == 2]\n\n            if mod_total == 1:\n\n                one_mod_1 =   min_n(mod_1, 1)\n                two_mod_2 =   min_n(mod_2, 2)\n\n                return total - min(one_mod_1, two_mod_2)\n\n            elif mod_total == 2:\n\n                two_mod_1 =   min_n(mod_1, 2)\n                one_mod_2 =   min_n(mod_2, 1)\n\n                return total - min(two_mod_1, one_mod_2)\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        m0 = 0\n        m1 = 0\n        m2 = 0\n        for n in nums:\n            m = n % 3\n            m0n, m1n, m2n = m0, m1, m2\n            \n            if m == 0:\n                m0n = m0 + n\n                m1n = m1 + n\n                m2n = m2 + n\n            elif m == 1:\n                if m2 % 3 == 2:\n                    m0n = max(m0, m2 + n)\n                m1n = max(m1, m0 + n)\n                if m1 % 3 == 1:\n                    m2n = max(m2, m1 + n)\n            elif m == 2:\n                if m1 % 3 == 1:\n                    m0n = max(m0, m1 + n)\n                if m2 % 3 == 2:\n                    m1n = max(m1, m2 + n)\n                m2n = max(m2, m0 + n)\n            m0, m1, m2 = m0n, m1n, m2n\n            \n        return m0", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        counts = [0, 0, 0]\n        small_two = []\n        small_one = []\n\n        result = 0\n        for i in nums:\n            result += i\n            rem = i % 3\n            counts[i % 3] += 1\n            \n            if rem == 0:\n                continue\n            elif rem == 1:\n                small_one = sorted(small_one + [i])[:3]\n            else:\n                small_two = sorted(small_two + [i])[:3]\n\n        # compensate\n        print(small_two, small_one, result)\n        if result % 3 == 2:\n            return result - (small_two[0] if len(small_one) < 2 or (small_two[0] < small_one[0]+small_one[1]) else small_one[0]+small_one[1])\n        if result % 3 == 1:\n            return result - (small_one[0] if len(small_two) < 2 or (small_one[0] < small_two[0]+small_two[1]) else small_two[0]+small_two[1])\n\n        return result", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        total = sum(nums)\n        nums.sort()\n\n        rest = total % 3\n\n        if not rest:\n            return total\n\n        a, b = 0, 0\n        for n in nums:\n            if b and n > b:\n                break\n\n            mod = n % 3\n            if mod:\n                if rest == mod:\n                    return total - n\n                else:\n                    if not a:\n                        a = n\n                    elif not b:\n                         b = a + n\n\n        return total - b", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        snum = sum(nums)\n        nums.sort()\n        if not snum%3: return snum\n        ones, twos = [], []\n        for k, v in enumerate(nums):\n            if v%3 == 1: \n                heapq.heappush(ones,nums[k])\n            if v%3 == 2:\n                heapq.heappush(twos,nums[k])\n        if snum % 3 == 1:\n            snum = snum - min(ones[0], sum(twos[:2])) if len(twos) >=2 else snum - ones[0]\n        if snum % 3 == 2:\n            snum = snum - min(twos[0], sum(ones[:2])) if len(ones) >= 2 else snum - twos[0]\n        return snum\n        \n        \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        x=sum(nums)\n        if x%3==0:\n            return x\n        nums.sort()\n        opt1=10**4+1\n        opt2=count=0\n        for n in nums:\n            if n%3==x%3:\n                opt1=min(opt1, n)\n                if count==2:\n                    break\n            elif n%3!=0 and n%3!=x%3:\n                if count<=1:\n                    opt2+=n\n                    count+=1\n                if count==2 and opt1<10**4+1:\n                    break\n        if count==2:\n            return x-min(opt1,opt2)\n        return x-opt1", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        total = sum(nums)\n        n = len(nums)\n        if total%3 == 0:\n            return total\n        nums_set = set(nums)\n        div, mod = divmod(total, 3)\n        nums.sort()\n        while mod <= total:\n            if mod in nums_set:\n                return div*3\n            for i in range(n-2):\n                sum_val = 0\n                if nums[i] > mod:\n                    break\n                for j in range(i+1, n-1):\n                    if nums[i] + nums[j] == mod:\n                        return div*3    \n                    for k in range(j+1, n):\n                        #print(i, j, k)\n                        #print(nums[i], nums[j:k])\n                        sum_val += nums[i] + sum(nums[j:k])\n                        if sum_val == mod:\n                            return div*3\n                        if sum_val > mod:\n                            break     \n\n            div -= 1\n            mod += 3", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0, None, None]\n        for num in nums:\n            mod = num % 3 \n            if mod == 0:\n                dp[0], dp[1], dp[2] = (dp[0] + num, \n                                       dp[1] + num if dp[1] else None, \n                                       dp[2] + num if dp[2] else None)\n            elif mod == 1:\n                dp[0], dp[1], dp[2] = (max(dp[0], dp[2] + num if dp[2] else 0),\n                                       max(dp[1] if dp[1] else 0, dp[0] + num),\n                                       max(dp[2] if dp[2] else 0, dp[1] + num if dp[1] else 0) if dp[1] or dp[2] else None)\n            elif mod == 2:\n                dp[0], dp[1], dp[2] = (max(dp[0], dp[1] + num if dp[1] else 0),\n                                       max(dp[1] if dp[1] else 0, dp[2] + num if dp[2] else 0) if dp[1] or dp[2] else None,\n                                       max(dp[2] if dp[2] else 0, dp[0] + num))\n        return dp[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        x=sum(nums)\n        if x%3==0:\n            return x\n        nums.sort()\n        #print(nums,x)\n        opt1=10**4+1\n        opt2=count=0\n        for n in nums:\n            if n%3==x%3:\n                opt1=min(opt1, n)\n                if count==2:\n                    break\n            elif n%3!=0 and n%3!=x%3:\n                if count<=1:\n                    opt2+=n\n                    count+=1\n                elif count==2:\n                    pass\n        #print(opt1, opt2)\n        if count==2:\n            return x-min(opt1,opt2)\n        return x-opt1", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0, 0, 0]\n        for n in nums:\n            if n % 3 == 0:\n                dp0 = dp[0] + n\n                if dp[1] > 0: dp1 = dp[1] + n\n                else: dp1 = dp[1]\n                if dp[2] > 0: dp2 = dp[2] + n\n                else: dp2 = dp[2]\n            elif n % 3 == 1:\n                if dp[2] > 0: dp0 = max(dp[0], dp[2] + n)\n                else: dp0 = dp[0]\n                if dp[0] > 0: dp1 = max(dp[1], dp[0] + n)\n                else: dp1 = max(dp[1], n) \n                if dp[1] > 0: dp2 = max(dp[2], dp[1] + n)\n                else: dp2 = dp[2]\n            elif n % 3 == 2:\n                if dp[1] > 0: dp0 = max(dp[0], dp[1] + n)\n                else: dp0 = dp[0]\n                if dp[2] > 0: dp1 = max(dp[1], dp[2] + n)\n                else: dp1 = dp[1]\n                if dp[0] > 0: dp2 = max(dp[2], dp[0] + n)\n                else: dp2 = max(dp[2], n)\n            dp[0] = dp0\n            dp[1] = dp1\n            dp[2] = dp2\n            \n\n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        r0, r1, r2 = 0, 0, 0\n        for val in nums:\n            r = val % 3\n            if r == 0:\n                new_r0 = r0 + val\n                new_r1 = r1 + val if r1 else 0\n                new_r2 = r2 + val if r2 else 0\n            elif r == 1:\n                new_r0 = max(r2 + val, r0) if r2 else r0\n                new_r1 = max(r0 + val, r1)\n                new_r2 = max(r1 + val, r2) if r1 else r2\n            elif r == 2:\n                new_r0 = max(r1 + val, r0) if r1 else r0\n                new_r1 = max(r2 + val, r1) if r2 else r1\n                new_r2 = max(r0 + val, r2) \n                \n            r0, r1, r2 = new_r0, new_r1, new_r2\n        \n        return r0\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        S = sum(nums)\n        if S%3==0: return S\n        \n        ns1 = sorted([n for n in nums if n%3==1])\n        ns2 = sorted([n for n in nums if n%3==2])\n        \n        remove = S\n        \n        if ([[],ns1,ns2][S%3]):\n            remove = min(remove, [[],ns1,ns2][S%3][0])\n        if len([[],ns1,ns2][3-S%3])>1:\n            remove = min(remove, sum([[],ns1,ns2][3-S%3][:2]))\n        \n        return S - remove", "import heapq\nfrom collections import defaultdict, Counter\nclass Solution:\n    '''Return the smallest / 2nd smallest element'''\n    def get_min_1_2(self, nums):\n        return heapq.nsmallest(2, nums)\n    \n    def maxSumDivThree(self, nums: List[int]) -> int:\n        sum_ = sum(nums)\n        mod_dic = defaultdict(list)    # Hash table: 1->[1, 7, 10...]\n        for num in nums:\n            mod_dic[num%3].append(num)\n        print(mod_dic)\n            \n        if sum_%3 == 0:\n            return sum_\n        \n        if sum_%3 == 1:\n            sum1 = -float('inf')\n            sum2 = -float('inf')\n            if 1 in mod_dic:\n                sum1 = sum_ - min(mod_dic[1])\n            if 2 in mod_dic and len(mod_dic[2]) >= 2:\n                min_mod2, second_min_mod2 = self.get_min_1_2(mod_dic[2])\n                # min_mod2 = min(mod_dic[2])\n                # mod_dic[2].remove(min_mod2)\n                # second_min_mod2 = min(mod_dic[2])\n                sum2 = sum_ - min_mod2 - second_min_mod2\n            return max(sum1, sum2)\n        \n        if sum_%3 == 2:\n            sum1 = -float('inf')\n            sum2 = -float('inf')\n            if 2 in mod_dic:\n                sum2 = sum_ - min(mod_dic[2])\n            if 1 in mod_dic and len(mod_dic[1]) >= 2:\n                min_mod1, second_min_mod1 = self.get_min_1_2(mod_dic[1])\n                # min_mod1 = min(mod_dic[1])\n                # mod_dic[1].remove(min_mod1)\n                # second_min_mod1 = min(mod_dic[1])\n                sum1 = sum_ - min_mod1 - second_min_mod1\n            return max(sum1, sum2)\n", "class Solution:\n    def maxSumDivThree(self, A: List[int]) -> int:\n        dp = [0, 0, 0]\n        for a in A:\n            for i in dp[:]:\n                mod = (i + a) % 3\n                dp[mod] = max(dp[mod], i + a)\n        return dp[0]\n        \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0,float('-inf'),float('-inf')] # largest number with remainder 0,1,2\n        for i in range(1,n+1):\n            x = nums[i-1]\n            dp1 = [0]*3\n            if x%3==0:\n                for j in range(3):\n                    dp1[j] = dp[j]+x\n            elif x%3==1:\n                dp1[0] = max(dp[0],dp[2]+x)\n                dp1[1] = max(dp[1],dp[0]+x)\n                dp1[2] = max(dp[2],dp[1]+x)\n            elif x%3==2:\n                dp1[0] = max(dp[0],dp[1]+x)\n                dp1[1] = max(dp[1],dp[2]+x)\n                dp1[2] = max(dp[2],dp[0]+x)\n            dp=dp1\n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        '''\n        - Dynamic programming solution\n        - We don't need to keep track of all sums, only of the \n          max sum for each possible remainder (0, 1, 2)\n        \n        \n        '''\n        \n        max_sums = [0]*3\n        \n        for num in nums:\n            for max_sum in max_sums[:]:\n                max_sums[(num+max_sum)%3] = max(max_sum+num, max_sums[(num+max_sum)%3])\n        \n        return max_sums[0]", "\n# 1262. Greatest Sum Divisible by Three\n\n# Explanation: seen[i] means the current maximum possible sum that sum % 3 = i\n# Complexity: Time O(N), Space O(1)\n\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0, 0, 0]\n        for a in nums:\n            for i in seen[:]:\n                seen[(i + a) % 3] = max(seen[(i + a) % 3], i + a)\n                # print(a, i, seen)\n        return seen[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen=[0,0,0]\n        for num in nums:\n            for c in seen[:]:\n                seen[(c+num)%3] = max(seen[(c+num)%3],c+num)\n        return seen[0]\n        \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0, 0, 0]\n        for num in nums:\n            for x in dp[:]:\n                dp[(x + num) % 3] = max(dp[(x + num) % 3], x + num)\n        return dp[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0,0,0]\n        for num in nums:\n            for idx in dp[:]:\n                dp[(idx+num)%3] = max(dp[(idx+num)%3], idx+num)\n        return dp[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        # n = len(nums)\n        # # dp = [[0]*3 for _ in range(n)]\n        # dp = [0,0,0]\n        \n#         for i, x in enumerate(nums):\n#             m = x % 3\n#             if i > 0:\n#                 # dp[i] = dp[i-1][::]\n#                 # for j in range(3):\n#                 #     if dp[i][(j-m)%3] > 0:\n#                 #         dp[i][j] = max(dp[i][j], dp[i][(x-m)%3] + x)\n#                 rot = [dp[(x-m)%3] for x in range(3)]\n\n#                 for j in range(3):\n#                     if rot[j] > 0:\n#                         dp[j] = max(dp[j], rot[j] + x) # can add to it\n                        \n#             dp[m] = max(dp[m], x) # better to start anew with current element\n#             # print(i, dp)\n                \n#         # print(dp)\n#         return dp[0]\n\n        seen = [0,0,0]\n        for a in nums:\n            for i in seen[:]:\n                seen[(i+a)%3] = max(seen[(i+a)%3], i+a)\n                \n            # print(a, seen)\n            \n        return seen[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        total = sum(nums)\n        mod = total % 3\n        if mod == 0:\n            return total\n        min_2 = defaultdict(list)\n        for num in nums:\n            if num % 3 == 1:\n                min_2[1].append(num)\n                min_2[1].sort()\n                if len(min_2[1]) > 2:\n                     min_2[1].pop()\n            elif num % 3 == 2:\n                min_2[2].append(num)\n                min_2[2].sort()\n                if len(min_2[2]) > 2:\n                     min_2[2].pop()\n        res = 0\n        if mod == 1:\n            if len(min_2[1]) >= 1:\n                res = total - min_2[1][0]\n            if len(min_2[2]) >= 2:\n                res = max(res, total - min_2[2][0] - min_2[2][1])\n            return res\n        if len(min_2[2]) >= 1:\n            res = total - min_2[2][0]\n        if len(min_2[1]) >= 2:\n            res = max(res, total - min_2[1][0] - min_2[1][1])\n        return res", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0,0,0]\n        \n        for n in nums:\n            for i in dp[:]:\n                dp[(i+n) % 3] = max(dp[(i+n) % 3], i+n)\n                \n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp=[0,0,0]\n        for num in nums:\n            newlist=dp.copy()\n            for i in range(len(dp)):\n                curr=newlist[i]+num\n                dp[curr%3]=max(dp[curr%3],curr)\n        return dp[0]", "class Solution:\n    # https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0, 0, 0]\n        for n in nums:\n            # we need create a copy of seen, since we change element of seen in for loop.\n            for j in [i + n for i in seen]:\n                seen[j % 3] = max(seen[j % 3], j)\n        return seen[0]", "class Solution:\n    # https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/431077/JavaC%2B%2BPython-One-Pass-O(1)-space\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0, 0, 0]\n        for n in nums:\n            # we need create a copy of seen, since we change element of seen in for loop.\n            for j in [i + n for i in seen]:\n                seen[j % 3] = max(seen[j % 3], j)\n            # print('n = {0}, seen = {1}'.format(n, seen))\n        return seen[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0] * 3\n        \n        for num in nums:\n            r = num % 3\n            \n            pre = dp[:]\n            for i in range(3):\n                if pre[i]:\n                    dp[(i + r) % 3] = max(pre[(i + r) % 3], pre[i] + num)\n                    \n            if dp[r] == 0:\n                dp[r] = num\n                \n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        cur = [0] + [-1] * 2\n        tmp = cur[:]\n        for x in nums:\n            for i in range(3):\n                idx = (i+x)%3\n                if cur[i] >= 0:\n                    tmp[idx] = max(cur[i] + x, cur[idx])\n                    \n            cur = tmp[:]\n        return cur[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0,0,0]\n        for i in range(len(nums)):\n            for j in dp[:]:\n                dp[(j + nums[i])%3] = max(j+nums[i], dp[(j + nums[i])%3])\n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [ [0]*(3) for _ in range(n+1)  ]\n        dp[0] = [0,float('-inf'),float('-inf')] # largest number with remainder 0,1,2\n        for i in range(1,n+1):\n            x = nums[i-1]\n            if x%3==0:\n                for j in range(3):\n                    dp[i][j] = dp[i-1][j]+x\n            elif x%3==1:\n                dp[i][0] = max(dp[i-1][0],dp[i-1][2]+x)\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0]+x)\n                dp[i][2] = max(dp[i-1][2],dp[i-1][1]+x)\n            elif x%3==2:\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1]+x)\n                dp[i][1] = max(dp[i-1][1],dp[i-1][2]+x)\n                dp[i][2] = max(dp[i-1][2],dp[i-1][0]+x)\n        return dp[n][0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        sumVal = sum(nums)\n        if sumVal % 3 == 0:\n            return sumVal\n        categories = [[],[],[]]\n        for num in nums:\n            categories[num % 3].append(num)\n        categories[1].sort()\n        categories[2].sort()\n        if sumVal % 3 == 1:\n            if (len(categories[2]) < 2):\n                return sumVal - categories[1][0]\n            elif not categories[1]:\n                return sumVal - categories[2][0] - categories[2][1]\n            else:\n                remainder = min(categories[1][0], categories[2][0] + categories[2][1])\n                return sumVal - remainder\n        else:\n            if (len(categories[1]) < 2):\n                return sumVal - categories[2][0]\n            elif not categories[2]:\n                return sumVal - categories[1][0] - categories[1][1]\n            else:\n                remainder = min(categories[2][0], categories[1][0] + categories[1][1])\n                return sumVal - remainder\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0] * 3\n        \n        for num in nums:\n            r = num % 3\n            \n            pre = dp[:]\n            for i in range(3):\n                if pre[i]:\n                    dp[(i + r) % 3] = max(pre[(i + r) % 3], pre[i] + num)\n                    \n            if not dp[r]:\n                dp[r] = num\n                \n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0,0,0]\n        for num in nums:\n            for prev in dp[:]:\n                dp[(prev+num)%3] = max(prev+num, dp[(prev+num)%3])\n        return dp[0]\n    \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        \n        n = len(nums)+1\n        \n        dp = [[0]*3 for i in range(n)]\n        \n        dp[0][0], dp[0][1], dp[0][2] = 0, -float('inf'), -float('inf')\n        \n        for i in range(1,n):\n            \n            rem = nums[i-1]%3\n            \n            if rem == 0:\n                \n                dp[i][0] = dp[i-1][0] + nums[i-1]\n                dp[i][1] = dp[i-1][1] + nums[i-1]\n                dp[i][2] = dp[i-1][2] + nums[i-1]\n                \n            elif rem == 1:\n                \n                dp[i][0] = max(dp[i-1][0],dp[i-1][2]+nums[i-1])\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0]+nums[i-1])\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1]+nums[i-1])\n                \n            else:\n                \n                dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i-1])\n                dp[i][1] = max(dp[i-1][1],dp[i-1][2]+nums[i-1])\n                dp[i][2] = max(dp[i-1][2],dp[i-1][0]+nums[i-1])\n                \n        return dp[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0, -1, -1]\n        \n        for v in nums:\n            new_dp = list(dp)\n            if dp[v%3] < 0:\n                new_dp[v%3] = v\n            for i in range(0,3):\n                new_i = (i+v) % 3\n                if dp[i] >= 0:\n                    new_dp[new_i] = max(dp[new_i], dp[i] + v)\n                    \n            dp = new_dp\n#            print(dp)\n\n        return dp[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        maxes = [0, 0, 0, 0]\n        for num in nums:\n            new_maxes = [x for x in maxes]\n            for module in maxes:\n                idx = (num + module) %3\n                new_maxes[idx] = max(new_maxes[idx], num+module)\n            maxes = new_maxes\n        return maxes[0]\n                \n", "class Solution:\n    def maxSumDivThree(self, A):\n        print(A)\n        seen = [0, 0, 0]\n        for a in A:\n            temp = seen.copy()\n            for i in seen:            \n                temp[(i + a) % 3] = max(temp[(i + a) % 3], i + a)\n            seen = temp\n\n        return seen[0]", "class Solution:\n    def maxSumDivThree(self, A):\n        seen = [0,0,0]\n        for a in A:\n            for i in seen:\n                temp = seen.copy()\n                temp[(i+a)%3] = max(temp[(i+a)%3], i+a)\n                seen = temp\n        return seen[0]", "import heapq\nfrom collections import defaultdict, Counter\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        sum_ = sum(nums)\n        mod_dic = defaultdict(list)    # Hash table: 1->[1, 7, 10...]\n        for num in nums:\n            mod_dic[num%3].append(num)\n        print(mod_dic)\n            \n        if sum_%3 == 0:\n            return sum_\n        \n        if sum_%3 == 1:\n            sum1 = -float('inf')\n            sum2 = -float('inf')\n            if 1 in mod_dic:\n                sum1 = sum_ - min(mod_dic[1])\n            if 2 in mod_dic and len(mod_dic[2]) >= 2:\n                min_mod2, second_min_mod2 = heapq.nsmallest(2, mod_dic[2])\n                sum2 = sum_ - min_mod2 - second_min_mod2\n            return max(sum1, sum2)\n        \n        if sum_%3 == 2:\n            sum1 = -float('inf')\n            sum2 = -float('inf')\n            if 2 in mod_dic:\n                sum2 = sum_ - min(mod_dic[2])\n            if 1 in mod_dic and len(mod_dic[1]) >= 2:\n                min_mod1, second_min_mod1 = heapq.nsmallest(2, mod_dic[1])\n                sum1 = sum_ - min_mod1 - second_min_mod1\n            return max(sum1, sum2)\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        total = sum(nums)\n        n = len(nums)\n        if total%3 == 0:\n            return total\n        nums_set = set(nums)\n        nums.sort()\n        prefix_sum = [0] * (n+1)\n        for i in range(n):\n            prefix_sum[i] = prefix_sum[i-1] + nums[i] \n        div, mod = divmod(total, 3)    \n        while mod <= total:\n            if mod in nums_set:\n                return div*3\n            for i in range(n-2):\n                sum_val = 0\n                if nums[i] > mod:\n                    break\n                for j in range(i+1, n-1):\n                    if nums[i] + nums[j] == mod:\n                        return div*3    \n                    for k in range(j+1, n):\n                        sum_val += prefix_sum[k] - prefix_sum[i-1]\n                        if sum_val == mod:\n                            return div*3\n                        if sum_val > mod:\n                            break    \n            div -= 1\n            mod += 3\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        s = sum(nums)\n        if s % 3 == 0:\n            return s\n        pos_1_1, pos_2_1 = True, True\n        min_1_1, min_1_2, min_2_1, min_2_2 = float('inf'), float('inf'), float('inf'), float('inf')\n        for i in range(n):\n            if nums[i] % 3 == 1:\n                if nums[i] < min_1_1:\n                    min_1_1 = nums[i]\n                    pos_1_1 = i\n            elif nums[i] % 3 == 2:\n                if nums[i] < min_2_1:\n                    min_2_1 = nums[i]\n                    pos_2_1 = i\n        for i in range(n):\n            if i == pos_1_1 or i == pos_2_1:\n                continue\n            if nums[i] % 3 == 1:\n                min_1_2 = min(min_1_2, nums[i])\n            if nums[i] % 3 == 2:\n                min_2_2 = min(min_2_2, nums[i])\n                \n        if s % 3 == 1:\n            return s - min(min_1_1, min_2_1 + min_2_2)\n        return s - min(min_2_1, min_1_1 + min_1_2)\n                \n        \n                \n                \n                \n        \n                \n                \n            \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        dp = [[0 for _ in range(3)] for _ in range(len(nums)+1)]\n        dp[0][1] = float('-inf')\n        dp[0][2] = float('-inf')\n        \n        for i in range(1, len(nums)+1):\n            num = nums[i-1]\n            rem = num % 3\n            if rem == 0:\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0]+num)\n                dp[i][1] = max(dp[i-1][1], dp[i-1][1]+num)\n                dp[i][2] = max(dp[i-1][2], dp[i-1][2]+num)\n            elif rem == 1:\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2]+num)\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0]+num)\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1]+num)\n            else:\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1]+num)\n                dp[i][1] = max(dp[i-1][1], dp[i-1][2]+num)\n                dp[i][2] = max(dp[i-1][2], dp[i-1][0]+num)\n        \n        return dp[-1][0]", "from collections import defaultdict\n\nclass Solution:\n  def maxSumDivThree(self, nums: List[int]) -> int:\n    dp = defaultdict(lambda: [0, float('-inf'), float('-inf')])\n    \n    for i, x in enumerate(nums):\n      # print(i, x, dp[i-1][0], dp[i-1][2] + x)\n      if x % 3 == 0:\n        dp[i][0] = dp[i-1][0] + x\n        dp[i][1] = dp[i-1][1] + x\n        dp[i][2] = dp[i-1][2] + x\n        \n      elif x % 3 == 1:\n        dp[i][1] = max(dp[i-1][1], dp[i-1][0] + x)\n        dp[i][2] = max(dp[i-1][2], dp[i-1][1] + x)\n        dp[i][0] = max(dp[i-1][0], dp[i-1][2] + x)\n        \n      elif x % 3 == 2:\n        dp[i][2] = max(dp[i-1][2], dp[i-1][0] + x)\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + x)\n        dp[i][1] = max(dp[i-1][1], dp[i-1][2] + x)\n      # print(dp[i])\n\n    return dp[len(nums) - 1][0]\n  \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n#         total_sum = sum(nums)\n#         sorted_nums = sorted(nums)\n#         print(sorted_nums)\n\n#         if total_sum%3 == 0:\n#             return total_sum\n#         curr_max = 0\n#         for i in range(length(sorted_nums)):\n#             if (total_sum - sorted_nums[i]) %3 == 0:\n#                 curr_max = (total_sum - sorted_nums[i])\n            \n#             if (total_sum - sorted_nums[i]) %3 == 0:\n#                 curr_max = (total_sum - sorted_nums[i])\n            \n        dp = [0, float('-inf'), float('-inf')]\n        for n in nums:\n            dp = [max(dp[i], dp[(3 - n%3 + i)%3]+n) for i in range(3)]\n        return dp[0]\n        \n            \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0]*3 for _ in range(n+1)]\n        dp[0][1] = float('-inf')\n        dp[0][2] = float('-inf')\n        \n        print (dp)\n        for i in range(1, n+1):\n            if nums[i-1] % 3 == 0: # Current remainder == 0\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][0] to keep the remainder 0\n                dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][1] to keep the remainder 1\n                dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][2] to keep the remainder 2\n            elif nums[i-1] % 3 == 1: # Current remainder == 1\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][2] to keep the remainder 0\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][0] to keep the remainder 1\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][1] to keep the remainder 2\n            else: # Current remainder == 2\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]) # Can you tell how this works now?\n                dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\n                dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\n\n        return dp[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        if n == 0:\n            return 0\n        \n        nums.sort()\n        \n        m3 = []\n        m2 = []\n        m1 = []\n        \n        for i in nums:\n            if i % 3 == 0:\n                m3.append(i)\n            elif i % 3 == 2:\n                m2.append(i)\n            elif i % 3 == 1:\n                m1.append(i)\n        \n        # print(m1)\n        # print(m2)\n        # print(m3)\n        \n        \n        total = sum(nums)\n        if total % 3 == 0:\n            return total\n        elif total % 3 == 2:\n            comp1 = 0\n            comp2 = 0\n            \n            if len(m2) > 0:\n                comp1 = total - m2[0]\n            \n            if len(m1) > 1:\n                comp2 = total - m1[0] - m1[1]\n                \n            return max(comp1, comp2)\n    \n        elif total % 3 == 1: \n            comp1 = 0\n            comp2 = 0\n            \n            if len(m1) > 0:\n                comp1 = total - m1[0]\n            \n            if len(m2) > 1:\n                comp2 = total - m2[0] - m2[1]\n                \n            return max(comp1, comp2)", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n=len(nums)\n        dp=[[0 for _ in range(3)] for _ in range(n)]\n        ans=0\n        \n        if nums[0]%3==0:\n            dp[0][0]=nums[0]\n        elif nums[0]%3==1:\n            dp[0][1]=nums[0]\n        else:\n            dp[0][2]=nums[0]\n            \n        for i in range(1, n):\n            if nums[i]%3==0:\n                dp[i][0]=dp[i-1][0]+nums[i]\n                if dp[i-1][1]!=0:\n                    dp[i][1]=dp[i-1][1]+nums[i]\n                else:\n                    dp[i][1]=dp[i-1][1]\n                if dp[i-1][2]!=0:\n                    dp[i][2]=dp[i-1][2]+nums[i]\n                else:\n                    dp[i][2]=dp[i-1][2]          \n            elif nums[i]%3==1:\n                dp[i][1]=max(dp[i-1][0]+nums[i], dp[i-1][1])\n                if dp[i-1][2]!=0:\n                    dp[i][0]=max(dp[i-1][0], dp[i-1][2]+nums[i])\n                else:\n                    dp[i][0]=dp[i-1][0]\n                if dp[i-1][1]!=0:\n                    dp[i][2]=max(dp[i-1][2], dp[i-1][1]+nums[i])\n                else:\n                    dp[i][2]=dp[i-1][2]\n            else:\n                dp[i][2]=max(dp[i-1][0]+nums[i], dp[i-1][2])\n                if dp[i-1][1]!=0:\n                    dp[i][0]=max(dp[i-1][0], dp[i-1][1]+nums[i])\n                else:\n                    dp[i][0]=dp[i-1][0]\n                if  dp[i-1][2]!=0:\n                    dp[i][1]=max(dp[i-1][1], dp[i-1][2]+nums[i])\n                else:\n                    dp[i][1]=dp[i-1][1]    \n        # print(dp)\n        return dp[n-1][0]\n            \n            \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        l = [0] * 3\n        for i in nums:\n            t = [0] * 3\n            for j in l:\n                t[(j+i)%3] = max(t[(j+i)%3], j+i)\n            \n            for g in range(3):\n                l[g] = max(t[g], l[g])\n                \n        return l[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [[0] * 3 for _ in range(len(nums)+1)]\n        dp[0][1] = float('-inf')\n        dp[0][2] = float('-inf')\n        \n        for i in range(1, len(nums)+1):\n            if nums[i-1] % 3 == 0:\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1])\n                dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1])\n                dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1])\n            elif nums[i-1] % 3 == 1:\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1])\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1])\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1])\n            else:\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1])\n                dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\n                dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\n        return dp[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0]*3 for _ in range(n+1)]\n        dp[0][1] = float('-inf')\n        dp[0][2] = float('-inf')\n        for i in range(1, n+1):\n            if nums[i-1] % 3 == 0: # Current remainder == 0\n                dp[i][0] = max(dp[i-1][0], dp[i-1][0] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][0] to keep the remainder 0\n                dp[i][1] = max(dp[i-1][1], dp[i-1][1] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][1] to keep the remainder 1\n                dp[i][2] = max(dp[i-1][2], dp[i-1][2] + nums[i-1]) # Current remainder is 0, so we add to dp[i-1][2] to keep the remainder 2\n            elif nums[i-1] % 3 == 1: # Current remainder == 1\n                dp[i][0] = max(dp[i-1][0], dp[i-1][2] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][2] to keep the remainder 0\n                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][0] to keep the remainder 1\n                dp[i][2] = max(dp[i-1][2], dp[i-1][1] + nums[i-1]) # Current remainder is 1, so we add to dp[i-1][1] to keep the remainder 2\n            else: # Current remainder == 2\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + nums[i-1]) # Can you tell how this works now?\n                dp[i][1] = max(dp[i-1][1], dp[i-1][2] + nums[i-1])\n                dp[i][2] = max(dp[i-1][2], dp[i-1][0] + nums[i-1])\n\n        return dp[n][0]        ", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        ans = 0\n        next_nums = []\n        nums1, nums2 = [], []\n        nums.sort(reverse=True)\n        for n in nums:\n            val = n % 3\n            if val == 0:\n                ans += n\n            elif val == 1:\n                nums1.append(n)\n            else:\n                nums2.append(n)\n\n        if len(nums1) < len(nums2):\n            small = nums1\n            big = nums2\n        else:\n            small = nums2\n            big = nums1\n\n        mod = (len(big) - len(small)) % 3\n        val1, val2 = 0, 0\n        if mod == 0:\n            val1 = sum(big) + sum(small)\n        else:\n            val1 = sum(small) + sum(big[:-mod])\n            if len(big) >= 3 and 3 - mod <= len(small):\n                val2 = sum(small[:-(3 - mod)]) + sum(big)\n\n        return ans + max(val1, val2)\n\n    def traversal(self, nums1, nums2, idx1, idx2, curr_val, visited):\n        if idx1 == len(nums1) and idx2 == len(nums2):\n            return curr_val, True\n\n        if (idx1, idx2, curr_val) in visited:\n            return visited[(idx1, idx2, curr_val)], False\n\n        if idx1 + 1 <= len(nums1) and idx2 + 1 <= len(nums2):\n            val, ret = self.traversal(\n                nums1,\n                nums2,\n                idx1 + 1,\n                idx2 + 1,\n                curr_val + nums1[idx1] + nums2[idx2],\n                visited\n            )\n            if ret:\n                return val, True\n            max_val = max(max_val, val)\n\n        max_val = curr_val\n        if idx2 + 3 <= len(nums2):\n            s = nums2[idx2] + nums2[idx2 + 1] + nums2[idx2 + 2]\n            val, ret = self.traversal(\n                nums1,\n                nums2,\n                idx1,\n                idx2 + 3,\n                curr_val + s,\n                visited\n            )\n            if ret:\n                return val, True\n            max_val = max(max_val, val)\n\n        if idx1 + 3 <= len(nums1):\n            s = nums1[idx1] + nums1[idx1 + 1] + nums1[idx1 + 2]\n            val, ret = self.traversal(\n                nums1,\n                nums2,\n                idx1 + 3,\n                idx2,\n                curr_val + s,\n                visited\n            )\n            if ret:\n                return val, True\n            max_val = max(max_val, val)\n\n        visited[(idx1, idx2, curr_val)] = max_val\n        return max_val, True\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0] * 3\n        for num in nums:\n            tmp = list(dp)\n            for s in tmp:\n                dp[(s + num) % 3] = max([dp[(s + num) % 3], s + num])\n        return dp[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        seen = [0, 0, 0]\n        for n in nums:\n            for s in seen[:]:\n                seen[(s + n) % 3] = max(seen[(s + n) % 3], s + n)\n        return seen[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        # dp = [[0]*3 for _ in range(n)]\n        dp = [0,0,0]\n        \n        for i, x in enumerate(nums):\n            m = x % 3\n            if i > 0:\n                # dp[i] = dp[i-1][::]\n                # for j in range(3):\n                #     if dp[i][(j-m)%3] > 0:\n                #         dp[i][j] = max(dp[i][j], dp[i][(x-m)%3] + x)\n                rot = [dp[(x-m)%3] for x in range(3)]\n\n                for j in range(3):\n                    if rot[j] > 0:\n                        dp[j] = max(dp[j], rot[j] + x) # can add to it\n                        \n            dp[m] = max(dp[m], x) # better to start anew with current element\n            # print(i, dp)\n                \n        # print(dp)\n        return dp[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        # dp = [[0 for j in range(3)] for i in range(n)]\n        # dp[0][nums[0]%3] = nums[0]\n        # for i in range(1, n):\n        #     for j in range(3):\n        #         dp[i][j] = dp[i-1][j]\n        #         if (j-nums[i]) % 3 == 0:\n        #             dp[i][j] = max(dp[i-1][(j-nums[i]) % 3] + nums[i], dp[i-1][j])\n        #         else:\n        #             if dp[i-1][(j-nums[i]) % 3] > 0:\n        #                 dp[i][j] = max(dp[i-1][(j-nums[i]) % 3] + nums[i], dp[i-1][j])\n        # # print([i[0] for i in dp])\n        # # print([i[1] for i in dp])\n        # # print([i[2] for i in dp])\n        # return dp[n-1][0]\n        \n        dp = [[0 for j in range(3)] for i in range(n+1)]\n        dp[0][0], dp[0][1], dp[0][2] = 0, -float('inf'), -float('inf')\n        for i in range(1, n+1):\n            for j in range(3):\n                dp[i][j] = max(dp[i-1][(j-nums[i-1]) % 3] + nums[i-1], dp[i-1][j])\n        # print([i[0] for i in dp])\n        # print([i[1] for i in dp])\n        # print([i[2] for i in dp])\n        return dp[n][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        seen = [0]*3\n        for a in nums:\n            for i in seen[:]:\n                seen[(i + a) % 3] = max(seen[(i + a) % 3], i + a)\n        return seen[0]\n        \n        \n        \n        \n        '''\n        3,6,5,1,8\n\n        0 , 0 , 0 \n        \n        \n        '''", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        dp = [[0,0,0] for i in range(n)]\n        \n        dp[0][nums[0]%3] = nums[0]\n        for i in range(1,n):\n            dp[i][0] = dp[i-1][0]\n            dp[i][1] = dp[i-1][1]\n            dp[i][2] = dp[i-1][2]\n            \n            if nums[i]%3 == 0:\n                dp[i][0] = max(dp[i][0], dp[i-1][0] + nums[i])\n                if dp[i-1][1]:\n                    dp[i][1] = max(dp[i][1], dp[i-1][1] + nums[i])\n                if dp[i-1][2]:\n                    dp[i][2] = max(dp[i][2], dp[i-1][2] + nums[i])\n                    \n            elif nums[i]%3 == 1:\n                if dp[i-1][2]:\n                    dp[i][0] = max(dp[i][0], dp[i-1][2] + nums[i])\n                \n                dp[i][1] = max(dp[i][1], dp[i-1][0] + nums[i])\n                if dp[i-1][1]:\n                    dp[i][2] = max(dp[i][2], dp[i-1][1] + nums[i])\n            else:\n                if dp[i-1][1]:\n                    dp[i][0] = max(dp[i][0], dp[i-1][1] + nums[i])\n                if dp[i-1][2]:\n                    dp[i][1] = max(dp[i][1], dp[i-1][2] + nums[i])\n                dp[i][2] = max(dp[i][2], dp[i-1][0] + nums[i])\n            # print(i, dp[i])\n        \n        return dp[n-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        f = [[0] * 3 for i in range(len(nums))]\n        f[0][nums[0] % 3] = nums[0]\n        for i in range(1, len(nums)):\n            for j in range(3):\n                include = f[i-1][(j - nums[i]) % 3] + nums[i]\n                if include % 3 == j:\n                    f[i][j] = max(f[i-1][j], include)\n                else:\n                    f[i][j] = f[i-1][j]\n        return f[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums):\n        N = len(nums)\n        dp = [[0]*3 for _ in range(2)]\n        dp[0][nums[0]%3] = nums[0]\n        for n in range(1, N):\n            row = n%2\n            alt = 1-row\n            r = nums[n]%3\n            for i in range(3):\n                if dp[alt][i] > 0:\n                    dp[row][(i+r)%3] = dp[alt][i] + nums[n]\n            for i in range(3):\n                dp[row][i] = max(dp[row][i], dp[alt][i])\n            dp[row][r] = max(dp[row][r], nums[n])\n        # for l in dp:\n        #     print(l)\n        return dp[1-N%2][0]", "\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        s = sum(nums)\n        if s % 3 == 0:\n            return s\n        one = [x for x in nums if x%3 == 1]\n        two = [x for x in nums if x%3 == 2]\n        three = [x for x in nums if x%3 == 0]\n        if s % 3 == 1:\n            if one and len(two)>1:\n                return s - min(one[0], sum(two[0:2]))\n            if one:\n                return s - one[0]\n            return s - sum(two[0:2])\n        if s % 3 == 2:\n            if len(one)>1 and two:\n                return s - min(sum(one[0:2]), two[0])\n            if len(one)>1:\n                return s - sum(one[0:2])\n            return s - two[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [[0]*3 for _ in range(len(nums)+1)]        \n        \n        for i, n in enumerate(nums):\n            r = n%3\n            for j in range(3):\n                if dp[i][j] > 0:\n                    dp[i+1][(j+r)%3] = max(dp[i][j] + n, dp[i][(j+r)%3] )\n                else:\n                    dp[i+1][(j+r)%3] = dp[i][(j+r)%3]\n            \n            dp[i+1][r] = max(n,dp[i+1][r])\n                    \n        #print(dp)\n                \n        return dp[-1][0]\n            \n        \n        \n        \n", "\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        nr = len(nums)\n        dp = [[0] * 3 for _ in range(nr)]\n        dp[0][nums[0] % 3] = nums[0]\n        \n        for i in range(1, nr):\n            for j in range(3):\n                dp[i][j] = dp[i-1][j]\n                \n            for j in range(3):\n                new_num = dp[i-1][j] + nums[i]\n                new_rem = new_num % 3\n                \n                if dp[i][new_rem] < new_num:\n                    dp[i][new_rem] = new_num\n        \n\n        return dp[nr-1][0]\n                    \n                    \n                \n            \n        \n      \n        \n        \n        \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        #\n        # DP ----- 544 ms (25.55%) / 19 MB (27.94%)\n        # Only consider three cases: residue is in [0, 1, 2]\n        # Maintain the greatest sum with residue [0, 1, 2] divived by 3, respectively.\n        # For each number, consider the result when adding it and check whether the sum increases or not.\n        # ------------------------------------------------------------------------------------------------------------\n        dic = {0: 0}\n        \n        for n in nums:\n            dic_new = {}\n            #  If add `n`, the temporary result is denoted by `dic_new`\n            for i, s in dic.items():\n                r = (i + n) % 3\n                dic_new[r] = max(n + s, dic.get(r, 0))\n            # Update `dict` by `dic_new`\n            for i, s in dic_new.items():\n                dic[i] = max(s, dic.get(i, 0))\n                        \n        return dic.get(0, 0)", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        mod = [0, -1, -1]\n        mod[nums[0] % 3] = nums[0]\n        \n        for i in range(1, len(nums)):\n            mod2 = list(mod)\n            for j in range(3):\n                if mod[j] != -1:\n                    newSum = mod[j] + nums[i]\n                    mod2[newSum % 3] = max(mod[newSum % 3], newSum)\n            mod = mod2\n        \n        return mod[0] if mod[0] != -1 else 0\n                    \n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dic = [0, 0, 0]\n        for i in nums:\n            if i % 3 == 0:\n                dic[0]+=i\n                if dic[2] != 0:\n                    dic[2]+=i\n                if dic[1] != 0 :\n                    dic[1]+=i\n            elif i % 3 == 1:\n                a,b,c = dic[0],dic[1],dic[2]\n                dic[1] = max(a+i, dic[1])\n                if b != 0:\n                    dic[2] = max(b+i, dic[2])\n                if c!=0:\n                    dic[0] = max(c+i, dic[0] )\n            elif i % 3 == 2:\n                a,b,c = dic[0],dic[1],dic[2]\n                dic[2] = max(a+i, dic[2])\n                if c != 0:\n                    dic[1] = max(c+i, dic[1])\n                if b != 0:\n                    dic[0] = max(b+i, dic[0] )\n        return dic[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [[-math.inf]*3 for _ in nums]\n        dp[0][nums[0]%3] = nums[0]\n        for i, n in enumerate(nums[1:], start=1):\n            dp[i][n%3] = n\n            for j in range(3):\n                dp[i][j] = max(dp[i][j], dp[i-1][j], n+dp[i-1][(j-n%3)%3])\n        ans = dp[-1][0]\n        return ans if ans > 0 else 0\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        f = [[0] * 3 for i in range(len(nums))]\n        f[0][nums[0] % 3] = nums[0]\n        for i in range(1, len(nums)):\n            for j in range(3):\n                include = f[i-1][(j + 3 - nums[i] %3) % 3] + nums[i]\n                if include % 3 == j:\n                    f[i][j] = max(f[i-1][j], include)\n                else:\n                    f[i][j] = f[i-1][j]\n        return f[-1][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        # dp 0/1 problem\n        dp = [ [0] * len(nums) for _ in range(3)]\n        \n        for i, n in enumerate(nums):\n            if i == 0:\n                dp[n%3][0] = n\n            \n            else:\n                for rem in range(3):\n                    if dp[rem][i-1] % 3 == rem:\n                        # choose / don't choose\n                        dp[(n+rem)%3][i] = max(dp[rem][i-1] + n, dp[(n+rem)%3][i-1]) \n                    else:\n                        dp[(n+rem)%3][i] = dp[(n+rem)%3][i-1]\n                    \n\n        return dp[0][-1] if dp[0][-1] != float('-inf') else 0\n \n\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dp = [0 for i in range(3)]\n        for num in nums:\n            tmp = dp[:]\n            for remainder in range(3):\n                dp[(tmp[remainder]+num)%3] = max(dp[(tmp[remainder]+num)%3], tmp[remainder] + num)\n            # print('num, dp', num, dp)\n        return dp[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1 and nums[0] % 3:\n            return 0\n\n        sum_ = sum(nums)\n        mod_ = sum_ % 3\n        if not mod_:\n            return sum_\n\n        vals = {False: self.min_two([n for n in nums if n % 3 == 3 - mod_]),\n                True: [min([n for n in nums if n % 3 == mod_])]}\n\n        if vals[True] and (len(vals[False]) <= 1 or vals[True][0] < sum(vals[False])):\n            return sum_ - vals[True][0]\n\n        elif len(vals[False]) == 2:\n            return sum_ - sum(vals[False])\n        return 0\n\n\n\n    def min_two(self, l):\n        if not l:\n            return []\n        idx = [i for i in range(len(l))]\n        out = [min(idx, key = lambda i: l[i])]\n        idx.pop(out[0])\n        if idx:\n            out.append(min(idx, key = lambda i: l[i]))\n\n        return [l[i] for i in out]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dic = {0: 0}\n        \n        for num in nums:\n            dic_new = {}\n            \n            for prev_remain, prev_sum in list(dic.items()):\n                remain = (prev_remain + num) % 3\n                dic_new[remain] = max(num + prev_sum, dic.get(remain, 0))\n                \n            for remain, sum_val in list(dic_new.items()):\n                dic[remain] = max(sum_val, dic.get(remain, 0))\n\n        return dic[0]\n", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        states = [0, float('-inf'), float('-inf')]\n        \n        for n in nums:\n            old = states[:]\n            for i in range(3):\n                states[(i + n) % 3] = max(old[(i + n) % 3], old[i] + n)\n        \n        return states[0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(3)] for i in range(n + 1)]\n        dp[0] = [0, -1e18, -1e18]\n        \n        for i, v in enumerate(nums):\n            for k in range(3):\n                dp[i + 1][k] = max( dp[i][k], v + dp[i][(k - (v % 3) + 3) % 3])\n        \n        return dp[n][0]", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        dic = {0: 0}\n        \n        for n in nums:\n            dic_new = {}\n            \n            for i, s in dic.items():\n                r = (i + n) % 3\n                dic_new[r] = max(n + s, dic.get(r, 0))\n                \n            for i, s in dic_new.items():\n                dic[i] = max(s, dic.get(i, 0))\n                        \n        return dic.get(0, 0)", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        zero = one = two = 0\n        for n in nums:\n            nz, no, nt = zero + n, one + n, two + n\n            zero = max(zero, nz if nz%3 == 0 else 0, no if no%3 == 0 else 0, nt if nt%3 == 0 else 0)\n            one = max(one, nz if nz%3 == 1 else 0, no if no%3 == 1 else 0, nt if nt%3 == 1 else 0)\n            two = max(two, nz if nz%3 == 2 else 0, no if no%3 == 2 else 0, nt if nt%3 == 2 else 0)\n            # print(zero, one, two)\n        \n        return zero", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \n        @lru_cache(None)\n        def recurse(i,pos):\n            if pos<0:\n                if i==0:\n                    return 0\n                return -10000000\n                \n            temp = max(nums[pos]+recurse((i+nums[pos])%3,pos-1),recurse((i)%3,pos-1))\n        \n            #print(i,pos,temp)\n            return temp\n        \n        return recurse(0,len(nums)-1)", "def maxsum(a, k):\n    dp =[float('-inf') if a[0]%k!=x else a[0] for x in range(k)]\n    for i in range(1, len(a)):\n        new = [0 for x in range(k)]\n        for j in range(k):\n            rem=a[i]%k\n            index = (k-rem+j)%k\n            new[j] = max(dp[j], dp[index]+a[i], a[i] if a[i]%k==j else float('-inf'))\n        dp = new\n\n    return 0 if dp[0] ==float('-inf') else dp[0]\n\nclass Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        return maxsum(nums, 3)", "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        @lru_cache(None)\n        def dfs(index, remainder):\n            if index == len(nums):\n                if remainder == 0:\n                    return 0\n                else:\n                    return -float('inf')\n            \n            \n            new_remainder = (nums[index] + remainder) % 3\n            choose = dfs(index + 1, new_remainder) + nums[index]\n            no_choose = dfs(index + 1, remainder)\n            \n            return max(choose, no_choose)\n        \n        return dfs(0,0)"]
["class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for i in range(len(grid)):\n            grid[i].insert(0, 0)\n            grid[i].append(0)\n        grid.insert(0, [0 for i in range(len(grid[0]))])\n        grid.append([0 for i in range(len(grid[0]))])\n        islands = []\n        max_length = 1\n        for i in range(1, len(grid) - 1):\n            for j in range(1, len(grid[0]) - 1):\n                if grid[i][j] != 1:\n                    continue\n                island_id = len(islands)\n                length = 0\n                connect_length = 0\n                queue = [(i, j)]\n                grid[i][j] = 2 + island_id\n                while queue:\n                    x, y = queue.pop()\n                    for dx, dy in directions:\n                        this_grid = grid[x + dx][y + dy]\n                        if this_grid == 1:\n                            grid[x + dx][y + dy] = 2 + island_id\n                            queue.append((x + dx, y + dy))\n                        elif isinstance(this_grid, list):\n                            new_connect = 0\n                            already = False\n                            for old_island_id in this_grid:\n                                if old_island_id != island_id:\n                                    new_connect += islands[old_island_id]\n                                else:\n                                    already = True\n                            if not already:\n                                connect_length = max(connect_length, new_connect)\n                                this_grid.append(island_id)\n                        else:\n                            grid[x + dx][y + dy] = [island_id]\n                    length += 1\n                islands.append(length)\n                max_length = max(max_length, length + connect_length + 1)\n        return min(max_length, (len(grid) - 2) * (len(grid[0]) - 2))", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        n_rows = len(grid)\n        n_cols = len(grid[0])\n        \n        borders = dict()\n        seen = set()\n        max_size = 0\n        \n        def bfs(r, c):\n            nonlocal max_size\n            size = 1\n            border = set()\n            stack = [(r, c)]\n            while stack:\n                r, c = stack.pop()\n                for r, c in [(r+1, c), (r-1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= r < n_rows and 0 <= c < n_cols and (r,c) not in seen:\n                        \n                        if grid[r][c] == 1:\n                            size += 1\n                            stack.append((r, c))\n                            seen.add((r, c))\n                        else:\n                            border.add((r, c))\n            \n            max_size = max(max_size, size)\n            for r, c in border:\n                if (r, c) in borders:\n                    max_size = max(max_size, borders[(r, c)] + size)\n                    borders[(r, c)] = borders[(r, c)] + size\n                else:\n                    borders[(r, c)] = size\n            \n            \n        for r in range(n_rows):\n            for c in range(n_cols):\n                if grid[r][c] == 1 and (r, c) not in seen:\n                    seen.add((r, c))\n                    bfs(r, c)\n                    \n        return max_size + 1 if max_size != n_rows*n_cols else max_size", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        nei = [(0,1),(1,0),(0,-1),(-1,0)]\n        m, n = len(grid), len(grid[0])\n        rec = dict()\n        ans = 0\n        def count(grid, i, j):\n            cnt = 1\n            grid[i][j] = -1\n            for dx, dy in nei:\n                nx, ny = i + dx, j + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    cnt += count(grid, nx, ny)\n                    \n            return cnt\n        \n        def flip(grid, i, j, val):\n            grid[i][j] = val\n            \n            for dx, dy in nei:\n                nx, ny = i + dx, j + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == -1:\n                    flip(grid, nx, ny, val)\n                    \n            return\n        \n        color = 2\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    temp = count(grid, i, j)\n                    flip(grid, i, j, color)\n                    rec[color] = temp\n                    color += 1\n                    ans = max(ans, temp)\n        \n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    visit = set()\n                    for dx, dy in nei:\n                        nx, ny = i + dx, j + dy\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 0:\n                            visit.add(grid[nx][ny])\n                            \n                    ans = max(ans, 1 + sum(rec[i] for i in visit))\n           \n        return ans\n                    \n        \n        \n        \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        islandId = 2\n        areaDict = {}\n        maxArea = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    areaDict[islandId] = self.dfs(grid, i, j, m, n, islandId)\n                    maxArea = max(maxArea, areaDict[islandId])\n                    islandId += 1\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    neighborIslands = set()\n                    for ni, nj in self.getNeighbors(grid, i, j, m, n):\n                        if grid[ni][nj] > 0:\n                            neighborIslands.add(grid[ni][nj])\n                            \n                    maxArea = max(maxArea, 1 + sum([areaDict[islandId] for islandId in neighborIslands]))\n        \n        return maxArea\n\n    def dfs(self, grid, i, j, m, n, islandId):\n        area = 1\n        grid[i][j] = islandId\n        for ni, nj in self.getNeighbors(grid, i, j, m, n):\n            if grid[ni][nj] != 1:\n                continue\n            area += self.dfs(grid, ni, nj, m, n, islandId)\n        return area\n    \n    def bfs(self, grid, i, j, m, n, islandId):\n        grid[i][j] = islandId\n        area = 1\n        q = [(i, j)]\n        while q:\n            x, y = q.pop(0)\n            for nx, ny in self.getNeighbors(grid, x, y, m, n):\n                if grid[nx][ny] != 1:\n                    continue\n                area += 1\n                grid[nx][ny] = islandId\n                q.append((nx, ny))\n        \n        return area\n    \n    def getNeighbors(self, grid, x, y, m, n):\n        result = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n        return [\n            (a, b)\n            for a, b in result\n            if 0 <= a < m and 0 <= b < n and grid[a][b] > 0\n        ]", "\\\"\\\"\\\"\ndfs timeO(mn) spaceO(mn)\n1. get area of an island (similar to LC200, 695)\n2. set visited nodes to 2,3,4, ... for 1st, 2nd,3rd ... islands\n3. store the maxArea of islands\n4. for each 0, check its 4 neighbors.if a neighbor is not 0, get its area. try to fill this 0 and connect its neighbor islands\n\\\"\\\"\\\"\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]: return 0\n        self.grid = grid\n        mark = 1\n        mark2island = {}\n        mark2island[0]=0\n        maxArea = 0\n        \n        # get area of each island; mark them as 2,3,... timeO(mn)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if self.grid[i][j] == 1: # found a new island\n                    mark+=1\n                    area = self.getArea(i,j,mark)\n                    mark2island[mark] = area\n                    maxArea = max(maxArea,area)\n        \n        # check each 0, try connect it to 4 neighbors timeO(mn)\n        maxNewIsland = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if self.grid[i][j] == 0: # found a new 0\n                    tempArea = 1 # the grid itself\n                    neighborIslands = set() # must use set to avoid duplicates\n                    for d in ([0,1],[0,-1],[1,0],[-1,0]):\n                        neighborIslands.add(self.getMark(i+d[0], j+d[1]))\n                    for m in neighborIslands:\n                        tempArea+=mark2island[m]\n                    # print(i,j,tempArea)\n                    maxNewIsland = max(maxNewIsland,tempArea)\n        # print(self.grid)\n        return max(maxNewIsland,maxArea) # the max can be an existing island\n        \n                    \n        \n    def getArea(self,i,j,mark):\n        if 0<=i<len(self.grid) and 0<=j<len(self.grid[0]) and self.grid[i][j]==1: \n            self.grid[i][j] = mark # set visited node to 'mark' (e.g. 2,3,4)\n            return 1+self.getArea(i+1,j,mark)+self.getArea(i-1,j,mark)+self.getArea(i,j+1,mark)+self.getArea(i,j-1,mark)\n        return 0\n    \n    def getMark(self,i,j): # get a grid's mark\n        if 0<=i<len(self.grid) and 0<=j<len(self.grid[0]):\n            return self.grid[i][j]\n        return 0\n        \n        ", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        def neighbors(r, c):\n            for nr, nc in [(r+1, c), (r, c+1), (r-1, c), (r, c-1)]:\n                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):\n                    yield nr, nc\n        \n        def dfs(r, c, island_num):\n            island_area = 1\n            grid[r][c] = island_num\n            for nr, nc in neighbors(r, c):\n                if grid[nr][nc] == 1:\n                    island_area += dfs(nr, nc, island_num)\n            return island_area\n        \n        area = {}\n        island_num = 2\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    area[island_num] = dfs(r, c, island_num)\n                    island_num += 1\n        \n        ans = max(area.values() or [0])\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 0:\n                    neighboring_islands = set()\n                    for nr, nc in neighbors(r, c):\n                        if grid[nr][nc] > 1:\n                            neighboring_islands.add(grid[nr][nc])\n                            \n                    ans = max(ans, 1+sum(area[i] for i in neighboring_islands))\n        return ans", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        m, n = len(grid), len(grid[0])\n    \n        def move(i, j):\n            for (x, y) in ((1,0),(-1,0),(0,1),(0,-1)):\n                if 0<=i+x<m and 0<=j+y<n:\n                    yield i+x, j+y\n\n        def dfs(i, j, key):\n            res = 0\n            grid[i][j] = key\n            for x, y in move(i, j):\n                if grid[x][y] == 1:\n                    res += dfs(x, y, key)\n            return res + 1\n\n        ## map each island to distinct keys\n        mappings = {0:0}\n        index = 2\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    mappings[index] = dfs(i, j, index)\n                    index += 1\n\n        res = max(mappings.values()) \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    temp = set(grid[x][y] for x,y in move(i, j))\n                    res = max(res, sum(mappings[key] for key in temp)+1)\n\n        return res           \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        u = {(r, c): (r, c) for r, row in enumerate(grid) for c, v in enumerate(row) if v}\n\n        def head(p):\n            if u[p] == p:\n                return p\n            u[p] = head(u[p])\n            return u[p]\n\n        for r, row in enumerate(grid):\n            for c, v in enumerate(row):\n                if not v:\n                    continue\n\n                for nr, nc in [(r - 1, c), (r, c - 1)]:\n                    if nr < 0 or nc < 0 or not grid[nr][nc]:\n                        continue\n\n                    u[head((r, c))] = head((nr, nc))\n\n        islands = {p: 0 for p, h in list(u.items()) if p == h}\n        for p in u:\n            islands[head(p)] += 1\n\n        max_size = max(list(islands.values()), default=0)\n        for r, row in enumerate(grid):\n            for c, v in enumerate(row):\n                if v:\n                    continue\n\n                connected = set()\n                for nr, nc in [(r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1)]:\n                    if nr < 0 or nc < 0 or nr >= len(grid) or nc >= len(row) or not grid[nr][nc]:\n                        continue\n\n                    if (nr, nc) in u:\n                        connected.add(head((nr, nc)))\n\n                size = 1 + sum(islands[i] for i in connected)\n                max_size = max(max_size, size)\n\n        return max_size\n\n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        nrows,ncols=len(grid),len(grid[0])\n        dp=[ [ (0,0) for _ in range(ncols)] for _ in range(nrows) ]\n        \n        cum_visited=set()\n        isl_no=1\n        maxsize=0\n        for r in range(nrows):\n            for c in range(ncols):\n                if (r,c) not in cum_visited and grid[r][c]==1:\n                    visited=set()\n                    self.dfs(grid,r,c,visited)\n                    size=len(visited)\n                    maxsize=max(maxsize,size)\n                    for x,y in visited:\n                        dp[x][y]=(isl_no,size)\n                    cum_visited=cum_visited.union(visited)\n                    isl_no+=1\n                    #print (size,cum_visited)\n        #print (dp)\n        for r in range(nrows):\n            for c in range(ncols):\n                if grid[r][c]==0:\n                    sz=self.join_zero(grid,dp,r,c)\n                    maxsize=max(maxsize,sz)\n        return maxsize\n    \n    def join_zero(self,grid,dp,r,c):\n        islands=set()\n        for nr,nc in [(r-1,c),(r,c-1),(r,c+1),(r+1,c)]:\n            if nr>=0 and nr<len(grid) and nc>=0 and nc<len(grid[0]) and dp[nr][nc][1]!=0:\n                islands.add(dp[nr][nc])\n        if len(islands)==0: return 1\n        \n        #srt=list(islands)\n        #srt.sort(key=lambda x:x[1])\n        #print (r,c,srt)\n        return sum(x[1] for x in islands)+1\n                        \n                    \n    def dfs(self,grid,r,c,visited):\n        visited.add((r,c))\n        for n_r,n_c in [(r-1,c),(r,c-1),(r,c+1),(r+1,c)]:\n            if n_r>=0 and n_r<len(grid) and n_c>=0 and n_c<len(grid[0]) and grid[n_r][n_c]==1 and (n_r,n_c) not in visited:\n                self.dfs(grid,n_r,n_c,visited)\n        \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        def markIsland(grid, pos, root, d):\n            i = pos[0]\n            j = pos[1]\n            if pos in d.get(root, set()):\n                return\n            if root not in d:\n                d[root] = set()\n            d[root].add(pos)\n            \n            if i > 0 and grid[i-1][j] == 1:\n                markIsland(grid, (i-1,j), root, d)\n            if i < len(grid) - 1 and grid[i+1][j] == 1:\n                markIsland(grid, (i+1, j), root, d)\n            if j > 0 and grid[i][j-1] == 1:\n                markIsland(grid, (i, j-1), root, d)\n            if j < len(grid[i]) - 1 and grid[i][j+1] == 1:\n                markIsland(grid, (i, j+1), root, d)\n            \n            if pos == root:\n                for entry in d[root]:\n                    grid[entry[0]][entry[1]] = len(d[root])\n            return\n            \n        def checkBranch(grid, pos, pos_dict, checked):\n            def getSurrounding(grid, pos, pos_dict, checked):\n                if pos in checked:\n                    return checked[pos]\n                visited = set()\n                i = pos[0]\n                j = pos[1]\n                ret = 1\n                if i > 0 and grid[i-1][j] != 0 and pos_dict[(i-1,j)] not in visited:\n                    visited.add(pos_dict[(i-1,j)])\n                    ret += grid[i-1][j]\n                if i < len(grid) - 1 and grid[i+1][j] != 0 and pos_dict[(i+1,j)] not in visited:\n                    visited.add(pos_dict[(i+1,j)])\n                    ret += grid[i+1][j]\n                if j > 0 and grid[i][j-1] != 0 and pos_dict[(i,j-1)] not in visited:\n                    visited.add(pos_dict[(i,j-1)])\n                    ret += grid[i][j-1]\n                if j < len(grid[i]) - 1 and grid[i][j+1] != 0 and pos_dict[(i,j+1)] not in visited:\n                    visited.add(pos_dict[(i,j+1)])\n                    ret += grid[i][j+1]\n                #print(pos, ret, checked, visited)\n                checked[pos] = ret\n                return ret\n            \n            \n            i = pos[0]\n            j = pos[1]\n            max_connect = 1\n            if i > 0 and grid[i-1][j] == 0:\n                max_connect= max(max_connect, getSurrounding(grid, (i-1,j), pos_dict, checked))\n            if i < len(grid) - 1 and grid[i+1][j] == 0:\n                max_connect= max(max_connect, getSurrounding(grid, (i+1,j), pos_dict, checked))\n            if j > 0 and grid[i][j-1] == 0:\n                max_connect= max(max_connect, getSurrounding(grid, (i,j-1), pos_dict, checked))\n            if j < len(grid[i]) - 1 and grid[i][j+1] == 0:\n                max_connect= max(max_connect, getSurrounding(grid, (i,j+1), pos_dict, checked))\n            return max_connect\n            \n        # mark total island sizes\n        # { root: set(points in island) }\n        d = dict()\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == 1:\n                    markIsland(grid, (i,j), (i,j), d)\n        #print(grid)\n        \n        max_size = 1\n        pos_dict = dict()\n        for key, value in d.items():\n            max_size = max(max_size, len(value))\n            for pos in value:\n                pos_dict[pos] = key\n        \n        \n        checked = dict()\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                max_size = max(max_size, checkBranch(grid, (i,j), pos_dict, checked))\n        return max_size", "class UF:\n    def __init__(self, grid):\n        N = len(grid[0]) * len(grid)\n        self.parent = list(range(N))\n        self.size = [0] * N\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:\n                    self.size[i * len(grid) + j] = 1\n\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n            self.parent[a] = self.parent[self.parent[a]]\n        return self.parent[a]\n    \n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa != pb:\n            self.parent[pa] = pb\n            self.size[pb] += self.size[pa]\n\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        uf = UF(grid)\n        N, M = len(grid), len(grid[0])\n        for i in range(N):\n            for j in range(M):\n                if not grid[i][j]:\n                    continue\n                for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < N and 0 <= ny < M and grid[nx][ny]:\n                        uf.union(i * N + j, nx * N + ny)\n        mx = 0\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j]:\n                    continue\n                all_adjacent = 0\n                seen = set()\n                for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < N and 0 <= ny < M and grid[nx][ny]:\n                        parent = uf.find(nx * N + ny)\n                        if parent not in seen:\n                            seen.add(parent)\n                            all_adjacent += uf.size[parent]\n                mx = max(mx, 1 + all_adjacent)\n        return max(mx, max(uf.size))", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        ROW, COL = len(grid), len(grid[0])\n        labels = [ [0] * COL for _ in range(ROW) ]\n        id = 0\n        def neighbors(r, c):\n            for nr, nc in ( (r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if nr >= 0 and nr < ROW and nc >= 0 and nc < COL:\n                    yield (nr, nc)\n                    \n        def dfs(row, col, id):\n            if row < 0 or row >= ROW or col < 0 or col >= COL:\n                return\n            if labels[row][col] > 0 or grid[row][col] == 0:\n                return\n            labels[row][col] = id\n            for (nr, nc) in neighbors(row, col):\n                dfs(nr, nc, id)\n            \n        for row in range(ROW):\n            for col in range(COL):\n                if grid[row][col] == 1:\n                    id += 1\n                    dfs(row, col, id)\n        \n        size = collections.defaultdict(int)\n        for row in range(ROW):\n            for col in range(COL):\n                id = labels[row][col]\n                if id > 0:\n                    size[id] += 1\n        \n\n        ans = max(list(size.values()) or [0])\n        for row in range(ROW):\n            for col in range(COL):\n                if grid[row][col] == 1:\n                    continue\n                seen = { labels[nr][nc] for (nr, nc) in neighbors(row, col) if grid[nr][nc] == 1}\n                ans = max(ans, 1 + sum( [size[id] for id in seen] ))\n                          \n        return ans\n                \n                    \n                \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        '''\n        Run DFS to find all islands (marked with unique id) and store their sizes. Then iterate through all zeros to see if a zero connects two islands. \n        DFS also counts the number of nodes in an island.\n        \n        Time O(N) - Run DFS to find all connected components takes O(N), and iterate through each zero takes O(1) for each because we only need to check the 4 neighbors of each zero. Total time O(N)\n        Space O(N) - worst case, only additional storage is for island_sizes hashmap and zeros hashset, plus some constants.\n        '''\n        island_sizes = {}\n        max_island_id, max_island_size = -1, 0\n        # id starts from 2 to avoid conflict with 0/1\n        global_island_id = 2\n        zeros = set()\n        deltas = ((1, 0), (-1, 0), (0, 1), (0, -1))\n        rows, cols = len(grid), len(grid[0])\n        \n        def dfs(row, col, island_id) -> int:\n            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n                return 0\n            count = 1\n            grid[row][col] = island_id\n            for dr, dc in deltas:\n                count += dfs(row + dr, col + dc, island_id)\n            return count\n        \n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 1:\n                    cur_size = dfs(r, c, global_island_id)\n                    island_sizes[global_island_id] = cur_size\n                    if cur_size > max_island_size:\n                        max_island_size = cur_size\n                        max_island_id = global_island_id\n                    global_island_id += 1\n                elif val == 0:\n                    zeros.add((r,c))\n        \n        if not zeros:\n            return max_island_size\n        \n        for r, c in zeros:\n            cur_max_size = 1\n            islands_seen = set()\n            for dr, dc in deltas:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    cur_val = grid[nr][nc]\n                    if cur_val in island_sizes and cur_val not in islands_seen:\n                        islands_seen.add(cur_val)\n                        cur_max_size += island_sizes[cur_val]\n            max_island_size = max(max_island_size, cur_max_size)\n        \n        return max_island_size", "class DSU:\n    def __init__(self, N):\n        self.par = [i for i in range(N)]\n        self.cnt = N\n    def find(self, i):\n        if self.par[i] != i:\n            self.par[i] = self.find(self.par[i])\n        return self.par[i]\n    def union(self, i, j):\n        pi = self.find(i)\n        pj = self.find(j)\n        if pi != pj:\n            self.par[pi] = pj\n            self.cnt-=1\n        \nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        R = len(grid)\n        C = len(grid[0])\n        dsu = DSU(R*C)\n        dirs = [[1,0], [0,1],[-1,0], [0,-1]]\n        for y in range(R):\n            for x in range(C):\n                if grid[y][x] == 1:\n                    for dx,dy in dirs:\n                        nx , ny = dx+x, dy+y\n                        if 0<=nx<C and 0<=ny<R and grid[ny][nx] == 1:\n                            dsu.union(y*R+x, ny*R+nx)\n        smap = {}\n        for y in range(R):\n            for x in range(C):\n                if grid[y][x] == 1:\n                    r = dsu.find(y*R+x)\n                    if r in smap:\n                        smap[r] += 1\n                    else:\n                        smap[r] = 1\n        ans = 0\n        for y in range(R):\n            for x in range(C):\n                if grid[y][x] == 0:\n                    rset = set()\n                    for dx, dy in dirs:\n                        nx , ny = dx+x, dy+y\n                        if 0<=nx<C and 0<=ny<R and grid[ny][nx] == 1:\n                            r = dsu.find(ny*R+nx)\n                            rset.add(r)\n                    t = 1\n                    for r in rset:\n                        t+=smap[r]\n                    ans = max(ans, t)\n        return ans if ans != 0 else R*C\n", "class UnionFind:\n    def __init__(self, N):\n        self.parents = [i for i in range(N)]\n        self.size = [1]*N\n\n    def find(self, x):\n        root = x\n        while root != self.parents[root]:\n            root = self.parents[root]\n\n        while x != root:\n            parent = self.parents[x]\n            self.parents[x] = root\n            x = parent\n\n        return root\n\n    def union(self, a, b):\n        root_a = self.find(a)\n        root_b = self.find(b)\n        if root_a == root_b:\n            return False\n\n        if self.size[root_a] <= self.size[root_b]:\n            self.parents[root_a] = root_b\n            self.size[root_b] += self.size[root_a]\n        else:\n            self.parents[root_b] = root_a\n            self.size[root_a] += self.size[root_b]\n\n        return True\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        # assuming we have a UnionFind data structure\n        \n        def rc2idx(r, c):\n            return r*n + c\n        \n        # build uf out of the islands\n        uf = UnionFind(m*n)\n        max_area = 0\n        for r in range(m):\n            for c in range(n):\n                # union with the neighbours\n                if grid[r][c] == 1:\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < m and 0 <= nc < n):\n                            continue\n                        if grid[nr][nc] == 1:\n                            uf.union(rc2idx(r, c), rc2idx(nr, nc))\n        \n                    max_area = max(max_area, uf.size[uf.find(rc2idx(r, c))])\n        \n        # check all possible points for setting 0 to 1\n        for r in range(m):\n            for c in range(n):\n                area = 0\n                if grid[r][c] == 0:\n                    area = 1\n                    unique_neis = set()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < m and 0 <= nc < n):\n                            continue\n                        if grid[nr][nc] == 1:\n                            island = uf.find(rc2idx(nr, nc))\n                            unique_neis.add(island)\n\n                    area += sum([uf.size[island] for island in unique_neis])\n    \n                max_area = max(max_area, area)\n        \n        return max_area\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1]*n\n    \n    def find(self, x):\n        root = x\n        while self.parent[root] != root:\n            root = self.parent[root]\n            \n        while x != root:\n            tmp = self.parent[x]\n            self.parent[x] = root\n            x = tmp\n        return root\n    \n    def union(self, a, b):\n        root_a = self.find(a)\n        root_b = self.find(b)\n        if root_a == root_b:\n            return False\n        \n        if self.size[root_a] <= self.size[root_b]:\n            self.parent[root_a] = root_b\n            self.size[root_b] += self.size[root_a]\n        else:\n            self.parent[root_b] = root_a\n            self.size[root_a] += self.size[root_b]\n        \n        return True\n    \n    \nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n        m = len(grid)\n        n = len(grid[0])\n        uf = UnionFind(m*n)        \n        # merge edges with 1-1\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 0:\n                    continue\n                \n                rc = r*m+c\n                for r_off, c_off in directions:\n                    new_r, new_c = r+r_off, c+c_off\n                    if not (0 <= new_r < len(grid) and 0 <= new_c < len(grid[0])):\n                        continue\n                    if grid[new_r][new_c] == 1:\n                        new_rc = new_r*m+new_c\n                        uf.union(rc, new_rc)\n        \n        max_area = max(uf.size)\n        # try checking changing 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    continue\n                    \n                rc = r*m+c\n                # id of neighbouring islands\n                neighbours = set()\n                for r_off, c_off in directions:\n                    new_r, new_c = r+r_off, c+c_off\n                    if not (0 <= new_r < len(grid) and 0 <= new_c < len(grid[0])):\n                        continue\n                    if grid[new_r][new_c] == 1:\n                        new_rc = new_r*m+new_c\n                        neighbours.add(uf.find(new_rc))\n                \n                max_area = max(max_area, 1 + sum([uf.size[i] for i in neighbours]))\n        \n        return max_area", "class Solution(object):\n    def largestIsland(self, grid):\n        N = len(grid)\n\n        def neighbors(r, c):\n            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if 0 <= nr < N and 0 <= nc < N:\n                    yield nr, nc\n\n        def dfs(r, c, index):\n            ans = 1\n            grid[r][c] = index\n            for nr, nc in neighbors(r, c):\n                if grid[nr][nc] == 1:\n                    ans += dfs(nr, nc, index)\n            return ans\n\n        area = {}\n        index = 2\n        for r in range(N):\n            for c in range(N):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index)\n                    index += 1\n\n        ans = max(area.values() or [0])\n        for r in range(N):\n            for c in range(N):\n                if grid[r][c] == 0:\n                    seen = {grid[nr][nc] for nr, nc in neighbors(r, c) if grid[nr][nc] > 1}\n                    ans = max(ans, 1 + sum(area[i] for i in seen))\n        return ans", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        ret=1\n        size=[]\n        direction=[(1,0),(0,1),(-1,0),(0,-1)]\n        h=len(grid)\n        w=len(grid[0])\n        def dfs(y0,x0,mark):\n            if grid[y0][x0]==1:\n                grid[y0][x0]=mark\n            inc=0\n            cnt=0 \n            seen=[]\n            for y_offset,x_offset in direction:\n                y1=y0+y_offset\n                x1=x0+x_offset\n                if 0<=x1<w and 0<=y1<h:\n                    if grid[y0][x0]==0 and grid[y1][x1]<0 and grid[y1][x1]!=mark and grid[y1][x1] not in seen:\n                        seen.append(grid[y1][x1])\n                        inc+=size[-grid[y1][x1]-1]\n                    elif grid[y0][x0]==mark and grid[y1][x1]>=0:\n                        a,b=dfs(y1,x1,mark)\n                        cnt+=a\n                        inc=max(inc,b)\n            print((cnt+(0 if grid[y0][x0]==0 else 1),inc+(1 if grid[y0][x0]==0 else 0)))\n            return cnt+(0 if grid[y0][x0]==0 else 1),inc+(1 if grid[y0][x0]==0 else 0)\n        idx=-1\n        for y in range(h):\n            for x in range(w):\n                if grid[y][x]==1:\n                    cnt,inc=dfs(y,x,idx)\n                    size.append(cnt)\n                    ret=max(ret,cnt+inc)\n                    idx-=1\n        return ret\n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        \\\"\\\"\\\"\n        Best explanation: https://www.youtube.com/watch?v=_426VVOB8Vo\n        \\\"\\\"\\\"\n        \n        if not grid:\n            return 0\n        \n        rows = len(grid)\n        columns = len(grid[0])\n        \n        \n        def dfsIslandSize(r, c, islandID, size):\n            if r < 0 or r > rows - 1 or c < 0 or c > columns - 1 or grid[r][c] != 1:\n                return size\n            \n            grid[r][c] = islandID\n            size += 1\n            \n            size = dfsIslandSize(r-1, c, islandID, size)\n            size = dfsIslandSize(r+1, c, islandID, size)\n            size = dfsIslandSize(r, c-1, islandID, size)\n            size = dfsIslandSize(r, c+1, islandID, size)\n            \n            return size\n            \n        \n        def calculateJoinedIslandsSize(r, c):\n            neighbors = set()\n            \n            if r - 1 >= 0 and grid[r-1][c] > 1:\n                neighbors.add(grid[r-1][c])\n                \n            if c - 1 >= 0 and grid[r][c-1] > 1:\n                neighbors.add(grid[r][c-1])\n                \n            if r + 1 <= rows - 1 and grid[r+1][c] > 1:\n                neighbors.add(grid[r+1][c])\n                \n            if c + 1 <= columns - 1 and grid[r][c+1]:\n                neighbors.add(grid[r][c+1])\n                \n            \n            size = 1 # becouse we converted the current 0 to a 1\n            for neighbor in list(neighbors):\n                size += d[neighbor]\n                \n            return size                    \n        \n\n        \n        islandID = 2\n        d = {}\n        maxSize = 0\n        \n        # Iterate first to mark grid with islandID and calculate island sizes\n        for r in range(rows):\n            for c in range(columns):\n                if grid[r][c] == 1:\n                    size = dfsIslandSize(r, c, islandID, 0)\n                    d[islandID] = size\n                    islandID += 1\n                    maxSize = max(maxSize, size)\n        \n        # Iterate over grid. Convert 0 to 1 and calculate joined islands size\n        for r in range(rows):\n            for c in range(columns):\n                if grid[r][c] == 0:\n                    size = calculateJoinedIslandsSize(r, c)\n                    maxSize = max(maxSize, size)\n                    \n        return maxSize\n            \n            \n        ", "from collections import defaultdict, Counter\nclass Solution:\n    def find(self, j):\n        if self.d[j] == j:\n            return j\n        \n        self.d[j] = self.find(self.d[j])\n        return self.d[j]\n    \n    def union(self, ij1, ij2):\n        i1 = self.find(ij1)\n        i2 = self.find(ij2)\n        if i1 == i2:\n            return\n        \n        if self.rank[i2] > self.rank[i1]:\n            self.d[i1] = i2\n            # self.rank[i2] = self.rank[i1] + 1\n        else:\n            if self.rank[i1] >= self.rank[i2]:\n                self.d[i2] = i1\n            self.rank[i1] += 1\n    \n    def largestIsland(self, grid: List[List[int]]) -> int:\n        self.rank, self.d = {}, {}\n        self.z = []\n        self.res = 1\n        for r, row in enumerate(grid):\n            for c, col in enumerate(row):\n                if col == 1:\n                    self.d[(r, c)] = (r, c)\n                    self.rank[(r, c)] = 0\n                if col == 0:\n                    self.z.append((r, c))\n                    \n        for a, b in list(self.d.keys()):\n            search = [(a + 1, b), (a - 1, b), (a, b + 1), (a, b - 1)]\n            for c, d in search:\n                if 0 <= c < len(grid) and 0 <= d < len(grid[0]) and grid[c][d] == 1:\n                    self.union((a, b), (c, d))\n        for key in list(self.d.keys()):\n            self.find(key)\n        cc = Counter(list(self.d.values()))\n        if cc:\n            self.res = max(cc.values())\n        for a, b in self.z:\n            search = [(a + 1, b), (a - 1, b), (a, b + 1), (a, b - 1)]\n            total = {}\n            for c, d in search:\n                if 0 <= c < len(grid) and 0 <= d < len(grid[0]) and grid[c][d] == 1:\n                    e, f = self.d[(c, d)]\n                    total[(e, f)] = cc[(e, f)]\n            print(('total ', total))\n            s = sum(total.values())\n            self.res = max(self.res, s + 1)\n            \n        return self.res\n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        R = len(grid)\n        C = len(grid[0])\n        \n        label = 2\n       \n        sum_of_area = 0\n        max_area = 0\n        map_info = {}\n        # grid_info = copy.deepcopy(grid)\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 1:\n                    area = self.findIsland(grid, i, j, R, C, label)\n                    map_info[label] = area\n                    sum_of_area += area\n                    label += 1\n                \n        print(map_info)    \n        print(grid)\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 0:\n                    current = self.testChange(grid, i, j, R, C, map_info)\n                    if current > max_area:\n                        max_area = current\n        \n        if max_area == 0:\n            max_area = sum_of_area\n                \n        return max_area\n        \n        \n    def testChange(self, grid_info, i, j, R, C, map_info):\n        \n        island = []\n        area = 0\n        if 0 <= i+1 < R and grid_info[i+1][j] > 0:\n            island.append(grid_info[i+1][j])\n        \n        if 0 <= i-1 < R and grid_info[i-1][j] > 0:\n            island.append(grid_info[i-1][j])\n        \n        if 0 <= j+1 < C and grid_info[i][j+1] > 0:\n            island.append(grid_info[i][j+1])\n        \n        if 0 <= j-1 < C and grid_info[i][j-1] > 0:\n            island.append(grid_info[i][j-1])\n            \n        if not island: \n            return 1\n        \n        for key in list(map_info.keys()):\n            if key in island:\n                area += map_info[key]\n                \n        return area + 1\n    \n        \n    def findIsland(self, grid, i, j, R, C, label):\n        \n        area = 0\n        \n        if  (i >= R or j >= C or i < 0 or j < 0) or grid[i][j] == 0 or grid[i][j] == label:\n            return 0\n        else:\n            area = grid[i][j]\n            grid[i][j] = label\n            \n            \n        return area + self.findIsland(grid, i, j+1, R, C, label) + self.findIsland(grid, i, j-1, R, C, label) + self.findIsland(grid, i+1, j, R, C, label) + self.findIsland(grid, i-1, j, R, C, label)\n        \n            \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        N, M = len(grid), len(grid[0])\n        visited = [[0]*M for _ in range(N)]\n        group_ids_ = collections.defaultdict()\n        group_counts_ = collections.Counter()\n        _id_ = 0\n        previous_count = 0\n        for row in range(N):\n            for col in range(M):\n                if grid[row][col] == 1 and visited[row][col] == 0:\n                    _id_ += 1\n                    visited[row][col] = 1\n                    stack = [(row, col)]\n                    group_ids_[(row, col)] = _id_\n                    while stack:\n                        r, c = stack.pop()\n                        for newr, newc in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\n                            if 0<=newr<N and 0<=newc<M and visited[newr][newc]==0 and grid[newr][newc]==1:\n                                visited[newr][newc] = 1\n                                stack.append((newr,newc))\n                                group_ids_[(newr,newc)] = _id_\n\n                    group_counts_[_id_] = sum([sum(l) for l in visited]) - previous_count\n                    previous_count = sum([sum(l) for l in visited])\n        \n        #print(group_ids_)\n        #print(group_counts_)\n        biggest = 0\n        hasZero = False\n        for r in range(N):\n            for c in range(M):\n                if grid[r][c] == 0:\n                    hasZero = True\n                    groups = set()\n                    for newr, newc in [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]:\n                        if 0<=newr<N and 0<=newc<M and grid[newr][newc]==1:\n                            groups.add(group_ids_[(newr,newc)])\n                    biggest = max(biggest, sum([group_counts_[_id_] for _id_ in groups]) + 1)\n        if hasZero:            \n            return biggest\n        else:\n            return N*M\n                        \n                    \n                    \n                \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        '''\n        Run DFS to find all islands (marked with unique id) and store their sizes. Then iterate through all zeros to see if a zero connects two islands.\n        '''\n        island_sizes = {}\n        max_island_id, max_island_size = -1, 0\n        # id starts from 2 to avoid conflict with 0/1\n        global_island_id = 2\n        zeros = set()\n        deltas = ((1, 0), (-1, 0), (0, 1), (0, -1))\n        rows, cols = len(grid), len(grid[0])\n        \n        def dfs(row, col, island_id) -> int:\n            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n                return 0\n            count = 1\n            grid[row][col] = island_id\n            for dr, dc in deltas:\n                count += dfs(row + dr, col + dc, island_id)\n            return count\n        \n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 1:\n                    cur_size = dfs(r, c, global_island_id)\n                    island_sizes[global_island_id] = cur_size\n                    if cur_size > max_island_size:\n                        max_island_size = cur_size\n                        max_island_id = global_island_id\n                    global_island_id += 1\n                elif val == 0:\n                    zeros.add((r,c))\n        \n        if not zeros:\n            return max_island_size\n        \n        for r, c in zeros:\n            cur_max_size = 1\n            islands_seen = set()\n            for dr, dc in deltas:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    cur_val = grid[nr][nc]\n                    if cur_val in island_sizes and cur_val not in islands_seen:\n                        islands_seen.add(cur_val)\n                        cur_max_size += island_sizes[cur_val]\n            max_island_size = max(max_island_size, cur_max_size)\n        \n        return max_island_size", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        R = len(grid)\n        C = len(grid[0])\n        \n        label = 2\n       \n        sum_of_area = 0\n        max_area = 0\n        map_info = {}\n        # grid_info = copy.deepcopy(grid)\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 1:\n                    area = self.findIsland(grid, i, j, R, C, label)\n                    map_info[label] = area\n                    sum_of_area += area\n                    label += 1\n                \n        print(map_info)    \n        print(grid)\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 0:\n                    current = self.testChange(grid, i, j, R, C, map_info)\n                    if current > max_area:\n                        max_area = current\n        \n        if max_area == 0:\n            max_area = sum_of_area\n                \n        return max_area\n        \n        \n    def testChange(self, grid_info, i, j, R, C, map_info):\n        \n        island = []\n        area = 0\n        if 0 <= i+1 < R and grid_info[i+1][j] > 0:\n            island.append(grid_info[i+1][j])\n        \n        if 0 <= i-1 < R and grid_info[i-1][j] > 0:\n            island.append(grid_info[i-1][j])\n        \n        if 0 <= j+1 < C and grid_info[i][j+1] > 0:\n            island.append(grid_info[i][j+1])\n        \n        if 0 <= j-1 < C and grid_info[i][j-1] > 0:\n            island.append(grid_info[i][j-1])\n            \n        if not island: \n            return 1\n        \n        for key in list(map_info.keys()):\n            if key in island:\n                area += map_info[key]\n                \n        return area + 1\n    \n        \n    def findIsland(self, grid, i, j, R, C, label):\n        \n        area = 0\n        \n        if  (i >= R or j >= C or i < 0 or j < 0) or grid[i][j] != 1:\n            return 0\n        else:\n            area = grid[i][j]\n            grid[i][j] = label\n            \n            \n        return area + self.findIsland(grid, i, j+1, R, C, label) + self.findIsland(grid, i, j-1, R, C, label) + self.findIsland(grid, i+1, j, R, C, label) + self.findIsland(grid, i-1, j, R, C, label)\n        \n            \n", "from collections import defaultdict, Counter\nclass Solution:\n    def find(self, j):\n        if self.d[j] == j:\n            return j\n        \n        self.d[j] = self.find(self.d[j])\n        return self.d[j]\n    \n    def union(self, ij1, ij2):\n        i1 = self.find(ij1)\n        i2 = self.find(ij2)\n        if i1 == i2:\n            return\n        \n        if self.rank[i2] > self.rank[i1]:\n            self.d[i1] = i2\n            # self.rank[i2] = self.rank[i1] + 1\n        else:\n            if self.rank[i1] >= self.rank[i2]:\n                self.d[i2] = i1\n            self.rank[i1] += 1\n    \n    def largestIsland(self, grid: List[List[int]]) -> int:\n        self.rank, self.d = {}, {}\n        self.z = []\n        self.res = 1\n        for r, row in enumerate(grid):\n            for c, col in enumerate(row):\n                if col == 1:\n                    self.d[(r, c)] = (r, c)\n                    self.rank[(r, c)] = 0\n                if col == 0:\n                    self.z.append((r, c))\n                    \n        for a, b in list(self.d.keys()):\n            search = [(a + 1, b), (a - 1, b), (a, b + 1), (a, b - 1)]\n            for c, d in search:\n                if 0 <= c < len(grid) and 0 <= d < len(grid[0]) and grid[c][d] == 1:\n                    self.union((a, b), (c, d))\n        for key in list(self.d.keys()):\n            self.find(key)\n        cc = Counter(list(self.d.values()))\n        print(('cc ', cc))\n        \n        print(('d ', self.d))\n        print(('rank', self.rank))\n        if cc:\n            self.res = max(cc.values())\n        for a, b in self.z:\n            search = [(a + 1, b), (a - 1, b), (a, b + 1), (a, b - 1)]\n            total = {}\n            for c, d in search:\n                if 0 <= c < len(grid) and 0 <= d < len(grid[0]) and grid[c][d] == 1:\n                    e, f = self.d[(c, d)]\n                    total[(e, f)] = cc[(e, f)]\n            print(('total ', total))\n            s = sum(total.values())\n            self.res = max(self.res, s + 1)\n            \n        return self.res\n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        def method1():\n            R=len(grid)\n            if R<1:\n                return 0\n            C=len(grid[0])\n            \n            def neighbors(r,c):\n                for dr,dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                    nr,nc=r+dr,c+dc\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n            \n            def dfs(r,c,visited):\n                if (r,c) in seen:\n                    return\n                \n                if grid[r][c]==0:\n                    return\n                \n                seen.add((r,c))\n                visited.add((r,c))\n                for nr,nc in neighbors(r,c):\n                    dfs(nr,nc,visited)\n                    \n            \n            ans=float('-inf')\n            seen=set()\n            cc=[]\n            zeros=set()\n            \n            for r in range(R):\n                for c in range(C):\n                    if grid[r][c]==1 and (r,c) not in seen:\n                        visited=set()\n                        dfs(r,c,visited)\n                        if visited:\n                            cc.append(visited)\n                    \n                    if grid[r][c]==0:\n                        zeros.add((r,c))\n                        \n            if len(zeros)==R*C:\n                return 1\n                            \n            ans=len(max(cc, key=len))\n            for r,c in zeros:\n                nei={(nr,nc) for nr,nc in neighbors(r,c)}\n                \n                if len(cc)==1:\n                    if any((r,c) in cc[0] for r,c in nei):\n                        ans=max(ans, len(cc[0])+1)\n                else:\n                    for i in range(len(cc)):\n                        for j in range(i,len(cc)):\n                            if (i!=j and any((r,c) in cc[i] for r,c in nei) and any((r,c) in cc[j] for r,c in nei)):\n                                ans=max(ans, len(cc[i]) + len(cc[j]) + 1)\n                        \n            return ans\n        #return method1()\n    \n        def method2():\n            R=len(grid)\n            if R<1:\n                return 0\n            C=len(grid[0])\n            \n            def neighbors(r,c):\n                for dr,dc in [(-1,0),(1,0),(0,-1),(0,1)]:\n                    nr,nc=r+dr,c+dc\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n                        \n            def dfs(r,c,index):\n                ans=1\n                grid[r][c]=index\n                for nr,nc in neighbors(r,c):\n                    if grid[nr][nc]==1:\n                        ans+=dfs(nr,nc,index)\n                return ans\n            \n            area={}\n            index=2\n            for r in range(R):\n                for c in range(C):\n                    if grid[r][c]==1:\n                        area[index]=dfs(r,c,index)\n                        index+=1\n                        \n            ans=max(list(area.values()) or [0])\n            for r in range(R):\n                for c in range(C):\n                    if grid[r][c]==0:\n                        seen={grid[nr][nc] for nr,nc in neighbors(r,c) if grid[nr][nc]>1}\n                        ans=max(ans, 1+sum(area[i] for i in seen))\n                        \n            return ans\n        return method2()\n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n        def dfs(row, col, index):\n            if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n                return 0\n            grid[row][col] = index\n            area = 1\n            for direction in directions:\n                area += dfs(row+direction[0], col+direction[1], index)\n            return area\n        \n        max_area = 0\n        found_zero = False\n        visited = set()\n        index = 2\n        area = {}\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 1:\n                    area[index] = dfs(row, col, index)\n                    index += 1\n        \n        max_area = max(area.values() or [0])\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 0:\n                    indexes = set()\n                    for direction in directions:\n                        new_row = row + direction[0]\n                        new_col = col + direction[1]\n                        if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] > 1:\n                            indexes.add(grid[new_row][new_col])\n                        max_area = max(max_area, sum(area[index] for index in indexes) + 1)\n                        \n        return max_area", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        R = len(grid)\n        C = len(grid[0])\n        \n        label = 1\n       \n        sum_of_area = 0\n        max_area = 0\n        map_info = {}\n        grid_info = copy.deepcopy(grid)\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 1:\n                    area = self.findIsland(grid, grid_info, i, j, R, C, label)\n                    map_info[label] = area\n                    sum_of_area += area\n                    label += 1\n                \n        print(map_info)\n        print(grid_info)\n        \n        \n        for i in range(R):\n            for j in range(C):\n                if grid_info[i][j] == 0:\n                    current = self.testChange(grid_info, i, j, R, C, map_info)\n                    if current > max_area:\n                        max_area = current\n        \n        if max_area == 0:\n            max_area = sum_of_area\n                \n        return max_area\n        \n        \n    def testChange(self, grid_info, i, j, R, C, map_info):\n        \n        island = []\n        area = 0\n        if 0 <= i+1 < R and grid_info[i+1][j] > 0:\n            island.append(grid_info[i+1][j])\n        \n        if 0 <= i-1 < R and grid_info[i-1][j] > 0:\n            island.append(grid_info[i-1][j])\n        \n        if 0 <= j+1 < C and grid_info[i][j+1] > 0:\n            island.append(grid_info[i][j+1])\n        \n        if 0 <= j-1 < C and grid_info[i][j-1] > 0:\n            island.append(grid_info[i][j-1])\n            \n        if not island: \n            return 1\n        \n        for key in list(map_info.keys()):\n            if key in island:\n                area += map_info[key]\n                \n        return area + 1\n        \n    def findIsland(self, grid, grid_info, i, j, R, C, label):\n        \n        area = 0\n        \n        if  (i >= R or j >= C or i < 0 or j < 0) or grid[i][j] == 0:\n            return 0\n        else:\n            area = grid[i][j]\n            grid_info[i][j] = label\n            grid[i][j] = 0\n            \n        return area + self.findIsland(grid, grid_info, i, j+1, R, C, label) + self.findIsland(grid, grid_info, i, j-1, R, C, label) + self.findIsland(grid, grid_info, i+1, j, R, C, label) + self.findIsland(grid, grid_info, i-1, j, R, C, label)\n        \n            \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return\n        R,C = len(grid), len(grid[0])\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\n        d = collections.defaultdict(int)\n        def dfs(grid,row,col,idx):\n            grid[row][col] = idx\n            total = 1\n            for di in directions:\n                newrow,newcol = row+di[0], col+di[1]\n                if 0<=newrow<R and 0<=newcol<C and grid[newrow][newcol] ==1:\n                    total += dfs(grid,newrow,newcol,idx)\n            return total\n                    \n        index = 2\n        maxlength = 0\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] ==1:\n                    total = 0\n                    total = dfs(grid,i,j,index)\n                    d[index] = total\n                    maxlength = max(maxlength, total)\n                    index +=1\n        \n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] ==0:\n                    keyset,length = set(),0\n                    for di in directions:\n                        newrow,newcol = i+di[0], j+di[1]\n                    \n                        if 0<=newrow<R and 0<=newcol<C and grid[newrow][newcol] > 1:\n                            keyset.add(grid[newrow][newcol])\n                    length = sum(d[key] for key in keyset)+1\n                    maxlength = max(length,maxlength)\n        \n        return max(1,maxlength)\n        \n                            \n        \n        \n                    \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        M = len(grid[0])\n\n        def neighbors(r, c):\n            result = []\n            for newR, newC in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if 0 <= newR < N and 0 <= newC < M:\n                    result.append((newR, newC))\n            return result\n\n        def dfs(r, c, index):\n            ans = 1\n            grid[r][c] = index\n            for newR, newC in neighbors(r, c):\n                if grid[newR][newC] == 1:\n                    ans += dfs(newR, newC, index)\n            return ans\n\n        area = {}\n        index = 2\n        for r in range(N):\n            for c in range(M):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index)\n                    index += 1\n\n        ans = max(area.values() or [0])\n        for r in range(N):\n            for c in range(M):\n                if grid[r][c] == 0:\n                    seen = {grid[newR][newC] for newR, newC in neighbors(r, c) if grid[newR][newC] > 1}\n                    ans = max(ans, 1 + sum(area[i] for i in seen))\n        return ans", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        return self.largestIsland_dfs(grid)\n        \n        \n    def largestIsland_dfs(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        * Make eavery island a unqiue index (dfs, bfs)\n        * Chehck every empty cell(0) to figure out largest area\n        \\\"\\\"\\\"\n        \n        def moves(row, col):\n            for rm, cm in (0, 1), (1, 0), (0, -1), (-1, 0):\n                nr, nc = row + rm, col + cm\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    yield nr, nc\n        \n        def dfs(row, col, index) -> int:\n            grid[row][col] = index\n            cur_size = 1\n            for nr, nc in moves(row, col):\n                if grid[nr][nc] != 1:\n                    continue\n                cur_size += dfs(nr, nc, index)\n            return cur_size\n        \n        rows, cols = len(grid), len(grid[0])\n        index = 2\n        island_to_size = defaultdict(int)\n        # island_to_size = {0:0} # edge case: input [[0,0],[0,0]]\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] != 1:\n                    continue\n                size = dfs(r, c, index)\n                island_to_size[index] = size\n                index += 1\n                \n        # edge case: [[1,1], [1, 1]] or [[1]]\n        # max_size = max(island_to_size.values())\n        max_size = max(island_to_size.values()) if island_to_size else 0\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c]:\n                    continue\n                islands = set([grid[nr][nc] for nr, nc in moves(r, c)])\n                cur_size = sum(island_to_size[idx] for idx in islands) + 1\n                max_size = max(max_size, cur_size)\n                \n        return max_size\n                \n\n        ", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        \n        def neighbours(r,c):\n            result = []\n            for nr, nc in [(r-1,c),(r+1,c),(r, c-1), (r, c+1)]:\n                if 0 <= nr < N and 0 <= nc < N:\n                    result.append((nr,nc))\n            return result \n        \n        def dfs(r, c, index):\n            ans = 1 \n            grid[r][c] = index\n            for nr, nc in neighbours(r,c):\n                if grid[nr][nc] == 1:\n                    ans += dfs(nr, nc, index)\n            return ans \n        \n        areas = {}\n        index = 2\n        for r in range(N):\n            for c in range(N):\n                if grid[r][c] == 1:\n                    areas[index] = dfs(r,c,index)\n                    index += 1 \n        ans = max(list(areas.values()) or [0])\n        for r in range(N):\n            for c in range(N):\n                if grid[r][c] == 0:\n                    seen = {grid[nr][nc] for nr, nc in neighbours(r,c) if grid[nr][nc] > 1}\n                    ans = max(ans, 1 + sum(areas[i] for i in seen))\n        \n        return ans \n                    \n        \n                    \n                    \n        \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n\n        max_size = 0\n\n        # mark islands\n        area_sizes = [0, 0]  # starts from  2\n\n        def mark(i, j) -> int:  # size\n            if not (0 <= i < M and 0 <= j < N):\n                return 0\n            if grid[i][j] != 1:\n                return 0\n            else:\n                grid[i][j] = len(area_sizes)\n            return 1 + mark(i - 1, j) + mark(i + 1, j) + mark(i, j - 1) + mark(i, j + 1)\n\n        for i in range(M):\n            for j in range(N):\n                if grid[i][j] == 1:\n                    area_sizes.append(mark(i, j))\n\n        max_size = max(max_size, *area_sizes)  # FIXME: bug: \u5fd8\u8a18\u8003\u616e\u6c92\u6709 0 \u7684\u72c0\u6cc1\n\n        # for each 0, try to find max size\n        for i in range(M):\n            for j in range(N):\n                if grid[i][j] == 0:\n                    ids = set() # FIXME: bug: \u5fd8\u8a18 dedup, \u9020\u6210\u91cd\u8907\u7b97\n                    if 0 <= i - 1:\n                        ids.add(grid[i - 1][j])\n                    if i + 1 < M:\n                        ids.add(grid[i + 1][j])\n                    if 0 <= j - 1:\n                        ids.add(grid[i][j - 1])\n                    if j + 1 < N:\n                        ids.add(grid[i][j + 1])\n\n                    max_size = max(max_size, sum(area_sizes[id] for id in ids) + 1)\n\n        return max_size\n", "from typing import List\nimport math\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n      if grid == None or len(grid) == 0 or grid[0] == None or len(grid[0]) == 0:\n        return 0\n      n = len(grid)\n      m = len(grid[0])\n      compSize = [0]*(n*m + 2)\n      def dfs(x, y, c):\n        nonlocal compSize\n        nonlocal grid\n        compSize[c] += 1\n        grid[y][x] = c\n        nextPoints = [[x - 1, y],[x, y - 1],[x + 1, y],[x, y + 1]]\n        for point in nextPoints:\n          nextX = point[0]\n          nextY = point[1]\n          if nextX < 0 or nextX == m or nextY < 0 or nextY == n:\n            continue\n          if grid[nextY][nextX] == 1:\n            dfs(nextX, nextY, c)\n        return\n      def calMaxLinkSize(x, y) -> int:\n        nonlocal compSize\n        nonlocal grid\n        uniqueCompNums = []\n        nextPoints = [[x - 1, y],[x, y - 1],[x + 1, y],[x, y + 1]]\n        for point in nextPoints:\n          nextX = point[0]\n          nextY = point[1]\n          if nextX < 0 or nextX == m or nextY < 0 or nextY == n:\n            continue\n          compNum = grid[nextY][nextX]\n          if compNum >= 2 and compNum not in uniqueCompNums:\n            uniqueCompNums.append(compNum)\n        return sum([compSize[c] for c in uniqueCompNums]) + 1\n      compNum =2\n      maxCompSize = 0\n      for y in range(n):\n        for x in range(m):\n          if grid[y][x] == 1:\n            dfs(x, y, compNum)\n            maxCompSize = max(maxCompSize, compSize[compNum])\n            compNum += 1\n      for y in range(n):\n        for x in range(m):\n          if grid[y][x] == 0:\n            maxCompSize = max(maxCompSize, calMaxLinkSize(x, y))\n      return maxCompSize\n        \n\n\n\ndef __starting_point():\n  pass\n__starting_point()", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        # First DFS to find the each island and the island components. Then do another DFS to find out \n        # the size of the islands if the were to join.\n        # TC = O(n^2), SC = O(n^2)\n        \n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        def dfs(i, j):\n            dic[(i, j)] = curr\n            count[curr] += 1\n            for dx, dy in directions:\n                a, b = i + dx, j + dy\n                if 0 <= a < m and 0 <= b < n and grid[a][b] == 1 and (a, b) not in dic:\n                    dfs(a, b)\n\n        def neighbours(i, j, adj):\n            for dx, dy in directions:\n                a, b = i + dx, j + dy\n                if 0 <= a < m and 0 <= b < n and grid[a][b] == 1 and dic[(a, b)] not in adj:\n                    adj.add(dic[(a, b)])\n            \n            return adj            \n        \n        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and (i, j) not in dic: \n                    curr += 1\n                    dfs(i, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1: \n                    res = max(res, count[dic[(i, j)]])\n                else:\n                    res = max(res, sum(count[r] for r in neighbours(i, j, set())) + 1)\n    \n        return res", "DIRECTIONS = [(0, 1), (0, -1), (1, 0), (-1, 0)]\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        \n        def move(x, y):\n            ans = []\n            for mv_x, mv_y in DIRECTIONS:\n                x_ = x + mv_x\n                y_ = y + mv_y\n                if 0 <= x_ < N and 0 <= y_ < N:\n                    ans.append((x_, y_))\n            return ans\n        \n        # return area of the island\n        def dfs(x, y, idx):\n            ans = 1\n            grid[x][y] = idx\n            for i, j in move(x, y):\n                if grid[i][j] == 1:\n                    ans += dfs(i, j, idx)\n            return ans\n        \n        idx = 2\n        areas = {0: 0}\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == 1:\n                    areas[idx] = dfs(i, j, idx)\n                    idx += 1\n        \n        ans = max(areas.values())\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == 0:\n                    cands = set(grid[x][y] for x, y in move(i, j))\n                    ans = max(ans, sum(areas[idx] for idx in cands) + 1)\n        return ans", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        parent = {}\n        nums = collections.defaultdict(int)\n        visited = set()\n        res = 1\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1 and (i, j) not in parent:\n                    parent[(i, j)] = (i, j)\n                    stack = [(i, j)]\n                    while stack:\n                        x, y = stack.pop()\n                        nums[(i, j)] += 1\n                        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n                        for direction in directions:\n                            dx, dy = direction\n                            if self.is_valid(grid, (x + dx, y + dy), parent):\n                                parent[(x+dx, y+dy)] = (i, j)\n                                stack.append((x + dx, y + dy))\n        \n        for v in list(nums.values()):\n            res = max(res, v)\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    candidates = []\n                    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n                    for direction in directions:\n                        dx, dy = direction\n                        if i + dx < 0 or i + dx >= len(grid) or j + dy < 0 or j + dy >= len(grid[0]):\n                            continue\n                        # if (i+dx, j+dy) in visited:\n                        #     continue\n                        if grid[i+dx][j+dy] == 1:\n                            continue\n                        visited.add((i+dx, j+dy))\n                        res = max(res, nums[parent[i, j]] + 1)\n                        extra = 1\n                        temp_visited = set()\n                        for second_direction in directions:\n                            ddx, ddy = second_direction\n                            if i + dx + ddx < 0 or i + dx + ddx >=len(grid) or j + dy + ddy < 0 or j + dy + ddy >= len(grid[0]):\n                                continue\n                            if grid[i+dx+ddx][j+dy+ddy] == 0:\n                                continue\n                            if parent[(i+dx+ddx, j+dy+ddy)] == parent[(i, j)]:\n                                continue\n                            if parent[(i+dx+ddx, j+dy+ddy)] in temp_visited:\n                                continue\n                            else:\n                                extra += nums[parent[i+dx+ddx, j+dy+ddy]]\n                                temp_visited.add(parent[(i+dx+ddx, j+dy+ddy)])\n                        \n                        res = max(res, nums[parent[i, j]] + extra)\n        \n        return res\n        \n        \n    def is_valid(self, grid, pos, parent):\n        x, y = pos\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n            return False\n        if (x, y) in parent:\n            return False\n        if grid[x][y] == 0:\n            return False\n        \n        return True\n                    \n", "\nclass Solution:\n    \n    def largestIsland(self, grid):\n        m, n, largest, areaMap = len(grid), len(grid[0]), 0, {}\n        dirs = [[0,1], [0,-1], [-1,0], [1,0]]\n        def getIsland(cords, cord):\n            if cord[0] < 0 or cord[0] >= m or cord[1] < 0 or cord[1] >= n or not grid[cord[0]][cord[1]]: return\n            if (cord[0], cord[1]) not in cords:\n                cords.add(cord)\n                for dir in dirs: getIsland(cords, (cord[0] + dir[0], cord[1] + dir[1]))\n        # get {(i, j), set()} kind of map for each (i, j) where set includes all (i, j)s in the connected area\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] and (i, j) not in areaMap:\n                    cubes = set()\n                    getIsland(cubes, (i, j))\n                    largest = max(largest, len(cubes))\n                    for c in cubes: areaMap[c] = cubes\n        # traverse again to find any possible gap and walk thru the surrounding areas to find the largest\n        for i in range(m):\n            for j in range(n):\n                if not grid[i][j]:\n                    area, areaSet = 0, set()\n                    for dir in dirs:\n                        if (i + dir[0], j + dir[1]) in areaMap and (i + dir[0], j + dir[1]) not in areaSet:\n                            area += len(areaMap[(i + dir[0], j + dir[1])])\n                            areaSet |= areaMap[(i + dir[0], j + dir[1])]\n                    largest = max(largest, area + 1)\n\n        return largest\n                        \n                        \n                    \n                    \n                        \n                        \n            \n            \n", "class Node:\n    \n    def __init__(self, row, col, parent=None):\n        self.row = row\n        self.col = col\n        self.parent = parent or self\n        self.rank = 0\n        self.size = 1\n    \n    def __eq__(self, other):\n        return other.row == self.row and other.col == self.col\n    \n    def __hash__(self):\n        return hash((self.row, self.col))\n    \n    def __repr__(self):\n        return f\\\"Node: {(self.row,self.col)}, Rank {self.rank}, Size {self.size}\\\"\n\n\nclass UnionFind:\n    def __init__(self):\n        self.count = 0\n        self.rc_to_node = {}\n        self.disjoint_sets=set()\n    \n    def find(self, row, col):\n        \n        val = (row,col)\n        node = self.rc_to_node.get(val)\n        if not node:\n            node = Node(row,col)\n            self.rc_to_node[val] = node\n            self.disjoint_sets.add(node)\n            self.count+=1\n        elif node.parent != node:\n            node.parent = self.find(node.parent.row, node.parent.col)\n        \n        return node.parent\n    \n    def union(self, fr,fc,sr,sc):\n        first = self.find(fr,fc)\n        second = self.find(sr,sc)\n        \n        if first == second:\n            return\n        \n        if first.rank > second.rank:\n            first,second = second, first\n        \n        first.parent = second\n        second.rank+=first.rank == second.rank\n        second.size+=first.size\n        self.disjoint_sets.remove(first)\n        self.count-=1\n        #print(f\\\"{self.disjoint_sets}, {self.rc_to_node}\\\" )\n\n\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \n        direction = [(1,0),(0,1),(-1,0),(0,-1)]\n        mrow,mcol = len(grid), len(grid[0])\n        \n        zero_indexes = []\n        uf = UnionFind()\n        for i, row in enumerate(grid):\n            for j, col in enumerate(row):\n                if not col:\n                    zero_indexes.append((i,j))\n                    continue\n                uf.find(i,j)\n\n                for dr,dc in direction:\n                    r,c = dr+i, dc+j\n                    if 0<=r<mrow and 0<=c<mcol and grid[r][c]:\n                        uf.union(i,j,r,c)\n        \n        max_size = 0\n        for c in uf.disjoint_sets:\n            max_size = max(max_size,c.size)\n        \n        for i,j in zero_indexes:\n            size = 0 \n            parents = set()\n            for dr,dc in direction:\n                r,c = dr+i, dc+j\n                if 0<=r<mrow and 0<=c<mcol and grid[r][c]:\n                    node = uf.find(r,c)\n                    if (node.row,node.col) not in parents:\n                        size+=node.size\n                        parents.add((node.row,node.col))\n            \n            max_size = max(max_size,size+1)\n        \n        return max_size\n                        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution:\n    def largestIsland(self, matrix: List[List[int]]) -> int:\n        def move(r, c):\n            for ri, ci in [[0,1], [1,0], [0,-1], [-1,0]]:\n                rn, cn = r+ri, c+ci\n                if 0 <= rn < len(matrix) and 0 <= cn < len(matrix[0]):\n                    yield rn, cn\n        def dfs(r, c, idx):\n            res = 1\n            matrix[r][c] = idx\n            for rn, cn in move(r, c):\n                if matrix[rn][cn] == 1:\n                    res += dfs(rn, cn, idx)\n            return res\n        res = 0\n        group = 2\n        group_size = {0:0}\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 1:\n                    count = dfs(i, j, group)\n                    group_size[group] = count\n                    res = max(res, count)\n                    group += 1\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    # check adj 4\n                    adjgrp = set(matrix[r][c] for r,c in move(i,j))\n                    res = max(res, sum(group_size[grp] for grp in adjgrp)+1)\n        return res            ", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        if not grid: return 0\n        \n        M, N = len(grid), len(grid[0])\n        size = [0, 0]\n        \n        for i in range(M):\n            for j in range(N):\n                if grid[i][j] == 1:\n                    num = self.dfs(grid, i, j, len(size))\n                    size.append(num)\n                    \n        #print(size)\n        res = 0            \n        for x0 in range(M):\n            for y0 in range(N):\n                if grid[x0][y0] == 0:\n                    tmpSum = 1\n                    tmpClr = set()\n                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        x = x0 + dx\n                        y = y0 + dy\n                        if 0 <= x < M and 0 <= y < N:\n                            tmpClr.add(grid[x][y])\n\n                    for c in tmpClr:\n                        tmpSum += size[c]\n                        \n                    res = max(res, tmpSum)\n                      \n        return res if res > 0 else M*N\n    \n    def dfs(self, grid, x0, y0, clr):\n        grid[x0][y0] = clr\n        res = 1\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            x = x0 + dx\n            y = y0 + dy\n            if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y] == 1:\n                res += self.dfs(grid, x, y, clr)\n                \n        return res\n                    \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        nei = [(0,1),(1,0),(0,-1),(-1,0)]\n        m, n = len(grid), len(grid[0])\n        rec = dict()\n        ans = 0\n        def dfs(grid, i, j, color):\n            cnt = 1\n            grid[i][j] = color\n            for dx, dy in nei:\n                nx, ny = i + dx, j + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    cnt += dfs(grid, nx, ny, color)\n                    \n            return cnt\n        \n        color = 2\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    temp = dfs(grid, i, j, color)\n                    rec[color] = temp\n                    color += 1\n                    ans = max(ans, temp)\n        \n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    visit = set()\n                    for dx, dy in nei:\n                        nx, ny = i + dx, j + dy\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 0:\n                            visit.add(grid[nx][ny])\n                            \n                    ans = max(ans, 1 + sum(rec[i] for i in visit))\n           \n        return ans\n                    \n        \n        \n        \n", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        # Time O(N^2) Space O(N^2)              \n        if not grid or len(grid)==0: return 0\n        nrows= len(grid)\n        ncols= len(grid[0])\n        islandid= 2\n        maxsize= 0\n        idsize= dict()\n        \n        def getIslandSize(grid, r, c, islandid):\n            if not (0<=r<nrows and 0<=c<ncols) or grid[r][c]!=1:\n                return 0\n            grid[r][c]= islandid\n            left= getIslandSize(grid, r, c-1, islandid)\n            right= getIslandSize(grid, r, c+1, islandid)\n            up = getIslandSize(grid, r-1, c, islandid)\n            down= getIslandSize(grid, r+1, c, islandid)\n            \n            return left+right+up+down+1\n        \n        # DFS to assign unique islandid to all existing islands\n        for r in range(nrows):\n            for c in range(ncols):\n                if grid[r][c]==1:\n                    size= getIslandSize(grid, r, c, islandid)\n                    maxsize= max(maxsize, size)\n                    idsize[islandid]= size\n                    islandid+=1\n        \n        \n        # BFS to find if any 0 can be changed to 1 and find maxsize\n        for r in range(nrows):\n            for c in range(ncols):\n                if grid[r][c]==0:\n                    islands= set()\n                    for direction in [[1,0], [0,1], [-1,0], [0,-1]]:\n                        newr= r+direction[0]\n                        newc= c+direction[1]\n                        if 0<=newr<nrows and 0<=newc<ncols and grid[newr][newc]!=0:\n                            islands.add(grid[newr][newc])\n                    sum=1 # converted 0 to 1\n                    for id in islands:\n                        sum+=idsize[id]\n                    maxsize= max(maxsize, sum)\n                    \n        return maxsize\n                    \n#   Only 2 steps:\n\n# Explore every island using DFS, count its area, give it an island index and save the result to a {index: area} map.\n# Loop every cell == 0, check its connected islands and calculate total islands area.\n\n\n                \n        \n    \n", "from collections import defaultdict\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        def dfs(m, n, c_id):\n            nonlocal grid, c_dict\n            stack = [(m, n)]\n            size = 1\n            while stack:\n                i, j = stack.pop()\n                children = [(i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j)]\n                for x, y in children:\n                    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1:\n                        grid[x][y] = c_id\n                        size += 1\n                        stack.append((x, y))\n            c_dict[c_id] = size\n        c_id = 1\n        c_dict = defaultdict(int)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    c_id += 1\n                    grid[i][j] = c_id\n                    dfs(i, j, c_id)\n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0: continue\n                children = [(i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j)]\n                n_c = set()\n                for x, y in children:\n                    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] > 0:\n                        n_c.add(grid[x][y])\n                result = max(result, sum([c_dict[c] for c in n_c]) + 1)\n        return result if result > 0 else len(grid) * len(grid[0])", "class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n\n        def neighbors(r,c):\n            for nr, nc in [(r-1,c),  (r,c-1),(r+1,c),(r,c+1)]:\n                if 0 <= nr < N and 0 <= nc < N:\n                    yield nr,nc\n        \n        \n        def dfs(r,c, index):\n            ans = 1\n            grid[r][c] = index\n            for nr, nc in neighbors(r,c):\n                if grid[nr][nc] == 1:\n                    ans += dfs(nr, nc, index)\n            return ans\n        \n            \n        area = {}\n        index = 2\n        N = len(grid)\n        for r in range(N):\n            for c in range(N):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r,c, index)\n                    index += 1\n        \n        \n        \n        ans = max(area.values() or [0])\n        \n        for r in range(N):\n            for c in range(N):\n                if grid[r][c] == 0:\n                    seen = {grid[nr][nc] for nr,nc in neighbors(r,c) if grid[nr][nc] > 1}\n                    ans = max(ans, 1+sum(area[i] for i in seen))\n                \n        return ans"]
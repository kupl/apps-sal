["class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [0] * len(arr[0])\n        for r, row in enumerate(arr):\n            minNb = min(dp)\n            min1 = dp.index(minNb)\n            dp[min1] = float('inf')\n            min2 = dp.index(min(dp))\n            dp[min1] = minNb\n            \n            for c in range(len(row)):\n                if c != min1:\n                    row[c] += dp[min1]\n                else:\n                    row[c] += dp[min2]\n                #row[c] += min(dp[:c]+dp[c+1:])\n            dp = row[:]\n        return min(dp)", "class Solution(object):\n    def minFallingPathSum(self, arr):\n        \\\"\\\"\\\"\n        :type arr: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        m, n = len(arr), len(arr[0])\n        i = 1\n        while i < m:\n            a = arr[i - 1][:]\n            min1 = a.index(min(a))\n            a[min1] = float('inf')\n            min2 = a.index(min(a))\n            a = arr[i - 1]\n            for j in range(n):\n                if j == min1:\n                    arr[i][j] += a[min2]\n                else:\n                    arr[i][j] += a[min1]\n            i += 1\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1, len(arr)):\n            r = heapq.nsmallest(2, arr[i - 1])\n            for j in range(len(arr[0])):\n                arr[i][j] += r[1] if arr[i - 1][j] == r[0] else r[0]\n        return min(arr[-1])", "import heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        def min_array_except_self(arr):\n            res = arr[:]\n            for i in range(len(res)):\n                prev = arr[0:i]\n                next = arr[i+1:] if i < len(arr)-1 else []\n                res[i] = min(prev + next )\n\n            return res\n            \n            \n        l = len(arr)\n        dp = [[0 for i in range(l)] for j in range(l)]\n        res = inf\n        \n        for j in range(l):\n            dp[0][j] = arr[0][j]\n        \n        mindp = dp[:]\n        mindp[0] = min_array_except_self(dp[0])\n        \n        print(dp, \\\"||\\\", mindp)\n        \n        for i in range(1,l):\n            for j in range(len(dp)):\n                dp[i][j] = arr[i][j] + mindp[i-1][j]\n                if i == l - 1:\n                    res = min(res, dp[i][j])\n\n            mindp[i] = min_array_except_self(dp[i])\n            \n        return res\n                          \n        \n                           \n                         \n        \n       \n        \n        \n # [1,2,3]\n # [4,5,6]\n # [7,8,9]\n\n[[-2,-18,31,-10,-71,82,47,56,-14,42],\n [-95,3,65,-7,64,75,-51,97,-66,-28],\n [36,3,-62,38,15,51,-58,-90,-23,-63],\n [58,-26,-42,-66,21,99,-94,-95,-90,89],\n [83,-66,-42,-45,43,85,51,-86,65,-39],\n [56,9,9,95,-56,-77,-2,20,78,17],\n [78,-13,-55,55,-7,43,-98,-89,38,90],\n [32,44,-47,81,-1,-55,-5,16,-81,17],\n [-87,82,2,86,-88,-58,-91,-79,44,-9],\n [-96,-14,-52,-8,12,38,84,77,-51,52]]\n\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1, n:=len(arr)):\n            for j in range(n):\n                t = min(arr[i-1][0:j] + arr[i-1][j+1:n])\n                arr[i][j] += t\n                \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for row in range(1,len(arr)):\n            for col in range(0, len(arr)):\n                if col == 0:\n                    arr[row][col] += min(arr[row-1][1:])\n                elif col == len(arr)-1:\n                    arr[row][col] += min(arr[row-1][:-1])\n                else:\n                    arr[row][col] += min(arr[row-1][:col] + arr[row-1][col+1:])\n            \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = arr[0][:]\n\n        for i, costs in enumerate(arr[1:], 1):\n            prev = dp[:]\n            \n            for j, cost in enumerate(costs):\n                dp[j] = cost + min(prev[:j] + prev[j+1:])\n\n        return min(dp)\n    \n    \n    \n#         min_path_sum = float('inf')\n        \n#         def get_all_min_paths(arr, cur_row, cur_index, cur_sum):\n#             nonlocal min_path_sum\n#             if cur_row == len(arr):\n#                 # print()\n#                 min_path_sum = min(min_path_sum, cur_sum)\n#             else: \n#                 current_row = arr[cur_row]\n#                 for i in range(len(current_row)):\n#                     if i != cur_index:\n#                         ele = current_row[i]\n#                         # print('cur_value', cur_index, 'ele', ele, 'cur_sum', cur_sum)\n#                         get_all_min_paths(arr, cur_row+1, i, cur_sum+ele)\n            \n#             # pick one of the elements from the next row\n#             # if its valye > cur \n#             # once reached len(arr) add path to array if its sum is \n#             # less than the current minimum \n            \n        \n        \n#         get_all_min_paths(arr, 0, None, 0)\n#         return min_path_sum \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        A=arr\n        n=len(A)\n        for i in range(1,n):\n            for j in range(n):\n                res=A[i-1][0:j]+A[i-1][j+1:n]\n                A[i][j]+=min(res)\n        return min(A[n-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        nRow, nCol = len(arr), len(arr[0])\n        # pathSum = [[0] * col for _ in range(row)] # row-by-col 2D array filled with 0\n        pathSum = arr.copy()\n        \n        for row in range(-2, -nCol - 1, -1): # bottom-to-top\n            for col in range(nCol): # left-to-right\n                pathSum[row][col] += min(pathSum[row + 1][0:col] + pathSum[row + 1][col + 1:])\n        \n        return min(pathSum[0])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                arr[i][j]+=min(arr[i-1][:j]+arr[i-1][j+1:])\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = len(arr)\n        dp = [[0 for x in range(m)] for x in range(m)]\n        \n        for i in range(m):\n            for j in range(m):\n        \n                if i == 0:\n                    dp[i][j] = arr[i][j]\n                   \n                else:\n                    temp = dp[i-1].copy()\n                    temp.pop(j)\n                    dp[i][j] = arr[i][j] + min(temp)\n         \n        return min(dp[m-1])\n        \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        # [[1,2,3],\n        #  [4,5,6],\n        #  [7,8,9]]\n        \n        # do a dp where dp(i,j) returns the minimum path starting from (i,j)\n        \n        if not arr:\n            return 0\n        \n        m = len(arr)\n        n = len(arr[0])\n        INF = float('inf')\n        dp = [[INF]*n for _ in range(m)]\n        \n        dp[-1] = arr[-1]\n        \n        for i in range(m-2,-1,-1):\n            for j in range(n):\n                dp[i][j] = min(dp[i+1][:j]+dp[i+1][j+1:])+arr[i][j]\n        print(dp)\n        return min(dp[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[-100 for _ in range(len(arr[0]))] for _ in range(len(arr))]\n        mi, mis = 100, 100\n        index = -1\n        for j in range(len(arr[0])):\n            dp[0][j] = arr[0][j]\n            if dp[0][j] <= mi:\n                mis = mi\n                mi = dp[0][j]\n                index = j\n            elif dp[0][j] < mis:\n                mia = dp[0][j]\n        candidate = [mi, mis, index]\n        #print(candidate)\n        \n        for i in range(1, len(arr)):\n            nxt = [float(\\\"inf\\\"), float(\\\"inf\\\"), -1]\n            for j in range(len(arr[0])):\n                if j != candidate[2]:\n                    dp[i][j] = candidate[0] + arr[i][j]\n                    \n                else:\n                    dp[i][j] = candidate[1] + arr[i][j]\n                \n                if dp[i][j] <= nxt[0]:\n                    nxt[1] = nxt[0]\n                    nxt[0] = dp[i][j]\n                    nxt[2] = j\n                elif dp[i][j] < nxt[1]:\n                    nxt[1] = dp[i][j]\n            candidate = nxt[:]\n            #print(candidate)\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn)\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors(i, j):\n            a, row_prev[j] = row_prev[j], float('inf')\n            min_val = min(row_prev)\n            row_prev[j] = a\n            return min_val\n        \n        \n        row_prev = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            for col in range(n):\n                cur[col] = get_min_neighbors(row, col) + arr[row][col]\n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            row_prev = cur[:]\n            #print(cur)\n        \n        return global_min", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        for i in range(1, n):\n            for j in range(n):\n                prevmin = min(arr[i-1])\n                temp = arr[i-1][:]\n                temp.remove(prevmin)\n                prevmin2 = min(temp)\n                arr[i][j] += prevmin if prevmin != arr[i-1][j] else prevmin2 \n        return min(arr[n-1])\n", "class Solution:\n    def minFallingPathSum(self, dp: List[List[int]]) -> int:\n        for i in range(1, len(dp)):\n            for j in range(len(dp[i])):\n                dp[i][j] = min(dp[i-1][:j]+dp[i-1][j+1:]) + dp[i][j]\n\n        return min(dp[-1])", "from heapq import nsmallest\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        for i in range(m-1)[::-1]:\n            for j in range(n):\n                ans = nsmallest(2, arr[i+1])\n                arr[i][j] += ans[0] if ans[0]!=arr[i+1][j] else ans[1]\n        return min(arr[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        A = arr\n        n = len(A)\n        dp = [[float('inf') for _ in range(n)] for _ in range(n)]\n        for c in range(n):\n            dp[0][c] = A[0][c]\n        \n        for r in range(1, n):\n            for c in range(n):\n                prev = heapq.nsmallest(2, dp[r - 1])\n                dp[r][c] = A[r][c]\n                dp[r][c] += prev[1] if dp[r - 1][c] == prev[0] else prev[0]\n        \n        return min(dp[n - 1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n        length=len(arr)\n        for i in range(1,length):\n            for j in range(length):\n                if j==0:\n                    arr[i][j]+=min(arr[i-1][j+1:])\n                elif j==len(arr)-1:\n                    arr[i][j]+=min(arr[i-1][:-1])\n                else:\n                    arr[i][j]+=min(arr[i-1][:j]+arr[i-1][j+1:])\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        dp = [[0] * n for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(n):\n                m0, m1 = heapq.nsmallest(2, dp[i - 1])\n                dp[i][j] = arr[i - 1][j] + (m0 if dp[i - 1][j] != m0 else m1)\n                \n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        for i in range(1, m):\n            for j in range(n):\n                m0, m1 = heapq.nsmallest(2, arr[i - 1])\n                arr[i][j] += m0 if arr[i - 1][j] != m0 else m1\n                \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        self.memo = {}\n        if not arr:\n            return 0\n        \n        possible_values = []\n        for column in range(len(arr[0])):\n            possible_values.append(self.visit_row(arr, 0, column))\n            \n        return min(possible_values)\n        \n        \n    def visit_row(self, arr, i, j):\n        if (i, j) in self.memo:\n            return self.memo[(i,j)]\n        # Base case\n        if i == len(arr) - 1:\n            return arr[i][j]\n        val = arr[i][j]\n        possible_values = []\n        prev_val = 999999999999999\n        for k in [i[0] for i in sorted(enumerate(arr[i+ 1]), key=lambda x:x[1])]:\n            if k == j:\n                continue\n            next_val = self.visit_row(arr, i + 1, k)\n            possible_values.append(next_val)\n            if prev_val < next_val:\n                break\n            prev_val = next_val\n        val += min(possible_values)\n        self.memo[(i, j)] = val\n        return val", "# O(mn) time and O(1) space\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        \n        for i in range(1, m):\n            # find two smallest in prev row\n            min1 = 0\n            min2 = 1\n            \n            for j in range(1,n):\n                if arr[i-1][j] < arr[i-1][min1]:\n                    min2 = min1\n                    min1 = j\n                elif arr[i-1][j] < arr[i-1][min2]:\n                    min2 = j\n            \n            # for j in range(n):\n            #     if min1 == None or arr[i-1][min1]  > arr[i-1][j]:\n            #         min2 = min1\n            #         min1 = j\n            #     elif min2 == None or arr[i-1][min2] > arr[i-1][j]:\n            #         min2 = j\n            \n            for j in range(n):\n                if j == min1:\n                    arr[i][j] += arr[i-1][min2]\n                else:\n                    arr[i][j] += arr[i-1][min1]\n        \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        min_path = float(\\\"inf\\\")\n        n = len(arr)\n        m = len(arr[0])\n        for r in range(1, n):\n            min_path = float(\\\"inf\\\")\n            for c in range(0, m):\n                arr[r][c] += sorted(arr[r-1][:c]+arr[r-1][c+1:])[0]\n                min_path = min(min_path, arr[r][c])\n\n        return min_path\n                                \n                                 \n        \n                                 ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        def second_smallest(nums):\n            s1, s2 = float('inf'), float('inf')\n            for num in nums:\n                if num <= s1:\n                    s1, s2 = num, s1\n                elif num < s2:\n                    s2 = num\n            return s2\n        \n        n = len(arr)\n        for i in range(1, n):\n            for j in range(n):\n                prevmin = min(arr[i-1])\n                prevmin2 = second_smallest(arr[i-1])\n                arr[i][j] += prevmin if prevmin != arr[i-1][j] else prevmin2 \n        return min(arr[n-1])\n    \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n        rows, cols = len(arr), len(arr[0])\n        \n        for r in range(1, rows):\n            for c in range(cols):\n                val = float('inf')\n                for x in range(cols):\n                    if arr[r-1][x]<val and x!=c:\n                        val = arr[r-1][x]\n                arr[r][c] += val\n        return min(arr[-1])\n", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, len(cost)):\n            dp = [cost[h][m] + min(dp[prevMat]\n                    for prevMat in range(0, cols)\n                    if prevMat != m)\n                 for m in range(0, cols)]\n\n        return min(dp)", "# O(mn) time and O(1) space\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        \n        for i in range(1, m):\n            min1, min2 = None, None\n            \n            for j in range(n):\n                if min1 == None or arr[i-1][min1]  > arr[i-1][j]:\n                    min2 = min1\n                    min1 = j\n                elif min2 == None or arr[i-1][min2] > arr[i-1][j]:\n                    min2 = j\n            \n            for j in range(n):\n                if j == min1:\n                    arr[i][j] += arr[i-1][min2]\n                else:\n                    arr[i][j] += arr[i-1][min1]\n        \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        pre = arr[0][:]\n        for i in range(1, m):\n            dp = []\n            for j in range(n):\n                dp += [arr[i][j] + min(pre[k] for k in range(n) if k != j)]\n            pre = dp\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, A):\n        m, n = len(A), len(A[0])\n        dp = A[0].copy()\n        for x in range(1, m):\n            tmp = [0] * n\n            for y in range(n):\n                tmp[y] = min(dp[py] for py in range(n) if y != py) + A[x][y]\n            dp, tmp = tmp, dp\n        return min(dp)  ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        \n        temp_array = copy.deepcopy(arr[0])\n        \n        for i in range(1, len(arr)):\n            print(temp_array)\n            temp_array_new = [0]*len(arr)\n            for j in range(0, len(arr)):\n                mins = [temp_array[k] for k in range(len(arr)) if k != j]\n                temp_array_new[j] = min(mins) + arr[i][j]\n            temp_array = copy.deepcopy(temp_array_new)\n            \n        print(temp_array)\n        \n        return min(temp_array)\n", "import numpy as np\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = arr[0]\n        \n        \n        for r in range(1, len(arr)):\n            new_dp = [i for i in dp]\n            for c in range(len(arr)):\n                lst = [dp[j] for j in range(len(arr)) if j != c]\n                \n                new_dp[c] = min(lst)+arr[r][c]\n            dp = new_dp\n        return int(min(dp))\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        while len(arr) > 1:\n            bottom = arr.pop()\n            for i in range(len(arr[-1])):\n                arr[-1][i] += min(el for j, el in enumerate(bottom) if i != j)\n            \n        return min(arr[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        cumSum = [[0 for j in range(len(arr[0]) + 1)] for i in range(len(arr)+1)]\n        for i in range(len(arr)):\n            for j in range(len(arr[0])):\n                cumSum[i+1][j+1] = arr[i][j] + cumSum[i+1][j] + cumSum[i][j+1] - cumSum[i][j]\n\n        dp = [arr[i] for i in range(len(arr))]\n        for i in range(1,len(dp)):\n            for j in range(len(dp[0])):\n                i1, j1 = i+1, j+1\n                aboveDP = min([x for c,x in enumerate(dp[i-1]) if c != j])\n                dp[i][j] = cumSum[i1][j1] - cumSum[i][j1] - cumSum[i1][j] + cumSum[i][j] + aboveDP\n\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr or not arr[0]:\n            raise ValueError(\\\"empty input.\\\")\n        \n        m = len(arr) # row\n        n = len(arr[0]) # col\n        dp = list(arr[0]) # start with first row.\n        \n        for row in arr[1:]:\n            dp_new = [0] * n\n            for i in range(n):\n                dp_new[i] = row[i] + min([x for i_prev, x in enumerate(dp) if i != i_prev])\n            dp = dp_new\n            \n        return min(dp_new)", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        \n        numHouses = len(cost)\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, numHouses):\n            newRow = [0 for _ in range(cols)]\n            for m in range(0, cols):\n                prevCost = min(dp[prevMat]\n                    for prevMat in range(0, cols)\n                    if prevMat != m)\n                newRow[m] = (cost[h][m] + prevCost)\n            dp = newRow\n\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        cumSum = [[0 for j in range(len(arr[0]) + 1)] for i in range(len(arr)+1)]\n        for i in range(len(arr)):\n            for j in range(len(arr[0])):\n                cumSum[i+1][j+1] = arr[i][j] + cumSum[i+1][j] + cumSum[i][j+1] - cumSum[i][j]\n\n        dp = [arr[i] for i in range(len(arr))]\n        for i in range(1,len(dp)):\n            for j in range(len(dp[0])):\n                csR, csC = i+1, j+1\n                leftR, leftC = i, j+1\n                topR, topC = i+1, j\n                addR, addC = i, j\n                aboveDP = min([x for c,x in enumerate(dp[i-1]) if c != j])\n                dp[i][j] = cumSum[csR][csC] - cumSum[leftR][leftC] - cumSum[topR][topC] + cumSum[addR][addC] + aboveDP\n\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m=len(arr)\n        print(m)\n        if m==1:\n            return min(arr[0])\n        dp=[[0 for x in range(m)]for x in range(m)]\n        for i in range(m):\n            for j in range(m):\n                if i==0:\n                    dp[i][j]=arr[i][j]\n                else:\n                    minn=1000\n                    for k in range(0,m):\n                        if k!=j and dp[i-1][k]<minn:\n                            minn=dp[i-1][k]\n                    dp[i][j]=minn+arr[i][j]\n        print(dp)\n        return min(dp[m-1])", "import heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        while len(arr) > 1:\n            row = arr.pop()\n            heap = []\n        \n            for i in range(len(row)):\n                if not heap:\n                    heap = [row[x] for x in range(len(row)) if x != i]\n                    heapq.heapify(heap)\n                \n                else:\n                    if heap[0] == row[i]:\n                        heapq.heappop(heap)\n                    heapq.heappush(heap, row[i-1])\n                    \n                arr[-1][i] += heap[0]\n        \n        return min(arr[0])", "\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        R,C = len(arr), len(arr[0])\n        \n        DP = [[float(\\\"inf\\\")]*C for i in range(R)]\n        \n        #fill the 1st row with same values:\n        for j in range(C):\n            DP[0][j]=arr[0][j]\n        \n        for i in range(1,R):\n            for j in range(C):\n                #if left edge--> then nothing on left\n                if(j==0):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j+1,C))\n                \n                #if right edge--> then nothing on right\n                elif(j==C-1):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j-1,-1,-1))\n                    \n                #else--> both from left & right\n                else:\n                    left = min(DP[i-1][k] for k in range(0,j))\n                    right = min(DP[i-1][k] for k in range(j+1,C))\n                    DP[i][j] = min(left+arr[i][j],right+arr[i][j])\n        \n        return min(DP[R-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        R,C = len(arr), len(arr[0])\n        \n        DP = [[float(\\\"inf\\\")]*C for i in range(R)]\n        \n        #fill the 1st row with same values:\n        for j in range(C):\n            DP[0][j]=arr[0][j]\n        \n        for i in range(1,R):\n            for j in range(C):\n                #if left edge--> then nothing on left\n                if(j==0):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j+1,C))\n                \n                #if right edge--> then nothing on right\n                elif(j==C-1):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j-1,-1,-1))\n                    \n                #else--> both from left & right\n                else:\n                    left = min(DP[i-1][k] for k in range(0,j))\n                    right = min(DP[i-1][k] for k in range(j+1,C))\n                    DP[i][j] = min(left+arr[i][j],right+arr[i][j])\n        \n        return min(DP[R-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        R,C = len(arr), len(arr[0])\n        \n        DP = [[float(\\\"inf\\\")]*C for i in range(R)]\n        \n        #fill the 1st row with same values:\n        for j in range(C):\n            DP[0][j]=arr[0][j]\n        \n        for i in range(1,R):\n            for j in range(C):\n                #if left edge--> then nothing on left\n                if(j==0):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j+1,C))\n                \n                #if right edge--> then nothing on right\n                elif(j==C-1):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j-1,-1,-1))\n                    \n                #else--> both from left & right\n                else:\n                    left = min(DP[i-1][k] for k in range(0,j))\n                    right = min(DP[i-1][k] for k in range(j+1,C))\n                    DP[i][j] = min(left+arr[i][j],right+arr[i][j])\n        \n        return min(DP[R-1])\n        \n        ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        R,C = len(arr), len(arr[0])\n        \n        DP = [[float(\\\"inf\\\")]*C for i in range(R)]\n        \n        #fill the 1st row with same values:\n        for j in range(C):\n            DP[0][j]=arr[0][j]\n        \n        for i in range(1,R):\n            for j in range(C):\n                #if left edge--> then nothing on left\n                if(j==0):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j+1,C))\n                \n                #if right edge--> then nothing on right\n                elif(j==C-1):\n                    DP[i][j] = min(arr[i][j]+DP[i-1][k] for k in range(j-1,-1,-1))\n                    \n                #else--> both from left & right\n                else:\n                    left = min(DP[i-1][k] for k in range(0,j))\n                    right = min(DP[i-1][k] for k in range(j+1,C))\n                    DP[i][j] = min(left+arr[i][j],right+arr[i][j])\n        \n        return min(DP[R-1])\n        ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        \n        for i in range(1, len(arr)):\n            for j in range(len(arr[0])):\n                \n                curr_min = float(\\\"inf\\\")\n                #need a for loop to try all directions.\n                for k in range(len(arr[0])):                    \n                    if k == j:\n                        continue\n                                        \n                    if arr[i - 1][k] < curr_min:\n                        curr_min = arr[i - 1][k]\n                \n                arr[i][j] += curr_min\n                \n                \n        return min(arr[-1])\n\n    ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(len(arr)-2, -1, -1):\n            a = sorted([arr[i+1][j], j] for j in range(len(arr[0])))\n            for j in range(len(arr[0])):\n                for v, idx in a:\n                    if idx != j:\n                        arr[i][j] += v\n                        break\n        return min(arr[0])", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        \n        numHouses = len(cost)\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, numHouses):\n            newRow = [0 for _ in range(cols)]\n            for m in range(0, cols):\n                prevCost = min([dp[prevMat]\n                    for prevMat in range(0, cols)\n                    if prevMat != m])\n                newRow[m] = (cost[h][m] + prevCost)\n            dp = newRow\n\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp_mtx = [[0] * len(arr[0]) for _ in range(len(arr))]\n        \n        for i in range(len(arr)):\n            for j in range(len(arr[0])):\n                if i == 0:\n                    dp_mtx[i][j] = arr[i][j]\n                else:\n                    dp_mtx[i][j] = arr[i][j] + min(dp_mtx[i - 1][k] for k in range(len(arr[0])) if k != j)\n        \n        return min(dp_mtx[len(arr) - 1])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        for i in range(1, n): # for each row after the first\n            for j in range(n): # for each col\n                # collect the non-adjacent cols in the prev row\n                prevNonAdj = [arr[i-1][k] for k in range(n) if k != j]\n                # add the min of the prev non-adj cols to the curr col\n                # since modifying arr directly, sum accumulates\n                arr[i][j] += min(prevNonAdj)\n        return min(arr[n-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp_mtx = [[0] * len(arr[0]) for _ in range(len(arr))]\n        \n        for i in range(len(arr)):\n            for j in range(len(arr[0])):\n                if i == 0:\n                    dp_mtx[i][j] = arr[i][j]\n                else:\n                    dp_mtx[i][j] = arr[i][j] + min(dp_mtx[i - 1][k] for k in range(len(arr[0])) if k != j)\n                                \n        for i in range(len(dp_mtx)):\n            print(dp_mtx[i])\n        \n        return min(dp_mtx[len(arr) - 1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[float('inf')] + i + [float('inf')] for i in arr]\n        for i in range(1,len(dp)):\n            for j in range(1,len(dp[0])-1):\n                dp[i][j] = dp[i][j] + min([dp[i-1][k] for k in range(len(dp[i-1])) if k != j])\n                \n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        for i in range(m-1)[::-1]:\n            for j in range(n):\n                arr[i][j] += min(arr[i+1][k] for k in range(n) if k != j)\n        return min(arr[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        dp1 = [None for i in range(n)]\n        for i in range(0,n):\n            dp1[i] = arr[0][i]\n        for i in range(1,n):\n            dp2 = [None for i in range(n)]\n            for j in range(0,n):\n                minList = []\n                for k in range(0,n):\n                    if k == j:\n                        continue\n                    minList.append(dp1[k])\n                dp2[j] = min(minList)+arr[i][j]\n            dp1 = dp2\n        return min(dp2)\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = len(arr)\n        n = len(arr[0])\n        \n        for i in range(1, m):\n            for j in range(0, n):\n                arr[i][j] += min([arr[i-1][k] for k in range(0, n) if k != j])\n        return min(arr[-1])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        m, n = len(arr), len(arr[0])\n        \n        dp = [[float('inf')] * n for _ in range(m)]\n        \n        \n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[0][j] = arr[0][j]\n                else:\n                    dp[i][j] = arr[i][j] + min(dp[i-1][x] for x in range(n) if x != j)\n                    \n        return min(dp[-1])\n                \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n        m, n = len(arr), len(arr[0])\n        for i in range(1, m):\n            for j in range(n):\n                arr[i][j] = min([arr[i-1][col] for col in range(n) if col != j])+arr[i][j]\n        \n        return min(arr[-1])", "\nclass Solution(object):\n    def minFallingPathSum(self, a):\n        \\\"\\\"\\\"\n        :type arr: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n=len(a)\n        if(n==1):\n            return a[0][0]\n        dp=[[0 for i in range(n)]for j in range(n)]\n        pos1=-1\n        pos2=-1\n        for i in range(n):\n            print(pos1,pos2)\n            for j in range(n):\n                dp[i][j]=a[i][j]\n                if i==0:\n                    continue\n                if j==pos1:\n                    dp[i][j]+=dp[i-1][pos2]\n                else:\n                    dp[i][j]+=dp[i-1][pos1]\n            pos1=0\n            pos2=1\n            if dp[i][0]>dp[i][1]:\n                pos1,pos2=pos2,pos1\n            for j in range(2,n):\n                if dp[i][j]<dp[i][pos1]:\n                    pos2=pos1\n                    pos1=j\n                elif dp[i][j]<dp[i][pos2]:\n                    pos2=j\n        print(dp)      \n        return dp[-1][pos1]", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0] = arr[0]\n        for i in range(1, m):\n            for j in range(n):\n                dp[i][j] = min([dp[i-1][k] for k in range(n) if k != j]) + arr[i][j]\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = arr[:]\n        m, n = len(arr), len(arr[0])\n        for i in range(1, m):\n            for j in range(n):\n                dp[i][j] = arr[i][j] + min(dp[i - 1][k] for k in range(n) if k != j)\n        return min(dp[-1])", "import heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n       \n        l = len(arr)\n        dp = [[0 for i in range(l)] for j in range(l)]\n        res = inf\n    \n        for j in range(l):\n            dp[0][j] = arr[0][j]\n        \n        print(dp)\n        \n        for i in range(1,l):\n            for j in range(len(dp)):\n                minr = min([dp[i-1][k] for k in range(l) if k != j])\n                dp[i][j] = arr[i][j] + minr\n                if i == l - 1:\n                    res = min(res, dp[i][j])\n        \n        return res\n                          \n        \n                           \n                         \n        \n       \n        \n        \n # [1,2,3]\n # [4,5,6]\n # [7,8,9]\n\n[[-2,-18,31,-10,-71,82,47,56,-14,42],\n [-95,3,65,-7,64,75,-51,97,-66,-28],\n [36,3,-62,38,15,51,-58,-90,-23,-63],\n [58,-26,-42,-66,21,99,-94,-95,-90,89],\n [83,-66,-42,-45,43,85,51,-86,65,-39],\n [56,9,9,95,-56,-77,-2,20,78,17],\n [78,-13,-55,55,-7,43,-98,-89,38,90],\n [32,44,-47,81,-1,-55,-5,16,-81,17],\n [-87,82,2,86,-88,-58,-91,-79,44,-9],\n [-96,-14,-52,-8,12,38,84,77,-51,52]]\n\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = len(arr)\n        n = len(arr[0])\n        dp = [[0]*n for i in range(m)]\n\n        for j in range(n):\n            dp[0][j] = arr[0][j]\n\n        for i in range(1,m):\n            for j in range(n):\n                dp[i][j] = min([dp[i-1][k] for k in range(n) if k!=j]) + arr[i][j]\n\n        return min(dp[m-1])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        R = len(arr)\n        C = len(arr[0])\n        \n        dp = [[float('inf') for j in range(C)] for i in range(R)]\n        \n        for i in range(C):\n            dp[0][i] = arr[0][i]\n            \n        for r in range(1,R):\n            for c in range(C):\n                dp[r][c] = arr[r][c] + min(dp[r-1][k] if k!=c else float('inf') for k in range(C))\n                \n        return min(dp[R-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n        m, n = len(arr), len(arr[0])\n        dp = [[float('inf')]*n for _ in range(m)]\n        dp[0] = arr[0]\n        for i in range(1, m):\n            for j in range(n):\n                dp[i][j] = min([dp[i-1][col] for col in range(n) if col != j])+arr[i][j]\n        \n        return min(dp[-1])", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, len(cost)):\n            for m in range(0, cols):\n                cost[h][m] += min(cost[h-1][prevMat]\n                        for prevMat in range(0, cols)\n                        if prevMat != m)\n                 \n\n        return min(cost[-1])", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        for i in range(len(A)-1):\n            x = [0 for _ in A]\n            for j in range(len(A)):\n                ls = []\n                for k in range(len(A)):\n                    if not j==k:\n                        ls.append(A[0][k])\n                        \n                x[j] = A[i+1][j]+min(ls)\n                \n            A[0] = x\n                \n        return min(A[0])", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        \n        numHouses = len(cost)\n        numMaterials = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, numHouses):\n            newRow = [0 for _ in range(numMaterials)]\n            for m in range(1, numMaterials+1):\n                prevCost = min([dp[prevMat-1]\n                    for prevMat in range(1, numMaterials+1)\n                    if prevMat != m])\n                newRow[m-1] = (cost[h][m-1] + prevCost)\n            dp = newRow\n\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        memo = {}\n        return self.helper(0,None,arr,memo)\n        \n    def helper(self,index,notAllowed,arr,memo):\n        if (index == len(arr)):\n            return 0\n        elif (index,notAllowed) in memo:\n            return memo[(index,notAllowed)]\n        else:\n            maxOne,maxTwo = self.getMaxTwo(notAllowed,arr[index])\n            useOne = arr[index][maxOne] + self.helper(index + 1,maxOne,arr,memo)\n            useTwo = arr[index][maxTwo] + self.helper(index + 1,maxTwo,arr,memo)\n            res = min(useOne,useTwo)\n            memo[(index,notAllowed)] = res\n            return res\n                \n    def getMaxTwo(self,blocked,arr):\n        minOne = None\n        minIndex = None\n        for i in range (len(arr)):\n            if (i == blocked):\n                continue\n            else:\n                curr_num = arr[i]\n                if (minOne == None) or (curr_num < minOne):\n                    minOne = curr_num\n                    minIndex = i\n        minTwo = None\n        minIndexTwo = None\n        for j in range (len(arr)):\n            if (j == blocked) or (j == minIndex):\n                continue\n            else:\n                curr_num = arr[j]\n                if (minTwo == None) or (curr_num < minTwo):\n                    minTwo = curr_num\n                    minIndexTwo = j\n        return minIndex,minIndexTwo\n        \n", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        \n        numHouses = len(cost)\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, numHouses):\n            newRow = [0 for _ in range(cols)]\n            for m in range(0, cols):\n                newRow[m] = cost[h][m] + min(dp[prevMat]\n                    for prevMat in range(0, cols)\n                    if prevMat != m)\n            dp = newRow\n\n        return min(dp)", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        \n        numHouses = len(cost)\n        numMaterials = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, numHouses):\n            newRow = []\n            for m in range(1, numMaterials+1):\n                prevCost = min([dp[prevMat-1]\n                    for prevMat in range(1, numMaterials+1)\n                    if prevMat != m])\n                newRow.append(cost[h][m-1] + prevCost)\n            dp = newRow\n\n        return min(dp)", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        dp = [cost[0]]\n        numHouses = len(cost)\n        numMaterials = len(cost[0])\n\n        for h in range(1, numHouses):\n            newRow = []\n            for m in range(1, numMaterials+1):\n                prevCost = min([dp[-1][prevMat-1]\n                    for prevMat in range(1, numMaterials+1)\n                    if prevMat != m])\n                newRow.append(cost[h][m-1] + prevCost)\n            dp.append(newRow)\n\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                above = set()\n                for k in range(len(arr[0])):\n                    if k!=j:\n                        above.add(arr[i-1][k])\n                #print(above)\n                arr[i][j] = arr[i][j] + min(above)\n        \n        #for row in arr:\n            #print(row)\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, A):\n        m, n = len(A), len(A[0])\n        dp = A[0].copy()\n        for x in range(1, m):\n            tmp = [0] * n\n            for y in range(n):\n                tmp[y] = min(dp[py] + A[x][y] for py in range(n) if y != py )\n            dp, tmp = tmp, dp\n        return min(dp)  ", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        \n        numHouses = len(cost)\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, numHouses):\n            newRow = [0 for _ in range(cols)]\n            for m in range(1, cols+1):\n                prevCost = min([dp[prevMat-1]\n                    for prevMat in range(1, cols+1)\n                    if prevMat != m])\n                newRow[m-1] = (cost[h][m-1] + prevCost)\n            dp = newRow\n\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [arr[i] for i in range(len(arr))]\n    \n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                opts = [ (arr[i][j]+x) for c,x in enumerate(arr[i-1]) if c != j]\n                dp[i][j] = min(opts)\n        return min(dp[-1])", "import heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        def min_array_except_self(arr):\n            res = arr[:]\n            for i in range(len(res)):\n                prev = arr[0:i]\n                next = arr[i+1:] if i < len(arr)-1 else []\n                res[i] = min(prev + next )\n\n            return res\n            \n            \n        l = len(arr)\n        dp = [[0 for i in range(l)] for j in range(l)]\n        res = inf\n        \n        for j in range(l):\n            dp[0][j] = arr[0][j]\n        \n        mindp = dp[:]\n        mindp[0] = min_array_except_self(dp[0])\n        \n        print(dp, \\\"||\\\", mindp)\n        \n        for i in range(1,l):\n            for j in range(len(dp)):\n                minr = min([dp[i-1][k] for k in range(l) if k != j])\n                dp[i][j] = arr[i][j] + minr\n                if i == l - 1:\n                    res = min(res, dp[i][j])\n\n            mindp[i] = min_array_except_self(dp[i])\n            \n        return res\n                          \n        \n                           \n                         \n        \n       \n        \n        \n # [1,2,3]\n # [4,5,6]\n # [7,8,9]\n\n[[-2,-18,31,-10,-71,82,47,56,-14,42],\n [-95,3,65,-7,64,75,-51,97,-66,-28],\n [36,3,-62,38,15,51,-58,-90,-23,-63],\n [58,-26,-42,-66,21,99,-94,-95,-90,89],\n [83,-66,-42,-45,43,85,51,-86,65,-39],\n [56,9,9,95,-56,-77,-2,20,78,17],\n [78,-13,-55,55,-7,43,-98,-89,38,90],\n [32,44,-47,81,-1,-55,-5,16,-81,17],\n [-87,82,2,86,-88,-58,-91,-79,44,-9],\n [-96,-14,-52,-8,12,38,84,77,-51,52]]\n\n", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        costs = [[None for i in range(len(A))] for j in range(len(A[0]))]\n        \n        for j in range(len(A)):\n            costs[0] = A[0]\n        \n        for i in range(1, len(A)):\n            for j in range(len(A)):\n                parents = list()\n                for p in range(len(A)):\n                    if p != j:\n                        parents.append(costs[i-1][p])\n                \n                costs[i][j] = min(parents) + A[i][j]\n        \n        return min(costs[len(A)-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        T = [[0 for _ in range(len(arr))] for _ in range(len(arr))]\n        T[0] = arr[0]\n        for i in range(1, len(arr)):\n            for j in range(len(arr)):\n                T[i][j] = arr[i][j] + min([T[i-1][c] for c in range(len(arr)) if c != j])\n        return min(T[-1])", "import heapq as pq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        rows = len(arr)\n        cols = len(arr[0])\n        \n        # Find first min, the 2nd min\n        min_vals = []\n        for i in range(cols):\n            pq.heappush(min_vals, (arr[0][i], i))\n\n        min_vals = pq.nsmallest(2, min_vals)\n        \n        for i in range(1, cols):\n            # print(min_vals)\n            \n            new_min_vals = []\n            (min_val2, _) = min_vals.pop()\n            (min_val, min_col) = min_vals.pop()\n            for col in range(cols):\n                arr[i][col] += min_val if min_col != col else min_val2\n                pq.heappush(new_min_vals, (arr[i][col], col))\n            min_vals = pq.nsmallest(2, new_min_vals)\n            # print(i, arr)\n        return min(arr[-1])", "\\\"\\\"\\\"\n\n\ndp[r][c] = the minimum sum of falling int to row r and column c\n\ndp[r][c] = arr[r][c] + min(dp[r-1][pc] for all pc != c)\n\n\\\"\\\"\\\"\n\n\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        rows = len(arr)\n        cols = len(arr[0])\n        infi = float('inf')\n        dp = [[infi]*cols for _ in range(rows)]\n        for c in range(cols):\n            dp[0][c] = arr[0][c]\n            \n        for r in range(1, rows):\n            for c in range(cols):\n                dp[r][c] = arr[r][c] + min(dp[r-1][pc] for pc in range(cols) if pc != c)\n        return min(dp[-1])    \n                    ", "\\\"\\\"\\\"\n\n\ndp[r][c] = the minimum sum of falling int to row r and column c\n\ndp[r][c] = arr[r][c] + min(dp[r-1][pc] for all pc != c)\n\n\\\"\\\"\\\"\n\n\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        rows = len(arr)\n        cols = len(arr[0])\n        infi = float('inf')\n        dp = [[infi]*cols for _ in range(rows)]\n        for c in range(cols):\n            dp[0][c] = arr[0][c]\n            \n        for r in range(1, rows):\n            for c in range(cols):\n                dp[r][c] = arr[r][c] + min(dp[r-1][pc] for pc in range(cols) if pc != c)\n        print(dp)                \n        return min(dp[-1])    \n                    ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[0] * len(arr[0]) for _ in arr]\n        \n        for i in range(len(arr)):\n            if i == 0:\n                dp[i] = arr[i]\n            else:\n                for j in range(len(arr[0])):\n                    dp[i][j] = self.min_exclude(dp[i - 1], j) + arr[i][j]\n                    \n        return min(dp[-1])\n                  \n                \n    def min_exclude(self, array, exclude):\n        if len(array) == 0:\n            return None\n        out = float('inf')\n        for i in range(len(array)):\n            if i != exclude:\n                out = min(out, array[i])\n        return out\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        A = arr\n        for i in range(1, len(A)):\n            for j in range(len(A[0])):\n                if j==0:\n                    A[i][j] += min([A[i-1][j] for j in range(1, len(A))])\n                elif j == len(A[0])-1:\n                    A[i][j] += min([A[i-1][j] for j in range(0, len(A)-1)])\n                else:\n                    A[i][j] += min([A[i-1][j] for j in [x for x in range(len(A)) if x !=j]])\n            \n        return min(A[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        m=len(arr)\n        \n        for i in range(1,m):\n            for j in range(m):\n                res=float('inf')\n                for x in range(m):\n                    if x!=j:\n                        if arr[i][j]+arr[i-1][x]<res:\n                            res=arr[i][j]+arr[i-1][x]\n                arr[i][j]=res\n                    \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        dp = [[None for i in range(n)] for i in range(n)]\n        for i in range(0,n):\n            dp[0][i] = arr[0][i]\n        for i in range(1,n):\n            for j in range(0,n):\n                minList = []\n                for k in range(0,n):\n                    if k == j:\n                        continue\n                    minList.append(dp[i-1][k])\n                dp[i][j] = min(minList)+arr[i][j]\n        return min(dp[n-1])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        # brute force recursive solution (TLE)\n        # answer = float(\\\"inf\\\")\n        # def helper(rowIdx, prevIdx, curr): \n        #     nonlocal answer\n        #     if rowIdx == len(arr):\n        #         answer = min(answer, sum(curr))\n        #         return\n        #     row = arr[rowIdx]\n        #     for i in range(len(row)):\n        #         if rowIdx != 0 and i != prevIdx:\n        #             curr.append(row[i])\n        #             helper(rowIdx+1, i, curr)\n        #             curr.pop()\n        #         elif rowIdx == 0: \n        #             curr.append(row[i])\n        #             helper(rowIdx+1, i, curr)\n        #             curr.pop()        \n        # helper(0, 0, [])\n        # return answer\n        \n        # bottom-up DP solution\n        dp = [[0 for _ in range(len(arr))] for _ in range(len(arr[0]))]\n        for i in range(len(dp)):\n            dp[0][i] = arr[0][i]\n        \n        for i in range(1, len(dp)):\n            for j in range(len(dp[i])):\n                if j == 0: # left edge\n                    dp[i][j] = min(arr[i][j] + dp[i-1][k] for k in range(1, len(dp[i])))\n                elif j == len(dp[i])-1: # right edge\n                    dp[i][j] = min(arr[i][j] + dp[i-1][k] for k in range(len(dp[i])-1))\n                else: # in between \n                    left_max = min(arr[i][j] + dp[i-1][k] for k in range(j))\n                    right_max = min(arr[i][j] + dp[i-1][k] for k in range(j+1, len(dp[i])))\n                    dp[i][j] = min(left_max, right_max)\n    \n        return min(dp[-1])\n\n\n        \n                \n                \n                \n                \n        \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        m=len(arr)\n        \n        for i in range(1,m):\n            for j in range(m):\n                res=float('inf')\n                for x in range(m):\n                    val=arr[i][j]+arr[i-1][x]\n                    if x!=j and val<res:\n                        res=val\n                arr[i][j]=res\n                    \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        for each column, we can either choose or not choose\n        if we choose one, then the adjacent rows cannot choose the same column\n                                    []\n                             1       2       3 \n                        \n                          5   6    4   6    4   5\n                       \n                       7   9 7  8 \n        \\\"\\\"\\\"\n        # brute force recursive solution\n        # answer = float(\\\"inf\\\")\n        # def helper(rowIdx, prevIdx, curr): \n        #     nonlocal answer\n        #     if rowIdx == len(arr):\n        #         answer = min(answer, sum(curr))\n        #         return\n        #     row = arr[rowIdx]\n        #     for i in range(len(row)):\n        #         if rowIdx != 0 and i != prevIdx:\n        #             curr.append(row[i])\n        #             helper(rowIdx+1, i, curr)\n        #             curr.pop()\n        #         elif rowIdx == 0: \n        #             curr.append(row[i])\n        #             helper(rowIdx+1, i, curr)\n        #             curr.pop()        \n        # helper(0, 0, [])\n        # return answer\n        \n        dp = [[0 for _ in range(len(arr))] for _ in range(len(arr[0]))]\n        for i in range(len(dp)):\n            dp[0][i] = arr[0][i]\n        \n        for i in range(1, len(dp)):\n            for j in range(len(dp[i])):\n                if j == 0: # left edge\n                    dp[i][j] = min(arr[i][j] + dp[i-1][k] for k in range(1, len(dp[i])))\n                elif j == len(dp[i])-1: # right edge\n                    dp[i][j] = min(arr[i][j] + dp[i-1][k] for k in range(len(dp[i])-1))\n                else: # in between \n                    left_max = min(arr[i][j] + dp[i-1][k] for k in range(j))\n                    right_max = min(arr[i][j] + dp[i-1][k] for k in range(j+1, len(dp[i])))\n                    dp[i][j] = min(left_max, right_max)\n    \n        return min(dp[-1])\n\n\n        \n                \n                \n                \n                \n        \n        ", "from heapq import nsmallest\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[0] * len(arr[0]) for _ in range(len(arr))]\n        dp[0] = arr[0]\n        for i in range(1, len(arr)):\n            min1, min2 = nsmallest(2, arr[i - 1])\n            for j in range(len(arr[0])):\n                if arr[i - 1][j] == min1:\n                    arr[i][j] += min2\n                else:\n                    arr[i][j] += min1\n        return min(arr[-1])\n                \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        # brute force recursive solution\n        # answer = float(\\\"inf\\\")\n        # def helper(rowIdx, prevIdx, curr): \n        #     nonlocal answer\n        #     if rowIdx == len(arr):\n        #         answer = min(answer, sum(curr))\n        #         return\n        #     row = arr[rowIdx]\n        #     for i in range(len(row)):\n        #         if rowIdx != 0 and i != prevIdx:\n        #             curr.append(row[i])\n        #             helper(rowIdx+1, i, curr)\n        #             curr.pop()\n        #         elif rowIdx == 0: \n        #             curr.append(row[i])\n        #             helper(rowIdx+1, i, curr)\n        #             curr.pop()        \n        # helper(0, 0, [])\n        # return answer\n        \n        # bottom-up DP solution\n        dp = [[0 for _ in range(len(arr))] for _ in range(len(arr[0]))]\n        for i in range(len(dp)):\n            dp[0][i] = arr[0][i]\n        \n        for i in range(1, len(dp)):\n            for j in range(len(dp[i])):\n                if j == 0: # left edge\n                    dp[i][j] = min(arr[i][j] + dp[i-1][k] for k in range(1, len(dp[i])))\n                elif j == len(dp[i])-1: # right edge\n                    dp[i][j] = min(arr[i][j] + dp[i-1][k] for k in range(len(dp[i])-1))\n                else: # in between \n                    left_max = min(arr[i][j] + dp[i-1][k] for k in range(j))\n                    right_max = min(arr[i][j] + dp[i-1][k] for k in range(j+1, len(dp[i])))\n                    dp[i][j] = min(left_max, right_max)\n    \n        return min(dp[-1])\n\n\n        \n                \n                \n                \n                \n        \n", "from functools import lru_cache\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n        \n        cols = set(range(len(arr[0])))\n        \n        @lru_cache(maxsize=None)\n        def path_sum(row, col):\n            ret = arr[row][col]\n            if row == len(arr) - 1:\n                return ret\n            \n            other_cols = cols - {col}\n            ret += min(path_sum(row+1,_) for _ in other_cols)\n            return ret\n        \n        return min(path_sum(0, _) for _ in cols)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[0 for _ in range(len(arr[0]))] for _ in range(len(arr))]\n        for i in range(len(dp[0])):\n            dp[0][i] = arr[0][i]\n            \n        for i in range(1, len(dp)):\n            for j in range(len(dp[0])):\n                mi = -1\n                for k in range(len(dp[0])):\n                    if not j == k:\n                        if mi == -1 or dp[i-1][k] + arr[i][j] < mi:\n                            mi = dp[i-1][k] + arr[i][j]\n                dp[i][j] = mi\n        \n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[0] * len(arr[0]) for _ in range(len(arr))]\n        dp[0] = arr[0][:]\n        for i in range(1, len(arr)):\n            for j in range(len(arr[0])):\n                dp[i][j] = min([arr[i][j] + dp[i-1][k] for k in range(len(arr[0])) if k != j])\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        @functools.lru_cache(None)\n        def dp(i, j):\n            if i == 0: \n                return arr[0][j]\n            if i == len(arr): \n                return min(dp(i-1, k) for k in range(len(arr[0])))\n            return arr[i][j] + min(dp(i-1, k) for k in range(len(arr[0])) if k!=j)\n        return dp(len(arr), -1)  ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        @functools.lru_cache(None)\n        def dp(i, j):\n            if i == 0: return arr[0][j]\n            return arr[i][j] + min(dp(i-1, k) for k in range(len(arr[0])) if k!=j)\n        return min(dp(len(arr)-1, i) for i in range(len(arr[0])))", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        total = 0\n        for row in range(len(arr)-1):\n            row1_min, row2_min = min(arr[row]), min(arr[row+1])\n            i1, i2 = arr[row].index(row1_min), arr[row+1].index(row2_min)\n            if i1 != i2:\n                total += row1_min\n            else:\n                total = False\n                break\n        if total:\n            return total + min(arr[-1])\n        dp = [[arr[j][i] if j == 0 else float('inf') for i in range(len(arr))] for j in range(len(arr))]\n        for row in range(len(arr)-1):\n            for col in range(len(arr[row])):\n                for next_col in range(len(arr[row])):\n                    if next_col != col:\n                        dp[row+1][next_col] = min(dp[row+1][next_col], dp[row][col] + arr[row+1][next_col])\n        return min(dp[len(arr)-1])", "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        \n        @lru_cache(None)\n        def helper(r, c):\n            if r == m:\n                return 0\n            return arr[r][c] + min(helper(r + 1, nc) for nc in range(n) if nc != c)\n        \n        return min(helper(0, c) for c in range(n))", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        if n == 1:\n            return arr[0][0]\n        firstRow = arr[0]\n        srow = sorted([(num, idx) for idx, num in enumerate(firstRow)])\n        cand1, cand2 = srow[0], srow[1]\n        for row in arr[1:]:\n            srow = sorted([(num, idx) for idx, num in enumerate(row)])\n            # minimum, second minimum\n            num1, idx1 = srow[0][0], srow[0][1]\n            num2, idx2 = srow[1][0], srow[1][1]\n            c1v = min(float('inf') if cand1[1] == idx1 else cand1[0] + num1, \\\\\n                      float('inf') if cand2[1] == idx1 else cand2[0] + num1)\n            c2v = min(float('inf') if cand1[1] == idx2 else cand1[0] + num2, \\\\\n                      float('inf') if cand2[1] == idx2 else cand2[0] + num2)\n            cand1 = (c1v, idx1)\n            cand2 = (c2v, idx2)\n        return min(cand1[0], cand2[0])\n            \n            \n            ", "import heapq, bisect\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr or not arr[0]:\n            raise ValueError(\\\"empty input.\\\")\n        \n        m = len(arr) # row\n        n = len(arr[0]) # col\n        dp = [0] * n\n        prev_min = [(0, -1), (0, -1)]\n\n        for row in arr:\n            dp_new = [0] * n\n            curr_min = []\n            for i, num in enumerate(row):\n                if i == prev_min[0][1]:\n                    dp_new[i] = prev_min[1][0] + num\n                else:\n                    dp_new[i] = prev_min[0][0] + num\n                bisect.insort(curr_min, (dp_new[i], i))\n                \n                if len(curr_min) > 2:\n                    curr_min.pop()\n            prev_min = curr_min\n            dp = dp_new\n        return min(dp)\n        # dp = [(x, i) for i, x in enumerate(arr[0])] # start with first row.\n        # heapq.heapify(dp)\n        # # O(mnlogn) solution\n        # for row in arr[1:]:\n        #     dp_new = []\n        #     for i in range(n):\n        #         if dp[0][1] == i:\n        #             tmp = heapq.heappop(dp)\n        #             heapq.heappush(dp_new, (dp[0][0] + row[i], i))\n        #             heapq.heappush(dp, tmp)\n        #         else:\n        #             heapq.heappush(dp_new, (dp[0][0] + row[i], i))\n        #     dp = dp_new\n        # return dp[0][0]\n#         # O(mn^2) solution:\n#         for row in arr[1:]:\n#             dp_new = [0] * n\n#             for i in range(n):\n#                 dp_new[i] = row[i] + min([x for i_prev, x in enumerate(dp) if i != i_prev])\n#             dp = dp_new\n            \n#         return min(dp_new)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n=len(arr)\n        m=len(arr[0])\n        dp=[[sys.maxsize]*m for i in range(n)]\n        for j in range(m):\n            dp[0][j]=arr[0][j]\n        for i in range(1,n):\n            for j in range(m):\n                val=sys.maxsize\n                for k in range(m):\n                    if k !=j:\n                        val=min(val,dp[i-1][k])\n                dp[i][j]=val+arr[i][j]\n        return min(dp[-1][:])", "from functools import lru_cache\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        @lru_cache(maxsize=None)\n        def dp(i,j):\n            if not (0<=i<len(arr) and 0<=j<len(arr[0])):\n                return float('inf')\n            if i == len(arr)-1:\n                return arr[i][j]\n            return arr[i][j] + min(dp(i+1, k) for k in range(len(arr[0])) if k!=j)\n        \n        return min(dp(0, j) for j in range(len(arr[0])))", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                above = []\n                for k in range(len(arr[0])):\n                    if k!=j:\n                        heapq.heappush(above, arr[i-1][k])\n                        #above.add()\n                #print(above)\n                #print(above)\n                arr[i][j] = arr[i][j] + above[0]\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m,n=len(arr),len(arr[0])\n        for i in range(1,m):\n            for j in range(n):\n                m=float('inf')\n                for k in range(n):\n                    if k==j:\n                        continue\n                    m=min(m,arr[i-1][k])\n                arr[i][j]+=m\n        return min(arr[-1])", "import itertools\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int: \n        nr, nc = len(arr), len(arr[0])\n        for (r_i, c_i) in itertools.product(\n            list(range(nr-2,-1,-1)),\n            list(range(nc))\n        ):\n            downs = [\n                (r_i+1, d_c) for d_c in range(nc) if d_c != c_i\n            ]\n            min_downs = min([\n                arr[d_r][d_c] for (d_r, d_c) in downs\n            ])\n            \n            arr[r_i][c_i] += min_downs\n            \n        return min([\n            arr[0][c] for c in range(nc)\n        ])\n        \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        N = len(arr)\n        \n        dp = [[0] * N for _ in range(N)]\n        \n        for i in range(N):\n            dp[N-1][i] = arr[N-1][i]\n        \n        for r in range(N-2, -1, -1):\n            for c in range(N):\n                min_c = float('inf')\n                for n_c in range(N):\n                    if n_c == c:\n                        continue\n                    min_c = min(min_c, arr[r+1][n_c])\n                dp[r][c] = min_c + arr[r][c]\n                arr[r][c] = dp[r][c]\n        \n        res = float('inf')\n        for i in range(N):\n            res = min(res, dp[0][i])\n        \n        return res", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        from copy import deepcopy\n        \n        v=deepcopy(arr)\n        \n        for i in range(len(arr)-2,-1,-1):\n            for j in range(len(arr[0])):\n                minn=float('inf')\n                for k in range(len(arr[0])):\n                    if j!=k:\n                        minn=min(minn,v[i+1][k])\n                        \n                v[i][j]+=minn\n                \n                \n        return min(v[0])\n                \n                \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if len(arr)==0: return 0\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                mini = float('inf')\n                for k in range(len(arr[0])):\n                    if k!=j:\n                        mini = min(mini,arr[i-1][k])\n                arr[i][j] += mini\n        ans = float('inf')\n        for i in range(len(arr[0])):\n            ans = min(ans, arr[-1][i])\n        return ans", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        g = [[inf]*len(a) for a in A]\n        def get(i,j):\n            m = inf\n            for k in range(0, len(A[0])):\n                if k != j:\n                    m = min(m, g[i-1][k])\n            return m\n        for i in range(len(g)):\n            for j in range(len(g[0])):\n                if i == 0:\n                    g[i][j] = A[i][j]\n                else:\n                    g[i][j] = min(g[i][j], get(i,j)+A[i][j])\n        return min(g[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp=[[0 for i in range(len(arr))]for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[0][i]=arr[0][i]\n        for i in range(1,len(arr)):\n            for j in range(len(arr)):\n                m=9999999\n                for k in range(len(arr)):\n                    if k!=j:\n                        m=min(m,dp[i-1][k])\n                dp[i][j]=arr[i][j]+m \n        m=99999999        \n                \n        for i in range(len(arr)):\n            m=min(m,dp[len(arr)-1][i])\n        return m    ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        min_index = 0\n        secondmn_index = 0\n        temp = [[0 for i in range(len(arr[0]))] for j in range(len(arr))]\n        temp[0] = arr[0][:]\n        for i in range(1,len(arr)):\n            min_index = 0\n            secondmn_index = 1\n            for j in range(len(arr)):\n                if temp[i-1][min_index]>temp[i-1][j]:\n                    secondmn_index = min_index\n                    min_index = j\n                elif temp[i-1][secondmn_index]>temp[i-1][j] and j!=min_index:\n                    secondmn_index = j\n            for j in range(len(arr)):\n                if j!=min_index:\n                    temp[i][j] = arr[i][j] + temp[i-1][min_index]\n                else:\n                    temp[i][j] = arr[i][j] + temp[i-1][secondmn_index]\n        print(temp)\n        return min(temp[len(temp)-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        A = arr\n        m = len(A)\n        n = len(A[0])\n        # dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]\n        if m == n == 1:\n            return A[0][0]\n            \n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                cell = float('inf')\n                for k in range(1, n + 1):\n                    if j == k:\n                        continue\n                    cell = min(cell, dp[i-1][k])\n                dp[i][j] = cell + A[i-1][j-1]\n                \n                \n        return min(dp[-1][1:])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n        \n        R = C = len(arr)\n        \n        for r in range(1, R):\n            for c in range(0, C):\n                \n                m = float('inf')\n                for i in range(C):\n                    if i != c:\n                        m = min(m, arr[r-1][i])\n                \n                arr[r][c] += m\n            # print(arr[r], m)\n        \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if arr is None or len(arr) == 0 or len(arr[0]) == 0: return 0\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                temp = float('inf')\n                for last_col in range(len(arr[0])):\n                    if last_col != j:\n                        temp = min(temp, arr[i-1][last_col])\n                arr[i][j] += temp\n        ans = float('inf')     \n        for i in range(len(arr[0])):\n            ans = min(ans, arr[-1][i])\n        return ans\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        for i in range(1, n):\n            for j in range(len(arr[0])):\n                curMin = float('inf')\n                for k in range(len(arr[0])):\n                    if j == k:\n                        continue\n                    curMin = min(curMin, arr[i - 1][k])\n                arr[i][j] += curMin\n            # arr[i][1] += min(arr[i - 1][0], arr[i - 1][2])\n            # arr[i][2] += min(arr[i - 1][0], arr[i - 1][1])\n                \n        return min(arr[n - 1])\n                        \n                    \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        dp = arr\n        for i in range(1, m):\n            for j in range(n):\n                acc = float('inf')\n                for k in range(n):\n                    if k == j: continue\n                    acc = min(acc, arr[i - 1][k])\n                dp[i][j] = arr[i][j] + acc\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        import math\n        n = len(arr)\n        if n==0: return 0\n        k = len(arr[0])\n        for house in range(1,n):\n            for color in range(k):\n                best = math.inf\n                for prev_color in range(k):\n                    if color == prev_color:\n                        continue\n                    best = min(best, arr[house - 1][prev_color])\n                arr[house][color] += best\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n\n        rows = len(arr)\n        columns = len(arr[0])\n        for i in range(1,rows):\n            for j in range(columns):\n                minimum = float('inf')\n                for k in range(columns):\n                    if k!=j:\n                        minimum = min(minimum,arr[i-1][k])\n                arr[i][j] = arr[i][j] + minimum\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        for i in range(1, n):\n            lowest = min(arr[i - 1])\n            lowestCount = 0\n            secondLowest = float('inf')\n            for j in range(len(arr[0])):\n                if arr[i - 1][j] == lowest:\n                    lowestCount += 1\n                    \n                if arr[i - 1][j] > lowest:\n                    secondLowest = min(secondLowest, arr[i - 1][j])\n                    \n            if lowestCount >= 2:\n                secondLowest = lowest\n            \n            for j in range(len(arr[0])):\n                if arr[i-1][j] == lowest:\n                    arr[i][j] += secondLowest\n                else:\n                    arr[i][j] += lowest\n                \n        return min(arr[n - 1])\n                        \n                    \n", "import heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        copy = deepcopy(arr)\n        \n        for row in range(1,len(arr)):\n            smallest=heapq.nsmallest(2,copy[row-1])\n            for col in range(len(arr[0])):\n                copy[row][col] += smallest[0] if copy[row-1][col]!=smallest[0] else smallest[1]\n        return min(copy[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        if n == 1:\n            return arr[0][0]\n        \n        MAX_V = int(1e9)\n        min_v = [0] * n\n        \n        for i in range(n):\n            row = arr[i]\n            new_min_v = [MAX_V] * n\n            scan_min = min_v[-1]\n            for i in range(n - 2, -1, -1):\n                new_min_v[i] = min(new_min_v[i], scan_min + row[i])\n                scan_min = min(scan_min, min_v[i])\n            scan_min = min_v[0]\n            for i in range(1, n):\n                new_min_v[i] = min(new_min_v[i], scan_min + row[i])\n                scan_min = min(scan_min, min_v[i])\n            min_v = new_min_v\n        return min(min_v)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = len(arr)\n        n = len(arr[0])\n        dp = [[float('inf') for j in range(n)] for i in range(m)]\n        ## initialization\n        for j in range(n):\n            dp[0][j] = arr[0][j]\n            \n        for i in range(1, m):\n            min_idx = sec_min_idx = None\n            for j in range(n):\n                if min_idx is None or dp[i-1][j]<dp[i-1][min_idx]:\n                    sec_min_idx = min_idx\n                    min_idx = j\n                elif sec_min_idx is None or dp[i-1][j]<dp[i-1][sec_min_idx]:\n                    sec_min_idx = j\n                    \n            # print(\\\"min_idx\\\", min_idx, \\\"sec_min_idx\\\", sec_min_idx)\n            for j in range(n):\n                if j == min_idx:\n                    dp[i][j] = dp[i-1][sec_min_idx] + arr[i][j]\n                else:\n                    dp[i][j] = dp[i-1][min_idx] + arr[i][j]\n                    \n        return min(dp[m-1])\n", "'''\nfind the minimum of the previous row and add it to the minimum of the current row if they are not in the same column\n\nelse -> add the second smallest from the previous to the min in current row\n\n'''\nimport heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        rows,cols = len(arr), len(arr[0])\n        for i in range(1,rows):\n            # find the 2 smallest value from previous row\n            min1, min2 =  heapq.nsmallest(2,arr[i-1])\n            '''min1 = min(arr[i-1])\n            min1_index = arr[i-1].index(min1)\n           \n            min2 = min(x for j,x in enumerate(arr[i-1]) if j!=min1_index )'''\n            for j in range(cols):\n                if arr[i-1][j] == min1:\n                    arr[i][j] +=min2\n                else:\n                    arr[i][j] +=min1\n        return min(arr[-1])\n            \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        dp = arr[0][:]\n        for i in range(1, n):\n            right_min = [math.inf]*(n-1) + [dp[n-1]]\n            for j in range(n-2, -1, -1):\n                right_min[j] = min(right_min[j+1], dp[j])\n            left_min = math.inf\n            for j in range(n):\n                prev = left_min\n                if j < n-1:\n                    prev = min(prev, right_min[j+1])\n                left_min = min(left_min, dp[j])\n                dp[j] = prev + arr[i][j]\n        return min(dp)\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        # always fall to the smallest or second smallest (if smallest is the same )\n        \n        m, n = len(arr), len(arr[0])\n        i = 1\n        while i < m:\n            a = arr[i - 1][:]\n            min1 = a.index(min(a))\n            a[min1] = float('inf')\n            min2 = a.index(min(a))\n            a = arr[i - 1]\n            for j in range(n):\n                if j == min1:\n                    arr[i][j] += a[min2]\n                else:\n                    arr[i][j] += a[min1]\n            i += 1\n        return min(arr[-1])\n        \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        rows = len(arr)\n\n        for row in range(1, rows):\n            nsmall_in_row = heapq.nsmallest(2, arr[row - 1])\n            \n            for col in range(0, rows):\n                arr[row][col] += nsmall_in_row[1] if nsmall_in_row[0] == arr[row - 1][col] else nsmall_in_row[0]\n\n        return min(arr[-1])\n    \n    # Time complexity - O( n * (heap time + n))\n", "import heapq\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [[float('inf')] + i + [float('inf')] for i in arr]\n        for i in range(1,len(dp)):\n            hp = heapq.nsmallest(2, dp[i - 1])\n            for j in range(1,len(dp[0])-1):\n                dp[i][j] +=  hp[0] if dp[i-1][j] != hp[0] else hp[1]\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        n=len(A)\n        for i in range(n-2,-1,-1):\n            mn=min(A[i+1])\n            idx=A[i+1].index(mn)\n            for j in range(n):\n                if(j!=idx):\n                    A[i][j]+=mn\n                elif(j==idx):\n                    dp=[101 for _ in range(n)]\n                    for k in range(n):\n                        if(k!=idx):\n                            dp[k]=A[i+1][k]\n                    A[i][j]+=min(dp)    \n        return(min(A[0]))            ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        above_others = [0] * len(arr[0]) #minimum path sum not including itself\n        \n        for row in arr:\n            paths = [n + path for n, path in zip(row, above_others)]\n            others = [float(\\\"inf\\\")] * len(paths)\n            \n            for r in range(len(paths)), reversed(range(len(paths))):\n                min_path = float('inf')\n                for i in r:\n                    others[i] = min(others[i], min_path)\n                    min_path = min(min_path, paths[i])\n            \n            above_others = others\n        \n        return min(above_others)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = copy.deepcopy(arr)\n        for i in range(1, len(dp)):\n            r = heapq.nsmallest(2, dp[i-1])\n            for j in range(len(dp[0])):\n                dp[i][j] += r[1] if dp[i - 1][j] == r[0] else r[0]\n        return min(dp[-1])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        import heapq\n\n        dp = arr[0][:]\n        for i in range(1, len(arr)):\n            heap = list((v, k) for k, v in enumerate(dp))\n            heapq.heapify(heap)\n            min_value, min_pos = heapq.heappop(heap)\n            alter_value, _ = heapq.heappop(heap)\n            new_dp = [v + min_value for v in arr[i]]\n            new_dp[min_pos] += alter_value - min_value\n            dp = new_dp\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        def getmin(row):\n            m1=float(\\\"inf\\\")\n            indx1=0\n            m2=float(\\\"inf\\\")\n            indx2=0\n            for elem in range(len(row)):\n                #print(m1,m2)\n                if row[elem]<=m1:\n                    m2=m1\n                    m1=row[elem]\n                    indx2=indx1\n                    indx1=elem\n                elif row[elem]<m2:\n                    m2=row[elem]\n                    indx2=elem\n            return indx1,indx2\n        \n        for i in range(1,len(arr)):\n            col1,col2=getmin(arr[i-1])\n            #print(col1,col2)\n            for j in range(len(arr[0])):\n                if j==col1:\n                    arr[i][j]+=arr[i-1][col2]\n                else:\n                    arr[i][j]+=arr[i-1][col1]\n        #print(arr)\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        copy = deepcopy(arr)\n        \n        for row in range(1,len(arr)):\n            min1, ind1, min2, ind2 = 20000,0,20000,0\n            for i, v in enumerate(copy[row-1]):\n                if v < min1:\n                    min1=v\n                    ind1=i\n            for i, v in enumerate(copy[row-1]):\n                if v < min2 and i!=ind1:\n                    min2=v\n                    ind2=i\n            # print(min1, ind1, min2, ind2)\n            for col in range(len(arr[0])):\n                copy[row][col] += copy[row-1][ind1] if ind1 != col else copy[row-1][ind2]\n        return min(copy[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        def findMinOtherThanThis(nums):\n            ret = list()\n            left, right = [0 for i in range(len(arr))], [0 for i in range(len(arr))]\n            \n            left_min = float('inf')\n            for idx, n in enumerate(nums):\n                left[idx] = left_min\n                left_min = min(left_min, n)\n                \n            right_min = float('inf')\n            for idx in range(len(nums)-1, -1, -1):\n                right[idx] = right_min\n                right_min = min(right_min, nums[idx])\n                \n            for idx in range(len(nums)):\n                ret.append(min(left[idx], right[idx]))\n            \n            return ret\n            \n        if not arr:\n            return 0\n        m = len(arr)\n        n = len(arr[0])\n        dp = [[0 for j in range(n)] for i in range(m)]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                if i == m-1:\n                    dp[i][j] = arr[i][j]\n                else:\n                    dp[i][j] = arr[i][j] + dp[i+1][j]\n            dp[i] = findMinOtherThanThis(dp[i])\n        \n        return min(dp[0])", "\\\"\\\"\\\"\ndp[r][c] = min(dp[r-1][c1], dp[r-1][c2]) for any c1, c2 != c\n\nBase case:\n\ndp[r][c] = 0 for r < 0\n\nComplexity:\n\nTime = r * c\n\\\"\\\"\\\"\n\n# TLE for top down\n\n# class Solution:\n#     def minFallingPathSum(self, arr: List[List[int]]) -> int:\n#         rows, cols = len(arr), len(arr[0])\n        \n#         @lru_cache(None)\n#         def dp(r, c):\n#             if r < 0:\n#                 return 0\n            \n#             return arr[r][c] + min(dp(r-1, c1) for c1 in range(cols) if c1 != c)\n    \n#         return min(dp(rows-1, c) for c in range(cols))\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        rows, cols = len(arr), len(arr[0])\n        prev_row = [0] * cols\n    \n        for r in range(rows):\n            min1, min2 = heapq.nsmallest(2, prev_row)\n            prev_row = [arr[r][c] + (min1 if min1 != prev_row[c] else min2) for c in range(cols)]\n        \n        return min(prev_row)\n                        ", "class Solution:\n    \n    \n    def minFallingPathSum(self, cost: List[List[int]]) -> int:\n        cols = len(cost[0])\n        dp = cost[0]\n\n        for h in range(1, len(cost)):\n            prev = sorted(cost[h-1])\n            for m in range(0, cols):\n                cost[h][m] += prev[1] if cost[h-1][m] == prev[0] else prev[0]\n\n                 \n\n        return min(cost[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        for i in range(1,len(arr)):\n            r = heapq.nsmallest(2, arr[i - 1])\n            \n            for j in range(len(arr[0])):\n                arr[i][j] += r[1] if arr[i-1][j] == r[0] else r[0]\n                \n                \n        return min(arr[-1])\n            \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        from copy import deepcopy\n        from heapq import heapify\n        \n        v=deepcopy(arr)\n        \n        \n        for i in range(len(arr)-2,-1,-1):\n            s=deepcopy(v[i+1])\n            heapify(s)\n            min1=s[0]\n            min2=min(s[1],s[2])\n            # print(min1,min2)\n            for j in range(len(arr[0])):\n                \n                if v[i+1][j]!=min1:\n                    v[i][j]+=min1\n                else:\n                    v[i][j]+=min2\n                    \n                        \n\n                \n        return min(v[0])\n                \n                \n", "import heapq\nimport numpy as np\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        # This requires exploring all subpaths ? No I dont think so, It jus trquires an intelligent browse of the problem\n\n        x = len(arr)\n        new_count = np.zeros((x, x))\n        new_count[0] = arr[0]\n        for k in range(1, x):\n            previous_line_maxes =  heapq.nsmallest(2, new_count[k-1])\n            for index in range(len(arr)):\n                if new_count[k -1][index] == previous_line_maxes[0]:\n                    value_to_add = previous_line_maxes[1]\n                else : \n                    value_to_add = previous_line_maxes[0]\n  \n                new_count[k, index] = value_to_add + arr[k][index]\n    \n            \n        return(int(min(new_count[-1])))\n        \n", "import heapq\n\nclass Solution:\n  def minFallingPathSum(self, arr: List[List[int]]) -> int:\n    # O(N^2), N = len(arr) >= 3\n    n = len(arr)\n    # keep the min and 2nd-min with corresponding index of falling path at each row\n    xm = [(0, -1), (0, -1)]\n    for i in range(n):\n      xm = heapq.nsmallest(2, [(x + xm[1][0], j) if j == xm[0][1] else (x + xm[0][0], j) for j, x in enumerate(arr[i])])\n    return xm[0][0]", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n     \n        def getTwo(a):\n            pos = {v:k for k,v in enumerate(a)}\n            f,s = sorted(a)[:2]\n            return ([f,pos[f]],[s,pos[s]])\n        \n        for i in range(1,n):\n            pre = getTwo(arr[i-1])\n            for j in range(n):\n                if j!=pre[0][1]:\n                    arr[i][j]+=pre[0][0]\n                else:\n                    arr[i][j]+=pre[1][0]\n        return min(arr[-1])", "\\\"\\\"\\\"\ndp[r][c] = min(dp[r-1][c1], dp[r-1][c2]) for any c1, c2 != c\n\nBase case:\n\ndp[r][c] = 0 for r < 0\n\nComplexity:\n\nTime = r * c\n\\\"\\\"\\\"\n\n# TLE for top down\n\n# class Solution:\n#     def minFallingPathSum(self, arr: List[List[int]]) -> int:\n#         rows, cols = len(arr), len(arr[0])\n        \n#         @lru_cache(None)\n#         def dp(r, c):\n#             if r < 0:\n#                 return 0\n            \n#             return arr[r][c] + min(dp(r-1, c1) for c1 in range(cols) if c1 != c)\n    \n#         return min(dp(rows-1, c) for c in range(cols))\n\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        prev_row = [0] * len(arr[0])\n    \n        for r in range(len(arr)):\n            min1, min2 = heapq.nsmallest(2, prev_row)\n            prev_row = [arr[r][c] + (min1 if min1 != prev_row[c] else min2) for c in range(len(arr[r]))]\n        \n        return min(prev_row)\n                        ", "class Solution:\n    \n    \n\n    \n    \n    def minFallingPathSum(self, A):\n        for i in range(1, len(A)):\n            r = heapq.nsmallest(2, A[i - 1])\n            for j in range(len(A[0])):\n                A[i][j] += r[1] if A[i - 1][j] == r[0] else r[0]\n        return min(A[-1])", "class Solution:\n    def minFallingPathSum(self, dp: List[List[int]]) -> int:\n        for i in range(1, len(dp)):\n            best2 = sorted(list(enumerate(dp[i-1])), key=lambda x: x[1])[:2]\n            for j in range(len(dp[i])):\n                dp[i][j] = [x for x in best2 if x[0] != j][0][1] + dp[i][j]\n\n        return min(dp[-1])", "class Solution:\n    def scan(self, row: List[int], n: int) -> (int, int, int):\n        best = None\n        k = None\n        alt = None\n        for j in range(n):\n            if not best or row[j] < best:\n                alt = best\n                best = row[j]\n                k = j\n            elif not alt or row[j] < alt:\n                alt = row[j]\n        return best, k, alt\n    \n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        M = [[None for j in range(n)] for i in range(n)]\n\n        for j in range(n):\n            M[0][j] = arr[0][j]\n        best, k, alt = self.scan(M[0], n)\n\n        for i in range(1, n):\n            for j in range(n):\n                if j != k:\n                    M[i][j] = arr[i][j] + best\n                else:\n                    M[i][j] = arr[i][j] + alt\n            best, k, alt = self.scan(M[i], n)\n        \n        return best", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m, n = len(arr), len(arr[0])\n        dp = [[float(\\\"inf\\\") for _ in range(n)] for _ in range(m)]\n        for j in range(n):\n            dp[0][j] = arr[0][j]\n        for i in range(1, m):\n            first_min, second_min = float(\\\"inf\\\"), dp[i-1][0]\n            first_idx, second_idx = 0, 0\n            for j in range(n):\n                if dp[i-1][j] < first_min:\n                    first_min, second_min = dp[i-1][j], first_min\n                    first_idx, second_idx = j, first_idx\n                elif dp[i-1][j] < second_min:\n                    second_min = dp[i-1][j]\n                    second_idx = j\n            for j in range(n):\n                if j == first_idx:\n                    dp[i][j] = second_min + arr[i][j]\n                else:\n                    dp[i][j] = first_min + arr[i][j]\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        iMax = len(arr)\n        jMax = len(arr[0])\n        \n        # sortedIndex = [sorted([(arr[i][j], j) for j in range(jMax)]) for i in range(iMax)]\n        dp = {}\n        smallest2 = [None for _ in range(iMax)]\n        \n        def moveDown(preJ, iNow):\n            if iNow == iMax:\n                return 0\n\n            if (preJ, iNow) in dp:\n                return dp[(preJ, iNow)]\n            subAns = float('inf')\n            if smallest2[iNow] == None:\n                temp1 = float('inf')\n                temp1Index = None\n                temp2 = float('inf')\n                temp2Index = None\n                for j, val in enumerate(arr[iNow]):\n                    subAns = val + moveDown(j, iNow+1)\n                    if subAns <= temp1:\n                        temp1, temp2 = subAns, temp1\n                        temp1Index, temp2Index = j, temp1Index\n                    elif subAns <= temp2:\n                        temp2 = subAns\n                        temp2Index = j\n                smallest2[iNow] = [[temp1Index, temp1], [temp2Index, temp2]]\n                \n            if preJ == smallest2[iNow][0][0]:\n                subAns = smallest2[iNow][1][1]\n            else:\n                subAns = smallest2[iNow][0][1]\n            dp[(preJ, iNow)] = subAns\n            return subAns\n        return moveDown(-1, 0)\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n= len(arr)\n        for i in range(1, n):\n            r= heapq.nsmallest(2, arr[i-1])\n            for j in range(n):\n                arr[i][j]+= r[1] if arr[i-1][j]== r[0] else r[0]\n                \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum1(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn^2)  - due linear search for min in inner loop\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors(j):\n            a, row_prev[j] = row_prev[j], float('inf')\n            min_val = min(row_prev)\n            row_prev[j] = a\n            return min_val\n        \n        row_prev = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            for col in range(n):\n                cur[col] = get_min_neighbors(col) + arr[row][col]\n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            row_prev = cur[:]\n        \n        return global_min\n\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn) - if heapq.nsmallest is linear, here min search is in outer loop\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors():\n            #min1, min2 = heapq.nsmallest(2, row_prev) #also works\n            min1 = float('inf')\n            min2 = float('inf')\n            \n            for val in dp:\n                if val < min1:\n                    min2 = min1\n                    min1 = val\n                elif val < min2:\n                    min2 = val\n                    \n            return min1, min2\n        \n        dp = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            min1, min2 = get_min_neighbors()\n            for col in range(n):\n                min_val = min1 if dp[col] != min1 else min2 #doesnt matter if duplicates\n                cur[col] = min_val + arr[row][col] \n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            dp = cur[:]\n\n        return global_min", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1, len(arr)):\n            r = heapq.nsmallest(2, arr[i - 1])\n            for j in range(len(arr[0])):\n                arr[i][j] += r[1] if arr[i-1][j] == r[0] else r[0]\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        iMax = len(arr)\n        jMax = len(arr[0])\n        \n        # sortedIndex = [sorted([(arr[i][j], j) for j in range(jMax)]) for i in range(iMax)]\n        dp = {}\n        smallest2 = [None for _ in range(iMax)]\n        \n        def moveDown(preJ, iNow):\n            if iNow == iMax:\n                return 0\n\n            if (preJ, iNow) in dp:\n                return dp[(preJ, iNow)]\n            subAns = float('inf')\n            if smallest2[iNow] == None:\n                temp1 = float('inf')\n                temp1Index = None\n                temp2 = float('inf')\n                temp2Index = None\n                for j, val in enumerate(arr[iNow]):\n                    subAns = val + moveDown(j, iNow+1)\n                    if subAns <= temp1:\n                        temp1, temp2 = subAns, temp1\n                        temp1Index, temp2Index = j, temp1Index\n                    elif subAns <= temp2:\n                        temp2 = subAns\n                        temp2Index = j\n                smallest2[iNow] = [[temp1Index, temp1], [temp2Index, temp2]]\n                \n            if preJ == smallest2[iNow][0][0]:\n                subAns = smallest2[iNow][1][1]\n            else:\n                subAns = smallest2[iNow][0][1]\n            dp[(preJ, iNow)] = subAns\n            return subAns\n        return moveDown(-1, 0)\n    \n#         iMax = len(arr)\n#         jMax = len(arr[0])\n        \n#         # sortedIndex = [sorted([(arr[i][j], j) for j in range(jMax)]) for i in range(iMax)]\n#         # print(sortedIndex)\n#         dp = {}\n#         dp2 = {}\n#         ans = [float('inf')]\n        \n#         def moveDown(preJ, iNow, sumNow):\n#             if iNow == iMax:\n#                 ans[0] = min(ans[0], sumNow)\n#                 return 0\n\n#             if (preJ, iNow) in dp and dp[(preJ, iNow)] <= sumNow:\n#                 ans[0] = min(ans[0], sumNow +  dp2[(preJ, iNow)])\n#                 return dp2[(preJ, iNow)]\n#             # if (preJ, iNow) in dp2:\n#             #     ans[0] = min(ans[0], sumNow +  dp2[(preJ, iNow)])\n#             #     return dp2[(preJ, iNow)]\n#             dp[(preJ, iNow)] = sumNow\n#             # if sumNow >= ans[0]:\n#             #     return float('inf')\n#             subAns = float('inf')\n#             # for val,j in (sortedIndex[iNow]):\n#             for j, val in enumerate(arr[iNow]):\n#                 if j != preJ:\n#                     subAns = min(subAns, val + moveDown(j, iNow+1, val+sumNow))\n#                     # moveDown(j, iNow+1, val+sumNow)\n                    \n#             dp2[(preJ, iNow)] = subAns\n#             return subAns\n#         moveDown(-1, 0, 0)\n#         return ans[0]\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = len(arr)\n        n = len(arr[0])\n        dp = [[0]*n for i in range(m)]\n\n        for j in range(n):\n            dp[0][j] = arr[0][j]\n\n        for i in range(1,m):\n            sorted_lastrow = sorted([(k, dp[i - 1][k]) for k in range(n)], key=lambda x: x[1])\n            p_index, p = sorted_lastrow[0]\n            q_index, q = sorted_lastrow[1]\n            \n            for j in range(n):\n\n                \n\n                lastdp = p if p_index != j else q\n                dp[i][j] = lastdp + arr[i][j]\n\n        return min(dp[m-1])\n", "class Solution:\n    def minFallingPathSum1(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn^2)  - due linear search for min in inner loop\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors(j):\n            a, row_prev[j] = row_prev[j], float('inf')\n            min_val = min(row_prev)\n            row_prev[j] = a\n            return min_val\n        \n        row_prev = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            for col in range(n):\n                cur[col] = get_min_neighbors(col) + arr[row][col]\n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            row_prev = cur[:]\n        \n        return global_min\n\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn) - if heapq.nsmallest is linear, here min search is in outer loop\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors():\n            min1, min2 = heapq.nsmallest(2, row_prev)\n            return min1, min2\n        \n        row_prev = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            min1, min2 = get_min_neighbors() #if linear\n            for col in range(n):\n                min_val = min1 if row_prev[col] != min1 else min2 #doesnt matter if duplicates\n                cur[col] = min_val + arr[row][col] \n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            row_prev = cur[:]\n\n        return global_min", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        if n == 1:\n            return arr[0][0]\n        \n        \\\"\\\"\\\"\n        Returns the tuples (fp_sum, fp_sum_2) each of the form\n        (col, value) where col is the col the falling path sum\n        starts from and value is the falling path sum's value.\n        fp_sum is the true min falling path sum for the row and\n        fp_sum_2 is the SECOND-to-min falling path sum for the\n        row. That way we can guarantee an optimal continuation\n        for the row before since the element with the same col\n        as fp_sum can just continue locally with fp_sum_2.\n        \\\"\\\"\\\"\n        @lru_cache(maxsize=None)\n        def min_fp_sums(row):\n            fp_sum, fp_sum_2 = ((-1, 0), (-1, 0)) if row == n - 1 else min_fp_sums(row + 1)\n            min_fp_sum, min_fp_sum_2 = ((-1, math.inf), (-1, math.inf))\n            for col, num in enumerate(arr[row]):\n                value = num + (fp_sum if col != fp_sum[0] else fp_sum_2)[1]\n                if value < min_fp_sum[1]:\n                    min_fp_sum_2 = min_fp_sum\n                    min_fp_sum = (col, value)\n                elif value < min_fp_sum_2[1]:\n                    min_fp_sum_2 = (col, value)\n            return min_fp_sum, min_fp_sum_2\n            \n        return min_fp_sums(0)[0][1]", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = len(arr[0])\n        table = [arr[0][i] for i in range(m)]\n        \n        def get_mins(table):\n            cur_min = int(1e+9)\n            cur_min_i = -1\n            next_cur_min = int(1e+9)\n            next_cur_min_i = -1\n            for i, x in enumerate(table):\n                if x <= cur_min:\n                    cur_min, cur_min_i = x, i\n            for i, x in enumerate(table):\n                if x <= next_cur_min and i != cur_min_i:\n                    next_cur_min, next_cur_min_i = x, i\n            return cur_min, cur_min_i, next_cur_min, next_cur_min_i \n        \n        cur_min, cur_min_i, next_cur_min, next_cur_min_i = get_mins(table)\n        for i in range(1, len(arr)):\n            for j in range(m):\n                table[j] = arr[i][j]\n                if j != cur_min_i:\n                    table[j] = arr[i][j] + cur_min\n                else:\n                    table[j] = arr[i][j] + next_cur_min\n            cur_min, cur_min_i, next_cur_min, next_cur_min_i = get_mins(table)\n        return cur_min\n", "import numpy as np\nclass Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        if len(arr)==1: return min(arr[0])\n        \n        if len(arr[0])==2:\n            return (min(arr[0][1]+arr[1][0], arr[0][0]+arr[1][1]))\n        \n        # arr = np.random.sample((6,6))\n        \n        # find the smallest 3 of the index\n        sml = -np.ones((len(arr)+1, 3))\n        for i in range(len(arr)):\n            r = np.array(arr[i])\n            sml[i+1] = (np.argsort(r)[:3])\n        # print (sml)\n        \n        \n        dp = np.zeros((len(arr)+1, 3))\n        for i in range(1, len(arr)+1):\n            for j in range(3):\n                # print(i,j)\n                col_idx = int(sml[i][j])\n                sml_idx = [idx for idx in range(3) if sml[i-1][idx] != col_idx]\n                # print (col_idx, sml_idx)\n                # find the smallest of the last row\n                # print (arr[i-1][(col_idx)])\n                # print ([dp[i-1][c] for c in sml_idx])\n                dp[i][j] = arr[i-1][(col_idx)] + min([dp[i-1][c] for c in sml_idx])\n\n        print((dp[-1]))\n        return int(min(dp[-1]))\n", "class Solution:\n    def minFallingPathSum(self, dp: List[List[int]]) -> int:\n        for i in range(1, len(dp)):\n            best2 = heapq.nsmallest(2, list(enumerate(dp[i-1])), key=lambda x: x[1])\n            for j in range(len(dp[i])):\n                dp[i][j] = [x for x in best2 if x[0] != j][0][1] + dp[i][j]\n\n        return min(dp[-1])", "from heapq import nsmallest\n\n\nclass Solution:\n    def minFallingPathSum(self, arr) -> int:\n        \\\"\\\"\\\"\n        Given a square matrix of integers, this program uses dynamic\n        programming to determine the minimum falling path sum following\n        the rule that the values chosen from consecutive rows cannot be\n        from the same column.\n\n        :param arr: square matrix of integers\n        :type arr: list[list[int]]\n        :return: minimum falling path sum\n        :rtype: int\n        \\\"\\\"\\\"\n\n        \\\"\\\"\\\"\n        Initialize:\n        - Number of rows (rows) and number of columns (cols) are the\n          same value for a square matrix.\n        - Return quickly with the result when matrix is 1 x 1. \n        \\\"\\\"\\\"\n        rows = len(arr)\n        cols = rows\n        if rows == 1:\n            return arr[0][0]\n\n        \\\"\\\"\\\"\n        Dynamic Programming:\n        - Overwrite the arr matrix\n        - Compute a falling path sum for each element in a row\n          using the falling path sums from the previous row.\n        - Use the minimum path sum from the previous row unless\n          it is in the column, in which case use the second\n          minimum path sum.\n        - Return the minimum path sum in the bottom row as the answer.\n        \\\"\\\"\\\"\n        for row in range(1, rows):\n            min_path_sum, min_path_sum_2nd = nsmallest(2, arr[row - 1])\n            for col in range(cols):\n                if arr[row - 1][col] == min_path_sum:\n                    arr[row][col] += min_path_sum_2nd\n                else:\n                    arr[row][col] += min_path_sum\n        return min(arr[rows - 1])\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        m=len(arr)\n        \n        for i in range(1,m):\n            min1=min(arr[i-1])\n            ind=arr[i-1].index(min1)\n            for j in range(m):\n                if ind==j:\n                    arr[i][j]=arr[i][j]+min(arr[i-1][0:j]+arr[i-1][j+1:])\n                else:\n                    arr[i][j]=arr[i][j]+min1\n        return min(arr[-1])", "from collections import Counter\nclass Solution:\n    def get_minset(self, l):\n        left = []\n        right = []\n        n = len(l)\n        for i in range(n):\n            if i == 0:\n                left.append(l[i])\n                right.append(l[n-i-1])\n            else:\n                left.append(min(left[-1], l[i]))\n                right.append(min(right[-1], l[n-i-1]))\n        right = right[::-1]\n        res = []\n        for i in range(n):\n            if i == 0:\n                res.append(right[1])\n            elif i == n-1:\n                res.append(left[n-2])\n            else:\n                res.append(min(left[i-1], right[i+1]))\n        return res\n\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        last = arr[0]\n        maxset = self.get_minset(last)\n        for i in range(1, len(arr)):\n            tmp = []\n            for j in range(len(arr[0])):\n                tmp.append(maxset[j]+arr[i][j])\n            last = tmp\n            maxset = self.get_minset(last)\n        return min(last)\n                \n                \n", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        for i in range(1, len(A)):\n            for j in range(len(A)):\n                \n                temp = A[i-1][j]\n                A[i-1][j] = float(\\\"Inf\\\")\n                A[i][j] += min(A[i-1])\n                A[i-1][j] = temp\n        return min(A[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn)\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors(i, j):\n            a, row_prev[j] = row_prev[j], float('inf')\n            min_val = min(row_prev)\n            row_prev[j] = a\n            return min_val\n        \n        row_prev = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            for col in range(n):\n                cur[col] = get_min_neighbors(row, col) + arr[row][col]\n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            row_prev = cur[:]\n        \n        return global_min", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        m = 100 * len(arr)\n        T = [[0 for _ in range(len(arr))] for _ in range(len(arr))]\n        T[0] = arr[0]\n        for i in range(1, len(arr)):\n            for j in range(len(arr)):\n                temp = T[i-1][j]\n                T[i-1][j] = m\n                T[i][j] = arr[i][j] + min(T[i-1])\n                T[i-1][j] = temp\n        return min(T[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        inf=2000000000\n        m, n = len(arr), len(arr[0])\n        res = [[inf]*n for _ in range(m)]\n        res[0] = arr[0]\n        for i in range(1, m):\n            for j in range(n):\n                last = min(res[i-1][:j]) if j > 0 else inf\n                last = min(last,min(res[i-1][j+1:])) if j < n - 1 else last\n                res[i][j] = last + arr[i][j] \n        print(res)\n        return min(res[-1])", "class Solution(object):\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        N = len(A)\n        \n        # init dp array (dp[i][j] min sum from i,j forward)\n        dp = [[0 for i in range(N)] for j in range(N)]\n        \n        # init last row of dp (base case)\n        for j in range(N):\n            dp[-1][j] = A[-1][j]\n            \n        for i in range(N-2, -1, -1):\n            for j in range(N):\n                if j == 0:\n                    # left column\n                    dp[i][j] = A[i][j] + min(dp[i+1][1:])\n                elif j == N-1:\n                    # right column\n                    dp[i][j] = A[i][j] + min(dp[i+1][:-1])\n                else:\n                    # not border column\n                    dp[i][j] = A[i][j] + min(dp[i+1][:j]+dp[i+1][j+1:])\n        \n        print(dp)\n        return min(dp[0])", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        \n        if len(A)==1:\n            return min(A[0])\n        \n        for i in range(1, len(A)):\n            \n            minValue, minIdx = sys.maxsize, -1\n            secondMinValue = sys.maxsize\n            for j in range(len(A[0])): \n                if A[i-1][j] < minValue: \n                    secondMinValue = minValue\n                    minValue, minIdx  = A[i-1][j], j\n                elif A[i-1][j] < secondMinValue: \n                    secondMinValue = A[i-1][j]\n            for j in range(len(A[0])):\n                if j==minIdx: \n                    A[i][j] += secondMinValue\n                else: \n                    A[i][j] += minValue \n                    \n        return min(A[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [0] * len(arr[0])\n        for r, row in enumerate(arr):\n            for c in range(len(row)):\n                row[c] += min(dp[:c]+dp[c+1:])\n            dp = row[:]\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        m = len(arr[0])\n        res = 0\n        for i in range(1, n):\n            for j in range(m):\n                arr[i][j] += min(arr[i-1][0:j] + arr[i-1][j+1:])\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        dp = [[0 for i in range(n)] for i in range(n)]\n        for i in range(n):\n            dp[0][i] = arr[0][i]\n        for i in range(1,n):\n            dp[i][0] = min(dp[i-1][1:]) + arr[i][0]\n            for j in range(1,n-1):\n                minLeft = min(dp[i-1][:j])\n                minRight = min(dp[i-1][(j+1):])\n                dp[i][j] = min(minLeft,minRight) + arr[i][j]\n            dp[i][-1] = min(dp[i-1][:(-1)]) + arr[i][-1]\n        return min(dp[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        m = len(arr[0])\n        for i in range(1,n):\n            for j in range(m):\n                arr[i][j] += min(arr[i-1][0:j]+arr[i-1][j+1:])\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        for i in range(1, len(arr)):\n            for j in range(len(arr[0])):\n                \n                # if j == 0:\n                arr[i][j] += min(arr[i - 1][:j] + arr[i - 1][j + 1 :])\n                \n#                 elif j == len(A[0]) - 1:\n#                     A[i][j] += min()\n                    \n#                 else:\n#                     A[i][j] += min()\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        # find all falling path?: must be TLE\n        # recursive with memo: also TLE, in O(n^2) time complexity\n        # helper(i, j): we are looking at jth row and its last row , we choose col: i\n        \n#         self.dic = {}\n#         def helper(i, j):\n#             if (i, j) in self.dic:\n#                 return self.dic[(i, j)]\n            \n#             if j == len(arr) -1:\n#                 res =  min(arr[-1][0:i]+arr[-1][i+1:])\n#                 self.dic[(i, j)] = res\n#                 return res\n            \n            \n#             res = math.inf\n            \n#             for c in range(len(arr)):\n#                 if c != i:\n#                     res = min(res, helper(c, j+1) + arr[j][c])\n#             self.dic[(i, j)] = res\n#             return res\n        \n#         res =  helper(-1, 0)\n            \n#         print(self.dic)\n#         return res\n        \\\"\\\"\\\"\n            try dp also square complexity...\n            dp[i][j] choose jth col in ith row\n        \\\"\\\"\\\" \n        l = len(arr)\n        dp = [[0]*len(arr) for _ in range(len(arr))]\n        for i in range(l):\n            dp[-1][i] = arr[-1][i]\n        print(dp)\n        res = inf\n        for i in range((l-2), -1, -1):\n            for j in range(l):\n                dp[i][j] = min(dp[i+1][0:j] + dp[i+1][j+1:]) + arr[i][j]\n        return min(dp[0])\n        ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                arr[i][j] += min(arr[i - 1][:j] + arr[i - 1][j + 1:])\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        for i in range(1, len(arr)):\n            for j in range(len(arr[0])):\n                \n                # if j == 0:\n                arr[i][j] += min(arr[i - 1][:j] + arr[i - 1][j + 1 :])\n                \n#                 elif j == len(A[0]) - 1:\n#                     A[i][j] += min()\n                    \n#                 else:\n#                     A[i][j] += min()\n\n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        n = len(arr)\n        \n        dp = [([0] * n) for _ in range(n)]\n        dp[0] = arr[0]\n        \n        for i in range(1, n):\n            for j in range(n):\n                dp[i][j] = arr[i][j] + min(dp[i-1][:j] + dp[i-1][j+1:])\n                \n        return min(dp[-1])", "class Solution:\n    def find_smallest_and_second_smallest(self,a):\n        smallest = a[0]\n        c = 1\n        for i in a:\n            if i<smallest:\n                smallest = i\n                c = 1\n            if i==smallest:\n                c+=1\n        smallest2 = True\n        if c==2:\n            smallest2 = 999999\n            for i in a:\n                if i!=smallest:\n                    smallest2 = min(smallest2,i)\n        return smallest, smallest2\n\n    def givedp(self,arr):\n        if len(arr)==1:\n            return min(arr[0])\n        a,b = '',''\n        for i in range(len(arr)-1,-1,-1):\n            if i!=len(arr)-1:\n                for j in range(len(arr[i])):\n                    if a==arr[i+1][j] and b!=True:\n                        arr[i][j]+=b\n                    else:\n                        arr[i][j]+=a\n            if i!=0:\n                a,b = self.find_smallest_and_second_smallest(arr[i])\n        return min(arr[0])\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        return self.givedp(arr)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        '''\n        Time: O(mn)\n        Space: O(n + n) ~ O(n)\n        '''\n        m = len(arr)\n        n = len(arr[0])\n        \n        if m == 1: # 1 ele sq. matrix\n            return arr[0][0]\n        \n        def get_min_neighbors(i, j):\n            a, row_prev[j] = row_prev[j], float('inf')\n            min_val = min(row_prev)\n            row_prev[j] = a\n            return min_val\n        \n        \n        row_prev = arr[0]\n        cur = [0]*n\n        global_min = float('inf')\n        \n        for row in range(1, m):\n            for col in range(n):\n                cur[col] = get_min_neighbors(row, col) + arr[row][col]\n                \n                if row == m-1 and cur[col] < global_min:\n                    global_min = cur[col]\n     \n            row_prev = cur[:]\n        \n        return global_min", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n\n        prev = arr[0]\n        curr = [0 for i in range(len(prev))]\n\n        for cost in arr[1:]:\n            for i in range(len(cost)):\n                tmp = prev[:i] + prev[i + 1:]\n                curr[i] = min(tmp) + cost[i]\n            prev[:] = curr[:]\n\n        return min(prev)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if not arr:\n            return 0\n\n        prev = arr[0]\n        curr = [0 for i in range(len(prev))]\n\n        for item in arr[1:]:\n            for i in range(len(item)):\n                curr[i] = min(prev[:i] + prev[i + 1:]) + item[i]\n            prev[:] = curr[:]\n\n        return min(prev)\n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        N = len(arr)\n        while len(arr) >= 2:\n            cur = arr.pop()\n            for i in range(N):\n                newa = cur[:i] + cur[i+1:]\n                arr[-1][i] += min(newa)\n        \n        return min(arr[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n      while(len(arr)>=2):\n            row = arr.pop()\n            for i in range(len(row)):\n                r = row[:i]+row[i+1:]\n                arr[-1][i] += min(r)\n      return min(arr[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = arr[0][:]\n\n        for i, costs in enumerate(arr[1:], 1):\n            prev = dp[:]\n            \n            for j, cost in enumerate(costs):\n                dp[j] = cost + min(prev[:j] + prev[j+1:])\n\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(len(arr)-2, -1, -1):\n            for j in range(len(arr[0])):\n                arr[i][j] += min(arr[i+1][:j] + arr[i+1][j+1:])\n        return min(arr[0])", "class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        n = len(A)\n        dp = [[0 for j in range(n)] for i in range(n)]\n        for i in range(n):\n            dp[-1][i] = A[-1][i]\n        for i in range(n-2,-1,-1):\n            for j in range(n):\n                dp[i][j] = A[i][j] + min(dp[i+1][:j]+dp[i+1][j+1:])\n        return min(dp[0])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        num_rows = len(arr)\n        num_cols = len(arr[0])\n        dp = [[float('inf') for _ in range(num_cols)] for _ in range(num_rows + 1)] # min cost up to pos\n        \n        for col in range(num_cols):\n            dp[0][col] = 0\n        \n        for row in range(num_rows):\n            dp_r = row + 1\n            for col in range(num_cols):\n                dp[dp_r][col] = min(dp[dp_r - 1][:col] + dp[dp_r - 1][col + 1:]) + arr[row][col]\n            \n        \n        return min(dp[-1])\n            \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        n = len(arr)\n        d = [[float('-inf') for _ in range(n)] for _ in range(n)]\n        for y in range(n):\n            d[0][y] = arr[0][y]\n\n        for x in range(1, n):\n            smallest_two = heapq.nsmallest(2, d[x - 1])\n            for y in range(n):\n                if d[x - 1][y] == smallest_two[0]:\n                    d[x][y] = smallest_two[1] + arr[x][y]\n                else:\n                    d[x][y] = smallest_two[0] + arr[x][y]\n\n        ans = float('inf')\n        for y in range(n):\n            ans = min(ans, d[n - 1][y])\n        return ans", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        if len(arr) ==1:\n            return arr[0][0]\n        else:\n            Row = len(arr)\n            Col = len(arr[0])\n            ResultMat = [arr[0]] \n            for i in range(1,Row):\n                ResultList = []\n                for j in range(Col):\n                    NewList= ResultMat[i-1]\n                    NewList = NewList[0:j] + NewList[(j+1):len(NewList)]\n                    Min = min(NewList)\n                    Value = Min+arr[i][j]\n                    ResultList.append(Value)\n                ResultMat.append(ResultList)\n            return min(ResultMat[Row-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        for i in range(1,len(arr)):\n            for j in range(len(arr[0])):\n                arr[i][j] += min(arr[i - 1][:j] + arr[i - 1][j + 1:])\n        \n        return min(arr[-1])", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = arr[0]\n        n = len(arr[0])\n        for row in arr[1:]:\n            newdp = row[:]\n            for i in range(n):\n                temp = dp[:i]+dp[i+1:]\n                newdp[i]+=min(temp)\n            dp = newdp\n        return min(dp)", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        \n        nr = len(arr)\n        nc = len(arr[0])\n        \n        store = arr[:]\n        \n        result = 0\n        \n        for i in range(nr):\n            \n            for j in range(nc):\n                \n                if i >0:\n                    \n                    store[i][j] = min(store[i-1][:j]+ store[i-1][j+1:] )+ arr[i][j]\n            \n                    \n                \n        print(store)\n        \n        return min(store[nr-1])\n        \n", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        min_path = float(\\\"inf\\\")\n        n = len(arr)\n        m = len(arr[0])\n        for r in range(1, n):\n            min_path = float(\\\"inf\\\")\n            for c in range(0, m):\n                if (c == 0):\n                    arr[r][c] += min(arr[r-1][1:])\n                elif(c == m):\n                    arr[r][c] += min(arr[r-1][:-1])\n                else:\n                    arr[r][c] += min(arr[r-1][:c]+arr[r-1][c+1:])\n                min_path = min(min_path, arr[r][c])\n\n        return min_path\n                                \n                                 \n        \n                                 ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        min_path = float(\\\"inf\\\")\n        n = len(arr)\n        m = len(arr[0])\n        for r in range(1, n):\n            min_path = float(\\\"inf\\\")\n            for c in range(0, m):\n                arr[r][c] += min(arr[r-1][:c]+arr[r-1][c+1:])\n                min_path = min(min_path, arr[r][c])\n\n        return min_path\n                                \n                                 \n        \n                                 ", "class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        min_path = float(\\\"inf\\\")\n        for r in range(1, len(arr)):\n            min_path = float(\\\"inf\\\")\n            for c in range(0, len(arr[0])):\n                if (c == 0):\n                    arr[r][c] += min(arr[r-1][1:])\n                elif(c == len(arr[0])):\n                    arr[r][c] += min(arr[r-1][:-1])\n                else:\n                    arr[r][c] += min(arr[r-1][:c]+arr[r-1][c+1:])\n                min_path = min(min_path, arr[r][c])\n\n        return min_path\n                                \n                                 \n        \n                                 "]
["# cook your dish here\nt = int(input())\n\nwhile(t>0):\n    n = int(input())\n    k=1\n    while(k<=n):\n        print(k, end=' ')\n        k+=1\n    print('\\n')\n    t-=1", "from math import tan,sqrt,pi,floor,ceil\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    y=0\r\n    for i in range(1,1001):\r\n        p=n*(i**3)\r\n        if(floor(sqrt(p))==ceil(sqrt(p))):\r\n            y=i\r\n            break\r\n    x=[y]*n\r\n    print(*x)", "for T in range(int(input())):\n    N = int(input())\n    print(' '.join(map(str, range(1, N + 1))))", "\r\nfrom math import radians\r\nfrom heapq import heapify, heappush, heappop\r\nimport bisect\r\nfrom math import pi\r\nfrom collections import deque\r\nfrom math import factorial\r\nfrom math import log, ceil\r\nfrom collections import defaultdict\r\nfrom math import *\r\nfrom sys import stdin, stdout\r\nimport itertools\r\nimport os\r\nimport sys\r\nimport threading\r\nfrom collections import deque, Counter, OrderedDict, defaultdict\r\nfrom heapq import *\r\n# from math import ceil, floor, log, sqrt, factorial, pow, pi, gcd\r\n# from bisect import bisect_left,bisect_right\r\n# from decimal import *,threading\r\nfrom fractions import Fraction\r\nmod = int(pow(10, 9)+7)\r\n# mod = 998244353\r\n\r\n\r\ndef ii(): return int(input())\r\n\r\n\r\ndef si(): return str(input())\r\n\r\n\r\ndef mi(): return map(int, input().split())\r\n\r\n\r\ndef li1(): return list(mi())\r\n\r\n\r\ndef fii(): return int(stdin.readline())\r\n\r\n\r\ndef fsi(): return str(stdin.readline())\r\n\r\n\r\ndef fmi(): return map(int, stdin.readline().split())\r\n\r\n\r\ndef fli(): return list(fmi())\r\n\r\n\r\nabd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12,\r\n       'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24,\r\n       'z': 25}\r\n\r\n\r\ndef getKey(item): return item[0]\r\n\r\n\r\ndef sort2(l): return sorted(l, key=getKey)\r\n\r\n\r\ndef d2(n, m, num): return [[num for x in range(m)] for y in range(n)]\r\n\r\n\r\ndef isPowerOfTwo(x): return (x and (not (x & (x - 1))))\r\n\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\", \"\")\r\n\r\n\r\ndef ntl(n): return [int(i) for i in str(n)]\r\n\r\n\r\ndef powerMod(x, y, p):\r\n    res = 1\r\n    x %= p\r\n    while y > 0:\r\n        if y & 1:\r\n            res = (res * x) % p\r\n        y = y >> 1\r\n        x = (x * x) % p\r\n    return res\r\n\r\n\r\ngraph = defaultdict(list)\r\nvisited = [0] * 1000000\r\ncol = [-1] * 1000000\r\n\r\n\r\ndef bfs(d, v):\r\n    q = []\r\n    q.append(v)\r\n    visited[v] = 1\r\n    while len(q) != 0:\r\n        x = q[0]\r\n        q.pop(0)\r\n        for i in d[x]:\r\n            if visited[i] != 1:\r\n                visited[i] = 1\r\n                q.append(i)\r\n        print(x)\r\n\r\n\r\ndef make_graph(e):\r\n    d = {}\r\n    for i in range(e):\r\n        x, y = mi()\r\n        if x not in d:\r\n            d[x] = [y]\r\n        else:\r\n            d[x].append(y)\r\n        if y not in d:\r\n            d[y] = [x]\r\n        else:\r\n            d[y].append(x)\r\n    return d\r\n\r\n\r\ndef gr2(n):\r\n    d = defaultdict(list)\r\n    for i in range(n):\r\n        x, y = mi()\r\n        d[x].append(y)\r\n    return d\r\n\r\n\r\ndef connected_components(graph):\r\n    seen = set()\r\n\r\n    def dfs(v):\r\n        vs = set([v])\r\n        component = []\r\n        while vs:\r\n            v = vs.pop()\r\n            seen.add(v)\r\n            vs |= set(graph[v]) - seen\r\n            component.append(v)\r\n        return component\r\n\r\n    ans = []\r\n    for v in graph:\r\n        if v not in seen:\r\n            d = dfs(v)\r\n            ans.append(d)\r\n    return ans\r\n\r\n\r\ndef primeFactors(n):\r\n    s = set()\r\n    while n % 2 == 0:\r\n        s.add(2)\r\n        n = n // 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):\r\n        while n % i == 0:\r\n            s.add(i)\r\n            n = n // i\r\n    if n > 2:\r\n        s.add(n)\r\n    return s\r\n\r\n\r\ndef find_all(a_str, sub):\r\n    start = 0\r\n    while True:\r\n        start = a_str.find(sub, start)\r\n        if start == -1:\r\n            return\r\n        yield start\r\n        start += len(sub)\r\n\r\n\r\ndef SieveOfEratosthenes(n, isPrime):\r\n    isPrime[0] = isPrime[1] = False\r\n    for i in range(2, n):\r\n        isPrime[i] = True\r\n    p = 2\r\n    while (p * p <= n):\r\n        if (isPrime[p] == True):\r\n            i = p * p\r\n            while (i <= n):\r\n                isPrime[i] = False\r\n                i += p\r\n        p += 1\r\n    return isPrime\r\n\r\n\r\ndef dijkstra(edges, f, t):\r\n    g = defaultdict(list)\r\n    for l, r, c in edges:\r\n        g[l].append((c, r))\r\n\r\n    q, seen, mins = [(0, f, ())], set(), {f: 0}\r\n    while q:\r\n        (cost, v1, path) = heappop(q)\r\n        if v1 not in seen:\r\n            seen.add(v1)\r\n            path = (v1, path)\r\n            if v1 == t:\r\n                return (cost, path)\r\n\r\n            for c, v2 in g.get(v1, ()):\r\n                if v2 in seen:\r\n                    continue\r\n                prev = mins.get(v2, None)\r\n                next = cost + c\r\n                if prev is None or next < prev:\r\n                    mins[v2] = next\r\n                    heappush(q, (next, v2, path))\r\n    return float(\"inf\")\r\n\r\n\r\ndef binsearch(a, l, r, x):\r\n    while l <= r:\r\n        mid = l + (r-1)//2\r\n        if a[mid]:\r\n            return mid\r\n        elif a[mid] > x:\r\n            l = mid-1\r\n        else:\r\n            r = mid+1\r\n    return -1\r\n\r\n\r\n# def input():\r\n#    return stdin.buffer.readline()\r\n\r\n\r\ndef readTree(n):\r\n    adj = [set() for _ in range(n)]\r\n    for _ in range(n-1):\r\n        u, v = map(int, input().split())\r\n        adj[u-1].add(v-1)\r\n        adj[v-1].add(u-1)\r\n    return adj\r\n\r\n\r\ndef treeOrderByDepth(n, adj, root=0):\r\n    parent = [-2] + [-1]*(n-1)\r\n    ordered = []\r\n    q = deque()\r\n    q.append(root)\r\n    depth = [0] * n\r\n    while q:\r\n        c = q.popleft()\r\n        ordered.append(c)\r\n        for a in adj[c]:\r\n            if parent[a] == -1:\r\n                parent[a] = c\r\n                depth[a] = depth[c] + 1\r\n                q.append(a)\r\n    return (ordered, parent, depth)\r\n\r\n\r\nfor _ in range(ii()):\r\n    n=ii()\r\n    l=[n]*n\r\n    print(*l)", "# cook your dish here\nt = int(input())\n\nwhile(t>0):\n    n = int(input())\n    k=1\n    while(k<=n):\n        print(k, end=' ')\n        k+=1\n    print('\\n')\n    t-=1", "# cook your dish here\n # Let's hack this code.\n\nfrom sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\nmod = 1000000007\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\n\ndef printIn(ob):\n    return stdout.write(str(ob))\n\ndef powerLL(n, p):\n    result = 1\n    while (p):\n        if (p&1):\n            result = result * n % mod\n        p = int(p / 2)\n        n = n * n % mod\n    return result\n\n#--------------------------------------\n\ndef myCode():\n    n = I()\n    for i in range(1,n+1):\n        print(i,end = ' ')\n    print('')\ndef main():\n    for t in range(I()):\n        myCode()\ndef __starting_point():\n    main()\n\n__starting_point()", "# cook your dish here\nt=int(input())\nwhile(t>0):\n    t-=1\n    n=int(input())\n    for i in range(n):\n        print(n,end=\" \")\n    print()\n", "def fun(n):\r\n\tfor i in range(n):\r\n\t\tif i!=n-1:\r\n\t\t\tprint(n,end=\" \")\r\n\t\telse:\r\n\t\t\tprint(n)\r\n\r\nt=int(input())\r\nfor _ in range(t):\r\n\tn=int(input())\r\n\tfun(n)", "# cook your dish here\nt=int(input())\nwhile(t>0):\n    t-=1\n    n=int(input())\n    for i in range(n):\n        print(n,end=\" \")\n    print()", "# cook your dish here\nt = int(input())\nwhile t>0:\n    n= int(input())\n    for i in range(1,n+1):\n        print(i,end=\" \")\n    print()\n    t-=1", "from sys import stdin,stdout\nfrom collections import defaultdict \nt=int(stdin.readline())\nfor _ in range(t):\n    n=int(stdin.readline())\n    for i in range(1,n+1):\n        stdout.write(str(i)+' ')\n    stdout.write('\\n')", "# cook your dish here\nt=int(input())\nfor r in range(t):\n    n=int(input())\n    for i in range(1,n+1):\n        print(i,end=\" \")\n        ", "for ad in range(int(input())):\n    n=int(input())\n    \n    for i in range(1,n+1):\n        print(i,end=\" \")    \n    print()", "# cook your dish here\nt = int(input())\n\nwhile(t>0):\n    n = int(input())\n    k=1\n    while(k<=n):\n        print(k, end=' ')\n        k+=1\n    print('\\n')\n    t-=1", "try:\r\n    for _ in range(int(input())):\r\n        n=int(input())\r\n        for i in range(1,n+1):\r\n            print(i,end=\" \")\r\n        print()\r\nexcept:\r\n    pass", "t=int(input())\r\nn=[]\r\nfor i in range(t):\r\n    a=int(input())\r\n    n.append(a)\r\nfor i in range(t):\r\n    for j in range(n[i]):\r\n        print(j+1,end=' ')\r\n    print()\r\n", "t = int(input())\r\n\r\nwhile(t>0):\r\n    n = int(input())\r\n    k=1\r\n    while(k<=n):\r\n        print(k, end=' ')\r\n        k+=1\r\n    print('\\n')\r\n    t-=1", "for _ in range(int(input())):\n    n = int(input())\n    for i in range(1,n+1):\n        print(i,end=\" \")\n    print()", "\n# cook your dish here\nfor i in range(int(input())):\n    \n    x=int(input())\n\n    for i in range(1,x+1):\n        print(i,end=' ')\n    print( )", "\"\"\"\n\n    Author - AYUSHMAN CHAHAR #\n\n\"\"\"\n\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\n#import numpy\nfrom itertools import combinations\nfrom itertools import permutations\nfrom collections import deque\nfrom atexit import register\nfrom collections import Counter\nfrom functools import reduce\nsys.setrecursionlimit(10000000)\n\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n  \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n \ndef main():\n    \n\tfor _ in range(int(eval(input()))):\n\t\tprint(*[ _ for _ in range(1, int(eval(input())) + 1)])     \n \ndef __starting_point():\n    sync_with_stdio(False)\n    main()\n \n\n__starting_point()", "t=int(input())\r\nwhile t>0:\r\n    n=int(input())\r\n    a=[]\r\n    for i in range(1,n+1):\r\n        print(i,end=\" \")\r\n        if(i==n):\r\n            print()\r\n        \r\n    t-=1", "# cook your dish here\nfor i in range(int(input())):\n    n=int(input())\n    for i in range(n):\n        print(i+1,end=\" \")", "# cook your dish here\ntry:\n    for _ in range(int(input())):\n        n=int(input())\n        li=[i for i in range(1,n+1)]\n        print(*li)\nexcept:\n    pass", "try:\n    for _ in range(int(input())):\n        n=int(input())\n        for i in range(1,n+1):\n            print(i,end=\" \")\n        print()\nexcept:\n    pass", "try:\r\n\tt=int(input())\r\n\tfor _ in range(t):\r\n\t\tn=int(input())\r\n\t\tarr=[]\r\n\t\tfor i in range(1,n+1):\r\n\t\t\tarr.append(i)\r\n\t\tprint(*arr)\r\nexcept:\r\n\tpass\r\n"]
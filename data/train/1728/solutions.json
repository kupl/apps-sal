["class PlayerMovement:\n    \n    PREC   = [8,        2,         4,        6]                                                                               # Order of precedence\n    I_KEYS = {8: 0,     2: 1,      4: 2,      6: 3}                                                                           # Index of the keys in self.pressed\n    MOVES  = {8: (0,1), 2: (0,-1), 4: (-1,0), 6: (1,0)}                                                                       # Moves directions\n\n    def __init__(self, x, y):\n        self.position  = Tile(x, y)                                                                                           # Current position\n        self.direction = 8                                                                                                    # Current direction of move\n        self.pressed   = [0,0,0,0]                                                                                            # Keys currently pressed or not (True/False)\n        self.stack     = []                                                                                                   # Stack representing the order of the pressed keys (according to pressing order AND precedence if multiple pressing at the same time)\n\n    def update(self):\n        state       = [Input.get_state(d) for d in self.PREC]                                                                 # State of the art at update time\n        \n        newPressed  =     [ d for i,d in enumerate(self.PREC) if not self.pressed[i] and state[i] ]                           # All keys freshly pressed\n        notReleased = next((d for d   in self.stack[::-1]  if self.pressed[self.I_KEYS[d]] and state[self.I_KEYS[d]]), None)  # Last key that has not been released yet (according to the order of the stack[::-1] because one search for the last pressed)\n        releasedLst =     [ d for i,d in enumerate(self.PREC) if self.pressed[i] and not state[i] ]                           # All keys freshly released\n        \n        if newPressed:                                                                                                        # If new key pressed:\n            self.direction = newPressed[0]                                                                                    #     Update direction with higher precedence\n            for t in newPressed[::-1]: self.stack.append(t)                                                                   #     append all the new kleys to the stack, lower preccedence first\n            \n        elif self.direction in releasedLst:                                                                                   # If the current direction has been released:\n            self.direction = notReleased or self.direction                                                                    #     upadte direction. If no pressed key remain, do not update\n                \n        elif notReleased:                                                                                                     # If current direction still pressed and no other key pressed in the meantime:\n            self.position  = Tile(*( z+dz for z,dz in zip([self.position.x, self.position.y], self.MOVES[notReleased]) ))     #     MOVE!\n            \n        self.pressed = state                                                                                                  # Archive current state of keys\n        for t in releasedLst: self.stack.remove(t)                                                                            # remove all the released keys from the stack, whatever their position in the stack is", "\nclass PlayerMovement:\n    def __init__(self, x, y):\n        self.position = Tile(x, y)\n        self.direction = 8\n        self.pressed = []\n\n    def update(self):\n        can_move = bool(self.pressed)\n        for key in [6, 4, 2, 8]:\n            pressed = Input.get_state(key)\n            if not pressed and key in self.pressed:\n                self.pressed.remove(key)\n            elif pressed and key not in self.pressed:\n                self.pressed.append(key)\n        if self.pressed:\n            if self.direction == self.pressed[-1] and can_move:\n                self.move(self.direction)\n            self.direction = self.pressed[-1]\n    \n    def move(self, direction):\n        dx, dy = PlayerMovement.DIR_VECT[direction]\n        self.position = Tile(\n            self.position.x + dx,\n            self.position.y + dy\n        )\n\nPlayerMovement.DIR_VECT = {8: (0, 1), 2: (0, -1), 4: (-1, 0), 6: (1, 0)}\n", "class PlayerMovement:                                              # class by MMMAAANNN @ codewars.com\n\n    KEYS = 6, 4, 2, 8                                              # In order of reverse priority\n    DIRS = dict(list(zip(KEYS, (( 1,  0),                               # Associating with directions\n                           (-1,  0),\n                           ( 0, -1),\n                           ( 0,  1)))))\n    \n    def __init__(self, x, y):\n        self.position  = Tile(x, y)\n        self.direction = 8\n        self.previous  = {i: False for i in self.KEYS}            # Event detection\n        self.keystack  = [0]                                      # The order of keypress\n\n    def update(self):\n        current = dict(list(Input.STATES.items()))                      # Read current state\n        if (current != self.previous):                            # Skip recalc if no events happened\n            change = {i : current[i] - self.previous[i]           # Calculate type of change\n                      for i in self.KEYS}\n            for key in self.KEYS:                                 # Update the status of keystack\n                if   change[key] > 0:\n                    self.keystack.append(key)\n                elif change[key] < 0:\n                    self.keystack.remove(key)\n        if (self.keystack[-1] == self.direction                   # Movement only if no turn required\n            and sum(self.previous.values())):                     # Avoid moving if first event after idle\n            dx, dy = self.DIRS[self.direction]                    # Reading the movement vector\n            self.position = Tile(self.position.x + dx,            # Updating coordinates: x\n                                 self.position.y + dy)            #               ... and y\n        else:\n            self.direction = self.keystack[-1] or self.direction  # Turning if needed\n        self.previous = current                                   # Remember state to detect next event\n", "class PlayerMovement:\n\n   def __init__(self, x, y):\n      self.position = Tile(x, y)\n      self.direction = 8\n      self.stack = []\n      self.moves = {8:[0,1],2:[0,-1],4:[-1,0],6:[1,0]}\n\n   def update(self):\n      # release\n      self.stack = list(filter(lambda x: Input.get_state(x),self.stack))\n\n      # push\n      firsttimer = False\n      for i in [6,4,2,8]:\n         if not i in self.stack and Input.get_state(i):\n            firsttimer = True\n            self.stack.append(i)\n      \n      if not self.stack:\n         return\n      \n      winner = self.stack[-1]\n\n      if winner != self.direction or firsttimer:\n         self.direction = winner\n      else:\n         move = self.moves[self.direction]\n         self.position =  Tile(self.position.x+move[0], self.position.y+move[1])", "from enum import IntEnum\n\nclass PlayerMovement:\n\n    class Dir(IntEnum):\n        UP = 4\n        DOWN = 3\n        LEFT = 2\n        RIGHT = 1\n        \n        @classmethod\n        def get_dir(cls, key):\n            map = {8: cls.UP, 2: cls.DOWN, 4: cls.LEFT, 6: cls.RIGHT}\n            return map[key]\n        \n        @classmethod\n        def get_key(cls, dir):\n            map = {cls.UP: 8, cls.DOWN: 2, cls.LEFT: 4, cls.RIGHT: 6}\n            return map[dir]\n        \n        @classmethod\n        def get_move(cls, dir):\n            map = {cls.UP: (0,1), cls.DOWN: (0, -1), cls.LEFT: (-1, 0), cls.RIGHT: (1, 0)}\n            return map[dir]\n            \n                            \n    def __init__(self, x, y):\n        self.position = Tile(x, y)\n        self.direction = 8\n        self.directions = []\n\n    def update_directions(self):\n        pressed = [self.Dir.get_dir(x) for x in (8, 2, 4, 6) if Input.get_state(x)==True]\n        self.directions = [x for x in self.directions if x in pressed]\n        pressed.sort()\n        for x in pressed:\n            if x not in self.directions:\n                self.directions.append(x)\n\n    def update(self):\n        directions_before = self.directions\n        self.update_directions()\n        if len(self.directions) == 0:\n            pass\n        elif self.directions[-1] != self.Dir.get_dir(self.direction) \\\n        or self.directions[-1] not in directions_before:\n            self.direction = self.Dir.get_key(self.directions[-1])\n        else:\n            move = self.Dir.get_move(self.directions[-1])\n            self.position = Tile(self.position.x + move[0], self.position.y + move[1])\n", "class PlayerMovement:\n    \n    PREC   = [8,        2,         4,        6]                                                                               # Order of precedence\n    I_KEYS = {8: 0,     2: 1,      4: 2,      6: 3}                                                                           # Index of the keys in self.pressed\n    MOVES  = {8: (0,1), 2: (0,-1), 4: (-1,0), 6: (1,0)}                                                                       # Moves directions\n\n    def __init__(self, x, y):\n        self.position  = Tile(x, y)                                                                                           # Current position\n        self.direction = 8                                                                                                    # Current direction of move\n        self.pressed   = [0,0,0,0]                                                                                            # Keys currently pressed or not (True/False)\n        self.stack     = []                                                                                                   # Stack representing the order of the pressed keys (according to pressing order AND precedence if multiple pressing at the same time)\n\n    def update(self):\n        state       = [Input.get_state(d) for d in self.PREC]                                                                 # State of the art at update time\n        \n        newPressed  =     [ d for i,d in enumerate(self.PREC) if not self.pressed[i] and state[i] ]                           # All keys freshly pressed\n        notReleased = next((d for d   in self.stack[::-1]  if self.pressed[self.I_KEYS[d]] and state[self.I_KEYS[d]]), None)  # Last key that has not been released yet (according to the order of the stack[::-1] because one search for the last pressed)\n        releasedLst =     [ d for i,d in enumerate(self.PREC) if self.pressed[i] and not state[i] ]                           # All keys freshly released\n        \n        if newPressed:                                                                                                        # If new key pressed:\n            self.direction = newPressed[0]                                                                                    #     Update direction with higher precedence\n            for t in newPressed[::-1]: self.stack.append(t)                                                                   #     append all the new kleys to the stack, lower preccedence first\n            \n        elif self.direction in releasedLst:                                                                                   # If the current direction has been released:\n            self.direction = notReleased or self.direction                                                                    #     upadte direction. If no pressed key remain, do not update\n                \n        elif notReleased:                                                                                                     # If current direction still pressed and no other key pressed in the meantime:\n            self.position  = Tile(*( z+dz for z,dz in zip([self.position.x, self.position.y], self.MOVES[notReleased]) ))     #     MOVE!\n            \n        self.pressed = state                                                                                                  # Archive current state of keys\n        for t in releasedLst: self.stack.remove(t)                                        ", "class PlayerMovement:\n    def __init__(self, x, y):\n        self.position = Tile(x, y)\n        self.direction = 8\n        self.pressed = []\n        self.movements = {8: (0, 1), 2: (0, -1), 6: (1, 0), 4: (-1, 0)}\n\n    def update(self):\n        newkey = False\n        if any(Input.get_state(x) for x in (2, 4, 6, 8)):\n            for x in (6, 4, 2, 8):\n                if Input.get_state(x):\n                    if not x in self.pressed:\n                        self.pressed.append(x)\n                        self.direction = x\n                        newkey = True\n                else:\n                    if x in self.pressed:\n                        if self.pressed[-1] == x:\n                            newkey = True\n                            if len(self.pressed) > 1:\n                                self.direction = self.pressed[-2]\n                        self.pressed.remove(x)\n        else:\n            self.pressed = []\n            newkey = True\n        if not newkey:\n            self.position = Tile(self.position.x + self.movements[self.direction][0], self.position.y + self.movements[self.direction][1])", "class PlayerMovement:\n    def __init__(self, x, y):\n        self.position = Tile(x, y)\n        self.direction = 8\n        self.pressed = []\n        self.movements = {8: (0, 1), 2: (0, -1), 6: (1, 0), 4: (-1, 0)}\n\n    def update(self):\n        newkey = False\n        if any(Input.get_state(x) for x in (2, 4, 6, 8)):\n            if Input.get_state(6):\n                if not 6 in self.pressed:\n                    self.pressed.append(6)\n                    self.direction = 6\n                    newkey = True\n            else:\n                if 6 in self.pressed:\n                    if self.pressed[-1] == 6:\n                        newkey = True\n                        if len(self.pressed) > 1:\n                            self.direction = self.pressed[-2]\n                    self.pressed.remove(6)\n    \n            if Input.get_state(4):\n                if not 4 in self.pressed:\n                    self.pressed.append(4)\n                    self.direction = 4\n                    newkey = True\n            else:\n                if 4 in self.pressed:\n                    if self.pressed[-1] == 4:\n                        newkey = True\n                        if len(self.pressed) > 1:\n                            self.direction = self.pressed[-2]\n                    self.pressed.remove(4)\n            \n            if Input.get_state(2):\n                if not 2 in self.pressed:\n                    self.pressed.append(2)\n                    self.direction = 2\n                    newkey = True\n            else:\n                if 2 in self.pressed:\n                    if self.pressed[-1] == 2:\n                        newkey = True\n                        if len(self.pressed) > 1:\n                            self.direction = self.pressed[-2]\n                    self.pressed.remove(2)\n            \n            if Input.get_state(8):\n                if not 8 in self.pressed:\n                    self.pressed.append(8)\n                    self.direction = 8\n                    newkey = True\n            else:\n                if 8 in self.pressed:\n                    if self.pressed[-1] == 8:\n                        newkey = True\n                        if len(self.pressed) > 1:\n                            self.direction = self.pressed[-2]\n                    self.pressed.remove(8)\n                    \n        else:\n            self.pressed = []\n            newkey = True\n        \n        if not newkey and self.pressed:\n            self.position = Tile(self.position.x + self.movements[self.direction][0], self.position.y + self.movements[self.direction][1])\n", "from collections import Counter\nclass PlayerMovement:\n\n    def __init__(self, x, y):\n        self.position = Tile(x, y)\n        self.direction = 8\n        self.moves = {8:[0,1],2:[0,-1],4:[-1,0],6:[1,0]}\n        self.keys = []\n    def update(self):\n        release = [i for i in [8,2,4,6] if not Input.get_state(i)]\n        if any(i in self.keys for i in release):\n            if len(self.keys)==1 : return self.keys.pop()\n            for i in release:\n                if i in self.keys : self.keys.pop(len(self.keys)-self.keys[::-1].index(i)-1)\n            if not self.keys : return\n            if self.direction == self.keys[-1]:\n                  inc,dec = self.moves[self.direction]\n                  self.position = Tile(self.position.x+inc,self.position.y+dec)\n            self.direction = self.keys[-1]\n        else:\n            direction = [i for i in [8,2,4,6] if Input.get_state(i)]\n            new, c = list((Counter(direction)-Counter(self.keys)).elements()), bool(self.keys)\n            if not new and not self.keys : return\n            self.keys.extend(sorted(new,key=[6,4,2,8].index))\n            d = self.keys[-1]\n            if not c or (d != self.direction): self.direction = d ; return\n            inc,dec = self.moves[self.direction]\n            self.position = Tile(self.position.x+inc,self.position.y+dec)", "KEYS = [\"Right\", \"Left\", \"Down\", \"Up\"]\nDIRS = [6, 4, 2, 8]\nKEYS_DIR = {6: \"Right\", 4: \"Left\", 2: \"Down\", 8: \"Up\"}\nKEYS_DIR_REV = {\"Right\": 6, \"Left\": 4, \"Down\": 2, \"Up\": 8}\nMOVE = [(1, 0), (-1, 0), (0, -1), (0, 1)]\nfirstTime = False\n\nclass PlayerMovement:\n\n    def __init__(self, x, y):\n        self.position = Tile(x, y)\n        self.direction = 8\n        self.pressedList = []\n\n    def update(self):\n        savedDirection = self.direction\n        savedLen = len(self.pressedList)\n        i = 0\n        firstTime = False\n        while i < 4:\n            Dir = KEYS_DIR_REV[KEYS[i]]\n            Key = KEYS_DIR[DIRS[i]]\n            if Input.get_state(Dir):\n                if Key not in self.pressedList:\n                    self.pressedList.append(Key)\n                    self.direction = KEYS_DIR_REV[Key]\n                    firstTime = True\n            else:\n                if Key in self.pressedList:\n                    if self.pressedList[-1] == Key:\n                        del self.pressedList[-1]\n                        if len(self.pressedList) > 0:\n                            self.direction = KEYS_DIR_REV[self.pressedList[-1]]\n                            firstTime = True\n                    else:\n                        del self.pressedList[self.pressedList.index(Key)]\n            i += 1\n        if len(self.pressedList) > 0 and firstTime == False:\n            index = KEYS.index(self.pressedList[-1])\n            self.position = Tile(self.position.x + MOVE[index][0], self.position.y + MOVE[index][1])\n        if savedLen > 0:\n            check = 0\n            for D in DIRS:\n                if Input.get_state(D):\n                    check = 1\n                    break\n            if check == 0:\n                self.direction = savedDirection\n"]
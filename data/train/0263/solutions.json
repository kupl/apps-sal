["class Solution:\n    dp = [[1] * 10]\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        for i in range(len(self.dp), n):\n            new = [0] * 10\n            for j in range(10):\n                new[j] = sum(self.dp[-1][k] for k in jump[j]) % MOD\n            self.dp.append(new)\n        return sum(self.dp[n - 1]) % MOD\n", "from functools import lru_cache\n\nmapping = [\n            [4, 6], # 0\n            [6, 8], # 1\n            [7, 9], # 2\n            [4, 8], # 3\n            [0, 3, 9], # 4\n            [], # 5\n            [0, 1, 7], # 6\n            [2, 6], # 7\n            [1, 3], # 8\n            [2, 4] # 9\n        ]\n\nmod = 1000_000_007\n\n@lru_cache(None)\ndef dfs(n, i):\n        if n == 1:\n            return 1\n        \n        sum_ = 0\n        for nei in mapping[i]:\n            sum_ = (sum_ + dfs(n -1, nei)) % mod\n            \n        return sum_    \n    \nclass Solution:            \n    def knightDialer(self, N: int) -> int:                \n        total = 0\n        for i in range(10):\n            total = (total + dfs(N, i)) % mod\n            \n        return total", "import numpy as np\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n#         d = {1:[6,8],\n#              2:[7,9],\n#              3:[4,8],\n#              4:[3,9,0],\n#              5:[],\n#              6:[1,7,0],\n#              7:[2,6],\n#              8:[1,3],\n#              9:[2,4],\n#              0:[4,6]}\n#         @lru_cache(None)\n#         def dfs(i, n):\n#             if n == 1:\n#                 return 1\n#             else:\n#                 res = 0\n#                 for c in d[i]:\n#                     res += dfs(c, n-1)\n#                 return res % (10**9+7)\n            \n#         return sum(dfs(i, n) for i in range(10)) % (10**9+7)\n    \n        mod = 10**9 + 7\n        N = n\n        if N == 1: return 10\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        res, N = 1, N - 1\n        while N:\n            if N % 2: res = res * M % mod\n            M = M * M % mod\n            N //= 2\n        return int(np.sum(res)) % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # dp[neigh] at step k += dp[curr]\n        possibleMoves = [[4,6], [6,8],[9,7],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3], [2,4]]\n        dp = [1]*10\n        upper = 10**9 + 7\n        for i in range(n-1):\n            dp2 = [0]*10\n            for j in range(10):\n                for adj in possibleMoves[j]:\n                    dp2[adj] = (dp2[adj] + dp[j])%upper\n            dp = dp2\n        return sum(dp)%upper\n                    \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        \n        \n        \n        table = [[0 for col in range(10)] for row in range(N+1)]\n        \n        for val in range(10):\n            table[1][val] = 1\n            \n            \n        \n        for i in range(2,N+1):\n            table[i][0] = table[i-1][4] + table[i-1][6]\n            table[i][1] = table[i-1][6] + table[i-1][8]\n            table[i][2] = table[i-1][7] + table[i-1][9]\n            table[i][3] = table[i-1][4] + table[i-1][8]\n            table[i][4] = table[i-1][3] + table[i-1][9] + table[i-1][0]\n            table[i][5] = 0\n            table[i][6] = table[i-1][7] + table[i-1][1] + table[i-1][0]\n            table[i][7] = table[i-1][2] + table[i-1][6]\n            table[i][8] = table[i-1][1] + table[i-1][3]\n            table[i][9] = table[i-1][2] + table[i-1][4]\n\n            \n        return sum(table[-1])%(10**9 + 7)\n\n        \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        move = {1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 5:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]}\n        \n        curr_dial = [1] * 10\n        for _ in range(n-1):\n            next_dial = [0] * 10\n            for key in range(10):\n                for neighbor in move[key]:\n                    next_dial[neighbor] = (next_dial[neighbor] + curr_dial[key]) % (10 ** 9 +7)\n                \n            curr_dial = next_dial\n            \n        return sum(curr_dial) % (10 ** 9 +7)\n    \n#         case = set()\n        \n#         def dfs(curr = \\\"\\\", k = 0):\n#             if k == n:\n#                 case.add(curr)\n#                 return\n#             if k == 0:\n#                 for i in range(10):\n#                     dfs(curr + str(i), k+1)\n#             else:\n#                 for i in move[int(curr[-1])]:\n#                     dfs(curr + str(i), k+1)\n        \n#         dfs()    \n            \n#         return len(case) % (10 ** 9 +7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        # Space O(10)\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1] * 10\n        MOD = 10**9 + 7\n        for i in range(N - 1):\n            next_dp = [0] * 10\n            for j in range(10):\n                for next_digit in moves[j]:\n                    next_dp[j] = (next_dp[j] + dp[next_digit]) % MOD\n            dp = next_dp\n        return sum(dp) % MOD\n        \n        # space O(10 * N)\n        mapping = {1:[6,8], \n                   2:[7,9], \n                   3:[4,8], \n                   4:[3,9,0],\n                   5:[],\n                   6:[1,7,0],\n                   7:[2,6], \n                   8:[1,3], \n                   9:[2,4], \n                   0:[4,6]}\n        dp = [[1] * 10 for _ in range(N)]\n        dp[0] = [1] * 10\n        for i in range(1, N):\n            for j in range(10):\n                for k in mapping[j]:\n                    dp[i][j] += dp[i - 1][k]\n        return sum(dp[-1]) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [\n            [4, 6],\n            [6, 8],\n            [7, 9],\n            [4, 8],\n            [0, 3, 9],\n            [],\n            [0, 1, 7],\n            [2, 6],\n            [1, 3],\n            [2, 4],\n        ]\n        kmod = 10**9 + 7\n        dp = [1] * 10\n        for k in range(1, n):\n            tmp = [0] * 10\n            for i in range(10):\n                for j in moves[i]:\n                    tmp[j] = (tmp[j] + dp[i]) % kmod\n            dp = tmp\n        res = 0\n        for i in range(10):\n            res = (res + dp[i]) % kmod\n        return res", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        valid_moves = [\n            [4, 6], \n            [6, 8], \n            [7, 9],\n            [4, 8],\n            [0, 3, 9], \n            [],\n            [0, 1, 7],\n            [2, 6],\n            [1, 3],\n            [2, 4]\n        ]\n        \n        dp = [1] * 10\n        m = 10 ** 9 + 7\n        for _ in range(n-1):\n            new_dp = [0] * 10\n            for i in range(10):\n                for j in valid_moves[i]:\n                    new_dp[j] += dp[i] % m\n            dp = new_dp\n        return sum(dp) % m\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n        memo = [1]*10\n        maxV = (10**9+7)\n        for _ in range(N-1):\n            temp = [0]*10\n            for i in range(10):\n                for dest in moves[i]:\n                    temp[i] += memo[dest]\n                temp[i] %= (10**9+7)\n            memo = temp\n                    \n        return sum(memo)%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        \n        #dp[i][j] possible answers at step[i], number j\n        dp =[0 for _ in range(10)]\n        #possible next moves\n        move = [[4,6], [6,8], [7,9], [4,8], [3,9,0], [], [1,7,0], [2,6], [1,3], [4,2]]\n        #noundary condition, initialization at n = 0, dp[0][j] = 1\n        dp = [1  for _ in range(10)]\n        #transfer equation\n        for i in range(n-1):\n            dp2 = [0]*10\n            for j in range(10):\n                for nei in move[j]:\n                    dp2[nei] = (dp2[nei] + dp[j])%MOD\n            dp = dp2\n        #final answer\n        return sum(dp)%MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        movements = {\n        0:(4,6),\n        1:(6,8),\n        2:(7,9),\n        3:(4,8),\n        4:(0,3,9),\n        5:(),\n        6:(0,1,7),\n        7:(2,6),\n        8:(1,3),\n        9:(2,4)\n        }\n        total = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        for _ in range(n - 1):\n            curr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            for num in range(10):\n                for move in movements[num]:\n                    curr[move] = (curr[move] + total[num]) % (10 ** 9 + 7)\n            total = curr\n        return sum(total) % (10**9 + 7)", "import numpy as np\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        mod = 10**9 + 7\n        moves = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        res = np.matrix([[1]*10])\n\n        N -= 1\n        while N:\n            if N % 2 != 0: \n                res = res * moves % mod     \n                N -= 1\n            else:\n                moves = moves * moves % mod\n                N //= 2\n        return int(np.sum(res)) % mod\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        mod = 10**9+7\n        next_dic = {}\n        next_dic[1] = [8,6]\n        next_dic[2] = [7,9]\n        next_dic[3] = [4,8]\n        \n        next_dic[4] = [3,9,0]\n        next_dic[5] = []\n        next_dic[6] = [7,1,0]\n        \n        next_dic[7] = [2,6]\n        next_dic[8] = [3,1]\n        next_dic[9] = [2,4]\n        \n        next_dic[0] = [6,4]\n        \n        dp  = [1]*10\n        for i in range(n-1):\n            dp_new = [0]*10\n            for i in range(10):\n                for move in next_dic[i]:\n                    dp_new[move] = (dp_new[move]+dp[i])%mod\n            del dp\n            dp = dp_new\n        return sum(dp)%mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # Neighbors maps K: starting_key -> V: list of possible destination_keys\n        neighbors = {\n            0:(4,6),\n            1:(6,8),\n            2:(7,9),\n            3:(4,8),\n            4:(0,3,9),\n            5:(),\n            6:(0,1,7),\n            7:(2,6),\n            8:(1,3),\n            9:(2,4)\n        }\n        current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        for _ in range(n-1):\n            next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            for src_key in range(10):\n                for dst_key in neighbors[src_key]:\n                    next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\n            current_counts = next_counts\n        return sum(current_counts) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        M = 10 ** 9 + 7\n        d = {1: [6, 8], 2: [7, 9], 3:[4, 8], 4: [3, 9, 0], 5: [],\n             6: [0, 1, 7], 7: [6, 2], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        \n        out = [1] * 10\n        for _ in range(N - 1):\n            out1 = [0] * 10\n            for j in range(10):\n                for k in d[j]:\n                    out1[k] += out[j] % M\n            out = out1\n        return sum(out) % M\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9+7\n        dic = {0:[4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 5:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[4,2]}\n        counts = [1,1,1,1,1,1,1,1,1,1]\n        for k in range(n-1):\n            new = [0,0,0,0,0,0,0,0,0,0]\n            for i in range(10):\n                for j in dic[i]:\n                    new[j] = (new[j]+counts[i])%mod\n            counts = new\n        return sum(counts)%mod\n                \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        # Neighbors maps K: starting_key -> V: list of possible destination_keys\n        neighbors = {\n            0:(4,6),\n            1:(6,8),\n            2:(7,9),\n            3:(4,8),\n            4:(0,3,9),\n            5:(),\n            6:(0,1,7),\n            7:(2,6),\n            8:(1,3),\n            9:(2,4)\n        }\n        current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        for _ in range(N-1):\n            next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            for src_key in range(10):\n                for dst_key in neighbors[src_key]:\n                    next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\n            current_counts = next_counts\n        return sum(current_counts) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {1:(6, 8), 2:(7, 9), 3:(4,8), 4: (0, 3, 9), 5:(), 6: (0, 1, 7), 7:(2, 6), 8:(1, 3), 9:(2, 4), 0:(4,6)}\n        prev = [1] * 10\n        \n        for dial in range(n - 1):\n            nex = [0] * 10\n            for curNum in range(10):\n                for nexNum in d[curNum]:\n                    nex[nexNum] = (nex[nexNum] + prev[curNum]) % (10**9+ 7)\n            prev = nex [:]\n        return sum(prev)%(10**9+ 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4, 6],[6, 8],[7, 9],[4, 8]\n                 ,[0, 3, 9],[],[0, 1, 7]\n                 ,[2, 6],[1, 3],[2, 4]]\n        dp = [1] * 10\n        for _ in range(n-1):\n            dp2 = [0] * 10\n            for i, cnt in enumerate(dp):\n                for nxt in moves[i]:\n                    dp2[nxt] += cnt\n            dp = dp2\n        return sum(dp) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # time O(n); space O(1)\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[], [1,7,0],[2,6],[1,3],[2,4]]\n        \n        dp = [1] * 10\n        for hop in range(n-1):\n            new_dp = [0] * 10\n            for node, cnt in enumerate(dp):\n                for nei in moves[node]:\n                    new_dp[nei] += cnt\n            dp = new_dp\n        \n        return sum(dp) % (10**9+7)", "class Solution:\n    def knightDialer1(self, N: int) -> int:\n        m,n = 4,3\n        M = 10**9+7\n        def dp(i,j,k):\n            if k==0:\n                return 1\n            out = 0\n            for x,y in [(i+2,j+1),(i-2,j+1),(i+2,j-1),(i-2,j-1),\n                       (i+1,j+2),(i+1,j-2),(i-1,j+2),(i-1,j-2)]:\n                if 0<=x<m and 0<=y<n and (x!=3 or y not in [0,2]):\n                    out += dp(x,y,k-1)\n            return out\n        out = 0\n        for i in range(m):\n            for j in range(n):\n                if i!=m-1 or j not in [0,2]:\n                    out+=dp(i,j,N-1)\n        return out\n    def knightDialer(self, N: int) -> int:\n        M = 10**9+7\n        d = {1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4],0:[4,6]}\n        \n        out = [1]*10\n        for i in range(N-1):\n            out1=[0]*10\n            for j in range(10):\n                for k in d[j]:\n                    out1[k]+=out[j]%M\n            out=out1\n        return sum(out)%M\n", "class Solution:\n    def helper(self,cache,position,num_hops):\n        neighbors = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n             [1,7,0],[2,6],[1,3],[2,4]]\n        if (position, num_hops) in cache:\n            return cache[ (position, num_hops) ]\n\n        if num_hops == 0:\n            return 1\n\n        else:\n            num_sequences = 0\n            for neighbor in neighbors[position]:\n                num_sequences += self.helper(cache,neighbor, num_hops - 1)\n            cache[ (position, num_hops) ] = num_sequences\n        return num_sequences\n        \n    def knightDialer(self, n: int) -> int:\n            neighbors = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n             [1,7,0],[2,6],[1,3],[2,4]]\n            prior_case = [1] * 10                                     \n            current_case = [1] * 10                                   \n            current_num_hops = 1                                    \n\n            while current_num_hops < n:                       \n                current_case = [0] * 10                               \n                current_num_hops += 1                                 \n\n                for position in range(0, 10):                         \n                    for neighbor in neighbors[position]:              \n                        current_case[position] += prior_case[neighbor]\n                prior_case = current_case                             \n\n            return sum(current_case) % (10**9 + 7)\n    \n\n\n\n        \n        \n                    \n                    \n                    \n                \n", "class Solution:\n    \n    BASE = 10 ** 9 + 7\n    \n    def knightDialer(self, N: int) -> int:\n        if N <= 1:\n            return 10\n        a, b, c, d = 2, 4, 2, 1\n        for _ in range(N - 1):\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\n        return (a + b + c + d) % self.BASE", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        dic={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n        dp=[1 for i in range(10)]\n        for i in range(N-1):\n            new_dp=[0 for j in range(10)]\n            for j in range(10):\n                for k in dic[j]:\n                    new_dp[j]+=dp[k]\n                new_dp[j]%=(10**9+7)\n            dp=new_dp\n        return sum(dp)%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4, 6],[6, 8],[7, 9],[4, 8]\n         ,[0, 3, 9],[],[0, 1, 7]\n         ,[2, 6],[1, 3],[2, 4]]\n        dp = [1] * 10\n        for _ in range(n-1):\n            dp2 = [0] * 10\n            for i, cnt in enumerate(dp):\n                for nxt in moves[i]:\n                    dp2[nxt] += cnt\n            dp = dp2\n        return sum(dp) % (10**9 + 7)\n    # time:  O(n)\n    # space: O(1)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        total_jumps = [1] * 10  #base case you can be placed ANYWHERE \n        #These are your neighbors where you jumping to with your knight mover \n        neighbors = { \n            0:(4,6),\n            1:(6,8),\n            2:(7,9),\n            3:(4,8),\n            4:(0,3,9),\n            5:(),\n            6:(0,1,7),\n            7:(2,6),\n            8:(1,3),\n            9:(2,4)\n        \n        }\n        \n        #jumps allowed is n - 1 \n        for jumps_left in range(n - 1): \n            #our next_jumps \n            next_jumps = [0] * 10 \n            for num in range(0, 10): \n                for next_num in neighbors[num]: \n                    next_jumps[next_num] = next_jumps[next_num] + total_jumps[num] % (10 ** 9 + 7)\n                    \n            total_jumps = next_jumps\n            \n        return sum(total_jumps) % (10 ** 9 + 7)\n\n                    \n# class Solution():            \n    # def count_sequences(start_position, num_hops):                \n    #     prior_case = [1] * 10                                     \n    #     current_case = [0] * 10                                   \n    #     current_num_hops = 1                                      \n\n    #     while current_num_hops <= num_hops:                       \n    #         current_case = [0] * 10                               \n    #         current_num_hops += 1                                 \n\n    #         for position in range(0, 10):                         \n    #             for neighbor in neighbors(position):              \n    #                 current_case[position] += prior_case[neighbor]\n    #         prior_case = current_case                             \n\n    #     return current_case[start_position]              \n# class Solution:\n#     def knightDialer(self, n: int) -> int:\n#         #knight -> up or down (2 steps) and move left or right ( 1step)\n#         #knight -> move left or right (2 steps) and move up and down (1 step)\n        \n#         #We have a Knight as shown above\n#         #We also have a numer pad and can ONLY stand on numbers \n        \n#         #Given an int -> n move the knight on any numeric cell and then perform n-1 jumps to dial a number of length n \n#         #Return the answer modulo 10^9 + 7 \n\n#         neighbors = { \n#             0:(4,6),\n#             1:(6,8),\n#             2:(7,9),\n#             3:(4,8),\n#             4:(0,3,9),\n#             5:(),\n#             6:(0,1,7),\n#             7:(2,6),\n#             8:(1,3),\n#             9:(2,4)\n        \n#         }\n    \n#         cur_numpads = [1] * 10 \n        \n#         for pos in range(n - 1): \n#             next_numpads_num = [0] * 10\n            \n#             for cur_key in range(10):\n#                 for next_key in neighbors[cur_key]:\n#                     next_numpads_num[next_key] = next_numpads_num[next_key] + cur_numpads[cur_key] % (10 ** 9 + 7)\n                    \n#             cur_numpads = next_numpads_num \n        \n#         return sum(cur_numpads) % (10**9 + 7)\n", "class Solution:    \n    def knightDialer(self, n: int) -> int:\n        dp = [1 for _ in range(10)]\n        BASE = 10**9+7\n        data = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        \n        for i in range(n-1):\n            dp_tmp = []\n            for j in range(10):\n                sum_tmp = 0\n                for k in data[j]:\n                    sum_tmp += (dp[k] % BASE)\n                dp_tmp.append(sum_tmp % BASE)\n            dp = dp_tmp\n        \n        return sum(dp) % BASE\n        \n\n        \n        \n", "class Solution:\n    def knightDialer(self, n):\n        dmap = [[4, 6], [8, 6], [7, 9], [8, 4], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4],[4, 6]]\n        mod_val = 10 ** 9 + 7\n        ans = 0\n        dp1 = [1]*10\n        dp2 = [0]*10\n        \n        for _ in range(2, n+1):\n            for j in range(0, 10):\n                tv = dmap[j]\n                for t in tv:\n                    dp2[j] += dp1[t] % mod_val\n            dp1 = dp2[:]\n            dp2 = [0]*10\n        #print(dp)\n        ans = sum(dp1) % mod_val\n        return ans\n", "class Solution:\n    \n    def __init__(self):\n        self.paths = {1: [8, 6], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n    \n    def knightDialer(self, n: int) -> int: # 3\n        constant = 10**9+7\n        if n == 0:\n            return 0\n        \n        # Stream\n        prev_cache = [1 for i in range(10)]\n        cache = [0 for i in range(10)]\n        \n        for i in range(n-1):\n            # print(prev_cache)\n            for j in range(10):\n                total_sum = 0\n                for adj_num in self.paths[j]:\n                    total_sum += prev_cache[adj_num]\n                cache[j] = total_sum\n                # print(j, total_sum)\n            # print(cache)\n            prev_cache, cache = cache, prev_cache\n            \n        return sum(prev_cache) % constant\n        \n        \n        # Below is recur\n        # ways(0, 3)\n            # ways(4, 2)\n                # ways(3, 1)\n                    # ways(4, 0)\n                        # return 0\n                    # ways(8, 0) # 0\n                # ways(9, 1)\n                # ways(0, 1)\n            # ways(6, 2)\n        \n#         cache = {}\n        \n#         # @lru_cache\n#         def ways(number, turns):\n#             if turns < 2:\n#                 return turns\n            \n#             key = (number, turns)\n#             if key in cache:\n#                 return cache[key]\n            \n#             total_ways = 0\n#             for new_number in self.paths[number]:\n#                 total_ways += ways(new_number, turns-1)\n            \n#             cache[key] = total_ways % (10**9+7)\n            \n#             return cache[key]\n                \n#         total_ways = 0 # 0\n#         for i in range(10):\n#             total_ways += ways(i, n) # \n#         return total_ways % (10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9 + 7\n\n        d = dict()\n        d[0] = {4, 6}\n        d[1] = {6, 8}\n        d[2] = {7, 9}\n        d[3] = {4, 8}\n        d[4] = {0, 3, 9}\n        d[6] = {0, 1, 7}\n        d[7] = {2, 6}\n        d[8] = {1, 3}\n        d[9] = {2, 4}\n        \n#         memo = [[0]*10 for i in range(n+1)]\n#         memo[1] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        \n#         for i in range(2, n+1):\n#             for key, val in d.items():\n#                 for v in val:\n#                     memo[i][key] += memo[i-1][v]\n        \n        # memo = [[0]*10 for i in range(n+1)]\n        memo = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        memo2 = [0]*10\n        \n        for i in range(2, n+1):\n            for key, val in list(d.items()):\n                for v in val:\n                    memo2[key] += memo[v]\n            memo = memo2\n            memo2 = [0]*10\n        \n        return sum(memo)%mod\n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        prior_case = [1] * 10                                     \n        current_case = [0] * 10                                   \n        current_num_hops = 1                                      \n                                                              \n        while current_num_hops < n:                       \n            current_case = [0] * 10                               \n            current_num_hops += 1                                 \n                                                              \n            for position in range(0, 10):                         \n                for neighbor in neighbors[position]:              \n                    current_case[position] += prior_case[neighbor]\n            prior_case = current_case \n            # print(sum(prior_case))\n            \n        return sum(prior_case) % (10**9 + 7)\n        '''\n        moves = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        # down up dp appraoch\n        prev_level = [1] * 10 # base\n        curr_level = [0] * 10\n        level = 1\n        \n        while level < n:\n            \n            for num in range(10):\n                for reachable in moves[num]:\n                    curr_level[reachable] += prev_level[reachable]\n                    \n            level += 1\n            prev_level = curr_level\n            curr_evel = [0] * 10\n            print(sum(prev_level))\n            \n        return sum(prev_level)\n        '''", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        cur_count = [1] * 10 \n        for _ in range(n-1):\n            next_count = [0] * 10 \n            for src_key in range(10):\n                for dst_key in moves[src_key]:\n                    next_count[dst_key] += cur_count[src_key]\n                    \n            cur_count = next_count\n        \n        return sum(cur_count) % 1000000007\n\n", "class Solution:    \n    def knightDialer(self, N: int) -> int:\n        MOD = 1000000007\n            \n        if N == 1:\n            return 10\n        \n        a, b, c, d = 1, 1, 1, 1\n        for _ in range(N-1):\n            a, b, c, d = (c + b) % MOD, (2*a + d) % MOD, (2*a) % MOD, (2*b) % MOD\n            \n        return (4 * a + 2 * b + 2 * c + d) % MOD\n", "class Solution(object):\n    def knightDialer(self, N):\n        MOD = 10**9 + 7\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\n\n        dp = [1] * 10\n        for hops in range(N - 1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 10\n        \n        pad = {\n            0: (4,6),\n            1: (6, 8),\n            2: (7,9),\n            3: (4,8),\n            4: (0, 3, 9),\n            5: tuple(),\n            6: (0,1,7),\n            7: (2,6),\n            8: (1,3),\n            9: (2,4),\n        }\n        \n        current = [0]*10\n        prev = [1]*10\n\n        for _ in range(n-1):\n            current = [0]*10\n\n            for key in range(10):\n                for bro in pad[key]:\n                    current[key] += prev[bro]\n            prev = current\n        \n        return sum(current) %(10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jump = {1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 5:[],6:[0,1,7], 7:[6,2],8:[1,3],9:[4,2],0:[6,4]}\n        dp = [1]*10\n        for _ in range(n-1):\n            new_dp = [0]*10\n            for u in range(10):\n                for v in jump[u]:\n                    new_dp[v] += dp[u]\n            dp = new_dp\n        return sum(dp)%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jump = {1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 5:[],6:[0,1,7], 7:[6,2],8:[1,3],9:[4,2],0:[6,4]}\n        dp = [1]*10\n        for _ in range(n-1):\n            new_dp = [0]*10\n            for v in range(10):\n                for u in jump[v]:\n                    new_dp[v] += dp[u]\n            dp = new_dp\n        return sum(dp)%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        if n == 1:\n            return 10\n        \n        transition = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        \n        vec = [1 for _ in range(10)]\n        for n in range(1, n):\n            new_vec = [0 for _ in range(10)]\n            for i in range(0, 10):\n                for j in transition[i]:\n                    new_vec[j] = (new_vec[j] + vec[i]) % (1_000_000_000 + 7)\n                    # print(new_vec, vec)\n            vec = new_vec\n        \n        return sum(vec) % (1_000_000_000 + 7)", "class Solution(object):\n    def knightDialer(self, N):\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(N-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        move = {0:[4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[4,2]}\n        \n        pre = [1 for _ in range(10)]\n        for i in range(n-1):\n            new = [0 for _ in range(10)]\n            for j in range(10):\n                for k in move[j]:\n                    new[k] += pre[j]%(10**9+7)\n            pre = new\n        \n        return sum(pre)%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9 + 7\n        moves = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [0,1,7], [2,6], [1,3], [2,4]]\n        \n        dp = [1]*10\n        \n        for i in range(n-1):\n            new_dp = [0]*10\n            \n            for c, val in enumerate(dp):\n                for j in moves[c]:\n                    new_dp[j] += val\n                    new_dp[j] %= mod\n                    \n                dp = new_dp\n                \n        return (sum(dp))%mod\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        MOD = 10**9 + 7\n        # moves: each item is numbers which can move to idx number\n        # e.g., 0 can move to 4 and 6\n        moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),\n                     (1,7,0),(2,6),(1,3),(2,4)]\n        \n        # dp[start] = f(start, n), n as idx in dp\n        # f(start, n): starting from start and dial n times\n        dp = [1] * 10 \n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp): # node is number\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], \n                [1, 7, 0], [2, 6], [1, 3], [2, 4]]\n        dp = [1] * 10\n        for hops in range(n - 1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for neighbor in moves[node]:\n                    dp2[neighbor] += count\n                    dp2[neighbor] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n\n                for nei in moves[node]:\n                    \n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n\n     \n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\n        \n        dp = [1] * 10\n        for _ in range(n - 1):\n            nxt = [0] * 10\n            for i in range(10):\n                for j in dct[i]:\n                    nxt[j] += dp[i]\n            dp = nxt\n        \n        return sum(dp) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        if n == 1:\n            return 10\n        next_square = [[4,6], [6,8], [7,9], [4,8], [3, 9, 0], [], [0, 1, 7], [2,6], [1,3], [2,4], [4,6]]\n        \n        values = [1, 1, 1, 1, 1, 0, 1, 1, 1, 1]\n        for i in range(1, n):\n            next_values = [0] * 10\n            for num in range(10):\n                for square in next_square[num]:\n                    next_values[square] += values[num]\n                    next_values[square] %= MOD\n\n            values = next_values[:]\n            \n        return sum(values) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jump = {1:[6,8], 2:[7,9], 3:[8,4], 4:[0,9,3], 5:[], 6:[7,1,0], 7:[6,2], 8:[3,1], 9:[4,2], 0:[6,4]}\n        \n        dp = [1]*10\n        for _ in range(n-1):\n            nxt = [0]*10\n            for i in range(10):\n                for j in jump[i]:\n                    nxt[j] += dp[i]\n            dp = nxt\n        return sum(dp)%(10**9+7)\n    \n    \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        MOD = 10**9+7\n        dp = [1]*10\n        for jumps in range(n-1):\n            temp = [0]*10\n            for i in range(10):\n                for nei in moves[i]:\n                    temp[nei] += dp[i]\n                    temp[nei] %= MOD\n            dp = temp\n        return sum(dp) % MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # # starting points have 10 possible locations\n        # grid = [\n        #     [1,2,3],\n        #     [4,5,6],\n        #     [7,8,9],\n        #     [None,0,None]\n        # ]\n        # # DFS to search through all possibilities\n        # X = len(grid)\n        # Y = len(grid[0])\n        # def dfs(x,y,remain,X=X,Y=Y,grid=grid):\n        #     if x < 0 or x >= X or y < 0 or y >= Y or not grid[x][y] or remain == 0:\n        #         return -1\n        #     temp_step = 8\n        #     temp_step += dfs(x-2,y+1,remain-1)\n        #     temp_step += dfs(x-1,y+2,remain-1)\n        #     temp_step += dfs(x+1,y+2,remain-1)\n        #     temp_step += dfs(x+2,y+1,remain-1)\n        #     temp_step += dfs(x+2,y-1,remain-1)\n        #     temp_step += dfs(x+1,y-2,remain-1)\n        #     temp_step += dfs(x-1,y-2,remain-1)\n        #     temp_step += dfs(x-2,y-1,remain-1)\n        #     self.step *= temp_step\n        #     print(temp_step)\n        #     return temp_step\n        # total = 0\n        # for i in range(X):\n        #     for j in range(Y):\n        #         if grid[i][j]:\n        #             self.step = 0\n        #             dfs(i,j,n)\n        #             total += self.step\n        # return total % (10**9+7)\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [1] * 10\n        states = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        \n        mod = int(1e9) + 7\n        for i in range(n-1):\n            dp1 = [0] * 10\n            \n            for j, st in list(states.items()):\n                for k in st:\n                    dp1[k] += dp[j]\n                    dp1[k] %= mod\n            dp = dp1\n        return sum(dp) % mod\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        if n == 1:\n            return 10\n        next_square = [[4,6], [6,8], [7,9], [4,8], [3, 9, 0], [], [0, 1, 7], [2,6], [1,3], [2,4], [4,6]]\n        \n        values = [1, 1, 1, 1, 1, 0, 1, 1, 1, 1]\n        for i in range(1, n):\n            next_values = [0] * 10\n            for num in range(10):\n                for square in next_square[num]:\n                    next_values[square] += values[num]  \n                    next_values[square] %= MOD\n\n            values = next_values[:]\n            \n        return sum(values) % MOD", "move_map = {\n    0: {4,6},\n    1: {6,8},\n    2: {7,9},\n    3: {4,8},\n    4: {3, 9, 0},\n    5: {},\n    6: {1, 0, 7},\n    7: {2, 6},\n    8: {1, 3},\n    9: {2, 4}\n}\n\nclass Solution:    \n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        old_row = [1 for _ in move_map]\n        new_row = [0 for _ in move_map]\n        for N in range(2,n+1):\n            new_row = [0 for _ in move_map]\n            for key in move_map:\n                res = 0\n                for new_key in move_map[key]:\n                    res += old_row[new_key]\n                new_row[key] = res\n            old_row = new_row\n                \n        return sum(new_row) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        nxt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        dp0 = [1] * 10\n        \n        for _ in range(1, n):\n            dp1 = [0]*10\n            for i in range(10):\n                for j in nxt[i]:\n                    dp1[j] += dp0[i]\n            dp0[:] = dp1[:]\n        \n        return sum(dp0)%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        dialer_map = {0: [4, 6],\n                      1: [6, 8],\n                      2: [7, 9],\n                      3: [4, 8],\n                      4: [0, 3, 9],\n                      5: [],\n                      6: [0, 1, 7],\n                      7: [2, 6],\n                      8: [1, 3],\n                      9: [2, 4]}\n\n        level = [1 for i in range(10)]\n\n        for i in range(1, n):\n            next_level = [0 for i in range(10)]\n            for l in range(10):\n                for d in dialer_map[l]:\n                    next_level[d]+=level[l]\n                \n            level = next_level\n        \n        return  sum(level)%(10**9+7)\n                    \n                    \n            \n        \n", "\n#27\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        prev = [1] * 10\n        \n        fromMap = {1: {8,6}, 2: {7,9}, 3:{4,8}, 4: {0,3,9}, 5:{}, 6:{0,1,7}, 7:{2,6}, 8:{1,3}, 9:{2,4}, 0:{4,6}}\n        \n        for i in range(1,n):\n            dp = [0] * 10\n            for k in range(10):\n                for j in fromMap[k]:\n                    dp[k] += prev[j]\n                    dp[k] %= 10**9 + 7\n            \n            prev = dp\n        \n        return sum(prev) % (10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        prev = [0] * 10\n        dp = [1] * 10\n        \n        m = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        def parents(x):\n            return m[x]\n\n        for l in range(1, n + 1):\n            for x in range(10):\n                for prevX in parents(x):\n                    dp[x] = (dp[x] + prev[prevX]) % (10 ** 9 + 7)\n            prev, dp = dp, [0] * 10\n            \n\n        return sum(prev) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if not n:\n            return 0\n        if n == 1:\n            return 10\n        \n        steps = [1] * 10\n        \n        mapping = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5:[], 6:[1,7, 0], 7:[2, 6], 8:[1,3], 9:[2,4], 0:[4,6]}\n        \n        for i in range(2, n+1):\n            newSteps = [0] * 10\n            for i in range(10):\n                for j in mapping[i]:\n                    newSteps[i] += steps[j]\n                    newSteps[i] %= 10**9 + 7\n                    \n                    \n            steps = newSteps\n            \n        return sum(steps) % (10**9 + 7)            ", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9+7\n        dc = {(x,1): 1 for x in range(10)}\n        \n        for i in range(1,n):\n            dc[(0,i+1)] = (dc[(4,i)] + dc[(6,i)]) % mod \n            dc[(1,i+1)] = (dc[(6,i)] + dc[(8,i)]) % mod\n            dc[(2,i+1)] = (dc[(7,i)] + dc[(9,i)]) % mod \n            dc[(3,i+1)] = (dc[(4,i)] + dc[(8,i)]) % mod \n            dc[(4,i+1)] = (dc[(0,i)] + dc[(3,i)] + dc[(9,i)]) % mod \n            dc[(5,i+1)] = 0 \n            dc[(6,i+1)] = (dc[(0,i)] + dc[(1,i)] + dc[(7,i)]) % mod\n            dc[(7,i+1)] = (dc[(2,i)] + dc[(6,i)]) % mod\n            dc[(8,i+1)] = (dc[(1,i)] + dc[(3,i)]) % mod \n            dc[(9,i+1)] = (dc[(2,i)] + dc[(4,i)]) % mod\n            \n        res = 0\n        for j in range(10):\n            res = (res + dc[(j,n)]) % mod\n        return res", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dirs = {(-2, -1), (-1, -2), (1, -2), (2, -1),\n                (2, 1), (1, 2), (-1, 2), (-2, 1)}\n        prohibited = {(0, 3), (2, 3)}\n        \n        graph = {}\n        result = [0] * (3 * 4)\n        for i in range(3 * 4):\n            x1 = i % 3\n            y1 = i // 3\n            graph[i] = []\n            if (x1, y1) in prohibited:\n                continue\n            \n            for j in range(3 * 4):\n                x2 = j % 3\n                y2 = j // 3\n\n                if (x2 - x1, y2 - y1) in dirs and (x2, y2) not in prohibited:\n                    graph[i].append(j)\n            result[i] = 1\n            \n        # for k, v in graph.items():\n        #     print(k, v)\n        M = 10 ** 9 + 7\n        for i in range(1, n):\n            res_next = [0] * (3 * 4)\n            for x in range(3 * 4):\n                for adj in graph.get(x, []):\n                    res_next[x] = (res_next[x] + result[adj]) % M\n                    \n            result = res_next\n        # print(result)\n        return sum(result) % M", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        KMOD = 10 ** 9 + 7\n        moves = [[4,6], [8,6], [7,9], [4,8], [3,9,0], [], [1,7,0], [2,6], [1,3], [2,4]]\n        # moves represet 4 and 6 can jump to 1 (index position)\n        dp = [1 for _ in range(10)] # 10 keys\n        for k in range(1, n):\n            cur = [0 for _ in range(10)]\n            for i in range(10): # for each key\n                for from_key in moves[i]:\n                    cur[from_key] += dp[i]\n            dp = cur\n        \n        result = 0\n        for i in range(10):\n            result += dp[i]\n        return result % KMOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        lis = [10, 20, 46, 104, 240, 544]\n        if(n <= 6):\n            return lis[n-1]\n        for i in range(7, n+1):\n            lis.append(6*lis[-2] - 4*lis[-4])\n        return lis[-1]%(10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        '''\n        0: 4,6\n        1: 6,8\n        2: 7,9\n        3: 4,8\n        4: 0,3,9\n        5: None\n        6: 1,7,0\n        7: 2,6\n        8: 1,3\n        9: 2,4\n        '''\n        mod = 10**9+7\n        nxt_pos = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1 for _ in range(10)] # dp[i] is the number of times of i be the last dialed number at step 1\n        res = 10\n        for _ in range(1,n):\n            cur_dp = [0 for _ in range(10)]\n            for val, times in enumerate(dp):\n                for nxt in nxt_pos[val]:\n                    cur_dp[nxt] += times\n                    cur_dp[nxt] %= mod\n            dp = cur_dp\n            \n        return sum(dp)%mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        numMoves = {}\n        for i in range(10):\n            numMoves[1, i] = 1\n        for i in range(2,n+1):\n            numMoves[i,1] = numMoves[i-1, 6] + numMoves[i-1, 8] % (10**9+7)\n            numMoves[i,2] = numMoves[i-1, 7] + numMoves[i-1, 9] % (10**9+7)\n            numMoves[i,3] = numMoves[i-1, 4] + numMoves[i-1, 8] % (10**9+7)\n            numMoves[i,4] = numMoves[i-1, 3] + numMoves[i-1, 9] + numMoves[i-1,0] % (10**9+7)\n            numMoves[i,5] = 0\n            numMoves[i,6] = numMoves[i-1, 1] + numMoves[i-1, 7] + numMoves[i-1,0] % (10**9+7)\n            numMoves[i,7] = numMoves[i-1, 2] + numMoves[i-1, 6] % (10**9+7)\n            numMoves[i,8] = numMoves[i-1, 1] + numMoves[i-1, 3] % (10**9+7)\n            numMoves[i,9] = numMoves[i-1, 2] + numMoves[i-1, 4] % (10**9+7)\n            numMoves[i,0] = numMoves[i-1, 4] + numMoves[i-1, 6] % (10**9+7)\n        totalMoves = 0\n        for i in range(10):\n            totalMoves += numMoves[n, i]\n        return totalMoves % (10**9+7)", "move_map = {\n    0: {4,6},\n    1: {6,8},\n    2: {7,9},\n    3: {4,8},\n    4: {3, 9, 0},\n    5: {},\n    6: {1, 0, 7},\n    7: {2, 6},\n    8: {1, 3},\n    9: {2, 4}\n}\n\nclass Solution:    \n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        old_row = [1 for _ in move_map]\n        new_row = [0 for _ in move_map]\n        for N in range(2,n+1):\n            for key in move_map:\n                res = 0\n                for new_key in move_map[key]:\n                    res += old_row[new_key]\n                new_row[key] = res\n            for idx, n in enumerate(new_row):\n                old_row[idx] = n\n                \n        return sum(new_row) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],\n                 [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        result = [1] * 10\n\n        hops = 0\n        while hops < n - 1:\n            nextResult = [0] * 10\n            for idx in range(len(result)):\n                for step in moves[idx]:\n                    nextResult[idx] += result[step]\n            result = nextResult\n            hops += 1\n\n        return sum(result) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [[1] * 10] + [[0] * 10 for _ in range(n-1)]\n        \n        for i in range(1, n):\n            dp[i][1] += dp[i-1][8] + dp[i-1][6]\n            dp[i][3]  = dp[i][1]\n            \n            dp[i][2] += dp[i-1][7] + dp[i-1][9]\n            \n            dp[i][4] += dp[i-1][9] + dp[i-1][3] + dp[i-1][0]\n            dp[i][6]  = dp[i][4]\n            \n            dp[i][7] += dp[i-1][6] + dp[i-1][2]\n            dp[i][9]  = dp[i][7]\n            \n            dp[i][8] += dp[i-1][1] + dp[i-1][3]\n            \n            dp[i][0] += dp[i-1][4] + dp[i-1][6]\n\n        return sum(dp[-1]) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 7 + 10**9\n        moves = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        \n        dp = [1] * 10\n        \n        for i in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for neighbor in moves[node]:\n                    dp2[neighbor] += count\n                    dp2[neighbor] %= MOD\n            \n            dp = dp2\n        \n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp=[1]*10\n        dic={0:[4,6],1:[8,6],2:[7,9],3:[4,8],4:[3,9,0],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4]}\n        \n        \n        for i in range(1,n):\n            temp=dp\n            dp=[0]*10\n            for j in range(10):\n                if j in dic:\n                    for k in dic[j]:\n                        dp[k]+=temp[j]\n                        dp[k]%=(10**9 + 7)\n            \n                    \n        return sum(dp)%(10**9 + 7)", "class Solution:\n    NEIGHBORS = (\n            (4, 6),\n            (6, 8),\n            (7, 9),\n            (4, 8),\n            (0, 3, 9),\n            (),\n            (0, 1, 7),\n            (2, 6),\n            (1, 3),\n            (2, 4)\n    )\n    \n    cache = {}\n            \n    def get_neighbors(self, n: int) -> Tuple[int]:\n        return self.NEIGHBORS[n]\n    \n    def knightDialer(self, n: int) -> int:\n        results = 0\n        prior = [1] * 10\n        for _ in range(n - 1):\n            current = [0] * 10\n            for pos in range(10):\n                for neighbor in self.get_neighbors(pos):\n                    current[pos] += prior[neighbor] % 1000000007\n            prior = current\n                \n        return sum(prior) % 1000000007\n\n#     def traverse(self, pos: int, length: int) -> int:\n#         if length == 1:\n#             return 1\n#         if (pos, length) in self.cache:\n#             return self.cache[(pos, length)]\n#         jumps = 0\n#         for neighbor in self.get_neighbors(pos):\n#             jumps += self.traverse(neighbor, length - 1)\n            \n#         jumps %= 1000000007\n#         self.cache[(pos, length)] = jumps\n#         return jumps\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        memo = [1]*10\n        for i in range(n-1):\n            memonext = [0]*10\n            for j in range(10):\n                for m in moves[j]:\n                    memonext[m] += memo[j]\n                    #print(memonext,m)\n            for j in range(10):\n                memo[j] = memonext[j]\n            #print(memo)\n        return sum(memo) % (10**9 + 7)", "'''\n 0. 1. 2. 3. 4. 5. 6. 7. 8. 9\n[2, 2, 2, 2, 3, 0, 3, 2, 2, 2]\n[6, 5, 0, 0, 0, 0, 0, 0, 0, 0]\n\n[6, 5, 4, 5, 6, 0, 6, 5, 4, 5]\n\n\n'''\nclass Solution(object):\n    def knightDialer(self, N):\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(N-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n            dp = dp2\n        print(dp)\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n\n        mod = 10**9+7\n        nxt_pos = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1 for _ in range(10)]\n        for _ in range(1,n):\n            new_dp = [0 for _ in range(10)]\n            for val,times in enumerate(dp):\n                for i in nxt_pos[val]:\n                    new_dp[i] += times\n                    new_dp[i] %= mod\n            dp = new_dp\n        return sum(dp)%mod\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        moves = {1: {6,8}, 2: {9,7}, 3: {8,4}, 4: {3,9,0}, 5: {}, 6: {1,7,0}, 7: {2,6}, 8: {1,3}, 9:{2,4}, 0: {4,6}}\n        # N = 2\n        dp = [1] * 10\n        \n        \n        for i in range(2, N+1):\n            newDp = [0] * 10\n            for j in range(10):\n                for conn in moves[j]:\n                    newDp[conn] += dp[j] % (10**9 + 7)\n            \n            dp = newDp\n        \n        print(dp)\n        return sum(dp) % (10**9 + 7)\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        res = 0\n        path = {0:[4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0], 5:[], 6:[1,7,0], 7:[2,6], 8:[1,3], 9:[2,4]}\n        dp = [1]*10\n        MOD = 10**9 + 7\n        \n        for i in range(2,n+1):\n            dp2 = [0]*10\n            for j in range(10):\n                for p in path[j]:\n                    dp2[j] += dp[p]\n                # dp[j] %= MOD\n            dp = dp2\n        res = sum(dp)\n        \n        return res%MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        reachFrom = {1: [8,6], 2: [7,9], 3: [4,8], 4: [0,9,3], 5:[], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2, 4], 0: [4,6]}\n        prevdp = [1 for _ in range(10)]\n        curdp = [0 for _ in range(10)]\n        for iteration in range(1, n):\n            curdp = [0 for _ in range(10)]\n            for i in range(10): \n                for nbor in reachFrom[i]:\n                    curdp[i] += prevdp[nbor]\n            prevdp = curdp.copy()\n        ans = 0\n        for i in range(10):\n            ans += prevdp[i]\n        return ans%(10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        if n == 1:\n            return 10\n        next_square = [[4,6], [6,8], [7,9], [4,8], [3, 9, 0], [], [0, 1, 7], [2,6], [1,3], [2,4], [4,6]]\n        \n        values = [1, 1, 1, 1, 1, 0, 1, 1, 1, 1]\n        for i in range(1, n):\n            next_values = [0] * 10\n            for num in range(10):\n                for square in next_square[num]:\n                     \n                    next_values[square] %= MOD\n                    next_values[square] += values[num] \n\n            values = next_values[:]\n            \n        return sum(values) % MOD", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        steps = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0],5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        ret = set()\n        def DFS(cur, i):\n            if i == N:\n                n = 0\n                for c in cur:\n                    n = n * 10 +c\n                ret.add(n)\n                print(n)\n                return\n            for n in steps[cur[-1]]:\n                DFS(cur+[n], i+1)\n            return\n        for k in list(steps.keys()):\n            DFS([k], 1)\n        return len(ret)\n        \nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        steps = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        dp = [1 for _ in range(10)]\n        for _ in range(N-1):\n            cur = [0 for _ in range(10)]\n            for i in range(10):\n                for j in steps[i]:\n                    cur[j] += dp[i]\n            dp = cur\n        return sum(dp) % (10**9 +7)\n                    \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        '''\n        0: 4,6\n        1: 6,8\n        2: 7,9\n        3: 4,8\n        4: 0,3,9\n        5: None\n        6: 1,7,0\n        7: 2,6\n        8: 1,3\n        9: 2,4\n        '''\n        mod = 10**9+7\n        nxt_pos = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1 for _ in range(10)]\n        for _ in range(1,n):\n            new_dp = [0 for _ in range(10)]\n            for val,times in enumerate(dp):\n                for i in nxt_pos[val]:\n                    new_dp[i] += times\n                    new_dp[i] %= mod\n            dp = new_dp\n        return sum(dp)%mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n#         mappings = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [1,7,0], [2,6], [1,3], [2,4]]\n#         total = 0\n#         MOD = 10**9 + 7\n        \n#         for s in range(0, 10):\n#             last = collections.deque([s])\n#             for i in range(2, n+1):\n#                 length = len(last)\n#                 for j in range(length):\n#                     number = last.pop()\n#                     last.extendleft([] + mappings[number])\n#             total+=len(last)\n\n#         return total % MOD\n\n        mappings = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [1,7,0], [2,6], [1,3], [2,4]]\n        mod = 10**9 + 7\n        dp = [1] * 10\n\n        for digit in range(2, n+1):\n            dp2 = [0] * 10\n            for startNumber, counter in enumerate(dp2):\n                for x in mappings[startNumber]:\n                    dp2[startNumber] += dp[x]\n                    dp2[startNumber]\n            dp = dp2\n        return sum(dp)%mod\n    \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        pos_map = {0:[4,6], 1: [6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\n        num_vals = [1 if i != 5 else 0 for i in range(10)]\n        mod_val = 10**9+7\n        if n == 1:\n            return 10\n        else:\n            for num in range(1,n):\n                temp = [0 for i in range(10)]\n                for i, count in enumerate(num_vals):\n                    for val in pos_map[i]:\n                        temp[val] += count\n                num_vals = temp\n        return sum(num_vals)%mod_val\n", "from collections import deque\n\n\nclass Solution:\n    \n    def knightDialer(self, n: int) -> int:\n        neighborMap = {\n            1: (6,8),\n            2: (7,9),\n            3: (4,8),\n            4: (3,9,0),\n            5: (),\n            6: (1,7,0),\n            7: (2,6),\n            8: (3,1),\n            9: (2,4),\n            0: (4,6)\n        }\n        \n        \n        def neighbors(pos):\n            return neighborMap[pos]\n    \n        \n        def countSeq():\n            prevMoves = [1] * 10\n            curMoves = [0] * 10\n            curN = 1\n            \n            while curN < n:\n                curMoves = [0] * 10\n                curN += 1\n                \n                for pos in range(10):\n                    for neighbor in neighbors(pos):\n                        curMoves[pos] += prevMoves[neighbor]\n                prevMoves = curMoves\n                \n            curMoves = prevMoves\n            # print(curMoves)\n            return sum(curMoves)\n        \n        # totalSeq = 0\n        # for curPos in range(10):\n        #     totalSeq += countSeq(curPos)\n        \n        return countSeq() % (10**9 + 7)\n        \n    \n    \n# Prev implementation\n#     def knightDialer(self, n: int) -> int:\n#         def inPad(row, col):\n#             if row >= 0 and row < 3 and col >= 0 and col < 3 or (row == 3 and col == 1):\n#                 return True\n#             return False\n            \n#         dRows = [1,-1,1,-1,2,-2,2,-2]\n#         dCols = [2,2,-2,-2,1,-1,-1,1]\n        \n#         q = deque()\n#         q.append((3,1,n-1))\n        \n#         for i in range(3):\n#             for j in range(3):\n#                 q.append((i,j, n-1))\n        \n#         distinctNums = 0\n#         while q:\n#             cur = q.popleft()\n            \n#             if cur[2] == 0:\n#                 distinctNums += 1\n#                 continue\n\n#             for dRow, dCol in zip(dRows, dCols):\n#                 newRow, newCol = cur[0] + dRow, cur[1] + dCol\n\n#                 if inPad(newRow, newCol):\n#                     q.append((newRow, newCol, cur[2] - 1))\n\n#         return distinctNums % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        prev = [0] * 10\n        dp = [1] * 10\n        \n        m = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        def parents(x):\n            return m[x]\n\n        for l in range(1, n + 1):\n            for x in range(10):\n                for prevX in parents(x):\n                    dp[x] += prev[prevX]\n            prev, dp = dp, [0] * 10\n            \n\n        return sum(prev) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n#         mod = 10**9 + 7\n\n#         d = dict()\n#         d[0] = {4, 6}\n#         d[1] = {6, 8}\n#         d[2] = {7, 9}\n#         d[3] = {4, 8}\n#         d[4] = {0, 3, 9}\n#         d[6] = {0, 1, 7}\n#         d[7] = {2, 6}\n#         d[8] = {1, 3}\n#         d[9] = {2, 4}\n        \n#         memo = [[0]*10 for i in range(n+1)]\n#         memo[1] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        \n#         for i in range(2, n+1):\n#             for key, val in d.items():\n#                 for v in val:\n#                     memo[i][key] += memo[i-1][v]\n        \n#         return sum(memo[-1])%mod\n    \n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD\n        \n        \n", "# deem the jumps as path from a dummy starting node to each level of a tree. Count the number of nodes in each level\n\n# method 1\n# dynamic programming\n# time complexity: O(n)\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {0:(4,6),\n             1:(6,8), \n             2:(7,9),\n             3:(4,8),\n             4:(0,3,9),\n             5:(),\n             6:(0,1,7),\n             7:(2,6),\n             8:(1,3),\n             9:(2,4)}\n        \n        # start from a dummy node, from which we can reach every node 0-9\n        # count the number of nodes in each level\n        # if prev_level[i] = freq, then there {freq} nodes that equals {i} in that level\n        prev_level = {i:1 for i in range(10)} # level 1\n        for j in range(1,n):\n            curr_level = defaultdict(int)\n            for i,freq in list(prev_level.items()):\n                for child in d[i]:\n                    curr_level[child] += freq\n            prev_level = curr_level\n        \n        return sum(prev_level.values()) % (10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        possible_paths = {1: [6, 8], 2: [7, 9], 3: [4,8], 4: [0, 3, 9], 5: [],\n                          6: [0, 1,7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        dp = [1] * 10\n        for i in range(n-1):\n            temp = [0] * 10\n            for start_num in range(10):\n                for target_num in possible_paths[start_num]:\n                    temp[target_num] += dp[start_num]\n            dp = temp\n\n        return sum(dp) % (7 + 10**9)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        \n        graph = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\n        MOD = 1000000007\n        prev = [1,1,1,1,1,0,1,1,1,1]\n        for _ in range(n-1):\n            val = [0] * 10\n            for i in range(10):\n                for x in graph[i]:\n                    val[x] += prev[i]\n            prev = val\n        return sum(prev) % MOD\n", "class Solution:\n    def knightDialer(self, n):\n        dmap = [[4, 6], [8, 6], [7, 9], [8, 4], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4],[4, 6]]\n        mod_val = 10 ** 9 + 7\n        ans = 0\n        dp = [[0]*10 for _ in range(n+1)]\n        for i in range(10):\n            dp[1][i] = 1\n        for i in range(2, n+1):\n            for j in range(0, 10):\n                tv = dmap[j]\n                for t in tv:\n                    dp[i][j] += dp[i-1][t] % mod_val\n        #print(dp)\n        ans = sum(dp[n]) % mod_val\n        return ans\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 1000000007\n        if n == 0:\n            return 0\n        dict = {}\n        dict[1] = [6, 8]\n        dict[2] = [7, 9]\n        dict[3] = [4, 8]\n        dict[4] = [3, 9, 0]\n        dict[5] = []\n        dict[6] = [1, 7, 0]\n        dict[7] = [2, 6]\n        dict[8] = [1, 3]\n        dict[9] = [2,4]\n        dict[0] = [4,6]\n        dp = [0] * 10\n        for i in range(10):\n            dp[i] = [0] * (n + 1)\n        for i in range(10):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        sum = 0\n        for j in range(2, n+1):\n            for i in range(10):\n                for k in dict[i]:\n                    dp[i][j] = (dp[i][j] + dp[k][j - 1]) % mod\n                \n        for i in range(0, 10):\n            sum = (sum + dp[i][n]) % mod\n        return sum % mod\n            \n", "import numpy as np\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        mod = 10**9 + 7\n        moves = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        \n        res = [[1]*10]\n\n        N -= 1\n        while N:\n            if N % 2 != 0: \n                res = res * moves % mod     \n                N -= 1\n            else:\n                moves = moves * moves % mod\n                N //= 2\n        return int(np.sum(res)) % mod\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # dp[i, j] = # of distinct phone numbers of length j that can be dialed starting at i\n        # dp[i, 1] = 1\n        # dp[i, j] = sum(dp[i-1, k]) where k are all the possible numbers the knight can jump to\n        if n == 1:\n            return 10\n        dp_old = [1 for _ in range(10)]\n        dp_new = [0 for _ in range(10)]\n        possible_next_digits = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        for _ in range(n-1):\n            \n            for j in range(10):\n                dp_new[j] = 0\n                for digit in possible_next_digits[j]:\n                    dp_new[j] += dp_old[digit]\n            for j in range(10):\n                dp_old[j] = dp_new[j]\n\n        total = 0\n        for num in dp_new:\n            total += num\n        return total % (10**9 + 7)\n        \n# 1 1 1 1 1 1 1 1 1\n#\n", "class Solution:\n    def knightDialer(self, N):\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\n        neighbors = {\n            0:(4,6),\n            1:(6,8),\n            2:(7,9),\n            3:(4,8),\n            4:(0,3,9),\n            5:(),\n            6:(0,1,7),\n            7:(2,6),\n            8:(1,3),\n            9:(2,4)\n        }\n        current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        for _ in range(N-1):\n            next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            for src_key in range(10):\n                for dst_key in neighbors[src_key]:\n                    next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\n            current_counts = next_counts\n        return sum(current_counts) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # dp[i, j] = # of distinct phone numbers of length j that can be dialed starting at i\n        # dp[i, 1] = 1\n        # dp[i, j] = sum(dp[i-1, k]) where k are all the possible numbers the knight can jump to\n        if n == 1:\n            return 10\n        possible_next_digits = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        dp = [1 for _ in range(10)]\n        dp_next = [0 for _ in range(10)]\n\n        for _ in range(n-1):\n            for j in range(10):\n                dp_next[j] = 0\n                for digit in possible_next_digits[j]:\n                    dp_next[j] += dp[digit]\n            for j in range(10):\n                dp[j] = dp_next[j]\n\n        total = 0\n        for num in dp:\n            total += num\n        return total % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        \n        mod = 10**9+7\n        dc = {\n              (0,1): 1,\n              (1,1): 1,\n              (2,1): 1,\n              (3,1): 1,\n              (4,1): 1,\n              (5,1): 1,\n              (6,1): 1,\n              (7,1): 1,\n              (8,1): 1,\n              (9,1): 1,\n             }\n        \n        for i in range(n-1):\n            dc[(0,i+2)] = (dc[(4,i+1)] + dc[(6,i+1)]) % mod \n            dc[(1,i+2)] = (dc[(6,i+1)] + dc[(8,i+1)]) % mod\n            dc[(2,i+2)] = (dc[(7,i+1)] + dc[(9,i+1)]) % mod \n            dc[(3,i+2)] = (dc[(4,i+1)] + dc[(8,i+1)]) % mod \n            dc[(4,i+2)] = (dc[(0,i+1)] + dc[(3,i+1)] + dc[(9,i+1)]) % mod \n            dc[(5,i+2)] = 0 \n            dc[(6,i+2)] = (dc[(0,i+1)] + dc[(1,i+1)] + dc[(7,i+1)]) % mod\n            dc[(7,i+2)] = (dc[(2,i+1)] + dc[(6,i+1)]) % mod\n            dc[(8,i+2)] = (dc[(1,i+1)] + dc[(3,i+1)]) % mod \n            dc[(9,i+2)] = (dc[(2,i+1)] + dc[(4,i+1)]) % mod\n            \n        res = 0\n        for j in range(10):\n            res = (res + dc[(j,n)]) % mod\n        return res", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        prev = [0] * 10\n        dp = [1] * 10\n        \n        m = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        def parents(x):\n            return m[x]\n\n        for l in range(1, n + 1):\n            for x in range(10):\n                for prevX in parents(x):\n                    dp[x] += prev[prevX]\n                    dp[x] = dp[x] % (10 ** 9 + 7)\n            prev, dp = dp, [0] * 10\n            \n\n        return sum(prev) % (10 ** 9 + 7)", "class Solution:\n    moveMap = {\n        0: [4, 6],\n        1: [8,6],\n        2: [7,9],\n        3: [8,4],\n        4: [3,9,0],\n        5: [],\n        6: [1,7,0],\n        7: [2,6],\n        8: [1,3],\n        9: [2,4]\n    }\n    \n    def nextMoves(self, n: int):\n        return self.moveMap[n]\n        \n    def knightDialer(self, n: int) -> int:\n        modulo = 1000000007\n        if n<0:\n            return 0\n        counts = [1]*10\n        moves = len(self.moveMap)\n        while n>1:\n            newCounts = [0]*10\n            for i in range(moves):\n                for m in self.nextMoves(i):\n                    newCounts[m] += counts[i]\n            counts = newCounts\n            n -= 1\n        return sum(counts) % modulo\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        num_map = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        table = [[0 for _ in range(10)] for _ in range(2)]\n        for j in range(10):\n            table[0][j] = 1\n            \n        for i in range(1, n):\n            for j in range(10):\n                sum_d = 0\n                for d in num_map[j]:\n                    sum_d += table[(i-1)%2][d]\n                table[i%2][j] = sum_d\n        \n        \n        return sum(table[(n-1)%2]) % (1000000007)\n        \n", "class Solution:\n    # 5 can only show up as the last number\n    def knightDialer(self, n: int) -> int:\n        from collections import defaultdict\n        dct = {1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0], 5:[], 6:[1,7,0], 7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]}\n        dp = {1:1, 2:1, 3:1, 4:1, 5:1, 6:1, 7:1, 8:1, 9:1, 0:1}   # number: curr_sum\n        n -= 1\n        \n        while n > 0:\n            new_dp = defaultdict(int)\n            for num1 in dp:\n                for num2 in dct[num1]:\n                    new_dp[num2] += dp[num1]\n            dp = new_dp\n            n -= 1\n        \n        ans = 0\n        for key in dp:\n            ans += dp[key]\n        return ans % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        M = 10**9 + 7\n        moves = {0: [4,6], 1: [6,8], 2: [7,9], 3: [4,8], 4: [3,9,0],\n                 5: [], 6: [1,7,0], 7: [2,6], 8: [1,3], 9: [2,4]}\n        \n        # f(start, n) = number of ways to build an n-digit number starting\n        # at number start\n        # prior_n[i] = number of ways to build a 1-digit no. starting at i\n        prior_n = [1] * 10\n        \n        # repeat process to generate array that gives number of \n        # ways to build 2, 3, ... , n digit numbers starting at i\n        for hops in range(2, n + 1):\n            curr_n = [0] * 10\n            # build on prior n results\n            for num, count in enumerate(prior_n):\n                # looking at numbers generated when we move nbr --> num --> ...\n                for nbr in moves[num]:\n                    curr_n[nbr] += count\n                    curr_n[nbr] %= M\n                    \n            # curr n becomes prior n\n            prior_n = curr_n\n        # return the sum of all n digit phone nums that can be created\n        # by starting at num 0, 1, ... , 9\n        return sum(prior_n) % M", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        validJumps = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        memo = [[0 for _ in range(n + 1)] for _ in range(10)]\n        \n        for i in range(len(memo)):\n            memo[i][1] = 1\n            \n        for j in range(2, n + 1):\n            for i in range(len(memo)):\n                for k in validJumps[i]:\n                    memo[i][j] = (memo[i][j] + memo[k][j - 1]) % (10**9 + 7)\n            \n        ans = 0\n        for i in range(10):\n            ans = (ans + memo[i][n]) % (10**9 + 7)\n        return ans", "from functools import lru_cache\n\nmapping = [\n            [4, 6], # 0\n            [6, 8], # 1\n            [7, 9], # 2\n            [4, 8], # 3\n            [0, 3, 9], # 4\n            [], # 5\n            [0, 1, 7], # 6\n            [2, 6], # 7\n            [1, 3], # 8\n            [2, 4] # 9\n        ]\n\nmod = 1000_000_007\n\n@lru_cache(None)\ndef f(n: int, d: int) -> int:\n    if n == 1: return 1\n    s = 0\n    \n    for d1 in mapping[d]:\n        s = (s + f(n - 1, d1)) % mod\n    return s\n        \nclass Solution:        \n    def knightDialer(self, N: int) -> int:                \n        tot = 0\n        for d in range(10):\n            tot = (tot + f(N, d)) % mod\n            \n        return tot", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # dp[i, j] = # of distinct phone numbers of length j that can be dialed starting at i\n        # dp[i, 1] = 1\n        # dp[i, j] = sum(dp[i-1, k]) where k are all the possible numbers the knight can jump to\n        if n == 1:\n            return 10\n        dp = [1 for _ in range(10)]\n        possible_next_digits = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        for _ in range(n-1):\n            dp_next = [0] * 10\n            for j in range(10):\n                dp_next[j] = 0\n                for digit in possible_next_digits[j]:\n                    dp_next[j] += dp[digit]\n            for j in range(10):\n                dp[j] = dp_next[j]\n\n        total = 0\n        for num in dp:\n            total += num\n        return total % (10**9 + 7)\n", "'''\n'''\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        adj_lists = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]] #adj_lists[i] are the neighbors of digit i\n        table = [[1]*10 for i in range(n)] #table[n][digit] is the number of solutions for length `n+1` starting at digit\n        #table is already initialized for n=1\n        \n        for n0 in range(1,n):\n            for digit in range(10):\n                acc = 0\n                for adj in adj_lists[digit]:\n                    acc += table[n0-1][adj]\n                table[n0][digit] = acc\n        \n        return sum(table[n-1]) % (10**9+7)\n", "from collections import defaultdict\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        _nextMove = {0 : [4 ,6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5:[],\n                    6: [0, 1, 7], 7: [2, 6], 8:[1, 3], 9: [2, 4]}\n        \n        moves = {i : 1 for i in range(10)}\n        \n        while n > 1:\n            newmoves = defaultdict(int)\n            for k, v in moves.items():\n                for _next in _nextMove[k]:\n                    newmoves[_next] += v\n            moves = newmoves\n            n -= 1\n        \n        \n        \n        \n        \n        return sum(moves.values()) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        positions = [\n            [4, 6],\n            [6, 8],\n            [7, 9],\n            [4, 8],\n            [0, 3, 9],\n            [],\n            [0, 1, 7],\n            [2, 6],\n            [1, 3],\n            [2, 4]\n        ]\n        \n        dp = [[0 for i in range(n + 1)] for i in range(10)]\n        \n        for i in range(10):\n            dp[i][1] = 1\n        \n        for j in range(2, n + 1):\n            for i in range(10):\n                for pos in positions[i]:\n                    dp[i][j] = (dp[i][j] + dp[pos][j - 1]) % 1000000007\n        \n        result = 0\n        \n        for i in range(10):\n            result = (result + dp[i][n]) % 1000000007\n        \n        return result", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==0:\n            return 0\n        dic = {0: (4, 6),\n               1: (8, 6),\n               2: (7, 9),\n               3: (4, 8),\n               4: (3, 9, 0),\n               5: (),\n               6: (1, 7, 0),\n               7: (2, 6),\n               8: (1, 3),\n               9: (2, 4)}\n        dp = [1]*10\n        for _ in range(n-1):\n            new = [0]*10\n            for i in range(10):\n                for nei in dic[i]:\n                    new[i] += dp[nei]\n                    new[i] %= (10**9+7)\n            dp = new\n        \n        return sum(dp)%(10**9+7)", "MOD = 10**9 + 7\n\nnum_to_next = {\n    1: [6, 8],\n    2: [7, 9],\n    3: [4, 8],\n    4: [3, 9, 0],\n    5: [],\n    6: [1, 7, 0],\n    7: [2, 6],\n    8: [1, 3],\n    9: [2, 4],\n    0: [4, 6],\n}\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        dp = [1 for _ in range(10)]\n        for _ in range(n-1):\n            next_dp = [0 for _ in range(10)]\n            for current in range(10):\n                for next_pos in num_to_next[current]:\n                    next_dp[next_pos] += dp[current]\n                    next_dp[next_pos] = next_dp[next_pos] % MOD\n            dp = next_dp\n            \n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD\n    \n        '''\n        1  2  3\n        4  5  6\n        7  8  9\n        -1 0 -1\n        \n        def dfs(d, x, y):\n            if d == n:\n                ans.append()\n            # check x, y\n            x + 2, y + 1, y - 1\n            x - 2, y + 1, y - 1\n            y + 2, x + 1, x - 1\n            y - 2, x + 1, x - 1\n            (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1, -2), (-1, -2)\n            dfs(d + 1, nx, ny)\n        \n        '''\n#         def dfs(d, x, y):\n#             nonlocal ans\n#             if d == n:\n#                 ans += 1\n#                 return \n#             for dx, dy in directions:\n#                 nx, ny = x + dx, y + dy\n#                 if nx < 0 or nx > M - 1 or ny < 0 or ny > N - 1 or matrix[nx][ny] == -1:\n#                     continue\n#                 dfs(d + 1, nx, ny)\n                    \n#         matrix = [[1, 2, 3], \n#                   [4, 5, 6],\n#                   [7, 8, 9],\n#                   [-1, 0, -1]]\n#         M, N = len(matrix), len(matrix[0])\n#         directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1, -2), (-1, -2)]\n#         ans = 0\n#         for i in range(M):\n#             for j in range(N):\n#                 if matrix[i][j] != -1:\n#                     dfs(1, i, j)\n#         return ans % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        MOD = 10**9 + 7\n        dp = [1] * 10\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        \n        for hop in range(n - 1):\n            dp2 = [0] * 10\n            for i, move in enumerate(moves):\n                count = dp[i]\n                for pos in move:\n                    dp2[pos] += count\n                    dp2[pos] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1:\n            return 10\n        numpad = {'0':['4','6'],'1':['6','8'],'2':['7','9'],'3':['4','8'],'4':['0','3','9'],'6':['0','1','7'],'7':['2','6'],'8':['1','3'],'9':['4','2']}\n        dp={}\n        for i in ['0','1','2','3','4','6','7','8','9']:\n            dp[i]=[]\n            dp[i].append(1)\n        for i in range(1,n):\n            for j in ['0','1','2','3','4','6','7','8','9']:\n                dp[j].append(0)\n                for k in numpad[j]:\n                    dp[j][i]+=dp[k][i-1]\n                dp[j][i]%=(1000000007)\n        res=0\n        for i in ['0','1','2','3','4','6','7','8','9']:\n            res+=dp[i][n-1]\n            res%=(1000000007)\n        return res", "import collections\nclass Solution:\n    def knightDialer(self, m: int) -> int:\n        MOD=10**9+7\n        n={0:[4,6], 1:[6,8], 2:[7,9],3:[4,8],4:[0,3,9] ,5:[] ,6:[0,1,7] ,7:[2,6],8:[1,3],9:[2,4]}\n        \n        end={}\n        for ab in range(10):\n            end[ab]=1\n        for a in range(1,m):\n            \n            end2={}\n            for ab in range(10):\n                end2[ab]=0\n            \n            \n            for key in range(10):\n                val=n[key]\n                # print(val)\n                for c in val:\n                    end2[key]+=end[c]\n                # print(end2)\n            end=end2\n        return (sum(end.values()))%MOD\n", "import logging\n\nLOG = logging.getLogger(__name__)\nMODULO = 10**9 + 7\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n\n        counts = [2, 2, 3, 2]\n        for _ in range(n-2):\n            next_counts = [\n                (counts[1] + counts[2]),\n                (2 * counts[0]),\n                (2 * counts[0] + counts[3]),\n                (2 * counts[2])\n            ]\n\n            counts= next_counts\n\n        return (4 * counts[0] + 2 * counts[1]  + 2 * counts[2]  + counts[3]) % MODULO\n", "class Solution:\n   \n        \n        \n    \n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        if n==1:\n            return 10\n        neighbors={\n            0: (4,6),\n            1: (6,8),\n            2: (7,9),\n            3: (8,4),\n            4: (3,9,0),\n            5: tuple(),\n            6: (7,1,0),\n            7: (2,6),\n            8: (1,3),\n            9: (4,2),\n        }\n            \n        prev_jump=[1]*10\n        curr_jump=[0]*10\n        jump=0\n        \n        for jump in range(0,n-1):\n            curr_jump=[0]*10\n            for num in range(0,10):\n                for i in neighbors[num]:\n                    curr_jump[i]+=prev_jump[num]\n                    curr_jump[i]%=MOD\n            prev_jump=curr_jump\n \n        return sum(curr_jump)%MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        num_map = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        table = [[0 for _ in range(10)] for _ in range(n)]\n        for j in range(10):\n            table[0][j] = 1\n            \n        for i in range(1, n):\n            for j in range(10):\n                sum_d = 0\n                for d in num_map[j]:\n                    sum_d += table[i-1][d]\n                table[i][j] = sum_d\n        \n        \n        return sum(table[n-1]) % (1000000007)\n        \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                 [1,7,0],[2,6],[1,3],[2,4]]\n        \n        \n        # dp[i] denotes the number of combinations starting from i\n        dp = [1] * 10\n        \n        for n in range(N-1):\n            newdp = [0] * 10\n            for i in range(10):\n                for j in moves[i]:\n                    newdp[i] += dp[j] \n                    newdp[i] %= (10**9 + 7)\n            dp = newdp\n            \n        return sum(dp) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1: return 10\n        d = {0:[4, 6],\n             1:[6, 8],\n             2:[7, 9],\n             3:[4, 8],\n             4:[0, 3, 9],\n             5:[],\n             6:[0, 1, 7],\n             7:[2, 6],\n             8:[1, 3],\n             9:[2, 4]\n             }\n        dp = [1] * 10\n        for i in range(1, n):\n            dp_l = [0] * 10\n            for sq, count in enumerate(dp):\n                for neigh in d[sq]:\n                    dp_l[neigh] += count\n                    dp_l[neigh] %= (10**9 + 7)\n                    \n            dp = dp_l\n        return sum(dp) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {\n            0: [4,6],\n            1: [6,8],\n            2: [9,7],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [6,2],\n            8: [3,1],\n            9: [4,2]\n        }\n        res = 0\n        dp = [1]*10\n        for x in range(1,n):\n            temp = [0]*10\n            for i in range(10):\n                for j in d[i]:\n                    temp[j] += dp[i]\n            dp = temp \n        return sum(dp) % ((10**9)+7) \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[] for x in range(10)]\n       \n        moves[0] = [4,6]\n        moves[1] = [6,8]\n        moves[2] = [7,9]\n        moves[3] = [4,8]\n        moves[4] = [3,9,0]\n        moves[5] = []\n        moves[6] = [0,1,7]\n        moves[7] = [2,6]\n        moves[8] = [1,3]\n        moves[9] = [2,4]\n        \n        dp = {}\n\n        def dialer(start,n):\n            if (start,n) in dp:\n                return dp[(start,n)]\n            if n==1:\n                dp[(start,n)] = 1\n                return 1\n            xmoves = 0\n            for move in moves[start]:\n                xmoves += dialer(move,n-1)\n            xmoves %= (10**9+7)\n            dp[(start,n)] = xmoves \n            return xmoves\n        xmoves = 0\n        for i in range(0):\n            xmoves += dialer(i,n)\n            print(('i ',i,'moves',dialer(i,n),'tot ',xmoves))\n        #return xmoves % (10**9+7)\n\n    \n        prev = [1] * 10\n        for hop in range(2,n+1):\n            #print('zzzzzzzzzz')\n            #print('prev ',prev)\n            #print('curr ',curr)\n            curr = [0] * 10\n            for i in range(10):\n                for move in moves[i]:\n                    curr[i] += prev[move]\n                    \n                    #print('i ',i,'curr[i] ',curr[i],'prev ',prev[i],'move')\n            #print('prev ',prev)\n            #print('curr ',curr)\n            prev = curr\n        return sum(prev) % (10**9 +7)\n        \n                \n            \n", "class Solution:\n    def knight(self, n, current, memo):\n        knight_mp = {1: {8, 6},\n                    2: {9, 7},\n                    3: {4, 8},\n                    4: {3, 9, 0}, # 0 also\n                    5: {},\n                    6: {7, 1, 0}, # 0 also\n                    7: {2, 6},\n                    8: {3, 1},\n                    9: {2, 4},\n                    0: {6, 4}}        \n\n        if n==1:\n            return 1\n        if (current, n) in memo:\n            return memo[(current, n)]\n        res = 0\n        for item in knight_mp.get(current, set()):\n            res+=self.knight(n-1, item, memo)\n            \n            \n        memo[(current, n)] = res\n        return res\n        \n    def knightDialer(self, n: int) -> int:\n#         res = 0\n#         mod = 10**9+7\n#         memo = {}\n#         for i in range(0, 10):\n#             res+=self.knight(n, i, memo)%mod\n#         return res%mod\n    \n    \n        knight_mp = {1: {8, 6},\n                    2: {9, 7},\n                    3: {4, 8},\n                    4: {3, 9, 0}, # 0 also\n                    5: {},\n                    6: {7, 1, 0}, # 0 also\n                    7: {2, 6},\n                    8: {3, 1},\n                    9: {2, 4},\n                    0: {6, 4}}        \n\n#         dp = [[0 if i!=0 else 1 for _ in range(0, 10)] for i in range(n)]\n#         mod = 10**9+7\n\n#         for step in range(1, n):\n#             for cell in range(0, 10):\n#                 for neighbor in knight_mp.get(cell, set()):\n#                     dp[step][cell] += dp[step-1][neighbor]\n#         return sum(dp[n-1])%mod\n    \n        prev = [1 for _ in range(0, 10)]\n        mod = 10**9+7\n\n        for step in range(1, n):\n            curr = [0 for _ in range(0, 10)]\n            for cell in range(0, 10):\n                for neighbor in knight_mp.get(cell, set()):\n                    curr[cell] += prev[neighbor]\n            prev = curr\n        return sum(prev)%mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        dp = [1] * 10\n        for i in range(1, n):\n            new = [0] * 10\n            for j in range(10):\n                new[j] = sum(dp[k] for k in jump[j]) % MOD\n            dp = new\n        return sum(dp) % MOD\n", "#https://leetcode-cn.com/problems/knight-dialer/solution/4zhuang-tai-dong-tai-gui-hua-pythonjie-kong-jian-f/ markov chain, \u8fd9\u4e2a\u89e3\u6cd5\u795e\u4e86\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        if N ==1 : return 10\n        \n        nums = [1,1,1,1]\n        \n        for _ in range(N-1):\n            nums = [nums[1] + nums[2], 2 * nums[0], 2 * nums[0] + nums[3], 2 * nums[2]]\n        \n        return (4 * nums[0] + 2 * nums[1] + 2 * nums[2] + nums[3]) % (10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        el=[[] for i in range(10)]\n        el[0]=[4,6]\n        el[1]=[6,8]\n        el[2]=[7,9]\n        el[3]=[4,8]\n        el[4]=[3,9,0]\n        el[5]=[]\n        el[6]=[1,7,0]\n        el[7]=[2,6]\n        el[8]=[1,3]\n        el[9]=[2,4]\n        a=[[0 for i in range(10)] for j in range(n)]\n        for i in range(10):\n            a[0][i]=1\n        for i in range(1,n):\n            for j in range(10):\n                for x in el[j]:\n                    a[i][j]=(a[i][j]+a[i-1][x])%(10**9+7)\n        c=0\n        for i in range(10):\n            c+=a[-1][i]\n        return c%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        adj = {}\n        adj[0] = [4, 6]\n        adj[1] = [6, 8]\n        adj[2] = [7, 9]\n        adj[3] = [4, 8]\n        adj[4] = [0, 3, 9]\n        adj[5] = []\n        adj[6] = [0, 1, 7]\n        adj[7] = [2, 6]\n        adj[8] = [1, 3]\n        adj[9] = [2, 4]\n        \n        p = 10**9 + 7\n        f = [None] * n\n        f[0] = [1] * 10\n        for i in range(1, n):\n            f[i] = [0] * 10\n            for v in range(0, 10):\n                for u in adj[v]:\n                    f[i][v] += f[i-1][u]\n        \n        total = 0\n        for d in range(0, 10):\n            total = (total % p + f[n-1][d] % p) % p\n        return total", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        possibilities = {2: {9, 7}, 1: {8, 6}, 3: {4, 8}, 4: {3, 9, 0}, 5: {}, 6: {1, 7, 0}, 7: {6, 2}, 8:{1,3}, 9:{4,2}, 0:{4,6}}\n        \n        def dp(n):\n            result = {i:1 for i in range(10)}\n            for i in range(2, n+1):\n                temp = defaultdict(int)\n                for curr_position in result:\n                    for next_position in possibilities[curr_position]:\n                        temp[next_position] += result[curr_position]\n                result = temp\n            return sum(result.values()) % (pow(10, 9) + 7)\n        \n        return dp(n)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        cur_state = [1 for _ in range(10)]\n        mod = 10 ** 9 + 7\n        edges = [(1, 6), (1, 8), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)]\n        edge_dic = { i: [] for i in range(10) }\n        for i, j in edges:\n            edge_dic[i].append(j)\n            edge_dic[j].append(i)\n\n        for _ in range(1, n):\n            new_state = [0 for _ in range(10)]\n            for i in range(10):\n                new_state[i] = sum([cur_state[j] for j in edge_dic[i]]) % mod\n            cur_state = new_state\n        \n        return sum(cur_state) % mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        dp = [[1] * 10]\n        dp += [[0] * 10 for i in range(n-1)]\n        for i in range(n-1):\n            for j in range(10):\n                for k in d[j]:\n                    dp[i+1][k] = (dp[i+1][k] + dp[i][j]) % 1000000007\n        return sum(dp[-1]) % 1000000007", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10  # dp[i, N] = dp[nei, N-1] + dp[nei1, N-1] => dp[i] = \n        for i_n in range(n-1):\n            dp2 = [0] * 10\n            for i in range(10):\n                for nei in moves[i]:\n                    dp2[nei] += dp[i]\n                    dp2[nei] %= MOD\n            dp = list(dp2)\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = int(1e9 + 7)\n        adj = [\n            [4, 6],\n            [6, 8],\n            [7, 9],\n            [4, 8],\n            [3, 9, 0],\n            [],\n            [0, 1, 7],\n            [2, 6],\n            [1, 3],\n            [2, 4],\n        ]\n        dp = [[0] * 10 for _ in range(n + 1)]\n        dp[1] = [1] * 10\n        for i in range(2, n + 1):\n            for j in range(10):\n                for child in adj[j]:\n                    dp[i][j] += dp[i - 1][child]\n                    dp[i][j] %= MOD\n        ans = 0\n        for v in dp[n]:\n            ans += v\n            ans %= MOD\n        return ans\n", "from collections import Counter\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = {1 : [6, 8],\n                 2 : [7, 9],\n                 3 : [4, 8],\n                 4 : [3, 9, 0],\n                 6 : [1, 7, 0],\n                 7 : [2, 6],\n                 8 : [1, 3],\n                 9 : [2, 4],\n                 0 : [4, 6],\n                }\n        if n == 1:\n            return 10\n        \n        starts = dict([(i, 1) for i in moves])\n        for _ in range(n - 1):\n            next = dict([(i, 0) for i in moves])\n            for i in starts:\n                for j in moves[i]:\n                    next[j] += starts[i]\n            starts = next\n            \n        return sum(starts.values()) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        # [# of 0, # of 4/6, # of 2/8, # of corners]\n        c = [1,2,2,4]\n        nx = [0,0,0,0]\n        for i in range(n-1):\n            nx[0] = c[1]\n            nx[1] = 2*c[0] + c[3]\n            nx[2] = c[3]\n            nx[3] = 2*(c[1] + c[2])\n            c = nx[:]\n        return sum(c) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4, 6], [6, 8], [9, 7], [8, 4], [3, 9, 0], [], [7, 1, 0], [6, 2], [1, 3], [2, 4]]\n        count = [[0] * 10 for _ in range(n + 1)]\n        for i in range(10):\n            count[1][i] = 1\n        for i in range(1, n + 1):\n            for num in range(10):\n                for nei in moves[num]:\n                    count[i][num] += count[i - 1][nei]\n                    count[i][num] %= 10 ** 9 + 7\n        return sum(count[-1]) % (10 ** 9 + 7)", "class Solution:\n    neighbors = {1: (6, 8),\n                 2: (7, 9),\n                 3: (4, 8),\n                 4: (3, 9, 0),\n                 5: tuple(),\n                 6: (1, 7, 0),\n                 7: (2, 6),\n                 8: (1, 3),\n                 9: (2, 4),\n                 0: (4, 6)\n                }\n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 10\n        prev_moves = [1] * 10\n        current_moves = [0] * 10\n        \n        for i in range(n - 1):\n            for j in range(10):\n                current_moves[j] = sum(prev_moves[k] for k in self.neighbors[j]) % (10**9 + 7)\n            prev_moves = current_moves[:]\n        \n        return sum(prev_moves) % (10**9 + 7)\n", "class Solution:\n    neighbors = {1: (6, 8),\n                 2: (7, 9),\n                 3: (4, 8),\n                 4: (3, 9, 0),\n                 5: tuple(),\n                 6: (1, 7, 0),\n                 7: (2, 6),\n                 8: (1, 3),\n                 9: (2, 4),\n                 0: (4, 6)\n                }\n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 10\n        prev_moves = [1] * 10\n        current_moves = [0] * 10\n        \n        for i in range(n - 1):\n            for j in range(10):\n                current_moves[j] = sum(prev_moves[k] for k in self.neighbors[j]) % (10**9 + 7)\n            prev_moves = current_moves.copy()\n        \n        return sum(prev_moves) % (10**9 + 7)\n", "MODULE = 10 ** 9 + 7\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n\n        MOVEMENTS = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n\n        dp = [2, 2, 2, 2, 3, 0, 3, 2, 2, 2]\n        for idx in range(2, n):\n            new_dp = [0] * 10\n            for jdx in range(10):\n                for next_jdx in MOVEMENTS[jdx]:\n                    new_dp[next_jdx] += dp[jdx]\n            dp = new_dp\n\n        print(dp)\n        return sum(dp) % MODULE\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        adj = [\n            [4, 6],\n            [8, 6],\n            [7, 9],\n            [4, 8],\n            [3, 9, 0],\n            [],\n            [1, 7, 0],\n            [2, 6],\n            [1, 3],\n            [2, 4]\n        ]\n        m = 10 ** 9 + 7\n        \n        memo = [1] * 10\n        for i in range(1, n):\n            memo = [sum(memo[e] for e in adj[d]) % m for d in range(10)]\n        \n        return sum(memo) % m", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9+7\n        moves = {1:[6,8], 2:[7,9], 3:[4,8],\n                4: [0,3,9], 5:[], 6:[0,1,7],\n                7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]}\n        curr = [1]*10\n        for _ in range(n-1):\n            nex = [0]*10\n            for i in range(10):\n                nex[i] = sum(curr[j] for j in moves[i])%mod\n            curr = nex\n        return sum(curr)%mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7 \n        res = 0 \n        mappings = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9], \n            5: [], \n            6: [0, 1, 7], \n            7: [2, 6], \n            8: [1, 3], \n            9: [2, 4], \n            0: [4, 6],\n        }        \n        \n        dp = [[0 for i in range(10)] for i in range(n+1)]\n        dp[0] = [1 for i in range(10)]\n        dp[1] = [len(mappings[i]) for i in range(10)]\n        \n        for i in range(1, n-1):\n            for j in range(10):\n                pos = mappings[j]\n                # dp[i + 1][j] += dp[i-1][j] * dp[1][j]\n                for k in pos:\n                    dp[i + 1][k] += dp[i][j]\n                   \n        # print(dp)\n        return sum(dp[n - 1]) % MOD", "'''\nuse DP instead of BFS, becasue only finite many states\n2D DP:\nDP[l][s] = number of unique path of length l, starting with state s\nDP[l][1] = DP[l-1][6] + DP[l-1][8], becasue 1 can move to 6, 8\n'''\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        movedict = {0:[4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0],\n                    5:[], 6:[1,7,0], 7:[2,6], 8:[1,3], 9:[2,4]}\n        DP = [[0]*10 for _ in range(n)]\n        DP[0] = [1]*10\n        for l in range(1, n):\n            for s in range(10):\n                for moveto in movedict[s]:\n                    DP[l][s] += DP[l-1][moveto]\n                    DP[l][s] %= MOD\n        ans = sum(DP[-1]) % MOD\n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        nextMove = [(4,6), (6,8), (7,9), (4,8), (0,3,9), (),(0,1,7), (2,6), (1,3), (2,4)]\n        dp = [[0]*10 for _ in range(n)]\n        \n        if n ==1: return 10\n        MOD = 10**9 + 7\n        for i in range(10):\n            dp[0][i] = 1\n        \n        for r in range(1,n):\n            for i in range(10):\n                for m in nextMove[i]:\n                    # print(r,i,m)\n                    dp[r][m] = dp[r][m] + dp[r-1][i]\n                    # dp[r][m] %= MOD\n        return sum(dp[-1])  % MOD\n        \n", "class Solution(object):\n    def knightDialer(self, N):\n        # Use This Code\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        MOD = 10**9 + 7\n        table = [1] * 10\n        \n        for _ in range(N-1):\n            temp = [0] * 10\n            for k in range(10):\n                temp[k] = sum(table[i] for i in moves[k])\n                temp[k] %= MOD\n            table = temp\n\n        return sum(table)%MOD\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        # [# of 0, # of 4/6, # of 2/8, # of corners]\n        a,b,c,d = [1,2,2,4]\n        for i in range(n-1):\n            a,b,c,d = [b, 2*a+d, d, 2*(b+c)]\n        return sum([a,b,c,d]) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:     \n        graph = {\n            0: [4, 6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4:[9, 3, 0],\n            5: [],\n            6: [7, 1, 0], \n            7: [6, 2],\n            8: [1, 3],\n            9: [2,4]\n        }\n        \n        prev_dp = [1] * 10\n        for i in range(n-1):\n            dp = [0] * 10\n            for j in range(10):\n                dp[j] = sum(prev_dp[k] for k in graph[j]) % (10**9 + 7)\n            prev_dp = dp\n        return sum(prev_dp) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        #dp[i][j] possible answers at step[i], number j\n        dp =[[0 for _ in range(10)] for _ in range(n)]\n        #possible next moves\n        move = [[4,6], [6,8], [7,9], [4,8], [3,9,0], [], [1,7,0], [2,6], [1,3], [4,2]]\n        #initialization at n = 0, dp[0][j] = 1\n        dp[0] = [1  for _ in range(10)]\n        #transition funciton\n        for i in range(1, n):\n            for j in range(10):\n                for nei in move[j]:\n                    dp[i][j] = (dp[i][j] + dp[i-1][nei])%MOD\n        #final answer\n        return sum(dp[-1])%MOD", "class Solution():\n  def knightDialer(self, n):\n    max_val = 10**9 + 7\n    mem = {(1,1):1,\n           (1,2):1,\n           (1,3):1,\n           (1,4):1,\n           (1,5):1,\n           (1,6):1,\n           (1,7):1,\n           (1,8):1,\n           (1,9):1,\n           (1,0):1,\n          }\n\n    fields = {0:(4,6),\n              1:(6,8),\n              2:(7,9),\n              3:(4,8),\n              4:(3,9,0),\n              5:(),\n              6:(0,1,7),\n              7:(2,6),\n              8:(3,1),\n              9:(2,4),\n             }\n    \n    new_mem = {}\n\n    for length in range(1,n):\n      for num in range(10):\n        possible_jumps = fields[num]\n        possible_paths = 0\n        for jump in possible_jumps:\n          possible_paths = (possible_paths + mem[(length, jump)]) % max_val\n        new_mem[(length+1, num)] = possible_paths\n      mem = new_mem\n      new_mem = {}\n    \n    result = 0\n    for key in list(mem.keys()):\n      result = (result + mem[key]) % max_val\n    return result % max_val\n", "class Solution:\n    neighbors = {1: (6, 8),\n                 2: (7, 9),\n                 3: (4, 8),\n                 4: (3, 9, 0),\n                 5: tuple(),\n                 6: (1, 7, 0),\n                 7: (2, 6),\n                 8: (1, 3),\n                 9: (2, 4),\n                 0: (4, 6)\n                }\n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 10\n        prev_moves = [1] * 10\n        \n        for i in range(n - 1):\n            current_moves = [sum(prev_moves[k] for k in self.neighbors[j]) % (10**9 + 7) for j in range(10)]\n            prev_moves = current_moves\n        \n        return sum(prev_moves) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n\n        moves = [\n            [4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n            [1,7,0],[2,6],[1,3],[2,4]\n        ]\n        \n        dp = [[0] * 10 for _ in range(n + 1)]\n        for i in range(10):\n            dp[1][i] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(10):\n                for move in moves[j]:\n                    dp[i][move] += dp[i - 1][j]\n                    dp[i][move] %= MOD\n        \n        return sum(dp[n]) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9 + 7\n\n        d = dict()\n        d[0] = {4, 6}\n        d[1] = {6, 8}\n        d[2] = {7, 9}\n        d[3] = {4, 8}\n        d[4] = {0, 3, 9}\n        d[6] = {0, 1, 7}\n        d[7] = {2, 6}\n        d[8] = {1, 3}\n        d[9] = {2, 4}\n        \n        memo = [[0]*10 for i in range(n+1)]\n        memo[1] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        # print(memo)\n        \n        for i in range(2, n+1):\n            for key, val in list(d.items()):\n                for v in val:\n                    memo[i][key] += memo[i-1][v]\n        \n        # print(memo[-3:-1])\n        return sum(memo[-1])%mod\n        \n        \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        #OPT(i, j) = number of numbers you can dial with j hops reaching i\n        #k - possible places I could have come from\n        #OPT(i, j) = SUM(OPT(k, j-1))\n        #base cases\n        #if j = 0, then 0\n        #if i = 5, j = j, then OPT(i, j) = 0\n        jumps = dict({1:[8,6], 2:[7,9], 3:[4,8], 4:[0,3,9], 5:[], 6:[0,1,7], 7:[2,6], 8:[1,3],9:[2,4], 0:[4,6]})\n        table = [[0] * N for i in range(10)]\n        for j in range(N):\n            for i in range(10):\n                if j == 0:\n                    table[i][0] = 1\n                elif j == 1:\n                    table[i][j] = len(jumps[i])\n                else:\n                    kList = jumps[i]\n                    for k in kList:\n                        table[i][j] += table[k][j-1]\n        res = 0\n        for i in range(len(table)):\n            res = (res +table[i][-1])%(10**9 + 7)\n        return res\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        dp = [[0 for _ in range(n+1)] for _ in range(10)]  #dp[i][j] --> f(i, j) start from i and take j steps\n        for i in range(10):\n            dp[i][1] = 1\n        \n        for j in range(2,n+1):\n            for i in range(10):\n                for move in moves[i]:\n                    dp[i][j] += dp[move][j-1]\n                    dp[i][j] %= MOD\n                \n        sum_ = 0\n        for i in range(10):\n            sum_ += dp[i][n]\n            sum_ %= MOD\n            \n        return sum_        ", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {\n            0:(4, 6),\n            1:(6, 8),\n            2:(7, 9),\n            3:(4, 8),\n            4:(3, 9, 0),\n            5:(),\n            6:(1, 7, 0),\n            7:(2, 6),\n            8:(1, 3),\n            9: (2, 4)\n        }\n        dp = [1] * 10\n        for _ in range(n-1):\n            temp = [0] * 10\n            for i in range(10):\n                for j in d[i]:\n                    temp[j] = dp[i] + temp[j]\n            dp = temp\n        \n      \n        return sum(dp) % (10 ** 9 + 7)", "# class Solution:\n#     def knightDialer(self, N: int) -> int:\n#         steps = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0],5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n#         ret = set()\n#         def DFS(cur, i):\n#             if i == N:\n#                 n = 0\n#                 for c in cur:\n#                     n = n * 10 +c\n#                 ret.add(n)\n#                 print(n)\n#                 return\n#             for n in steps[cur[-1]]:\n#                 DFS(cur+[n], i+1)\n#             return\n#         for k in steps.keys():\n#             DFS([k], 1)\n#         return len(ret)\n        \nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        steps = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        dp = [1 for _ in range(10)]\n        for _ in range(N-1):\n            cur = [0 for _ in range(10)]\n            for i in range(10):\n                for j in steps[i]:\n                    cur[j] += dp[i]\n            dp = cur\n        return sum(dp) % (10**9 +7)\n                    \n", "class Solution:\n    d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]       # Create a graph, index is the vertex and values are the edges\n    cache = {}\n    def dfs(self, i, n):\n        if n == 0: return 1\n        elif (i, n) not in self.cache:\n            self.cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])  # Memoization\n            if i in [1,4,7]: self.cache[i+2, n] = self.cache[i, n]           # Symmetry\n            elif i in [3,6,9]: self.cache[i-2, n] = self.cache[i, n]\n        return self.cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        return sum(self.dfs(i, n-1) for i in range(10)) % (int(1e9)+7)  \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        mod = 10**9 + 7\n        dp = [[0 for i in range(n+1)] for j in range(10)]\n        for i in range(10):\n            dp[i][1] = 1\n        d = {0:[4, 6], 1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4]}\n        for j in range(2, n+1):\n            for i in range(10):\n                if i != 5:\n                    for ele in d[i]:\n                        dp[i][j] += dp[ele][j-1]\n                        dp[i][j] %= mod\n        # print(dp)\n        ans = 0\n        for i in range(10):\n            ans += dp[i][n]\n            ans %= mod\n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [[0 for _ in range(10)] for _ in range(n+1)]\n        prevs = {0: [4, 6], 1: [8, 6], 2: [7, 9], 3: [8, 4], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [6, 2], 8: [1, 3], 9: [4, 2]}\n        \n        for i in range(10):\n            dp[1][i] = 1\n        \n        for i in range(2, n+1):\n            for j in range(10):\n                for prev in prevs[j]:\n                    dp[i][j] += dp[i-1][prev]\n        \n        return sum(dp[-1]) % 1000000007", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1:\n            return 10\n        numpad = {'0':['4','6'],'1':['6','8'],'2':['7','9'],'3':['4','8'],'4':['0','3','9'],'6':['0','1','7'],'7':['2','6'],'8':['1','3'],'9':['4','2']}\n        dp={}\n        for i in ['0','1','2','3','4','6','7','8','9']:\n            dp[i]=[1,0]\n        for i in range(1,n):\n            for j in ['0','1','2','3','4','6','7','8','9']:\n                dp[j][i%2]=0\n                for k in numpad[j]:\n                    dp[j][i%2]+=dp[k][1-i%2]\n                dp[j][i%2]%=(1000000007)\n        res=0\n        for i in ['0','1','2','3','4','6','7','8','9']:\n            res+=dp[i][(n-1)%2]\n            res%=(1000000007)\n        return res", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [ [1]*10 for _ in range(n+1) ]\n        \n        d = {\n            0:(4,6),\n            1:(6,8),\n            2:(7,9),\n            3:(8,4),\n            4:(3,9,0),\n            5:(),\n            6:(1,7,0),\n            7:(6,2),\n            8:(1,3),\n            9:(2,4)\n        }\n        \n        for i in range(2, n+1):            \n            for j in range(0,10):\n                dp[i][j] = 0\n                for k in d[j]:\n                    dp[i][j] += dp[i-1][k]\n                    \n        \n        return sum(dp[n]) % (10**9 + 7)\n            \n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==0:\n            return 0\n        dic = {0: (4, 6),\n               1: (8, 6),\n               2: (7, 9),\n               3: (4, 8),\n               4: (3, 9, 0),\n               5: (),\n               6: (1, 7, 0),\n               7: (2, 6),\n               8: (1, 3),\n               9: (2, 4)}\n        dp = [1]*10\n        for _ in range(n-1):\n            new = [0]*10\n            for i in range(10):\n                for nei in dic[i]:\n                    new[i] += dp[nei]\n            dp = new\n        \n        return sum(dp)%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        arr = [[0 for i in range(10)] for i in range(n)]\n        mappings = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        mod = 10**9+7\n        arr[0] = [1 for i in range(10)]\n        for i in range(1,n):\n            for j in range(10):\n                for k in mappings[j]:\n                    arr[i][j] += arr[i-1][k]\n        return sum(arr[n-1])%mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        N=n\n        l=10\n        dp=[1]*l\n        m={1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\n        \n        for _ in range(2,N+1):\n            dp2=[0]*l\n            for i in range(l):\n                for j in m[i]:\n                    dp2[i]+=dp[j]\n            dp=dp2\n        \n        return sum(dp)%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        nextMove = [(4,6), (6,8), (7,9), (4,8), (0,3,9), (),(0,1,7), (2,6), (1,3), (2,4)]\n        dp = [[0]*10 for _ in range(n)]\n        \n        if n ==1: return 10\n        MOD = 10**9 + 7\n        for i in range(10):\n            dp[0][i] = 1\n        \n        for r in range(1,n):\n            for i in range(10):\n                for m in nextMove[i]:\n                    # print(r,i,m)\n                    dp[r][m] = dp[r][m] + dp[r-1][i]\n                    dp[r][m] %= MOD\n        return sum(dp[-1])  % MOD\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        next_move = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\n        \n        memo = defaultdict(int)\n        for i in range(10):\n            memo[i] = 1\n            \n        for _ in range(n-1):\n            next_memo = defaultdict(int)\n            for i in range(10):\n                for next_step in next_move[i]:\n                    next_memo[next_step] += memo[i]\n                    next_memo[next_step] %= 10**9 + 7\n            memo = next_memo\n        return sum(memo.values()) % (10**9 + 7)", "MOVES = [\n    [4, 6], # 0\n    [6, 8], # 1\n    [7, 9], # 2\n    [4, 8], # 3\n    [3, 9, 0], # 4\n    [], # 5\n    [1, 7, 0], # 6\n    [2, 6], # 7\n    [1, 3], # 8\n    [2, 4], # 9\n]\n\nmodulus = 10**9 + 7\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [1] * 10  # dp[i] = number of ways to get to digit in n moves, for n = 1, 2, ...\n        dp2 = [0] * 10  # second copy of dp2 to avoid mutating dp while iterating over it\n        for _ in range(1, n):\n            for digit in range(10):\n                dp2[digit] = 0\n                for next_digit in MOVES[digit]:\n                    dp2[digit] += dp[next_digit]\n                    dp2[digit] %= modulus\n            dp2, dp = dp, dp2  # swap out current dp\n        \n        result = 0\n        for ways in dp:\n            result += ways\n            result %= modulus\n        \n        return result", "class Solution:\n    d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n    cache = {}\n    def dfs(self, i, n):\n        if n == 0: return 1\n        if (i, n) not in self.cache:\n            self.cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])\n            if i in [1,4,7]: self.cache[i+2, n] = self.cache[i, n]\n            elif i in [3,6,9]: self.cache[i-2, n] = self.cache[i, n]\n        return self.cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        mod = int(1e9)+7\n        return sum(self.dfs(i, n-1) for i in range(10)) % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        ### f[i][j]: # of different codes with length i and with j as the last number\n        ### f[i][j] = sum(f[i-1][l]), where l can be achieved from j on the map\n        ### f[1][j] = 1, 0<=j<=9\n        \n        achievable = {}\n        achievable[0] = [ 4,6 ]\n        achievable[1] = [ 6,8 ]\n        achievable[2] = [ 7,9 ]\n        achievable[3] = [ 4,8 ]\n        achievable[4] = [ 0,3,9 ]\n        achievable[5] = [ ]\n        achievable[6] = [ 0,1,7 ]\n        achievable[7] = [ 2,6 ]\n        achievable[8] = [ 1,3 ]\n        achievable[9] = [ 2,4 ]\n        \n        f1 = [1 for _ in range(10)]\n        \n        m = 10 ** 9 + 7\n        \n        for i in range(1, n):\n            f2 = [0 for _ in range(10)]\n            for j in range(10):\n                f2[j] = sum( f1[l] for l in achievable[j]) % m\n            f1 = f2.copy()\n        \n        return sum(f1) % m\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        moves = {0:[4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], \n                 5:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\n        \n        mem = [[0 for i in range(n)] for i in range(10)]\n        \n        for i in range(10):\n            mem[i][0] = 1\n            \n        for col in range(1,n):\n            for row in range(10):\n                for move in moves[row]:\n                    mem[row][col] += mem[move][col-1]\n                    mem[row][col] %= (10**9) + 7\n        \n        tot_sum = 0\n        for row in range(10):\n            tot_sum += mem[row][n-1]\n            tot_sum %= (10**9) + 7\n            \n        return tot_sum\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {\n            0: [4,6],\n            1: [6,8],\n            2: [9,7],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [6,2],\n            8: [3,1],\n            9: [4,2]\n        }\n        res = 0\n        dp = [1]*10\n        for x in range(1,n):\n            temp = [0]*10\n            for i in range(10):\n                for j in d[i]:\n                    temp[j] += dp[i]\n            dp = temp \n        for i in dp:\n            res += i\n        return res % ((10**9)+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        tab = [[0 for i in range(n + 1)] for i in range(10)]\n        \n        for i in range(10):\n            tab[i][1] = 1\n            \n        for i in range(2, n + 1):\n            for j in range(10):\n                if j == 0:\n                    tab[j][i] = tab[4][i - 1] + tab[6][i - 1]\n                if j == 1:\n                    tab[j][i] = tab[6][i - 1] + tab[8][i - 1]\n                if j == 2:\n                    tab[j][i] = tab[7][i - 1] + tab[9][i - 1]\n                if j == 3:\n                    tab[j][i] = tab[4][i - 1] + tab[8][i - 1]\n                if j == 4:\n                    tab[j][i] = tab[3][i - 1] + tab[9][i - 1] + tab[0][i - 1]\n                if j == 5:\n                    tab[j][i] = 0\n                if j == 6:\n                    tab[j][i] = tab[1][i - 1] + tab[7][i - 1] + tab[0][i - 1]\n                if j == 7:\n                    tab[j][i] = tab[2][i - 1] + tab[6][i - 1]\n                if j == 8:\n                    tab[j][i] = tab[1][i - 1] + tab[3][i - 1]\n                if j == 9:\n                    tab[j][i] = tab[2][i - 1] + tab[4][i - 1]\n                    \n                tab[j][i] = tab[j][i] % (10**9 + 7)\n                \n        s = 0\n                \n        for i in range(10):\n            s += tab[i][n]\n            \n        s = s % (10**9 + 7)\n        \n        return s", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp=[[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[4,2]]\n        ct=[1]*10\n\n        while n-1:           \n\n            ct=[sum(ct[j] for j in i) for i in dp]\n                   \n            n-=1\n\n        return sum(ct)%(10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dic = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(0,3,9),5:(),6:(1,0,7),7:(2,6),8:(1,3),9:(2,4)}\n        prev_dic = {}\n        for i in range(10):\n            prev_dic[i] = 1\n        for i in range(n-1):\n            cur_dic = collections.defaultdict(int)\n            for j in prev_dic:\n                for k in dic[j]:\n                    cur_dic[k] += prev_dic[j]\n            prev_dic = cur_dic\n        return sum(prev_dic.values())%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7                        \n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1] * 10\n        for cell in range(n - 1):\n            dp2 = [0] * 10\n            for num_cell, count in enumerate(dp):\n                for knight in moves[num_cell]:\n                    dp2[knight] += count\n                    dp2[knight] %= MOD\n                dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        \n        \n        # dp[i][j] = x\n        # x possible calls of length i when knight is placed on j\n        \n        dp = [[0 for j in range(10)] for i in range(n)]\n        \n        for i in range(n):\n            for j in range(10):\n                if i == 0:\n                    dp[i][j] = 1\n                else:\n                    for move in moves[j]:\n                        dp[i][j] += dp[i-1][move] \n        \n        return sum(dp[n-1]) % (10 ** 9 + 7)\n                \n            \n        \n", "class Solution:\n    d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]       # Create a graph, index is the vertex and values are the edges\n    cache = {}\n    def dfs(self, i, n):\n        if n == 0: return 1\n        elif (i, n) not in self.cache:\n            self.cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])  # Memoization\n            if i in [1,4,7]: self.cache[i+2, n] = self.cache[i, n]           # Symmetry\n            elif i in [3,6,9]: self.cache[i-2, n] = self.cache[i, n]\n        return self.cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        return sum(self.dfs(i, n-1) for i in range(10)) % (int(1e9)+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        arr = [[0 for i in range(10)] for i in range(n)]\n        mappings = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        mod = 10**9+7\n        arr[0] = [1 for i in range(10)]\n        for i in range(1,n):\n            for j in range(10):\n                for k in mappings[j]:\n                    arr[i][j] = (arr[i][j]%mod + arr[i-1][k]%mod)%mod\n        return sum(arr[n-1])%mod", "import numpy as np\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\n        for i in range(n - 1):\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\n        return sum(dp) % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        #recursive + memo\n#         next_map = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n       \n#         def dfs(cur_num,n):\n#             if (cur_num,n) in memo.keys():\n#                 return memo[(cur_num,n)]\n#             if n == 0:\n#                 return 1\n#             ans = 0\n#             for next_num in next_map[cur_num]:                \n#                 ans += dfs(next_num,n-1)\n#             memo[(cur_num,n)] = ans\n#             return ans\n        \n#         ans = 0\n#         MOD = pow(10,9)+7\n#         memo = {}\n#         for i in range(10):            \n#             ans += dfs(i,n-1)%MOD\n#             ans = ans%MOD\n#         #    print (\\\"i:{}, ans={}\\\".format(i,ans))\n            \n#         return ans\n\n          #dp[numr][n]: represent the total combinations when start with number :num with n steps\n          dp = [ [0 for _ in range(n+1)] for _ in range(10)]\n          next_map = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n          MOD = pow(10,9)+7\n        \n          for i in range(10):\n              dp[i][1] = 1\n            \n          for k in range(2,n+1):\n              for i in range(10):\n                  for next_num in next_map[i]:\n                      dp[i][k] += dp[next_num][k-1]%MOD\n                      dp[i][k] %= MOD\n          ans  = 0  \n          for i in range(10):\n              ans += dp[i][n]\n              ans %= MOD\n            \n          return ans\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        \n        dp = [[0]*10  for _ in range(n)]\n        for i in range(n):\n            for j in range(10):\n                dp[i][j] = 0\n                \n        for i in range(10):\n            dp[0][i] = 1\n            \n        for t in range(1, n):\n            for num in range(10):\n                for move in moves[num]:\n                    dp[t][num] += dp[t - 1][move]\n                    dp[t][num] %= MOD\n        return sum(dp[n-1])%MOD\n", "class Solution:\n    \n    def knightDialer(self, k: int) -> int:\n        self.dirs = [\n            [1, 2], [1, -2], [-1, 2], [-1, -2],\n            [2, 1], [2, -1], [-2, 1], [-2, -1]\n        ]\n    \n        self.mod = 10 ** 9 + 7\n\n        self.n = 4\n        self.m = 3\n        if k == 1:\n            return 10\n        \n        self.forbidden = set([(3, 0), (3, 2)])\n        self.next_pos = self.build_pos()\n        # print(self.next_pos)\n        self.dp = [1] * 10\n        self.helper(k - 1)\n        return sum(self.dp) % self.mod\n    \n    \n    def helper(self, k):\n        if k == 0:\n            return\n        # print(self.dp)\n        next_dp = [0] * 10\n        for i in range(10):\n            for j in self.next_pos[i]:\n                next_dp[j] += (self.dp[i] % self.mod)\n                next_dp[j] %= self.mod\n        # print(next_dp)\n        self.dp = next_dp\n        self.helper(k - 1)\n    \n    def build_pos(self):\n        res = {}\n        for i in range(10):\n            next_num = []\n            x, y = self.get_pos(i)\n            for d in self.dirs:\n                nx, ny = d\n                if self.is_valid(x + nx, y + ny):\n                    \n                    num = self.get_num(x + nx, y + ny)\n                    # print(i, x + nx, y + ny, num)\n                    next_num.append(num)\n            res[i] = next_num\n        return res\n                    \n    \n    def is_valid(self, x, y):\n        return 0 <= x < self.n and 0 <= y < self.m and (x, y) not in self.forbidden\n        \n    \n    def get_num(self,x, y):\n        if x == 3 and y == 1:\n            return 0\n        if self.is_valid(x, y):\n            return x * 3 + y + 1\n        \n\n\n    def get_pos(self, num):\n        if num == 0:\n            return (3, 1)\n        num -= 1\n        row = num // 3\n        col = num % 3\n        return (row, col)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        '''\n        0->[4,6]->[1,3,7,9]->\n        \n        2 20 (3, 6), (2, 14)\n        \n        '''\n        if n == 1: return 10\n        \n        m = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        \n        cnt = defaultdict(int)\n        for k in m:\n            for v in m[k]:\n                cnt[v] += 1\n        \n        for _ in range(n-2):\n            cnt2 = defaultdict(int)\n            for k in cnt:\n                for v in m[k]:\n                    cnt2[v] += cnt[k]\n            cnt = cnt2\n        \n        return sum(cnt[k] for k in cnt) % (10**9+7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(N-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [[1] * 10 for _ in range(n)]\n        moves = {0: [4, 6],\n                 1: [6, 8],\n                 2: [7, 9],\n                 3: [4,  8],\n                 4: [0, 3, 9],\n                 5: [],\n                 6: [0, 1, 7],\n                 7: [2, 6],\n                 8: [1, 3],\n                 9: [2, 4]}\n        for i in range(1, n):\n            for j in range(10):\n                count = 0\n                for digit in moves[j]:\n                    count += dp[i-1][digit]\n                dp[i][j] = count\n        return sum(dp[-1]) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [\n            [4, 6],\n            [6, 8],\n            [7, 9],\n            [4, 8],\n            [3, 9, 0],\n            [],\n            [1, 7, 0],\n            [2, 6],\n            [1, 3],\n            [2, 4]\n        ]\n        dp = [1] * 10\n        for _ in range(n - 1):\n            prevDp = copy.copy(dp)\n            for i in range(10):\n                dp[i] = sum([prevDp[move] for move in moves[i]])\n        return sum(dp) % (10**9 + 7)\n            \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        LARGEINT = 10**9 + 7\n        moves = {1:2, 2:1, 4:2, 7:2, 8:1, 0:1}\n        while n > 1:\n            new_moves = {\n                1: (moves[4] + (2*moves[8])) % LARGEINT,\n                2: moves[7],\n                4: (moves[1] + moves[7] + (2*moves[0])) % LARGEINT,\n                7: (moves[4] + (2*moves[2])) % LARGEINT,\n                8: moves[1],\n                0: moves[4]\n            }\n            moves = new_moves\n            n -= 1\n        return sum(moves.values()) % LARGEINT\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            1 : (6, 8),\n            2 : (7, 9),\n            3 : (4, 8),\n            4: (3, 9, 0),\n            5 : tuple(),\n            6 : (1, 7, 0),\n            7 : (2, 6),\n            8 : (1, 3),\n            9 : (2, 4),\n            0 : (4, 6) \n        }\n        \n        dp = [[0 for _ in range(10)] for _ in range(n+1)]\n        \n        for r in range(n+1):\n            for c in range(10):\n                if r == 0:\n                    dp[r][c] = 0\n                elif r == 1:\n                    dp[r][c] = 1\n                else:\n                    for ne in neighbors[c]:\n                        dp[r][c] += dp[r-1][ne]\n        \n        return sum(dp[-1]) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {1:[6,8],\n             2:[7,9],\n             3:[4,8],\n             4:[3,9,0],\n             5:[],\n             6:[1,7,0],\n             7:[2,6],\n             8:[1,3],\n             9:[2,4],\n             0:[4,6]}\n        @lru_cache(None)\n        def dfs(i, n):\n            if n == 1:\n                return 1\n            else:\n                res = 0\n                for c in d[i]:\n                    res += dfs(c, n-1)\n                return res % (10**9+7)\n            \n        return sum(dfs(i, n) for i in range(10)) % (10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1: return 10\n        \n        MOD = 1000000007\n        graph = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        prev = [1,1,1,1,1,0,1,1,1,1]\n        for _ in range(n-1):\n            val = [0] * 10\n            for i in range(10):\n                for x in graph[i]:\n                    val[x] += prev[i]\n            prev = val\n        return sum(prev) % MOD\n", "class Solution:\n    def _knightDialer(self, n: int, curr_n: int, moves_map: dict, cache: dict) -> int:\n        if n == 0:\n            return 1\n        \n        if (curr_n,n) in cache:\n            return cache[(curr_n,n)]\n        \n        distinct_nums = 0\n        for next_n in moves_map[curr_n]:\n            distinct_nums += self._knightDialer(n-1, next_n, moves_map, cache)\n        \n        cache[(curr_n, n)] = distinct_nums\n        return cache[(curr_n,n)]\n    \n    def knightDialer(self, n: int) -> int:\n        # TLE, let's take care of some symmetry\n        # 1 == 3 == 9 == 7, 4 == 6, 2 == 8, 0\n        if n == 1:\n            return 10\n\n        mod = 10 ** 9 + 7\n        moves_map = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6],\n        }\n\n        # Bottom-up\n        dp_curr = [1] * 10\n        dp_next = [0] * 10\n\n        for _ in range(1, n):\n            for start, poss_moves in list(moves_map.items()):\n                dp_next[start] = sum(dp_curr[poss_move] for poss_move in poss_moves)\n            dp_curr = dp_next\n            dp_next = [0] * 10\n            \n        return sum(dp_curr) % mod\n        \n#         nums = 0\n#         for m, weight in [(1,4),(2,2),(4,2),(0,1)]:\n#             nums += weight * self._knightDialer(n-1, m, moves_map, cache)\n        \n#         return nums % mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        k = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n        }\n        \n        \n        dp = [[1] * 10, [0] * 10]\n        \n        turn = 0\n        \n        for t in range(n-1):\n            turn = 1 - turn\n            for i in range(10):\n                dp[turn][i] = sum(dp[1-turn][j] for j in k[i]) % (10 ** 9 + 7)\n                     \n        \n        return sum(dp[turn]) % (10 ** 9 + 7)\n        \n", "class Solution:\n\n    adjacency = {\n            0: {4, 6},\n            1: {8, 6},\n            2: {7, 9},\n            3: {8, 4},\n            4: {3, 9, 0},\n            5: {},\n            6: {1, 7, 0},\n            7: {2, 6},\n            8: {1, 3},\n            9: {2, 4}\n        }\n\n    def knightDialer(self, n: int):\n        count = [1 for _ in range(10)]\n\n        for _ in range(n - 1):\n            count = [sum(count[next_digit] for next_digit in Solution.adjacency[digit]) for digit in range(10)]\n\n        return sum(count) % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        next_move = { 0: [4,6], 1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7:[2,6], 8: [1,3], 9: [2,4]}\n        mod_num = 10**9 + 7\n        dp_prev = [1] * 10\n        \n        for i in range(n-1):\n            dp_new = [0] * 10\n            for num in range(10):\n                phones_for_num = sum((dp_prev[x] for x in next_move[num]))\n                dp_new[num] = phones_for_num\n            dp_prev = dp_new\n\n        return sum(dp_prev) % mod_num", "\n# class Solution:\n#     def knightDialer(self, n: int) -> int:\n#         possible_moves = {1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0], 5:[],\n#                           6:[1,7,0], 7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]}\n        \n#         self.memo = {}\n#         def dfs(cur_point, count, n):\n#             if count == n:\n#                 return 1\n#             if (cur_point, count) not in self.memo:\n#                 self.memo[(cur_point, count)] = sum(dfs(nxt_point, count + 1, n) for nxt_point in possible_moves[cur_point])\n#                 if cur_point in [1,4,7]: \n#                     self.memo[(cur_point+2, count)] = self.memo[(cur_point, count)]         \n#                 elif cur_point in [3,6,9]: \n#                     self.memo[(cur_point-2, count)] = self.memo[(cur_point, count)]\n#             return self.memo[(cur_point, count)]\n                \n        \n#         return sum(dfs(i, 1, n) for i in range(10)) % (10**9 + 7)\n\nclass Solution:\n    d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]       # Create a graph, index is the vertex and values are the edges\n    cache = {}\n    def dfs(self, i, n):\n        if n == 0: return 1\n        elif (i, n) not in self.cache:\n            self.cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])  # Memoization\n            if i in [1,4,7]: self.cache[i+2, n] = self.cache[i, n]           # Symmetry\n            elif i in [3,6,9]: self.cache[i-2, n] = self.cache[i, n]\n        return self.cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        return sum(self.dfs(i, n-1) for i in range(10)) % (int(1e9)+7)", "class Solution:\n    neighbors = {1: (6, 8),\n                 2: (7, 9),\n                 3: (4, 8),\n                 4: (3, 9, 0),\n                 5: tuple(),\n                 6: (1, 7, 0),\n                 7: (2, 6),\n                 8: (1, 3),\n                 9: (2, 4),\n                 0: (4, 6)\n                }\n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 10\n        prev_moves = [1] * 10\n        \n        for i in range(n - 1):\n            current_moves = [sum(prev_moves[k] for k in self.neighbors[j]) for j in range(10)]\n            prev_moves = current_moves\n        \n        return sum(prev_moves) % (10**9 + 7)\n", "class Solution:\n    \n    def __init__(self):\n        self.mem = dict()\n    \n    def knightDialer(self, n: int) -> int:\n        reach = [ [4,6], [6,8], [7,9], [4,8], [0,3,9], [], [0,1,7], [2,6], [1,3], [2,4] ]\n        \n        counts = [1] * 10\n        for i in range(n-1):\n            counts2 = [ sum(counts[k] for k in reach[j] ) for j in range(10) ]\n            # print(i,counts2)\n            counts = counts2\n        return sum(counts) % (10**9 + 7)\n        \n        \n#         def doit(start, hopsLeft):\n#             key = (start,hopsLeft)\n#             if key in self.mem:\n#                 return self.mem[key]\n#             if hopsLeft == 0:\n#                 count = 1\n#             else:\n#                 count = sum(doit(z,hopsLeft-1) for z in reach[start])\n#             self.mem[key] = count\n#             return count\n\n#         return sum(doit(z,n-1) for z in range(10)) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jumps = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        mod = 10**9 + 7\n        \n        if n == 1:\n            return 10\n        curr_total = []\n        last_step_totals = [1 for _ in range(10)]\n        \n        for i in range(n - 1):\n            curr_total = [0 for _ in range(10)]\n            \n            for i in range(10):\n                for jump_location in jumps[i]:\n                    curr_total[i] += last_step_totals[jump_location]\n            last_step_totals = curr_total\n        return sum(curr_total) % mod\n        \n        \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        #recursive + memo\n#         next_map = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n       \n#         def dfs(cur_num,n):\n#             if (cur_num,n) in memo.keys():\n#                 return memo[(cur_num,n)]\n#             if n == 0:\n#                 return 1\n#             ans = 0\n#             for next_num in next_map[cur_num]:                \n#                 ans += dfs(next_num,n-1)\n#             memo[(cur_num,n)] = ans\n#             return ans\n        \n#         ans = 0\n#         MOD = pow(10,9)+7\n#         memo = {}\n#         for i in range(10):            \n#             ans += dfs(i,n-1)%MOD\n#             ans = ans%MOD\n#         #    print (\\\"i:{}, ans={}\\\".format(i,ans))\n            \n#         return ans\n\n          #dp[numr][n]: represent the total combinations when start with number :num with n steps\n          dp = [ [0 for _ in range(n+1)] for _ in range(10)]\n          next_map = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n          MOD = pow(10,9)+7\n          for i in range(10):\n              dp[i][1] = 1\n            \n          for k in range(2,n+1):\n              for i in range(10):\n                  for next_num in next_map[i]:\n                      dp[i][k] += dp[next_num][k-1]%MOD\n                      dp[i][k] =  dp[i][k]%MOD\n          ans  = 0  \n          for i in range(10):\n              ans += dp[i][n]\n              ans = ans%MOD\n            \n          return ans\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "move_map = {\n    0: {4,6},\n    1: {6,8},\n    2: {7,9},\n    3: {4,8},\n    4: {3, 9, 0},\n    5: {},\n    6: {1, 0, 7},\n    7: {2, 6},\n    8: {1, 3},\n    9: {2, 4}\n}\n\nclass Solution:    \n    def knightDialer(self, n: int) -> int:\n        table = {}\n        for key in move_map:\n            table[key, 1] = 1\n            \n        for N in range(2,n+1):\n            for key in move_map:\n                val = 0\n                for new_key in move_map[key]:\n                    val += table[new_key, N-1]\n                table[key, N] = val\n                \n        res = 0\n        for key in move_map:\n            res += table[key, n]\n        return res % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # dp(0, digit) = 0\n        # dp(n steps, digit) = sum(dp(n - 1, f) for f in digit's friends)\n        if n == 0:\n            return 0\n        \n        friends = [0] * 10\n        friends[0] = [4, 6]\n        friends[1] = [6, 8]\n        friends[2] = [7, 9]\n        friends[3] = [8, 4]\n        friends[4] = [0, 3, 9]\n        friends[5] = []\n        friends[6] = [0, 1, 7]\n        friends[7] = [2, 6]\n        friends[8] = [1, 3]\n        friends[9] = [2, 4]\n        \n        dp = [[0 for _ in range(10)] for _ in range(n + 1)]\n        dp[1] = [1] * 10\n        for steps in range(2, n + 1):\n            for digit in range(10):\n                dp[steps][digit] = sum([dp[steps - 1][f] for f in friends[digit]]) % (10**9 + 7)\n        \n        return sum(dp[-1]) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        next_move = { 0: [4,6], 1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7:[2,6], 8: [1,3], 9: [2,4]}\n        mod_num = 10**9 + 7\n        dp_prev = [1] * 10\n        \n        for i in range(n-1):\n            dp_new = [0] * 10\n            for num in range(10):\n                phones_for_num = sum((dp_prev[x] for x in next_move[num])) % mod_num\n                dp_new[num] = phones_for_num\n            dp_prev = dp_new\n\n        return sum(dp_prev) % mod_num", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        if n == 1:\n            return 10\n        maps = {\n            0: {4, 6},\n            1: {6, 8},\n            2: {7, 9},\n            3: {4, 8},\n            4: {3, 9, 0},\n            5: {},\n            6: {1, 7, 0},\n            7: {2, 6},\n            8: {1, 3},\n            9: {4, 2}\n        }\n        prev = [1]*10\n        for i in range(1, n):\n            curr = [0]*10\n            for j in range(0, 10):\n                curr[j] = sum(prev[k] for k in maps[j])\n            prev = curr\n        return sum(prev)%(10**9+7)\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp=[[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[4,2]]\n        ct=[1]*10\n\n        while n-1:\n            tmp=[]\n            for i in range(10):\n                tmp+=[sum(ct[j] for j in dp[i])]\n            ct=tmp\n            n-=1\n\n        return sum(ct)%(10**9 + 7)\n", "possible = {\n    -1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n    0: [4, 6],\n    1: [6, 8],\n    2: [7, 9],\n    3: [4, 8],\n    4: [0, 3, 9],\n    5: [],\n    6: [0, 1, 7],\n    7: [2, 6],\n    8: [1, 3],\n    9: [2, 4]\n}\n\ncache = {}\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        total = self.helper(-1, n, 0) % 1000000007\n        return total\n    \n    \n    def helper(self, num, n, total):\n        if (num, n) in cache:\n            total += cache[(num, n)]\n            return total\n            \n        nxt = possible[num]\n        total_begin = total\n        if n == 1:\n            total += len(nxt)\n        else:\n            for num_next in nxt:\n                total = self.helper(num_next, n-1, total) % 1000000007\n        cache[(num, n)] = total - total_begin\n        return total", "from collections import deque\n\nclass Solution:\n    \n    cache = {}\n    d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)] \n\n    def dfs(self, i, n):\n        if n == 0: return 1\n        elif (i, n) not in self.cache:\n            self.cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])  # Memoization\n            if i in [1,4,7]: self.cache[i+2, n] = self.cache[i, n]           # Symmetry\n            elif i in [3,6,9]: self.cache[i-2, n] = self.cache[i, n]\n        return self.cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        return sum(self.dfs(i, n-1) for i in range(10)) % (int(1e9)+7)\n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {\n            0: [4,6],\n            1: [6,8],\n            2: [9,7],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [6,2],\n            8: [3,1],\n            9: [4,2]\n        }\n        res = 0\n        dp = [1]*10\n        for x in range(1,n):\n            temp = [0]*10\n            for i in range(10):\n                for j in d[i]:\n                    temp[j] += dp[i]\n            dp = temp \n        res = sum(dp) % ((10**9)+7)\n        return res \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moveable = {\n        1: [6, 8],\n        2: [7, 9],\n        3: [4, 8],\n        4: [0, 3, 9],\n        5: [],\n        6: [0, 1, 7],\n        7: [2, 6],\n        8: [1, 3],\n        9: [2, 4],\n        0: [4, 6]\n        }\n        MOD = 7 + 1e9\n        @lru_cache(maxsize=None)\n        def helper(step, num=-1):\n            if step == n:\n                return 1\n\n            result = 0\n            if num == -1:\n                for i in range(10):\n                    result = (result + helper(step + 1, i)) % MOD\n            else:\n                for move in moveable[num]:\n                    result = (result + helper(step + 1, move)) % MOD\n            return result\n\n        return int(helper(0))", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        d = {1:[6,8],2:[7,9],3:[8,4],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\n        f = [[0]*10 for i in range(2)]\n        f[1&1] = [1]*10\n        for i in range(2,n+1):\n            f[i&1] = [0]*10\n            for j in range(10):\n                for v in d[j]:\n                    f[i&1][v] += f[(i-1)&1][j] % (10**9+7)\n            # print(f[i&1])\n        return sum(f[n&1]) % (10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # recursive backtracking:\n        # you have 4 options: \n        #     (2 right, 1 down)\n        #     (2 right, 1 up)\n        #     (2 left, 1 down)\n        #     (2 left, 1 up)\n        # we have a grid, 4 by 3\n        if n == 1:\n            return 10\n        # grid = [\n        #     [1, 2, 3],\n        #     [4, 5, 6],\n        #     [7, 8, 9],\n        #     [-1,0,-1]\n        # ]\n        # # append the number after reaching node\n        # # we could do dynamic programming and remember how many we can reach if \n        # # we are at a specific n\n        # # at 0,0:\n        # # we can create a graph of things we can connect,\n        # # ie how many things can we reach from where we are right now\n        \n        # 0 - 9 are the connections\n        maps = {\n            0: {4, 6},\n            1: {6, 8},\n            2: {7, 9},\n            3: {4, 8},\n            4: {3, 9, 0},\n            5: {},\n            6: {1, 7, 0},\n            7: {2, 6},\n            8: {1, 3},\n            9: {4, 2}\n        }\n        prev = [1]*10\n        for i in range(1, n):\n            curr = [0]*10\n            for j in range(0, 10):\n                curr[j] = sum(prev[k] for k in maps[j])\n            prev = curr\n        return sum(prev)%(10**9+7)\n                \n        \n        '''\n            this index is the sum of all previous possibilities\n            we see when we reach at index 1, there are 2 places we could have came from\n            we have n total moves and 9 total numbers\n            we start at number 1, number 1 is connected to 6 and 8\n            now we go to 6 and 8,\n                6 connected to 1, 0, 7\n                8 connected to 1, 3\n                \n                can we some how sum for each n?\n                opt(i, j) = sum(opt(i-1, j) for j in connected )\n                return the sum of the top part of the array\n                \n                \n                \n                n=2 [1= arr[i-1][6]+arr[i-1][[8] ... ]]\n                n=1 [1:1, 2:1, 3:1 ... 0:1]\n            \n        \n        '''\n        \n        \n        \n        \n        \n        \n#         count = 0\n#         numbers = set()\n#         def recursion(x, y, number, depth):\n#             nonlocal count, numbers\n#             if depth > n:\n#                 return\n#             if not(0<= x < 4 and 0<=y<3 and grid[x][y]!=-1):\n#                 return\n#             if depth == n:\n#                 numbers.add(number)\n#                 return\n#             else:\n#                 number+=grid[x][y]*(10**depth)\n#                 recursion(x+2, y-1, number, depth+1)\n#                 recursion(x+2, y+1, number, depth+1)\n                \n#                 recursion(x-2, y-1, number, depth+1)\n#                 recursion(x-2, y+1, number, depth+1)\n                \n#                 recursion(x+1, y+2, number, depth+1)\n#                 recursion(x+1, y-2, number, depth+1)\n                \n#                 recursion(x-1, y+2, number, depth+1)\n#                 recursion(x-1, y-2, number, depth+1)\n                \n#                 return\n#         for x in range(0, 4):\n#             for y in range(0, 3):\n#                 recursion(x, y, 0, 0)\n#         print(numbers)\n#         return len(numbers)%(10**9+7)\n", "possibilities = {\n    1: [6,8],\n    2: [7,9],\n    3: [8,4],\n    4: [9,3,0],\n    5: [],\n    6: [1,7,0],\n    7: [6,2],\n    8: [1,3],\n    9: [2,4],\n    0: [4,6],\n}\n\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        if N == 1:\n            return 10\n        \n        counter = 0\n        num_ways = [1,1,1,1,1,0,1,1,1,1]\n        for i in range(N-1):\n            updated = [0]*10\n            for digit in range(10):\n                updated[digit] = sum([num_ways[previous] % int(10e8+7) for previous in possibilities[digit]]) \n            num_ways = updated\n        return sum(num_ways) % int(10e8+7)\n        \n        \n        \n        \n        \n        \n\n\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        res = [1] * 10  # \u6bcf\u4e2a\u4f4d\u7f6e\u51fa\u73b0\u7684\u6b21\u6570\n        next_move = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        i = 1\n        while i < N:\n            res2 = [0] * 10\n            for k, v in enumerate(res):\n                for j in next_move[k]:  # \u5bf9\u4e8e\u8df3\u5230\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u66f4\u65b0\u51fa\u73b0\u7684\u6b21\u6570\n                    res2[j] += v\n            res = res2  # \u66f4\u65b0\u7ed3\u679c\n            i += 1\n        return sum(res) % (10**9 +7)  # \u4e0d\u8981\u5fd8\u8bb0\u53d6\u4f59\n#https://www.jianshu.com/p/caa2c35321a7\n", "class Solution:\n    def knight(self, n, current, memo):\n        knight_mp = {1: {8, 6},\n                    2: {9, 7},\n                    3: {4, 8},\n                    4: {3, 9, 0}, # 0 also\n                    5: {},\n                    6: {7, 1, 0}, # 0 also\n                    7: {2, 6},\n                    8: {3, 1},\n                    9: {2, 4},\n                    0: {6, 4}}        \n\n        if n==1:\n            return 1\n        if (current, n) in memo:\n            return memo[(current, n)]\n        res = 0\n        for item in knight_mp.get(current, set()):\n            res+=self.knight(n-1, item, memo)\n            \n            \n        memo[(current, n)] = res\n        return res\n        \n    def knightDialer(self, n: int) -> int:\n#         res = 0\n#         mod = 10**9+7\n#         memo = {}\n#         for i in range(0, 10):\n#             res+=self.knight(n, i, memo)%mod\n#         return res%mod\n    \n    \n        knight_mp = {1: {8, 6},\n                    2: {9, 7},\n                    3: {4, 8},\n                    4: {3, 9, 0}, # 0 also\n                    5: {},\n                    6: {7, 1, 0}, # 0 also\n                    7: {2, 6},\n                    8: {3, 1},\n                    9: {2, 4},\n                    0: {6, 4}}        \n\n        dp = [[0 if i!=0 else 1 for _ in range(0, 10)] for i in range(n)]\n        mod = 10**9+7\n\n        for step in range(1, n):\n            for cell in range(0, 10):\n                for neighbor in knight_mp.get(cell, set()):\n                    dp[step][cell] += dp[step-1][neighbor]\n        return sum(dp[n-1])%mod\n    \n    \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        possible_moves = [\n            [4, 6],\n            [6, 8],\n            [7, 9],\n            [4, 8],\n            [3, 9, 0],\n            [],\n            [1, 7, 0],\n            [2, 6],\n            [1, 3],\n            [2, 4]\n        ]\n        \n        dp = [1 for _ in range(10)]\n        for _ in range(1, N):\n            dp1 = [0 for _ in range(10)]\n            for i in range(10):\n                for m in possible_moves[i]:\n                    dp1[i] += dp[m]\n            dp = dp1\n        \n        return sum(dp) % (pow(10, 9) + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1: return 10\n        \n        move_dict = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], \n                     5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\n        MOD = 10**9+7\n        # dp[i] suggests how many ways we can move to i on the phone pad\n        dp = [2, 2, 2, 2, 3, 0, 3, 2, 2, 2]\n        \n        # the first two moves are done\n        for i in range(n-2):\n            new_dp = [2, 2, 2, 2, 3, 0, 3, 2, 2, 2]\n            for d in range(10):\n                new_dp[d] = sum(dp[move] for move in move_dict[d]) % MOD\n            dp = new_dp\n            \n        return sum(dp) % MOD\n        \n        \n", "class Solution(object):\n    def knightDialer(self, N):\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(N-1):\n            dp2 = [0] * 10\n            for i, c in enumerate(dp):\n                for nei in moves[i]:\n                    dp2[i] += dp[nei]\n                    dp2[i] %= MOD\n            dp = dp2\n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # DP \u6bcf\u6b21\u8981\u52a0\u4e0a\u90a3\u4e2a\u683c\u7684DP\u503c\n        #{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 9}, {4, 2}\n        # \u4e8c\u7ef4\u6570\u7ec4 \u8868\u793a\u7b2ci\u6b21\u8df3\u5230j\u4e0a\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\n        # \u6bd4\u5982\u52304\u7684\u65f6\u5019 \u90a3\u4e48\u53ef\u80fd\u662f\u4ece3,9,0 \u6765\u7684 \u90a3\u4e48i,4 = i,4 + i-1 (3,9,0)\n        stack = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,9],[4,2]]\n        dp = [[0 for _ in range(10)] for __ in range(n)]\n        for i in range(10):     # \u968f\u4fbf\u653e  \u6240\u6709\u6309\u952e\u90fd\u521d\u59cb\u4e3a1 \u56e0\u4e3an\u662f\u8df3\u7684\u6b21\u6570 \u653e\u7684\u4e0d\u7b97\n            dp[0][i] = 1\n        for i in range(1,n):\n            for j in range(10):\n                for k in stack[j]:\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % (10**9 + 7)\n        return sum(dp[-1][i] for i in range(10))  % (10**9 + 7)", "class Solution:\n    def initMoveTable(self):\n        moveTable = dict()\n        moveTable[0] = [4, 6]\n        moveTable[1] = [6, 8]\n        moveTable[2] = [7, 9]\n        moveTable[3] = [4, 8]\n        moveTable[4] = [0, 3, 9]\n        moveTable[5] = []\n        moveTable[6] = [0, 1, 7]\n        moveTable[7] = [2, 6]\n        moveTable[8] = [1, 3]\n        moveTable[9] = [2, 4]\n        \n        return moveTable\n        \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 10\n        \n        moveTable = self.initMoveTable()\n        dp = []\n        for i in range(n+1):\n            newRow = []\n            for j in range(10):\n                newRow.append(None)\n            dp.append(newRow)\n            \n        for i in range(10):\n            dp[1][i] = 1\n            \n    \n        for i in range(2, n+1):\n            for j in range(10):\n                localNumWays = 0\n                moves = moveTable[j]\n                for move in moves:\n                    localNumWays += dp[i-1][move]\n                dp[i][j] = localNumWays % (pow(10,9) + 7)\n                \n        return sum(dp[i]) % (pow(10,9) + 7)\n", "class Solution:\n    main_dic = {}\n    \n    def __init__(self):\n        dic = {}\n        for i in range(4):\n            for j in range(3):\n                if i==3 and (j==0 or j==2): continue\n                dic[(i,j)] = self.get_ind(i,j)\n        self.main_dic = dic\n    \n    def get_ind(self,i,j):\n        lst = []\n        lst.append((i+2,j-1))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i+2,j+1))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i-2,j-1))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i-2,j+1))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i+1,j+2))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i-1,j+2))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i+1,j-2))\n        if not self.check_ind(lst[-1]): lst.pop()\n        lst.append((i-1,j-2))\n        if not self.check_ind(lst[-1]): lst.pop()\n        return lst\n        \n    def check_ind(self,t):\n        i,j = t\n        if i<0 or j<0: return False\n        if i>3 or j>2: return False\n        if i==3 and (j==0 or j==2): return False\n        return True\n    \n    def knightDialer(self, n: int) -> int:\n        if n==1: return 10;\n        \n        old = [[1]*3 for i in range(4)]\n        old[3][0],old[3][2]=0,0\n        \n        for k in range(n-1):\n            new = []\n            for i in range(4):\n                temp = []\n                for j in range(3):\n                    if i==3 and (j==0 or j==2): \n                        temp.append(0)\n                        continue\n                    lst,res = self.main_dic[(i,j)],0\n                    for m,n in lst:\n                        res+=old[m][n]\n                    temp.append(res)\n                new.append(temp)\n            old = new\n        res = sum([sum(l) for l in old])\n        return res%(10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        \n        hop_map = {1:[6,8],\n                  2:[7,9],\n                  3:[4,8],\n                  4:[0,3,9],\n                  6:[0,1,7],\n                  7:[2,6],\n                  8:[1,3],\n                  9:[2,4],\n                  0:[4,6]}\n        \n        memo = {(i,1): 1 for i in range(10)}\n        \n        def num_hops(key:int, N:int):\n\n            if N == 1:\n                return 1\n            \n            if key in [1,4,7]:\n                key += 2\n            elif key == 5:\n                return 0\n            \n            if (key, N) in memo:\n                return memo[(key, N)]\n            \n            sum_ = 0\n            for v in hop_map[key]:\n                sum_ += num_hops(v, N-1)\n            \n            memo[(key, N)] = sum_ % (10**9 + 7)\n            return sum_\n    \n        sum_ = 0\n        for i in range(10):\n            sum_ += num_hops(i, N)  % (10**9 + 7)\n        return sum_  % (10**9 + 7)\n", "from collections import deque\n\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        m = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        \n        curt = {i: 1 for i in range(0, 10)}\n        n -= 1        \n        \n        while n > 0:\n            next_set = {}\n            for key in curt:\n                for nei in m[key]:\n                    next_set[nei] = (next_set.get(nei, 0) + curt[key]) % MOD\n                    \n            curt = next_set\n            n -= 1\n        \n        return sum(curt.values()) % MOD\n        \n            \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        x0, x1, x2, x3, x4, x5, x6, x7, x8, x9 = 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n        mod = pow(10, 9) + 7\n        for i in range(n - 1):\n            t0 = (x4 + x6) % mod\n            t1 = (x6 + x8) % mod\n            t2 = (x7 + x9) % mod\n            t3 = (x4 + x8) % mod\n            t4 = (x0 + x3 + x9) % mod\n            t5 = 0\n            t6 = (x0 + x1 + x7) % mod\n            t7 = (x2 + x6) % mod\n            t8 = (x1 + x3) % mod\n            t9 = (x2 + x4) % mod\n            x0, x1, x2, x3, x4, x5, x6, x7, x8, x9 = t0, t1, t2, t3, t4, t5, t6, t7, t8, t9\n            \n        return (x0 + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9) % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dct={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n        \n        def func(k):\n            \n            if k==1:\n                return {i:1 for i in range(10)}\n                        \n            res=func(k-1)\n            \n            counts={i:0 for i in range(10)}\n            \n            for i in range(10):\n                for t in dct[i]:\n                    counts[t]+=res[i]\n                    \n            return counts\n        \n        \n        res=func(n)\n        \n        return sum(res.values())%(10**9+7)", "from functools import lru_cache\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        @lru_cache(None)\n        def jumps(start, n):\n            if n == 0:\n                return 1\n            ans = 0\n            for neighbor in neighbors[start]:\n                ans = (ans + jumps(neighbor, n-1)) % MOD\n            return ans % MOD\n        \n        neighbors = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6]\n        }\n        MOD = pow(10, 9) + 7\n        res = 0\n        for i in range(10):\n            res = (res + jumps(i, n-1)) % MOD\n        return res", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        \n        dp = [[None]*10 for _ in range(n)]\n        for i in range(10):\n            dp[0][i] = 1\n            \n        def helper(node, jumpsLeft):\n            if dp[jumpsLeft][node]:\n                return dp[jumpsLeft][node]\n            cnt = 0\n            for nextJump in moves[node]:\n                cnt += helper(nextJump, jumpsLeft - 1)\n                cnt %= MOD\n            dp[jumpsLeft][node] = cnt\n            return cnt\n        \n        for i in range(10):\n            helper(i, n-1)\n            \n        return sum(dp[n-1]) % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10 ** 9 + 7\n        nei = {0: [4, 6,], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\n        \n        @lru_cache(None)\n        def dfs(i, pre):\n            if i == n:\n                return 1\n            cand = nei[pre] if pre != None else range(10)\n            ans = 0\n            for k in cand:\n                ans += dfs(i + 1, k) % mod\n            return ans % mod\n        \n        return dfs(0, None)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # dp[i][move] = [dp[neighbor][move - 1]for neighbor in neighbors]\n        neighbors = {1:[6,8], 2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\n        if n == 0:\n            return 0\n        dp = [[1 for i in range(n)] for i in range(10)]\n        for move in range(1,n):\n            for num in range(10):\n                dp[num][move] = sum([dp[neighbor][move - 1] for neighbor in neighbors[num]]) % 1000000007\n        return sum([dp[num][n-1] for num in range(10)]) % 1000000007\n", "class Solution:\n    def knightDialer(self, n: int) -> int: \n        w = [1]\n        x = [1]\n        y = [1]\n        z = [1]\n        \n        for i in range(n-1):\n            w_n = 2*x[-1]\n            x_n = w[-1] + 2*y[-1]\n            y_n = x[-1] + z[-1]\n            z_n = 2*y[-1]\n            w.append(w_n)\n            x.append(x_n)\n            y.append(y_n)\n            z.append(z_n)\n            \n        return (w[-1] + 2*x[-1] + 4*y[-1] + 2*z[-1] + (1 if n == 1 else 0)) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        path={\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5:[],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        M=10**9+7\n        dp=[[None for _ in range(n) ] for _ in range(10)]\n        def paths(i,n):\n            if dp[i][n]:\n                return dp[i][n]\n            #number of ways to jump from i n times          \n            if n==1:\n                return len(path[i])\n            if n==0:\n                return 1\n            s=0\n            for v in path[i]:\n                s+=paths(v,n-1)\n            dp[i][n]=s%M\n            return dp[i][n]\n        ans=0\n        for k in path:\n            ans+=paths(k,n-1)\n        return ans%(M)\n                \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        h = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        \n        if n == 1:\n            return 10\n        \n        o = []\n        le = 0\n        \n        oTrack = [0] * 10\n        track = [0] * 10\n        \n        for loops in range(n - 1):\n            track = [0] * 10\n            for k,v in enumerate(track):\n                #print(\\\"k: \\\", k, track)\n                hg = h.get(k)\n                for i in hg:\n                    track[i] += max(oTrack[k], 1)\n                    \n            \n            #print(\\\"loop: \\\", loops, p, track, oTrack)\n            oTrack = track.copy()\n            \n        \n        return sum(track) % (10 ** 9 + 7)\n", "class Solution:\n        \n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        dp = [1] * 10\n        for hops in range(n-1):\n            dp2 = [0] * 10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        prior_case = [1]*10\n        current_case = [1]*10\n        paths = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2,6], 8: [1,3], 9: [2, 4], 0: [4,6]}\n        curr_hop = 1\n        \n        while curr_hop < n:\n            curr_hop += 1\n            current_case = [0]*10\n            \n            for num in range(10):\n                for neighbor in paths[num]:\n                    current_case[num] += prior_case[neighbor]\n                    \n            prior_case = current_case\n            \n        return sum(current_case) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        mm = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [8, 4],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [6, 4]\n        }\n        \n        ans = 0\n        \n        @lru_cache(maxsize=None)\n        def dfs(val, rem):\n            if rem == 0:\n                return 1\n            \n            res = 0\n            for adj in mm[val]:\n                res += dfs(adj, rem - 1)\n                \n            return res\n        \n        for key in list(mm.keys()):\n            ans += dfs(key, n - 1)\n            \n        return ans % 1000000007\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        \n        hop_map = {1:[6,8],\n                  2:[7,9],\n                  3:[4,8],\n                  4:[0,3,9],\n                  6:[0,1,7],\n                  7:[2,6],\n                  8:[1,3],\n                  9:[2,4],\n                  0:[4,6]}\n        \n        memo = {(i,1): 1 for i in range(10)}\n        \n        def num_hops(key:int, N:int):\n\n            if N == 1:\n                return 1\n            \n            if key in [1,4,7]:\n                key += 2\n            elif key == 5:\n                return 0\n            \n            if (key, N) in memo:\n                return memo[(key, N)]\n            \n            sum_ = 0\n            for v in hop_map[key]:\n                sum_ += num_hops(v, N-1)\n            \n            memo[(key, N)] = sum_ \n            return sum_\n    \n        sum_ = 0\n        for i in range(10):\n            sum_ += num_hops(i, N) \n        return sum_  % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 0 or not n:\n            return 0\n        \n        graph = {0:[4,6],\n                 1:[6,8],\n                 2:[7,9],\n                 3:[4,8],\n                 4:[3,9,0],\n                 5:[],\n                 6:[1,7,0],\n                 7:[2,6],\n                 8:[1,3],\n                 9:[2,4]}\n        @lru_cache(maxsize=None)\n        def helper(left, curr): \n            \n            if left == 1:\n                return 1\n            \n            cnt = 0\n            for nei in graph[curr]:\n                cnt += helper(left-1, nei)\n            return cnt\n        #n = 3\n        ans = 0\n        for i in range(10):\n            ans += helper(n, i)\n        return ans %(10**9+7)\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            0: [4, 6], \n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n\n        count = 0\n        num_each_digit = {\n            0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1\n        } \n        for i in range(1, n+1):\n            count = sum(num_each_digit.values()) \n            temp_dict = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n            for digit in num_each_digit: \n                num_digit = num_each_digit[digit]\n                digit_neighbors = neighbors[digit]\n                for neighbor in digit_neighbors: \n                    temp_dict[neighbor] += num_digit \n            num_each_digit = temp_dict\n        return count % (10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def matmul(A, B):\n            BT = list(zip(*B))\n            res = [[sum((x*y) for x, y in zip(row, col))%M for col in BT] for row in A]\n            return res\n        \n        def pow(A, n):\n            \n            l = n.bit_length()\n            res = [[1 if i==j else 0 for j in range(len(A[0]))] for i in range(len(A))]\n            tmp = A\n            \n            for i in range(l):\n                \n                mask = 1 << i\n                \n                if mask & n != 0:\n                    res = matmul(res, tmp)\n                    \n                tmp = matmul(tmp, tmp)\n                \n            return res\n        \n        M = 10**9+7\n        A = [[0,0,0,0,1,0,1,0,0,0],\n             [0,0,0,0,0,0,1,0,1,0],\n             [0,0,0,0,0,0,0,1,0,1],\n             [0,0,0,0,1,0,0,0,1,0],\n             [1,0,0,1,0,0,0,0,0,1],\n             [0,0,0,0,0,0,0,0,0,0],\n             [1,1,0,0,0,0,0,1,0,0],\n             [0,0,1,0,0,0,1,0,0,0],\n             [0,1,0,1,0,0,0,0,0,0],\n             [0,0,1,0,1,0,0,0,0,0]]\n        \n        res = matmul([[1,1,1,1,1,1,1,1,1,1]], pow(A,n-1))\n        \n        return sum(res[0]) % M\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        numpad = [[1,2,3],[4,5,6],[7,8,9],['*',0,'#']]\n        dp = [1,1,1,1,1,1,1,1,1,1]\n        square = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[7,0,1],[2,6],[1,3],[2,4]]\n        mod = 10**9+7\n        for i in range(2,N+1):\n            temp=[0,0,0,0,0,0,0,0,0,0]\n            for row in range(4):\n                for col in range(3):\n                    if numpad[row][col] == '*' or numpad[row][col] == '#':\n                        continue\n                    else:\n                        num = numpad[row][col]\n                        for j in square[num]:\n                            temp[num] += dp[j]%mod\n            dp=temp\n        return sum(dp)%mod\n                                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        moves = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\n        \n        from functools import lru_cache\n        @lru_cache(maxsize = None)\n        def dfs(i, length):\n            if n == length:\n                return 1\n            \n            total = 0\n            for newI in moves[i]:\n                total += dfs(newI, length + 1)\n            return total\n        \n        bound = 10**9+7\n        \n        ans = 0\n        for i in range(0, 10):\n            ans += dfs(i, 1)\n            if ans >= bound:\n                ans = ans%bound\n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        next_moves = defaultdict(list)\n        next_moves[1] = [6, 8]\n        next_moves[2] = [7, 9]\n        next_moves[3] = [4, 8]\n        next_moves[4] = [0, 3, 9]\n        next_moves[5] = []\n        next_moves[6] = [0, 1, 7]\n        next_moves[7] = [2, 6]\n        next_moves[8] = [1, 3]\n        next_moves[9] = [2, 4]\n        next_moves[0] = [4, 6]\n        \n        solutions = [1 for _ in range(10)]\n        while n > 1:\n            next_solutions = []\n            for last_num in range(0, 10):\n                count = sum(solutions[prev] for prev in next_moves[last_num])\n                if count >= MOD: count %= MOD\n                next_solutions.append(count)\n            solutions = next_solutions\n            n -= 1\n                \n        return sum(solutions) % MOD\n        \n        \n        memo = dict()\n        \n        def count(size, at):\n            if size == 0: return 1\n            if (size, at) in memo: return memo[(size, at)]\n            \n            c = sum(count(size - 1, next_at) for next_at in next_moves[at])\n            if c >= MOD: c %= MOD\n            \n            memo[(size, at)] = c\n            return c\n        \n        total_possible = sum(count(n - 1, at) for at in range(0, 10))\n        return total_possible % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = pow(10, 9) + 7\n        maps = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n        }\n        \n        dp = [[0] * n for _ in range(10)]\n        for i in range(10):\n            dp[i][0] = 1\n            \n        for i in range(1, n):\n            for digit in range(10):\n                dp[digit][i] = sum(dp[j][i-1] for j in maps[digit])\n                \n        return sum(dp[digit][-1] for digit in range(10)) % mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        D = []\n        modulo = 10**9 + 7\n        \n        movesDict = { 0: [4, 6], 1: [6, 8], 2: [7,9], 3: [4,8], 4: [3,9,0],\n                      5: [], 6: [1,7 ,0],  7: [2,6], 8: [1,3], 9: [2,4]}\n        \n        for i in range(10):\n            D.append([-1]*(n+1))\n        \n        def help(start, length):\n            if length == 1:\n                return 1\n            if D[start][length] != -1:\n                return D[start][length]\n            moves = movesDict[start]\n            total = 0\n            for newStart in moves:\n                total += help(newStart, length - 1)\n                total %= modulo\n            D[start][length] = total\n            # print(f'start: {start}, length: {length}, total: {total}')\n            return total\n        \n        res = 0\n        for i in range(10):\n            res += help(i, n)\n        return res % modulo \n        \n        \n'''\n1 -> 6, 8\n2 -> 7, 9\n3 -> 4, 8\n4 -> 3, 9, 0\n5 -> n/a\n6 -> 1, 7, 0\n7 -> 2, 6\n8 -> 1, 3\n9 -> 2, 4\ndp - solve how many for n - 1 starting at some index then ?\narray [start][length]\ninit with [10][n+1]\n\n\n\n'''\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def knight_dailer(n):\n            paths = {0: [4, 6], 1: [6, 8], 2: [9, 7], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [6, 2], 8: [1, 3],\n                     9: [4, 2]}\n            count = 0\n            import sys, functools\n            sys.setrecursionlimit(10**9)\n\n            @functools.lru_cache(None)\n            def traverse(i, rem):\n                if rem == 0:\n                    return 1\n                ans = 0\n                for p in paths[i]:\n                    res = traverse(p,rem-1)\n                    ans += res\n                return ans\n            for i in range(10):\n                count += (traverse(i,n-1))\n            return count % ((10**9) + 7)\n        return knight_dailer(n)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        map = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        \n        dp = [1] * len(map)\n        for hops in range(n - 1):\n            dp2 = [0] * len(map)\n            for node, cnt in enumerate(dp):\n                for nei in map[node]:\n                    dp2[nei] += cnt\n                    dp2[nei] %= MOD\n            dp = dp2\n        return sum(dp) % MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n\n    \n        dp = [ [0] * 10 for _ in range(n)]\n        \n        pad_map = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        mod = 10**9 + 7\n        \n        for i in range(10):\n            dp[0][i] = 1\n            \n        for i in range(n - 1):\n            for j in range(10):\n                \n                dsts = pad_map[j]\n                \n                for dst in dsts:\n                    dp[i + 1][dst] = (dp[i][j] + dp[i + 1][dst]) % mod\n                \n                \n        \n            \n        return sum(dp[-1])%mod", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        d = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [4, 2], 5: [], 0: [4, 6]}\n        \n        @lru_cache(None)\n        def helper(k, i):\n            if k == 0:\n                return 1\n            r = 0\n            for n in d[i]:\n                r += helper(k - 1, n)\n            return r\n        ans = 0\n        \n        for n in list(d.keys()):\n            ans += helper(N - 1, n)\n            \n        return ans % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = int(1e9)+7\n        d = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7:[2,6], 8: [1,3], 9:[2, 4], 0: [4,6]}\n        ans = {}\n        # 1,3; 4,6; 7,9\n        @lru_cache(maxsize=None)\n        def dfs(i, n):\n            nonlocal d\n            if n == 0: return 1\n            ans = 0\n            for val in d[i]:\n                ans += dfs(val, n-1)\n            return ans    \n        for i in range(10):\n            if i in [3,6,9]:\n                ans[i] = ans[i-2]\n            else:    \n                ans[i] = dfs(i, n-1)\n        #print(ans)                \n        return sum(ans.values()) % mod\n        # mod = int(1e9)+7\n        # d = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7:[2,6], 8: [1,3], 9:[2, 4], 0: [4,6]}\n        # cache = collections.defaultdict(int)\n        # #@lru_cache(maxsize=None)\n        # def dfs(i, n):\n        #     if i in [3,6,9] and cache[i-2, n] != 0: return cache[i-2, n]\n        #     if i in [1,4,7] and cache[i+2, n] != 0: return cache[i+2, n]\n        #     nonlocal d\n        #     if not n: return 1\n        #     s = sum(dfs(val, n-1) for val in d[i])\n        #     cache[i, n] = s\n        #     return s\n        # \n        # return sum(dfs(i, n-1) for i in range(10)) % mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0 for _ in range(10)] for _ in range(n)]\n        for i in range(10):\n            dp[0][i] = 1\n        \n        def check(k):\n            if k == 0:\n                return [4, 6]\n            elif k == 1:\n                return [6,8]\n            elif k == 2:\n                return [7, 9]\n            elif k == 3:\n                return [4, 8]\n            elif k == 4:\n                return [0, 3, 9]\n            elif k == 5:\n                return []\n            elif k == 6:\n                return [0, 1, 7]\n            elif k == 7:\n                return [2, 6]\n            elif k == 8:\n                return [1, 3]\n            else:\n                return [2, 4]\n        for i in range(1, n):\n            for j in range(10):\n                for k in check(j):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod\n                    \n        ans = 0\n        for i in range(10):\n            ans = (ans + dp[n - 1][i])%mod\n        return ans\n        \n", "from collections import Counter\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = {1 : [6, 8],\n                 2 : [7, 9],\n                 3 : [4, 8],\n                 4 : [3, 9, 0],\n                 6 : [1, 7, 0],\n                 7 : [2, 6],\n                 8 : [1, 3],\n                 9 : [2, 4],\n                 0 : [4, 6],\n                }\n        if n == 1:\n            return 10\n        \n        starts = Counter([i for i in moves])\n        for _ in range(n - 1):\n            next = Counter()\n            for i in starts:\n                for j in moves[i]:\n                    next[j] += starts[i]\n            starts = next\n            \n        return sum(starts.values()) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dic = {1: [6, 8], 2: [7, 9], 4: [0, 3, 9], 5: [], 7: [2, 6], 8: [1, 3], 0: [4, 6]}\n        #1 = 3, 4 = 6, 7 = 9\n        pair = {3: 1, 6: 4, 9: 7}\n        \n        @lru_cache(None)\n        def dp(i, n):\n            if n == 1: return 1\n            if i in pair: i = pair[i]\n            res = 0\n            for j in dic[i]:\n                res += dp(j, n - 1)\n            return res\n        \n        return (2 * (dp(1, n) + dp(4, n) + dp(7, n)) + dp(0, n) + dp(2, n) + dp(5, n) + dp(8, n))%(10 **9 + 7)\n", "class Solution:\n    \n    def knightDialer(self, n: int) -> int:\n        \n        valid_moves = {0: (4, 6), \n                       1:(8, 6), \n                       2:(7,9),\n                       3:(4,8),\n                       4:(0, 3, 9),\n                       5:(),\n                       6:(0, 1, 7),\n                       7:(2, 6),\n                       8:(1, 3),\n                       9:(2, 4),\n                      }\n        \n        dp = [[0]*10 for _ in range(n)]\n        for c in range(10):\n            dp[0][c] = 1\n        if n > 1:\n            for c in range(10):            \n                dp[1][c] = len(valid_moves[c])\n            \n        \n        for i in range(2, n):\n            for j in range(10):\n                valid = valid_moves[j]\n                #print (\\\"computing i: {0}, j:{1} with valid:{2}\\\".format(i, j, valid))\n                dp[i][j] = sum([dp[i-1][r] for r in valid])\n        # print (dp)        \n        # print (  sum(dp[n-1]) % (10**9+7))\n        \n        return sum(dp[n-1]) % (10**9+7)\n", "class Solution:\n    legal_moves = {\n            0: [4, 4],\n            1: [6, 8],\n            2: [7, 7],\n            3: [4, 8],\n            4: [0, 1, 7],\n            # 5: [],\n            6: [0, 1, 7],\n            7: [2, 4],\n            8: [1, 1],\n            9: [2, 4]\n        }\n    \n    def knightDialer(self, n: int) -> int:\n        total = 0 if n != 1 else 1\n        memo = {}\n        for i in range(0, 10):\n            if i is not 5:\n                total = total + self.num_jumps(i, n - 1, memo)\n                \n        return total % (pow(10, 9) + 7)\n            \n    def num_jumps(self, start, jumps_left, memo):\n        \n        # If we have no moves left we have completed a number\n        if jumps_left == 0:\n            return 1\n        \n        # Check if we have done this calculation before\n        if (start, jumps_left) not in memo:\n            \n            # Calculate total number of numbers from this starting position\n            total = 0\n            for legal_move in self.legal_moves[start]:\n                total = total + self.num_jumps(legal_move, jumps_left - 1, memo)\n        \n            # Save result\n            memo[(start, jumps_left)] = total\n        \n        # Return calculated or retreived result\n        return memo[(start, jumps_left)]", "from functools import lru_cache\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        \n        '''\n        build the neighbors dictionary\n        \n        neighbors to a key are the keys reachable to itself from a key\n        '''\n        neighbors = {0 : (4,6), 1: (6,8), 2: (7,9), 3: (4,8), 4: (3,9,0),\n                     5 : (), 6: (1,7,0), 7: (2,6), 8: (1,3), 9: (2,4)}\n        \n        @lru_cache(maxsize=None)\n        def num_ways(key, n):\n            if n == 0:\n                return 0\n            if n == 1:\n                return len(neighbors[key])\n            \n            w = 0\n            for neighbor in neighbors[key]:\n                w += num_ways(neighbor, n-1)\n            return w\n        \n        answer = 0\n        for i in range(10):\n            answer += num_ways(i, n-1)\n            #print(num_ways.cache_info())\n        \n        answer %= (pow(10, 9) + 7)\n        return answer\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1:\n            return 10\n        ret=0\n        dp=[[0]*10 for i in range(n)]\n        for i in range(10):\n            dp[0][i]=1\n        graph={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n        \n        for i in range(1,n):\n            for j in range(10):\n                for neighbor in graph[j]:\n                    dp[i][j]+=dp[i-1][neighbor]\n        ret=sum(dp[n-1][i] for i in range(10))\n        return ret%(10**9+7)\n#1 dp\u9700\u8981\u4e8c\u7ef4\u7684\u6765\u8868\u793a\u624d\u884c\uff0c\u4e00\u7ef4\u7684\u8bdd\uff0c\u503c\u5f88\u5bb9\u6613\u88ab\u8986\u76d6\uff0c\u6bd4\u5982dp[1]\u5728\u7b2c\u4e8c\u6b65\u7684\u65f6\u5019\u66f4\u65b0\u4e86\uff0c\u4f46\u662f\u540e\u9762\u53c8\u7528\u5230dp[1]\u7684\u8bdd\uff0c\u5c31\u4f1a\u7528\u8fd9\u4e2a\u66f4\u65b0\u7684\u503c\uff0c\u800c\u4e0d\u662f\u7b2c\u4e00\u6b65\u7684dp\u503c\n#1 \u8fd9\u91cc\u6211\u5f00\u59cb\u5199\u621010^9+7\u4e86\uff0c^\u5728python\u91cc\u662f\u5f02\u6216\u5440\uff0c\u5e42\u8981\u5199\u6210**\n#https://www.jianshu.com/p/5a588aab3ae5\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        knight_graph = {\n            1:(8,6),\n            2:(7,9),\n            3:(8,4),\n            4:(3,9,0),\n            5:(),\n            6:(7,1,0),\n            7:(2,6),\n            8:(1,3),\n            9:(4,2),\n            0:(4,6)\n        }\n        memo = {}\n        MOD = pow(10,9)+7\n        def btHelper(coordinate, n):\n            if n == 0:\n                return 1\n            possibility = 0\n            for avail_node in knight_graph[coordinate]:\n                if (avail_node,n-1) in memo:\n                    possibility += memo[(avail_node, n-1)]\n                else:\n                    possibility += btHelper(avail_node,n-1)\n            memo[(coordinate, n)] = possibility % MOD\n            return possibility\n        ans = 0  \n        for i in range(10):\n            ans += btHelper(i,n-1)\n        #print(memo)\n        return ans%MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        x0,x1,x2,x3,x4,x5,x6,x7,x8,x9 = 1,1,1,1,1,0,1,1,1,1\n        for i in range(1, n):\n            x0,x1,x2,x3,x4,x6,x7,x8,x9 = x4+x6,x6+x8,x7+x9,x4+x8,x0+x3+x9,x0+x1+x7,x2+x6,x1+x3,x2+x4\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0)%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        cell2jump = dict()\n        cell2jump[1] = [6, 8]\n        cell2jump[2] = [7, 9]\n        cell2jump[3] = [4, 8]\n        cell2jump[4] = [3, 9, 0]\n        cell2jump[5] = []\n        cell2jump[6] = [1, 7, 0]\n        cell2jump[7] = [2, 6]\n        cell2jump[8] = [1, 3]\n        cell2jump[9] = [2, 4]\n        cell2jump[0] = [4, 6]\n        \n#         # dp[n, i] = helper(n, i)\n#         dp = defaultdict()\n        \n#         def helper(num_jumps, cell):\n#             # return number of jumps if place at cell and have num_jumps remaining\n#             if num_jumps == 1:\n#                 return 1\n#             elif num_jumps == 2:\n#                 return len(cell2jump[cell])\n    \n#             if (num_jumps, cell) in dp:\n#                 return dp[num_jumps, cell]\n            \n#             res = 0\n#             for nei in cell2jump[cell]:\n#                 res += helper(num_jumps-1, nei)\n            \n#             dp[num_jumps, cell] = res\n#             return res\n        \n#         total = []\n#         for i in range(10):\n#             total.append(helper(n, i))\n        \n\n        dp = [1]*10\n        for _ in range(n-1):\n            new_dp = [0]*10\n            for i in range(10):\n                new_dp[i] = sum(dp[nxt] for nxt in cell2jump[i])\n    \n            dp = new_dp\n\n        return sum(dp) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [1,7,0], [2,6], [1,3], [2,4]]\n        \n        dp = [1] * 10\n        for _ in range(n-1):\n            dp2 = [0] * 10\n            for i in range(10):\n                dp2[i] = sum(dp[j] for j in moves[i]) % (10**9+7)\n                \n            dp = dp2\n            \n        return sum(dp) % (10**9 + 7)\n    \n    # def knightDialer(self, N: int) -> int:\n    #     pad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\n    #     for _ in range(N-1):\n    #         next_cnt = [1]*10\n    #         for i in range(10):\n    #             next_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\n    #         cnt = next_cnt\n    #     return sum(cnt) % (10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        kd_key = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]]\n        # kd_key[start] = [ends]\n        memo = dict()\n        \n        out = 0\n        # all starting pos\n        for i in range(10):\n            out += self.dial(i, n, kd_key, memo)\n        \n        # print(int(1e9+7))\n        return out % int(1e9 +7)\n    \n    def dial(self, pos, n, kd_key, memo):\n        if n == 1:\n            return 1\n        \n        out = 0\n        for next_pos in kd_key[pos]:\n            if (next_pos, n-1) in memo:\n                out += memo[(next_pos, n-1)]\n            else:\n                out += self.dial(next_pos, n-1, kd_key, memo)\n        \n        memo[(pos, n)] = out\n        return out", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jump = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [6,2],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6]\n        }\n        memo = {}\n        \n        def helper(cur, k):\n            if (cur,k) in memo:\n                return memo[(cur,k)]\n            if k == 0:\n                return 0\n            elif k == 1:\n                return 1\n            res = 0\n            for item in jump[cur]:\n                res += helper(item, k-1)\n            memo[(cur,k)] = res % (10**9+7)\n            return res\n            \n        res = 0\n        for i in range(10):\n            res += helper(i, n)\n        return res % (10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1: return 10\n        p=math.pow(10,9)+7\n        c={}\n        c[1]=[6,8]\n        c[2]=[7,9]\n        c[3]=[4,8]\n        c[4]=[3,9,0]\n        c[5]=[]\n        c[6]=[1,7,0]\n        c[7]=[2,6]\n        c[8]=[1,3]\n        c[9]=[2,4]\n        c[0]=[4,6]\n        dp=[[None for _ in range(n+1)]for _ in range(10)]\n        for i in range(10):\n            dp[i][1]=1\n            dp[i][2]=len(c[i])\n        def find(i,x):\n            if dp[i][x]is not None:\n                return dp[i][x]\n            dp[i][x]=0\n            for j in c[i]:\n                dp[i][x]+=find(j,x-1)%p\n            return dp[i][x]\n        res=0\n        for i in range(10):\n            res+=find(i,n)%p\n        return int(res%p)\n            \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        numpad = [[1,2,3],[4,5,6],[7,8,9],['*',0,'#']]\n        dp = [1]*10\n        square = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[7,0,1],[2,6],[1,3],[2,4]]\n        mod = 10**9+7\n        for i in range(2,N+1):\n            temp=[0]*10\n            for num in range(10):\n                for j in square[num]:\n                    temp[num] += dp[j]%mod\n            dp=temp\n        return sum(dp)%mod\n                                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4],\n            0: [6,4]          \n        }\n        p = 10**9 + 7\n        \n        dp = defaultdict(lambda:1)\n        for t in range(n-1):\n            for i in range(10):\n                dp[i,t&1] = sum(dp[j,(t+1)&1] for j in neighbors[i]) % p\n                \n        return sum(dp[i,n&1] for i in range(10)) % p", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[] for x in range(10)]\n       \n        moves[0] = [4,6]\n        moves[1] = [6,8]\n        moves[2] = [7,9]\n        moves[3] = [4,8]\n        moves[4] = [3,9,0]\n        moves[5] = []\n        moves[6] = [0,1,7]\n        moves[7] = [2,6]\n        moves[8] = [1,3]\n        moves[9] = [2,4]\n        dp = {}\n\n        def dialer(start,n):\n            if (start,n) in dp:\n                return dp[(start,n)]\n            if n==1:\n                dp[(start,n)] = 1\n                return 1\n            xmoves = 0\n            for move in moves[start]:\n                xmoves += dialer(move,n-1)\n            xmoves %= (10**9+7)\n            dp[(start,n)] = xmoves \n            return xmoves\n        xmoves = 0\n        for i in range(10):\n            xmoves += dialer(i,n)\n        return xmoves % (10**9+7)\n                \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0:\n                return 1\n            result = 0\n            for j in jump[i]:\n                result = (result + dp(j, k - 1)) % MOD\n            return result\n        MOD = 10 ** 9 + 7\n        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [0, 1, 7], [2, 6], [1, 3], [2, 4], list(range(10))]\n        return dp(10, n)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        list_old = [1] * 10\n        for t in range(2, n+1):\n            list_new = [0] * 10\n            for i in range(0, 10):\n                temp = Solution().map(i)\n                for j in range(len(temp)):\n                    list_new[i] = list_new[i] + list_old[temp[j]]\n            list_old = list_new[0:10]\n        return sum(list_old) % (10**9 + 7)\n\n    def map(self, d: int) -> List[int]:\n        if d == 0:\n            return [4, 6]\n        elif d == 1:\n            return [6, 8]\n        elif d == 2:\n            return [7, 9]\n        elif d == 3:\n            return [4, 8]\n        elif d == 4:\n            return [0, 3, 9]\n        elif d == 5:\n            return []\n        elif d == 6:\n            return [0, 1, 7]\n        elif d == 7:\n            return [2, 6]\n        elif d == 8:\n            return [1, 3]\n        else:\n            return [2, 4]", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        G = {5:set(), 1:set([6,8]), 3:set([4,8]), 7:set([2,6]),\n            9:set([2,4]), 4:set([3,9,0]),6:set([1,7,0]), 2:set([7,9]), 8:set([1,3]),0:set([4,6])}\n        \n        mem = dict()\n        \n        def dfs(val,rem):\n            if (val, rem) in mem:\n                return mem[(val,rem)]\n            if rem == 1:\n                return 1\n            ans = 0\n            for n in G[val]:\n                ans += dfs(n,rem-1)\n            mem[(val,rem)] = ans\n            return ans%(10**9+7)\n        \n        ans = 0\n        for i in range(10):\n            ans += dfs(i,n)\n        return ans%(10**9+7)", "from collections import defaultdict\nmove_map = {\n    0: {4,6},\n    1: {6,8},\n    2: {7,9},\n    3: {4,8},\n    4: {3, 9, 0},\n    5: {},\n    6: {1, 0, 7},\n    7: {2, 6},\n    8: {1, 3},\n    9: {2, 4}\n}\n\nclass Solution:    \n    def knightDialer(self, n: int) -> int:\n        table = defaultdict(int)\n        for key in move_map:\n            table[key, 1] = 1\n            \n        for N in range(2,n+1):\n            for key in move_map:\n                for new_key in move_map[key]:\n                    table[key, N] += table[new_key, N-1]\n                \n        res = 0\n        for key in move_map:\n            res += table[key, n]\n        return res % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        map = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        memo = [[-1] * n for i in range(len(map))]\n        \n        def recur(num, hops, memo):\n            if hops < 0:\n                return 0\n            elif hops == 0:\n                return 1\n            \n            if memo[num][hops] == -1:\n                s = 0\n                for move in map[num]:\n                    s += recur(move, hops - 1, memo)\n\n                memo[num][hops] = s\n            return memo[num][hops]\n        \n        s = 0\n        for key in range(len(map)):\n            s += recur(key, n - 1, memo)\n        \n        return s % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        knight_graph = {\n            1:(8,6),\n            2:(7,9),\n            3:(8,4),\n            4:(3,9,0),\n            5:(),\n            6:(7,1,0),\n            7:(2,6),\n            8:(1,3),\n            9:(4,2),\n            0:(4,6)\n        }\n        memo = {}\n        MOD = pow(10,9)+7\n        def btHelper(coordinate, n):\n            if (coordinate, n) in memo:\n                return memo[(coordinate, n)]\n            if n == 0:\n                return 1\n            possibility = 0\n            for avail_node in knight_graph[coordinate]:\n                possibility += btHelper(avail_node,n-1)\n            memo[(coordinate, n)] = possibility % MOD\n            return possibility\n        ans = 0  \n        for i in range(10):\n            ans += btHelper(i,n-1)\n        #print(memo)\n        return ans%MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:return 10\n        R = int (math.pow(10,9) + 7)\n        memo = {}\n        \n        options = {\n            1:[6,8],\n            2:[7,9],\n            3:[8,4],\n            4:[3,9,0],\n            6:[1,7,0],\n            7:[2,6],\n            8:[1,3],\n            9:[4,2],\n            0:[4,6]\n        }\n        \n        def dfs(step, dig):\n            if (step, dig) in memo :\n                return memo[(step, dig)]\n            \n            if step==1:\n                return 1\n        \n            res = 0\n            for d in options[dig]:\n                res = (res + dfs(step-1, d)) %R\n            memo[(step,dig)] = res\n            return res\n        \n        res = 0\n        for d in range(0,10,1):\n            if d == 5 : continue\n            res =(res + dfs(n, d))%R\n\n        return res\n    \n            \n        \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        dp = {}\n        MOD = 10**9+7\n        def moveOnce(num0, N0):\n            if (num0, N0) in dp:\n                return dp[(num0, N0)]\n            if N0 == 0:\n                return 1\n            if N0 < 0 :\n                return 0\n            subAns = 0\n            if num0 == 1:\n                subAns = moveOnce(6, N0-1) + moveOnce(8, N0-1)\n            elif num0 == 2:\n                subAns = moveOnce(7, N0-1) + moveOnce(9, N0-1)\n            elif num0 == 3:\n                subAns = moveOnce(4, N0-1) + moveOnce(8, N0-1)\n            elif num0 == 4:\n                subAns = moveOnce(3, N0-1) + moveOnce(9, N0-1) + moveOnce(0, N0-1)\n            elif num0 == 5:\n                subAns = 0#moveOnce(5, N0-2) + moveOnce(7, N0-2) + moveOnce(9, N0-2)\n            elif num0 == 6:\n                subAns = moveOnce(1, N0-1) + moveOnce(7, N0-1) + moveOnce(0, N0-1)\n            elif num0 == 7:\n                subAns = moveOnce(2, N0-1) + moveOnce(6, N0-1) #+ moveOnce(5, N0-2) + moveOnce(7, N0-2)\n            elif num0 == 8:\n                subAns = moveOnce(1, N0-1) + moveOnce(3, N0-1)\n            elif num0 == 9:\n                subAns = moveOnce(2, N0-1) + moveOnce(4, N0-1) #+ moveOnce(5, N0-2) + moveOnce(9, N0-2)\n            elif num0 == 0:\n                subAns = moveOnce(4, N0-1) + moveOnce(6, N0-1)\n            dp[(num0, N0)] = subAns%MOD\n            return subAns\n        return sum([moveOnce(i, N-1) for i in range(10)])%MOD", "class Solution:\n    \n    def knightDialer(self, N: int) -> int:\n            \n        \n        def getNeighbors(N):\n            neighs=[[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n            return neighs[N]\n        \n        mod= 10**9 +7\n        curr= [1]*10\n        for i in range(N-1):\n            nextlist= [0]*10\n            for j in range(10):\n                \n                for neigh in getNeighbors(j):\n                    nextlist[neigh]= (nextlist[neigh]+curr[j])%mod\n                    \n            curr=nextlist\n            \n        return sum(curr)%mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        jumps = {\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (3, 9, 0),\n            5: (),\n            6: (1, 7, 0),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2, 4),\n            0: (4, 6),\n        }\n\n        dp = [1] * 10\n\n        for i in range(2, n + 1):\n            t = list(dp)\n            for i in range(10):\n                dp[i] = sum(t[v] for v in jumps[i]) % MOD\n\n        return sum(dp) % MOD\n\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        last_dp = [1]*10\n        this_dp = [0]*10\n        next_steps = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        for _ in range(2, n+1):\n            for i in range(10):\n                if i != 5:\n                    this_dp[i] = sum(last_dp[next_step] for next_step in next_steps[i]) % int(10**9+7)\n            last_dp = this_dp\n            this_dp = [0]*10\n        return sum(last_dp) % int(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        graph = {1: (6,8),\n                 2: (9,7),\n                 3: (4,8),\n                 4: (9,3,0),\n                 5: (),\n                 6: (7,1,0),\n                 7: (2,6),\n                 8: (1,3),\n                 9: (4,2),\n                 0: (4,6)}\n        count = 0\n        MOD = 10**9 + 7\n        memo = collections.defaultdict(list)\n        def dfs(cur,graph,n,memo):\n            if n == 0:\n                return 1\n            if (n,cur) in memo:\n                return memo[(n,cur)]\n            count = 0\n            for nei in graph[cur]:\n                count += dfs(nei,graph,n-1,memo) % MOD\n            memo[(n,cur)] = count\n            return count\n        for nei in range(10):\n            memo[nei] = []\n            count += dfs(nei,graph,n-1,memo) % MOD\n        return count % MOD", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        memo = {} #(number,steps): totalDistinctValues\n        \n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        \n        \n        for i in range(0, 10):\n            memo[(i,0)] = 0\n            memo[(i,1)] = 1\n        \n        for n in range(2, N+1):\n            for i in range(0, 10):\n                memo[(i,n)] = 0\n                \n                for nextDig in moves[i]:\n                    memo[(i,n)] += memo[(nextDig, n-1)]\n        \n        total = 0\n        \n        for i in range(0, 10):\n            total += memo[(i,N)]\n        \n        return total % (10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        s = 0\n        for k in range(10):\n            d = [0] * 10\n            d[k] = 1\n            for i in range(n - 1):\n                d2 = [\n                    d[4] + d[6],\n                    d[6] + d[8],\n                    d[7] + d[9],\n                    d[4] + d[8],\n                    d[3] + d[9] + d[0],\n                    0,\n                    d[1] + d[7] + d[0],\n                    d[2] + d[6],\n                    d[1] + d[3],\n                    d[2] + d[4],\n                ]\n                d = d2\n            s += sum(d)\n        return s % (10 ** 9 + 7)\n\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\n        for i in range(n - 1):\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\n        return sum(dp) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        nei = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [8, 4],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        def helper(n, curr, seen, nei):\n            if n == 1:\n                return 1\n            if curr not in nei:\n                return 0\n            key = (n, curr)\n            if key in seen:\n                return seen[key]\n            answer = 0\n            for ne in nei[curr]:\n                answer = (answer + helper(n - 1, ne, seen, nei)) % (10 ** 9 + 7)\n            seen[key] = answer\n            return answer\n        total = 0\n        seen = {}\n        for i in range(10):\n            total = (total + helper(n, i, seen, nei)) % (10 ** 9 + 7)\n        return total\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        mapping = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        \n        if N == 1: return 10\n        dp = collections.defaultdict(int)\n        for idx in range(10):\n            if idx == 5: continue\n            dp[idx] = 1\n        while N > 1:\n            next_dp = collections.defaultdict(int)\n            for idx in range(10):\n                if idx == 5: continue\n                for k in mapping[idx]:\n                    next_dp[k] += dp[idx]\n            N -= 1\n            dp = next_dp\n        return sum(dp.values()) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n        validNumbers = {(1,i):1 for i in range(10)}##because it will always be 1 thing possible regardless of start digit. If we had used base case of 0, we would've gotten that we would double count. So sometimes it is better to do the simplest nontrivial basecase rather than try to work with 0.\n        BIG_MOD = 10**9+7\n        def computePhoneNumbers(length,startDigit):##we can assume length is always >= 1\n            if (length,startDigit) in validNumbers:\n                return validNumbers[(length,startDigit)]\n            else:\n                totalValid = 0\n                for neighbor in neighbors[startDigit]:\n                    totalValid += computePhoneNumbers(length-1,neighbor)\n                    totalValid %= (BIG_MOD)\n                validNumbers[(length,startDigit)] = totalValid\n                return totalValid\n        allValid = 0\n        for i in range(10):\n            allValid += computePhoneNumbers(n,i)\n            allValid %= (BIG_MOD)\n        return allValid\n", "from collections import defaultdict\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        self.buildPad()\n        self.buildMoves()\n        \n        self.memo = [[-1 for _ in range(n)] for _ in range(10)]\n        \n        numbers = sum(self.visit(start, n-1) for start in range(10))\n                      \n        return numbers % (10**9 + 7)\n        \n    def visit(self, start: int, n: int) -> int:\n        if n == 0:\n            return 1\n        elif self.memo[start][n] != -1:\n            return self.memo[start][n]\n        \n        numbers = 0\n        for new_start in self.moves[start]:\n            numbers += self.visit(new_start, n-1)\n        \n        self.memo[start][n] = numbers\n        return numbers\n    \n    def buildPad(self) -> None:\n        self.pad = [[str(i + j) for j in range(3)] for i in range(1, 10, 3)]\n        self.pad.append(['*', '0', '#'])\n    \n    def buildMoves(self) -> None:\n        self.moves = (\n            (4, 6),\n            (6, 8),\n            (7, 9),\n            (4, 8),\n            (0, 3, 9),\n            (),\n            (0, 1, 7),\n            (2, 6),\n            (1, 3),\n            (2, 4)\n        )\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        if N == 1: return 10\n        mapper = {1:[8,6],\n                 2:[7,9],\n                 3:[8,4],\n                 4:[0,9,3],\n                 6:[0,1,7],\n                 7:[2,6],\n                 8:[1,3],\n                 9:[2,4],\n                 0:[4,6]}\n        \n        dp =[ [0]*10 for _ in range(N)]\n        MM = 10**9+7\n        for i in range(10):\n            if i==5: continue\n            dp[0][i] = 1\n            \n        def searching(s, i):\n            \n            if dp[s][i]>0:\n                return dp[s][i]\n            \n            for k in mapper[i]:\n                dp[s][i] += searching(s-1,k)\n                dp[s][i] = dp[s][i] % MM\n            return dp[s][i]\n        for i in range(10):\n            if i==5: continue\n            searching(N-1,i)\n        \n        return sum(dp[N-1])% MM", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        possibleMoves = {0:[4,6], 1:[6,8],2:[9,7],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3], 9:[2,4]}\n        upper = 10**9 + 7\n        cache = {}\n        def dfs(steps,loc):\n            if (steps,loc) in cache: return cache[(steps,loc)]\n            if steps == 0: \n                return 1\n            ans = 0\n            for stop in possibleMoves[loc]:\n                ans = (ans + dfs(steps-1,stop))%upper\n            cache[(steps,loc)] = ans\n            return ans\n        return sum(dfs(n-1,loc) for loc in possibleMoves)%upper", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        if n == 1:\n            return 10\n        moves = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        \n        memo = dict()\n        \n        def count_moves(position, digits):\n            if digits == 1:\n                return 1\n            if (position, digits) in memo:\n                return memo[position, digits]\n            curr = 0\n            for m in moves[position]:\n                curr += count_moves(m, digits - 1)\n            memo[position, digits] = curr % MOD\n            return memo[position, digits]\n        \n        res = 0\n        \n        for pos in moves.keys():\n            res += count_moves(pos, n)\n            res %= MOD\n            \n        return res", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        MOD = 10**9 + 7\n        reach = {\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[3,9,0],\n            5:[],\n            6:[1,7,0],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4],\n        }\n        \n        memo = {}\n        \n        def helper(num, steps):\n            if (num, steps) in memo:\n                return memo.get((num, steps))\n            if steps == 0:\n                memo[((num, steps))] = 1\n                return memo.get((num, steps))\n            res = 0\n            for next_no in reach[num]:\n                res += helper(next_no, steps-1)\n                \n            res = res % MOD \n            memo[((num, steps))] = res\n            return res\n        \n        result = 0\n        for pos in range(0,10):\n            result += helper(pos, N-1)\n        \n        return result % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        paths = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2,6], 8: [1,3], 9: [2, 4], 0: [4,6]}\n        counts = 0\n        lookup = {}\n        for i in range(10):\n            counts += self.traverse(i,paths, lookup,n,0)\n        return counts % ( 10**9 + 7 )\n        \n    def traverse(self, starting, paths, lookup, n, level):\n        if level == n-1:\n            return 1\n        counts = 0 \n        for path in paths[starting]:\n            if (path, level +1) not in lookup:\n                lookup[(path, level +1)] = (self.traverse(path, paths, lookup, n, level +1))\n            counts += lookup[(path, level +1)]\n        \n        return counts % ( 10**9 + 7 )", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        adj_graph = {\n            \n            1: [8,6],\n            2: [7,9],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [2,6],\n            8: [1,3],\n            9: [4,2],\n            0: [4,6]\n                \n        }\n        \n        def moveHelper(num,n,memo):\n            \n            if n == 1:\n                \n                return 1\n            \n            sumCounts = 0\n            \n            for number in adj_graph[num]:\n                \n                if (number,n-1) in memo:\n\n                    sumCounts += memo[(number,n-1)]\n                    \n                else:\n                \n                    res = moveHelper(number,n-1,memo)\n                    sumCounts += res\n                    memo[(number,n-1)] = res\n                \n            return sumCounts\n        \n        \n        sumCount = 0\n        memo = {}\n        \n        for k in list(adj_graph.keys()):\n            \n            sumCount += moveHelper(k,n,memo)\n            \n            \n        return sumCount%(pow(10,9)+7)\n", "import numpy as np\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1: return 10\n        def fast_power(a,m):\n\n            res=np.identity(10,int)\n            for bit_idx,bit in enumerate(reversed(bin(m)[2:])):\n                if bit_idx==0:\n                    cur=a\n                else:\n                    cur=np.mod(np.dot(cur,cur),10**9+7)\n                if bit == '1':\n                    res=np.mod(np.dot(res,cur),10**9+7)\n            return res\n\n        gh = {}\n        gh[0] = [4, 6]\n        gh[1] = [6, 8]\n        gh[2] = [7, 9]\n        gh[3] = [4, 8]\n        gh[4] = [0,3, 9]\n        gh[5] = []\n        gh[6] = [0, 1, 7]\n        gh[7] = [2, 6]\n        gh[8] = [1, 3]\n        gh[9] = [2, 4]\n        t = []\n        for u in gh:\n            \n            if u != 5:\n                row = 0\n                for v in gh[u]:\n                    row = row^(1 << v)\n                row = list(bin(row)[2:])\n                row.reverse()\n                \n                row = list([int(x) for x in row])\n                row.extend([0] * (10 - len(row)))\n                t.append(row)\n            else:\n                t.append([0] * 10)\n        t = np.array(t,dtype=int)\n        \n        ans = sum(np.mod(np.dot(fast_power(t, n - 1), np.ones(10,dtype=int)),10**9+7)) % (10**9+7)\n        return ans\n\n\n\n\n\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # mod = int(1e9)+7\n        # d = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7:[2,6], 8: [1,3], 9:[2, 4], 0: [4,6]}\n        # cache = collections.defaultdict(int)\n        # #@lru_cache(maxsize=None)\n        # def dfs(i, n):\n        #     #nonlocal d, cache\n        #     if not n: return 1\n        #     if (i, n) not in cache:\n        #         s = sum(dfs(val, n-1) for val in d[i])\n        #         cache[i, n] = s\n        #         if i in [3,6,9]: cache[i-2, n] = s\n        #         elif i in [1,4,7]: cache[i+2, n] = s\n        #     return cache[i, n]\n        # \n        # return sum(dfs(i, n-1) for i in range(10)) % mod\n\n        self.moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n        return sum(self.knightDialer_(n, i) for i in range(10)) % (10**9 + 7)\n\n    def knightDialer_(self, N, i, dp={}):\n        if N == 1: return 1\n        if (N,i) not in dp:\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\n        return dp[(N,i)]\n    \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n#         MOD = 10**9 + 7\n#         moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n#                      [1,7,0],[2,6],[1,3],[2,4]]\n\n#         dp = [1] * 10\n#         for hops in range(n-1):\n#             dp2 = [0] * 10\n#             for node, count in enumerate(dp):\n#                 for nei in moves[node]:\n#                     dp2[nei] += count\n#                     dp2[nei] %= MOD\n#             dp = dp2\n#         return sum(dp) % MOD\n        modulo = pow(10,9)  + 7\n        get_position= [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]   \n        cache = {}\n        def solve(pos, step):\n            key = (pos, step)\n            if key not in cache:\n                if step>=n:\n                    return 1\n                res = 0\n                for i in get_position[pos]:\n                    res += solve(i, step + 1)\n                    res = res % modulo\n                cache[key] = res\n            return cache[key]\n        res = 0\n        \n        for i in range(10):\n            res += solve(i, 1)\n        return res % modulo", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9 + 7\n        reachFrom = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [],\n                     6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        dp = [[1] * 10 for _ in range(2)]\n        for i in range(1, n):\n            for j in range(10):\n                dp[i % 2][j] = 0\n                for src in reachFrom[j]:\n                    dp[i % 2][j] += dp[(i - 1) % 2][src]\n        return sum(dp[(n - 1) % 2]) % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        valid = {\n            1: [8, 6],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [4, 2],\n            0: [4, 6]\n        }\n        \n        MOD = 10 ** 9 + 7\n        dp = {}\n        nums = 0\n        \n        def dfs(pos, steps):\n            if steps == 0:\n                return 1\n            if (pos, steps,) in dp:\n                return dp[(pos, steps,)]\n            c = 0\n            for next in valid[pos]:\n                c += dfs(next, steps - 1)\n                c %= MOD\n            dp[(pos, steps,)] = c\n            return c\n        \n        ans = 0\n        for i in range(10):\n            x = dfs(i, n - 1)\n            ans += x\n            ans %= MOD\n        return ans % MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        self.knight_movable_map = {\n            0:[4,6],\n            1:[6, 8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5: [],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        self.dp = [[None for _ in range(10)] for _ in range(n)]\n        \n        def traverse(dial, remaining):\n            if remaining == 0:\n                return 1\n            if self.dp[remaining][dial] is not None:\n                \n                return self.dp[remaining][dial]\n            \n            cnt = 0\n            for next_dial in self.knight_movable_map[dial]:\n                cnt += traverse(next_dial, remaining-1)\n            \n            self.dp[remaining][dial] = cnt\n            return cnt\n            \n            \n        cnt = 0\n        for i in range(10):\n            cnt += traverse(i, n -1)\n        \n        modulo_num = 10**9 + 7\n        \n        return cnt % modulo_num\n", "# DFS solution\n# O(n) time and space\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        steps = {\n           0:[4, 6],\n           1:[6, 8], \n           2:[7, 9], \n           3:[4, 8], \n           4:[0, 3, 9], \n           5:[], \n           6:[0, 1, 7], \n           7:[2, 6], \n           8:[1, 3], \n           9:[2, 4]\n        }\n        \n        \n        def dfs(start, remain, seen):\n            if remain == 0:\n                return 1\n            if (start, remain) in seen:\n                return seen[(start, remain)]\n            \n            ans = 0\n            for s in steps[start]:\n                ans += dfs(s, remain-1, seen)\n            seen[(start, remain)] = ans\n            return ans\n                \n        ans = 0\n        seen = {}\n        \n        for i in range(10):\n            ans += dfs(i, N-1, seen)\n        return ans %(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (3, 9, 0),\n            5: [],  # 5 has no neighbors\n            6: (1, 7, 0),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2, 4),\n            0: (4, 6),\n        }\n        memo = {}\n        def dp_memo(S, N):\n            if (S, N) in memo:\n                return memo[(S, N)]\n            elif N == 0:\n                return 1\n            else:\n                moves = 0\n                for neigh in neighbors[S]:\n                    moves += dp_memo(neigh, N - 1)\n                memo[(S, N)] = moves\n                return moves\n        result = 0\n        for i in range(0, 10):\n            result += dp_memo(i, n - 1)\n        return result % ((10 ** 9) + 7)\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        mem = {}\n        MOD = 10**9 + 7\n        def get(start, k):\n            if k == 1:\n                return 1\n            if (start, k) in mem:\n                return mem[start, k]\n            total = 0\n            for nxt in moves[start]:\n                total += get(nxt, k-1)\n                total = total % MOD\n            \n            mem[start,k] = total\n            return total\n        \n        ret = 0\n        for x in range(10):\n            ret += get(x, n)\n            ret = ret%MOD\n        return ret", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mapping = {\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5:[],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        memo = {}\n        def helper(num, total):\n            if (num, total) in memo:\n                return memo[(num, total)]\n            if total == 0:\n                return 1\n            count = 0\n            for next_num in mapping[num]:\n                count += helper(next_num, total-1)\n            memo[(num, total)] = count\n            return count\n        count = 0\n        for i in range(10):\n            count += helper(i,n-1)\n        return count % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        '''\n        mod = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1]*10\n        for _ in range(n-1):\n            dp2 = [0]*10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] = (dp2[nei] + count) % mod\n            dp = dp2\n        return sum(dp)%mod\n        '''\n\n        mod = 10**9+7\n        x0 = x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = 1\n        for k in range(1, n):\n            x0, x1, x2, x3, x4, x5, x6, x7, x8, x9 = x4+x6, x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x2+x4\n        return (x0+x1+x2+x3+x4+x5+x6+x7+x8+x9)%mod", "class Solution:\n    def __init__(self):\n        self.moves = [\n            [4,6],\n            [6,8],\n            [7,9],\n            [4,8],\n            [3,9,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [4,2]\n        ]\n        \n        self.memoized_moves = {}\n    \n    def knightDialer(self, n: int) -> int:\n        moves = 0\n        for i in range(10):\n            moves += self.getNumberFromNMoves(n-1, i)\n        \n        return moves%(pow(10,9) + 7)\n        \n    \n    def getNumberFromNMoves(self, remaining_moves, current_number):\n        if remaining_moves == 0:\n            return 1\n        \n        moves = 0\n        for move in self.moves[current_number]:\n            if (move, remaining_moves) not in self.memoized_moves:\n                self.memoized_moves[(move, remaining_moves)] = self.getNumberFromNMoves(remaining_moves-1, move)\n            moves += self.memoized_moves[(move, remaining_moves)]\n            \n        return moves\n        \n    \n    def getMoves(self, number):\n        return self.moves[number]\n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # mp = {0: [4,6], 1: [6, 8], 2: [9,7], 3: [8,4], 4:[9, 0, 3], 5:[], 6: [1, 7, 0], 7: [6, 2], 8:[3,1], 9: [2,4]}\n        c = 0\n        mp = [[4,6], [6,8], [9,7], [8,4], [0,9,3], [],[1,7,0],[6,2],[3,1], [2,4]]\n        memo = {}\n        for i in range(0, 10):\n            c += self.gen(i, n, mp, memo)\n        mpow = (10**9) + 7\n        return c % mpow\n    \n    def gen(self, start, n, mp, memo):\n        if n == 1:\n            return 1\n        key = (start, n)\n        if key in memo:\n            return memo[key]\n        c = 0\n        for opt in mp[start]:\n            c += self.gen(opt, n-1, mp, memo)\n        memo[key] = c\n        return c\n        \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mp = {0: [4,6],\n              1: [6, 8],\n              2: [9,7],\n              3: [8,4],\n              4:[9, 0, 3],\n              5:[],\n              6: [1, 7, 0],\n              7: [6, 2],\n              8:[3,1],\n              9: [2,4]\n             }\n        c = 0\n        memo = {}\n        for i in range(0, 10):\n            c += self.gen(i, n, mp, memo)\n        mpow = (10**9) + 7\n        return c % mpow\n    \n    def gen(self, start, n, mp, memo):\n        if n == 1:\n            return 1\n        key = (start, n)\n        if key in memo:\n            return memo[key]\n        c = 0\n        for opt in mp[start]:\n            c += self.gen(opt, n-1, mp, memo)\n        memo[key] = c\n        return c\n        \n            \n", "class Solution:\n    \n    def distinctNumbers(self, start, moves, validMoves, cache):\n        if moves == 1:\n            return 1\n        \n        if (start, moves) in cache:\n            return cache[(start,moves)]\n        \n        result = 0\n        for i in validMoves[start]:\n            result += self.distinctNumbers(i, moves-1, validMoves, cache)\n        cache[(start, moves)] = result\n        \n        return result\n        \n    def knightDialer(self, n: int) -> int:\n        \n        '''\n        define numpad\n        define validmove (within array and not 'X')\n        use dynamic programming, grid of numbers and length n\n        '''\n        \n        validMoves = dict()\n        validMoves[1] = [6,8]\n        validMoves[2] = [7,9]\n        validMoves[3] = [4,8]\n        validMoves[4] = [3,9,0]\n        validMoves[5] = []\n        validMoves[6] = [1,7,0]\n        validMoves[7] = [2,6]\n        validMoves[8] = [1,3]\n        validMoves[9] = [2,4]\n        validMoves[0] = [4,6]\n        \n        cache = {}\n        \n        \n        result = 0\n        for i in range(10):\n            result += self.distinctNumbers(i, n, validMoves, cache)\n            \n        return result % (10 ** 9 + 7)\n        \n    \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        path={\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5:[],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        M=10**9+7\n        dp={}\n        def paths(i,n):\n            if (i,n) in dp:\n                return dp[(i,n)]\n            #number of ways to jump from i n times          \n            if n==1:\n                return len(path[i])\n            if n==0:\n                return 1\n            s=0\n            for v in path[i]:\n                s+=paths(v,n-1)\n            dp[(i,n)]=s%M\n            return dp[(i,n)]\n        ans=0\n        for k in path:\n            ans+=paths(k,n-1)\n        return ans%(M)\n                \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        self.res = 0\n        mapping = {1:[6,8],2:[9,7],3:[8,4],4:[3,9,0],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6],5:[]}\n        memo = {}\n        \n        def helper(n,rem):\n            if (n,rem) in memo:\n                return memo[(n,rem)]\n            if rem == 0:\n                return 1\n            res = 0\n            for nei in mapping[n]:\n                res += helper(nei,rem-1)\n            memo[(n,rem)] = res\n            return res\n        res = 0\n        for i in range(10):\n            res += helper(i,n-1)\n        return res % (10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        def helper(pos, hops_left):\n            if hops_left == 1: return 1\n            if (pos, hops_left) in cache:\n                return cache[(pos, hops_left)]\n            else:\n                sequences = 0\n                for ne in neighbors[pos]:\n                    sequences += helper(ne, hops_left-1)\n                cache[(pos, hops_left)] = sequences\n                # print(f\\\"seq {sequences} for (pos {pos}, hops_left {hops_left})\\\")\n                return sequences\n        cache = {}\n        counts = [0]*10\n        for start in range(10):\n            counts[start] = helper(start, n)\n            # print(f\\\"counts[{start}] = {counts[start]}\\\")\n        return sum(counts)%(10**9+7)", "class Solution:\n    moves = {0: [4, 6], 1: [6, 8], 2: [7, 9],\n            3: [4, 8], 4: [0,3,9], 5:[], 6:[0, 1, 7], \n             7: [2, 6], 8: [1, 3], 9: [2, 4]}\n    \n    def dialed_Numbers(self, number, moves_left, memoization):\n        if (number, moves_left) in memoization:\n            return memoization[(number, moves_left)]\n        \n        if moves_left == 0:\n            return 1\n        \n        fin_sum = 0\n        for next_move in self.moves[number]:\n            fin_sum += self.dialed_Numbers(next_move, moves_left - 1, memoization)\n            \n        memoization[(number, moves_left)] = fin_sum\n        return fin_sum\n    \n    def knightDialer(self, n: int) -> int:\n        memoization = {}\n        fin_sum = 0\n        for i in range(0, 10):\n            fin_sum += (self.dialed_Numbers(i, n-1, memoization))\n        \n        return fin_sum % (10**9 + 7)", "class Solution:\n    \n    def recur_helper(self, num, n, cnt, memo, next_moves):\n        \n        if n == 0:\n            return cnt\n        \n        key = (num, n)\n        if key in memo:\n            return memo[key]\n        \n        cnt = 0\n        for next_num in next_moves[num]:\n            cnt += self.recur_helper(next_num, n-1, 1, memo, next_moves)\n        \n        memo[key] = cnt\n        \n        return memo[key]\n    \n    def knightDialer(self, n: int) -> int:\n        next_moves = {\n            0: [4, 6],\n            1: [8, 6],\n            2: [7, 9],\n            3: [4, 8],\n            4: [9, 3, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        memo = dict()\n        cnt = 0\n        for num in range(10):\n            cnt += self.recur_helper(num, n-1, 1, memo, next_moves)\n        \n        return cnt % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6], [6,8], [7,9], [4,8], [0,3,9], [], [1,7,0], [2,6], [1,3], [2,4]]\n        \n        dp = [1] * 10\n        for _ in range(n-1):\n            dp2 = [0] * 10\n            for i in range(10):\n                dp2[i] = sum(dp[j] for j in moves[i]) % (10**9+7)\n                \n            dp = dp2\n            \n        return sum(dp) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        results = 0\n        self.cache = {}\n        for pos in range(10):\n            results += self.traverse(pos, n)\n            results %= 1000000007\n        return results\n        \n        \n    def traverse(self, pos: int, length: int) -> int:\n        if length == 1:\n            return 1\n        if (pos, length) in self.cache:\n            return self.cache[(pos, length)]\n        jumps = 0\n        for neighbor in self.get_neighbors(pos):\n            jumps += self.traverse(neighbor, length - 1)\n            \n        jumps %= 1000000007\n        self.cache[(pos, length)] = jumps\n        return jumps\n        \n    def get_neighbors(self, n: int) -> Tuple[int]:\n        NEIGHBORS = (\n            (4, 6),\n            (6, 8),\n            (7, 9),\n            (4, 8),\n            (0, 3, 9),\n            (),\n            (0, 1, 7),\n            (2, 6),\n            (1, 3),\n            (2, 4)\n        )\n        return NEIGHBORS[n]", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        self.edges = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [9, 3, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        \n        self.MAX = (10 ** 9) + 7\n        \n        # at *this* cell, with *this* many steps left, what's the count?\n        self.ledger = [[None]*n for _ in range(10)]\n        \n        dialable = 0\n        for cell in range(10):\n            dialable += self.knight_dialer(n - 1, cell)\n\n        return dialable % self.MAX\n        \n        \n\n    def knight_dialer(self, steps_left: int, position: int) -> None:\n        if not steps_left:\n            return 1\n\n        if self.ledger[position][steps_left]:\n            return self.ledger[position][steps_left]\n        \n        dialable = 0\n        for nbr in self.edges[position]:\n            dialable += self.knight_dialer(steps_left - 1, nbr) % self.MAX\n        \n        self.ledger[position][steps_left] = dialable\n        \n        \n        return dialable % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        def helper(pos, hops_left):\n            if hops_left == 1: return 1\n            if (pos, hops_left) in cache:\n                return cache[(pos, hops_left)]\n            else:\n                sequences = 0\n                for ne in neighbors[pos]:\n                    sequences += helper(ne, hops_left-1)\n                cache[(pos, hops_left)] = sequences\n                # print(f\\\"seq {sequences} for (pos {pos}, hops_left {hops_left})\\\")\n                return sequences\n        cache = {}\n        counts = 0\n        for start in range(10):\n            counts += helper(start, n)\n        return counts%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        graph = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[3, 9, 0], 5:[], 6:[1, 7, 0], 7:[6, 2], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\n        \n        @lru_cache(None)\n        def dfs(node, n=n):\n            if n == 1:\n                return 1\n            else:\n                moves = 0\n                for neigb in graph[node]:\n                    # if neigb in (3, 6, 9):\n                    #     neigb -= 2\n                    moves += dfs(neigb, n-1)\n                return moves\n                \n        ans = 0\n        for node in range(10):\n            ans += dfs(node)\n        \n        return ans % (10 **9 + 7)", "#bfs solution\n\n#graph problem\n\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        neighbours = {\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (3, 9, 0),\n            5: tuple(),  # 5 has no neighbors\n            6: (1, 7, 0),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2, 4),\n            0: (4, 6),\n        }\n        \n        memo={}\n        def helper(position, num_hops):\n            if (position, num_hops) in memo:\n                return memo[(position, num_hops)]\n            \n            if num_hops == 0: return 1\n            \n            num_sequences = 0\n            for neighbour in neighbours[position]:\n                num_sequences += helper(neighbour, num_hops - 1)\n                \n            memo[(position, num_hops)] = num_sequences\n            \n            return num_sequences\n        \n        total = 0\n        for pos in neighbours:\n            total += helper(pos, n-1)\n        \n        return total%(10**9+7)\n", "class Solution:\n    NEIGHBORS = (\n            (4, 6),\n            (6, 8),\n            (7, 9),\n            (4, 8),\n            (0, 3, 9),\n            (),\n            (0, 1, 7),\n            (2, 6),\n            (1, 3),\n            (2, 4)\n    )\n    \n    def knightDialer(self, n: int) -> int:\n        results = 0\n        self.cache = {}\n        for pos in range(10):\n            results += self.traverse(pos, n)\n            results %= 1000000007\n        return results\n        \n        \n    def traverse(self, pos: int, length: int) -> int:\n        if length == 1:\n            return 1\n        if (pos, length) in self.cache:\n            return self.cache[(pos, length)]\n        jumps = 0\n        for neighbor in self.get_neighbors(pos):\n            jumps += self.traverse(neighbor, length - 1)\n            \n        jumps %= 1000000007\n        self.cache[(pos, length)] = jumps\n        return jumps\n        \n    def get_neighbors(self, n: int) -> Tuple[int]:\n        return self.NEIGHBORS[n]", "class Solution:\n    d = [[4,6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2,6], [1,3], [2, 4]]\n    #d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n    def dfs(self, i, n, cache={}):\n        if n == 1: return 1\n        if (i, n) not in cache:\n            cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])\n        return cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        mod = int(1e9)+7\n        return sum(self.dfs(i, n) for i in range(10)) % mod\n\n# class Solution(object):\n#     moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n#     def knightDialer(self, N):\n#         return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\n#     def knightDialer_(self, N, i, dp={}):\n#         if N == 1: return 1\n#         if (N,i) not in dp:\n#             dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\n#         return dp[(N,i)]\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [[-1 for i in range(n+1)] for i in range(10)]\n        d={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\n        out = 0\n        for i in range(0,10):\n            out+=self.helper(n-1,i,d,dp)\n        return out%1000000007\n    \n    def helper(self,n,index,d,dp):\n        if(n==0):\n            return 1\n        \n        if(dp[index][n]!=-1):\n            return dp[index][n]\n        \n        ans = 0\n        for i in range(len(d[index])):\n            ans+=self.helper(n-1,d[index][i],d,dp)\n        dp[index][n] = ans\n        return ans", "class Solution:\n    mod = 10**9 + 7\n    \n    def knightDialer(self, N: int) -> int:\n        nMap = {\n            0: (6, 4),\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (3, 9, 0),\n            5: (),\n            6: (1, 7, 0),\n            7: (2, 6),\n            8: (1, 3),\n            9: (4, 2)\n        }\n\n        m = {} # (position, num)\n        \n        def count(start, n):\n            \n            if (start, n) in m:\n                return m[(start, n)]\n            \n            if n == 0:\n                return 1\n\n            else:\n                \n                num = 0\n                \n                for i in nMap[start]:\n                    num += count(i, n - 1) \n                    \n                m[(start, n)] = num\n                \n                return num\n        \n        ret = 0\n        for i in range(10):\n            ret = (ret + count(i, N - 1)) % self.mod\n\n        return int(ret)\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n             [1,7,0],[2,6],[1,3],[2,4]]\n        \n        cache = {}\n        def backtrack(pos, hops):\n            if (pos, hops) in cache:\n                return cache[(pos, hops)]\n            if hops == 0:\n                return 1\n            count = 0\n            for nbr in moves[pos]:\n                count += backtrack(nbr, hops-1)\n            cache[(pos, hops)] = count\n            return count\n            \n        counts = 0\n        for pos in range(10):\n            counts += backtrack(pos, n-1)\n            \n        return counts%(10**9+7)\n        \n#         cur_hops = 1\n#         prev_counts = [1]*10\n#         cur_counts = [0]*10\n        \n#         while cur_hops < n:\n#             cur_hops += 1\n#             cur_counts = [0]*10\n\n#             for pos in range(10):\n#                 for nbr in moves[pos]:\n#                     cur_counts[pos] += prev_counts[nbr]\n#             prev_counts = cur_counts\n        \n#         return sum(prev_counts)%(10**9+7)\n", "class Solution:\n    legal_moves = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            # 5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n    \n    def knightDialer(self, n: int) -> int:\n        total = 0 if n != 1 else 1\n        memo = {}\n        for i in range(0, 10):\n            if i is not 5:\n                total = total + self.num_jumps(i, n - 1, memo)\n                \n        return total % (pow(10, 9) + 7)\n            \n    def num_jumps(self, start, jumps_left, memo):\n        \n        # If we have no moves left we have completed a number\n        if jumps_left == 0:\n            return 1\n        \n        # Check if we have done this calculation before\n        if (start, jumps_left) not in memo:\n            \n            # Calculate total number of numbers from this starting position\n            total = 0\n            for legal_move in self.legal_moves[start]:\n                total = total + self.num_jumps(legal_move, jumps_left - 1, memo)\n        \n            # Save result\n            memo[(start, jumps_left)] = total\n        \n        # Return calculated or retreived result\n        return memo[(start, jumps_left)]", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        moveMap = {1:[8, 6], 2:[7, 9], 3:[4, 8], 4:[3, 9, 0], 5:[], 6:[1, 7, 0],\n                   7:[2, 6], 8:[1, 3], 9:[4, 2], 0:[4, 6]}\n        \n        memo = {}\n    \n        def aux(key, rem):\n            if rem == 0:\n                return 1\n            if (key, rem) in memo: return memo[(key, rem)]\n            \n            count = 0\n            # Move to each valid key from this key\n            moves = moveMap[key]\n            for m in moves:\n                count += aux(m, rem - 1)\n            \n            # Save the result\n            memo[(key, rem)] = count\n            return count\n        \n        count = 0\n        for startKey in moveMap:\n            count += aux(startKey, n - 1)\n            \n        return count % MOD\n                \n            \n", "class Solution:\n    def __init__(self):\n        \n        self.pos_2_pos_map = {\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (3, 0, 9),\n            5: tuple(),\n            6: (7, 1, 0),\n            7: (2, 6),\n            8: (1, 3),\n            9: (4, 2),\n            0: (4, 6)\n        }\n        \n    def dfs(self, position, n, memo):\n        if n == 0:\n            return 1\n        \n        if (position, n) in memo:\n            return memo[(position, n)]\n\n        counts = 0\n        for nei in self.pos_2_pos_map[position]:\n            counts += self.dfs(nei, n-1, memo)\n        memo[(position, n)] = counts\n        \n        return counts\n        \n    def knightDialer(self, n: int) -> int:\n        memo = {}\n        counts = 0\n        \n        for position in self.pos_2_pos_map:\n            counts += self.dfs(position, n-1, memo)\n        return counts % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, l: int) -> int:\n        table = defaultdict(lambda: defaultdict(int))\n        tableEnts = {(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0)}\n        def dp(n, lv) -> int:\n            if lv == 0:\n                return 1\n            if (n, lv) in tableEnts:\n                return table[n][lv]\n\n            if n == 0:\n                ret = dp(4, lv - 1) + dp(6, lv - 1)\n            elif n == 1:\n                ret = dp(6, lv - 1) + dp(8, lv - 1)\n            elif n == 2:\n                ret = dp(7, lv - 1) + dp(9, lv - 1)\n            elif n == 3:\n                ret = dp(4, lv - 1) + dp(8, lv - 1)\n            elif n == 4:\n                ret = dp(3, lv - 1) + dp(9, lv - 1) + dp(0, lv - 1)\n            elif n == 6:\n                ret = dp(1, lv - 1) + dp(7, lv - 1) + dp(0, lv - 1)\n            elif n == 7:\n                ret = dp(2, lv - 1) + dp(6, lv - 1)\n            elif n == 8:\n                ret = dp(1, lv - 1) + dp(3, lv - 1)\n            elif n == 9:\n                ret = dp(2, lv - 1) + dp(4, lv - 1)\n            \n            ret %= 1000000007\n            table[n][lv] = ret\n            tableEnts.add((n, lv))\n            return ret\n\n        if l == 1:\n            return 10\n        else:\n            res = 0\n            for i in [0, 1, 2, 3, 4, 6, 7, 8, 9]:\n                res += dp(i, l - 1)\n            return res % 1000000007", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        k = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n        }\n        \n        mem = {}\n        def count(i, j):\n            if j > n: return 0\n            if j == n: return 1\n            if (i, j) in mem: return mem[i, j]\n            \n            cc = 0\n            for l in k[i]:\n                cc += count(l, j + 1)\n            \n            mem[i, j] = cc % (10 ** 9 + 7)\n            return mem[i, j]\n        \n        \n        return sum(count(i, 1) for i in range(10)) % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def matmul(A, B):\n            BT = list(zip(*B))\n            res = [[sum((x*y)%M for x, y in zip(row, col)) for col in BT] for row in A]\n            return res\n        \n        def pow(A, n):\n            \n            l = n.bit_length()\n            res = [[1 if i==j else 0 for j in range(len(A[0]))] for i in range(len(A))]\n            tmp = A\n            \n            for i in range(l):\n                \n                mask = 1 << i\n                \n                if mask & n != 0:\n                    res = matmul(res, tmp)\n                    \n                tmp = matmul(tmp, tmp)\n                \n            return res\n        \n        M = 10**9+7\n        A = [[0,0,0,0,1,0,1,0,0,0],\n             [0,0,0,0,0,0,1,0,1,0],\n             [0,0,0,0,0,0,0,1,0,1],\n             [0,0,0,0,1,0,0,0,1,0],\n             [1,0,0,1,0,0,0,0,0,1],\n             [0,0,0,0,0,0,0,0,0,0],\n             [1,1,0,0,0,0,0,1,0,0],\n             [0,0,1,0,0,0,1,0,0,0],\n             [0,1,0,1,0,0,0,0,0,0],\n             [0,0,1,0,1,0,0,0,0,0]]\n        \n        res = matmul([[1,1,1,1,1,1,1,1,1,1]], pow(A,n-1))\n        \n        return sum(res[0]) % M\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        graph = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[3, 9, 0], 5:[], 6:[1, 7, 0], 7:[6, 2], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\n        \n        @lru_cache(None)\n        def dfs(node, n=n):\n            if n == 1:\n                return 1\n            else:\n                moves = 0\n                for neigb in graph[node]:\n                    if neigb in (3, 6, 9):\n                        neigb -= 2\n                    moves += dfs(neigb, n-1)\n                return moves\n                \n        ans = 0\n        for node in range(10):\n            ans += dfs(node)\n        \n        return ans % (10 **9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        cnt = 0\n        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [\n            0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        visited = dict()\n        def helper(n,i):\n            if (n,i) in visited:\n                return visited[(n,i)]\n            if n == 1:\n                visited[(n,i)] = 1\n                return 1\n            tot = 0\n            \n            for v in jump[i]:\n                tot += helper(n -1,v)\n            visited[(n,i)] = tot\n            return tot\n        for i in range(10):\n            cnt += helper(n,i)\n        return cnt%(10**9 + 7)\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        d = {1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[3,9,0],\n            5:[],\n            6:[1,7,0],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4],\n            0:[4,6]}\n        \n        cache = {}\n        \n        def dfs(l,m):\n            nonlocal d\n            nonlocal cache\n            key = (l,m)\n            \n            if key in cache:\n                return cache[key]\n            \n            if m == n:\n                return 1\n            \n            ans = 0\n            \n            for v in d[l]:\n                ans += dfs(v,m+1)\n                \n            cache[key] = ans\n            return ans\n        \n        ret = 0\n        for i in range(10):\n            ret += dfs(i,1)\n                \n        return ret%(10**9 +7)", "class Solution:\n    \n    def __init__(self):\n        self.paths = {1: [8, 6], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n    \n    def knightDialer(self, n: int) -> int: # 3\n        \n        # ways(0, 3)\n            # ways(4, 2)\n                # ways(3, 1)\n                    # ways(4, 0)\n                        # return 0\n                    # ways(8, 0) # 0\n                # ways(9, 1)\n                # ways(0, 1)\n            # ways(6, 2)\n        \n        cache = {}\n        \n        # @lru_cache\n        def ways(number, turns):\n            if turns < 2:\n                return turns\n            \n            key = (number, turns)\n            if key in cache:\n                return cache[key]\n            \n            total_ways = 0\n            for new_number in self.paths[number]:\n                total_ways += ways(new_number, turns-1)\n            \n            cache[key] = total_ways\n            \n            return cache[key]\n                \n        total_ways = 0 # 0\n        for i in range(10):\n            total_ways += ways(i, n) # \n        return total_ways % (10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = {0: (4,6), 1: (8, 6), 2: (7, 9), 3: (4, 8), 4: (0, 3, 9), 6: (0, 1, 7), 7: (2, 6), 8: (1,3), 9: (2, 4)}\n        @lru_cache(None)\n        def dfs(last_val=None, length=0):\n            if length == n:\n                return 1\n            count = 0\n            if not length:\n                for i in range(0,10): \n                    count += dfs(i, 1)\n            elif last_val != 5:\n                for i in moves[last_val]:\n                    count += dfs(i, length+1)\n            return count\n        return dfs() % ((10**9)+7)\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n\n        # dp = [1] * 10  # dp[i, N] = dp[nei, N-1] + dp[nei1, N-1] => dp[i] = \n        # for i_n in range(n-1):\n        #     dp2 = [0] * 10\n        #     for i in range(10):\n        #         for nei in moves[i]:\n        #             dp2[nei] += dp[i]\n        #             dp2[nei] %= MOD\n        #     dp = list(dp2)\n        # return sum(dp) % MOD        \n        dp = [[0] * 10 for _ in range(n)]\n        for i in range(10):\n            dp[0][i] = 1\n            \n        for i_n in range(0, n-1):\n            for i in range(10):\n                for nei in moves[i]:\n                    dp[i_n+1][nei] += dp[i_n][i]\n                    dp[i_n+1][nei] %= MOD\n        res = 0\n        for i in range(10):\n            res += dp[n-1][i]\n            res %= MOD\n        return res \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5:[],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        MOD = 10**9 + 7\n        res = 0\n        cache = {}\n        for i in range(10):\n            res += self.helper(i,n,neighbors,cache)\n        return res % MOD\n    def helper(self,num,hops,neighbors,cache):\n        if hops == 1:\n            return 1\n        if (num,hops) in cache:\n            return cache[(num,hops)]\n        seq = 0\n        for i in neighbors[num]:\n            seq += self.helper(i,hops-1,neighbors,cache)\n        cache[(num,hops)] = seq\n        return seq", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        modulo = 10**9 + 7\n\n        dp = [1] * 10 \n        \n        while n > 1:\n            new_table = [0] * 10\n            for digit in range(0,10):\n                for neighbor in self.neighbors(digit):\n                    new_table[neighbor] += dp[digit]\n            n -= 1\n            dp = new_table\n            \n        return sum(dp) % modulo\n    \n#     def getWays(self, digit, n):\n#         if n == 0:\n#             return 1\n        \n#         if (digit,n) in self.cache:\n#             return self.cache[(digit,n)]\n        \n#         temp = 0\n#         for neighbor in self.neighbors(digit):\n#             temp += self.getWays(neighbor, n-1)\n    \n#         self.cache[(digit, n)] = temp\n#         return self.cache[(digit,n)]\n    \n    def neighbors(self, digit):\n        neighbors = {\n            0: (4, 6),\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (0, 3, 9),\n            5: (),\n            6: (0, 1, 7),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2,4)\n\n        }\n        \n        return neighbors[digit]", "jumps = [\n(4, 6),\n(6, 8),\n(7, 9),\n(4, 8),\n(0, 3, 9),\n(),\n(0, 1, 7),\n(2, 6),\n(1, 3),\n(2, 4),\n]\n\nclass Solution:\n    @staticmethod\n    def numNumbersFrom(cache, button, ttl):\n        if ttl == 0:\n            return 0\n        if ttl == 1:\n            return 1\n        if button in cache and ttl in cache[button]:\n            return cache[button][ttl]\n        total = 0\n        for i in jumps[button]:\n            total += int(Solution.numNumbersFrom(cache, i, ttl - 1) % (1e9 + 7))\n        if button not in cache:\n            cache[button] = {}\n        cache[button][ttl] = total\n        return total\n        \n    \n    def knightDialer(self, n: int) -> int:\n        total = 0\n        cache = {}\n        for i in range(0, len(jumps)):\n            total += self.numNumbersFrom(cache, i, n)\n        return int(total % (1e9 + 7))", "class Solution:\n    def __init__(self):\n        self.moves = [\n            [4,6],\n            [6,8],\n            [7,9],\n            [4,8],\n            [3,9,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [4,2]\n        ]\n        self.memoized_moves = {}\n    \n    def knightDialer(self, n: int) -> int:\n        moves = 0 \n        \n        for i in range(10):\n            moves += self.calculateMoves(n-1, i)\n            \n        return moves% (pow(10,9) + 7)\n            \n            \n    def calculateMoves(self, moves_remaining, current_number):\n        if moves_remaining == 0:\n            return 1\n        \n        moves = 0\n        for next_number in self.getMoves(current_number):\n            if (moves_remaining, next_number) not in self.memoized_moves:\n                self.memoized_moves[(moves_remaining, next_number)] = self.calculateMoves(moves_remaining-1, next_number)\n            moves += self.memoized_moves[(moves_remaining, next_number)]\n            \n        return moves\n        \n        \n    def getMoves(self, number):\n        return self.moves[number]\n        \n        \n", "class Solution:\n    d = [[4,6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2,6], [1,3], [2, 4]]\n    #d = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n    def dfs(self, i, n, cache={}):\n        if n == 0: return 1\n        if (i, n) not in cache:\n            cache[i, n] = sum(self.dfs(val, n-1) for val in self.d[i])\n        return cache[i, n]\n    \n    def knightDialer(self, n: int) -> int:\n        mod = int(1e9)+7\n        return sum(self.dfs(i, n-1) for i in range(10)) % mod\n\n# class Solution(object):\n#     moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n#     def knightDialer(self, N):\n#         return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\n#     def knightDialer_(self, N, i, dp={}):\n#         if N == 1: return 1\n#         if (N,i) not in dp:\n#             dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\n#         return dp[(N,i)]\n", "NEIGHBORS_MAP = {\n    1: (6, 8),\n    2: (7, 9),\n    3: (4, 8),\n    4: (3, 9, 0),\n    5: tuple(),  # 5 has no neighbors\n    6: (1, 7, 0),\n    7: (2, 6),\n    8: (1, 3),\n    9: (2, 4),\n    0: (4, 6),\n}\n\nclass Solution:\n    def nextPositions(self,n):\n        return NEIGHBORS_MAP[n]\n    \n    def build_x_y_map(self):\n        r,c = 0,0\n        ht = {}\n        \n        for i in range(1,10):\n            ht[i] = (r,c)\n            c+=1\n            if c == 3:\n                r+=1\n                c = 0\n        \n        ht[0] = (3,1)\n        return ht\n    \n    def knightDialer(self, n: int) -> int:\n        def count_moves(curr_cell,hops,memo):\n            if hops == 0:\n                return 1\n            key = (curr_cell,hops)\n            if key not in memo:\n                ways = 0\n                for pos in self.nextPositions(curr_cell):\n                    ways += count_moves(pos,hops-1,memo)\n                memo[key] = ways\n            return memo[key]\n        \n        total = 0\n        memo = {}\n        for i in range(0,10):\n            total += count_moves(i,n-1,memo)\n        return total % (10**9 + 7)\n        \n", "class Solution:\n    def nextHops(self, row: int, col: int) -> list:\n        hops = []\n        if (row, col) not in self.hopDict:       \n            for jump in [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2),(-1, 2), (-2, 1)]:\n                nr, nc = row + jump[0], col + jump[1]\n                if nr < 0 or nc < 0 or nr > 2 or nc > 2:\n                    if (nr == 3 and nc == 1):\n                        hops.append((nr, nc))\n                    continue\n\n                hops.append((nr, nc))\n                \n            self.hopDict[(row, col)] = hops\n            \n        return self.hopDict[(row, col)]\n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n             return\n            \n        reached = [ [1] * 3 for _ in range(4)]\n        reached[3][0] = 0\n        reached[3][2] = 0\n        self.hopDict = {}\n\n        for move in range(2, n + 1):\n            nreached = [ [0] * 3 for _ in range(4)]\n            for i, row in enumerate(reached):\n                for j, button in enumerate(row):\n                    if button == 0:\n                        continue\n\n                    for hop in self.nextHops(i, j):\n                        nreached[hop[0]][hop[1]] += button\n                        nreached[hop[0]][hop[1]] %= (10**9 + 7)\n            \n            reached = nreached\n        \n        return sum(map(sum, reached)) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        maxs = (10**9 + 7)\n        moves = ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2))\n        memo = {}\n        neighbors = { 1: (6, 8) , 2: (7, 9), 3: (4, 8), 4: (3, 9, 0),5: tuple(), 6: (1, 7, 0), 7: (2, 6), 8: (1, 3), 9: (2, 4), 0: (4, 6),}\n        def dfs(i,n):\n            if n == 1:\n                return 1\n\n            if (n,i) in memo:\n                return memo[(n,i)]\n\n            else:\n                nums = 0\n                for d in neighbors[i]:\n                    nums +=  dfs(d ,n-1) \n                memo[(n,i)] = nums \n            return nums\n            \n        total = 0\n        \n        for i in range(10):\n                total += dfs(i,N)\n        \n        return total % maxs\n            \n       \n            \n            \n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        \n        # dp [i][j] = distinct phone numbers reachable of length j if you are at number i\n        # 0 <= i <= 9\n        # 0 <= j <= n\n        \n        dp = [[0 for j in range(n + 1)] for i in range(10)]\n        \n        for j in range(n + 1):\n            for i in range(10):\n                if (j <= 1):\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = sum([dp[possibleMove][j - 1] for possibleMove in moves[i]])\n\n        return sum([dp[i][n] for i in range(10)]) % (10 ** 9 + 7)\n", "move_map = {\n    0: {4,6},\n    1: {6,8},\n    2: {7,9},\n    3: {4,8},\n    4: {3, 9, 0},\n    5: {},\n    6: {1, 0, 7},\n    7: {2, 6},\n    8: {1, 3},\n    9: {2, 4}\n}\n\nclass Solution:\n    def dfs(self, n, key):\n        if n == 1:\n            return 1\n        if (n, key) in self.memo:\n            return self.memo[n, key]\n        res = 0\n        for new_key in move_map[key]:\n            res += self.dfs(n-1, new_key)\n        self.memo[n, key] = res\n        return res\n    \n    def knightDialer(self, n: int) -> int:\n        self.memo = {}\n        res = 0\n        for key in move_map:\n            res += self.dfs(n, key)\n            \n        return res % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        s = 0\n        for k in range(10):\n            d = [0] * 10\n            d2 = [0] * 10\n            d[k] = 1\n            for i in range(n - 1):\n                d2[0] = d[4] + d[6]\n                d2[1] = d[6] + d[8]\n                d2[2] = d[7] + d[9]\n                d2[3] = d[4] + d[8]\n                d2[4] = d[3] + d[9] + d[0]\n                d2[5] = 0\n                d2[6] = d[1] + d[7] + d[0]\n                d2[7] = d[2] + d[6]\n                d2[8] = d[1] + d[3]\n                d2[9] = d[2] + d[4]\n                d, d2 = d2, d\n            s += sum(d)\n        return s % (10 ** 9 + 7)\n\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        jump_map = {1:[6,8],\n                   2:[7,9],\n                   3:[4,8],\n                   4:[3,9,0],\n                   5: [],\n                   6: [1,7,0],\n                   7:[6,2],\n                   8:[1,3],\n                   9:[2,4],\n                   0:[4,6]}\n        \n        dp_map = {}\n        \n        def get_num(s, n):\n            if (s,n) not in dp_map:\n                if n == 1:\n                    dp_map[(s,n)] = 1\n                    return dp_map[(s,n)]\n                ans = 0\n                for target in jump_map[s]:\n                    ans += get_num(target, n-1)\n                dp_map[(s,n)] = ans\n            return dp_map[(s,n)]\n            \n        total = 0\n        for i in jump_map.keys():\n            total += get_num(i, N)\n            \n        return total % (10**9 + 7)", "class Solution:\n    def _knightDialer(self, n: int, curr_n: int, moves_map: dict, cache: dict) -> int:\n        if n == 0:\n            return 1\n        \n        if (curr_n,n) in cache:\n            return cache[(curr_n,n)]\n        \n        distinct_nums = 0\n        for next_n in moves_map[curr_n]:\n            distinct_nums += self._knightDialer(n-1, next_n, moves_map, cache)\n        \n        cache[(curr_n, n)] = distinct_nums\n        return cache[(curr_n,n)]\n    \n    def knightDialer(self, n: int) -> int:\n        # TLE, let's take care of some symmetry\n        # 1 == 3 == 9 == 7, 4 == 6, 2 == 8, 0\n        if n == 1:\n            return 10\n\n        mod = 10 ** 9 + 7\n        nums = 0\n        cache = {}\n        moves_map = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6],\n        }\n\n        nums = 0\n        for m, weight in [(1,4),(2,2),(4,2), (0,1)]:\n            nums += weight * self._knightDialer(n-1, m, moves_map, cache)\n        \n        return nums % mod", "class Solution:\n    def helper(self, keys, n, digit, cache):\n        if not n:\n            return 1\n        \n        if (n, digit) in cache:\n            return cache[(n,digit)]\n        \n        count = 0\n        for d in keys[digit]:\n            count += self.helper(keys, n-1, d, cache)\n        \n        cache[(n,digit)] = count\n        return cache[(n,digit)]\n        \n    def knightDialer(self, n: int) -> int:\n        \n        keys = {1:[6,8], 2:[7,9], 3:[4,8],4:[0,3,9], 5: [], 6:[7,1,0], 7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]}\n        \n        count = 0\n        cache = {}\n        for i in range(0, 10):\n            count += self.helper(keys, n-1, i, cache)\n        return count % (10**9+7)\n        # def helper()\n", "from functools import lru_cache\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        ## dp/ recursion\n        neighbors = {\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[3,9,0],\n            5:[], # 5 is a stuck point? also no way to get to 5\n            6:[1,7,0],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4],\n        }\n        \n        @lru_cache(None)\n        def dfs(i,n):\n            if(n == 1):\n                return 1;\n            count = 0;\n            for x in neighbors[i]:\n                count = (count+dfs(x,n-1))%(10**9+7)\n            return count;\n        ansr = 0;\n        for i in range(10):\n            #print(dfs(i,n))\n            ansr= (ansr+dfs(i,n))%(10**9+7)\n            \n        return ansr\n            \n", "# \u5f53\u524dindex\u4f4d\u7f6e\uff0c\u4e0b\u4e00\u4e2a\u53ef\u80fd\u5230\u8fbe\u7684\u4f4d\u7f6e(0 ~ 9)\nMOVES = [\n    [4, 6], [6, 8], [7,9],\n    [4, 8], [3, 9, 0], [],\n    [1, 7, 0], [2, 6], [1, 3], [2, 4],\n]\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        memo = {}\n        res = 0\n        for i in range(10):\n            res += self._dfs(i, N, memo)\n        return res % (10 ** 9 + 7)\n\n    def _dfs(self, curr, steps, memo):\n        if steps == 1:\n            return 1\n\n        key = (curr, steps)\n        if key in memo:\n            return memo[key]\n        memo[key] = 0\n        for next_digit in MOVES[curr]:\n            memo[key] += self._dfs(next_digit, steps - 1, memo)\n        return memo[key]\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dic = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4:[0, 3, 9], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9: [2, 4]}\n        MOD = 10 ** 9 + 7\n        cache = {}\n        \n        def dfs(start, digit):\n            key = (start, digit)\n            \n            if key in cache:\n                return cache[key]\n            \n            if digit == 0:\n                return 1\n            \n            if digit < 0:\n                return 0\n            \n            ans = 0\n            if dic.get(start, -1) == -1:\n                return 0\n            \n            for neigh in dic[start]:\n                ans += dfs(neigh, digit -1)\n            \n            cache[key] = ans\n            \n            return ans\n        \n        count = 0\n        for i in range(10):\n            count = (count + dfs(i, n-1)) % MOD\n            \n        return count", "class Solution:\n        \n    def knightDialer(self, n: int) -> int:\n        \n        MOD = 10**9 + 7\n        \n        M = [[0 for i in range(10)] for j in range(n+1)] \n        # print(M)\n        \n        next_move = {0: [4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0], 5:[],\n                     6:[1,7,0], 7:[2,6],8:[1,3],9:[2,4]}\n    \n    \n        def paths(pos, nhop):\n            if nhop == 1:\n                return 1\n            \n            if M[nhop][pos] > 0: \n                return M[nhop][pos];\n        \n            for j in range(len(next_move[pos])):\n                M[nhop][pos] += paths(next_move[pos][j], nhop-1)% MOD  \n            return M[nhop][pos]\n        \n        ans = 0\n        for start in range(10):\n            ans = (ans + paths(start, n)) % MOD\n            \n        return int(ans);\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9+7\n        \n        if n == 1:\n            return 10\n        \n        dic = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 6: {1, 7, 0}, 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        memo = {}\n        def dfs(cur, n):\n            if n == 0:\n                return 1\n            if (cur, n) in memo:\n                return memo[cur, n]\n            ret = 0\n            for nxt in dic.get(cur, []):\n                ret += dfs(nxt, n-1)\n            memo[cur, n] = ret\n            return ret\n    \n        ret = 0\n        for i in range(10):\n            ret += dfs(i, n-1) \n            ret %= mod\n        return ret", "class Solution:\n    def dfs(self, i, N):\n        if N == 1:\n            return 1\n        \n        if (i, N) in self.memo:\n            return self.memo[(i, N)]\n        \n        ans = 0\n        for nxt in self.map[i]:\n            ans += self.dfs(nxt, N - 1)\n        self.memo[(i, N)] = ans\n        return ans\n            \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        if n == 1:\n            return 10\n        \n        self.map = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4]\n        }\n        self.memo = {}\n        \n        ans = 0\n        \n        for i in range(10):\n            if i == 5:\n                continue\n            ans = (ans + self.dfs(i, n)) % (10**9 + 7)\n            \n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # DP \u6bcf\u6b21\u8981\u52a0\u4e0a\u90a3\u4e2a\u683c\u7684DP\u503c\n        #{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 9}, {4, 2}\n        # \u4e8c\u7ef4\u6570\u7ec4 \u8868\u793a\u7b2ci\u6b21\u8df3\u5230j\u4e0a\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\n        # \u6bd4\u5982\u52304\u7684\u65f6\u5019 \u90a3\u4e48\u53ef\u80fd\u662f\u4ece3,9,0 \u6765\u7684 \u90a3\u4e48i,4 = i,4 + i-1 (3,9,0)\n        stack = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,9],[4,2]]\n        dp = [[0 for _ in range(10)] for __ in range(n)]\n        for i in range(10):     # \u968f\u4fbf\u653e  \u6240\u6709\u6309\u952e\u90fd\u521d\u59cb\u4e3a1 \u56e0\u4e3an\u662f\u8df3\u7684\u6b21\u6570 \u653e\u7684\u4e0d\u7b97\n            dp[0][i] = 1\n        for i in range(1,n):    # \u8df3 1 \u5230 n-1 \u6b21\n            for j in range(10):\n                for k in stack[j]:\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % (10**9 + 7)\n        return sum(dp[-1][i] for i in range(10))  % (10**9 + 7)", "class Solution:\n    NEIGHBORS = {\n        0: (4, 6),\n        1: (6, 8),\n        2: (7, 9),\n        3: (4, 8),\n        4: (3, 9, 0),\n        5: (),\n        6: (1, 7, 0),\n        7: (2, 6),\n        8: (1, 3),\n        9: (2, 4),\n    }\n    \n    def numsFromPos(self, num, jumps):\n        jumps_remaining = jumps - 1\n        if not jumps_remaining:\n            return 1\n        \n        if (num, jumps) in self.cache:\n            return self.cache[(num, jumps)]\n        \n        res = 0\n        for nei in self.NEIGHBORS[num]:\n            res += self.numsFromPos(nei, jumps_remaining)\n            \n        self.cache[(num, jumps)] = res\n        return res\n        \n    def knightDialer(self, n: int) -> int:\n        self.cache = {}\n        \n        res = 0\n        for i in range(10):\n            res += self.numsFromPos(i, n)\n        return res % (10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\n        for _ in range(N-1):\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = x8+x6, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x2+x4, x4+x6\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0)%(10**9+7)\n        \n        \n        \n#         x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\n#         for i in range(N-1):\n#             x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x2+x4, x4+x6\n#         return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0)%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        modulo = 10**9 + 7\n        \n        dp = [1] * 10 \n        \n        while n > 1:\n            new_table = [0] * 10\n            for digit in range(10):\n                for neighbor in self.getNeighbor(digit):\n                    new_table[neighbor] += dp[digit]\n            dp = new_table\n            n -= 1\n            \n        return sum(dp) % (modulo)\n            \n#     def getWays(self, curr, steps):\n#         if steps == 0:\n#             return 1 \n#         if (curr, steps) in self.cache:\n#             return self.cache[(curr,steps)]\n#         temp = 0\n#         for digit in self.getNeighbor(curr):\n#             temp += self.getWays(digit,steps-1)\n          \n#         self.cache[(curr,steps)] = temp\n        \n#         return temp\n            \n    \n    def getNeighbor(self, digit):\n        neighbors = {\n            1: (6,8),\n            2: (7,9),\n            3: (4,8),\n            4: (0,3,9),\n            5: (),\n            6: (0,1,7),\n            7: (2,6),\n            8: (1,3),\n            9: (2,4),\n            0: (4,6)\n        }\n        \n        return neighbors[digit]\n    \n", "class Solution:\n    def _knightDialer(self, n: int, curr_n: int, moves_map: dict, cache: dict) -> int:\n        if n == 0:\n            return 1\n        \n        if (curr_n,n) in cache:\n            return cache[(curr_n,n)]\n        \n        distinct_nums = 0\n        for next_n in moves_map[curr_n]:\n            distinct_nums += self._knightDialer(n-1, next_n, moves_map, cache)\n        \n        cache[(curr_n, n)] = distinct_nums\n        return cache[(curr_n,n)]\n    \n    def knightDialer(self, n: int) -> int:\n        # TLE, let's take care of some symmetry\n        # 1 == 3 == 9 == 7, 4 == 6, 2 == 8, 0\n        if n == 1:\n            return 10\n\n        mod = 10 ** 9 + 7\n        nums = 0\n        cache = {}\n        moves_map = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6],\n        }\n        for m in [1,2,4,0]:\n            self._knightDialer(n-1, m, moves_map, cache)\n        \n        total = cache[(1, n-1)] * 4 + cache[(4,n-1)] * 2 + cache[(2,n-1)] * 2 + cache[(0,n-1)]\n        return total % mod", "class Solution:\n    def knightDialer(self, N: 'int') -> 'int':\n        path_graph = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n        mem = {}\n        if N == 1: return 10\n        def dfs(n, steps):\n            if steps == 1: \n                # return [partial]\n                return len(path_graph[n])\n            if (n,steps) not in mem:\n                all_paths = 0\n                for next_num in path_graph[n]:\n                    # if next_num not in visited:\n                        # visited.add(next_num)\n                    all_paths += dfs(next_num, steps-1)      \n                mem[(n,steps)] = all_paths\n            return mem[(n, steps)]\n        result = 0\n        for n in range(10):\n            # visited = set([n])\n            temp = dfs(n, N-1)\n            # print(temp)\n            result += temp\n        return result%(10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def dfs(pos, remain):\n            if remain == 0:\n                return 1\n            if not (pos, remain) in memo:\n                cur = 0\n                for np in pos_map[pos]:\n                    cur += dfs(np, remain-1)\n                memo[(pos, remain)] = cur\n            return memo[(pos, remain)]\n        \n        res = 0\n        memo = {}\n        pos_map = {0: [4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],\n                  5:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\n        for i in range(10):\n            res += dfs(i, n-1)\n        return res % (pow(10,9)+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        self.mod_Val = 10**9 + 7\n        self.map = {\n            1 : [6,8],\n            2 : [7,9],\n            3 : [4,8],\n            4 : [3,9,0],\n            5 : [],\n            6 : [1,7,0],\n            7 : [2,6],\n            8 : [1,3],\n            9 : [2,4],\n            0 : [4,6],\n        }\n        self.ans = 0\n        self.mem = collections.defaultdict(int)\n        for i in range(10):\n            self.ans+=self.recursion(n-1, i)\n            \n        return self.ans%self.mod_Val\n        \n    def recursion(self, hops, s):\n        if not hops:\n            return 1\n        count = 0\n        if (hops, s) not in self.mem:\n            for n in self.map[s]:\n                count += self.recursion(hops-1, n)\n            self.mem[(hops,s)] = count\n        \n        return self.mem[(hops,s)]", "class Solution:\n    \n    \n    \n    def knightDialer(self, n: int) -> int:\n        mem = [[1] for i in range(10)]\n        for i in range(1, n):\n            for cell in range(10):\n                mem[cell].append(self.knightDialerHelper(i, cell, mem))\n            \n        ans = sum([x[n - 1] for x in mem])\n        return ans % (10 ** 9 + 7)\n    \n    def knightDialerHelper(self, n, cellNumber, mem):\n        \n        moves = [\n            [4, 6],\n            [6, 8],\n            [7, 9],\n            [4, 8],\n            [3, 9, 0],\n            [],\n            [1, 7, 0],\n            [2, 6],\n            [1, 3],\n            [2, 4]\n        ]\n        \n        ans = 0\n        for nextCell in moves[cellNumber]:\n            ans += mem[nextCell][n - 1]\n        return ans\n", "# \u5f53\u524dindex\u4f4d\u7f6e\uff0c\u4e0b\u4e00\u4e2a\u53ef\u80fd\u5230\u8fbe\u7684\u4f4d\u7f6e(0 ~ 9)\nMOVES = [\n    [4, 6], [6, 8], [7,9],\n    [4, 8], [3, 9, 0], [],\n    [1, 7, 0], [2, 6], [1, 3], [2, 4],\n]\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        memo = {}\n        res = 0\n        for i in range(10):\n            res += self._dfs(i, N - 1, memo)\n        return res % (10 ** 9 + 7)\n\n    def _dfs(self, curr, steps, memo):\n        if steps == 0:\n            return 1\n\n        key = (curr, steps)\n        if key in memo:\n            return memo[key]\n        memo[key] = 0\n        for next_digit in MOVES[curr]:\n            memo[key] += self._dfs(next_digit, steps - 1, memo)\n        return memo[key]\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves=[[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\n        mod=10**9+7\n        dp=[[0 for j in range(10)] for i in range(n)]\n        for i in range(10):\n            dp[0][i]=1\n        for i in range(1,n):\n            for j in range(10):\n                for nei in moves[j]:\n                    dp[i][nei]+=dp[i-1][j]\n                    dp[i][nei]=dp[i][nei]%mod\n        res=sum(dp[n-1])%mod\n        return res\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        solution = 0\n        self.valid_jumps = {\n            1: [6, 8],\n            2: [9, 7],\n            3: [8, 4],\n            4: [9, 3, 0],\n            5: [],\n            6: [7, 1, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [4, 2],\n            0: [4, 6]\n        }\n        \n        self.N = N\n        self.cache = {}\n\n        solution = 0\n\n        for i in range(10):\n            solution += self.jump_around(1, i)\n        \n                                    \n        return solution % (pow(10, 9) + 7)\n    \n\n    def jump_around(self, number_len_so_far, last_number):\n        if (number_len_so_far, last_number) in self.cache:\n            return self.cache[(number_len_so_far, last_number)]\n        \n        if number_len_so_far == self.N:\n            return 1\n        else:\n            solution_for_this_set = 0\n            possible_jumps = self.valid_jumps[last_number]\n            for possible_jump in possible_jumps:\n                solution_for_this_set += self.jump_around(number_len_so_far + 1, possible_jump)\n            self.cache[(number_len_so_far, last_number)] = solution_for_this_set\n            return solution_for_this_set\n         \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        next_map = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n        memo = {}\n        def dfs(cur_num,n):\n            if (cur_num,n) in memo.keys():\n                return memo[(cur_num,n)]\n            if n == 0:\n                return 1\n            ans = 0\n            for next_num in next_map[cur_num]:                \n                ans += dfs(next_num,n-1)\n            memo[(cur_num,n)] = ans\n            return ans\n        \n        ans = 0\n        MOD = pow(10,9)+7\n        memo = {}\n        for i in range(10):            \n            ans += dfs(i,n-1)%MOD\n            ans = ans%MOD\n        #    print (\\\"i:{}, ans={}\\\".format(i,ans))\n            \n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        M = 10**9 + 7\n        current_ways = [1]*10\n        for i in range(1,n):\n            prev = current_ways.copy()\n            current_ways[0] = (prev[4] + prev[6]) % M\n            current_ways[1] = (prev[6] + prev[8]) % M\n            current_ways[2] = (prev[7] + prev[9]) % M\n            current_ways[3] = (prev[4] + prev[8]) % M\n            current_ways[4] = (prev[3] + prev[9] + prev[0]) % M\n            current_ways[5] = 0\n            current_ways[6] = (prev[1] + prev[7] + prev[0]) % M\n            current_ways[7] = (prev[2] + prev[6]) % M\n            current_ways[8] = (prev[1] + prev[3]) % M\n            current_ways[9] = (prev[2] + prev[4]) % M\n            \n            \n        return sum(current_ways) % M\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # DP \u6bcf\u6b21\u8981\u52a0\u4e0a\u90a3\u4e2a\u683c\u7684DP\u503c\n        #{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 9}, {4, 2}\n        # \u4e8c\u7ef4\u6570\u7ec4 \u8868\u793a\u7b2ci\u6b21\u8df3\u5230j\u4e0a\u6709\u591a\u5c11\u79cd\u65b9\u6cd5\n        # \u6bd4\u5982\u52304\u7684\u65f6\u5019 \u90a3\u4e48\u53ef\u80fd\u662f\u4ece3,9,0 \u6765\u7684 \u90a3\u4e48i,4 = i,4 + i-1 (3,9,0)\n        stack = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,9],[4,2]]\n        dp = [[0 for _ in range(10)] for __ in range(n)]\n        for i in range(10):\n            dp[0][i] = 1\n        for i in range(1,n):\n            for j in range(10):\n                for k in stack[j]:\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % (10**9 + 7)\n        return sum(dp[-1][i] for i in range(10))  % (10**9 + 7)", "class Solution:\n    def __init__(self):\n        self.moves = [\n            [4,6],\n            [6,8],\n            [7,9],\n            [4,8],\n            [3,9,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [4,2]\n        ]\n        self.memoized_moves = {}\n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        moves = 0 \n        \n        for i in range(10):\n            moves += self.calculateMoves(n-1, i)\n            \n        return moves% (pow(10,9) + 7)\n            \n            \n    def calculateMoves(self, moves_remaining, current_number):\n        if moves_remaining == 0:\n            return 1\n        \n        moves = 0\n        for next_number in self.getMoves(current_number):\n            if (moves_remaining, next_number) not in list(self.memoized_moves.keys()):\n                self.memoized_moves[(moves_remaining, next_number)] = self.calculateMoves(moves_remaining-1, next_number)\n            moves += self.memoized_moves[(moves_remaining, next_number)]\n            \n        return moves\n        \n        \n    def getMoves(self, number):\n        return self.moves[number]\n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        next_map = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]}\n       \n        def dfs(cur_num,n):\n            if (cur_num,n) in memo.keys():\n                return memo[(cur_num,n)]\n            if n == 0:\n                return 1\n            ans = 0\n            for next_num in next_map[cur_num]:                \n                ans += dfs(next_num,n-1)\n            memo[(cur_num,n)] = ans\n            return ans\n        \n        ans = 0\n        MOD = pow(10,9)+7\n        memo = {}\n        for i in range(10):            \n            ans += dfs(i,n-1)%MOD\n            ans = ans%MOD\n        #    print (\\\"i:{}, ans={}\\\".format(i,ans))\n            \n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        memo = {}\n        pos = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8], \n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [3, 1],\n            9: [2, 4],\n            0: [6, 4]\n        }\n        \n        res = 0\n        mod = 10**9 + 7\n        \n        def recur(i, hops):\n            if (i, hops) in memo:\n                return memo[(i, hops)]\n            if hops == 0:\n                return 1\n            cnt = 0\n            for nums in pos[i]:\n                cnt += recur(nums, hops - 1)\n                memo[(i, hops)] = cnt\n            return cnt\n                \n        for i in range(10):\n            res += recur(i, n-1)\n        return res % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        nbrs = {\n                1: [6,8],\n                2: [9,7],\n                3: [4,8],\n                4: [3,9,0],\n                5 : [],\n                6: [1,7,0],\n                7: [2,6],\n                8: [1,3],\n                9: [2,4],\n                0:  [4,6]            \n                }\n        \n        self.memo = {}\n        def find_count(idx,num):\n            if idx == n:\n                return 1\n            if (num,idx) in self.memo:\n                return self.memo[(num,idx)]\n            count = 0\n            for nbr in nbrs[num]:\n                count += find_count(idx+1,nbr)\n            \n            self.memo[(num,idx)] = count\n            return count\n        ans = 0\n        for i in range(10):\n            ans += find_count(1,i)\n        mod = 10 ** 9 + 7\n        \n        return ans%mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        moves = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\n        \n        from functools import lru_cache\n        @lru_cache(maxsize = None)\n        def dfs(i, length):\n            if n == length:\n                return 1\n            \n            total = 0\n            for newI in moves[i]:\n                total += dfs(newI, length + 1)\n            return total\n        \n        ans = 0\n        for i in range(0, 10):\n            ans += dfs(i, 1)\n            if ans >= 10**9+7:\n                ans = ans%(10**9+7)\n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [0 for i in range(12)]\n        num = [1,2,3,4,5,6,7,8,9,11]\n        for j in num:\n            dp[j] = 1\n        for i in range(1,n):\n            temp = [0 for l in range(12)]\n            for j in num:\n                if(j%3==0):\n                    temp[j] += dp[j+5] if j+5 in num else 0\n                    temp[j] += dp[j-5] if j-5 in num else 0\n                    temp[j] += dp[j+1] if j+1 in num else 0\n                    temp[j] += dp[j-7] if j-7 in num else 0\n                elif(j%3==1):\n                    temp[j] += dp[j+5] if j+5 in num else 0\n                    temp[j] += dp[j-5] if j-5 in num else 0\n                    temp[j] += dp[j+7] if j+7 in num else 0\n                    temp[j] += dp[j-1] if j-1 in num else 0\n                else:\n                    temp[j] += dp[j+5] if j+5 in num else 0\n                    temp[j] += dp[j-5] if j-5 in num else 0\n                    temp[j] += dp[j+7] if j+7 in num else 0\n                    temp[j] += dp[j-7] if j-7 in num else 0\n            dp = temp\n        return sum(dp)%(10**9+7)", "class Solution:\n    def __init__(self):\n        self.moves = [\n            [4,6],\n            [6,8],\n            [7,9],\n            [4,8],\n            [3,9,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [4,2]\n        ]\n        \n        self.memoized_numbers= {}\n    \n    def knightDialer(self, n: int) -> int:\n        distinctPhoneNumbers = 0\n        for i in range(10):\n            distinctPhoneNumbers += self.getPhoneNumbers(n-1, i)\n        \n        return(distinctPhoneNumbers%(pow(10,9)+7))\n        \n    \n    def getPhoneNumbers(self, moves_remaining, current_number):\n        if moves_remaining == 0:\n            return 1\n        \n        else:\n            moves = 0\n            for number in self.getMoves(current_number):\n                if (moves_remaining, number) not in list(self.memoized_numbers.keys()):\n                    self.memoized_numbers[(moves_remaining, number)] = self.getPhoneNumbers(moves_remaining-1, number)\n                moves += self.memoized_numbers[(moves_remaining, number)]\n\n            return moves\n\n    def getMoves(self, move):\n        return self.moves[move]\n        \n", "from collections import defaultdict\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        MOD = 10 ** 9 + 7\n        board = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [-1, 0, -1]]\n        \n        dp = defaultdict(int)\n        movesC = {}\n        def moves(i, j):\n            valids = set()\n            for u,v in [(i-1, j + 2), (i + 1, j + 2), (i - 1,j-2), (i+1, j-2), (i-2, j +1), (i-2,j-1), (i+2, j+1), (i + 2, j-1)]:\n                if u < 0 or v < 0 or u >= len(board) or v >= 3:\n                    continue\n                if board[u][v] != -1:\n                    valids.add((u,v))\n            return valids\n        for i in range(len(board)):\n            for j in range(3):\n                if board[i][j] != -1:\n                    movesC[(i, j)] = moves(i, j)\n        total = 0\n        for n in range(1, N+1):\n            for i in range(len(board)):\n                for j in range(len(board[i])):\n                    num = board[i][j]\n                    if num != -1:\n                        key = (i, j, n)\n                        if n == 1:\n                            dp[key] = 1\n                        else:\n                            \n                            for u, v in movesC[(i, j)]:\n                                dp[key] += dp[(u, v, n - 1)] % MOD\n                        if n == N:\n                            total += dp[key]  % MOD\n                    \n        return total % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        MOD = 10**9 + 7\n        poss = {}\n        poss[1] = [6,8]\n        poss[2] = [7,9]\n        poss[3] = [4,8]\n        poss[4] = [3,9,0]\n        poss[5] = []\n        poss[6] = [1,7,0]\n        poss[7] = [2,6]\n        poss[8] = [1,3]\n        poss[9] = [2,4]\n        poss[0] = [4,6]\n        \n        \n        def helper(numb,i):\n            # print('numb is ', numb)\n            # print('at i ',i)\n            if i == n:\n                return 1\n            if (numb,i) in mem:\n                return mem[(numb,i)]\n            out= 0\n            child = poss[numb]\n            nchild = len(child)\n            for j in range(nchild):\n                val = child[j]\n                out += helper(val,i+1)\n                out = out % MOD\n            mem[(numb,i)] = out \n            return out\n        res = 0\n        mem = {}\n        for i in range(10):\n            # print('starting at ',i)\n            res += helper(i,1)\n        return res % MOD", "from collections import defaultdict\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        \n        board = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [-1, 0, -1]]\n        \n        dp = defaultdict(int)\n        movesC = {}\n        def moves(i, j):\n            valids = set()\n            for u,v in [(i-1, j + 2), (i + 1, j + 2), (i - 1,j-2), (i+1, j-2), (i-2, j +1), (i-2,j-1), (i+2, j+1), (i + 2, j-1)]:\n                if u < 0 or v < 0 or u >= len(board) or v >= 3:\n                    continue\n                if board[u][v] != -1:\n                    valids.add((u,v))\n            return valids\n        for i in range(len(board)):\n            for j in range(3):\n                if board[i][j] != -1:\n                    movesC[(i, j)] = moves(i, j)\n        total = 0\n        for n in range(1, N+1):\n            for i in range(len(board)):\n                for j in range(len(board[i])):\n                    num = board[i][j]\n                    if num != -1:\n                        key = (i, j, n)\n                        if n == 1:\n                            dp[key] = 1\n                        else:\n                            \n                            for u, v in movesC[(i, j)]:\n                                dp[key] += dp[(u, v, n - 1)]\n                        if n == N:\n                            total += dp[key]\n                    \n        return total % (10 ** 9 + 7)", "from collections import deque\n\nclass Solution:\n    \n    def __init__(self):\n        self.next_move = [(4,6), (6, 8), (7,9), (4, 8), (3,0,9), (), (1, 7,0), (6, 2), (3,1), (2, 4)]\n        self.cache = {}\n        \n    def dfs(self, start, n):\n        if n == 0:\n            return 1\n        \n        if not self.cache.get((start, n)):\n            total_numbers = 0\n            for i in self.next_move[start]:\n                total_numbers += self.dfs(i, n-1)\n            self.cache[(start,n)] = total_numbers\n        return self.cache[(start,n)]\n    \n    def knightDialer(self, n: int) -> int:\n        return sum([self.dfs(i, n-1) for i in range(10)]) % (10**9 + 7)\n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [0 for i in range(12)]\n        num = [1,2,3,4,5,6,7,8,9,11]\n        for i in range(n):\n            temp = [0 for l in range(12)]\n            for j in num:\n                if(i==0):\n                    temp[j] = 1\n                else:\n                    temp[j] += dp[j+5] if j+5 in num else 0\n                    temp[j] += dp[j-5] if j-5 in num else 0\n                    if(j%3==0):\n                        temp[j] += dp[j+1] if j+1 in num else 0\n                        temp[j] += dp[j-7] if j-7 in num else 0\n                    elif(j%3==1):\n                        temp[j] += dp[j+7] if j+7 in num else 0\n                        temp[j] += dp[j-1] if j-1 in num else 0\n                    else:\n                        temp[j] += dp[j+7] if j+7 in num else 0\n                        temp[j] += dp[j-7] if j-7 in num else 0\n            dp = temp\n        return sum(dp)%(10**9+7)", "class Solution:\n    def __init__(self):\n        self.moves = [ \n            [4,6],\n            [8,6],\n            [7,9],\n            [4,8],\n            [9,3,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [2,4],\n        ]\n        \n        self.memoized_current_number_and_remaining_moves = {}\n    \n    def getNextMoves(self, current_number):\n        return self.moves[current_number]\n    \n    def knightDialer(self, n: int) -> int:\n        total_moves = 0\n        for number in range(10):\n            total_moves += self.knightDialerOneNumber(number, n-1)\n        return total_moves % (pow(10,9) +7)\n    \n    \n    def knightDialerOneNumber(self, current_number, moves_left):\n        if moves_left == 0:\n            return 1\n        \n        moves = 0\n        \n        for move in self.getNextMoves(current_number):\n            if (move, moves_left) in list(self.memoized_current_number_and_remaining_moves.keys()):\n                moves += self.memoized_current_number_and_remaining_moves[(move, moves_left)]\n            else:\n                self.memoized_current_number_and_remaining_moves[(move, moves_left)] = self.knightDialerOneNumber(move, moves_left -1)\n                moves += self.memoized_current_number_and_remaining_moves[(move, moves_left)]\n            \n        return moves\n", "from functools import lru_cache\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        ## dp/ recursion\n        neighbors = {\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[3,9,0],\n            5:[], # 5 is a stuck point? also no way to get to 5\n            6:[1,7,0],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4],\n        }\n        \n        #lru_cache is needed\n        @lru_cache(None)\n        def dfs(i,n):\n            if(n == 1):\n                return 1;\n            count = 0;\n            for x in neighbors[i]:\n                count = (count+dfs(x,n-1))%(10**9+7)\n            return count;\n        ansr = 0;\n        for i in range(10):\n            #print(dfs(i,n))\n            ansr= (ansr+dfs(i,n))%(10**9+7)\n            \n        return ansr\n            \n", "class Solution:\n    valid_jumps = dict()\n    valid_jumps[0] = [4,6]\n    valid_jumps[1] = [6,8]\n    valid_jumps[2] = [7,9]\n    valid_jumps[3] = [4,8]\n    valid_jumps[4] = [0,3,9]\n    valid_jumps[5] = []\n    valid_jumps[6] = [0,1,7]\n    valid_jumps[7] = [2,6]\n    valid_jumps[8] = [1,3]\n    valid_jumps[9] = [2,4]\n    cache = dict()\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10;\n        agg = 0\n        for idx in range(10):\n            if idx != 5:\n                agg += self.knightDialerHelper(idx, n-1)\n        return agg % int(1e9 + 7)\n    \n    def knightDialerHelper(self, start, n):\n        if n == 1:\n            return len(self.valid_jumps[start])\n        if (start, n) in self.cache.keys():\n            return self.cache[(start,n)]\n        numbers = 0\n        for k in self.valid_jumps[start]:\n            numbers += self.knightDialerHelper(k, n-1)\n        self.cache[(start,n)] = numbers\n        return numbers", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        dp = [1 for x in range(10)]\n        \n        # jumpMap = {1: [6, 8], 2: [7, 9], 3: [8, 4], 4: [9, 3, 0]: 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [4, 2], 0: [4, 6]}\n        \n        for index in range(n - 1):\n            \n            newDp = [dp[4] + dp[6],\n                     dp[6] + dp[8], \n                     dp[7] + dp[9], \n                     dp[8] + dp[4], \n                     dp[9] + dp[3] + dp[0],\n                     0, \n                     dp[1] + dp[7] + dp[0],\n                     dp[2] + dp[6], \n                     dp[1] + dp[3], \n                     dp[4] + dp[2]]\n                        \n            dp = newDp\n        \n        return sum(dp) % (10**9 + 7)", "from collections import defaultdict\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        # the graph\n        G =  {1: [6, 8],\n             2: [7, 9],\n             3: [4, 8],\n             6: [1, 7, 0],\n             5: [],\n             4: [3, 9, 0],\n             7: [2,6],\n             8: [1,3],\n             9: [2,4],\n             0: [4,6]}\n        \n        \n        \n        # keys are 0,1,2....10\n        # values are dict\n        #.      keys are number of movement from this point\n        #       how many different combination exist\n        \n        dp = defaultdict(lambda: defaultdict(lambda: 0))\n            \n        \n        def dfs(number, numberOfMovements):\n            \n            if numberOfMovements == 0:\n                return 1\n            \n            if dp[number][numberOfMovements]:\n                return dp[number][numberOfMovements]\n            \n            total = 0\n            for i in G[number]:\n                total += dfs(i, numberOfMovements-1)\n                \n                \n            dp[number][numberOfMovements] = total\n            return total\n        \n        res = 0\n        for i in range(10):\n            res += dfs(i, n-1)\n            res = res % 1000000007\n            \n        return res\n            \n        \n        \n                                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dc = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),5:(),6:(0,7,1),7:(2,6),8:(1,3),9:(2,4)}\n        dp = [[0]*10 for i in range(n+1)]\n        for i in range(10):\n            dp[1][i]=1\n        for i in range(2,n+1):\n            for j in range(10):\n                for k in range(10):\n                    if j in dc[k]:\n                        dp[i][j]+=dp[i-1][k]\n        return sum(dp[n])%(10**9+7)\n", "import numpy as np\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        ans = np.ones((10,),dtype=int)\n        table = {0:[4,6],\n                 1:[6,8],\n                 2:[7,9],\n                 3:[4,8],\n                 4:[0,3,9],\n                 6:[0,1,7],\n                 7:[2,6],\n                 8:[1,3],\n                 9:[4,2]\n                }\n   \n        for i in range(n-1):\n            tempans = np.zeros((10,),dtype=int)\n            for j in range(10):\n                if j!=5:\n                    values = table.get(j)\n                    for value in values:\n                        tempans[value] += ans[j]\n            ans = tempans\n            if(sum(ans)>10**9+7):\n                ans = ans%(10**9+7)\n        return sum(ans)%(10**9+7)\n                            \n                    \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n             [1,7,0],[2,6],[1,3],[2,4]]\n        \n        sol = []\n        cache = {}\n        def backtrack(pos, hops, cur):\n            if (pos, hops) in cache:\n                return cache[(pos, hops)]\n            if hops == 0:\n                return 1\n            count = 0\n            for nbr in moves[pos]:\n                cur.append(nbr)\n                count += backtrack(nbr, hops-1, cur)\n                cur.pop()\n            cache[(pos, hops)] = count\n            return count\n            \n        counts = 0\n        for pos in range(10):\n            counts += backtrack(pos, n-1, [])\n            \n        return counts%(10**9+7)\n        \n#         cur_hops = 1\n#         prev_counts = [1]*10\n#         cur_counts = [0]*10\n        \n#         while cur_hops < n:\n#             cur_hops += 1\n#             cur_counts = [0]*10\n\n#             for pos in range(10):\n#                 for nbr in moves[pos]:\n#                     cur_counts[pos] += prev_counts[nbr]\n#             prev_counts = cur_counts\n        \n#         return sum(prev_counts)%(10**9+7)\n", "from collections import defaultdict\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        self.buildPad()\n        self.buildMoves()\n        \n        self.memo = defaultdict(lambda: -1)\n        \n        numbers = sum(self.visit(start, n-1) for start in range(10))\n                      \n        return numbers % (10**9 + 7)\n        \n    def visit(self, start: int, n: int) -> int:\n        if n == 0:\n            return 1\n        elif self.memo[(start, n)] != -1:\n            return self.memo[(start, n)]\n        \n        numbers = 0\n        for new_start in self.moves[start]:\n            numbers += self.visit(new_start, n-1)\n        \n        self.memo[(start, n)] = numbers\n        return numbers\n    \n    def buildPad(self) -> None:\n        self.pad = [[str(i + j) for j in range(3)] for i in range(1, 10, 3)]\n        self.pad.append(['*', '0', '#'])\n    \n    def buildMoves(self) -> None:\n        self.moves = (\n            (4, 6),\n            (6, 8),\n            (7, 9),\n            (4, 8),\n            (0, 3, 9),\n            (),\n            (0, 1, 7),\n            (2, 6),\n            (1, 3),\n            (2, 4)\n        )\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n <=0:\n            return 0\n        MOD = 10 ** 9 + 7\n        g = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        dp = [[None] * 10 for _ in range(n+1)]\n        # kd(n,start) = sum(kd(n-1,nxtstart) for nxtstart in g[start]))\n        # kd(1,start) = 1\n        def kd(n, start):\n            if n == 1:\n                return 1\n            if dp[n][start] is None:\n                dp[n][start] = sum([kd(n-1, nxt) for nxt in g[start]])\n            return dp[n][start]\n        return sum(kd(n, start) for start in range(10)) % MOD", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        g = {0:[4,6],\n             1:[6,8],\n             2:[7,9],\n             3:[4,8],\n             4:[3,9,0],\n             5:[],\n             6:[1,7,0],\n             7:[2,6],\n             8:[1,3],\n             9:[4,2]}\n        \n        A = [[1 if i in g[j] else 0 for i in range(10)] for j in range(10)]\n        \n        v = [1]*10\n        for _ in range(N-1):\n            res = [0]*10\n            for r in range(10):\n                for c in range(10):\n                    if A[r][c]:\n                        res[c] += v[r]\n            v = res\n        return sum(v) % (10**9 + 7)", "class Solution:\n    def __init__(self):\n        self.moves = [\n            [4,6],\n            [6,8],\n            [7,9],\n            [4,8],\n            [3,9,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [4,2]\n        ]\n        \n        self.memoized_numbers= {}\n    \n    def knightDialer(self, n: int) -> int:\n        distinctPhoneNumbers = 0\n        for i in range(10):\n            distinctPhoneNumbers += self.getPhoneNumbers(n-1, i)\n        \n        return(distinctPhoneNumbers% (pow(10,9) +7))\n        \n        \n    \n    def getPhoneNumbers(self, moves_remaining, current_number):\n        if moves_remaining == 0:\n            return 1\n            \n        moves = 0\n        for number in self.getMoves(current_number):\n            if (moves_remaining-1, number) not in list(self.memoized_numbers.keys()):\n                self.memoized_numbers[(moves_remaining-1, number)] = self.getPhoneNumbers(moves_remaining-1, number)\n            moves += self.memoized_numbers[(moves_remaining-1, number)]\n                \n        return moves\n    \n    def getMoves(self, move):\n        return self.moves[move]\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        adj = {1:[6,8], 2:[7,9], 3:[8,4], 4:[0,9,3], 5:[], 6:[7,1,0], 7:[6,2], 8:[3,1], 9:[4,2], 0:[6,4]}\n        res = 0\n        memo = collections.defaultdict(int)\n        for i in range(10):\n            res = (res + self.top_down(memo, adj, n-1, i))%(10**9+7)\n        return res\n    \n    \n    \n    def top_down(self, memo, adj, n, cur):\n        if n == 0: return 1\n        if (cur, n) not in memo:\n            for nb in adj[cur]:\n                memo[(cur, n)] += self.top_down(memo, adj, n-1, nb)%(10**9+7)\n        return memo[(cur, n)]\n        \n#         jump = {1:[6,8], 2:[7,9], 3:[8,4], 4:[0,9,3], 5:[], 6:[7,1,0], 7:[6,2], 8:[3,1], 9:[4,2], 0:[6,4]}\n#         # dp = [1]*10\n#         # for _ in range(n-1):\n#         #     nxt = [0]*10\n#         #     for i in range(10):\n#         #         for j in jump[i]:\n#         #             nxt[j] += dp[i]\n#         #     dp = nxt\n#         # return sum(dp)%(10**9+7)\n    \n#     def count_paths(self, start, n, adj):\n#         if not n: return 1\n#         dp = {v:1 for v in adj.keys()}\n#         return self.helper([start], n, adj)\n    \n#     def helper(self, cur, n, adj):\n#         if not n: \n#             return len(cur)\n#         nxt = []\n#         for u in cur:\n#             nxt.extend(adj[u])\n#         return self.helper(nxt, n-1, adj)\n    \n", "class Solution:\n    def pos(self, idx):\n        return {0: [4, 6],\n                1: [6, 8],\n                2: [9, 7],\n                3: [4, 8],\n                4: [3, 9, 0],\n                5: [],\n                6: [1, 7, 0],\n                7: [6, 2],\n                8: [1, 3],\n                9: [4, 2]}[idx]\n\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        memo = [[0 for _ in range(n + 1)] for i in range(10)]\n        for i in range(10):\n            memo[i][1] = 1\n        for s in range(2, n + 1):\n            for idx in range(10):\n                for p in self.pos(idx):\n                    memo[idx][s] += memo[p][s - 1]\n        return sum((memo[i][n] for i in range(10))) % (10 ** 9 + 7)\n\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jumps = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n        mod = 10**9 + 7\n        memo = {}\n        def helper(n, starting, memo):\n            if (n,starting) in memo:\n                return memo[(n,starting)]\n            if n == 1:\n                return 1\n            if n == 2:\n                return len(jumps[starting])\n            sum = 0\n            for jump_location in jumps[starting]:\n                sum += helper(n-1, jump_location, memo)\n            memo[(n,starting)] = sum\n            return sum\n        \n        total_jumps = 0\n        for i in range(10):\n            if i == 5 and n != 1:\n                continue\n            total_jumps += helper(n, i, memo)\n        return total_jumps % mod\n        \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dc = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[0,7,1],7:[2,6],8:[1,3],9:[2,4]}\n        dp = [[0]*10 for i in range(n+1)]\n        for i in range(10):\n            dp[1][i]=1\n        for i in range(2,n+1):\n            for j in range(10):\n                for k in range(10):\n                    if j in dc[k]:\n                        dp[i][j]+=dp[i-1][k]\n        return sum(dp[n])%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        path = [(4, 6), (6, 8), (7, 9), (4, 8),\n               (0, 3, 9), (), (0, 1, 7),\n               (2, 6), (1, 3), (2, 4)]\n        memo = []\n        for i in range(n+1):\n            memo.append({})\n            for j in range(10):\n                memo[i][j] = -1\n        \n        def dp(num, steps):\n            if steps == 1:\n                return 1\n            if memo[steps][num] != -1:\n                return memo[steps][num]\n            ret = 0\n            for i in path[num]:\n                ret += dp(i, steps-1)\n            memo[steps][num] = ret\n            return ret % 1000000007\n        \n        res = 0\n        for num in range(10):\n            res += dp(num, n)\n            res %= 1000000007\n        return res", "import numpy as np\n\nclass Solution:\n    # Time: O(N), Space: O(N).\n    def knightDialer(self, N: int) -> int:\n        goto = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n        }\n        # We can build backwards...\n        # With x moves left how many numbers numbers can you form from i.\n        # For x = 0, 1. \n        \n        # Shape (10, N).\n        # dp[p, i] = on position p, with i move lefts, how many moves\n        # can the knight make.\n        dp = np.zeros((10, N)).astype(int)\n        \n        # With 0 moves left you can only make 1 number. \n        dp[:, 0] = 1\n        \n        for c in range(1, N):\n            for p in range(10):\n                for next_vals in goto[p]:\n                    dp[p, c] += dp[next_vals, c - 1] % (10**9 + 7)\n        \n        return int(sum(dp[:, N - 1])) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        myMap = {1: [8, 6], \n                 2: [7, 9],\n                 3: [4, 8],\n                 4: [0, 3, 9],\n                 5: [], \n                 6: [0, 1, 7], \n                 7: [2, 6], \n                 8: [1, 3], \n                 9: [2, 4], \n                 0: [4, 6], \n                 -1: list(range(10))}\n        cache = {}\n        \n        def dfs(start, level):\n            if level == 0:\n                return 1 \n            key = str(start) + str(level)\n            if key in cache:\n                return cache[key]\n            else:\n                ans = 0 \n                for number in myMap[start]:\n                    ans += dfs(number, level - 1)\n                cache[key] = ans \n                return ans \n            \n        total = dfs(-1, N)\n        return total % (10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        NEIGHBORS_MAP = {\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (3, 9, 0),\n            5: tuple(),  # 5 has no neighbors\n            6: (1, 7, 0),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2, 4),\n            0: (4, 6),\n        }\n        mx = 10**9 + 7\n        memo = {}\n        def dp(n, curr_num):\n            if (n, curr_num) in memo:\n                return memo[(n, curr_num)]\n            \n            if n == N - 1:\n                return 1\n            comb = 0\n            for neighbor in NEIGHBORS_MAP[curr_num]:\n                comb += dp(n + 1, neighbor)\n            memo[(n, curr_num)] = comb \n            return comb\n        res = 0\n        for i in range(0, 10):\n            res += dp(0, i)\n        return res % mx\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10**9+7\n        c = [1]*10\n        for _ in range(n-1):\n            c = [\n                c[4]+c[6], c[6]+c[8],\n                c[7]+c[9], c[4]+c[8],\n                c[0]+c[3]+c[9], 0,\n                c[0]+c[7]+c[1], c[2]+c[6],\n                c[1]+c[3], c[2]+c[4]\n            ]\n        return sum(c)%mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        next = {1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (0, 3, 9),\n            5: (),\n            6: (0, 1, 7),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2, 4),\n            0: (4, 6),\n           }\n        M = 1000000007\n        # cache = {}\n        cache = defaultdict(int)\n        def helper(m, n):\n            if (m, n) not in cache:\n                # cache[m,n] = []\n                if n == 1:\n                    cache[m,n] = 1\n                else:\n                    for nn in next[m]:\n                        # for e in helper(nn, n-1):\n                        #     cache[m,n].append([m] + e)\n                        cache[m,n] += helper(nn, n-1)\n                cache[m,n] %= M\n            return cache[m,n] \n\n        # res = []\n        # for i in range(10):\n        #    res.extend(helper(i, n))\n        # return res\n\n        return sum(helper(i, n) for i in range(10)) % M", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1: return 10\n        hash_map = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(0,3,9),5:(),6:(0,1,7),7:(2,6),8:(1,3),9:(2,4)}\n        \n        dp = {}\n        def ways_n(n,val):\n            if n==0:\n                return 1\n            \n            if (n,val) in dp:\n                return dp[n,val]\n            \n            dp[n,val] = 0\n            for i in hash_map[val]:\n                dp[n,val] += ways_n(n-1,i)\n            return dp[n,val]\n        \n        ans = 0\n        for i in range(10):\n            ans+=ways_n(n-1,i)\n        return ans%(10**9+7)\n    \n", "class Solution:\n    def getAccessible(self, key):\n        switch = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6]\n        }\n        return switch.setdefault(key, [])\n        \n    def knightDialer(self, n: int) -> int:\n        dp = [[0]*10 for _ in range(n)]\n        dp[0] = [1]*10\n        \n        for r in range(1,len(dp)):\n            for c in range(len(dp[0])):\n                neighbors = self.getAccessible(c)\n                for n in neighbors:\n                    dp[r][c] = dp[r-1][n] + (dp[r][c] % (10**9 + 7))\n        return sum(dp[-1]) % (10**9 + 7)\n        \n                \n                \n            \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        possible_ways = {1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\n        remember_dict = {}\n        def numofways(N, startnum):\n            if (startnum,N) in remember_dict:\n                return remember_dict[(startnum,N)]\n            if N == 1:\n                return 1\n            else:\n                temp = 0\n                for nextnum in possible_ways[startnum]:\n                    temp += numofways(N-1,nextnum)\n                remember_dict[(startnum,N)] = temp   \n                return temp\n        summation = 0\n        for i in range(10):\n            summation += numofways(N, i)\n        return summation % 1000000007\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        cache = [[0 for i in range(n+1)] for i in range(10)]\n        for i in range(10):\n            cache[i][1] = 1\n        return self.hopper(n, cache) % (10 ** 9 + 7)\n    \n    def hopper(self, hops_left, cache):\n                \n        if hops_left == 1:\n            return sum([cache[i][1] for i in range(10)])\n        elif hops_left < 1:\n            return 0\n        else:\n            for i in range(2, hops_left+1):\n                for j in range(10):\n                    for nbr in self.nbrs(j):\n                        cache[j][i] += cache[nbr][i-1]\n                    \n        return sum([cache[i][hops_left] for i in range(10)])\n    \n    \n    def nbrs(self, ind):\n        nbrs = {0: [4,6],\n                1: [6, 8],\n                2: [9, 7],\n                3: [4, 8],\n                4: [3, 9, 0],\n                5: [],\n                6: [1,7, 0],\n                7: [6, 2],\n                8: [1, 3],\n                9: [4, 2]}\n        \n        return nbrs[ind]\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n      moves = {\n        0: [4, 6],\n        2: [7, 9],\n        1: [6, 8],\n        3: [4, 8],\n        4: [0, 3, 9],\n        5: [],\n        6: [0, 1, 7],\n        7: [2, 6],\n        8: [1, 3],\n        9: [2, 4]\n      }        \n      \n      store = {}\n      def f(num, rem):\n        if rem == 1: return 1 \n        if (num, rem) in store: return store[(num, rem)]\n        res = store[(num, rem)] = sum([f(m, rem - 1) for m in moves[num]])\n        return res\n      \n      return sum([f(num, n) for num in range(10)]) % (10 ** 9 + 7)\n        \n        \n        \n        \n      \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        \n        hop_map = {1:[6,8],\n                  2:[7,9],\n                  3:[4,8],\n                  4:[0,3,9],\n                  5:[],\n                  6:[0,1,7],\n                  7:[2,6],\n                  8:[1,3],\n                  9:[2,4],\n                  0:[4,6]}\n        \n        memo = {(i,1): 1 for i in range(10)}\n        \n        def num_hops(key:int, N:int):\n            \n            if N == 1:\n                return memo[(key, 1)]\n            if (key, N) in memo:\n                return memo[(key, N)]\n            \n            sum_ = 0\n            for v in hop_map[key]:\n                sum_ += num_hops(v, N-1)\n            \n            memo[(key, N)] = sum_ % (10**9 + 7)\n            return sum_\n    \n        sum_ = 0\n        for i in range(10):\n            sum_ += num_hops(i, N)  % (10**9 + 7)\n        return sum_  % (10**9 + 7)\n", "class Solution:\n    arr = None\n    \n    def knightDialer(self, n: int) -> int:\n        self.init_arr(n)\n        if n == 1:\n            return 10\n        \n        total = 0\n        \n        for j in range(2, n+1):\n            for i in range(10):\n                self.dialStart(i, j)\n        \n        return self.get_ans(n)\n    \n    def get_ans(self, n):\n        total = 0\n        for i in range(10):\n            total = (total + self.arr[i][n]) % 1000000007\n        return total\n    \n    def init_arr(self, n):\n        self.arr = [[0]*(n+1) for i in range(10)]\n        \n        for i in range(10):\n            self.arr[i][1] = 1\n    \n    def dialStart(self, start: int, n: int):\n        neighbours = self.get_neighbours()\n\n        total = 0\n        for ne in neighbours[start]:\n            total = (total + self.arr[ne][n-1]) % 1000000007\n        \n        self.arr[start][n] = total\n    \n    def get_neighbours(self):\n        return {\n            0: [4, 6],\n            1: [8, 6],\n            2: [7, 9],\n            3: [8, 4],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n        }\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        move = [1]*10\n        for i in range(n-1):\n            new_move = [1]*10\n            new_move[0], new_move[1] = (move[4]+move[6])%(10**9 + 7), (move[8]+move[6])%(10**9 + 7)\n            new_move[2], new_move[3] = (move[7]+move[9])%(10**9 + 7), (move[8]+move[4])%(10**9 + 7)\n            new_move[4], new_move[5] = (move[0]+move[3]+move[9])%(10**9 + 7), 0\n            new_move[6], new_move[7] = (move[0]+move[1]+move[7])%(10**9 + 7), (move[2]+move[6])%(10**9 + 7)\n            new_move[8], new_move[9] = (move[1]+move[3])%(10**9 + 7), (move[2]+move[4])%(10**9 + 7)\n            move = new_move\n        return sum(move) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        if N == 1:\n            return 10\n        \n        navigation = {\n            0: [4, 6],\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n        }\n        \n        memo = {}\n        \n        def get_num_distinct_dials(last_digit, N_left):\n            if N_left == 0:\n                return 1\n            \n            memo_key = (last_digit, N_left)\n            if memo_key in memo:\n                return memo[memo_key]\n            \n            result = sum([get_num_distinct_dials(next_digit, N_left - 1) for next_digit in navigation[last_digit]])\n            memo[memo_key] = result\n            return result\n        \n        return sum([get_num_distinct_dials(first_digit, N - 1) for first_digit in navigation.keys()]) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        moves = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n                \n        dp1 = [1] * 10\n        for i in range(n - 1):  # do n - 1 times \n            dp2 = [0] * 10\n            for digit in range(10):\n                for neib in moves[digit]:\n                    dp2[digit] += dp1[neib]\n                    dp2[digit] %= pow(10, 9) + 7\n            dp1 = dp2\n        \n        return (sum(dp1)) % (pow(10, 9) + 7)\n        \n", "MAX = 10**9 + 7\n\nd = [\n    [4, 6],\n    [6, 8],\n    [7, 9],\n    [4, 8],\n    [3, 9, 0],\n    [],\n    [1, 7, 0],\n    [2, 6],\n    [1, 3],\n    [2, 4],\n    [4, 6]\n]\n\n\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n    \n    def knightDialer(self, n: int) -> int:\n        return sum([self.helper(n, p) for p in range(10)]) % MAX\n    \n    def helper(self, n: int, p: int) -> int:\n        if (n, p) in self.memo: return self.memo[(n, p)]\n        if n == 1: return 1\n        r = sum([self.helper(n - 1, q) for q in d[p]])\n        self.memo[(n, p)] = r\n        return r", "MAX = 10**9 + 7\n\nd = {\n    1: [6, 8],\n    2: [7, 9],\n    3: [4, 8],\n    4: [3, 9, 0],\n    5: [],\n    6: [1, 7, 0],\n    7: [2, 6],\n    8: [1, 3],\n    9: [2, 4],\n    0: [4, 6]\n}\n\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n    \n    def knightDialer(self, n: int) -> int:\n        return sum([self.helper(n, p) for p in d.keys()]) % MAX\n    \n    def helper(self, n: int, p: int) -> int:\n        if (n, p) in self.memo: return self.memo[(n, p)]\n        if n == 1: return 1\n        r = sum([self.helper(n - 1, q) for q in d[p]])\n        self.memo[(n, p)] = r\n        return r", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        graph = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,9,3],5:[],6:[0,7,1],7:[2,6],8:[1,3],9:[4,2]}\n        \n        ans = 0\n        \n        self.cache = {}\n        \n        for u in graph.keys():\n            \n            ans += self.dial(graph,u,n-1)\n        \n        return ans % (10**9 + 7)\n    \n    def dial(self,graph,start,n):\n        \n        if n == 0:\n            return 1\n        \n        ans = 0\n        \n        key = str(start) + ' ' + str(n)\n        \n        if key in self.cache.keys():\n            \n            return self.cache[key]\n        \n        for v in graph[start]:\n            ans += self.dial(graph,v,n-1)\n            \n        self.cache[key] = ans\n            \n        return self.cache[key]", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        graph = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,9,3],5:[],6:[0,7,1],7:[2,6],8:[1,3],9:[4,2]}        \n        ans = 0\n        self.cache = {}\n        for u in list(graph.keys()):\n            ans += self.dial(graph,u,n-1)\n            \n        return ans % (10**9 + 7)\n        \n    def dial(self,graph,start,n):\n        \n        if n == 0:\n            return 1\n        \n        ans = 0\n        \n        key = str(start) + ' ' + str(n)\n        \n        if key in list(self.cache.keys()):\n            \n            return self.cache[key]\n        \n        for v in graph[start]:\n            ans += self.dial(graph,v,n-1)\n            \n        self.cache[key] = ans\n            \n        return self.cache[key]\n#         pkey = str(i) + '-' + str(j) + '-' + str(n)\n        \n#         if pkey in self.dp.keys():\n#             return self.dp[pkey]\n\n\n#         for dx,dy in self.dirs:\n#             x = i + dx\n#             y = j + dy\n#             temp = 0    \n#             if 0 <= x <= self.m -1 and 0 <= y <= self.n-1 and self.numpad[x][y] != -1:\n#                 key = str(x) + '-' + str(y) + '-' + str(n-1)\n#                 if key in self.dp.keys():\n#                     temp =  self.dp[key]\n#                 else:\n#                     temp =  self.solve(x,y,n-1)           \n#                     self.dp[key] = temp\n#             ans += temp\n            \n#         self.dp[pkey] = ans\n        \n\n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        # pad = [['1','2','3'],['4','5','6'],['7','8','9'],['*','0','#']]\n        \n        graph = {0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,9,3],5:[],6:[0,7,1],7:[2,6],8:[1,3],9:[4,2]}\n        \n        # self.dirs = [(1,2),(2,1),(-1,2),(-2,1),(-1,-2),(-2,-1),(2,-1),(1,-2)]\n        \n        ans = 0\n        \n        self.cache = {}\n        \n        for u in list(graph.keys()):\n            \n            ans += self.dial(graph,u,n-1)\n        \n        return ans % (10**9 + 7)\n    \n    def dial(self,graph,start,n):\n        \n        if n == 0:\n            return 1\n        \n        ans = 0\n        \n        key = str(start) + ' ' + str(n)\n        \n        if key in list(self.cache.keys()):\n            \n            return self.cache[key]\n        \n        for v in graph[start]:\n            ans += self.dial(graph,v,n-1)\n            \n        self.cache[key] = ans\n            \n        return self.cache[key]\n                \n            \n            \n        \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod_num = 10 ** 9 + 7\n        moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1)]\n        cells = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 1)]\n        cell2idx = {}\n        for i, cell in enumerate(cells):\n            cell2idx[cell] = i \n        # number of sequences end at cell\n        sequences = [1 for _ in cells]\n        for step in range(n - 1):\n            new_sequences = [0 for _ in cells]\n            for i, (r, c) in enumerate(cells):\n                for rm, cm in moves:\n                    newr = r + rm\n                    newc = c + cm\n                    if (newr, newc) in cell2idx:\n                        new_idx = cell2idx[(newr, newc)]\n                        new_sequences[new_idx] += sequences[i]\n            sequences = [cnt % mod_num for cnt in new_sequences]\n        return sum(sequences) % mod_num\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        myMap = {1: [8, 6], \n                 2: [7, 9],\n                 3: [4, 8],\n                 4: [0, 3, 9],\n                 5: [], \n                 6: [0, 1, 7], \n                 7: [2, 6], \n                 8: [1, 3], \n                 9: [2, 4], \n                 0: [4, 6], \n                 -1: list(range(10))}\n        cache = {}\n        \n        def dfs(start, level):\n            if level == 0:\n                return 1 \n            key = str(start) + str(level)\n\n            ans = 0 \n            for number in myMap[start]:\n                nextK = str(number) + str(level-1)\n                if nextK in cache:\n                    ans += cache[nextK]\n                else:\n                    ans += dfs(number, level - 1)\n            cache[key] = ans \n            return ans \n            \n        total = dfs(-1, N)\n        return total % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        move = [1]*10\n        for i in range(n-1):\n            new_move = [1]*10\n            new_move[0], new_move[1] = (move[4]+move[6])%(10**9 + 7), (move[8]+move[6])%(10**9 + 7)\n            new_move[2], new_move[3] = (move[7]+move[9])%(10**9 + 7), (move[8]+move[4])%(10**9 + 7)\n            new_move[4], new_move[5] = (move[0]+move[3]+move[9])%(10**9 + 7), 0\n            new_move[6], new_move[7] = (move[0]+move[1]+move[7])%(10**9 + 7), (move[2]+move[6])%(10**9 + 7)\n            new_move[8], new_move[9] = (move[1]+move[3])%(10**9 + 7), (move[2]+move[4])%(10**9 + 7)\n            move = new_move\n        return sum(move) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        choices = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [0, 1, 7],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        \n        self.memo = dict()\n        \n        def dfs(curr, n):\n            key = (curr, n)\n            if key in self.memo:\n                return self.memo[key]\n            \n            if n == 1:\n                return 1\n            \n            sub = 0\n            for next in choices[curr]:\n                sub += dfs(next, n - 1)\n            \n            self.memo[key] = sub\n            return sub\n        \n        res = 0\n        for s in range(10):\n            res += dfs(s, N)\n                \n        return res % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        space = {1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 5:[], 6:[0,7,1], 7:[2,6],8:[1,3],9:[4,2],0:[4,6]}\n        memory = {}\n        if n < 1:\n            return 0\n        \n        def recurse(number, n):\n            if n < 2:\n                return 1\n            \n            key = str([number,n])\n            if key in memory:\n                return memory[key]\n            \n            moves = 0\n            for i in space[number]:\n                moves+= recurse(i,n-1)\n    \n            memory[key] = moves\n            return moves\n        \n        s = 0\n        for number in space:\n            s+= recurse(number, n)\n        \n        return s % (10**9 + 7)", "class Solution:\n  def knightDialer(self, N: int) -> int:\n    if N == 0:\n      return 0\n    d = {}\n    choices = [\n      [4, 6],\n      [6, 8],\n      [7, 9],\n      [4, 8],\n      [0, 3, 9],\n      [],\n      [0, 1, 7],\n      [2, 6],\n      [1, 3],\n      [2, 4]\n    ]\n    def dp(k, n):\n      if n == 0:\n        return 1\n      if n == 1:\n        return len(choices[k])\n      if (k, n) not in d:\n        d[(k, n)] = sum([dp(nxt, n-1) for nxt in choices[k]])\n      return d[(k, n)]\n    return sum([dp(v, N-1) for v in range(10)]) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        cell2jump = dict()\n        cell2jump[1] = [6, 8]\n        cell2jump[2] = [7, 9]\n        cell2jump[3] = [4, 8]\n        cell2jump[4] = [3, 9, 0]\n        cell2jump[5] = []\n        cell2jump[6] = [1, 7, 0]\n        cell2jump[7] = [2, 6]\n        cell2jump[8] = [1, 3]\n        cell2jump[9] = [2, 4]\n        cell2jump[0] = [4, 6]\n        \n        # dp[n, i] = helper(n, i)\n        dp = defaultdict()\n        \n        def helper(num_jumps, cell):\n            # return number of jumps if place at cell and have num_jumps remaining\n            if num_jumps == 1:\n                return 1\n            elif num_jumps == 2:\n                return len(cell2jump[cell])\n    \n            if (num_jumps, cell) in dp:\n                return dp[num_jumps, cell]\n            \n            res = 0\n            for nei in cell2jump[cell]:\n                res += helper(num_jumps-1, nei)\n            \n            dp[num_jumps, cell] = res\n            return res\n        \n        total = []\n        for i in range(10):\n            total.append(helper(n, i))\n\n    \n        return sum(total) % (10**9 + 7)\n", "from functools import lru_cache\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        to = { 0: (4, 6), 1: (6, 8), 2: (7, 9), 3: (4, 8), 4: (0, 3, 9), 5: (), 6: (0, 1, 7), 7: (2, 6), 8: (1, 3), 9: (2, 4) }\n        \n        @lru_cache(maxsize=None)\n        def dfs(i: int, k: int) -> int:\n            if i not in to: return 0\n            if k == 1: return 1\n            return sum([dfs(t, k-1) for t in to[i]])\n        return sum([dfs(i, n) for i in range(10)]) % (10**9 + 7)", "class Solution:\n    \n    def knightDialer(self, N: int) -> int:\n            \n        mod= (10**9)+7\n        def getNeighbors(N):\n            neighs=[[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\n            return neighs[N]\n        \n        def getCount(start,n):\n            \n            if (start,n) not in dic:\n                \n                if n==0:\n                    dic[(start,n)]=1\n                else:\n                    count=0\n                    for nei in  getNeighbors(start):\n                        count+=getCount(nei,n-1)\n                    dic[(start,n)]=count\n                        \n            return dic[(start,n)]\n                    \n                \n                \n        dic={}\n        val=0\n        for i in range(10):\n            val+=getCount(i,N-1)\n            \n        return val%mod", "from functools import lru_cache\n\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        \n        @lru_cache(maxsize=None)\n        def dfs(s, n):\n            if n == 0:\n                return 1\n            # for v in moves[s]:\n            return sum([dfs(v, n-1) for v in moves[s]])\n            \n        answer = 0\n        for i in range(10):\n            answer += dfs(i, N-1)\n            answer %= 10 ** 9 + 7\n            \n        return answer % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        parent_child_dict = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [3, 9, 0], 5: [], 6: [1, 7, 0], 7: [2, 6], 8: [1, 3], 9: [2, 4]}\n        \n        dp = [[0] * 10 for _ in range(N)]\n        for j in range(10):\n            dp[0][j] = 1\n            \n        for i in range(N - 1):\n            for j in range(10):\n                children = parent_child_dict[j]\n                for child in children:\n                    dp[i + 1][child] += dp[i][j]\n                dp[i][j] = dp[i][j] % (10 ** 9 + 7)\n        \n        return sum(dp[N - 1]) % (10 ** 9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n#         board = [[str(j) for j in (1 + 3*i, 3*i + 2, 3*i + 3)] for i in range(3)]\n#         board.append(['*', '0', '#'])\n#         direct = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n        \n#         dp = {}\n#         def dfs(i, j, step):\n           \n#             if i < 0 or i > 3 or j < 0 or j > 2: return 0\n#             if board[i][j] in '*#': return 0\n#             if step == 1: return 1\n#             key = (board[i][j], step)\n#             if key in dp: return dp[key]\n#             dest = set([(i + dr, j + dc) for  dr, dc in direct])\n#             dp[key] = sum([dfs(r, c, step - 1) for r, c in dest])\n#             return dp[key]\n        \n#         res = 0\n#         for i in range(10):\n#             res += dfs(str(i), n)\n#         return res%(10**9 + 7)\n        dp  = {}\n        def nextStep(k):\n            if k == 1: return [6, 8]\n            if k == 2: return [7, 9]\n            if k == 3: return [4, 8]\n            if k == 4: return [9, 3, 0]\n            if k == 6: return [7,1,0]\n            if k == 7: return [6,2]\n            if k == 8: return [1,3]\n            if k == 9: return [4,2]\n            if k == 0: return [4, 6]\n            \n        def dfs(k, step):\n            if k == 5 and step > 1: return 0\n            if step == 1: return 1\n            key = (k, step)\n            if key in dp: return dp[key]\n            dp[key] = sum([dfs(e, step - 1) for e in nextStep(k)])  \n            return dp[key]\n        res = 0\n        for i in range(10):\n            # if i ==5:continue\n            res += dfs(i, n)\n        return res%(10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = {i:1 for i in range(10)}\n        mod = 10**9+7\n        for _ in range(1, n):\n            dp2 = {}\n            dp2[0] = (dp[4]+dp[6])%mod\n            dp2[1] = (dp[6]+dp[8])%mod\n            dp2[2] = (dp[7]+dp[9])%mod\n            dp2[3] = (dp[4]+dp[8])%mod\n            dp2[4] = (dp[0]+dp[3]+dp[9])%mod\n            dp2[5] = 0\n            dp2[6] = (dp[0]+dp[1]+dp[7])%mod\n            dp2[7] = (dp[2]+dp[6])%mod\n            dp2[8] = (dp[1]+dp[3])%mod\n            dp2[9] = (dp[2]+dp[4])%mod\n            dp = dp2\n            \n        return sum(dp.values())%mod", "NEIGHBORS_MAP = {\n    1: (6, 8),\n    2: (7, 9),\n    3: (4, 8),\n    4: (3, 9, 0),\n    5: tuple(),  # 5 has no neighbors\n    6: (1, 7, 0),\n    7: (2, 6),\n    8: (1, 3),\n    9: (2, 4),\n    0: (4, 6),\n}\n\n\ndef neighbors(position):\n    return NEIGHBORS_MAP[position]\n\n\nclass Solution:\n    def knightDialer(self, num_hops):\n        cache = {}\n        mod = 10**9 + 7\n\n        def helper(position, num_hops):\n            if (position, num_hops) in cache:\n                return cache[(position, num_hops)]\n            if num_hops == 0 or num_hops == 1:\n                return 1\n            num_sequences = 0\n            for neighbor in neighbors(position):\n                num_sequences += helper(neighbor, num_hops - 1)\n            cache[(position, num_hops)] = num_sequences\n            # print(cache)\n            return num_sequences\n\n        res = 0\n        for i in range(0, 10):\n            res += helper(i, num_hops)\n        # print(res, cache)\n        return res % mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        Mod = 10**9+7\n        dirs = [(-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1)]\n        dp = [[1]*3 for _ in range(4)]\n        dp[3][0] = 0\n        dp[3][2] = 0\n        \n        for k in range(1,n):\n            temp = [[0]*3 for _ in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if i == 3 and j != 1: continue \n                    for x, y in dirs:\n                        nx = i+x\n                        ny = j+y\n                        if nx<0 or nx>=4 or ny<0 or ny>=3: continue\n                        temp[i][j] = (temp[i][j] + dp[nx][ny])%Mod\n            dp = temp[:]\n        \n        print(dp)\n        ans = 0\n        for i in range(4):\n            for j in range(3):\n                ans = (ans + dp[i][j])%Mod\n        return ans ", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        modulo = pow(10,9)  + 7\n        def get_position(pos):\n            _map= {0: [4, 6],\n                    1: [8, 6],\n                    2: [7, 9],\n                    3: [4, 8],\n                    4: [3, 9, 0],\n                    5: [],\n                    6: [1,7,0],\n                    7: [2,6],\n                    8: [1,3],\n                    9: [4,2],\n                   }\n            return _map[pos]\n        cache = {}\n        def solve(pos, step):\n            key = (pos, step)\n            if key not in cache:\n                if step>=n:\n                    return 1\n                res = 0\n                for i in get_position(pos):\n                    res += solve(i, step + 1)\n                    res = res % modulo\n                cache[key] = res\n            return cache[key]\n        res = 0\n        \n        for i in range(10):\n            res += solve(i, 1)\n        return res % modulo", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1: return 10\n        self.mod = 1e9 + 7\n        self.cache = {}\n        self.knight_steps = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [2, 4],\n            0: [4, 6]\n        }\n        count = 0\n        for i in range(10):\n            count += self.recursive_calc(i, n - 1) \n            count = count % self.mod\n            \n        # print(self.cache)\n        return int(count % self.mod)\n        \n    \n    def recursive_calc(self, current_number, steps):\n        if steps == 0: return 1\n        if (current_number, steps) in self.cache:\n            return self.cache[(current_number, steps)]\n        total = 0\n        for i in self.knight_steps[current_number]:\n            total += self.recursive_calc(i, steps - 1)\n            total = total % self.mod\n        self.cache[(current_number, steps)] = total\n        return self.cache[(current_number, steps)]", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        # https://blog.csdn.net/fuxuemingzhu/article/details/83716573\n        self.ans = dict()\n        self.ans[0] = 10\n        board = [[1] * 3 for _ in range(4)]\n        board[3][0] = board[3][2] = 0\n        pre_dict = {(i, j) : self.prevMove(i, j) for i in range(4) for j in range(3)}\n        for n in range(1, n):\n            new_board = copy.deepcopy(board)\n            for i in range(4):\n                for j in range(3):\n                    cur_move = 0\n                    for x, y in pre_dict[(i, j)]:\n                        cur_move = (cur_move + board[x][y]) % (10 ** 9 + 7)\n                    new_board[i][j] = cur_move\n            board = new_board\n        return sum([board[i][j] for i in range(4) for j in range(3)]) % (10 ** 9 + 7)\n        \n    def prevMove(self, i, j):\n        if (i, j) == (3, 0) or (i, j) == (3, 2):\n            return []\n        directions = [(-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1)]\n        res = []\n        for d in directions:\n            x, y = i + d[0], j + d[1]\n            if 0 <= x < 4 and 0 <= y < 3 and (x, y) != (3, 0) and (x, y) != (3, 2):\n                res.append((x, y))\n        return res\n", "from functools import lru_cache\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        @lru_cache(None)\n        def _jump(row, col, remaining):\n            if remaining == 1:\n                return 1\n            total = 0\n            for dr, dc in (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2):\n                if (\n                    0 <= row + dr < m and 0 <= col + dc < n and pad[row + dr][col + dc]\n                ):\n                    total += _jump(row + dr, col + dc, remaining - 1)\n            return total % MAX\n\n        MAX = 10**9 + 7\n        pad = [\n            [1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1],\n            [0, 1, 0]\n        ]\n        m, n = len(pad), len(pad[0])\n        total = 0\n        for i in range(m):\n            for j in range(n):\n                if pad[i][j]:\n                    total += _jump(i, j, N)\n        return total % MAX", "class Solution:  \n    def knightDialer(self, N: int) -> int:\n        total = 0\n        places = {1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0], 6:[1,7,0], 7:[2,6], 8:[1,3], 9:[2,4], 0: [4,6]}\n        if N == 1:\n            return 10\n        dp = [1]*10\n        for i in range(2, N+1):\n            tmp_dp = [0]*10\n            for i in range(0, 10):\n                \n                if i != 5:\n                    neighbors = places.get(i)\n                    curr = 0\n                    for n in neighbors:\n                        curr += dp[n]\n                    tmp_dp[i] = curr\n            dp = copy.deepcopy(tmp_dp)\n        \n        return sum(dp) % (10**9 + 7)\n                    \n                \n        \n", "class Solution:\n    def __init__(self):\n        self.memory = {}\n    def knightDialer(self, n: int) -> int:\n        steps = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,9,3],\n            5: [],\n            6: [7,1,0],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        def kDialer(i, n, steps,c):\n            if n==1:\n                return 1\n            if n==0:\n                return 0\n            if (i, n) in self.memory:\n                return self.memory[(i, n)]\n            self.memory[(i, n)] = 0\n            for j in steps[i]:\n                self.memory[(i, n)]+= kDialer(j, n-1, steps,c)%c\n            self.memory[(i, n)] = self.memory[(i, n)]%c\n            return self.memory[(i, n)]\n        \n        combinations = 0\n        for i in range(0, 10):\n            combinations+=kDialer(i, n, steps, (10**9) + 7)%((10**9) + 7)\n        \n        return combinations%((10**9) + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = {(0,0):1, (0,1):1, (0,2):1, \n              (1,0):1, (1,1):1, (1,2):1, \n              (2,0):1, (2,1):1, (2,2):1, \n              (3,1):1}\n        for x in range(1, n):\n            temp = {}\n            for r in range(4):\n                for c in range(3):\n                    if (r == 3 and c == 0) or (r==3 and c == 2):\n                        continue\n                    sm = 0\n                    for i in (1,-1):\n                        for j in (2, -2):\n                            sm = sm + dp.get((r+i, c+j), 0) + dp.get((r+j, c+i), 0)\n                    temp[(r,c)] = sm\n            dp = temp\n        return sum(dp.values())%(10**9 + 7)      \n", "from functools import reduce\n\ndef make_grid():\n    g = [[1] * 3 for _ in range(4)]\n    g[3][0] = None\n    g[3][2] = None\n    return g\n\nMOVES = [\n    (2, 1),\n    (2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n    (-2, 1),\n    (-2, -1),\n] \n\n# def jump(grid):\n#     for i in range(4):\n#         for j in range(3):\n#             if grid[i][j] is not None:\n#                 for di, dj in MOVES:\n#                     ni = i+di\n#                     nj = j+dj\n#                     if (0 <= ni < 4) and (0 <= nj < 3) and (grid[ni][nj] is not None):\n#                         grid[ni][nj] += 1\n                \ndef jump(grid):\n    new_grid = make_grid()\n    for i in range(4):\n        for j in range(3):\n            if grid[i][j] is not None:\n                c = 0\n                for di, dj in MOVES:\n                    ni = i+di\n                    nj = j+dj\n                    if (0 <= ni < 4) and (0 <= nj < 3) and (grid[ni][nj] is not None):\n                        #grid[ni][nj] += 1\n                        c += grid[ni][nj]\n                new_grid[i][j] = c\n    return new_grid\n                \n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        grid = make_grid()\n        m = 10**9 + 7\n        \n        c = 0\n        for _ in range(n-1):\n            grid = jump(grid)\n            c += 10\n        \n        print(grid)\n        \n        return sum([sum([c for c in row if c]) for row in grid]) % m#- c\n        #for _ in range(n):\n        #    jump(grid)\n        #\n        #return reduce(list.__add__, [[c for c in row] for row in grid])\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        limit = 10**9+7\n        # print(limit)\n        direction = [(1,2),(-1,2),(1,-2),(-1,-2),(2,-1),(2,1),(-2,1),(-2,-1)]\n        dp = [[1 for i in range(3)] for j in range(4)]\n        dp[3][0],dp[3][2] = 0,0\n        for i in range(n-1):\n            temp = [[0 for i in range(3)] for j in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if i ==3 and j !=1:\n                        continue\n                    for di,dj in direction:\n                        new_i,new_j = di+i,dj+j\n                        if 0<=new_i<4 and 0 <= new_j <3:\n                            temp[i][j] = (temp[i][j] + dp[new_i][new_j])%limit\n            dp = temp[:]\n        res = 0\n        for i in range(4):\n            for j in range(3):\n                res+=dp[i][j]\n        return res%limit\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        limit = 10**9+7\n        dp = [[1 for i in range(3)] for j in range(4)]\n        dp[3][0],dp[3][2] = 0,0\n        direction = [(1,2),(-1,2),(1,-2),(-1,-2),(2,-1),(2,1),(-2,1),(-2,-1)]\n        for k in range(n-1):\n            temp = [[0 for i in range(3)] for j in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if i == 3 and j != 1:\n                        continue\n                    for di,dj in direction:\n                        new_i,new_j = di+i,dj+j\n                        if 0<= new_i< 4 and 0<= new_j<3:\n                            temp[i][j] = (temp[i][j]+dp[new_i][new_j])%limit\n            dp = temp[:]\n        res = 0\n        for i in range(4):\n            for j in range(3):\n                res+= dp[i][j]\n        return res%limit", "class Solution:\n    dic = {}\n    dic[1] = [6,8]\n    dic[2] = [7,9]\n    dic[3] = [4,8]\n    dic[4] = [0,3,9]\n    dic[5] = []\n    dic[6] = [0,1,7]\n    dic[7] = [2,6]\n    dic[8] = [1,3]\n    dic[9] = [2,4]\n    dic[0] = [4,6]\n    \n    \n    \n    def knightDialer(self, n: int) -> int:\n        mem = defaultdict(int)\n        \n        for j in range(10):\n            mem[(1,j)] = 1\n        \n        for i in range(1,n):\n            for j in range(10):\n                for num in self.dic[j]:\n                    mem[(i+1,num)] += mem[(i,j)]\n                    mem[(i+1,num)] = mem[(i+1,num)] %(10**9+7)\n        \n        res = 0\n                \n        for i in range(10):\n            res += mem[(n,i)]\n            res = res%(10**9+7)\n        \n        return res", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        MOD = 10**9 + 7\n        # dp = [ [[0]*3 for _2 in range(4)]   for _ in range(N)]\n        dp = [[0]*3 for _2 in range(4)]\n        for i in range(4):\n            for j in range(3):\n                if (i,j) in [(3,0),(3,2)]:\n                    continue\n                dp[i][j] = 1\n        \n        for k in range(1,N):\n            new_dp = [[0]*3 for _2 in range(4)]\n            for i in range(3):\n                for j in range(i,3):\n                    # print(i,j)\n                    a = [[i+2,j+1],[i+2,j-1],[i-2,j+1],[i-2,j-1],\n                         [i+1,j+2],[i-1,j+2],[i+1,j-2],[i-1,j-2]]\n                    for p in a:\n                        if not(0 <= p[0] < 4) or not(0 <= p[1] < 3):\n                            continue\n                        new_dp[i][j] += dp[p[0]][p[1]] % MOD\n                        # new_dp[j][i] = new_dp[i][j]\n            new_dp[1][0] = new_dp[1][2]\n            new_dp[2][0] = new_dp[2][2]\n            new_dp[2][1] = new_dp[0][1]\n            i = 3\n            j = 1\n            new_dp[3][1] = (dp[1][2] + dp[1][0]) % MOD\n            dp = new_dp\n            # print(dp)\n            \n        s = 0\n        # dp[3][0] = dp[N-1][3][2] = 0\n        for i in dp:\n            for j in i:\n                s += j % MOD\n        return s % MOD\n    \n        \n        # cac = {}\n        # MOD = 10**9 + 7\n        # def d(k,i,j):\n        #     try:\n        #         return cac[(k,i,j)]\n        #     except:\n        #         pass\n        #     if (i,j) in [(3,0),(3,2)]:\n        #         return 0\n        #     if not(0 <= i < 4) or not(0 <= j < 3):\n        #         return 0\n        #     if k == 0:\n        #         return 1\n        #     temp = 0\n        #     temp += d(k-1,i+2,j+1) % MOD\n        #     temp += d(k-1,i+2,j-1) % MOD\n        #     temp += d(k-1,i-2,j+1) % MOD\n        #     temp += d(k-1,i-2,j-1) % MOD\n        #     temp += d(k-1,i+1,j+2) % MOD\n        #     temp += d(k-1,i-1,j+2) % MOD\n        #     temp += d(k-1,i+1,j-2) % MOD\n        #     temp += d(k-1,i-1,j-2) % MOD\n        #     cac[(k,i,j)] = temp\n        #     return temp\n        # ans = 0\n        # for i in range(4):\n        #     for j in range(3):\n        #         ans += d(N-1,i,j) % MOD\n        # return ans % MOD\n", "class Solution:\n    def __init__(self):\n        self.moves = [ \n            [4,6],\n            [8,6],\n            [7,9],\n            [4,8],\n            [9,3,0],\n            [],\n            [7,1,0],\n            [6,2],\n            [1,3],\n            [2,4],\n        ]\n        \n        self.memoized_results= {}\n    \n    def knightDialer(self, n: int) -> int:\n        total_moves = 0\n        for number in range(10):\n            moves = self.knightDialerOnOneDigit(number, n-1)\n            total_moves += moves\n        return(total_moves%(pow(10,9) +7))\n        \n    \n    def knightDialerOnOneDigit(self, current_number, remaining_moves):\n        if remaining_moves == 0:\n            return 1\n        \n        moves = 0\n        for number in self.moves[current_number]:\n            if (number, remaining_moves-1) in list(self.memoized_results.keys()):\n                new_moves = self.memoized_results[(number, remaining_moves-1)]\n            else:\n                new_moves = self.knightDialerOnOneDigit(number, remaining_moves-1)\n                self.memoized_results[(number, remaining_moves-1)] = new_moves\n            moves += new_moves\n        return moves\n        \n        \n", "MOD = 10**9 + 7\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        @lru_cache(None)\n        def dfs(i, j, k):\n            # base case\n            if k == n - 1:\n                return 1\n            # recursion\n            res = 0\n            for di, dj in [(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)]:\n                ni, nj = i + di, j + dj\n                if not (0 <= ni < 4 and 0 <= nj < 3):\n                    continue\n                if (ni, nj) in [(3, 0), (3, 2)]:\n                    continue\n                res += dfs(ni, nj, k + 1)\n                res %= MOD\n            return res\n    \n        ans = 0\n        for i, j in product(range(4), range(3)):\n            if (i, j) in [(3, 0), (3, 2)]:\n                    continue\n            ans += dfs(i, j, 0)\n        return ans % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        M = 4\n        N = 3\n        KMOD = 10 ** 9 + 7\n        dp = [[1 for _ in range(N)] for _ in range(M)] # init as 1 for 0/1 hops\n        dp[3][0] = dp[3][2] = 0\n        directions = [(1, 2), (-1, -2), (1, -2), (-1, 2),\n                      (2, 1), (-2, -1), (2, -1), (-2, 1), ]\n        for _ in range(1, n): # starts from 1 hop\n            cur = [[0 for _ in range(N)] for _ in range(M)] # cur init as 0\n            for i in range(M):\n                for j in range(N):\n                    if i == 3 and (j == 0 or j == 2):\n                        continue\n                    for d in directions:\n                        x = i + d[0]\n                        y = j + d[1]\n                        if 0 <= x < M and 0 <= y < N:\n                            cur[i][j] += dp[x][y]\n            dp = cur\n        result = 0\n        for i in range(M):\n            for j in range(N):\n                if i == 3 and (j == 0 or j == 2):\n                    continue\n                result += dp[i][j]\n        return result % KMOD", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        d = [1 for n in range(10)]\n        for i in range(N - 1):\n            (d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9]) = (\n                d[4] + d[6], d[6] + d[8], d[7] + d[9], d[4] + d[8], d[0] + d[3] + d[9],\n                0, d[0] + d[1] + d[7], d[2] + d[6], d[1] + d[3], d[2] + d[4])\n        return sum(d) % (10 ** 9 + 7)        \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        if N == 0:\n            return 0\n        \n        dialer = [[1, 1, 1] for _ in range(4)]\n        directions = [[-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1], [2, 1], [1, 2]]\n        forbidden = set()\n        forbidden.add((3, 0))\n        forbidden.add((3, 2))\n        for _ in range(1, N):\n            tmp = [[0, 0, 0] for _ in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if (i, j) not in forbidden:\n                        for direction in directions:\n                            new_i, new_j = i + direction[0], j + direction[1]\n                            if 0 <= new_i < 4 and 0 <= new_j < 3:\n                                tmp[new_i][new_j] += dialer[i][j]\n            dialer = tmp\n            \n        \n        return (sum(sum(dialer, [])) - dialer[3][0] - dialer[3][2]) % (10 ** 9 + 7)\n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        valid = {\n            1: [8, 6],\n            2: [7, 9],\n            3: [4, 8],\n            4: [3, 9, 0],\n            5: [],\n            6: [1, 7, 0],\n            7: [2, 6],\n            8: [1, 3],\n            9: [4, 2],\n            0: [4, 6]\n        }\n        \n        MOD = 10 ** 9 + 7\n        dp = {}\n        nums = 0\n        \n        def dfs(pos, steps):\n            if steps == 0:\n                return 1\n            if (pos, steps,) in dp:\n                return dp[(pos, steps,)]\n            c = 0\n            for next in valid[pos]:\n                x = dfs(next, steps - 1)\n                dp[(next, steps - 1)] = x\n                c += x\n                c %= MOD\n            dp[(pos, steps,)] = c\n            return c\n        \n        ans = 0\n        for i in range(10):\n            x = dfs(i, n - 1)\n            ans += x\n            ans %= MOD\n        return ans % MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [1 for _ in range(10)]\n        \n        move = [[4,6], [6,8], [7,9], [4,8], [3,9,0], [], [1,7,0], [2,6], [1,3], [4,2]]\n        for i in range(n-1):\n            dp2 = [0] *10\n            for node, count in enumerate(dp):\n                for nei in move[node]:\n                    dp2[nei] += count\n                    dp2[nei] %MOD\n            dp = dp2\n        print(dp)\n        return sum(dp)%MOD", "class Solution(object):\n    def knightDialer(self, N):\n        # Use This Code\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        MOD = 10**9 + 7\n        \n        table = [1]*10 # table[i] = number of way ending in i\n        for _ in range(N-1):\n            temp = [0] * 10\n            for node, count in enumerate(table):\n                for nei in moves[node]:\n                    temp[nei] += count\n                    temp[nei]%MOD\n            table = temp\n            \n        return sum(table)%MOD\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [(-2, 1),(-1, 2),(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1)]\n        \n        previous = {(r, c): 1 for r, c in ((0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,1))}\n        current = {(r, c): 0 for r, c in previous}\n        \n        for i in range(n-1):\n            for (r, c), v in previous.items():\n                for dr, dc in moves:\n                    if (r+dr, c+dc) in current:\n                        current[(r+dr, c+dc)] += v\n                        current[(r+dr, c+dc)] %= 1000000007\n            previous = current\n            current = {(r, c): 0 for r, c in previous}\n                        \n        return sum(previous.values()) % 1000000007", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        keyboard = [[0] * 3 for _ in range(4)]\n        k = 1\n        for i in range(3):\n            for j in range(3):\n                keyboard[i][j] = k\n                k+=1\n        keyboard[-1][0] = -1\n        keyboard[-1][-1] = -1\n        \n        mod = 10**9 + 7\n        count = [[1] * 3 for _ in range(4)]\n        count[-1][0] = 0\n        count[-1][-1] = 0\n        moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(-1,2),(1,-2),(-1,-2)]\n        for k in range(n - 1):\n            tmp_count = [[0] * 3 for _ in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if keyboard[i][j] < 0 :\n                        continue\n                    for mv in moves:\n                        x = i + mv[0]\n                        y = j + mv[1]\n                        if 0<=x<4 and 0<=y<3 and keyboard[x][y]>=0:\n                            tmp_count[x][y] = (tmp_count[x][y] + count[i][j]) % mod\n                            \n            count = tmp_count\n        num_count = 0\n        for r in count:\n            num_count = (num_count + sum(r)) % mod\n        return num_count ", "class Solution:\n    mod = 10 ** 9 + 7\n    phone = [[1,1,1],[1,1,1],[1,1,1],[0,1,0]]\n    moves = ((2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2))\n    def knightDialer(self, n: int) -> int:\n        # memo = {}\n        @lru_cache(None)\n        def helper(row, col, left):\n#             if (row,col,left) in memo:\n#                 return memo[(row,col,left)]\n                \n            # if not 0<=row<=3 or not 0<=col<=2 or Solution.phone[row][col] ==0:\n            #     return 0\n            if left <= 0:\n                return 1\n            ans = 0\n            for r,c in Solution.moves:\n                if 0<=row+r<=3 and 0<=col+c<=2 and Solution.phone[row+r][col+c] ==1:\n                    ans += helper(row+r,col+c,left-1)\n            # memo[(row,col,left)] = ans\n            return ans\n        \n        ans = 0\n        for row in range(4):\n            for col in range(3):\n                if Solution.phone[row][col] == 1:\n                    ans += helper(row, col, n-1)\n        \n        return ans % Solution.mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        cell2jump = dict()\n        cell2jump[1] = [6, 8]\n        cell2jump[2] = [7, 9]\n        cell2jump[3] = [4, 8]\n        cell2jump[4] = [3, 9, 0]\n        cell2jump[5] = []\n        cell2jump[6] = [1, 7, 0]\n        cell2jump[7] = [2, 6]\n        cell2jump[8] = [1, 3]\n        cell2jump[9] = [2, 4]\n        cell2jump[0] = [4, 6]\n        \n        # dp[n, i] = helper(n, i)\n        dp = defaultdict()\n        \n        def helper(num_jumps, cell):\n            # return number of jumps if place at cell and have num_jumps remaining\n            if num_jumps == 0:\n                return 1\n            elif num_jumps == 1:\n                return len(cell2jump[cell])\n            \n            if (num_jumps, cell) in dp:\n                return dp[num_jumps, cell]\n            \n            res = 0\n            for nei in cell2jump[cell]:\n                res += helper(num_jumps-1, nei)\n            \n            dp[num_jumps, cell] = res\n            return res\n        \n        total = []\n        for i in range(10):\n            total.append(helper(n-1, i))\n\n    \n        return sum(total) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n ==1:return 10\n        f1,f2,f3,f4,f6,f7,f8,f9,f0 = [1]*n,[1]*n,[1]*n,[1]*n,[1]*n,[1]*n,[1]*n,[1]*n,[1]*n\n        \n        for j in range(1,n):\n            f0[j] = (f4[j-1]+f6[j-1])%(1e9+7)\n            f1[j] = (f6[j-1]+f8[j-1])%(1e9+7)\n            f2[j] = (f7[j-1]+f9[j-1])%(1e9+7)\n            f3[j] = (f4[j-1]+f8[j-1])%(1e9+7)\n            f4[j] = (f3[j-1]+f9[j-1]+f0[j-1])%(1e9+7)\n            f6[j] = (f1[j-1]+f7[j-1]+f0[j-1])%(1e9+7)\n            f7[j] = (f6[j-1]+f2[j-1])%(1e9+7)\n            f8[j] = (f1[j-1]+f3[j-1])%(1e9+7)\n            f9[j] = (f2[j-1]+f4[j-1])%(1e9+7)\n        \n        # res = 2*(f0[n]+f1[n]+f2[n]+f3[n]+f7[n]+f8[n]+f9[n])+3*(f4[n]+f6[n])\n        res = f0[n-1]+f1[n-1]+f2[n-1]+f3[n-1]+f7[n-1]+f8[n-1]+f9[n-1]+f4[n-1]+f6[n-1]\n        return int(res%(1e9+7))", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        N = n\n        transition = {1:[6,8],\n        2:[7,9],\n        3:[4,8],\n        4:[3,9,0],\n        5:[],\n        6:[1,7,0],\n        7:[2,6],\n        8:[1,3],\n        9:[2,4],\n        0:[4,6]}\n        # key:cur position\n        # value: next position\n        self.count = 0\n        self.mem = {}\n        \n        def dfs(cur,steps):\n            if steps==2:\n                #self.count+=len(transition[cur])\n                return len(transition[cur])\n            else:\n                tmp = 0\n                if (cur,steps) in self.mem:\n                    return self.mem[(cur,steps)]\n                \n                for neigh in transition[cur]:\n                    tmp +=dfs(neigh,steps-1)\n                    #print(tmp)\n                self.mem[(cur,steps)] = tmp\n                \n                return self.mem[(cur,steps)]\n        \n        if N==1:\n            return 10\n        \n        for i in range(10):\n            self.count+=dfs(i,N)\n        \n        return self.count%(10**9+7)\n    \n#         if n==1:\n#             return 10\n        \n#         jump = {0:[4,6],\n#                 1:[6,8],\n#                2:[7,9],\n#                3:[4,8],\n#                4:[3,9,0],\n#                5:[],\n#                6:[1,7,0],\n#                7:[2,6],\n#                8:[1,3],\n#                9:[2,4]}\n        \n#         def get(n,d):\n#             if n==1:\n#                 s = 0\n#                 for key in d.keys():\n#                     s+=d[key]\n                    \n#                 return s%(10**9+7)\n#             new_d = collections.defaultdict(int)\n#             for key in d.keys():\n#                 nexts = jump[key]\n#                 for next in nexts:\n#                     new_d[next]+=d[key]\n            \n#             return get(n-1,new_d)\n#         count = 0\n#         for i in range(10):\n#             d = collections.defaultdict(int)\n#             d[i]=1\n#             count+=get(n,d)\n            \n#         return count%(10**9+7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def dp(cur: int, k: int, cache: dict) -> int:\n            state = tuple([cur, k])\n            if state in cache:\n                return cache[state]\n            \n            if k==0:\n                return 1\n            \n            dic = [[4,6],[6,8],[7,9], [4,8], [0,3,9],[], [0,1,7],[2,6], [1,3], [2,4]]\n            res = 0\n            for nc in dic[cur]:\n                res += dp(nc, k-1, cache)\n            \n            cache[state] = res\n            return cache[state]\n        \n        result = 0\n        cache = {}\n        mod = 10**9 + 7\n        for i in range(10):\n            result += dp(i, n-1, cache)\n            result = result%mod\n        \n        return result%(mod)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        memo = {}\n        return sum(self.hopper(i, n-1, memo) for i in range(10)) % (10 ** 9 + 7)\n    \n    def hopper(self, cur_ind, hops_left, memo):\n        if hops_left == 0:\n            return 1\n        if (cur_ind, hops_left) in memo:\n            return memo[(cur_ind, hops_left)]\n        \n        counts = 0\n        for nbr in self.nbrs(cur_ind):\n            res = self.hopper(nbr, hops_left-1, memo)\n            counts += res\n            memo[(nbr, hops_left-1)] = res\n            \n        return counts\n    \n    \n    def nbrs(self, ind):\n        nbrs = {0: [4,6],\n                1: [6, 8],\n                2: [9, 7],\n                3: [4, 8],\n                4: [3, 9, 0],\n                5: [],\n                6: [1,7, 0],\n                7: [6, 2],\n                8: [1, 3],\n                9: [4, 2]}\n        \n        return nbrs[ind]\n", "from functools import lru_cache\n\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n                     [1,7,0],[2,6],[1,3],[2,4]]\n        \n        @lru_cache(maxsize=100000)\n        def dfs(s, n):\n            if n == 0:\n                return 1\n            # for v in moves[s]:\n            return sum([dfs(v, n-1) for v in moves[s]])\n            \n        answer = 0\n        for i in range(10):\n            answer += dfs(i, N-1)\n            \n        return answer % (10 ** 9 + 7)", "\nfrom functools import reduce\nclass Solution:\n    \n    validMoves = {\n        0: {4, 6},\n        1: {6, 8},\n        2: {7, 9},\n        3: {4, 8},\n        4: {3, 9, 0},\n        5: {},\n        6: {1, 7, 0},\n        7: {2, 6},\n        8: {1, 3},\n        9: {2, 4}\n    }\n    \n    def knightDialer(self, n: int) -> int:\n        cache = {} # from (remainingMoves, location) => numberOfPaths\n        \n        def reducer(acc: int, x: int) -> int:\n            return (acc + x) % 1000000007 #10^9+7\n        \n        def helper(remainingMoves: int, location: int) -> int:\n            depth = n - remainingMoves\n            insert = '\\\\t' * depth\n            # print('{}ENTER: at {} with {} remaining'.format('\\\\t' * (depth - 1), location, remainingMoves))\n            \n            if remainingMoves == 0:\n                # print('{}Ran out of moves in location {}'.format(insert, location))\n                return 1\n            else:\n                if (remainingMoves, location) in cache:\n                    answer = cache[(remainingMoves, location)]\n                    # print('{}Found ({}, {}) in cache: returning {}'.format(insert, remainingMoves, location, answer))\n                    return answer\n                else:\n                    nextMoves = self.validMoves[location]\n                    answers = [helper(remainingMoves - 1, newLocation) for newLocation in nextMoves]\n                    reduced = reduce(reducer, answers, 0)\n                    cache[(remainingMoves, location)] = reduced\n                    # print('{}Calculated ({}, {}) = {}'.format(insert, remainingMoves, location, reduced))\n                    return reduced\n        \n        answers = [helper(n-1, x) for x in range(0, 10)]\n        reduced = reduce(reducer, answers, 0)\n        return reduced", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [-1, 0, -1]]\n        R, C = len(grid), len(grid[0])\n        dp = [[1] * C for _ in range(R)]\n        invalid = set([(3, 0), (3, 2)])\n        for r, c in invalid:\n            dp[r][c] = 0\n        dirs = [\n            (2, 1), (-2, 1), (2, -1), (-2, -1),\n            (1, 2), (-1, 2), (1, -2), (-1, -2)\n        ]\n        for _ in range(n - 1):\n            dp2 = [[0] * C for _ in range(R)]\n            for r, row in enumerate(dp):\n                for c, val in enumerate(row):\n                    if (r, c) in invalid:\n                        continue\n                    for dr, dc in dirs:\n                        nr, nc = r + dr, c + dc\n                        if (nr, nc) in invalid:\n                            continue\n                        if 0 <= nr < R and 0 <= nc < C:\n                            dp2[nr][nc] += val\n            dp = dp2\n            \n        return sum(map(sum, dp)) % (pow(10, 9) + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        m,n = 4,3\n        \n        \n        \n        dp = {}\n        ans = 0\n        for k in range(1,N+1):\n            count = 0\n            for i in range(m):\n                for j in range(n):\n                    if i==3 and j in [0,2]: continue\n                    \n                    temp = 0\n                            \n                    if 1==k:\n                        temp+=1\n\n                    else:\n                        for a,b in [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]:\n                            r,c =i+a, j+b\n                            if 0<=r<m and 0<=c<n and (r,c) not in [(3,0), (3,2)]:\n                                # print(r,c,k-1)\n                                temp+=dp[(r,c,k-1)]\n                                    \n                    dp[(i,j,k)] = temp\n                    count+=temp \n            ans = count\n        # print(dp)\n        return ans%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10 ** 9 + 7\n        phone = [[1,1,1],[1,1,1],[1,1,1],[0,1,0]]\n        moves = ((2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2))\n        # memo = {}\n        @lru_cache(None)\n        def helper(row, col, left):\n#             if (row,col,left) in memo:\n#                 return memo[(row,col,left)]\n                \n            if not 0<=row<=3 or not 0<=col<=2 or phone[row][col] ==0:\n                return 0\n            if left <= 0:\n                return 1\n            ans = 0\n            for r,c in moves:\n                if 0<=row+r<=3 and 0<=col+c<=2 and phone[row+r][col+c] ==1:\n                    ans += helper(row+r,col+c,left-1)\n            # memo[(row,col,left)] = ans\n            return ans\n        \n        ans = 0\n        for row in range(4):\n            for col in range(3):\n                if phone[row][col] == 1:\n                    ans += helper(row, col, n-1)\n        \n        return ans % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n#         board = [[str(j) for j in (1 + 3*i, 3*i + 2, 3*i + 3)] for i in range(3)]\n#         board.append(['*', '0', '#'])\n#         direct = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n        \n#         dp = {}\n#         def dfs(i, j, step):\n           \n#             if i < 0 or i > 3 or j < 0 or j > 2: return 0\n#             if board[i][j] in '*#': return 0\n#             if step == 1: return 1\n#             key = (board[i][j], step)\n#             if key in dp: return dp[key]\n#             dest = set([(i + dr, j + dc) for  dr, dc in direct])\n#             dp[key] = sum([dfs(r, c, step - 1) for r, c in dest])\n#             return dp[key]\n        \n#         res = 0\n#         for i in range(10):\n#             res += dfs(str(i), n)\n#         return res%(10**9 + 7)\n\n#         dp  = {}\n#         def nextStep(k):\n#             if k == 1: return [6, 8]\n#             if k == 2: return [7, 9]\n#             if k == 3: return [4, 8]\n#             if k == 4: return [9, 3, 0]\n#             if k == 6: return [7,1,0]\n#             if k == 7: return [6,2]\n#             if k == 8: return [1,3]\n#             if k == 9: return [4,2]\n#             if k == 0: return [4, 6]\n            \n#         def dfs(k, step):\n#             if k == 5 and step > 1: return 0\n#             if step == 1: return 1\n#             key = (k, step)\n#             if key in dp: return dp[key]\n#             dp[key] = sum([dfs(e, step - 1) for e in nextStep(k)])  \n#             return dp[key]\n#         res = 0\n#         for i in range(10):\n#             res += dfs(i, n)\n#         return res%(10**9 + 7)\n    \n        dp = [1]*10\n        if n == 1: return 10\n        for i in range(n-1):\n            dpc = dp[:]\n            dpc[0] = dp[4] + dp[6]\n            dpc[1] = dp[6] + dp[8]\n            dpc[2] = dp[7] + dp[9]\n            dpc[3] = dp[4] + dp[8]\n            dpc[4] = dp[9] + dp[3] + dp[0]\n            dpc[5] = 0\n            dpc[6] = dp[7] + dp[1] + dp[0]\n            dpc[7] = dp[6] + dp[2]\n            dpc[8] = dp[1] + dp[3]\n            dpc[9] = dp[2] + dp[4]\n            dp = dpc\n        return sum(dp)%(10**9 + 7)\n            \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        dp = [[None] * 10 for _ in range(N + 1)]\n        edges = [[1,6], [1,8], [2, 7], [2, 9],\n                 [3, 4], [3, 8], [4, 9], [4, 0], \n                 [6, 7], [6, 0]]\n        \n        graph = {}\n        for edge0, edge1 in edges:\n            graph[edge0] = graph.get(edge0, []) + [edge1]\n            graph[edge1] = graph.get(edge1, []) + [edge0]\n            \n        def count(n, x):\n            if n == 0:\n                return 1\n            \n            if dp[n][x] is not None:\n                return dp[n][x]\n            \n            dp[n][x] = sum([count(n - 1, y) for y in graph.get(x, [])])\n            return dp[n][x]\n        \n        return sum([count(N - 1, x) for x in range(10)]) % (10 ** 9 + 7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        arr = [1]*10\n        mul = [[0,0,0,0,1,0,1,0,0,0],\n               [0,0,0,0,0,0,1,0,1,0],\n               [0,0,0,0,0,0,0,1,0,1],\n               [0,0,0,0,1,0,0,0,1,0],\n               [1,0,0,1,0,0,0,0,0,1],\n               [0,0,0,0,0,0,0,0,0,0],\n               [1,1,0,0,0,0,0,1,0,0],\n               [0,0,1,0,0,0,1,0,0,0],\n               [0,1,0,1,0,0,0,0,0,0],\n               [0,0,1,0,1,0,0,0,0,0]]\n        for n in range(N-1):\n            newarr = [0]*10\n            for i in range(10):\n                for j in range(10):\n                    newarr[i] += mul[i][j]*arr[j]\n                    newarr[i] %= 10**9+7\n            arr = newarr\n        s = 0\n        for x in arr:\n            s = (s+x)%(10**9+7)\n        return s", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        d = {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 1)}\n        dirs = [(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, 2), (1, 2), (-1, -2), (1, -2)]\n        m = 10**9 + 7\n        dp = {}\n        for x in d:\n            dp[x] = [0] * (N + 1)\n            dp[x][1] = 1\n\n        for n in range(2, N + 1):\n            for r, c in d:\n                for z in dirs:\n                    rz, cz = r + z[0], c + z[1]\n                    if (rz, cz) in d:\n                        dp[(r, c)][n] = (dp[(r, c)][n] + dp[(rz, cz)][n - 1]) %m\n        return sum(x[N] for x in dp.values()) % m", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        m,n = 4,3\n        \n        dp = {}\n        ans = 0\n        for k in range(1,N+1):\n            count = 0\n            for i in range(m):\n                for j in range(n):\n                    if i==3 and j in [0,2]: continue\n                    \n                    temp = 0\n                            \n                    if 1==k:\n                        temp+=1\n\n                    else:\n                        for a,b in [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]:\n                            r,c =i+a, j+b\n                            if 0<=r<m and 0<=c<n and (r,c) not in [(3,0), (3,2)]:\n                                temp+=dp[(r,c,k-1)]\n                                    \n                    dp[(i,j,k)] = temp\n                    count+=temp \n            ans = count%(10**9+7)\n        \n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        @lru_cache(None)\n        def dp(i, j, k):\n            if k == 0:\n                return 1\n            result = 0\n            for di in [-2, -1, 1, 2]:\n                for dj in [3 - abs(di), abs(di) - 3]:\n                    ii, jj = i + di, j + dj\n                    if 0 <= ii < m and 0 <= jj < n and not (ii == 3 and (jj == 0 or jj == 2)):\n                        result = (result + dp(ii, jj, k - 1)) % MOD\n            return result\n        MOD = 10 ** 9 + 7\n        k = n\n        m, n = 4, 3\n        result = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 3 and (j == 0 or j == 2):\n                    continue\n                result = (result + dp(i, j, k - 1)) % MOD\n        return result", "class Solution:\n    def knightDialer(self, left: int) -> int:\n        moves = [(2,-1),(2,1),(-2,1),(-2,-1),(-1,2),(-1,-2),(1,2),(1,-2)]\n        n = 4\n        m = 3\n        @lru_cache(None)\n        def back(i,j,left):\n            if left==1:\n                return 1\n            ans = 0\n            for a,b in moves:\n                if 0<=i+a<n and 0<=j+b<m and (i+a,j+b)!=(3,0) and (i+a,j+b)!=(3,2):\n                    ans+=back(i+a, j+b, left-1)\n            return ans\n        main = 0\n        for i in range(3):\n            for j in range(3):\n                main+= back(i,j, left)\n        main+=back(3, 1,left)\n        \n        return main%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def get_position(pos):\n            _map= {0: [4, 6],\n                    1: [8, 6],\n                    2: [7, 9],\n                    3: [4, 8],\n                    4: [3, 9, 0],\n                    5: [],\n                    6: [1,7,0],\n                    7: [2,6],\n                    8: [1,3],\n                    9: [4,2],\n                   }\n            return _map[pos]\n        cache = {}\n        def solve(pos, step):\n            key = (pos, step)\n            if key not in cache:\n                if step>=n:\n                    return 1\n                res = 0\n                for i in get_position(pos):\n                    res += solve(i, step + 1)\n                    res = res % (pow(10,9)  + 7)\n                cache[key] = res\n            return cache[key]\n        res = 0\n        \n        for i in range(0, 10):\n            res += solve(i, 1)\n        return res % (pow(10,9)  + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        \n        def knightPos(i,j):\n            #left top bot\n            lt = (i+2,j-1)\n            lb = (i-2, j-1)\n            #right top bot\n            rt = (i+2, j+1)\n            rb = (i-2, j+1)\n            #top left right\n            tl = (i+1, j-2)\n            tr = (i+1, j+2)\n            #bot left right\n            bl = (i-1, j-2)\n            br = (i-1, j+2)\n            \n            return (lt,lb,rt,rb,tl,tr,bl,br)\n        \n        dp = [[1]*3 for _ in range(4)]\n        dp[3][0] = dp[3][2] = 0\n        mod = (10**9)+7\n        \n        for k in range(1,n):\n            tmp = [[0]*3 for _ in range(4)]\n            for i in range(4):\n                for j in range(3):\n                    if (i==3 and j==0) or (i==3 and j==2):\n                        continue\n                    for x,y in knightPos(i,j):\n                        if 0 <= x <= 3 and 0 <= y <= 2:\n                            tmp[i][j] += dp[x][y]\n            dp = tmp\n            \n        \n        return sum([sum(i) for i in dp]) % mod", "class Solution:\n    @lru_cache(maxsize=None)\n    def startFrom(self, i, l):\n        if l <= 1:\n            return 1 if l == 1 else 0\n        else:\n            return sum([self.startFrom(j, l-1) for j in self.mapping[i]]) % (10**9+7)\n        \n    def knightDialer(self, n: int) -> int:\n        self.mapping = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[3, 9, 0], 5:[], 6:[1,7,0], 7:[2, 6], 8:[1,3], 9:[2, 4], 0:[4, 6]}\n        return sum([self.startFrom(i, n) for i in range(10)]) % (10**9+7)", "import numpy as np\n\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        mod = 10**9 + 7\n        if N == 1: return 10\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        \n        res = np.matrix([[1]*10])\n        N -= 1\n        while N:\n            if N % 2 != 0: \n                res = res * M % mod                \n                N -= 1\n            else:\n                M = M * M % mod\n                N /= 2\n        return int(np.sum(res)) % mod\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        ans = [1 for x in range(10)]\n        mod = 1000_000_007\n        for i in range(n-1):\n            ans[0], ans[1], ans[2], ans[3], ans[4], ans[5], ans[6], ans[7], ans[8], ans[9] = ans[4]+ans[6], ans[8]+ans[6], ans[7]+ans[9], ans[8]+ans[4], ans[9]+ans[3]+ans[0], 0, ans[7]+ans[1]+ans[0], ans[6]+ans[2], ans[1]+ans[3], ans[4]+ans[2]\n            \n        return sum(ans)%mod\n", "class Solution:\n    from collections import defaultdict\n    def knightDialer(self, N: int) -> int:\n        pos_mapping=[[4, 6], [6, 8], [9, 7], [4, 8], [9, 3, 0], [], [7, 1, 0], [6, 2], [1, 3], [4, 2]]\n\n        \n        total_count = 0\n        for i in range(10):\n            prev_arr = [0]*10\n            prev_arr[i] = 1\n            for ii in range(N - 1):\n                new_arr = [0]*10\n                for idx,count in enumerate(prev_arr):\n                    if count == 0:\n                        continue\n                    for next_pos in pos_mapping[idx]:\n                        new_arr[next_pos] += count\n                prev_arr = new_arr\n            total_count += sum(prev_arr)\n        MOD = 10**9 + 7\n        return total_count % MOD", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        dirs = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2), (-2, 1), (-1, 2)]\n        dp = [[0 for j in range(N)] for i in range(10)]\n        for num in range(10):\n            dp[num][0] = 1\n        for i in range(1, N):\n            for num in range(10):\n                if num == 0:\n                    pos = (1, 3)\n                else:\n                    pos = ((num - 1) % 3, (num - 1) // 3)\n                x = pos[0]\n                y = pos[1]\n                for d in dirs:\n                    new_x = x - d[0]\n                    new_y = y - d[1]\n                    if new_x < 0 or new_x > 2 or new_y < 0  or new_y > 3:\n                        continue\n                    if (new_x == 0 and new_y == 3) or (new_x == 2 and new_y == 3):\n                        continue\n                    new_num = 0 if (new_x == 1 and new_y == 3) else new_y * 3 + new_x + 1\n                    dp[num][i] += dp[new_num][i-1]\n        res = 0\n        for num in range(10):\n            res += dp[num][N-1]\n        return res % (pow(10, 9) + 7)\n", "class Solution:\n    def helper(self, n, board, row, col, cache):\n        if n == 0:\n            return 1\n        \n        if (row, col, n) in cache:\n            return cache[(row, col, n)]\n        \n        rows = len(board)\n        cols = len(board[0])\n        result = 0\n        for rMove, cMove in [(-1, -2), (-2, -1), (2, 1), (1, 2), (-2, 1), (1, -2), (2, -1), (-1, 2)]:\n            if 0 <= row + rMove < rows and 0 <= col + cMove < cols and board[row+rMove][col+cMove] not in ['*', '#']:\n                result += self.helper(n-1, board, row+rMove, col+cMove, cache)\n        \n        cache[(row, col, n)] = result\n        return result\n    \n    def knightDialer(self, n: int) -> int:\n        board = [\n            ['1', '2', '3'],\n            ['4', '5', '6'],\n            ['7', '8', '9'],\n            ['*', '0', '#']\n        ]\n        \n        totalResult = 0\n        cache = {}\n        rows = len(board)\n        cols = len(board[0])\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] not in ['*', '#']:\n                    totalResult += self.helper(n-1, board, r, c, cache)\n        return totalResult % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        def dp(cur: int, k: int, cache: dict) -> int:\n            state = tuple([cur, k])\n            if state in cache:\n                return cache[state]\n            \n            if k==0:\n                return 1\n            \n            dic = {\n                0: [4,6],\n                1: [6,8],\n                2: [7,9],\n                3: [4,8],\n                4: [0,3,9],\n                6: [0,1,7],\n                7: [2,6],\n                8: [1,3],\n                9: [2,4]\n            }\n            res = 0\n            for nc in dic.get(cur,[]):\n                res += dp(nc, k-1, cache)\n            \n            cache[state] = res\n            return cache[state]\n        \n        result = 0\n        cache = {}\n        mod = 10**9 + 7\n        for i in range(10):\n            result += dp(i, n-1, cache)\n        \n        return result%(mod)", "class Solution:\n    mod = 10 ** 9 + 7\n    phone = [[1,1,1],[1,1,1],[1,1,1],[0,1,0]]\n    moves = ((2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2))\n    def knightDialer(self, n: int) -> int:\n        # memo = {}\n        @lru_cache(None)\n        def helper(row, col, left):\n#             if (row,col,left) in memo:\n#                 return memo[(row,col,left)]\n                \n            # if not 0<=row<=3 or not 0<=col<=2 or Solution.phone[row][col] ==0:\n            #     return 0\n            if left <= 0:\n                return 1\n            ans = 0\n            for r,c in Solution.moves:\n                if 0<=row+r<=3 and 0<=col+c<=2 and Solution.phone[row+r][col+c] ==1:\n                    ans = (ans + helper(row+r,col+c,left-1)) % Solution.mod\n            # memo[(row,col,left)] = ans\n            return ans\n        \n        ans = 0\n        for row in range(4):\n            for col in range(3):\n                if Solution.phone[row][col] == 1:\n                    ans = (ans + helper(row, col, n-1)) % Solution.mod\n        \n        return ans# % Solution.mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n         board=[[1,2,3],[4,5,6],[7,8,9],['*',0,'#']]\n         dirc=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]\n         mod=10**9+7;mem={}\n         def dfs(i,j,k):\n             if k==1:\n                return 1\n             if (i,j,k) in mem:\n                    return mem[(i,j,k)]\n             ans=0\n             for x,y in dirc:\n                if -1<i+x<4 and -1<j+y<3 and board[i+x][j+y]!='#' and board[i+x][j+y]!='*':\n                  ans+=dfs(i+x,j+y,k-1)%mod\n             ans%=mod\n             mem[(i,j,k)]=ans\n             return ans\n         res=0\n         for i in range(3):\n             for j in range(3):\n                 res+=dfs(i,j,n)%mod\n         res=(res+dfs(3,1,n))%mod\n         return res\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n#         MOD = 10**9 + 7\n#         # dp = [ [[0]*3 for _2 in range(4)]   for _ in range(N)]\n#         dp = [[0]*3 for _2 in range(4)]\n#         for i in range(4):\n#             for j in range(3):\n#                 if (i,j) in [(3,0),(3,2)]:\n#                     continue\n#                 dp[i][j] = 1\n        \n#         for k in range(1,N):\n#             new_dp = [[0]*3 for _2 in range(4)]\n#             for i in range(3):\n#                 for j in range(i,3):\n#                     # print(i,j)\n#                     a = [[i+2,j+1],[i+2,j-1],[i-2,j+1],[i-2,j-1],\n#                          [i+1,j+2],[i-1,j+2],[i+1,j-2],[i-1,j-2]]\n#                     for p in a:\n#                         if not(0 <= p[0] < 4) or not(0 <= p[1] < 3):\n#                             continue\n#                         new_dp[i][j] += dp[p[0]][p[1]] % MOD\n#                         # new_dp[j][i] = new_dp[i][j]\n#             new_dp[1][0] = new_dp[1][2]\n#             new_dp[2][0] = new_dp[2][2]\n#             new_dp[2][1] = new_dp[0][1]\n#             i = 3\n#             j = 1\n#             new_dp[3][1] = (dp[1][2] + dp[1][0]) % MOD\n#             dp = new_dp\n#             # print(dp)\n            \n#         s = 0\n#         # dp[3][0] = dp[N-1][3][2] = 0\n#         for i in dp:\n#             for j in i:\n#                 s += j % MOD\n#         return s % MOD\n    \n        \n        cac = {}\n        MOD = 10**9 + 7\n        pmvs = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[4,2]]\n        def d(k,i):\n            try:\n                # 1/0\n                return cac[(k,i)]\n            except:\n                pass\n            if k == 0:\n                return 1\n            s = 0\n            for j in pmvs[i]:\n                s += d(k-1,j) % MOD\n            cac[(k,i)] = s % MOD\n            return cac[(k,i)]\n        ans = 0\n        for i in range(10):\n            ans += d(N-1,i) % MOD\n        return ans % MOD\n", "class Solution:\n    \n    def __init__(self):\n        self.helper = {(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)}\n    \n    def dynamic(self,r,c,dp):\n        \n        curr = 0\n        for s in self.helper:\n            x,y = r+s[0],c+s[1]\n            \n            if 0<=x<4 and 0<=y<3 and ((x,y) != (3,0) or (x,y) != (3,2)):\n                curr += dp[x][y]\n        return curr#%(10**9+7)\n    \n    def knightDialer(self, n: int) -> int:\n        \n        dp = [[1]*3 for _ in range(4)]\n        \n        dp[3][0] = dp[3][2] = 0\n        \n        for i in range(n-1):\n            dp2 = [[0]*3 for _ in range(4)]\n                \n            for r in range(4):\n                for c in range(3):\n                    if (r,c) == (3,0) or (r,c) == (3,2): continue\n                        \n                    dp2[r][c] = self.dynamic(r,c,dp)\n                    \n            dp = dp2[:]\n\n        return sum([dp[i][j] for i in range(4) for j in range(3)])%(10**9+7)\n", "class Solution:\n\n    adjacency = {\n            0: {4, 6},\n            1: {8, 6},\n            2: {7, 9},\n            3: {8, 4},\n            4: {3, 9, 0},\n            5: {},\n            6: {1, 7, 0},\n            7: {2, 6},\n            8: {1, 3},\n            9: {2, 4}\n        }\n\n    def matrixExponentiation(self, a: List[List[int]], k: int) -> List[List[int]]:\n        if k == 0:\n            return [[1 if r == c else 0 for c in range(len(a[0]))] for r in range(len(a))]\n\n        result = self.matrixExponentiation(a, k // 2)\n        result = self.matrixMultiplication(result, result)\n\n        if k % 2 == 1:\n            result = self.matrixMultiplication(a, result)\n\n        return result\n\n    def matrixMultiplication(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:\n        m, n, p = len(a), len(a[0]), len(b[0])\n        assert len(a[0]) == len(b)\n\n        matrix = [[0] * p for _ in range(m)]\n\n        for r in range(m):\n            for c in range(p):\n                for i in range(n):\n                    matrix[r][c] += a[r][i] * b[i][c]\n\n        return matrix\n\n    def knightDialer(self, n: int):\n        matrix = [[(1 if r in Solution.adjacency[c] else 0) for c in range(10)] for r in range(10)]\n        matrix = self.matrixExponentiation(matrix, n - 1)\n\n        count = [[1] for _ in range(10)]\n        count = self.matrixMultiplication(matrix, count)\n\n        return sum((sum(r) for r in count)) % (10 ** 9 + 7)\n\n\n    def knightDialerDP(self, n: int):\n        count = [1 for _ in range(10)]\n\n        for _ in range(n - 1):\n            count = [sum(count[next_digit] for next_digit in Solution.adjacency[digit]) for digit in range(10)]\n\n        return sum(count) % (10 ** 9 + 7)\n\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        nos = [[1,2,3], [4,5,6], [7,8,9], [None, 0, None]]\n        if N == 0:\n            return 0\n        \n        memo = {}\n        \n        def calculate(currentIndex, remainingSteps):\n            if remainingSteps == 0:\n                return 1\n            if (currentIndex, remainingSteps) in memo:\n                return memo[(currentIndex, remainingSteps)] \n            \n            i, j = currentIndex\n            \n            possibleMoves = []\n            \n            if i+2 < 4 and j - 1 >= 0 and nos[i+2][j-1] is not None:\n                possibleMoves.append((i+2, j-1))\n                \n            if i+2 < 4 and j + 1 < 3 and nos[i+2][j+1] is not None:\n                possibleMoves.append((i+2, j+1))\n            \n            if i - 1 >= 0 and j+2 < 3 and nos[i-1][j+2] is not None:\n                possibleMoves.append((i-1,j+2))\n            \n            if i+1 < 4 and j+2 < 3 and nos[i+1][j+2] is not None:\n                possibleMoves.append((i+1, j+2))\n            \n            if i-2 >= 0 and j+1 < 3 and nos[i-2][j+1] is not None:\n                possibleMoves.append((i-2,j+1))\n            \n            if i-2 >=0 and j-1 >= 0 and nos[i-2][j-1] is not None:\n                possibleMoves.append((i-2, j-1))\n            \n            if i-1>=0 and j-2>=0 and nos[i-1][j-2] is not None:\n                possibleMoves.append((i-1,j-2))\n                \n            if i+1 < 4 and j-2 >=0 and nos[i+1][j-2] is not None:\n                possibleMoves.append((i+1,j-2))\n                \n            if remainingSteps == 1:\n                memo[(currentIndex, remainingSteps)]  = len(possibleMoves)\n                return len(possibleMoves) \n            \n            \n            \n            totalNos = 0\n            \n            for nextInd in possibleMoves:\n                if (nextInd, remainingSteps-1) in memo:\n                    totalNos += memo[nextInd, remainingSteps-1]\n                else:\n                    totalNos += calculate(nextInd, remainingSteps-1)\n                # if totalNos >= 10**9 + 7:\n                #     totalNos = totalNos % (10**9 + 7)\n            \n            memo[(currentIndex, remainingSteps)] = totalNos\n            return memo[(currentIndex, remainingSteps)] \n        \n        \n        total = 0\n        for i in range(0, 4):\n            for j in range(0, 3):\n                if nos[i][j] is not None:\n                    total += calculate((i,j), N-1)\n        return total % (10**9 + 7)", "class Solution:\n    \n    def __init__(self):\n        self.helper = {(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)}\n    \n    def dynamic(self,r,c,dp):\n        \n        curr = 0\n        for s in self.helper:\n            x,y = r+s[0],c+s[1]\n            \n            if 0<=x<4 and 0<=y<3 and ((x,y) != (3,0) or (x,y) != (3,2)):\n                curr += dp[x][y]\n        return curr\n    \n    def knightDialer(self, n: int) -> int:\n        \n        dp = [[1]*3 for _ in range(4)]\n        \n        dp[3][0] = dp[3][2] = 0\n        \n        \n        for i in range(n-1):\n            dp2 = [[0]*3 for _ in range(4)]\n                \n            for r in range(4):\n                for c in range(3):\n                    if (r,c) == (3,0) or (r,c) == (3,2): continue\n                        \n                    dp2[r][c] = self.dynamic(r,c,dp)\n            dp = dp2[:]\n        #print(dp)\n        return sum([dp[i][j] for i in range(4) for j in range(3)])%(10**9+7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        P = 10**9 + 7\n        def wrap(x):\n            return x - P if x >= P else x\n        s = 0\n        for k in range(10):\n            d = [0] * 10\n            d2 = [0] * 10\n            d[k] = 1\n            for i in range(n - 1):\n                d2[0] = wrap(d[4] + d[6])\n                d2[1] = wrap(d[6] + d[8])\n                d2[2] = wrap(d[7] + d[9])\n                d2[3] = wrap(d[4] + d[8])\n                d2[4] = wrap(d[3] + d[9] + d[0])\n                d2[5] = 0\n                d2[6] = wrap(d[1] + d[7] + d[0])\n                d2[7] = wrap(d[2] + d[6])\n                d2[8] = wrap(d[1] + d[3])\n                d2[9] = wrap(d[2] + d[4])\n                d, d2 = d2, d\n            s += sum(d)\n        return s % (10 ** 9 + 7)\n\n", "class Solution:\n    from collections import defaultdict\n    def knightDialer(self, N: int) -> int:\n        pos_mapping=[[4, 6], [6, 8], [9, 7], [4, 8], [9, 3, 0], [], [7, 1, 0], [6, 2], [1, 3], [4, 2]]\n\n        \n        total_count = 0\n        for i in range(10):\n            prev_arr = [0]*10\n            prev_arr[i] = 1\n            for _ in range(N - 1):\n                new_arr = [0]*10\n                for idx in range(10):\n                    if prev_arr[idx] == 0:\n                        continue\n                    for next_pos in pos_mapping[idx]:\n                        new_arr[next_pos] += prev_arr[idx]\n                prev_arr = new_arr\n            total_count += sum(prev_arr)\n        MOD = 10**9 + 7\n        return total_count % MOD", "class Solution:\n    DIAL = [\n        [1,   2,  3],\n        [4,   5,  6],\n        [7,   8,  9],\n        ['*', 0, '#']\n    ]\n    def knightDialer(self, n: int) -> int:\n        directions = [(1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2)]\n\n        count = 0\n        m = len(self.DIAL)\n        nn = len(self.DIAL[0])\n        cache = {}\n\n        def jump(i, j, path_length):\n            if path_length == n:\n                return 1\n            else:\n                total = 0\n                if (i, j, path_length) in cache:\n                    return cache[i, j, path_length]\n                for inc_r, inc_c in directions:\n                    r = i + inc_r\n                    c = j + inc_c\n                    if 0 <= r < m and 0 <= c < nn and isinstance(self.DIAL[r][c], int):\n                        total += jump(r, c, path_length+1)\n                cache[i, j, path_length] = total\n                return total\n\n        res = 0\n\n        for i in range(m):\n            for j in range(nn):\n                if isinstance(self.DIAL[i][j], int):\n                    res += jump(i, j, 1)\n\n        return res % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        path={\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5:[],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        M=10**9+7\n        @lru_cache\n        def paths(i,n):\n            #number of ways to jump from i n times          \n            if n==1:\n                return len(path[i])\n            if n==0:\n                return 1\n            s=0\n            for v in path[i]:\n                s+=paths(v,n-1)\n            return s%M\n        ans=0\n        for k in path:\n            ans+=paths(k,n-1)\n        return ans%(M)\n                \n            \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        nos = [[1,2,3], [4,5,6], [7,8,9], [None, 0, None]]\n        if N == 0:\n            return 0\n        \n        memo = {}\n        \n        def calculate(currentIndex, remainingSteps):\n            if remainingSteps == 0:\n                return 1\n            if (currentIndex, remainingSteps) in memo:\n                return memo[(currentIndex, remainingSteps)] \n            i, j = currentIndex\n            \n            possibleMoves = []\n            \n            if i+2 < 4 and j - 1 >= 0 and nos[i+2][j-1] is not None:\n                possibleMoves.append((i+2, j-1))\n                \n            if i+2 < 4 and j + 1 < 3 and nos[i+2][j+1] is not None:\n                possibleMoves.append((i+2, j+1))\n            \n            if i - 1 >= 0 and j+2 < 3 and nos[i-1][j+2] is not None:\n                possibleMoves.append((i-1,j+2))\n            \n            if i+1 < 4 and j+2 < 3 and nos[i+1][j+2] is not None:\n                possibleMoves.append((i+1, j+2))\n            \n            if i-2 >= 0 and j+1 < 3 and nos[i-2][j+1] is not None:\n                possibleMoves.append((i-2,j+1))\n            \n            if i-2 >=0 and j-1 >= 0 and nos[i-2][j-1] is not None:\n                possibleMoves.append((i-2, j-1))\n            \n            if i-1>=0 and j-2>=0 and nos[i-1][j-2] is not None:\n                possibleMoves.append((i-1,j-2))\n                \n            if i+1 < 4 and j-2 >=0 and nos[i+1][j-2] is not None:\n                possibleMoves.append((i+1,j-2))\n                \n            if remainingSteps == 1:\n                memo[(currentIndex, remainingSteps)]  = len(possibleMoves)\n                return len(possibleMoves) \n            \n            \n            \n            totalNos = 0\n            \n            for nextInd in possibleMoves:\n                totalNos += calculate(nextInd, remainingSteps-1)\n                # if totalNos >= 10**9 + 7:\n                #     totalNos = totalNos % (10**9 + 7)\n            \n            memo[(currentIndex, remainingSteps)] = totalNos\n            return memo[(currentIndex, remainingSteps)] \n        \n        \n        total = 0\n        for i in range(0, 4):\n            for j in range(0, 3):\n                if nos[i][j] is not None:\n                    total += calculate((i,j), N-1)\n        return total % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        modulo = 10**9 + 7\n        self.count = 0\n        self.cache = {}\n        \n        for digit in range(0,10):\n            self.count += self.getWays(digit, n-1)\n        \n        return self.count % modulo\n    \n    def getWays(self, digit, n):\n        if n == 0:\n            return 1\n        \n        if (digit,n) in self.cache:\n            return self.cache[(digit,n)]\n        \n        temp = 0\n        for neighbor in self.neighbors(digit):\n            temp += self.getWays(neighbor, n-1)\n    \n        self.cache[(digit, n)] = temp\n        return self.cache[(digit,n)]\n    \n    def neighbors(self, digit):\n        neighbors = {\n            0: (4, 6),\n            1: (6, 8),\n            2: (7, 9),\n            3: (4, 8),\n            4: (0, 3, 9),\n            5: (),\n            6: (0, 1, 7),\n            7: (2, 6),\n            8: (1, 3),\n            9: (2,4)\n\n        }\n        \n        return neighbors[digit]", "import math\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        dp = [[[0 for _ in range(3)] for _ in range(4)] for _ in range(N)]\n        \n        \n        direction = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]\n        \n        for k in range(N):\n            for i in range(4):\n                for j in range(3):\n                    if k == 0:\n                        if (i == 3 and j == 0) or (i == 3 and j == 2):\n                            dp[0][i][j] = None\n                        else:\n                            dp[0][i][j] = 1\n                    else:\n                        if dp[k-1][i][j] == None:\n                            dp[k][i][j] = None\n                            continue\n\n                        if i == 1 and j == 1:\n                            dp[k][i][j] = 0\n                            continue\n\n                        for d in direction:\n                            fromi = i + d[0]\n                            fromj = j + d[1]\n                            #check fromi and fromj are valid\n                            if 0 <= fromi <= 3 and 0 <= fromj <= 2 and dp[k-1][fromi][fromj] != None:\n                                dp[k][i][j] += dp[k-1][fromi][fromj]\n        res = 0\n        for i in range(4):\n            for j in range(3):\n                if dp[-1][i][j] == None:\n                    continue\n                res += dp[-1][i][j]\n        t = pow(10,9)+7\n        return res % t\n                        \n                        \n                        \n", "class Solution:\n    def __init__(self):\n        self.memo = {}\n        \n    def getOrCreate(self, i, n):\n        if (i,n) not in self.memo:\n            self.memo[(i, n)] = self.__knightDialerDP(i, n)\n        return self.memo[(i, n)]\n\n    def __knightDialerDP(self, i, n):\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # if i in set([0,1,2,3,7,8,9]):\n        #     return self.getOrCreate(i, n-1) + 2\n        # elif i in set([4,6]): \n        #     return self.getOrCreate(i, n-1) + 3\n        # else:\n        #     return 0\n\n        if i == 0:\n            return self.getOrCreate(4, n-1) + self.getOrCreate(6, n-1)\n        elif i == 1: \n            return self.getOrCreate(6, n-1) + self.getOrCreate(8, n-1)\n        elif i == 2:\n            return self.getOrCreate(7, n-1) +  self.getOrCreate(9, n-1)\n        elif i == 3: \n            return self.getOrCreate(4, n-1) +  self.getOrCreate(8, n-1)\n        elif i == 4: \n            return self.getOrCreate(0, n-1) +  self.getOrCreate(3, n-1) + self.getOrCreate(9, n-1)\n        elif i == 6:\n            return self.getOrCreate(0, n-1) +  self.getOrCreate(1, n-1) + self.getOrCreate(7, n-1)\n        elif i == 7: \n            return self.getOrCreate(2, n-1) +  self.getOrCreate(6, n-1)\n        elif i == 8: \n            return self.getOrCreate(1, n-1) +  self.getOrCreate(3, n-1)\n        elif i == 9: \n            return self.getOrCreate(2, n-1) +  self.getOrCreate(4, n-1)\n        else:\n            return 0\n        \n    \n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        for k in range(n):\n            total_count = 0\n            for i in range(10):\n                total_count += self.__knightDialerDP(i, k+1)\n        return total_count % ((10 ** 9) + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [1]*10\n        mod = 10**9 + 7\n        for i in range(1,n):\n            dp_old = dp.copy()\n            dp[0] = dp_old[4]+dp_old[6]\n            dp[1] = dp_old[6]+dp_old[8]\n            dp[2] = dp_old[7]+dp_old[9]\n            dp[3] = dp_old[4]+dp_old[8]\n            dp[4] = dp_old[3]+dp_old[9]+dp_old[0]\n            dp[5] = 0\n            dp[6] = dp_old[1]+dp_old[7]+dp_old[0]\n            dp[7] = dp_old[2]+dp_old[6]\n            dp[8] = dp_old[1]+dp_old[3]\n            dp[9] = dp_old[2]+dp_old[4]\n    \n        return sum(dp)%mod", "import math\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        dp = [[[0 for _ in range(3)] for _ in range(4)] for _ in range(N)]\n        \n        \n        direction = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]\n        \n        for k in range(N):\n            for i in range(4):\n                for j in range(3):\n                    if k == 0:\n                        if (i == 3 and j == 0) or (i == 3 and j == 2):\n                            dp[k][i][j] = None\n                        else:\n                            dp[k][i][j] = 1\n                    else:\n                        if dp[k-1][i][j] == None:\n                            dp[k][i][j] = None\n                            continue\n\n                        if i == 1 and j == 1:\n                            dp[k][i][j] = 0\n                            continue\n\n                        for d in direction:\n                            fromi = i + d[0]\n                            fromj = j + d[1]\n                            #check fromi and fromj are valid\n                            if 0 <= fromi <= 3 and 0 <= fromj <= 2 and dp[k-1][fromi][fromj] != None:\n                                dp[k][i][j] += dp[k-1][fromi][fromj]\n        res = 0\n        for i in range(4):\n            for j in range(3):\n                if dp[-1][i][j] == None:\n                    continue\n                res += dp[-1][i][j]\n        t = pow(10,9)+7\n        return res % t\n                        \n                        \n                        \n", "class Solution:\n    def helper(self,cache,position,num_hops):\n        neighbors = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],\n             [1,7,0],[2,6],[1,3],[2,4]]\n        if (position, num_hops) in cache:\n            return cache[ (position, num_hops) ]\n\n        if num_hops == 0:\n            return 1\n\n        else:\n            num_sequences = 0\n            for neighbor in neighbors[position]:\n                num_sequences += self.helper(cache,neighbor, num_hops - 1)\n            cache[ (position, num_hops) ] = num_sequences\n        return num_sequences\n        \n    def knightDialer(self, n: int) -> int:\n        cache = {}\n        res = 0      \n        for start in range(10):\n            res += self.helper(cache,start, n-1)\n        return res % (10**9 + 7)\n    \n\n\n\n        \n        \n                    \n                    \n                    \n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        movesMap=dict()\n        MOD=10**9+7\n        movesMap[0]=[4,6]\n        movesMap[1]=[6,8]\n        movesMap[2]=[7,9]\n        movesMap[3]=[4,8]\n        movesMap[4]=[0,3,9]\n        movesMap[5]=[]\n        movesMap[6]=[0,1,7]\n        movesMap[7]=[2,6]\n        movesMap[8]=[1,3]\n        movesMap[9]=[2,4]\n        totalCount=0\n        for i in range(10):\n            curPos=[0]*10\n            curPos[i]=1\n            for count in range(n-1):\n                nextPos=[0]*10\n                for curIndex in range(10):\n                    if curPos[curIndex]>0:\n                        for nextIndex in movesMap[curIndex]: \n                            nextPos[nextIndex]+=curPos[curIndex]\n                            nextPos[nextIndex]=nextPos[nextIndex]%MOD\n                curPos=nextPos\n            for finIndex in range(10):\n                totalCount+=curPos[finIndex]\n                totalCount=totalCount%MOD\n        return totalCount", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        movesMap=dict()\n        MOD=10**9+7\n        movesMap[0]=[4,6]\n        movesMap[1]=[6,8]\n        movesMap[2]=[7,9]\n        movesMap[3]=[4,8]\n        movesMap[4]=[0,3,9]\n        movesMap[5]=[]\n        movesMap[6]=[0,1,7]\n        movesMap[7]=[2,6]\n        movesMap[8]=[1,3]\n        movesMap[9]=[2,4]\n        totalCount=0\n        for i in range(10):\n            curPos=[0]*10\n            curPos[i]=1\n            for count in range(n-1):\n                nextPos=[0]*10\n                for curIndex in range(10):\n                    if curPos[curIndex]>0:\n                        for nextIndex in movesMap[curIndex]: \n                            nextPos[nextIndex]+=curPos[curIndex]\n                            nextPos[nextIndex]%=MOD\n                curPos=nextPos\n            for finIndex in range(10):\n                totalCount+=curPos[finIndex]\n                totalCount%=MOD\n        return totalCount", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        pad = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9'], ['*', '0', '#']]\n        dirs = [[-1, -2], [-2, -1], [1, -2], [2, -1], [-1, 2], [-2, 1], [1, 2], [2, 1]]\n        \n        memo = dict()\n        for i in range(10):\n            memo[str(i)] = [0 for j in range(n + 1)]\n            memo[str(i)][1] = 1\n            \n        for j in range(2, n + 1):\n            for r in range(4):\n                for c in range(3):\n                    number = pad[r][c]\n                    if number == '*' or number == '#':\n                        continue\n                    memo[number][j] = 0\n                    for dir0 in dirs:\n                        x = r + dir0[0]\n                        y = c + dir0[1]\n                        if x < 0 or x >= 4 or y < 0 or y >= 3 or pad[x][y] == '*' or pad[x][y] == '#':\n                            continue\n                            \n                        parent = pad[x][y]\n                        memo[number][j] += memo[parent][j - 1]\n        \n        res = 0\n        for i in range(10):\n            number = str(i)\n            res += memo[number][n]\n        return res % 1_000_000_007\n                        \n        \n        \n# Idea:     use 2D dp array memo[10][n + 1] to store the number of distinct phone numbers\n#           memo[i][0] = 0\n#           memo[i][j] = sum(memo[parent][j - 1])\n#           Res = sum(memo[i][n])\n# Time:     O(n)\n# Space:    O(n)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # Move records at each idex, which numbers it can jump to\n        # 0 can jump to 4 and 6, 1 can jump to 6 and 8, etc\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1]*10\n        for hops in range(n-1):\n            dp2 = [0]*10\n            for node, count in enumerate(dp):\n                for nei in moves[node]:\n                    dp2[nei] += count\n                    dp2[nei] % MOD\n            dp = dp2\n        return sum(dp)%MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        moves = [(x, y) for x in range(-2, 3, 2) for y in range(-2, 3, 2) if abs(x) != abs(y)]\n        MOD = 10 ** 9 + 7 \n        res = 0 \n        mappings = {\n            1: [6, 8],\n            2: [7, 9],\n            3: [4, 8],\n            4: [0, 3, 9], \n            5: [], \n            6: [0, 1, 7], \n            7: [2, 6], \n            8: [1, 3], \n            9: [2, 4], \n            0: [4, 6],\n        }\n        \n        @lru_cache\n        def dfs(num_jumps, cell): \n            if num_jumps == 1:\n                return 1\n            cur = 0\n            for i in mappings[cell]:\n                cur += dfs(num_jumps - 1, i)\n            return cur\n        \n        for i in range(0, 10):\n            res += dfs(n, i)\n        \n        return res % MOD", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        dialer_map = {0: [4, 6],\n                      1: [6, 8],\n                      2: [7, 9],\n                      3: [4, 8],\n                      4: [0, 3, 9],\n                      5: [],\n                      6: [0, 1, 7],\n                      7: [2, 6],\n                      8: [1, 3],\n                      9: [2, 4]}\n        \n        total = 0\n        for i in range(10):\n            if i == 5 and n==1:\n                total += 1\n                continue\n            \n            level = {i:1}\n            curr = 1\n            while curr<n:\n                next_level = defaultdict(lambda:0)\n                for l in list(level.keys()):\n                    for d in dialer_map[l]:\n                        next_level[d]+=level[l]\n                \n                level = next_level\n                curr += 1\n            count = sum(level.values())\n            total += count\n            total = total%(10**9+7)\n        \n        return total\n                    \n                    \n            \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mod = 10 ** 9 + 7\n        dp = [1] * 10\n        \n        for _ in range(2, n + 1):\n            dpc = dp.copy()\n            dp[0] = dpc[4] + dpc[6]\n            dp[1] = dpc[6] + dpc[8]\n            dp[2] = dpc[7] + dpc[9]\n            dp[3] = dpc[4] + dpc[8]\n            dp[4] = dpc[3] + dpc[9] + dpc[0]\n            dp[5] = 0\n            dp[6] = dpc[1] + dpc[7] + dpc[0]\n            dp[7] = dpc[2] + dpc[6]\n            dp[8] = dpc[1] + dpc[3]\n            dp[9] = dpc[4] + dpc[2]\n            \n        res = sum(dp) % mod\n        return res\n            \n        \n            \n            \n            \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        \n        dialer_map = {0: [4, 6],\n                      1: [6, 8],\n                      2: [7, 9],\n                      3: [4, 8],\n                      4: [0, 3, 9],\n                      5: [],\n                      6: [0, 1, 7],\n                      7: [2, 6],\n                      8: [1, 3],\n                      9: [2, 4]}\n        \n        total = 0\n        for i in range(10):\n            if i == 5 and n==1:\n                total += 1\n                continue\n            \n            level = {i:1}\n            curr = 1\n            while curr<n:\n                next_level = defaultdict(lambda:0)\n                for l in list(level.keys()):\n                    for d in dialer_map[l]:\n                        next_level[d]+=level[l]\n                \n                level = next_level\n                curr += 1\n            count = sum(level.values())\n            total += count\n        \n        return total%(10**9+7)\n                    \n                    \n            \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        valid_positions = {\n            (0, 0): 1,\n            (1, 0): 2,\n            (2, 0): 3,\n            (0, 1): 4,\n            (1, 1): 5,\n            (2, 1): 6,\n            (0, 2): 7,\n            (1, 2): 8,\n            (2, 2): 9,\n            (1, 3): 0\n        }\n        \n        mod_val = 10**9 + 7\n        \n        cache = {}\n        def find_numbers(start, length):\n            if start not in valid_positions:\n                return 0\n            x,y = start\n            \n            if (x,y,length) in cache:\n                return cache[(x,y,length)]\n                \n            if length == n:\n                return 1\n            \n            x,y = start\n            nums_found = sum(\n                        [find_numbers((x+1, y-2), length+1),\n                        find_numbers((x+2, y-1), length+1),\n                        find_numbers((x-1, y-2), length+1),\n                        find_numbers((x-2, y-1), length+1),\n                        find_numbers((x-2, y+1), length+1),\n                        find_numbers((x-1, y+2), length+1),\n                        find_numbers((x+2, y+1), length+1),\n                        find_numbers((x+1, y+2), length+1)]\n            ) % mod_val\n            \n            cache[(x,y,length)] = nums_found\n            return nums_found\n                \n                \n            \n        numbers_found = 0\n        for position in valid_positions:\n            numbers_found += find_numbers(position, 1)\n            numbers_found %= mod_val\n            \n        # print(sorted(nums))\n        \n        return numbers_found\n            \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        self.mod = 10**9 + 7\n        total_path = 0\n        self.d = {}\n        for i in range(0,4):\n            for j in range(0,3):\n                total_path = (total_path + self.dfs(i,j,n) )%self.mod\n                #print(total_path)\n        return total_path        \n     \n    def dfs(self,i,j,n):\n        if i<0 or j<0 or j>=3 or i>=4 or (i==3 and j!=1):\n            return 0\n        \n        if (i,j,n) in self.d:\n            return self.d[(i,j,n)]\n        \n        if n==1:\n            return 1\n        \n        total=self.dfs(i-1,j+2,n-1)%self.mod+self.dfs(i-1,j-2,n-1)%self.mod+self.dfs(i+1,j-2,n-1)%self.mod+self.dfs(i+1,j+2,n-1)%self.mod+self.dfs(i+2,j+1,n-1)%self.mod+self.dfs(i+2,j-1,n-1)%self.mod+self.dfs(i-2,j+1,n-1)%self.mod+self.dfs(i-2,j-1,n-1)%self.mod\n        \n        self.d[(i,j,n)] = total\n        return total\n        \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        memo = {}\n        maxi = (10**9)+7\n        def paths(i,j,n):\n            if i>3 or j>2 or i<0 or j <0 or (i==3 and j != 1):\n                return 0\n            if n == 1:\n                return 1\n            if (i,j,n) in memo:\n                return memo[(i,j,n)]\n            result = paths(i - 1, j - 2, n - 1) % maxi + paths(i - 2, j - 1, n - 1) % maxi + paths(i - 2, j + 1, n - 1) % maxi+ paths(i - 1, j + 2, n - 1) % maxi + paths(i + 1, j + 2, n - 1) % maxi + paths(i + 2, j + 1, n - 1) % maxi + paths(i + 2, j - 1, n - 1) % maxi + paths(i + 1, j - 2, n - 1) % maxi\n            \n            memo[(i,j,n)] = result\n            return result\n\n        totalPaths = 0\n        for i in range(4):\n            for j in range(3):\n                totalPaths = (totalPaths+paths(i,j,N))%maxi\n                \n        return totalPaths\n    \n# Inspired from Sriram's Java Solution\n# https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        self.mod = 10**9 + 7\n        total_path = 0\n        self.d = {}\n        for i in range(0,4):\n            for j in range(0,3):\n                total_path = (total_path + self.dfs(i,j,n) )%self.mod\n                \n        return total_path        \n     \n    def dfs(self,i,j,n):\n        if i<0 or j<0 or j>=3 or i>=4 or (i==3 and j!=1):\n            return 0\n        \n        if (i,j,n) in self.d:\n            return self.d[(i,j,n)]\n        \n        if n==1:\n            return 1\n        \n        total=self.dfs(i-1,j+2,n-1)%self.mod+self.dfs(i-1,j-2,n-1)%self.mod+self.dfs(i+1,j-2,n-1)%self.mod+self.dfs(i+1,j+2,n-1)%self.mod+self.dfs(i+2,j+1,n-1)%self.mod+self.dfs(i+2,j-1,n-1)%self.mod+self.dfs(i-2,j+1,n-1)%self.mod+self.dfs(i-2,j-1,n-1)%self.mod\n        \n        self.d[(i,j,n)] = total\n        return total\n        \n        \n        \n        \n", "class Solution:  \n    def knightDialer(self, N: int) -> int:\n        total = 0\n        places = {1:[6,8], 2:[7,9], 3:[4,8], 4:[3,9,0], 6:[1,7,0], 7:[2,6], 8:[1,3], 9:[2,4], 0: [4,6]}\n        if N == 1:\n            return 10\n        dp = [1]*10\n        for i in range(2, N+1):\n            tmp = copy.deepcopy(dp)\n            for i in range(0, 10):\n                if i!=5:\n                    vals = places.get(i)\n                    new_tot = 0\n                    for v in vals:\n                        new_tot += dp[v]\n                    tmp[i] = new_tot\n            dp = copy.deepcopy(tmp)\n        ans = 0\n        for d in dp:\n            ans+=d\n        return (ans-1) % (10**9 + 7)\n                    \n                \n        \n", "class Solution:\n    def nextPositions(self,n):\n        x,y = self.x_y_map[n]\n        arr = [(x-2,y+1),(x-1,y+2),(x+1,y+2),(x+2,y+1),(x+2,y-1),(x+1,y-2),(x-1,y-2),(x-2,y-1)]\n        return [self.reverse_map[v] for v in arr if v in self.reverse_map]\n    def build_x_y_map(self):\n        r,c = 0,0\n        ht = {}\n        \n        for i in range(1,10):\n            ht[i] = (r,c)\n            c+=1\n            if c == 3:\n                r+=1\n                c = 0\n        \n        ht[0] = (3,1)\n        return ht\n    \n    def knightDialer(self, n: int) -> int:\n        self.x_y_map = self.build_x_y_map()\n        self.reverse_map = {v:k for k,v in list(self.x_y_map.items())}\n        \n        def count_moves(curr_cell,hops,memo):\n            if hops == 0:\n                return 1\n            key = (curr_cell,hops)\n            if key not in memo:\n                ways = 0\n                for pos in self.nextPositions(curr_cell):\n                    ways += count_moves(pos,hops-1,memo)\n                memo[key] = ways\n            return memo[key]  \n        total = 0\n        memo = {}\n        for i in range(0,10):\n            total += count_moves(i,n-1,memo)\n        return total % (10**9 + 7)\n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        keyboard = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9],\n            [-1, 0, -1],\n        ]\n        dp = [[\n            [1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1],\n            [0, 1, 0]\n        ]]\n        modulo = 10**9+7\n        for k in range(1, n):\n            dp.append([[0 for _ in range(3)] for _ in range(4)])\n            for i in range(4):\n                for j in range(3):\n                    for (x, y) in [(i+2, j+1),\n                                   (i+2, j-1),\n                                   (i-2, j+1),\n                                   (i-2, j-1),\n                                   (i+1, j+2),\n                                   (i+1, j-2),\n                                   (i-1, j+2),\n                                   (i-1, j-2)]:\n                        if 0 <= x < 4 and 0 <= y < 3 and keyboard[x][y] != -1:\n                            dp[k][x][y] = (dp[k][x][y]+dp[k-1][i][j])%modulo\n        return sum(sum(row) for row in dp[n-1])%modulo", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if(n == 0):\n            return 0\n        if(n == 1):\n            return 10\n        total = 9\n        digit = {}\n        for j in range(0,10):\n            if(j == 5):\n                continue\n            digit[j] = 1\n        const = 10 ** 9 + 7\n        for i in range(1,n):\n            num_1 = (digit[6] + digit[8]) % const\n            num_2 = (digit[7] + digit[9]) % const\n            num_3 = (digit[4] + digit[8]) % const\n            num_4 = (digit[3] + digit[9] + digit[0]) % const\n            num_6 = (digit[1] + digit[7] + digit[0]) % const\n            num_7 = (digit[2] + digit[6]) % const\n            num_8 = (digit[1] + digit[3]) % const\n            num_9 = (digit[2] + digit[4]) % const\n            num_0 = (digit[4] + digit[6]) % const\n            digit[0] = num_0\n            digit[1] = num_1\n            digit[2] = num_2\n            digit[3] = num_3\n            digit[4] = num_4\n            digit[6] = num_6\n            digit[7] = num_7\n            digit[8] = num_8\n            digit[9] = num_9\n            total = (num_0 + num_1 + num_2 + num_3 + num_4 + num_6 + num_7  + num_8 + num_9) % const\n        return total\n            \n            \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        path={\n            0:[4,6],\n            1:[6,8],\n            2:[7,9],\n            3:[4,8],\n            4:[0,3,9],\n            5:[],\n            6:[0,1,7],\n            7:[2,6],\n            8:[1,3],\n            9:[2,4]\n        }\n        \n        @lru_cache\n        def paths(i,n):\n            #number of ways to jump from i n times          \n            if n==1:\n                return len(path[i])\n            if n==0:\n                return 1\n            s=0\n            for v in path[i]:\n                s+=paths(v,n-1)\n            return s\n        ans=0\n        for k in path:\n            ans+=paths(k,n-1)\n        return ans%(10**9+7)\n                \n            \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        if N==0: return 0\n        \n        dp = [1]*10\n        \n        for i in range(N-1):\n            temp = [0]*10\n            temp[1], temp[2], temp[3] = dp[6]+dp[8], dp[7]+dp[9], dp[4]+dp[8]\n            temp[4], temp[5], temp[6]  = dp[3]+dp[0]+dp[9], 0, dp[1]+dp[7]+dp[0]\n            temp[7], temp[8], temp[9]  = dp[2]+dp[6], dp[1]+dp[3], dp[2]+dp[4]\n            temp[0] = dp[4]+dp[6]\n            dp = temp\n            \n        \n        \n        return sum(dp)%(10**9+7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        D = [[0] * 10 for _ in range(2)]\n        D[0] = [1] * 10\n        for i in range(1, N):\n            idx = i % 2\n            P = D[(i-1)%2]\n            D[idx][1] = P[8] + P[6]\n            D[idx][2] = P[7] + P[9]\n            D[idx][3] = P[4] + P[8]\n            D[idx][4] = P[3] + P[9] + P[0]\n            D[idx][5] = 0\n            D[idx][6] = P[1] + P[7] + P[0]\n            D[idx][7] = P[2] + P[6]\n            D[idx][8] = P[1] + P[3]\n            D[idx][9] = P[2] + P[4]\n            D[idx][0] = P[4] + P[6]\n            \n        return sum(D[(N+1)%2]) % (10**9 + 7)", "mexp = 10 ** 9 + 7\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [1 for x in range(10)]\n        for _ in range(n - 1):\n            ndp = [0 for x in range(10)]\n            ndp[0] = (dp[4] + dp[6]) % mexp\n            ndp[1] = (dp[6] + dp[8]) % mexp\n            ndp[2] = (dp[7] + dp[9]) % mexp\n            ndp[3] = (dp[4] + dp[8]) % mexp\n            ndp[4] = (dp[3] + dp[9] + dp[0]) % mexp\n            ndp[5] = 0\n            ndp[6] = (dp[1] + dp[7] + dp[0]) % mexp\n            ndp[7] = (dp[2] + dp[6]) % mexp\n            ndp[8] = (dp[1] + dp[3]) % mexp\n            ndp[9] = (dp[2] + dp[4]) % mexp\n            dp = ndp\n        return sum(dp) % mexp", "import numpy as np\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        mod = 10**9 + 7\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        res = np.matrix([[1]*10])\n\n        N -= 1\n        while N:\n            if N % 2 != 0: \n                res = res * M % mod     \n                N -= 1\n            else:\n                M = M * M % mod\n                N /= 2\n        return int(np.sum(res)) % mod\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        mexp = 10 ** 9 + 7\n        dp = [1 for x in range(10)]\n        for i in range(n - 1):\n            ndp = [0 for x in range(10)]\n            ndp[0] = (dp[4] + dp[6]) % mexp\n            ndp[1] = (dp[6] + dp[8]) % mexp\n            ndp[2] = (dp[7] + dp[9]) % mexp\n            ndp[3] = (dp[4] + dp[8]) % mexp\n            ndp[4] = (dp[0] + dp[3] + dp[9]) % mexp\n            ndp[5] = 0\n            ndp[6] = (dp[0] + dp[1] + dp[7]) % mexp\n            ndp[7] = (dp[2] + dp[6]) % mexp\n            ndp[8] = (dp[1] + dp[3]) % mexp\n            ndp[9] = (dp[2] + dp[4]) % mexp\n            dp = ndp\n        return sum(dp) % mexp", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n==1:\n            return 10\n        a_0 = 1\n        a_1 = 1\n        a_2 = 1\n        a_3 = 1\n        a_4 = 1\n        a_5 = 0\n        a_6 = 1\n        a_7 = 1\n        a_8 = 1\n        a_9 = 1\n        A= [a_0,a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9]\n        def count_next_moves(A):\n            result =[]\n            result.append(A[6]+A[4])\n            result.append(A[6]+A[8])\n            result.append(A[7]+A[9])\n            result.append(A[4]+A[8])\n            result.append(A[3]+A[9]+A[0])\n            result.append(0)\n            result.append(A[1]+A[7]+A[0])\n            result.append(A[6]+A[2])\n            result.append(A[1]+A[3])\n            result.append(A[2]+A[4])\n            return result\n        for i in range(n-1):\n            A = count_next_moves(A)\n        result = (sum(A)%((10**9) + 7))\n        return result\n                \n                \n\n        \n        \n                    \n                                \n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        D = [[0] * 10 for _ in range(N)]\n        D[0] = [1] * 10\n        for i in range(1, N):\n            P = D[i-1]\n            D[i][1] = P[8] + P[6]\n            D[i][2] = P[7] + P[9]\n            D[i][3] = P[4] + P[8]\n            D[i][4] = P[3] + P[9] + P[0]\n            D[i][5] = 0\n            D[i][6] = P[1] + P[7] + P[0]\n            D[i][7] = P[2] + P[6]\n            D[i][8] = P[1] + P[3]\n            D[i][9] = P[2] + P[4]\n            D[i][0] = P[4] + P[6]\n            \n        return sum(D[-1]) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n#         if N < 1: return 0\n#         modnum = 10**9 + 7\n#         memo = defaultdict(lambda:0)\n\n#         def dfs(y, x, cnt):\n#             nonlocal modnum, memo, N\n#             if (y,x) == (3,0) or (y,x) == (3,2):\n#                 return 0\n#             elif cnt == N:\n#                 return 1\n#             elif (y, x, cnt) in memo:\n#                 return memo[(y, x, cnt)]\n            \n#             tmpcnt = 0\n\n#             for (nxy, nxx) in ((y-1, x-2), (y-2, x-1), (y-2, x+1), (y-1, x+2), (y+1, x+2), (y+2, x+1), (y+2, x-1), (y+1, x-2)):\n#                 if(0<=nxy<4 and 0<=nxx<3):\n#                     tmpcnt += dfs(nxy, nxx, cnt+1)\n#                     tmpcnt %= modnum\n            \n#             memo[(y, x, cnt)] = tmpcnt\n#             return memo[(y, x, cnt)]\n            \n#         return sum(dfs(y,x,1) for y in range(4) for x in range(3))%modnum\n        \n        #\u8d85\u7ea7\u5feb\u7684\u7248\u672c\n    #     self.moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n    #     return sum(self.dfs(N, i) for i in range(10)) % (10**9+7)\n    # def dfs(self, N, i, dp={}):\n    #     if N == 1: return 1\n    #     if (N,i) not in dp:\n    #         dp[(N,i)] = sum(self.dfs(N-1, j) for j in self.moves[i])%(10**9+7)\n    #     return dp[(N,i)]\n        \n        #O(N) solution no dfs\n        if N == 1: return 10;\n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        mod = 1e9+7\n        \n        for i in range(N-1):\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = (ends_in[4] + ends_in[6]) % mod\n            next_ends_in[1] = (ends_in[6] + ends_in[8]) % mod\n            next_ends_in[2] = (ends_in[7] + ends_in[9]) % mod\n            next_ends_in[3] = (ends_in[4] + ends_in[8]) % mod\n            next_ends_in[4] = (ends_in[3] + ends_in[9] + ends_in[0]) % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = (ends_in[1] + ends_in[7] + ends_in[0]) % mod\n            next_ends_in[7] = (ends_in[2] + ends_in[6]) % mod\n            next_ends_in[8] = (ends_in[1] + ends_in[3]) % mod\n            next_ends_in[9] = (ends_in[2] + ends_in[4]) % mod\n            ends_in = next_ends_in\n        \n        return int(sum(ends_in) % mod)\n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dp = [1] * 10\n        MOD = 10 ** 9 + 7\n        \n        for i in range(2, n+1):\n            old_dp = dp.copy()\n            \n            dp[0] = old_dp[4] + old_dp[6]\n            dp[1] = old_dp[6] + old_dp[8]\n            dp[2] = old_dp[7] + old_dp[9]\n            dp[3] = old_dp[4] + old_dp[8]\n            dp[4] = old_dp[3] + old_dp[9] + old_dp[0]\n            dp[5] = 0\n            dp[6] = old_dp[1] + old_dp[7] + old_dp[0]\n            dp[7] = old_dp[2] + old_dp[6]\n            dp[8] = old_dp[1] + old_dp[3]\n            dp[9] = old_dp[2] + old_dp[4]\n        \n        ans = sum(dp) % MOD\n        \n        return ans", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        dialer = {}\n        for i in range(10):\n            dialer[i] = 1\n        for j in range(n):\n            store = [dialer[k] for k in dialer]\n            dialer[0] = store[4] + store[6]\n            dialer[1] = store[8] + store[6]\n            dialer[2] = store[9] + store[7]\n            dialer[3] = store[8] + store[4]\n            dialer[4] = store[0] + store[9] + store[3]\n            dialer[5] = 0\n            dialer[6] = store[0] + store[7] + store[1]\n            dialer[7] = store[2] + store[6]\n            dialer[8] = store[1] + store[3]\n            dialer[9] = store[2] + store[4]\n        return sum(store) % (10 ** 9 + 7)", "import numpy as np\nclass Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        mod = 10**9 + 7\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        res = np.matrix([[1]*10])\n\n        N -= 1\n        while N:\n            if N % 2 != 0: \n                res = res * M % mod     \n                N -= 1\n            else:\n                print(M)\n                M = M * M % mod\n                print(M)\n                N /= 2\n        return int(np.sum(res)) % mod\n                \n        \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        len_start_number = {}\n        mod_num = 1000000007\n        len_start_number = {(1,i): 1 for i in range(0,10)}\n        for i in range(2,n+1):\n            len_start_number[(i,1)] = (len_start_number[(i-1,4)] + len_start_number[(i-1,8)]) % mod_num \n            len_start_number[(i,2)] = (len_start_number[(i-1,7)] * 2) % mod_num\n            len_start_number[(i,4)] = (len_start_number[(i-1,1)] + len_start_number[(i-1,7)] + len_start_number[(i-1,0)]) % mod_num\n            len_start_number[(i,5)] = 0\n            len_start_number[(i,7)] = (len_start_number[(i-1,2)] + len_start_number[(i-1,4)]) % mod_num\n            len_start_number[(i,8)] = (len_start_number[(i-1,1)] * 2) % mod_num\n            len_start_number[(i,0)] = (len_start_number[(i-1,4)] * 2) % mod_num\n        \n        count = 0\n        for k in [0,1,2,4,5,7,8]:\n            if k in [1,4,7]:\n                count += (2 * len_start_number[(n,k)]) % mod_num\n            else:\n                count += len_start_number[(n,k)] % mod_num\n        return count % mod_num\n            \n", "import numpy as np\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        M = np.matrix([\n            [0,0,0,0,1,0,1,0,0,0],\n            [0,0,0,0,0,0,1,0,1,0], \n            [0,0,0,0,0,0,0,1,0,1], \n            [0,0,0,0,1,0,0,0,1,0], \n            [1,0,0,1,0,0,0,0,0,1], \n            [0,0,0,0,0,0,0,0,0,0], \n            [1,1,0,0,0,0,0,1,0,0], \n            [0,0,1,0,0,0,1,0,0,0], \n            [0,1,0,1,0,0,0,0,0,0], \n            [0,0,1,0,1,0,0,0,0,0]\n        ])\n\n        dp = [1,1,1,1,1,1,1,1,1,1]\n        f = M\n        n = n - 1\n        while n > 0:\n            if n % 2:\n                dp = dp * M % 1000000007\n            n = n // 2\n            M = M * M % 1000000007\n        return np.sum(dp) % 1000000007\n            \n# class Solution:\n#     def knightDialer(self, n: int) -> int:\n#         path = [(4, 6), (6, 8), (7, 9), (4, 8),\n#                (0, 3, 9), (), (0, 1, 7),\n#                (2, 6), (1, 3), (2, 4)]\n#         memo = []\n#         for i in range(n+1):\n#             memo.append({})\n#             for j in range(10):\n#                 memo[i][j] = -1\n        \n#         def dp(num, steps):\n#             if steps == 1:\n#                 return 1\n#             if memo[steps][num] != -1:\n#                 return memo[steps][num]\n#             ret = 0\n#             for i in path[num]:\n#                 ret += dp(i, steps-1)\n#             memo[steps][num] = ret\n#             return ret % 1000000007\n        \n#         res = 2 * (dp(1, n) + dp(4, n) + dp(7, n)) + dp(2, n) + dp(5, n) + dp(8, n) + dp(0, n)\n#         res %= 1000000007\n#         return res\n", "#bfs solution\n\n#graph problem\n\n\n\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1: return 10\n        chessmap = {1:[4,2], 2:[1,3], 3:[4,2], 4:[3,1,0], 0:[4,4]}\n        table = [1]*5\n        for i in range(2, n+1):\n            tmp = [0] * 5\n            for j in range(5):\n                for k in chessmap[j]:\n                    tmp[j] += table[k]\n            table = tmp\n        return (sum(table)*2-table[0]) % (10**9+7)", "class Solution:\n    def knightDialer(self, l: int) -> int:\n        dpTable = [1] * 10\n        for _ in range(l - 1):\n            newTable = [0] * 10\n            for i in [0, 1, 2, 3, 4, 6, 7, 8, 9]:\n                if i == 0:\n                    ret = dpTable[4] + dpTable[6]\n                elif i == 1:\n                    ret = dpTable[6] + dpTable[8]\n                elif i == 2:\n                    ret = dpTable[7] + dpTable[9]\n                elif i == 3:\n                    ret = dpTable[4] + dpTable[8]\n                elif i == 4:\n                    ret = dpTable[3] + dpTable[9] + dpTable[0]\n                elif i == 6:\n                    ret = dpTable[1] + dpTable[7] + dpTable[0]\n                elif i == 7:\n                    ret = dpTable[2] + dpTable[6]\n                elif i == 8:\n                    ret = dpTable[1] + dpTable[3]\n                elif i == 9:\n                    ret = dpTable[2] + dpTable[4]\n                newTable[i] = ret % 1000000007\n            dpTable = newTable\n        return sum(dpTable) % 1000000007\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        D = 10**9 + 7\n        l = [1 for _ in range(10)]\n        for _ in range(N-1):\n            l = self.transform_list(l)\n            l = [x % D for x in l]\n        return sum(l) % D\n        \n        \n    def transform_list(self, l: List[int]) -> List[int]:\n        # 0 -> 4, 6\n        # 1 -> 6, 8\n        # 2 -> 7, 9\n        # 3 -> 4, 8\n        # 4 -> 3, 9, 0\n        # 5 -> None\n        # 6 -> 1, 7, 0\n        # 7 -> 2, 6\n        # 8 -> 1, 3\n        # 9 -> 2, 4\n        nl = [0 for _ in range(10)]\n        nl[0] = l[4] + l[6]\n        nl[1] = l[6] + l[8]\n        nl[2] = l[7] + l[9]\n        nl[3] = l[4] + l[8]\n        nl[4] = l[3] + l[9] + l[0]\n        nl[6] = l[1] + l[7] + l[0]\n        nl[7] = l[2] + l[6]\n        nl[8] = l[1] + l[3]\n        nl[9] = l[2] + l[4]\n        return nl\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return n\n        pad = []\n        for i in range(4):\n            pad.append([1]*3)\n        pad[3][0] = 0\n        pad[3][2] = 0\n        for k in range(n-1):\n            newPad = []\n            for i in range(4):\n                newPad.append([1]*3)\n            newPad[0][0] = (pad[1][2] + pad[2][1])%(10**9 + 7)\n            newPad[0][1] = (pad[2][0] + pad[2][2])%(10**9 + 7)\n            newPad[0][2] = (pad[1][0] + pad[2][1])%(10**9 + 7)\n            newPad[1][0] = (pad[0][2] + pad[2][2] + pad[3][1])%(10**9 + 7)\n            newPad[1][1] = 0\n            newPad[1][2] = (pad[0][0] + pad[2][0] + pad[3][1])%(10**9 + 7)\n            newPad[2][0] = (pad[1][2] + pad[0][1])%(10**9 + 7)\n            newPad[2][1] = (pad[0][0] + pad[0][2])%(10**9 + 7)\n            newPad[2][2] = (pad[0][1] + pad[1][0])%(10**9 + 7)\n            newPad[3][0] = 0\n            newPad[3][1] = (pad[1][0] + pad[1][2])%(10**9 + 7)\n            newPad[3][2] = 0\n            pad = newPad\n        total = 0\n        for i in range(len(pad)):\n            total += sum(pad[i])\n        return total%(10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        dp = [[0] * 10 for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                dp[i] = [1] * 10\n                continue\n            dp[i][0] = dp[i-1][4] + dp[i-1][6]\n            dp[i][1] = dp[i-1][8] + dp[i-1][6]\n            dp[i][2] = dp[i-1][7] + dp[i-1][9]\n            dp[i][3] = dp[i-1][4] + dp[i-1][8]\n            dp[i][4] = dp[i-1][0] + dp[i-1][3] + dp[i-1][9]\n            dp[i][5] = 0\n            dp[i][6] = dp[i-1][0] + dp[i-1][1] + dp[i-1][7]\n            dp[i][7] = dp[i-1][2] + dp[i-1][6]\n            dp[i][8] = dp[i-1][1] + dp[i-1][3]\n            dp[i][9] = dp[i-1][2] + dp[i-1][4]\n        #print(dp)\n        return sum(dp[-1]) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        \n        dp = [0] * 10\n        \n        for j in range(10):\n            dp[j] = 1\n\n        for i in range(1, N):\n            tmp0 = (dp[4] + dp[6]) % (math.pow(10,9) + 7)\n            tmp1 = (dp[6] + dp[8]) % (math.pow(10,9) + 7)\n            tmp2 = (dp[7] + dp[9]) % (math.pow(10,9) + 7)\n            tmp3 = (dp[4] + dp[8]) % (math.pow(10,9) + 7)\n            tmp4 = (dp[0] + dp[3] + dp[9]) % (math.pow(10,9) + 7)\n            tmp5 = 0\n            tmp6 = (dp[0] + dp[1] + dp[7]) % (math.pow(10,9) + 7)\n            tmp7 = (dp[2] + dp[6]) % (math.pow(10,9) + 7)\n            tmp8 = (dp[1] + dp[3]) % (math.pow(10,9) + 7)\n            tmp9 = (dp[2] + dp[4]) % (math.pow(10,9) + 7)\n            \n            dp[0] = tmp0\n            dp[1] = tmp1\n            dp[2] = tmp2\n            dp[3] = tmp3\n            dp[4] = tmp4\n            dp[5] = tmp5\n            dp[6] = tmp6\n            dp[7] = tmp7\n            dp[8] = tmp8\n            dp[9] = tmp9\n            \n        total = 0\n        for j in range(10):\n            if N > 1 and j == 5: continue\n            total += dp[j]\n            \n                \n        total = int(total % (math.pow(10,9) + 7))\n        return total\n            \n                \n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 0:\n            return n\n        pad = []\n        for i in range(4):\n            pad.append([1]*3)\n        pad[3][0] = 0\n        pad[3][2] = 0\n        for k in range(n-1):\n            newPad = []\n            for i in range(4):\n                newPad.append([1]*3)\n            newPad[0][0] = pad[1][2] + pad[2][1]\n            newPad[0][1] = pad[2][0] + pad[2][2]\n            newPad[0][2] = pad[1][0] + pad[2][1]\n            newPad[1][0] = pad[0][2] + pad[2][2] + pad[3][1]\n            newPad[1][1] = 0\n            newPad[1][2] = pad[0][0] + pad[2][0] + pad[3][1]\n            newPad[2][0] = pad[1][2] + pad[0][1]\n            newPad[2][1] = pad[0][0] + pad[0][2]\n            newPad[2][2] = pad[0][1] + pad[1][0]\n            newPad[3][0] = 0\n            newPad[3][1] = pad[1][0] + pad[1][2]\n            newPad[3][2] = 0\n            pad = newPad\n        total = 0\n        for i in range(len(pad)):\n            total += sum(pad[i])\n        return total%(10**9 + 7)", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        T = [[0] * (N+1) for i in range(10)]\n        for i in range(10):\n            T[i][1] = 1\n        for step in range(2, N+1):\n            T[0][step] = T[4][step-1] + T[6][step-1]\n            T[1][step] = T[8][step-1] + T[6][step-1]\n            T[2][step] = T[7][step-1] + T[9][step-1]\n            T[3][step] = T[4][step-1] + T[8][step-1]\n            T[4][step] = T[3][step-1] + T[9][step-1] + T[0][step-1]\n            T[5][step] = 0\n            T[6][step] = T[1][step-1] + T[7][step-1] + T[0][step-1]\n            T[7][step] = T[6][step-1] + T[2][step-1]\n            T[8][step] = T[1][step-1] + T[3][step-1]\n            T[9][step] = T[2][step-1] + T[4][step-1]\n        return sum([T[i][N] for i in range(10)]) % (pow(10, 9) + 7)\n", "class Solution:\n        \n    def knightDialer(self, n: int) -> int:\n        import numpy as np\n        mod = 10**9 + 7\n        if n == 1: return 10\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\n        res = np.matrix([[1]*10])\n        n -= 1\n        while n:\n            if n % 2 != 0: \n                res = res * M % mod                \n                n -= 1\n            else:\n                M = M * M % mod\n                n /= 2\n        return int(np.sum(res)) % mod", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        if n == 1:\n            return 10\n        dp = [[1,1,1,1,1,0,1,1,1,1] for _ in range(n+1)]\n        for i in range(2, n+1):\n            dp[i][0] = dp[i-1][4] + dp[i-1][6]\n            dp[i][1] = dp[i-1][8] + dp[i-1][6]\n            dp[i][2] = dp[i-1][7] + dp[i-1][9]\n            dp[i][3] = dp[i-1][4] + dp[i-1][8]\n            dp[i][4] = dp[i-1][0] + dp[i-1][9] + dp[i-1][3]\n            dp[i][6] = dp[i-1][1] + dp[i-1][7] + dp[i-1][0]\n            dp[i][7] = dp[i-1][6] + dp[i-1][2]\n            dp[i][8] = dp[i-1][1] + dp[i-1][3]\n            dp[i][9] = dp[i-1][4] + dp[i-1][2]\n        return sum(dp[-1]) % (10**9 + 7)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        num = 0\n        stack = [(1, i, i) for i in range(10)]\n        pos = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}\n        memo = [[1]*10 for _ in range(n)]\n        for i in range(1,n):\n            memo[i][0] = memo[i-1][4] + memo[i-1][6]\n            memo[i][1] = memo[i-1][6] + memo[i-1][8]\n            memo[i][2] = memo[i-1][7] + memo[i-1][9]\n            memo[i][3] = memo[i-1][4] + memo[i-1][8]\n            memo[i][4] = memo[i-1][0] + memo[i-1][3] + memo[i-1][9]\n            memo[i][5] = 0\n            memo[i][6] = memo[i-1][1] + memo[i-1][7] + memo[i-1][0]\n            memo[i][7] = memo[i-1][2] + memo[i-1][6]\n            memo[i][8] = memo[i-1][1] + memo[i-1][3]\n            memo[i][9] = memo[i-1][2] + memo[i-1][4]\n\n        return sum(memo[-1]) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n#         moveable = {\n#         1: [6, 8],\n#         2: [7, 9],\n#         3: [4, 8],\n#         4: [0, 3, 9],\n#         5: [],\n#         6: [0, 1, 7],\n#         7: [2, 6],\n#         8: [1, 3],\n#         9: [2, 4],\n#         0: [4, 6]\n#         }\n#         MOD = 7 + 1e9\n#         @lru_cache(maxsize=None)\n#         def helper(step, num=-1):\n#             if step == n:\n#                 return 1\n\n#             result = 0\n#             if num == -1:\n#                 for i in range(10):\n#                     result = (result + helper(step + 1, i)) % MOD\n#             else:\n#                 for move in moveable[num]:\n#                     result = (result + helper(step + 1, move)) % MOD\n#             return result\n\n#         return int(helper(0))\n    \n        moveable = {\n        1: [6, 8],\n        2: [7, 9],\n        3: [4, 8],\n        4: [0, 3, 9],\n        5: [],\n        6: [0, 1, 7],\n        7: [2, 6],\n        8: [1, 3],\n        9: [2, 4],\n        0: [4, 6]\n        }\n        MOD = 7 + 1e9\n\n        dp = [1] * 10\n        for step in range(n - 1):\n            newDP = [0] * 10\n            for key in range(10):\n                for move in moveable[key]:\n                    newDP[move] = (newDP[move] + dp[key]) % MOD\n            dp = newDP\n\n        return int(sum(dp) % MOD)", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        jump = {\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [3,9,0],\n            5: [],\n            6: [1,7,0],\n            7: [6,2],\n            8: [1,3],\n            9: [2,4],\n            0: [4,6]\n        }\n        \n        dp = [1]*10\n        for _ in range(n-1):\n            newDp = [1]*10\n            for i in range(10):\n                res = 0\n                for item in jump[i]:\n                    res += dp[item]\n                res %= 1000000007\n                newDp[i] = res\n            dp = newDp\n        return sum(dp)%1000000007", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        a, M = [1]*10, 10**9 + 7\n        moves = [(4,6), (6,8), (7,9), (4,8), (0,3,9), (), (0,1,7), (2,6), (1,3), (2,4)]\n        for _ in range(1, n):\n            b = [0]*10\n            for i in range(10):\n                for j in moves[i]:\n                    b[i] = (b[i] + a[j]) % M\n            a = b\n        \n        return sum(a)%M", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        dp = [1] * 10\n        MOD = 10 ** 9 + 7\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]]\n        \n        for hop in range(N - 1):\n            new_dp = [0] * 10\n            for num, count in enumerate(dp):\n                for neigh in moves[num]:\n                    new_dp[neigh] = (new_dp[neigh] + count) % MOD\n            dp = new_dp\n        \n        return sum(dp) % MOD", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        # Space O(10)\n        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\n        dp = [1] * 10\n        MOD = 10**9 + 7\n        for i in range(N - 1):\n            next_dp = [0] * 10\n            for j in range(10):\n                for next_digit in moves[j]:\n                    next_dp[j] = (next_dp[j] + dp[next_digit]) % MOD\n            dp = next_dp\n        return sum(dp) % MOD\n        \n        # space O(10 * N)\n        # mapping = {1:[6,8], \n        #            2:[7,9], \n        #            3:[4,8], \n        #            4:[3,9,0],\n        #            5:[],\n        #            6:[1,7,0],\n        #            7:[2,6], \n        #            8:[1,3], \n        #            9:[2,4], \n        #            0:[4,6]}\n        # dp = [[0] * 10 for _ in range(N)]\n        # dp[0] = [1] * 10\n        # for i in range(1, N):\n        #     for j in range(10):\n        #         for next_digit in mapping[j]:\n        #             dp[i][j] += dp[i - 1][next_digit]\n        # return sum(dp[-1]) % (10**9 + 7)\n", "class Solution:\n    def knightDialer(self, N: int) -> int:\n        moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\n        memo = [1]*10\n        maxV = (10**9+7)\n        for _ in range(N-1):\n            temp = [0]*10\n            for i in range(10):\n                for dest in moves[i]:\n                    temp[i] += memo[dest]\n                temp[i] %= maxV\n            memo = temp\n                    \n        return sum(memo)%maxV\n", "class Solution:\n    def knightDialer(self, n: int) -> int:\n        neighbors = {\n            0: [4,6],\n            1: [6,8],\n            2: [7,9],\n            3: [4,8],\n            4: [0,3,9],\n            5: [],\n            6: [0,1,7],\n            7: [2,6],\n            8: [1,3],\n            9: [2,4]\n        }\n        # def helper(pos, hops_left):\n        #     if hops_left == 1: return 1\n        #     if (pos, hops_left) in cache:\n        #         return cache[(pos, hops_left)]\n        #     else:\n        #         sequences = 0\n        #         for ne in neighbors[pos]:\n        #             sequences += helper(ne, hops_left-1)\n        #         cache[(pos, hops_left)] = sequences\n        #         # print(f\\\"seq {sequences} for (pos {pos}, hops_left {hops_left})\\\")\n        #         return sequences\n        # cache = {}\n        # counts = [0]*10\n        # for start in range(10):\n        #     counts[start] = helper(start, n)\n        #     # print(f\\\"counts[{start}] = {counts[start]}\\\")\n        # return sum(counts)%(10**9+7)\n        current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        for _ in range(n-1):\n            next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            for src_key in range(10):\n                for dst_key in neighbors[src_key]:\n                    next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\n            current_counts = next_counts\n        return sum(current_counts) % (10**9 + 7)"]
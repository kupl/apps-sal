["for _ in range(int(input())):\n    a1, b1 = list(map(int, input().split()))\n    a2, b2 = list(map(int, input().split()))\n    if a1 > b1:\n        a1, b1 = b1, a1\n    if a2 > b2:\n        a2, b2 = b2, a2\n    flag = False\n    if a1 == a2 and a1 == b1 + b2:\n        flag = True\n    if b1 == b2 and b1 == a1 + a2:\n        flag = True\n    print('Yes' if flag else 'No')\n", "t = int(input())\nfor _ in range(t):\n\ta1, b1 = map(int, input().split())\n\ta2, b2 = map(int, input().split())\n\tif a1 > b1:\n\t\ta1, b1 = b1, a1\n\tif a2 > b2:\n\t\ta2, b2 = b2, a2\n\n\tif b1 == b2 and a1 + a2 == b1:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "t = int(input())\nfor case in range(t):\n    a, b = list(map(int, input().split()))\n    c, d = list(map(int, input().split()))\n    if a == c and b + d == a:\n        print('Yes')\n    elif b == d and a + c == b:\n        print('Yes')\n    elif a == d and b + c == a:\n        print('Yes')\n    elif b == c and a + d == b:\n        print('Yes')\n    else:\n        print('No')", "import math\nfor _ in range(int(input())):\n    a,b=list(map(int,input().split()))\n    c,d=list(map(int,input().split()))\n    if min(c,d)+min(a,b)==max(a,b) and max(a,b)==max(c,d):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n", "import sys\n\n\n\nfor t in range(int(sys.stdin.readline())):\n\n\n\ta, b = list(map(int, sys.stdin.readline().split()))\n\tx, y = list(map(int, sys.stdin.readline().split()))\n\ta, b = min(a, b), max(a, b)\n\tx, y = min(x, y), max(x, y)\n\tif b == y and b == a + x:\n\t\tsys.stdout.write(\"Yes\\n\")\n\telse:\n\t\tsys.stdout.write(\"No\\n\")\n", "import sys,bisect,string,math,time,functools,random\nfrom heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nfrom itertools import permutations,combinations,groupby\ndef Golf():*a,=map(int,open(0))\ndef I():return int(input())\ndef S_():return input()\ndef IS():return input().split()\ndef LS():return [i for i in input().split()]\ndef LI():return [int(i) for i in input().split()]\ndef LI_():return [int(i)-1 for i in input().split()]\ndef NI(n):return [int(input()) for i in range(n)]\ndef NI_(n):return [int(input())-1 for i in range(n)]\ndef StoLI():return [ord(i)-97 for i in input()]\ndef ItoS(n):return chr(n+97)\ndef LtoS(ls):return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,ls=None,Directed=False,index=1):\n    org_inp=[];g=[[] for i in range(V)]\n    FromStdin=True if ls==None else False\n    for i in range(E):\n        if FromStdin:\n            inp=LI()\n            org_inp.append(inp)\n        else:\n            inp=ls[i]\n        if len(inp)==2:\n            a,b=inp;c=1\n        else:\n            a,b,c=inp\n        if index==1:a-=1;b-=1\n        aa=(a,c);bb=(b,c);g[a].append(bb)\n        if not Directed:g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\n    mp=[boundary]*(w+2);found={}\n    for i in range(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]\n    mp+=[boundary]*(w+2)\n    return h+2,w+2,mp,found\ndef TI(n):return GI(n,n-1)\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)];rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:print(*inp,end=end)\n\nYN=['YES','NO'];Yn=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\n#sys.setrecursionlimit(10**7)\ninput=lambda: sys.stdin.readline().rstrip()\n\nclass Tree:\n    def __init__(self,inp_size=None,init=True):\n        self.LCA_init_stat=False\n        self.ETtable=[]\n        if init:\n            self.stdin(inp_size)\n        return\n\n    def stdin(self,inp_size=None,index=1):\n        if inp_size==None:\n            self.size=int(input())\n        else:\n            self.size=inp_size\n        self.edges,_=GI(self.size,self.size-1,index=index)\n        return\n    \n    def listin(self,ls,index=0):\n        self.size=len(ls)+1\n        self.edges,_=GI(self.size,self.size-1,ls,index=index)\n        return\n\n    def __str__(self):\n        return  str(self.edges)\n\n    def dfs(self,x,func=lambda prv,nx,dist:prv+dist,root_v=0):\n        q=deque()\n        q.append(x)\n        v=[-1]*self.size\n        v[x]=root_v\n        while q:\n            c=q.pop()\n            for nb,d in self.edges[c]:\n                if v[nb]==-1:\n                    q.append(nb)\n                    v[nb]=func(v[c],nb,d)\n        return v\n\n    def EulerTour(self,x):\n        q=deque()\n        q.append(x)\n        self.depth=[None]*self.size\n        self.depth[x]=0\n        self.ETtable=[]\n        self.ETdepth=[]\n        self.ETin=[-1]*self.size\n        self.ETout=[-1]*self.size\n        cnt=0\n        while q:\n            c=q.pop()\n            if c<0:\n                ce=~c\n            else:\n                ce=c\n                for nb,d in self.edges[ce]:\n                    if self.depth[nb]==None:\n                        q.append(~ce)\n                        q.append(nb)\n                        self.depth[nb]=self.depth[ce]+1\n            self.ETtable.append(ce)\n            self.ETdepth.append(self.depth[ce])\n            if self.ETin[ce]==-1:\n                self.ETin[ce]=cnt\n            else:\n                self.ETout[ce]=cnt\n            cnt+=1\n        return\n    \n    def LCA_init(self,root):\n        self.EulerTour(root)\n        self.st=SparseTable(self.ETdepth,init_func=min,init_idl=inf)\n        self.LCA_init_stat=True\n        return\n    \n    def LCA(self,root,x,y):\n        if self.LCA_init_stat==False:\n            self.LCA_init(root)\n        xin,xout=self.ETin[x],self.ETout[x]\n        yin,yout=self.ETin[y],self.ETout[y]\n        a=min(xin,yin)\n        b=max(xout,yout,xin,yin)\n        id_of_min_dep_in_et=self.st.query_id(a,b+1)\n        return self.ETtable[id_of_min_dep_in_et]\n\nclass SparseTable: # O(N log N) for init, O(1) for query(l,r)\n    def __init__(self,ls,init_func=min,init_idl=float('inf')):\n        self.func=init_func\n        self.idl=init_idl\n        self.size=len(ls)\n        self.N0=self.size.bit_length()\n        self.table=[ls[:]]\n        self.index=[list(range(self.size))]\n        self.lg=[0]*(self.size+1)\n        \n        for i in range(2,self.size+1):\n            self.lg[i]=self.lg[i>>1]+1\n\n        for i in range(self.N0):\n            tmp=[self.func(self.table[i][j],self.table[i][min(j+(1<<i),self.size-1)]) for j in range(self.size)]\n            tmp_id=[self.index[i][j] if self.table[i][j]==self.func(self.table[i][j],self.table[i][min(j+(1<<i),self.size-1)]) else self.index[i][min(j+(1<<i),self.size-1)] for j in range(self.size)]\n            self.table+=[tmp]\n            self.index+=[tmp_id]\n    \n    # return func of [l,r)\n    def query(self,l,r):\n        #N=(r-l).bit_length()-1\n        N=self.lg[r-l]\n        return self.func(self.table[N][l],self.table[N][r-(1<<N)])\n    \n    # return index of which val[i] = func of v among [l,r)\n    def query_id(self,l,r):\n        #N=(r-l).bit_length()-1\n        N=self.lg[r-l]\n        a,b=self.index[N][l],self.index[N][r-(1<<N)]\n        if self.table[0][a]==self.func(self.table[N][l],self.table[N][r-(1<<N)]):\n            b=a\n        return b\n    \n    def __str__(self):\n        return str(self.table[0])\n        \n    def print(self):\n        for i in self.table:\n            print(*i)\n\nshow_flg=False\nshow_flg=True\nans=0\n\nT=I()\nfor _ in range(T):\n    a,b=LI()\n    c,d=LI()\n    if a>b:\n        a,b=b,a\n    if c>d:\n        c,d=d,c\n    ans='Yes' if b==d and a+c==b else 'No'\n    print(ans)\n\n", "q = int(input())\n\nfor _ in range(q):\n    a, b = list(map(int, input().split()))\n    c, d = list(map(int, input().split()))\n    a, b = min(a, b), max(a, b)\n    c, d = min(c, d), max(c, d)\n    if b == d and a+c == b:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n", "t=int(input())\nfor tests in range(t):\n    a1,b1=list(map(int,input().split()))\n    a2,b2=list(map(int,input().split()))\n\n    if min(a1,b1)+min(a2,b2)==max(a1,b1)==max(a2,b2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n", "for _ in range(int(input())):\n    a, b = list(map(int,input().split()))\n    c, d = list(map(int,input().split()))\n    if b > a:\n        a, b = b, a\n    if d > c:\n        c, d = d, c\n    if a == c == b+d:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n", "for __ in range(int(input())):\n\ta,b=map(int,input().split())\n\tx,y=map(int,input().split())\n\tif(a==x and b+y==x):\n\t\tprint(\"Yes\")\n\telif(a==y and b+x==y):\n\t\tprint(\"Yes\")\n\telif(b==x and a+y==x):\n\t\tprint(\"Yes\")\n\telif(b==y and a+x==y):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "t=int(input())\nfor i in range(t):\n    a,b=list(map(int,input().split()))\n    c,d=list(map(int,input().split()))\n    if max(a,b)==max(c,d):\n        if min(a,b)+min(c,d)==max(a,b):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n", "t = int(input())\nfor i in range(t):\n    a, b = list(map(int, input().split()))\n    c, d = list(map(int, input().split()))\n    if a + c == b == d or a + d == b == c or b + c == a == d or b + d == a == c:\n        print(\"Yes\")\n    else:\n        print(\"No\")", "for n in range(int(input())):\n\ta,b=map(int,input().split())\n\tc,d=map(int,input().split())\n\tm1=max(a,b)\n\tn1=min(a,b)\n\tm2=max(c,d)\n\tn2=min(c,d)\n\tif m1==m2 and n1+n2==m1:\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')", "a=int(input())\nfor i in range(a):\n    x,y=list(map(int,input().split()))\n    r,s=list(map(int,input().split()))\n    if(x==s and y+r==s):\n        print('Yes')\n    elif(x==r and y+s==x):\n        print('Yes')\n    elif(y==s and x+r==y):\n        print('Yes')\n    elif(y==r and x+s==y):\n        print('Yes')\n    else:\n        print('No')\n", "from sys import stdin, exit\ninput = stdin.readline\n\ndef i(): return input()\ndef ii(): return int(input())\ndef iis(): return list(map(int, input().split()))\ndef liis():\treturn list(map(int, input().split()))\ndef print_array(a): print(\" \".join(map(str, a)))\n\nt = ii()\nfor _ in range(t):\n\ta1, b1 = iis()\t\n\ta2, b2 = iis()\n\tif (a1 == a2 and b1+b2 == a1) or (a1 == b2 and a2+b1 == a1) or (a2 == b1 and a1+b2 == a2) or (b2 == b1 and a1+a2 == b2):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n", "T = int(input())\n\nfor t in range(T):\n  i1 = [int(i) for i in input().split(' ')]\n  i2 = [int(i) for i in input().split(' ')]\n  if i1[0]==i2[0] and i1[1]+i2[1]==i1[0]:\n    print('Yes')\n  elif i1[0]==i2[1] and i1[1]+i2[0]==i1[0]:\n    print('Yes')\n  elif i1[1]==i2[0] and i1[0]+i2[1]==i1[1]:\n    print('Yes')\n  elif i1[1]==i2[1] and i1[0]+i2[0]==i1[1]:\n    print('Yes')\n  else:\n    print('No')\n", "def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    a = list(read_ints())\n    b = list(read_ints())\n    ok = False\n    for i in range(2):\n        for j in range(2):\n            if a[i] != b[j]:\n                continue\n            if a[1 - i] + b[1 - j] == a[i]:\n                ok = True\n    print('Yes' if ok else 'No')\n", "q = int(input())\nfor i in range(q):\n    a1, b1 = map(int, input().split())\n    a2, b2 = map(int, input().split())\n    if max(a1, b1) == max(a2, b2) == (min(a1, b1) + min(a2, b2)):\n        print('Yes')\n    else:\n        print('No')"]
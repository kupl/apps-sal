["from collections import deque\nmoves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\n\ndef knight(p1, p2):\n    x, y = ord(p2[0])-97, int(p2[1])-1\n    left, seen = deque([(ord(p1[0])-97, int(p1[1])-1, 0)]), set()\n    while left:\n        i, j, v = left.popleft()\n        if i==x and j==y: return v\n        if (i, j) in seen: continue\n        seen.add((i, j))\n        for a,b in moves:\n            if 0 <= i+a < 8 and 0 <= j+b < 8:\n                left.append((i+a, j+b, v+1))", "def knight(p1, p2):\n    a, b = [('abcdefgh'.index(p[0]), int(p[1])) for p in [p1, p2]]\n    x, y = sorted((abs(a[0] - b[0]), abs(a[1] - b[1])))[::-1]\n\n    if (x, y) == (1, 0): return 3\n    if (x, y) == (2, 2) or ((x, y) == (1, 1) and any(p in ['a1','h1','a8','h8'] for p in [p1, p2])): return 4\n    \n    delta = x - y\n    \n    return delta - 2*((delta-y)//(3 if y > delta else 4))    ", "from copy import copy\nmove_map = ((-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1))\n\ndef algebraic_to_eucledian(pos):\n    return (int(pos[1]) - 1, 'abcdefgh'.index(pos[0]))\n\ndef knight(p1, p2):\n    p1, p2 = algebraic_to_eucledian(p1), algebraic_to_eucledian(p2)\n    num_moves = -1\n    visited = []\n    moves = [p1]\n    while moves:\n        next_moves = []\n        num_moves += 1\n        for move in moves:\n            if move == p2:\n                return num_moves\n            visited.append(move)\n            next_moves.extend([(move[0]+x, move[1]+y) for x, y in move_map if 0 <= move[0]+x < 8 and 0 <= move[1]+y < 8 and (move[0]+x, move[1]+y) not in visited])\n        moves = copy(next_moves)\n", "from collections import deque\nMOVES = [[1, -2], [1, 2], [2, -1], [2, 1], [-1, -2], [-1, 2], [-2, 1], [-2, -1]]\n\ndef knight(p1, p2):    \n    p1 = (8 - int(p1[1]), 'abcdefgh'.index(p1[0]))\n    p2 = (8 - int(p2[1]), 'abcdefgh'.index(p2[0]))\n    \n    Q = deque([(p1, -1)])\n    visited = set()\n    \n    while Q:\n        k, l = Q.popleft()\n        l += 1\n        visited.add(k)\n    \n        if k == p2 : return l\n    \n        for i, j in MOVES:\n            ni, nj = k[0] + i, k[1] + j\n            if 0 <= ni < 8 and 0 <= nj < 8 and (ni, nj) not in visited:\n                Q.append([(ni, nj),l])\n    return None", "# https://www.codewars.com/kata/shortest-knight-path/python\n\n# Function to transform from \"a1\" to \"[1,1]\", for example\ndef transformChessPointToMatrixPoint(point):\n    return [int(ord(point[0])-96),int(point[1])]\n\n# From a point in a matrix, check all possible moves as a knight and then remove every move out of the board.\ndef availableMoves(point):\n    moves = []\n    final_moves = []\n    moves.append([point[0]+2, point[1]+1])\n    moves.append([point[0]+2, point[1]-1])\n    moves.append([point[0]-2, point[1]+1])\n    moves.append([point[0]-2, point[1]-1])\n    moves.append([point[0]+1, point[1]+2])\n    moves.append([point[0]+1, point[1]-2])\n    moves.append([point[0]-1, point[1]+2])\n    moves.append([point[0]-1, point[1]-2])\n\n    # Return only the points IN the board\n    for move in moves:\n        if 1<=move[0]<=8 and 1<=move[1]<=8:\n            final_moves.append(move)\n    return final_moves\n\n# Main Function - Implementing Breadth First Search (kinda)\ndef knight(p1, p2):\n    #Transform Points from letters \"ky\" to \"[x,y]\" points\n    p1 = transformChessPointToMatrixPoint(p1)\n    p2 = transformChessPointToMatrixPoint(p2)\n    # Initialize visited nodes\n    already_visited = [p1]\n\n    # Queue to check and to find the minimum solution. A list of arrays where first is the point (array [x,y]) and second is the amount of steps done, initialized at 0.\n    to_check = [[p1,0]]\n\n    # While we have nodes to check\n    while len(to_check) > 0:\n\n        # If we have found the answer\n        if to_check[0][0] == p2:\n            # Return the amount of steps done\n            return to_check[0][1]\n\n        # Check available moves from point to_check[0][0]\n        moves_to_visit = availableMoves(to_check[0][0])\n        for move in moves_to_visit:\n            # If they have been visited once, we must not check them again\n            if move in already_visited:\n                pass\n            # First time checking the point\n            else:\n                # Added to visited nodes\n                already_visited.append(move)\n                # Added to the check \"queue\" and added 1 to the amount of steps\n                to_check.append([move,to_check[0][1]+1])\n        # Remove first node after being checked\n        to_check.pop(0)\n    # Return impossibility to reach an answer (just in case they enter an invalid point out of an 8x8 board)\n    return None    ", "def knight(p1, p2):\n    pos={'a':1,'b':2,'c':3,'d':4,'e':5,'f':6,'g':7,'h':8}\n    p1=[pos[p1[0]]-1,int(p1[1])-1]\n    p2=[pos[p2[0]]-1,int(p2[1])-1]\n    moves=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]\n    board=[]\n    for i in range(8): board.append([0,0,0,0,0,0,0,0])\n    board[p1[1]][p1[0]]=1\n    while True in [0 in ii for ii in board]:\n        for j in range(8):\n            for k in range(8):\n                for i in moves:\n                    new=[j+i[0],k+i[1]]\n                    if new[0] in range(8) and new[1] in range(8) and new!=p1 and board[k][j]!=0:\n                        if board[new[1]][new[0]]==0:\n                            board[new[1]][new[0]]=board[k][j]+1\n                        else:\n                            board[new[1]][new[0]]=min(board[k][j]+1,board[new[1]][new[0]])\n    return board[p2[1]][p2[0]]-1\n", "from itertools import chain\n\ndef knight(p1, p2):\n    p1,p2 = ('abcdefgh'.index(p1[0]),int(p1[1])-1), ('abcdefgh'.index(p2[0]),int(p2[1])-1)\n    span = [p1]\n    for i in range(8):\n        if p2 in span: return i\n        span = set(chain.from_iterable(map(lambda p: [(p[0]+i,p[1]+j) for (i,j) in [(1,2),(2,1),(-1,2),(-2,1),(1,-2),(2,-1),(-1,-2),(-2,-1)] if p[0]+i>=0 and p[1]+j>=0 and p[0]+i<8 and p[1]+j<8],span)))", "def knight(p1, p2):\n    from collections import deque\n\n    mapper = {1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\", 6: \"f\", 7: \"g\", 8: \"h\"}\n    mapper_inv = {\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5, \"f\": 6, \"g\": 7, \"h\": 8}\n    visited = set()\n    que = deque()\n\n    start_pos = tuple(p1)\n    start_pos = (int(mapper_inv[start_pos[0]]), int(start_pos[1]))\n\n    que.appendleft((start_pos, 1))\n\n    def _gen_move(spos):\n        \"\"\"\n        Generate next moves\n        eg. spos = (a, 1) == (1, 1) == (x, y)\n        \"\"\"\n        dx = [-2, -1, 1, 2, 2, 1, -1, -2]  # relative directions x\n        dy = [1, 2, 2, 1, -1, -2, -2, -1]  # relative directions y\n        for d in range(8):\n            nx = spos[0] + dx[d]\n            ny = spos[1] + dy[d]\n            if not 0 < nx < 9 or not 0 < ny < 9 and (nx, ny) not in visited:\n                continue\n            npos = (nx, ny)\n            visited.add(npos)\n            yield npos\n\n    while len(que) > 0:\n\n        # generate next positions and put them in que\n        sp, step = que.pop()\n        for nm in _gen_move(sp):\n            # check if next move is last\n            nm_ = mapper[nm[0]]+str(nm[1])\n            if nm_ == p2:\n                return step\n            que.appendleft((nm, step+1))", "import heapq\n\ndef knight(p1, p2):\n    heuristic = lambda f: max(abs(f[0] - p2[0]), abs(f[1] - p2[1])) // 2\n    p1, p2 = ((ord(p[0]) - ord('a'), int(p[1]) - 1) for p in (p1, p2))\n    pqueue = [(heuristic(p1), p1, 0)]\n    while pqueue:\n        _, (x, y), count = heapq.heappop(pqueue)\n        if (x, y) == p2:\n            return count\n        for dx, dy in ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)):\n            x2, y2 = x + dx, y + dy\n            if 0 <= x2 < 8 and 0 <= y2 < 8:\n                heapq.heappush(pqueue, (count + heuristic((x2, y2)), (x2, y2), count + 1))", "letter_to_number={\"a\":1, \"b\":2,\"c\":3,\"d\":4, \"e\":5, \"f\":6, \"g\":7, \"h\":8}\n\ndef possible_moves(p1):\n  possible_moves = ([1,2],[-1,2],[1,-2],[-1,-2],[2,1],[-2,1],[2,-1],[-2,-1])\n  new_positions=[]\n  for move in possible_moves:\n    if (0<(p1[0]+move[0])<=8) and (0<(p1[1]+move[1])<=8):\n      new_positions.append([(p1[0]+move[0]),(p1[1]+move[1])])\n  return new_positions\n  \ndef knight(p1, p2):\n  new_p1=[letter_to_number[p1[0]], int(p1[1])]\n  new_p2=[letter_to_number[p2[0]], int(p2[1])]\n  \n  if new_p2 in possible_moves(new_p1):\n    return 1\n\n  for move1 in possible_moves(new_p1):\n    if new_p2 in possible_moves(move1):\n      return 2\n      break\n  \n  for move1 in possible_moves(new_p1):\n    for move2 in possible_moves(move1):\n      if new_p2 in possible_moves(move2):\n        return 3\n\n  for move1 in possible_moves(new_p1):\n    for move2 in possible_moves(move1):\n      for move3 in possible_moves(move2):\n        if new_p2 in possible_moves(move3):\n          return 4\n          \n  for move1 in possible_moves(new_p1):\n    for move2 in possible_moves(move1):\n      for move3 in possible_moves(move2):\n        for move4 in possible_moves(move3):\n          if new_p2 in possible_moves(move4):\n            return 5\n  return 6\n        \n         \n  \n\n  \n  \n  \n"]
["class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         N = len(grid)\n         if N == 1:\n             return 0\n         \n         eleD = {}\n         for i in range(N):\n             for j in range(N):\n                 eleD[grid[i][j]] = (i,j)\n \n \n         C = [[0 for _ in range(N)] for _ in range(N)]\n         stack = set()\n         nextstack = set()\n         nextstack.add((0,0))\n         for t in range(grid[0][0],N*N):\n             if eleD[t] not in nextstack:\n                 continue\n             stack.add(eleD[t])\n             nextstack.remove(eleD[t])\n             while stack:\n                 (x,y) = stack.pop()\n                 if x == N-1 and y == N-1:\n                     return t\n                 C[x][y] = 1\n                 if x > 0:\n                     P = (x-1,y)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n                 if y > 0:\n                     P = (x,y-1)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n                 if x < N-1:\n                     P = (x+1,y)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n                 if y < N-1:\n                     P = (x,y+1)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n             print(t)\n                 \n                 \n \n         # eleD = {}\n         # for i in range(N):\n         #     for j in range(N):\n         #         eleD[grid[i][j]] = (i,j)\n         # res = grid\n         # for t in range(N*N):\n         #     (x,y) = eleD[t]\n         #     if x > 0:\n         #         if res[x-1][y] <= t:\n         #             temp = res[x-1][y]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     if y > 0:\n         #         if res[x][y - 1] <= t:\n         #             temp = res[x][y - 1]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     if x < N - 1:\n         #         if res[x + 1][y] <= t:\n         #             temp = res[x + 1][y]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     if y < N - 1:\n         #         if res[x][y + 1] <= t:\n         #             temp = res[x][y + 1]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     #print(t,res)\n         #     if res[0][0] == res[N-1][N-1]:\n         #         return t\n", "class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(grid)\n         flag = []\n         for i in range(n):\n             flag.append([0] * n)\n         flag[0][0] = 1\n         pos = [0] * (n * n)\n         for i in range(n):\n             for j in range(n):\n                 pos[grid[i][j]] = (i, j)\n \n                 \n         def search(x, y, n, grid, flag, k):\n             if x < 0 or x >= n or y < 0 or y >= n or flag[x][y] == 2:\n                 return\n             if grid[x][y] > k:\n                 flag[x][y] = 1\n             else:\n                 flag[x][y] = 2\n                 search(x - 1, y, n, grid, flag, k)\n                 search(x + 1, y, n, grid, flag, k)\n                 search(x, y - 1, n, grid, flag, k)\n                 search(x, y + 1, n, grid, flag, k)\n         for k in range(n * n):\n             x, y = pos[k]\n             if flag[x][y] == 1:\n                 search(x, y, n, grid, flag, k)\n             if flag[n - 1][n - 1] == 2:\n                 return k\n", "class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(grid)\n         pq = [(grid[0][0], 0, 0)]\n         seen = set([(0, 0)])\n         res = 0\n         while True:\n             val, y, x = heapq.heappop(pq)\n             res = max(res, val)\n             if y == x == n - 1:\n                 return res\n             for i, j in [(y + 1, x), (y - 1, x), (y, x + 1), (y, x - 1)]:\n                 if 0 <= i < n and 0 <= j < n and (i, j) not in seen:\n                     seen.add((i, j))\n                     heapq.heappush(pq, (grid[i][j], i, j))\n         return 0\n", "import heapq\n \n class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         q = [(grid[0][0], (0, 0))]\n         n = len(grid)\n         grid[0][0] = -1\n         \n         dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n         \n         while q:\n             val = heapq.heappop(q)\n             i = val[1][0]\n             j = val[1][1]\n             \n             if i == j == n - 1:\n                 return val[0]\n             \n             for d in dirs:\n                 x = i + d[0]\n                 y = j + d[1]\n                 \n                 if 0 <= x < n and 0 <= y < n and grid[x][y] != -1:\n                     heapq.heappush(q, (max(grid[x][y], val[0]), (x, y)))\n                     grid[x][y] = -1\n         \n         return -1\n         \n         \n                     \n                     \n                     \n         ", "import heapq\n class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         def neighbors(n, x, y):\n             neighbors = []\n             if 0 <= x+1 < n and 0 <= y < n: neighbors.append((x+1, y))\n             if 0 <= x-1 < n and 0 <= y < n: neighbors.append((x-1, y))\n             if 0 <= x < n and 0 <= y+1 < n: neighbors.append((x, y+1))\n             if 0 <= x < n and 0 <= y-1 < n: neighbors.append((x, y-1))\n             return neighbors\n                 \n             \n         \n         n = len(grid)\n         \n         poss = set((0,0))\n         pq = [(grid[0][0],0,0)]\n         maxx = 0\n         while pq:\n             elem, x, y = heapq.heappop(pq)\n             maxx = max(maxx, elem)\n             for newx, newy in neighbors(n, x, y):\n                 if newx == n-1 and newy == n-1:\n                     return max(maxx, grid[n-1][n-1])\n                 if (newx, newy) not in poss:\n                     poss.add((newx, newy))\n                     # neighborval = grid[newx][newy]\n                     # if neighborval <= elem:\n                     heapq.heappush(pq, (grid[newx][newy], newx, newy))\n             # print(pq)\n         return maxx\n                     \n             \n             \n         ", "class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         N, pq, seen, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\n         while True:\n             T, x, y = heapq.heappop(pq)\n             res = max(res, T)\n             if x == y == N - 1:\n                 return res\n             for i, j in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\n                 if 0 <= i < N and 0 <= j < N and (i, j) not in seen:\n                     seen.add((i, j))\n                     heapq.heappush(pq, (grid[i][j], i, j))", "class Solution:\n     def swimInWater(self, grid):\n         \"\"\"\n         :type grid: List[List[int]]\n         :rtype: int\n         \"\"\"\n         m, n = len(grid), len(grid[0])\n         seen = set()\n         seen.add((0, 0))\n         heap = [(grid[0][0], 0, 0)]\n         ans = 0\n         while heap:\n             h, i, j = heapq.heappop(heap)\n             ans = max(ans, h)\n             if i == m-1 and j == n-1:\n                 return ans\n             for a, b in [[i-1, j], [i+1, j], [i, j-1], [i, j+1]]:\n                 if 0 <= a < m and 0 <= b < n and (a, b) not in seen:\n                     heapq.heappush(heap, (grid[a][b], a, b))\n                     seen.add((a, b))\n"]
["w=list(input());n=len(w);t=-1\ndef Z(s):\n    m=len(s);z=[0]*m;c=0;f=[1]*m;\n    for i in range(1,m):\n        if i+z[i-c]<c+z[c]:z[i]=z[i-c]\n        else:\n            j=max(0,c+z[c]-i)\n            while i+j<n and s[j]==s[i+j]:j=j+1\n            z[i]=j;c=i\n    for p in range(1,m):\n        for k in range(2,z[p]//p+2):f[k*p-1]=0\n    return f\nfor j in range(1,n//2+1):\n    if n%j==0 and w[:n-j]==w[j:]:t=j;break;\nif t==-1:print ('1\\n1')\nelif t==1:print (n);print((1))\nelse:\n    zl=Z(w)\n    w.reverse()\n    zr=Z(w)\n    cnt=0\n    for i in range(0,n-1):\n        if zl[i] and zr[n-2-i]:cnt=cnt+1\n    print((2));print(cnt);\n", "from collections import Counter\n*W, = map(ord, input())\nN = len(W)\n\nC = Counter(W)\nif len(C) == 1:\n    print(N)\n    print(1)\n    return\n\ndef z_algo(S):\n    A = [0]*N\n    i = 1; j = 0\n    A[0] = l = len(S)\n    while i < l:\n        while i+j < l and S[j] == S[i+j]:\n            j += 1\n        A[i] = j\n        if not j:\n            i += 1\n            continue\n        k = 1\n        while l-i > k < j - A[k]:\n            A[i+k] = A[k]\n            k += 1\n        i += k; j -= k\n    return A\n\ndef calc(W):\n    Z = z_algo(W)\n    G = [0]*N\n    for i in range(N):\n        G[i] = 1\n    for p in range(1, N):\n        if not G[p-1]:\n            continue\n        for k in range(2, Z[p]//p+2):\n            G[k*p-1] = 0\n    return G\nG0 = calc(W)\nW.reverse()\nG1 = calc(W)\n\nif G0[N-1]:\n    print(1)\n    print(1)\n    return\n\nprint(2)\nprint(sum(p and q for p, q in zip(G0[:-1], reversed(G1[:-1]))))", "import sys\nreadline = sys.stdin.readline\n\nclass Rollinhash:\n    def __init__(self, S):\n        N = len(S)\n        self.mod = 10**9+9\n        self.base = 2009          \n        self.has = [0]*(N+1)\n        self.power = [1]*(N+1)\n        for i in range(N):\n            s = S[i]\n            self.has[i+1] = (self.has[i]*self.base + s)%self.mod\n            self.power[i+1] = self.power[i]*self.base%self.mod\n \n    def rh(self, i, j):\n        return (self.has[j] - self.has[i]*self.power[j-i])%self.mod\n\nMOD = 10**9+7\n \nS = list(map(ord, readline().strip()))\nN = len(S)\nif len(set(S)) == 1:\n    print(N)\n    print((1))\nelse:\n    Rs = Rollinhash(S)\n    \n    tabler = [True]*(N+1)\n    for d in range(1, 1+N//2):\n        r = Rs.rh(0, d)\n        for i in range(1, N//d):\n            if r != Rs.rh(i*d, (i+1)*d):\n                break\n            tabler[(i+1)*d] = False\n    tablel = [True]*(N+1)\n    for d in range(1, 1+N//2):\n        r = Rs.rh(N-d, N)\n        for i in range(1, N//d):\n            if r != Rs.rh(N-(i+1)*d, N-i*d):\n                break\n            tablel[N-(i+1)*d] = False\n    \n    if tabler[N]:\n        print((1))\n        print((1))\n    else:\n        print((2))\n        ans = 0\n        for i in range(N+1):\n            if tabler[i] and tablel[i]:\n                ans += 1\n        assert ans > 0, ''\n        print(ans)\n", "w=list(input())\nn=len(w)\nt=-1\ndef Z(s):\n    m=len(s);z=[0]*m;c=0;f=[1]*m;\n    for i in range(1,m):\n        if i+z[i-c]<c+z[c]:z[i]=z[i-c]\n        else:\n            j=max(0,c+z[c]-i)\n            while i+j<n and s[j]==s[i+j]:j=j+1\n            z[i]=j;c=i\n    for p in range(1,m):\n        for k in range(2,z[p]//p+2):f[k*p-1]=0\n    return f\nfor j in range(1,n//2+1):\n    if n%j==0 and w[:n-j]==w[j:]:t=j;break;\nif t==-1:print ('1\\n1')\nelif t==1:print (n);print((1))\nelse:\n    zl=Z(w)\n    w.reverse()\n    zr=Z(w)\n    cnt=0\n    for i in range(0,n-1):\n        if zl[i] and zr[n-2-i]:cnt=cnt+1\n    print((2));print(cnt);\n", "def Z_algorithm(S):\n    l=len(S)\n    A=[0]*l\n    A[0]=l\n    i=1; j=0\n    while i<l:\n        while i+j<l and S[j]==S[i+j]:\n            j+=1\n        if not j:\n            i+=1\n            continue\n        A[i]=j\n        k=1\n        while l-i>k<j-A[k]:\n            A[i+k]=A[k]\n            k+=1\n        i+=k; j-=k\n    return A\n\ndef jugde(W):\n    Z=Z_algorithm(W)\n    l=len(W)\n    B=[True]*l\n    for p in range(1,l):\n        if not B[p-1]:\n            continue\n        k=2\n        while (k-1)*p<=Z[p]:\n            B[k*p-1]=False\n            k+=1\n    return B\n\ndef solve(W):\n    n=len(W)\n    if len(set(W))==1:\n        print(n)\n        print(1)\n        return\n    G=jugde(W)\n    W.reverse()\n    G_rev=jugde(W)\n    if G[-1]:\n        print(1)\n        print(1)\n        return\n    print(2)\n    cnt=0\n    for i in range(n-1):\n        cnt+=G[i] and G_rev[-(i+2)]\n    print(cnt)\n    return\n\nsolve(list(input()))"]
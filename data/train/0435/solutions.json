["# Calculate the prefix sum and count it.\n# In c++ and java, a % K + K takes care of the cases where a < 0.\n# Python\n\nclass Solution: \n    def subarraysDivByK(self, A, K):\n        res = 0\n        prefix = 0\n        count = [1] + [0] * K\n        for a in A:\n            prefix = (prefix + a) % K\n            res += count[prefix]\n            count[prefix] += 1\n        return res\n    \n# If a subarray is divisible by K, it has to be a multiple of K\n\n# a-b=n*k, a = running total, b = any previous subarray sum, same as original prefix sum problems.\n\n# We want to solve for b, so using basic algebra, b=a-n*k\n\n# We don't know what n is, so we can get rid of n by modding every element by k\n# (b%k) = (a%k) - (n*k)%k\n\n# since n*k is a multiple of k and k goes into it evenly, the result of the (n *k)%k will be 0\n\n# therefore\n# b%k = a%k\n\n# is the same as the formula we defined earlier, a-b=n*k\n\n# where b = running total, a = any previous subarray sum\n\n# So we just have to see if running total mod k is equal to any previous running total mod k\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        res = 0\n        count = [1] + [0] * K\n        prefix = 0\n        for a in A:\n            prefix = (prefix + a) % (K)\n            res += count[prefix]\n            count[prefix] += 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        B = [a % K for a in A]\n        \n        sum_dict = {}\n        ans = 0\n        curr_sum = 0\n        sum_dict[0] = 1\n        \n        n = len(B)\n        \n        for i, num in enumerate(B):\n            curr_sum = (curr_sum + num) % K\n            if curr_sum in sum_dict:\n                ans += sum_dict[curr_sum]\n                \n            sum_dict[curr_sum] = sum_dict.get(curr_sum, 0) + 1\n         \n        return ans", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        countPrefs = {0: 1}\n        total = 0\n        res = 0\n        for i, num in enumerate(A):\n            total += num\n            res += countPrefs.get(total % K , 0)\n            if total % K in countPrefs:\n                countPrefs[total % K] += 1\n            else:\n                countPrefs[total % K] = 1\n        return res\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        res, n, cache, sv = 0, len(A), collections.defaultdict(int), 0\n        cache[0] = 1\n        for i, v in enumerate(A):\n            sv += v\n            if cache[sv % K] > 0:\n                res += cache[sv % K]\n            cache[sv % K] += 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        n = len(A)\n        pre = 0\n        res = 0\n        d = {0: 1}\n        for a in A:\n            pre = (pre + a) % K\n            res += d.get(pre, 0)\n            d[pre] = d.get(pre, 0) + 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        cumsum = [0]\n        for n in A:\n            cumsum.append(cumsum[-1]+n)\n        print((cumsum, A))\n        cnt = 0\n        # for i in range(len(A)):\n        #     for j in range(i+1,len(A)):\n        #         if (cumsum[j]-cumsum[i])%K == 0:\n        #             cnt += 1\n        # return cnt\n        count = [0]*K\n        for x in cumsum:\n            count[(x%K+K)%K] += 1\n            \n        cnt = 0\n        for num in count:\n            cnt += num*(num-1)//2\n        return cnt\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        mod_count = Counter({0:1})\n        \n        ans = 0\n        for s in [*accumulate(A)]:\n            m = s % K\n            if m in mod_count:\n                ans += mod_count[m]\n            mod_count[m] += 1\n        return ans", "# Refer to Problem 523 for more info \nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        res = 0\n        currsum = 0\n        d = Counter()\n        d[0] = 1\n        for i, num in enumerate(A):\n            currsum+= num\n            currsum %= K\n            if currsum in d:\n                #all the past subarray end points where the remainder is same as the current one will act as starting point for the current subarray so that the total sum is divisible by K \n                res+= d[currsum]\n            d[currsum]+=1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        # (cs - cs[i]) % k == 0\n        res = 0\n        cs = 0\n        seen = collections.Counter({0: 1})\n        for i in range(len(A)):\n            x = A[i]\n            cs += x\n            if cs % K in seen:\n                res += seen[cs % K]\n            seen[cs % K] += 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        m = defaultdict(int)\n        m[0] = 1\n        curr_sum = 0\n        result = 0\n        for a in A:\n            curr_sum += a\n            remainder = curr_sum % K\n            if remainder in m:\n                result += m[remainder]\n            m[remainder] += 1\n        return result", "from collections import defaultdict\n\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        if not A:\n            return 0\n        # Instead of actual prefix sums, store prefix sums mod K\n        # And don't have to store indices, just store count\n        prefix_sums = defaultdict(int)\n        prefix_sums[0] = 1\n        cumsum = 0\n        ans = 0\n        for i, x in enumerate(A):\n            cumsum = (cumsum + x) % K\n            ans += prefix_sums[cumsum]\n            prefix_sums[cumsum] += 1\n        return ans", "class Solution(object):\n    def subarraysDivByK(self, A, K):\n        nums = A\n        k = K\n        modDict = {}\n        tempSumn = 0\n        ans = 0\n        continousSum = []\n        \n        for num in nums:\n            tempSumn += num\n            continousSum.append(tempSumn)\n            remain = tempSumn%k\n            \n            if remain not in modDict:\n                modDict[remain] = 0\n            modDict[remain] += 1\n        \n        diff = k\n        for i in range(0, len(continousSum)):\n            if diff%k in modDict:\n                ans += modDict[diff%k]\n                \n            diff = continousSum[i]\n            modDict[diff%k] -= 1\n        \n        return ans", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        sums = 0\n        count = 0\n        dic = {0:1}\n        \n        for a in A:\n            sums = (sums + a) % K\n            print(sums)\n            if sums in dic:\n                count += dic[sums]\n                dic[sums] += 1\n            else:\n                dic[sums] = 1\n                \n        return count", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        su = 0 \n        dic = {}\n        count = 0\n        for i in range(len(A)):\n             \n                su +=A[i]\n                \n                if(su%K==0):\n                    count +=1\n                if((su)%K in dic.keys()):\n                  count += dic[(su)%K]\n                \n                \n                if(su%K in dic.keys()):\n                  dic[su%K] += 1\n                else:\n                  dic[su%K]  = 1\n        print(dic)\n        print(count)\n        return count", "'''\nContiguous sub array\nPositive and negative\ncannot be empty\n\nreturn count\n\n\nCreate prefix\n\nLoop through --> if remainder in prefix count += 1\nadd prefix % k into seen\n\n\n4 9 9 7 4 5\n\n4 4 4 5 4 0\n'''\nfrom collections import Counter\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        seen = Counter()\n        \n        prefix = [] # store sum up till and including this index\n        curr_sum = 0\n        for x in A:\n            curr_sum += x\n            prefix.append(curr_sum % K)\n            \n        ans = 0 \n        for ix in range(len(A)):\n            remainder = K - prefix[ix]\n            if prefix[ix] in seen: # handle case whereby sub array = 0 or sub array = 5\n                ans += seen[prefix[ix]]\n            if prefix[ix] == 0:\n                ans += 1\n            seen[prefix[ix]] += 1\n        return ans\n            \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        n = len(A)\n        A[0] = A[0]%K\n        seen = {0:1}\n        count = 0 \n        for i in range(1,n):\n            A[i] = (A[i] + A[i-1])%K\n        for i in range(n):\n            newTarget = (A[i] - K)%K\n            if newTarget in seen: \n                count+= seen[newTarget]\n            if A[i] in seen:\n                seen[A[i]] += 1\n            else:\n                seen[A[i]] = 1\n        return count \n            \n            \n            \n        \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        cnt = Counter([0])\n        pref, ans = 0, 0\n        for a in A:\n            pref = (pref + a) % K\n            ans += cnt[pref]\n            cnt[pref] += 1\n        return ans", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        prefix = [0]*len(A)\n        prefix[0] = A[0]%K\n        counter = Counter([prefix[0]])\n        ans = 1 if prefix[0] == 0 else 0\n        for i in range(1, len(A)):\n            prefix[i] = (prefix[i-1] + A[i]) % K\n            target = prefix[i] - 0\n            ans += counter[target]\n            if target == 0:\n                ans += 1\n            counter[prefix[i]] += 1\n        return ans", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        \n        cumsum = 0\n        complements = {0: 1}\n        counts = 0\n        for a in A:\n            cumsum += a\n            mods = cumsum % K\n            counts += complements.get(mods, 0)\n            complements[mods] = complements.get(mods, 0) + 1 \n            \n        return counts\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        '''\n        Algorithm\n        ---------\n        We will keep track of the running sum s. We then take the\n        modulo of the sum and record its frequency in a hash table.\n        \n        After the first pass the number of subarrays divisible by K\n        is the sum of the frequencies of the remainders choose 2 -> c *(c - 1)//2\n        '''\n        \n        # Hash table to store modulo\n        ht = [0] * K\n        \n        sum = 0\n        for num in A:\n            sum += num\n            ht[sum % K] += 1\n        \n        # handle the case of 0 remainder -> n * (n - 1) // 2 + n\n        results = ht[0]\n        \n        for c in ht:\n            results += (c * (c - 1)) // 2\n        return results\n        \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        prefix_sum = [0]\n        for idx, i in enumerate(A):\n            prefix_sum.append(i+prefix_sum[idx])\n        print(prefix_sum)\n        \n        # now we go through and try to see if we've seen the pair number already\n        \n        num_enc = dict()\n        total = 0\n        for i in prefix_sum:\n            if (i%K) in num_enc:\n                total+=num_enc[i%K]\n            if (i%K - K) in num_enc:\n                total+=num_enc[i%K - K]\n            if i%K not in num_enc:\n                num_enc[i%K] = 0\n            num_enc[i%K]+=1\n        return total\n            \n            \n                \n\n        \n#         total = 0\n#         for i in range(0, len(A)):\n#             curr_sum = A[i]\n#             if curr_sum%K==0:\n#                 total+=1\n#             for j in range(i+1, len(A)):\n#                 curr_sum+=A[j]\n#                 if curr_sum%K==0:\n#                     total+=1\n#         return total\n                \n                \n                \n                \n                \n#         for wsize in range(1, len(A)):\n#             i = 0\n#             curr_sum = sum(A[j] for j in range(0, wsize+1))\n#             while i + wsize < len(A):\n                \n#                 if i != 0:\n#                     curr_sum-=A[i-1]\n#                     curr_sum+=A[i+wsize]\n#                 if curr_sum%5==0:\n#                     total+=1\n#                 print(i, i+wsize, wsize, curr_sum)\n#                 i+=1\n#         return total\n", "class Solution:\n    def TRIAlsubarraysDivByK(self, A: List[int], K: int) -> int:\n        n = 0\n        for i in range(len(A)):\n            sum = 0\n            for j in range(i,len(A)):\n                sum+=A[j]\n                if(sum%K==0):\n                    n+=1\n        return n\n    \n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        rems = [0]*len(A)\n        for i in range(len(A)):\n            if(i==0):\n                rems[0] = A[0]%K\n            else:\n                rems[i] = (rems[i-1] + A[i])%K\n        print(rems)\n            \n        count = list(Counter(rems).values())\n        print(count)\n        return(int(sum(n*(n-1)/2 for n in count)) + rems.count(0))\n", "from collections import defaultdict\n\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        if not A:\n            return 0\n        # Instead of actual prefix sums, store prefix sums mod K\n        prefix_sums = defaultdict(list)\n        prefix_sums[0].append(-1)\n        cumsum = 0\n        ans = 0\n        for i, x in enumerate(A):\n            cumsum += x\n            cumsum_mod = cumsum % K\n            ans += len(prefix_sums[cumsum_mod])\n            prefix_sums[cumsum_mod].append(i)\n        return ans", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        if not A or not K:\n            return 0\n        map = Counter()\n        map[0] = 1\n        sum = 0\n        res = 0\n        for num in A:\n            sum += num\n            sum %= K\n            if sum < 0:\n                sum += K\n            if sum in map:\n                res += map[sum]\n            map[sum] += 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        n = len(A)\n        prefix = [0] * (n+1)\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + A[i-1]\n        for i in range(1, n+1):\n            prefix[i] = prefix[i] % K\n        d = defaultdict(list)\n        ans = 0\n        for i in range(1, n+1):\n            if prefix[i] == 0:\n                ans += 1\n            if prefix[i] in d.keys():\n                ans += len(d[prefix[i]])\n            d[prefix[i]].append(i)\n        return ans", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) ->int:\n        count = [0]*K\n        sum = 0\n        for i in A:\n            sum += i%K\n            count[sum % K] += 1\n        result = count[0]\n        for j in count:\n            result +=(j*(j-1))/2\n        return int(result)", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        map = {}\n        map[0] = 1\n        sum, count = 0, 0\n        \n        for n in A:\n            sum = (sum + n) % K\n            \n            if sum not in list(map.keys()):\n                map[sum] = 1\n            else:\n                count += map[sum]\n                map[sum] += 1\n        \n        return count\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        ans=0\n        count=[1]+[0]*K\n        prefix=0\n        \n        for num in A:\n            prefix=(prefix+num)%K\n            ans+=count[prefix]\n            count[prefix]+=1\n        \n        return ans", "import collections\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        counts = [0] * K\n        \n        total = 0\n        \n        for num in A:\n            total += num\n            counts[total % K] += 1\n              \n        \n        result = counts[0]\n        \n        for count in counts:   \n            result += (count*(count-1))//2\n  \n\n        return result", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        D, s = {0:1}, 0\n        for a in A:\n            s = (s + a) % K\n            if s in D: \n                D[s] += 1\n            else: \n                D[s] = 1\n        return sum(i*(i-1)//2 for i in list(D.values()))\n", "import collections\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        rem_array = [0]\n        for num in A:\n            rem_array.append((num+rem_array[-1])%K)\n        \n        counter = collections.Counter(rem_array)\n        return sum(v*(v-1)//2 for v in counter.values())", "from collections import defaultdict\n\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        count = 0\n        mods = [0]\n        modFreqs = defaultdict(lambda: 0)\n        for num in nums:\n            mod = (mods[-1] + num) % k\n            if mod == 0:\n                count += 1\n            count += modFreqs[mod]\n            mods.append(mod)\n            modFreqs[mod] += 1\n        return count", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        P = [0]\n        for x in A:\n            P.append((P[-1]  + x)%K)\n        count = collections.Counter(P)\n        return int(sum(v*(v-1)/2 for v in count.values()))", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        hash_map = collections.defaultdict(int)\n        hash_map[0] = 1\n        prefix = 0\n        res = 0\n        for i in range(len(A)):\n            num = A[i]\n            prefix = ( prefix + num ) % K\n            res += hash_map[prefix]\n            hash_map[prefix] += 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        P = [0]\n        for x in A:\n            P.append((P[-1] + x) % K)\n            \n        # print(P)\n\n        count = collections.Counter(P)\n        \n        # print(count)\n        return sum(v*(v-1)//2 for v in count.values())", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        arr, ans, curr = [1]+[0]*K, 0, 0\n        for i in A:\n            curr = (curr+i)%K\n            ans += arr[curr]\n            arr[curr] += 1\n        return ans", "from collections import defaultdict\nfrom operator import add\n\ndef accum(op, l):\n    if not l:\n        return []\n    v = l[0]\n    ret = [v]\n    for x in l[1:]:\n        v = op(v, x)\n        ret.append(v)\n    return ret\n    \nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        B = accum(add, A)\n        B = [0] + B\n        B = [x % K for x in B]\n        seen = defaultdict(lambda: 0)\n        seen[0] = 1\n        combinations = 0\n        for s in B[1:]:\n            target = s\n            if seen[target] > 0:\n                combinations += seen[target]\n            seen[s] = seen[s] + 1\n        return combinations", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        hashmap = [0] * K\n        hashmap[0] = 1\n        result = 0\n        prefix = 0\n        for i in range(len(A)):\n            prefix = (prefix + A[i])%K\n            hashmap[prefix] += 1\n            result += (hashmap[prefix] - 1)\n\n        return result\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        m = Counter()\n        cur_sum = 0\n        ans = 0\n        for x in A:\n            cur_sum += x\n            ans += m[cur_sum % K]\n            if cur_sum % K == 0:\n                ans += 1\n            print((x, m[cur_sum % K]))\n            m[cur_sum % K] += 1\n        return ans\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        #O(n^2) solutions: build all sub, find sum, divisible by K\n        \n        #O(n): store something with value % K\n        \n        '''\n        #Running sum\n        a - b = n * k, a is curr_sum, b is prev_sum\n        We're looking for prev_sum that can add a to -> looking for b\n        b = a - n * k \n        b % k = a % k\n        -> see if running total % k -> find the prev_sum % k\n        \n        '''\n        dp = [1] + [0] * K\n        result = 0\n        running_sum = 0\n        for num in A:\n            running_sum += num\n            result += dp[running_sum % K]\n            dp[running_sum % K] += 1\n            \n        return result", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        res = 0\n        sums = 0\n        d = {0:1}\n        for num in A:\n            sums = (sums + num) % K\n            # if sums < 0:\n            #     sums += K\n            res += d.get(sums, 0)\n            d[sums] = d.get(sums, 0) + 1\n        return res\n    \n    # [4,9,9,7,4,5]\n    # d = {\n    #     0:1, 4:4, 2:1, \n    # }\n    # res = 7\n    # sums = 4\n        \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        sum1=sum(A)\n        count1=0\n        dict1={0:1}\n        rem1=0\n        sum2=0\n        for i in range(len(A)):\n            sum2+=A[i]\n            rem1=sum2%K\n            if rem1<0:\n                rem1+=k\n                \n                \n            if rem1 in dict1:\n                count1+=dict1[rem1]\n                dict1[rem1]+=1\n                \n            else:\n                dict1[rem1]=1\n        print(dict1)\n        return count1\n                \n            \n                \n            \n            \n            \n            \n            \n            \n                    \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        # use the prefix sum \n        prefix = [0]\n        for a in A:\n            prefix += [(prefix[-1] + a) % K]\n        #count how many of them are the same\n        cnt = collections.Counter(prefix)\n        # for the index with the same remainder, randomly choose pairs\n        return int(sum( v * (v-1) / 2 for v in list(cnt.values())))\n", "from collections import defaultdict\n\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        seen = defaultdict(int, {0: 1})\n        ret = psum = 0\n        for n in A:\n            psum = (psum + n) % K\n            if psum in seen:\n                ret += seen[psum]\n            seen[psum] += 1\n        return ret", "from collections import Counter\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        presum = [0]\n        for num in A:\n            presum.append((presum[-1] + num) % K)    \n            \n        count = Counter(presum)\n        return sum(c * (c - 1) // 2 for c in list(count.values()))\n            \n        \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        hm = {}\n        hm[0] = 1\n        prefix = 0\n        count = 0\n        for i in range(0, len(A)):\n            prefix = (A[i] + prefix)%K\n            if prefix in hm:\n                count += hm[prefix]\n            else:\n                hm[prefix] = 0\n            hm[prefix] += 1\n        return count\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        res = 0\n        prefix = 0\n        count = [1] + [0] * K\n        for a in A:\n            prefix = (prefix + a) % K\n            res += count[prefix]\n            count[prefix] += 1\n        return res", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        \n        cumsum = 0\n        counts = 0\n        complements = {0: 1}\n        for a in A:\n            cumsum += a\n            mods = cumsum % K\n            counts += complements.get(mods, 0)\n            complements[mods] = complements.get(mods, 0) + 1 \n            \n        return counts\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        n = len(A)\n        prefixsum = 0\n        remain = collections.defaultdict(int)\n        remain[0] = 1\n        \n        res = 0\n        for i in range(n):\n            prefixsum += A[i]\n            re = prefixsum % K\n            res += remain[re]\n            remain[re] += 1\n        return res\n            \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        \n        res = 0\n        lookup = {0:1}\n        presum = 0\n        for i, num in enumerate(A):\n            presum += num\n            remainder = presum % K\n            res += lookup.get(remainder, 0)\n            lookup[remainder] = lookup.get(remainder, 0) + 1\n            \n            \n        return res\n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        \n        # P[i] stores sum up to index i\n        P = [0]\n        for x in A:\n            P.append( (P[-1] + x) % K )\n        \n        count = collections.Counter(P)\n        \n        ans = 0\n        for v in list(count.values()):\n            ans += int(v*(v-1)*0.5)\n        \n        return ans\n        #return sum( v*(v-1)//2 for v in count.values())\n        \n        \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        preSum = [0] \n        for num in A:\n            preSum.append((preSum[-1]+num)%K)\n        preSumCounter = Counter(preSum)\n        return sum(v*(v-1)//2 for v in preSumCounter.values())", "'''\nhttps://leetcode.com/problems/continuous-subarray-sum/\n'''\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        d = {0: 1}\n        runningSum = 0\n        sol = 0\n        for i in range(len(A)):\n            runningSum += A[i]\n            newMod = runningSum % K\n            if newMod not in d:\n                d[newMod] = 0\n            d[newMod] += 1\n            sol += d[newMod] - 1\n        return sol\n            \n            \n                \n                \n", "'''\n[4,5,0,-2,-3,1]\n\n'''\nclass Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        d = {0: 1}\n        runningSum = 0\n        sol = 0\n        for i in range(len(A)):\n            runningSum += A[i]\n            newMod = runningSum % K\n            if newMod not in d:\n                d[newMod] = 0\n            d[newMod] += 1\n            sol += d[newMod] - 1\n        return sol\n            \n            \n                \n                \n", "class Solution:\n    def subarraysDivByK(self, A: List[int], K: int) -> int:\n        \n        \n        prefixMod = 0\n        hashTable = collections.defaultdict(int)\n        total = 0\n        curSum = 0\n        hashTable[0] = 1\n        \n        for i,x in enumerate(A) :\n           \n            prefixMod = prefixMod + x\n            \n            prefixMod = prefixMod%K\n           \n            total += hashTable[prefixMod]\n            \n            hashTable[prefixMod] += 1\n    \n        return total\n"]
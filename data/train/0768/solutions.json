["# cook your dish here\n# cook your dish here\nfrom math import log2;\nimport sys;\n\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ninf = float(\"inf\")\ndef find_height(node):\n    nodes[node]=1\n    for i in graph[node]:\n        nodes[node]+=find_height(i)\n    return nodes[node]\ndef find_sum(node):\n    suma=nodes[node]\n    maxa=0\n    for i in graph[node]:\n        maxa=max(find_sum(i),maxa)\n    return maxa+suma\nfor i in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    graph=defaultdict(set)\n    for i in range(len(l)):\n\n        graph[l[i]].add(i+2)\n    nodes=defaultdict(int)\n    find_height(1)\n    ans=find_sum(1)\n    print(ans)\n\n\n\n", "from sys import setrecursionlimit\r\nsetrecursionlimit(10**8)\r\n\r\ndef max_mex(dept):\r\n    \r\n    for i in at_dept[dept]:\r\n\r\n        m,l=0,0\r\n        for j in child[i]:\r\n            m=max(m,mex[j][1])\r\n            l+=mex[j][0]\r\n\r\n        mex[i]=[l+1,m+l+1]\r\n\r\n    if(dept > 1):\r\n        max_mex(dept-1)\r\n            \r\n\r\n\r\ndef all_dept(arr,dept=2):\r\n    for i in arr:\r\n        at_dept[dept].append(i)\r\n        all_dept(child[i],dept+1)\r\n\r\n\r\nfor T in range(int(input())):\r\n    n=int(input())\r\n    parent=list(map(int,input().split()))\r\n\r\n\r\n    child=[[] for i in range(n+1)]\r\n    for i in range(n-1):\r\n        \r\n        child[parent[i]].append(i+2)\r\n    \r\n    at_dept=[[] for i in range(n+1)]\r\n    at_dept[1].append(1)\r\n    all_dept(child[1])\r\n\r\n    for arr in at_dept[::-1]:\r\n        if(arr==[]):\r\n            at_dept.pop()\r\n        else:\r\n            break\r\n\r\n    mex=[0]*(n+1)\r\n    for i in at_dept[-1]:\r\n        mex[i]=[1,1]\r\n\r\n    max_mex(len(at_dept)-2)\r\n\r\n    print(mex[1][1])", "#================= author:------sushmanth ========================\r\n\r\nfrom sys import setrecursionlimit\r\nsetrecursionlimit(10**8)\r\n\r\ndef max_mex(dept):\r\n    \r\n    for i in at_dept[dept]:\r\n\r\n        m,l=0,0\r\n        for j in child[i]:\r\n            m=max(m,mex[j][1])\r\n            l+=mex[j][0]\r\n\r\n        mex[i]=[l+1,m+l+1]\r\n\r\n    if(dept > 1):\r\n        max_mex(dept-1)\r\n            \r\n\r\n\r\ndef all_dept(arr,dept=2):\r\n    for i in arr:\r\n        at_dept[dept].append(i)\r\n        all_dept(child[i],dept+1)\r\n\r\n\r\nfor T in range(int(input())):\r\n    n=int(input())\r\n    parent=list(map(int,input().split()))\r\n\r\n\r\n    child=[[] for i in range(n+1)]\r\n    for i in range(n-1):\r\n        \r\n        child[parent[i]].append(i+2)\r\n    \r\n    at_dept=[[] for i in range(n+1)]\r\n    at_dept[1].append(1)\r\n    all_dept(child[1])\r\n\r\n    for arr in at_dept[::-1]:\r\n        if(arr==[]):\r\n            at_dept.pop()\r\n        else:\r\n            break\r\n\r\n    mex=[0]*(n+1)\r\n    for i in at_dept[-1]:\r\n        mex[i]=[1,1]\r\n\r\n    max_mex(len(at_dept)-2)\r\n\r\n    print(mex[1][1])\r\n\r\n\r\n    \r\n    \r\n", "# cook your dish here\nfrom sys import setrecursionlimit\nsetrecursionlimit(10**8)\n\ndef max_mex(dept):\n    \n    for i in at_dept[dept]:\n\n        m,l=0,0\n        for j in child[i]:\n            m=max(m,mex[j][1])\n            l+=mex[j][0]\n\n        mex[i]=[l+1,m+l+1]\n\n    if(dept > 1):\n        max_mex(dept-1)\n            \n\n\ndef all_dept(arr,dept=2):\n    for i in arr:\n        at_dept[dept].append(i)\n        all_dept(child[i],dept+1)\n\n\nfor T in range(int(input())):\n    n=int(input())\n    parent=list(map(int,input().split()))\n\n\n    child=[[] for i in range(n+1)]\n    for i in range(n-1):\n        \n        child[parent[i]].append(i+2)\n    \n    at_dept=[[] for i in range(n+1)]\n    at_dept[1].append(1)\n    all_dept(child[1])\n\n    for arr in at_dept[::-1]:\n        if(arr==[]):\n            at_dept.pop()\n        else:\n            break\n\n    mex={}\n    for i in at_dept[-1]:\n        mex[i]=[1,1]\n\n    max_mex(len(at_dept)-2)\n\n    print(mex[1][1])\n\n\n    \n    \n", "from sys import setrecursionlimit\r\nsetrecursionlimit(999999)\r\ndef createTree(n,par):\r\n    graph=[[] for i in range(n+1)]\r\n    for i in range(len(par)):\r\n        graph[par[i]].append(i+2)\r\n    return graph\r\n\r\ndef recurse(graph,root):\r\n    if (len(graph[root]) == 0):\r\n        return [1,1]\r\n        \r\n    noNodes=1\r\n    root_sum = 0\r\n    for i in range(len(graph[root])):\r\n        temp = recurse(graph, graph[root][i])\r\n        noNodes += temp[0]\r\n        root_sum = max(root_sum, temp[1])\r\n    return [noNodes,root_sum+noNodes]\r\n\r\nfor i in range(int(input())):\r\n    n = int(input())\r\n    arr = [int(i) for i in input().split()]\r\n    graph = createTree(n, arr)\r\n    print(recurse(graph,1)[1])\r\n", "import sys\r\n\r\n \r\ndef eprint(*args):\r\n    print(*args, file=sys.stderr)\r\nzz=1\r\n \r\nsys.setrecursionlimit(10**6)\r\nif zz:\r\n\tinput=sys.stdin.readline\r\nelse:\t\r\n\tsys.stdin=open('input.txt', 'r')\r\n\tsys.stdout=open('all.txt','w')\r\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\r\n\r\ndef string(s):\r\n\treturn \"\".join(s)\r\ndef fori(n):\r\n\treturn [fi() for i in range(n)]\t\r\ndef inc(d,c,x=1):\r\n\td[c]=d[c]+x if c in d else x\r\ndef bo(i):\r\n\treturn ord(i)-ord('A')\t\r\ndef li():\r\n\treturn [int(xx) for xx in input().split()]\r\ndef fli():\r\n\treturn [float(x) for x in input().split()]\t\r\ndef comp(a,b):\r\n\tif(a>b):\r\n\t\treturn 2\r\n\treturn 2 if a==b else 0\t\t\r\ndef gi():\t\r\n\treturn [xx for xx in input().split()]\r\ndef cil(n,m):\r\n\treturn n//m+int(n%m>0)\t\r\ndef fi():\r\n\treturn int(input())\r\ndef pro(a): \r\n\treturn reduce(lambda a,b:a*b,a)\t\t\r\ndef swap(a,i,j): \r\n\ta[i],a[j]=a[j],a[i]\t\r\ndef si():\r\n\treturn list(input().rstrip())\t\r\ndef mi():\r\n\treturn \tmap(int,input().split())\t\t\t\r\ndef gh():\r\n\tsys.stdout.flush()\r\ndef isvalid(i,j,n,m):\r\n\treturn 0<=i<n and 0<=j<m \r\ndef bo(i):\r\n\treturn ord(i)-ord('a')\t\r\ndef graph(n,m):\r\n\tfor i in range(m):\r\n\t\tx,y=mi()\r\n\t\ta[x].append(y)\r\n\t\ta[y].append(x)\r\n\r\n\r\n\r\nt=fi()\r\n\t\t\t\t\t\t\t \t\t\r\nwhile t>0:\r\n\tt-=1\r\n\tn=fi()\r\n\tp=li()\r\n\ta=[[] for i in range(n+1)]\r\n\tfor i in range(n-1):\r\n\t\ta[i+2].append(p[i])\r\n\t\ta[p[i]].append(i+2)\t\r\n\tsubtree=[1]*(n+1)\r\n\tdef dfs(i,par=-1):\r\n\t\tfor j in a[i]:\r\n\t\t\tif j!=par:\r\n\t\t\t\tdfs(j,i)\r\n\t\t\t\tsubtree[i]+=subtree[j]\t\t\t\r\n\tdfs(1,-1)\r\n\tans=[0]*(n+1)\r\n\t\r\n\tfor i in range(1,n+1):\r\n\t\tif i==1:\r\n\t\t\tans[i]=n\r\n\t\telse:\r\n\t\t\tans[i]+=subtree[i]+ans[p[i-2]]\t\r\n\tprint(max(ans))\t", "from sys import setrecursionlimit\r\nsetrecursionlimit(999999)\r\nfrom collections import defaultdict as dd\r\nfrom collections import deque as dq\r\n\r\ndef dfs_rec(g,root):\r\n    if len(g[1])==0:\r\n        return [1,1]\r\n    \r\n    sz,mx=1,-1\r\n    \r\n    for i in range(len(g[root])):\r\n        temp = dfs_rec(g,g[root][i])\r\n        sz+=temp[0]\r\n        mx = max(mx,temp[1])\r\n    return [sz,mx+sz]\r\n\r\nfor _ in range(int(input())):\r\n    \r\n    n = int(input())\r\n    l = list(map(int,input().split()))\r\n    g = dd(list)\r\n    \r\n    for i in range(n-1):\r\n        g[l[i]].append(i+2)\r\n    \r\n    r = dfs_rec(g,1)[1]\r\n    #print(g)\r\n    print(r+1)", "# cook your dish here\nimport sys \n\nsys.setrecursionlimit(10**6) \ndef recurse(root):\n    if adj[root]==[]:\n        return 1,1\n    sub=1\n    max1=0\n    for v in adj[root]:\n        x,y=recurse(v)\n        sub+=x\n        max1=max(max1,y)\n    return sub,sub+max1\n    \nfor _ in range(int(input())):\n    n=int(input())\n    p=list(map(int, input().split()))\n    adj={}\n    for i in range(1,n+1):\n        adj[i]=[]\n    for i in range(n-1):\n        parent,child=p[i],i+2\n        adj[parent].append(child)\n    x,y=recurse(1)\n    print(y)\n    ", "# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    p = list(map(int, input().strip().split()))\n    ans = [0] * (n+1)\n    nos = [1] * (n+1)\n    for i in range(n-2, -1, -1):\n        nos[p[i]] += nos[i+2]\n        ans[i+2] += nos[i+2]\n        ans[p[i]] = max(ans[p[i]], ans[i+2])\n    print(ans[1] + nos[1])\n", "import sys\nsys.setrecursionlimit(int(1e6))\ndef solve(graph, cur):\n    if not graph[cur]:\n        return (1, 1)\n    tot = 0\n    ans = 0\n    for child in graph[cur]:\n        prevans, tnodes = solve(graph, child)\n        tot += tnodes\n        ans = max(ans, prevans)\n    return tot + 1 + ans, tot + 1\n\nfor t in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input(). split()))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        graph[lis[i]].append(i + 2)\n    print(solve(graph, 1)[0])", "import sys\r\n\r\nsys.setrecursionlimit(1000000)  \r\ndef dfs(root, graph):\r\n    retrieval = []\r\n    try:\r\n        for i in graph[root]:\r\n            retrieval.append(dfs(i, graph))\r\n        if(retrieval!=[]):\r\n            mx = retrieval[0][0]+retrieval[0][1]\r\n            totalNodesInSubtree = 0\r\n            for i in retrieval:\r\n                totalNodesInSubtree+=i[1]\r\n                if(i[0]+i[1]>mx):\r\n                    mx = i[0]+i[1]\r\n            return [mx, totalNodesInSubtree+1]\r\n        else:\r\n            return[0, 1]\r\n    except:\r\n        return [0, 1]\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    l = list(map(int, input().split()))\r\n    graph={}\r\n    for i in range(n-1):\r\n        if(graph.get(l[i])):\r\n            graph[l[i]].add(i+2)\r\n        else:\r\n            graph[l[i]] = set([i+2])\r\n    ans = dfs(1, graph)\r\n    print(ans[0]+ans[1])", "from sys import setrecursionlimit\r\nsetrecursionlimit(10**6)\r\nclass Graph:\r\n    def __init__(self,V):\r\n        self.graph=[[] for i in range(V+1)]\r\n        self.Visited=set()\r\n        self.height=1\r\n        \r\n    def addEdges(self):\r\n        arr=[int(x) for x in input().split()]\r\n        for i in range(len(arr)):\r\n            self.graph[i+1].append(arr[i]-1)\r\n            self.graph[arr[i]-1].append(i+1)\r\n            \r\n    def DFS(self,Node):\r\n        self.Visited.add(Node)\r\n        if len(self.graph[Node]) == 0:\r\n            return 1,1\r\n        node=1\r\n        mex=1\r\n        for each in self.graph[Node]:\r\n            if each not in self.Visited:\r\n                n1,m1=self.DFS(each)\r\n                node+=n1\r\n                mex=max(m1,mex)\r\n            \r\n        return node,mex+node\r\n        \r\nfor _ in range(int(input())):\r\n    V=int(input())\r\n    gra=Graph(V)\r\n    gra.addEdges()\r\n    #print(gra.graph)\r\n    x,y=gra.DFS(0)\r\n    print(y-1)\r\n    #print(height*height)\r\n    #print((gra.height*(gra.height+1))//2)\r\n", "import sys\ninput,print=sys.stdin.readline,sys.stdout.write\nsys.setrecursionlimit(10**6)\ndef ans(dic,n):\n    if dic.get(n)!=None:\n        b=[]\n        for a in dic[n]:\n            b.append(ans(dic,a))\n        mx=0 \n        node=0\n        for a in b:\n            if a[0]>mx:\n                mx=a[0]\n            node+=a[1]\n        node+=len(dic[n])\n        return (mx+node+1,node)\n    else:\n        return (1,0)\n        \nfor i in range(int(input())):\n    n=int(input())\n    a=[int(x) for x in input().split()]\n    dic={}\n    for j in range(1,n):\n        temp=a[j-1]\n        if dic.get(temp)==None:\n            dic[temp]=[j+1]\n        else:\n            dic[temp].append(j+1)\n    anss=ans(dic,1)\n    print(str(anss[0])+\"\\n\")", "from sys import setrecursionlimit\r\nsetrecursionlimit(999999)\r\n\r\n\r\ndef children(g, n, child):\r\n    if n in g.keys():\r\n        x = 0\r\n        for adg in g[n]:\r\n            x += children(g, adg, child)\r\n        child[n] = len(g[n]) + x\r\n        return len(g[n]) + x\r\n    else:\r\n        child[n] = 0\r\n        return 0\r\n\r\n\r\ndef check(g, n, child):\r\n    if n in g.keys():\r\n        x = 0\r\n        for adg in g[n]:\r\n            l = check(g, adg, child)\r\n            if l > x:\r\n                x = l\r\n        if x > 0:\r\n            return  child[n] + 1 + x\r\n    else:\r\n        return 1\r\n\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    a = [0] + list(map(int, input().split()))\r\n    tree = {}\r\n    for i in range(1, n):\r\n        tree[a[i]] = tree.setdefault(a[i], [])\r\n        tree[a[i]].append(i + 1)\r\n    child = [0] * (n + 1)\r\n    children(tree, 1, child)\r\n    print(check(tree, 1, child))\r\n\r\n", "import sys\r\nsys.setrecursionlimit(10**7)\r\n#from sys import stdin,stdout\r\nimport math\r\n#import random\r\n#import heapq\r\nfrom collections import Counter\r\n#from queue import PriorityQueue\r\n#from functools import lru_cache\r\n#@lru_cache(maxsize=None) #for optimizing the execution time of callable objects/functions(placed above callable functions)\r\nadj=[[] for i in range(100005)]\r\ndef dfs(node):\r\n    mex=0\r\n    size=1\r\n    for i in adj[node]:\r\n        temp=dfs(i)\r\n        mex=max(mex,temp[0])\r\n        size+=temp[1]\r\n    return [mex+size,size]\r\n\r\n\r\n\r\n\r\n\r\n\r\ntry:\r\n    for _ in range(int(input())):\r\n        n=int(input())\r\n        for i in range(1,n+1):\r\n            adj[i].clear()\r\n        arr=[int(i) for i in input().split()]\r\n        for i in range(1,n):\r\n            #print(arr[i-1])\r\n            adj[arr[i-1]].append(i+1)\r\n            #adj[i].append(arr[i-1])\r\n        ans=dfs(1)\r\n        print(ans[0])\r\n        \r\n            \r\n        \r\n\r\n\r\n\r\n\r\n\r\n        \r\nexcept EOFError as e:\r\n    print(e)\r\n", "for _ in range(int(input())):\r\n    n=int(input())\r\n    con=list(map(int,input().split()))\r\n    le=[1 for i in range(n)]\r\n    for i in range(n-2,-1,-1):le[con[i]-1]+=le[i+1]\r\n    ans=[0 for i in range(n)]\r\n    ma=0\r\n    tra=[[] for i in range(n+1)]\r\n    no=2\r\n    for i in con:tra[i].append(no);no+=1\r\n    bfs=[1]\r\n    l=0\r\n    while l<len(bfs):\r\n        go=bfs[l]\r\n        for i in tra[go]:bfs.append(i)\r\n        l+=1\r\n    ans[0]=le[0]\r\n    for i in range(1,n,1):\r\n        ci=bfs[i]\r\n        va=le[ci-1]+ans[con[ci-2]-1]\r\n        if va>ma:ma=va\r\n        ans[ci-1]=va\r\n    print(ma)\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "# cook your dish here\nimport sys \n\nsys.setrecursionlimit(10**6) \n\ndef recurse(root):\n\tif root not in dic:\n\t\treturn (1,1)\n\tsum1=1\n\tmax1=0\n\tfor i in dic[root]:\n\t\tx,y=recurse(i)\n\t\tsum1+=x \n\t\tmax1=max(max1,y)\n\treturn sum1,sum1+max1\n\nfor _ in range(int(input())):\n\tn=int(input())\n\t\n\tdic={}\n\tlis=list(map(int,input().split()))\n\tfor i in range(len(lis)):\n\t\tif lis[i] not in dic:\n\t\t\tdic[lis[i]]=[i+2]\n\t\telse:\n\t\t\tdic[lis[i]].append(i+2)\n\tx,y=recurse(1)\n\tprint(y)", "from collections import defaultdict\r\nimport sys \r\nsys.setrecursionlimit(10**6) \r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    if n == 1:\r\n        print(1)\r\n    else:\r\n        l = list(map(int, input().split()))\r\n        mex = 0\r\n        d = defaultdict(lambda: [])\r\n        for i, num in enumerate(l):\r\n            d[num-1].append(i+1)\r\n\r\n        def dfs(i):\r\n            mex = 0\r\n            size = 1\r\n            for j in d[i]:\r\n                if i==j:\r\n                    continue\r\n                x = dfs(j)\r\n                mex = max(mex, x[0])\r\n                size += x[1]\r\n            return [mex+size, size]\r\n        print(dfs(0)[0])\r\n", "from sys import stdin as stin,stdout as stout,setrecursionlimit as srl\r\nfrom collections import defaultdict as dd,Counter,deque as dq \r\n#from heapq import heapify,heappush as hpu,heappop as hpo\r\n#import math \r\n#import numpy\r\nsrl(10**6)\r\ndef get_ints():return map(int,stin.readline().split())\r\ndef get_list(): return list(map(int,stin.readline().split()))\r\ndef get_int(): return int(stin.readline())\r\ndef get_str(): return stin.readline()\r\ndef dfs(graph,u,parent):\r\n    size,max_mex=0,0\r\n    for i in graph[u]:\r\n        if i==parent:\r\n            continue \r\n        tmax,tsize=dfs(graph,i,u)\r\n        max_mex=max(max_mex,tmax) \r\n        size+=tsize \r\n    return max_mex+size+1,size+1\r\nfor _ in range(get_int()):\r\n    n=get_int()\r\n    nums=get_list()\r\n    graph=dd(list)\r\n    for i in range(2,n+1):\r\n        graph[nums[i-2]].append(i) \r\n    print(dfs(graph,1,1)[0])\r\n    "]
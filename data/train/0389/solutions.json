["class Solution:\n    def splitArraySameAverage(self, A):\n        N, S = len(A), sum(A)\n        if N == 1: return False\n        A = [z * N - S for z in A] \n        mid, left, right = N//2, {A[0]}, {A[-1]}\n\n\n        if not any((S*size) % N == 0 for size in range(1, mid+1)): return False\n\n        for i in range(1, mid): left |= {z + A[i] for z in left} | {A[i]}\n        for i in range(mid, N-1): right |= {z + A[i] for z in right} | {A[i]}\n        if 0 in (left|right): return True\n\n\n        left -= {sum(A[:mid])}\n        return any(-ha in right for ha in left)", "class Solution:\n    def splitArraySameAverage(self, A):\n        N, S, P = len(A), sum(A), [1]\n        for a in A:\n            P[1:] = [(p << a) | q for p, q in zip(P, P[1:] + [0])]\n        return any(S * n % N == 0 and P[n] & (1 << (S * n // N))\n               for n in range(1, N))", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        tot = sum(A)\n        n = len(A)\n        target = tot/n \n        visited = [ False]*len(A)\n        m = n // 2\n        possible = False\n        for i in range(1, m+ 1):\n            if (tot * i)%n == 0:\n                possible = True\n                break\n        if not possible:\n            return False\n        A.sort( )\n        \n        \n        def helper(A, cursum, curcnt, pos):\n            if curcnt == 0:\n                return cursum == 0\n            \n            for i in range(pos, len(A) - curcnt + 1):\n                if i > pos and A[i]==A[i-1]:\n                    continue\n                if helper(A, cursum - A[i], curcnt - 1, i + 1):\n                    return True\n            \n            return False\n         \n        for i in range(1, m + 1):\n            if (tot * i)%n == 0 and helper(A, (tot * i)/n, i, 0):\n                return True\n        return False\n            \n            \n", "# from functools import lru_cache\n# class Solution:\n#     def splitArraySameAverage(self, A: List[int]) -> bool:\n#         # A.sort(reverse=True)\n#         n, total = len(A), sum(A)\n#         avag = total/n\n#         # epsilon = 0.000001\n#         # print(avag)\n#         @lru_cache(None)\n#         def dfs(idx, sums, sz):\n#             if 0 < sz <= n//2 and total*sz%n == 0 and sums == total*sz//n:\n#                 return True\n#             if idx == n or sz > n//2 or sums > total/2:\n#                 return False\n            \n#             return dfs(idx+1, sums+A[idx], sz+1) or dfs(idx+1, sums, sz)\n#             # print(idx,sums,sz,res)\n#         return dfs(0,0,0)\n\nfrom functools import lru_cache\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n, total = len(A), sum(A)\n        @lru_cache(None)\n        def dfs(idx, target, sz):\n            if target < 0 or idx+sz > n:\n                return False\n            if sz == 0 or idx  == n:\n                return target == 0\n            \n            \n            \n            return dfs(idx+1, target-A[idx], sz-1) or dfs(idx+1, target, sz)\n            # print(idx,sums,sz,res)\n        return any(dfs(0,total*k//n,k) for k in range(1,n//2+1) if total*k%n == 0)", "# from functools import lru_cache\n# class Solution:\n#     def splitArraySameAverage(self, A: List[int]) -> bool:\n#         # A.sort(reverse=True)\n#         n, total = len(A), sum(A)\n#         avag = total/n\n#         # epsilon = 0.000001\n#         # print(avag)\n#         @lru_cache(None)\n#         def dfs(idx, sums, sz):\n#             if 0 < sz <= n//2 and total*sz%n == 0 and sums == total*sz//n:\n#                 return True\n#             if idx == n or sz > n//2 or sums > total/2:\n#                 return False\n            \n#             return dfs(idx+1, sums+A[idx], sz+1) or dfs(idx+1, sums, sz)\n#             # print(idx,sums,sz,res)\n#         return dfs(0,0,0)\n\nfrom functools import lru_cache\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n, total = len(A), sum(A)\n        @lru_cache(None)\n        def dfs(idx, target, sz):\n            \n            if target < 0 or idx+sz > n:\n                return False\n            if sz == 0:\n                return target == 0\n            \n            \n            return dfs(idx+1, target-A[idx], sz-1) or dfs(idx+1, target, sz)\n            # print(idx,sums,sz,res)\n        return any(dfs(0,total*k//n,k) for k in range(1,n//2+1) if total*k%n == 0)", "# from functools import lru_cache\n# class Solution:\n#     def splitArraySameAverage(self, A: List[int]) -> bool:\n#         # A.sort(reverse=True)\n#         n, total = len(A), sum(A)\n#         avag = total/n\n#         # epsilon = 0.000001\n#         # print(avag)\n#         @lru_cache(None)\n#         def dfs(idx, sums, sz):\n#             if 0 < sz <= n//2 and total*sz%n == 0 and sums == total*sz//n:\n#                 return True\n#             if idx == n or sz > n//2 or sums > total/2:\n#                 return False\n            \n#             return dfs(idx+1, sums+A[idx], sz+1) or dfs(idx+1, sums, sz)\n#             # print(idx,sums,sz,res)\n#         return dfs(0,0,0)\n\nfrom functools import lru_cache\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n, total = len(A), sum(A)\n        @lru_cache(None)\n        def dfs(idx, target, sz):\n            if sz == 0:\n                return target == 0\n            if target < 0 or idx+sz > n:\n                return False\n            \n            \n            \n            return dfs(idx+1, target-A[idx], sz-1) or dfs(idx+1, target, sz)\n            # print(idx,sums,sz,res)\n        return any(dfs(0,total*k//n,k) for k in range(1,n//2+1) if total*k%n == 0)", "from functools import lru_cache\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n        # mem = {}\n        @lru_cache(None)\n        def find(target, k, i):\n\n            if k == 0: return target == 0\n\n            if k + i > len(A): return False\n\n            # if (target, k, i) in mem: return mem[(target, k, i)]\n\n\n            ans = find(target - A[i], k - 1, i + 1) or find(target, k, i + 1)\n\n            return ans\n\n        n, s = len(A), sum(A)\n\n        return any(find(s * j // n, j, 0) for j in range(1, n // 2 + 1) if s * j % n == 0)\n", "# from functools import lru_cache\n# class Solution:\n#     def splitArraySameAverage(self, A: List[int]) -> bool:\n#         # A.sort(reverse=True)\n#         n, total = len(A), sum(A)\n#         avag = total/n\n#         # epsilon = 0.000001\n#         # print(avag)\n#         @lru_cache(None)\n#         def dfs(idx, sums, sz):\n#             if 0 < sz <= n//2 and total*sz%n == 0 and sums == total*sz//n:\n#                 return True\n#             if idx == n or sz > n//2 or sums > total/2:\n#                 return False\n            \n#             return dfs(idx+1, sums+A[idx], sz+1) or dfs(idx+1, sums, sz)\n#             # print(idx,sums,sz,res)\n#         return dfs(0,0,0)\n\nfrom functools import lru_cache\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n, total = len(A), sum(A)\n        @lru_cache(None)\n        def dfs(idx, target, sz):\n            if sz < 0 or target < 0 or idx+sz > n:\n                return False\n            if idx == n:\n                return target == 0\n            \n            \n            return dfs(idx+1, target-A[idx], sz-1) or dfs(idx+1, target, sz)\n            # print(idx,sums,sz,res)\n        return any(dfs(0,total*k//n,k) for k in range(1,n//2+1) if total*k%n == 0)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        if len(A) < 2:\n            return False\n        \n        sumA, lenA = sum(A), len(A)\n        \n        if sumA / lenA in A:\n            return True\n        \n        if len(A) < 3:\n            return False\n        \n        if not any((sumA*size) % lenA == 0 for size in range(1, lenA//2+1)): \n            return False\n        \n        A = [i * lenA - sumA for i in A]\n        A.sort()\n        \n        a = [i for i in A if i < 0]\n        b = [i for i in A if i > 0]\n        \n        if len(a) > len(b):\n            a, b = b, a\n        \n        d = set()\n        def r1(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                \n                d.add(-ss)\n                \n                if n:\n                    r1(ss, list(arr), n-1)\n\n        r1(0, a, len(a) // 2)\n        \n        def r2(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                if ss in d:\n                    return True\n                \n                if n and r2(ss, list(arr), n-1):\n                    return True\n        return r2(0, b, len(b) // 2 - 1)\n\n\n\n            \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        # fix how many go into B and C\n        # then we know what the goal is?\n        # 4:1, B gets 4x as much as C\n        # B gets 4/5, C gets 1/5\n        # then knapsack on one of them (lower one)\n        A.sort(reverse=True)\n        def helper(goal,cnt):\n            # knapsack\n            @lru_cache(None)\n            def dp(i,tot,left):\n                if tot==goal and left==0:\n                    return True\n                if tot>goal or left==0 or i==len(A):\n                    return False\n                return dp(i+1,tot,left) or dp(i+1,tot+A[i],left-1)\n            return dp(0,0,cnt)\n        tot = sum(A)\n        for i in range(1,len(A)//2+1):\n            # B gets i\n            # C gets len(A)-i\n            # B gets i/len(A) * tot\n            needed = tot*i/len(A)\n            if int(needed)!=needed:\n                continue\n            needed=int(needed)\n            if helper(needed,i):\n                print(needed)\n                return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        m = len(A)\n        total = sum(A)\n        target = total / m\n        A.sort()\n        \n        @lru_cache(None)\n        def dfs(k, i, sum_b):\n            if k == 0:\n                return sum_b == 0\n            if i == len(A):\n                return False\n            return dfs(k - 1, i + 1, sum_b - A[i]) or dfs(k, i + 1, sum_b)\n        \n        for k in range(1, m // 2 + 1):\n            if total * k % m == 0:\n                if dfs(k, 0, total * k // m):\n                    return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        def dp(idx, L, target):\n            if L==0 and target==0:\n                return True\n            \n            if idx==N or L==0 or target<0:\n                return False\n            \n            if (idx, L, target) in memo: return memo[(idx, L, target)]\n            memo[(idx, L, target)] = A[idx]<=target and dp(idx+1, L-1, target-A[idx]) or dp(idx+1, L, target)\n            return memo[(idx, L, target)]       \n\n        total = sum(A)\n        N = len(A)\n        \n        for i in range(1, len(A)//2+1):\n            sub_sum = total*i/N\n            memo = {}\n            if sub_sum == int(sub_sum) and dp(0, i, int(sub_sum)):\n                return True\n            \n        return False\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        S = sum(A)\n        N = len(A)\n        A.sort(reverse = True)\n        import functools\n        @functools.lru_cache(None)\n        def DFS(target,i,n_left):\n            if target == 0 :\n                return (n_left == 0)\n            if target < 0 :\n                return False\n            if i == len(A):\n                return False\n            return DFS(target-A[i],i+1,n_left-1) or DFS(target,i+1,n_left)\n        \n        \n        return any(DFS(S*K//N,0,K) for K in range(1,N) if S*K%N == 0)\n", "class Solution:\n    def splitArraySameAverage(self, nums):\n        def find(target, k, i):\n            if (target, k) in d and d[(target, k)] <= i:\n                return False\n            if k == 0:\n                return target == 0\n            if k + i > len(nums):\n                return False\n            res = find(target - nums[i], k - 1, i + 1) or find(target, k, i + 1)\n            if not res:\n                d[(target, k)] = min(d.get((target, k), length), i)\n            return res\n\n        d, length, sum_nums = {}, len(nums), sum(nums)\n        return any(\n            find(sum_nums * i // length, i, 0) \n            for i in range(1, length // 2 + 1) \n            if sum_nums * i % length == 0\n                )", "from functools import lru_cache\n\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        # TLE\n#         avg = sum(A) / len(A)\n#         for k in range(1, len(A) // 2 + 1):\n#             for comb in combinations(A, k):\n#                 if abs(sum(comb) / k - avg) < 1e-5:\n#                     return True\n            \n#         return False\n\n        N, S = len(A), sum(A)\n        \n        @lru_cache(None)\n        def combinationSum(target, start, k):\n            if target == 0:\n                return k == 0\n            if start == N or k < 0 or target < 0:\n                return False\n            \n            return combinationSum(target-A[start], start+1, k-1) or combinationSum(target, start+1, k)\n        \n        for k in range(1, N // 2 + 1):\n            if S * k % N == 0:\n                if combinationSum(S * k // N, 0, k):\n                    return True\n        \n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        la = len(A)\n        sa = sum(A)\n       \n        memo = {}\n        \n        def find(target,k,i): # k is needed length, i is the ith element\n            if k==0: return target==0\n            if k+i>la: return False\n         \n            if (target,k,i) in memo: return memo[(target,k,i)]\n            \n            memo[(target,k,i)] = find(target-A[i],k-1,i+1) or find(target,k,i+1)\n            return memo[(target,k,i)]\n        \n        return any(find(j*sa//la,j,0) for j in range(1,la//2+1) if j*sa%la==0)\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        import sys\n        from functools import lru_cache\n        \n    \n    \n        @lru_cache(None)\n        def knapsack(i, num, tot):\n            # Find num items in A that add up to tot\n            if i > len(A) - 1 or num <= 0 or tot <= 0:\n                return False\n            elif num == 1 and A[i] == tot:\n                return True\n            else:\n                include = knapsack(i + 1, num - 1, tot - A[i])\n                exclude = knapsack(i + 1, num, tot)\n\n                if include:\n                    return True\n                elif exclude:\n                    return True\n            return None\n        sys.setrecursionlimit(100000)\n        tot = sum(A)\n        n = len(A)\n\n        gcd = math.gcd(tot, n)\n\n        num = n // gcd\n        A = sorted(A)\n\n        for i in range(1,n):\n            if (tot*i)%n == 0:\n                k = knapsack(0, i, tot * i // n)\n                if k is not None:\n                    return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        memo = {}\n        \n        def dfs(k, idx, total):\n            if k == 0: return total == 0\n            if k + idx > len(A): return False\n            \n            if (k, idx, total) in memo: return memo[(k, idx, total)]\n            \n            pick = dfs(k - 1, idx + 1, total - A[idx])\n            not_pick = dfs(k, idx + 1, total)\n            \n            memo[(k-1, idx+1, total - A[idx])] = pick or not_pick\n            return pick or not_pick\n        n, s = len(A), sum(A)\n        for k in range(1, n // 2 + 1):\n            if k * s % n == 0 and dfs(k, 0, k * s // n):\n                return True\n        return False", "class Solution:\n#def splitArraySameAverage(self, A: List[int]) -> bool:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n    # A subfunction that see if total k elements sums to target\n    # target is the goal, k is the number of elements in set B, i is the index we have traversed through so far\n        mem = {}\n\n        def find(target, k, i):\n        # if we are down searching for k elements in the array, see if the target is 0 or not. This is a basecase\n            if k == 0: return target == 0\n\n            # if the to-be selected elements in B (k) + elements we have traversed so far is larger than total length of A\n            # even if we choose all elements, we don't have enough elements left, there should be no valid answer.\n            if k + i > len(A): return False\n\n            if (target, k, i) in mem: return mem[(target, k, i)]\n\n            # if we choose the ith element, the target becomes target - A[i] for total sum\n            # if we don't choose the ith element, the target doesn't change\n            mem[(target - A[i], k - 1, i + 1)] = find(target - A[i], k - 1, i + 1) or find(target, k, i + 1)\n\n            return mem[(target - A[i], k - 1, i + 1)]\n\n        n, s = len(A), sum(A)\n    # Note that the smaller set has length j ranging from 1 to n//2+1\n    # we iterate for each possible length j of array B from length 1 to length n//2+1\n    # if s*j%n, which is the sum of the subset, it should be an integer, so we only proceed to check if s * j % n == 0\n    # we check if we can find target sum s*j//n (total sum of j elements that sums to s*j//n)\n        return any(find(s * j // n, j, 0) for j in range(1, n // 2 + 1) if s * j % n == 0)\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        S = sum(A)\n        N = len(A)\n        A.sort()\n        import functools\n        @functools.lru_cache(None)\n        def DFS(target,i,n_left):\n            if target == 0 :\n                return (n_left == 0)\n            if i == len(A) or target < 0 or target-A[i]*n_left < 0:\n                return False\n            return DFS(target-A[i],i+1,n_left-1) or DFS(target,i+1,n_left)\n        \n        \n        return any(DFS(S*K//N,0,K) for K in range(1,N) if S*K%N == 0)\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n        memo = {}\n        \n        def dfs(idx, k, total) -> bool:\n            #base case\n            if k == 0: return total == 0\n            if k + idx > len(A): return False\n            if (idx, k, total) in memo: return memo[(idx, k, total)]\n            \n            #pick or not pick\n            memo[(idx+1, k-1, total-A[idx])] = dfs(idx+1, k-1, total-A[idx]) or dfs(idx+1, k, total)\n            return memo[(idx+1, k-1, total-A[idx])]\n            \n        s, n = sum(A), len(A)\n        \n        #to check k*s is interger\n        return any(dfs(0, k, k*s//n) for k in range(1, n//2 + 1) if k*s%n == 0)\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n        memo = {}\n        \n        def dfs(idx, k, total) -> bool:\n            \n            if k == 0: return total == 0\n            if idx + k > len(A): return False\n            if (idx, k, total) in memo: return memo[(idx, k, total)]\n            \n            #pick or not pick\n            memo[(idx+1, k-1, total-A[idx])] = dfs(idx+1, k-1, total-A[idx]) or dfs(idx+1, k, total)\n            \n            return memo[(idx+1, k-1, total-A[idx])]\n            \n        \n        s, n = sum(A), len(A)\n        #(s//n) is the average\n        return any(dfs(0, k, k * s//n) for k in range(1, n // 2 + 1) if k * s % n == 0)\n        \n", "class Solution:\n    def dp(self, A, index, sum_, size, aux, dp):\n        if index == len(A): return False\n        if size == 0: return sum_ == 0\n\n        key = str(index) + str(sum_) + str(size)\n        if key in dp:\n            return dp[key]\n\n        if A[index] <= sum_:\n            aux.append(A[index])\n            if self.dp(A,index+1, sum_-A[index], size - 1, aux, dp):\n                dp[key] = True\n                return dp[key]\n            aux.pop()\n\n        if self.dp(A, index+1, sum_, size, aux, dp):\n            dp[key] = True\n            return dp[key]\n\n        dp[key] = False\n        return dp[key]\n    \n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n = len(A)\n        sum_ = sum(A)\n        dp = {}\n        ans = []\n        tmp1 = A\n        for i in range(1,n):\n            if (sum_ * i) % n == 0:\n                s1 = sum_*i\n                s1 //= n\n                aux = []\n                if self.dp(A,0, s1, i, aux, dp):\n                    return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        memo = {}\n        \n        def dfs(total, k, idx) -> bool:\n            if k == 0: return total == 0\n            if k + idx > len(A): return False\n            \n            if (total, k, idx) in memo: return memo[(total, k, idx)]\n            \n            #pick\n            pick = dfs(total - A[idx], k-1, idx+1)\n            not_pick = dfs(total, k, idx+1)\n            \n            memo[(total - A[idx], k-1, idx+1)] = pick or not_pick\n            return memo[(total - A[idx], k-1, idx+1)] \n        \n        n, s = len(A), sum(A)\n        \n        return any(dfs(s * k // n, k, 0) for k in range(1, n//2 + 1) if k * s % n == 0)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        A_sum = float(sum(A))\n        max_sublen = len(A) // 2\n        \n        targets = {}\n        last_valid_target = None\n        for i in range(1, max_sublen+1):\n            target = A_sum*i/len(A)\n            if target % 1 == 0:\n                last_valid_target = int(target)\n                targets[last_valid_target] = i\n                \n        if last_valid_target is None:\n            return False\n                \n        dp = [set() for _ in range(last_valid_target+1)]\n        dp[0].add(0)\n        for i in range(len(A)):\n            for sum_ in range(last_valid_target, A[i]-1, -1):\n                set2 = dp[sum_-A[i]]\n                if A[i] == 0:\n                    set2 = dp[sum_-A[i]].copy()\n                for n in set2:\n                    dp[sum_].add(n+1)\n                    if sum_ in targets and targets[sum_] == n+1:\n                        #print(dp)\n                        #print(sum_, n+1)\n                        return True\n        \n        return False\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        def dp(idx, rem, cnt):\n            if cnt==0 and rem==0:\n                return True\n            \n            if idx==N or cnt==0 or rem==0:\n                return False\n            \n            if (idx, rem, cnt) in memo: return memo[(idx, rem, cnt)]\n            \n            res = False\n            for i in range(idx, N):\n                if A[i]>rem: break\n                if dp(i+1, rem-A[i], cnt-1):\n                    res = True\n                    break\n            \n            memo[(idx, rem, cnt)] = res\n            return res\n        \n        suma = sum(A)\n        N = len(A)\n        memo = {}\n        A.sort()\n        for i in range(1, N//2+1):\n            if suma*i%N==0 and dp(0, suma*i/N, i):\n                return True\n            \n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        mem = {}\n\n        def find(target, k, i):\n            if k == 0: \n                return target == 0\n\n            if k + i > len(A): \n                return False\n\n            if (target, k, i) in mem: \n                return mem[(target, k, i)]\n\n           \n            mem[(target - A[i], k - 1, i + 1)] = find(target - A[i], k - 1, i + 1) or find(target, k, i + 1)\n\n            return mem[(target - A[i], k - 1, i + 1)]\n\n        n, s = len(A), sum(A)\n       \n        return any(find(s * j // n, j, 0) for j in range(1, n // 2 + 1) if s * j % n == 0)\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        A.sort()\n        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket\n        all_sum=sum(A)\n        DP[0]=set([0])\n        for item in A:                  #iterate over items in the list\n            for count in range(len(DP)-2,-1,-1):          # iterate backwards w.r.t. the bracket size\n                if len(DP[count])>0:                             # if DP[i] is not empty, then update DP[i+1] by adding the current item into all sums in DP[i]\n                    for a in DP[count]:\n                        DP[count+1].add(a+item)\n        for size in range(1,len(DP)):\n            if all_sum*size/len(A) in DP[size]:\n                return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n = len(A)\n        k = int(n/2)\n        dp = [set() for i in range(k+1)]\n        dp[0].add(0)\n        \n        for i,v in enumerate(A):\n            for j in range(min(i+1,k),0,-1):\n                for m in dp[j-1]:\n                    dp[j].add(m+v)\n        total = sum(A)\n        for i in range(1,k+1):\n            if total * i % n == 0:\n                if (i * total / n) in dp[i]:\n                    return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        n = len(A)\n        k = int(n/2)\n        dp = [set() for i in range(k+1)]\n        dp[0].add(0)\n        for i,v in enumerate(A):\n            for j in range(min(i+1,k),0,-1):\n                for m in dp[j-1]:\n                    dp[j].add(m+v)\n        \n        total = sum(A)\n        for i in range(1,k+1):\n            if i * total % n == 0:\n                if (total * i / n) in dp[i]:\n                    return True\n        return False", "#class Solution:\n#    def splitArraySameAverage(self, A: List[int]) -> bool:\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        A.sort()\n        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket\n        all_sum=sum(A)\n        DP[0]=set([0])\n        for item in A:                  #iterate over items in the list\n            for count in range(len(DP)-2,-1,-1):          # iterate backwards w.r.t. the bracket size\n                if len(DP[count])>0:                             # if DP[i] is not empty, then update DP[i+1] by adding the current item into all sums in DP[i]\n                    for a in DP[count]:\n                        DP[count+1].add(a+item)\n        for size in range(1,len(DP)):\n            if all_sum*size/len(A) in DP[size]:\n                return True\n        return False", "from collections import defaultdict\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        total = sum(A)\n        size = len(A)\n        possible = False\n        for i in range(size//2):\n            if total*i % size == 0:\n                possible = True\n                break\n        if not possible:\n            return False\n        dp = defaultdict(set)\n        dp[0].add(0)\n        for n in A:\n            for i in range(size//2, 0, -1):\n                for ele in dp[i-1]:\n                    dp[i].add(ele+n)\n        for i in range(1, size//2+1):\n            if total*i % size == 0 and total*i//size in dp[i]:\n                return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        A.sort()\n        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket\n        all_sum=sum(A)\n        DP[0]=set([0])\n        for item in A:                  #iterate over items in the list\n            for count in range(len(DP)-2,-1,-1):          # iterate backwards w.r.t. the bracket size\n                if len(DP[count])>0:                             # if DP[i] is not empty, then update DP[i+1] by adding the current item into all sums in DP[i]\n                    for a in DP[count]:\n                        DP[count+1].add(a+item)\n        for size in range(1,len(DP)):\n            if all_sum*size/len(A) in DP[size]:\n                return True\n        return False\n", "from functools import lru_cache\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        A.sort()\n        @lru_cache(None)\n        def dfs(idx, n, target):\n            if target == 0 and n == 0:\n                return True\n            if idx >= len(A) or n == 0:\n                return False\n            return dfs(idx + 1, n - 1, target - A[idx]) or dfs(idx + 1, n, target)\n        \n        return any([dfs(0, i, (sum(A) * i) // len(A)) for i in range(1, len(A)) if (sum(A) * i) % len(A) == 0])\n        \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n        if len(A) < 3:\n            return False\n        \n        sumA, lenA = sum(A), len(A)\n        \n        if sumA / lenA in A:\n            return True\n        \n        A = [i * lenA - sumA for i in A]\n        A.sort()\n        \n        a = [i for i in A if i < 0]\n        b = [i for i in A if i > 0]\n        \n        if len(a) > len(b):\n            a, b = b, a\n        \n        d = set()\n        def r1(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                \n                d.add(-ss)\n                \n                if n:\n                    r1(ss, list(arr), n-1)\n\n        r1(0, a, len(a) // 2)\n        \n        def r2(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                if ss in d:\n                    return True\n                \n                if n and r2(ss, list(arr), n-1):\n                    return True\n        return r2(0, b, len(b) // 2 - 1)\n\n\n\n            \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        ksums = [{0}]\n        maxk = len(A) // 2\n        \n        for a in A:\n            #print('a', a)\n            #print('ksums', ksums)\n            ksums = [[0]] + [\n                (ksums[k] if k < len(ksums) else set()) |\n                {a + x for x in ksums[k - 1]}\n                for k in range(1, min(len(ksums), maxk) + 1)\n            ]\n            #print('ksums*', ksums)\n            \n        n = len(A)\n        S = sum(A)\n        for k in range(1, min(len(ksums), maxk) + 1):\n            if any(x * (n - k) == k * (S - x) for x in ksums[k]):\n                return True\n        \n        return False", "\nfrom typing import List\n\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        if (len(A) <= 1):\n            return False\n        \n        n = len(A)\n        Sum = 0\n        for x in A:\n            Sum += x\n        dp = [ 0 for _ in range(Sum+1)]\n        dp[A[0]] = 2;\n        for i in range(1,n):\n            for s in range(Sum-A[i] , -1, -1):\n                if dp[s] > 0:\n                    dp[s+A[i]] |= (dp[s]<<1)\n            dp[A[i]] |= 2;\n        \n        for leng in range(1, n):\n            if (Sum*leng) % n == 0 and ( (1<<leng) & dp[(Sum*leng)//n] ):\n                return True\n        return False\n    \n    \n", "\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        return self.dp_bitwise(A)\n\n    def dp_bitwise(self, A: List[int]) -> bool:\n        #dummy case\n        if (len(A) <= 1):\n            return False\n        #calculate sum and number of elements\n        n = len(A)\n        Sum = 0\n        for x in A:\n            Sum += x\n        #dp[s] = m -- means sum s can be formed with elements of length bit i == 1 of m\n        #e.g. dp[10] = 20 it means sum 10 can be achieved with 2 or 4 elements - 10100 \n        #init dp with 0\n        dp = [ 0 for _ in range(Sum+1)]\n        dp[A[0]] = 2\n        #we iterate through all the elements\n        for i in range(1, n):\n            #we check every possible sum \n            for s in range(Sum-A[i], -1, -1):\n                #if s can be previously formed\n                if dp[s] > 0:\n                    # it means we can form s + A[i] also from dp[s] by shifting it \n                    # with one, as we have an additional element\n                    dp[s + A[i]] |= (dp[s]<<1)\n            dp[A[i]] |= 2\n        \n        for leng in range(1, n):\n            if (Sum * leng) % n == 0 and ( (1 << leng) & dp[(Sum * leng) // n] ):\n                return True\n        return False\n\n    \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        \n        N = len(A)\n        \n        if N <= 1:\n            return False\n        \n        max_sum = sum(A)\n        #print(max_sum)\n        sums = [0] * (max_sum+1)\n        for i in range(N):\n            num = A[i]\n            for s in range(max_sum, num-1, -1):\n                if sums[s-num]:\n                    sums[s] |= sums[s-num] << 1\n            sums[num] |= 1\n            #print(sums)\n        #print(sums)\n        for l in range(1, N):\n            if (max_sum * l) % N == 0:\n                s = int((max_sum * l) / N)\n                if (sums[s] >> (l-1)) & 1:\n                    return True\n        return False           ", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        \n        N = len(A)\n        \n        if N <= 1:\n            return False\n        \n        max_sum = sum(A)\n        #print(max_sum)\n        sums = [0] * (max_sum+1)\n        for i in range(N):\n            num = A[i]\n            for s in range(max_sum, num-1, -1):\n                if sums[s-num]:\n                    sums[s] |= sums[s-num] << 1\n            sums[num] |= 1\n            #print(sums)\n        #print(sums)\n        for l in range(1, N):\n            s = (max_sum * l) / N\n            if s.is_integer() and (sums[int(s)] >> (l-1)) & 1:\n                return True\n        return False           ", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        \n#         ALen = len(A)\n#         visited = set()\n        \n#         def checkNum(i0, bN, bSum, aN, aSum):\n#             if i0 == ALen:\n#                 if aN != 0 and bN != 0 and bSum*aN == aSum*bN:\n#                     return True\n#                 return False\n#             if (i0, bN, bSum) in visited:\n#                 return False\n#             visited.add((i0, bN, bSum))\n#             subAns = checkNum(i0+1, bN+1, bSum+A[i0], aN, aSum) or checkNum(i0+1, bN, bSum, aN +1, aSum + A[i0])\n#             return subAns\n        \n#         return checkNum(0, 0, 0, 0, 0)\n        from fractions import Fraction\n        ALen = len(A)\n        s = sum(A)\n        if ALen == 1:\n            return False\n        \n        for i in range(ALen):\n            A[i] -= Fraction(s, ALen)\n        A.sort()\n        leftSet = {A[0]}\n        for i in range(1, ALen//2):\n            leftSet = {z+A[i] for z in leftSet} | leftSet | {A[i]}\n        if 0 in leftSet:\n            return True\n        \n        rightSet = {A[ALen-1]}\n        for i in range(ALen//2, ALen-1):\n            rightSet = {z+A[i] for z in rightSet} | rightSet | {A[i]}\n        if 0 in rightSet:\n            return True\n        \n        leftSum = sum(A[:ALen//2])\n        rightSum = sum(A[ALen//2:])\n        \n        return any(-left in rightSet and (left, -left) != (leftSum, rightSum) for left in leftSet)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        ksums = [{0}]\n        maxk = len(A) // 2\n        \n        n = len(A)\n        S = sum(A)\n        for a in A:\n            #print('a', a)\n            #print('ksums', ksums)\n            nksums = [[0]]\n            for k in range(1, min(len(ksums), maxk) + 1):\n                new_part = {a + x for x in ksums[k - 1]}\n                if any(x * (n - k) == k * (S - x) for x in new_part):\n                    return True\n                \n                row = (ksums[k] if k < len(ksums) else set()) | new_part\n                nksums.append(row)\n                \n            ksums = nksums\n            #print('ksums*', ksums)\n            \n        \n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        total_sum = sum(A)\n        sum_dict = collections.defaultdict(set)\n\n        for val in A:\n            temp_list = [(1, val)]\n            for key, set_val in sorted(sum_dict.items()):\n                if key == len(A) // 2:\n                    break\n                for sum_val in set_val:\n                    temp_list.append((key + 1, val + sum_val))\n            for key_val, sum_val in temp_list:\n                sum_dict[key_val].add(sum_val)\n\n        for i in range(len(A) - 1):\n            if (total_sum * (i + 1) / len(A)) in sum_dict[i + 1]:\n                return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n        if len(A) < 3:\n            return False\n        \n        sumA, lenA = sum(A), len(A)\n        \n        if sumA / lenA in A:\n            return True\n        \n        A = [i * lenA - sumA for i in A]\n        A.sort()\n        \n        a = [i for i in A if i < 0]\n        b = [i for i in A if i > 0]\n        \n        if len(a) > len(b):\n            a, b = b, a\n        \n        d = {-i for i in A}\n        def r1(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                \n                d.add(-ss)\n                \n                if n and r1(ss, list(arr), n-1):\n                    return True\n\n        # print(a)\n        if r1(0, a, len(a) // 2):\n            return True\n        # print(d)\n        # print(b)\n        \n        def r2(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                if ss in d:\n                    return True\n                \n                if n and r2(ss, list(arr), n-1):\n                    return True\n        if r2(0, b, len(b) // 2 - 1):\n            return True\n        # print(d)\n        return False\n\n\n            \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        su = sum(A)\n        ii = len(A)//2+1\n        arr = [set() for _ in range(ii)]\n        arr[0].add(0)\n        for x in A:\n            for t in reversed(range(1,ii)):\n                arr[t]|=set(map(lambda s:s+x,arr[t-1]))\n        # print(arr)\n        for i in range(1,len(A)//2+1):\n            if (su*i)%len(A)==0:\n                # print(i, su*i, arr[i])\n                if (su*i)//len(A) in arr[i]:\n                    return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n        \n        if N == 1:\n            return False\n        \n        left = {A[0]}\n        \n        for i in range(1, N//2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        \n        if 0 in left:\n            return True\n        \n        right = {A[-1]}\n        \n        for i in range(N//2, N-1):\n            right = {z + A[i] for z in right} | right |{A[i]}\n        \n        if 0 in right:\n            return True\n        \n        sleft = sum(A[i] for i in range(N//2))\n        sright = sum(A[i] for i in range(N//2, N))\n        \n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)\n            \n", "class Solution(object):\n    def splitArraySameAverage(self, A):\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in range(1, N//2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in range(N//2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in range(N//2))\n        sright = sum(A[i] for i in range(N//2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)", "class Solution(object):\n    def splitArraySameAverage(self, A):\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in range(1, int(N/2)):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in range(int(N/2), N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in range(int(N/2)))\n        sright = sum(A[i] for i in range(int(N/2), N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        ksums = [{0}]\n        maxk = len(A) // 2\n        \n        n = len(A)\n        S = sum(A)\n        for a in A:\n            #print('a', a)\n            #print('ksums', ksums)\n            nksums = [[0]]\n            for k in range(1, min(len(ksums), maxk) + 1):\n                row = (ksums[k] if k < len(ksums) else set()) | {a + x for x in ksums[k - 1]}\n                if any(x * (n - k) == k * (S - x) for x in row):\n                    return True\n            \n                nksums.append(row)\n                \n            ksums = nksums\n            #print('ksums*', ksums)\n            \n        \n        return False", "from fractions import Fraction\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in range(1, N//2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in range(N//2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in range(N//2))\n        sright = sum(A[i] for i in range(N//2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)", "#\n# @lc app=leetcode id=805 lang=python3\n#\n# [805] Split Array With Same Average\n#\n# https://leetcode.com/problems/split-array-with-same-average/description/\n#\n# algorithms\n# Hard (24.71%)\n# Likes:    244\n# Dislikes: 49\n# Total Accepted:    10.3K\n# Total Submissions: 41.6K\n# Testcase Example:  '[1,2,3,4,5,6,7,8]'\n#\n# In a given integer array A, we must move every element of A to either list B\n# or list C. (B and C initially start empty.)\n# \n# Return true if and only if after such a move, it is possible that the average\n# value of B is equal to the average value of C, and B and C are both\n# non-empty.\n# \n# \n# Example :\n# Input: \n# [1,2,3,4,5,6,7,8]\n# Output: true\n# Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of\n# them have the average of 4.5.\n# \n# \n# Note:\n# \n# \n# The length of A will be in the range\u00a0[1, 30].\n# A[i] will be in the range of [0, 10000].\n# \n# \n# \n# \n#\nfrom fractions import Fraction\n\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        # Time  complexity: O(2^(N/2))\n        # Space complexity: O(2^(N/2))\n        N, S = len(A), sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        left = {A[0]}\n        for i in range(1, N//2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in range(N//2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in range(N//2))\n        sright = sum(A[i] for i in range(N//2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)\n\n        \n\n\n        \n\n", "class Solution1:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        \n        N = len(A)\n        \n        if N <= 1:\n            return False\n        \n        max_sum = sum(A)\n        #print(max_sum)\n        sums = [0] * (max_sum+1)\n        for i in range(N):\n            num = A[i]\n            for s in range(max_sum, num-1, -1):\n                if sums[s-num]:\n                    sums[s] |= sums[s-num] << 1\n            sums[num] |= 1\n            #print(sums)\n        #print(sums)\n        for l in range(1, N):\n            if (max_sum * l) % N == 0:\n                s = int((max_sum * l) / N)\n                if (sums[s] >> (l-1)) & 1:\n                    return True\n        return False\n\nimport math\nclass Solution2:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        A.sort(reverse=True)\n        N = len(A)\n        if N <= 1:\n            return False\n        max_size = math.ceil(N / 2)\n        \n        max_sum = sum(A)\n        target_mean = max_sum / N\n        #print(target_mean)\n        ans = False\n        \n        def choose(max_n, curr_n, curr_sum, next_id):\n            nonlocal target_mean\n            nonlocal ans\n            nonlocal N\n            #print(max_n, curr_n, curr_sum, next_id)\n            if ans:\n                return\n            if curr_n > max_n:\n                return\n            if curr_n:\n                curr_mean = curr_sum / curr_n\n                if curr_mean < target_mean:\n                    return\n                if curr_mean == target_mean:\n                    ans = True\n                    return\n            if next_id == N -1:\n                return\n            for i in range(next_id, N):\n                choose(max_n, curr_n + 1, curr_sum + A[i], i+1)\n        \n        choose(max_size, 0, 0, 0)\n        \n        return ans\n    \nclass Solution(object):\n    def splitArraySameAverage(self, A):\n        from fractions import Fraction\n        N = len(A)\n        S = sum(A)\n        A = [z - Fraction(S, N) for z in A]\n\n        if N == 1: return False\n\n        #Want zero subset sum\n        left = {A[0]}\n        for i in range(1, N//2):\n            left = {z + A[i] for z in left} | left | {A[i]}\n        if 0 in left: return True\n\n        right = {A[-1]}\n        for i in range(N//2, N-1):\n            right = {z + A[i] for z in right} | right | {A[i]}\n        if 0 in right: return True\n\n        sleft = sum(A[i] for i in range(N//2))\n        sright = sum(A[i] for i in range(N//2, N))\n\n        return any(-ha in right and (ha, -ha) != (sleft, sright) for ha in left)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        tot = sum(A)\n        n = len(A)\n        target = tot/n \n        visited = [ False]*len(A)\n        m = n // 2\n        possible = False\n        for i in range(1, m+ 1):\n            if (tot * i)%n == 0:\n                possible = True\n                break\n        if not possible:\n            return False\n        A.sort( )\n        \n        \n        def helper(A, cursum, curcnt, pos):\n            if curcnt == 0:\n                return cursum == 0\n            if A[pos] >cursum/curcnt:\n                return False\n            for i in range(pos, len(A) - curcnt + 1):\n                if i > pos and A[i]==A[i-1]:\n                    continue\n                if helper(A, cursum - A[i], curcnt - 1, i + 1):\n                    return True\n            \n            return False\n         \n        for i in range(1, m + 1):\n            if (tot * i)%n == 0 and helper(A, (tot * i)/n, i, 0):\n                return True\n        return False\n            \n            \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        dp = set([(0,0)])\n        suma = sum(A)\n        N = len(A)\n        A.sort()\n        for num in A:\n            for k, v in list(dp):\n                if k>=N//2: continue\n                if num+v>suma*(k+1)//N: continue\n                # print(k, v, num, dp)    \n                if num+v==suma*(k+1)//N and suma*(k+1)%N==0 and k+1<N:\n                    return True\n\n                dp.add((k+1, num+v))\n        \n        return False\n\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        total = sum(A)\n        sets = [{0}] + [set() for _ in A]\n        for num in A:\n            for j in reversed(list(range(len(A) - 1))):\n                for k in sets[j]:\n                    s = k + num\n                    if total * (j + 1) == s * len(A):\n                        return True\n                    sets[j + 1].add(k + num)\n        \n        return False\n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        total = sum(A)\n        l = len(A)\n        dp = [0] * (total + 1)\n        dp[A[0]] = 2\n        for i in range(1, l):\n            for j in range(total - A[i], -1, -1):\n                dp[j + A[i]] |= (dp[j] << 1)\n            dp[A[i]] |= 2\n        \n        for i in range(1, l):\n            if (total * i) % l == 0 and ((1 << i) & dp[total * i // l]) > 0:\n                return True\n        return False\n", "from fractions import Fraction\nclass Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        if len(A) == 1: return False\n        avg = Fraction(sum(A), len(A))\n        A = [num - avg for num in A]\n        left = set()\n        for i in range(len(A) // 2):\n            curr_set = {s + A[i] for s in left}\n            left = left | curr_set | {A[i]}\n        if 0 in left: return True\n        rsum = sum(A[i] for i in range(len(A) // 2, len(A)))\n        right = set()\n        for i in range(len(A) // 2, len(A)):\n            if A[i] == 0: return True\n            curr_set = {A[i]}\n            for s in right:\n                if s + A[i] == 0 or (- s - A[i] in left and s + A[i] != rsum):\n                    return True\n                curr_set.add(s + A[i])\n            right = right | curr_set\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        avg, N = sum(A), len(A)\n        if N < 2: return False\n        if N == 2: return A[0] == A[1]\n        A = [num*N - avg for num in A]\n        \n        dp = collections.defaultdict(set)\n        # Last element goes to another array\n        for i, n in enumerate(A[:-1]):\n            if n == 0: return True # Single element array\n            if i == 0:\n                dp[0].add(n)\n                continue\n            sums = set()\n            sums.add(n)\n            for j, s in dp.items():\n                for ps in s:\n                    if ps + n == 0:\n                        return True\n                    sums.add(ps+n)\n            dp[i] = sums\n        return False", "class Solution:\n    def splitArraySameAverage(self, A) -> bool:\n        if sum(A)==0 and len(A)>1:\n            return True\n        elif len(A)==1:\n            return False\n        mem={}\n        ss=sum(A)\n        n=len(A)\n        def rec(index,cur_sum,length):\n            if cur_sum*(n-length)==length*(ss-cur_sum) and length>0 and length<n:\n                return True\n            elif index==n:\n                return False\n            elif (index,cur_sum) in mem:\n                return mem[(index,cur_sum)]\n            else:\n                mem[(index,cur_sum)]=(rec(index+1,cur_sum+A[index],length+1) | rec(index+1,cur_sum,length))\n                return mem[(index,cur_sum)]\n            \n        return rec(0,0,0)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n\n        if len(A) < 3:\n            return False\n        \n        sumA, lenA = sum(A), len(A)\n        \n        if sumA / lenA in A:\n            return True\n        \n        A = [i * lenA - sumA for i in A]\n        A.sort()\n        \n        a = [i for i in A if i < 0]\n        b = [i for i in A if i > 0]\n        \n        if len(a) > len(b):\n            a, b = b, a\n        \n        # d = {-i for i in a}\n        d = set()\n        def r1(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                \n                d.add(-ss)\n                \n                if n and r1(ss, list(arr), n-1):\n                    return True\n\n        # print(a)\n        if r1(0, a, len(a) // 2):\n            return True\n        # print(d)\n        # print(b)\n        \n        def r2(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                if ss in d:\n                    return True\n                \n                if n and r2(ss, list(arr), n-1):\n                    return True\n        if r2(0, b, len(b) // 2 - 1):\n            return True\n        # print(d)\n        return False\n\n\n            \n", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        S = sum(A)\n        L = len(A)\n        if L == 1: return False\n        sizes = {(0,0)}\n        for n in A:\n            for s,c in sizes.copy():\n                if c<L//2:\n                    sizes.add((s+n,c+1))\n        sizes.remove((0,0))\n        for s,c in sizes:\n            if s*(L-c) == (S-s)*c:\n                return True\n        return False", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        \n        N = len(A)\n        \n        if N <= 1:\n            return False\n        \n        max_sum = sum(A)\n        print(max_sum)\n        sums = [0] * (max_sum+1)\n        for i in range(N):\n            num = A[i]\n            for s in range(max_sum, num-1, -1):\n                if sums[s-num]:\n                    sums[s] |= sums[s-num] << 1\n            sums[num] |= 1\n            #print(sums)\n        #print(sums)\n        for s in range(max_sum+1):\n            for i in range(N-1):\n                if (sums[s] >> i) & 1:\n                    mean = s / (i + 1)\n                    rem = (max_sum - s) / (N - (i + 1))\n                    if mean == rem:\n                        return True\n                    \n        return False           ", "class Solution:\n    dp = []\n    def is_possible(self, l, actual_sum, index, curr_sum, curr_element_count):\n        if index >= len(l):\n            return False\n        if Solution.dp[curr_element_count][curr_sum] != None:\n            return Solution.dp[curr_element_count][curr_sum]\n        if curr_element_count!=0 and (actual_sum-curr_sum) / (len(l)-curr_element_count) == curr_sum/curr_element_count:\n            print(curr_sum/curr_element_count)\n            return True\n        Solution.dp[curr_element_count][curr_sum] =  self.is_possible(\n            l, actual_sum, index+1, curr_sum+l[index], curr_element_count+1\n            ) or self.is_possible(\n                l, actual_sum, index+1, curr_sum, curr_element_count\n                )\n        return Solution.dp[curr_element_count][curr_sum]\n\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        if A == None or len(A) <=1:\n            return False\n        Solution.dp = [[None] * (sum(A)+10) for _ in range(len(A)+1)]\n        return self.is_possible(A, sum(A), 0, 0, 0)", "class Solution:\n    dp = []\n    def is_possible(self, l, actual_sum, index, curr_sum, curr_element_count):\n        if index >= len(l):\n            return False\n        if Solution.dp[curr_element_count][curr_sum] != None:\n            return Solution.dp[curr_element_count][curr_sum]\n        if curr_element_count!=0 and (actual_sum-curr_sum) / (len(l)-curr_element_count) == curr_sum/curr_element_count:\n            #print(curr_sum/curr_element_count)\n            return True\n        Solution.dp[curr_element_count][curr_sum] =  self.is_possible(\n            l, actual_sum, index+1, curr_sum+l[index], curr_element_count+1\n            ) or self.is_possible(\n                l, actual_sum, index+1, curr_sum, curr_element_count\n                )\n        return Solution.dp[curr_element_count][curr_sum]\n\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        if A == None or len(A) <=1:\n            return False\n        Solution.dp = [[None] * (sum(A)+10) for _ in range(len(A)+1)]\n        return self.is_possible(A, sum(A), 0, 0, 0)", "class Solution:\n    def splitArraySameAverage(self, A: List[int]) -> bool:\n        # A = [53,6,3,34,91,82,47,9,70,1]\n        if len(A) < 3:\n            return False\n        \n        sumA, lenA = sum(A), len(A)\n        \n        if sumA / lenA in A:\n            return True\n        \n        A = [i * lenA - sumA for i in A]\n        A.sort()\n        \n        a = [i for i in A if i < 0]\n        b = [i for i in A if i > 0]\n        \n        if len(a) > len(b):\n            a, b = b, a\n        \n        d = {-i for i in A}\n        def r(s, arr, n):\n            xx = None\n            while arr:\n                x = arr.pop()\n                if xx == x:\n                    continue\n                \n                xx = x\n                ss = s + x\n                if ss in d:\n                    return True\n                \n                d.add(-ss)\n                \n                if n and r(ss, list(arr), n-1):\n                    return True\n\n        # print(a)\n        if r(0, a, len(a) - 1):\n            return True\n        # print(d)\n        # print(b)\n        if r(0, b, len(b) // 2 - 1):\n            return True\n        # print(d)\n        return False\n\n\n            \n"]
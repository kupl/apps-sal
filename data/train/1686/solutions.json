["class PathNode:\n\n    def __init__(self, row, col, st_x, st_y, p_count=0):\n        self.x = row\n        self.y = col\n        self.pathCount = p_count\n\n    def __str__(self):\n        return str(self.x) + \" | \" + str(self.y) + \" | \" + str(self.pathCount)\n\n\nclass GraphUtil:\n    def __init__(self, mat, R,C, d):\n        self.mat = mat\n        self.R = R\n        self.C = C\n        self.d = d\n        self.tab = {}\n\n    def isValidMove(self, r, c, blockVal):\n        return r < self.R and c < self.C and self.mat[r][c] != blockVal\n\n    def possbilePathUtil(self, r, c, blockVal, step,direction):\n\n        if(not self.isValidMove(r, c, 0)):\n            return 0\n            \n        if (r == self.R - 1 and c == self.C - 1):\n            return 1\n\n        if ((r,c,step,direction) in self.tab):\n            return self.tab[(r,c,step,direction)]\n\n        result = 0\n        \n        if direction == 1:\n            if step < self.d:\n                result = (result + self.possbilePathUtil(r, c + 1, blockVal, step + 1,1)) % 20011\n            result = (result +  self.possbilePathUtil(r+1, c, blockVal, 1,2)) % 20011\n        else:\n            if step < self.d:\n                result = (result + self.possbilePathUtil(r + 1, c, blockVal, step + 1, 2)) % 20011\n            result = (result + self.possbilePathUtil(r, c + 1, blockVal, 1,1)) % 20011\n        \n        self.tab[(r,c,step,direction)] = result\n        \n        return result\n\n    def possbilePath(self):\n        if (not self.mat or len(self.mat) < 1):\n            return 0\n\n        return self.possbilePathUtil(0, 0, 0,0,2)\n\n\nnumbers = [int(n) for n in input().split()]\n\nmat = [[int(n) for n in input().split()] for r in range(0, numbers[0])]\n\nresult = GraphUtil(mat, numbers[0], numbers[1], numbers[2])\n\nprint(result.possbilePath())\n# print(result.count)# cook your dish here\n", "MODULO = 20011\r\n\r\ndef solve(grid, R, C, d):\r\n    if grid[1][1] == 0 or grid[R][C] == 0:\r\n        return 0\r\n    # count paths from (r=1, c=1) to (r=R, c=C)\r\n    path_top = [[0] * (C + 1) for row in range(R + 1)]\r\n    path_left = [[0] * (C + 1) for row in range(R + 1)]\r\n    # 1st row:\r\n    # from (1,1) going right, you can travel all the\r\n    # way to (1,d+1) but no further than (1,C)\r\n    for col in range(1, min(d + 2, C + 1)):\r\n        if grid[1][col] == 1:\r\n            path_left[1][col] = 1\r\n        else:\r\n            break\r\n    # row-th row, row>1\r\n    for row in range(2, R + 1):\r\n        for col in range(1, C + 1):\r\n            if grid[row][col] == 1:\r\n                # entering (row,col) from the top:\r\n                for i in range(1, min(d + 1, row)):\r\n                    if grid[row - i][col] == 1:\r\n                        path_top[row][col] += path_left[row - i][col]\r\n                    else:\r\n                        break\r\n                # entering (row,col) from the left:\r\n                for i in range(1, min(d + 1, col)):\r\n                    if grid[row][col - i] == 1:\r\n                        path_left[row][col] += path_top[row][col - i]\r\n                    else:\r\n                        break\r\n    # return solution\r\n    return path_top[R][C] + path_left[R][C]\r\n\r\ndef __starting_point():\r\n    R, C, d = list(map(int, input().strip().split()))\r\n    grid = [[0] * (C + 1) for row in range(R + 1)]\r\n    for row in range(1, R + 1):\r\n        grid[row] = [0] + list(map(int, input().strip().split()))\r\n    print(solve(grid, R, C, d) % MODULO)\r\n\n__starting_point()", "# cook your dish here\nr, c, k = map(int, input().split())\nmatrix=[]\nfor _ in range(r):\n    matrix.append(list(map(int, input().split())))\nleft=[[[0,0] for _ in range(c)] for i in range(r)]\nup=[[[0,0] for _ in range(c)] for i in range(r)]\nleft[0][0][0]=1 \nup[0][0][0]=1 \nfor i in range(1,min(k+1,c)):\n    if matrix[0][i]==1:\n        left[0][i][0]=left[0][i-1][0]\n        if left[0][i-1][0]>0:\n            left[0][i][1]=left[0][i-1][1]+1\nfor i in range(1,min(k+1,r)):\n    if matrix[i][0]==1:\n        up[i][0][0]=up[i-1][0][0]\n        if up[i-1][0][0]>0:\n            up[i][0][1]=up[i-1][0][1]+1\nfor i in range(1,min(k+1,r)):\n    for j in range(1,min(k+1,c)):\n        if matrix[i][j]==1:\n            left[i][j][0]=left[i][j-1][0]+up[i][j-1][0]\n            if left[i][j-1][0]+up[i][j-1][0]>0:\n                left[i][j][1]=left[i][j-1][1]+1\n            up[i][j][0]=up[i-1][j][0]+left[i-1][j][0]\n            if left[i-1][j][0]+up[i-1][j][0]>0:\n                up[i][j][1]=up[i-1][j][1]+1\n    for j in range(min(k+1,c), c):\n        if matrix[i][j]==1:\n            up[i][j][0]=up[i-1][j][0]+left[i-1][j][0]\n            if left[i-1][j][0]+up[i-1][j][0]>0:\n                up[i][j][1]=up[i-1][j][1]+1\n            left[i][j][0]=left[i][j-1][0]+up[i][j-1][0]\n            if left[i][j-1][0]+up[i][j-1][0]>0:\n                left[i][j][1]=left[i][j-1][1]+1\n            if left[i][j][1]>k:\n                left[i][j][0]-=up[i][j-k-1][0]\n            \nfor i in range(min(k+1,r),r):\n    for j in range(1,min(k+1,c)):\n        if matrix[i][j]==1:\n            left[i][j][0]=left[i][j-1][0]+up[i][j-1][0]\n            if left[i][j-1][0]+up[i][j-1][0]>0:\n                left[i][j][1]=left[i][j-1][1]+1\n            up[i][j][0]=up[i-1][j][0]+left[i-1][j][0]\n            if left[i-1][j][0]+up[i-1][j][0]>0:\n                up[i][j][1]=up[i-1][j][1]+1\n            if up[i][j][1]>k:\n                up[i][j][0]-=left[i-k-1][j][0]\n            \n    for j in range(min(k+1,c), c):\n        if matrix[i][j]==1:\n            up[i][j][0]=up[i-1][j][0]+left[i-1][j][0]\n            if left[i-1][j][0]+up[i-1][j][0]>0:\n                up[i][j][1]=up[i-1][j][1]+1\n            if up[i][j][1]>k:\n                up[i][j][0]-=left[i-k-1][j][0]\n            left[i][j][0]=left[i][j-1][0]+up[i][j-1][0]\n            if left[i][j-1][0]+up[i][j-1][0]>0:\n                left[i][j][1]=left[i][j-1][1]+1\n            if left[i][j][1]>k:\n                left[i][j][0]-=up[i][j-k-1][0]\n'''\nfor i in range(r):\n    print([el for el in up[i]])\nfor i in range(r):\n    print([el[0] for el in left[i]])\n'''\nprint((up[-1][-1][0]+left[-1][-1][0])%20011)", "# cook your dish here\nMOD = 20011\nimport copy\nR,C,D = map(int,input().split())\nlist1=[]\nfor i in range(R):\n    temp = list(map(int,input().split()))\n    list1.append(temp)\nfor j in range(C):\n    if list1[0][j] ==0:\n        for i in range(j,C):\n            list1[0][i]=0\n        break\nfor i in range(R):\n    if list1[i][0] ==0:\n        for j in range(i,R):\n            list1[j][0] =0\n        break\nif D+1<C:\n    for j in range(D+1,C):\n        list1[0][j] = 0\nif D+1<R:\n    for i in range(D+1,R):\n        list1[i][0] = 0\nlist2 = copy.deepcopy(list1)\nfor j in range(1,R):\n    count=[ 0 for i in range(R)]\n    count1=[0 for j in range(C)]\n    for i in range(1,C):\n        if list2[j][i]!=0:\n            list2[j][i] = list2[j-1][i]+list2[j][i-1]\n        if j-D-1>=0 and list2[j-1][i]!=0:\n            list2[j][i] -= list2[j-D-1][i]\n            if j-D-2>=0:\n                list2[j][i] += list2[j-D-2][i]\n        if i-D-1>=0 and list2[j][i-1]!=0:\n            list2[j][i]-=list2[j][i-D-1]\n            if i-D-2>=0:\n                list2[j][i] += list2[j][i-D-2]\n        if list2[j][i]<0:\n            list2[j][i] =0\nanswer = (list2[R-1][C-1])%MOD\n#for i in range(len(list1)):\n    #print(list1[i],list2[i])\nprint(answer)\n", "# cook your dish here\nMOD = 20011\nimport copy\nR,C,D = map(int,input().split())\nlist1=[]\nfor i in range(R):\n    temp = list(map(int,input().split()))\n    list1.append(temp)\nfor j in range(C):\n    if list1[0][j] ==0:\n        for i in range(j,C):\n            list1[0][i]=0\n        break\nfor i in range(R):\n    if list1[i][0] ==0:\n        for j in range(i,R):\n            list1[j][0] =0\n        break\nif D+1<C:\n    count = 1\n    for j in range(D+1,C):\n        list1[0][j] = list1[0][j] - count\n        count +=1\nif D+1<R:\n    count=1\n    for i in range(D+1,R):\n        list1[i][0] = list1[i][0]-count\n        count +=1\nlist2 = copy.deepcopy(list1)\nfor j in range(1,R):\n    for i in range(1,C):\n        if list2[j][i]!=0:\n            list2[j][i] = list2[j-1][i]+list2[j][i-1]\nanswer = (list2[R-1][C-1])%MOD\n#for i in range(len(list1)):\n    #print(list1[i])\n#print()\n#for j in range(len(list2)):\n    #print(list2[j])\nprint(answer)\n", "# cook your dish here\nMOD = 20011\nimport copy\nR,C,D = map(int,input().split())\nlist1=[]\nfor i in range(R):\n    temp = list(map(int,input().split()))\n    list1.append(temp)\nfor j in range(C):\n    if list1[0][j] ==0 or j>D:\n        for i in range(j,C):\n            list1[0][i]=0\n        break\nfor i in range(R):\n    if list1[i][0] ==0 or i >D:\n        for j in range(i,R):\n            list1[j][0] =0\n        break\nlist2 = copy.deepcopy(list1)\nfor j in range(1,R):\n    for i in range(1,C):\n        if list2[j][i]!=0:\n            list2[j][i] = list2[j-1][i]+list2[j][i-1]\nanswer = (list2[R-1][C-1])%MOD\n#for i in range(len(list1)):\n    #print(list1[i],list2[i])\nprint(answer)\n", "# import all important libraries and inbuilt functions\n\nfrom fractions import Fraction\nimport numpy as np\nimport sys,bisect,copyreg,copy,statistics,os\nfrom math import *\nfrom collections import Counter,defaultdict,deque,OrderedDict   \nfrom itertools import combinations,permutations,accumulate,groupby \nfrom numpy.linalg import matrix_power as mp\nfrom bisect import bisect_left,bisect_right,bisect,insort,insort_left,insort_right\nfrom statistics import mode\nfrom functools import reduce,cmp_to_key \nfrom io import BytesIO, IOBase\nfrom scipy.spatial import ConvexHull\nfrom heapq import *\nfrom decimal import *\nfrom queue import Queue,PriorityQueue\nfrom re import sub,subn\n\n# end of library import\n\n# map system version faults\nif sys.version_info[0] < 3:\n    from builtins import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n# template of many functions used in competitive programming can add more later \n# based on need we will use this commonly.\n\n# bfs in a graph\ndef bfs(adj,v): # a schema of bfs\n    visited=[False]*(v+1);q=deque()\n    while q:pass\n\n# definition of vertex of a graph\ndef graph(vertex): return [[] for i in range(vertex+1)]\n\ndef powermodulo(x, y, p) : \n    res = 1;x = x % p        \n    if (x == 0) : return 0  \n    while (y > 0) : \n        if ((y & 1) == 1) :   res = (res * x) % p \n        y = y >> 1 \n        x = (x * x) % p           \n    return res\n\ndef lcm(a,b): return (a*b)//gcd(a,b)\n\n# most common list in a array of lists\ndef most_frequent(List):return Counter(List).most_common(1)[0][0]\n\n# element with highest frequency\ndef most_common(List):return(mode(List))\n\n#In number theory, the Chinese remainder theorem states that \n#if one knows the remainders of the Euclidean division of an integer n by \n#several integers, then one can determine uniquely the remainder of the \n#division of n by the product of these integers, under the condition \n#that the divisors are pairwise coprime.\ndef chinese_remainder(a, p):\n    prod = reduce(op.mul, p, 1);x = [prod // pi for pi in p]\n    return sum(a[i] * powermodulo(x[i], p[i] - 2, p[i]) * x[i] for i in range(len(a))) % prod\n\n# make a matrix\ndef createMatrix(rowCount, colCount, dataList):   \n    mat = []\n    for i in range (rowCount):\n        rowList = []\n        for j in range (colCount):\n            if dataList[j] not in mat:rowList.append(dataList[j])\n        mat.append(rowList) \n    return mat\n\n# input for a binary tree\ndef readTree(): \n    v=int(inp());adj=[set() for i in range(v+1)]\n    for i in range(v-1):u1,u2=In(); adj[u1].add(u2);adj[u2].add(u1)\n    return adj,v\n    \n# sieve of prime numbers    \ndef sieve():\n    li=[True]*1000001;li[0],li[1]=False,False;prime=[]\n    for i in range(2,len(li),1):\n        if li[i]==True:\n            for j in range(i*i,len(li),i):li[j]=False    \n    for i in range(1000001):\n        if li[i]==True:prime.append(i)\n    return prime\n\n#count setbits of a number.\ndef setBit(n):\n    count=0\n    while n!=0:n=n&(n-1);count+=1\n    return count\n\n# sum of digits of a number\ndef digitsSum(n):\n    if n == 0:return 0\n    r = 0\n    while n > 0:r += n % 10;n //= 10\n    return r\n\n# ncr efficiently\ndef ncr(n, r):\n    r = min(r, n - r);numer = reduce(op.mul, list(range(n, n - r, -1)), 1);denom = reduce(op.mul, list(range(1, r + 1)), 1)\n    return numer // denom  # or / in Python 2\n\n#factors of a number\ndef factors(n):return list(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\n\n#prime fators of a number\ndef prime_factors(n):\n    i = 2;factors = []\n    while i * i <= n:\n        if n % i:i += 1\n        else:n //= i;factors.append(i)\n    if n > 1:factors.append(n)\n    return len(set(factors))\n\ndef prefixSum(arr):\n    for i in range(1, len(arr)):arr[i] = arr[i] + arr[i-1]\n    return arr    \n\ndef binomial_coefficient(n, k):\n    if 0 <= k <= n:\n        ntok = 1;ktok = 1\n        for t in range(1, min(k, n - k) + 1):ntok *= n;ktok *= t;n -= 1\n        return ntok // ktok\n    else:return 0\n \ndef powerOfK(k, max):\n    if k == 1:return [1]\n    if k == -1:return [-1, 1] \n    result = [];n = 1\n    while n <= max:result.append(n);n *= k\n    return result\n\n# maximum subarray sum use kadane's algorithm\ndef kadane(a,size):\n    max_so_far = 0;max_ending_here = 0 \n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):max_so_far = max_ending_here \n        if max_ending_here < 0:max_ending_here = 0\n    return max_so_far                                    \n                  \ndef divisors(n):\n    result = []\n    for i in range(1,ceil(sqrt(n))+1):\n        if n%i == 0:\n            if n/i == i:result.append(i)\n            else:result.append(i);result.append(n/i)\n    return result\n\ndef sumtilln(n): return ((n*(n+1))//2)\n\ndef isPrime(n) : \n\tif (n <= 1) :return False\n\tif (n <= 3) :return True\n\tif (n % 2 == 0 or n % 3 == 0) :return False\n\tfor i in range(5,ceil(sqrt(n))+1,6):\n\t\tif (n % i == 0 or n % (i + 2) == 0) :return False\n\treturn True\n\ndef isPowerOf2(n):\n    while n % 2 == 0:n //= 2\n    return (True if n == 1 else False)\n\ndef power2(n):\n    k = 0\n    while n % 2 == 0:k += 1;n //= 2\n    return k\n\ndef sqsum(n):return ((n*(n+1))*(2*n+1)//6)\n    \ndef cusum(n):return ((sumn(n))**2)\n\ndef pa(a):\n    for i in range(len(a)):print(a[i], end = \" \")\n    print()\n\ndef pm(a,rown,coln):\n    for i in range(rown):\n        for j in range(coln):print(a[i][j],end = \" \")\n        print()\n\ndef pmasstring(a,rown,coln):\n    for i in range(rown):\n        for j in range(coln):print(a[i][j],end = \"\")\n        print()\n        \ndef isPerfectSquare(n):return pow(floor(sqrt(n)),2) == n\n\ndef nC2(n,m):return (((n*(n-1))//2) % m)\n\ndef modInverse(n,p):return powermodulo(n,p-2,p)\n\ndef ncrmodp(n, r, p):  \n\tnum = den = 1\n\tfor i in range(r):num = (num * (n - i)) % p ;den = (den * (i + 1)) % p \n\treturn (num * powermodulo(den,p - 2, p)) % p \n\ndef reverse(string):return \"\".join(reversed(string))        \n\ndef listtostr(s):return ' '.join([str(elem) for elem in s]) \n\ndef binarySearch(arr, l, r, x): \n\twhile l <= r: \n\t\tmid = l + (r - l) // 2; \n\t\tif arr[mid] == x:return mid \n\t\telif arr[mid] < x:l = mid + 1\n\t\telse:r = mid - 1\n\treturn -1\n\ndef isarrayodd(a):\n    r = True\n    for i in range(len(a)):\n        if a[i] % 2 == 0:\n            r = False\n            break\n    return r\n\ndef isPalindrome(s):return s == s[::-1] \n\ndef gt(x,h,c,t):return ((x*h+(x-1)*c)/(2*x-1))\n\ndef CountFrequency(my_list): \n    freq = {} \n    for item in my_list:freq[item] = (freq[item] + 1 if (item in freq) else 1)\n    return freq\n\ndef CountFrequencyasPair(my_list1,my_list2,freq): \n    for item in my_list1:freq[item][0] = (freq[item][0] + 1 if (item in freq) else 1)\n    for item in my_list2:freq[item][1] = (freq[item][1] + 1 if (item in freq) else 1)     \n    return freq \n \ndef binarySearchCount(arr, n, key):   \n    left = 0;right = n - 1;count = 0  \n    while (left <= right):  \n        mid = int((right + left) / 2) \n        if (arr[mid] <= key):count,left = mid + 1,mid + 1\n        else:right = mid - 1      \n    return count\n\ndef primes(n):\n  sieve,l = [True] * (n+1),[]\n  for p in range(2, n+1):\n    if (sieve[p]):\n      l.append(p)\n      for i in range(p, n+1, p):sieve[i] = False\n  return l\n\ndef Next_Greater_Element_for_all_in_array(arr): \n\ts,n,reta,retb = list(),len(arr),[],[];arr1 = [list([0,i]) for i in range(n)]\n\tfor i in range(n - 1, -1, -1): \n\t\twhile (len(s) > 0 and s[-1][0] <= arr[i]):s.pop() \n\t\tif (len(s) == 0):arr1[i][0] = -1\t\t\t\t\t\n\t\telse:arr1[i][0] = s[-1]\t \n\t\ts.append(list([arr[i],i]))\t\t\n\tfor i in range(n):reta.append(list([arr[i],i]));retb.append(arr1[i][0])\n\treturn reta,retb\n\ndef polygonArea(X,Y,n):   \n    area = 0.0;j = n - 1\n    for i in range(n):area += (X[j] + X[i]) * (Y[j] - Y[i]);j = i   \n    return abs(area / 2.0)\n\ndef merge(a, b):\n\tans = defaultdict(int)\n\tfor i in a:ans[i] += a[i]\n\tfor i in b:ans[i] += b[i]\n\treturn ans\n \n#defining a LRU Cache\n# where we can set values and get values based on our requirement\nclass LRUCache: \n\t# initialising capacity \n\tdef __init__(self, capacity: int): \n\t\tself.cache = OrderedDict() \n\t\tself.capacity = capacity \n\n\t# we return the value of the key \n\t# that is queried in O(1) and return -1 if we \n\t# don't find the key in out dict / cache. \n\t# And also move the key to the end \n\t# to show that it was recently used. \n\tdef get(self, key: int) -> int: \n\t\tif key not in self.cache:return -1\n\t\telse:self.cache.move_to_end(key);return self.cache[key] \n\n\t# first, we add / update the key by conventional methods. \n\t# And also move the key to the end to show that it was recently used. \n\t# But here we will also check whether the length of our \n\t# ordered dictionary has exceeded our capacity, \n\t# If so we remove the first key (least recently used) \n\tdef put(self, key: int, value: int) -> None: \n\t\tself.cache[key] = value;self.cache.move_to_end(key) \n\t\tif len(self.cache) > self.capacity:self.cache.popitem(last = False)\n\nclass segtree:\n    def __init__(self,n):\n        self.m = 1\n        while self.m < n:self.m *= 2\n        self.data = [0] * (2 * self.m)\n    def __setitem__(self,i,x):\n        x = +(x != 1);i += self.m;self.data[i] = x;i >>= 1\n        while i:self.data[i] = self.data[2 * i] + self.data[2 * i + 1];i >>= 1\n    def __call__(self,l,r):\n        l += self.m;r += self.m;s = 0\n        while l < r:\n            if l & 1:s += self.data[l];l += 1\n            if r & 1:r -= 1;s += self.data[r]\n            l >>= 1;r >>= 1\n        return s        \n\nclass FenwickTree:\n  def __init__(self, n):self.n = n;self.bit = [0]*(n+1)  \n  def update(self, x, d):\n    while x <= self.n:self.bit[x] += d;x += (x & (-x))  \n  def query(self, x):\n    res = 0\n    while x > 0:res += self.bit[x];x -= (x & (-x))\n    return res\n  def range_query(self, l, r):return self.query(r) - self.query(l-1)        \n# can add more template functions here\n    \n# end of template functions\n\n# To enable the file I/O i the below 2 lines are uncommented.\n# read from in.txt if uncommented\nif os.path.exists('in.txt'): sys.stdin=open('in.txt','r')\n# will print on Console if file I/O is not activated\n#if os.path.exists('out.txt'): sys.stdout=open('out.txt', 'w')\n\n# inputs template\n#for fast input we areusing sys.stdin\ndef inp(): return sys.stdin.readline().strip()\n\n#for fast output, always take string\ndef out(var): sys.stdout.write(str(var))  \n\n# cusom base input needed for the program\ndef I():return (inp())\ndef II():return (int(inp()))\ndef FI():return (float(inp()))\ndef SI():return (list(str(inp())))\ndef MI():return (map(int,inp().split()))\ndef LI():return (list(MI()))\ndef SLI():return (sorted(LI()))\ndef MF():return (map(float,inp().split()))\ndef LF():return (list(MF()))\ndef SLF():return (sorted(LF()))\n\n# end of inputs template\n\n# common modulo values used in competitive programming\nMOD = 998244353\nmod = 10**9+7\n\n# any particular user-defined functions for the code.\n# can be written here.  \n \n# end of any user-defined functions\n\n# main functions for execution of the program.\ndef __starting_point():  \n    # execute your program from here.\n    # start your main code from here\n        \n    # Write your code here\n    r,c,d = MI()\n    l = []\n    for _ in range(r):l.append(LI())\n    dp = [[[0,0] for _ in range(c)] for iiii in range(r)]                                  \n    dp[0][0] = [1,1]\n    for j in range(r):\n        for i in range(c):\n            if l[j][i] == 0:\n                continue\n            for z in range(i-1,max(-1,i-1-d),-1):\n                if l[j][z] == 0:break\n                dp[j][i][0] += dp[j][z][1]\n            for z in range(j-1,max(-1,j-1-d),-1):\n                if l[z][i] == 0:break\n                dp[j][i][1] += dp[z][i][0]\n    print(sum(dp[-1][-1])%20011)\n    # end of main code\n    # end of program\n\n# This program is written by :\n#   Shubham Gupta\n#   B.Tech (2019-2023)\n#   Computer Science and Engineering,\n#   Department of EECS\n#   Contact No:8431624358\n#   Indian Institute of Technology(IIT),Bhilai\n#   Sejbahar,\n#   Datrenga,\n#   Raipur,\n#   Chhattisgarh\n#   492015\n\n#   THANK YOU FOR \n#YOUR KIND PATIENCE FOR READING THE PROGRAM.    \n__starting_point()", "# cook your dish here\nR,C,d = map(int,input().split())\ntable = []\nfor i in range(R):\n    temp = list(map(int,input().split()))\n    table.append(temp)\nif R>=C:\n    temp1 =R\nelse:\n    temp1=C\nfor i in range(d+1,temp1):\n    try:\n        table[0][i]=0\n        table[i][0]=0\n    except:\n        try:\n            table[i][0]=0\n        except:\n            continue\nfor i in range(C):\n    if table[0][i] == 0:\n        for j in range(i,C):\n            table[0][j]=0\n        break\nfor i in range(R):\n    if table[i][0] == 0:\n        for j in range(i,R):\n            table[j][0] = 0\n        break\nanswer=table.copy()\n#print(answer)\nfor i in range(1,R):\n    for j in range(1,C):\n        if answer[i][j] !=0:\n            answer[i][j] = answer[i-1][j]+answer[i][j-1]\nprint(str(answer[R-1][C-1] % 20011))\n#for row in answer:\n    #print(row)", "class PathNode:\r\n\r\n    def __init__(self, row, col, st_x, st_y, p_count=0):\r\n        self.x = row\r\n        self.y = col\r\n        self.pathCount = p_count\r\n\r\n    def __str__(self):\r\n        return str(self.x) + \" | \" + str(self.y) + \" | \" + str(self.pathCount)\r\n\r\n\r\nclass GraphUtil:\r\n    def __init__(self, mat, R,C, d):\r\n        self.mat = mat\r\n        self.R = R\r\n        self.C = C\r\n        self.d = d\r\n        self.tab = {}\r\n\r\n    def isValidMove(self, r, c, blockVal):\r\n        return r < self.R and c < self.C and self.mat[r][c] != blockVal\r\n\r\n    def possbilePathUtil(self, r, c, blockVal, step,direction):\r\n\r\n        if(not self.isValidMove(r, c, 0)):\r\n            return 0\r\n            \r\n        if (r == self.R - 1 and c == self.C - 1):\r\n            return 1\r\n\r\n        if ((r,c,step,direction) in self.tab):\r\n            return self.tab[(r,c,step,direction)]\r\n\r\n        result = 0\r\n        \r\n        if direction == 1:\r\n            if step < self.d:\r\n                result = (result + self.possbilePathUtil(r, c + 1, blockVal, step + 1,1)) % 20011\r\n            result = (result +  self.possbilePathUtil(r+1, c, blockVal, 1,2)) % 20011\r\n        else:\r\n            if step < self.d:\r\n                result = (result + self.possbilePathUtil(r + 1, c, blockVal, step + 1, 2)) % 20011\r\n            result = (result + self.possbilePathUtil(r, c + 1, blockVal, 1,1)) % 20011\r\n        \r\n        self.tab[(r,c,step,direction)] = result\r\n        \r\n        return result\r\n\r\n    def possbilePath(self):\r\n        if (not self.mat or len(self.mat) < 1):\r\n            return 0\r\n\r\n        return self.possbilePathUtil(0, 0, 0,0,2)\r\n\r\n\r\nnumbers = [int(n) for n in input().split()]\r\n\r\nmat = [[int(n) for n in input().split()] for r in range(0, numbers[0])]\r\n\r\nresult = GraphUtil(mat, numbers[0], numbers[1], numbers[2])\r\n\r\nprint(result.possbilePath())\r\n# print(result.count)", "class PathNode:\r\n\r\n    def __init__(self, row, col, st_x, st_y, p_count=0):\r\n        self.x = row\r\n        self.y = col\r\n        self.pathCount = p_count\r\n\r\n    def __str__(self):\r\n        return str(self.x) + \" | \" + str(self.y) + \" | \" + str(self.pathCount)\r\n\r\n\r\nclass GraphUtil:\r\n    def __init__(self, mat, R,C, d):\r\n        self.mat = mat\r\n        self.R = R\r\n        self.C = C\r\n        self.d = d\r\n        self.tab = {}\r\n\r\n    def isValidMove(self, r, c, blockVal):\r\n        return r < self.R and c < self.C and self.mat[r][c] != blockVal\r\n\r\n    def possbilePathUtil(self, r, c, blockVal, step,direction):\r\n\r\n        if(not self.isValidMove(r, c, 0)):\r\n            return 0\r\n            \r\n        if (r == self.R - 1 and c == self.C - 1):\r\n            return 1\r\n\r\n        if ((r,c,step,direction) in self.tab):\r\n            return self.tab[(r,c,step,direction)]\r\n\r\n        result = 0\r\n        \r\n        if direction == 1:\r\n            if step < self.d:\r\n                result = (result + self.possbilePathUtil(r, c + 1, blockVal, step + 1,1)) % 20011\r\n            result = (result +  self.possbilePathUtil(r+1, c, blockVal, 1,2)) % 20011\r\n        else:\r\n            if step < self.d:\r\n                result = (result + self.possbilePathUtil(r + 1, c, blockVal, step + 1, 2)) % 20011\r\n            result = (result + self.possbilePathUtil(r, c + 1, blockVal, 1,1)) % 20011\r\n        \r\n        self.tab[(r,c,step,direction)] = result\r\n        \r\n        return result\r\n\r\n    def possbilePath(self):\r\n        if (not self.mat or len(self.mat) < 1):\r\n            return 0\r\n\r\n        return self.possbilePathUtil(0, 0, 0,0,2)\r\n\r\n\r\nnumbers = [int(n) for n in input().split()]\r\n\r\nmat = [[int(n) for n in input().split()] for r in range(0, numbers[0])]\r\n\r\nresult = GraphUtil(mat, numbers[0], numbers[1], numbers[2])\r\n\r\nprint(result.possbilePath())\r\n# print(result.count)", "#for _ in range(int(input())):\n#dt = {} for i in x: dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\nipnl = lambda n: [int(input()) for _ in range(n)]\ninp = lambda :int(input())\nip = lambda :[int(w) for w in input().split()]\nmp = lambda :map(int,input().split())\n\nr,c,d = mp()\nx = [[{'D':0,'R':0,'f':1} for i in range(c)] for j in range(r)]\nfor i in range(r):\n    t = ip()\n    for j in range(c):\n        if t[j] == 0:\n            x[i][j] = {'D':0,'R':0,'f':0}\nx[0][0] = {'D':1,'R':1,'f':1}\nfor i in range(r):\n    for j in range(c):\n        if x[i][j]['f']:\n            ind = i-1\n            ctr = 0\n            while ind>=0 and ctr < d and x[ind][j]['f']:\n                x[i][j]['D'] += x[ind][j]['R']\n                ind -= 1\n                ctr += 1\n            ind = j-1\n            ctr = 0\n            while ind>=0 and ctr < d and x[i][ind]['f']:\n                x[i][j]['R'] += x[i][ind]['D']\n                ind -= 1\n                ctr += 1\nans = x[-1][-1]['R'] + x[-1][-1]['D']\nprint(ans%20011)", "#for _ in range(int(input())):\n#dt = {} for i in x: dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\nipnl = lambda n: [int(input()) for _ in range(n)]\ninp = lambda :int(input())\nip = lambda :[int(w) for w in input().split()]\nmp = lambda :map(int,input().split())\n\nr,c,d = mp()\nx = [[{'D':0,'R':0,'CT':0,'f':1} for i in range(c+1)] for j in range(r+1)]\nfor i in range(1,r+1):\n    t = ip()\n    for j in range(c):\n        if t[j] == 0:\n           x[i][j+1]['f'] = 2\nfor i in range(1,r+1):\n    for j in range(1,c+1):\n        flag = 0\n        if i==1 and j==1:\n            x[i][j] = {'D':0,'R':0,'CT':1,'f':0}\n        elif x[i][j]['f'] != 2:\n            x[i][j] = {'D':0,'R':0,'CT':0,'f':0}\n            #from up\n            if x[i-1][j]['f'] == 0 and x[i-1][j]['D'] < d:\n                flag += 1\n                x[i][j]['D'] = x[i-1][j]['D'] + 1\n                x[i][j]['CT'] += x[i-1][j]['CT']\n            #from left\n            if x[i][j-1]['f'] == 0 and x[i][j-1]['R'] < d:\n                flag += 1\n                x[i][j]['R'] = x[i][j-1]['R'] + 1\n                x[i][j]['CT'] += x[i][j-1]['CT']\n            if flag == 0:\n                x[i][j] = {'D':0,'R':0,'CT':0,'f':2}\nprint(x[r][c]['CT']%20011)\n\"\"\"\nfor i in range(r+1):\n    print(*x[i])\n\"\"\"", "# cook your dish here\nr, c, d = map(int, input().split())\nl = []\nfor _ in range(r):\n    l.append(list(map(int, input().split())))\n    \n#hori, verti\ndp = [[[0,0] for _ in range(c)] for _ in range(r)]\n\ndp[0][0] = [1, 1]\nfor j in range(r):\n    for i in range(c):\n        if l[j][i] == 0:\n            continue\n        for ii in range(i-1, max(-1, i-1-d), -1):\n            if l[j][ii] == 0:\n                break\n            dp[j][i][0] += dp[j][ii][1]\n            \n        for jj in range(j-1, max(-1, j-1-d), -1):\n            if l[jj][i] == 0:\n                break\n            dp[j][i][1] += dp[jj][i][0]\n# print('\\n'.join(str(v) for v in dp))\n# if r == 1 and c == 1:\n#     print(1)\n# else:\nprint(sum(dp[-1][-1])%20011)", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * m for _ in range(n)]\r\n\r\nfor i in range(min(n, d+1)):\r\n    if gr[i][0] == 0:\r\n        break\r\n\r\n    dp[i][0] = 1\r\n\r\nfor i in range(min(m, d+1)):\r\n    if gr[0][i] == 0:\r\n        break\r\n\r\n    dp[0][i] = 1\r\n\r\nfor i in range(1, n):\r\n    for j in range(1, m):\r\n        if gr[i][j] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 >= 0:\r\n            for r in range(i-d, i):\r\n                if not gr[r][j]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n                if i - d - 2 >= 0:\r\n                    dp[i][j] += dp[i - d - 2][j]\r\n\r\n        if j - d - 1 >= 0:\r\n            for r in range(j-d, j):\r\n                if not gr[i][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n                if j - d - 2 >= 0:\r\n                    dp[i][j] += dp[i][j - d - 2]\r\n\r\n        dp[i][j] = max(dp[i][j], 0) % MOD\r\n\r\nprint(dp[n-1][m-1])\r\n", "MOD = 20011\r\n\r\ndef lego(x , y , consec , prev):\r\n\r\n\t#X --> 0\r\n\t#Y -- > 1\r\n\r\n\tif x >= r or y >= c:\r\n\t\treturn 0\r\n\r\n\tif grid[x][y] == 0:\r\n\t\treturn 0\r\n\r\n\tif x == r-1 and y == c-1:\r\n\t\treturn 1\r\n\r\n\r\n\tif dp[x][y][consec][prev] != -1:\r\n\t\treturn dp[x][y][consec][prev]\r\n\r\n\tif consec == 0:\r\n\t\tif prev == 0:\r\n\t\t\tdp[x][y][consec][prev] = lego(x , y +1 , d-1 , 1)%MOD\r\n\t\telse:\r\n\t\t\tdp[x][y][consec][prev] = lego(x + 1 , y , d-1 , 0)%MOD\r\n\r\n\telse:\r\n\r\n\t\tif prev == 0:\r\n\t\t\tdp[x][y][consec][prev] = (lego(x+1 , y , consec - 1 , 0) + lego(x , y+1, d-1 , 1))%MOD\r\n\r\n\t\telse:\r\n\r\n\t\t\tdp[x][y][consec][prev] = (lego(x , y+1 , consec - 1 , 1) + lego(x+1 , y, d-1 , 0))%MOD\r\n\r\n\r\n\r\n\treturn dp[x][y][consec][prev] \r\n\r\n\r\n\r\n\r\n\r\n\r\nr,c,d = map(int , input().split())\r\n\r\ngrid = []\r\nfor  i in range(r):\r\n\talpha = list(map(int , input().split()))\r\n\tgrid.append(alpha)\r\n\t\r\n\r\n\r\ndp = [[[[-1 , -1] for z in range(d)] for j in range(c)] for i in range(r)]\r\n\r\nprint((lego(1 , 0 , d-1 , 0) + lego(0,1,d-1 , 1))%MOD)\r\n\r\n\r\n\r\n\r\n", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 12:31\r\n\r\n\"\"\"\r\n\r\nR, C, D = map(int, input().split())\r\nA = []\r\nfor r in range(R):\r\n    A.append([int(x) for x in input().split()])\r\n\r\nif A[0][0] == 0:\r\n    print(0)\r\n    exit(0)\r\n\r\ndp = [[[[0 for _ in range(D+1)] for _ in range(2)] for _ in range(C)] for _ in range(R)]\r\nfor c in range(1, min(C, D+1)):\r\n    if A[0][c] == 0:\r\n        break\r\n    dp[0][c][0][c] = 1\r\nfor r in range(1, min(R, D+1)):\r\n    if A[r][0] == 0:\r\n        break\r\n    dp[r][0][1][r] = 1\r\n\r\nMOD = 20011\r\nfor r in range(1, R):\r\n    for c in range(1, C):\r\n        if A[r][c] == 0:\r\n            continue\r\n        for d in range(2, D+1):\r\n            dp[r][c][0][d] = dp[r][c-1][0][d-1]\r\n            dp[r][c][1][d] = dp[r-1][c][1][d-1]\r\n            dp[r][c][0][d] %= MOD\r\n            dp[r][c][1][d] %= MOD\r\n        dp[r][c][0][1] = sum(dp[r][c-1][1][1:]) % MOD\r\n        dp[r][c][1][1] = sum(dp[r-1][c][0][1:]) % MOD\r\n\r\nprint(sum(dp[R-1][C-1][0]) + sum(dp[R-1][C-1][1]) % MOD)", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 12:31\r\n\r\n\"\"\"\r\n\r\nR, C, D = map(int, input().split())\r\nA = []\r\nfor r in range(R):\r\n    A.append([int(x) for x in input().split()])\r\n\r\nif A[0][0] == 0:\r\n    print(0)\r\n    exit(0)\r\n\r\ndp = [[[[0 for _ in range(D+1)] for _ in range(2)] for _ in range(C)] for _ in range(R)]\r\nfor c in range(1, min(C, D+1)):\r\n    if A[0][c] == 0:\r\n        break\r\n    dp[0][c][0][c] = 1\r\nfor r in range(1, min(R, D+1)):\r\n    if A[r][0] == 0:\r\n        break\r\n    dp[r][0][1][r] = 1\r\n\r\nMOD = 20011\r\nfor r in range(1, R):\r\n    for c in range(1, C):\r\n        if A[r][c] == 0:\r\n            continue\r\n        for d in range(2, D+1):\r\n            dp[r][c][0][d] = dp[r][c-1][0][d-1]\r\n            dp[r][c][1][d] = dp[r-1][c][1][d-1]\r\n            dp[r][c][0][d] %= MOD\r\n            dp[r][c][1][d] %= MOD\r\n        dp[r][c][0][1] = sum(dp[r][c-1][1][1:]) % MOD\r\n        dp[r][c][1][1] = sum(dp[r-1][c][0][1:]) % MOD\r\n\r\nprint(sum(dp[R-1][C-1][0]) + sum(dp[R-1][C-1][1]) % MOD)", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 12:31\r\n\r\n\"\"\"\r\n# import random\r\n\r\nR, C, D = map(int, input().split())\r\n\r\n# R, C, D = 5, 5, 15\r\n\r\nA = []\r\nfor r in range(R):\r\n    A.append([int(x) for x in input().split()])\r\n\r\n\r\ndef solve1():\r\n    if A[0][0] == 0:\r\n        return 0\r\n    MOD = 20011\r\n    dp = [[0 for _ in range(C)] for _ in range(R)]\r\n    dp[0][0] = 1\r\n    for r in range(R):\r\n        for c in range(C):\r\n            if A[r][c] != 0:\r\n                dp[r][c] += dp[r-1][c] if r > 0 else 0\r\n                dp[r][c] += dp[r][c-1] if c > 0 else 0\r\n                # dp[r][c] %= MOD\r\n\r\n    # for row in dp:\r\n    #     print(row)\r\n\r\n    return dp[R-1][C-1]\r\n\r\ndef solve2():\r\n    if A[0][0] == 0:\r\n        return 0\r\n\r\n    dp = [[[[0 for _ in range(D+1)] for _ in range(2)] for _ in range(C)] for _ in range(R)]\r\n    for c in range(1, min(C, D+1)):\r\n        if A[0][c] == 0:\r\n            break\r\n        dp[0][c][0][c] = 1\r\n    for r in range(1, min(R, D+1)):\r\n        if A[r][0] == 0:\r\n            break\r\n        dp[r][0][1][r] = 1\r\n\r\n    MOD = 20011\r\n    for r in range(1, R):\r\n        for c in range(1, C):\r\n            if A[r][c] == 0:\r\n                continue\r\n            for d in range(2, D+1):\r\n                dp[r][c][0][d] = dp[r][c-1][0][d-1]\r\n                dp[r][c][1][d] = dp[r-1][c][1][d-1]\r\n                dp[r][c][0][d] %= MOD\r\n                dp[r][c][1][d] %= MOD\r\n            dp[r][c][0][1] = sum(dp[r][c-1][1][1:]) % MOD\r\n            dp[r][c][1][1] = sum(dp[r-1][c][0][1:]) % MOD\r\n\r\n\r\n    # for r in range(R):\r\n    #     for c in range(C):\r\n    #         print('='*10 + '{}-{}'.format(r, c)+'='*10)\r\n    #         for row in dp[r][c]:\r\n    #             print(row)\r\n    # print(dp[R-1][C-1][0])\r\n    # print(dp[R - 1][C - 1][1])\r\n    return (sum(dp[R-1][C-1][0]) + sum(dp[R-1][C-1][1])) % MOD\r\n\r\n# while True:\r\n#     R, C = random.randint(2, 22), random.randint(2, 22)\r\n#     # A = []\r\n#     # for i in range(R):\r\n#     #     # A.append([int(x) for x in input().split()])\r\n#     #     A.append([1 if random.randint(1, 10) > 2 else 0 for _ in range(C)])\r\n#\r\n#     A = [\r\n#         [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],\r\n#         [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n#         [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n#         [1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1],\r\n#         [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],\r\n#         [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1],\r\n#         [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1],\r\n#         [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1],\r\n#         [1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1],\r\n#         [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1],\r\n#         [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1],\r\n#         [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0],\r\n#         [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1],\r\n#         [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],\r\n#         [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\r\n#         [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1],\r\n#         [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n#         [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],\r\n#         [0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1],\r\n#         [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],\r\n#         [1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],\r\n#         [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n#     ]\r\n#\r\n#\r\n#     R, C = len(A), len(A[0])\r\n#     D = max(R, C) + 1\r\n#     print(solve2())\r\n#\r\n#     a, b = solve1(), solve2()\r\n#     print(a, b)\r\n#     if a != b:\r\n#         # print(R, C)\r\n#         # for row in A:\r\n#         #     print(row)\r\n#         # print('=' * 40)\r\n#         # print(a, b)\r\n#         exit(0)\r\n#     exit(0)\r\n\r\nprint(solve2())", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 12:31\r\n\r\n\"\"\"\r\n# import random\r\n\r\nR, C, D = map(int, input().split())\r\n#\r\n# R, C, D = 5, 5, 15\r\n\r\nA = []\r\nfor r in range(R):\r\n    A.append([int(x) for x in input().split()])\r\n\r\n\r\ndef solve1():\r\n    if A[0][0] == 0:\r\n        return 0\r\n    MOD = 20011\r\n    dp = [[0 for _ in range(C)] for _ in range(R)]\r\n    dp[0][0] = 1\r\n    for r in range(R):\r\n        for c in range(C):\r\n            if A[r][c] != 0:\r\n                dp[r][c] += dp[r-1][c] if r > 0 else 0\r\n                dp[r][c] += dp[r][c-1] if c > 0 else 0\r\n                dp[r][c] %= MOD\r\n\r\n    # for row in dp:\r\n    #     print(row)\r\n\r\n    return dp[R-1][C-1]\r\n\r\ndef solve2():\r\n    if A[0][0] == 0:\r\n        return 0\r\n\r\n    dp = [[[[0 for _ in range(D+1)] for _ in range(2)] for _ in range(C)] for _ in range(R)]\r\n\r\n    if A[0][1] != 0:\r\n        dp[0][1][0][1] = 1\r\n    if A[1][0] != 0:\r\n        dp[1][0][1][1] = 1\r\n\r\n    A[0][1] = 0\r\n    A[1][0] = 0\r\n\r\n    MOD = 20011\r\n    for r in range(R):\r\n        for c in range(C):\r\n            if A[r][c] == 0:\r\n                continue\r\n            for d in range(2, D+1):\r\n                dp[r][c][0][d] += dp[r][c-1][0][d-1] if c > 0 else 0\r\n                dp[r][c][1][d] += dp[r-1][c][1][d-1] if r > 0 else 0\r\n                dp[r][c][0][d] %= MOD\r\n                dp[r][c][1][d] %= MOD\r\n            dp[r][c][0][1] = (sum(dp[r][c-1][1][1:]) if c > 0 else 0) % MOD\r\n            dp[r][c][1][1] = (sum(dp[r-1][c][0][1:]) if r > 0 else 0) % MOD\r\n\r\n\r\n    # for r in range(R):\r\n    #     for c in range(C):\r\n    #         print('='*10 + '{}-{}'.format(r, c)+'='*10)\r\n    #         for row in dp[r][c]:\r\n    #             print(row)\r\n\r\n    return sum(dp[R-1][C-1][0]) + sum(dp[R-1][C-1][1]) % MOD\r\n\r\n# while True:\r\n#     R, C = random.randint(2, 10), random.randint(2, 10)\r\n#     A = []\r\n#     for i in range(R):\r\n#         # A.append([int(x) for x in input().split()])\r\n#         A.append([1 if random.randint(1, 10) > 2 else 0 for _ in range(C)])\r\n#\r\n#     R, C = len(A), len(A[0])\r\n#     a, b = solve1(), solve2()\r\n#     print(a, b)\r\n#     if a != b:\r\n#         for row in A:\r\n#             print(row)\r\n#         print('=' * 40)\r\n#         print(a, b)\r\n#         exit(0)\r\n\r\nprint(solve1())", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * m for _ in range(n)]\r\n\r\nfor i in range(min(n, d+1)):\r\n    if gr[i][0] == 0:\r\n        break\r\n\r\n    dp[i][0] = 1\r\n\r\nfor i in range(min(m, d+1)):\r\n    if gr[0][i] == 0:\r\n        break\r\n\r\n    dp[0][i] = 1\r\n\r\nfor i in range(1, n):\r\n    for j in range(1, m):\r\n        if gr[i][j] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 >= 0:\r\n            for r in range(i-d, i):\r\n                if not gr[r][j]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n        if j - d - 1 >= 0:\r\n            for r in range(j-d, j):\r\n                if not gr[i][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n        dp[i][j] = max(dp[i][j], 0) % MOD\r\n\r\nprint(dp[n-1][m-1])\r\n\r\n\"\"\"\r\n\r\n3 4 2\r\n1 1 1 1\r\n1 1 1 1\r\n1 1 0 1\r\n\r\n\r\n\"\"\"", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * m for _ in range(n)]\r\n\r\nfor i in range(min(n, d+1)):\r\n    if gr[i][0] == 0:\r\n        break\r\n\r\n    dp[i][0] = 1\r\n\r\nfor i in range(min(m, d+1)):\r\n    if gr[0][i] == 0:\r\n        break\r\n\r\n    dp[0][i] = 1\r\n\r\nfor i in range(1, n):\r\n    for j in range(1, m):\r\n        if gr[i][j] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 >= 0:\r\n            for r in range(i-d, i):\r\n                if not gr[r][j]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n        if j - d - 1 >= 0:\r\n            for r in range(j-d, j):\r\n                if not gr[i][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n        dp[i][j] = max(dp[i][j] % MOD, 0)\r\n\r\nprint(dp[n-1][m-1])\r\n\r\n\"\"\"\r\n\r\n3 4 2\r\n1 1 1 1\r\n1 1 1 1\r\n1 1 0 1\r\n\r\n\r\n\"\"\"", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * m for _ in range(n)]\r\n\r\nfor i in range(min(n, d+1)):\r\n    if gr[i][0] == 0:\r\n        break\r\n\r\n    dp[i][0] = 1\r\n\r\nfor i in range(min(m, d+1)):\r\n    if gr[0][i] == 0:\r\n        break\r\n\r\n    dp[0][i] = 1\r\n\r\nfor i in range(1, n):\r\n    for j in range(1, m):\r\n        if gr[i][j] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 >= 0:\r\n            for r in range(i-d-1, i):\r\n                if not gr[r][j]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n        if j - d - 1 >= 0:\r\n            for r in range(j-d-1, j):\r\n                if not gr[i][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n        dp[i][j] = max(dp[i][j] % MOD, 0)\r\n\r\nprint(dp[n-1][m-1])\r\n", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * m for _ in range(n)]\r\n\r\nfor i in range(min(n, d+1)):\r\n    if gr[i][0] == 0:\r\n        break\r\n\r\n    dp[i][0] = 1\r\n\r\nfor i in range(min(m, d+1)):\r\n    if gr[0][i] == 0:\r\n        break\r\n\r\n    dp[0][i] = 1\r\n\r\nfor i in range(1, n):\r\n    for j in range(1, m):\r\n        if gr[i][j] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 >= 0:\r\n            for r in range(i-d, i):\r\n                if not gr[r][j]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n        if j - d - 1 >= 0:\r\n            for r in range(j-d, j):\r\n                if not gr[i][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n        dp[i][j] = max(dp[i][j], 0) % MOD\r\n\r\nprint(dp[n-1][m-1])\r\n", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * m for _ in range(n)]\r\n\r\nfor i in range(min(n, d+1)):\r\n    if gr[i][0] == 0:\r\n        break\r\n\r\n    dp[i][0] = 1\r\n\r\nfor i in range(min(m, d+1)):\r\n    if gr[0][i] == 0:\r\n        break\r\n\r\n    dp[0][i] = 1\r\n\r\nfor i in range(1, n):\r\n    for j in range(1, m):\r\n        if gr[i][j] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 > 0:\r\n            for r in range(i-d, i):\r\n                if not gr[r][j]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n        if j - d - 1 > 0:\r\n            for r in range(j-d, j):\r\n                if not gr[i][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n        dp[i][j] = max(dp[i][j], 0) % MOD\r\n\r\nprint(dp[n-1][m-1])\r\n", "MOD = 20011\r\n\r\nn, m, d = map(int, input().split())\r\ngr = [list(map(int, input().split())) for _ in range(n)]\r\n\r\ndp = [[0] * (m + 1) for _ in range(n + 1)]\r\ndp[1][1] = 1\r\n\r\nfor i in range(1, n+1):\r\n    for j in range(1, m+1):\r\n        if gr[i-1][j-1] == 0:\r\n            dp[i][j] = 0\r\n            continue\r\n\r\n        if i == j == 1:\r\n            continue\r\n\r\n\r\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n        if i - d - 1 > 0:\r\n            for r in range(i-d-1, i):\r\n                if not gr[r][j-1]:\r\n                    break\r\n            else:\r\n\r\n                dp[i][j] -= dp[i - d - 1][j]\r\n\r\n        if j - d - 1 > 0:\r\n            for r in range(j-d-1, j):\r\n                if not gr[i-1][r]:\r\n                    break\r\n            else:\r\n                dp[i][j] -= dp[i][j - d - 1]\r\n\r\n        dp[i][j] = max(dp[i][j], 0) % MOD\r\n\r\nprint(dp[n][m])\r\n"]
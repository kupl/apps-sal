["import os,sys\nfrom io import BytesIO, IOBase\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return list(map(int,input().split()))\ndef li(): return list(mi())\nimport math \n\nimport collections \n\ndef CountFrequency(arr): \n return collections.Counter(arr) \n\nfor i in range(1):\n n,q=mi()\n p=pow(2,n+1)-2 \n t=1 \n b=pow(2,n)\n s=n+1\n for i in range(q):\n  a=li()\n  if len(a)==2:\n   if a[1]==1 or a[1]==2:\n    p*=2 \n    p+=s\n    t*=2 \n    b*=2\n   else:\n    p*=2 \n    if a[1]==3:\n     p+=t\n     t=b \n     s*=2\n    else:\n     p+=b\n     b=t\n     s*=2\n  else:\n   print(p%1000000007)\n", "# cook your dish here\nn,q=map(int,input().split())\nedges=2*(2**n-1)\nside_nodes=n+1\ntop_nodes=1\nbottom_nodes=2**n\nfor i in range(q):\n query=list(map(int,input().split()))\n if query[0]==1:\n  if query[1]==1 or query[1]==2:\n   edges=edges*2+side_nodes\n   top_nodes*=2\n   bottom_nodes*=2\n  elif query[1]==3:\n   edges=edges*2+top_nodes\n   top_nodes=bottom_nodes\n   side_nodes*=2\n  else:\n   edges=edges*2+bottom_nodes\n   bottom_nodes=top_nodes\n   side_nodes*=2\n else:\n  print(edges%1000000007)", "# cook your dish here\nMOD=1000000007\nlevels,q=input().split()\nlevels=int(levels)\nq=int(q)\nleft=levels+1\nright=levels+1\ntop=1\nbottom=pow(2,levels)\nedges=0\nf=1\nfor i in range(1,levels+1):\n f=((2%MOD)*(f%MOD))%MOD\n edges+=f\n\nlevels+=1\n\nfor i in range(1,q+1):\n l1=list(map(int,input().split()))\n if(l1[0]==1):\n  y=l1[1]\n  if(y==1):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(levels%MOD))%MOD\n   top=((top%MOD)*(2%MOD))%MOD\n   bottom=((bottom%MOD)*(2%MOD))%MOD\n  elif(y==2):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(levels%MOD))%MOD\n   top=((top%MOD)*(2%MOD))%MOD\n   bottom=((bottom%MOD)*(2%MOD))%MOD\n  elif(y==3):\n    edges=((edges%MOD)*(2%MOD))%MOD\n    edges=((edges%MOD)+(top%MOD))%MOD\n    top=bottom;\n    levels=((levels%MOD)*(2%MOD))\n  elif(y==4):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(bottom%MOD))%MOD\n   bottom=top\n   levels=((levels%MOD)*(2%MOD))\n elif(l1[0]==2):\n  print(edges%MOD)\n", "MOD=1000000007\nlevels,q=input().split()\nlevels=int(levels)\nq=int(q)\nleft=levels+1\nright=levels+1\ntop=1\nbottom=pow(2,levels)\nedges=0\nf=1\nfor i in range(1,levels+1):\n f=((2%MOD)*(f%MOD))%MOD\n edges+=f\n\nlevels+=1\n\nfor i in range(1,q+1):\n l1=list(map(int,input().split()))\n if(l1[0]==1):\n  y=l1[1]\n  if(y==1):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(levels%MOD))%MOD\n   top=((top%MOD)*(2%MOD))%MOD\n   bottom=((bottom%MOD)*(2%MOD))%MOD\n  elif(y==2):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(levels%MOD))%MOD\n   top=((top%MOD)*(2%MOD))%MOD\n   bottom=((bottom%MOD)*(2%MOD))%MOD\n  elif(y==3):\n    edges=((edges%MOD)*(2%MOD))%MOD\n    edges=((edges%MOD)+(top%MOD))%MOD\n    top=bottom;\n    levels=((levels%MOD)*(2%MOD))\n  elif(y==4):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(bottom%MOD))%MOD\n   bottom=top\n   levels=((levels%MOD)*(2%MOD))\n elif(l1[0]==2):\n  print(edges%MOD)\n", "n, q = list(map(int, input().split()))\n\ntop = 1\nbottom = 2 ** n\ndepth = n + 1\nedges = 2 ** (n + 1) - 2\n\nfor _ in range(q):\n x = list(map(int, input().split()))\n\n if x[0] == 2:\n  print(edges % (10 ** 9 + 7))\n else:\n  t = x[1]\n\n  edges *= 2\n\n  if t == 1 or t == 2:\n   top *= 2\n   bottom *= 2\n\n   edges += depth\n\n  if t == 3:\n   depth *= 2\n   edges += top\n   top = bottom\n\n  if t == 4:\n   depth *= 2\n   edges += bottom\n   bottom = top\n", "MOD=1000000007\nlevels,q=input().split()\nlevels=int(levels)\nq=int(q)\nleft=levels+1\nright=levels+1\ntop=1\nbottom=pow(2,levels)\nedges=0\nf=1\nfor i in range(1,levels+1):\n f=((2%MOD)*(f%MOD))%MOD\n edges+=f\n\nlevels+=1\n\nfor i in range(1,q+1):\n l1=list(map(int,input().split()))\n if(l1[0]==1):\n  y=l1[1]\n  if(y==1):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(levels%MOD))%MOD\n   top=((top%MOD)*(2%MOD))%MOD\n   bottom=((bottom%MOD)*(2%MOD))%MOD\n  elif(y==2):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(levels%MOD))%MOD\n   top=((top%MOD)*(2%MOD))%MOD\n   bottom=((bottom%MOD)*(2%MOD))%MOD\n  elif(y==3):\n    edges=((edges%MOD)*(2%MOD))%MOD\n    edges=((edges%MOD)+(top%MOD))%MOD\n    top=bottom;\n    levels=((levels%MOD)*(2%MOD))\n  elif(y==4):\n   edges=((edges%MOD)*(2%MOD))%MOD\n   edges=((edges%MOD)+(bottom%MOD))%MOD\n   bottom=top\n   levels=((levels%MOD)*(2%MOD))\n elif(l1[0]==2):\n  print(edges%MOD)\n", "def mirror_down(e,r,l,u,d):\n edge=(2*e)+d\n right=r*2\n left=l*2\n up=u\n down=u\n #print(edge,right,left,up,down)\n return [edge,right,left,up,down]\ndef mirror_up(e,r,l,u,d):\n edge=(2*e)+u\n right=r*2\n left=l*2\n up=d\n down=d\n #print(edge,right,left,up,down)\n return [edge,right,left,up,down]\ndef mirror_left(e,r,l,u,d):     \n edge=(2*e)+l\n right=r\n left=l\n up=u*2\n down=d*2\n #print(edge,right,left,up,down)\n return [edge,right,left,up,down]\ndef mirror_right(e,r,l,u,d):\n edge=(2*e)+r\n right=r\n left=l\n up=u*2\n down=d*2\n #print(edge,right,left,up,down)\n return [edge,right,left,up,down]\ns=input('').split(' ')\nn,q=(int(s[0]),int(s[1]))\ne=(2**(n+1))-2\nl=n+1\nr=n+1\nu=1\nd=2**n\nwhile(q!=0):\n s=input('').split(' ')\n if(len(s)==2):\n  c=int(s[1])\n  if(c==1):\n   a=mirror_right(e,r,l,u,d)\n   e=a[0]\n   r=a[1]\n   l=a[2]\n   u=a[3]\n   d=a[4]\n  if(c==2):\n   a=mirror_left(e,r,l,u,d)\n   e=a[0]\n   r=a[1]\n   l=a[2]\n   u=a[3]\n   d=a[4]\n  if(c==3):\n   a=mirror_up(e,r,l,u,d)\n   e=a[0]\n   r=a[1]\n   l=a[2]\n   u=a[3]\n   d=a[4]\n  if(c==4):\n   a=mirror_down(e,r,l,u,d)\n   e=a[0]\n   r=a[1]\n   l=a[2]\n   u=a[3]\n   d=a[4]\n  \n else:\n  print(e%1000000007)\n q-=1\n", "mod=1000000007\nn,q=map(int,input().split())\npot=pow(2,n,mod) #2 to the power n and then mod mod\ne=((pot-1)*2)%mod\nright=n+1\nleft=n+1\ntop=1\nbottom=pot\nfor _ in range(q):\n l=input()\n add=0\n if l[0]=='1':\n  if l[2]=='1':\n   add=right\n   top*=2\n   bottom*=2\n  elif l[2]=='2':\n   add=left\n   top*=2\n   bottom*=2\n  elif l[2]=='3':\n   add=top\n   right*=2\n   left*=2\n   top=bottom\n  else:\n   add=bottom\n   left*=2\n   right*=2\n   bottom=top\n  e=(e*2+add)%mod\n else:\n  print(e)", "def main():\n n,q = list(map(int,input().split()))\n edges = ((pow(2,n,1000000007)-1)*2)%1000000007\n bottom = pow(2,n,1000000007)\n top = 1\n right = n+1\n left = n+1\n\n for i in range(q):\n  query = list(map(int,input().split()))\n  if len(query) == 1:\n   print(edges)\n  else:\n   op = query[1]\n   if op == 1:\n    edges *= 2\n    edges += right\n    edges = edges%1000000007\n    bottom *= 2\n    top *= 2\n   elif op == 2:\n    edges *= 2\n    edges += left\n    edges = edges%1000000007\n    bottom *= 2\n    top *= 2\n   elif op == 3:\n    edges *= 2\n    edges += top\n    edges = edges%1000000007\n    left *= 2\n    right *= 2\n    top = bottom\n   else:\n    edges *= 2\n    edges += bottom\n    edges = edges%1000000007\n    left *= 2\n    right *= 2\n    bottom = top\n\n   left = left%1000000007\n   right = right%1000000007\n   bottom = bottom%1000000007\n   top = top%1000000007\n\nmain()\n", "import sys\nmod=10**9+7\nn,q=list(map(int,input().split()))\nu,l,r,d=1,n+1,n+1,pow(2,n,mod)\ne=(2*(d-1))%mod\nfor a in sys.stdin:\n a=list(a.split())\n if a[0]==\"1\":\n  e=(e*2)%mod\n  if a[1]==\"1\":\n   e=(e+r)%mod\n   r=l\n   u=(u*2)%mod\n   d=(d*2)%mod\n  elif a[1]==\"2\":\n   e=(e+l)%mod\n   l=r\n   u=(u*2)%mod\n   d=(d*2)%mod\n  elif a[1]==\"3\": \n   e=(e+u)%mod\n   u=d\n   l=(l*2)%mod\n   r=(r*2)%mod\n  else:\n   e=(e+d)%mod\n   d=u\n   l=(l*2)%mod\n   r=(r*2)%mod\n else:\n  print(e)\n  \n", "# cook your dish here\ndepth,q=list(map(int,input().split()))\nr=1000000007\nedges=0\ntop=1\nbottom=2**(depth)\nfor i in range(1,depth+1):\n edges=edges+(2**i)\nfor i1 in range(0,q):\n a=list(map(int,input().split()))\n if len(a)==1:\n  print(edges%r)\n else:\n  x=a[1]\n  if x==1:\n   top=2*top\n   bottom=2*bottom\n   edges=(2*edges)+depth+1\n   \n  elif x==2:\n   top=top*2\n   bottom=2*bottom\n   edges=(2*edges)+depth+1\n  elif x==3:\n   depth=(2*depth)+1\n   edges=(2*edges)+top\n   top=bottom\n  else:\n   depth=(2*depth)+1\n   edges=(2*edges)+bottom\n   bottom=top\n    \n   \n  \n", "n, q = list(map(int, input().split()))\nb, e = 2 ** n, 2 ** (n + 1) - 2\n\nc = 1\nn += 1\n\nfor _ in range(q):\n l = input().split()\n\n if l[0] == '1':\n  x = l[1]\n\n  if x == '1' or x == '2':\n   e = e * 2 + n\n   b *= 2\n   c *= 2\n\n  if x == '3':\n   e = e * 2 + c\n   c = b\n   n *= 2\n\n  if x == '4':\n   e = e * 2 + b\n   b = c\n   n *= 2\n\n else:\n  print(e % 1000000007)\n", "mod=1000000007\nn,q=map(int,input().split())\nl=n+1%mod\nr=n+1%mod\nt=1%mod\nb=pow(2,n)%mod\ne=(pow(2,n+1)-2)%mod\nfor _ in range(q):\n lst=list(map(int,input().split()))\n if (len(lst)!=1) :\n  if(lst[1]==1):\n   e=(2*e+l)%mod\n   l=l\n   r=r\n   t=(2*t)%mod\n   b=(2*b)%mod\n  if lst[1]==2:\n   e=(2*e+r)%mod\n   l=l\n   r=r\n   t=(2*t)%mod\n   b=(2*b)%mod\n  if lst[1]==3:\n   e=((2*e)+t)%mod\n   t=b%mod\n   l=2*l%mod\n   r=2*r%mod\n   b=b%mod\n  if lst[1]==4:\n   e=((2*e)+b)%mod\n   b=t%mod\n   l=2*l%mod\n   r=2*r%mod\n   b=b%mod\n else:\n  print(e)"]
["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if head==None:\n            return 0\n        temp=head\n        arr=[]\n        stack=[]\n        while temp:\n            arr.append(temp.val)\n            temp=temp.__next__\n        output=[0]*len(arr)\n        for i in range(len(arr)):\n            while stack and arr[stack[-1]]<arr[i]:\n                output[stack.pop()]=arr[i]\n            stack.append(i)\n        return output\n        \n       \n            \n                \n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        cur, nodes = head, []\n        while cur: \n            nodes += [cur.val] \n            cur = cur.next\n        \n        out = [0]*len(nodes)\n        stack= []\n        for i in range(len(out)):\n            \n            while len(stack) and nodes[stack[-1]] < nodes[i]: \n                out[stack.pop()] = nodes[i]\n            stack.append(i)\n        return out", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        count_list = 0\n        tmp = head\n        while tmp:\n            count_list += 1\n            tmp = tmp.next\n        result = [0] * count_list\n        stack = list()\n        position = 0\n        while head:\n            while len(stack) and stack[-1][0] < head.val:\n                result[stack[-1][1]] = head.val\n                stack.pop()\n            stack.append((head.val, position))\n            position += 1\n            head = head.next\n        \n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n        nums=[]\n        while head:\n            nums.append(head.val)\n            head=head.next\n        map={}\n        stack=[]\n        for i,x in enumerate(nums):\n            while stack and stack[-1][1]<x:\n                map[stack.pop()[0]]=x\n                \n            stack.append((i,x))\n        res=[]\n        for i,x in enumerate(nums):\n            res.append(map.setdefault(i,0))\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        # \u7528stack\u5b58\u4e00\u4e2a\u9012\u51cf\u5217\u8868\uff0c\u6bcf\u6b21\u9047\u5230\u5927\u7684\u6570\u5c31\u51fa\u6808\uff0c\u540c\u65f6\u66f4\u65b0stack\u4e2d\u5b58\u7684index\u5bf9\u5e94\u7684output\n        if head is None:\n          return []\n        if head.next is None:\n          return [0]\n\n        i = head\n        stack = []\n        out = []\n        count = 0\n        while i:\n          # print('node ', i.val)\n          if not stack:\n            stack.append([count, i.val])\n          elif i.val <= stack[-1][1]:\n            stack.append([count, i.val])\n          else:\n            while stack and i.val > stack[-1][1]:\n              tmp_count, tmp_val = stack.pop()\n              out.append([tmp_count, i.val])\n            stack.append([count, i.val])\n          # print(stack, out)\n          i = i.next\n          count += 1\n\n        output = [0] * count\n        for i, j in out:\n          output[i] = j\n        return output", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stk = []\n        ans = []\n        i = 0\n        while head:\n            ans.append(0)\n            stk.append((i,head.val))\n            # print(i, head.val, stk)\n            while head.next and stk and head.next.val>stk[-1][1]:\n                j,_=stk.pop()\n                ans[j]=head.next.val\n            head = head.next\n            i+=1\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        tail = head\n        res = [] \n        if not head:\n            return res\n        res = [None] * 10000\n        idx = 0\n        while tail:\n            while stack and tail.val > stack[-1][0]:\n                _, i = stack.pop()\n                res[i] = tail.val\n            if not stack or tail.val <= stack[-1][0]:\n                stack.append((tail.val, idx))\n            tail = tail.next\n            idx += 1\n        i = 0\n        while i < len(stack):\n            _, index = stack[i]\n            res[index] = 0\n            i+=1\n        return res[:idx]", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def nextLargerNodes(self, head):\n\n        stack = []\n        res = []\n        vals = []\n\n        ind = 0\n\n        while True:\n\n            res+=[0]\n\n            #print(stack, vals, ind, res, head.val)\n            \n            while len(stack)>0 and vals[stack[-1]]<head.val:\n                res[stack[-1]] = head.val\n                stack.pop()\n                \n\n\n            stack+=[ind]\n            vals+=[head.val]\n\n            ind+=1\n\n            \n            if head.__next__ is not None:\n                head = head.__next__\n            else:\n                break\n            \n        \n        return res\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    \n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if not head:\n            return []\n        orig_head = head\n        all_res = []\n        stack = []\n        i = 0\n        while head:\n            while stack:\n                v, j = stack[-1]\n                if head.val > v:\n                    all_res.append((head.val, j))\n                    stack.pop()\n                else:\n                    break\n            stack.append((head.val, i))\n            head = head.__next__\n            i += 1\n        while stack:\n            _, top = stack.pop()\n            all_res.append((0, top))\n        all_res = sorted(all_res, key=lambda x: x[1])\n        return [v for v, _ in all_res]\n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if head is None:\n            return []\n        stack=[];index=0;length=0;\n        ansarray=[0]*100001\n        while head:\n            while(len(stack) and head.val>stack[-1][0].val):\n                k=stack.pop()\n                ansarray[k[1]]=head.val\n            stack.append([head,index])\n            length+=1\n            index+=1;head=head.next\n        return ansarray[:length]", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        p=head\n        stack=[]\n        d=collections.defaultdict(deque)\n        res=[]\n        length=0\n        \n        while p:\n            while stack and stack[-1]<p.val:\n                val=stack.pop()\n                d[val].append(p.val)\n            stack.append(p.val)\n            p=p.__next__\n            length+=1\n        #print(d,[0]*length)   \n        while head:\n            #print(head.val)\n            if head.val in d:\n                if d[head.val]:\n                    res.append(d[head.val].popleft())\n                else:\n                    res.append(0)\n            else:\n                res.append(0)\n            head=head.__next__\n        return res\n            \n            \n        \n            \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        \n        n = len(nums)\n        idx = [n] * n\n        ans = [0] * n\n        for i in reversed(range(0, n - 1, 1)):\n            cur = i + 1\n            while cur < n:\n                if nums[cur] <= nums[i]:\n                    cur = idx[cur]\n                else:\n                    ans[i] = nums[cur]\n                    idx[i] = cur\n                    break\n\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n        st = []\n        ret = []\n        def get_nxt_grt(cur):\n            if not cur:\n                return\n            \n            get_nxt_grt(cur.__next__)\n            \n            while st and st[-1] <= cur.val:\n                st.pop()\n            \n            if not st:\n                ret.append(0)\n            else:\n                ret.append(st[-1])\n            st.append(cur.val)\n            \n        get_nxt_grt(head)\n        return ret[::-1]\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        result = []\n        if head == None:\n            return result\n        l = []\n        result.append(0)\n        l.append(head.val)\n        head = head.next\n        index = 0\n        while head != None:\n            index = len(l) - 1\n            while index >= 0:\n                if head.val > l[index]:\n                    for i in range(len(result) - 1, -1, -1):\n                        if result[i] == 0:\n                            result[i] = head.val\n                            break\n                    index -= 1\n                    l.pop()\n                else:\n                    break\n            result.append(0)\n            l.append(head.val)\n            head = head.next\n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        result = [0]\n        stack = list()\n        position = 0\n        while head:\n            while len(stack) and stack[-1][0] < head.val:\n                result[stack[-1][1]] = head.val\n                stack.pop()\n            if len(result) <= position:\n                result += [0] * (position - len(result) + 1)\n            stack.append((head.val, position))\n            position += 1\n            head = head.next\n        \n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        pos = -1\n        ans = []\n        stack = []\n        while head:\n            pos += 1\n            ans.append(0)\n            while stack and stack[-1][1] < head.val:\n                idx,_ = stack.pop()\n                ans[idx] = head.val\n            stack.append((pos,head.val))\n            head = head.next\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        p = head\n        stack = []\n        res = []\n        i = 0\n        \n        while p:\n            while stack and p.val > stack[-1][0].val:\n                res[stack[-1][1]] = p.val\n                stack.pop()\n                \n            stack.append((p,i))\n            \n            i += 1   \n            p = p.next\n            res.append(0)\n                \n        return res", "from collections import deque\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        res = []\n        while head != None:\n            res.append(head.val)\n            head = head.__next__\n        # monotonic decreasing stack\n        stack = deque()\n        for i in range(len(res)):\n            while stack:\n                if res[stack[-1]] < res[i]:\n                    pos = stack.pop()\n                    res[pos] = res[i]\n                else: \n                    break\n            stack.append(i)\n        # the positions left in stack cannot find larger elements, and assign 0\n        while stack:\n            pos = stack.pop()\n            res[pos] = 0\n        return res\n\n                    \n                    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if head is None:\n            return []\n        \n        n = 0\n        cur = head\n        while cur is not None:\n            cur = cur.next\n            n += 1\n        \n        cur = head\n        pos = 0\n        result = [0] * n\n        stack = []\n        \n        while cur is not None:\n            while stack and stack[-1][0] < cur.val:\n                result[stack[-1][1]] = cur.val\n                stack.pop()\n            stack.append([cur.val, pos])\n            \n            cur = cur.next\n            pos += 1\n        \n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        t = head\n        temp = []\n        while t:\n            temp.append(t.val)\n            t = t.next\n        stack, result = [0], []\n        for i in range(1, len(temp)):\n            if temp[i] > temp[stack[-1]]:\n                result.append(temp[i])\n                stack.pop()\n                while stack:\n                    if temp[i] > temp[stack[-1]]:\n                        result[stack[-1]] = temp[i]\n                        stack.pop()\n                    else:\n                        break\n                stack.append(i)\n            else:\n                stack.append(i)\n                result.append(0)\n        result.append(0)\n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        p=head\n        stack=[]\n        d=collections.defaultdict(deque)\n        res=[]\n        length=0\n        \n        while p:\n            while stack and stack[-1]<p.val:\n                val=stack.pop()\n                d[val].append(p.val)\n            stack.append(p.val)\n            p=p.__next__\n            length+=1\n        #print(d,[0]*length)   \n        while head:\n            print((head.val))\n            if head.val in d:\n                if d[head.val]:\n                    res.append(d[head.val].popleft())\n                else:\n                    res.append(0)\n            else:\n                res.append(0)\n            head=head.__next__\n        return res\n            \n            \n        \n            \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerVal(self, in_list):\n        length = len(in_list)\n        i = length - 1\n        \n        stack = []\n        answer = []\n        \n        while i >= 0:\n            if not stack:\n                answer.append(0)\n            elif stack and stack[-1] > in_list[i]:\n                answer.append(stack[-1])\n            elif stack and stack[-1] <= in_list[i]:\n                while stack and stack[-1] <= in_list[i]:\n                    stack.pop()\n                    \n                if stack:\n                    answer.append(stack[-1])\n                else:\n                    answer.append(0)\n                \n                \n            stack.append(in_list[i])\n            i -= 1\n              \n        print(('Result is: {}'.format(answer[::-1])))\n        return answer[::-1]\n        \n        \n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if head is None:\n            return\n        if head.__next__ is None:\n            return [0]\n        \n        temp = head\n        \n        input_list = []\n        \n        while temp:\n            input_list.append(temp.val)\n            temp = temp.__next__\n            \n        result = self.nextLargerVal(input_list)\n        \n        return result\n        \n        \n", "from typing import List, Iterable, Iterator\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    \\\"\\\"\\\"\n    Time: O(3n) => O(n)\n    Space: O(3n) => O(n)\n    \\\"\\\"\\\"\n\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        result, stack = [], []\n        while head:\n            while stack and stack[-1][1] < head.val:\n                result[stack.pop()[0]] = head.val\n            stack.append((len(result), head.val))\n            result.append(0)\n            head = head.next\n\n        return result\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n        def get_length(head):\n            count = 0 \n            while head:\n                count += 1 \n                head = head.__next__ \n            return count \n        \n        length = get_length(head)\n        if length == 0:\n            return []\n        if length == 1:\n            return [0]\n        \n        ans = [0] * length \n        heap = []\n        heapify(heap)\n        index = 0\n        while head:\n            node = head\n            head = head.__next__ \n            while heap and heap[0][0] < node.val:\n                out = heappop(heap)\n                ans[out[1]] = node.val\n            heappush(heap, (node.val, index))\n            index += 1\n        \n        return ans\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addToHashmap(self,hashmap, key, val):\n        if hashmap.get(key) is None:\n            hashmap[key] = [val]\n        else:\n            x = hashmap[key]\n            x.append(val)\n            hashmap[key] = x\n        \n        \n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        curr = head\n        new = []\n        i = 0\n        hashmap = {}\n        while curr is not None:\n            while i>0 and stack[i-1] < curr.val:\n                x = stack.pop()\n                self.addToHashmap(hashmap, x, curr.val)\n                i-=1\n            stack.append(curr.val)\n            i+=1\n            curr = curr.next\n        temp = head\n        while temp is not None:\n            if hashmap.get(temp.val) is not None:\n                x = hashmap.get(temp.val)\n                if len(x) > 0:\n                    new.append(x[0])\n                    x.remove(x[0])\n                else:\n                    new .append(0)\n            else:\n                new.append(0)\n            temp = temp.next \n        return new", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n\nclass Stack:\n    def __init__(self):\n        self.data = []\n    \n    def push(self,element):\n        self.data.append(element)\n    \n    def pop(self):\n        return self.data.pop()  \n    \n    def peek(self):\n        return self.data[-1]\n    \n    def is_empty(self):\n        return len(self.data) == 0\n    \n\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        aux = Stack()\n        result = []\n        \n        current = head\n        \n        i = 0\n        while current:\n            result.append(0)\n            if aux.is_empty() or aux.peek()[1] >= current.val:\n                aux.push((i,current.val))\n                current = current.next\n                i += 1\n                continue\n            \n            while (not aux.is_empty()) and (aux.peek()[1] < current.val):\n                position, value = aux.pop()\n                result[position] = current.val\n            aux.push((i,current.val))\n            i += 1\n            current = current.next\n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        numbers = []\n        answers = []\n\n        while head:\n            numbers.append(head.val)\n            answers.append(0)\n            head = head.next\n            \n            n = len(numbers) - 1\n            \n            while head and n >= 0 and head.val > numbers[n]:\n                if answers[n] == 0:\n                    answers[n] = head.val\n                n-=1\n            # print(numbers, answers)\n        return answers", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        res, stack = [], []\n\n        while head:\n            while stack and stack[-1][1] < head.val:\n                top = stack.pop()\n                res[top[0]] = head.val\n            stack.append([len(res), head.val])\n            res.append(0)\n            head = head.__next__\n\n        return res\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        temp=[]\n        i=head\n        while i!=None:\n            temp.append(i.val)\n            i=i.next\n        #print(temp)\n        n=len(temp)\n        res=[0]*n\n        for i in range(n-2,-1,-1):\n            for j in range(i+1,n):\n                if(temp[j]>temp[i]):\n                    res[i]=temp[j]\n                    break\n                elif((temp[j]==temp[i])or(res[j]==0)):\n                    res[i]=res[j]\n                    break\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head):\n        \\\"\\\"\\\"\n        :type head: ListNode\n        :rtype: List[int]\n        \\\"\\\"\\\"\n        answer_array = []\n        stack = []\n        index = 0\n        \n        while head is not None:\n            answer_array.append(0)\n            current_value = head.val\n            \n            while stack and stack[-1][0] < current_value:\n                last_value = stack.pop()\n                answer_array[last_value[1]] = current_value\n\n            stack.append((current_value, index))\n            index += 1\n            head = head.next\n\n        return answer_array\n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        count = 0\n        out = []\n        \n        while head:\n            \n            out.append(0)\n            while stack and head.val > stack[-1][0]:\n                out[stack[-1][1]] = head.val\n                stack.pop()\n            stack.append((head.val,count))\n            count += 1\n            head = head.__next__\n       \n        return out\n                \n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        res = []\n        i = 0\n        prev_min = sys.maxsize\n        val = set()\n        curr = head\n        while curr != None:\n            n = curr.val\n            if n > prev_min:\n                to_remove = []\n                for node in val:\n                    if node[1] < n:\n                        res[node[0]] = n\n                        to_remove.append(node)\n                for node in to_remove:\n                    val.remove(node)\n            else:\n                prev_min = n\n            val.add((i, n))\n            res.append(0)\n            curr = curr.__next__\n            i+=1\n        return res\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def __init__(self):\n        self.result = []\n        self.stack = []\n    \n    def nextLargerNodes(self, head: ListNode) -> list:\n        self.__recursive(head)\n        return self.result[::-1]\n        \n    def __recursive(self, head: ListNode) -> None:\n        if head == None:\n            return\n        \n        self.__recursive(head.__next__)\n        \n        val = 0\n        while len(self.stack) != 0:\n            val = self.stack.pop()\n            \n            if val > head.val:\n                self.result.append(val)\n                self.stack.extend([val, head.val])\n                break\n        \n        if len(self.stack) == 0:\n            self.result.append(0)\n            self.stack.append(head.val)\n            \n        return\n\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if not head:\n            return [0]\n        \n        idx = -1\n        res = []\n        stack = []\n        \n        while head:\n            res.append(0)\n            \n            while stack and stack[-1][1] < head.val:\n                position , _ = stack.pop()\n                res[position] = head.val\n            \n            idx += 1\n            stack.append((idx , head.val))\n            head = head.__next__\n            \n        return res\n        \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        res = []\n        pos = 0\n        while head:\n            res.append(0)\n            while stack and head.val > stack[-1][1]:\n                idx, _ = stack.pop()\n                res[idx] = head.val\n            stack.append((pos, head.val))\n            pos += 1\n            head = head.next\n        while stack:\n            idx, _ = stack.pop()\n            res[idx] = 0\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        return self.stacksol(head)\n        \\\"\\\"\\\"\n        1) Go backwards\n        2) Keep sorted list of numbers\n        3) Upon new number, insert into list in sorted order, and remove all values smaller than that number\n            a) if new number is at the end of the list (max), then return 0 for that value\n            b) else, return the next larger value in the list\n        \\\"\\\"\\\"\n        vals = [] #list form of linked list\n        while(head):\n            vals += [head.val]\n            head = head.next\n        \n        slist = [] #sorted max list\n        alist = [] #answer\n        \n        for i,val in enumerate(vals[::-1]):\n            newind = bisect.bisect_right(slist, val)\n            slist.insert(newind, val)\n            if slist[-1] == val:\n                alist += [0]\n            else:\n                alist += [slist[newind+1]]\n            slist = slist[newind:]\n            \n        return alist[::-1]\n    \n    def stacksol(self, head: ListNode) -> List[int]:\n        \\\"\\\"\\\"\n        add numbers to stack\n        1) pop off all numbers lower than number first\n        2) add number to answer list, in equal number of pops (else add 0 place holder)\n        3) \n        \n        \\\"\\\"\\\"\n        ret, stack = [], []\n        \n        while(head):\n            while(stack and stack[-1][0] < head.val):\n                p = stack.pop()\n                ret[p[1]] = head.val\n            stack += [(head.val, len(ret) )]\n            ret += [0]\n            head = head.next\n        return ret\n    \n    \n#         ret, stack = [], []\n#         while(head):\n#             counter = 0\n#             while(stack and stack[-1] < head.val):\n#                 stack.pop()\n#                 counter += 1\n#             stack += [head.val]\n\n#             for i in range(counter):\n#                 ret[-(i+1)] = head.val\n#             ret += [0]\n#             head = head.next\n#         return ret", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        p = head\n        stack = []\n        res = []\n        i = 0\n        \n        while p:\n            while stack and p.val > stack[-1][0].val:\n                # res.append(p.val)\n                res[stack[-1][1]] = p.val\n                stack.pop()\n                \n            stack.append((p,i))\n            \n            i += 1   \n            p = p.next\n            res.append(0)\n                \n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        ans = []\n        stack = []\n\n        while head:\n            while stack and stack[-1][0]<head.val:\n                ans[stack.pop()[1]] = head.val\n            stack.append((head.val, len(ans)))\n            ans.append(0)\n            head = head.next\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        nums = []\n        p = head\n        while p:\n            nums.append(p.val)\n            p = p.__next__\n        \n        st = []\n        ans = [0]* len(nums)\n        for i in range(len(nums)):\n            while st and nums[st[-1]] < nums[i]:\n                ans[st[-1]] = nums[i]\n                st.pop()\n            st.append(i)\n        \n         \n        return ans\n                    \n\n            \n                \n        \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n    \n        stack = []\n        result = []\n        index = 0\n        while(head):\n            \n            if len(stack) > 0:\n                if head.val > stack[-1][0]:\n                    # Pop the stack, change the list\n                    for i in range(len(stack)):\n                        if stack[-1][0] < head.val:\n                            result[stack.pop()[1]] = head.val\n                    \n            stack.append((head.val, index))\n\n            result.append(0)\n            index += 1\n            head = head.__next__\n            \n            \n        return result\n        \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        maps = defaultdict(lambda:[]); lst = []; runner = head; \n    \n        while runner:\n            lst.append(runner.val)\n            runner = runner.__next__\n        \n        for i, v in enumerate(lst): maps[v].append(i)\n\n        res = [0 for _ in range(len(lst))]; heap = []\n        for i in range(len(lst)):\n            while heap and lst[i] > heap[0][0]:\n                pop = heapq.heappop(heap)\n                res[pop[1]] = lst[i]\n            heapq.heappush(heap, (lst[i], i))\n        return res\n        \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    \n    def find_best(self, head):\n        current = head\n        while current.next:\n            if current.next.val>head.val:\n                return current.next.val\n            current = current.next\n        return 0\n    \n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        self.lst = []\n        def helper(head, i):\n            if not head:\n                return\n            self.lst.append(0)\n            helper(head.next, i+1)\n            if head.next:\n                if head.next.val>head.val:\n                    self.lst[i] = head.next.val\n                else:\n                    if self.lst[i+1] == 0 or self.lst[i+1] > head.val:\n                        self.lst[i] = self.lst[i+1]\n                    else:\n                        self.lst[i] = self.find_best(head)\n        helper(head,0)\n        return self.lst", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        ##\u8f6c\u5316\u6210stack \u6765\u505a\n        if not head:\n            return head\n        val_list = []\n        while head:\n            val_list.append(head.val)\n            head = head.__next__\n        stack = []\n        res = [0 for _ in range(len(val_list))]\n        for i in range(len(val_list)):\n            while stack and val_list[stack[-1]] < val_list[i]:\n                res[stack.pop()] = val_list[i]\n            stack.append(i)\n        return res\n\n    \n    \n            \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n    \n        stack = []\n        result = []\n        index = 0\n        while(head):\n            \n            if len(stack) > 0:\n                if head.val > stack[-1][0]:\n                    # Pop the stack, change the list\n                    for i in range(len(stack)):\n                        stack_val = stack.pop()\n                        if stack_val[0] < head.val:\n                            result[stack_val[1]] = head.val\n                        else:\n                            stack.append(stack_val)\n            stack.append((head.val, index))\n\n            result.append(0)\n            index += 1\n            head = head.__next__\n            \n            \n        return result\n        \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        \n        current = head\n        ret = []\n        index = 0\n        while current is not None:\n            ret.append(0)\n            while stack and current.val > stack[-1][1]:\n                i, _ = stack.pop()\n                ret[i] = current.val\n            \n            stack.append((index, current.val))\n            \n            index += 1\n            current = current.next\n            \n        return ret", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        node = head\n        ans = []\n        stack = []\n        i = 0\n        while node is not None:\n            # print(i, stack, ans)\n            ans.append(0)\n            if len(stack):\n                while len(stack) and node.val > stack[-1][1]:\n                    j = stack[-1][0]\n                    ans[j] = node.val\n                    # print(j, ans[j])\n                    stack.pop()\n            stack.append((i, node.val))\n            node = node.__next__\n            i += 1\n        return ans\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        dic={}\n        stack=[]\n        i=0\n        ans=[0]*100001\n        while head:\n            while stack and dic[stack[-1]]<head.val:\n                t=stack.pop()\n                ans[t]=head.val\n            dic[i]=head.val\n            stack.append(i)\n            i+=1\n            head=head.__next__\n        while stack:\n            t=stack.pop()\n            ans[t]=0\n        return ans[:i]\n", "\nimport heapq\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if not head:\n            return []\n        \n        h = []\n        res = {}\n        cur = head\n        i = 0\n        while cur:\n            if len(h) == 0:\n                heappush(h, (cur.val, i))\n            else:\n                while h and cur.val > h[0][0]:\n                    val, index = heappop(h)\n                    res[index] = cur.val\n                heappush(h, (cur.val, i))    \n            i += 1     \n            cur = cur.next\n        while h:\n            val, index = h.pop()\n            print(val, index)\n            res[index] = 0\n        \n        return [res[index] for index in sorted([k for k in res])]", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if not head:return []\n        ans=[]\n        while head:\n            ans.append(head.val)\n            head=head.next\n        n=len(ans)\n        lst=[]\n        for i in range(n-1,-1,-1):\n            v=ans[i]\n            while lst and lst[-1]<=v:\n                lst.pop()\n            ans[i]=0 if not lst else lst[-1]\n            lst.append(v)\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        arr=[]\n        temp = head\n        while temp:\n            arr.append(temp.val)\n            temp = temp.next\n        stk = []\n        i=0\n        while i<len(arr):\n            while stk and arr[stk[-1]] < arr[i]:\n                arr[stk.pop()] = arr[i]\n            stk.append(i)\n            i+=1\n        while stk:\n            arr[stk.pop()] = 0\n        return arr       ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if not head:\n            return []\n        \n        stack = []\n        res = []\n        \n        idx = 0\n        while head:\n            while stack and stack[-1][1] < head.val:\n                pos, _ = stack.pop()\n                res[pos] = head.val\n            stack.append((idx, head.val))\n            res.append(0)\n            idx += 1\n            head = head.next\n        \n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        arr=[]\n        cur=head\n        while cur:\n            arr.append(cur.val)\n            cur=cur.next\n        st,res=[],[0]*len(arr)\n        for i in range(len(arr)):\n            while st and arr[i]>arr[st[-1]]:\n                res[st.pop()]=arr[i]\n            st.append(i)\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        vals = []\n        node = head\n        while node:\n            vals.append(node.val)\n            node = node.__next__\n        \n        n = len(vals)\n        ret = [0 for _ in range(n)]\n        q = [(n - 1, vals[n - 1])]  # idx, val\n\n        for i in range(n - 1, -1, -1):\n            curr = vals[i]\n            while q:\n                if q[0][1] > curr:\n                    ret[i] = q[0][1]\n                    heapq.heappush(q, (i, curr))\n                    break\n                else:\n                    heapq.heappop(q)\n            else:\n                heapq.heappush(q, (i, curr))\n        \n        return ret\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        output = []\n        stack = []\n        curr = head\n        \n        while curr:\n            while stack and stack[-1][1] < curr.val:\n                output[stack.pop()[0]] = curr.val\n            stack.append([len(output), curr.val])\n            output.append(0)\n            curr = curr.__next__\n        return output\n            \n\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        ######################################################################\n       # solution 1, using stack \n        stack = []\n        curr = head \n        while curr:\n            stack.append(curr.val)\n            curr = curr.__next__ \n            \n        result = [0]* len(stack) # populate \n        stack2 = []\n        \n        for  i in range(len(stack)):\n            while stack2 and stack[stack2[-1]] < stack[i]:\n                  result[stack2.pop()] = stack[i]\n            stack2.append(i)\n            \n        while stack2: # reaplce the indexes of the stack with 0s\n            result[stack2.pop()] = 0\n            \n        return result\n    ######################################################################\n        # solution 2, using stack with two for loops \n#         output = []\n#         if head.next == None:\n#             return output + [0]  \n#         curr = head \n#         stack = []\n#         while curr:\n#             stack.append(curr.val)\n#             curr = curr.next \n            \n#         for i in range(len(stack)-1):\n#             flag = True\n#             for j in range(i, len(stack)):\n#                 if stack[i] < stack[j]:\n#                     output.append(stack[j])\n#                     flag = False \n#                     break \n#             if flag:\n#                 output.append(0)\n#         return output + [0]\n        ######################################################################\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        results = {}\n        stack = deque()\n        next = head.__next__\n        curr = head\n        extra_values = 0\n        stack.append((0, curr.val))\n        index = 0\n        while(next != None):\n            while(len(stack) != 0 and stack[-1][1] < next.val):\n                (ind, val) = stack.pop()\n                print((ind, val))\n                results[ind] = next.val\n            index += 1\n            stack.append((index, next.val))\n            next = next.__next__\n        #add extra zeros\n        for i in range(len(stack)):\n            results[stack[i][0]] = 0\n        result_arr = [0] * len(results)\n        for j in range(len(result_arr)):\n            result_arr[j] =results[j]\n\n        return result_arr\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stk, res = [], []\n        while head:\n            while stk and head.val > stk[-1][1]:\n                idx = stk.pop()[0]\n                res[idx] = head.val\n            stk.append([len(res), head.val])\n            res.append(0)\n            head = head.__next__\n        return res\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        arr = []\n        ptr = head\n        while ptr:\n            arr.append(ptr.val)\n            ptr = ptr.__next__\n        result = [0] * len(arr)\n        s = []\n        for i in range(len(arr)-1,-1,-1):\n            while (len(s)>0 and s[-1]<= arr[i]):\n                s.pop()\n            result[i] = 0 if len(s)==0 else s[-1]\n            s.append(arr[i])\n        return result\n            \n", "import heapq\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        h = []\n        vals = {}\n        cur = head\n        idx = 0\n        while cur:\n            while len(h) > 0 and h[0][0] < cur.val:\n                print(f\\\"{h[0]} < {cur.val}\\\")\n                _, i = heapq.heappop(h)\n                vals[i] = cur.val\n            heapq.heappush(h, (cur.val, idx))\n            cur = cur.next\n            idx += 1\n        \n        res = []\n        i = 0\n        while head:\n            res.append(vals.get(i, 0))\n            head = head.next\n            i += 1\n        return res\n        \n            \n        ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        vals = []\n        stack = []\n        node = head\n        \n        while node != None:\n            vals.append(node.val)\n            node = node.__next__\n            \n        if len(vals) == 1:\n            return [0]\n        if len(vals) == 0:\n            return 0\n        \n        res = [0 for _ in range(len(vals))]\n        \n        for i,val in enumerate(vals):\n            while stack:\n                if vals[stack[-1]] < val:\n                    pos = stack.pop()\n                    res[pos] = val\n                else:\n                    break\n                \n            stack.append(i)\n            \n        while stack:\n            pos = stack.pop()\n            res[pos] = 0\n        return res\n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        nodes = []\n        curr = head\n        while curr: \n            nodes.append(curr.val)\n            curr = curr.next\n        res = [0]*len(nodes)\n        stack = []\n        \n        for i in range(len(nodes)): \n            while stack and nodes[stack[-1]]<nodes[i]: \n                res[stack.pop()] = nodes[i]\n            \n            stack.append(i)\n        \n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        curr = head\n        i = 0\n        res = []\n        stack = []\n        while curr:\n            res.append(0)\n            val = curr.val\n            while stack and stack[-1][0] < val:\n                v , index = stack.pop()\n                res[index] = val\n            \n            stack.append((val,i))\n            i  = i + 1\n            curr = curr.__next__\n        del stack    \n        #print(stack)    \n        return res     \n        \n                \n                              \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        curr=head\n        prev=None\n        while curr!=None:\n            temp=curr.__next__\n            curr.next=prev\n            prev=curr\n            curr=temp\n        curr=prev\n        stack=[0]\n        l=[]\n        while curr!=None:\n            if stack[-1]>curr.val:\n                l.append(stack[-1])\n            else:\n                while stack[-1]<=curr.val and stack[-1]!=0:\n                    stack.pop()\n                l.append(stack[-1])\n            stack.append(curr.val)\n            curr=curr.__next__\n        return l[::-1]\n        \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \\\"\\\"\\\"\n        1) Go backwards\n        2) Keep sorted list of numbers\n        3) Upon new number, insert into list in sorted order, and remove all values smaller than that number\n            a) if new number is at the end of the list (max), then return 0 for that value\n            b) else, return the next larger value in the list\n        \\\"\\\"\\\"\n        vals = [] #list form of linked list\n        while(head):\n            vals += [head.val]\n            head = head.next\n        \n        slist = [] #sorted max list\n        alist = [] #answer\n        \n        for i,val in enumerate(vals[::-1]):\n            newind = bisect.bisect_right(slist, val)\n            slist.insert(newind, val)\n            if slist[-1] == val:\n                alist += [0]\n            else:\n                alist += [slist[newind+1]]\n            slist = slist[newind:]\n            \n        return alist[::-1]", "class Stack:\n    def __init__(self):\n        self.items = []\n        self.time_stamps = dict()\n        self.t = 0\n\n    def isEmpty(self):\n        return self.items == []\n\n    def push(self, item):\n        \n        self.items.append([item, self.t])\n        self.time_stamps[item] =self.t \n        self.t +=1\n        \n\n    def pop(self):\n        return self.items.pop()\n\n    def peek1(self):\n        return self.items[len(self.items)-1][0]\n    def peek2(self):\n        return self.items[len(self.items)-1][1]\n\n    def size(self):\n        return len(self.items)\n    def ret(self):\n        return self.items\n\n\n\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n        T= []\n        while head:\n            T.append(head.val)\n            head = head.__next__\n        \n        def dailyTemperatures(T: List[int]) -> List[int]:\n            if len(T) == 0:\n                return [0]\n            ans = [0]*len(T)\n            stack = Stack()\n            stack.push(T[0])\n\n            for i in range(1, len(T)):\n                current = T[i]\n                if current <= stack.peek1():\n                    stack.push(current)\n                    \n                else:\n                    while(stack.size() !=0 and current > stack.peek1()):\n                        ans[stack.peek2()] = stack.t - stack.peek2()\n                        stack.pop()\n                    stack.push(current)\n\n\n            return ans\n        S = dailyTemperatures(T)\n        n = len(S)\n        ans = [0]*n\n        for i in range(n):\n            if S[i] !=0:\n                ans[i]= T[i+S[i]]\n        \n        return ans\n\n\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        result = [] \n        stack = []\n        idx = 0\n        while head:\n            while stack and head.val > stack[-1][0]:\n                result[stack.pop()[1]] = head.val\n            stack.append((head.val, idx))                            \n            result.append(0)\n            head = head.__next__\n            idx += 1\n        return result\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        answer = []\n        index = 0\n        while head:\n            answer.append(0)\n            while len(stack) > 0 and stack[-1][0] < head.val:\n                number_and_index = stack.pop()                \n                answer[number_and_index[1]] = head.val\n            stack.append((head.val, index))\n            index += 1\n            head = head.next\n        return answer", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        return self.stacksol(head)\n        \\\"\\\"\\\"\n        1) Go backwards\n        2) Keep sorted list of numbers\n        3) Upon new number, insert into list in sorted order, and remove all values smaller than that number\n            a) if new number is at the end of the list (max), then return 0 for that value\n            b) else, return the next larger value in the list\n        \\\"\\\"\\\"\n        vals = [] #list form of linked list\n        while(head):\n            vals += [head.val]\n            head = head.next\n        \n        slist = [] #sorted max list\n        alist = [] #answer\n        \n        for i,val in enumerate(vals[::-1]):\n            newind = bisect.bisect_right(slist, val)\n            slist.insert(newind, val)\n            if slist[-1] == val:\n                alist += [0]\n            else:\n                alist += [slist[newind+1]]\n            slist = slist[newind:]\n            \n        return alist[::-1]\n    \n    def stacksol(self, head: ListNode) -> List[int]:\n        \\\"\\\"\\\"\n        add numbers to stack\n        1) pop off all numbers lower than number first\n        2) add number to answer list, in equal number of pops (else add 0 place holder)\n        3) \n        \n        \\\"\\\"\\\"\n        ret, stack = [], []\n        \n        while(head):\n            while(stack and stack[-1][0] < head.val):\n                p = stack.pop()\n                ret[p[1]] = head.val\n            stack += [(head.val, len(ret) )]\n\n            ret += [0]\n            head = head.next\n        return ret\n    \n    \n#         ret, stack = [], []\n#         while(head):\n#             counter = 0\n#             while(stack and stack[-1] < head.val):\n#                 stack.pop()\n#                 counter += 1\n#             stack += [head.val]\n\n#             for i in range(counter):\n#                 ret[-(i+1)] = head.val\n#             ret += [0]\n#             head = head.next\n#         return ret", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack = []\n        cur = head\n        res = [0]*1000000\n        ind = 0 \n\n        while cur:\n\n            while stack and stack[-1][1]< cur.val:\n                res[stack[-1][0]] = cur.val\n                stack.pop()\n\n\n            stack.append((ind,cur.val))\n            ind+=1\n            cur = cur.__next__\n            \n        # while stack:\n        #     res[stack[-1][0]] = 0\n        #     stack.pop()\n\n        return res[:ind]\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        data=[]\n        node=head\n        maxN=0\n        while node!=None:\n            data.append(node.val)\n            node=node.next\n      #  print(data)\n        s=[]\n        out=[0]*len(data)\n        for i in range(len(data)-1,-1,-1):\n            \n            while len(s)>0 and s[-1]<=data[i]:\n                s.pop()\n            if len(s)>0:\n                out[i]=s[-1]\n            s.append(data[i])\n            \n        return out\n        out=[]\n        for i in range(len(data)-1,-1,-1):\n         #   print(maxN)\n            \n            maxN=max(maxN,data[i])\n            if maxN!=data[i]:\n                out.appendleft(maxN)\n            else:\n                out.appendleft(0)\n          #  print(data[i],maxN)\n        return list(out)\n        return out", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        ans, stack = [], []\n        while head:\n            while stack and stack[-1][1] < head.val:\n                ans[stack.pop()[0]] = head.val\n            stack.append([len(ans), head.val])\n            ans.append(0)\n            head = head.next\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        def lreverse(head):\n            if head is None:\n                return head\n            p = None\n            q = head\n            r = head.__next__\n            while q:\n                q.next = p\n                p = q\n                q = r\n                if r:\n                    r = r.__next__\n            return p\n        head = lreverse(head)\n        q, res = [],[]\n        while head:\n            while q and head.val >= q[-1]:\n                q.pop()\n            if len(q) == 0:\n                res.append(0)\n            else:\n                res.append(q[-1])\n            q.append(head.val)\n            head = head.__next__\n            \n        return res[::-1] \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n        memo = {}\n        t=head\n        nodes=[]\n        while t:\n            nodes.append(t.val)\n            t=t.__next__\n        \n        maxes = [0]*len(nodes)\n        sol = [0]*len(nodes)\n        for idx,val in enumerate(nodes[::-1]):\n            if idx != 0:\n                maxes[-idx-1] = max(maxes[-idx],nodes[-idx])\n            else:\n                maxes[-idx-1] = nodes[-idx-1]\n                \n        for idx,val in enumerate(nodes):\n            if val in memo and memo[val] > idx:\n                sol[idx] = nodes[memo[val]]\n            elif maxes[idx] > val:\n                for j in range(idx+1,len(nodes)):\n                    if nodes[j]>val:\n                        memo[val] = j\n                        sol[idx] = nodes[j]\n                        break\n            else:\n                continue\n        \n        return sol\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        \n        \\\"\\\"\\\"\n        \u8fd9\u9053\u9898\u5206\u6790\u4e00\u4e0b\u5176\u5b9e\u4e0d\u96be\uff0c\u6bd4\u8f83\u5bb9\u6613\u610f\u8bc6\u5230\u9700\u8981\u7528heap\n        \u5bf9\u4e8e\u5f53\u524dposi, \u5b83\u5e94\u8be5pop heap\u4e2d\u6bd4\u5b83\u5c0f\u7684\u6240\u6709pending\uff0c\u7136\u540e\u81ea\u5df1\u8fdbheap  \n        \u5982\u679c\u6700\u540e\u8fd8\u6ca1\u51faheap\u90a3\u5c31\u662f\u5728\u5176\u540e\u6ca1\u627e\u5230\u6bd4\u81ea\u5df1\u5927\u7684\n        \\\"\\\"\\\"\n        \n        def get_length(head):\n            count = 0 \n            while head:\n                count += 1 \n                head = head.next \n            return count \n        \n        length = get_length(head)\n        if length == 0:\n            return []\n        if length == 1:\n            return [0]\n        \n        ans = [0] * length \n        heap = []\n        heapify(heap)\n        index = 0\n        while head:\n            node = head\n            head = head.next \n            while heap and heap[0][0] < node.val:\n                out = heappop(heap)\n                ans[out[1]] = node.val\n            heappush(heap, (node.val, index))\n            index += 1\n        \n        return ans\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        stack=[]\n        res=[]\n        while head:\n            while stack and stack[-1][1]<head.val:\n                res[stack.pop()[0]]=head.val\n            stack.append([len(res),head.val])\n            res.append(0)\n            head=head.next\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        # \u501f\u9274\u81ea discuss\n        pos = 0\n        ans = []\n        stack = []  # \u5355\u8c03\u6808\uff08\u9012\u51cf\uff09\n        while head:\n            ans.append(0)\n            # \u9000\u6808\u7684\u65f6\u5019\u66f4\u65b0 ans \u6570\u7ec4\n            while stack and stack[-1][1] < head.val:\n                idx, _ = stack.pop()\n                ans[idx] = head.val\n            \n            stack.append((pos, head.val))\n            head = head.next\n            pos += 1\n\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        st1 = []\n        ptr = head\n        while ptr:\n            st1.append(ptr.val)\n            ptr=ptr.__next__\n        \n        st2=[]\n        ans=[]\n        while st1:\n            while st2 and st2[-1]<=st1[-1]:\n                st2.pop()\n            if len(st2)==0:\n                ans.append(0)\n            else:\n                ans.append(st2[-1])\n            st2.append(st1.pop())\n        return ans[::-1]\n"]
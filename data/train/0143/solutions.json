["class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        prior_fruit = tree[0]\n        prior_fruit_counter = 0\n        fruits_in_basket = [tree[0]]\n        fruits_in_basket_counter = 0\n        max_fib = -1\n        for fruit in tree: \n            if prior_fruit == fruit:\n                prior_fruit_counter += 1\n                fruits_in_basket_counter += 1\n            elif prior_fruit != fruit:\n                if fruit in fruits_in_basket:\n                    fruits_in_basket_counter += 1\n                else:\n                    fruits_in_basket, fruits_in_basket_counter = [prior_fruit, fruit], prior_fruit_counter + 1\n                prior_fruit, prior_fruit_counter = fruit, 1\n            if fruits_in_basket_counter > max_fib:\n                max_fib = fruits_in_basket_counter\n        return max_fib", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        best_so_far = start = 0\n        fruit_1 = fruit_2 = fruit_1_last_index = fruit_2_last_index = None\n        \n        for end in range(len(tree)):\n            if fruit_1 is None:\n                fruit_1 = tree[end]\n                fruit_1_last_index = end\n                \n            elif fruit_2 is None and tree[end] != fruit_1:\n                fruit_2 = tree[end]\n                fruit_2_last_index = end\n                \n            else:\n                if tree[end] == fruit_1:\n                    fruit_1_last_index = end\n                elif tree[end] == fruit_2:\n                    fruit_2_last_index = end\n                else:\n                    best_so_far = max(best_so_far, end - start)\n                    \n                    if fruit_1_last_index < fruit_2_last_index:\n                        start = fruit_1_last_index + 1\n                        fruit_1 = tree[end]\n                        fruit_1_last_index = end\n                    else:\n                        start = fruit_2_last_index + 1\n                        fruit_2 = tree[end]\n                        fruit_2_last_index = end\n        \n        return max(best_so_far, len(tree) - start)", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        q = []\n        ans = -99999999999\n        s = 0\n        e = s\n        while e<len(tree):\n            if tree[e] not in q:\n                if len(q)<2:\n                    q.append(tree[e])\n                else:\n                    if e-s > ans:\n                        ans = e-s\n                    i = e-1\n                    while tree[i] == tree[e-1] and i>-1:\n                        i -= 1\n                    s = i+1\n                    q.clear()\n                    q.append(tree[s])\n                    q.append(tree[e])\n                \n            e += 1\n        \n        if e-s > ans:\n            ans = e-s\n        \n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        tran_ptr = 0\n        maxlist = []\n        \n        while True:\n            scan_ptr = tran_ptr\n            count = 0\n            types = []\n            \n            # Scan pointer reaches the end of tree[]\n            # or until finding 3rd type of fruit\n            while True:\n                if tree[scan_ptr] in types:\n                    count += 1\n                elif len(types) == 0:\n                    types.append(tree[scan_ptr])\n                    count += 1\n                elif len(types) == 1:\n                    tran_ptr = scan_ptr\n                    types.append(tree[scan_ptr])\n                    count += 1\n                else: # New type of fruit and types are full\n                    break\n                scan_ptr += 1\n                if scan_ptr == len(tree):\n                    break\n            maxlist.append(count)\n            \n            if scan_ptr == len(tree):\n                break\n        \n        return max(maxlist)", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        window = collections.Counter()\n        ans = 0\n        \n        left = 0\n        for right in range(len(tree)):\n            window[tree[right]] += 1\n            while len(window) > 2:\n                window[tree[left]] -= 1\n                if window[tree[left]] == 0:\n                    del window[tree[left]]\n                left += 1\n                \n            ans = max(ans, sum(window.values()))\n            \n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        maxi=0\n        if len(tree)==1:\n            return 1\n        l=[]\n        s=set()\n        for i in range(len(tree)):\n            l.append(tree[i])\n            s.add(tree[i])\n            if len(s)>2:\n                #l=l[::-1]\n                while len(set(l))>2:\n                    #l.pop()\n                    l=l[1:]\n                #l=l[::-1]\n            maxi=max(maxi,len(l))\n        return maxi\n        \n#         maxi=0\n#         if len(tree)==1:\n#             return 1\n            \n#         for i in range(len(tree)):\n#             s=set()\n#             s.add(tree[i])\n#             for j in range(i+1,len(tree)):\n#                 s.add(tree[j])\n#                 if len(s)>2:\n#                     break\n#                 maxi=max(maxi,j-i+1)\n#         return maxi\n        \n        # for i in range(len(tree),0,-1):\n        #     start=0\n        #     end=i\n        #     for j in range(len(tree)-i+1):\n        #         s=tree[start:end]\n        #         start+=1\n        #         end+=1\n        #         if len(set(s))<=2:\n        #             return i\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res = 0\n        max_elem_count = 0\n        window = {}\n        start = 0\n        \n        l = len(tree)\n        for end in range(l):\n            if tree[end] in window:\n                window[tree[end]] += 1\n            else:\n                window[tree[end]] = 1\n            max_elem_count = max(max_elem_count, window[tree[end]])\n            \n            while len(window) > 2:\n                window[tree[start]] -= 1\n                if window[tree[start]] == 0:\n                    window.pop(tree[start])\n                start += 1\n                \n            res = max(res, end - start + 1)\n        \n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # find the largest region using only two numbers..\n        # sliding window may do the trick here\n        # use a dictionary to keep track of the fruits/ how many types you have .. or just use two baskekts\n        import collections\n        fruits = collections.defaultdict(int)\n        # only put something in the basket if it's empty\n        max_len = 0\n        front = back = 0\n        while back < len(tree):\n            if len(list(fruits.keys())) <= 2:\n                fruits[tree[back]] += 1\n                back += 1\n            else:\n                fruits[tree[front]] -= 1\n                if fruits[tree[front]] == 0:\n                    del fruits[tree[front]]\n                front += 1\n            if len(list(fruits.keys())) <= 2:\n                max_len = max(max_len, back-front)\n        return max_len\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not tree:\n            return 0\n        \n        max_count = 1\n        basket = {tree[0]: 1}\n        i = 0\n        for j in range(1, len(tree)):\n            basket[tree[j]] = basket.get(tree[j], 0) + 1\n            while (len(basket) > 2):\n                # remove tree[i], decrement i\n                basket[tree[i]] = basket.get(tree[i], 0) - 1\n                if (basket[tree[i]] == 0):\n                    basket.pop(tree[i])\n                i += 1\n            curr_count = sum(basket.values())\n            max_count = max(max_count, curr_count)\n        \n        return max_count\n        \n            \n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n\n        p1 = 0\n        p2 = 0\n        counter = 0\n        mx = 0\n        mmap = {}\n        uniq = set()\n        while p2 < len(tree):\n            if len(uniq) > 2:\n                # remove here\n                mmap[tree[p1]] -= 1\n                if mmap[tree[p1]] == 0:\n                    uniq.remove(tree[p1])\n                    \n                p1 += 1\n                #print(mmap, uniq, p1, p2)\n            else:\n                # add here\n                if tree[p2] in mmap:\n                    mmap[tree[p2]] += 1\n                else:\n                    mmap[tree[p2]] = 1\n                    \n                uniq.add(tree[p2])\n                if len(uniq) <= 2:\n                    counter = p2 - p1 + 1\n                mx = max(mx, counter)  \n                p2 += 1\n                \n                \n        return mx\n                \n            \n    \n            \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(set(tree))<=2:\n            return len(tree)\n        res = cur = count_b = a = b = 0\n\n        for c in tree:\n            cur = cur + 1 if c in (a, b) else count_b + 1\n            count_b = count_b + 1 if c == b else 1\n            if b != c: a, b = b, c\n            res = max(res, cur)\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        fruit_types = collections.Counter()\n        max_fruit = 0\n        \n        start_idx = 0\n        end_idx = 0\n        \n        # Move end pointer forward\n        while end_idx < len(tree):\n            fruit_types[tree[end_idx]] += 1\n            \n            # Move start pointer forward\n            while len(fruit_types) > 2:\n                fruit_types[tree[start_idx]] -= 1\n                if fruit_types[tree[start_idx]] == 0:\n                    del fruit_types[tree[start_idx]]\n                start_idx += 1\n                \n            max_fruit = max(max_fruit, sum(fruit_types.values()))\n            \n            end_idx += 1\n        \n        return max_fruit", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        #You want a basket that can get both. \n        total_fruits = collections.defaultdict(int)\n        unique_baskets = 0\n        max_fruit_types = 0 \n        start = 0\n        for end in range(len(tree)):\n            cur_fruit = tree[end]\n            total_fruits[cur_fruit] += 1 \n            if total_fruits[cur_fruit] == 1: #then we know there is a unique fruit here\n                unique_baskets += 1 \n                \n            while unique_baskets >= 3: \n                start_fruit = tree[start]\n                total_fruits[start_fruit] -= 1\n                if not total_fruits: #this means that we have less unique baskets now \n                    unique_baskets -= 1 \n                start += 1\n                    \n            max_fruit_types = max(max_fruit_types, end - start + 1)\n            \n        return max_fruit_types\n            \n#         #Start at ANY tree of my choice \n#         #Then perform the steps \n# #         1) Add one fruit from the tree to basket. If you can't you stp \n# #         2) Move to the next tree to the RIGHT of the current tree if there is no such tree you stop. \n        \n#     #So you reset back to step 1 after you're done. \n#     #So this means that once you're done and because we want to GET all possible fruits through your positions \n# #         WANT: Total amount of fruit collected \n#         last_fruit = -1 \n#         second_last_fruit = -1 \n#         last_fruit_count = 0\n#         total_fruits = 0 \n#         cur_fruits_max = 0 \n#         #Let's call prev fruits \n#         #last_fruit, second_last_fruit \n#         # fruit is our CURRENT fruit \n        \n#         #So we have 2 prev fruit and current fruit.  \n#         #If fruit is the second_last_fruit \n#         #We will know \n#         for fruit in tree: \n#             if fruit == last_fruit or fruit == second_last_fruit: \n#                 cur_fruits_max += 1 \n                \n#             else: \n#                 cur_fruits_max = last_fruit_count + 1 #this means we picked you new fruit \n                \n     \n#             #You need to check fruit with last fruit not second to last fruit since last fruit will be your \\\"best case scenario\\\"\n#             if fruit == last_fruit: \n#                 last_fruit_count += 1 \n#             else: \n#                 last_fruit_count = 1 #never been seen before (base case)\n            \n#             #This means that we'd be double counting if we moved you beforehand \n#             if fruit != last_fruit: #meaning your a second_last_fruit basically \n#                 second_last_fruit = last_fruit \n#                 last_fruit = fruit \n                \n#             total_fruits = max(total_fruits, cur_fruits_max)\n            \n#         print(total_fruits)\n#         # (O(N)) run time \n#         return total_fruits \nclass Solution():\n    def totalFruit(self, tree):\n        fruit_basket = collections.defaultdict(int)\n        unique_fruits = 0 \n        total_fruits = 0 \n        start = 0\n        end = 0 \n        for end in range(len(tree)): \n            type_of_fruit = tree[end]\n            fruit_basket[type_of_fruit] += 1 #Defaultdict so if not there instantiate it and add one \n            #small check to count it one time for the fruit \n            if fruit_basket[type_of_fruit] == 1: \n                unique_fruits += 1 \n                \n            while unique_fruits > 2:\n                start_fruit = tree[start]\n                fruit_basket[start_fruit] -= 1 \n                if not fruit_basket[start_fruit]: #meaning it's empty \n                    unique_fruits -= 1 \n                start += 1 \n            total_fruits = max(total_fruits, end - start + 1)\n        return total_fruits\n        \n#Map Way   \n# import collections\n# class Solution():\n#     def totalFruit(self, tree):\n#         count = collections.defaultdict(int)\n#         unique = res = end = start = 0\n#         while end < len(tree):\n#             count[tree[end]] += 1\n#             if count[tree[end]] == 1: unique+=1\n#             while unique > 2:\n#                 count[tree[start]] -= 1\n#                 if not count[tree[start]]: \n#                     unique -= 1\n#                 start += 1\n#             res = max(res, end - start + 1)\n#             end += 1\n#         return res\n            \n                \n        \n        \n        \n            \n            \n            \n\n\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans, j = 0,0\n        n = len(tree)\n        dic = {}\n        for i in range(n):\n            dic[tree[i]] = i\n            #print(dic, ans)\n            if len(dic) > 2:\n                ans = max(ans, i-j)\n                k = None\n                for key in dic:\n                    if key != tree[i] and key !=tree[i-1]:\n                        k = key\n                        j = dic[key]+1\n                del dic[k]\n                \n        return max(ans, n-j)\n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        nTrees, ans = len(tree), 0\n        if len(set(tree)) <= 2:\n            return nTrees\n        i, j = 0,1\n        while i < j and j < nTrees:\n            if len(set(tree[i:j+1])) <= 2:\n                j += 1\n                ans = max(ans, j-i)\n            else:\n                i+= 1\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i = 0\n        count = collections.Counter()\n        for index, value in enumerate(tree):\n            count[value] += 1\n            if len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i +=1\n        return len(tree) - i\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        '''\n        Using sliding window, keep track of the longest window length where unique fruit types <= 2\n        the max window will be the answer\n        '''\n        left = 0\n        n = len(tree)\n        ans = 0\n        basket = set()\n        counter = collections.Counter()\n        for right, fruit in enumerate(tree):\n            basket.add(fruit)\n            counter[fruit] += 1\n            while len(basket) > 2:\n                counter[tree[left]] -= 1\n                if counter[tree[left]] == 0:\n                    basket.remove(tree[left])\n                left += 1\n            ans = max(ans, right-left+1)\n        return ans\n        \n        # # Recursive\n        # memo = {}\n        # def collect(index, basket=[]):\n        #     if index == len(tree):\n        #         return 0\n        #     # if (index, set(basket)) \n        #     take = 0\n        #     if len(basket) < 2 or (tree[index] in basket):\n        #         take = collect(index+1, basket+[tree[index]]) + 1\n        #     skip = 0\n        #     if len(basket) < 2:\n        #         skip = collect(index+1, basket)\n        #     return max(take, skip)\n        # return collect(0)                        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # Goal is to find longest continuous subsequence containing only 2 types\n        ans = i = 0\n        count = Counter()\n        for j, t in enumerate(tree):\n            count[t] += 1\n            while len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n\n            ans = max(ans, j - i + 1)\n        return ans\n", "class Solution(object):\n    def totalFruit(self, tree):\n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans", "class Solution:\n     def totalFruit(self, tree: List[int]) -> int:\n            start = 0\n            max = 0\n            reset = 0\n            baskets ={1: [None, 0], 2: [None, 0]}\n            while start < len(tree) and start >= 0:\n                if baskets[1][0] == None:\n                    baskets[1][0] = tree[start]\n                    baskets[1][1] += 1\n                    while reset and start > 0:\n                        if baskets[1][0] != tree[start -1]:\n                            reset = 0\n                        else:\n                            start -= 1\n                elif baskets[1][0] == tree[start]:\n                    baskets[1][1] += 1\n                elif baskets[2][0] == None:\n                    baskets[2][0] = tree[start]\n                    baskets[2][1] += 1\n                elif baskets[2][0] == tree[start]:\n                    baskets[2][1] += 1\n                else:\n                    if max < baskets[1][1]+ baskets[2][1]:\n                        print((baskets,start))\n                    baskets ={1: [None, 0], 2: [None, 0]}\n                    reset  = 1\n                if reset == 1:\n                    if start > 0:\n                        start -= 1\n                else:\n                    start += 1\n                if max < baskets[1][1]+ baskets[2][1]:\n                    max  =  baskets[1][1]+ baskets[2][1]\n            return max\n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        finalMax = currentMax = last = secondLast = lastCount = 0\n\n        for fruit in tree:\n            if fruit == last or fruit == secondLast:\n                currentMax += 1\n            else:\n                currentMax = lastCount + 1\n\n            if fruit == last:\n                lastCount += 1\n            else:\n                secondLast = last\n                last = fruit\n                lastCount = 1\n\n            finalMax = max(finalMax, currentMax)\n\n        return finalMax\n\n", "from collections import Counter\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        max_fruits = 0\n        window_start = 0\n        freq = Counter()\n        for i, val in enumerate(tree):\n            freq[val] += 1\n            while len(freq) > 2:\n                to_delete = tree[window_start]\n                freq[to_delete] -= 1\n                if not freq[to_delete]:\n                    del freq[to_delete]\n                window_start += 1\n            max_fruits = max(max_fruits, i - window_start + 1)\n        return max_fruits", "class Solution:\n    def totalFruit(self, trees: List[int]) -> int:\n        \n        if len(trees) <= 2:\n            return len(trees)\n        \n        lp = 0\n        rp = 1\n        maxSize = 0\n        hash = collections.defaultdict(int)\n        lpInc = False\n        rpInc = False\n        curSet = set()\n        \n        # Start the left and right pointer values at 1 frequency. Use += 1 in case trees[lp] and trees[rp] point to the same value.\n        hash[trees[lp]] += 1\n        curSet.add(trees[lp])\n        hash[trees[rp]] += 1\n        curSet.add(trees[rp])\n        \n        while rp < len(trees):\n            if lpInc:\n                hash[trees[lp-1]] = max(hash[trees[lp-1]]-1, 0)\n                if hash[trees[lp-1]] > 0:\n                    curSet.add(trees[lp-1])\n                else:\n                    curSet.remove(trees[lp-1])\n            if rpInc:\n                hash[trees[rp]] += 1\n                curSet.add(trees[rp])\n                \n            lpInc = False\n            rpInc = False\n            \n            if len(curSet) <= 2:\n                if (rp - lp) + 1 > maxSize:\n                    maxSize = (rp - lp) + 1\n                    \n            if len(curSet) > 2:\n                lp += 1\n                lpInc = True\n            else:\n                rp += 1\n                rpInc = True\n        \n        return maxSize\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i = 0\n        j = 0\n        hm = {}\n        maxL = 0\n        while j < len(tree):\n            if tree[j] in hm:\n                hm[tree[j]] += 1\n            else:\n                if len(hm)<2:\n                    hm[tree[j]] = 1\n                else:\n                    maxL = max(maxL, j-i)\n                    while i<j and len(hm)>1:\n                        hm[tree[i]] -= 1\n                        if hm[tree[i]] == 0:\n                            del hm[tree[i]]\n                        i += 1\n                    hm[tree[j]] = 1\n\n            j += 1\n\n        maxL = max(maxL,j-i)\n        return maxL\n", "from collections import Counter\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        baskets = Counter()\n        max_fr = 0\n        i = 0\n        \n        for j, t in enumerate(tree):\n            baskets[t] += 1\n            \n            while len(baskets) > 2:\n                baskets[tree[i]] -= 1\n                if baskets[tree[i]] == 0:\n                    del baskets[tree[i]]\n                \n                i += 1\n            \n            max_fr = max(max_fr, j - i + 1)\n        \n        return max_fr\n\n# class Solution:\n\n#     def totalFruit(self, tree):\n#         count, i = {}, 0\n#         for j, v in enumerate(tree):\n#             count[v] = count.get(v, 0) + 1\n#             if len(count) > 2:\n#                 count[tree[i]] -= 1\n#                 if count[tree[i]] == 0: del count[tree[i]]\n#                 i += 1\n#         return j - i + 1\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        fruitCap = [0] * len(tree)\n        fruitCap[-1] = 1\n        \n        fruitA = tree[-1]\n        fruitB = None\n        for i in reversed(list(range(len(tree) - 1))):\n            if tree[i] == fruitA or tree[i] == fruitB:\n                fruitCap[i] = fruitCap[i + 1] + 1\n            elif fruitB == None:\n                fruitCap[i] = fruitCap[i + 1] + 1\n                fruitB = tree[i]\n            else:\n                fruitA = tree[i]\n                fruitB = tree[i + 1]\n                fruitCap[i] = getConsecutive(tree, i + 1) + 1\n        \n        print(fruitCap)\n        return max(fruitCap)\n    \ndef getConsecutive(tree, index):\n    \n    consecutive = 0\n    fruit = tree[index]\n    for i in range(index, len(tree)):\n        if tree[i] == fruit:\n            consecutive += 1\n        else:\n            break\n    \n    return consecutive\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        #tree = [0,1,6,6,4,4,6]\n        max_fruits = 0\n        counter = 0\n        fruit_basket = set()\n        i = 0\n        while i < len(tree):\n            if len(fruit_basket) < 2 :\n                counter += 1\n                fruit_basket.add(tree[i])\n                if len(fruit_basket) == 2:\n                    new_fruit_idx = i\n            elif tree[i] in fruit_basket:\n                counter += 1\n            else:\n                fruit_basket = set()\n                max_fruits = max(counter,max_fruits)\n                counter = 0\n                i = new_fruit_idx - 1\n            i += 1\n        max_fruits = max(counter,max_fruits)\n        return max_fruits", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        max_ = 0\n        baskets = {}\n        \n        def get_other_tree(this_tree):\n            trees = list(baskets.keys())\n            return trees[1 - trees.index(this_tree)] if len(trees) == 2 else trees[0]\n        \n        for idx, tr in enumerate(tree):\n            need_to_empty_1_basket = tr not in baskets and len(baskets) == 2\n            if need_to_empty_1_basket:\n                max_ = max(max_, sum(sum(baskets[b]) for b in baskets))\n                last_tree = tree[idx - 1]\n                other_tree = get_other_tree(last_tree)\n                baskets = {last_tree: [baskets[last_tree][1], 0], tr: [0, 1]}\n            else:\n                there_is_another_tree = (tr not in baskets and len(baskets) == 1) or (tr in baskets and len(baskets) == 2)\n                if there_is_another_tree:\n                    other_tree = get_other_tree(tr)\n                    baskets[other_tree] = [sum(baskets[other_tree]), 0]\n\n                if tr not in baskets:\n                    baskets[tr] = [0, 0]\n                baskets[tr][1] += 1\n                \n        return max(max_, sum(sum(baskets[b]) for b in baskets))\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not tree or len(tree) == 0:\n            return 0\n        max_ = 1\n        mem = {}\n        i,j = 0,0\n        while j<len(tree):\n            if len(mem) <=2:\n                mem[tree[j]] = j\n                j += 1\n            if len(mem) > 2:\n                min_ = len(tree) - 1\n                for value in mem.values():\n                    min_ = min(min_,value)\n                i = min_ + 1\n                del mem[tree[min_]]\n            max_ = max(max_,j-i)\n            \n        return max_", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        max_ = 0\n        baskets = {}\n        \n        def get_other_tree(this_tree):\n            trees = list(baskets.keys())\n            return trees[1 - trees.index(this_tree)] if len(trees) == 2 else trees[0]\n        \n        for idx, tr in enumerate(tree):\n            if tr not in baskets and len(baskets) == 2:\n                max_ = max(max_, sum(sum(baskets[b]) for b in baskets))\n                last_tree = tree[idx - 1]\n                other_tree = get_other_tree(last_tree)\n                baskets = {last_tree: [baskets[last_tree][1], 0], tr: [0, 1]}\n            else:\n                there_is_another_tree = (tr not in baskets and len(baskets) == 1) or (tr in baskets and len(baskets) == 2)\n                if there_is_another_tree:\n                    other_tree = get_other_tree(tr)\n                    baskets[other_tree] = [sum(baskets[other_tree]), 0]\n\n                if tr not in baskets:\n                    baskets[tr] = [0, 0]\n                baskets[tr][1] += 1\n                \n        return max(max_, sum(sum(baskets[b]) for b in baskets))\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        pre=-1\n        ans=a=b=0\n        x=y=-1\n        for cur in tree:\n            if cur!=x and cur!=y:\n                x,y=pre,cur\n                a,b=b,1\n            elif cur==pre:\n                b+=1\n            else:\n                a+=b\n                b=1\n            if a+b>ans:\n                ans=a+b\n            pre=cur\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # need to identify longest streak of two unique types of fruit\n        \n        # brute force \n        # \n        # loop i \n        #   \n        #   loop j\n        #       if dict < 2 then add unique character to dict\n        #       if num encountered is not in dict and dict.len == 2 then break\n        #  check if the counter > max if it is then set max to counter\n        \n#         answer = 0\n#         counter = 0\n#         dictionary = {}\n#         # print(tree)\n#         for i in range(len(tree)):\n#             for j in range(i, len(tree)):\n#                 # print('curr', tree[j], i, j)\n#                 if tree[j] in dictionary:\n#                     counter += 1\n#                 elif tree[j] not in dictionary and len(dictionary) < 2:\n#                     counter += 1\n#                     dictionary[tree[j]] = tree[j]\n#                 elif tree[j] not in dictionary and len(dictionary) == 2:\n#                     break\n#             # print('round done')\n#             if counter > answer:\n#                 answer = counter\n#                 # print('reassigning answer', answer)\n#             counter = 0\n#             dictionary = {}\n                \n#         return answer\n\n        # something faster\n    \n        answer = 0 \n        currTree = 0\n        numsDictionary = collections.Counter()\n        \n        for treeIndex, fruit in enumerate(tree):\n            numsDictionary[fruit] += 1\n            while len(numsDictionary) >= 3:\n                numsDictionary[tree[currTree]] -= 1\n                if numsDictionary[tree[currTree]] == 0:\n                    del numsDictionary[tree[currTree]]\n                currTree += 1\n            answer = max(answer, treeIndex - currTree + 1 )\n        return answer", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i=0\n        counter={}\n        res=0\n        for j, v in enumerate(tree):\n            counter[v]=counter.get(v,0)+1\n            while len(counter)>2:\n                counter[tree[i]]-=1\n                if not counter[tree[i]]: \n                    del counter[tree[i]]\n                i+=1\n            res=max(res, j-i+1)\n        return res\n                \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i = 0\n        next_start_pos = None\n        max_len = 0\n        s = set()\n        res = []\n        while i < len(tree):\n            if tree[i] in s:\n                max_len += 1\n                i += 1\n            else:\n                if len(s) == 0:\n                    s.add(tree[i])\n                    max_len += 1\n                    i += 1\n                elif len(s) == 1:\n                    s.add(tree[i])\n                    max_len += 1\n                    next_start_pos = i\n                    i += 1\n                elif len(s) == 2:\n                    res.append(max_len)\n                    max_len = 0\n                    s = set()\n                    i = next_start_pos\n                    \n        res.append(max_len)\n        return max(res)", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        max_ = 0\n        baskets = {}\n        \n        def get_other_tree(this_tree):\n            trees = list(baskets.keys())\n            return trees[1 - trees.index(this_tree)] if len(trees) == 2 else trees[0]\n        \n        for idx, tr in enumerate(tree):\n            need_to_empty_1_basket = tr not in baskets and len(baskets) == 2\n            if need_to_empty_1_basket:\n                max_ = max(max_, sum(sum(counts) for counts in list(baskets.values())))\n                last_tree = tree[idx - 1]\n                other_tree = get_other_tree(last_tree)\n                baskets = {last_tree: [baskets[last_tree][1], 0], tr: [0, 1]}\n            else:\n                there_is_another_tree = (tr not in baskets and len(baskets) == 1) or (tr in baskets and len(baskets) == 2)\n                if there_is_another_tree:\n                    other_tree = get_other_tree(tr)\n                    baskets[other_tree] = [sum(baskets[other_tree]), 0]\n\n                if tr not in baskets:\n                    baskets[tr] = [0, 0]\n                baskets[tr][1] += 1\n                \n        return max(max_, sum(sum(counts) for counts in list(baskets.values())))\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left,right=-1,0\n        seen = Counter()\n        ans = 0\n        while left<=right<len(tree):\n            while right<len(tree) and (len(seen) < 2 or tree[right]in seen):\n                seen[tree[right]]+=1\n                right+=1\n                \n            ans = max(ans,right-left-1) #-1?\n\n            left+=1\n            seen[tree[left]]-=1\n            if seen[tree[left]]==0:\n                del seen[tree[left]]\n                \n        return ans", "class Solution(object):\n    def totalFruit(self, nums):\n        d = {}\n        k = 2\n        maxL = 0\n        L = 0\n        \n        for R in range(len(nums)):\n            if nums[R] in d:\n                d[nums[R]] += 1\n            else:\n                d[nums[R]] = 1\n            while len(d) > k:\n                d[nums[L]] -= 1\n                if d[nums[L]] == 0:\n                    del d[nums[L]]\n                L+=1\n            maxL = max(maxL, R-L+1)\n        return maxL", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        maxi=0\n        if len(tree)==1:\n            return 1\n        l=[]\n        s=set()\n        for i in range(len(tree)):\n            l.append(tree[i])\n            s.add(tree[i])\n            if len(s)>2:\n                l=l[::-1]\n                while len(set(l))>2:\n                    l.pop()\n                l=l[::-1]\n            maxi=max(maxi,len(l))\n        return maxi\n        \n#         maxi=0\n#         if len(tree)==1:\n#             return 1\n            \n#         for i in range(len(tree)):\n#             s=set()\n#             s.add(tree[i])\n#             for j in range(i+1,len(tree)):\n#                 s.add(tree[j])\n#                 if len(s)>2:\n#                     break\n#                 maxi=max(maxi,j-i+1)\n#         return maxi\n        \n        # for i in range(len(tree),0,-1):\n        #     start=0\n        #     end=i\n        #     for j in range(len(tree)-i+1):\n        #         s=tree[start:end]\n        #         start+=1\n        #         end+=1\n        #         if len(set(s))<=2:\n        #             return i\n", "class Track(object):\n    def __init__(self, n = 2):\n        # Maps the values to their counts\n        self.count = {}\n        \n        # Keeps track of the last element\n        self.last = {}\n        self.order = [None for _ in range(n - 1)]\n        \n    def is_new_elem(self, elem):\n        return elem not in self.count\n    \n    def is_last_elem(self, elem):\n        return elem in self.last\n    \n    def add(self, elem):\n        if self.is_new_elem(elem):\n            self.count = {elem: 1}\n            for key, val in self.last.items():\n                self.count[key] = val\n        else:\n            self.count[elem] += 1\n                \n        if self.is_last_elem(elem):\n            self.last[elem] += 1\n        else:\n            if elem in self.order:\n                del self.order[self.order.index(elem)]\n            else:\n                rem = self.order.pop(0)\n                if rem is not None:\n                    del self.last[rem]\n            \n            self.last[elem] = 1\n            self.order.append(elem)\n        \n    def get_count(self):\n        total = 0\n        for _, val in self.count.items():\n            total += val\n        return total\n        \nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        tracker = Track()\n        \n        max_count = 0\n        for t in tree:\n            tracker.add(t)\n            max_count = max(max_count, tracker.get_count())\n            \n        \n        return max_count", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        ans= i=0\n        \n        basket = {}\n        \n        for j, x in enumerate(tree):\n            \n            if x in basket:\n                basket[x] += 1\n            else:\n                basket[x] = 1\n                \n            while len(basket)>=3:\n                \n                basket[tree[i]] -= 1\n                \n                if basket[tree[i]] == 0:\n                    \n                    del basket[tree[i]]\n                \n                i += 1\n                \n            ans = max(ans, j-i+1)\n                \n        return ans\n", "class Solution:\n    def totalFruit(self, tree) -> int:\n        unit_first=tree[0]\n        unit_second=-1\n        amount_first=0\n        amount_second=0\n        max_amount=0\n        prev=tree[0]\n        prev_amount=0\n        for i in range(len(tree)):\n            if(tree[i] == prev):\n                prev_amount+=1\n            \n            if(tree[i] == unit_first):\n                amount_first+=1\n            elif(tree[i] == unit_second):\n                amount_second+=1\n            else:\n                max_amount = max(max_amount,(amount_first+amount_second))\n                unit_first=prev\n                amount_first=prev_amount\n                unit_second=tree[i]\n                amount_second=1\n            \n            if(tree[i] != prev):\n                prev_amount=1\n\n            prev = tree[i]\n\n        return max(max_amount,(amount_first+amount_second))", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        b1, b2, b1N, b2N, b2NCons, maxPick = None, None, 0, 0, 0, 0\n\n        for fruit in tree:\n\n            if fruit == b2:\n                b2N, b2NCons = b2N + 1, b2NCons + 1\n\n            elif fruit == b1:\n                b1, b2, b1N, b2N, b2NCons = b2, b1, b2N, b1N+1, 1\n\n            else:\n                b1, b2, b1N, b2N, b2NCons = b2, fruit, b2NCons, 1, 1\n\n            maxPick = max(maxPick, b1N+b2N)\n\n        return maxPick", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = 0\n        p = 0\n        while p < len(tree):\n            acc = 1\n            first = tree[p]\n            next_p = len(tree)\n            second = -1\n            for i in range(p + 1, len(tree)):\n                if tree[i] != first:\n                    if second == -1:\n                        second = tree[i]\n                        next_p = i\n                    elif tree[i] != second:\n                        break\n                acc += 1\n                if i == len(tree) - 1:\n                    return max(ans, acc)\n            p = next_p\n            ans = max(ans, acc)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        type_cnt = {}\n        max_fruit = -1\n        left_ptr = 0\n        last_cnt = 0\n        while left_ptr < len(tree):\n            right_ptr = left_ptr\n            while right_ptr < len(tree) - 1 and tree[right_ptr] == tree[right_ptr + 1]:\n                right_ptr += 1\n            curr_type = tree[left_ptr]\n            curr_cnt = right_ptr - left_ptr + 1\n                \n            if curr_type not in type_cnt:\n                type_cnt[curr_type] = curr_cnt\n            else:\n                type_cnt[curr_type] += curr_cnt\n\n            if len(type_cnt) > 2:\n                type_cnt = {last_type: last_cnt, curr_type: curr_cnt}\n            \n            max_fruit = max(max_fruit, sum([cnt for cnt in list(type_cnt.values())]))\n            last_cnt = curr_cnt\n            last_type = curr_type\n            left_ptr = right_ptr + 1 \n        return max_fruit\n               \n", "from collections import Counter\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        num_fruit = Counter()\n        j, num_type, max_fruit = 0, 0, 0\n        for i in range( len(tree) ):\n            if num_fruit[ tree[i] ] == 0: num_type += 1\n            num_fruit[ tree[i] ] += 1\n            \n            if num_type <= 2:\n                max_fruit = max( i-j+1, max_fruit )\n            else:\n                while True:\n                    num_fruit[ tree[j] ] -= 1\n                    j += 1\n                    if num_fruit[ tree[j-1] ] == 0: break\n                num_type -= 1\n        \n        return max_fruit", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        result = 0\n        collected = {}\n        i = 0\n        for j, fruit in enumerate(tree):\n            collected[fruit] = collected.get(fruit, 0) + 1\n            while len(collected) > 2:\n                collected[tree[i]] -= 1\n                if not collected[tree[i]]:\n                    collected.pop(tree[i])\n                i += 1\n            result = max(result, j - i + 1)\n        return result", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        freq = collections.defaultdict(int)\n        for j, fruit in enumerate(tree):\n            freq[fruit] += 1\n            while len(freq) == 3:\n                freq[tree[i]] -= 1\n                if freq[tree[i]] == 0:\n                    del freq[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) < 2: return len(tree)\n        start, end, res = 0, 1, 1\n        basket = {tree[start]: 1}\n        while end < len(tree):\n            if tree[end] in basket:\n                basket[tree[end]] +=1\n                end += 1\n                res = max(res, end-start)\n            elif len(basket) < 2:\n                basket[tree[end]] = 1\n                end += 1\n                res = max(res, end-start)\n            else:\n                basket[tree[start]] -= 1\n                if basket[tree[start]] == 0:\n                    del basket[tree[start]]\n                start += 1\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        '''\n        sliding window\n        O(N)\n        '''           \n        if len(tree) == 1:\n            return 1\n        \n        l = 0\n        r = 1\n        \n        curr_window = defaultdict(int)\n        curr_window[tree[l]] += 1 \n        res = 1\n        while r < len(tree):                                        \n            curr_window[tree[r]] += 1\n            while len(curr_window) > 2:                                    \n                curr_window[tree[l]] -= 1\n                if curr_window[tree[l]] == 0:\n                    del curr_window[tree[l]]\n                l += 1\n                                    \n            if r - l + 1 > res:\n                res = r - l + 1\n                \n            r += 1\n                \n        \n        return res\n        \n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(j - i + 1, ans)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        last_fruit = -1\n        second_last_fruit = -1\n        last_fruit_count = 0\n        current_max = 0\n        maxi = 0\n        \n        for fruit in tree:\n            if fruit == last_fruit or fruit == second_last_fruit:\n                current_max+=1\n            else:\n                current_max = last_fruit_count + 1\n                \n            if fruit == last_fruit:\n                last_fruit_count += 1\n            else:\n                last_fruit_count = 1\n                \n            if fruit != last_fruit:\n                second_last_fruit = last_fruit\n                last_fruit = fruit\n                \n            \n            maxi = max(current_max, maxi)\n            \n        return maxi", "from collections import Counter\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res = l = 0\n        count = Counter()\n        for r, t in enumerate(tree):\n            count[t] += 1\n            while len(count) >= 3:\n                count[tree[l]] -= 1\n                if count[tree[l]] == 0:\n                    del count[tree[l]]\n                l += 1\n            res = max(res, r - l + 1)\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        max_length = 0\n        fruits_frequency = defaultdict(int)\n        window_start = 0\n        \n        for window_end in range(0, len(tree)):\n            right_fruit = tree[window_end]\n            fruits_frequency[right_fruit] += 1\n            \n            while len(fruits_frequency) > 2:\n                left_fruit = tree[window_start]\n                fruits_frequency[left_fruit] -= 1\n                if fruits_frequency[left_fruit] == 0:\n                    del fruits_frequency[left_fruit]\n                    \n                window_start += 1\n            max_length = max(max_length, window_end - window_start + 1)\n            \n        return max_length", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        count2 = 0\n        basket = 0\n        ans = 0\n        kind1, kind2 = 0, 0\n        for t in tree:\n            if t == kind2:\n                count2 += 1\n                basket += 1\n            elif t == kind1:\n                count2 = 1\n                basket += 1\n                kind1, kind2 = kind2, kind1\n            else:\n                basket = count2 + 1\n                count2 = 1\n                kind1, kind2 = kind2, t\n            ans = max(ans, basket)\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left=ans=0\n        types=collections.defaultdict(int)\n        for right in range(len(tree)):\n            types[tree[right]]+=1\n            if len(types.keys())<=2:\n                ans=max(ans,right-left+1)\n            while len(types.keys())>2:\n                types[tree[left]]-=1\n                if types[tree[left]]==0:\n                    types.pop(tree[left])\n                left+=1\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        l, r, ans = 0, 0, 0\n        counter = Counter()\n        length = 0\n        while r < len(tree):\n            counter[tree[r]] += 1\n            length = len(counter)\n            r += 1\n\n            while length > 2:\n                counter[tree[l]] -= 1\n                if counter[tree[l]] == 0:\n                    del counter[tree[l]]\n                    length -= 1\n                l += 1\n            ans = max(ans, r - l)\n        return ans\n\n\n\n\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        maxStreak = 0\n        i = 0\n        types = set()\n        last_type = 0\n        streak = 0\n        while i < len(tree):\n            if len(types) == 0 or len(types) == 1:\n                types.add(tree[i])\n                last_type = i\n                streak += 1\n                i += 1\n            else:\n                if tree[i] in types:\n                    if tree[last_type] != tree[i]:\n                        last_type = i\n                    streak += 1\n                    i += 1\n                else:\n                    i = last_type\n                    types = set()\n                    maxStreak = max(streak, maxStreak)\n                    streak = 0\n                    \n        return max(streak, maxStreak)\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        cnt = 1\n        max = 1\n        keys = set([tree[0]])\n        \n        spree = [tree[0], 1] # to hold the numberof fruits before a switch\n        \n        for k in range(1, len(tree)):\n            if tree[k] in keys:\n                cnt += 1\n                if tree[k] == spree[0]:\n                    spree[1] +=1\n                else:\n                    spree = [tree[k], 1]\n            elif len(keys)==1: # if the 1st tree is the same as the following...\n                keys.add(tree[k])\n                cnt +=1\n                spree = [tree[k], 1]\n            else:\n                if cnt > max:\n                    max = cnt\n                keys = set([tree[k-1], tree[k]])\n                cnt = spree[1] + 1 #reset counter\n                spree = [tree[k], 1]\n  \n        if cnt > max:\n            max = cnt\n        return max", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        start = 0\n        end = 1\n        maxLength = 1\n        types = {}\n        types[tree[0]] = 1\n        \n        if len(tree) <= 2:\n            return len(tree)\n        \n        while end < len(tree) - 1 or start < end:\n            if end < len(tree)-1 and len(types) < 2:                \n                if types.get(tree[end]):\n                    types[tree[end]] += 1\n                else:\n                    types[tree[end]] = 1\n                \n                end += 1\n            elif end == len(tree) or types.get(tree[end]) == None:\n                types[tree[start]] -= 1\n                \n                if types[tree[start]] == 0:\n                    del types[tree[start]]\n                \n                start += 1           \n            else:                \n                if types.get(tree[end]):\n                    types[tree[end]] += 1\n                else:\n                    types[tree[end]] = 1\n                    \n                end += 1\n                \n            if len(types) <= 2:\n                maxLength = max(maxLength, end-start)\n            \n        return maxLength", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if(len(tree)<=1):\n            return len(tree)\n        if(len(list(set(tree))) == 2):\n            return len(tree)\n        maxCount = 0\n        classes = []\n        i = 0\n        while(i < len(tree)):\n            j = i + 1\n            classes = [tree[i]]\n            count = 1\n            secFruitStart = -1\n            while(len(classes) <= 2 and j < len(tree)):\n                if(tree[j] not in classes):\n                    classes.append(tree[j])\n                    if(len(classes) == 2):\n                        secFruitStart = j\n                if(len(classes) == 3):\n                    continue\n                count = count + 1\n                j = j + 1\n            if(count > maxCount):\n                maxCount = count\n            if(secFruitStart != -1):\n                i = secFruitStart\n            else:\n                break\n        return maxCount", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        #max contiguous sum with 2 different types of elements\n        \n        start = 0\n        end = 0\n        le = len(tree)\n        hmap = collections.defaultdict(int)\n        count = 0\n        res = 0\n        \n        while end < le:\n            \n            hmap[tree[end]] += 1\n            if hmap[tree[end]] == 1:\n                count += 1\n            \n            end += 1\n            \n            while count > 2 and start < end:\n                hmap[tree[start]] -= 1\n                if hmap[tree[start]] == 0:\n                    count -= 1\n                start += 1\n            \n            if count > 2:\n                continue\n            \n            res = max(res, end-start)\n        \n        return res\n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        secondLastFruit = -1\n        lastFruit = -1\n        lastFruitCount = 0\n        currFruits = 0\n        maxFruits = 0\n        \n        for fruit in tree:\n            if fruit == lastFruit or fruit == secondLastFruit:\n                currFruits += 1\n            else:\n                currFruits = lastFruitCount + 1\n                \n            if fruit == lastFruit:\n                lastFruitCount += 1\n            else:\n                lastFruitCount = 1\n                secondLastFruit = lastFruit\n                lastFruit = fruit\n                \n            maxFruits = max(currFruits, maxFruits)\n        \n        return maxFruits", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i,maxLen=0,0\n        cache=collections.defaultdict(int)\n        for j in range(len(tree)):\n            cache[tree[j]]+=1\n            if len(cache)<=2:\n                maxLen=max(maxLen,j-i+1)\n            while len(cache)>2:\n                cache[tree[i]]-=1\n                if cache[tree[i]]==0:\n                    del cache[tree[i]]\n                i+=1\n        if maxLen==0:\n            return 1\n        return maxLen\n", "\nclass Solution:\n    def totalFruit(self, tree) -> int:\n        '''\n\n        :param tree: : List[int]\n        :return:\n        '''\n        n = len(tree)\n        if n <=2:\n            return n \n        tem = collections.Counter()\n        res = 0\n        i = 0\n        j = 1\n        tem.update(tree[:1])\n\n        while j<n:\n            while j < n and  len(tem.keys()) <=2:\n                tem.update([tree[j]])\n                res = max(res, j - i )\n                j += 1\n\n            while len(tem.keys()) >=3 :\n                tem[tree[i]] -= 1\n                if tem[tree[i]] ==0:\n                    tem.pop(tree[i])\n                i += 1\n\n            if j == n :\n                res = max(res, j - i)\n                break\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        res = 0\n        \n        mres = 0\n        temp = set()\n        i = 0\n        newidx = 0\n        \n        while i < len(tree):\n            if len(temp) == 0:\n                mres += 1\n                temp.add(tree[i])\n                i += 1\n            \n            elif len(temp) == 1:\n                newidx = i\n                temp.add(tree[i])\n                mres += 1\n                i += 1\n                \n            else:\n                if tree[i] in temp:\n                    mres += 1\n                    i += 1\n                else:\n                    res = max(res, mres)\n                    mres = 0\n                    temp = set()\n                    i = newidx\n                    \n        res = max(res, mres)\n        return res\n            \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not tree:\n            return 0\n        if len(set(tree)) <= 2:\n            return len(tree)\n        \n        max_collected = 0\n        \n        for i in range(len(tree)):\n            num_collected = 0\n            different_types = set()\n            for j in range(i, len(tree)):\n                if len(different_types) < 2:\n                    different_types.add(tree[j])\n                    num_collected += 1\n                elif tree[j] in different_types:\n                    num_collected += 1\n                else:\n                    break\n            \n            max_collected = max(max_collected, num_collected)\n        \n        return max_collected", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n      item1_val = -1\n      item1_fs = -1 \n      item1_ls = -1\n      item2_val = -1\n      item2_fs = -1\n      item2_ls = -1\n      size = list()\n      for i in range(len(tree)):\n        if tree[i] == item1_val:\n          item1_ls = i\n          if item1_fs == -1:\n            item1_ls = i\n          if i == 0:\n            size.append(1)\n          size.append(size[i-1] + 1)\n        elif tree[i] == item2_val:\n          item2_ls = i\n          if item2_fs == -1:\n            item2_ls = i\n          if i == 0:\n            size.append(1)\n          size.append(size[i-1] + 1)\n        else:\n          if item1_ls > item2_ls: # item1 stays\n            item1_fs = item2_ls + 1\n            item2_val = tree[i]\n            item2_fs = i\n            item2_ls = i\n            size.append(i - item1_fs + 1)\n          else: # item2 stays\n            item2_fs = item1_ls + 1\n            item1_val = tree[i]\n            item1_fs = i\n            item1_ls = i\n            size.append(i - item2_fs + 1)\n\n      return(max(size))\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        counter = collections.defaultdict(int)\n        \n        start = 0\n        res = 0\n        \n        for end in range(len(tree)):\n            counter[tree[end]] += 1\n            \n            while len(list(counter.keys())) > 2:\n                counter[tree[start]] -= 1\n                \n                if counter[tree[start]] == 0:\n                    del counter[tree[start]]\n                \n                start += 1\n            res = max(res, sum(counter.values()))\n        \n        return res\n            \n            \n                \n", "\nfrom collections import defaultdict\nclass Solution:\n    def totalFruit(self, tree):\n        if len(tree) <3:\n            return len(tree)\n        # run1 = 0\n        # run2 = 1\n        # # run3 = 0\n        best_pair = 0\n        # tree_type1 = None\n        # tree_type2 = tree[0]\n        forest = defaultdict(int)\n        forest[tree[0]] = (0,1)\n        for t in range(1, len(tree)):\n            # print('tree',t)\n            if tree[t] not in forest:\n                best_pair = max([best_pair, sum([b for basket in list(forest.values()) for b in basket])])\n                temp = defaultdict(int)\n                temp[tree[t]] = (0,0)\n                temp[tree[t-1]] = (0,forest[tree[t-1]][-1])\n                forest = temp\n                # print('established tt1', t)\n            if tree[t] == tree[t-1]:\n                forest[tree[t]] = (forest[tree[t]][0],forest[tree[t]][-1]+1)\n            else:\n                # print(forest)\n                forest[tree[t]] = (sum(forest[tree[t]]),1)\n            # if t == tree_type1:\n            #     run1 += 1\n            #     print('run1',run1)\n            # elif t == tree_type2:\n            #     run2 += 1\n            #     print('run2', run2)\n            # else:\n            #     print('new set')\n            #     best_pair = max([best_pair, sum([run1, run2])])\n            #     run2 = run1\n            #     run1 = 1\n            #     tree_type2 = tree_type1\n            #     tree_type1 = t\n            #     print(best_pair, run1, run2, 'tree_type1',tree_type1,'tree_type2', tree_type2)\n            # print(run1, run2)\n            # print(forest)\n            # print(best_pair)\n        best_pair = max([best_pair, sum([b for basket in list(forest.values()) for b in basket])])\n        return best_pair\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        c = collections.Counter()\n        j = 0\n        ans = 0\n        for i in range(len(tree)):\n            c[tree[i]]+=1\n            while len(c)>=3:\n                c[tree[j]] -= 1\n                if c[tree[j]]==0:\n                    del c[tree[j]]\n                j+=1\n            ans = max(ans,i-j+1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        prev_count = curr =  count_b = result = 0\n        a = None\n        b = None\n        for c in tree:\n            if b == c:\n                curr += 1\n                count_b += 1\n            elif a == c:\n                curr += 1\n                count_b = 1\n                a = b\n                b = c\n            elif a != c and b != c:\n                curr = count_b + 1\n                count_b = 1\n                a = b\n                b = c\n            result = max(result, curr)\n        return result", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        current_picking = tree[0]\n        prev_picking = None\n        max_picked = 0\n        baskets = {current_picking: [0, 0]}\n        for i in range(len(tree)):\n            if tree[i] != current_picking:\n                if len(baskets) < 2:\n                    baskets[current_picking] = [0, i-1]\n                    prev_picking = current_picking\n                    current_picking = tree[i]\n                    baskets[current_picking] = [i, i]\n                else:\n                    if tree[i] != prev_picking:\n                        baskets = {\n                            current_picking: [baskets[prev_picking][1] + 1, baskets[current_picking][1]],\n                            tree[i]: [i, i]\n                        }\n                        prev_picking = current_picking\n                        current_picking = tree[i]\n                    else:\n                        prev_picking, current_picking = current_picking, prev_picking\n                        baskets[current_picking][1] = i\n            else:\n                baskets[current_picking][1] = i\n            if baskets.get(current_picking) and baskets.get(prev_picking):\n                max_picked = max(max_picked, max([pos[1] for pos in baskets.values()]) - min([pos[0] for pos in baskets.values()]) + 1)\n            else:\n                max_picked = max(max_picked, baskets[current_picking][1] - baskets[current_picking][0] + 1)\n        return max_picked", "from collections import Counter\nclass window:\n    \n    def __init__(self):\n        self.type = Counter()\n    \n    def add(self, x):\n        self.type[x] += 1\n    \n    def remove(self, x):\n        self.type[x] -= 1\n        if self.type[x] == 0:\n            del self.type[x]\n    \n    def valid(self):\n        return len(self.type) <= 2\n        \n        \nclass Solution:\n    def totalFruit(self, tree):\n        \n        win = window()\n        l, res = 0, 0\n        for r,fruit in enumerate(tree):\n            win.add(fruit)\n            while l < r and not win.valid():\n                win.remove(tree[l])\n                l += 1\n            res = max(res, r-l+1)\n        return res\n            \n            \n        \n        \n        \n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not tree:\n            return 0\n        \n        n = len(tree)\n        res = 1\n        \n        # starting type\n        last_occur = {tree[0]: 0}\n        \n        i, j = 0, 1\n        \n        # condition for while loop\n        while j < n:\n            new_type = tree[j]\n            if new_type in last_occur or len(last_occur.keys()) < 2:\n                last_occur[new_type] = j\n                res = max(res, j-i+1)\n                \n            # should have new types\n            else:\n                count = j - i\n                res = max(res, count)\n                \n                # start from the new index\n                keys = list(last_occur.keys())\n                t = keys[0] if last_occur[keys[0]] < last_occur[keys[1]] else keys[1]\n                i = last_occur[t] + 1\n                del last_occur[t]\n                # new starting type at i\n                \n                last_occur[new_type] = j\n\n            j+=1\n\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        maxL = 0\n        l, r = 0, 0 # 0, 4\n        if len(set(tree)) < 3:\n            return len(tree)\n        \n        while r <= len(tree):\n            temp = tree[l:r]\n            if len(set(temp)) < 3:\n                maxL = max(maxL, len(temp))\n                r += 1\n            elif len(set(temp)) >= 3:\n                l += 1\n        \n        return maxL", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        #two fruit\n        firstFruit = secondFruit = -1\n        firstQuant = secondQuant = 0\n        ans = 0\n        \n        n = len(tree)\n        i = 0\n        while i<n:\n            if firstQuant == 0 or firstFruit == tree[i]:\n                firstFruit  = tree[i]\n                firstQuant += 1\n            elif secondQuant == 0 or secondFruit == tree[i]:\n                secondFruit = tree[i]\n                secondQuant += 1\n            \n            elif i>0 and tree[i-1] == firstFruit:\n                secondFruit = tree[i]\n                secondQuant = 1\n                j = i-1\n                while j>=0 and tree[j]==firstFruit:\n                    j-=1\n                firstQuant = i-1-j\n                    \n            elif i>0 and tree[i-1] == secondFruit:\n                firstFruit = tree[i]\n                firstQuant = 1\n                j = i-1\n                while j>=0 and tree[j]==secondFruit:\n                    j-=1\n                secondQuant = i-1-j\n            ans = max(ans,firstQuant+secondQuant)\n            #print(firstFruit,firstQuant,secondFruit,secondQuant,ans)\n            i+=1\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        count = collections.Counter()\n        # count = {}\n        for j, x in enumerate(tree):\n            count[x] += 1\n            # if x not in count:\n            #     count[x] = 1\n            # else:\n            #     count[x] += 1\n            while len(count) == 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n            \n            \n", "class Solution:\n    def totalFruit(self, ar: List[int]) -> int:\n        l=list(set(ar))\n        if len(l)<=2:\n            return len(ar)\n        else:\n            m=0\n            for i in range(0,len(ar)):\n                l=[ar[i]]\n                # c=0\n                d=1\n                for j in range(i+1,len(ar)):\n                    if ar[j] in l:\n                        l.append(ar[j])\n                    elif ar[j] not in l and d==1:\n                        d+=1\n                        l.append(ar[j])\n                    else:\n                        break\n                m=max(m,len(l))\n            return m\n                    \n                    \n                \n               \n        \n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree)==1:\n            return 1\n        \n        window_start = 0\n        window_end = 2\n        total_max = 2\n        \n        if tree[0] == tree[1]:\n            tmp_index = 0\n        else:\n            tmp_index = 1\n            \n        fruit_type = set(tree[:2])\n        \n        for i in range(2, len(tree)):\n            if (tree[i] in  fruit_type) or len(fruit_type)<2:\n                window_end += 1\n                if tree[i] != tree[i-1]:\n                    tmp_index = i\n                fruit_type.add(tree[i])\n            else:\n                window_start  = tmp_index\n                tmp_index = i\n                window_end += 1\n                fruit_type = set(tree[i-1:i+1])\n            #print(window_start, window_end, fruit_type)\n            if window_end - window_start > total_max:\n                total_max = window_end - window_start\n        return total_max\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        dp = [[] for i in range(len(tree))]\n        dp[-1] = [1, 1, [tree[-1]]]\n        res = 1\n        for i in reversed(list(range(len(tree)-1))):\n            if tree[i] == tree[i+1]:\n                dp[i] = [dp[i+1][0]+1, dp[i+1][1]+1, dp[i+1][2]]\n            elif len(dp[i+1][2]) == 1:\n                dp[i] = [dp[i+1][0]+1, 1, [tree[i], dp[i+1][2][0]]] \n            elif tree[i] in dp[i+1][2]:\n                dp[i] = [dp[i+1][0]+1, 1, dp[i+1][2]]\n            else:\n                dp[i] = [1+dp[i+1][1], 1, [tree[i], tree[i+1]]]\n            res = max(res, dp[i][0])\n        return res\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        N = len(tree)\n        out = 0\n        start = 0\n        olderstart = 0\n        newerend = newerstart = 0\n        olderend = olderstart = 0\n        older = newer = tree[0]        \n        j = 0\n        if N < 3:\n            return len(tree)\n        while newer == older and j < N:\n            olderend = j\n            j+= 1\n            if j == N:\n                return N\n            newer = tree[j]\n            newerstart = j\n            \n        assert(newer != older)\n        \n        for i in range(j, N):\n            curr = tree[i]\n            if (curr == older or curr == newer) :\n                if curr == older:\n                    olderend = i\n                if curr == newer:\n                    newerend = i\n                \n            else:\n                \n                if prev == older:\n                    olderstart = newerend+1\n                else:                    \n                    olderstart = olderend+1\n                    olderend = newerend\n                    older = newer                   \n                \n                newerstart = i\n                newerend = i\n                newer = curr\n                \n            prev = curr                \n            out = max(i-olderstart+1, out)\n        return out\n                \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i = 0\n        count = collections.Counter()\n        for value in tree:\n            count[value] += 1\n            if len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i +=1\n        return len(tree) - i\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree)<=2: return len(tree)\n        \n        n = len(tree)\n        \n        res = 0 \n        start = 0\n        while start<n:\n            type1, type2, type2_pos = -1, -1, -1\n            i = start \n            while i<n: # i represents the end pos\n                if type1 == -1:\n                    type1 = tree[i]\n                    \n                elif tree[i]!=type1 and type2 == -1:\n                    type2 = tree[i]\n                    type2_pos = i\n                    \n                elif tree[i]!=type1 and tree[i]!=type2:\n                    break\n                i += 1\n                \n            res = max(res, i-start)\n            if i==n: break\n            start = type2_pos\n            \n        return res\n            \n                \n        \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        total_len = len(tree)\n        \n        if total_len == 0:\n            return 0\n        \n        rst = 1\n        \n        fruit_1 = tree[0]\n        \n        start = 0\n        \n        # Check the first fruit\n        while tree[start] == fruit_1:\n            start += 1\n            if start >= total_len:\n                return start\n        \n        # Check the second fruit\n        fruits = [fruit_1, tree[start]]\n        fruits_order = [start-1, start]\n        total_fruits = start+1\n        \n        #print(fruits, fruits_order, total_fruits, start)\n        \n        for i in range(start+1, total_len):\n            #print(\\\"new_fruit is\\\", tree[i])\n            if tree[i] == fruits[0]:\n                fruits_order[0] = i\n                total_fruits += 1\n                #print(\\\"Update the basket 0\\\", fruits, fruits_order, total_fruits)\n                \n            elif tree[i] == fruits[1]:\n                fruits_order[1] = i\n                total_fruits += 1\n                #print(\\\"Update the basket 1\\\", fruits, fruits_order, total_fruits)\n                \n            else:\n                if total_fruits > rst:\n                    rst = total_fruits\n                if fruits_order[0] > fruits_order[1]:\n                    fruits[1] = tree[i]\n                    total_fruits = i - fruits_order[1]\n                    fruits_order[1] = i\n                else:\n                    fruits[0] = tree[i]\n                    total_fruits = i - fruits_order[0]\n                    fruits_order[0] = i\n                \n                #print(\\\"generate the new fruits order, type\\\")\n                #print(fruits, fruits_order, total_fruits)\n                \n        if total_fruits > rst:\n            return total_fruits\n        \n        return rst\n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n    \n        out = 0\n        for i in range(len(tree)):\n            tot = self.getTotalAtIndex(tree, i)\n            if tot>out:\n                out = tot\n            if tot == len(tree):\n                break\n        return out\n    \n    \n    def getTotalAtIndex(self, tree, i):\n        \n        fruit_types = set()\n        cnt = 0\n        for j in range(i, len(tree)):\n            if len(fruit_types)<2:\n                fruit_types.add(tree[j])\n                \n            if tree[j] in fruit_types:\n               cnt+=1\n            else:\n                break\n        return cnt\n        pass\n", "from collections import defaultdict\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        st = 0\n        max_len = 0\n        basket = defaultdict(int)\n\n        for end in range(len(tree)):\n            basket[tree[end]] += 1\n\n            while len(basket) > 2:\n                basket[tree[st]] -= 1\n                if basket[tree[st]] == 0:\n                    del basket[tree[st]]\n                st += 1\n\n            total = 0\n            for k in basket:\n                total += basket[k]\n\n            max_len = max(max_len, total)\n\n        return max_len\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        n = len(tree)\n        \n        if n < 3:\n            return n\n        \n        max_count = 0\n\n        dp = [[set(),0,set(),0] for _ in range(n)]\n        \n        dp[0] = [{tree[0]},1,{tree[0]},1]\n        \n        for i in range(1, n):\n            if tree[i] in dp[i-1][2]:\n                set_2 = dp[i-1][2].copy()\n                count_2 = dp[i-1][3] + 1\n            else:\n                temp = dp[i-1][0].copy()\n                temp.add(tree[i])\n                set_2 = temp\n                count_2 = dp[i-1][1] + 1\n            if tree[i] in dp[i-1][0]:\n                set_1 = dp[i-1][0].copy()\n                count_1 = dp[i-1][1] + 1\n            else:\n                set_1 = {tree[i]}\n                count_1 = 1\n                \n            dp[i] = [set_1, count_1, set_2, count_2]\n            \n            max_count = max(max_count, max(count_1, count_2))\n            \n            \n        return max_count\n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        count = collections.Counter()\n        i = ans = 0\n\n        for j in range(len(tree)):\n            fruit = tree[j]\n            count[fruit] += 1\n\n            while len(count.keys()) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n\n            ans = max(ans, j-i+1)\n\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) <= 2:\n            return len(tree)\n        types = {tree[0]: 0, tree[1]: 1} if tree[0] != tree[1] else {tree[0]: 1}\n        res = 2\n        temp = 2\n        for i in range(2, len(tree)):\n            if len(types) == 2:\n                if tree[i] not in types:\n                    res = max(res, temp)\n                    delete = sorted(types, key=types.get)[0]\n                    temp = i - types[delete]\n                    del types[delete]\n                    types[tree[i]] = i\n                else:\n                    temp += 1\n                    types[tree[i]] = i\n            else:\n                temp += 1\n                types[tree[i]] = i\n        res = max(res, temp)\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n            \n        \n            \n        \n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left_pointer, right_pointer = 0, 0\n        fruits = 0\n        fruits_in_basket = {}\n        \n        while (right_pointer < len(tree)) :\n            if (len(fruits_in_basket) <= 2) :\n                fruits_in_basket[tree[right_pointer]] = right_pointer\n                right_pointer += 1\n                #print(fruits_in_basket)\n            if (len(fruits_in_basket) > 2) :\n                minimum_index = len(tree)\n                for index in list(fruits_in_basket.values()) :\n                    minimum_index = min(minimum_index, index)\n                left_pointer = minimum_index + 1\n                #print(left_pointer)\n                fruits_in_basket.pop(tree[minimum_index])\n            fruits = max(fruits, (right_pointer - left_pointer))\n            #print(fruits)\n            \n        return fruits\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if tree == [] or tree is None:\n            return 0\n        \n        if len(tree) == 1:\n                return 1\n\n        # [1,3,3,1]\n        s = 0\n        max = 1\n        count = max\n        \n        for i in range(len(tree)):\n            j = i + 1\n            b1 = tree[i]  # backet 1\n            b2 = tree[j]  # backet 2\n            count = 1\n\n            if b1 == b2:\n                # continue finding a different value while incrementing\n                while j < len(tree) and tree[j] == b1:\n                    j += 1\n                    count += 1\n                if j != len(tree):\n                    b2 = tree[j]    \n                elif count > max:\n                    return count\n            \n            while j < len(tree):\n                \n                \n                    \n                # a new number occured\n                if tree[j] != b1 and tree[j] != b2:\n                    # compare count and max\n                    if count >= max:\n                        max = count\n                    # reset starting position\n            \n                    break\n                \n                # pick up fruit and move\n                count += 1\n                j += 1\n\n                if j == len(tree):\n                    if count >= max:\n                        max = count\n                    return max\n                \n        return max\n          \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        char_to_count = defaultdict(int)\n        unique_chars = 0\n        \n        start = 0\n        end = 0\n        max_fruit = 0\n        while end < len(tree):\n            char_to_count[tree[end]] += 1\n            if char_to_count[tree[end]] == 1:\n                unique_chars +=  1\n            \n            while unique_chars > 2:\n                char_to_count[tree[start]] -= 1\n                if char_to_count[tree[start]] == 0:\n                    unique_chars -= 1\n                start += 1\n            end += 1\n            max_fruit = max(max_fruit, end-start)\n            \n        return max_fruit\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        d = {}\n        first = -1\n        second = -1\n        i = 0\n        n = len(tree)\n        m = -1\n        while i<n:\n            if tree[i] in d:\n                d[tree[i]].append(i)\n                i+=1\n            else:\n                if len(list(d.keys()))==2:\n                    s = 0\n                    for k,v in list(d.items()):\n                        s+=len(v)\n                    m = max(m, s)\n                    if d[first][-1]>d[second][-1]:\n                        i = d[second][-1]+1\n                        first = first\n                        d = {}\n                        d[tree[i]] = [i]\n                        i+=1\n                    else:\n                        i = d[first][-1]+1\n                        first = second\n                        d = {}\n                        d[tree[i]] = [i]\n                        i+=1\n                elif len(list(d.keys()))==1:\n                    second = tree[i]\n                    d[tree[i]] = [i]\n                    i+=1\n                else:\n                    first = tree[i]\n                    d[tree[i]] = [i]\n                    i+=1\n        s = 0\n        for k,v in list(d.items()):\n            s+=len(v)\n        return max(m, s)\n                    \n                    \n            \n                \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        a = Counter(tree)\n        if len(a) <= 2:\n            return len(tree)\n        \n        ans = 0\n        \n        i = 0\n        while i < len(tree):\n            count = 1\n            basket = [tree[i]]\n            j = i + 1\n            while j < len(tree):\n                if tree[j] in basket:\n                    count += 1\n                else:\n                    if len(basket) >= 2:\n                        break\n                    else:\n                        basket.append(tree[j])\n                        count += 1\n                j += 1\n            \n            if count > ans:\n                ans = count\n            i += 1\n            \n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        if len(set(tree))<=2:\n            return len(tree)\n        \n        types = set()\n\n        maxFruits = 0\n        \n        for i in range(len(tree)):\n            start = i\n            res = 0\n            types = set()\n            for i in range(start,len(tree)):\n                fruitType = tree[i]\n                if (len(types)>=2) and (fruitType not in types):\n                    break\n                elif fruitType in types:\n                    res+=1\n                else:\n                    types.add(fruitType)\n                    res+=1\n            \n            maxFruits = max(maxFruits,res)\n            \n        return maxFruits", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        dic = {}\n        first = 0\n        i = 0\n        n = len(tree)\n        ans = 0\n        while i<n:\n            val = tree[i]\n            if val in dic:\n                dic[val] += 1\n            elif len(dic)<2: \n                dic[val] = 1\n            else:\n                dic[val] = 1\n                while len(dic) >= 2:\n                    v2 = tree[first]\n                    first+=1\n                    dic[v2] -= 1\n                    if dic[v2] == 0:\n                        dic.pop(v2,None)\n                        break\n            ans = max(i-first+1, ans)\n            i+=1\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        fruits = tree\n        window_start = 0\n        max_length = 0\n        fruit_frequency = {}\n\n  # try to extend the range [window_start, window_end]\n        for window_end in range(len(fruits)):\n            right_fruit = fruits[window_end]\n            if right_fruit not in fruit_frequency:\n                fruit_frequency[right_fruit] = 0\n            fruit_frequency[right_fruit] += 1\n\n    # shrink the sliding window, until we are left with '2' fruits in the fruit frequency dictionary\n            while len(fruit_frequency) > 2:\n                left_fruit = fruits[window_start]\n                fruit_frequency[left_fruit] -= 1\n                if fruit_frequency[left_fruit] == 0:\n                    del fruit_frequency[left_fruit]\n                window_start += 1  # shrink the window\n            max_length = max(max_length, window_end-window_start + 1)\n        return max_length    ", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        best_attempt = 0\n        for i in range(len(tree)):\n            baskets = {}\n            for j in range(i, len(tree)):\n                if tree[j] in baskets:\n                    baskets[tree[j]] += 1\n                elif len(baskets) >= 2:\n                    break\n                else:\n                    baskets[tree[j]] = 1\n            attempt_val = sum(baskets.values())\n            if attempt_val > best_attempt:\n                best_attempt = attempt_val\n            if best_attempt > len(tree) - i:\n                break\n        return best_attempt\n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res = 0\n        N = len(tree)\n        oneidx = twoidx = 0\n        onetype = tree[0]\n        twotype = None\n        left, right = 0, 0\n        while right < N and tree[right] == onetype:\n          oneidx += 1\n          right += 1\n        oneidx -= 1\n        if right == N:\n          return N\n        twotype = tree[right]\n        twoidx = right\n        while right < N:\n          if tree[right] == onetype:\n            oneidx = right\n          elif tree[right] == twotype:\n            twoidx = right\n          else:\n            res = max(res, right - left)\n            if oneidx < twoidx:\n              left = oneidx + 1\n              onetype = tree[right]\n              oneidx = right\n            else:\n              left = twoidx + 1\n              twotype = tree[right]\n              twoidx = right\n          right += 1\n        return max(res, right - left)\n", "from collections import OrderedDict\n\nclass Solution:\n    \n    def totalFruit(self, tree: List[int]) -> int:\n        \n        last_index_of = OrderedDict()\n        \n        ans = l = 0\n        \n        for i, t in enumerate(tree):\n            \n            last_index_of[t] = i\n            last_index_of.move_to_end(t)\n            \n            if len(last_index_of) > 2:\n                ans = max(ans, i-l)\n                l = last_index_of.popitem(last=False)[1] + 1\n                \n        ans = max(ans, len(tree) - l)\n        \n        return ans", "'''\n{3:1,1:1}\n\n'''\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        first,sec=0,0\n        curr_hash={}\n        if len(tree)<3:return len(tree)\n        Max=[float('-inf')]\n        while(first<len(tree)):\n            first=self.first_pass(first,curr_hash,tree,Max)\n            if first>len(tree):continue\n            sec=self.sec_pass(sec,first,curr_hash,tree)\n        return Max[0]\n    def first_pass(self,pointer,hash,trees,Max):\n        count=0\n        for key in hash:\n            count+=hash[key]\n        while(pointer<len(trees)):\n            typ=trees[pointer]\n            if typ in hash:hash[typ]+=1\n            else:\n                if len(hash)<2:\n                    hash[typ]=1\n                else:\n                    break\n            count+=1\n            pointer+=1\n        Max[0]=max(Max[0],count)\n        return pointer\n    \n    def sec_pass(self,sec,first,hash,tree):\n        while(sec<first and len(hash)>1):\n            typ=tree[sec]\n            if hash[typ]==1: del hash[typ]\n            else: hash[typ]-=1\n            sec+=1\n        return sec\n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        if len(set(tree))<=2:\n            return len(tree)\n        \n        types = set()\n\n        maxFruits = 0\n        \n        for i in range(len(tree)):\n            start = i\n            res = 0\n            types = set()\n            \n            if (len(tree)-start)<=maxFruits:\n                continue\n            \n            for i in range(start,len(tree)):\n                fruitType = tree[i]\n                if (len(types)>=2) and (fruitType not in types):\n                    break\n                elif fruitType in types:\n                    res+=1\n                else:\n                    types.add(fruitType)\n                    res+=1\n            \n            maxFruits = max(maxFruits,res)\n            \n        return maxFruits", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        k = 2\n        left = 0\n        cnt = collections.Counter()\n        res = 0\n        for j, i in enumerate(tree):\n            if cnt[i] == 0: k-=1\n            cnt[i] += 1\n            while k<0:\n                cnt[tree[left]] -= 1\n                if cnt[tree[left]] == 0: k+=1\n                left += 1\n            res = max(res, j-left +1)\n        return res\n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        c=0\n        p=0\n        for i in range(len(tree)):\n            l=[]\n            k=0\n            for j in range(i,len(tree)):\n                if(tree[j] not in l):\n                    l.append(tree[j])\n                    k+=1\n                else:\n                    k+=1\n                #print(l)\n                if(len(l)>2):\n                    k=k-1\n                    break\n               \n            if(k>p):\n                p=k\n            if(p==len(tree)):\n                break;\n        return p\n                    \n                    \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        max_count = 0\n        tree_len = len(tree)\n        if len(tree) == 1:\n            return 1\n        if len(set(tree)) in (1,2):\n            return len(tree)\n        for i in range(tree_len - 1):\n            tree_set = set()\n            tree_set.add(tree[i])\n            count = 1\n            for j in range(i+1, tree_len):\n                if tree[j] not in tree_set and len(tree_set) == 2:\n                    break\n                tree_set.add(tree[j])\n                count += 1\n            max_count = max(max_count, count)\n        return max_count\n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        blocks = [(k, len(list(v)))\n                  for k, v in itertools.groupby(tree)]\n\n        ans = i = 0\n        while i < len(blocks):\n            # We'll start our scan at block[i].\n            # types : the different values of tree[i] seen\n            # weight : the total number of trees represented\n            #          by blocks under consideration\n            types, weight = set(), 0\n\n            # For each block from i and going forward,\n            for j in range(i, len(blocks)):\n                # Add each block to consideration\n                types.add(blocks[j][0])\n                weight += blocks[j][1]\n\n                # If we have 3 types, this is not a legal subarray\n                if len(types) >= 3:\n                    i = j-1\n                    break\n\n                ans = max(ans, weight)\n\n            # If we go to the last block, then stop\n            else:\n                break\n\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        st = c = res = 0\n        dic = dict()\n        for end in range(len(tree)):\n            if tree[end] in dic:\n                dic[tree[end]] += 1\n            else:\n                dic[tree[end]] = 1\n                c += 1\n            while c > 2:\n                dic[tree[st]] -= 1\n                if dic[tree[st]] == 0: \n                    del dic[tree[st]]\n                    c -= 1\n                st+=1\n            res = max(res,end-st+1)\n        return res\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        insp = {}\n        pos = {}\n        mxx = -1\n        i = 0\n        while i < len(tree):\n            f = tree[i]\n            if f not in insp and len(insp) == 2:\n                mnn = math.inf\n                tod = None\n                for of, op in list(pos.items()):\n                    mnn = min(mnn, op)\n                    if mnn == op:\n                        tod = of\n                k = pos[tod]\n                while k >= 0:\n                    of = tree[k]\n                    if of not in pos:\n                        break\n                    insp[of] -= 1\n                    k -= 1\n                        \n                del pos[tod]\n                del insp[tod]\n                insp[f] = 0\n            elif f not in insp:\n                insp[f] = 0\n            \n            pos[f] = i\n            insp[f] += 1\n            score =  self.get_basketsize(insp)\n            mxx = max(mxx,score)\n            i += 1\n            \n        return mxx\n          \n    def get_basketsize(self, insp):\n        mxx = 0\n        nmxx = 0\n        for f,ct in list(insp.items()):\n            if ct >= mxx:\n                nmxx = max(mxx, nmxx)\n                mxx = max(ct, mxx)\n            elif ct >= nmxx:\n                nmxx = max(ct, nmxx)\n        return mxx + nmxx\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        counter = collections.Counter()\n        \n        l = r = 0\n        res = 0\n        while r < len(tree):\n            counter[tree[r]] += 1\n            while len(counter.keys()) > 2:\n                counter[tree[l]] -= 1\n                if counter[tree[l]] == 0:\n                    del counter[tree[l]]\n                l += 1\n            res = max(res, sum(counter.values()))\n            r += 1\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        start = end = disFruits = curTotal = maxTotal = 0\n        fruits = {}\n        while end < len(tree):\n            curFruit = tree[end]\n            frontFruit = tree[start]\n            if curFruit not in fruits and disFruits == 2:\n                if fruits[frontFruit] == 1:\n                    del fruits[frontFruit]\n                    disFruits -= 1\n                else:\n                    fruits[frontFruit] -= 1\n                curTotal -= 1\n                start += 1\n            else:\n                curFruit = tree[end]\n                if curFruit not in fruits:\n                    fruits[curFruit] = 1\n                    disFruits += 1\n                else:\n                    fruits[curFruit] += 1\n                curTotal += 1\n                maxTotal = max(curTotal, maxTotal)\n                end += 1\n        return maxTotal\n                        \n            \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) == 1:\n            return 1\n        start = last1 = last2 = 0\n        res = 1\n        for i in range(1, len(tree)):\n            if tree[i] == tree[last1]:\n                last1 = i\n            elif tree[i] == tree[last2]:\n                last2 = i\n            elif tree[last1] == tree[last2]:\n                last1 = max(last1, last2)\n                last2 = i\n            else:\n                start = min(last1, last2)+1\n                if last1 < last2:\n                    last1 = i\n                else:\n                    last2 = i\n            res = max(res, i-start+1)\n        return res\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n           \n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        def pick(start, end):\n            res = 0\n            fruitType = set()\n            \n            for i in range(start, end):\n                fruit  = tree[i]\n                if fruit not in fruitType and len(fruitType) >= 2:\n                    return res\n                \n                fruitType.add(fruit)\n                res += 1\n            \n            return res\n        \n        ##Main\n        n = len(tree)\n        cnt = Counter(tree)\n        if len(cnt) <= 2:\n            return n\n        \n        maxFruit = 0\n        for i in range(n):\n            maxFruit = max(maxFruit, pick(i, n))\n            \n        return maxFruit", "from collections import defaultdict\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        counter = {}\n        longest = 0\n        fruits = 0\n        i = 0\n        for j in range(len(tree)):\n            if tree[j] not in counter:\n                fruits += 1\n                counter[tree[j]] = 0\n            counter[tree[j]] += 1\n            while fruits > 2:\n                counter[tree[i]] -= 1\n                if counter[tree[i]] == 0:\n                    fruits -= 1\n                    del counter[tree[i]]\n                i += 1\n            longest = max(longest, j-i+1)\n        return longest", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if(len(tree)==1):\n            return 1\n        if(not tree):\n            return 0\n        i = 0\n        j = 1\n        l=len(tree)\n        ans=0\n        found = False\n        second = tree[1]\n        count = 1\n        while(i<l and j<l):\n            if(tree[i]!=tree[j] and not found):\n                second=tree[j]\n                found=True\n            if(found and tree[j]!=second and tree[j]!=tree[i]):\n                ans=max(ans,count)\n                count=0\n                i+=1\n                j=i\n                found=False\n            j+=1\n            count+=1\n        ans=max(ans, count)\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        fruit_dict = collections.defaultdict(int)\n        j,result,count=0,0,0\n        for i,t in enumerate(tree):\n            fruit_dict[t]+=1\n            count+=1\n            while len(fruit_dict)>2 and j<len(tree):\n                fruit_dict[tree[j]]-=1\n                count-=1\n                if fruit_dict[tree[j]]==0:\n                    del fruit_dict[tree[j]]\n                j+=1\n            if len(fruit_dict)<=2:\n                result = max(result,count)\n        return result\n        '''\n        blocks = [(k,len(list(v))) for k,v in itertools.groupby(tree)]\n        i,result=0,0\n        \n        while i<len(blocks):\n            j=i\n            count=0\n            fruit_set = set()\n            while j<len(blocks):\n                fruit_set.add(blocks[j][0])\n                count+=blocks[j][1]\n                if len(fruit_set)>2:\n                    i=j-1\n                    break\n                result=max(result,count)\n                j+=1\n            else:\n                break\n            \n        return result\n        '''", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        '''\n        fruit_dict = collections.defaultdict(int)\n        j,result,count=0,0,0\n        for i,t in enumerate(tree):\n            fruit_dict[t]+=1\n            count+=1\n            while len(fruit_dict)>2 and j<len(tree):\n                fruit_dict[tree[j]]-=1\n                count-=1\n                if fruit_dict[tree[j]]==0:\n                    del fruit_dict[tree[j]]\n                j+=1\n            if len(fruit_dict)==2:\n                result = max(result,count)\n        return result\n        '''\n        blocks = [(k,len(list(v))) for k,v in itertools.groupby(tree)]\n        i,result=0,0\n        \n        while i<len(blocks):\n            j=i\n            count=0\n            fruit_set = set()\n            while j<len(blocks):\n                fruit_set.add(blocks[j][0])\n                count+=blocks[j][1]\n                if len(fruit_set)>2:\n                    i=j-1\n                    break\n                result=max(result,count)\n                j+=1\n            else:\n                break\n            \n        return result\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        count = collections.Counter()\n        \n        j = res = 0\n        \n        for i in range(len(tree)):\n            count[tree[i]] += 1\n            \n            while len(count) > 2:\n                count[tree[j]] -= 1\n                if count[tree[j]] == 0:\n                    del count[tree[j]]\n                j += 1\n            \n            res = max(res, sum(count.values()))\n        return res\n            \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res=[]\n        ind=0\n        if len(tree)==1:\n            return 1\n        if len(set(tree))<=2:\n            return len(tree)\n        while ind<len(tree)-1:\n            count=0\n            types=set()\n            for i in range(ind,len(tree)):\n                types.add(tree[i])\n                if len(types)>2:\n                    break\n                count+=1\n            res.append(count)\n            ind+=1\n        return max(res)", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n#         winstart=0\n#         maxlen=0\n#         for winend in range(len(tree)+1):\n#             while(len(set(tree[winstart:winend])))>=3:\n#                 winstart+=1\n#             maxlen=max(maxlen,winend - winstart)\n            \n#         return maxlen\n                \n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        grp = []\n        x, y = tree[0], 1\n        for e in tree[1:]:\n            if e==x:\n                y+=1\n            else:\n                grp.append((x,y))\n                x, y = e, 1\n        grp.append((x,y))\n        \n        ret = 0\n        pair, pair_sum = [], 0\n        for i in range(len(grp)):\n            x, y = grp[i]\n            if x in pair:\n                pair_sum += y\n            else:\n                if len(pair)<2:\n                    pair = pair + [x]\n                    pair_sum += y\n                else:\n                    pair = [grp[i-1][0]] + [x]\n                    pair_sum = grp[i-1][1] + y\n            # print(pair)\n            # print(pair_sum)\n            # print('***')\n            ret = max(ret, pair_sum)\n        return ret\n            \n            \n", "from collections import defaultdict\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # freq = defaultdict(int)\n        # freq[2] += 1\n        # ftypes = set()\n        # ftypes.add(2)\n        \n        if not tree:\n            return 0\n        \n        freq, ftypes, ans, i = defaultdict(int), set(), float('-inf'), 0\n        \n        for j, num in enumerate(tree):\n            freq[num] += 1\n            ftypes.add(num)\n            \n            while len(ftypes) > 2:\n                freq[tree[i]] -= 1\n                if freq[tree[i]] == 0:\n                    ftypes.remove(tree[i])\n                i += 1\n            \n            ans = max(ans, j - i + 1)\n            j += 1\n            \n        return ans", "import collections\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res=i=0\n        count=Counter()\n        for j, k in enumerate(tree):\n            count[tree[j]] +=1\n            while len(count)>=3:\n                count[tree[i]] -= 1\n                if count[tree[i]]==0:\n                    del count[tree[i]]\n                i +=1\n            res=max(res, j-i+1)\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i, j = 0, 0\n        \n        max_fruit = 0\n        baskets = defaultdict(int)\n        while j <= len(tree) and i < len(tree):\n            #print(i, j, baskets)\n            if j < len(tree) and len(set(list(baskets.keys()) + [tree[j]])) <= 2:\n                baskets[tree[j]] += 1\n                j += 1\n            else:\n                baskets[tree[i]] -= 1\n                if baskets[tree[i]] == 0:\n                    baskets.pop(tree[i])\n                i += 1\n            max_fruit = max(sum(baskets.values()), max_fruit)\n        return max_fruit\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i = 0\n        maxCol = 0\n        baskets = [0,0]\n        while i < len(tree) and maxCol + i < len(tree):\n\n            baskets[0] = tree[i]\n            j = i +1\n            basket1Empty = True\n            while j< len(tree):\n                if tree[j] != baskets[0] and basket1Empty:\n                    baskets[1] = tree[j]\n                    basket1Empty = False\n\n                elif tree[j] != baskets[0] and tree[j] != baskets[1]:\n                    col = j-i\n                    if col > maxCol:\n                        maxCol = col\n                    break\n\n\n                j +=1\n            col = j-i\n            if col > maxCol:\n                maxCol = col\n\n\n            i += 1\n\n        return maxCol\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) == 0:\n            return 0\n        types = {}\n        numFruits = 0\n        maxNumFruits = 0\n        left = 0\n        right = 0\n        while(right < len(tree)):\n            if tree[right] in types:\n                types[tree[right]] += 1\n            else:\n                types[tree[right]] = 1\n            numFruits += 1\n            right += 1\n            \n            while len(types) > 2:\n                if types[tree[left]] == 1:\n                    del(types[tree[left]])\n                else:\n                    types[tree[left]] -= 1\n                left += 1\n                numFruits -= 1\n            maxNumFruits = max(maxNumFruits, numFruits)\n            \n            \n        return maxNumFruits\n                    \n                \n            \n\n            \n                \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree)<=2: return len(tree)\n        \n        n = len(tree)\n        res,l = 0,0\n        while l<n:\n            type1, type2 = -1, -1\n            next_l = -1 # this denote where we should place l in next subarray\n            for r in range(l,n):\n                if type1==-1:\n                    type1 = tree[r]\n                elif tree[r]!=type1 and type2==-1:\n                    next_l = r\n                    type2 = tree[r]\n                elif tree[r] != type1 and tree[r] != type2:\n                    break\n                r += 1\n            res = max(res, r-l)\n            if r==n: break\n            l = next_l\n        return res\n                            \n            \n        \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        hMap = {}\n        if not tree:\n            return 0\n            \n        maxCount = 0\n        count = 0\n        for i in range(len(tree)):\n            hMap[tree[i]] = i\n            \n            if len(hMap) <= 2:\n                count += 1\n                maxCount = max(count, maxCount)\n            else:\n                j = sys.maxsize\n                r = None\n                for k in hMap:\n                    if hMap[k] < j:\n                        r = k\n                        j = hMap[k]\n                hMap.pop(r, None)\n                count = i - j\n                \n            # print(tree[i], hMap, count, maxCount)\n                \n        return maxCount", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        counter = {}\n        start = 0\n        maxL = 0\n        for end in range(len(tree)):\n            if tree[end] in counter:\n                counter[tree[end]] += 1\n            else:\n                counter[tree[end]] = 1\n            while (len(counter) > 2):\n                counter[tree[start]] -= 1\n                if counter[tree[start]] == 0:\n                    del counter[tree[start]]\n                start += 1\n            maxL = max(maxL, end - start + 1)\n        \n        return maxL", "class Solution:\n    def totalFruit(self, f: List[int]) -> int:\n        start, count, maxFruits = 0,0,0 \n        fruitHash = defaultdict(int)\n\n        for end in range(len(f)):\n            if fruitHash[f[end]] == 0:\n                count += 1\n            fruitHash[f[end]] += 1\n\n            if count <= 2:\n                maxFruits = max(maxFruits, end-start+1)\n\n            while count > 2:\n                fruitHash[f[start]] -= 1\n                start += 1\n                if fruitHash[f[start-1]] == 0:\n                    count -= 1\n                    maxFruits = max(maxFruits, end-start+1)\n        return maxFruits", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        max_len = 0\n        start = end = 0\n        N = len(tree)\n        count = 0\n        uniq = {}\n        \n        while end < N:\n            cur = tree[end]\n            if cur not in uniq:\n                uniq[cur] = 0\n            \n            uniq[cur] += 1\n            if uniq[cur] == 1:\n                count += 1\n            \n            while count > 2:\n                rem = tree[start]\n                uniq[rem] -= 1\n                if uniq[rem] == 0:\n                    count -= 1\n                start += 1\n            \n            max_len = max(max_len, end - start + 1)\n            end += 1\n            \n        return max_len\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        k = 2\n        \n        start = 0\n        \n        freqHashmap = {}\n        \n        maxFruit = 0\n        \n        for end in range(len(tree)):\n            freqHashmap[tree[end]] = freqHashmap.get(tree[end], 0) + 1\n            \n            while len(freqHashmap) > k:\n                freqHashmap[tree[start]] -= 1\n                \n                if freqHashmap[tree[start]] == 0:\n                    del freqHashmap[tree[start]]\n                \n                start += 1\n            \n            maxFruit = max(maxFruit, end - start + 1)\n        \n        return maxFruit", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # \u5305\u542b\u4e24\u4e2a\u5143\u7d20\u7684\uff08\u56e0\u4e3a\u9898\u76ee\u8bf4\u662f\u4e24\u4e2a\u7bee\u5b50\uff09\u7684\u6700\u957f\u5b50\u5e8f\u5217\uff0c\u91c7\u82f9\u679c\u4e0d\u80fd\u540e\u9000\u4e5f\u4e0d\u80fd\u8df3\u8fc7\uff0c\u6240\u4ee5\u5c31\u662f\u8fde\u7eed\u5b50\u4e32,\u91c7\u7684\u82f9\u679c\u4e2a\u6570\u5c31\u6307\u7684\u662f\u5b50\u4e32\u957f\u5ea6\n        # \u8ddf\u4e4b\u524d\u7684\u9898\u76ee\u4e00\u6a21\u4e00\u6837\n        \n        k = 2\n        n = len(tree)\n        if n < k:\n            return n\n        \n        i = 0\n        lookup = {}\n        ans = 0\n        # 1\uff09\u6709\u65f6\u5019\u4f1a\u6655\u662f\u627e\u5230\u5b57\u5178\u4e2d\u7684\u6700\u5c0f\u4e0b\u6807\uff0c\u8fd8\u662f\u627e\u5230\u5b57\u5178\u4e2d\u7684\u91cd\u590d\u4e0b\u6807\n        # 2\uff09\u56e0\u4e3a\u8fd9\u91cc\u5e76\u4e0d\u662f\u56e0\u4e3a\u51fa\u73b0\u91cd\u590d\u7684key\u800c\u9700\u8981\u79fb\u52a8\u5de6\u6307\u9488\uff0c\u800c\u662f\u56e0\u4e3a\u5b57\u5178\u91cc\u5143\u7d20\u592a\u591a\u4e86\u800c\u8981\u79fb\u52a8\u5de6\u6307\u9488\n        # 3\uff09\u8981\u627e\u5230\u91cd\u590d\u4e86\u7684key\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5728\u63d2\u5165\u4e4b\u524d\u53bb\u5224\u65ad, \u9047\u5230\u91cd\u590d\u7684\u952e\u503ci = max(i, 1+lookUp[nums[j]])\n        # 4\uff09\u5b57\u5178\u957f\u5ea6\u8d85\u6807\uff0c\u4e0d\u6015\u91cd\u590d\uff0c\u56e0\u4e3a\u91cd\u590d\u7684\u5f55\u5165\u540c\u4e00\u4e2a\u952e\u503c\u4e00\u76f4\u8bb0\u5f55\u7684\u8be5key\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\n        #    4.1\uff09i_min = min(lookup.values()), \u53e6 i= i_min+1, \u4e4b\u6240\u4ee5\u8981\u4e00\u4e2a\u4e2d\u95f4\u53d8\u91cfi_min\uff0c\u662f\u56e0\u4e3a\u540e\u9762\u8981\u7528\u5b83\u53bb\u5220\u9664\u952e\u503c\n        #    4.2\uff09\u540c\u65f6\u5220\u9664\u8fd9\u4e2akey\uff0c\u5426\u5219\u4f60\u6bcf\u6b21\u53d6min\u90fd\u4f1a\u627e\u5230\u8fd9\u4e2a\u6570\u61c2\u5417\n        for j in range(n):\n            lookup[tree[j]] = j\n            if len(lookup) <= k:\n                ans = max(ans, j-i+1)\n            else:\n                i_min = min(lookup.values())\n                del lookup[tree[i_min]]\n                i = i_min + 1\n                \n        return ans\n                \n            \n            \n", "class Solution:\n    def totalFruit(self, tree):\n        res = cur = count_b = a = b = 0\n        for c in tree:\n            cur = cur + 1 if c in (a, b) else count_b + 1\n            count_b = count_b + 1 if c == b else 1\n            if b != c: a, b = b, c\n            res = max(res, cur)\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # \u5305\u542b\u4e24\u4e2a\u5143\u7d20\u7684\uff08\u56e0\u4e3a\u9898\u76ee\u8bf4\u662f\u4e24\u4e2a\u7bee\u5b50\uff09\u7684\u6700\u957f\u5b50\u5e8f\u5217\uff0c\u91c7\u82f9\u679c\u4e0d\u80fd\u540e\u9000\u4e5f\u4e0d\u80fd\u8df3\u8fc7\uff0c\u6240\u4ee5\u5c31\u662f\u8fde\u7eed\u5b50\u4e32,\u91c7\u7684\u82f9\u679c\u4e2a\u6570\u5c31\u6307\u7684\u662f\u5b50\u4e32\u957f\u5ea6\n        # \u8ddf\u4e4b\u524d\u7684\u9898\u76ee\u4e00\u6a21\u4e00\u6837\n        \n        k = 2\n        n = len(tree)\n        if n < k:\n            return n\n        \n        i = 0\n        lookup = {}\n        ans = 0\n        # 1\uff09\u6709\u65f6\u5019\u4f1a\u6655\u662f\u627e\u5230\u5b57\u5178\u4e2d\u7684\u6700\u5c0f\u4e0b\u6807\uff0c\u8fd8\u662f\u627e\u5230\u5b57\u5178\u4e2d\u7684\u91cd\u590d\u4e0b\u6807\n        # 2\uff09\u56e0\u4e3a\u8fd9\u91cc\u5e76\u4e0d\u662f\u56e0\u4e3a\u51fa\u73b0\u91cd\u590d\u7684key\u800c\u9700\u8981\u79fb\u52a8\u5de6\u6307\u9488\uff0c\u800c\u662f\u56e0\u4e3a\u5b57\u5178\u91cc\u5143\u7d20\u592a\u591a\u4e86\u800c\u8981\u79fb\u52a8\u5de6\u6307\u9488\n        # 3\uff09\u8981\u627e\u5230\u91cd\u590d\u4e86\u7684key\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5728\u63d2\u5165\u4e4b\u524d\u53bb\u5224\u65ad, \u9047\u5230\u91cd\u590d\u7684\u952e\u503ci = max(i, 1+lookUp[nums[j]])\n        # 4\uff09\u5b57\u5178\u957f\u5ea6\u8d85\u6807\uff0c\u4e0d\u6015\u91cd\u590d\uff0c\u56e0\u4e3a\u91cd\u590d\u7684\u5f55\u5165\u540c\u4e00\u4e2a\u952e\u503c\u4e00\u76f4\u8bb0\u5f55\u7684\u8be5key\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\n        #    4.1\uff09i_min = min(lookup.values()), \u53e6 i= i_min+1, \u4e4b\u6240\u4ee5\u8981\u4e00\u4e2a\u4e2d\u95f4\u53d8\u91cfi_min\uff0c\u662f\u56e0\u4e3a\u540e\u9762\u8981\u7528\u5b83\u53bb\u5220\u9664\u952e\u503c\n        #    4.2\uff09\u540c\u65f6\u5220\u9664\u8fd9\u4e2akey\uff0c\u5426\u5219\u4f60\u6bcf\u6b21\u53d6min\u90fd\u4f1a\u627e\u5230\u8fd9\u4e2a\u6570\u61c2\u5417\n        for j in range(n):\n            lookup[tree[j]] = j\n            if len(lookup) > k:\n                i_min = min(lookup.values())\n                del lookup[tree[i_min]]\n                i = i_min + 1\n            ans = max(ans, j-i+1)\n                \n        return ans\n                \n            \n            \n", "class Solution:\n    def totalFruit(self, tree) -> int:\n        if len(tree) < 3:\n            return len(tree)\n        seq_len = [[tree[0], 0]]\n        for f in tree:\n            if seq_len[-1][0] == f:\n                seq_len[-1][1] += 1\n            else:\n                seq_len.append([f, 1])\n        most = seq_len[0][1]\n        if len(seq_len) > 1:\n            curr_two_types = set([seq_len[0][0], seq_len[1][0]])\n            most = curr_most = seq_len[0][1] + seq_len[1][1]\n            for i in range(2, len(seq_len)):\n                if seq_len[i][0] in curr_two_types:\n                    curr_most += seq_len[i][1]\n                else:\n                    curr_most = seq_len[i][1] + seq_len[i-1][1]\n                    curr_two_types = set([seq_len[i][0], seq_len[i-1][0]])\n                most = max(most, curr_most)\n        return most", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        '''\n        Sliding window: the window can at most only have two distinct numbers\n        Find the longest sliding window\n        Technique: keep the last seen index of each fruit type in my current sliding window\n        seen: { x: i, y: j }\n        Whenever a new type of fruit is ahead, fast forward the left boundary to min(i,j) + 1\n        '''\n        ans = 0\n        lo, hi = -1, 0\n        seen = {}\n        for hi in range(len(tree)):\n            if tree[hi] not in seen and len(seen) == 2:\n                # tree[hi] is not in seen and seen already has 2 elements\n                remove = (float('inf'), None)\n                for typ in seen:\n                    remove = min(remove, (seen[typ], typ))\n                lo = seen.pop(remove[1])\n            seen[tree[hi]] = hi\n            #print(lo, hi, seen)\n            ans = max(ans, hi-lo)\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        count, i = {}, 0\n        for j, v in enumerate(tree):\n            count[v] = count.get(v, 0) + 1\n            if len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0: del count[tree[i]]\n                i += 1\n        return j - i + 1\n", "class Solution:\n    \n    \n    def totalFruit(self, tree: List[int]) -> int:\n        \n        max_count = pair_count = last_count = 0\n        fruit_1 = fruit_2 = last_fruit = None\n        \n        for fruit_type in tree:\n            if fruit_type == fruit_1:\n                pair_count += 1\n                if fruit_type == last_fruit:\n                    last_count += 1\n                else:\n                    last_fruit = fruit_type\n                    last_count = 1\n            elif fruit_type == fruit_2:\n                pair_count += 1\n                if fruit_type == last_fruit:\n                    last_count += 1\n                else:\n                    last_fruit = fruit_type\n                    last_count = 1\n            elif fruit_1 == None:\n                fruit_1 = last_fruit = fruit_type\n                last_count = 1\n                pair_count += 1\n            elif fruit_2 == None:\n                fruit_2 = last_fruit = fruit_type\n                last_count = 1\n                pair_count += 1\n            else:\n                fruit_1 = last_fruit\n                fruit_2 = last_fruit = fruit_type\n                max_count = max(max_count, pair_count)\n                pair_count = last_count+1\n                last_count = 1\n        \n        return max(max_count, pair_count)", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans=0\n        past=[]\n        last=[]\n        for i in range(len(tree)):\n            #print(past,last)\n            if len(past)==0:\n                past.append(tree[i])\n                last.append(i)\n                ans=max((i-last[0]+1),ans)\n                continue\n            if len(past)==1:\n                if tree[i] not in past:\n                    past.append(tree[i])\n                    last.append(i)\n                ans=max((i-last[0]+1),ans)\n                continue\n            if tree[i] not in past:\n                bt=i-1\n                ele=tree[bt]\n                while tree[bt]==ele:\n                    bt-=1\n                bt+=1\n                past=[tree[bt],tree[i]]\n                last=[bt,i]\n            ans=max((i-last[0]+1),ans)\n        return ans\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        n = len(tree)\n        \n        if n < 3:\n            return n\n        \n        max_count = 0\n\n        set_1 = {tree[0]}\n        count_1 = 1\n        set_2 = set_1.copy()\n        count_2 = 1\n        \n        \n        for i in range(1, n):\n            if tree[i] in set_2:\n                count_2 += 1\n            else:\n                temp = set_1.copy()\n                temp.add(tree[i])\n                set_2 = temp\n                count_2 = count_1 + 1\n            if tree[i] in set_1:\n                count_1 += 1\n            else:\n                set_1 = {tree[i]}\n                count_1 = 1\n                \n            max_count = max(max_count, max(count_1, count_2))\n            \n            \n        return max_count\n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        l = 0\n        count = {}\n        \n        for r, value in enumerate(tree):\n            count[value] = count.get(value,0)+1\n            if len(count) > 2:\n                count[tree[l]] -= 1\n                if count[tree[l]] == 0:\n                    del count[tree[l]]\n                l += 1\n                \n        return r-l+1", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res, start, distince_count, visited = 0, 0, 0, [0] * len(tree)\n        for i, c in enumerate(tree):\n            if visited[c] == 0:\n                distince_count += 1\n            visited[c] += 1\n\n            while distince_count > 2:\n                visited[tree[start]] -= 1\n                if visited[tree[start]] == 0:\n                    distince_count -= 1\n\n                start += 1\n\n            res = max(res, i - start + 1)\n\n        return res\n\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        res = cur = count_b = a = b = 0\n        for c in tree:\n            cur = cur + 1 if c in (a, b) else count_b + 1\n            count_b = count_b + 1 if c == b else 1\n            if b != c: a, b = b, c\n            res = max(res, cur)\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        '''\n        \u884c\u4e0d\u901a\u7684 example4\u5c31\u4e0d\u6ee1\u8db3\n        #\u6700\u957f\u7684bi-value subarray\n        #\u8bb0\u5f55\u5230i\u5904\u4e00\u5171\u51e0\u79cd\u6570\u51fa\u73b0\uff0c\u4e24\u4e2a\u51cf\u51fa\u6765=2\u610f\u5473\u7740\u4e2d\u95f4\u53ea\u6709\u4e24\u79cd\u3002subarray\u6807\u51c6\u5957\u8def.\n        from collections import Counter\n        n = len(tree)\n        record = []\n        \n        for i in range(n):\n            a = len(Counter(tree[:i+1]))\n            record.append(a)\n        print(record)\n        dic = {}\n        ans = 0\n        dic[0] = [-1,-1] #\u8bb0\u5f55\u7b2c\u4e00\u6b21\u51fa\u73b0\u548c\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\n        for i in range(n):\n            if record[i] not in dic.keys():\n                dic[record[i]] = [i,i]\n            else:\n                dic[record[i]][1] = i\n            \n            if record[i]-2 in dic.keys():\n                print(i,dic[record[i]],dic[record[i]-2])\n                ans = max(ans,dic[record[i]][1]-dic[record[i]-2][1])\n                print('ans=',ans)\n            \n        \n        return ans\n        '''\n        #sliding  window, two pointers:x,i\n        n = len(tree)\n        dic = {}\n        x = 0\n        for i in range(n):\n            if tree[i] not in dic.keys():\n                dic[tree[i]] = 1\n            else:\n                dic[tree[i]] += 1\n            \n            if len(dic) > 2:\n                dic[tree[x]] -= 1\n                if dic[tree[x]]==0 :\n                    del dic[tree[x]]\n                x +=1\n        return i-x+1", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        deq = []\n        currentTwo = set()\n        result = 0\n        temp = 0\n        for e in tree:\n            if len(deq) == 0:\n                currentTwo.add(e)\n                deq.append((e, 1))\n                temp = 1\n            elif e in currentTwo:\n                if e == deq[-1][0]:\n                    deq[-1] = (e, deq[-1][1]+1)\n                    temp += 1\n                else:\n                    deq.append((e,1))\n                    temp += 1\n            else:\n                previousOne = deq[-1][0]\n                currentTwo = set([previousOne, e])\n                deq = deq[-1:]\n                temp = deq[-1][1]\n                deq.append((e, 1))\n                temp += 1\n\n            result = max(result, temp)\n\n        return result\n        \n", "class Solution:\n    def totalFruit(self, tree) -> int:\n        if len(tree) < 3:\n            return len(tree)\n\n        # i = 0\n        # while i < len(tree) and tree[i] == tree[0]:\n        #     i += 1\n        # if i == len(tree):\n        #     return i\n        # most_fruit = i + 1\n        # first_type, f_counter = tree[0], i\n        # second_type, s_counter = tree[i], 1\n\n        seq_len = [[tree[0], 0]]\n        for f in tree:\n            if seq_len[-1][0] == f:\n                seq_len[-1][1] += 1\n            else:\n                seq_len.append([f, 1])\n        most = curr_most = seq_len[0][1]\n        # print(seq_len)\n        if len(seq_len) > 1:\n            curr_two_types = set([seq_len[0][0], seq_len[1][0]])\n            most = curr_most = seq_len[0][1] + seq_len[1][1]\n            for i in range(2, len(seq_len)):\n                if seq_len[i][0] in curr_two_types:\n                    curr_most += seq_len[i][1]\n                else:\n                    curr_most = seq_len[i][1] + seq_len[i-1][1]\n                    curr_two_types = set([seq_len[i][0], seq_len[i-1][0]])\n                most = max(most, curr_most)\n                # print(\\\"---\\\", most)\n        return most", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        letter_count = collections.defaultdict(int)\n        left, right = 0, 0\n\n        while right < len(tree):\n            letter_count[tree[right]] += 1\n            right += 1\n\n            if len(letter_count) > 2:\n                letter_count[tree[left]] -= 1\n                if letter_count[tree[left]] == 0:\n                    del letter_count[tree[left]]\n                left += 1\n\n        return right - left\n", "class Solution:\n    def totalFruit(self, tree):\n        ans = cur = one = two = count_one = count_two = 0\n        for i in tree:\n            if i not in (one, two):\n                cur = count_two + 1\n            else:\n                cur += 1\n            if i != two:\n                one, two = two, i\n                count_two = 1\n            else:\n                count_two += 1\n            ans = max(ans, cur)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not len(tree):\n            return 0\n        count_max = 0\n        start = 0\n        f_num = tree[0]\n        tracking = set()\n        tracking.add(f_num)\n        last_change = 0\n        current_num = tree[0]\n        for i in range(1, len(tree)):\n            if tree[i] not in tracking:\n                if len(tracking) >= 2:\n                    count_max = max(i-start, count_max)\n                    tracking.remove(f_num)\n                    tracking.add(tree[i])\n                    f_num = current_num\n                    start = last_change\n                    \n                else:\n                    tracking.add(tree[i])\n            if tree[i] != current_num:\n                last_change = i\n                f_num = current_num\n                current_num = tree[i]\n        count_max = max(len(tree)-start, count_max)\n        return count_max\n\n                \n                \n", "class Solution:\n    # def totalFruit(self, tree):\n    #     # scan the array\n    #     fruit_block = []\n    #     #fruit_block entity = [left_most index in fruit, weight]\n    #     for i in range(len(tree)):\n    #         if i == 0 or tree[i] != tree[i-1]:\n    #             fruit_block.append([i, 1 ])\n    #         elif tree[i] == tree[i-1]:\n    #             fruit_block[-1][1] += 1\n    #     # print(fruit_block)\n    #     max_fruit = 0\n    #     i = 0\n    #     while i < len(fruit_block):\n    #         old_i = i\n    #         type_fruit = []\n    #         weight = 0\n    #         for j in range(i, len(fruit_block)):\n    #             if tree[fruit_block[j][0]] not in type_fruit:\n    #                 type_fruit.append(tree[fruit_block[j][0]])\n    #             weight += fruit_block[j][1]\n    #             # print(\\\"type fruit \\\", type_fruit)\n    #             # print(\\\"weight \\\", weight)\n    #             if len(type_fruit) > 2:\n    #                 # print(\\\"break\\\")\n    #                 i = j -1\n    #                 break\n    #             max_fruit = max(max_fruit, weight)\n    #             if j == len(fruit_block):\n    #                 break\n    #         if i == old_i:\n    #             break\n    #     return max_fruit\n            \n        \n#     def totalFruit(self, tree: List[int]) -> int:\n        \n#         greattest_count = 0\n#         for i in range(len(tree)):\n#             if i > 0 and tree[i] == tree[i-1]:\n#                 print(i)\n#                 continue\n#             if i > 2 and tree[i] == tree[i-2] and tree[i-1] == tree[i-3] and tree[i] != tree[i-1] and self.checkRepeat(tree, i):\n#                 #add function to define tree[i-1] == the newest tree after ones that look like tree[i]\n#                 print(i)\n#                 continue\n#             fruit = self.pickFruit(i, tree)\n#             if fruit > greattest_count:\n#                 greattest_count = fruit\n#         return greattest_count\n                \n#             # print(count)\n#             # print(greattest_count)\n        \n#         return greattest_count\n    \n#     def checkRepeat(self,tree, i):\n#         for j in range(i, len(tree)):\n#             if tree[j] != tree[i]:\n#                 return tree[j]==tree[i-1]\n#         return True\n                \n    \n#     def pickFruit(self, i, tree):\n#         count = 0\n#         basket=[\\\"\\\", \\\"\\\"]\n#         for j in range(i, len(tree)):\n#             if basket[0] == \\\"\\\":\n#                 basket[0] = tree[j]\n#                 # print(\\\"basket1: \\\", basket[0])\n#                 count += 1\n#                 # print(\\\"basket1\\\")\n#             elif tree[j] == basket[0]:\n#                 count+=1\n#                 # print(\\\"already in basket1\\\")\n#             elif basket[1] == \\\"\\\":\n#                 basket[1] = tree[j]\n#                 count += 1\n#                 # print(\\\"basket2: \\\", basket[1])\n#             elif tree[j] == basket[1]:\n#                 count += 1\n#                 # print(\\\"already in basket2\\\")\n#             elif tree[j] not in basket:\n#                 return count\n#             if j == len(tree)-1:\n#                 return count\n\n    def totalFruit(self, tree: List[int]) -> int:\n        basket1 = -1\n        basket2 = -1\n        max_fruit = 0\n        start = 0\n        end = 0\n        i = 0\n        while i < len(tree):\n            if tree[i] == basket1 or tree[i] == basket2:\n                if tree[i] != tree[i-1]:\n                    end = i\n                i += 1\n                continue\n            if basket1 == -1:\n                basket1 = tree[i]\n                end = i\n                i += 1\n                continue\n            if basket2 == -1:\n                basket2 = tree[i]\n                end = i\n                i += 1\n                continue\n            print(i)\n            print(end)\n            weight = i - start \n            max_fruit = max(max_fruit, weight)\n            #max_fruit = 2 - 0 = 2\n            i = end # 1\n            start = end # 1\n            basket1 = -1\n            basket2 = -1\n        # if start == 0:\n        #     weight = len(tree)\n        # else:\n        #     weight = len(tree) - start - 1\n        weight = len(tree) - start\n            \n        \n        max_fruit = max(max_fruit, weight)\n            \n        return max_fruit", "class Solution:\n    def totalFruit(self, t: List[int]) -> int:\n        st,a,b,a_hi,res,b_hi = 0,t[0],-1,0,0,0\n        for i,v in enumerate(t):\n            if v != a and b == -1:\n                b = v\n                b_hi = i\n            elif v == a:\n                a_hi = i\n            elif v == b:\n                b_hi = i\n            elif v not in (a,b):\n                res = max(res,i-st)\n                st_m = min(a_hi,b_hi)\n                a,b,st,a_hi,b_hi = t[st_m+1],v,st_m+1,max(a_hi,b_hi),i\n        return max(res,len(t)-st)\n\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        dic = {}\n        i = 0\n        j = 0\n        MAX = 1\n        \n        if tree == None or len(tree) == 0:\n            return None\n        \n        while j < len(tree):\n            if len(dic) <= 2:\n                dic[tree[j]] = j\n                j+=1\n            if len(dic) > 2:\n                mins = len(tree) -1\n                \n                for val in list(dic.values()):\n                    mins = min(mins,val)\n                \n                i = mins + 1\n                del dic[tree[mins]]\n            \n            MAX = max(MAX,j-i)\n        return MAX\n            \n                              \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not tree:\n            return 0\n        l = 0\n        mp = collections.defaultdict(int)\n        fruits = 1\n        for i in range(0, len(tree)):\n            mp[tree[i]] += 1\n            while len(mp) > 2:\n                mp[tree[l]] -= 1\n                if mp[tree[l]] == 0:\n                    del mp[tree[l]]\n                l += 1\n            fruits = max(fruits, i-l+1)\n        return fruits\n            \n                \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left = 0\n        right = 0\n        window = set()\n        res = 0\n        last_index = collections.defaultdict(int)\n        \n        for right in range(len(tree)):\n            fruit_type = tree[right]\n            last_index[fruit_type] = right\n            if tree[right] in window or len(window) < 2:\n                window.add(tree[right])\n            else:\n                window.add(tree[right])\n                while len(window) > 2:\n                    fruit_type = tree[left]\n                    if left == last_index[fruit_type]:\n                        window.remove(fruit_type)\n                    left += 1\n            res = max(res, right - left + 1)\n        return res\n", "# longest run that only contains two symbols?\n# 6:52 -> 7:01 TLE on naive n^2 solution\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        counts = 0\n        starts = {}\n        start = end = 0\n        longest = 0\n        \n        def find_earliest(starts):\n            earliest = len(tree)\n            for key in starts:\n                earliest = min(starts[key], earliest)\n            return earliest\n        \n        while end < len(tree):\n            # print(start, end, starts)\n            current = tree[end]\n            if current in starts:\n                starts[current] = end\n                end += 1\n            else:\n                if counts == 2:\n                    earliest = find_earliest(starts)\n                    del starts[tree[earliest]]\n                    start = earliest + 1\n                    counts -= 1\n                else:\n                    starts[current] = end\n                    counts += 1\n                    end += 1\n            longest = max(end - start, longest)\n        \n        return max(end - start, longest)\n        \n        \n#         longest = 0\n        \n#         def contains_two_symbols(subarray):\n#             c = Counter(subarray)\n#             contains = 0\n#             for key in c:\n#                 if c[key]:\n#                     contains += 1\n#             return contains < 3\n            \n#         for i in range(len(tree)):\n#             for j in range(i + 1, len(tree) + 1):\n#                 if contains_two_symbols(tree[i:j]):\n#                     longest = max(longest, j - i)\n        \n#         return longest\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        count = collections.defaultdict(int)\n        for j, ftype in enumerate(tree):\n            count[ftype] += 1\n            while len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    count.pop(tree[i])\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        # length of the longest subarray containing at most 2 distinct elements\n        if len(tree) == 0: return 0\n        i, j, n_kind, res = 0, 0, 1, 1\n        cnts = [0,] * len(tree)\n        cnts[tree[0]] += 1\n        while True:\n            while n_kind <= 2:\n                res = max(res, j-i+1)\n                j += 1\n                if j >= len(tree): \n                    return res  # ?\n                if cnts[tree[j]] == 0:\n                    n_kind += 1\n                cnts[tree[j]] += 1\n            while n_kind > 2:\n                cnts[tree[i]] -= 1\n                if cnts[tree[i]] == 0:\n                    n_kind -= 1\n                i += 1\n        return res\n", "from collections import deque\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        maxFruits = 0\n        fruitTypes = set()        \n        queue = deque()\n        \n        for i in tree:\n            if i in fruitTypes or len(fruitTypes) < 2:\n                fruitTypes.add(i)\n            else:\n                prevFruit = queue[-1]\n                j = len(queue)-2\n                while j >= 0 and queue[j] == prevFruit:\n                    j -= 1\n                while j >=0:\n                    queue.popleft()\n                    j -= 1\n                for k in list(fruitTypes):\n                    if k == prevFruit:\n                        continue\n                    else:\n                        fruitTypes.remove(k)\n                fruitTypes.add(i)\n            queue.append(i)\n            maxFruits = max(len(queue), maxFruits)\n        return maxFruits\n            \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        l, res, check = 0, 0, dict()\n        for i, t in enumerate(tree):\n            check[t] = check.get(t, 0) + 1\n            if len(check) <= 2:\n                res = max(res, i - l + 1)\n            while len(check) > 2:\n                check[tree[l]] -= 1\n                if check[tree[l]] == 0:\n                    del check[tree[l]]\n                l += 1\n        return res", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) <= 2:\n            return len(tree)\n        collection_list = [tree[0]]\n        counter = 1\n        _max = 1\n        rep = 1\n        for i in range(1, len(tree)):\n            if tree[i] in collection_list:\n                if tree[i] == tree[i-1]:\n                    rep += 1\n                else:\n                    rep = 1\n                counter += 1\n                if counter > _max:\n                    _max = counter\n            else:\n                if len(collection_list) == 1:\n                    collection_list.append(tree[i])\n                    counter += 1\n                    rep = 1\n                    if counter > _max:\n                        _max = counter\n                else:\n                    collection_list = [tree[i-1], tree[i]]\n                    counter = 1 + rep\n                    rep = 1\n        return _max", "from collections import Counter\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        d = collections.defaultdict(int)\n        left = 0 \n        total = 0\n        for idx, i in enumerate(tree):\n            d[i] += 1 \n            while(len(d) > 2):\n                d[tree[left]] -= 1 \n                if(d[tree[left]] == 0):\n                    del d[tree[left]]\n                left += 1 \n                \n            total = max(total, idx - left + 1)\n        return total\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) == 0 or len(tree) == 1:\n            return len(tree);\n        A = [-1]*2\n        B = [-1]*2\n        f1 = -1\n        f2 = -1\n        n = len(tree)\n        maxi = 1\n        i=0\n        while i<n:\n            if tree[i]==f1 or tree[i]==f2:\n                if tree[i]==f1:\n                    A[1]=i\n                else: \n                    B[1]=i\n            else:\n                if tree[i-1]==f1:\n                    f2=tree[i]\n                    A[0]=B[1]+1\n                    B[0]=B[1]=i\n                else:\n                    f1=tree[i]\n                    B[0]=A[1]+1\n                    A[0]=A[1]=i\n                \n            maxi = max(maxi,max(A[1],B[1])-min(A[0],B[0]))\n            i = i+1\n        return maxi+1\n            \n\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        idx, baskets, res = -1, collections.deque(maxlen=2), 0\n        for i, x in enumerate(tree):\n            if x not in [y[0] for y in baskets]:\n                if len(baskets) == 2:\n                    res, idx = max(res, i - idx - 1), baskets[0][1]\n                baskets.append([x, i])\n            else:\n                if x == baskets[0][0]:\n                    baskets.popleft()\n                    baskets.append([x, i])\n                else:\n                    baskets[1][1] = i\n                \n        return max(res, len(tree) - 1 - idx)", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        store = collections.defaultdict(lambda:0)\n        ans = 0\n        i=0\n        for k,val in enumerate(tree):\n            store[val]+=1\n            while len(store)>2:\n                store[tree[i]]-=1\n                if store[tree[i]]==0:\n                    del store[tree[i]]\n                i+=1\n            ans = max(ans,k-i+1)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        f1, f2= [-1,-1],[-1,-1]\n        res, fruit1, fruit2 = 0, -1, -1\n        for i in range(len(tree)):\n            if tree[i] not in [fruit1,fruit2]:   \n                if f2[1]>f1[1]:\n                    f2[0] = f1[1]+1\n                    f1 = [i,i]\n                    fruit1 = tree[i]\n                else:\n                    f1[0] = f2[1]+1\n                    f2 = [i,i]\n                    fruit2 = tree[i]\n            elif tree[i] == fruit1: f1[1] = i\n            else: f2[1] = i\n            res = max(res,max(f1[1],f2[1]) - min(f1[0],f2[0]))\n        return res+1", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        # compress the tree\n        compressedTree = []\n        \n        current = [tree[0], 0]\n        for index in range(len(tree)):\n            fruit = tree[index]\n            if fruit != current[0]:\n                compressedTree.append(current)\n                current = [fruit, 1]\n            else:\n                current[1] += 1\n        compressedTree.append(current)\n        \n        ans = i = 0\n        while i < len(compressedTree):\n            # We'll start our scan at block[i].\n            # types : the different values of tree[i] seen\n            # weight : the total number of trees represented\n            #          by blocks under consideration\n            types, weight = set(), 0\n\n            # For each block from i and going forward,\n            for j in range(i, len(compressedTree)):\n                # Add each block to consideration\n                types.add(compressedTree[j][0])\n                weight += compressedTree[j][1]\n\n                # If we have 3 types, this is not a legal subarray\n                if len(types) >= 3:\n                    i = j-1\n                    break\n\n                ans = max(ans, weight)\n\n            # If we go to the last block, then stop\n            else:\n                break\n\n        return ans", "from collections import defaultdict\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        l, r = 0, 0\n        d = defaultdict(int)\n        res = 0\n        \n        \n        for r in range(len(tree)):\n            d[tree[r]] += 1\n            while len(d) > 2:\n                #print(l)\n                d[tree[l]] -= 1\n                if d[tree[l]] == 0:\n                    d.pop(tree[l])\n                l += 1\n            res = max(res, r - l + 1)\n            #print(r,l)\n        \n        return res\n        \n#         while r < len(tree):\n            \n#             while len(d) <= 2:\n#                 r += 1\n#                 if r < len(tree):\n#                     d[tree[r]] += 1\n#                 else:\n#                     break\n                \n#             if len(d) > 2 or r == len(tree):\n#                 res = max(res, r - l)\n                \n# #            print(\\\"1s\\\", r, l)\n            \n#             while len(d) > 2:\n#                 d[tree[l]] -= 1\n#                 if d[tree[l]] == 0:\n#                     d.pop(tree[l])\n#                 l += 1\n                \n# #            print(\\\"2s\\\", r, l)\n#         return res\n            \n        \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        '''\n            [0,1,2,2]\n            ^\n            \n            [3,3,3,1,2,1,1,2,3,3,4]\n        \n        \n        '''\n        n = len(tree)\n        res = 0\n        \n        window = defaultdict(int)\n        count = 0\n        left =  0\n        \n        for idx in range(n):\n            curr = tree[idx]\n            if window[curr] == 0:\n                count += 1\n            window[curr] += 1\n            if count <= 2:\n                res = max(res, idx - left + 1)\n            while count > 2:\n                window[tree[left]] -= 1\n                if window[tree[left]] == 0:\n                    count -= 1\n                left += 1\n        return res\n    \n                \n            \n            \n                \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left = 0\n        right = 0\n        window = set()\n        res = 0\n        last_index = collections.defaultdict(int)\n        \n        while left < len(tree) and right < len(tree):\n            fruit_type = tree[right]\n            last_index[fruit_type] = right\n            if tree[right] in window or len(window) < 2:\n                window.add(tree[right])\n            else:\n                window.add(tree[right])\n                while len(window) > 2:\n                    fruit_type = tree[left]\n                    if left == last_index[fruit_type]:\n                        window.remove(fruit_type)\n                    left += 1\n            res = max(res, right - left + 1)\n            right += 1\n        return res\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        best_so_far = start = 0\n        fruit_1 = fruit_2 = fruit_1_last_index = fruit_2_last_index = None\n        \n        for end in range(len(tree)):\n            # If we haven't picked any fruit yet, put this fruit in basket 1\n            if fruit_1 is None:\n                fruit_1 = tree[end]\n                fruit_1_last_index = end\n                \n            # If we haven't picked two different fruits yet, put this fruit in backet 2\n            elif fruit_2 is None and tree[end] != fruit_1:\n                fruit_2 = tree[end]\n                fruit_2_last_index = end\n                \n            # We have picked at least 2 different fruits so far\n            else:\n                # If this is basket 1's fruit, remember this as the most recent place we saw fruit 1\n                if tree[end] == fruit_1:\n                    fruit_1_last_index = end\n                    \n                # If this is basket 2's fruit, remember this as the most recent place we saw fruit 2\n                elif tree[end] == fruit_2:\n                    fruit_2_last_index = end\n                    \n                # This is neither fruit 1 nor fruit 2\n                else:\n                    # This is as far as we can go with these two fruits. Remember how many fruits we got.\n                    best_so_far = max(best_so_far, end - start)\n                    \n                    # Replace <the fruit whose most recent sighting was longer ago> with this new fruit\n                    if fruit_1_last_index < fruit_2_last_index:\n                        start = fruit_1_last_index + 1\n                        fruit_1 = tree[end]\n                        fruit_1_last_index = end\n                    else:\n                        start = fruit_2_last_index + 1\n                        fruit_2 = tree[end]\n                        fruit_2_last_index = end\n        \n        return max(best_so_far, len(tree) - start)", "class Solution:\n    \n    def totalFruit(self, tree: List[int]) -> int:\n        \n        blocks = [(k, len(list(v))) for k, v in itertools.groupby(tree)]\n        \n        ans = i = 0\n        \n        while i < len(blocks):\n            \n            types, weight = set(), 0\n            \n            for j in range(i, len(blocks)):\n                \n                types.add(blocks[j][0])\n                \n                weight += blocks[j][1]\n                \n                if len(types) >= 3:\n                    \n                    i = j - 1\n                    \n                    break\n                    \n                ans = max(ans, weight)\n                \n                \n            else:\n                \n                break\n                \n        return ans\n            \n            \n        \n            \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        count, i, j = {}, 0, 0\n        max_cnt = 0\n        while j < len(tree):\n            v = tree[j]\n            count[v] = count.get(v, 0) + 1\n            if len(count) <= 2:\n                max_cnt = max(sum(count.values()), max_cnt)\n            while len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0: del count[tree[i]]\n                i += 1\n            j += 1\n        return max_cnt\n", "import collections\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left = 0\n        right = 0\n        fruitsTypes = defaultdict(int)\n        numFruits = 0\n        maxNumFruit = 0\n        while(right < len(tree)):\n            fruitsTypes[tree[right]] += 1\n            numFruits += 1\n            right += 1\n            while len(fruitsTypes) > 2:\n                fruitsTypes[tree[left]] -= 1\n                if fruitsTypes[tree[left]] == 0:\n                    del(fruitsTypes[tree[left]])\n                numFruits -= 1\n                left += 1\n            maxNumFruit = max(maxNumFruit, numFruits)\n        return maxNumFruit\n                \n                \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        maxCount = count = 0\n        head = back = 0\n        buckets = dict()\n        while back < len(tree):\n            fruit = tree[back]\n            if fruit in buckets:\n                buckets[fruit] += 1  \n            else:\n                buckets[fruit] = 1\n                while len(list(buckets.keys())) > 2:\n                    dropFruit = tree[head]\n                    buckets[dropFruit] -= 1\n                    if buckets[dropFruit] == 0:\n                        buckets.pop(dropFruit)\n                    count -= 1\n                    head += 1\n            count += 1\n            maxCount = max(maxCount, count)\n            back += 1\n        return maxCount\n                \n                    \n                    \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        result = 0\n        left, right = 0, 0\n        basket = collections.defaultdict(int)\n        \n        \n        while right < len(tree):\n            basket[tree[right]] += 1\n            \n            while len(basket) > 2:\n                if basket[tree[left]] == 1:\n                    basket.pop(tree[left])\n                else:\n                    basket[tree[left]] -= 1\n                left += 1\n            \n            result = max(result, right - left + 1)\n            right += 1\n            \n            \n        return result", "class Solution(object):\n    def totalFruit(self, tree):\n        blocks = [(k, len(list(v)))\n                  for k, v in itertools.groupby(tree)]\n\n        ans = i = 0\n        while i < len(blocks):\n            # We'll start our scan at block[i].\n            # types : the different values of tree[i] seen\n            # weight : the total number of trees represented\n            #          by blocks under consideration\n            types, weight = set(), 0\n\n            # For each block from i and going forward,\n            for j in range(i, len(blocks)):\n                # Add each block to consideration\n                types.add(blocks[j][0])\n                weight += blocks[j][1]\n\n                # If we have 3 types, this is not a legal subarray\n                if len(types) >= 3:\n                    i = j-1\n                    break\n\n                ans = max(ans, weight)\n\n            # If we go to the last block, then stop\n            else:\n                break\n\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        blocks = []\n        \n        i = 0\n        while i < len(tree):\n            j = i + 1\n            length = 1\n            while j < len(tree) and tree[j] == tree[j-1]:\n                length += 1\n                j += 1\n                \n            blocks.append((tree[i], length))\n            i = j\n            \n        \n        maxi = 0\n\n        i = 0\n        while i < len(blocks):\n            types, cur = set(), 0\n            for j in range(i, len(blocks)):\n                types.add(blocks[j][0])\n                cur += blocks[j][1]\n                if len(types) > 2:\n                    i = j - 1\n                    break\n                \n            \n                maxi = max(maxi, cur)\n            else:\n                break\n        return maxi", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i, j = 0, 0\n        res = 0\n        d = {} \n        while j < len(tree):\n            d[tree[j]] = d.get(tree[j], 0) + 1\n            if len(d) <= 2:\n                res = max(res, j - i + 1)\n            else: \n                while len(d) > 2:\n                    d[tree[i]] = d[tree[i]] - 1\n                    if d[tree[i]] == 0:\n                        d.pop(tree[i])\n                    i += 1\n            j += 1\n        return res\n                \n            \n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        t1 = t2 = -1\n        t1s = -1\n        ans = 0;\n        for i in range(0, len(tree)):\n            t = tree[i]\n            if t != t1 and t != t2:\n                ans = max(ans, i - t1s)\n                t1s = i\n                while (t1s > 0 and tree[t1s - 1] == tree[i - 1]):\n                    t1s -= 1\n                t1 = tree[i - 1]\n                t2 = t\n        ans = max(ans, len(tree) - t1s)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        block = []\n        prev = tree[0]\n        start = 0\n        for i in range(1, len(tree)):\n            if prev != tree[i]:\n                block.append((prev, i-start))\n                start = i\n                prev = tree[i]\n        block.append((prev, len(tree) - start))\n        head, tail = 0, 1\n        basket = {block[0][0]: block[0][1]}\n        res = block[0][1]\n        while tail < len(block):\n            t, q = block[tail]\n            if t in list(basket.keys()):\n                basket[t] += q\n            else:\n                if len(basket) < 2:\n                    basket[t] = q\n                else:\n                    while len(basket) == 2:\n                        ht, hq = block[head]\n                        head += 1\n                        basket[ht] -= hq\n                        if basket[ht] == 0:\n                            basket.pop(ht)\n                    basket[t] = q\n            val = 0\n            for tt in list(basket.keys()):\n                val += basket[tt]\n            res = max(res, val)\n            tail += 1\n        return res\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        count, i, j = {}, 0, 0\n        max_cnt = 0\n        while j < len(tree):\n            # print(count)\n            v = tree[j]\n            count[v] = count.get(v, 0) + 1\n            if len(count) <= 2:\n                max_cnt = max(sum(count.values()), max_cnt)\n            while len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0: del count[tree[i]]\n                i += 1\n            j += 1\n        return max_cnt\n                \n        \n# j = 2\n# i = 1\n# count = {\n#     3: 2,\n#     1: 1,\n#     2: 1\n# }\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        i = 0\n        j = 0\n        my_map = {}\n        max_len = 0\n        while i < len(tree):\n            while i < len(tree) and (tree[i] not in my_map and len(my_map) < 2 or tree[i] in my_map):\n                if tree[i] not in my_map:\n                    my_map[tree[i]] = 0\n                my_map[tree[i]] += 1\n                i += 1\n            max_len = max(max_len, i - j)\n            while len(my_map) == 2: \n                my_map[tree[j]] -= 1\n                if my_map[tree[j]] == 0:\n                    del my_map[tree[j]]\n                j += 1\n            \n        return max_len\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        fruits = {}\n        maxNum = 0\n        \n        left = 0\n        right = 0\n        while right < len(tree):\n            while len(fruits) < 3 and right < len(tree):\n                fruit = tree[right]\n                if fruit not in fruits:\n                    fruits[fruit] = 0\n                fruits[fruit] += 1\n                if len(fruits) < 3:\n                    maxNum = max(maxNum, sum(fruits.values()))\n                right += 1\n            while len(fruits) > 2 and left < right:\n                fruit = tree[left]\n                fruits[fruit] -= 1\n                if fruits[fruit] == 0:\n                    del fruits[fruit]\n                left += 1\n        return maxNum", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if len(tree) == 1:\n            return 1\n        lo = 0\n        hi = 1\n        baskets = set()\n        baskets.add(tree[0])\n        bmaps = {}\n        bmaps[tree[0]] = 1\n        cnt = 1\n        while hi < len(tree):\n            baskets.add(tree[hi])\n            if tree[hi] in bmaps:\n                bmaps[tree[hi]] += 1\n            else:\n                bmaps[tree[hi]] = 1\n\n            while len(baskets) > 2:\n                if bmaps[tree[lo]] == 1:\n                    baskets.remove(tree[lo])\n                    bmaps[tree[lo]] = 0\n                else:\n                    bmaps[tree[lo]] -= 1\n                lo += 1\n            cnt = max(hi - lo + 1, cnt)\n            hi += 1\n        return cnt\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        l, nums, res = 0, collections.Counter(), 0\n        for r in range(len(tree)):\n            nums[tree[r]] += 1\n            while len(nums) > 2:\n                nums[tree[l]] -= 1 \n                if not nums[tree[l]]:\n                    nums.pop(tree[l])\n                l += 1\n            res = max(res, r - l + 1)\n        return res        ", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        if not tree:\n            return 0\n        i = 0\n        max_value = 0\n        count = Counter()\n        for index, value in enumerate(tree):\n            count[value] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            max_value = max(max_value, index - i + 1)\n        return max_value", "class Solution:\n    def totalFruit(self, s: List[int]) -> int:\n        m=0\n        arr={}\n        i=0\n        k=2\n        for j in range(len(s)):\n            if s[j] not in arr:\n                arr[s[j]]=0\n            arr[s[j]]+=1\n            while len(arr)>k:\n                x=s[i]\n                arr[x]-=1\n                if arr[x]==0:\n                    arr.pop(x)\n                i+=1\n            m=max(m,j-i+1)\n        return m", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        \n        \n        blocks = []\n        i=0\n        while i<len(tree):\n            start=i\n            while i+1<len(tree) and tree[i+1]==tree[start]:\n                i+=1\n            blocks.append((tree[start],i-start+1))\n            i = i+1\n            \n\n        ans =0\n        i=0\n        while i<len(blocks):\n            types = set()\n            weight = 0\n            j=i\n            while j<len(blocks):\n                types.add(blocks[j][0])\n                weight+=blocks[j][1]\n                \n                if len(types)>2:\n                    i=j-1\n                    break\n                \n                ans = max(ans,weight)\n                j+=1\n                \n                if j==len(blocks):\n                    i=j\n            \n            if i==len(blocks):\n                break\n        \n        return ans\n", "from collections import Counter\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        d = Counter()\n        left = 0 \n        total = 0\n        for idx, i in enumerate(tree):\n            d[i] += 1 \n            while(len(d) > 2):\n                d[tree[left]] -= 1 \n                if(d[tree[left]] == 0):\n                    del d[tree[left]]\n                left += 1 \n                \n            total = max(total, idx - left + 1)\n        return total\n", "class Solution:\n    def total(self, fruits):\n        total = 0\n        for key in fruits:\n            total += fruits[key]\n        \n        return total\n    \n    def totalFruit(self, tree: List[int]) -> int:\n        \n        fruits = {}\n        left_index = 0\n        best = 0\n        \n        for right_index in range(len(tree)):\n            curr_fruit = tree[right_index]\n            \n            if curr_fruit not in fruits:\n                fruits[curr_fruit] = 1\n            else:\n                fruits[curr_fruit] += 1\n            \n            while len(fruits) > 2:\n                old_fruit = tree[left_index]\n                fruits[old_fruit] -= 1\n                if fruits[old_fruit] == 0:\n                    del fruits[old_fruit]\n                left_index += 1 \n                \n            best = max(best, self.total(fruits))\n        \n        return best\n            \n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        result = 0\n        ptr = 0\n        count = collections.Counter()\n        for i, t in enumerate(tree):\n            count[t] += 1\n            while len(count) >= 3:\n                count[tree[ptr]] -= 1\n                if count[tree[ptr]] == 0:\n                    del count[tree[ptr]]\n                ptr += 1\n            result = max(result, i - ptr + 1)\n        return result\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n\n        max_len = 0\n        basket = collections.Counter()\n        start = 0\n        \n        for end, fruit in enumerate(tree):\n            basket[fruit] += 1\n            \n            while len(basket) >= 3:\n                basket[tree[start]] -= 1\n                \n                if basket[tree[start]] == 0:\n                    del basket[tree[start]]\n                    \n                start += 1\n            max_len = max(max_len, end - start + 1)\n            \n        return max_len", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        ans = i = 0\n        count = collections.Counter()\n        for j, x in enumerate(tree):\n            count[x] += 1\n            while len(count) >= 3:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n            \n            \n            \n                \n            \n", "# \u95ee\u9898\u53ef\u4ee5\u62bd\u8c61\u4e3a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u6c42\u89e3\u6700\u591a\u9009\u62e9\u4e24\u79cd\u6570\u5b57\u7684\u60c5\u51b5\u4e0b\uff0c\u6700\u5927\u7684\u8fde\u7eed\u5b50\u5e8f\u5217\u957f\u5ea6\uff0c\u5176\u4e2d\u6570\u7ec4\u548c\u539f\u9898\u76ee\u4e00\u6837\uff0c\u6bcf\u4e00\u4e2a\u6570\u5b57\u4ee3\u8868\u4e00\u4e2a\u6c34\u679c\u3002\n\n# \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u6765\u89e3\u51b3\u3002 \u601d\u8def\u548c \u30101004. \u6700\u5927\u8fde\u7eed 1 \u7684\u4e2a\u6570 III\u3011\u6ed1\u52a8\u7a97\u53e3\uff08Python3\uff09 \u4e00\u6837\u3002\n\n\n\nclass Solution:\n    def atMostK(self, nums, K):\n        counter = collections.Counter()\n        res = i = 0\n        for j in range(len(nums)):\n            if counter[nums[j]] == 0:\n                K -= 1\n            counter[nums[j]] += 1  #\u7136\u540e\u52a0\u4e0a1\n            while K < 0:\n                counter[nums[i]] -= 1  #\u79fb\u53bb\u6700\u5916\u9762\u7684\uff0c\u7136\u540e\u81ea\u5df1\u5f80\u5de6\u8d70\n                if counter[nums[i]] == 0:\n                    K += 1  #\u8bf4\u660e\u6709\u4e00\u4e2a\u54c1\u79cd\u591a\u51fa\u6765\u4e86\uff0c\u6240\u4ee5\u5728\u6ca1\u6709\u5230\u53ef\u4ee5\u79fb\u51fa\u54c1\u79cd\u4e4b\u524d\uff0c\u9700\u8981\u4e00\u76f4\u53d8\u52a8\n                i += 1\n            res = max(res, j - i + 1)  #\u56e0\u4e3a\u8fd8\u8981\u591a\u4e00\u4e2a\n        return res\n\n    def totalFruit(self, tree: List[int]) -> int:\n        return self.atMostK(tree, 2)   #\u6700\u591a\u4e24\u4e2a\n\n# \u590d\u6742\u5ea6\u5206\u6790\n\n# \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)O(N)\n# \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(N))O(N)) \uff08\u6211\u4eec\u4f7f\u7528\u4e86Counter\uff09\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n#dynamic sliding windo        \n        maxi=0\n        if len(tree)==1:\n            return 1\n        l=[]\n        s=set()\n        for i in range(len(tree)):\n            l.append(tree[i])\n            s.add(tree[i])\n            if len(s)>2:#we need to change the start of the window, remove until the size of set reduces to less than=2\n                #l=l[::-1]\n                while len(set(l))>2:\n                    #l.pop()\n                    l=l[1:]#pop the first element until the set has less than equal to 2 elements\n                #l=l[::-1]\n                s=set(l)#new version of set\n            maxi=max(maxi,len(l))\n        return maxi\n#increasing the sizee of sliding window by starting at each element        \n#         maxi=0\n#         if len(tree)==1:\n#             return 1\n            \n#         for i in range(len(tree)):\n#             s=set()\n#             s.add(tree[i])\n#             for j in range(i+1,len(tree)):\n#                 s.add(tree[j])\n#                 if len(s)>2:\n#                     break\n#                 maxi=max(maxi,j-i+1)\n#         return maxi\n        \n        # for i in range(len(tree),0,-1):\n        #     start=0\n        #     end=i\n        #     for j in range(len(tree)-i+1):\n        #         s=tree[start:end]\n        #         start+=1\n        #         end+=1\n        #         if len(set(s))<=2:\n        #             return i\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n#dynamic sliding windo        \n        maxi=0\n        if len(tree)==1:\n            return 1\n        l=[]\n        s=set()\n        for i in range(len(tree)):\n            l.append(tree[i])\n            s.add(tree[i])\n            if len(s)>2:\n                #l=l[::-1]\n                while len(set(l))>2:\n                    #l.pop()\n                    l=l[1:]#pop the first element until the set has less than equal to 2 elements\n                #l=l[::-1]\n                s=set(l)\n            maxi=max(maxi,len(l))\n        return maxi\n#increasing the sizee of sliding window by starting at each element        \n#         maxi=0\n#         if len(tree)==1:\n#             return 1\n            \n#         for i in range(len(tree)):\n#             s=set()\n#             s.add(tree[i])\n#             for j in range(i+1,len(tree)):\n#                 s.add(tree[j])\n#                 if len(s)>2:\n#                     break\n#                 maxi=max(maxi,j-i+1)\n#         return maxi\n        \n        # for i in range(len(tree),0,-1):\n        #     start=0\n        #     end=i\n        #     for j in range(len(tree)-i+1):\n        #         s=tree[start:end]\n        #         start+=1\n        #         end+=1\n        #         if len(set(s))<=2:\n        #             return i\n", "class Solution(object):\n    def totalFruit(self, tree):\n        n = len(tree)\n        left, right = 0, 0\n        basket = {}\n        \n        ans = 0\n        while right<n:\n            while left<right and len(basket)>1:\n                basket.update({tree[left]:basket.get(tree[left], 0)-1})\n                if basket.get(tree[left], None) == 0:\n                    basket.pop(tree[left])\n                left +=1\n                \n            basket.update({tree[right]:basket.get(tree[right], 0)+1})\n            right += 1\n            while right<n and basket.get(tree[right], 0) > 0:\n                basket.update({tree[right]:basket.get(tree[right], 0)+1})\n                right += 1\n            # print(left, right, basket)\n            ans = max(ans, right-left)\n        return ans", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        N = len(tree)\n        \n        cache = Counter()\n        \n        left = right = 0\n        maxx = 0\n        while left < N and right < N:\n            # while len(cache) < 2 and right < N:\n            curr = tree[right]\n            cache[curr] += 1                \n            # right += 1\n                \n            while len(cache) > 2 and left < N:\n                # print(cache)\n                curr = tree[left]\n                cache[curr] -= 1\n                if cache[curr] <= 0:\n                    del cache[curr]\n                left += 1\n            \n            # print(tree[left:right+1])\n            maxx = max(maxx, right-left+1)\n            right += 1\n            \n        return maxx", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        l, nums, ans = 0, collections.Counter(), 0\n        for r in range(len(tree)):\n            nums[tree[r]] += 1\n            while len(nums) > 2:\n                nums[tree[l]] -= 1\n                if not nums[tree[l]]:\n                    del nums[tree[l]]\n                l += 1\n            ans = max(ans, r - l + 1)\n        return ans\n                    \n                    \n                \n", "from collections import defaultdict\n\nclass Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n\n        maxAmountOfFruit = 0\n        startIndex, endIndex = 0, 0\n\n        countByFruit = defaultdict(int)\n        countByFruit[tree[startIndex]] = 1\n        \n        while endIndex < len(tree):\n            while len(countByFruit) > 2:\n                fruitToRemove = tree[startIndex]\n                countByFruit[fruitToRemove] -= 1\n                if countByFruit[fruitToRemove] == 0:\n                    del countByFruit[fruitToRemove]\n                startIndex += 1\n            maxAmountOfFruit = max(maxAmountOfFruit, endIndex - startIndex + 1)\n            endIndex += 1\n            if endIndex != len(tree):\n                countByFruit[tree[endIndex]] += 1\n        return maxAmountOfFruit\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        cnt = collections.Counter()\n        i = 0\n        res = 0\n        for j in range(len(tree)):\n            cnt[tree[j]] += 1\n            while len(cnt) > 2:\n                cnt[tree[i]] -= 1\n                if cnt[tree[i]] == 0:\n                    cnt.pop(tree[i])\n                i += 1\n            res = max(res, sum(cnt.values()))\n        return res\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # fruit_1, fruit_2 = None, None\n        # pos_1, pos_2 = -1, -1\n        # i = 0\n        # max_len = 0\n        # for t in range(len(tree)):\n        #     if tree[t]==fruit_1:\n        #         fruit_1, fruit_2 = fruit_2, fruit_1\n        #         pos_1, pos_2 = pos_2, t\n        #     elif tree[t]==fruit_2:\n        #         pos_2 = t\n        #     else:\n        #         fruit_1, fruit_2 = fruit_2, tree[t]\n        #         i = pos_1 + 1\n        #         pos_1, pos_2 = pos_2, t\n        #     if t - i + 1 > max_len:\n        #         max_len = t - i + 1\n        # return max_len\n", "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        left, right = 0, 0\n        res = 0\n        cnt = collections.defaultdict(int)\n        while right < len(tree):\n            cnt[tree[right]] += 1\n            while len(cnt) > 2:\n                cnt[tree[left]] -= 1\n                if cnt[tree[left]] == 0:\n                    del cnt[tree[left]]\n                left += 1\n            res = max(res, right - left + 1)\n            right += 1\n        return res"]
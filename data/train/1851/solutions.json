["class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort(key=lambda x: [x[0], -x[1]])\n        res = 0            \n        r = 0\n        new_r = 0\n        # print(clips)\n        for s, e in clips:\n            if s <= r:\n                new_r = max(new_r, e)\n            elif s > new_r:\n                return -1\n            else:\n                res += 1\n                r = new_r\n                # print(new_r)\n                new_r = max(new_r, e)\n            if new_r >= T:\n                break\n        if new_r < T:\n            return -1\n        if r < T and new_r >= T:\n            res += 1\n        return res\n", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        # First find clips that start from 0\n            # Then use the clip that reaches the farthest\n        # Continually find clips that continue, and pick ones that reach the farthest\n        \n        last_end = 0\n        clip_count = 0\n        while last_end < T:\n            # If no more clips\n            if clip_count >= len(clips):\n                return -1\n            # Find valid clip that reaches the farthest\n            max_end = -1\n            for clip in clips:\n                if clip[0] <= last_end:\n                    if clip[1] > max_end:\n                        max_end = clip[1]\n            \n            if max_end >= 0:\n                last_end = max_end\n                clip_count += 1\n            else:\n                return -1\n            \n        return clip_count\n", "class Solution:\n    \n    def videoStitching(self, clips, T):\n        end, end2, res = -1, 0, 0\n        for i, j in sorted(clips):\n            if end2 >= T or i > end2:\n                break\n            elif end < i <= end2:\n                res, end = res + 1, end2\n            end2 = max(end2, j)\n        return res if end2 >= T else -1    ", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        \n        dp = [T+1] * (T+1)\n        dp[0] = 0\n        i = 1\n        while i <= T and dp[i-1] < T:\n            for c in clips:\n                if c[0] <= i and i <= c[1]:\n                    dp[i] = min(dp[i], dp[c[0]] + 1)\n            i+=1\n        return dp[T] if dp[T] != T+1 else -1", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort(key=lambda x:x[0])\n        n = len(clips)\n        memo = {}\n        def recur(i,interval):\n            if (i,interval) in memo:\n                return memo[(i,interval)]\n            if interval >= T:\n                return 0\n            if i==n:\n                return sys.maxsize \n            if interval >= clips[i][0] and interval < clips[i][1]:\n                ans = min(recur(i+1,clips[i][1])+1,recur(i+1,interval))\n            else:\n                ans = recur(i+1,interval)\n            memo[(i,interval)] = ans\n            return ans\n        fnl = recur(0,0)\n        return -1 if fnl == sys.maxsize else fnl\n        \n            \n            \n", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        dp = [T+1] * (T + 1)\n        dp[0] = 0\n        for i in range(1,T+1):\n            if dp[i-1] >= T:\n                break\n            for start, end in clips:\n                if start <= i <= end:\n                    dp[i] = min(dp[i], dp[start] + 1)\n                    print(dp)\n        if dp[T] == T + 1:\n            return -1\n        else:\n            return dp[T]", "class Solution:\n    import json\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        IMPOSSIBLE = float('inf')\n        sorted_clips = sorted(clips, key=lambda x: x[0], reverse=False)\n        opt = {}\n        for index, clip in enumerate(sorted_clips):\n            for t in range(0, T+1):\n                start, end = tuple(clip)\n                if t == 0:\n                    opt[index, t] = 0\n                elif index == 0:\n                    opt[index, t] = 1 if start == 0 and t <= end else IMPOSSIBLE\n                else:\n                    opt[index, t] = min(opt[index-1, t], opt[index-1, min(start, t)]+1 if t <= end else IMPOSSIBLE)\n        print(opt)\n        return opt[len(clips)-1, T] if opt[len(clips)-1, T] != float('inf') else -1", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort()\n        n = len(clips)\n        dp = [float('inf')]*(T+1)\n        dp[0] = 0\n        for i in range(1, T+1):\n            for j in range(n):\n                if clips[j][0]<=i<=clips[j][1]:\n                    dp[i] = min(dp[i], 1+dp[clips[j][0]])\n        if dp[T] == float('inf'):\n            return -1\n        return dp[-1]\n", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort()\n        i = 0\n        end = 0\n        res = 0\n        \n        while end < T:\n            current_end = 0\n            while i < len(clips) and clips[i][0] <= end: # basically stating while there is an overlap, keep doing this loop\n                current_end = max(current_end, clips[i][1]) # trying to extend end time as far as possible \n                i += 1\n            if current_end <= end:\n                return -1\n            end = current_end\n            res += 1\n        return res # if the new end is not greater than or equal then it means there are no intervals in which you can extend to the end of the clip", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        end, end2, cnt= -1, 0, 0 # end \u8868\u793a\u4e0a\u4e00\u6bb5\u6700\u540e\u622a\u6b62\u70b9\uff0cend2\u8868\u793a\u5f53\u524d\u53ef\u4ee5\u6700\u5927\u5ef6\u4f38\u7684\u6700\u8fdc\u5730\u70b9\n        for s, e in sorted(clips):\n            if end2>=T or s> end2: # end2>=T\u8868\u793a\u5df2\u7ecf\u627e\u5230\u4e00\u4e2a\u53ef\u4ee5cover\u6240\u6709T\uff1b s>end2\u8868\u793a\u5b8c\u5168\u63a5\u4e0d\u4e0a\uff08\u56e0\u4e3a\u5df2\u7ecf\u6392\u8fc7\u5e8f\u4e86\uff09\n                break\n            elif end< s <= end2: # \u5982\u679cs=end \u8bf4\u660e\u65b0\u7684\u8fd9\u6bb5\u548c\u4e0a\u4e00\u6bb5\u6709overlap\uff0c\u53ea\u9700\u8981\u770b\u65b0\u7684\u8fd9\u6bb5\u662f\u4e0d\u662f\u6bd4\u4e0a\u4e00\u6bb5cover\u66f4\u591a \u6765\u8ddf\u65b0end2\n                cnt+=1\n                end = end2\n            end2= max(end2, e)\n        return cnt if end2>=T else -1", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        step = 0 \n        l, r = -1, 0\n        for i,j in sorted(clips):\n            if r >= T:\n                return step\n            if i>r:\n                return -1\n            \n            if l<i<=r:\n                step += 1\n                l = r          \n            r = max(r, j)            \n        return step if r>=T else -1", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        dp = [float(inf)] * (101)\n        clips.sort()\n        if clips[0][0] > 0:\n            return -1\n        dp[0] = 0\n        for i in range(len(clips)):\n            clip = clips[i]\n\n            if clip[0] != 0 and dp[clip[0]] == float(inf):\n                break\n            \n            # if clip[0] == 0:\n            #     min_so_far = 0\n            # else:\n            min_so_far = dp[clip[0]]\n            \n            for k in range(clip[0], clip[1] + 1):\n                dp[k] = min(dp[k], min_so_far + 1)\n        \n        if dp[T] == inf:\n            return -1\n        return dp[T]", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        dp = [float(inf)] * (101)\n        clips.sort()\n        if clips[0][0] > 0:\n            return -1\n\n        for i in range(len(clips)):\n            clip = clips[i]\n\n            if clip[0] != 0 and dp[clip[0]] == float(inf):\n                break\n            \n            if clip[0] == 0:\n                min_so_far = 0\n            else:\n                min_so_far = dp[clip[0]]\n            \n            for k in range(clip[0], clip[1] + 1):\n                dp[k] = min(dp[k], min_so_far + 1)\n        \n        if dp[T] == inf:\n            return -1\n        return dp[T]", "import math\n\nclass Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort()\n        longest = sorted(clips, key=lambda a: a[1])[-1][1]\n        memo = [[None for i in range(longest + 1)] for i in range(len(clips))]\n        \n        def dp(i, start):\n            if start >= T:\n                return 0\n            \n            curr = clips[i]\n            if curr[0] > start:\n                return math.inf\n            elif i == len(clips) - 1:\n                if curr[1] < T:\n                    return math.inf\n                return 1\n            \n            # Pick first clip\n            if memo[i + 1][curr[1]] == None:\n                memo[i + 1][curr[1]] = dp(i + 1, curr[1])\n            \n            #Don't pick first clip\n            if memo[i + 1][start] == None:\n                memo[i + 1][start] = dp(i + 1, start)\n            \n            return min(1 + memo[i + 1][curr[1]], memo[i + 1][start])\n        \n        res = dp(0, 0)\n        return res if res != math.inf else -1", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        table = [101] * 101\n        table[0] = 0\n        \n        changed = True\n        while changed:\n            changed = False\n            for i, j in clips:\n                for k in range(i, j+1):\n                    if table[i] + 1 < table[k]:\n                        table[k] = table[i] + 1\n                        changed = True\n        \n        if table[T] < 101:\n            return table[T]\n        else:\n            return -1", "class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort(key=lambda x: x[0])\n        dp = [[0]*(len(clips)+1)]+[[float('inf')]*(len(clips)+1) for _ in range(T)]\n        for row in range(1, len(dp)):\n            for col in range(1, len(dp[0])):\n                dp[row][col] = dp[row][col-1]\n                if(clips[col-1][0] <= row-1 < clips[col-1][1]):\n                    dp[row][col] = min(dp[row][col], 1+dp[clips[col-1][0]][col])\n        ans = dp[-1][-1] if dp[-1][-1]!=float('inf') else -1\n        return ans"]
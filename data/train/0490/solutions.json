["class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        def dfs(node, visited):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in rooms[node]:\n                if nei in visited:\n                    continue\n                dfs(nei,visited)\n            return\n        visited = set()\n        dfs(0, visited)\n        if len(visited) == len(rooms):\n            return True\n        else: \n            return False\n            \n", "from collections import deque \n\nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        seen = [False for i in range(len(rooms))]\n        seen[0] = True \n        stack = deque()\n        stack.append(0)\n        \n        while stack:\n            room = stack.pop()\n            for key in rooms[room]:\n                if not seen[key]:\n                    seen[key] = True \n                    stack.append(key)\n        \n        return all(seen)\n\n                \n                \n        \n", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        def recur(room, visited):\n            if room in visited: return False\n            visited.append(room)\n            if len(visited) == len(rooms): return True\n            for i in rooms[room]:\n                if recur(i, visited): return True\n            return False\n\n        return recur(0, [])", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        list_of_rooms_visited = [0]\n        \n        def check(arr):\n            #print(list_of_rooms_visited)\n            for j in arr:\n                if j not in list_of_rooms_visited:\n                    list_of_rooms_visited.append(j)\n                    check(rooms[j])\n            return\n                \n        check(rooms[0])\n        if len(list_of_rooms_visited)!=len(rooms):\n            return False\n        else:\n            return True\n", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        self.visited = [0]\n        \n        self.dfs(rooms, 0)\n        #print(self.visited)\n        if len(self.visited) == len(rooms):\n            return True\n        return False\n        \n    def dfs(self, rooms, i):\n        keys = rooms[i]\n        \n        for key in keys:\n            if key not in self.visited:\n                self.visited.append(key)\n                self.dfs(rooms, key)\n                \n            \n        return\n", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        self.visited = [0]\n        \n        self.dfs(rooms, 0)\n        #print(self.visited)\n        if len(self.visited) == len(rooms):\n            return True\n        return False\n        \n    def dfs(self, rooms, i):\n        keys = rooms[i]\n        \n        for key in keys:\n            if key not in self.visited:\n                self.visited.append(key)\n                self.dfs(rooms, key)\n                \n            else:\n                continue\n        return\n", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        self.visited = []\n        self.dfs(rooms, 0)\n        return len(self.visited) == len(rooms)\n    \n    def dfs(self, rooms, room_id):\n        if room_id in self.visited:\n            return\n        self.visited.append(room_id)\n        for key in rooms[room_id]:\n            self.dfs(rooms, key)\n", "class GraphNode:\n    def __init__(self):\n        self.neighbors = set()\n    \nclass Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        nodes = [GraphNode() for i in range(len(rooms))]\n        for index, keys in enumerate(rooms):\n            for key in keys:\n                nodes[index].neighbors.add(nodes[key])\n        \n        stack = [nodes[0]]\n        visited = set()\n        while stack:\n            node = stack.pop()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in node.neighbors:\n                stack.append(neighbor)\n                \n        return len(visited) == len(rooms)", "import numpy as np\nclass Solution(object):\n    def canVisitAllRooms(self, rooms):\n        seenRooms = np.zeros(len(rooms), dtype = bool)\n        Keys = [0]\n        while(len(Keys)!=0):\n            curr = Keys.pop(0)\n            seenRooms[curr] = True\n            for key in rooms[curr]:\n                if not seenRooms[key]:\n                    Keys.append(key)\n        return True if all(seenRooms) else False\n                \n            \n", "import numpy as np\nclass Solution(object):\n    def canVisitAllRooms(self, rooms):\n        seenRooms = np.zeros(len(rooms), dtype = bool)\n        stackKeys = [0]\n        while(len(stackKeys)!=0):\n            curr = stackKeys.pop()\n            if not seenRooms[curr]:\n                seenRooms[curr] = True\n                for key in rooms[curr]:\n                    stackKeys.append(key)\n        return True if all(seenRooms) else False\n                \n            \n", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \n        q=deque([])\n        vis=[False]*len(rooms)\n        q.append(0)\n        \n        while q:\n            ver=q.popleft()\n            vis[ver]=True\n            for neigh in rooms[ver]:\n                if(vis[neigh]!=True):\n                    q.append(neigh)\n\n        if(False in vis):\n            return False\n        else:\n            return True\n          \n            \n        \n", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        n = len(rooms)\n        rooms_to_visit = [i for i in range(n)]\n        \n        def dfs(curr_room, rooms_left, keys):\n            # print(curr_room, rooms[curr_room], rooms_left, keys)\n            if len(rooms_left) == 0:\n                return True\n            else:\n                res = False\n                if len(keys) == 0:\n                    return False\n                for key in keys:\n                    if key in rooms_left:\n                        rooms_left.remove(key)\n                        tmp_keys = (keys.union(set(rooms[key]))).intersection(set(rooms_left))\n                        return dfs(key, rooms_left, tmp_keys)\n                        rooms_left.append(key)\n            \n        return dfs(0, list(range(1,n)), set(rooms[0]))", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n    \n        q = deque([0])\n        visited = set([0])\n        while q:\n            r = q.pop()\n            for k in rooms[r]:\n                if k not in visited:\n                    visited.add(k)\n                    q.append(k)\n                \n        return len(visited)==len(rooms)", "class Room:\n    def __init__(self, num, keys):\n        self.num = num\n        self.keys = keys\n        self.visited = False\n        \nclass Solution:\n    def explore(self, room_id, all_rooms):\n        cur_room = all_rooms[room_id]\n        if cur_room.visited:\n            return\n        \n        cur_room.visited = True\n        for key in cur_room.keys:\n            self.explore(key, all_rooms)\n        \n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        all_rooms = [Room(i, keys) for i, keys in enumerate(rooms)]\n        self.explore(0, all_rooms)\n        \n        for room in all_rooms:\n            if not room.visited:\n                return False\n            \n        return True", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        seen = [False]*len(rooms)\n        seen[0]= True\n        stack =[0]\n        while stack:\n            nodes = stack.pop()\n            for node in rooms[nodes]:\n                if not seen[node]:\n                    seen[node]=True\n                    stack.append(node)\n        return all(seen)", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \n        graph=defaultdict(list)\n        \n        for i in range(len(rooms)):\n            for j in range(len(rooms[i])):\n                graph[i].append(rooms[i][j])\n                \n        visited=set()\n        q=[0]\n        \n        while q:\n            item = q.pop(0)\n            if item not in visited:\n                visited.add(item)\n                for val in graph[item]:\n                    q.append(val)\n        \n        if len(visited)==len(rooms):\n            return True\n        else:\n            return False", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \n        graph=defaultdict(list)\n        \n        for i in range(len(rooms)):\n            for j in range(len(rooms[i])):\n                graph[i].append(rooms[i][j])\n                \n        visited=set()\n        item=0\n        \n        \n        def rec(item):\n            if item not in visited:\n                visited.add(item)\n                for val in graph[item]:\n                    rec(val)\n        rec(item)\n        \n        if len(visited)==len(rooms):\n            return True\n        else:\n            return False", "class Solution:\n    def canVisitAllRooms(self, rooms):\n        graph = {}\n        visited = {}\n        for node, edges in enumerate(rooms):\n            visited[node] = False\n            graph[node] = []\n            for edge in edges:\n                graph[node].append(edge)\n        \n        def DFS(visited, graph, node):\n            visited[node] = True\n            for neighbour_node in graph[node]:\n                if not visited[neighbour_node]:\n                    DFS(visited, graph, neighbour_node)\n        \n        islands = 0\n\n        for node in visited:\n            if not visited[node]:\n                islands += 1\n                DFS(visited, graph, node)\n\n        return islands == 1", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \n        def dfs(curRoom, visited):\n            visited[curRoom] = True\n            \n            for key in rooms[curRoom]:\n                if not visited[key]:\n                    dfs(key, visited)\n        \n        visited = [False] * len(rooms)\n        dfs(0, visited)\n        #print(visited)\n        return all(visited)", "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        rem_rooms = [i for i in range(1, len(rooms))]\n\n        visited = set()\n        def dfs(r, key):\n            stack = [key]\n\n            while stack and rem_rooms:\n                element = stack.pop()\n                if element in rem_rooms:\n                    rem_rooms.remove(element)\n\n                if element not in visited:\n                    visited.add(element)\n\n                    for neighbour in rooms[element]:\n                        stack.append(neighbour)\n\n        dfs(rooms, 0)\n\n        return len(rem_rooms) == 0"]
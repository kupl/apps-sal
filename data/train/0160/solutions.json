["class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return True", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return 1;\n", "class Solution:\n    def recur(self,i,j,piles,n,dp,s):\n        if j==i+1:\n            return max(piles[i],piles[j])\n        if dp[i+1][j] != -1:\n            l = dp[i+1][j]\n        else:    \n            l = self.recur(i+1,j,piles,n,dp,s-piles[i])\n        if dp[i][j-1] !=-1:\n            r = dp[i][j-1]\n        else:    \n            r = self.recur(i,j-1,piles,n,dp,s-piles[j])\n            \n        ans =  max(s-l,s-r)\n        dp[i][j] = ans\n        return ans\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[-1 for i in range(n+1)] for j in range(n+1)]\n        m = (self.recur(0,n-1,piles,n,dp,sum(piles)))\n    \n        if m>sum(piles)-m:\n            return True\n        else:\n            return False\n        \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def dp(i, j):\n            if i > j: return 0\n            if (j - i + 1) % 2 == 0:\n                return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n            else:\n                return max(-piles[i] + dp(i + 1, j), -piles[j] + dp(i, j - 1))\n        return dp(0, len(piles) - 1) > 0\n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def dfs(i, j, isAlex):\n            if j < i: return 0\n            elif i == j: return piles[i] if isAlex else -piles[i]\n            if isAlex:\n                return max(piles[i]+dfs(i+1, j, not isAlex), piles[j]+dfs(i, j-1, not isAlex))\n            else:\n                return min(-piles[i]+dfs(i+1, j, not isAlex), -piles[j]+dfs(i, j-1, not isAlex))\n        \n        if not piles: return False\n        n = len(piles)\n        \n        return dfs(0, n-1, True) > 0\n", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        @lru_cache(None)\n        def dp(i, j):\n            if i > j: return 0\n            if (j - i - N) % 2 == 0:\n                return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n            else:\n                return max(-piles[i] + dp(i + 1, j), -piles[j] + dp(i, j - 1))\n        return dp(0, N - 1) > 0\n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        lp = len(piles)\n        \n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if i > j: return 0\n            parity = (j-i) % 2\n            if parity == 1:\n                return max(piles[i] + dp(i+1, j), piles[j]+dp(i, j-1))\n            if parity == 0:\n                return min(-piles[i] + dp(i+1, j), -piles[j]+dp(i, j-1))\n            \n        return dp(0, lp-1)>0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        @lru_cache(None)\n        def play(i, j, alexTurn):\n            if i > j:\n                return 0\n            \n            if alexTurn:\n                return max(play(i + 1, j, False) + piles[i], play(i, j - 1, False) + piles[j])\n            else:\n                return min(play(i + 1, j, True) - piles[i], play(i, j - 1, True) - piles[j])\n            \n            \n        return play(0, len(piles) - 1, True) > 0", "from functools import lru_cache\n\nclass Solution:\n\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if i > j:\n                return 0\n            parity = (j - i - N) % 2\n            \n            if parity == 1:\n                return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n            else:\n                return min(-piles[i] + dp(i + 1, j), -piles[j] + dp(i, j - 1))\n        \n        return dp(0, N - 1) > 0\n", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp_a = [[0] * n for _ in range(n)]\n        dp_b = [[0] * n for _ in range(n)]\n        total = 0\n        for i in range(n): \n            dp_a[i][i] = piles[i]\n            total += piles[i]\n        for l in range(1, n): \n            for i in range(0, n - l): \n                dp_a[i][i+l] = max(piles[i] + dp_b[i+1][i+l], piles[i+l] + dp_b[i][i+l-1]) \n                dp_b[i][i+l] = max(dp_a[i+1][i+l], dp_a[i][i+l-1])\n        return dp_a[0][n-1] > total // 2\n", "import functools\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n: int = len(piles)\n        @functools.lru_cache(maxsize = None)\n        def dp(i: int, j: int) -> int:\n            if i > j:\n                return 0\n            parity: int = (j - i - n) % 2\n            if parity == 1:\n                return max(dp(i + 1, j) + piles[i], dp(i, j - 1) + piles[j])\n            else:\n                return min(dp(i + 1, j) - piles[i], dp(i, j - 1) - piles[j])\n        return dp(0, n - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        \n        # i refers to left pointer, j refers to right pointer to piles array\n        @lru_cache(None)\n        def dp(i, j):\n            if i > j:\n                return 0\n            \n            parity = (j - i) % 2\n            if parity == 1:\n                return max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1))\n            else:\n                return min(-piles[i] + dp(i+1, j), -piles[j] + dp(i,j-1))\n        \n        return dp(0, N-1) > 0\n", "class Solution:\n    def stoneGame(self, piles):\n        N = len(piles)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0\n    \n    \n", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        @lru_cache(None)\n        def dp(i,j):\n            if i > j:\n                return 0\n            player = (j-i-n) % 2\n            if player == 1:\n                # alex\n                return max(piles[i] + dp(i+1, j), piles[j] + dp(i,j-1))\n            else:\n                # lee\n                return min(dp(i+1,j)-piles[i], dp(i,j-1)-piles[j])\n        return dp(0, n-1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        @lru_cache(None)\n        def dp(i, j):\n            if i > j: return 0\n            if (j - i - N) % 2 == 0:\n                return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n            else:\n                return max(-piles[i] + dp(i + 1, j), -piles[j] + dp(i, j - 1))\n        return dp(0, N - 1) > 0\n            \n", "from functools import lru_cache\n\nclass Solution(object):\n    def stoneGame(self, piles):\n        N = len(piles)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0", "class Solution:\n    def stoneGame(self, p: List[int]) -> bool:\n        n = len(p)\n        dp = [[int(j==i) for j in range(n)] for i in range(n)]\n        for d in range(1, n):\n            for i in range(n - d):\n                # print(i, i+d)\n                dp[i][i+d] = max(p[i]-dp[i+1][i+d], p[i+d]-dp[i][i+d-1])\n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp_a = [[0] * n for _ in range(n)]\n        dp_b = [[0] * n for _ in range(n)]\n        for i in range(n): \n            dp_a[i][i] = piles[i]\n        for l in range(1, n): \n            for i in range(0, n - l): \n                dp_a[i][i+l] = max(piles[i] + dp_b[i+1][i+l], piles[i+l] + dp_b[i][i+l-1]) \n                dp_b[i][i+l] = max(dp_a[i+1][i+l], dp_a[i][i+l-1])\n        return dp_a[0][n-1] > sum(piles) // 2\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        #1 + (N - 1)\n        @lru_cache(None)\n        def solve(i, j):\n            if i > j:\n                return 0\n            if (i + j) %2 == 1:\n                return max(solve(i+1, j)+piles[i], solve(i, j-1)+piles[j])\n            else:\n                return min(solve(i+1, j)+piles[i], solve(i, j-1)+piles[j])\n        return solve(0, n-1) > 0\n        \n\n", "class Solution:\n    def stoneGame(self, piles):\n      def dfs(left, right):\n        if left > right:\n          return 0\n        \n        if left + 1 == right:\n          return piles[left]\n\n        if dp[left][right] != None:\n          return dp[left][right]\n\n        dp[left][right] = max(\n          piles[left] + dfs(left + 1, right - 1),\n          piles[left] + dfs(left + 2, right),\n          piles[right] + dfs(left + 1, right - 1),\n          piles[right] + dfs(left, right - 2)\n        )\n\n        return dp[left][right] \n\n      n = len(piles)\n      dp = [[None for i in range(n)] for j in range(n)]\n\n      ALEX = dfs(0, n - 1)\n      LEE = sum(piles) - ALEX\n      return ALEX >= LEE\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        prefix = [0]\n        for p in piles:\n            prefix.append(prefix[-1] + p)\n        @lru_cache(None)\n        def dp(i, j):\n            if i == j:\n                return piles[i]\n            a = piles[i] + prefix[j + 1] - prefix[i + 1] - dp(i + 1, j)\n            b = piles[j] + prefix[j] - prefix[i] - dp(i, j - 1)\n            return max(a, b)\n        return dp(0, len(piles) - 1) > prefix[-1] // 2", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        @lru_cache(None)\n        def helper(start=0, end=len(piles)):\n            if end - start == 2:\n                return (max(piles), min(piles))\n\n            leeL, alexL = helper(start+1, end)\n            alexL += piles[start]\n            \n            leeR, alexR = helper(start, end-1)\n            alexR += piles[end-1]\n            \n            return (alexR, leeR) if alexR > alexL else (alexL, leeL)\n        \n        alex, lee = helper()\n        return alex > lee\n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:    \n        n=len(piles) \n\n        dp=[[2500001]*(n+1) for _ in range(n+1)]   \n        def kmp(i,j):\n            if i>j:\n                return 0 \n            elif dp[i][j]!=2500001:\n                return dp[i][j]\n            else:\n\n                \n                parity=(j-i+1)%2              \n                if parity==1:                                       \n                    dp[i][j]=min(-piles[i]+kmp(i+1,j),-piles[j]+kmp(i,j-1)) \n                    return dp[i][j]\n                else:\n                    dp[i][j]=max(piles[i]+kmp(i+1,j),piles[j]+kmp(i,j-1))\n                    return dp[i][j]\n        return kmp(0,n-1)>0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        '''\n        def helper(piles,i,j):\n            if i==j:\n                return piles[i]\n            elif i+1==j:\n                return max(piles[i],piles[j])\n            return max(piles[i]+min(helper(piles,i+2,j),helper(piles,i+1,j-1)), piles[j]+\n            min(helper(piles,i+1,j-1),helper(piles,i,j-2)))\n        summ=helper(piles,0,len(piles)-1)\n        #print(summ)\n        if summ>sum(piles)-summ:\n            return True\n        return False\n        '''\n        n=len(piles)\n        dp=[[0]*n for i in range(n)]\n        #for i in range(len(piles)):\n            #dp[i][i]=piles[i]\n        \n        for d in range(1, n): #diff between i and j is d\n            for i in range(n - d):# when diff is 1, diagonally loop runs for n-1 time\n                #when diff is 0, it runs for n times, ex 3X3 matrix diagonal\n                j=i+d # as the diff b/w i and j is d\n                if i+1==j:\n                    dp[i][j] = max(piles[i],piles[j])\n                else:\n                    dp[i][j] = max(piles[i] + min(dp[i+2][j],dp[i+1][j-1]), piles[j] +                            min(dp[i+1][j-1],dp[i][j-2]))\n        #print(dp[0][n-1])  \n        return dp[0][n-1] > sum(piles) - dp[0][n-1]\n        \n        \n        \n                \n", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        \n        @lru_cache(None)\n        def dp(i,j):\n            if i > j:\n                return 0\n            parity = (N - (j-i+1)) % 2 #0-alex, 1-lee\n            # parity = (j-i-N) % 2\n            if parity == 0 :\n                return max(piles[i] + dp(i+1,j), piles[j]+dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n            \n        return dp(0, N-1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        def pmin(i, j):\n            if (i,j) in mincache: return mincache[(i,j)]\n            if i == j: return 0\n            mincache[(i,j)] =  min(pmax(i+1, j), pmax(i, j-1))\n            return mincache[(i,j)]\n\n        def pmax(i, j):\n            if (i,j) in maxcache: return maxcache[(i,j)]\n            if i == j: return piles[i]\n            maxcache[(i,j)] =  max(piles[i] + pmin(i+1, j), pmin(i, j-1) + piles[j])\n            return maxcache[(i,j)]\n\n        mincache, maxcache = {}, {}\n        p1 = pmax(0, len(piles)-1)\n        p2 = sum(piles) - p1\n        return p1 > p2", "class Solution:\n    def stoneGame(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n <= 2 :\n            return True\n        dp = [[0]*n for i in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n-1):\n            dp[i][i+1] = max(nums[i],nums[i+1])\n            \n        for j in range(2,n):\n            for i in range(n-j):\n                dp[i][j+i] = max(nums[i]+min(dp[i+1][j+i-1],dp[i+2][j+i]), nums[j+i] + min(dp[i][j+i-2],dp[i+1][j+i-1]))\n        #print(dp)\n        if sum(nums) - dp[0][n-1] > dp[0][n-1]:\n            return False\n        return True", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        A = piles\n        @lru_cache(maxsize=None)\n        def hello(st,end,turn):\n            if st > end:\n                return 0\n            if turn%2 == 0:\n                return max(A[st]+hello(st+1,end,turn+1),A[end]+hello(st,end-1,turn+1))\n            else:\n                return min(hello(st+1,end,turn+1)-A[st],hello(st,end-1,turn+1)-A[end])\n        t = hello(0,len(A)-1,0)\n        return t > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        def solve(i,j,arr,dp):\n            if i>j:\n                return 0\n            if dp[i][j]!=-1:\n                return dp[i][j]\n            \n            op1 = arr[i]+solve(i+1,j,arr,dp)\n            op2 = arr[j]+solve(i,j-1,arr,dp)\n            dp[i][j] = max(op1,op2)\n            return dp[i][j]\n        dp = [[-1]*500]*500\n        ans = solve(0,len(piles)-1,piles,dp)\n        ans2 = sum(piles)-ans\n        return ans>ans2\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def dp(i, j):\n            if i >= j or j >= len(piles): return 0\n            if i + 1 == j:\n                return max(piles[i:j + 1])\n            res = piles[i] + max(dp(i + 2, j), dp(i + 1, j - 1))\n            res = max(res, piles[j] + max(dp(i, j - 2), dp(i + 1, j - 1)))\n            return res\n        return dp(0, len(piles) - 1) > sum(piles)//2\n", "class Solution:\n    # @lru_cache(None)\n    def stoneGame(self, piles: List[int]) -> bool:\n        result = dict()\n        \n        def Alex(start, end) -> int:\n            if start == end:\n                return piles[start]\n            if (start, end) in result:\n                return result[(start, end)]\n            else:\n                result[(start, end)] = max(Lee(start + 1, end) + piles[start], Lee(start, end - 1) + piles[end])\n            return result[(start, end)]\n            \n        def Lee(start, end) -> int:\n            if start == end:\n                return 0\n            if (start, end) in result:\n                return result[(start, end)]\n            else:\n                result[(start, end)] =  min(Alex(start + 1, end), Alex(start, end - 1))\n            return result[(start, end)]\n        Alex(0, len(piles) - 1)\n        summ = sum(piles)\n        # print(result[(0, len(piles - 1))])\n        # print(summ)\n        return result[(0, len(piles) - 1)] > (summ - result[(0, len(piles) - 1)])", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n#         alex = [[0 for x in range(2)] for y in range((len(piles)//2)+1)]\n#         lee = [[0 for x in range(2)] for y in range((len(piles)//2)+1)]\n#         first,last = 0,len(piles)-1\n#         turn = 0\n#         x,y = 1,1\n#         while first < last:\n#             if turn == 0:\n#                 alex[x][0] = max(alex[x-1][0],alex[x-1][1]) + first\n#                 alex[x][1] = max(alex[x-1][0],alex[x-1][1]) + last\n            \n        dp = [[-1 for x in range(len(piles))] for y in range(len(piles))]\n        def recur_dp(si,ei,turn):\n            if si > ei:\n                return 0\n            if dp[si][ei] != -1:\n                return dp[si][ei]\n            if turn == 0: #alex turn\n                start = recur_dp(si+1,ei,1 - turn) + piles[si]\n                end = recur_dp(si,ei-1,1-turn) + piles[ei]\n                dp[si][ei] = max(start,end)\n                return dp[si][ei]\n            else:\n                start = recur_dp(si+1,ei,1-turn) - piles[si]\n                end = recur_dp(si,ei-1,1-turn) - piles[ei]\n                dp[si][ei] = min(start,end)\n                return dp[si][ei]\n        recur_dp(0,len(piles)-1,0)\n        return dp[0][len(piles)-1] >= 0\n            \n        \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        presum = [0]\n        for pile in piles:\n            presum.append(presum[-1]+pile)\n        \n        @lru_cache(None)\n        def solve(a,b):\n            if a==b:\n                return piles[a]\n            return max(presum[b+1]-presum[a]-solve(a+1,b), presum[b+1]-presum[a]-solve(a,b-1))\n        gain = solve(0,len(piles)-1)\n        return gain>presum[-1]-gain\n", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # alex's best score must be greater than total score // 2\n        totalScore = sum(piles)\n        memo = {}\n        \n        @lru_cache(None)\n        def helper(first = 0, last = len(piles) - 1, ):\n            if first > last:\n                return 0\n            isAlex = (last - first - len(piles)) % 2 \n            # total score from this state of the game minus ( - ) min of my opponent's score\n            if isAlex:\n                return max(piles[first] + helper(first + 1, last), piles[last] + helper(first, last - 1))\n            else:\n                return min(-piles[first] + helper(first + 1, last), -piles[last] + helper(first, last - 1))\n            # memo[qstring] = myMaxScore\n            # return myMaxScore\n        \n        return helper() > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        l = len(piles)\n        if l == 0:\n            return False\n        dp = [[0 for i in range(l)] for j in range(l)]\n        \n        for i in range(l):\n            dp[i][i] = piles[i]\n            \n        for i in range(1,l):\n            for j in range(l-i):\n                dp[j][i+j] = max(piles[j]-dp[i+j][j], piles[i+j]-dp[i+j][i+j-1])\n        return dp[0][l-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        # returns the maximum points Alex can get\n        mem = {}\n        def dp(l, r):\n            if l > r:\n                return 0\n            if (l, r) in mem:\n                return mem[(l, r)]\n            alex_turn = ((r - l) % 2 == 1)\n            reward_left = dp(l+1, r)\n            reward_right = dp(l, r-1)\n            if alex_turn:\n                res = max(reward_left + piles[l], reward_right + piles[r])\n            else:\n                res = min(reward_left, reward_right)\n            mem[(l, r)] = res\n            return res\n        \n        reward = dp(0, len(piles)-1)\n        total = sum(piles)\n        return reward > total / 2\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        total = sum(piles)\n        pre_sums = [0] * (len(piles) + 1)\n        \n        for i in range(len(piles)):\n            pre_sums[i+1] = piles[i] + pre_sums[i]\n        \n        m = {}\n        def dfs(start, end):\n            if end == start:\n                return piles[end]\n            if (start, end) in m:\n                return m[(start, end)]\n            interval_total = pre_sums[end+1] - pre_sums[start]\n            max_stone = interval_total - min(dfs(start+1, end), dfs(start, end-1))\n\n            m[(start, end)] = max_stone\n            \n            return max_stone\n        \n        Alex_score = dfs(0, len(piles)-1)\n        if Alex_score > total//2:\n            return True\n        else:\n            return False", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = {}\n        \n        Alex = self.firstscore(0, len(piles), memo, piles)\n        Lee = sum(piles) - Alex\n        return Alex > Lee\n    \n    def firstscore(self, i, j, memo, piles):\n        if i >= j:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        res = max(\n            piles[i] + min(\n                            self.firstscore(i+2, j, memo, piles),\n                            self.firstscore(i+1, j-1, memo, piles)\n                          ),\n            piles[j-1] + min(\n                            self.firstscore(i, j-2, memo, piles),\n                            self.firstscore(i+1, j-1, memo, piles)\n                          )\n                  )\n        \n        memo[(i, j)] = res\n        return res", "class Solution:\n    def __init__(self):\n        self.g=[]        \n    def recurse(self, piles, i, j): \n        if self.g[i][j]:\n            return self.g[i][j]\n        if j - i <= 1:\n            return True\n        self.g[i][j] = self.recurse(piles, i+1, j) or self.recurse(piles, i, j-1)\n        return self.g[i][j]\n    \n    def stoneGame(self, piles: List[int]) -> bool:\n        if not piles: \n            return True\n        self.g = [[False]*len(piles) for i in range(len(piles))]\n        ans= self.recurse(piles, 0, len(piles)-1)\n        return ans", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp=[[-1 for i in range(len(piles))] for j in range(len(piles))]\n        left = 0\n        right = len(piles)-1\n        out = self.helper(piles,left,right,dp,0)\n        if(out>sum(piles)-out):\n            return True\n        return False\n        \n    def helper(self,piles,left,right,dp,flag):\n        if(left>right):\n            return 0\n        \n        if(dp[left][right]!=-1):\n            return dp[left][right]\n        \n        if(flag==0):\n            one = self.helper(piles,left+1,right,dp,1)+piles[left]\n            two = self.helper(piles,left,right-1,dp,1)+piles[right]\n            dp[left][right] = max(one,two)\n            return max(one,two)\n        \n        else:\n            one = self.helper(piles,left+1,right,dp,0)\n            two = self.helper(piles,left,right-1,dp,0)\n            dp[left][right] = min(one,two)\n            return min(one,two)\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        self._visited = {}\n        alex_minus_lee = self.search(piles, 0, len(piles) - 1)\n        return alex_minus_lee > 0\n        \n    \n    def search(self, piles: List[int], start: int, end: int):\n        if start > end:\n            return 0\n        key = (start, end)\n        if key in self._visited:\n            return self._visited[key]\n        \n        score = max(piles[start] - self.search(piles, start + 1, end), \n                    piles[end] - self.search(piles, start, end - 1))\n        \n        self._visited[key] = score\n        \n        return score\n        \n        \n        \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = {}\n        \n        def dfs(i, j, alex):\n            if (i, j, alex) in memo:\n                return memo[i, j, alex]\n            \n            if i >= j:\n                return 0\n            \n            left = dfs(i+1, j, not alex)\n            right = dfs(i, j - 1, not alex)\n            \n            if not alex:\n                ans = min(left, right)\n            else:\n                ans = max(left + piles[i], right + piles[j])\n            \n            memo[i, j, alex] = ans\n            return ans\n        \n        a = dfs(0, len(piles) - 1, True)\n        return a > sum(piles) / 2        ", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        memo = [[-sys.maxsize for i in range(n)] for j in range(n)]\n        \n        def DFS(left:int,right:int)->int:\n            if memo[left][right]!=-sys.maxsize:\n                return memo[left][right]\n            if left>=right:\n                return 0\n            score = max(piles[left]-DFS(left+1,right),piles[right]-DFS(left,right-1))\n            memo[left][right] = score\n            return score\n        \n        \n        return True if DFS(0,n-1)>0 else False", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        l = len(piles)\n        \n        dp = [[[0,0] for _ in range(l+1)] for _ in range(l+1)]\n        \n        for i in range(1, l+1):\n            dp[i][i][0] = piles[i-1]\n            \n        for i in range(l+1,-1,-1):\n            for j in range(i+1, l+1):\n                left = piles[i-1] + dp[i+1][j][1]\n                right = piles[j-1] + dp[i][j-1][1]\n                if left > right:\n                    dp[i][j][0] = left\n                    dp[i][j][1] = dp[i+1][j][0]\n                else:\n                    dp[i][j][0] = right\n                    dp[i][j][1] = dp[i][j-1][0]\n                    \n        return dp[1][l][0] > dp[1][l][1]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        def pmin(i, j):\n            if (i, j) in mincache:\n                return mincache[(i, j)]\n            elif i == j:\n                return piles[i]\n            mincache[(i, j)] = min(pmax(i+1, j), pmax(i, j-1))\n            return mincache[(i, j)]\n        \n        def pmax(i, j):\n            if (i, j) in maxcache:\n                return maxcache[(i, j)]\n            elif i == j:\n                return piles[i]\n            maxcache[(i, j)] = max(piles[i] + pmin(i+1, j),\n                                   piles[j] + pmin(i, j-1))\n            return maxcache[(i, j)]\n        \n        mincache, maxcache = {}, {}\n        p1 = pmax(0, len(piles)-1)\n        p2 = sum(piles) - p1\n        return p1 > p2", "def memoize(f):\n    memo = {}\n    def inner(*args):\n        tup = tuple(args)\n        if tup in memo:\n            return memo[tup]\n        res = f(*args)\n        memo[tup] = res\n        return res\n    return inner\n        \nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = {}\n        def score(i=0, j=len(piles)-1):\n            if i == j: \n                return piles[i]\n            if (i,j) in memo: return memo[(i,j)]\n            lscore = piles[j] - score(i, j-1)\n            rscore = piles[i] - score(i+1, j)\n            result = max(lscore, rscore)\n            memo[(i,j)] = result\n            return result\n        return score() > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        if not piles:\n            return False\n        \n        cache = {}\n        \n        def dfs(l, r):\n            # Calculate the best sum of Alex.\n            if l >= r + 1:\n                return 0\n            if (l, r) in cache:\n                return cache[(l, r)]\n            res = max(piles[l] + min(dfs(l+2, r), dfs(l+1, r-1)), piles[r] + min(dfs(l, r-2), dfs(l+1, r-1)))   \n            cache[(l, r)] = res\n            return cache[(l, r)]\n        \n        \n        sum_a = dfs(0, len(piles) - 1)\n        sum_b = sum(piles) - sum_a\n        # print(sum_a)\n        return sum_a > sum_b", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = {}\n        \n        def helper(i, j):\n            if i == j:\n                return piles[i]\n            if (i, j) in dp:\n                return dp[(i, j)] \n            \n            dp[(i, j)] = max(piles[i]+helper(i+1, j), piles[j]+helper(i, j-1))\n            return dp[(i , j)]\n\n        \n        if helper(0, len(piles)-1) > sum(piles)//2:\n            return True\n        return False\n            \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = {}\n        \n        def backtracking(i, j):\n            if i == j:\n                return piles[i]\n            if not (i + 1, j) in dp:\n                dp[(i + 1, j)] = backtracking(i + 1, j)\n            res = piles[i] - dp[(i + 1, j)]\n            if not (i, j - 1) in dp:\n                dp[(i, j - 1)] = backtracking(i, j - 1)\n            res = max(res, piles[j] - dp[i, j - 1])\n            return res\n        \n        return backtracking(0, len(piles) - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = {}\n        \n        def backtracking(i, j):\n            if i == j:\n                return piles[i]\n            if not (i, j) in dp:\n                dp[(i, j)] = max(piles[i] - backtracking(i + 1, j), piles[j] - backtracking(i, j - 1))\n            return dp[(i, j)]\n        \n        return backtracking(0, len(piles) - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        ''' Use Math one-liner: return True\n        Solution 1. Dynamic Programming:'''\n        n = len(piles)\n        @lru_cache(None)\n        def dp(i, j):\n            if i > j:\n                return 0\n            parity = (j - i - n) % 2\n            if parity == 1: # first player\n                return max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1))\n            else:\n                return min(-piles[i] + dp(i+1, j), -piles[j] + dp(i, j-1))\n        return dp(0, n-1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        '''\n        def optimalMax(piles: List[int]):\n            if len(piles)==1:\n                return piles[0]\n            return max(piles[0]+sum(piles[1:])-optimalMax(piles[1:]),\n                   piles[-1]+sum(piles[:-1])-optimalMax(piles[:-1]))\n        return optimalMax(piles)>sum(piles)/2\n        '''\n        # actual list: piles[i:j]\n        def optimalMax(piles: List[int], dpTable, i,j,sum_):\n            if j-i==1:\n                dpTable[i][j-1]=piles[i]\n                return piles[i]\n            if dpTable[i][j-1]<=0:\n                dpTable[i][j-1]=max(sum_-optimalMax(piles,dpTable,i+1,j,sum_-piles[i]),\n                   sum_-optimalMax(piles,dpTable,i,j-1,sum_-piles[j-1]))\n            return dpTable[i][j-1]\n        dpTable=[[0 for _ in piles] for _ in piles]\n        #print(dpTable)\n        return optimalMax(piles, dpTable,0,len(piles),sum(piles))>sum(piles)/2\n    \n    \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        presum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            presum[i] = presum[i - 1] + piles[i - 1]\n        self.dp = [[0 for j in range(n)] for i in range(n)]\n        ans = self.solve(piles, 0, n - 1, presum)\n        return ans > ans - presum[n]\n        \n    def solve(self, piles, i, j, presum):\n        if self.dp[i][j] > 0:\n            return self.dp[i][j]\n\n        if i == j:\n            return piles[i]\n        \n        result = piles[i] + presum[j] - presum[i] - self.solve(piles, i + 1, j, presum)\n        result = max(result, piles[j] + presum[j - 1] - presum[i - 1] - self.solve(piles, i, j - 1, presum))\n        self.dp[i][j] = result\n        return result", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        @lru_cache(None)\n        def dp(i,j):\n            if i > j:\n                return 0\n            player = (j-i-n) % 2\n            if player == 1:\n                # alex\n                return max(piles[i] + dp(i+1, j), piles[j] + dp(i,j-1))\n            else:\n                # lee: he requires to decrease alex's score, so we need to find the minimum\n                return min(dp(i+1,j)-piles[i], dp(i,j-1)-piles[j])\n        return dp(0, n-1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        alex = 0\n        lee = 0\n        \n        alex_turn = True\n        \n        while len(piles) != 0:\n            maxi = (-1,0)\n            for i in range(len(piles)):\n                if piles[i] > maxi[0]:\n                    maxi = (piles[i], i)\n\n            piles.pop(maxi[1])\n            if alex_turn:\n                alex += maxi[0]\n                alex_turn = False\n            else:\n                lee += maxi[0]\n                alex_turn = True\n        \n        if alex > lee:\n            return True\n        return False", "class Solution:\n    memo = []\n\n    def stoneGame(self, piles: List[int]) -> bool:\n        length = len(piles)\n        self.memo = [[[-1] * (length + 1) for _ in range(length + 1)] for i in range(2)]\n        return (self.helper(0, length-1, piles, 1)) >= 0\n\n    def helper(self, l, r, piles, ID):\n        if l > r:\n            return 0\n        if self.memo[ID][l][r] != -1:\n            return self.memo[ID][l][r]\n\n        next = abs(ID - 1)\n        if ID == 1:\n            self.memo[ID][l][r] = max(piles[l] + self.helper(l + 1, r, piles, next),\n                                      piles[r] + self.helper(l, r - 1, piles, next))\n        else:\n            self.memo[ID][l][r] = min(-piles[l] + self.helper(l + 1, r, piles, next),\n                                      -piles[r] + self.helper(l, r - 1, piles, next))\n        return self.memo[ID][l][r]\n\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # Other solution\n        mem = dict()\n        \n        def search(i, j):\n            if i > j:\n                return 0\n            \n            if (i,j) in mem:\n                return mem.get((i,j))\n            \n            side = (j-i+1) % 2\n            \n            if side == 0:\n                ret = max(search(i+1,j)+piles[i],  search(i,j-1)+piles[j])\n                mem[(i,j)] = ret\n                return ret\n            else:\n                ret = min(search(i+1,j)-piles[i], search(i, j-1)-piles[j])\n                mem[(i,j)] = ret\n                return ret\n            \n            \n            \n        return search(0,len(piles)-1) > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return self.getmax(piles, 0, 0, len(piles)-1, {}) > 0\n    \n    def getmax(self, piles, p, i, j, cache):\n        if (i > j):\n            return 0\n        if (i,j,p) in cache:\n            return cache[(i,j,p)]\n        if p == 0:\n            cache[(i,j,p)] = max(piles[i] + self.getmax(piles, 1, i+1, j, cache), piles[j] + self.getmax(piles, 1, i, j-1, cache))\n        else:\n            cache[(i,j,p)] = min(-piles[i] + self.getmax(piles, 0, i+1, j, cache), -piles[j] + self.getmax(piles, 0, i, j-1, cache))\n        return cache[(i,j,p)]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = {}\n        def find(i,j):\n            if (i,j) in memo:\n                return memo[(i,j)]\n            if j - i == 1:\n                return max(piles[i],piles[j])\n            memo[(i,j)] = max(min(find(i + 1, j-1), find(i + 2, j)) + piles[i], min(find(i + 1, j - 1), find(i, j - 2)) + piles[j])\n            return memo[(i,j)]\n        return find(0,len(piles) - 1) > sum(piles) // 2\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        i = 0\n        j = len(piles) - 1\n        self.memo = {}\n        score = self.recurse(piles, i, j, True)\n        return score > 0\n        \n    \n    \n    def recurse(self, piles, i, j, a_turn):\n        \n        if (i,j) in self.memo:\n            return self.memo[(i,j)]\n        \n        if i == j:\n            return 0\n        \n        if a_turn:\n            l = self.recurse(piles, i+1, j, False) + piles[i]\n            r = self.recurse(piles, i, j-1, False) + piles[j]\n            self.memo[(i,j)] = max(l, r)\n        else:\n            l = self.recurse(piles, i+1, j, True) - piles[i]\n            r = self.recurse(piles, i, j-1, True) - piles[j]\n            self.memo[(i,j)] = min(l, r)\n        return self.memo[(i,j)]", "from collections import defaultdict\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.dp_table = defaultdict(int)\n        \n        def maximize_score_gap(piles,left,right):\n            \n            if left == right:\n                return piles[left]\n            \n            if (left,right) in self.dp_table:\n                return self.dp_table[(left,right)]\n            \n            choose_left = piles[left] - maximize_score_gap( piles, left+1, right)\n            choose_right = piles[right] - maximize_score_gap( piles, left, right-1)\n            \n            self.dp_table[ (left,right) ] = max( choose_left, choose_right )\n            \n            return self.dp_table[(left,right)]\n        \n        score_gap_for_alex = maximize_score_gap( piles, left = 0, right = len(piles)-1 )\n        \n        return score_gap_for_alex > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        def dp(m,n,x):\n            if m>n:\n                return 0\n            if t[m][n]!=-1:\n                return t[m][n]\n            else:\n                if x==0:\n                    self.cost1+=max((dp(m+1,n,1)+piles[m]),dp(m,n-1,1)+piles[n])\n                    t[m][n]=self.cost1\n                    return t[m][n]\n                else:\n                    self.cost2+=max((dp(m+1,n,0)+piles[m]),dp(m,n-1,0)+piles[n])\n                    t[m][n]=self.cost2\n                    return t[m][n]\n        self.cost1=0\n        n=len(piles)\n        self.cost2=0\n        t=[[-1]*(n+1) for  i in range(n+1)]\n        dp(0,n-1,0)\n        print((self.cost1,self.cost2))\n        if self.cost1>self.cost2:\n            return True\n        else:\n            return False\n                \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = [[[0, 0] for _ in range(len(piles))] for _ in range(len(piles))]\n        \n        for i in range(len(piles)):\n            dp[i][i][0] = piles[i]\n            dp[i][i][1] = 0\n        \n        for l in range(1, len(piles)):\n            for r in range(len(piles) - l):\n                c = r + l\n                left = piles[r] + dp[r + 1][c][1]\n                right = piles[c] + dp[r][c - 1][1]\n                dp[r][c][0] = max(left, right)\n                \n                if left > right:\n                    dp[r][c][1] = dp[r + 1][c][0]\n                else:\n                    dp[r][c][1] = dp[r][c - 1][0]\n        \n        return dp[0][len(piles) - 1][0] > dp[0][len(piles) - 1][1]\n", "import numpy as np\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return True", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        prefix = list(itertools.accumulate(piles))\n        \n        @lru_cache(maxsize=None)\n        def getScore(i, j):\n            if i > j:\n                return 0\n            \n            stones = float('-inf')\n            prev = prefix[i - 1] if i - 1 >= 0 else 0\n            stones = max(stones, prefix[j] - prev - getScore(i + 1, j))\n            stones = max(stones, prefix[j] - prev - getScore(i, j - 1))\n            return stones\n            \n        alex_score = getScore(0, len(piles) - 1)\n        if alex_score > prefix[-1] - alex_score:\n            return True\n        return False", "class Solution:\n    \n    def stoneGame(self, piles):\n        \n        n = len(piles)\n        memo = dict()\n        \n        def dp(i,j):\n            if i>j: return 0\n            if (i,j) in memo: return memo[(i,j)]\n            \n            ans = max(piles[i] - dp(i+1, j), piles[j] - dp(i, j-1))\n            memo[(i,j)] = ans\n            return ans\n        return dp(0, n-1) > 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    def stoneGame1(self, piles):\n        # three methods, dp, memo+recursive\n        n = len(piles)\n        \n        memo = dict()\n        def dp(i,j):\n            if i>j: return 0\n            if (i,j) in memo: return memo[(i,j)]\n            \n            if (j-i+n) % 2 == 1: # player 1\n                ans = max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                ans = min(-piles[i] + dp(i+1, j), -piles[j] + dp(i,j-1))\n            memo[(i,j)] = ans\n            return ans\n        return dp(0, n-1) > 0 # \u76f8\u5bf9\u5206\u6570\n    \n    def stoneGame2(self, piles):\n        n = len(piles)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for alen in range(2, n+1):\n            for i in range(0, n-alen+1): # when i=n-alen, alen=n\n                j = i+alen-1 # j - i + 1 = alen, so j = i-1+alen\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        return dp[0][n-1] > 0 # \u76f8\u5bf9\u5206\u6570\n    \n    def stoneGame3(self, piles): # \u8bb0\u5fc6\u5316\u9012\u5f52\u7684\u65b9\u6cd5\uff01\u76f8\u5bf9\u6bd4\u8f83\u5bb9\u6613\u5199\u51fa\u6765\n        n = len(piles)\n        memo = dict()\n        def dp(i,j):\n            if i>j: return 0\n            if (i,j) in memo: return memo[(i,j)]\n            \n            ans = max(piles[i] - dp(i+1,j), piles[j] - dp(i, j-1)) # min-max\u8fc7\u7a0b\n            memo[(i,j)] = ans\n            return ans\n        return dp(0,n-1)>0 # \u76f8\u5bf9\u5206\u6570\uff0c\u4e5f\u5c31\u662f score(alex) - score(lee)\n    \n    def stoneGame4(self, piles):\n        return True\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    def stoneGame3(self, piles):\n        n = len(piles)\n        # dp[i] = max(your stones - op_stones) for piles[i] to piles[i+alen-1] i+alen-1-i+1 = alen = length of piles\n        dp = [0] * n\n        for alen in range(2, n+1):\n            for i in range(0, n-alen+1):\n                dp[i] = max(piles[i] - dp[i+1], piles[i+alen-1] - dp[i]) # \u95ee\u9898\uff0c\u4e8c\u7ef4\u8f6c\u4e00\u7ef4\u7684\u6280\u5de7\u662f\u4ec0\u4e48\uff1f\n        return dp[0] > 0\n    \n    \n    def stoneGame2(self, piles):\n        # dp[i][j] = max(yourscore - op_stones) for piles[i] ~ piles[j]\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        \n        for alen in range(2, n+1): #\u957f\u5ea6\u4e3a\u4ece2\u5230n\uff0c\u6784\u9020\n            for i in range(0, n-alen+1): # i\u8fd9\u4e2a\u5b50\u95ee\u9898\u7684\u8303\u56f4\n                j = i + alen - 1\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n                # j = i + alen - 1 \u4ee3\u5165\n                # dp[i][j] = max(piles[i] - dp[i+1][j], piles[i+alen-1] - dp[i][j-1])\n                # \u7136\u540e\u76f4\u63a5\u628aj\u53bb\u6389:\n                # dp[i] = max(piles[i] - dp[i+1], piles[i+alen-1] - dp[i]) \u5c31\u662f1D\u7684\u5199\u6cd5\u3002\u3002\u3002\n        return dp[0][n-1] > 0\n        \n    \n    def stoneGame1(self, piles: List[int]) -> bool:\n        # minmax + dp \u6216\u8005\u8bb0\u5fc6\u5316\u9012\u5f52\n        # \u4f60\u548c\u5bf9\u624b\u90fd\u662f\u9009\u62e9\u201c\u6700\u4f73\u201d\u7684option\u6765\u9009\u62e9\n        \n        # \u7b2c\u4e00\u79cd\u89e3\u6cd5\uff1aminmax\n        # def score(s, l, r)\n        #    if l>r: return 0\n        #    return max(s[l] - score(s, l+1, r), # left\n        #               s[r] - score(s, l, r-1)) # right\n        #    \u5bf9\u624b\u7684\u6700\u5927\u503c\uff0c\u81ea\u5df1\u7684\u6700\u5c0f\u503c\u4e0b\u7684 \u6700\u5927\u503c\n        #    return score(s, 0, n-1) > 0\n        # time: O(2^n), space O(n)\n        \n        # \u7b2c\u4e8c\u79cd\u89e3\u6cd5\uff1aminmax + memorization / DP\n        # dp[i][j] = best relative score of subarray s[i] ~ s[j]\n        # time O(n^2), space (O^2) -> O(n)\n        \n        # solution 1, recursive, \u4e0d\u8bb0\u5fc6\u4e2d\u95f4\u7ed3\u679c\uff0c\u65e0\u6cd5\u8fbe\u5230\u6700\u4f18\u89e3\uff01O(2^n) \u8bb0\u5fc6\u5316\u9012\u5f52\uff0c\u5bb9\u6613java\u7684stack\u7206\u6389\u3002\u3002\u3002\n        dp = dict()\n        def score(piles, l, r):\n            # left, right\n            if (l,r) in dp:\n                return dp[(l,r)]\n            if l == r:\n                dp[(l,r)] = piles[l] # \u53ea\u5269\u4e0b\u4e00\u5806\u7684\u8bdd\uff0c\u5c31\u53d6\u5b83\u4e86\uff0c\u6ca1\u6709\u5176\u4ed6\u53ef\u4ee5\u9009\u62e9\u7684\u4e86\uff01\n                return piles[l]\n            res = max(piles[l] - score(piles, l+1, r), piles[r] - score(piles, l, r-1))\n            # \u6211\uff0c\u5f53\u524d\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u62ffl\u6216\u8005\u62ffr\uff0c\u5982\u679c\u62ffl\uff0c\u5219\u5f97\u5206\u4e3apiles[l]\uff0c\u5931\u5206\u4e3a\u5bf9\u624b\u4ecel+1,r\u7684\u533a\u95f4\u80fd\u5f97\u5230\u7684\u6700\u5927\u503c\uff08\u5bf9\u624b\u7684\u6700\u5927\u503c\uff0c\u5c31\u662f\u6211\u7684\u6700\u5c0f\u503c\uff09\n            # \u5982\u679c\u62ffr\uff0c\u5219\u5f97\u5206\u4e3apiles[r]\uff0c\u5931\u5206\u4e3a\u5bf9\u624b\u4ecel, r-1\u7684\u533a\u95f4\u80fd\u5f97\u5230\u7684\u6700\u5927\u503c\uff08\u5bf9\u624b\u7684\u6700\u5927\u503c\uff0c\u5c31\u662f\u6211\u7684\u6700\u5c0f\u503c\uff09\n            # \u6240\u4ee5\u8fd9\u4e2a\u8fc7\u7a0b\u5c31\u662f\u7ecf\u5178\u7684minmax\u8fc7\u7a0b\n            dp[(l,r)] = res\n            return res\n        \n        res = score(piles, 0, len(piles)-1) \n        return True if res > 0 else False", "class Solution:\n    # return True would work because Alex always wins the game\n    def stoneGame(self, piles: List[int]) -> bool:\n        prefix = list(itertools.accumulate(piles))\n        \n        @lru_cache(maxsize=None)\n        def getScore(i, j):\n            if i > j:\n                return 0\n            \n            stones = float('-inf')\n            prev = prefix[i - 1] if i - 1 >= 0 else 0\n            stones = max(stones, prefix[j] - prev - getScore(i + 1, j))\n            stones = max(stones, prefix[j] - prev - getScore(i, j - 1))\n            return stones\n            \n        alex_score = getScore(0, len(piles) - 1)\n        if alex_score > prefix[-1] - alex_score:\n            return True\n        return False", "class Solution:\n    \n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        self.piles = piles\n        self.dp = {}\n        \n        def helper(i, j, turn=True):\n            \n            if i > j:\n                return 0\n            if (i,j) in self.dp:\n                return self.dp[(i,j)]\n            alex = 0\n            if turn:\n                alex = max(self.piles[i] + helper(i+1, j, turn=False), self.piles[j] + helper(i, j-1, turn=False))\n            else:\n                alex = max(helper(i+1, j, turn=True), helper(i, j-1, turn=True))\n            \n            self.dp[(i,j)] = alex\n            return self.dp[(i,j)]\n                \n        \n        alex = helper(0,len(self.piles)-1)\n        return 2*alex > sum(self.piles)", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = {}\n        def subseq(i, j):\n            if (i,j) in memo:\n                return memo[(i,j)]\n            if i > j:\n                return 0\n            if (j - i - len(piles)) % 2:\n                memo[(i,j)] = max(piles[i] + subseq(i+1, j), piles[j] + subseq(i, j-1))\n            else:\n                memo[(i,j)] = min(-piles[i] + subseq(i+1, j), -piles[j] + subseq(i, j-1))\n            return memo[(i,j)]\n        return subseq(0, len(piles)-1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = {}\n        def inner(i,j, chance):\n            if i == j and chance:\n                return piles[i]\n            if i > j:\n                return 0\n            if dp.get((i,j,chance)) == None:\n                if chance:\n                    dp[(i,j,chance)] = max(piles[i]+inner(i+1,j, False), piles[j]+inner(i,j-1, False))\n                else:\n                    dp[(i,j,chance)] = max(inner(i+1,j, True), inner(i,j-1, True))\n            return dp[(i,j,chance)]\n        a = inner(0,len(piles)-1, True)\n        return True if a > (sum(piles)-a) else False\n", "from collections import defaultdict\n\ndef maxsum(piles,left,right,memo):\n    if memo[left,right]:\n        return memo[left,right]\n    \n    if left==right:\n        return piles[left],0\n    \n    y1,x1 = maxsum(piles,left+1,right,memo)\n    y2,x2 = maxsum(piles,left,right-1,memo)\n    \n    if x1+piles[left]<x2+piles[right]:\n        memo[left,right]=x2+piles[right],y2\n    else:\n        memo[left,right]=x1+piles[left],y1\n    \n    return memo[left,right]\n    \n    \n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = defaultdict(int)\n        \n        x,y = maxsum(piles,0,len(piles)-1,memo)\n        \n        return True if x>y else False", "from collections import defaultdict\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        self.dp_table = defaultdict( int )\n        \n        def maximize_score_gap( piles, left, right):\n            \n            if left == right:\n                # Base case\n                # only one pile of stone remains\n                return piles[left]\n            \n            if (left, right) in self.dp_table:\n                # Directly return if this case has been computed before\n                return self.dp_table[ (left, right)] \n            \n            # Use optimal substructure to compute maximized score gap\n            choose_left = piles[left] - maximize_score_gap( piles, left+1, right)\n            choose_right = piles[right] - maximize_score_gap( piles, left, right-1)\n            \n            # update DP table\n            self.dp_table[ (left,right) ] = max( choose_left, choose_right )\n            \n            return self.dp_table[ (left,right) ]\n        \n        # ------------------------------------------------\n        \n        score_gap_for_alex = maximize_score_gap( piles, left = 0, right = len(piles)-1 )\n        \n        return score_gap_for_alex > 0", "class Solution:\n    def stoneGame(self, piles):\n        cache = {}\n        piles = tuple(piles)\n        \n    \n        res = [0]\n        for k in range(len(piles)):\n            res.append(res[-1] + piles[k])\n        \n        \n        def firstscore(i,j):\n            if i>=j: return 0\n            if j==i+1 and j < len(piles): return piles[i]\n            if (i,j) in cache: return cache[i,j]\n            r = max(res[j] - res[i] - firstscore(i + 1, j), res[j] - res[i] - firstscore(i, j - 1))\n            cache[i,j] = r\n            return r\n\n        Alex = firstscore(0,len(piles))\n        Lee = sum(piles) - Alex\n        return Alex > Lee", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles) // 2\n        dp1 = [0] * (N + 1)\n        dp2 = [0] * (N + 1)\n        \n        rot = 0\n        temp = piles.copy()\n        \n        i = 1\n        while len(temp) > 0:\n            alex = max(temp[0], temp[-1])\n            if temp[0] == temp[-1]:\n                rot += 1\n            if alex == temp[0]:\n                dp1[i] = dp1[i - 1] + temp[0]\n                temp.pop(0)\n            else:\n                dp1[i] = dp1[i - 1] + temp[-1]\n                temp.pop()\n            print(alex)\n            print(temp)\n            lee = max(temp[0], temp[-1])\n            if temp[0] == temp[-1]:\n                rot += 1\n                \n            if lee == temp[0]:\n                dp2[i] = dp2[i - 1] + temp[0]\n                temp.pop(0)\n            else:\n                dp2[i] = dp2[i - 1] + temp[-1]\n                temp.pop()\n            print(lee)\n            print(temp)\n            i += 1\n        print(dp1)\n        print(dp2)\n        \n        if rot > 0:\n            return True\n        return dp1[-1] > dp2[-1]\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        sums = [0] + list(itertools.accumulate(piles))\n        def get_sum(i, j):\n            return sums[j+1] - sums[i]\n        \n        n = len(piles)\n        dp = [[-1]*n for _ in range(n)]\n        def solve(i, j):\n            if i > j:\n                return 0\n            if i == j:\n                return piles[i]\n            if dp[i][j] >= 0:\n                return dp[i][j]\n            sa = piles[i] + get_sum(i+1, j) - solve(i+1, j)\n            sb = piles[j] + get_sum(i, j-1) - solve(i, j-1)\n            dp[i][j] = max(sa, sb)\n            return dp[i][j]\n        alice = solve(0, len(piles)-1)\n        return alice > get_sum(0, n-1) - alice\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        self.memo = {}\n        \n        def dfs(l, r, isAlex, alexSum, leeSum):\n            key = (l, r, isAlex)\n            \n            if key in self.memo:\n                return self.memo[key]\n            \n            if l == r:\n                leeSum += piles[l]\n                r = (alexSum > leeSum)\n                self.memo[key] = r\n                return r\n            \n            if isAlex:\n                r1 = dfs(l+1, r, False, alexSum + piles[l], leeSum)\n                r2 = dfs(l, r-1, False, alexSum + piles[r], leeSum)\n            else:\n                r1 = dfs(l+1, r, True, alexSum, leeSum + piles[l])\n                r2 = dfs(l, r-1, True, alexSum, leeSum + piles[r])\n                \n            self.memo[key] = r1 or r2\n            return r1 or r2\n        \n        return dfs(0, len(piles) -1, True, 0, 0)", "class Solution:\n    from functools import lru_cache\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        \n        @lru_cache(None)\n        def dp(i, j, asum, lsum, aturn):\n            \n            if i > j:\n                return (0, 0)\n            \n            if aturn:\n                asum += max(piles[i] + dp(i+1, j, asum, lsum, False)[0], piles[j] + dp(i, j-1, asum, lsum, False)[0])\n            else:\n                lsum += max(piles[i] + dp(i+1, j, asum, lsum, True)[1], piles[j] + dp(i, j-1, asum, lsum, True)[1])\n            \n            return (asum, lsum)\n        \n        asum, lsum = dp(0, n-1, 0, 0, True)\n\n        return bool(asum - lsum)", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # Other solution\n        self.dic = {}\n        self.length = len(piles)\n        \n        def search(i,j):\n            if i > j:\n                return 0\n            \n            if (i,j) in self.dic:\n                return self.dic.get((i,j))\n            \n            parity = (j-i+1) % 2\n            \n            if parity == 0:\n                ret1 = max(piles[i]+search(i+1,j), piles[j]+search(i,j-1))\n                self.dic[(i,j)] = ret1\n                return ret1\n            else:\n                ret2 = min(-piles[i]+search(i+1,j), -piles[j]+search(i,j-1))\n                self.dic[(i,j)] = ret2\n                return ret2\n            \n        return search(0,self.length-1) > 0\n", "class Solution:\n    def __init__(self):\n        self.result=False\n    \n    def backtrack(self,arr,start,end,alex,lee,count,visited):\n        if start>end and lee<alex:\n              return 1\n        elif start>end:\n            return 0\n        elif visited[start][end]!=-1:\n            return visited[start][end]\n        else:\n            a,b=0,0\n            if count%2==0:                a=max(self.backtrack(arr,start+1,end,alex+arr[start],lee,count+1,visited),self.backtrack(arr,start,end-1,alex+arr[end],lee,count+1,visited))\n            else:                b=max(self.backtrack(arr,start+1,end,alex,lee+arr[start],count+1,visited),self.backtrack(arr,start,end-1,alex,lee+arr[end],count+1,visited))\n            visited[start][end]=max(visited[start][end],a,b)\n            return visited[start][end]    \n                \n    def stoneGame(self, piles: List[int]) -> bool:\n        n=len(piles)\n        visited=[-1 for i in range(n)]\n        for i in range(n):\n            visited[i]=[-1 for i in range(n)]\n        \n        if self.backtrack(piles,0,len(piles)-1,0,0,0,visited):\n            return True\n        return False\n        \n        \n        \n", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        A = piles\n        Ans = {}\n        def hello(st,end,turn):\n            if st > end:\n                return 0\n            if Ans.get((st,end),None) != None:\n                return  Ans[(st,end)]\n            if turn%2 == 0:\n                t = max(A[st]+hello(st+1,end,turn+1),A[end]+hello(st,end-1,turn+1))\n                Ans[(st,end)] = t\n                return t\n            else:\n                t = min(hello(st+1,end,turn+1)-A[st],hello(st,end-1,turn+1)-A[end])\n                Ans[(st,end)] = t\n                return t\n        t = hello(0,len(A)-1,0)\n        return t > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[-1 for _ in range(n) ] for _ in range(n)]\n\n        def score_helper(l, r):\n            if l > r:\n                return 0\n            if l == r:\n                return piles[l]\n            if dp[l][r] != -1:\n                return dp[l][r]\n            dp[l][r] = max(piles[l] - dp[l+1][r], piles[r]-dp[l][r-1])\n            return score_helper(0, n-1)\n        \n        return score_helper(0, n-1) >= 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        mat = [[[0,0] for c in range(n)] for r in range(n)]\n        for r in range(n):\n            mat[r][r][0] = piles[r]\n        for diff in range(1,n):\n            for r in range(0, n-diff):\n                c = r + diff\n                left_ = mat[r][c-1]\n                picker_1 = left_[1]+piles[c]\n                other_1 = left_[0]\n                right_ = mat[r+1][c]\n                picker_2 = right_[1] + piles[r]\n                other_2 = right_[0]\n                mat[r][c] = (max(picker_1, picker_2), min(other_1, other_2))\n                \n        if mat[-1][-1][0] > mat[-1][-1][1]:\n            return True\n        return False\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = {}\n        \n        for i in range(n):\n            dp[(i,i)] = [piles[i],0]\n        \n        for i in range(n - 2, - 1,-1):\n            for j in range(i + 1,n):\n                left = [dp[(i + 1,j)][1] + piles[i],dp[(i + 1,j)][0]]\n                right = [dp[(i,j - 1)][1] + piles[j],dp[(i,j - 1)][0]]\n\n                dp[(i,j)] = max ( left ,right)         \n        return dp[(0,n - 1)][0] > dp[(0,n - 1)][1]", "from functools import lru_cache\n@lru_cache(maxsize=None)\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        A = piles\n        Ans = {}\n        def hello(st,end,turn):\n            if st > end:\n                return 0\n            if Ans.get((st,end),None) != None:\n                return  Ans[(st,end)]\n            if turn%2 == 0:\n                t = max(A[st]+hello(st+1,end,turn+1),A[end]+hello(st,end-1,turn+1))\n                Ans[(st,end)] = t\n                return t\n            else:\n                t = min(hello(st+1,end,turn+1)-A[st],hello(st,end-1,turn+1)-A[end])\n                Ans[(st,end)] = t\n                return t\n        t = hello(0,len(A)-1,0)\n        return t > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.mp = {}\n        t = self.foo(0, len(piles) - 1, piles)\n        return sum(piles) < 2 * t\n\n    def foo(self, i, j, p):\n        if i == j:\n            return p[i]\n        \n        key = str(i) + str(j)\n        if key in self.mp:\n            return self.mp[key]\n        v = max(\n            p[i] + self.foo(i + 1, j, p),\n            p[j] + self.foo(i, j - 1, p),\n        )\n        \n        self.mp[key] = v\n        return v\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.cache = {}\n        self.piles = piles\n        return self.minimax(0, len(piles) - 1, True) > 0\n    \n    def minimax(self, l, r, is_alex):\n        if (l, r) in self.cache: return self.cache[(l, r)]\n    \n        if l > r: return 0\n        \n        piles = self.piles\n        \n        if is_alex:\n            res = max(self.minimax(l + 1, r, False) + piles[l], self.minimax(l, r - 1, False) + piles[r])\n            self.cache[(l, r)] = max(self.cache[(l, r)], res) if (l, r) in self.cache else res\n        else:\n            res = min(self.minimax(l + 1, r, True) - piles[l], self.minimax(l, r - 1, True) - piles[r])\n            self.cache[(l, r)] = max(self.cache[(l, r)], res) if (l, r) in self.cache else res\n        return self.cache[(l, r)]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp=[[[0,0] for _ in range(len(piles))]for _ in range(len(piles))]\n        # print(dp)\n        for i in range(len(piles)):\n            dp[i][i]=[piles[i],0]\n        # print(dp)\n        for i in range(len(piles)-1,-1,-1):\n            for j in range(i,len(piles)):\n                if i==j:\n                    continue\n                a=max(dp[i+1][j][1]+piles[i],dp[i][j-1][1]+piles[j])\n                dp[i][j]=[a,0]\n                if dp[i][j][0]==dp[i+1][j][1]+piles[i]:\n                    dp[i][j][1]=dp[i+1][j][0]\n                else:\n                    dp[i][j][1]=dp[i][j-1][0]\n        \n        if dp[0][len(piles)-1][0]>dp[0][len(piles)-1][1]:\n            return True\n        return False\n                \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n        \n        # this is actually min max tree traversal :D\n        @lru_cache(None)\n        def recursion(i, j):\n            if i > j:\n                return 0\n            curr_len = (j - i)\n            if curr_len % 2 == 0:\n                return min(-piles[i] + recursion(i+1, j), -piles[j] + recursion(i, j-1))\n            else:\n                return max(piles[i] + recursion(i+1, j), piles[j] + recursion(i, j-1))\n        \n        return recursion(0, N - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        l = len(piles)\n        dp = [[[piles[i] * (i == j), 0] for j in range(l)] for i in range(l)]\n        for d in range(1, l):\n            for w in range(l - d):\n                x, y = w, w + d\n                l1, l2, r1, r2 = dp[x + 1][y] + dp[x][y - 1]\n                dp[x][y] = max([l2 + piles[x], l1], [r2 + piles[y], r1])\n        return dp[0][-1][0] > dp[0][-1][1]\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        if not piles:\n            return False\n        n = len(piles)\n        return self.helper(0, n-1, piles, 0, 0, 1, {})\n    \n    def helper(self, left, right, piles, scoreA, scoreB, isPlayerA, memo):\n        if left > right:\n            return scoreA > scoreB\n        \n        if (left, right, isPlayerA) in memo:\n            return memo[(left, right, isPlayerA)]\n        \n        if isPlayerA:\n            res = self.helper(left+1, right, piles, scoreA + piles[left], scoreB, 1-isPlayerA, memo) or self.helper(left, right-1, piles, scoreA + piles[right], scoreB, 1-isPlayerA, memo)\n        else:\n            res = self.helper(left+1, right, piles, scoreA, scoreB + piles[left], 1-isPlayerA, memo) or self.helper(left, right-1, piles, scoreA, scoreB + piles[right], 1- isPlayerA, memo)\n        \n        memo[(left, right, isPlayerA)] = res\n        return res\n        \n        \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[None] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = [piles[i], 0]\n        for k in range(2, n+1):\n            for i in range(n-k+1):\n                j = i + k - 1\n                first = max(piles[i] + dp[i+1][j][1], piles[j] + dp[i][j-1][1])\n                second = min(dp[i+1][j][0], dp[i][j-1][0])\n                dp[i][j] = [first, second]\n        return dp[0][-1][0] > dp[0][-1][1]", "class Solution:\n    \n    @staticmethod\n    def f(piles, start, end, cache, sums):\n        if cache[start][end] == -1:\n            cache[start][end] = max(\n                piles[start] + sums[end + 1] - sums[start + 1] - Solution.f(piles, start + 1, end, cache, sums),\n                piles[end] + sums[end] - sums[start] - Solution.f(piles, start, end - 1, cache, sums)\n            )\n        return cache[start][end]\n    \n    def stoneGame(self, piles: List[int]) -> bool:\n        cache = [[-1] * len(piles) for i in range(len(piles))]\n        sums = [0] * (len(piles) + 1)\n        for i in range(len(piles)):\n            sums[i + 1] = sums[i] + piles[i]\n            cache[i][i] = piles[i]\n        alex = Solution.f(piles, 0, len(piles) - 1, cache, sums)\n        return alex > sums[-1] - alex\n", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles):\n        N = len(piles)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0", "class Solution:\n    def stoneGame(self, piles):\n        \n        def dp(piles, l, r, memo):\n            if l > r:\n                return 0\n            if (l,r) in memo:\n                return memo[(l,r)]\n            op1 = piles[l] - dp(piles, l+1, r, memo)\n            op2 = piles[r] - dp(piles, l, r-1, memo)\n            stone = max(op1, op2)\n            memo[(l,r)] = stone\n            return stone\n        \n        return dp(piles, 0, len(piles)-1, {}) > 0\n            \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def dfs(i, j, isAlex):\n            if j < i: return 0\n            elif i == j: return piles[i] if isAlex else -piles[i]\n            if isAlex:\n                return max(piles[i]+dfs(i+1, j, not isAlex), piles[j]+dfs(i, j-1, not isAlex))\n            else:\n                return min(-piles[i]+dfs(i+1, j, not isAlex), -piles[j]+dfs(i, j-1, not isAlex))\n        \n        if not piles: return False\n        n = len(piles)\n        \n        return dfs(0, n-1, True) > 0\n    \n    def stoneGame(self, piles: List[int]) -> bool:\n        if not piles: return False\n        n = len(piles)\n        nums = piles\n        dp = [[[None, None] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i][0] = -nums[i]\n            dp[i][i][1] = nums[i]\n        for l in range(1, n):\n            for i in range(n-l):\n                j = i+l\n                dp[i][j][0] = min(-nums[i]+dp[i+1][j][1], -nums[j]+dp[i][j-1][1])\n                dp[i][j][1] = max(nums[i]+dp[i+1][j][0], nums[j]+dp[i][j-1][0])\n                \n        return dp[0][n-1][1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        self.memo = [[float('-inf') for _ in range(n)] for _ in range(n)]\n        return self.dfs(piles, 0, n - 1) > 0\n    \n    def dfs(self, piles, left, right):\n        if left == right:\n            return piles[left]\n        \n        if self.memo[left][right] == float('-inf'):\n            self.memo[left][right] = max(piles[left] - self.dfs(piles, left + 1, right), piles[right] - self.dfs(piles, left, right - 1))\n        \n        return self.memo[left][right]\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = dict()\n        return self.find(piles, 0, 0, True, 0, len(piles)-1, memo)\n        \n    def find(self, piles, a_score, b_scord, is_a, front, end, memo):\n        if front > end:\n            return a_score > b_scord\n        \n        key = (front, end)\n        if key in memo:\n            return memo[key]\n        \n        \n        if is_a:\n            res = self.find(piles, a_score + piles[front], b_scord, not is_a, front + 1, end, memo) or self.find(piles, a_score + piles[end], b_scord, not is_a, front, end-1, memo)\n        else:\n            res = self.find(piles, a_score, b_scord + piles[front], not is_a, front + 1, end, memo) or self.find(piles, a_score, b_scord + piles[end], not is_a, front, end-1, memo)\n        \n        memo[key] = res\n        return res\n        \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return self.dfs(piles, 0, len(piles) - 1, {})\n        \n    def dfs(self, piles, start, end, memo):\n        if start > end:\n            return 0\n        elif start == end:\n            return piles[start]\n        elif (start, end) in memo:\n            return memo[(start, end)]\n        \n        # choose one which is most optimal for the player\n        L = piles[start] - self.dfs(piles, start + 1, end, memo)\n        R = piles[end] - self.dfs(piles, start, end - 1, memo)\n        memo[(start, end)] = max(L, R)\n        return memo[(start, end)]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def dfs(i, j):\n            if i == j:\n                return piles[i]\n            \n            return max(piles[i] - dfs(i + 1, j), piles[j] - dfs(i, j - 1))\n        \n        return dfs(0, len(piles) - 1) > 0", "class Solution:\n    from functools import lru_cache\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        \n        @lru_cache(None)\n        def dp(i, j, asum, lsum, aturn):\n            \n            if i > j:\n                return (0, 0)\n            \n            if aturn:\n                asum += max(piles[i] + dp(i+1, j, asum, lsum, False)[0], piles[j] + dp(i, j-1, asum, lsum, False)[0])\n            else:\n                lsum += max(piles[i] + dp(i+1, j, asum, lsum, False)[1], piles[j] + dp(i, j-1, asum, lsum, False)[1])\n            \n            return (asum, lsum)\n        \n        asum, lsum = dp(0, n-1, 0, 0, True)\n\n        return bool(asum - lsum)", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles):\n        N = len(piles)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # The value of the game [piles[i], piles[i+1], ..., piles[j]].\n            if i > j: return 0\n            parity = (j - i - N) % 2\n            if parity == 1:  # first player\n                return max(piles[i] + dp(i+1,j), piles[j] + dp(i,j-1))\n            else:\n                return min(-piles[i] + dp(i+1,j), -piles[j] + dp(i,j-1))\n\n        return dp(0, N - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def dp(i, j):\n            if i + 1 == j:\n                arr = piles[i + 1: j + 1]\n                return max(arr) - min(arr)\n            \n            \n            L, R = piles[i], piles[j]\n            \n            return max(L - R + dp(i + 1, j), R - L + dp(i, j - 1))\n        \n        return dp(0, len(piles) - 1) > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.f_map, self.s_map = dict(), dict()\n        _sum = sum(piles)\n        alex = self.f(piles, 0, len(piles)-1)\n        return alex > _sum/2\n    \n    def f(self, piles, start, end):\n        if start == end:\n            return piles[start]\n        if ((start, end) not in self.f_map):\n            v_val = max(piles[start] + self.s(piles, start + 1, end), piles[end] + self.s(piles, start, end-1))\n            self.f_map[(start, end)] = v_val\n        return self.f_map[(start, end)]\n    \n    def s(self, piles, start, end):\n        if start == end:\n            return piles[start]\n        if ((start, end) not in self.s_map):\n            v_val = max(piles[start] + self.f(piles, start + 1, end), piles[end] + self.f(piles, start, end-1))\n            self.s_map[(start, end)] = v_val\n        return self.s_map[(start, end)]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        if len(piles) == 0:\n            return False\n        ans = []\n        l = len(piles)\n        for i in range(l):\n            ans.append(max(piles[0], piles[-1]))\n            piles.remove(max(piles[0], piles[-1]))\n            print(ans)\n        if ans[-2]>=ans[-1]:\n            return True", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n    \n\n        @lru_cache(None)\n        def dp(i, j):\n            if i > j:\n                return 0\n            term = (j - i) % 2\n            if term == 1:\n                return max(dp(i + 1, j) + piles[i] , dp(i, j -1) + piles[j])\n            else:\n                return min(dp(i + 1, j) - piles[i] , dp(i, j - 1) - piles[j])\n        return dp(0, len(piles) - 1) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        @lru_cache(None)\n        def sumRange(i, j):\n            if i == j: return piles[i]\n            else: return piles[i] + sumRange(i + 1, j)\n        @lru_cache(None)\n        def dp(i, j):\n            if i == j:\n                return piles[i]\n            else:\n                return max(piles[i] + sumRange(i+1, j) - dp(i + 1, j),\n                          piles[j] + sumRange(i, j - 1) - dp(i, j - 1))\n        Alex = dp(0, n-1)\n        Lee = sumRange(0, n-1) - Alex\n        return Alex > Lee", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        cache = {}\n        def firstscore(i, j):\n            if i >= j: \n                return 0\n            # if j == i+1 and j < len(piles): #because [i, j)\n            #     return piles[i] \n            if (i, j) in cache:\n                return cache[i, j]\n            res = max(piles[i] + min(firstscore(i+2, j), firstscore(i+1, j-1)), \n                              piles[j - 1] + min(firstscore(i+1, j-1), firstscore(i, j-2)))\n            cache[i, j] = res\n            return cache[i, j]\n        Alex = firstscore(0, len(piles))\n        Lee = sum(piles) - Alex\n        return Alex > Lee\n        \n", "import numpy as np\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = np.empty((n,n))\n        for j in range(1,n):\n            dp[j-1,j] = abs(piles[j-1]-piles[j])\n\n        for j in range(3,n,2):\n            for i in range(0,n-j):\n                #want to get dp[i,i+j]\n                #crrespond dp[i,i+j-2] dp[i+1,i+j-1],dp[i-2,i+j]\n                temp1 = piles[i+j]+min(-piles[i+j-1]+dp[i,i+j-2],-piles[i]+dp[i+1,i+j-1])\n                temp2 = piles[i]+min(-piles[i+1]+dp[i+2,i+j],-piles[i+j]+dp[i+1,i+j-1])\n                dp[i,i+j] = max(temp1,temp2)\n        if dp[0,n-1]>0:\n            return True\n        else: return False\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = {}\n        def dfs(i, j, Alex, Lee, who):\n            if (i, j) not in dp:\n                if i > j:\n                    return Alex, Lee\n                if who:\n                    Alextmp1, Leetmp1 = dfs(i + 1, j - 0, Alex + piles[i], Lee, not who)\n                    Alextmp2, Leetmp2 = dfs(i + 0, j - 1, Alex + piles[j], Lee, not who)\n                    if Alextmp1 - Alex > Alextmp2 - Alex:\n                        dp[i, j] = Alextmp1 - Alex, Leetmp1 - Lee\n                    else:\n                        dp[i, j] = Alextmp2 - Alex, Leetmp2 - Lee\n                else:\n                    Alextmp1, Leetmp1 = dfs(i + 1, j - 0, Alex, Lee + piles[i], not who)\n                    Alextmp2, Leetmp2 = dfs(i + 0, j - 1, Alex, Lee + piles[j], not who)\n                    if Leetmp1 - Lee > Leetmp2 - Lee:\n                        dp[i, j] = Alextmp1 - Alex, Leetmp1 - Lee\n                    else:\n                        dp[i, j] = Alextmp2 - Alex, Leetmp2 - Lee\n            return Alex + dp[i, j][0], Lee + dp[i, j][1]\n\n        Alex, Lee = dfs(0, len(piles) - 1, 0, 0, True)\n        #print(Alex, Lee)\n        if Alex > Lee:\n            return True\n        else:\n            return False\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.result_cache = {}\n        def f(low, high, nums):\n            if low > high:\n                return 0\n            if low == high:\n                return nums[low]\n            if (low, high) in self.result_cache:\n                return self.result_cache[(low, high)]\n            l = nums[low]  + min(f(low + 2, high, nums), f(low + 1, high - 1 , nums))\n            h = nums[high] + min(f(low + 1, high - 1, nums), f(low, high - 2, nums))\n            r = max(l, h)\n            self.result_cache[(low, high)] = r\n            return r\n        p1 = f(0, len(piles) - 1, piles)\n        p2 = sum(piles) - p1\n        return p1 > p2\n", "class Solution:\n    def dp(self, i, j):\n        if (i, j) in self.memo:\n            return self.memo[(i, j)]\n        if i > j:\n            return (0, 0)\n        \n        firstTakeLeft, firstTakeRight = self.piles[i] + self.dp(i+1, j)[1], self.piles[j] + self.dp(i, j-1)[1]\n        if firstTakeLeft > firstTakeRight:\n            self.memo[(i, j)] = (firstTakeLeft, self.dp(i+1,j)[0])\n        else:\n            self.memo[(i, j)] = (firstTakeRight, self.dp(i, j-1)[0])\n        \n        return self.memo[(i, j)]\n\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.piles = piles\n        self.memo = {}\n\n        for i in range(len(piles)):\n            self.memo[(i, i)] = (piles[i], 0)\n        \n        fir, sec = self.dp(0, len(piles)-1)\n\n        return fir >= sec", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = [[-1 for _ in range(len(piles))] for _ in range(len(piles))]\n        return self.recursive(0, 0, len(piles) - 1, 0, 0, piles, memo)\n    \n    def recursive(self, turn, left_idx, right_idx, sum1, sum2, piles, memo):\n        # Base Case\n        if left_idx >= right_idx:\n            return sum1 > sum2\n        \n        if memo[left_idx][right_idx] != -1:\n            return memo[left_idx][right_idx]\n        \n        \n        if turn % 2 == 0:\n            res = self.recursive(turn + 1, left_idx + 1, right_idx, sum1 + piles[left_idx], sum2, piles, memo) or self.recursive(turn + 1, left_idx, right_idx - 1, sum1 + piles[right_idx], sum2, piles, memo)\n        else:\n            res =  self.recursive(turn + 1, left_idx + 1, right_idx, sum1, sum2 + piles[left_idx], piles, memo) or self.recursive(turn + 1, left_idx, right_idx - 1, sum1, sum2 + piles[right_idx], piles, memo)\n        \n        memo[left_idx][right_idx] = res\n        return memo[left_idx][right_idx]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        memo = {}\n        def netWin(left, right):\n            \n            if (left, right) not in memo:\n                if left > right:\n                    return 0\n                \n                memo[(left, right)] = -float('inf')\n                memo[(left, right)] = max(memo[(left, right)], piles[left] - netWin(left + 1, right))\n                memo[(left, right)] = max(memo[(left, right)], piles[right] - netWin(left, right - 1))\n                \n            return memo[(left, right)]\n        \n        res = netWin(0, len(piles) - 1)\n        # print (memo, res)\n        return True if res > 0 else False", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        \n        @lru_cache(None)\n        # dp(i, j) max net score alex can get\n        def dp(i, j):\n            if i > j:\n                return 0\n            if (n - j + i) % 2 == 1: # alex plays\n                return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n            return min(dp(i + 1, j) - piles[i], dp(i, j - 1) - piles[j])\n        return dp(0, n - 1) > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        memo = {}\n        def netWin(left, right):\n            \n            if (left, right) not in memo:\n                if left > right:\n                    return 0\n                \n                memo[(left, right)] = -float('inf')\n                memo[(left, right)] = max(memo[(left, right)], piles[left] - netWin(left + 1, right))\n                memo[(left, right)] = max(memo[(left, right)], piles[right] - netWin(left, right - 1))\n                \n            return memo[(left, right)]\n        \n        res = netWin(0, len(piles) - 1)\n        # print (memo, res)\n        return True if res > 0 else False\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = [[[0 for i in range(2)] for z in range(len(piles))] for j in range(len(piles))]\n        for i in range(len(dp)):\n            dp[i][i] = [piles[i], 0]\n \n        for i in range(len(dp)-2, -1, -1):\n            for j in range(i+1, len(dp[0])):\n                left = piles[i] + dp[i+1][j][1]\n                right = piles[j] + dp[i][j-1][1]\n                if left > right:\n                    dp[i][j][0] = left\n                    dp[i][j][1] = dp[i+1][j][0]\n                else:\n                    dp[i][j][0] = right\n                    dp[i][j][1] = dp[i][j-1][0]\n        res = dp[0][-1]\n        if dp[0][-1][0] - dp[0][-1][1] > 0:\n            return True\n        else:\n            return False\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        l = len(piles)\n        dp = [[-1 for i in range(l)] for j in range(l)]\n        def solve(piles, i, j, tot):\n            alex = (j-i-l) % 2\n            if i == j:\n                if alex:\n                    tot += piles[i]\n                return tot > 0\n\n            if dp[i][j] != -1:\n                return dp[i][j]\n            if alex:\n                if solve(piles, i+1, j, tot+piles[i]):\n                    dp[i][j] = True\n                    return True\n                dp[i][j]= solve(piles, i, j-1, tot+piles[j])\n                return dp[i][j]\n            else:\n                if solve(piles, i+1, j, tot-piles[i]):\n                    dp[i][j] = True\n                    return True\n                dp[i][j]= solve(piles, i, j-1, tot-piles[j])\n                return dp[i][j]\n            \n        return solve(piles, 0, l-1, 0)", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        table = [[False] * (n+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            table[i][i] = True\n        \n        for row in range(n-1, -1, -1):\n            for col in range(row, n+1):\n                if table[row][col-1] == False:\n                    table[row][col] = True\n                if table[row+1][col] == False:\n                    table[row][col] = True\n        return table[0][n]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        self.dp = [[None for i in range(len(piles))] for i in range(len(piles))]\n        self.func(piles, 0, 0, len(piles)-1, 0, 0)\n        return self.dp[0][len(piles)-1]\n    \n    \n    def func(self, arr, turn, i, j, a, b):\n        if self.dp[i][j] == True:\n            return True\n        elif self.dp[i][j] == False:\n            return False\n\n        if  i == j:\n            b += arr[i]\n            self.dp[i][j] = a > b\n            return self.dp[i][j]\n\n        if not turn:\n            self.dp[i][j] = self.func(arr, turn^1, i+1, j, a+arr[i], b) or self.func(arr, turn^1, i, j-1, a+arr[j], b)\n            return self.dp[i][j]\n        else:\n            self.dp[i][j] = self.func(arr, turn^1, i+1, j, a, b+arr[i]) or self.func(arr, turn^1, i, j-1, a, b+arr[j])\n            return self.dp[i][j]\n    \n    \n        \n    # Gives TLE\n    # def recur(self, arr, turn, a, b):\n    #     if len(arr) == 1:\n    #         b += arr[0]\n    #         return a > b\n    #     if not turn:\n    #         return self.recur(arr[1:], turn^1, a+arr[0], b) or self.recur(arr[:-1], turn^1, a+arr[-1], b)\n    #     else:\n    #         return self.recur(arr[1:], turn^1, a, b+arr[0]) or self.recur(arr[:-1], turn^1, a, b+arr[-1])\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = piles.copy()\n        for i in range(len(piles)-2, -1, -1):\n            for j in range(i+1, len(piles)):\n                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])\n        \n        return dp[len(dp) - 1] > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i, -1 , -1):\n                if i == j:\n                    dp[i] = piles[i]\n                else:\n                    dp[j] = max(piles[i] - dp[j], piles[j] - dp[j+1])\n        return dp[0] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [piles[0]] * n \n        for j in range(1, n):\n            dp[j] = piles[j]\n            for i in range(j-1, -1 ,-1):\n                dp[i] = max(piles[i] - dp[i+1], piles[j] - dp[i])\n            #print(dp)\n                \n        return dp[0] > 0\n        \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = piles[:]\n        for d in range(1, n):\n            for i in range(n - d):\n                dp[i] = max(piles[i] - dp[i + 1], piles[i + d] - dp[i])\n        return dp[0] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [0] * n\n        # i is rightbound\n        for i in range(n):\n            # j is leftbound\n            for j in range(i, -1, -1):\n                if i == j:\n                    dp[i] = piles[i]\n                else:\n                    dp[j] = max(piles[i] - dp[j], piles[j] - dp[j+1])\n        return dp[0] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # Let f(i,j) be the maximum difference Alex-Lee\n        # Key idea: If Alex takes pile[i], then Lee will play optimally to get a score of f(i+1, j) for him,\n        # which is equilvalent to Alex getting a score of -f(i+1, j). So Alex's total score is pile[i] - f(i+1,j)\n        # Then just take the pile that results in maximum score.\n        # f(i,j) = max(piles[i] - f(i+1,j), piles[j] - f(i,j-1))\n        # Base case: f(i,i) = piles[i]\n        # If you draw the 2d grid, it looks like filling in diagonal order\n        # Can do space optimization using 1D DP\n        n = len(piles)\n        if n == 1:\n            return True\n        \n        dp = piles[:]  # Base row        \n        for l in range(1, n):\n            for i in range(n-l-1, -1, -1):\n                j = i+l\n                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j-1])\n                \n        return dp[-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        payoffs = piles\n        r = 1\n        while len(payoffs) > 1:\n            new_payoffs = []\n            for i in range(len(payoffs) - 1):\n                new_payoffs.append(max(piles[i] - payoffs[i+1], piles[i + r] - payoffs[i]))\n            payoffs = new_payoffs\n            r += 1\n        return payoffs[0] > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = piles[:]\n        for d in range(1,n):\n            for i in range(n-d):\n                dp[i] =  max(piles[i]-dp[i+1], piles[i+d]-dp[i])\n        return dp[0]>0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        pre_s = [0]\n        acc = 0\n        for num in piles:\n            acc += num\n            pre_s.append(acc)\n        \n        m = len(piles)\n        dp = [[0] * m for _ in range(m)]\n        \n        for i in reversed(list(range(m))):\n            for j in range(i, m):\n                if i == j:\n                    dp[i][j] = piles[i]\n                else:\n                    s = pre_s[j+1] - pre_s[i]\n                    if dp[i+1][j] < dp[i][j-1]:\n                        dp[i][j] = s - dp[i+1][j]\n                    else:\n                        dp[i][j] = s - dp[i][j-1]\n        \n        return dp[0][-1] > dp[1][-1] or dp[0][-1] > dp[0][-2]\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        memo = piles[:]\n        for l in range(2, n+1):\n            for i in range(n+1-l):\n                memo[i] = max(piles[i] - memo[i+1], piles[i+l-1] - memo[i])\n        return memo[0]    ", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # Mathematical\n        # If Alex takes the first pile initially, she can always take the third pile. If she takes the fourth pile initially, she can always take the second pile. At least one of first + third, second + fourth is larger, so she can always win.\n        # O(1)\n        # return True\n\n\n        # Dynamic Programming\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N^2)\n        # N = len(piles)\n\n        # @lru_cache(None)\n        # def dp(i, j):\n        #     if i > j: return 0\n        #     parity = (j - i - N) % 2\n        #     if parity == 1: # first player\n        #         return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n        #     else:\n        #         return min(-piles[i] + dp(i + 1, j), -piles[j] + dp(i, j - 1))\n\n        # return dp(0, N - 1) > 0\n\n\n        # N = len(piles)\n        # dp = [[0] * N for i in range(N)]\n        # for i in range(N):\n        #     dp[i][i] = piles[i]\n        # for d in range(1, N):\n        #     for i in range(N - d):\n        #         dp[i][i + d] = max(piles[i] - dp[i + 1][i + d], piles[i + d] - dp[i][i + d - 1])\n\n        # return dp[0][-1] > 0\n\n\n        N = len(piles)\n        dp = piles[:]\n        for d in range(1, N):\n            for i in range(N - d):\n                dp[i] = max(piles[i] - dp[i + 1], piles[i + d] - dp[i])\n        return dp[0] > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        dp = [[0] * N for _ in range(N)]\n        for i in range(N):\n            dp[i][i] = piles[i]\n        for i in range(N):\n            for j in range(i + 1, N):\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n        \n        return dp[i][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n\n        # Init\n        for i in range(n):\n            dp[i][i] = piles[i]\n        \n        for i in range(n-1, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        \n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, nums: List[int]) -> bool:\n        n, f = len(nums), [i for i in nums]\n        for i in range(1, n):\n            for j in range(n-i):\n                f[j] = max(nums[j]-f[j+1], nums[j+i]-f[j])\n        return f[0] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # condition on first dp[i,j] is the number of stones greater than the opponent if both using the optimum strate\n        # take first, dp[0][n-1] = max(piles[0] - dp[1][n-1], piles[n-1] - dp[0][n-2])\n        # dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j+1]\n        # return dp[0][n-1]\n        n = len(piles)\n        dp = [[0]*n for _ in range(n)]\n        \n        # initialize\n        for i in range(n):\n            dp[i][i] = piles[i]\n            \n        for l in range(1, n):\n            for i in range(n-l):\n                j = i + l\n                dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])\n            # print(dp)\n            \n        return dp[0][n-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        N = len(piles)\n        dp = [[0] * N for _ in range(N)]\n        for i in range(N):\n            dp[i][i] = piles[i]\n        \n        # j - i = d start from the shortest subarray\n        for d in range(1, N):\n            for i in range(N - d):\n                j = d + i\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n        \n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n): dp[i][i] = piles[i]\n        for l in range(1, n):\n            for i in range(n-l):\n                j = i + l\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for k in range(1, n):\n            for i in range(n-k):\n                j = i + k\n                # print(i, j, k)\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        f = [0] * n\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                f[j] = max(piles[i] - f[j], piles[j] - f[j - 1])\n        return f[n - 1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for d in range(1, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n        return dp[0][-1] > 0\n        \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # Let f(i,j) be the maximum difference Alex-Lee\n        # Key idea: If Alex takes pile[i], then Lee will play optimally to get a score of f(i+1, j) for him,\n        # which is equilvalent to Alex getting a score of -f(i+1, j). So Alex's total score is pile[i] - f(i+1,j)\n        # Then just take the pile that results in maximum score.\n        # f(i,j) = max(piles[i] - f(i+1,j), piles[j] - f(i,j-1))\n        # Base case: f(i,i) = piles[i]\n        # If you draw the 2d grid, it looks like filling in diagonal order\n        # Can do space optimization using 1D DP\n        n = len(piles)\n        if n == 1:\n            return True\n        \n        # First let's do 2D DP, space optimize later\n        dp = [[None]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        \n        for l in range(1, n):\n            for i in range(n-l):\n                j = i+l\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n                \n        return dp[0][n-1] > 0", "class Solution:\n    def stoneGame(self, piles):\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for d in range(1, n):\n            for i in range(n-d):\n                dp[i][i+d] = max(piles[i] - dp[i+1][i+d], piles[i+d] - dp[i][i+d-1])\n        return dp[0][-1] > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # dp[i][j] represents for piles[i:j + 1], the maximum differnce of Alex - Lee\n        n = len(piles)\n        dp = [[0 for col in range(n)] for row in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n            \n        for i in range(n - 1, -1 , -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n                \n        return dp[0][n - 1] > 0", "# 877. Stone Game\n    \n    # It's tricky when we have even number of piles of stones.\n    # You may not have this condition in an interview.\n\n    # Follow-up:\n\n    # What if piles.length can be odd?\n    # What if we want to know exactly the diffenerce of score?\n    # Then we need to solve it with DP.\n\n    # dp[i][j] means the biggest number of stones \n    # you can get more than opponent picking piles in piles[i] ~ piles[j].\n    # You can first pick piles[i] or piles[j].\n\n    # If you pick piles[i], your result will be piles[i] - dp[i + 1][j]\n    # If you pick piles[j], your result will be piles[j] - dp[i][j - 1]\n    # So we get:\n    # dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n    # We start from smaller subarray and then we use that to calculate bigger subarray.\n\n    # Note that take evens or take odds, it's just an easy strategy \n    # to win when the number of stones is even.\n    # It's not the best solution!\n    # I didn't find a tricky solution when the number of stones is odd (maybe there is).\n    \nclass Solution1: # 2D DP    \n    def stoneGame(self, piles: List[int]) -> bool:\n        p = piles\n        n = len(p)\n        \n        dp = [[0] * n for i in range(n)]\n        for i in range(n): \n            dp[i][i] = p[i]\n            \n        for d in range(1, n):\n            for i in range(n - d):\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\n                \n        return dp[0][-1] > 0\n    \n    \nclass Solution: # 1D DP, Space: O(N)    \n    def stoneGame(self, p):\n        n = len(p)\n        dp = p[:]\n        for d in range(1, n):\n            for i in range(n - d):\n                # \u8fd9\u6b21\u62ff\u5b8c\u4f1a\u8d62\uff0c\u4e0b\u6b21\uff1f\uff1f\uff1f\uff1f\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\n        return dp[0] > 0\n    \n    \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n): dp[i][i] = piles[i]\n        s = sum(piles)\n        \n        for l in range(1, n):\n            for i in range(n - l):\n                j = i + l\n                dp[i][j] = max(piles[i] + s - dp[i+1][j], piles[j] + s - dp[i][j-1])\n                \n        return dp[0][n - 1] > (s // 2)", "class Solution:\n    def stoneGame(self, p):\n        n = len(p)\n        dp = [[0] * n for i in range(n)]\n        for i in range(n): dp[i][i] = p[i]\n        for d in range(1, n):\n            for i in range(n - d):\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\n        return dp[0][-1] > 0\n        \n    \n        \n        \n                \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        if len(piles) == 0:\n            return False\n        n = len(piles)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for left in range(n):\n            for diff in range(1, n-left):\n                right = left + diff\n                dp[left][right] = max(piles[left] - dp[left+1][right], piles[right] - dp[left][right])\n        \n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        if len(piles) == 2:\n            return True\n        \n        alex = 0\n        lee = 0\n        \n        i = 0\n        \n        while(i < len(piles)):\n            \n            if i%2 == 0:\n                alex += max(piles[0],piles[len(piles)-1])\n                piles.remove(max(piles[0],piles[len(piles)-1]))\n                \n            else:\n                lee += min(piles[0],piles[len(piles)-1])\n                piles.remove(min(piles[0],piles(len(piles)-1)))\n                \n        if alex>lee:\n            return True\n        return False", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:    \n        def max_possible_score(i, j):\n            if j - i == 1:\n                return abs(piles[i] - piles[j])\n            return max(piles[i] - max_possible_score(i+1, j), piles[j] - max_possible_score(i, j-1))\n        #return max_possible_score(0, len(piles) - 1) > 0\n        n = len(piles)\n        dp = [[None for _ in range(n)] for _ in range(n)]\n        for i in range(n - 1):\n            j = i + 1\n            dp[i][j] = abs(piles[i] - piles[j])\n        for l in range(2, n):    \n            for i in range(n - l):\n                j = i + l\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        return dp[0][n-1] > 0\n        \n        \n            \n            \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[None for _ in range(n)] for _ in range(n)]\n        for i in range(n - 1):\n            j = i + 1\n            dp[i][j] = abs(piles[i] - piles[j])\n        for l in range(2, n):    \n            for i in range(n - l):\n                j = i + l\n                dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        return dp[0][n-1] > 0\n        \n        \n            \n            \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        prefix = [0]\n        for p in piles:\n            prefix.append(prefix[-1] + p)\n        n = len(piles)\n        dp = [0] * n\n        dp[n - 1] = piles[n - 1]\n        for i in range(n - 2, -1, -1):\n            for j in range(i, n):\n                a = piles[i] + prefix[j + 1] - prefix[i + 1] - dp[j]\n                b = piles[j] + prefix[j] - prefix[i] - dp[j - 1]\n                dp[j] = max(a, b)\n        return dp[n - 1] > prefix[-1] // 2", "class Solution:\n    def stoneGame(self, p: List[int]) -> bool:\n        n = len(p)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = p[i]\n        for d in range(1, n):\n            for i in range(n - d):\n                dp[i][i+d] = max(p[i]-dp[i+1][i+d], p[i+d]-dp[i][i+d-1])\n        return dp[0][-1] > 0", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # Mathematical\n        # If Alex takes the first pile initially, she can always take the third pile. If she takes the fourth pile initially, she can always take the second pile. At least one of first + third, second + fourth is larger, so she can always win.\n        # O(1)\n        # return True\n\n\n        # Dynamic Programming\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N^2)\n        # N = len(piles)\n\n        # @lru_cache(None)\n        # def dp(i, j):\n        #     if i > j: return 0\n        #     parity = (j - i - N) % 2\n        #     if parity == 1: # first player\n        #         return max(piles[i] + dp(i + 1, j), piles[j] + dp(i, j - 1))\n        #     else:\n        #         return min(-piles[i] + dp(i + 1, j), -piles[j] + dp(i, j - 1))\n\n        # return dp(0, N - 1) > 0\n\n\n        N = len(piles)\n        dp = [[0] * N for i in range(N)]\n        for i in range(N):\n            dp[i][i] = piles[i]\n        for d in range(1, N):\n            for i in range(N - d):\n                dp[i][i + d] = max(piles[i] - dp[i + 1][i + d], piles[i + d] - dp[i][i + d - 1])\n\n        return dp[0][-1] > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[None for _ in range(n)] for _ in range(n)]\n        for l in range(1, n):    \n            for i in range(n - l):\n                j = i + l\n                if j == i + 1:\n                    dp[i][j] = abs(piles[i] - piles[j])\n                else:\n                    dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])\n        return dp[0][n-1] > 0\n        \n        \n            \n            \n            \n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = [[0] * len(piles) for _ in range(len(piles))]\n        for i in range(len(piles)):\n            dp[i][i] = piles[i]\n        for i in range(len(piles) - 1)[::-1]:\n            for j in range(i + 1, len(piles)):\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for interval in range(1,n):\n            for left in range(n-interval):\n                dp[left][left+interval] = max(piles[left]-dp[left+1][left+interval],piles[left+interval] - dp[left][left+interval-1])\n        return dp[0][-1]>0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n=len(piles)\n        dp=[[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            dp[i][i]=piles[i]\n        for m in range(2,n+1):\n            for l in range(n-m+1):\n                r=l+m-1\n                dp[l][r]=max(piles[l]-dp[l+1][r], piles[r]-dp[l][r-1])\n        return dp[0][n-1]>0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        p = piles\n        n = len(p)\n        dp = [[0] * n for i in range(n)]\n        for i in range(n): dp[i][i] = p[i]\n        for d in range(1, n):\n            for i in range(n - d):\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # [3,8,5,1]\n        return True", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # dp[i][j], total score the Alex can get with pile[i:j + 1]\n        \n        n = len(piles)\n        dp = [[0 for i in range(n)] for j in range(n)]\n        \n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if l % 2 == 0:  # Alex next move\n                    dp[i][j] = max(dp[i + 1][j] + piles[i], dp[i][j - 1] + piles[j])\n                else:\n                    dp[i][j] = min(dp[i + 1][j] - piles[i], dp[i][j - 1] - piles[j])\n\n                    \n        return dp[0][n - 1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        if not piles or len(piles) == 0:\n            return False\n        \n        dp = [[0] * len(piles) for _ in range(len(piles))]\n        for i in range(len(piles)):\n            dp[i][i] = piles[i]\n            \n        for length in range(2, len(piles) + 1):\n            for i in range(0, len(piles) - length + 1):\n                j = i + length - 1\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n        \n        return dp[0][len(piles) - 1]", "\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        m = len(piles)\n        dp = [[0 for _ in range(m)] for _ in range(m)]\n\n        for i in range(m):\n            dp[i][i] = piles[i]\n\n        for length in range(2, m + 1):\n            for start in range(0, m, 1):\n                end = start + length - 1\n                if end >= m:\n                    break\n\n                dp[start][end] = max(piles[start] - dp[start+1][end], piles[end] - dp[start][end-1])\n        \n        return dp[0][m - 1] > 0\n", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles):\n        grid = [[0]*len(piles) for x in range(len(piles))]\n        for i in range(len(piles)-1, -1, -1):\n          for j in range(len(piles)):\n            if i >= j: grid[i][j] = 0\n            else:\n              #alex\n              if (j-i)%2 == 1:\n                grid[i][j] = max(piles[i] + grid[i+1][j], piles[j] + grid[i][j-1])\n              #lee\n              else:\n                grid[i][j] = min(-piles[i] + grid[i+1][j], -piles[j] + grid[i][j-1])\n        return grid[0][len(piles)-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        dp = [[(0,0)] * len(piles) for _ in range(len(piles))]\n        for i in range(len(piles)):\n            dp[i][i] = (piles[i], 0)\n            \n        for diff in range(1,len(piles)):\n            for j in range(len(piles) - diff):\n                i = diff + j\n                left = dp[j+1][i][1] + piles[j]\n                right = dp[j][i-1][1] + piles[i]\n                if left > right:\n                    dp[j][i] = (left, dp[j+1][i][0])\n                else:\n                    dp[j][i] = (right, dp[j][i-1][0])\n        \n        return dp[0][-1][0] > dp[0][-1][1]\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        @lru_cache(None)\n        def get_score(i, j):\n            if i > j:\n                return 0\n            if i == j:\n                return piles[i]\n            return max(piles[i] + get_score(i + 2, j), piles[i] + get_score(i + 1, j - 1),\n                      piles[j] + get_score(i + 1, j - 1), piles[j] + get_score(i, j - 2))\n        \n        return 2 * get_score(0, len(piles) - 1) > sum(piles)", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # use dp\n        # answer the question \\\"what is the expected gain of the current player over the next player given the plies[i : j] (inclusive)\\\"\n        table = [[0 for _ in range(len(piles))] for _ in range(len(piles))]\n        \n        # base case - single element\n        for i in range(len(piles)):\n            table[i][i] = piles[i]\n        \n        for diff in range(1, len(piles)):\n            for i in range(0, len(piles) - diff):\n                table[i][i + diff] = max(piles[i] - table[i + 1][i + diff], \n                                         piles[i + diff] - table[i][i + diff - 1])\n        \n        return table[0][len(piles) - 1] > 0", "class Solution:\n    def stoneGame(self, p: List[int]) -> bool:\n        n = len(p)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = p[i]\n        for d in range(1, n):\n            for i in range(n - d):\n                # print(i, i+d)\n                dp[i][i+d] = max(p[i]-dp[i+1][i+d], p[i+d]-dp[i][i+d-1])\n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles):\n        n = len(piles)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        presum = [0]\n        for p in piles:\n            presum.append(p + presum[-1])\n\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(piles[i] + presum[j + 1] - presum[i + 1] - dp[i + 1][j],\n                               piles[j] + presum[j] - presum[i] - dp[i][j - 1])\n        return dp[0][n - 1] > presum[-1] - dp[0][n - 1]", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0] * n for i in range(n)]\n\n        for i in range(n):\n            dp[i][i] = piles[i]\n        \n        for d in range(1, n + 1):\n            for i in range(n - d):\n                dp[i][i + d] = max(piles[i] - dp[i + 1][i + d], piles[i + d] - dp[i][i + d - 1])\n        \n        return dp[0][-1] > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n): dp[i][i] = piles[i]\n        cum = [0] * n\n        cum[0] = piles[0]\n        for i in range(1, n):\n            cum[i] = cum[i-1] + piles[i]\n        \n        for l in range(1, n):\n            for i in range(n - l):\n                j = i + l\n                dp[i][j] = max(piles[i] + cum[n-1] - dp[i+1][j], piles[j] + cum[n-1] - dp[i][j-1])\n                \n        return dp[0][n - 1] > (cum[n-1] // 2)", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # dp[i][j] represents the max difference in score current player gets over other player\n        dp = [[0 for _ in range(len(piles))] for _ in range(len(piles))]\n        \n        # base case where length of list is 1\n        for i in range(len(piles)):\n            dp[i][i] = piles[i]\n        \n        start = len(piles) - 1\n        while start >= 0:\n            end = start + 1\n            while end < len(piles):\n                dp[start][end] = max(piles[start] - dp[start + 1][end], piles[end] - dp[start][end - 1])\n                end += 1\n            start -= 1\n        \n        return dp[0][len(piles) - 1] >= 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n = len(piles)    \n        dp = [[0]*n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = piles[i]\n            \n        for i in range(n-1):\n            for j in range(n):\n                dp[i][j] = max(piles[i]-dp[i+1][j], piles[j] - dp[i][j - 1])\n                \n        \n        return dp[0][n-1] > 0\n", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \n        @lru_cache(None)\n        def game(left, right):\n            if left == right:\n                return piles[left]\n            return max(piles[left] - game(left + 1, right), piles[right] - game(left, right - 1))\n        \n        return game(0, len(piles) - 1) > 0", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        @lru_cache(maxsize=None)\n        def score(l, r):\n            if l == r: return piles[l]\n            return max(piles[l] - score(l+1, r),\n                        piles[r] - score(l, r-1))\n        return score(0, len(piles)-1) > 0", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(maxsize=None)\n        def score(l, r):\n            if l == r: return piles[l]\n            return max(piles[l] - score(l+1, r),\n                        piles[r] - score(l, r-1))\n        return score(0, len(piles)-1) > 0", "from functools import lru_cache\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memo = {}\n        return self.dfs(0, 0, piles, 0, len(piles)-1, memo)\n    \n    def dfs(self, person1, person2, piles, start, end, memo):\n        if (person1, person2, start, end) in memo:\n            return memo[(person1, person2, start, end)]\n        \n        if end-start == 1:\n            if person1 + max(piles) > person2 + min(piles):\n                return True\n            else:\n                return False\n        \n        case1_person1 = person1 + piles[0]\n        res1 = self.dfs(person2, case1_person1, piles, start+1, end, memo)\n        if res1 == False:\n            memo[(person1, person2, start, end)] = True\n            return True\n        \n        case2_person1 = person1+piles[-1]\n        res2 = self.dfs(person2, case2_person1, piles, start, end-1, memo)\n        if res2 == False:\n            memo[(person1, person2, start, end)] = True\n            return True\n        \n\n        memo[(person1, person2, start, end)] = False\n        \n        return False\n    \n", "class Solution:\n    # @lru_cache(None)\n    def stoneGame(self, piles: List[int]) -> bool:\n        result = dict()\n        @lru_cache(None)\n        def Alex(start, end) -> int:\n            if start == end:\n                return piles[start]\n            # if (start, end) in result:\n            #     return result[(start, end)]\n            else:\n                # result[(start, end)] = max(Lee(start + 1, end) + piles[start], Lee(start, end - 1) + piles[end])\n                return max(Lee(start + 1, end) + piles[start], Lee(start, end - 1) + piles[end])\n            # return result[(start, end)]\n            \n        def Lee(start, end) -> int:\n            if start == end:\n                return 0\n            # if (start, end) in result:\n            #     return result[(start, end)]\n            else:\n                # result[(start, end)] =  min(Alex(start + 1, end), Alex(start, end - 1))\n                return  min(Alex(start + 1, end), Alex(start, end - 1))\n            # return result[(start, end)]\n        Alex(0, len(piles) - 1)\n        summ = sum(piles)\n        # print(result[(0, len(piles - 1))])\n        # print(summ)\n        return Alex(0, len(piles) - 1) > (summ - Alex(0, len(piles) - 1))", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        memory = [[0 for _ in range(len(piles))]for _ in range(len(piles))]\n        return self.dfs(piles, 0, len(piles)-1, True, memory) > 0\n    def dfs(self, piles, start, end, turn, memory):\n        if start > end:\n            return 0\n        if memory[start][end] != 0:\n            return memory[start][end]\n        if turn:\n            memory[start][end] = max(piles[start] + self.dfs(piles, start+1, end, not turn, memory), piles[end] + self.dfs(piles, start, end-1, not turn, memory))\n        else:\n            memory[start][end] =  min(-piles[start] + self.dfs(piles, start+1, end, not turn, memory), -piles[end] + self.dfs(piles, start, end-1, not turn, memory))\n        return memory[start][end]\n        \n", "from functools import lru_cache\n\nclass Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @lru_cache(None)\n        def helper(l,r):\n            if r-l == 1:\n                return piles[l]\n            if r-l == 2:\n                return abs(piles[l] - piles[l+1])\n            return max(piles[l] - helper(l+1, r), piles[r-1] - helper(l,r-1))\n            \n        return helper(0,len(piles)) > 0", "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        n=len(piles)\n        if n//2==0:\n            return True\n        dp=[[0 for i in range(n)] for j in range(n)]\n        prefix=[0]\n        for i in range(n):\n            dp[i][i]=piles[i]\n            prefix.append(prefix[-1]+piles[i])\n        for k in range(1,n):\n            for i in range(n):\n                j=i+k\n                if j>=n:\n                    break\n                dp[i][j]=piles[j]+((prefix[j]-prefix[i])-dp[i][j-1])\n                dp[i][j]=max(dp[i][j],piles[i]+((prefix[j+1]-prefix[i+1])-dp[i+1][j]))\n        return (dp[0][-1]>sum(piles)//2)\n"]
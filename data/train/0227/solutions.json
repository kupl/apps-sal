["class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        hulu = []\n        cnt = 0\n        num = A[0]\n        for x in A:\n            if x == num:\n                cnt += 1\n            else:\n                hulu.append([num,cnt])\n                cnt = 1\n                num = x\n        if cnt>0:\n            hulu.append([num,cnt])\n        \n        # print(hulu)\n        \n        output = 0\n        \n        if A[0] == 1:\n            start = 0\n        else:\n            start = 1\n            if len(hulu)<2:\n                return min(K,len(A))\n            \n        end = start\n            \n        usage = 0\n        ones = hulu[start][1]\n        while end+2<len(hulu) and usage+hulu[end+1][1]<=K:\n            usage += hulu[end+1][1]\n            ones += hulu[end+2][1]\n            end += 2\n        \n        output = ones+K\n        \n        # print([start,end,usage,ones])\n        \n        start += 2\n        \n        while start<len(hulu):\n            ones -= hulu[start-2][1]\n            usage -= hulu[start-1][1]\n            if start>end:\n                end = start\n                ones = hulu[start][1]\n                usage = 0\n            while end+2<len(hulu) and usage+hulu[end+1][1]<=K:\n                usage += hulu[end+1][1]\n                ones += hulu[end+2][1]\n                end += 2\n            # print([start,end,usage,ones])\n            \n            output = max(output,ones+K)\n            start += 2\n            \n        return min(output,len(A))\n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n    \n        if len(A) - sum(A) <= K:\n            return len(A)\n        \n        left = right = 0\n        \n        for right in range(len(A)):\n            if A[right] == 0:\n                K-=1\n            \n            if K < 0:\n                \n                if A[left] == 0:\n                    K+=1\n                \n                left += 1\n        \n        return right-left + 1\n", "'''\n[1,1,1,0,0,0,1,1,1,1,0]\n           i\n                     j\n'''\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        left,right=0,0\n        alen=len(A)\n        \n        while right < alen:\n            \n            if A[right] == 0:\n                K-=1\n            \n            if K < 0:\n                if A[left] == 0:\n                    K+=1\n                left+=1\n            right+=1\n        \n        return right - left", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        window_start, max_length, max_ones_count = 0, 0, 0\n        \n        # Try to extend the range [window_start, window_end]\n        for window_end in range(len(A)):\n            if A[window_end] == 1:\n                max_ones_count += 1\n\n        # Current window size is from window_start to window_end, overall we have a maximum of 1s\n        # repeating 'max_ones_count' times, this means we can have a window with 'max_ones_count' 1s\n        # and the remaining are 0s which should replace with 1s.\n        # now, if the remaining 1s are more than 'k', it is the time to shrink the window as we\n        # are not allowed to replace more than 'k' 0s\n            if (window_end - window_start + 1 - max_ones_count) > K:\n                if A[window_start] == 1:\n                    max_ones_count -= 1\n                window_start += 1\n\n            max_length = max(max_length, window_end - window_start + 1)\n        return max_length", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i,j,count,res = 0,0, 0,0\n        while j<len(A):\n            if A[j]==0:\n                count+=1\n            while count>K:\n                if A[i]==0:\n                    count-=1\n                i+=1\n            res= max(res, j-i+1)\n            j+=1\n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        start, end = 0, 0\n        max_len = 0\n        numzeros = 0\n        while end < len(A):\n            if A[end] == 0:\n                numzeros += 1\n            while numzeros > K:\n                # shrink window\n                if A[start] == 0:\n                    numzeros -= 1\n                start += 1\n            max_len = max(max_len, end - start + 1)\n            end += 1\n        return max_len", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        res = 0\n        start, end = 0, 0\n        cnt = 0\n        while end < len(A) and start < len(A):\n            if A[end] == 1:\n                res = max(res, end - start + 1)\n                end += 1\n            elif A[end] == 0 and cnt < K:\n                res = max(res, end - start + 1)\n                cnt += 1\n                end += 1\n            else:\n                if A[start] == 0 and K > 0:\n                    cnt -= 1\n                start += 1\n                if start > end:\n                    end = start\n        return res\n                \n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        #brute force, linear scan NAIVE APPROACH \n        #start with the largest size and move down, time limit exceeded \n        '''\n        for size in range(len(A)-1, -1, -1): \n            i = 0\n            j = i+size\n            count = 0\n            for ind in range(i, j+1):\n                if A[ind] == 0: \n                    count += 1\n                    \n            while j < len(A): \n                if count <= K: \n                    return size+1\n                else:\n                    if A[i] == 0: count -= 1\n                    if j < len(A)-1 and A[j+1] == 0: count += 1\n                    j += 1\n                    i += 1\n                   \n        return 0\n        '''\n        \n        #use dynamic variant of sliding window technique\n        maxConsecutiveOnes = 0\n        windowStart = 0\n        currZeroes = 0\n        #iterate through the array linearly and see if the number of 0s is <= K\n        for windowEnd in range(len(A)): \n            if A[windowEnd] == 0: \n                currZeroes += 1\n            \n            #shrinks window \n            while currZeroes > K:\n                if A[windowStart] == 0: \n                    currZeroes -= 1\n                 \n                windowStart += 1\n\n                    \n            maxConsecutiveOnes = max(maxConsecutiveOnes, windowEnd - windowStart + 1)\n                \n                    \n                \n        return maxConsecutiveOnes", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left=0\n        right=0\n        for right in range(len(A)):\n            if A[right]==0:\n                K-=1\n            if K<0:\n                if A[left]==0:\n                    K+=1\n                left+=1\n        return right -left +1\n", "class Solution:\n    def longestOnes(self, arr: List[int], K: int) -> int:\n        left = 0\n        \n        for right in range(len(arr)):\n            K -= 1 - arr[right]\n            if K < 0:\n                K += 1 - arr[left]\n                left += 1\n                \n            \n        return right - left + 1\n        \n", "class Solution:\n    def longestOnes(self, A: List[int], k: int) -> int:\n        leftPtr=0\n        rightPtr=0\n        windowSize=[]\n        \n        while rightPtr<=len(A)-1:\n            if A[rightPtr]==0:\n                k-=1\n            if k<0:\n                if A[leftPtr]==0:\n                    k+=1\n                    \n                leftPtr+=1\n            rightPtr+=1\n            \n            \n        return rightPtr-leftPtr\n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        for right in range(len(A)):\n            K -= int(A[right] == 0)\n            if K < 0:\n                K += 1 - A[left]\n                left += 1\n        return right - left + 1\n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        start = 0\n        end = 0\n        l = len(A)\n        count = 0\n        max_len = 0\n        while end < l:\n       #     print(start, end)\n            if A[end] == 1:\n                max_len = max(max_len, end-start+1)\n                end = end + 1\n            else:\n                if count < K:\n                    max_len = max(max_len, end-start +1)\n                    count = count+1\n                    end = end + 1\n                else:\n                    while start <= end and count >= K:\n                        if A[start] == 0:\n                            count = count -1\n                        start = start + 1\n                    \n                  \n                    \n        return max_len\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        for right in range(len(A)):\n            \n            # If we included a zero in the window we reduce the value of K.\n            # Since K is the maximum zeros allowed in a window.\n            K -= (1 - A[right])\n            # A negative K denotes we have consumed all allowed flips and window has\n            # more than allowed zeros, thus increment left pointer by 1 to keep the window size same.\n            if K < 0:\n                # If the left element to be thrown out is zero we increase K.\n                K += 1 - A[left]\n                left += 1\n        return right - left + 1", "def solve(arr,n,k):\n    prefix=[0]\n    for i in range(0,n):\n        if(arr[i]==0):\n            prefix.append(prefix[-1]+1)\n        else:\n            prefix.append(prefix[-1])\n    low=0\n    high=n+1\n    ans=0\n    while(low<high):\n        f=0\n        mid=low+(high-low)//2\n        for i in range(mid,n+1):\n            if(prefix[i]-prefix[i-mid]<=k):\n                ans=max(ans,mid)\n                f=1\n        if(f==1):\n            low=mid+1\n        else:\n            high=mid\n    return ans\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        return solve(A,len(A),K)\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ans , i , c = 0 , 0 , [ ]\n        for j in range( len( A ) ) :\n            if A[ j ] == 0 :\n                c += j ,\n            while len( c ) > K :\n                 i = c.pop( 0 ) + 1\n            ans = max( ans , j - i + 1 )\n        return ans\n#Sanyam Rajpal\n", "class Solution:\n    def longestOnes(self, A: List[int], k: int) -> int:\n        res = 0\n        i = j = 0\n        \n        move = 1\n        while i<len(A) and j<len(A):\n            if move==1:\n                if A[j]==0:\n                    if k == 0:\n                        move = 0\n                        print(i,j)\n                        res = max(res,j-i)\n                    k -= 1\n                j += 1\n            if move==0:\n                if A[i]==0:\n                    k += 1\n                    move = 1\n                i += 1\n                \n        return max(res,j-i)", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        start, end = 0, 0\n        \n        for end in range(len(A)):\n            if A[end] == 0:\n                K -= 1\n            if K < 0:\n                if A[start] == 0:\n                    K += 1\n                start += 1\n        \n        return end - start + 1\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ans = 0\n        l = 0\n        r = 0\n        prefix = [0 for i in range(len(A))]\n        for i in range(len(A)):\n            if (i==0):\n                prefix[i] = A[0]\n            else:\n                prefix[i] = A[i] + prefix[i-1]\n                \n        if (K>=len(A)-prefix[-1]):\n            return len(A)\n            \n                \n        while (r<len(A) and l<len(A)):\n            while (r<len(A)):\n                if (l==0):\n                    this_sum = prefix[r]\n                else:\n                    this_sum = prefix[r] - prefix[l-1]\n                    \n                if (r-l+1-this_sum>K):\n                    r-=1\n                    break\n                    \n                r+=1\n                \n            if (r>=len(A)):\n                if (r-l>ans):\n                    #print (l,r,ans)\n                    ans = r-l\n                break\n            \n            if (r-l+1>ans):\n                #print (l,r,ans)\n                ans = r-l+1\n            \n            #r+=1\n            while (l<len(A) and A[l] == 1):\n                l+=1\n                \n            l+=1\n            \n        return ans\n            \n                \n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        count=0\n        maxCount=-1\n        first=0\n        for i in range(len(A)):\n            if A[i]==0 and K!=0:\n                count+=1\n                K-=1\n            elif A[i]==0 and K==0:\n                while A[first]!=0:\n                    first+=1\n                    count-=1\n                first+=1\n            else:\n                count+=1\n            maxCount=max(maxCount,count)\n        return maxCount\n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        # don't reduce window - time O(n); space O(1)\n        left = 0\n        for right in range(len(A)):\n            K -= (1 - A[right])\n            if K < 0:\n                K += (1 - A[left])\n                left += 1\n            \n        return right - left + 1", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i, j = 0, 0\n        count = 0\n        out = 0\n        for i in range(len(A)):\n            if A[i] == 0:\n                count += 1\n            while count > K and j < len(A):\n                if A[j] == 0:\n                    count -= 1\n                j += 1\n            out = max(out, i - j + 1)\n        return out\n            \n", "class Solution:\n    def longestOnes(self, a: List[int], K: int) -> int:\n        i = 0\n        j = 0\n        ml = 0\n        while i < len(a):\n            if a[i] == 0:\n                K -= 1\n            while K < 0:\n                if a[j] == 0:\n                    K += 1\n                j += 1\n            ml = max(ml, i-j+1)\n            i += 1\n        return ml", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        '''naive\n        \n        \n        sliding window\n        keep growing sliding window rhs as num of 0s in window is >k\n        when num 0s == k, slide lhs of window until k > num 0s again\n        keep track of largest sliding window'''\n        \n        \n        if not A:\n            return 0\n        \n        best_window_len = 0\n        p, q = 0, 0\n        \n        num_zeros = 0\n        #if A[q] == 0: num_zeros += 1\n        \n        while q < len(A):\n            if A[q] == 0: num_zeros += 1\n            #print(p, q, q - p)\n            if num_zeros > K:\n                best_window_len = max(q - p, best_window_len)\n                #print(\\\"running best:\\\", best_window_len)\n                while num_zeros > K:\n                    if A[p] == 0:\n                        num_zeros -= 1\n                    p += 1\n            q+=1\n            \n        best_window_len = max(q - p, best_window_len)\n        #if p == 0:\n            #best_window_len+=1\n        #print(best_window_len)\n        return best_window_len\n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        subarrays = []\n        start = -1\n        i = 0\n        while i < len(A):\n            if A[i] == 1:\n                if start == -1:\n                    start = i\n            else:\n                if start != -1:\n                    subarrays.append([start, i])\n                    start = -1\n            i += 1\n        if A[i-1] == 1:\n            subarrays.append([start, i])\n        print(subarrays)\n        \n        if K == 0:\n            result = 0\n            for arr in subarrays:\n                if arr[1] - arr[0] > result:\n                    result = arr[1] - arr[0]\n            return result\n        \n        window = []\n        start = []\n        end = []\n        result = 0\n        for i in range(len(A)):\n            if A[i] == 0: \n                if len(window) == K:\n                    window.pop(0)\n                window.append(i)\n                left = window[0] - 1\n                right = window[-1] + 1\n                while left >= 0 and A[left] != 0:\n                    left -=1\n                while right < len(A) and A[right] != 0:\n                    right += 1\n                if right - left > result:\n                    result = right - left\n                # for i in range(start, len(subarrays)):\n                #     if subarrays[i][0] > window[0]:\n                #         break\n                #     start = i\n                # for i in range(len(subarrays)-1, end-1, -1):\n                #     if subarrays[i][1] < window[-1]:\n                #         break\n                #     end = i\n                \n        # result = 0\n        # for curr_k in range(K, 0, -1)\n        #     i = 0\n        #     while i < len(subarrays) - 1:\n        #         gap = subarrays[i][1] + subarrays[i][0] - 1\n        #         if gap == curr_k:\n        return result - 1", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        start = end = 0\n        res = 0\n        map = collections.defaultdict(int)\n        while end < len(A):\n            map[A[end]] += 1\n            while end - start + 1 - map[1] > K:\n                map[A[start]] -= 1\n                start += 1\n            res = max(res, end-start+1)\n            end += 1\n            \n        return res\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        begins = [-1] * (K+1)\n        cur = [0] * (K+1)\n        maxL = 0\n        curMax = 0\n        for i, a in enumerate(A):\n            if a == 0:\n                maxL = max(maxL, curMax)\n                begins.pop(0)\n                begins.append(i)\n                curMax -= cur.pop(0)\n                curMax += 1 if begins[0] == -1 else 0\n                cur.append(0)\n            else:\n                cur[-1] += 1\n                curMax += 1\n        return max(maxL, curMax)", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        right = 0\n        for i in range(len(A)):\n            if A[i] == 0:\n                A[i] = 1\n            else:\n                A[i] = 0\n        tot = A[0]\n        res = 0\n        \n        for left in range(len(A)):\n            while tot <= K:\n                right = right + 1\n                if right >= len(A):\n                    break\n                tot = tot + A[right]\n            res = max(res, right - left)\n            if right >= len(A) - 1:\n                break\n            if A[left] == 1:\n                tot = tot - 1\n        \n        return res\n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        if A.count(0) <= K:\n            return len(A)\n        \n        res = 0\n        i = 0\n        for j in range(len(A)):\n            if A[j] == 0:\n                K -= 1\n            res = max(res, j-i)\n            while K < 0 and i <= j:\n                if A[i] == 0:\n                    K += 1\n                i += 1\n                \n        return max(res, len(A)-i)\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        k = K\n        j = ans = 0\n        for i in range(len(A)):\n            if not A[i]:\n                k -= 1\n            \n            while k<0:\n                if not A[j]:\n                    k += 1\n                j += 1\n            ans = max(ans, i-j+1)\n       \n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i, res = 0, 0\n        for j in range(len(A)):\n            K -= 1 - A[j]\n            while K < 0:\n                K += 1 - A[i]\n                i += 1\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left, right = 0,0\n        max_window = 0\n        zero_positions = []\n        num_violations = 0\n        while right < len(A):\n            if A[right] == 0:\n                num_violations +=1\n                zero_positions.append(right)\n            if num_violations > K:\n                left = zero_positions[0] +1\n                zero_positions.pop(0)\n                num_violations -=1\n            right +=1\n            max_window = max(max_window, right - left)\n        return max_window", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        z_count = 0\n        l = 0\n        result = 0\n        for i in range(len(A)):\n            if not A[i]:\n                z_count+=1\n            if z_count <= K:\n                result = max(result, i-l+1)\n            while l < i and z_count>K:\n                if not A[l]:\n                    z_count-=1\n                l+=1\n\n            \n        return result\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        longest = start = end = zeroes = 0\n        while end < len(A):\n            num = A[end]\n\n            if not num:\n                zeroes += 1\n            end += 1\n            while zeroes > K:\n                if A[start] == 0:\n                    zeroes -= 1\n                start += 1\n            longest = max(longest, end - start)\n        return longest \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        res = 0\n        i, j, N = 0, 0, len(A)\n        remaining = K if A[i] == 1 else K - 1\n        while i < N:\n            # resetting\n            if i > j:\n                j = i\n                remaining = K if A[i] == 1 else K - 1\n\n            # stretch\n            while j + 1 < N and remaining >= 0:\n                if A[j + 1] == 0:\n                    if remaining > 0:\n                        remaining -= 1\n                    else:\n                        break\n                j += 1\n                res = max(res, j - i + 1)\n\n            # pay debt\n            if A[i] == 0:\n                remaining += 1\n            i += 1\n        return res", "class Solution:\n    def longestOnes(self, x: List[int], K: int) -> int:\n        \n        buf = collections.deque()\n        n = len(x)\n        i = 0\n        unused = K\n        start = -1\n        maxlen = float('-inf')\n        while i < n:\n            if x[i] == 0:\n                if unused > 0:\n                    buf.append(i)\n                    unused -= 1\n                    maxlen = max(i - start, maxlen)\n                else:\n                    if buf:\n                        start = buf.popleft()\n                        maxlen = max(i - start, maxlen)\n                        buf.append(i)\n                    else:\n                        # K == 0\n                        maxlen = max(i - 1 - start, maxlen)\n                        start = i\n            else:\n                maxlen = max(i - start, maxlen)\n                \n                \n            i += 1\n        return maxlen if n > 0 else n", "#                 1,1,1,0,0,0,1,1,1,1,0\n# max=5,k=0       [       ]\n\n#                 1,1,1,0,0,0,1,1,1,1,0\n# max=5,k=-1        [       ]\n\n#                 1,1,1,0,0,0,1,1,1,1,0\n# max=6,k=0                 [         ]\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l = 0\n        for r in range(len(A)):\n            if A[r] == 0:\n                K-=1\n                \n            if K<0:\n                if A[l] == 0:\n                    K+=1\n                l+=1\n        return r-l+1\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        lo = 0\n        hi = len(A)\n        A = [0] + [1-x for x in A]\n        n = len(A)\n        for i in range(1, n):\n            A[i] += A[i-1]\n        \n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            \n            if min(A[i] - A[i-mid] for i in range(mid, len(A))) <= K:\n                lo = mid\n            else:\n                hi = mid - 1\n        \n        return lo\n", "'''\n\nInput: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2\nOutput: 6\n\n\n\n\n\n\n\n'''\n\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        '''\n        Sliding window technique\n        '''\n        # if there's no array\n        if not A:\n            return 0\n        \n        # define a window\n        window = 0\n        \n        # define start of the window\n        start = 0\n        \n        # maximum allowed ones\n        max_ones = 0\n        \n        # iterate over A\n        for it, value in enumerate (A):\n            \n            # add value to window\n            window += value\n            \n            # eviction reached?\n            # [1,1,1,0,0,0,1,1,1,1,0]\n            if it - start + 1 > window + K:\n                window -= A[start]\n                start += 1\n                \n            # figure the maximum ones possible\n            max_ones = max (max_ones, window + K)\n            \n        return min (max_ones, len (A))", "class Solution:\n    def longestOnes(self, A: List[int], k: int) -> int:\n        \n        \n        \n        ans=0\n        i=0\n        \n        for j,c in enumerate(A):\n            k-=(1-c)\n            if k<0:\n                k+=1-A[i]\n                i+=1\n                ans=max(ans,j-i+1)\n        return max(ans,j-i+1)\n                \n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left=0\n        right=0\n        maxlength=0\n        hashmap={}\n        count=0\n        while right<len(A):\n            hashmap[A[right]]=hashmap.get(A[right],0)+1\n            while A[right]==0 and hashmap[A[right]]>K:\n                    hashmap[A[left]]-=1\n                    left+=1\n            maxlength=max(maxlength,right-left+1)\n            right+=1\n        return maxlength\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        right = 0\n        contains = 0\n        max_len = 0\n        \n        while right < len(A):\n            if A[right] == 0:\n                contains += 1\n                \n                if contains > K:\n                    while contains > K:\n                        if A[left] == 0:\n                            contains -= 1\n                        left += 1\n            max_len = max(max_len, right - left + 1)\n            right += 1\n            \n        return max_len\n            \n        \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l = len(A)\n        end = 0\n        start = 0\n        ans = 0\n        count = 0\n        for i in range(l):\n            if A[i] == 1:\n                count += 1\n            if end - start + 1 - count <= K:\n                ans = max(ans, end - start + 1)\n            else:\n                if A[start] == 1:\n                    count -= 1\n                start += 1\n            end += 1\n        return ans\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        lo, hi = 0, 0\n        zmax = 0\n        n_k = 0\n        while hi < len(A):\n            # print(f\\\"{lo},{hi}, {zmax}\\\")\n            if A[hi] == 0:\n                n_k += 1\n            # break\n            \n            while n_k > K:\n                if A[lo] == 0:\n                    n_k-=1\n                lo+=1\n            \n            zmax = max(zmax, hi-lo+1)\n                \n            \n            hi+=1\n        return zmax", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left=0\n        for right in range(len(A)):\n            K-=1-A[right]\n            \n            if K<0:\n                K +=1-A[left]\n                left+=1\n        return right-left+1\n        \n        \n    \n", "class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0 \n\n        # left - on the first 1 of the island\n        # right - on the last 1 of that island\n        left = 0\n        while left < len(nums) and nums[left] != 1:\n            left += 1\n\n        right = left \n        while right + 1 < len(nums) and nums[right + 1] == 1:\n            right += 1\n\n        if right == len(nums):\n            return 0\n\n        maxOnes = right - left + 1\n\n        while left < len(nums):\n            left = right + 1\n            while left < len(nums) and nums[left] != 1:\n                left += 1\n\n            right = left \n            while right + 1 < len(nums) and nums[right + 1] == 1:\n                right += 1\n\n            maxOnes = max(maxOnes, right - left + 1)\n\n        return maxOnes\n    \n    \n    def longestOnes(self, A: List[int], K: int) -> int:\n        if K == 0:\n            return self.findMaxConsecutiveOnes(A)\n        \n        if len(A) == 0:\n            return 0\n\n        left, right = 0, 0\n\n        # Pre-condition: In the [left, right] we have exactly K zeros,\n        # and you can't move right any more\n\n        # Move right to K-th zero\n        if A[right] == 0:\n            K -= 1\n        while right + 1 < len(A) and K > 0:\n            right += 1\n            if A[right] == 0:\n                K -= 1\n\n        # Move more if there are 1s to the right of K-th zero    \n        while right + 1 < len(A) and A[right + 1] == 1:\n            right += 1\n\n        maxSize = right - left + 1\n\n        while right < len(A):\n            # Move left off of a zero, and then move right accordingly to include 1 more zero\n            while left < len(A) and A[left] != 0:\n                left += 1\n            if left < len(A):\n                left += 1\n            else:\n                return maxSize\n\n\n            # Move right to include one more zero   \n            right += 1\n            while right + 1 < len(A) and A[right + 1] == 1:\n                right += 1\n\n            maxSize = max(maxSize, right - left + 1)\n            \n        return maxSize ", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        # find the maximum subarray with max of K 0's \n        # this will help find the maximum number of 1s \n        \n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # fast = 5\n        # slow  = 0\n        # lastZero = 3, 4, 5\n        # slow = 3\n        slow = fast = 0\n        maxOnes = -1\n        lastZero = collections.deque()\n        while fast < len(A):\n            if A[fast] == 0:\n                lastZero.append(fast)\n                if len(lastZero) > K:\n                    slow = lastZero.popleft() + 1\n            fast += 1 \n            maxOnes = max(maxOnes, (fast - slow))\n        \n        if maxOnes == -1:\n            return len(A)\n        return maxOnes\n                    \n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        st,ed = 0,0\n        ans = 0\n        \n        longest = 0\n        k = 0\n        while ed < len(A):\n            while ed < len(A):\n                if A[ed] == 1:\n                    longest += 1\n                elif k < K:\n                    k += 1\n                    longest += 1\n                else:\n                    break\n                \n                ed += 1\n                \n            ans = max(longest, ans)      \n            while st <= ed and st < len(A):\n                longest -= 1\n                if A[st] == 0:\n                    k -= 1\n                    st += 1\n                    break\n                \n                st += 1\n                \n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        onecount = 0 \n        start = 0\n        ans = 0\n        \n        for end in range(len(A)):\n            if A[end] == 1: \n                onecount += 1\n \n            if end - start + 1 - onecount > K:\n                if A[start] == 1: onecount -= 1\n                start += 1\n   \n            ans = max(ans , end - start +1)\n            \n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        start, end, max_length, num_0 = 0, 0, 0, int(not A[0])\n        while end < len(A) - 1:\n            if num_0 > K:\n                if A[start] == 0:\n                    num_0 -= 1\n                start += 1\n            end += 1\n            if A[end] == 0:\n                num_0 += 1\n            if num_0 <= K:\n                max_length = end - start + 1\n        return max_length", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        startWindow = 0\n        maxLength = 0\n        nZerosInsideWindow = 0\n        \n        for endWindow, el in enumerate(A):\n            nZerosInsideWindow += (el == 0)\n            \n            while nZerosInsideWindow > K:\n                firstElement = A[startWindow]\n                nZerosInsideWindow -= (firstElement == 0)\n                startWindow += 1\n            \n            maxLength = max(maxLength, endWindow - startWindow + 1)\n        \n        return maxLength\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        n = len(A)\n        if n == 0:\n            return 0\n        \n        head = 0\n        tail = 0\n        num_zeros = 0\n        max_subseq = 0\n        while head < n:\n            if A[head] == 1:\n                head += 1\n            else:\n                num_zeros += 1\n                max_subseq = max(max_subseq, head-tail)\n                if num_zeros > K:\n                    while A[tail] == 1:\n                        tail += 1\n                    tail += 1\n                    num_zeros -= 1\n                head += 1\n        max_subseq = max(max_subseq, n-tail)\n        return max_subseq\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        allowance = K\n        currSum = 0\n        left = 0\n        maxSum = 0\n        for i in range(len(A)):\n            if A[i] == 1:\n                currSum += 1\n            else:\n                allowance -= 1\n                while allowance < 0:\n                    if A[left] == 1:\n                        currSum -= 1\n                    else:\n                        allowance += 1\n                    left += 1\n            maxSum = max(maxSum, K - allowance + currSum)\n        return maxSum\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        res = 0\n        i = 0\n        for j in range(len(A)):\n            if A[j] == 0:\n                K -= 1\n            res = max(res, j - i)\n            while K < 0:\n                if A[i] == 0:\n                    K += 1\n                i += 1\n        return max(res, len(A) - i)", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        res = 0\n        i = 0\n        for j in range(len(A)):\n            if A[j]==0:\n                K-=1\n            res = max(res,j-i)\n        \n            while K<0:\n                if(A[i]==0):\n                    K+=1\n                i += 1\n            \n        return max(res,len(A)-i)", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n      left = right = 0\n      \n      for right in range(len(A)):\n        # if we encounter a 0 the we decrement K\n        if A[right] == 0:\n          K -= 1\n        # else no impact to K\n        \n        # if K < 0 then we need to move the left part of the window forward\n        # to try and remove the extra 0's\n        if K < 0:\n          # if the left one was zero then we adjust K\n          if A[left] == 0:\n            K += 1\n          # regardless of whether we had a 1 or a 0 we can move left side by 1\n          # if we keep seeing 1's the window still keeps moving as-is\n          left += 1\n      \n      return right - left + 1\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:        \n        res = 0\n        i = 0\n        for j in range(len(A)):\n            if A[j] == 0:\n                K -= 1\n            res = max(res, j-i)\n            while K < 0 and i <= j:\n                if A[i] == 0:\n                    K += 1\n                i += 1\n                \n        return max(res, len(A)-i)\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        \n        i = 0\n        res = 0\n        for j, a in enumerate(A):            \n            if a == 0:\n                K-=1                   \n            while K < 0:\n                if A[i] == 0:\n                    K+=1\n                i+=1                \n            else:\n                res = max(res, j-i+1)\n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l, ans = 0, 0\n        for r in range(len(A)):\n            if A[r] == 0:\n                K -= 1\n            while K < 0:\n                if A[l] == 0:\n                    K += 1\n                l += 1\n            ans = max(ans, r+1-l)\n                \n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        if A == None or len(A) == 0 or K == None:\n            return 0\n        if len(A) <= K:\n            return K\n        \n        left = 0\n        flip = 0\n        maxlength = 0\n        for i, num in enumerate(A):\n            if A[i] == 0:\n                flip += 1\n            if flip <= K:\n                maxlength = max(maxlength, i - left + 1)\n                \n            while left < i and flip > K:\n                if A[left] == 0:\n                    flip -=1\n                left += 1\n\n        return maxlength\n            \n            \n        \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        count, n, l = 0, len(A), 0\n        ans = 0\n        for r in range(n):\n            count += 1 - A[r]\n            while count > K:\n                count -= 1 - A[l]\n                l += 1\n            ans = max(ans, r-l+1)\n        return ans\n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ans = 0\n        l = 0\n        for r in range(len(A)):\n            if A[r] == 0:\n                K -= 1\n            while K < 0:\n                if A[l] == 0:\n                    K += 1\n                l += 1\n            ans = max(ans, r+1-l)\n                \n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        windowstart, curr0,res = 0,0, 0\n        currwindow = {1:0 , 0:0}\n        \n        \n        for windowend in range(len(A)):\n\n        # add the new element into the current window,\n                currwindow[A[windowend]] +=1\n        # check if the least common number is above k\n                curr0 = currwindow[0]\n\n        # if yes, increase the window start \n                if curr0 > K :\n                        currwindow[A[windowstart]] -=1\n                        windowstart +=1\n                        \n        # look for the window size and max with the max and the current length\n                res = max (res, windowend-windowstart +1 )\n\n        return res ", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        count_1 = 0\n        zero_inx = []\n        res = 0\n        zero_before = -1\n        for i in range(len(A)):\n            if A[i] == 1:\n                count_1 += 1\n            else:\n                zero_inx.append(i)\n                if K > 0:\n                    K -= 1\n                    count_1 += 1\n                elif K == 0:\n                    res = max(res,count_1)\n                    first_0 = zero_inx.pop(0)\n                    count_1 -= (first_0 - zero_before - 1)\n                    zero_before = first_0\n        res = max(res, count_1)\n        return res", "class Solution:\n    def longestOnes(self, arr: List[int], k: int) -> int:\n        start_index = 0\n        longest_ones = 0\n        max_length = 0\n        for end_index in range(len(arr)):\n            if arr[end_index] == 1:\n                longest_ones += 1\n            if longest_ones+k <= (end_index - start_index):\n                if arr[start_index] == 1:\n                    longest_ones -= 1\n                start_index += 1\n            max_length = max(max_length, end_index-start_index+1)\n        return max_length\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        if A == None or len(A) == 0 or K == None:\n            return 0\n        if len(A) <= K:\n            return K\n        \n        left = 0\n        count_of_zero = 0\n        maxlength = 0\n        for i, num in enumerate(A):\n            if A[i] == 0:\n                count_of_zero += 1\n            if count_of_zero <= K:\n                maxlength = max(maxlength, i - left + 1)\n                \n            while left < i and count_of_zero > K:\n                if A[left] == 0:\n                    count_of_zero -=1\n                left += 1\n\n        return maxlength\n            \n            \n        \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l = 0\n        res = 0\n        for h in range(len(A)):\n            K -= 1 - A[h]\n            if K < 0:\n                K += 1 - A[l]\n                l += 1\n        return h-l+1", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i = 0\n        j = 0\n        \n        numZeros = 0\n        \n        bestSize = 0\n        while j < len(A):\n            if A[j] == 1:\n                pass\n            elif A[j] == 0:\n                numZeros += 1\n                while numZeros > K:\n                    if i >= 0 and A[i] == 0:\n                        numZeros -= 1\n                    i += 1\n            bestSize = max(bestSize, j - i + 1)\n            j += 1\n        return bestSize", "\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        s, e = 0, 0\n        r_k = K\n        result = 0\n        while e < len(A):\n            if A[e] == 0:\n                r_k -= 1\n\n            while r_k < 0:\n                if A[s] == 0:\n                    r_k += 1\n                s += 1\n\n            result = max(result, e - s + 1)\n\n            e+=1\n\n        return result\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        res = -1\n        start, count = 0, 0 # start is beginning of window, count is number of 1s\n        # i is end of window, hence len of window is i-start+1\n        \n        for i in range(len(A)):\n            if A[i]==1: count += 1\n            while (i-start+1-count > K):\n                if A[start]==1: count -= 1\n                start += 1\n            res = max(res, i-start+1)\n        \n        return res\n                \n", "class Solution:\n    def longestOnes(self, s: List[int], k: int) -> int:\n        l = 0\n        c_frequency = {0:0, 1:0}\n        longest_str_len = 0\n        for r in range(len(s)):\n            \n            if s[r] == 0:\n                c_frequency[0] += 1\n            else:\n                c_frequency[1] += 1\n            \n            # Replacements cost = cells count between left and right - highest frequency\n            cells_count = r - l + 1\n            if c_frequency[0] <= k or c_frequency[0] == 0:\n                longest_str_len = max(longest_str_len, cells_count)\n                \n            else:\n                if c_frequency[s[l]] != 0:\n                     c_frequency[s[l]] -= 1\n                l += 1\n        \n        return longest_str_len", "class Solution:\n    def longestOnes(self, A, K):\n        window_start, max_length, max_ones_count = 0, 0, 0\n        for window_end in range(0, len(A)):\n            if A[window_end] == 1:\n                max_ones_count += 1\n            while window_end - window_start + 1 - max_ones_count > K:\n                if A[window_start] == 1:\n                    max_ones_count -= 1\n                window_start += 1\n            max_length = max(max_length, window_end - window_start + 1)\n        return max_length\n", "import bisect\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ans = countzeroes = 0\n        counter = {0: -1}\n        for i, num in enumerate(A):\n            if num==0:\n                countzeroes+=1\n            if countzeroes not in counter:\n                counter[countzeroes] = i\n            j = counter[max(0, countzeroes-K)]\n            ans = max(ans, i-j)\n            \n        return ans\n", "import bisect\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ans = countzeroes = 0\n        counter = {0: -1}\n        for i in range(len(A)):\n            num = A[i]\n            if num==0:\n                countzeroes+=1\n            if countzeroes not in counter:\n                counter[countzeroes] = i\n            j = counter[max(0, countzeroes-K)]\n            ans = max(ans, i-j)\n            \n        return ans\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l,r = 0, -1\n        optim = 0\n        while r < len(A):\n            while r < len(A):\n                r += 1\n                if r == len(A):\n                    break\n                if A[r] == 0:\n                    K -= 1\n                if K < 0:\n                    break\n                else:\n                    optim = max(optim, r-l+1)\n            if r == len(A):\n                break\n            while l < r:\n                if A[l] == 0:\n                    K += 1\n                l += 1\n                if K >= 0:\n                    break\n        return optim", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        count = maxS = j = 0\n        \n        for i, a in enumerate(A):\n            if a == 0:\n                count += 1\n            \n            while j < len(A) and count > K:\n                if A[j] == 0:\n                    count -= 1\n                j += 1\n                \n            maxS = max(maxS, i-j+1)\n            \n        return maxS", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        windowstart,most_common,res=0,0,0\n        currentwindow={1:0, 0:0}\n        \n        for windowend in range(len(A)):\n\n            currentwindow[A[windowend]] +=1\n\n            most_common = currentwindow[1]\n\n            \n            #having this means we have to reduce the length of the window\n            if (windowend-windowstart+1 - most_common > K):\n                \n                currentwindow[A[windowstart]] -=1\n                windowstart +=1\n\n            res = max(res,windowend-windowstart+1)\n            \n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        for right in range(len(A)):\n            # If we included a zero in the window we reduce the value of K.\n            # Since K is the maximum zeros allowed in a window.\n            K -= 1 - A[right]\n            # A negative K denotes we have consumed all allowed flips and window has\n            # more than allowed zeros, thus increment left pointer by 1 to keep the window size same.\n            if K < 0:\n                # If the left element to be thrown out is zero we increase K.\n                K += 1 - A[left]\n                left += 1\n        return right - left + 1", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        zeros, ones, max_len = 0, 0,0\n        def element_found(element, inc):\n            nonlocal zeros, ones, max_len\n            if element == 0:\n                zeros += inc\n            else:\n                ones += inc\n            \n        start = 0\n        for element in A:\n            element_found(element, 1)\n            \n            while zeros > K:\n                start,start_element = start+1, A[start]\n                element_found(start_element, -1)\n            \n            max_len = max(max_len, zeros + ones)\n        return max_len\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        if not A:\n            return 0\n        \n        n = len(A)\n        \n        cur_max = 0\n        counter = 0\n        index = []\n        prev = -1\n        \n        for i in range(n):\n            if A[i] == 1:\n                counter += 1\n            else:\n                if K > 0:\n                    K -= 1\n                    counter += 1\n                    index.append(i)\n                else:\n                    if index:\n                        counter += 1\n                        temp = index.pop(0)\n                        counter -= temp - prev\n                        prev = temp\n                        index.append(i)\n                    else:\n                        counter = 0\n            \n            cur_max = max(cur_max, counter)\n            \n        return cur_max", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        left = 0\n        right = 0 \n        \n        k = K\n        max_ans = 0\n        so_far = 0\n        while(right < len(A)):\n            if(A[right]==1):\n                right+=1\n            else:\n                if(k>0):\n                    right+=1\n                    k-=1\n                else:\n                    if(A[left]==0):\n                        k+=1\n                    left+=1\n            \n            max_ans = max(max_ans, right-left)\n        \n        return max_ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        zeros_indices = []\n        for i in range(len(A)):\n            if A[i] == 0:\n                zeros_indices.append(i)\n\n        longest_ones = 0\n\n\n        longest_yet = 0\n        for i in range(len(A)):\n            if A[i] == 1:\n                longest_yet += 1\n                longest_ones = max(longest_ones, longest_yet)\n            else:\n                longest_yet = 0\n        if K == 0:\n            return longest_ones\n\n        if K >= len(zeros_indices):\n            return len(A)\n\n\n        # [0, 1, 4, 5, 9, 12, 13, 14]\n        zero_order = -1\n        for i in range(len(A)):\n            if A[i] == 0:\n                zero_order += 1\n                right_cons_ones = left_cons_ones = 0\n                if zero_order + K < len(zeros_indices):\n                    nxt = zero_order + K\n                    right_cons_ones = zeros_indices[nxt] - zeros_indices[zero_order]\n                else:\n                    nxt = len(zeros_indices) - 1\n                    right_cons_ones = zeros_indices[nxt] - zeros_indices[zero_order]\n                    right_cons_ones += len(A) - zeros_indices[nxt]\n                if not zero_order == 0:        \n                    left_cons_ones = zeros_indices[zero_order] - zeros_indices[zero_order-1] - 1\n                longest_ones = max(longest_ones, right_cons_ones + left_cons_ones)\n        return longest_ones", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        hash_count = dict()\n        hash_count[1] = 0\n        start = 0\n        max_count = 0\n        max_result = 0\n        for end in range(len(A)):\n            if A[end] == 1:\n                hash_count[A[end]] += 1 \n            max_count = max(max_count, hash_count[1])\n            if max_count + K  < ( end - start + 1 ):\n                if A[start] == 1 and hash_count.get(1):\n                    hash_count[1] -= 1\n                start += 1\n            max_result = max(max_result, end-start + 1)\n        return max_result\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        max_length = 0\n        start = 0\n        end = 1 \n        \n        zeros = 0\n            \n        if len(A) == 0:\n            return 0\n        if len(A) == 1:\n            return 1\n        \n        zeros = 2 - sum(A[:2])\n        \n        while end < len(A):\n                           \n            valid = zeros <= K\n            \n            if valid:\n                max_length = max(max_length, (end - start)+1)\n                end += 1\n                if end == len(A):\n                    return max_length\n                \n                if A[end] == 0:\n                    zeros += 1\n            else:\n                if A[start] == 0:\n                    zeros -= 1\n                start += 1\n        return max_length\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:       \n        K_original = K\n        i = 0\n        ans = 0\n        curr = 0\n        \n        j =0 \n        while(j<len(A)):\n            if A[j]==1 or K>0:\n                curr += 1\n            else:\n                curr = 0\n            K-=1 if (A[j]==0 and K>0) else 0\n            j+=1\n            ans = max(curr, ans)\n            if K_original>0 and K==0:\n                while(j<len(A) and A[j]==1):\n                    curr+=1\n                    j+=1\n                ans = max(curr, ans)\n                while(i<=j and i<len(A) and K==0):\n                    if A[i]==0:\n                        K+=1\n                    i+=1\n                    curr -=1 \n            # print(i,j,K, curr, ans)\n        return ans\n\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        hash_count = dict()\n        hash_count[1] = 0\n        start = 0\n        max_count = 0\n        max_result = 0\n        for end in range(len(A)):\n            if A[end] == 1:\n                hash_count[A[end]] += 1 \n            max_count = max(max_count, hash_count[1])\n            #print(f\\\" {max_count + K}  comp  {end - start + 1}\\\")\n            if max_count + K  < ( end - start + 1 ):\n                if A[start] == 1 and hash_count.get(1):\n                    hash_count[1] -= 1\n                start += 1\n            max_result = max(max_result, end-start + 1)\n            #print(max_result)\n        return max_result\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left, right = 0, 0\n        k = 0\n        flipped = set()\n        longest = 0\n        while right < len(A):\n            if A[right] == 1:\n                longest = max(longest, right - left + 1)\n                right += 1\n            elif A[right] == 0 and k < K:\n                flipped.add(right)\n                longest = max(longest, right - left + 1)\n                right += 1\n                k += 1\n            elif left == right:\n                right += 1\n                left += 1\n            else:\n                if left in flipped:\n                    flipped.discard(left)\n                    k -= 1\n                left += 1\n            \n            \n        return longest", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ct = Counter()\n        pt, max_len = 0, 0\n        for i, elem in enumerate(A):\n            ct[elem] += 1\n            if ct[0] <= K:\n                max_len = max(max_len, (i - pt + 1))\n            if ct[0] > K:\n                ct[A[pt]] -= 1\n          \n                pt += 1\n\n        return max_len\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        left = 0\n        for right in range(len(A)):\n            # If we included a zero in the window we reduce the value of K.\n            # Since K is the maximum zeros allowed in a window.\n            K -= 1 - A[right]\n            # A negative K denotes we have consumed all allowed flips and window has\n            # more than allowed zeros, thus increment left pointer by 1 to keep the window size same.\n            if K < 0:\n                # If the left element to be thrown out is zero we increase K.\n                K += 1 - A[left]\n                left += 1\n        print(len(A),right)\n        return right - left + 1", "from collections import deque\n\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        substited_indexes = deque()\n        start = 0\n        best = 0\n        \n        index = 0\n        while index < len(A):\n            num = A[index]\n            \n            if num == 0:\n                if K > 0:\n                    K -= 1\n                    A[index] = 1\n                    substited_indexes.append(index)\n                elif K == 0 and len(substited_indexes) == 0:\n                    start = index + 1\n                else:\n                    start = substited_indexes.popleft()\n                    A[start] = 0\n                    start += 1\n                    K += 1\n                    continue\n            \n            index += 1\n            best = max(best, index - start)\n            \n        return best\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        max_length = 0\n        start = 0\n        end = 1\n        ones = 1\n\n        if len(A) == 0:\n            return 0\n        if len(A) == 1:\n            return 1\n\n        ones = A[0] + A[1]\n\n        while end < len(A):\n\n            valid = ((end - start) + 1) - ones <= K\n\n            if valid:\n                max_length = max(max_length, (end - start) + 1)\n                end += 1\n                if end == len(A):\n                    return max_length\n                ones += A[end]\n            else:\n                ones -= A[start]\n                start += 1\n        return max_length\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        answer, length = 0, 0\n        inds = []\n        for i, num in enumerate(A):\n            if num == 1:\n                length += 1\n            elif len(inds) < K:\n                inds.append(i)\n                length += 1\n            elif K == 0:\n                length = 0\n            else:\n                last_index = inds.pop(0)\n                inds.append(i)\n                length = (i - inds[0]) + (inds[0] - last_index)\n            answer = max(answer, length)\n        return answer", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        max_length = 0\n        start = 0\n        end = 1\n        ones = 1\n\n        if len(A) == 0:\n            return 0\n        if len(A) == 1:\n            return 1\n\n        ones = sum(A[:2])\n\n        while end < len(A):\n\n            valid = ((end - start) + 1) - ones <= K\n\n            if valid:\n                max_length = max(max_length, (end - start) + 1)\n                end += 1\n                if end == len(A):\n                    return max_length\n                ones += A[end]\n            else:\n                ones -= A[start]\n                start += 1\n        return max_length\n", "import bisect\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ans = 0\n        countzeroes = 0\n        prefix = []\n        for i, num in enumerate(A):\n            prefix.append(countzeroes)\n            if num==0:\n                countzeroes+=1\n            j = bisect.bisect_left(prefix, countzeroes-K)\n            ans = max(ans, i-j + 1)            \n        return ans\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        counter = 0\n        i = 0 \n        j = 0\n        res=0\n        \n        for i in range(0,len(A)):\n            \n            if A[i] == 0:\n                counter+=1\n                \n            while counter>K and j<len(A):\n                if A[j]==0:\n                    counter-=1\n                j+=1 \n            res= max(res,i-j+1)\n            print(res)\n        \n        return res\n", "class Solution:\n    def longestOnes(self, A, K: int) -> int:\n        ans = count = 0\n        j = 0  # valid range is [i:j]\n        for i in range(len(A)):\n            if i > 0 and A[i - 1] == 0:\n                count -= 1\n\n            while j < len(A) and (A[j] or count < K):\n                if A[j] == 1:\n                    j += 1\n                elif count < K:\n                    count += 1\n                    j += 1\n\n            ans = max(ans, j - i)\n\n        return ans\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l = 0\n        r = 0\n        max_count = K\n\n        while (l < len(A) and r < len(A)):\n            \n            while(r < len(A)):\n                if A[r] == 1:\n                    r += 1\n                elif K > 0:\n                    r += 1\n                    K -= 1\n                else:\n                    break\n            if r - l + 1> max_count:\n                max_count = r - l\n            print(l,r,max_count)\n            if A[l] == 0:\n                K += 1\n            l += 1\n\n        return max_count", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        hashMap = {}\n        windowStart = 0\n        m = 0\n        hashMap[1] = 0\n        for windowEnd in range(len(A)):\n            if A[windowEnd] not in hashMap:\n                hashMap[A[windowEnd]] = 0\n            hashMap[A[windowEnd]] += 1\n     \n            while sum(hashMap.values()) - hashMap[1] > K:\n                hashMap[A[windowStart]] -= 1\n                windowStart += 1\n            m = max(m, windowEnd - windowStart + 1)\n        return m\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        maxLen = 0\n        oneFreq = 0\n        maxFreq = 0\n\n        for right in range(len(A)):\n            oneFreq += A[right]\n            maxFreq = max(maxFreq, oneFreq)\n\n            if right - left + 1 - maxFreq > K:\n                oneFreq -= A[left]\n                left += 1\n\n            maxLen = max(maxLen, right - left + 1)\n\n        return maxLen", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i,j,n = 0,0,len(A)\n        \n        for x in A:\n            j+=1\n            if x==0:\n                K-=1\n            if K<0:\n                if A[i]==0:\n                    K+=1\n                i+=1\n        return j-i\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        ans = 0\n        lo = 0\n        hi = 0\n        \n        d = collections.defaultdict(int)\n        while(hi<len(A)):\n            d[A[hi]]+=1\n            \n            while d[0]>K:\n                d[A[lo]]-=1\n                if d[A[lo]] == 0: del d[A[lo]]\n                lo+=1\n            ans = max(ans, hi-lo+1)\n            hi+=1\n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        '''naive\n        \n        \n        sliding window\n        keep growing sliding window rhs as num of 0s in window is >k\n        when num 0s == k, slide lhs of window until k > num 0s again\n        keep track of largest sliding window'''\n        \n        \n        if not A:\n            return 0\n        \n        best_window_len = 0\n        p, q = 0, 0\n        \n        num_zeros = 0\n\n        while q < len(A):\n            if A[q] == 0: num_zeros += 1\n            #print(p, q, q - p)\n            if num_zeros > K:\n                best_window_len = max(q - p, best_window_len)\n                #print(\\\"running best:\\\", best_window_len)\n                while num_zeros > K:\n                    if A[p] == 0:\n                        num_zeros -= 1\n                    p += 1\n            q+=1\n            \n        best_window_len = max(q - p, best_window_len)\n        return best_window_len\n                \n", "class Solution:\n    def longestOnes(self, arr: List[int], k: int) -> int:\n        hashmap=dict()\n        max_len=length=start_index=0\n        hashmap[0]=0\n        hashmap[1]=0\n        for i in arr:\n            hashmap[i]+=1\n            if hashmap[0]>k:\n                hashmap[arr[start_index]]-=1\n                start_index+=1\n            max_len=max(max_len,sum(hashmap.values()))\n\n        return max_len", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        # c1 and c0 are the count of 1 and 0 between left and right\n        left,right=0,0\n        n,c1,c0=len(A),0,0\n        ans=0\n        while True:\n            if c0<=K:\n                # it is a legal interval\n                ans=max(ans, right-left)\n                # move right\n                if right<n:\n                    right+=1\n                    x=A[right-1]\n                    if x: c1+=1\n                    else: c0+=1\n                else: return ans\n            else:\n                # move left\n                x=A[left]\n                left+=1\n                if x: c1-=1\n                else: c0-=1\n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        count = 0\n        max_count = 0\n\n        buf = K\n        l = r = 0\n        needs_buf = False\n        while l < len(A) and r < len(A):\n            if A[r] == 1:\n                count += 1\n                r += 1\n            elif A[r] == 0:\n                if buf:\n                    buf -= 1\n                    count += 1\n                    r += 1\n                else:\n                    needs_buf = True\n            \n            if needs_buf:\n                if A[l] == 0:\n                    buf += 1\n                    needs_buf = False\n                count -= 1\n                l += 1\n\n            if count > max_count:\n                max_count = count\n            # print(A[l:r])\n\n        # print(f'l: {l}, r: {r}')\n        return max_count", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        s,e,z,l = 0,0,0,0\n        ans = 0\n        while e<len(A):\n            if A[e] == 0:\n                z += 1\n            while z>K:\n                if A[s] == 0:\n                    z -= 1\n                s += 1\n                l -= 1\n            l += 1\n            ans = max(ans, l)\n            e += 1\n        return ans", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        res = 0\n        zeros = 0\n        n = len(A)\n        i = 0\n        for j in range(n):\n            zeros += A[j] == 0\n            if zeros <= K:\n                res = max(res, j-i+1)\n            if zeros > K:\n                zeros -= A[i] == 0\n                i += 1\n        return res\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        # right = 0\n        zeros = 0\n        res = 0\n        \n        for right in range(len(A)):\n            \n            if A[right] == 0:\n                zeros += 1\n                \n            while zeros > K:\n                left += 1\n                if A[left-1] == 0:\n                    zeros -= 1\n                    \n            res = max(res, right - left + 1)\n        \n        # if res == 0:\n        #     return 0\n        \n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i = 0\n        for j in range(len(A)):\n            K -= 1 - A[j]\n            if K < 0:\n                K += 1 - A[i]\n                i += 1\n        return j - i + 1\n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n            start, end = 0,0\n            max_len = 0\n            numzeros = 0\n            while end < len(A):\n                if A[end] == 0:\n                    numzeros += 1\n                while numzeros > K:\n                    # shrink window\n                    if A[start] == 0:\n                        numzeros -= 1\n                    start += 1\n                max_len = max(max_len, end-start+1)\n                end += 1\n            return max_len\n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        result = 0\n        zero_allowed = K\n        left = 0\n        \n        for right, x in enumerate(A):\n            if x==0:\n                zero_allowed -= 1\n            if zero_allowed>=0 and (right - left + 1) > result:\n                result = right - left + 1\n            \n            while zero_allowed < 0 and (right - left + 1) > result:\n                if A[left]==0:\n                    zero_allowed += 1\n                left += 1\n        \n        return result", "class Solution:\n    def longestOnes(self, arr: List[int], k: int) -> int:\n        start, max_length = 0,0\n        count_0 = 0\n\n        for end in range(len(arr)):\n\n            if arr[end] == 0:\n                count_0 += 1\n\n            while count_0 > k:\n                if arr[start] == 0:\n                    count_0 -= 1\n                start += 1\n            max_length = max(max_length, end - start + 1)\n        return max_length", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        zeroes = []\n        count = 0\n        maxCount = 0\n        for i in range(len(A)):\n            if A[i] == 0:\n                zeroes.insert(0,i)\n                \n            if len(zeroes) > K:\n                count = i - zeroes.pop()\n            else:\n                count += 1\n            maxCount = max(maxCount, count)\n        return maxCount\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        curr_k = 0\n        pointer_start = 0\n        pointer_end = 0\n        max_ones = 0\n        curr_ones = 0\n        while pointer_end < len(A):\n            if A[pointer_end] == 0:\n                if curr_k >= K:\n                    if A[pointer_start] == 0:\n                        curr_k -= 1\n                    pointer_start += 1\n                    curr_ones -= 1\n                else:\n                    pointer_end += 1\n                    curr_ones += 1\n                    curr_k += 1\n            else:\n                pointer_end += 1\n                curr_ones += 1\n            max_ones = max(curr_ones, max_ones)\n        return max_ones", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        ## intuition: probably use sliding windows\n        \n        l=0\n        r=0\n        val=0\n        if A[0]==0:\n            val=1\n        maxlength = 0\n        \n        \n        while r<len(A)-1:\n            while val<=K and r<len(A)-1:\n                if A[r+1]==0:\n                    val+=1\n                r+=1\n            if r==len(A)-1 and val<=K:\n                maxlength = max(maxlength, r-l+1)\n            elif val>K:\n                ##this must mean that A[r]==0\n                maxlength = max(maxlength, r-l)\n                # print(l,r,maxlength, val)\n                while val>K:\n                    if A[l]==0:\n                        val-=1\n                    l+=1\n        \n        return maxlength\n            \n            \n                \n                \n", "import math\nimport random\nimport string\nfrom functools import lru_cache\nfrom operator import truediv\nfrom typing import List\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\nimport numpy as np\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\n\u53cd\u8f6cK\u4e2a\u4f4d\u7f6e\u76840\u4e3a1\uff0c\u95ee\u6700\u957f\u8fde\u7eed1\u7684\u957f\u5ea6\u3002\n\nInput: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\nOutput: 10\nExplanation: \n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1.  The longest subarray is underlined.\n\n\n\u601d\u8def\uff1a\u6ed1\u52a8\u7a97\u53e3\u3002\n\u4e3b\u8981\u601d\u60f3\uff0c\u5f00\u533a\u95f4\u4f38\u7f29\u5de6\u53f3\u8fb9\u754c\u3002\u95ed\u533a\u95f4\u4e0d\u597d\u5904\u7406\u521d\u59cb\u60c5\u51b5\u3002\n\n'''\n\n\nclass Solution:\n    def longestOnes1(self, A: List[int], K: int) -> int:\n        # \u5f00\u533a\u95f4[start, end)\n        start = 0\n        end = 0\n        ret = 0\n        while end < len(A):\n            if A[end] == 1:\n                end += 1\n            else:\n                if K > 0:\n                    end += 1\n                    K -= 1\n                else:\n                    if A[start] == 0:\n                        K += 1\n                    start += 1\n            ret = max(ret, end - start)\n        return ret\n\n    def longestOnes(self, A, K):\n        i = 0\n        for j in range(len(A)):\n            K -= 1 - A[j]\n            if K < 0:\n                K += 1 - A[i]\n                i += 1\n        return j - i + 1\n\n# A = [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1]\n# K = 3\n# \n# r = Solution()\n# a = r.longestOnes(A, K)\n# print(a)\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        if not A:\n            return 0\n        \n        \n        ans = 0\n        count = [0, 0]\n        max_count = 0\n        l = 0\n        for r in range(len(A)):\n            # update the count\n            count[A[r]] += 1\n            max_count = max(max_count, count[1])\n            if r - l + 1 - max_count > K:\n                count[A[l]] -= 1\n                l += 1\n            else:\n                ans = max(ans, r - l + 1)\n        \n        return ans\n            \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        le = 0\n        for ri in range(len(A)):\n            K -= (1-A[ri]) # \u5982\u679cA[ri]\u662f0, k \u8981\u51cf\u53bb1\n            \n            print (le, ri)\n            if K < 0:\n                K += (1 - A[le])\n                le += 1\n        return ri - le + 1", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        n = len(A)\n\n        res = 0\n        j, count0 = 0, 0\n        for i in range(n):\n            if not A[i]:\n                count0 += 1\n                if count0 > K:\n                    res = max(res, i - j)\n                    while A[j]:\n                        j += 1\n                    j += 1\n                    count0 -= 1\n                    \n        res = max(res, i - j + 1)\n        return res\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i = 0\n        j = 0\n        maxValue = 0\n        numZeros = 0\n        while j < len(A):\n            if not A[j]:\n                if numZeros < K:\n                    numZeros += 1\n                    j += 1\n                else:\n                    maxValue = max(maxValue, j-i)\n                    while i <= j and A[i]:\n                        i += 1\n                    i += 1\n                    j += 1\n            else:\n                j += 1\n        maxValue = max(maxValue, j-i)\n        return maxValue\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        zeroes = []\n        count = 0\n        maxCount = 0\n        j = 0\n        for i in range(len(A)):\n            \n            if A[i] == 0:\n                zeroes.insert(0,i)\n\n            if len(zeroes) > K:\n                count = i - zeroes.pop()\n            else:\n                count += 1\n            maxCount = max(maxCount, count)\n        return maxCount\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i,j=0,0\n        res=0\n        zeroes=K\n        count=[0]\n        while i<len(A):\n            if A[i]==0:\n                zeroes-=1\n            if zeroes<0:\n                if A[j]==0:\n                    zeroes+=1\n                j+=1\n            i+=1\n            res=max(res,i-j)\n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left = 0\n        for right in range(len(A)):\n            K -= 1 - A[right]\n            if K < 0:\n                K += 1 - A[left]\n                left += 1\n        return right - left + 1", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        maxOnes = 0\n        start = 0\n        maxZeroes = 0\n        \n        for i in range(len(A)):\n            if A[i] == 0:\n                maxZeroes += 1\n                \n            while maxZeroes > K:\n                if A[start] == 0:\n                    maxZeroes -= 1\n                \n                start += 1\n                \n            maxOnes = max(maxOnes,i-start + 1)\n            \n        return maxOnes", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        start = 0\n        ans = 0\n        nn = [0, 0]\n        \n        for i, a in enumerate(A):\n            nn[a] += 1\n            while nn[0] > K:\n                nn[A[start]] -= 1\n                start += 1\n            \n            ans = max(ans, nn[0] + nn[1])\n        return ans", "import bisect \nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        n = len(A)\n        zeros = 0\n        dp = [0]*n\n        ans = 0\n\n        for i in range(n):\n            if A[i]==0:\n                zeros+=1\n            dp[i]=zeros\n        # print(dp)\n        for i in range(n):\n            val = dp[i]\n            if A[i]==1:\n                right = bisect.bisect_left(dp,val+K+1)\n            else:\n                right = bisect.bisect_left(dp,val+K)\n            # print(i,right)\n            delta = right-i\n            ans = max(ans,delta)\n            # print(i,ans,right)\n        return ans ", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        left = right = 0\n        \n        for right in range(len(A)):\n            if A[right] == 0:\n                K-=1\n            \n            if K < 0:\n                \n                if A[left] == 0:\n                    K+=1\n                \n                left += 1\n        \n        return right-left + 1\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        queue = []\n        i = ans = 0\n        for j in range(len(A)):\n            if(A[j] != 1):\n                if(len(queue) == K):\n                    try:\n                        i = queue.pop(0)+1\n                    except:\n                        i=j+1\n                if(len(queue) < K):\n                    queue.append(j)\n            ans = max(ans, j-i+1)\n        return ans", "from collections import deque\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        q=deque()\n        cnt=0\n        max_cnt=0\n        for i in range(len(A)):\n            if A[i]==0:\n                q.append(i)\n                if len(q)>K:\n                    max_cnt=max(max_cnt,cnt)\n                    cnt=i-q[0]\n                    q.popleft()\n                else:\n                    cnt+=1\n            else:\n                cnt+=1\n        max_cnt=max(max_cnt,cnt)\n        return max_cnt", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        l = 0\n        r = 0\n        m = len(A)\n        count = 0\n        max_count = 0\n        while r < m:\n            if A[r] == 1:\n                count += 1\n            while r - l + 1 - count > K:\n                if A[l] == 1:\n                    count -= 1\n                l += 1\n            max_count = max(r-l+1, max_count)\n            r += 1\n        return max_count\n", "class Solution:\n    def longestOnes(self, A, K):\n        if not A:\n            return 0\n        n = len(A)\n        right = 0\n        cnt = 0\n        res = 0\n        for left in range(n):\n            while right <= n - 1 and (cnt < K or A[right] == 1):\n                cnt += (A[right] == 0)\n                right += 1\n            res = max(res, right - left)\n            cnt -= (A[left] == 0)\n        return res", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        \n        pre_sum = [A[0]]\n        for i in range(1,len(A)):\n            pre_sum.append(pre_sum[-1]+A[i])\n            \n        def cal(l,r):\n            if (l == 0):\n                return pre_sum[r]\n            else:\n                return pre_sum[r] - pre_sum[l-1]\n            \n        l = 0\n        r = 0\n        ans = K\n        while (l<len(A)):\n            #print (l,r)\n            while (r<len(A) and (r-l+1)-cal(l,r)<=K ):\n                ans = max(ans,r-l+1)\n                r = r + 1\n            #print (r)\n            \n            if (r==len(A)):\n                break\n                \n            while ( l<len(A) and (r-l+1)-cal(l,r)>K ):\n                l = l + 1\n            #print (l)\n            \n        return ans\n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i=j=maxCount=maxlen=0\n        d={0:0,1:0}\n        while(i<len(A)):\n            d[A[i]]+=1\n            while(d[0]>K):\n                d[A[j]]-=1\n                j+=1\n            maxlen=max(maxlen,i-j+1)\n            i+=1\n        return maxlen", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        i, ans = 0, 0\n        for j, num in enumerate(A):\n            if num == 0:\n                K -= 1\n            while K < 0:\n                if A[i] == 0:\n                    K += 1\n                i += 1\n            ans = max(ans, j-i+1)\n        return ans\n        \n        ans = 0\n        start, end = 0, 0\n        \n        while end < len(A):\n            if A[end] == 1:\n                ans = max(ans, end-start+1)\n                end+=1\n            else:\n                if K != 0:\n                    ans = max(ans, end-start+1)\n                    end+=1\n                    K -= 1\n                else:\n                    if A[start] == 0:\n                        K+=1\n                    start+=1\n        return ans\n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        le, ri = 0, 0\n        max_len = 0\n        while ri < len(A):\n            if A[ri] == 0:\n                K -= 1\n            ri += 1\n            if K >= 0:\n                max_len= max(max_len, ri - le)\n            print((le, ri))\n            while K < 0 and le < ri:\n                if A[le] == 0:\n                    K += 1\n                le += 1\n            \n        return max_len\n                \n", "class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        left,right = 0,0\n        num_zeros = 0\n        window_size = 0\n        \n        while right < len(A):\n            if A[right] == 0:\n                num_zeros += 1\n            while num_zeros > K:\n                if A[left] == 0:\n                    num_zeros -= 1\n                left += 1 \n            window_size = max(window_size,right-left+1)\n            right += 1\n            \n        return window_size    ", "import math\nimport random\nimport string\nfrom functools import lru_cache\nfrom operator import truediv\nfrom typing import List\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\nimport numpy as np\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\n\u53cd\u8f6cK\u4e2a\u4f4d\u7f6e\u76840\u4e3a1\uff0c\u95ee\u6700\u957f\u8fde\u7eed1\u7684\u957f\u5ea6\u3002\n\nInput: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\nOutput: 10\nExplanation: \n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1.  The longest subarray is underlined.\n\n\n\u601d\u8def\uff1a\u6ed1\u52a8\u7a97\u53e3\u3002\n\u4e3b\u8981\u601d\u60f3\uff0c\u5f00\u533a\u95f4\u4f38\u7f29\u5de6\u53f3\u8fb9\u754c\u3002\u95ed\u533a\u95f4\u4e0d\u597d\u5904\u7406\u521d\u59cb\u60c5\u51b5\u3002\n\n'''\n\n\nclass Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        # \u5f00\u533a\u95f4[start, end)\n        start = 0\n        end = 0\n        ret = 0\n        while end < len(A):\n            if A[end] == 1:\n                end += 1\n            else:\n                if K > 0:\n                    end += 1\n                    K -= 1\n                else:\n                    if A[start] == 0:\n                        K += 1\n                    start += 1\n            ret = max(ret, end - start)\n        return ret\n\n\n# A = [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1]\n# K = 3\n# \n# r = Solution()\n# a = r.longestOnes(A, K)\n# print(a)\n"]
["class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         def prod(nums):\n             #function to calculate product\n             prod = 1\n             for i in nums:\n                 prod*=i\n             return prod\n         def listsplit(ls1,index):\n             result = []\n             st = -1\n             for i in index:\n                 if i == 0:\n                     st = i\n                 else:\n                     result.append(ls1[st+1:i])\n                     st = i\n             if st<len(ls1)-1:\n                 result.append(ls1[st+1:])\n             return result\n         \n         #main starts here\n         if not nums:\n             return 0\n         if len(nums) == 1:\n             return nums[0]\n         #find zeros: if zeros are included the result would be zeros only\n         result=[]\n         if 0 in nums:\n             zeros = [i for i in range(len(nums)) if nums[i] ==0]\n             sublist = listsplit(nums,zeros)\n             result.append(0)\n         else:\n             sublist = [nums]\n         #find negative numbers. consider even or odd\n         sublist = [i for i in sublist if i]\n         \n         for i in sublist:\n             if prod(i) <0:\n                 #there is negative number in the list\n                 negative = [j for j in range(len(i)) if i[j] < 0]\n                 left,right = negative[0],negative[-1]\n                 if len(i) == 1:\n                     result_t = i[0]\n                 elif left == 0 or right == len(i) -1:\n                     result_t = max(prod(i[left+1:]),prod(i[:right]))\n                 else:\n                     left_p,right_p = prod(i[:left]),prod(i[right+1:])\n                     if left_p <= right_p:\n                         result_t = prod(i[left+1:])\n                     else:\n                         result_t = prod(i[:right])\n             else:\n                 result_t = prod(i)\n             result.append(result_t)\n         return max(result)", "class Solution:\n \n \tdef maxProduct(self, nums):\n \t\tself._prod_cache = {}\n \t\tm_value = None\n \t\tif len(nums)==1:\n \t\t\treturn nums[0]\n \t\tif len(nums)==0:\n \t\t\treturn 0\n \t\tfor i in range(len(nums)):\n \t\t\ta_value = self.get_max_prod(nums, i, 1)\n \t\t\tif m_value is None or a_value>m_value:\n \t\t\t\tm_value = a_value\n \t\treturn m_value\n \n \tdef get_max_prod(self, nums, i, acc_p):\n \t\tif i<0:\n \t\t\treturn None\n \t\tif (i, acc_p) in self._prod_cache:\n \t\t\treturn self._prod_cache[(i, acc_p)]\n \t\tval = nums[i]\n \t\tif i>0:\n \t\t\tmax_p = max(self.get_max_prod(nums, i-1, acc_p*val),\n \t\t\t\t\t   acc_p*val)\n \t\telse:\n \t\t\tmax_p = acc_p*val\n \n \t\tself._prod_cache[(i, acc_p)]=max_p\n \t\treturn max_p\n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n=len(nums)\t\t\n         if n==0: return 0\n         if n==1: return nums[0]\n         ans=nums[0]\n         l=0\n         r=n-1 \n         prod=1\n \n         i=0\n         while i<n:\n             if nums[i]==0:\n                 zero_idx=i\n                 return max(self.maxProduct(nums[(zero_idx+1):]), max(0,self.maxProduct(nums[0:zero_idx])))\n             else:\n                 prod=prod*nums[i]\n                 i=i+1\n \t\t\n \n         if prod>0: return prod\n         prod_right=prod\n         max_prod_right=prod\n \t\t\n         prod_left=prod\n         max_prod_left=prod\n \t\t\n         if prod<0:\n             #print(max_prod_right)           \n             while 0<=r:\n                 prod_right=prod_right//nums[r]\n                 r=r-1\n                 if prod_right>max_prod_right:\n                     if prod_right>0:\n                         max_prod_right=prod_right\n                         break\n                     else:\n                         max_prod_right=prod_right\n \t\t\t\t\t\t\n \t\t    \n             print(max_prod_left)\n             while l<n:\n                 prod_left=prod_left//nums[l]\n                 l=l+1\n                 #print(l, prod_left,\"----\", nums[l], nums[l:])\n                 if prod_left>max_prod_left:\n                     if prod_left>0:\n                         max_prod_left=prod_left\n                         break\n                 else:\n                     max_prod_left=prod_left\n \n         #print(max_prod_left, max_prod_right)\t\t\t\n         return max(max_prod_left, max_prod_right)\n \t\t\n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums: return 0\n         res = premax = premin = nums[0]\n         curmax = curmin = None\n         for n in nums[1:]:\n             curmax, curmin = max(premax*n, premin*n, n), min(premax*n, premin*n, n)\n             premax, premin = curmax, curmin\n             res = max(res, curmax)\n         return res\n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         glo_max = nums[0]\n         \n         imax = glo_max\n         imin = glo_max\n         i = 1\n         \n         while i < len(nums):\n             \n             \n             if nums[i] < 0:\n                 temp = imax\n                 imax = imin\n                 imin = temp\n             \n             imax = max(nums[i], nums[i] * imax)\n             imin = min(nums[i], nums[i] * imin)\n             \n             \n             glo_max = max(glo_max, imax)\n             i += 1\n         \n         return glo_max", "class Solution(object):\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         # track min_negative_product and max_positive_product\n         \n         \n         if len(nums) == 0:\n             return nums\n         if len(nums) == 1:\n             return nums[0]\n         \n         curr_min = curr_max = best_max = nums[0]\n         \n         for i in range(1,len(nums)):\n             curr_min,curr_max = min(nums[i],nums[i]*curr_min,nums[i]*curr_max),max(nums[i],nums[i]*curr_min,nums[i]*curr_max)\n             \n             best_max = max(curr_max,best_max)\n             \n         return best_max", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         dp_max=[0]*len(nums)\n         dp_min=[0]*len(nums)\n         res=dp_max[0]=dp_min[0]=nums[0]\n         \n         for i in range(1,len(nums)):\n             dp_max[i]=max(nums[i],dp_max[i-1]*nums[i],dp_min[i-1]*nums[i])\n             dp_min[i]=min(nums[i],dp_max[i-1]*nums[i],dp_min[i-1]*nums[i])\n             res=max(res,dp_max[i])\n         return res", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         max_val = -float(\"inf\")\n         product = 1\n         for num in nums:\n             product *= num\n             max_val = max(product, max_val)\n             if num == 0:\n                 product = 1\n         product = 1\n         for num in nums[::-1]:\n             product *= num\n             max_val = max(product, max_val)\n             if num == 0:\n                 product = 1\n         return max_val", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         res = loc_min = loc_max = nums[0]\n         for i in nums[1:]:\n             if i < 0:\n                 loc_min, loc_max = loc_max, loc_min\n             loc_min = min(i, loc_min * i)\n             loc_max = max(i, loc_max * i)\n             res = max(loc_min, loc_max, res)\n         return res", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 1:\n             return nums[0]\n \n         else:\n             result = big = small = nums[0]\n         for i in nums[1:]:\n             big, small = max(i, i*big, i*small), min (i,i*small, i*big)\n             result = max(result, big)\n         return result\n \n                     \n                 \n                 \n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(nums)\n         dp = [[nums[0], nums[0]]] * n\n         ans = nums[0]\n         for i in range(1, n):\n             temp = [dp[i-1][0] * nums[i], dp[i-1][1] * nums[i], nums[i]]\n             dp[i][0], dp[i][1] = max(temp), min(temp)\n             if dp[i][0] > ans:\n                 ans = dp[i][0]\n         return ans", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(nums)\n         dp = [[nums[0], nums[0]] for _ in range(n)]\n         ans = nums[0]\n         for i in range(1, n):\n             temp = [dp[i-1][0] * nums[i], dp[i-1][1] * nums[i], nums[i]]\n             dp[i][0], dp[i][1] = max(temp), min(temp)\n             if dp[i][0] > ans:\n                 ans = dp[i][0]\n         return ans\n     \n #        n = len(nums)\n #        dp = [[nums[0], nums[0]]] * n   \u5c3d\u91cf\u4e0d\u8981\u4f7f\u7528\u4e58\u6cd5\n #        ans = nums[0]\n #        for i in range(1, n):\n #            temp = [dp[i-1][0] * nums[i], dp[i-1][1] * nums[i], nums[i]]\n #            dp[i][0], dp[i][1] = max(temp), min(temp)   \u8fd9\u6837\u8d4b\u503c\u4f1a\u6539\u53d8\u6240\u6709\u503c\n #            if dp[i][0] > ans:\n #                ans = dp[i][0]\n #        return dp[-1][0]\n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         f = [[nums[0], nums[0]]]\n         ans = nums[0]\n         for i in range(1, len(nums)):\n             f.append([0, 0])\n             f[i][0] = min(f[i-1][0]*nums[i], f[i-1][1]*nums[i], nums[i])\n             f[i][1] = max(f[i-1][0]*nums[i], f[i-1][1]*nums[i], nums[i])\n             ans = max(ans, f[i][1])\n         return ans", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         largestproduct = []\n         smallestproduct = []\n         n =len(nums)\n         largestproduct.append(nums[0])\n         smallestproduct.append(nums[0])\n         for i in range(n-1):\n             lp = max(max(largestproduct[i]*nums[i+1],smallestproduct[i]*nums[i+1]),nums[i+1])\n             sp = min(min(largestproduct[i]*nums[i+1],smallestproduct[i]*nums[i+1]),nums[i+1])\n             largestproduct.append(lp)\n             smallestproduct.append(sp)\n         sol = largestproduct[0]\n         for i in range(n):\n             sol = max(sol,largestproduct[i])\n         return sol\n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         maxPos = nums[0]\n         maxNeg = -nums[0]\n         p = 1\n         result = nums[0] \n         while p < len(nums):\n             if nums[p] >= 0:\n                 tmp1 = max(nums[p], nums[p] * maxPos)\n                 tmp2 = max(-nums[p], nums[p] * maxNeg) \n                 maxPos = tmp1\n                 maxNeg = tmp2\n             else:\n                 tmp1 = max(nums[p], -nums[p] * maxNeg)\n                 tmp2 = max(-nums[p], -nums[p] * maxPos)\n                 maxPos = tmp1\n                 maxNeg = tmp2\n             print((nums[p], maxPos, maxNeg))\n             result = max(result, maxPos)\n             p += 1\n         return result\n     \n \n", "class Solution:\n     def maxProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         maxP = nums[0]\n         minP = nums[0]\n         p = 1\n         result = nums[0] \n         while p < len(nums):\n             tmp1 = max(nums[p], nums[p] * maxP, nums[p] * minP)\n             tmp2 = min(nums[p], nums[p] * maxP, nums[p] * minP) \n             maxP = tmp1\n             minP = tmp2\n             print((nums[p], maxP, minP))\n             result = max(result, maxP)\n             p += 1\n         return result\n     \n \n"]
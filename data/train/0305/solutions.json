["# class Solution:\n#     def distinctEchoSubstrings(self, text: str) -> int:\n#         ans = set()\n        \n#         for i in range(len(text)-1): \n#             for j in range(i+1, (i+len(text))//2+1): \n#                 if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])\n        \n#         return len(ans)\nfrom collections import defaultdict, deque\nclass Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        if all(x==text[0] for x in text):\n            # handle worst case seperately\n            return len(text)//2\n        \n        res = set()\n        character_locations = defaultdict(lambda:deque())\n        for i, c in enumerate(text):\n            for j in character_locations[c]:\n                if i + (i - j) > len(text): break\n                    \n                # Use startswith to improve result slightly                    \n                if text.startswith(text[i:i+i-j], j):\n                    res.add(text[j:i+i-j])\n                    \n            character_locations[c].appendleft(i)\n            \n        return len(res)", "from collections import defaultdict, deque\nclass Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        if all(x==text[0] for x in text):\n            # handle worst case seperately\n            return len(text)//2\n        \n        res = set()\n        character_locations = defaultdict(lambda:deque())\n        for i, c in enumerate(text):\n            for j in character_locations[c]:\n                if i + (i - j) > len(text): break\n                    \n                # Use startswith to improve result slightly                    \n                if text.startswith(text[i:i+i-j], j):\n                    res.add(text[j:i+i-j])\n                    \n            character_locations[c].appendleft(i)\n            \n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        ans = set()\n        \n        for i in range(len(text)-1): \n            for j in range(i+1, (i+len(text))//2+1): \n                if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])\n        \n        return len(ans)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        \n        seen = set()\n        \n        count = 0\n        \n        for i in range(len(text)-1):\n            for j in range(i, len(text), 1):\n                # h = j//2\n                # l = h - i\n                \n                l=(j-i+1)//2\n                h=l+i\n                \n                # print(text[i:h], text[h:h+l], i, j)\n                if l<1 or text[i:h+l] in seen: continue\n                \n                if text[i:h] == text[h:h+l]:\n                    count += 1\n                    # print( '**', text[i:h+l])\n                    seen.add(text[i:h+l])\n                    \n                    \n        return count\n    \n    \n#     2 7\n    \n#     l=(j-i+1)//2\n#     h=l//2\n    \n    \n#     0 8\n    \n#     0:4 4:4+(8-0)//2\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        \n        seen = set()        \n        count = 0\n        \n        for i in range(len(text)-1):\n            for j in range(i, len(text), 1):\n                l=(j-i+1)//2\n                h=l+i\n                t = text[i:h+l]\n                \n                # print(text[i:h], text[h:h+l], i, j)\n                if l<1 or t in seen: continue\n                \n                if t[:l] == t[l:]:\n                    count += 1\n                    # print( '**', text[i:h+l])\n                    seen.add(t)\n                    \n                    \n        return count\n\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        def pos (s):\n            \n            n = len (s)\n            if n%2 != 0:\n                return False\n            \n            for i in range (n//2):\n                if s[i] != s[i+(n//2)]:\n                    return False\n                \n            return True\n        \n        res = set()\n        for i in range (len(text)-1):\n            for j in range (i+1, len(text), 2):\n                m = i + ((j-i+1)//2)\n                if hash (text[i:m]) == hash (text[m:j+1]):\n                    res.add (text[i:m])\n                    \n        return len(res)", "class Solution:\n    \n    def distinctEchoSubstrings2(self, text):\n        base = 29\n        mod = 10**9 + 7\n        \n        aset = set()\n        n = len(text)\n        \n        thash = [0] * (n+1) # thash[i] is the hash value for text[0..i-1] , \u4ecetext[0]\u5230text[i-1]\u90fd\u662f\u5305\u62ec\u7684\uff01\n        tpow = [0] * (n+1) # tpow[i] = base ^ i\n        tpow[0] = 1\n        \n        def getHash(l, r):\n            return (thash[r] - thash[l]*tpow[r-l] % mod + mod) % mod # \u5feb\u901f\u83b7\u53d6\u4e00\u4e2a\u533a\u95f4\u7684hash! \u8fd9\u4e2a\u7406\u89e3\u8d77\u6765\u6709\u96be\u5ea6\uff01\n            #       \u5168\u4f530..r    0..l, \u5e42\u7684\u5deer-l\n        \n        for i in range(1, n+1):\n            #thash[i] = (thash[i-1] * base + ord(text[i-1])-ord('a')) % mod # something is wrong if we use ord(text[i-1]) - ord('a')\n            thash[i] = (thash[i-1] * base + ord(text[i-1])) % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff0c\u8fd9\u4e2a\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n            tpow[i] = tpow[i-1] * base % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff01\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n        \n        for alen in range(1, n//2+1): # abab case? \u800c\u4e14\u4ee3\u7801\u5e76\u4e0d\u76f4\u89c2\u7684\u611f\u89c9\uff01\n            l = 0\n            r = alen\n            counter = 0\n            while l < n - alen:\n                if text[l] == text[r]:\n                    counter += 1\n                else:\n                    counter = 0\n                \n                if counter == alen:\n                    aset.add(getHash(l-alen+1, l+1))\n                    counter -= 1\n                l += 1\n                r += 1\n        return len(aset)\n        '''public int distinctEchoSubstrings(String text) {\n\\t\\tSet<Long> set = new HashSet<>();\n\\t\\tint n = text.length();\n\\t\\tpreprocess(n, text);\n\n\\t\\tfor (int len = 1; len <= n / 2; len++) {\n\\t\\t\\tfor (int l = 0, r = len, counter = 0; l < n - len; l++, r++) {\n\\t\\t\\t\\tif (text.charAt(l) == text.charAt(r)) {\n\\t\\t\\t\\t\\tcounter++;\n\\t\\t\\t\\t} else {\n\\t\\t\\t\\t\\tcounter = 0;\n\\t\\t\\t\\t}\n                \n                // \u8fd9\u4e2a\u64cd\u4f5c\u53ef\u4ee5\u52a0\u901f\uff1f\uff01\u5e76\u4e0d\u662f\u6240\u6709\u7684\u90fd\u662f\u76f4\u63a5call getHash\u7684\uff01\n\\t\\t\\t\\tif (counter == len) {\n\\t\\t\\t\\t\\tset.add(getHash(l - len + 1, l + 1));\n\\t\\t\\t\\t\\tcounter--;\n\\t\\t\\t\\t}\n\\t\\t\\t}\n\\t\\t}\n\n\\t\\treturn set.size();\n\\t}'''\n        \n    def distinctEchoSubstrings(self, text):\n        base = 29\n        mod = 10**9 + 7\n        aset = set()\n        n = len(text)\n        \n        thash = [0] * (n+1)\n        tpow = [0] * (n+1)\n        tpow[0] = 1\n        \n        def getHash(l, r):\n            return (thash[r] - thash[l]*tpow[r-l] % mod + mod) % mod\n        for i in range(1, n+1):\n            thash[i] = (thash[i-1] * base + ord(text[i-1])) % mod\n            tpow[i] = tpow[i-1]*base % mod\n        \n        for i in range(n):\n            for alen in range(2, n-i+1, 2): # i=n-1 then alen=1 is okay, i=0 then alen=n is okay; which means that i+alen=n! so alen = n - i is the upper bound\n                mid = i + alen//2\n                hash1 = getHash(i, mid)\n                hash2 = getHash(mid, i+alen)\n                if hash1 == hash2:\n                    aset.add(hash1)\n        return len(aset)\n                \n\n    \n    def distinctEchoSubstrings1(self, text: str) -> int:\n        base = 29\n        mod = 10**9 + 7\n        \n        aset = set()\n        n = len(text)\n        \n        thash = [0] * (n+1) # thash[i] is the hash value for text[0..i-1] , \u4ecetext[0]\u5230text[i-1]\u90fd\u662f\u5305\u62ec\u7684\uff01\n        tpow = [0] * (n+1) # tpow[i] = base ^ i\n        tpow[0] = 1\n        \n        def getHash(l, r):\n            return (thash[r] - thash[l]*tpow[r-l] % mod + mod) % mod # \u5feb\u901f\u83b7\u53d6\u4e00\u4e2a\u533a\u95f4\u7684hash! \u8fd9\u4e2a\u7406\u89e3\u8d77\u6765\u6709\u96be\u5ea6\uff01\n            #       \u5168\u4f530..r    0..l, \u5e42\u7684\u5deer-l\n        \n        for i in range(1, n+1):\n            #thash[i] = (thash[i-1] * base + ord(text[i-1])-ord('a')) % mod # something is wrong if we use ord(text[i-1]) - ord('a')\n            thash[i] = (thash[i-1] * base + ord(text[i-1])) % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff0c\u8fd9\u4e2a\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n            tpow[i] = tpow[i-1] * base % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff01\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n            \n        # \u7406\u89e3\u4e00\u4e0b\uff1a\n        # abcd -> \n        # thash[0] = 0\n        # thash[1] = (0*29 + ord('a')) % mod = ord('a') % mod\n        # thash[2] = [ ord('a')*29 + ord('b') ] % mod\n        # thash[3] = [ ord('a')*29*29 + ord('b') * 29 + ord('c')] % mod\n        # thash[4] = [ ord('a')*29*29*29 + ord('b') * 29*29 + ord('c')*29 + ord('d')] % mod\n        \n        # tpow[1] = 1*29 % mod = 29 % mod\n        # tpow[2] = 29*29 % mod\n        # tpow[3] = 29*29*29 % mod\n        # tpow[4] = 29*29*29*29 % mod\n        \n        # abab \u7684\u65f6\u5019\n        # thash[1] = [ ord('a') ] % mod\n        # thash[2] = [ ord('a')*29 + ord('b') ] % mod\n        # thash[3] = [ ord('a')*29*29 + ord('b') * 29 + ord('a')] % mod\n        # thash[4] = [ ord('a')*29*29*29 + ord('b') * 29*29 + ord('a')*29 + ord('b')] % mod\n        # tpow[4] = 29*29*29*29 % mod\n        \n        # i=0, alen=4 -> abab\n        # mid=2\n        # so, it is: \n        # getHash(0, 2) -> (ord('a')*29 + ord('b') - 0*tpow[2] + mod) % mod \n        #               -> (ord('a')*29 + ord('b') + mod) % mod\n        # getHash(2, 4) -> (ord('a')*29*29*29 + ord('b') * 29*29 + ord('a')*29 + ord('b') - (ord('a')*29 + ord('b'))*29*29 + mod) % mod\n        #               -> (ord('a')*29 + ord('b') + mod) % mod\n        \n        \n        for i in range(n):\n            for alen in range(2, n-i+1, 2): # \u904d\u5386\u6240\u6709\u957f\u5ea6\u4e3a\u5076\u6570\u7684\u5b50\u4e32\uff08\u4e2d\u95f4\u5207\u5f00\uff0c\u7136\u540e\u6bd4\u8f83\u5de6\u53f3\uff09\n                mid = i + alen//2\n                hash1 = getHash(i, mid)\n                hash2 = getHash(mid, i+alen)\n                if hash1 == hash2: # problem, even hash1 == hash2, not necessary mean that text[i,mid] = text[mid, i+alen]!\n                    aset.add(hash1)\n        return len(aset)\n        \n        \n        '''\n        class Solution {\n        long BASE = 29L, MOD = 1000000007L;\n        public int distinctEchoSubstrings(String str) {\n            HashSet<Long> set = new HashSet<>();\n            int n = str.length();\n            long[] hash = new long[n + 1]; // hash[i] is hash value from str[0..i]\n            long[] pow = new long[n + 1]; // pow[i] = BASE^i\n            pow[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                hash[i] = (hash[i - 1] * BASE + str.charAt(i - 1)) % MOD;\n                pow[i] = pow[i - 1] * BASE % MOD;\n            }\n            for (int i = 0; i < n; i++) {\n                for (int len = 2; i + len <= n; len += 2) {\n                    int mid = i + len / 2;\n                    long hash1 = getHash(i, mid, hash, pow);\n                    long hash2 = getHash(mid, i + len, hash, pow);\n                    if (hash1 == hash2) set.add(hash1);\n                }\n            }\n            return set.size();\n        }\n\n        long getHash(int l, int r, long[] hash, long[] pow) {\n            return (hash[r] - hash[l] * pow[r - l] % MOD + MOD) % MOD;\n        }\n    }\n    '''", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        res = set()\n        n = len(text)\n        def check(s):\n            l = len(s)\n            if l % 2 == 0 and s[:l//2] == s[l//2:]:\n                return True\n            return False\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if check(text[i:j]):\n                    res.add(text[i:j])\n        #print(res)\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        # MOD = 10**9+7\n        MOD = 2000000011\n        textlen = len(text)\n        half = textlen//2\n        f = [[0]*textlen for i in range(textlen)]\n        HASH = {}\n        for l in range(1,half+1):\n            HASH[l] = set()\n            for i in range(textlen-l+1):\n                if l == 1:\n                    f[i][i+l-1] = ord(text[i])-97\n                else:\n                    f[i][i+l-1] = (f[i][i+l-2]*26+ord(text[i+l-1])-97)%MOD\n                HASH[l].add(f[i][i+l-1])\n        a = half+1 if half%2 == 1 else half+2\n        for l in range(a,half*2+1,2):\n            HASH[l] = set()\n            for i in range(textlen-l+1):\n                f[i][i+l-1]=(f[i][i+l-3]*676+(ord(text[i+l-2])-97)*26+ord(text[i+l-1])-97)%MOD\n                HASH[l].add(f[i][i+l-1])\n        count = 0\n        # print(HASH)\n        # print(f)\n        tmp = 1\n        for l in range(1,half+1):\n            tmp = tmp*26%MOD\n            for v in HASH[l]:\n                if v*(tmp+1)%MOD in HASH[2*l]:\n                    count += 1\n        return count\n                \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        echos = set()\n        def find_echos(suffix):\n            n = len(suffix)\n            z = [0] * n\n            l, r = 0, 0\n            for i in range(1, n):\n                if r >= i:\n                    z[i] = min(r - i + 1, z[i - l])\n                while i + z[i] < n and suffix[i + z[i]] == suffix[z[i]]:\n                    z[i] += 1\n                if i + z[i] - 1 > r:\n                    l, r = i, i + z[i] - 1\n            for half in range(1, 1 + (n // 2)):\n                if z[half] >= half: echos.add(suffix[:2*half])\n        \n        for i in range(len(text) - 1):\n            find_echos(text[i:])\n            \n        return len(echos)\n        \n'''\n\naaaaaaaaaa\n2 + 4 + 6 + \n\n\nfor suffix pairs\ns[i:] s[j:] longest common prefix\n\n\nstore suffixes in a trie\n\n..abcdabceef\n\n\nabc..abc..\n\n'''", "class Solution:\n    def checkValid(self, checkString):\n        l = len(checkString)\n        if l % 2 != 0 or l == 0:\n            return False\n        \n        if checkString[:l//2] != checkString[l//2:]:\n            return False\n        return True\n    \n    def distinctEchoSubstrings(self, text: str) -> int:\n        l = len(text)\n        dic = {}\n        if l == 0:\n            return 0\n        for start in range(l-1):    \n            for end in range(l, start, -1):  \n                diff = end - start\n                left = text[start:diff//2 + start]\n                right = text[diff//2 + start:end]\n                if diff > 0 and (diff %2) == 0 and left == right:\n                    dic[text[start:end]] = 1              \n        return len(list(dic.keys()))", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        mod = 1_000_000_007\n        hashed = {}\n        for i in range(len(text)):\n            sm = 0\n            for j in range(i, len(text)):\n                sm = (sm*128 + ord(text[j]))%mod\n                hashed[(i, j)] = sm\n        \n        ans = 0\n        st = {}\n        for i in range(len(text)):\n            for j in range(i+1, len(text), 2):\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\n                    if hashed[(i, j)] not in st:\n                        ans += 1\n                        st[hashed[(i,j)]] = 1\n        return ans\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        mod = 1_000_000_007\n        # Dict for storing hashes for all substrings\n        hashed = {}\n        for i in range(len(text)):\n            sm = 0\n            for j in range(i, len(text)):\n                sm = (sm*128 + ord(text[j]))%mod\n                hashed[(i, j)] = sm\n        \n        ans = 0\n        st = {}\n        for i in range(len(text)):\n            for j in range(i+1, len(text), 2):\n                # For each even length substring check if hash of first half\n                # matches the hash of second half\n                # Also check if the full string already exists as stored map\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\n                    if hashed[(i, j)] not in st:\n                        ans += 1\n                        st[hashed[(i,j)]] = 1\n        return ans", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        N = len(text)\n        s = set()\n \n        for offset in range(1, N // 2 + 1):\n            K = 0\n            for j in range(N - offset):\n                if text[j] == text[j+offset]:\n                    K += 1\n                else:\n                    K = 0\n                if K >= offset:\n                    s.add(text[j-offset+1:j+offset+1])\n        return len(s)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        mod = 1_000_000_007\n        \n        hashed = {}\n        for i in range(len(text)):\n            sm = 0\n            for j in range(i, len(text)):\n                sm = (sm*128 + ord(text[j]))%mod\n                hashed[(i, j)] = sm\n        \n        ans = 0\n        st = {}\n        for i in range(len(text)):\n            for j in range(i+1, len(text), 2):\n                if hashed[(i, i-1+(j + 1 - i)//2)] == hashed[(i+(j + 1 - i)//2, j)]:\n                    if hashed[(i, j)] not in st:\n                        ans += 1\n                        st[hashed[(i,j)]] = 1\n        return ans", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        #for a in range(len(text)-1):\n        #    for b in range(1, (len(text)-a)//2+1):\n        #        print(text[a:a+b], text[a+b:a+2*b])\n        #        if text[a:a+b]==text[a+b:a+2*b]:\n        #            print('GOT ONE')\n        return len({text[a:a+b] for a in range(len(text)-1) for b in range(1, (len(text)-a)//2+1) if text[a:a+b]==text[a+b:a+2*b]})\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        if len(set(text)) == 1: return len(text)//2 # 1\n    \n        presum = [0] # 2\n        for char in text:\n            presum.append(presum[-1] + ord(char))\n    \n        res = set()\n        for w in range(1,(2 + len(text)) // 2):\n            for i in range(len(text) + 1 - 2*w):\n                if presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\n                    if text[i:i+w] == text[i+w:i+2*w]: # 3\n                        res.add(text[i:i+w])\n    \n        return len(res)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        if len(set(text)) == 1: return len(text)//2 # 1\n    \n        presum = [0] # 2\n        for char in text:\n            presum.append(presum[-1] + ord(char))\n    \n        res = set()\n        for w in range(1, len(text) // 2 + 1):\n            for i in range(len(text) + 1 - 2*w):\n                # if presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\n                  if text[i:i+w] == text[i+w:i+2*w]: # 3\n                        res.add(text[i:i+w])\n    \n        return len(res)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        res = set()\n        for i in range(n):\n            for j in range(i):\n                if text[i]==text[j] and text.startswith(text[j:i], i):\n                        res.add(text[j:i])\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        ansSet = set()\n        for i in range(len(text)):\n            for j in range(i+1, (i+1+len(text)+1)//2):\n                if text[i : j] == text[j : 2*j-i]:\n                    ansSet.add(text[i : 2*j-i])\n        return len(ansSet)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        N = len(text)\n        BASE = 27\n        MOD = 1000000007\n        s = set()\n        hoffset = 1\n        tord = [ord(x) - ord('a') + 1 for x in text]\n \n        for offset in range(1, N // 2 + 1):\n            hoffset = (hoffset * BASE) % MOD\n            K = 0\n            h = 0\n            for j in range(N - offset):\n                if text[j] == text[j+offset]:\n                    K += 1\n                    h = (h * BASE + tord[j+offset]) % MOD\n                else:\n                    K = 0\n                    h = 0\n \n                if K > offset:\n                    h = (((h - hoffset * tord[j+offset]) % MOD) + MOD) % MOD\n                    K -= 1\n \n                if K == offset:\n                    s.add(h)\n        return len(s)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        # subStrCounter = Counter()\n        # subStrCounter[1] = text[0]\n        # l = 0\n        # r = 1\n        ans = 0\n        visited = set()\n        textLen = len(text)\n        for i in range(textLen-1):\n            for j in range(0, min(i+1, textLen-i-1)):\n                if text[i-j:i+1] == text[i+1:i+j+2]:\n                    if text[i-j:i+1] not in visited:\n                        visited.add(text[i-j:i+1])\n                        ans += 1\n                # if text[i-j] == text[i+j+1]:\n                #     if text[i+1: i+j+2] not in visited:\n                #         visited.add(text[i+1: i+j+2])\n                #         ans += 1\n                # else:\n                #     break\n        return ans", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        if n <= 1:\n            return 0\n        \n        res = set()\n        for i in range(n - 1):\n            for j in range(min(i + 1, n - i - 1)):\n                if text[(i-j):(i+1)] == text[(i+1):(i+j+2)]:\n                    res.add(text[(i-j):(i+j+2)])\n        #print(res)\n        \n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        res = set()\n        for length in range(1, 1 + len(text)//2):\n            count = 0\n            l, r = 0, length\n            while r < len(text):\n                if text[l] == text[r]:\n                    count += 1\n                else:\n                    count = 0\n                if count == length:\n                    res.add(text[l-length+1: l+1])\n                    count -= 1\n                l, r = l+1, r+1\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, s):\n        n = len(s)\n        s += '.'\n        some_string = set()\n        for k in range(1, n//2+1):\n            same = sum(c == d for c, d in zip(s, s[k:k+k]))\n            for i in range(n - 2*k + 1):\n                if same == k:\n                    some_string.add(s[i:i+k])\n                same += (s[i+k] == s[i+k+k]) - (s[i] == s[i+k])\n        return len(some_string)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        \n        s = set()\n        res = 0\n        for i in range(0, len(text), 1):\n            for j in range(i + 1, len(text), 2):\n                mid = (i + j - 1) // 2\n                t1 = text[i:mid+1]\n                t2 = text[mid+1:j+1]\n                # print(i, j, mid, t1, t2)\n                \n                if t1 == t2 and t1 not in s:\n                    s.add(text[i:mid+1])\n                    res += 1                \n                    \n        return len(s)\n        \n        \n        n=len(s)\n        dp=[0 for i in range(n)]\n        \n        dp[0]=ord(s[0])-ord('a')\n        \n        pw=[0]*(n+1)\n        \n        pw[0]=1\n        \n        curr=26\n        \n        for i in range(1,n):\n            dp[i]=dp[i-1]+curr*(ord(s[i])-ord('a'))\n            pw[i]=curr\n            curr=curr*26\n            \n        pw[-1]=curr\n        \n        #print(dp)\n        \n        st=set()\n        \n        for i in range(n):\n            for j in range(i+1,n,2):\n                \n                mid=(j+i)//2\n                \n                if i!=0:\n                    x1=dp[mid]-dp[i-1]\n                else:\n                    x1=dp[mid]\n                \n                x2=dp[j]-dp[mid]\n                \n                #print(x1,x2,s[i:mid+1],s[mid+1:j+1])\n                \n                if x2==x1*(pw[mid-i+1]):\n                    if s[i:mid+1]==s[mid+1:j+1]:\n                        st.add(s[i:j+1])\n                        #print(st)\n        return len(st) ", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        s =text\n        n = len(s)\n        s += '.'\n        some_string = set()\n        for k in range(1, n//2+1):\n            same = sum(c == d for c, d in zip(s, s[k:k+k]))\n            for i in range(n - 2*k + 1):\n                if same == k:\n                    some_string.add(s[i:i+k])\n                same += (s[i+k] == s[i+k+k]) - (s[i] == s[i+k])\n        return len(some_string)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        text += '.'\n        seen = set()\n        for k in range(1, n // 2 + 1):\n            same = sum(c == d for c, d in zip(text, text[k: k + k]))\n            for i in range(n - 2 * k + 1):\n                if same == k:\n                    seen.add(text[i: i + k])\n                same += (text[i + k] == text[i + k * 2]) - (text[i] == text[i + k])\n        return len(seen)\n        # n = len(text)\n        # seen = set()\n        # for i in range(n):\n        #     for j in range(i + 1, n + 1):\n        #         if not (j - i) % 2 and text[i: i + (j - i) // 2] == text[i + (j - i) // 2: j]:\n        #             seen.add(text[i: j])\n        # return len(seen)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n\n        if len(set(text)) == 1: return len(text)//2 # 1\n\n        presum = [0] # 2\n        for char in text:\n            presum.append(presum[-1] + ord(char))\n\n        res = set()\n        for w in range(1,(2 + len(text)) // 2):\n            for i in range(len(text) + 1 - 2*w):\n                j = i + w\n                if presum[j] - presum[i] == presum[j+w] - presum[j]: # 2.1\n                    if text[i:j] == text[j:j+w]: # 3\n                        res.add(text[i:j])\n\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        # stefan++\n        N = len(text)\n        res = set()\n        text += '.'\n        # k is the length of substring\n        for k in range(1, N//2 + 1):\n            same = sum(a == b for a, b in zip(text, text[k:k+k]))\n            for i in range(N - 2*k + 1):\n                if same == k:\n                    res.add(text[i:i+k])\n                same += (text[i+k] == text[i+ 2*k]) - (text[i] == text[i + k])\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        text+='*'\n        valid = set()\n        for k in range(1, n//2 +1):\n            same = sum(c==d for c,d in zip(text, text[k:k+k]))\n            for i in range(n-2*k+1):\n                if same==k:\n                    valid.add(text[i:i+k])\n                same+= (text[i+k]==text[i+k+k]) -(text[i]==text[i+k])\n        return len(valid)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        # not the rolling hash method\n        # optimize\n        resultset = set()\n        \n        for i in range(len(text)):\n            for j in range(i+1, len(text)):\n                \n                if text[i] == text[j]:\n                    #compare two sliced string\n                    str1 = text[i:j]\n                    str2 = text[j: j+(j-i)]\n                                       \n                    if str1 == str2:\n                        resultset.add(text[i: j+(j-i)])\n\n        return len(resultset)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        L = len(text)\n        \n        count = 0\n        S = set()\n        \n        for i in range(L):\n            for j in range(i+1, L):\n                \n                if j - i <= L - j:\n                    \n                    #print(text[i:j])\n                    #print(text[j:2*j-i])\n                    \n                    if text[i:j] == text[j:2*j-i]:\n                        #print('here')\n                        \n                        S.add(text[i:j])\n                        \n                        #if text[i:j] not in D:\n                        #    D[text[i:j]] = 1\n                        #    count += 1\n                    \n        return len(S)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        satisfies = set()\n        for i in range(2,len(text)+2,2):\n            for j in range(0,len(text)-i+1):\n                cand = text[j:j+i]\n                if cand[:len(cand)//2] == cand[len(cand)//2:]:\n                    satisfies.add(cand)\n        return len(satisfies)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        res = set()\n        n = len(text)\n        for sz in range(1,int(n/2)+1,1):\n            r = sz\n            cur = 0\n            for l in range(0,n-sz):\n                if text[l] == text[r]:\n                    cur += 1\n                else:\n                    cur = 0\n                if cur == sz:\n                    #print('size: ' + str(sz) + ' L: ' + str(l) + text[l-sz:l])\n                    res.add(text[l-sz+1:l+1])\n                    cur -= 1\n                r += 1\n        return len(res)\n", "class Solution:\n  def distinctEchoSubstrings(self, text: str) -> int:\n    # O(N^2) check all substr, O(1) each check with rolling count of equality\n    # s: text + '#' in case length of text is odd and out of index error\n    s, n = text + '#', len(text)\n    echo = set()\n    for k in range(1, n // 2 + 1):\n      # init\n      same = sum(x == y for x, y in zip(s[:k], s[k:(k + k)]))\n      for i in range(n - 2 * k + 1):\n        if same == k:\n          echo.add(s[i:(i + 2 * k)])\n        # rolling the count of equality\n        same += (s[i + k] == s[i + k + k]) - (s[i] == s[i + k])\n    return len(echo)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        N = len(text)\n        BASE = 27\n        MOD = 1000000007\n        s = set()\n        hoffset = 1\n        tord = [ord(x) - ord('a') + 1 for x in text]\n \n        for offset in range(1, N // 2 + 1):\n            hoffset = (hoffset * BASE) % MOD\n            K = 0\n            h = 0\n            for j in range(N - offset):\n                if text[j] == text[j+offset]:\n                    K += 1\n                    h = (h * BASE + tord[j+offset]) % MOD\n                else:\n                    K = 0\n                    h = 0\n \n                if K > offset:\n                    h = (((h - hoffset * tord[j+offset]) % MOD) + MOD) % MOD\n                    K -= 1\n \n                if K == offset:\n                    s.add(h)\n        return len(s)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n=len(text)\n        res=set()\n        for k in range(1,n//2+1):\n            for i in range(n-k+1):\n                if text[i:i+k]==text[i+k:i+2*k]:\n                    res.add(text[i:i+2*k])\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        result = set()\n        size = len(text)\n        for i in range(size):\n            for j in range(i+1, size):\n                if text[i:j] == text[j:j+(j-i)]:\n                    result.add(text[i:j])\n                \n        return len(result)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        res = set()\n        n = len(text)\n        for sz in range(1,int(n/2)+1):\n            r = sz\n            cur = 0\n            for l in range(0,n-sz):\n                if text[l] == text[r]:\n                    cur += 1\n                else:\n                    cur = 0\n                if cur == sz:\n                    #print(text[l-sz+1:l+1])\n                    res.add(text[l-sz+1:l+1])\n                    cur -= 1\n                r += 1\n        return len(res)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        result = set()\n        size = len(text)\n        for i in range(size):\n            for j in range(i+1, size):\n                if text[i:j] == text[j:j+(j-i)]:\n                    result.add(text[i:j])\n            \n        print(result)\n        return len(result)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        distinct_subs = set()\n        for i in range(2, len(text)+1, 2):\n            for j in range(len(text)+1-i):\n                sub_string = text[j:j+i]\n                if sub_string[:int(i/2)] == sub_string[int(i/2):]:\n                    if sub_string not in distinct_subs:\n                        distinct_subs.add(sub_string)\n        \n        return len(distinct_subs)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n, size, res = len(text), 1, set()\n        while size * 2 <= n:\n            count = 0\n            for i in range(size):\n                if text[i] == text[i + size]:\n                    count += 1\n            for j in range(n - 2 * size + 1):\n                if count == size:\n                    res.add(text[j : j + 2 * size])\n                if text[j] == text[j + size]:\n                    count -= 1\n                if j + 2 * size < n and text[j + size] == text[j + 2 * size]:\n                    count += 1\n            size += 1\n        \n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        L = len(text)\n        res = set()\n        for i in range(1, L):\n            for j in range(max(0, 2*i-L), i):\n                if text[j:i] == text[i:2*i-j]:\n                    res.add(text[j:i])\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        some_strings = set()\n        for i in range(len(text)):\n            for j in range (i):\n                if text.startswith(text[j:i],i):\n                    some_strings.add(text[j:i])\n        return len(some_strings)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        \n        d = set()\n        c = 0\n        lim = len(text)\n        \n        for i in range(0,lim,2):\n            for j in range(0,lim-i):\n                val = text[j:j+i]\n                if val not in d:\n                    d.add(val)\n                    if 2*val[:i//2]==val:c+=1\n        if 2*text[:lim//2]==text:c+=1        \n        return c-1", "class Solution:\n    def distinctEchoSubstrings3(self, text: str) -> int:\n        if len(set(text)) == 1: return len(text)//2 # 1\n\n        presum = [0] # 2\n        for char in text:\n            presum.append(presum[-1] + ord(char))\n        print(presum)\n\n        res = set()\n        for w in range(1,(2 + len(text)) // 2):\n            for i in range(len(text) + 1 - 2*w):\n                if presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\n                    if text[i:i+w] == text[i+w:i+2*w]: # 3\n                        res.add(text[i:i+w])\n\n        return len(res)\n\n    def distinctEchoSubstrings(self, text: str) -> int:\n        result = set()\n        size = len(text)\n        presum = [0] * size * 2\n        \n        for i in range(size):        \n            presum[i] = presum[i-1] + ord(text[i])\n        for i in range(size):\n            for j in range(i+1, size):\n                if presum[j-1]-presum[i] == presum[j+(j-i)-1]-presum[j]:\n                    if text[i:j] == text[j:j+(j-i)]:\n                        result.add(text[i:j])\n            \n        print(result)\n        return len(result)", "class Solution:\n  def distinctEchoSubstrings(self, s: str) -> int:\n    n, seen = len(s), set()\n    for i in range(n):\n      for j in range(i + 2, n + 1, 2):\n        tmp = s[i:j]\n        l = (j - i) // 2\n        if tmp[:l] == tmp[l:]:\n          seen.add(tmp[:l])\n    \n    return len(seen)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        result = set()\n        size = len(text)\n        presum = [0] * size * 2\n        \n        for i in range(size):        \n            presum[i] = presum[i-1] + ord(text[i])\n        for i in range(size):\n            for j in range(i+1, size):\n                if presum[j-1]-presum[i] == presum[j+(j-i)-1]-presum[j]:\n                    if text[i:j] == text[j:j+(j-i)]:\n                        result.add(text[i:j])\n            \n        print(result)\n        return len(result)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        l = len(text)\n        dic = {}\n        if l == 0:\n            return 0\n        for start in range(l-1):    \n            for end in range(l, start, -1):  \n                diff = end - start\n                if (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\n                    dic[text[start:end]] = 1              \n        return len(list(dic.keys()))\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        l = len(text)\n        dic = {}\n        if l == 0:\n            return 0\n        for start in range(l-1):    \n            for end in range(l, start, -1):  \n                diff = end - start\n                if (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\n                    dic[text[start:end]] = 1              \n        return len(list(dic.keys()))", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        seen = set()\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if not (j - i) % 2 and text[i: i + (j - i) // 2] == text[i + (j - i) // 2: j]:\n                    seen.add(text[i: j])\n        return len(seen)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        s=set()\n        for j in range(len(text)):\n            for i in range(j):\n                #print(text[i:j])\n                if text[i:j]==text[j:j+j-i]:\n                    s.add(text[i:j])\n                #print(s)\n        return len(s)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        res = set()                                           # keep distinct\n        for i in range(len(text)):                            # i: start index\n            for l in range(1,len(text)-i):                    # l: length of the repeated string\n                if text[i] == text[i+l]:                      # only check if the first character matches\n                    k = 1                                     # k: repeated times\n                    while i+(k+1)*l <= len(text):\n                        if text[i:i+k*l] == text[i+k*l:i+(k+1)*l]:\n                            res.add(text[i:i+(k+1)*l])\n                            k *= 2                            # double the count and continue checking\n                        else:\n                            break\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n\n        if len(set(text)) == 1: return len(text)//2 # 1\n\n        presum = [0] # 2\n        for char in text:\n            presum.append(presum[-1] + ord(char))\n\n        res = set()\n        for w in range(1,(2 + len(text)) // 2):\n            for i in range(len(text) + 1 - 2*w):\n                if presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\n                    if text[i:i+w] == text[i+w:i+2*w]: # 3\n                        res.add(text[i:i+w])\n\n        return len(res)", "class Solution:\n    \n    def distinctEchoSubstrings(self, text: str) -> int:\n        l = len(text)\n        dic = {}\n        if l == 0:\n            return 0\n        for start in range(l-1):    \n            for end in range(l, start, -1):  \n                diff = end - start\n                if diff > 0 and (diff %2) == 0 and text[start:diff//2 + start] == text[diff//2 + start:end]:\n                    dic[text[start:end]] = 1              \n        return len(list(dic.keys()))", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n      result = set()\n      for j in range(3, len(text) + 1):\n        for i in range(0, j):\n          if (j - i) & 1 > 0: \n            continue\n          if self.check(text[i: j]):\n            result.add(text[i: j])\n      return len(result)\n    \n    def check(self, text: str) -> bool:\n      mid = len(text) >> 1\n      return text[:mid] == text[mid:]\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        prefix_rolling_hash = [0 for _ in range(len(text) + 1)]\n        for i in range(len(text)):\n            prefix_rolling_hash[i + 1] = ord(text[i]) + prefix_rolling_hash[i]\n        res = set()\n        for i in range(len(text)):\n            for j in range(i):\n                if (i - j + 1) % 2 == 0:\n                    if prefix_rolling_hash[j + ((i - j + 1) // 2)] - prefix_rolling_hash[j] == prefix_rolling_hash[i + 1] - prefix_rolling_hash[j + ((i - j + 1) // 2)]:\n                        x = text[j: (j + (i - j + 1) // 2)]\n                        if x == text[(j + (i - j + 1) // 2): i + 1]:\n                            res.add(x)\n        return len(res)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        st = set()\n        for s in range(1, 1 + len(text) // 2):\n            for start in range(len(text)):\n                l = text[start:start+s]\n                r = text[start+s:start+s+s]\n                if l == r and (l+r) not in st and len(l) != 0:\n                    st.add(l+r)\n        return len(st)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        ans = set([])\n        for i in range(n):\n            pat = text[i:]\n            lps = [0]*(n-i)\n            j = 1\n            k = 0\n            while j<len(lps):\n                if pat[j]==pat[k]:\n                    k+=1\n                    lps[j]=k\n                    j+=1\n                    d = j-k\n                    if j%d==0 and (j//d)%2==0:\n                        ans.add(pat[:j])\n                else:\n                    if k!=0:\n                        k = lps[k-1]\n                    else:\n                        lps[j]=0\n                        j+=1\n            \n        return len(ans)\n                            \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        subs=set()\n    \n        for i in range(len(text)):\n            for j in range(i+1,len(text)):\n            \n                temp=text[i:j]\n                if text[i:j]==text[j:j+j-i] :\n                    subs.add(text[i:j])\n            \n    #print(subs)\n        return len(subs)", "class Solution:\n    \n    def distinctEchoSubstrings(self, text):\n        base = 29\n        mod = 10**9 + 7\n        \n        aset = set()\n        n = len(text)\n        \n        thash = [0] * (n+1) # thash[i] is the hash value for text[0..i-1] , \u4ecetext[0]\u5230text[i-1]\u90fd\u662f\u5305\u62ec\u7684\uff01\n        tpow = [0] * (n+1) # tpow[i] = base ^ i\n        tpow[0] = 1\n        \n        def getHash(l, r):\n            return (thash[r] - thash[l]*tpow[r-l] % mod + mod) % mod # \u5feb\u901f\u83b7\u53d6\u4e00\u4e2a\u533a\u95f4\u7684hash! \u8fd9\u4e2a\u7406\u89e3\u8d77\u6765\u6709\u96be\u5ea6\uff01\n            #       \u5168\u4f530..r    0..l, \u5e42\u7684\u5deer-l\n        \n        for i in range(1, n+1):\n            #thash[i] = (thash[i-1] * base + ord(text[i-1])-ord('a')) % mod # something is wrong if we use ord(text[i-1]) - ord('a')\n            thash[i] = (thash[i-1] * base + ord(text[i-1])) % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff0c\u8fd9\u4e2a\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n            tpow[i] = tpow[i-1] * base % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff01\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n        \n        for alen in range(1, n//2+1): # abab case?\n            l = 0\n            r = alen\n            counter = 0\n            while l < n - alen:\n                if text[l] == text[r]:\n                    counter += 1\n                else:\n                    counter = 0\n                \n                if counter == alen:\n                    aset.add(getHash(l-alen+1, l+1))\n                    counter -= 1\n                l += 1\n                r += 1\n        return len(aset)\n        '''public int distinctEchoSubstrings(String text) {\n\\t\\tSet<Long> set = new HashSet<>();\n\\t\\tint n = text.length();\n\\t\\tpreprocess(n, text);\n\n\\t\\tfor (int len = 1; len <= n / 2; len++) {\n\\t\\t\\tfor (int l = 0, r = len, counter = 0; l < n - len; l++, r++) {\n\\t\\t\\t\\tif (text.charAt(l) == text.charAt(r)) {\n\\t\\t\\t\\t\\tcounter++;\n\\t\\t\\t\\t} else {\n\\t\\t\\t\\t\\tcounter = 0;\n\\t\\t\\t\\t}\n                \n                // \u8fd9\u4e2a\u64cd\u4f5c\u53ef\u4ee5\u52a0\u901f\uff1f\uff01\u5e76\u4e0d\u662f\u6240\u6709\u7684\u90fd\u662f\u76f4\u63a5call getHash\u7684\uff01\n\\t\\t\\t\\tif (counter == len) {\n\\t\\t\\t\\t\\tset.add(getHash(l - len + 1, l + 1));\n\\t\\t\\t\\t\\tcounter--;\n\\t\\t\\t\\t}\n\\t\\t\\t}\n\\t\\t}\n\n\\t\\treturn set.size();\n\\t}'''\n\n    \n    def distinctEchoSubstrings1(self, text: str) -> int:\n        base = 29\n        mod = 10**9 + 7\n        \n        aset = set()\n        n = len(text)\n        \n        thash = [0] * (n+1) # thash[i] is the hash value for text[0..i-1] , \u4ecetext[0]\u5230text[i-1]\u90fd\u662f\u5305\u62ec\u7684\uff01\n        tpow = [0] * (n+1) # tpow[i] = base ^ i\n        tpow[0] = 1\n        \n        def getHash(l, r):\n            return (thash[r] - thash[l]*tpow[r-l] % mod + mod) % mod # \u5feb\u901f\u83b7\u53d6\u4e00\u4e2a\u533a\u95f4\u7684hash! \u8fd9\u4e2a\u7406\u89e3\u8d77\u6765\u6709\u96be\u5ea6\uff01\n            #       \u5168\u4f530..r    0..l, \u5e42\u7684\u5deer-l\n        \n        for i in range(1, n+1):\n            #thash[i] = (thash[i-1] * base + ord(text[i-1])-ord('a')) % mod # something is wrong if we use ord(text[i-1]) - ord('a')\n            thash[i] = (thash[i-1] * base + ord(text[i-1])) % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff0c\u8fd9\u4e2a\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n            tpow[i] = tpow[i-1] * base % mod # \u7b80\u5355\u7684\u8fdb\u4f4d\u53e0\u52a0\uff01\u8fd8\u7b97\u5bb9\u6613\u8bb0\u4f4f\uff01\n            \n        # \u7406\u89e3\u4e00\u4e0b\uff1a\n        # abcd -> \n        # thash[0] = 0\n        # thash[1] = (0*29 + ord('a')) % mod = ord('a') % mod\n        # thash[2] = [ ord('a')*29 + ord('b') ] % mod\n        # thash[3] = [ ord('a')*29*29 + ord('b') * 29 + ord('c')] % mod\n        # thash[4] = [ ord('a')*29*29*29 + ord('b') * 29*29 + ord('c')*29 + ord('d')] % mod\n        \n        # tpow[1] = 1*29 % mod = 29 % mod\n        # tpow[2] = 29*29 % mod\n        # tpow[3] = 29*29*29 % mod\n        # tpow[4] = 29*29*29*29 % mod\n        \n        # abab \u7684\u65f6\u5019\n        # thash[1] = [ ord('a') ] % mod\n        # thash[2] = [ ord('a')*29 + ord('b') ] % mod\n        # thash[3] = [ ord('a')*29*29 + ord('b') * 29 + ord('a')] % mod\n        # thash[4] = [ ord('a')*29*29*29 + ord('b') * 29*29 + ord('a')*29 + ord('b')] % mod\n        # tpow[4] = 29*29*29*29 % mod\n        \n        # i=0, alen=4 -> abab\n        # mid=2\n        # so, it is: \n        # getHash(0, 2) -> (ord('a')*29 + ord('b') - 0*tpow[2] + mod) % mod \n        #               -> (ord('a')*29 + ord('b') + mod) % mod\n        # getHash(2, 4) -> (ord('a')*29*29*29 + ord('b') * 29*29 + ord('a')*29 + ord('b') - (ord('a')*29 + ord('b'))*29*29 + mod) % mod\n        #               -> (ord('a')*29 + ord('b') + mod) % mod\n        \n        \n        for i in range(n):\n            for alen in range(2, n-i+1, 2): # \u904d\u5386\u6240\u6709\u957f\u5ea6\u4e3a\u5076\u6570\u7684\u5b50\u4e32\uff08\u4e2d\u95f4\u5207\u5f00\uff0c\u7136\u540e\u6bd4\u8f83\u5de6\u53f3\uff09\n                mid = i + alen//2\n                hash1 = getHash(i, mid)\n                hash2 = getHash(mid, i+alen)\n                if hash1 == hash2: # problem, even hash1 == hash2, not necessary mean that text[i,mid] = text[mid, i+alen]!\n                    aset.add(hash1)\n        return len(aset)\n        \n        \n        '''\n        class Solution {\n        long BASE = 29L, MOD = 1000000007L;\n        public int distinctEchoSubstrings(String str) {\n            HashSet<Long> set = new HashSet<>();\n            int n = str.length();\n            long[] hash = new long[n + 1]; // hash[i] is hash value from str[0..i]\n            long[] pow = new long[n + 1]; // pow[i] = BASE^i\n            pow[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                hash[i] = (hash[i - 1] * BASE + str.charAt(i - 1)) % MOD;\n                pow[i] = pow[i - 1] * BASE % MOD;\n            }\n            for (int i = 0; i < n; i++) {\n                for (int len = 2; i + len <= n; len += 2) {\n                    int mid = i + len / 2;\n                    long hash1 = getHash(i, mid, hash, pow);\n                    long hash2 = getHash(mid, i + len, hash, pow);\n                    if (hash1 == hash2) set.add(hash1);\n                }\n            }\n            return set.size();\n        }\n\n        long getHash(int l, int r, long[] hash, long[] pow) {\n            return (hash[r] - hash[l] * pow[r - l] % MOD + MOD) % MOD;\n        }\n    }\n    '''", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        if len(set(text)) == 1: return len(text)//2 # 1\n    \n        presum = [0] # 2\n        for char in text:\n            presum.append(presum[-1] + ord(char))\n    \n        res = set()\n        for w in range(1, len(text) // 2 + 1):\n            for i in range(len(text) + 1 - 2*w):\n                if presum[i+w] - presum[i] == presum[i+2*w] - presum[i+w]: # 2.1\n                    if text[i:i+w] == text[i+w:i+2*w]: # 3\n                        res.add(text[i:i+w])\n    \n        return len(res)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        def check(s):return s[:len(s)//2]==s[len(s)//2:]\n        ret = set()\n        n = len(text)\n        for l in range(2,n+1,2):\n            for start in range(n-l+1):\n                s=text[start:start+l]\n                if check(text[start:start+l]): ret.add(s)\n        # print(ret)\n        return len(ret)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        result = 0\n        string_set = set()\n        n = len(text)\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if (j-i)%2:\n                    continue\n                s0 = text[i:j]\n                if s0 in string_set:\n                    continue\n                # print(text[i:j])\n                string_set.add(s0)\n                s1 = text[i:i+(j-i)//2]\n                s2 = text[i+(j-i)//2:j]\n                if s1==s2:\n                    result += 1\n        return result", "class Solution:\n    def checkSymetric(self, checkString):\n        l = len(checkString)\n        if l % 2 != 0 or l == 0:\n            return False\n        \n        if checkString[:l//2] != checkString[l//2:]:\n            return False\n        return True\n    \n    def distinctEchoSubstrings(self, text: str) -> int:\n        l = len(text)\n        dic = {}\n        for start in range(l):    \n            for end in range(l, start, -1):  \n                if (end - start) %2 == 0:\n                    if (self.checkSymetric(text[start:end])):\n                        dic[text[start:end]] = 1              \n        return len(list(dic.keys()))", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        result = 0\n        string_set = set()\n        n = len(text)\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if (j-i)%2:\n                    continue\n                if text[i:j] in string_set:\n                    continue\n                # print(text[i:j])\n                string_set.add(text[i:j])\n                s1 = text[i:i+(j-i)//2]\n                s2 = text[i+(j-i)//2:j]\n                if s1==s2:\n                    result += 1\n        return result", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n=len(text)\n        ans=set()\n        lens=n\n        for l in range(1,lens+1):\n            for i in range(lens-l+1):\n                j=i+l-1\n                # print(i,j)\n                curr1=text[i:j+1]\n                # print(curr1)\n                curr2=''\n                if(j+l+1<=n):\n                    curr2=text[j+1:j+1+l]\n                if(curr1==curr2):\n                    ans.add(curr1+curr2)\n        return len(ans)\n                \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        res = set()\n        n = len(text)\n        def check(s):\n            l = len(s)\n            if l % 2 == 0 and s[:l//2] == s[l//2:]:\n                return True\n            return False\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if check(text[i:j]):\n                    res.add(text[i:j])\n        #print(res)\n        return len(res)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        \n        subs=set()\n        \n        for i in range(len(text)):\n            for j in range(i+1,len(text)):\n                \n                temp=text[i:j]\n                \n                #print(\\\"\\\\t\\\\t temp:\\\",temp,\\\"\\\\t\\\\t \\\",temp==text.startswith(temp,j))\n                if text[i:j]==text[j:j+j-i] :#text.startswith(text[i:j],j):\n                    subs.add(text[i:j])\n                \n        #print(subs)\n        return len(subs)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        # 1. Use two pointers, start with 2 pointers that are 1 space apart\n        # 2. Then space the pointers 2, 3, 4 up to len(text)//2\n        # 3. Run the pointers along the text and anytime text[i] == text[j]\n        #    expand until i reaches where j started or text[i] != text[j]\n        #\n        #    Optimization, rabin-karp hash the entire text and check if len(i+window)-i == len(j+window) - j\n        \n        if len(set(text)) == 1: return len(text)//2\n        \n        rabin = [0]\n        for char in text:\n            rabin.append(rabin[-1] + ord(char))\n        \n        #print(rabin)\n        res = set()\n        for w in range(1,(2 + len(text)) // 2):\n            i = 0\n            j = w\n            while j <= len(text) - w:\n                if rabin[j] - rabin[i] == rabin[j+w] - rabin[j]:\n                    #print(text[i:j], rabin[j] - rabin[i], rabin[j+w] - rabin[j])\n                    if text[i:j] == text[j:j+w]:\n                        res.add(text[i:j])\n                i += 1\n                j += 1\n        return len(res)", "class Solution:\n    # O(n^3) time, O(n^2) space\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        def is_echo(s):\n            n = len(s)\n            if n % 2 != 0:\n                return False\n            return s[: n // 2] == s[n // 2 :]\n        \n        echo_str_set = set()\n        for i in range(len(text)):\n            for j in range(i, len(text)):\n                substr = text[i : j + 1]\n                if is_echo(substr):\n                    echo_str_set.add(substr)\n        return len(echo_str_set)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        nums = [ord(c) - ord('a') for c in text]\n        \n        def countEcho(L):\n            '''\n            count echo substrings with length L\n            '''\n            \n            a = 26\n            modulus = 2**32\n            \n            h1 = h2 = 0\n            for i in range(L):\n                h1 = (h1*a + nums[i]) % modulus\n                h2 = (h2*a + nums[L+i]) % modulus\n            # print(L, h1, h2)\n            seen = set()\n            ans = 0\n            if h1 == h2:\n                ans += 1\n                seen.add(h1)\n            aL = pow(a, L, modulus)\n            for i in range(1, n - 2*L + 1):\n                h1 = (h1 * a - nums[i-1] * aL + nums[i+L-1]) % modulus\n                h2 = (h2 * a - nums[i+L-1] * aL + nums[i+L*2-1]) % modulus\n                # print(L, h1, h2)\n                if h1 == h2 and h1 not in seen:\n                    ans += 1\n                    seen.add(h1)\n            return ans\n        \n        ans = 0\n        for L in range(1, n//2+1):\n            al = countEcho(L)\n            ans += al\n        return ans", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        variants = [text[x:y] for x, y in itertools.combinations(range(len(text) + 1), r=2) if y - x > 1 and (y - x) % 2 == 0 and (size := (y - x) // 2) > 0 and text[x:x + size] == text[x + size:y]]\n        return len(set(variants))", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n=len(text)\n        ans=set()\n        i=0\n        while i<n:\n            for l in range(2,n+1,2):\n                mid=i+l//2\n                if text[i:mid]==text[mid:i+l]:\n                    ans.add(text[i:mid])\n                l+=2\n            i+=1\n        return len(ans)", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        '''\n        ccbccbcabc\n        Input: text = \\\"abcabcabc\\\"\n        Output: 3\n        Explanation: The 3 substrings are \\\"abcabc\\\", \\\"bcabca\\\" and \\\"cabcab\\\".\n        \n        def EchoLen(i,j): length of echo string xxxi,xxxj\n            if i<0: return 0\n            if i == j: return 0\n            if text[i] == text[j]:\n                res = 1+EchoLen(i-1,-1j)\n            else: \n                res = 0\n        \n        \n        if text[i] == text[j]:\n            dp[i][j] = dp[i-1][j-1]+1\n        else: dp[i][j] = 0\n        \n        \n        '''\n        res = set()\n        dp = [[0 for _ in range(len(text))] for _ in range(len(text))]\n        for i in range(len(text)):\n            for j in range(i+1,len(text)):\n                if i == 0:\n                    if text[i] == text[j]:\n                        dp[i][j] = 1\n                else:\n                    if text[i] == text[j]:\n                        dp[i][j] = 1+dp[i-1][j-1]\n        # print(dp)\n        for i in range(len(text)):\n            for j in range(i+1,len(text)):\n                if (j-i+1)%2==0:\n                    m = (i+j)//2\n                    if dp[m][j]>=(j-m): \n                        # print(i,j,m)\n                        res.add(text[i:m+1])\n        print(res)\n        return len(res)\n                    \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        result = 0\n        seen = set()\n        BASE = 27\n        MOD = 10 ** 9\n        hashs = [0] * (n + 1)\n        pows = [1] * (n + 1)\n        for i in range(n):\n            hashs[i + 1] = (hashs[i] * BASE + ord(text[i]) - 96) % MOD\n            pows[i + 1] = (pows[i] * BASE) % MOD\n            \n        h = lambda i, j: (hashs[j + 1] - (hashs[i] * pows[j - i + 1]) % MOD) % MOD\n        \n        for i in range(n):\n            l = i\n            r = i + 1\n            while r < n:\n                h1 = h(i, l)\n                h2 = h(l + 1, r)\n                if h1 == h2 and h1 not in seen:\n                    result += 1\n                    seen.add(h1)\n                l += 1\n                r += 2\n        return result", "class Solution:\n    def checkSymetric(self, checkString):\n        l = len(checkString)\n        if l % 2 != 0 or l == 0:\n            return False\n        \n        if checkString[:l//2] != checkString[l//2:]:\n            return False\n        return True\n    \n    def distinctEchoSubstrings(self, text: str) -> int:\n        l = len(text)\n        dic = {}\n        for start in range(l):    \n            for end in range(l, start, -1):  \n                if (self.checkSymetric(text[start:end])):\n                    dic[text[start:end]] = 1              \n        return len(list(dic.keys()))", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        st = set()\n        for s in range(1, 1 + len(text) // 2):\n            for start in range(len(text)):\n                l = text[start:start+s]\n                r = text[start+s:start+s+s]\n                if l == r and (l+r) not in st and len(l) != 0:\n                    st.add(l+r)\n        return len(st)\n", "class Solution:\n    def distinctEchoSubstrings(self, s):\n        n = len(s)\n        shash = [0] * (n + 1)\n        spow = [1] * (n + 1)\n        base = 29\n        MOD = 10 ** 9 + 7\n        seen = set()\n        \n        def gethash(i: int, j: int) -> int:\n            return (shash[j] - shash[i - 1] * spow[j - i + 1] % MOD + MOD) % MOD\n        \n        for i in range(1, n + 1):\n            shash[i] = (shash[i - 1] * base + ord(s[i - 1])) % MOD\n            spow[i] = (spow[i - 1] * base) % MOD\n        \n        for i in range(n):\n            for j in range(i + 1, n, 2):\n                mid = (i + j) // 2\n                lhash = gethash(i + 1, mid + 1)\n                rhash = gethash(mid + 2, j + 1)\n                if lhash == rhash:\n                    #print(s[i - 1:j], lhash)\n                    seen.add(lhash)\n        \n        return len(seen)\n    \n    \n    # [0, 108, 3233, 93858, 2721998, 78938041, 289203286, 386895338, 219964826, 378980020, 990420611, 722197624, 943731072, 368200998, 677828983, 657040474, 54173714]\n    \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        out = set()\n        for i in range(len(text)-1):\n            for j in range(i+1,len(text)):\n                if text[i:j]==text[j:2*j -i]:\n                    out.add(text[i:j])\n        return len(out)\n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n        result = 0\n        seen = set()\n        BASE = 27\n        MOD = 10 ** 5\n        hashs = [0] * (n + 1)\n        pows = [1] * (n + 1)\n        for i in range(n):\n            hashs[i + 1] = (hashs[i] * BASE + ord(text[i]) - 96) % MOD\n            pows[i + 1] = (pows[i] * BASE) % MOD\n            \n        h = lambda i, j: (hashs[j + 1] - (hashs[i] * pows[j - i + 1]) % MOD) % MOD\n        \n        for i in range(n):\n            l = i\n            r = i + 1\n            while r < n:\n                h1 = h(i, l)\n                h2 = h(l + 1, r)\n                s = text[i: l + 1]\n                if h1 == h2 and s == text[l + 1: r + 1] and s not in seen:\n                    result += 1\n                    seen.add(s)\n                l += 1\n                r += 2\n        return result", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n\n        MOD = 10**9+7\n        BASE = 256\n        \n        ppow = defaultdict(int)\n        ippow = defaultdict(int)\n        ha = defaultdict(int)\n        vis = defaultdict(bool)\n        \n        \n        ippow[0] = ppow[0] = 1\n        for i in range(n):\n            ha[i] = (ha[i-1] + ord(text[i]) * ppow[i]) % MOD\n            ppow[i+1] = ppow[i] * BASE % MOD\n            ippow[i+1] = pow(ppow[i+1], -1, MOD)\n        \n        def compute(i, j):\n            return (ha[j] - ha[i-1]) * ippow[i] % MOD\n        \n        ret = 0\n        for i in range(n):\n            for j in range(i,n):\n                if j+j-i+1 < n:\n                    c1 = compute(i, j)\n                    if vis[c1]:\n                        continue\n                    u = j+1\n                    v = j+j-i+1\n                    if c1 == compute(u, v) and text[i:j+1] == text[u:v+1]:\n                        vis[c1] = True\n                        ret += 1\n        \n        return ret\n        \n            \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        count = 0\n        visited = {}\n        for i in range(len(text)):\n            for length in range(1, len(text)//2+1):\n                now = text[i:i+length] \n                if now in visited:\n                    continue\n                    \n                if now  == text[i+length:i + 2*length]:\n                    count += 1\n                    visited[now] = 1\n        \n        return count\n                    \n", "class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \n        \n        seen = set()        \n        count = 0\n        \n        for i in range(len(text)-1):\n            for j in range(i, len(text), 1):\n                l=(j-i+1)//2\n                if l<1: continue\n                h=l+i\n                t = text[i:h+l]\n                \n                # print(text[i:h], text[h:h+l], i, j)\n                if t in seen: continue\n                \n                if t[:l] == t[l:]:\n                    count += 1\n                    # print( '**', text[i:h+l])\n                    seen.add(t)\n                    \n                    \n        return count\n\n"]
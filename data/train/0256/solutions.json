["class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        bananas = sum(piles)\n        K = bananas // H + (bananas % H != 0)\n        while True:\n            hours_needed = 0\n            for pile in piles:\n                hours_needed += pile // K\n                if pile % K != 0:\n                    hours_needed += 1\n            if hours_needed <= H:\n                return K\n            K += 1\n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        total_bananas = sum(piles)\n        left, right = math.ceil(total_bananas / H), math.ceil(total_bananas / (H - len(piles) + 1))\n        while left < right:\n            mid = (left + right) // 2\n            if not sum([math.ceil(pile/mid) for pile in piles]) <= H:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time_need(K):\n            return sum(p//K + (1 if p%K else 0) for p in piles)\n        \n        low = max(1, sum(piles)//H)\n        high = max(piles)\n        while low < high:\n            if time_need(low)<=H: return low\n            \n            low += 1\n            mid = (low+high)//2\n            if time_need(mid) > H:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def helper(k):\n            ret=0\n            for pile in piles:\n                ret+=math.ceil(pile/k)\n                if ret>H:\n                    return False\n            return True\n        l,r=1,max(piles)\n        while l<=r:\n            mid=l+(r-l)//2\n            if helper(mid):\n                r=mid-1\n            else:\n                l=mid+1\n        return l\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # if len(piles) == 1:return -(piles[0] // -H)\n        self.piles = piles\n        l, r = 1, max(piles)\n        \n        while l <= r:\n            K = (l + r)//2\n            if self.eat_time(K) <= H:\n                r = K - 1\n            else:\n                l = K + 1\n        return l\n            \n    def eat_time(self, K):\n        cnt = 0\n        for banana in self.piles:\n            q, mod = divmod(banana, K)\n            cnt += q\n            if mod != 0: cnt += 1\n            # cnt += banana / K\n            # if banana%K != 0: cnt += 1\n        return cnt", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def enough(n):\n            hrs = 0\n            for i in piles:\n                if n > i:\n                    hrs += 1\n                elif i % n == 0:\n                    hrs += i // n\n                else:\n                    hrs += (i // n) + 1\n            return hrs <= H\n        \n        l,r = 1,sum(piles)\n        while l < r:\n            m = (l + r) // 2\n            if not enough(m):\n                l = m + 1\n            else:\n                r = m\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right - left) // 2\n            if self.condition(piles, H, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n    \n    def condition(self, piles, H, k):\n        hours = 0\n        for pile in piles:\n            div, rem = divmod(pile, k)\n            hours += div\n            if rem != 0:\n                hours += 1\n        return hours <= H", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def can(K):\n            cur = H\n            for a in piles:\n                cur -= a//K\n                cur -= (a%K!=0)\n            return cur >= 0\n        l, r = 1, sum([a+ 1 for a in piles])\n        while l<r:\n            mid = (l + r)//2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        end = max(piles)\n        start = 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2 \n            if self.possible(mid, piles, H):\n                end = mid \n            else:\n                start = mid \n        \n        if self.possible(start,piles,H):\n            return start \n        if self.possible(end, piles, H):\n            return end \n        \n    \n    def possible(self, eat_load, total_load, hour):\n        return sum([math.ceil(-k / -eat_load) for k in total_load]) <= hour ", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # Minimum value we can have is the sum of piles / H\n        lo = sum(piles) // H\n        \n        # Maximum would be the maximum value in the list\n        hi = max(piles)\n        \n        #\n        #         lo = 0\n        #         hi = float('-inf')\n\n        #         for pile in piles:\n        #             lo += pile\n        #             hi = max(hi, pile)\n\n        #         lo =// H\n        \n        if len(piles) == 1:\n            return ceil(piles[0] / H)\n        \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            \n            count = sum(map(lambda x: ceil(x / mid), piles))\n            \n            if count > H:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        return lo", "class Solution:\n    \n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def useDays(pile, speed):\n            days = pile // speed\n            return days if pile % speed == 0 else days + 1\n        \n        def CanDone(piles, speed, H):\n            numDays = 0\n            for num in piles:\n                numDays += useDays(num, speed)\n            return numDays <= H\n        \n        maxEat = max(piles)\n        left,right = 1, maxEat + 1\n        while left < right:\n            mid = left + ((right-left)>>1)            \n            if CanDone(piles, mid, H):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n            \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        #piles.sort()\n        \n        lo, hi = 1, max(piles)\n        ans = hi\n        while lo <= hi:\n            k = (lo + hi) // 2\n            time = 0\n            for i in piles:\n                t = int(ceil(i / k))\n                if not t:\n                    t += 1\n                time += t\n                \n            #print(k, time)\n            if time <= H:\n                hi = k - 1\n                ans = k\n            else:\n                lo = k + 1\n        \n        return ans", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        piles.sort()\n        \n        lo, hi = 1, piles[-1]\n        ans = hi\n        while lo <= hi:\n            k = (lo + hi) // 2\n            time = 0\n            for i in piles:\n                t = int(ceil(i / k))\n                if not t:\n                    t += 1\n                time += t\n                \n            #print(k, time)\n            if time <= H:\n                hi = k - 1\n                ans = k\n            else:\n                lo = k + 1\n        \n        return ans", "import math as m\nclass Solution:\n    def check_time(piles,speed):\n        hrs=0\n        for i in piles:\n            hrs+=int(m.ceil(i/speed))\n        return hrs\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        low=1\n        high=float('-inf')\n        for i in piles:\n            high=max(high,i)\n        if H==len(piles):\n            return high\n        while(low<=high):\n            mid=(low+high)//2\n            hrs=Solution.check_time(piles,mid)\n            if hrs>H:\n                low=mid+1\n            else:\n                high=mid-1\n        return low\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # want to search for K - this is the variable to change\n        \n        # if piles in sorted order - based on length of pile and hours - need to get average eats in the pile\n        \n        # let K = 1 to max(piles)\n        \n        # per hour - go through the piles and eat K bananas before time limit is up\n        # O(N) time to go through all piles N\n        # K is split via binary search log(K)\n        \n        # log(K) * N times\n        \n        low = 1\n        high = max(piles)\n        \n        # the piles is not the one we want to find - its K\n        \n        # take too much time to eat - raise K\n        # too little time to eat - lower K\n        # set timer\n        # always a solution\n        def possible(k):\n            time = 0\n            # find out how much time it takes\n            for pile in piles:\n                time += (pile - 1) // k + 1\n            return time <= H\n        \n        while low <= high:\n            mid = low + (high - low) // 2\n            outcome = possible(mid)\n            \n            # check if its possible\n            if possible(mid): # just right\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        return low # should not hit - always solution", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if len(piles)==H:\n            return max(piles)\n        low=1\n        high=max(piles)\n        ans=high\n        while low<=high:\n            mid=(low+high)//2\n            h=H\n            for i in range(len(piles)):\n                if piles[i]<=mid:\n                    h-=1\n                else:\n                    if piles[i]%mid==0:\n                        h-=piles[i]//mid\n                    else:\n                        h-=(piles[i]//mid)+1\n            if h>=0:\n                ans =min(ans,mid)\n                high=mid-1\n            else:\n                low=mid+1\n        return ans", "from math import ceil\nclass Solution:\n    def ok(self, piles: List[int], k: int, H: int) -> bool:\n        return sum([ ceil(piles[i] / k) for i in range(len(piles)) ]) <= H\n    \n    \n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        st = 1\n        en = sum(piles)\n        \n        ans = en\n        \n        while st <= en:\n            mid = st + (en - st) // 2\n            \n            if self.ok(piles, mid, H):\n                ans = mid\n                en = mid - 1\n                \n            else:\n                st = mid + 1\n                \n        return ans", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        L = len(piles)\n        if L==H:\n            return max(piles)\n        k2 = max(piles)\n        k1 = 1\n        res = k2\n        k = k1\n        while k1<k2-1:\n            \n            cur = 0\n            for j in range(L):\n                cur += math.ceil(piles[j]/k)\n                if cur>H:\n                    k1 = k\n                    break\n            if cur<=H:\n                k2 = k\n                res = min(res,k)\n            #print(k1,k2,k,cur)\n            k = (k1+k2)//2\n        return res\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time(val):\n            t = len(piles)\n            for pile in piles:\n                t += (pile - 1) // val\n            return t\n            \n        l, r = 1, max(piles)\n        while l <= r:\n            mid = l + (r - l) // 2\n            t = time(mid)\n            if t <= H:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # want to search for K - this is the variable to change\n        \n        # if piles in sorted order - based on length of pile and hours - need to get average eats in the pile\n        \n        # let K = 1 to max(piles)\n        \n        # per hour - go through the piles and eat K bananas before time limit is up\n        # O(N) time to go through all piles N\n        # K is split via binary search log(K)\n        \n        # log(K) * N times\n        \n        low = 1\n        high = max(piles)\n        \n        # the piles is not the one we want to find - its K\n        \n        # take too much time to eat - raise K\n        # too little time to eat - lower K\n        # set timer\n        # always a solution\n        def possible(k):\n            time = 0\n            # find out how much time it takes\n            for pile in piles:\n                time += (pile + k - 1) // k # if k >= pile then it will be 1.xxxxx that means we ate the pile\n                # if there is 0, then that means \n            return time <= H\n        \n        while low < high:\n            mid = low + (high - low) // 2\n            outcome = possible(mid)\n            \n            # check if its possible\n            if possible(mid): # reduce because anything greater will be satisfied - need to find left bound\n                high = mid\n            else: # not possible - need to increase K to eat faster\n                low = mid + 1\n\n                # low == high\n        return high # should not hit - always solution", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # want to search for K - this is the variable to change\n        \n        # if piles in sorted order - based on length of pile and hours - need to get average eats in the pile\n        \n        # let K = 1 to max(piles)\n        \n        # per hour - go through the piles and eat K bananas before time limit is up\n        # O(N) time to go through all piles N\n        # K is split via binary search log(K)\n        \n        # log(K) * N times\n        \n        low = 1\n        high = max(piles)\n        \n        # the piles is not the one we want to find - its K\n        \n        # take too much time to eat - raise K\n        # too little time to eat - lower K\n        # set timer\n        # always a solution\n        def possible(k):\n            time = 0\n            # find out how much time it takes\n            for pile in piles:\n                time += (pile + k - 1) // k # if k >= pile then it will be 1.xxxxx that means we ate the pile\n                # if there is 0, then that means \n            return time <= H\n        \n        while low < high:\n            mid = low + (high - low) // 2\n            outcome = possible(mid)\n            \n            # check if its possible\n            if possible(mid): # reduce because anything greater will be satisfied - need to find left bound\n                high = mid\n            else: # not possible - need to increase K to eat faster\n                low = mid + 1\n\n        return low # should not hit - always solution", "class Solution:\n    def minEatingSpeed(self, array: List[int], hour: int) -> int:\n        if len(array)==hour:\n            return max(array)\n        low=1\n        high=max(array)\n        ans=high\n        while low<=high:\n            mid=(low+high)//2\n            h=hour\n            for i in range(len(array)):\n                if array[i]<=mid:\n                    h-=1\n                else:\n                    if array[i]%mid==0:\n                        h-=array[i]//mid\n                    else:\n                        h-=(array[i]//mid)+1\n            if h>=0:\n                ans =min(ans,mid)\n                high=mid-1\n            else:\n                low=mid+1\n        return ans\n", "\nclass Solution:\n    def minEatingSpeed(self, piles, H):\n        speed = math.floor(sum(piles) / H)\n        while True:\n            time = sum([math.ceil(x / speed) if speed else float('inf') for x in piles])\n            print(f'{speed=}, {time=}, {H=}')\n            if time <= H: break\n            speed += 1\n        return speed\n\n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        self.store = {}\n\n        l = 1\n        r = max(piles)\n        while l <= r:\n            m = l + (r-l)//2\n            if self.calc_h(piles, m) > H:\n                l = m + 1\n            else:  # calc_h(piles, m) <= H\n                if m == 1 or self.calc_h(piles, m-1) > H:\n                    return m\n                r = m - 1\n\n    def calc_h(self, piles, K):\n        if K not in self.store:\n            h = [p // K + (p%K > 0) for p in piles]\n            self.store[K] = int(sum(h))\n        return self.store[K]\n", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l = 1\n        r = max(piles)\n        while l <= r:\n            m = l + (r-l)//2\n            if calc_h(piles, m) > H:\n                l = m + 1\n            else:  # calc_h(piles, m) <= H\n                if m == 1 or calc_h(piles, m-1) > H:\n                    return m\n                r = m - 1\n\ndef calc_h(piles, K):\n    h = [p // K + (p%K > 0) for p in piles]\n    return int(sum(h))\n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        total_bananas = sum(piles)\n        left, right = math.ceil(total_bananas / H), total_bananas\n        print(left, right)\n        while left < right:\n            mid = (left + right) // 2\n            if not sum([math.ceil(pile/mid) for pile in piles]) <= H:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def condition(k) -> bool:\n            count = 0\n            \n            for v in piles:\n                count += int(math.ceil(v / k))\n                if count > H:\n                    return False\n            return True\n        \n        left,right = 1,max(piles)\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n            \n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if not piles: return -1\n        \n        low,high=1,sum(piles)\n        \n        def isPossible(piles,target,H):\n            \n            return sum(math.ceil(p/target) for p in piles) <= H\n       \n        while low < high:\n            \n            mid = low+(high-low)//2\n            # print(low,high,mid)\n            if isPossible(piles,mid,H):\n                high = mid\n            else:\n                low = mid+1\n                \n        return low\n        \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left = 1\n        right = max(piles)\n        while left < right:\n            mid = (left + right) // 2\n            if self.get_total_days(piles, mid) > H:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n    \n    def get_total_days(self, piles: List[int], num_eat: int)-> int:\n        if num_eat == 0:\n            return 0\n        total_days = 0\n        for pile in piles:\n            total_days += math.ceil(float(pile) / num_eat)\n        return total_days", "class Solution:\n    def minEatingSpeed(self, array: List[int], hour: int) -> int:\n        if len(array)==hour:\n            return max(array)\n        low=1\n        high=max(array)\n        ans=high\n        while low<=high:\n            mid=(low+high)//2\n            h=hour\n            for i in range(len(array)):\n                if array[i]<=mid:\n                    h-=1\n                else:\n                    if array[i]%mid==0:\n                        h-=array[i]//mid\n                    else:\n                        h-=(array[i]//mid)+1\n                if h<0:\n                    break \n            if h>=0:\n                ans =mid\n                high=mid-1\n            else:\n                low=mid+1\n        return ans\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def possible(K):\n            return sum((p-1) //K+ 1 for p in piles) <= H\n\n        lo, hi = 1, max(piles)\n        while lo < hi:\n            mi = (lo + hi) //2\n            if not possible(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n \n        maxB = max(piles)\n\n        def getH(k):\n            if not k:\n                return float('inf')\n            numHours = 0\n            for pile in piles:\n                numHours += pile//k + int(bool(pile%k))\n            return numHours\n\n        \n        \n        def bs(start, end):\n            if start > end:\n                return float('inf')\n            mid = (start + end + 1)//2\n            h = getH(mid)\n            # print(mid, h)\n            if h < H:\n                if mid != start :\n                    return min(mid,bs(start, mid-1))\n            if h > H:\n                return bs(mid+1, end)\n            if h == H:\n                while getH(mid-1) == H:\n                    mid -= 1\n            return mid\n        \n        return  bs(0, maxB)\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time_needed(K):\n            return sum(p//K + (1 if p%K else 0) for p in piles)\n        \n        lower = max(1, sum(piles)//H)\n        upper = max(piles)\n        \n        while lower < upper:\n            if time_needed(lower) <= H:\n                return lower\n            \n            lower += 1\n            mid = (lower + upper)//2\n            if time_needed(mid) <= H:\n                upper = mid\n            else:\n                lower = mid + 1\n                \n        return lower", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        #piles.sort()\n        \n        lo, hi = 1, max(piles)\n        ans = hi\n        while lo <= hi:\n            k = (lo + hi) // 2\n            time = 0\n            for i in piles:\n                t = int(ceil(i / k))\n                if not t:\n                    t += 1\n                time += t\n                \n                if time > H:\n                    break\n                \n            #print(k, time)\n            if time <= H:\n                hi = k - 1\n                ans = k\n            else:\n                lo = k + 1\n        \n        return ans", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n \n        maxB = max(piles)\n\n        def getH(k):\n            if not k:\n                return float('inf')\n            numHours = 0\n            for pile in piles:\n                numHours += pile//k + int(bool(pile%k))\n            return numHours\n\n        \n        \n        def bs(start, end):\n            if start > end:\n                return float('inf')\n            mid = (start + end + 1)//2\n            h = getH(mid)\n            # print(mid, h)\n            if h < H:\n                if mid > start :\n                    return min(mid,bs(start, mid-1))\n            if h > H:\n                return bs(mid+1, end)\n            if h == H:\n                while getH(mid-1) == H:\n                    mid -= 1\n            return mid\n        \n        return  bs(0, maxB)\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        max_k = 0\n        for value in piles:\n            max_k = max(max_k, value)\n        \n        def possible(k):\n            hours = 0\n            for item in piles:\n                hours += math.ceil(item / k)\n                if hours > H:\n                    return False\n            if hours <= H:\n                return True\n            return False\n        \n        def binary_search(low, high):\n            mid = low + (high - low)//2\n            if possible(low):\n                return low\n            elif possible(mid):\n                return binary_search(low, mid)\n            else:\n                return binary_search(mid+1, high)\n        \n        def binary_search_iter(low, high):\n            pass\n        \n        return binary_search(1, max_k)", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # Find the first <= in  [> > > > > <= <=]\n        n = len(piles)\n        low, high = 1, max(piles)\n        while (low + 1) < high:\n            mid = low + ((high - low) // 2)\n            used_hrs = self.calc_hours(piles, mid)\n            #print(mid, used_hrs)\n            if used_hrs > H:\n                low = mid\n            else:\n                high = mid\n                \n        if self.calc_hours(piles, low) <= H:\n            return low\n        if self.calc_hours(piles, high) <= H:\n            return high\n    \n    @staticmethod\n    def calc_hours(piles, K):\n        return int(sum(math.ceil(pile / float(K)) for pile in piles))\n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        minn = max(1, int(math.floor(sum(piles) / float(H))))\n        l = minn\n        r = max(piles)\n        while l <= r:\n            m = l + (r-l)//2\n            if calc_h(piles, m) > H:\n                l = m + 1\n            else:  # calc_h(piles, m) <= H\n                if m == minn or calc_h(piles, m-1) > H:\n                    return m\n                r = m - 1\n\ndef calc_h(piles, K):\n    h = [p // K + (p%K > 0) for p in piles]\n    return int(sum(h))\n", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def compute_hours(piles, K):\n            ret = 0\n            for p in piles:\n                ret += math.ceil(p / K)\n            return ret\n        \n        ## descending, larger K, smaller hours; smaller K, larger hours\n        ## find smallest K, where h <= H\n        ## result K - 1 should be invalid, since K is the smallest valid value\n        lo = 1\n        hi = sum(piles)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            val = compute_hours(piles, mid)\n            if val <= H: ## K might be smaller\n                hi = mid - 1\n            else: ## too small\n                lo = mid\n        if compute_hours(piles, hi) <= H: ## happens when hi == original lo\n            return hi\n        else:\n            return hi + 1", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo = 1\n        hi = max(piles)\n        \n        while lo < hi:\n            mid = (hi - lo) // 2 + lo\n            if sum([math.ceil(i/mid) for i in piles]) > H:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lower_bound = 1\n        upper_bound = sum(piles)\n        \n        while lower_bound < upper_bound:\n            speed = (lower_bound + upper_bound) // 2\n            if self.can_finish(piles, speed, H):\n                upper_bound = speed\n            else:\n                lower_bound = speed + 1\n                \n        return upper_bound\n    \n    def can_finish(self, piles, speed, h):\n        hours = 0\n        for bananas in piles:\n            hours += math.ceil(bananas / speed)\n                \n        return hours <= h\n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n = len(piles)\n        s = sum(piles)\n        \n        if H == n:\n            return max(piles)\n        \n        if H > s:\n            return 1\n        \n        k = s // H\n        i = 0\n        while True:\n            t = 0\n            for j in range(len(piles)):\n                t += math.ceil(piles[j] / k)\n            if t <= H:\n                return k\n            k += 1\n        \n        return 0", "class Solution:\n    def minEatingSpeed(self, piles, H):\n        lo, hi = 1, max(piles)\n        \n        while lo <= hi:\n            K = lo + ((hi - lo) >> 1)\n            if self.countTimeEatAllAtSpeed(\n                    K, piles) <= H:  # count time to eat all bananas at speed K\n                hi = K - 1\n            else:\n                lo = K + 1\n        return lo\n    \n    def countTimeEatAllAtSpeed(self, K, piles):\n        countHours = 0  # hours take to eat all bananas\n        \n        for pile in piles:\n            countHours += pile // K\n            if pile % K != 0:\n                countHours += 1\n        return countHours", "class Solution:\n    def hours(self,piles,k):\n        cnt=0\n        for p in piles:\n            if p<=k:\n                cnt=cnt+1\n            else:\n                cnt=cnt+ p//k +1\n        return cnt\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if len(piles)==1:\n            return 1+piles[0]//H\n        l=0\n        r=max(piles)\n        while(l<=r):\n            mid=(l+r)//2\n            hrs=self.hours(piles,mid)\n            if (hrs<=H):\n                ans=mid\n                r=mid-1\n            else:\n                l=mid+1\n        return ans\n        \n                \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        left = 1\n        right = max(piles)\n        \n        \n        while right > left:\n            \n            speed = int((left+right)/2)\n            \n            total_hours = 0\n            \n            for i in piles:\n                total_hours += math.ceil(i/speed)\n                \n                \n            if(total_hours > H):\n                left = speed + 1\n            else:\n                right = speed\n                \n        return left\n                \n                \n                \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        max_k = 0\n        for value in piles:\n            max_k = max(max_k, value)\n        \n        def possible(k):\n            hours = 0\n            for item in piles:\n                hours += math.ceil(item / k)\n                if hours > H:\n                    return False\n            if hours <= H:\n                return True\n            return False\n        \n        def binary_search(low, high):\n            mid = low + (high - low)//2\n            if possible(low):\n                return low\n            elif possible(mid):\n                return binary_search(low, mid)\n            else:\n                return binary_search(mid+1, high)\n        \n        def binary_search_iter(low, high):\n            while low < high:\n                mid = low + (high - low)//2\n                if possible(low):\n                    return low\n                elif possible(mid):\n                    high = mid\n                else:\n                    low = mid + 1\n            return high\n        \n        return binary_search_iter(1, max_k)", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo = 1\n        hi = max(piles)\n        ans = 0\n        while hi >= lo:\n            mid = (lo + hi) // 2\n            if self.check(mid, piles, H):\n                ans = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1  \n        return ans\n    \n    def check(self, mid, piles, H):\n        i = 0\n        count = 0\n        new = piles[::]\n        while i < len(new):\n            if count > H:\n                return False\n            if mid >= new[i]:\n                count += 1\n                i += 1\n            else:\n                count += new[i] // mid + 1\n                i += 1\n        if count > H:\n            return False\n        return True\n                \n                \n            \n            \n            \n            \n            \n            \n            \n    \n    \n        \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if H == len(piles):\n            return max(piles)\n        \n        l = 1\n        r = max(piles) + 1\n        while l < r:\n            m = l + (r - l) // 2\n            if self.minHours(piles, m) <= H:\n                r = m\n            elif self.minHours(piles, m) > H:\n                l = m + 1\n        return l\n        \n        \n    def minHours(self, piles, k):\n        h = 0\n        for p in piles:\n            if p % k == 0:\n                h += p // k\n            else:\n                h = h + p // k + 1\n        return h\n        \n", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l = 1\n        r = max(piles)\n        while l <= r:\n            m = l + (r-l)//2\n            if calc_h(piles, m) > H:\n                l = m + 1\n            else:  # calc_h(piles, m) <= H\n                if m == 1 or calc_h(piles, m-1) > H:\n                    return m\n                r = m - 1\n\ndef calc_h(piles, K):\n    h = [math.ceil(p / K) for p in piles]\n    return int(sum(h))\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n\n\n        min_speed = 1\n        max_speed = sorted(piles)[-1]\n        while min_speed <=max_speed :\n            #print('min_speed',min_speed)\n            #print('max_speed',max_speed)\n\n            pivot = min_speed + (max_speed - min_speed)//2\n            #print('current_speed',pivot)\n\n            hours = [math.ceil(x/pivot) for x in piles]\n            #print('hours=',hours)\n            r=0\n            for x in hours:\n                if x ==0:\n                    #print('if_x',x+1)\n                    r+=1\n                else:\n                    #print('else_x',x)\n                    r+=x\n            #print('r',r)\n            #print()\n            if r == H:\n                return pivot\n            elif min_speed==max_speed and r>=H:\n                return pivot+1\n            #elif min_speed==max_speed and r < H:\n            #    min_speed = pivot+1\n            elif r < H:\n                max_speed = pivot-1\n\n            elif r > H:\n                min_speed = pivot+1\n        return pivot", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def cnt(k,piles):\n            ans=0\n            for p in piles:\n                ans+=math.ceil(p/float(k))\n            return int(ans)\n        piles.sort()\n        l=1\n        h=piles[-1]\n        mid=(l+h)//2\n        while l<=h:\n            s=cnt(mid,piles)\n            if s<=H:\n                h=mid-1\n            else:\n                l=mid+1\n            mid=(l+h)//2\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def valid(mid):\n            if mid==0:\n                return False\n            hours = 0\n            for i in piles:\n                if i<mid:\n                    hours+=1\n                else:\n                    hours+=math.ceil(i/mid)\n\n            return hours<=H\n        \n        if not piles:\n            return 0\n        \n        piles = sorted(piles)\n        s,e = 0,sum(piles)\n        ans = -1\n        while s<=e:\n            mid = (s+e)//2\n            if valid(mid):\n                ans = mid\n                e = mid-1\n            else:\n                s = mid+1\n                \n        return ans\n", "class Solution:\n    def get_hours(self, piles, k):\n        ans = 0\n        for x in piles:\n            if x%k==0:\n                ans+=x//k\n            else:\n                ans+=int(x//k)+1\n        return ans\n    \n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n,max_val = len(piles), max(piles)\n        if H<n:\n            return 1<<31\n        start,end=1, max_val\n        while start<=end:\n            mid = (end-start)//2+start\n            h = self.get_hours(piles, mid)\n            if h<=H:\n                end=mid-1\n            else:\n                start=mid+1\n                \n        #print(start)\n        return start if start<=max_val else start-1", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def is_smaller_equal_H(piles, K, H):\n            ret = 0\n            for p in piles:\n                ret += math.ceil(p / K)\n                if ret > H:\n                    return False\n            return True\n        \n        ## descending, larger K, smaller hours; smaller K, larger hours\n        ## find smallest K, where h <= H\n        ## result K - 1 should be invalid, since K is the smallest valid value\n        lo = 1\n        hi = sum(piles)\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            flag = is_smaller_equal_H(piles, mid, H)\n            if flag: ## K might be smaller\n                hi = mid - 1\n            else: ## too small\n                lo = mid\n        if is_smaller_equal_H(piles, hi, H): ## happens when hi == original lo\n            return hi\n        else:\n            return hi + 1", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        # bananas=0\n        \n        def isValid(mid):\n            hours=0\n            for banana in piles:\n\n                div=math.ceil(banana/mid)\n                hours+=div\n                if  hours>H:\n                    return False\n            return True\n        \n        def binsearch():\n            low=1\n            high=sum(piles)  \n            while low < high:   \n                mid=low+(high-low)//2\n                # print(isValid(mid),mid)\n                if isValid(mid):\n                    high=mid\n                else:\n                    low=mid+1\n            return low\n        total=sum(piles)\n        return binsearch()\n                    \n", "from typing import List\nfrom math import ceil\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def get_hours(piles, K):\n            total = 0\n            for num in piles:\n                total += ceil(num / K)\n            return total\n        \n        left, right = 1, max(piles)\n        while left < right:\n            mid = left + (right - left) // 2\n            if get_hours(piles, mid) > H:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def feasible(bananas):\n            hour = 0\n            for pile in piles:\n                hs, left = divmod(pile, bananas)\n                hour += hs + (left > 0)\n            return hour <= H\n            \n        l = 1\n        r = sum(piles)\n            \n        while l < r:\n            mid = (l+r)>>1\n            if feasible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        start, end = 1, max(piles)\n        while start+1 < end:\n            mid = (start+end) // 2\n            if self.is_feasible(piles, H, mid) == False:\n                start = mid + 1\n            elif self.is_feasible(piles, H, mid) == True:\n                end = mid\n        if self.is_feasible(piles, H, start):\n            return start\n        else:\n            return end\n        \n    \n    def is_feasible(self, piles, H, speed):\n        res = 0\n        for i in piles:\n            res += math.ceil(i/speed)\n        if res <= H:\n            return True\n        else:\n            return False\n        \n        \n", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def check(avg):\n            return sum(math.ceil(i/avg) for i in piles)<=H\n        hi,lo=max(piles),1\n        while lo<hi:\n            mid=(lo+hi)//2\n            if check(mid):\n                hi=mid\n            else:\n                lo=mid+1\n        return hi\n        \n1        \n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        lo = int(math.ceil(sum(piles) / H))\n        hi = sum(piles)\n        # print(hi)\n        \n        hours = lambda j: sum([int(math.ceil(i / j)) for i in piles])\n\n        out = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            res = hours(mid)   \n            # print(res, mid)\n            \n            if res <= H:\n                out = mid\n            if res <= H:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n                \n        return out", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        low=1\n        ans=[0]\n        high=max(piles)\n        h=[H]\n     \n        \n        def check(speed,piles):\n            cost=0\n            \n            for i in piles:\n                cost+=math.ceil(i/speed)\n                \n                if cost>h[0]:\n                    return False\n            return True\n            \n        def binary(low,high):\n            \n            if low>high:\n                return high\n            mid=(low+high)//2\n           \n            if check(mid,piles):\n                ans[0]=mid\n              \n                binary(low,mid-1)\n            else:\n                 \n                \n                binary(mid+1,high)\n        binary(low,high)\n        return ans[-1]", "from math import ceil\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def doesViolate(mid):\n            requiredHour = 0\n            for i in range(0, len(piles)):\n                if mid > piles[i]:\n                    requiredHour+=1\n                else:\n                    requiredHour += math.ceil(piles[i]/mid)\n            if requiredHour > H:\n                return True\n            else: return False\n        low = 1\n        high = max(piles)\n        \n        while (low < high):\n            mid = (low+high) // 2\n            if doesViolate(mid) == True:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        from math import ceil\n        left = 1\n        right = max(piles) + 1\n        timeConsumption = lambda speed: sum(ceil(pile / speed) for pile in piles)\n        while left < right:\n            mid = left + (right - left) // 2\n            time = timeConsumption(mid)\n            if time > H: left = mid + 1\n            else: right = mid\n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def feasible(bananas):\n            hour = 0\n            for pile in piles:\n                hs, left = divmod(pile, bananas)\n                hour += hs + (left > 0)\n                if hour > H:\n                    return False\n            return hour <= H\n            \n        l = 1\n        r = sum(piles)\n            \n        while l < r:\n            mid = (l+r)>>1\n            if feasible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l = max(sum(piles)//H, 1)\n        h = max(piles)\n        while l < h:\n            mid = (l + h) // 2\n            timeL = self.timeTaken(piles, l)\n            timeMid = self.timeTaken(piles, mid)\n            if timeL <= H:\n                return l\n            elif timeMid <= H:\n                h = mid\n                timeH = timeMid\n                l += 1\n            else:\n                l = mid + 1\n        return l\n    def timeTaken(self, piles, n):\n        summ = 0\n        for v in piles:\n            summ += v // n\n            if v % n:\n                summ += 1\n        return summ\n                \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # 14:25-\n        if H == len(piles):\n            return max(piles)\n        elif sum(piles) <= H:\n            return 1\n        \n        cntr = collections.Counter(piles)\n        lst = set()\n        for key in cntr.keys():\n            lst.add((key, cntr[key]))\n        \n        s = 2\n        e = max(piles) - 1\n        while s <= e:\n            K = int((s + e) / 2)\n            total = 0\n            for pile, n in lst:\n                q, r = divmod(pile, K)\n                if r:\n                    total += (q + 1) * n\n                else:\n                    total += q * n\n                \n                if total > H:\n                    break\n                    \n            # fast\n            if total <= H:\n                e = K - 1\n            #slow\n            else:\n                s = K + 1\n        \n        return s", "from math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        hi_fail = 0\n        low_pass = max(piles)\n        if len(piles) == H:\n            # O(n)\n            return low_pass\n\n        # O(n*log n)\n        piles.sort(reverse=True)\n        speed = low_pass // 2\n        while low_pass - hi_fail > 1:\n            # O(m where m <= n)\n            for i, num_bananas in enumerate(piles):\n                if num_bananas <= speed:\n                    break\n            else:\n                i += 1\n\n            if not self.can_eat_all(piles, H, speed, i):\n                hi_fail = speed\n            else:\n                low_pass = speed\n\n\n            speed = (low_pass + hi_fail) // 2\n\n        return low_pass\n\n    def can_eat_all(self, piles, hours, speed, stop_ind):\n        # O(l)\n        extra_hours = hours - len(piles)\n        for i in range(stop_ind):\n            hours_needed = int(ceil(piles[i] / speed))\n            extra_hours -= (hours_needed - 1)\n            if extra_hours < 0:\n                return False\n\n        if len(piles) == 1 and extra_hours == 0:\n            return False\n\n        return True\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left = 1\n        right = max(piles)\n        while left + 1 < right:\n            mid = left + (right-left)//2\n            if self.possible(piles, H, mid):\n                right = mid\n            else:\n                left = mid\n        if self.possible(piles, H, left):\n            return left\n        return right\n            \n        \n    def possible(self, piles, H, K):\n        time = 0\n        for p in piles:\n            time += math.ceil(p/K)\n        return time <= H", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def finishable(piles, H, eatRate) -> bool:\n            numHours = 0\n            for pile in piles:\n                numHours += ceil(pile / eatRate)\n            \n            return numHours <= H\n        \n        left, right = 1, max(piles)\n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if finishable(piles, H, mid):\n                right = mid\n            else:\n                left = mid + 1\n            \n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        right = 10**9\n        left = 1\n        piles.sort()\n        while left + 1 < right:\n            mid = (left + right)//2\n            if self.canEatAll(piles, mid, H):\n                right = mid\n            else:\n                left = mid\n        return left if self.canEatAll(piles, left, H) else right\n        \n\n    def canEatAll(self, piles, speed, H):\n        res = 0\n        for pile in piles:\n            res += (pile - 1)//speed + 1\n        return res <= H\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lower = 1\n        upper = max(piles)\n        \n        while lower < upper:\n            mid = (lower+upper)//2\n            if sum(p//mid + 1 if p%mid else p//mid for p in piles) > H:\n                lower = mid + 1\n            else:\n                upper = mid\n                \n        return upper\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        s, e = 1, max(piles)\n        minK = float('inf')\n        while s <= e:\n            m = (s + e) // 2\n            if self.eat(piles, m) > H:\n                s = m + 1\n            else:\n                minK = min(minK, m)\n                e = m - 1\n        return minK\n        \n    def eat(self, piles, K):\n        ret = 0\n        for p in piles:\n            ret += math.ceil(p / K)\n        return ret", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if len(piles) == 1:\n            div, rem = divmod(piles[0], H)\n            if rem == 0:\n                return div\n            else:\n                return div + 1\n        left = 0\n        right = sum(piles)\n        while left < right:\n            mid = (left + right) // 2\n            if self.CalcTime(piles, mid, H):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n        \n    def CalcTime(self, piles, K, H):\n        h = 0\n        for p in piles:\n            div, rem = divmod(p, K)\n            h += div\n            if rem > 0:\n                h += 1\n            if h > H:\n                return False\n        return h <= H\n", "class Solution:\n    def time_taken(self, piles, n):\n        return sum(v // n + (1 if v % n else 0) for v in piles)\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo = max(1, sum(piles) // H)\n        hi = max(piles)\n                    \n        t_hi = self.time_taken(piles, hi)\n        \n        while lo < hi:\n            \n            mid = (lo + hi) // 2\n            \n            t_lo = self.time_taken(piles, lo)\n            t_mid = self.time_taken(piles, mid)\n            \n            if t_lo <= H:\n                return lo\n            elif t_mid <= H:\n                hi, t_hi = mid, t_mid\n                lo += 1\n            else:\n                lo = mid + 1\n                \n        return lo\n    #https://leetcode.com/problems/koko-eating-bananas/discuss/804478/Python-Binary-Search-98\n        \n        \n\n\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def ifeatK(k):\n            hour = 0\n            for pile in piles:\n    #\u662fmath.ceil \u4e0d\u662fceiling            \n                hour += math.ceil(pile/k)\n            return hour\n        \n        start =1 \n        end = sum(piles)\n        \n        while start +1 <end:\n            mid = (start+end)//2\n            if ifeatK(mid) <H:\n                end = mid\n            elif ifeatK(mid)>H:\n                start = mid\n            else:\n  #\u4e0d\u5e94\u8be5 \u627e\u5230mid,\u5c31return\uff0c\u5e94\u8be5\u7ee7\u7eed\n                end= mid\n   #     print(start,end)\n        if ifeatK(start)>H:\n            return end\n        if ifeatK(start)==H:\n            return start\n        if ifeatK(end)==H:\n            return end\n        return start\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        min_speed = 1\n        max_speed = max(piles)\n        while min_speed <=max_speed :\n            pivot = min_speed + (max_speed - min_speed)//2  \n            hours = [math.ceil(x/pivot) for x in piles]\n            r=0\n            \n            for x in hours:\n                if x ==0:\n                    r+=1\n                else:\n                    r+=x\n                    \n            if r == H:\n                return pivot\n            elif min_speed==max_speed and r>=H:\n                return pivot+1\n            elif r < H:\n                max_speed = pivot-1\n            elif r > H:\n                min_speed = pivot+1\n                \n        return pivot", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        N = len(piles)\n        \n        start = 1\n        end = max(piles)\n        \n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            \n            if self._can_complete(piles, mid, H):\n                end = mid\n            else:\n                start = mid\n                \n        if self._can_complete(piles, start, H):\n            return start\n        else:\n            return end\n        \n    def _can_complete(self, piles, K, H):\n        i = 0\n        N = len(piles)\n        \n        c = 0\n        for d in piles:\n            c += math.ceil(d / K)\n            \n        return c <= H\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # 14:25-\n        if H == len(piles):\n            return max(piles)\n        elif sum(piles) <= H:\n            return 1\n        \n        cntr = collections.Counter(piles)\n        \n        s = 2\n        e = max(piles) - 1\n        while s <= e:\n            K = int((s + e) / 2)\n            total = 0\n            for pile in cntr.keys():\n                q, r = divmod(pile, K)\n                if r:\n                    total += (q + 1) * cntr[pile]\n                else:\n                    total += q * cntr[pile]\n                \n                if total > H:\n                    break\n                    \n            # fast\n            if total <= H:\n                e = K - 1\n            #slow\n            else:\n                s = K + 1\n        \n        return s", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:  \n        # piles = [30,11,23,4,20]\n        # H = 6\n                \n#         piles =[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\n        \n#         H = 823855818\n        \n        def sop(A, H, K):  \n            if (K==0):\n                return False\n            count = 0 \n            for i in A:   \n                if (i%K == 0):\n                    count += i//K\n                else: \n                    count += i//K +1\n                \n            if count <= H:\n                return True \n            \n            return False\n                            \n        l = sum(piles)//H \n        r = max(piles) \n        print((l, r))\n        \n        print((sop(piles,H,l)))\n        \n        if len(piles) == 1:\n            return l+1\n        \n        m = (l+r)//2\n        while (l<=r):\n            # print(m)\n            if (sop(piles,H,l) == False) and (sop(piles,H,l+1) == True):\n                return l+1 \n            \n            if (sop(piles,H,r-1) == False) and (sop(piles,H,r) == True):\n                return r \n            \n            if sop(piles,H,m) == False:\n                l = m \n                m = (l+r)//2\n            else: \n                r = m \n                m = (l+r)//2 \n                \n                \n                \n        \n            \n            \n            \n        \n        \n        \n            \n            \n", "class Solution:\n    def canEat(self, piles, bananas, H):\n        cur_H = 0\n        for pile in piles:\n            if pile % bananas == 0:\n                cur_H += pile // bananas\n            else:\n                cur_H += pile // bananas + 1\n        if cur_H > H:\n            return False\n        return True\n        \n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        min_speed = 1\n        max_speed = max(piles)\n        while(min_speed < max_speed):\n            mid = (min_speed + max_speed) // 2\n            if self.canEat(piles, mid, H):\n                max_speed = mid\n            else:\n                min_speed = mid + 1\n        return min_speed", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l, r = 1, max(piles)\n        while l <= r:\n            m = l + (r-l)//2\n            if self.speedBalancer(piles, m) > H:\n                l = m + 1\n            elif self.speedBalancer(piles, m) <= H:\n                r = m - 1\n        return l\n                \n                \n    def speedBalancer(self, piles, target):\n        h = 0\n        for i in piles:\n            h += i // target\n            if i % target != 0:\n                h += 1\n        return h", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def condition(arr, k, h):\n            res = 0\n            for i in arr:\n                res += math.ceil(i/k)\n            if res <= h:\n                return True\n            return False\n        \n        l, r = 1, max(piles)\n        while l < r:\n            m = l + (r-l)//2\n            if condition(piles, m, H):\n                r = m\n            else:\n                l = m + 1\n        \n        return l", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        low=1\n        ans=[0]\n        high=max(piles)\n        h=[H]\n        def check(speed,piles):\n            cost=0\n            \n            for i in piles:\n                cost+=math.ceil(i/speed)\n                \n                if cost>h[0]:\n                    return False\n            return True\n            \n        def binary(low,high):\n            \n            if low>high:\n                return high\n            mid=(low+high)//2\n           \n            if check(mid,piles):\n                ans[0]=mid\n              \n                binary(low,mid-1)\n            else:\n                 \n                \n                binary(mid+1,high)\n        binary(low,high)\n        return ans[-1]", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n = len(piles)\n        if n >= H:\n            return max(piles)\n        def check(m):\n            ret = 0\n            for p in piles:\n                ret += p//m + (p%m!=0)\n            return ret\n        upper = max(piles)\n        lo, hi = 1, upper\n        while lo<=hi:\n            mid = (lo+hi)//2\n            if check(mid) <= H:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        lo = max(1, sum(piles) // H)\n        hi = max(piles)\n        \n               \n        t_hi = self.time_taken(piles, hi)\n        \n        while lo < hi:\n            \n            mid = (lo + hi) // 2\n            \n            t_lo = self.time_taken(piles, lo)\n            t_mid = self.time_taken(piles, mid)\n            if t_lo <= H:\n                return lo\n            elif t_mid <= H:\n                hi, t_hi = mid, t_mid\n                lo += 1\n            else:\n                lo = mid + 1\n                \n        return lo\n        \n        \n    def time_taken(self, piles, n):\n        \n        return sum(v // n + (1 if v % n else 0) for v in piles)", "import math\n\nclass Solution:\n    def cc(self,l,n):\n        ans=0\n        for i in l:\n            ans+=math.ceil(i/n)\n        return(ans)\n    \n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n = len(piles)\n        if H==n:\n            return(max(piles))\n        else:\n            l = math.ceil(sum(piles)/H)-1\n            r = max(piles)+1\n            while r-l>1:\n                pivot = (l+r)//2\n                if self.cc(piles,pivot)<=H:\n                    r = pivot\n                elif self.cc(piles,pivot)>H:\n                    l = pivot\n                \n            return(r)\n                \n            \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n\n        piles.sort()\n        l,r = 1,max(piles)\n        while l <= r:\n            m = (l+r)//2\n            if sum([(x-1)//m+1 for x in piles]) > H:\n                l = m+1\n            elif sum([math.ceil(x/m) for x in piles]) < H:\n                r = m-1\n            else:\n                return m\n        return l\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l = 1\n        r=max(piles)\n        \n        while l<r:\n            m =l+(r-l)//2\n            \n            h=0\n            for i in piles:\n                h+=math.ceil(i/m)            \n            if h>H:\n                l=m+1\n            else:\n                r=m\n        return l\n    \n        # low, high = 1, max(piles)\n        # while low < high:\n        #     mid = (low + high) // 2\n        #     h = 0\n        #     for i in piles:\n        #         h +=math.ceil(i / mid)\n        #     if h > H:\n        #         low = mid + 1\n        #     else:\n        #         high = mid\n        # return low\n", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # Use binary search to find the smallest rate that Koko can eat bananas\n        # and still finish all of them in H hours\n        \n        def feasible(maxBananas):\n            hours = 0\n            for pile in piles:\n                hours += math.ceil(pile/maxBananas)\n    \n                if hours > H:\n                    return False\n            return True\n        \n        \n        left = 1 # Slowest\n        right = max(piles) # Fastest\n        \n        while left < right:\n            mid = left + (right - left)//2\n            \n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        '''\n        # Can Koko eat all bananas in H hours with eating speed K?\n        def possible(K):\n            return sum((p-1) / K + 1 for p in piles) <= H\n\n        lo, hi = 1, max(piles)\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if not possible(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo\n        '''\n        \n        \n        # solution: use binary guess\n        \n        \n        le = 1\n        ri = sum(piles)\n        \n        def checkHours(speed):\n            s = 0\n            for item in piles:\n                s+=math.ceil(item/speed)\n            return s\n            '''\n            sum_hours = 0\n            for i in piles:\n                bananas =  i\n                hours = 0\n                while True:\n                    bananas = bananas - speed\n                    hours += 1\n                    if bananas <= 0: # bug only <\n                        break\n                sum_hours += hours\n            return sum_hours\n            '''\n                        \n        \n        while le + 1 < ri:\n            mid = le + (ri - le)//2\n            result = checkHours(mid)\n            if result <= H : # decrease speed\n                ri = mid\n            else: # increase speed\n                le =  mid\n                \n        result = checkHours(le)\n \n        if result <= H: # changed to <= H\n            return le\n        else:\n            return ri\n\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left = 1\n        right = max(piles)\n        while left < right:\n            mid = (left+right)//2\n            \n            hours = 0\n            s = i = 0\n            rem = 0\n            while i<len(piles):\n                hours += int(math.ceil(piles[i]/mid))\n                i += 1\n            # print(mid, hours)\n            if hours <= H:\n                right = mid\n            else:\n                left = mid+1\n        return left", "from math import ceil\n\ndef count_hr(piles, k):\n    return sum([ceil(p / k) for p in piles])\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if len(piles) > H:\n            return\n        lo, hi = 1, max(piles)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if count_hr(piles, mid) > H:\n                lo = mid + 1\n            elif count_hr(piles, mid) <= H:\n                hi = mid - 1\n        \n        return lo", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def is_feasible(rate,H,piles):\n            \n            count=0\n            for i in range(len(piles)):\n                count+=piles[i]//rate\n                \n                if piles[i]%rate!=0:\n                    count+=1\n                \n                if count>H:\n                    return False\n            \n            return True\n    \n    \n        \n        l=1\n        h=sum(piles)\n        ans=float('inf')\n        \n        while l<=h:\n            mid=(l+h)//2\n            \n            if is_feasible(mid,H,piles):\n                ans=min(ans,mid) \n                h=mid-1\n            \n            else:\n                l=mid+1\n        \n        return ans\n            \n            \n                    \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        ceiling = lambda x,y : (x+y-1)//y\n\n        def timeTaken(v):\n            # total time taken if Koko eat with v speed\n            totalTime = 0\n            for p in piles: totalTime += ceiling(p, v)\n            return totalTime\n        \n        def binarySearch(s, e, up_bound):\n            # find maximum index that less or equal then up_bound, index s~e\n            if(s == e): return s\n            m = (s+e)//2\n            if(timeTaken(m) <= up_bound):\n                return binarySearch(s,m, up_bound)\n            else: \n                return binarySearch(m+1, e, up_bound)   \n        \n        pmax = 1\n        for p in piles: pmax = max(pmax, p)\n        return binarySearch(1, pmax, H)", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def can_finish(k):\n            hours = 0\n            for pile in piles:\n                div = pile//k\n                hours += div\n                if pile%k:\n                    hours += 1\n                # print(pile, k, pile//k, pile%k, hours)\n            return hours<=H\n        \n        left, right = 1, max(piles)\n        while left < right:\n            mid = (left+right)//2\n            if can_finish(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left\n\n        \n        \n'''\n3 6 7 11\n1 2 3 4 5 6 7 8 9 10 11\nmid = 6\nhours = 1+1+2+2 6<=8\nmid = 3\nhours = 1+2+3+4 10<=8\nmid = 4\nhours = 1+2+2+3 8<=8\nmid = 3\nhours = 1+2+3+4 10<=8\nmid = 3\nmid = 4\n\n'''", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo = max(1, sum(piles) // H)\n        hi = max(piles)\n                    \n        t_hi = self.time_taken(piles, hi)\n        \n        while lo < hi:\n            \n            mid = (lo + hi) // 2\n            \n            t_lo = self.time_taken(piles, lo)\n            t_mid = self.time_taken(piles, mid)\n            \n            if t_lo <= H:\n                return lo\n            elif t_mid <= H:\n                hi, t_hi = mid, t_mid\n                lo += 1\n            else:\n                lo = mid + 1\n                \n        return lo\n        \n        \n    def time_taken(self, piles, n):\n        \n        return sum(v // n + (1 if v % n else 0) for v in piles)\n", "class Solution:\n    def minEatingSpeed(self, piles, H):\n        lo, hi = 1, max(piles)\n        \n        while lo <= hi:\n            K = (lo+hi)//2\n            if self.countTimeEatAllAtSpeed(\n                    K, piles) <= H:  # count time to eat all bananas at speed K\n                hi = K - 1\n            else:\n                lo = K + 1\n        return lo\n    \n    def countTimeEatAllAtSpeed(self, K, piles):\n        countHours = 0  # hours take to eat all bananas\n        \n        for pile in piles:\n            countHours += pile // K\n            if pile % K != 0:\n                countHours += 1\n        return countHours", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time_needed(piles, time):\n            return sum(p//time + (1 if p%time else 0) for p in piles)\n        \n        lower = max(sum(piles)//H, 1)\n        upper = max(piles)\n        \n        while lower < upper:\n            time_lower = time_needed(piles, lower)\n            if time_lower <= H:\n                return lower\n            \n            mid = (lower+upper)//2\n            time_mid = time_needed(piles, mid)\n            if time_mid <= H:\n                upper = mid\n            else:\n                lower = mid+1\n                \n        return lower", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def is_valid(speed):\n            curr = 0\n            for n in piles:\n                q, r = divmod(n, speed)\n                if r:\n                    q += 1\n                curr += q\n                if curr > H:\n                    return False\n            return True\n            \n        l, r = 1, max(piles)\n        res = -1\n        while l <= r:\n            m = l + (r - l) // 2\n            if is_valid(m):\n                res = m\n                r = m - 1\n            else:\n                l = m + 1\n        return res", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def possible(K):\n            return sum(math.ceil(p/K) for p in piles) <= H\n        \n        low = 1\n        high = max(piles) + 1\n        \n        while low < high:\n            mid = low + ((high - low) // 2)\n            if possible(mid):\n                high = mid\n            else:\n                low = mid + 1\n                \n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def can_finish(k):\n            h = 0\n            for p in piles:\n                d, r = divmod(p, k)\n                if r:\n                    d += 1\n                h += d\n            return h <= H\n        l = 1\n        r = max(piles)\n        while l < r:\n            m = (l + r) // 2\n            if can_finish(m):\n                r = m\n            else:\n                l = m + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def is_ok(piles, H, mid):\n            sum = 0\n            for i in range(len(piles)):\n                if piles[i] <= mid:\n                    sum += 1\n                else:\n                    sum += math.ceil(piles[i] / mid)\n            return sum <= H\n        \n        ok = sum(piles)\n        ng = 0\n        while (abs(ok - ng) > 1):\n            mid = (ok + ng) // 2\n            if is_ok(piles, H, mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo, hi = 1, 1000000001\n        ans = -1\n        N = len(piles)\n        \n        def poss(val):\n            cnt = 0\n            \n            for n in range(N):\n                cnt += math.ceil(piles[n] / val)\n            \n            if cnt <= H:\n                return True\n            return False\n        \n        \n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if poss(mid):\n                ans = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        return ans\n", "\nclass Solution:\n    def minEatingSpeed(self, piles, H):\n        start = sum(piles)//H+1\n        while start<=max(piles):\n            suplus = sum(map(lambda x:(start - x%start)%start,piles))\n            if suplus + sum(piles) <= start*H:\n                return start\n            else:\n                start += 1\n        return max(piles)", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        lo = max(1, sum(piles) // H)\n        hi = max(piles)\n                    \n        #t_hi = self.time_taken(piles, hi)\n        \n        while lo < hi:\n            \n            mid = (lo + hi) // 2\n            \n            t_lo = self.time_taken(piles, lo)\n            t_mid = self.time_taken(piles, mid)\n            \n            if t_lo <= H:\n                return lo\n            elif t_mid <= H:\n                #hi, t_hi = mid, t_mid\n                hi = mid\n                lo += 1\n            else:\n                lo = mid + 1\n                \n        return lo\n        \n        \n    def time_taken(self, piles, n):\n        \n        return sum(v // n + (1 if v % n else 0) for v in piles)\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time(val):\n            t = len(piles)\n            for pile in piles:\n                t += (pile - 1) // val\n            return t\n        \n        s = sum(piles)\n        l, r = math.ceil(s / H), math.ceil(s / (H - len(piles) + 1))\n        while l <= r:\n            mid = l + (r - l) // 2\n            t = time(mid)\n            if t <= H:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l = max(1,sum(piles)//H)\n        r = max(piles)//(H//len(piles)) + 1\n        # print(l,r)\n        def hours(rate):\n            count = 0\n            for x in piles:\n                count += (x+rate-1)//rate\n            return count\n                \n        while l <= r:\n            mid = (l+r)//2\n            h = hours(mid)\n            if h > H:\n                l = mid+1\n            else:\n                ans = mid\n                r = mid-1\n        return ans   ", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time_needed(time):\n            return sum(p//time + (1 if p%time else 0) for p in piles)\n        \n        lower = max(sum(piles)//H, 1)\n        upper = max(piles)\n        \n        while lower < upper:\n            time_lower = time_needed(lower)\n            if time_lower <= H:\n                return lower\n            \n            mid = (lower+upper)//2\n            time_mid = time_needed(mid)\n            if time_mid <= H:\n                upper = mid\n                lower += 1\n            else:\n                lower = mid+1\n                \n        return lower", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if len(piles) == 1:\n            return piles[0]//H if piles[0]%H == 0 else piles[0]//H + 1\n        \n        l = sum(piles)//H \n        h = max(piles)*len(piles)//H + 1\n        \n        # def feasible(c):\n        #     t = 0\n        #     s = 0\n        #     for n in piles:\n        #         if n <= c: #can finish this pile\n        #             t += 1\n        #         else: \n        #             t += n//c if n%c == 0 else n//c + 1\n        #         #print(n, t)\n        #     if t <= H:\n        #         return True\n        #     return False\n        def feasible(k): #from solution, much shorter and cleaner\n            return sum((p-1)//k + 1 for p in piles) <= H\n        \n        while l < h:\n            mid = (l+h)//2\n            #print(l, h, mid)\n            if feasible(mid):\n                h = mid #search if smaller capacity possible\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lenth = len(piles)\n        s = ((min(piles)-1)*lenth)//H+1 #\u5411\u4e0a\u53d6\u6574\n        m = ((max(piles)-1)*lenth)//H+1\n        if int(m)<m:\n            m=int(m)+1\n        if s==m:return s\n        while s<m:\n            mid = (s+m)//2\n            count = sum([((i - 1) // mid + 1) for i in piles])\n            if count>H:\n                s=mid+1\n            else:\n                m=mid\n        return s\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time_needed(time):\n            return sum(p//time + (1 if p%time else 0) for p in piles)\n        \n        lower = max(1, sum(piles)//H)\n        upper = max(piles)\n        \n        while lower < upper:\n            time_lower = time_needed(lower)\n            if time_lower <= H:\n                return lower\n            \n            lower += 1\n            mid = (lower + upper)//2\n            time_mid = time_needed(mid)\n            if time_mid <= H:\n                upper = mid\n            else:\n                lower = mid + 1\n            \n            \n        return lower\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        k = sum(piles)//H\n        if k == 0: return 1 #if H is more than sum of all piles\n        while True:\n            h = 0\n            prev = k\n            #print(k)\n            for p in piles:\n                print(p,k)\n                if p > 1:\n                    h += (p-1)//k+1\n                else:\n                    h += 1\n                if h > H:\n                    #print(k,h)\n                    break\n            if h <= H:\n                return k \n            k += 1", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def possible(K):\n            return sum(ceil(pile / K) for pile in piles) <= H\n        total = sum(piles)\n        lo, hi = ceil(total / H), ceil(total / (H - len(piles) + 1))\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if possible(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        lo = max(1, sum(piles) // H)\n        hi = max(piles)\n        \n               \n        t_hi = self.time_taken(piles, hi)\n        \n        while lo < hi:\n            \n            mid = (lo + hi) // 2\n            \n            t_lo = self.time_taken(piles, lo)\n            t_mid = self.time_taken(piles, mid)\n            \n            if t_lo <= H:\n                return lo\n            elif t_mid <= H:\n                hi, t_hi = mid, t_mid\n                lo += 1\n            else:\n                lo = mid + 1\n                \n        return lo\n        \n        \n    def time_taken(self, piles, n):\n        \n        return sum(v // n + (1 if v % n else 0) for v in piles)", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n = len(piles)\n        piles.sort()\n        \n        def finish(k): #O(n)\n            return sum((p-1)//k+1 for p in piles)<=H \n            \n        r = 0\n        while r<n:\n            if finish(piles[r]):\n                break\n            else: r += 1\n        \n        # Then binary search K in piles[l] and piles[r]\n        start = 1 if r==0 else piles[0]\n        end = piles[r]\n        \n        while start<end:\n            mid = (start+end)//2\n            if finish(mid):\n                end = mid\n            else:\n                start = mid+1\n        return start\n                \n                \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if not piles:   return 0\n        l,r = 1,max(piles)\n        \n        def canDo(pace):\n            ans = 0\n            for v in piles:\n                ans -= (-v//pace)\n            return ans <= H\n        \n        while l < r:\n            m = (l+r)//2\n            if canDo(m):\n                r = m\n            else:\n                l = m+1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        lo = max(1, sum(piles) // H)\n        hi = max(piles)\n                    \n        t_hi = self.time_taken(piles, hi)\n        \n        while lo < hi:\n            \n            mid = (lo + hi) // 2\n            \n            t_lo = self.time_taken(piles, lo)\n            t_mid = self.time_taken(piles, mid)\n            \n            if t_lo <= H:\n                return lo\n            elif t_mid <= H:\n                hi, t_hi = mid, t_mid\n                lo += 1\n            else:\n                lo = mid + 1\n                \n        return lo\n        \n        \n    def time_taken(self, piles, n):\n        \n        return sum(v // n + (1 if v % n else 0) for v in piles)\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if not piles:   return 0\n        l,r = 1,max(piles)\n        \n        def canDo(k):\n            ans = 0\n            for v in piles:\n                ans -= (-v//k)  #round up\n            return ans <= H\n        \n        while l<r:\n            m = (l+r)//2\n            if canDo(m):\n                r = m\n            else:\n                l = m+1\n        return l\n", "class Solution:\n    def minEatingSpeed(self, piles, H):\n        import math\n        left = 1\n        right = math.ceil(max(piles)*len(piles)/H)\n        while left < right:\n            mid = left + (right - left)//2\n            if self.f(piles, mid) > H:\n                left = mid + 1\n            else:\n                right = mid\n\n        return left\n\n    def f(self, piles, K):\n        import math\n        hours = 0\n        for pile in piles:\n            hours += math.ceil(pile/K)\n        return hours", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        l, r = 1, max(piles)\n        \n        while l < r:\n            mid = l + (r - l) // 2\n            if sum([-pile // mid for pile in piles]) < -H:\n                l = mid + 1\n            else:\n                r = mid\n        \n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        bananas = sum(piles)\n        K = bananas // H + (bananas % H != 0)\n        while True:\n            if sum([pile // K + (pile % K != 0) for pile in piles]) <= H:\n                return K\n            K += 1\n", "## class Solution:\n##     def minEatingSpeed(self, piles: List[int], H: int) -> int:\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H:int) -> int:\n        \n        l, r = 1, max(piles)\n        \n        while l< r:\n            mid = l + (r-l) // 2\n            \n            if sum([-pile // mid for pile in piles]) < -H:\n                \n                l = mid +1\n            \n            else:\n                r = mid\n        return l\n            \n            \n            \n            \n            \n", "class Solution():\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def feasible(speed) -> bool:\n            # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \n            return sum((pile - 1) // speed + 1 for pile in piles) <= H  # faster\n\n        left, right = 1, max(piles)\n        while left < right:\n            mid = left  + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n#SELF TRY 10/7/2020\n# class Solution:\n#     def minEatingSpeed(self, piles: List[int], H: int) -> int:\n#         def eat_speed(K, H):\n#             banana_per_hour = 0 #This is basically the hour it'll take to eat all the bananas. \n#             #Let's say K = 4 \n#             #Pile is 10 \n#             #To eat 4 per hour it takes 3 hours \n#             #You can do pile // K -> 10 // 4 = 2  (8 banana in 2 hours)\n#             #Then pile % K -> 2 remainder is 2 (so since k is 4 then we can eat all the bananas)\n#             for pile in piles: \n#                 banana_per_hour += pile // K\n#                 if pile % K != 0: #You can eat all of it takes an extra hour only \n#                     banana_per_hour += 1 \n#             return banana_per_hour\n            \n            \n            \n#         #inclusive this is what we use for our K value to TRY \n#         left = 1 \n#         right = max(piles) \n        \n#         while left <= right: \n#             K = left + (right - left) // 2 \n#             banana_per_hour = eat_speed(K,H)\n#             if banana_per_hour <= H: #this is fine \n#                 right = K - 1 \n#             else: #banana_per_hour > H #not possible so we need to increase the number of bananas that Koko can eat.\n#                 left = K + 1 \n#         return left \n            \n            \n            \n            \n        \n# class Solution:\n#     def minEatingSpeed(self, piles: List[int], H: int) -> int:\n       \n        \n#         def K_speed(K, piles): \n#             hours_to_eat = 0\n            \n#             for pile in piles: \n#                 hours_to_eat = hours_to_eat + (pile // K)\n#                 if pile % K != 0:\n#                     hours_to_eat += 1\n                    \n                    \n#                 # if pile % K == 0: \n                \n#             return hours_to_eat\n        \n#         #two cases \n#         # 1 < H \n#         #2 == H \n#         left = 1 \n#         right = max(piles)\n#         #other way is inclusive ^ \n#         #but left <= right \n#         # and if that's the case right = K - 1 \n#         #So if you do it <= you know that AT that point hours to eat is <= H we know that there's a possibility of our CURRENT K being a solution\n#         #However in this case you need to do a K - 1 because you are trying to find the next smallest for Koko still eating all bananas.\n#         #Because if our RIGHT becomes < our right we are done \n#         while left < right: \n#             K = left + (right - left) // 2 \n#             if K_speed(K, piles) <= H: \n#                 right = K\n                \n#             else: \n#                 left = K + 1\n               \n                \n#         # LEFT has passed your RIGHT BOUND   \n#         #inclsuvie or exclusive inclsuive w/ one exclusive\n#         #I give you a number that doesn't exist \n#         return left \n    \n    \n    \n#     #BINARY SEARCH \n#     LEFT <= RIGHT: \n        \n        \n        \n#         return LEFT whatever it is your answer \n\n            \n        \n        \n                \n            \n        \n        \n        \n        \n        \n        \n        #monkey eats bananas\n        #there are N piles of bananas \n        #the i-th pile has piles[i] amount of bananas\n        #The guard have gone and will come back in H hours \n        \n        #She has a bananas eating per hour speed K \n        #Each hour she chosses some banans and eats the K bannas in that pile \n        \n#         1) \n        #If the pile has less than K bananas she eats all of them \n        #And won't eat anymore bananas during the hour \n        \n        \n        #Monkey eats slow but needs to finish eating all the bananas before the guard comes back\n        \n        #Return the minimum (int) K s.t she can eat all the bananas within H hours.\n        \n        \n        # \n        #K to try to eat all the piles within that hour \n        \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left = 1\n        right = max(piles)\n        while left <= right:\n            mid = (left + right) //2\n            hours = sum((x - 1) // mid + 1 for x in piles) # \u4ece1\u5f00\u59cb\u9700\u8981-1\n            if hours <= H: # mid\u8d8a\u5927 \uff0c\u9700\u8981\u65f6\u95f4\u8d8a\u77ed\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         def hours(k):\n#             count = 0 \n#             for x in piles:\n#                 count += (x-1)//k + 1 \n#             return count \n        \n#         left = 1\n#         right = max(piles)\n#         while left <= right:\n#             mid = (left + right)//2 \n#             if hours(mid) <= H:  #\n#                 right = mid - 1\n#             else: \n#                 left = mid + 1 \n#         return left \n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         def hours(k):\n#             h = 0\n#             for x in piles:\n#                 h += (x-1)//k + 1\n#             return h \n        \n#         left = 1 \n#         right = max(piles)  # \u6700\u591a\u4e5f\u5c31\u662f\u6bcf\u6b21\u90fd\u5403\u5b8c\n#         while left <= right:\n#             mid = (left + right)//2\n#             if hours(mid) > H:\n#                 left = mid + 1 \n#             else: \n#                 right = mid -1 \n#         return left \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         def hours(k):\n#             h = 0 \n#             for x in piles : \n#                 h += (x-1)//k + 1 \n#             return h \n        \n#         left = 1 \n#         right = max(piles) \n#         while left <= right: \n#             mid = (left + right)//2\n#             if hours(mid) <= H: \n#                 right = mid - 1 \n#             else: left = mid + 1 \n#         return left \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n    \n#         3 6 7 11 \n#         H = 8\n#         sumi = 27 \n#         mini = 4\n#         maxi = max(piles) = 11\n        \n        # 1 2 3 4 5 6 7 8 10 11\n        # func() => \n        # F F F T T T T T T  T \n        mini = 1\n        maxi = max(piles)\n        ans = 0\n        while(mini<=maxi):\n            mid = mini+(maxi-mini)//2\n            value = sum((p-1)//mid + 1 for p in piles)\n            # print(value, mid)\n            if value<=H:\n                ans = mid\n                maxi = mid-1\n            else:\n                mini = mid+1\n        return ans", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # time O(nlogw); space O(1)\n        def possible(k):\n            return sum((num-1) // k + 1 for num in piles) <= H\n        \n        left, right = 1, max(piles)\n        while left < right:\n            mid = (left + right) // 2\n            if not possible(mid):\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left ", "class Solution(object):\n    def minEatingSpeed(self, piles, H):\n        # Can Koko eat all bananas in H hours with eating speed K?\n        def possible(K):\n            return sum((p-1) // K + 1 for p in piles) <= H\n\n        lo, hi = 1, max(piles)\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if not possible(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def can_finish(piles, K, H):\n            return sum([(p + K - 1) // K for p in piles]) <= H\n        \n        low = 1\n        high = max(piles)\n        while low < high:\n            mid = low + (high - low) // 2\n            if can_finish(piles, mid, H):\n                high = mid\n            else:\n                low = mid + 1\n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l, r = 1, max(piles)\n        while l < r:\n            m = (l + r) // 2\n            if sum((p + m - 1) // m for p in piles) > H: l = m + 1\n            else: r = m\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        low, high = 1, max(piles)\n        while low < high:\n            K = low + (high - low) // 2\n            h = sum([(pile - 1) // K + 1 for pile in piles])\n            if h <= H:\n                high = K\n            else:\n                low = K + 1\n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        #bananas = sum(piles)\n        K = sum(piles) // H + (sum(piles) % H != 0)\n        while True:\n            hours_needed = 0\n            for pile in piles:\n                hours_needed += pile // K + (pile % K != 0)\n            if hours_needed <= H:\n                return K\n            K += 1\n", "from math import ceil\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left,right = 1,max(piles)\n        def banana_test(bans):\n            return sum([ceil(pile/bans) for pile in piles])<=H\n        while left < right:\n            mid = left + (right-left)//2\n            if banana_test(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def eats(piles, h, k):\n            hours = 0\n            for pile in piles:\n                hours += ((pile - 1) // k + 1)\n            return hours <= h\n        \n        lo = 1\n        hi = 10**9\n        \n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            \n            if eats(piles, H, mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        return lo\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def possible(k):\n            return sum((num-1) // k + 1 for num in piles) <= H\n            \n        left, right = 1, max(piles)\n        while left < right:\n            print((left, right))\n            mid = (left + right) // 2\n            if not possible(mid):\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # Find the first <= in  [> > > > > <= <=]\n        n = len(piles)\n        low, high = 1, max(piles)\n        while (low + 1) < high:\n            mid = low + ((high - low) // 2)\n            used_hrs = self.calc_hours(piles, mid)\n            if used_hrs > H:\n                low = mid\n            else:\n                high = mid\n                \n        if self.calc_hours(piles, low) <= H:\n            return low\n        if self.calc_hours(piles, high) <= H:\n            return high\n    \n    @staticmethod\n    def calc_hours(piles, K):\n        return sum(((pile - 1) // K + 1) for pile in piles)\n\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # find smallest k that koko can finish in H hours\n        left = 1 \n        right = max(piles)\n        \n        def can(k):\n            return sum((p-1)//k + 1 for p in piles) <= H\n            \n            \n        while left < right:\n            mid = (left + right) //2 # mid=left<right, left=right\n            if can(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return right\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time_used(T):\n            return sum(p//T + (1 if p%T else 0) for p in piles)\n        \n        low = max(sum(piles)//H, 1) \n        if time_used(low) <= H: return low\n        high = max(piles)\n        \n        while low+1 < high:\n            mid = (low + high)//2\n            if time_used(mid) > H:\n                low = mid\n            else:\n                high = mid\n                \n        return high", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # Find the first <= in  [> > > > > <= <=]\n        n = len(piles)\n        low, high = 1, max(piles)\n        while (low + 1) < high:\n            mid = low + ((high - low) // 2)\n            used_hrs = self.calc_hours(piles, mid)\n            if used_hrs > H:\n                low = mid\n            else:\n                high = mid\n                \n        if self.calc_hours(piles, low) <= H:\n            return low\n        if self.calc_hours(piles, high) <= H:\n            return high\n    \n    @staticmethod\n    def calc_hours(piles, K):\n        return int(sum(((pile - 1) // K + 1) for pile in piles))\n\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo, hi = 1, max(piles)\n        \n        while lo<hi:\n            mid=(lo+hi)//2\n            \n            cur_cap, num_hrs = 0, 0\n            for p in piles:\n                cur_cap = p\n                if cur_cap<=mid:\n                    num_hrs+=1\n                else:\n                    num_hrs+=(cur_cap//mid)+1\n\n            if num_hrs>H:\n                lo=mid+1\n            else:\n                hi=mid\n        \n        return lo\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def simulate(k):\n            hours = 0\n            for pile in piles:\n                hours += ceil(pile / k)\n            return hours\n        lower = 1\n        upper = 1\n        for pile in piles:\n            upper = max(upper, pile)\n        while lower < upper:\n            midpoint = (upper + lower) // 2\n            if simulate(midpoint) > H:\n                lower = midpoint + 1\n            else:\n                upper = midpoint\n        return upper", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def possible(K):\n            return sum(math.ceil(p/ K) for p in piles) <= H\n\n        N = len(piles)\n        if H == N:\n            return max(piles)\n        sm = sum(piles)\n        lo, hi = int(sm/H)+1, math.ceil(sm/(H-N))\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if not possible(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return hi\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l, h = 1, max(piles)\n        def canFinish(k):\n            hoursTaken = sum([ceil(p / k) for p in piles])\n            return hoursTaken <= H\n        \n        while l < h:\n            mid = l + (h - l) // 2\n            if canFinish(mid):\n                h = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        low = 1\n        high = max(piles)\n        while low < high:\n            mid = (low + high) // 2\n            if sum(pile // mid + (pile % mid > 0) for pile in piles) > H:\n                low = mid + 1\n            else:\n                high = mid\n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        def can_eat(x: int, h: int) -> bool:\n            hrs = 0\n            for p in piles:\n                if p<=x:\n                    hrs += 1\n                else:\n                    hrs += (p//x)+1\n                if hrs > h: return False\n            # print(x, hrs)\n            return True\n        \n        \n        low, high = 1, max(piles)\n        while low<high:\n            mid = low+((high-low)//2)\n            if can_eat(mid, H):\n                high = mid\n            else:\n                low = mid+1\n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def count(k):\n            \n            hours = 0\n            for i in range(len(piles)):\n                hours += (piles[i] + k - 1) // k\n            return hours\n                \n        l = 1\n        r = 1000000000\n        while l < r:\n            m = l + (r - l) //2\n            if count(m) > H:\n                l = m + 1\n            else:\n                r = m\n        return l\n                \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n\n        def possible(K):\n            #check if it is possible for K bananas to be finished in H hours\n            count = 0\n            \n            for banana in piles:\n                if banana%K==0:\n                    count+=banana/K\n                else:\n                    count += banana//K+1\n            \n            if count <= H:\n                return True\n            else:\n                return False\n                \n        \n        left,right = 1,max(piles)\n        \n        while left<=right:\n            mid = (left + right) //2\n            \n            if possible(mid):\n                right=mid-1\n            else:\n                left=mid+1\n                \n        return left\n", "#SELF TRY 10/7/2020\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def eat_speed(K, H):\n            banana_per_hour = 0\n            for pile in piles: \n                banana_per_hour += pile // K\n                if pile % K != 0: #You can eat all of it \n                    banana_per_hour += 1 \n            return banana_per_hour\n            \n            \n            \n        #inclusive\n        left = 1 \n        right = max(piles) \n        \n        while left <= right: \n            K = left + (right - left) // 2 \n            banana_per_hour = eat_speed(K,H)\n            if banana_per_hour <= H: #this is fine \n                right = K - 1 \n            else: #banana_per_hour > H #not possible \n                left = K + 1 \n        return left \n            \n            \n            \n            \n        \n# class Solution:\n#     def minEatingSpeed(self, piles: List[int], H: int) -> int:\n       \n        \n#         def K_speed(K, piles): \n#             hours_to_eat = 0\n            \n#             for pile in piles: \n#                 hours_to_eat = hours_to_eat + (pile // K)\n#                 if pile % K != 0:\n#                     hours_to_eat += 1\n                    \n                    \n#                 # if pile % K == 0: \n                \n#             return hours_to_eat\n        \n#         #two cases \n#         # 1 < H \n#         #2 == H \n#         left = 1 \n#         right = max(piles)\n#         #other way is inclusive ^ \n#         #but left <= right \n#         # and if that's the case right = K - 1 \n#         #So if you do it <= you know that AT that point hours to eat is <= H we know that there's a possibility of our CURRENT K being a solution\n#         #However in this case you need to do a K - 1 because you are trying to find the next smallest for Koko still eating all bananas.\n#         #Because if our RIGHT becomes < our right we are done \n#         while left < right: \n#             K = left + (right - left) // 2 \n#             if K_speed(K, piles) <= H: \n#                 right = K\n                \n#             else: \n#                 left = K + 1\n               \n                \n#         # LEFT has passed your RIGHT BOUND   \n#         #inclsuvie or exclusive inclsuive w/ one exclusive\n#         #I give you a number that doesn't exist \n#         return left \n    \n    \n    \n#     #BINARY SEARCH \n#     LEFT <= RIGHT: \n        \n        \n        \n#         return LEFT whatever it is your answer \n\n            \n        \n        \n                \n            \n        \n        \n        \n        \n        \n        \n        #monkey eats bananas\n        #there are N piles of bananas \n        #the i-th pile has piles[i] amount of bananas\n        #The guard have gone and will come back in H hours \n        \n        #She has a bananas eating per hour speed K \n        #Each hour she chosses some banans and eats the K bannas in that pile \n        \n#         1) \n        #If the pile has less than K bananas she eats all of them \n        #And won't eat anymore bananas during the hour \n        \n        \n        #Monkey eats slow but needs to finish eating all the bananas before the guard comes back\n        \n        #Return the minimum (int) K s.t she can eat all the bananas within H hours.\n        \n        \n        # \n        #K to try to eat all the piles within that hour \n        \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        l = 1\n        r = max(piles)\n        def findTime(count):\n            hr = 0\n            for p in piles: \n                hr += (p-1)//count+1\n                if hr>H:\n                    return False\n            return True\n        \n        while l<r:\n            mid = l+(r-l)//2\n            if findTime(mid):\n                r = mid\n            else:\n                l = mid+1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def count_hours(k):\n            hours = 0\n            if k == 1:\n                return sum(piles)\n            for p in piles:\n                hours += p//k\n                if p%k != 0:\n                    hours += 1\n            return hours\n        least = 1\n        most = max(piles)\n        \n        while least <= most:\n            mid = (most+least)//2\n            num_hours = count_hours(mid)\n            if num_hours <= H:\n                most = mid -1\n            else:\n                least = mid + 1\n        return least\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n       \n        \n        def K_speed(K, piles): \n            hours_to_eat = 0\n            \n            for pile in piles: \n                hours_to_eat = hours_to_eat + (pile // K)\n                if pile % K != 0:\n                    hours_to_eat += 1\n                    \n                    \n                # if pile % K == 0: \n                \n            return hours_to_eat\n        \n        #two cases \n        # 1 < H \n        #2 == H \n        left = 1 \n        right = max(piles)\n        #other way is inclusive ^ \n        #but left <= right \n        # and if that's the case right = K - 1 \n        #So if you do it <= you know that AT that point hours to eat is <= H we know that there's a possibility of our CURRENT K being a solution\n        #However in this case you need to do a K - 1 because you are trying to find the next smallest for Koko still eating all bananas.\n        while left < right: \n            K = left + (right - left) // 2 \n            if K_speed(K, piles) <= H: \n                right = K\n                \n            else: \n                left = K + 1\n               \n                \n        # LEFT has passed your RIGHT BOUND   \n        #inclsuvie or exclusive inclsuive w/ one exclusive\n        #I give you a number that doesn't exist \n        return left \n    \n    \n    \n#     #BINARY SEARCH \n#     LEFT <= RIGHT: \n        \n        \n        \n#         return LEFT whatever it is your answer \n\n            \n        \n        \n                \n            \n        \n        \n        \n        \n        \n        \n        #monkey eats bananas\n        #there are N piles of bananas \n        #the i-th pile has piles[i] amount of bananas\n        #The guard have gone and will come back in H hours \n        \n        #She has a bananas eating per hour speed K \n        #Each hour she chosses some banans and eats the K bannas in that pile \n        \n#         1) \n        #If the pile has less than K bananas she eats all of them \n        #And won't eat anymore bananas during the hour \n        \n        \n        #Monkey eats slow but needs to finish eating all the bananas before the guard comes back\n        \n        #Return the minimum (int) K s.t she can eat all the bananas within H hours.\n        \n        \n        # \n        #K to try to eat all the piles within that hour \n        \n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left, right = 1, max(piles)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.__getEatHours(piles, mid) <= H:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def __getEatHours(self, piles, speed):\n        hours = 0\n        for p in piles:\n            hours += p // speed\n            if p % speed != 0:\n                hours += 1\n        return hours", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left, right = 1, max(piles)\n        while left <= right:\n            k = left + (right - left) // 2\n            if self.finish(k, piles) <= H: # count time to eat all bananas at speed K\n                right = k - 1\n            else:\n                left = k + 1\n        return left\n    \n    def finish(self, k, piles):\n        res = 0\n        for pile in piles:\n            res += pile // k\n            if pile % k != 0:\n                res += 1\n        return res\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo, hi = 1, max(piles)\n        while lo <= hi:\n            k = lo + (hi - lo) // 2\n            if self.finish(k, piles) <= H: # count time to eat all bananas at speed K\n                hi = k - 1\n            else:\n                lo = k + 1\n        return lo\n    \n    def finish(self, k, piles):\n        res = 0\n        for pile in piles:\n            res += pile // k\n            if pile % k != 0:\n                res += 1\n        return res\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # wants to eat all bananas within H hours\n        # K - speed at which eat banana\n        # can eat up to pile[i] banana\n        # cannot eat 2 piles in 1 hour\n        # return min K to eat all bananas in H hours\n        \n        def get_hours_needed(piles, K):\n            hours_needed = 0\n            for pile in piles:\n                hours_needed += pile // K\n                if pile % K != 0:\n                    hours_needed += 1\n            return hours_needed\n        \n        lo = 1\n        hi = max(piles)\n        \n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            \n            if get_hours_needed(piles, mid) > H:\n                lo = mid + 1\n            else: #hours_needed <= H\n                hi = mid\n        \n        return lo", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        # use binary search to find the correct value\n        maxPile = 0\n        for i in piles:\n            if i > maxPile:\n                maxPile = i\n\n        low = 1\n        high = maxPile\n\n        minVal = maxPile\n        while low <= high:\n            middle = (low + high) // 2\n            numHours = 0\n            for j in piles:\n                numHours += j // middle\n                if j % middle > 0:\n                    numHours += 1\n\n            if numHours <= H:\n                minVal = middle\n                high = middle - 1\n            else:\n                low = middle + 1\n\n        return minVal", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        l, r = 1, max(piles)\n        while l < r:\n            p = l + (r - l) // 2\n            if sum(math.ceil(x / p) for x in piles) > H: l = p+1\n            else: r = p\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n = len(piles)\n        if not n:\n            return -1\n        \n        def binary_search(l, r):\n            nonlocal piles, H\n            while l < r:\n                mid = (l + r) // 2\n                if num_hours(mid) <= H:\n                    r = mid\n                else:\n                    l = mid + 1\n            return l\n        \n        def num_hours(bananas_per_hour):\n            nonlocal piles\n            res = 0\n            for i in piles:\n                if bananas_per_hour >= i:\n                    res += 1\n                    continue\n                res += (i // bananas_per_hour)\n                res += 1 if i % bananas_per_hour else 0\n            return res\n        \n        return binary_search(1, max(piles))\n    \n    \n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def possible(K):\n            return sum(math.ceil(p/K) for p in piles) <= H\n        \n        lo, hi = 1, max(piles)\n        while lo < hi:\n            mid = int(lo + (hi-lo)/2)\n            \n            if not possible(mid):\n                lo = mid+1\n            else:\n                hi = mid\n            \n        return lo", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def helper(speed):\n            h = 0\n            for p in piles:\n                h += math.ceil(p/speed)\n            return h\n        if not piles or len(piles) == 0:\n            return 0\n        start,end = 1,max(piles)\n        while start+1 < end:\n            mid = start + (end-start)//2\n            h = helper(mid)\n            if h <= H:\n                end = mid\n            else:\n                start = mid\n        return start if helper(start) <= H else end", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if H == len(piles):\n            return max(piles)\n        def possible(K):\n            return sum( math.ceil(p/K) for p in piles) <= H\n        lo, hi = 1, max(piles)\n        while lo <hi:\n            print (lo,hi)\n            mi = (lo+hi)//2\n            if not possible(mi):\n                lo = mi+1\n            else:\n                hi = mi\n        return lo", "import math\nclass Solution:\n    \n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        #1 2 3 4 5 6 7 8 9 10 11\n        \n        def possible(x):\n            if(x == 0):\n                return False\n            h = 0\n            for i in piles:\n                h += math.ceil(i/x)\n            return h <= H\n        \n        \n        high = max(piles)\n        low = 1\n        while(low < high):\n            mid = low + (high-low)//2\n            if(possible(mid)):\n                high = mid\n            else:\n                low = mid+1\n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        K = sum(piles) // H\n        if K == 0:\n            K = 1\n        while True:\n            hours_needed = 0\n            for pile in piles:\n                hours_needed += pile // K\n                if pile % K != 0:\n                    hours_needed += 1\n            if hours_needed <= H:\n                return K\n            K += 1\n", "# upper_bound: max(piles)\n# lower_bound: ceil(sum(piles) / H)\n\nimport math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left = math.ceil(sum(piles) / H)\n        right = max(piles)\n        \n        while left <= right:\n            middle = (left + right) // 2\n            if is_valid(piles, H, middle):\n                right = middle - 1\n            else:\n                left = middle + 1\n        \n        return left\n\ndef is_valid(piles, H, speed):\n    hour = 0\n    for pile in piles:\n        hour += math.ceil(pile / speed)\n    return hour <= H\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        if H == len(piles):\n            return max(piles)\n        else:\n            if sum(piles)%H == 0:\n                tempMin = sum(piles)//H\n            else:\n                tempMin = sum(piles)//H+1\n            tempMax = max(piles)\n            while tempMin != tempMax:\n                tempMid = (tempMax-tempMin)//2+tempMin\n                if self.ifOk(piles,H,tempMid):\n                    tempMax = tempMid\n                else:\n                    tempMin = tempMid + 1\n            return tempMin\n    def ifOk(self,piles,H,K):\n        hourNeed = 0\n        for pile in piles:\n            if pile % K == 0:\n                hourNeed = hourNeed + pile // K\n            else:\n                hourNeed = hourNeed + pile // K + 1\n            if hourNeed > H:\n                return False\n        return True", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def canEatAllBananas(speed):\n            count=0\n            for pile in piles:\n                if pile>=speed:\n                    count+=pile//speed\n                if pile%speed!=0:\n                    count+=1\n            return count<=H\n        \n        \n        low=1\n        high=max(piles)\n        \n        while low<=high:\n            mid=low+(high-low)//2\n            if canEatAllBananas(mid):\n                high=mid-1\n            else:\n                low=mid+1\n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def eatingPossible(cap, piles, H):\n            h = 0\n            for pile in piles:\n                h += pile // cap\n                if pile % cap != 0:\n                    h += 1\n                if h > H:\n                    return False\n            return True\n            \n        \n        piles.sort()\n        left = 1\n        right = max(piles)\n        \n        while left < right:\n            mid = left + (right-left)//2\n            if eatingPossible(mid, piles, H):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        total_bananas = sum(piles)\n        left, right = math.ceil(total_bananas / H), max(piles)\n        print(left, right)\n        while left < right:\n            mid = (left + right) // 2\n            if not sum([math.ceil(pile/mid) for pile in piles]) <= H:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        \n        def isValid(k):\n            total = 0\n            for pile in piles:\n                total += math.ceil(pile/k)\n            return total <= H\n        \n        i,j = 1,max(piles)\n        \n        while i < j:\n            mid = i + (j-i)//2\n            if isValid(mid):\n                j = mid\n            else:\n                i = mid+1\n        \n        return i", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        def time(val):\n            t = len(piles)\n            for pile in piles:\n                t += (pile - 1) // val\n            return t\n        \n        s = sum(piles)\n        l, r = math.ceil(s / H), min(max(piles), math.ceil(s / (H - len(piles) + 1)))\n        while l <= r:\n            mid = l + (r - l) // 2\n            t = time(mid)\n            if t <= H:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        \n        def feasible(threshold):\n            count = 0\n            for pile in piles:\n                \n                count += math.ceil(pile/threshold)\n                    \n                if count > H:\n                    return False\n            return True\n        \n        \n        left = 1\n        right = max(piles)\n        \n        while left < right :\n            \n            mid = left + ((right-left)>>1)\n            \n            if feasible(mid):\n                right = mid\n            else: left = mid+1\n                \n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        min_speed = 1\n        max_speed = max(piles)\n        while min_speed <=max_speed :\n            pivot = min_speed + (max_speed - min_speed)//2  \n            r = sum([math.ceil(x/pivot) for x in piles])\n            #r=sum(hours)\n            if r == H:\n                return pivot\n            elif min_speed==max_speed and r>=H:\n                return pivot+1\n            elif r < H:\n                max_speed = pivot-1\n            elif r > H:\n                min_speed = pivot+1\n                \n        return pivot", "import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        left = 1\n        right = max(piles)\n        while(left < right):\n            K = (left+right)//2\n            hours = 0\n            for pile in piles:\n                if(pile <= K):\n                    hours += 1\n                else:\n                    hours += math.ceil(pile/K)\n            if(hours > H):\n                left = K+1\n            else:\n                right = K\n                \n        return left", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        low, high = 1, max(piles)\n        \n        def isPossible(eatRate):\n            total = 0\n            for numBanana in piles:\n                total += ((numBanana-1)//eatRate) + 1\n            return total <= H\n        \n        while low < high:\n            mid = (low + high) // 2\n            if isPossible(mid):\n                high = mid\n            else:\n                low = mid + 1\n                \n        return low", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        n = len(piles)\n        if not n:\n            return -1\n        \n        def binary_search(l, r):\n            nonlocal piles, H \n            while l < r:\n                mid = (l + r) // 2\n                if num_hours(mid) <= H:\n                    r = mid\n                else:\n                    l = mid + 1\n            return l\n            \n        def num_hours(k):\n            nonlocal n, piles\n            res = 0\n            for i in range(n):\n                num = piles[i]\n                if k >= num:\n                    res += 1\n                    continue\n                res += (num // k)\n                res += 1 if (num % k) else 0 \n            return res\n        \n        return binary_search(1, max(piles))\n", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        minK = 1\n        maxK = 0\n        for pile in piles:\n            if pile > maxK:\n                maxK = pile\n\n        low = minK\n        high = maxK\n        mid = (low+high)//2\n\n        while (low < high):\n            testK = mid\n            if (self.validK(piles, H, mid)):\n                high = mid\n            else:\n                low = mid+1\n\n            mid = (low+high)//2\n        return high\n\n    def validK(self, piles, H, eatspeed):\n        hourCount = 0\n        for pile in piles:\n            hoursUsed = ceil(pile/eatspeed)\n            hourCount += hoursUsed\n            if hourCount > H:\n                return False\n\n        return True", "class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        lo = 1\n        hi = max(piles)\n        def ok(K):\n            return sum((1 + (pile - 1) // K) for pile in piles) <= H\n        \n        while lo < hi:\n            mid = (lo + hi) // 2\n            if ok(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"]
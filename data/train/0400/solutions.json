["class Solution:\n     def largestRectangleArea(self, heights):\n         \"\"\"\n         :type heights: List[int]\n         :rtype: int\n         \"\"\"\n         \n         if not heights:\n             return 0\n         stack = [0]\n         heights.append(0)\n         # print(heights)\n         max_area = 0\n         for i in range(len(heights)):\n             # print(stack)\n             if heights[i] >= stack[-1]:\n                 stack.append(heights[i])\n             else:\n                 k = len(stack) - 1\n                 count = 0\n                 while heights[i] < stack[k] and k >= 0:\n                     count += 1\n                     # print(count)\n                     # print(stack[k])\n                     area = count * stack[k]\n                     if max_area < area:\n                         max_area = area\n                     k -= 1\n                     # print(max_area)\n                 stack = stack[:-count] + [heights[i],] * (count + 1)\n                 # print((count + 1) * stack[k])\n                 # if max_area < (count + 1) * heights[i]:\n                     # max_area = (count + 1) * heights[i]\n         return max_area\n", "class Solution:\n \n \tdef largestRectangleArea(self, heights):\n \t\t\"\"\"\n \t\t:type heights: List[int]\n \t\t:rtype: int\n \t\t\"\"\"\n \t\tif not heights:\n \t\t\treturn 0\n \n \t\tmax_area = 0\n \t\tstack = []\n \t\ti = 0\n \t\twhile i < len(heights):\n \t\t\twhile i < len(heights) and (len(stack) == 0 or heights[i] > heights[stack[-1]]):\n \t\t\t\tstack.append(i)\n \t\t\t\ti += 1\n \t\t\ttmp = stack.pop()\n \t\t\tif stack:\n \t\t\t\tarea = heights[tmp] * (i - stack[-1] - 1)\n \t\t\telse:\n \t\t\t\tarea = heights[tmp] * i\n \t\t\tmax_area = max(area, max_area)\n \t\twhile stack:\n \t\t\ttmp = stack.pop()\n \t\t\tif stack:\n \t\t\t\tarea = heights[tmp] * (i - stack[-1] - 1)\n \t\t\telse:\n \t\t\t\tarea = heights[tmp] * i\n \t\t\tmax_area = max(area, max_area)\n \n \t\treturn max_area\n", "class Solution:\n     def largestRectangleArea(self, heights):\n         \"\"\"\n         :type heights: List[int]\n         :rtype: int\n         \"\"\"\n         stack = list()\n         helper_stack = list()\n \n         max_area = 0\n         for i in heights:\n             if not stack:\n                 stack.append(i)\n             else:\n                 if i >= stack[-1]:\n                     stack.append(i)\n                 else:\n                     width = 0\n                     helper_stack.append(i)\n                     while(stack and stack[-1]>i):\n                         width += 1\n                         height = stack.pop()\n                         helper_stack.append(i)\n                         max_area = max(max_area,height*width)\n                     while helper_stack:\n                         stack.append(helper_stack.pop())\n             # print(stack)\n         width = 0\n         # print(stack)\n         while stack:\n             width += 1\n             height = stack.pop()\n             max_area = max(max_area,height*width)\n \n         return max_area", "class Solution:\n     def largestRectangleArea(self, heights):\n         \"\"\"\n         :type heights: List[int]\n         :rtype: int\n         \"\"\"\n         stk = []\n         res = 0\n         for i in range(len(heights)):\n             if len(stk) == 0 or heights[i] >= heights[stk[-1]]:\n                 stk.append(i)\n             else:\n                 end_p = stk[-1]\n                 while len(stk) > 0 and heights[stk[-1]] >= heights[i]:\n                     start_p = stk.pop()\n                     res = max(res, (end_p - start_p + 1) * heights[start_p])\n                 res = max(res, heights[i] * (i - start_p + 1))\n                 heights[start_p] = heights[i]\n                 stk.append(start_p)\n                 stk.append(i)\n             #print(res, stk)\n         \n         if len(stk) > 0:\n             end_p = stk[-1]\n             while len(stk) > 0:\n                 start_p = stk.pop()\n                 res = max(res, (end_p - start_p + 1) * heights[start_p])\n                 #print(res)\n         \n         \n         return res\n                 \n                 \n                     \n             \n         \n", "class Solution:\n     def largestRectangleArea(self, heights):\n         \"\"\"\n         :type heights: List[int]\n         :rtype: int\n         \"\"\"\n         ans, stack = 0, []\n         for i in range(len(heights)):\n             while stack and heights[i] < heights[stack[-1]]:\n                 h = heights[stack.pop()]\n                 w = (i - 1 - stack[-1]) if stack else i\n                 ans = max(ans, h * w)\n             stack.append(i)\n         \n         while stack:\n             h = heights[stack.pop()]\n             w = (len(heights) - 1 - stack[-1]) if stack else len(heights)\n             ans = max(ans, h * w)\n         return ans", "class Solution:\n     def largestRectangleArea(self, heights):\n         n = len(heights)\n         if n == 0:\n             return 0\n         left = [i for i in range(n)]\n \n         right = [i+1 for i in range(n)]\n         print(heights)\n         for i in range(1, n):\n             # indicates the next value to compare\n             cur = i - 1\n             # import pdb\n             # pdb.set_trace()\n             while cur >= 0 and heights[cur] >= heights[i]:\n                 left[i] = left[cur]\n                 cur = left[cur] - 1\n \n         for j in range(n-1, -1, -1):\n             cur = j + 1\n             while cur < n and heights[cur] >= heights[j]:\n                 # import pdb\n                 # pdb.set_trace()\n                 right[j] = right[cur]\n                 cur = right[cur]\n \n         print(left)\n         print(right)\n         max_val = 0\n         for i in range(n):\n             tmp = heights[i] * (right[i] - left[i])\n             if max_val < tmp:\n                 max_val = tmp\n \n         return max_val\n", "class Solution:\n     def largestRectangleArea(self, heights):\n         \"\"\"\n         :type heights: List[int]\n         :rtype: int\n         \"\"\"\n         \n         # # sol1: mono_inc stack\n         # stack = [(-1, 0)]\n         # res = 0\n         # for i, h in enumerate(heights + [0]):\n         #     while stack[-1][1] > h:\n         #         H = stack.pop()[1]\n         #         W = i - stack[-1][0] - 1\n         #         res = max(res, H*W)\n         #     stack.append((i, h))\n         # return res\n         \n         # sol2: left/right(include self) higher neighbors\n         if not heights:\n             return 0\n         N = len(heights)\n         left, right = [1]*N, [1]*N\n         for i in range(1, N):\n             j = i - 1\n             while j >= 0 and heights[j] >= heights[i]:\n                 left[i] += left[j]\n                 j -= left[j]\n         for i in range(N - 1, -1, -1): # \u6ce8\u610f\u964d\u5e8f\u8981\u5199\u5b8c\u6574 -1, -1\n             j = i + 1\n             while j <= N - 1 and heights[j] >= heights[i]:\n                 right[i] += right[j]\n                 j += right[j]\n         return max((l+r-1)*h for l,r,h in zip(left,right,heights))", "class Solution:\n     def largestRectangleArea(self, heights):\n         \"\"\"\n         :type heights: List[int]\n         :rtype: int\n         \"\"\"\n         stack = []\n         ans = 0\n         heights += [-1]\n         for i in range(len(heights)):\n             left = i\n             while 1:\n                 if len(stack)==0:\n                     stack.append((heights[i], left))\n                     break\n                 if stack[-1][0]<heights[i]:\n                     stack.append((heights[i], left))\n                     break\n                 elif stack[-1][0]==heights[i]:\n                     break\n                 else:\n                     ans = (i-stack[-1][1])*stack[-1][0] if (i-stack[-1][1])*stack[-1][0]>ans else ans\n                     left = stack[-1][1]\n                     del stack[-1]\n         return ans"]
["class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        A = [a for i, a in enumerate(A) if all(a not in b for j, b in enumerate(A) if i != j)]\n\n        def memo(f):\n            dic = {}\n\n            def f_alt(*args):\n                if args not in dic:\n                    dic[args] = f(*args)\n                return dic[args]\n            return f_alt\n\n        def merge(w1, w2):\n            for k in range(len(w2), -1, -1):\n                if w1.endswith(w2[:k]):\n                    return w1+w2[k:]\n\n        @memo\n        def find_short(tup, last):\n            if len(tup) == 1:\n                return A[tup[0]]\n            mtup = tuple(t for t in tup if t != last)\n            return min((merge(find_short(mtup, t), A[last]) for t in mtup), key=len)\n\n        tup = tuple(range(len(A)))\n\n        return min((find_short(tup, i) for i in range(len(A))), key=len)\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        N = len(A)\n        def Cost(x, y):\n            cost = len(y)\n            max_similarity = 0\n            for i in range(1, min(len(x), len(y))):\n                if x[-i:] == y[:i]: max_similarity = i\n            return cost - max_similarity\n            \n        g = [[float('inf')] * N for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    cost = Cost(A[i], A[j])\n                    g[i][j] = cost\n                else: g[i][j] = len(A[i])\n                    \n        dp = [[float('inf')] * N for _ in range(1<<N)]\n        parent = [[-1] * N for _ in range(1<<N)]\n        \n        for i in range(N):\n            dp[1<<i][i] = len(A[i])\n        \n        for s in range(1, 1<<N):\n            for i in range(N):\n                if s & (1<<i):  #valid dp[s][i] check\n                    prev = s - (1<<i)\n                    for j in range(N):\n                        if j != i and prev & (1<<j):\n                            cur_cost = dp[prev][j] + g[j][i]\n                            if cur_cost < dp[s][i]:\n                                dp[s][i] = cur_cost\n                                parent[s][i] = j\n                                \n        min_cost = float('inf')\n        ind = -1\n        last_row = dp[2**N - 1]\n        for i in range(N):\n            if last_row[i] < min_cost:\n                min_cost = last_row[i]\n                ind = i\n        \n        s = 2**N - 1\n        res = A[ind]\n        child_ind = ind\n        # print(s, ind)\n        ind = parent[s][ind]\n        s = s - (1<<child_ind)\n        while s and ind >= 0:\n            cost = g[ind][child_ind]\n            pre_len = len(A[ind]) - len(A[child_ind]) + g[ind][child_ind]\n            res = A[ind][:pre_len] + res\n            child_ind = ind\n            # print(s, ind)\n            ind = parent[s][ind]\n            s = s - (1<<child_ind)\n            \n        return res\n            \n                \n                \n                            \n                    \n            \n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        overlaps = [[0 ]*n for x in range(n)]\n        for i, x in enumerate(A):\n            for j, y in enumerate(A):\n                if i != j:\n                    for l in range(min(len(x), len(y)), -1, -1):\n                        if x.endswith(y[:l]):\n                            overlaps[i][j] = l\n                            break\n        dp = [[-1]*n for x in range(1<<n)]\n        parent = [[None]*n for x in range(1<<n)]\n        for mask in range(1, 1<<n):\n            for bit in range(n):\n                if (mask>>bit) &1:\n                    pmask = mask^(1<<bit)\n                    if pmask ==0:\n                        dp[mask][bit] = 0\n                        continue\n                    for i in range(n):\n                        if (pmask>>i)&1:\n                            value = dp[pmask][i] + overlaps[i][bit]\n                            if value > dp[mask][bit]:\n                                dp[mask][bit] = value\n                                parent[mask][bit] = i\n        print(dp)\n        perm = []\n        mask = (1<<n)-1\n        i = 0\n        for j, val in enumerate(dp[-1]):\n            if val > dp[-1][i]:\n                i = j\n        while i is not None:\n            perm.append(i)\n            mask, i = mask^(1<<i), parent[mask][i]\n        \n        perm = perm[::-1]\n        '''\n        seen = [False] *n\n        for x in perm:\n            seen[x] = True\n        perm.extend([i for i in range(n) if not seen[i]])\n        '''\n        \n        \n        ans = [A[perm[0]]]\n        for i in range(1, len(perm)):\n            overlap = overlaps[perm[i-1]][perm[i]]\n            ans.append(A[perm[i]][overlap:])\n        return ''.join(ans)\n        \n", "# https://zxi.mytechroad.com/blog/searching/leetcode-943-find-the-shortest-superstring/\n# \u5c06\u6bcf\u4e2a\u5355\u8bcd\u770b\u4f5c\u662f\u4e00\u4e2a\u8282\u70b9, \u4e24\u4e24\u4e4b\u95f4\u6709\u4e00\u6761\u5e26\u6709\u6743\u91cd\u7684\u6709\u5411\u8def\u5f84, \u6743\u91cd\u8868\u793a\u4e3a\n# g[i][j]: the cost of appending word[j] after word[i]\n# \u5982\u5c06 gcta \u653e\u5728 catg \u540e\u9762\u7684 cost \u4e3a 3 \u56e0\u4e3a\u5b83\u4eec\u6709\u516c\u5171\u5b50\u4e32 g, \u6240\u4ee5\u603b\u957f\u5ea6\u53ea\u9700\u8981\u518d\u589e\u52a0 3\n# \u95ee\u9898\u8f6c\u5316\u4e3a\u4e86\u5728\u4e00\u4e2a\u6709\u5411\u56fe\u91cc, \u4ece\u4efb\u610f\u70b9\u51fa\u53d1\u627e\u5230\u7ecf\u8fc7\u6240\u6709\u70b9\u5404\u4e00\u6b21\u7684\u6700\u77ed\u8def\u5f84\n# dp[s][i]: min cost to visit nodes of s and ends with i (s is a binary string)\n# dp[14][2] is the min cost of visit nodes 1, 2, 3 and ends with 2 (14 = 2^1 + 2^2 + 2^3)\n# \u521d\u59cb\u5316 dp[2^i][i] = len(A[i]), visit A[i] cost len(A[i])\n# dp[s][i] = min(dp[s - 2^i][j] + g[j][i]), \u627e\u5230\u6240\u6709\u7684\u6ca1\u6709\u7ecf\u8fc7\u8282\u70b9 i \u7684\u72b6\u6001, \u7136\u540e\u5c06 i \u63a5\u5728 j \u540e\u9762\n# \u7ed3\u679c\u662f min(dp[2^n - 1][*]), \u904d\u5386\u5b8c\u4e86\u6240\u6709\u7684\u70b9 (2^n - 1) \u7684\u6700\u5c0f cost\n# \u7528 parent[2^i][i] \u6570\u7ec4\u5b58\u50a8\u8282\u70b9 i \u7684\u7236\u8282\u70b9, \u4ee5\u4fbf\u56de\u6eaf\u5f97\u5230\u6700\u7ec8\u7684\u5b57\u7b26\u4e32\n# O(n^2 * 2^n) time complexity, O(n * 2^n) space complexity\nclass Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        \n        def dist(s1, s2):\n            ans = 0\n            for k in range(min(len(s1), len(s2))):\n                if s1[len(s1) - k:] == s2[:k]:\n                    ans = len(s2) - k\n            return ans\n        \n        \n        n = len(A)\n        g = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                g[i][j] = dist(A[i], A[j])\n                g[j][i] = dist(A[j], A[i])\n        \n        parent = [[-1] * n for _ in range(1 << n)]\n        dp = [[float('inf')] * n for _ in range(1 << n)]\n        for i in range(n):\n            dp[1 << i][i] = len(A[i])  # \u521d\u59cb\u5316\u6bcf\u4e2a\u8282\u70b9\u662f\u7b2c\u4e00\u4e2a\u70b9\u7684\u60c5\u51b5\n\n        for s in range(1, 1 << n):\n            for i in range(n):\n                if not (s & (1 << i)):  # \u4ee5\u70b9 i \u4f5c\u4e3a\u7ed3\u5c3e\u5219\u72b6\u6001 s \u5fc5\u987b\u5df2\u7ecf\u8bbf\u95ee\u8fc7 i, \u6240\u4ee5 s \u7684\u7b2c i \u4f4d\u662f 1\n                    continue\n                prev = s - (1 << i)  # \u627e\u5230\u4e0a\u4e00\u4e2a\u72b6\u6001\n                for j in range(n):  # \u5bf9\u4e8e\u6240\u6709\u70b9, \u5c1d\u8bd5\u8ba9\u5b83\u4eec\u4f5c\u4e3a\u4e0a\u4e00\u4e2a\u70b9\n                    if dp[prev][j] + g[j][i] < dp[s][i]:\n                        dp[s][i] = dp[prev][j] + g[j][i]\n                        parent[s][i] = j\n\n        end = dp[-1].index(min(dp[-1]))  # \u627e\u5230\u904d\u5386\u5b8c\u6240\u6709\u70b9\u540e\u7684\u6700\u5c0f cost \u7684\u6700\u7ec8\u8282\u70b9\n        s = (1 << n) - 1  # \u6700\u7ec8\u7684\u72b6\u6001\n        res = ''\n        while s:\n            prev = parent[s][end]\n            if prev < 0:  # \u521d\u59cb\u5316 parent \u4e3a -1, \u5c0f\u4e8e 0 \u8bf4\u660e\u8fd9\u4e2a\u8282\u70b9\u6ca1\u6709\u7236\u8282\u70b9\n                res = A[end] + res\n            else:\n                res = A[end][len(A[end]) - g[prev][end]:] + res\n            s &= ~ (1 << end)  # \u4e0a\u4e00\u4e2a\u72b6\u6001\n            end = prev\n        return res\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        size = len(A)\n        costs = [[0] * size for _ in range(size)]\n        for i in range(size):\n            for j in range(size):\n                if i == j: \n                    costs[i][j] = 0\n                    continue\n                wi, wj = A[i], A[j]\n                si, sj = len(wi), len(wj)\n                costs[i][j] = sj\n                for k in range(1, min(si, sj) + 1):\n                    if wi[-k:] == wj[:k]:\n                        costs[i][j] = sj - k\n        dp = [[20 * 12] * size for _ in range(1 << size)]\n        parent = [[-1] * size for _ in range(1 << size)]\n        for i in range(size):\n            dp[1 << i][i] = len(A[i])\n        for state in range(1, 1 << size):\n            for i in range(size):\n                if state & (1 << i) == 0: continue\n                prev = state - (1 << i)\n                for j in range(size):\n                    if prev & (1 << j) == 0: continue\n                    if dp[state][i] > dp[prev][j] + costs[j][i]:\n                        dp[state][i] = dp[prev][j] + costs[j][i]\n                        parent[state][i] = j\n        minCost = min(dp[-1])\n        index = dp[-1].index(minCost)\n        res = ''\n        state = (1 << size) - 1\n        while state:\n            prevIndex = parent[state][index]\n            if prevIndex < 0: res = A[index] + res\n            else:\n                cost = costs[prevIndex][index]\n                res = A[index][-cost:] + res\n            state -= 1 << index\n            index = prevIndex\n        return res", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def cost(a, b):\n            alen, blen = len(a), len(b)\n            minlen = min(alen, blen)\n            for i in range(minlen - 1,0,-1):\n                if a[alen - i:] == b[:i]:\n                    return blen - i\n            return blen\n        n = len(A)\n        g = [[-1] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if j == i: continue\n                g[i][j] = cost(A[i],A[j])\n\n        dp = [[float('inf')] * n for _ in range(1<<n)]\n        parent = [[-1] * n for _ in range(1<<n)]\n        anslen = float('inf')\n        cur = -1\n        ans = ''\n        for i in range(n):\n            dp[1<<i][i] = len(A[i])\n        for s in range(1, 1<<n):\n            for j in range(n):\n                if (s & (1<<j)) == 0: continue\n                ps = s & ~(1 << j)\n                for i in range(n):\n                    if i == j: continue\n                    if dp[s][j] > dp[ps][i] + g[i][j]:\n                        dp[s][j] = dp[ps][i] + g[i][j]\n                        parent[s][j] = i\n\n        for i in range(n):\n            if anslen > dp[(1<<n)-1][i]:\n                anslen = dp[(1<<n)-1][i]\n                cur = i\n        s = (1 << n) - 1\n        while s > 0:\n            ps = s & ~(1 << cur)\n            parent_node = parent[s][cur]\n            if ps == 0:\n                ans = A[cur] + ans\n            else:\n                curstr = A[cur]\n                ans = curstr[len(curstr) - g[parent_node][cur]:] + ans\n            s = ps\n            cur = parent_node\n        return ans", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def dist(a, b):\n            d = len(b)\n            for i in range(min(len(a), len(b)), 0, -1):\n                if a[-i:] == b[:i]: \n                    d = len(b) - i\n                    break\n            return d\n                \n        n = len(A)\n        g = [[0]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                g[i][j] = dist(A[i], A[j])\n                \n        dp = [[sys.maxsize]*n for _ in range(1<<n)]\n        parent = [[-1]*n for _ in range(1<<n)]\n        for i in range(n): dp[1<<i][i] = len(A[i])\n        for s in range(1, 1<<n):\n            for j in range(n):\n                if not s & (1<<j): continue\n                ps = s & ~(1<<j)\n                for i in range(n):\n                    if dp[ps][i] + g[i][j] < dp[s][j]:\n                        dp[s][j] = dp[ps][i] + g[i][j]\n                        parent[s][j] = i   \n                        \n        j = dp[-1].index(min(dp[-1]))\n        s = (1<<n) - 1\n        ans = ''\n        while s:\n            i = parent[s][j]\n            if i < 0: ans = A[j] + ans\n            else: ans = A[j][(len(A[j])-g[i][j]):] + ans\n            s &= ~(1<<j)\n            j = i\n        return ans\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def dist(a, b):\n            d = len(b)\n            for i in range(1, min(len(a), len(b)) + 1):\n                if a[-i:] == b[:i]:\n                    d = len(b) - i\n            return d\n        \n        n = len(A)\n        g = [[0]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                g[i][j] = dist(A[i], A[j])\n        \n        dp = [[sys.maxsize/2]*n for _ in range(1<<n)]\n        parent = [[-1]*n for _ in range(1<<n)]\n        for i in range(n): dp[1<<i][i] = len(A[i])\n        for s in range(1, 1<<n):\n            for j in range(n):\n                if not s & (1<<j): continue\n                ps = s & ~(1<<j)\n                for i in range(n):\n                    if dp[ps][i] + g[i][j] < dp[s][j]:\n                        dp[s][j] = dp[ps][i] + g[i][j]\n                        parent[s][j] = i\n        \n        j = dp[-1].index(min(dp[-1]))\n        s = (1<<n) - 1\n        ans = ''\n        while s:\n            i = parent[s][j]\n            if i < 0: ans = A[j] + ans\n            else:\n                ans = A[j][(len(A[j]) - g[i][j]):] + ans\n            s &= ~(1<<j)\n            j = i\n        return ans\n        \n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        g = [[0]* n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                g[i][j]=len(A[j])\n                s=0\n                for s in range(min(len(A[i]), len(A[j]))):\n                    if A[i][len(A[i])-s:]==A[j][:s]: \n                        g[i][j]=len(A[j])-s\n        # print(g)\n        dp=[[float('inf')]*(n) for _ in range(2**n)]\n        parent=[[-1]*(n) for _ in range(2**n)]\n        # print(dp[0])\n        for i in range(n):\n            dp[2**i][i]=len(A[i])\n        for s in range(1, 2**n):\n            for i in range(n):\n                if s&(2**i)==0: continue\n                pre= s &~(1<<i)\n                # if pre==0: continue\n                for j in range(n):\n                    if dp[pre][j]+g[j][i]<dp[s][i]:\n                        dp[s][i]=dp[pre][j]+g[j][i]\n                        parent[s][i]=j\n        # print(dp[-1])\n        j = dp[-1].index(min(dp[-1]))\n        s=2**n-1\n        ans = ''\n        while s:\n            i= parent[s][j]\n            # print(i,j)\n            if i<0: ans=A[j]+ans\n            else: \n                ans=A[j][(len(A[j])-g[i][j]):]+ans\n            s&=~(1<<j)\n            j=i\n        return ans\n        \n", "import numpy as np\n\nclass Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:    \n        n = len(A)\n        # g[i][j] length of overlap words between A[i] <-> A[j]\n        g = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                g[i][j] = len(A[j])\n                k = 1\n                while k <= min(len(A[i]), len(A[j])):\n                    if A[i][len(A[i]) - k:] == A[j][:k]:\n                        g[i][j] = len(A[j]) - k\n                    k += 1\n                    \n        # dp[s][i] := min distance to visit nodes (represented as a binary state s)\n        # once and only once and the path ends with node i.\n        # e.g. dp[7][1] is the min distance to visit nodes (0, 1, 2) and ends with node 1,\n        # the possible paths could be (0, 2, 1), (2, 0, 1).\n        dp = [[float('inf')] * n for _ in range(1 << n)]\n        parent = [[-1] * n for _ in range(1 << n)]\n        \n        for i in range(n):\n            dp[1 << i][i] = len(A[i])\n        \n        for s in range(1, 1 << n):\n            for j in range(n):\n                # s doesn't pass j\n                if not (s & (1 << j)):\n                    continue\n                # parent state, before entering j\n                ps = s & ~(1 << j)\n                for i in range(n):\n                    if dp[ps][i] + g[i][j] < dp[s][j]:\n                        dp[s][j] = dp[ps][i] + g[i][j]\n                        parent[s][j] = i\n        \n        j = np.argmin(dp[-1])\n        s = (1 << n) - 1\n        ans = ''\n        while s:\n            i = parent[s][j]\n            if i < 0:\n                ans = A[j] + ans\n            else:\n                ans = A[j][len(A[j]) - g[i][j]:] + ans\n            s &= ~(1 << j)\n            j = i\n    \n            \n        return ans", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        # add string t in the end of string s. cost = # of chars can't be merged.\n        def mergecost(s, t):\n            c = len(t)\n            for i in range(1, min(len(s), len(t))):\n                if s[len(s) - i:] == t[0:i]:\n                    c = len(t) - i\n            return c\n        \n        n = len(A)\n        cost = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                cost[i][j] = mergecost(A[i], A[j])\n                cost[j][i] = mergecost(A[j], A[i])\n        # print('cost = {0}'.format(cost))\n        dp = [[float('inf') for _ in range(n)] for _ in range(1 << n)]\n        parent = [[-1 for _ in range(n)] for _ in range(1 << n)]\n        \n        for i in range(n):\n            dp[1 << i][i] = len(A[i])\n        # print('dp = {0}'.format(dp))\n        \n        for s in range(1, 1 << n):\n            for i in range(n):\n                # s doesn't contain index i.\n                if not (s & (1 << i)):\n                    continue\n                # prev -> i\n                prev = s - (1 << i)\n                for j in range(n):\n                    if dp[s][i] > dp[prev][j] + cost[j][i]:\n                        dp[s][i] = dp[prev][j] + cost[j][i]\n                        parent[s][i] = j\n        # print('dp = {0}'.format(dp))\n        minCost, end = float('inf'), 0\n        for i in range(n):\n            if dp[-1][i] < minCost:\n                minCost = dp[-1][i]\n                end = i\n        # print('end = {0}, dp[-1] = {1}'.format(end, dp[-1]))\n        # the state that all nodes are visited.\n        s = (1 << n) - 1\n        res = ''\n        while s:\n            prev = parent[s][end]\n            if prev < 0:\n                return A[end] + res\n            res = A[end][len(A[end]) - cost[prev][end]:] + res\n            s &= ~(1 << end)\n            end = prev\n        return res\n", "class Solution:\n    # https://www.youtube.com/watch?v=u_Wc4jwrp3Q\n    # time: O(n^2 * 2 ^ n), space(n * 2 ^ n)\n    def shortestSuperstring(self, A: List[str]) -> str:\n        # add string t in the end of string s. cost = # of chars can't be merged.\n        def mergecost(s, t):\n            c = len(t)\n            for i in range(1, min(len(s), len(t))):\n                if s[len(s) - i:] == t[0:i]:\n                    c = len(t) - i\n            return c\n        \n        n = len(A)\n        cost = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                cost[i][j] = mergecost(A[i], A[j])\n                cost[j][i] = mergecost(A[j], A[i])\n        dp = [[float('inf') for _ in range(n)] for _ in range(1 << n)]\n        parent = [[-1 for _ in range(n)] for _ in range(1 << n)]\n        \n        for i in range(n):\n            dp[1 << i][i] = len(A[i])\n        \n        for s in range(1, 1 << n):\n            for i in range(n):\n                # s doesn't contain index i.\n                if not (s & (1 << i)):\n                    continue\n                # connect i to prev set.\n                prev = s - (1 << i)\n                for j in range(n):\n                    if dp[s][i] > dp[prev][j] + cost[j][i]:\n                        dp[s][i] = dp[prev][j] + cost[j][i]\n                        parent[s][i] = j\n        minCost, end = float('inf'), 0\n        for i in range(n):\n            if dp[-1][i] < minCost:\n                minCost = dp[-1][i]\n                end = i\n        # the state that all nodes are visited.\n        s = (1 << n) - 1\n        res = ''\n        while s:\n            prev = parent[s][end]\n            if prev < 0:\n                return A[end] + res\n            res = A[end][len(A[end]) - cost[prev][end]:] + res\n            s &= ~(1 << end)\n            end = prev\n        return res\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        @lru_cache(None)\n        def dp(p, mask):\n            if mask == 0:\n                return 0, 0\n            result = 0\n            k = -1\n            for j in range(n):\n                if not (mask >> j) & 1:\n                    continue\n                l = g[p].get(j, 0)\n                h, x = dp(j,  mask & ~(1 << j))\n                h += l\n                if h >= result:\n                    result = h\n                    k = j\n            return result, k\n        A.insert(0, '*')\n        n = len(A)\n        g = collections.defaultdict(dict)\n        for i in range(n):\n            for j in range(n):\n                if i == j: continue\n                h = min(len(A[i]), len(A[j]))\n                for l in range(h - 1, 0, -1):\n                    if A[i][-l:] == A[j][:l]:\n                        g[i][j] = l\n                        break\n        mask = (1 << n) - 2\n        p = 0\n        result = ''\n        for i in range(1, n):\n            l, x = dp(p, mask)\n            result += A[x][g[p].get(x, 0):]\n            p = x\n            mask = mask & ~(1 << x)\n        return result\n", "# 18:31 - \nclass Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        \n        def extra_to_append(w1, w2):\n            for i in range(len(w1)):\n                if w2.startswith(w1[i:]):\n                    return w2[len(w1) - i:]\n            return w2\n        \n        n = len(A)\n        extra = [[''] * n for _ in range(n)]\n        for (i, j) in itertools.permutations(list(range(n)), 2):\n            extra[i][j] = extra_to_append(A[i], A[j])\n        \n        dp = [[''] * n for _ in range(1 << n)]\n        ret = ''\n        for mask in range(1, 1 << n):\n            for (ci, cw) in enumerate(A):\n                if not mask & (1 << ci):\n                    continue\n                pre_mask = mask & (~(1 << ci))\n                if not pre_mask:\n                    dp[mask][ci] = cw\n                else:\n                    for (pi, pw) in enumerate(A):\n                        if not pre_mask & (1 << pi):\n                            continue\n                        if not dp[mask][ci] or len(dp[mask][ci]) > len(dp[pre_mask][pi]) + len(extra[pi][ci]):\n                            dp[mask][ci] = dp[pre_mask][pi] + extra[pi][ci]\n                if mask == (1 << n) - 1:\n                    ret = dp[mask][ci] if not ret or len(ret) > len(dp[mask][ci]) else ret\n        \n        return ret\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        @lru_cache(None)\n        def dp(p, mask):\n            if mask == 0:\n                return 0, 0\n            result = 0\n            k = -1\n            for j in range(n):\n                if not (mask >> j) & 1:\n                    continue\n                l = g[p].get(j, 0)\n                h, x = dp(j,  mask & ~(1 << j))\n                h += l\n                if h >= result:\n                    result = h\n                    k = j\n            return result, k\n        A.insert(0, '*')\n        n = len(A)\n        g = collections.defaultdict(dict)\n        for i in range(n):\n            for j in range(n):\n                if i == j: continue\n                h = min(len(A[i]), len(A[j]))\n                for l in range(h - 1, 0, -1):\n                    if A[i].endswith(A[j][:l]):\n                        g[i][j] = l\n                        break\n        mask = (1 << n) - 2\n        p = 0\n        result = ''\n        for i in range(1, n):\n            l, x = dp(p, mask)\n            result += A[x][g[p].get(x, 0):]\n            p = x\n            mask = mask & ~(1 << x)\n        return result\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        @lru_cache(None)\n        def dp(i, p, mask):\n            if i == n:\n                return 0, 0\n            result = 0\n            k = -1\n            for j in range(n):\n                if not (mask >> j) & 1:\n                    continue\n                l = g[p].get(j, 0)\n                h, x = dp(i + 1, j,  mask & ~(1 << j))\n                h += l\n                if h >= result:\n                    result = h\n                    k = j\n            return result, k\n        A.insert(0, '*')\n        n = len(A)\n        g = collections.defaultdict(dict)\n        for i in range(n):\n            for j in range(n):\n                if i == j: continue\n                h = min(len(A[i]), len(A[j]))\n                for l in range(h - 1, 0, -1):\n                    if A[i][-l:] == A[j][:l]:\n                        g[i][j] = l\n                        break\n        mask = (1 << n) - 2\n        p = 0\n        result = ''\n        for i in range(1, n):\n            l, x = dp(i, p, mask)\n            result += A[x][g[p].get(x, 0):]\n            p = x\n            mask = mask & ~(1 << x)\n        return result\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        # 20*2**12 = 4092*20 = 80000\n        N = len(A)\n        cost = [\n            [0]*N for _ in range(N)\n        ]\n        for i in range(N):\n            for j in range(N):\n                # cost of adding A[j] to A[i]\n                cost[i][j] = math.inf\n                for k in range(len(A[i])):\n                    if A[j].startswith(A[i][k:]):\n                        cost[i][j] = k+len(A[j])-len(A[i])\n                        break\n                if cost[i][j] == math.inf:\n                    cost[i][j] = len(A[j])\n                    \n        dp = [[math.inf for _ in range(1<<N)] for i in range(N)]\n        for i in range(N):\n            dp[i][1<<i] = len(A[i])\n        backtrack = [\n            [None]*(1<<N) for _ in range(N)\n        ]\n        for i in range(N):\n            backtrack[i][1<<i] = (i, 0)\n            \n        for i in range(1<<N):\n            for j in range(N):\n                if i&(1<<j):\n                    for k in range(N):\n                        if i&(1<<k) and i!=k:\n                            if dp[j][i] > dp[k][i^(1<<j)]+cost[k][j]:\n                                dp[j][i] = dp[k][i^(1<<j)]+cost[k][j]\n                                backtrack[j][i] = (k, i^(1<<j))\n        min_cost = math.inf\n        min_index = -1\n        for i in range(N):\n            if min_cost > dp[i][(1<<N)-1]:\n                min_cost = dp[i][(1<<N)-1]\n                min_index = i\n        mask = (1<<N)-1\n        order = []\n        while mask:\n            order.append(min_index)\n            min_index, mask = backtrack[min_index][mask]\n        order.reverse()\n        \n        answer = []\n        last_i = -1\n        for i in order:\n            if len(answer) == 0:\n                answer.append(A[i])\n            else:\n                answer.append(A[i][-cost[last_i][i]:])\n            last_i = i\n        return ''.join(answer)", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        overlaps = [[0] * n for _ in range(n)]\n        for i, x in enumerate(A):\n            for j, y in enumerate(A):\n                for ans in range(min(len(x), len(y)), -1, -1):\n                    if x.endswith(y[:ans]):\n                        overlaps[i][j] = ans\n                        break\n        \n        maxv = 20 * n + 1\n        dp = [[maxv] * n for _ in range(1 << n)]\n        parent = [[-1] * n for _ in range(1 << n)]\n        \n        for i in range(n):\n            dp[1 << i][i] = len(A[i])\n            \n        for s in range(1, 1 << n):\n            for i in range(n):\n                if not s & (1 << i): continue\n                prev = s - (1 << i)\n                for j in range(n):\n                    if dp[prev][j] + len(A[i]) - overlaps[j][i] < dp[s][i]:\n                        dp[s][i] = dp[prev][j] + len(A[i]) - overlaps[j][i]\n                        parent[s][i] = j\n        \n        path = []\n        s, i = (1 << n) - 1, 0\n        for j in range(1, n):\n            if dp[s][j] < dp[s][i]:\n                i = j\n        path.append(i)\n        while len(path) < n:\n            j = parent[s][i]\n            path.append(j)\n            prev = s ^ (1 << i)\n            s, i = prev, j\n        \n        i = path[-1]\n        res = [A[i]]\n        for j in path[::-1][1:]:\n            res.append(A[j][overlaps[i][j]:])\n            i = j\n        return ''.join(res) ", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        # TSP, DP \n        n = len(A)\n        w = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(min(len(A[i]), len(A[j])), 0, -1):\n                    if A[j].startswith(A[i][-k:]):\n                        w[i][j] = k\n                        break\n        @lru_cache(None)\n        def dp(nodes):\n            if len(nodes) == 2:return A[nodes[0]]\n            end = nodes[-1]\n            end_idx = nodes.index(end) \n            # remove the current ending nodes from nodes[:-1]\n            nodes_wo_end = nodes[:end_idx]+nodes[end_idx+1:-1]\n            # A[end][w[node][end]:] will remove overlap part from the end node.\n            return min((dp(nodes_wo_end +(node, ))+A[end][w[node][end]:]\n                        for node in nodes_wo_end), key=len)\n        return min((dp(tuple(range(n))+(node, )) for node in range(n)), key=len)", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def dist(a, b):\n            d = len(b)\n            for i in range(min(len(a), len(b)), 0, -1):\n                if a[-i:] == b[:i]: return len(b) - i                    \n            return d\n        \n        def build_graph():\n            g = [[0]*n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    g[i][j] = dist(A[i], A[j])\n            return g\n        \n        def get_dp():\n            dp = [[sys.maxsize]*n for _ in range(1<<n)]\n            parent = [[-1]*n for _ in range(1<<n)]\n            for i in range(n): dp[1<<i][i] = len(A[i])\n            for s in range(1, 1<<n):\n                for j in range(n):\n                    if not s & (1<<j): continue\n                    ps = s & ~(1<<j)\n                    for i in range(n):\n                        if dp[ps][i] + g[i][j] < dp[s][j]:\n                            dp[s][j] = dp[ps][i] + g[i][j]\n                            parent[s][j] = i\n            return dp, parent\n        \n        def recover_path():\n            j = dp[-1].index(min(dp[-1]))\n            s = (1<<n) - 1\n            ans = ''\n            while s:\n                i = parent[s][j]\n                if i < 0: ans = A[j] + ans\n                else: ans = A[j][(len(A[j])-g[i][j]):] + ans\n                s &= ~(1<<j)\n                j = i\n            return ans\n        \n        n = len(A)\n        g = build_graph()\n        dp, parent = get_dp()\n        ans = recover_path()\n        return ans\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        w = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(min(len(A[i]), len(A[j])), 0, -1):\n                    if A[j].startswith(A[i][-k:]):\n                        w[i][j] = k\n                        break\n        @lru_cache(None)\n        def dp(nodes):\n            if len(nodes) == 2:return A[nodes[0]]\n            end = nodes[-1]\n            end_idx = nodes.index(end) \n            # remove the current ending nodes from nodes[:-1]\n            nodes_wo_end = nodes[:end_idx]+nodes[end_idx+1:-1]\n            # A[end][w[node][end]:] will remove overlap part from the end node.\n            return min((dp(nodes_wo_end +(node, ))+A[end][w[node][end]:]\n                        for node in nodes_wo_end), key=len)\n        return min((dp(tuple(range(n))+(node, )) for node in range(n)), key=len)        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # n, N = len(A), 1 << len(A)\n        # w = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         for k in range(min(len(A[i]), len(A[j])), 0, -1):\n        #             if A[j].startswith(A[i][-k:]):\n        #                 w[i][j] = k\n        #                 break\n        # f = [[None] * n for _ in range(N)]\n        # for i in range(N):\n        #     for k in (t for t in range(n) if (1 << t) & i):\n        #         i1 = i ^ (1 << k)\n        #         f[i][k] = min([f[i1][j] + A[k][w[j][k] :] \n        #                        for j in filter(lambda x: (1 << x) & i1, range(n))],\n        #                        key=len, default=A[k])                              \n        # return min(filter(None, f[-1]), key=len)        \n", "INF = 1 << 60\nclass Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        \n        # calculate overlap\n        overlap = [[0] * n for _ in range(n)]\n        for i, j in product(range(n), repeat = 2):\n            l = min(len(A[i]), len(A[j]))\n            overlap[i][j] = max(k for k in range(l + 1) if A[i][len(A[i]) - k:] == A[j][:k])\n        \n        # TSP\n        dp = [[INF] * n for _ in range(1 << n)]\n        prev = [[(None, None)] * n for _ in range(1 << n)]\n        \n        for i, S in enumerate(A):\n            dp[1 << i][i] = len(S)\n        \n        for U, i in product(range(1 << n), range(n)):\n            if not U >> i & 1:\n                continue\n            for ni in range(n):\n                if U >> ni & 1:\n                    continue\n                if dp[U | 1 << ni][ni] > dp[U][i] + len(A[ni]) -  overlap[i][ni]:\n                    dp[U | 1 << ni][ni] = dp[U][i] + len(A[ni]) -  overlap[i][ni]\n                    prev[U | 1 << ni][ni] = (U, i)\n        \n        U, i = (1 << n) - 1, min(range(n), key = lambda i : dp[-1][i])\n        res = []\n        while U is not None:\n            res.append(A[i])\n            U, i = prev[U][i]\n        res.reverse()\n        \n        ans = ''\n        for S in res:\n            l = min(len(ans), len(S))\n            k = max(k for k in range(l + 1) if ans[len(ans) - k:] == S[:k])\n            ans += S[k:]\n        return ans", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def dist(a, b):\n            for i in range(min(len(a), len(b)), 0, -1):\n                if a[-i:] == b[:i]: return len(b) - i\n            return len(b)\n            \n        def get_dist():\n            g = [[0]*n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    g[i][j] = dist(A[i], A[j])\n            return g\n        \n        def perform_dp():\n            dp = [[sys.maxsize//2]*n for _ in range(1<<n)]\n            parent = [[-1]*n for _ in range(1<<n)]\n            # init\n            for i in range(n): dp[1<<i][i] = len(A[i])\n            #\n            for s in range(1<<n):\n                for j in range(n):\n                    if not s & (1<<j): continue\n                    ps = s & ~(1<<j)\n                    for i in range(n):\n                        if dp[ps][i] + g[i][j] < dp[s][j]:\n                            dp[s][j] = dp[ps][i] + g[i][j]\n                            parent[s][j] = i\n            return dp, parent\n                            \n        def recover_path():\n            ans = ''\n            j = dp[-1].index(min(dp[-1]))            \n            s = (1<<n) - 1\n            while s:\n                i = parent[s][j]\n                if i < 0: ans = A[j] + ans\n                else: ans = A[j][-g[i][j]:] + ans\n                s &= ~(1<<j)\n                j = i\n            return ans\n        \n        n = len(A)\n        g = get_dist()\n        dp, parent = perform_dp()\n        ans = recover_path()\n        return ans\n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def dist(a, b): # cost to append b to a\n            for i in range(min(len(a), len(b)), 0, -1):\n                if a[-i:] == b[:i]: return len(b) - i\n            return len(b)\n            \n        def build_graph(): # build cost graph\n            graph = [[0]*n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    graph[i][j] = dist(A[i], A[j])\n            return graph\n        \n        def get_dp():\n            dp = [[sys.maxsize/2]*n for _ in range(1<<n)]\n            parent = [[-1]*n for _ in range(1<<n)]\n            for i in range(n): dp[1<<i][i] = len(A[i])\n            for s in range(1<<n):\n                for j in range(n):\n                    if not s & (1<<j): continue\n                    ps = s & ~(1<<j)\n                    for i in range(n):\n                        if dp[ps][i] + g[i][j] < dp[s][j]:\n                            dp[s][j] = dp[ps][i] + g[i][j]\n                            parent[s][j] = i\n            return dp, parent\n        \n        def recover_path():\n            ans = ''\n            j = dp[-1].index(min(dp[-1]))\n            s = (1<<n) - 1\n            while s:\n                i = parent[s][j]\n                if i < 0: ans = A[j] + ans\n                else: ans = A[j][-g[i][j]:] + ans\n                s &= ~(1<<j)\n                j = i\n            return ans\n        \n        n = len(A)\n        g = build_graph()\n        dp, parent = get_dp()\n        ans = recover_path()\n        return ans", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        ''' TSP: DP '''\n        n, N = len(A), 1 << len(A)\n        \n        w = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(min(len(A[i]), len(A[j])), 0, -1):\n                    if A[j].startswith(A[i][-k:]):\n                        w[i][j] = k\n                        break\n        \n        f = [[None] * n for _ in range(N)]\n        for i in range(N):\n            for k in filter(lambda x: (1 << x) & i, range(n)):\n                i1 = i ^ (1 << k)\n                f[i][k] = min([f[i1][j] + A[k][w[j][k] :] \n                               for j in filter(lambda x: (1 << x) & i1, range(n))],\n                               key=len, default=A[k])                              \n        \n        return min(filter(None, f[-1]), key=len)", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        def save(w1,w2):\n            n = len(w1)\n            for i in range(n):\n                if w1[i:] == w2[:n-i]:\n                    return n-i\n            return 0\n        \n        N = len(A)\n        s = [[0] * N for i in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    s[i][j] = save(A[i],A[j])\n        \n        end_state = (1<<N) - 1\n        \n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_state,cur_pos):\n            if cur_state == end_state:\n                return 0,[cur_pos]\n            cur_save = -100\n            pre_pos = 0\n            for pre_pos in range(N):\n                if pre_pos == 0 :\n                    pre_pos_b = 1\n                else:\n                    pre_pos_b = pre_pos_b << 1\n                if pre_pos_b|cur_state == cur_state:\n                    continue\n                if cur_save < s[pre_pos][cur_pos] + DFS(cur_state|pre_pos_b,pre_pos)[0]:\n                    cur_save = s[pre_pos][cur_pos] + DFS(cur_state|pre_pos_b,pre_pos)[0]\n                    path = DFS(cur_state|pre_pos_b,pre_pos)[1] + [cur_pos]\n            return cur_save,path\n        \n        ss = -1\n        pp = []\n        for last_pos in range(N):\n            if not last_pos:\n                last_pos_b = 1\n            else:\n                last_pos_b = last_pos_b << 1\n            if ss < DFS(last_pos_b,last_pos)[0]:\n                ss,pp = DFS(last_pos_b,last_pos)\n\n        res = A[pp[0]]\n        for i in range(1,N):\n            res += A[pp[i]][s[pp[i-1]][pp[i]]:]\n            \n        return res\n                \n", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        # Building the graph\n        graph = [[0] * n for _ in range(n)]\n        for i, word1 in enumerate(A):\n            for j, word2 in enumerate(A):\n                if i == j: continue\n                for k in range(min(len(word1), len(word2)))[::-1]:\n                    if word1[-k:] == word2[:k]:\n                        graph[i][j] = k\n                        break\n        \n        # Recursion. i is a mask to represent the ordering. k is the last node in the ordering.\n        memo = {}\n        def search(i, k):\n            if (i, k) in memo: return memo[i, k]\n            # if not (i & (1 << k)): return ''\n            if i == (1 << k): return A[k]\n            memo[i, k] = ''\n            for j in range(n):\n                if j != k and i & (1 << j):\n                    candidate = search(i ^ (1 << k), j) + A[k][graph[j][k]:]\n                    if memo[i, k] == '' or len(candidate) < len(memo[i, k]):\n                        memo[i, k] = candidate\n            return memo[i, k]\n        \n        # Finding the best\n        res = ''\n        for k in range(n):\n            candidate = search((1 << n) - 1, k)\n            if res == '' or len(candidate) < len(res):\n                res = candidate\n        return res        ", "class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        self.cost = [[0 for j in range(n)] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                w1 = A[i]\n                w2 = A[j]\n                k = min(len(w1), len(w2))\n                while k > 0:\n                    if w1[-k:] == w2[:k]:\n                        break\n                    k -= 1\n                \n                self.cost[i][j] = k\n        \n        self.cache = {}\n        ans = ''\n        for i in range(n):\n            candidate = self.dfs(A, i, (1 << n) - 1)\n            if ans == '' or len(candidate) < len(ans):\n                ans = candidate\n\n        return ans\n    \n    def dfs(self, A, index, cur):\n        if (index, cur) in self.cache:\n            return self.cache[(index, cur)]\n\n        if not ((1 << index) & cur):\n            return ''\n    \n        if cur == (1 << index):\n            return A[index]\n        \n        self.cache[(index, cur)] = ''\n        for i in range(len(A)):\n            if i == index or not ((1 << i) & cur):\n                continue\n            \n            temp = self.dfs(A, i, cur - (1 << index)) + A[index][self.cost[i][index]:]\n            if self.cache[(index, cur)] == '' or len(temp) < len(self.cache[(index, cur)]):\n                self.cache[(index, cur)] = temp\n        \n        return self.cache[(index, cur)]\n", "\n# we can memorize the path while doing dp\n# let dp[used][i] = (string length, actual string) represents the bitmask used ends with ith element.\n\nclass Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        common = {}\n        for i, s1 in enumerate(A):\n            for j in range(i):\n                s2 = A[j]\n                longest1, longest2 = 0, 0\n                for k in range(min(len(s1), len(s2)) + 1):\n                    if s1.endswith(s2[:k]):\n                        longest1 = k\n                    if s2.endswith(s1[: k]):\n                        longest2 = k\n                common[(i, j)] = longest1\n                common[(j, i)] = longest2\n        \n        end = 1 << n\n        dp = [[(float('inf'), '') \n               for i in range(n)] for m in range(end)]\n        le, res = float('inf'), ''\n        for used in range(end):\n            for i, s in enumerate(A):\n                if (used >> i) & 1 != 1:\n                    continue\n                mask = 1 << i\n                if used ^ mask == 0:\n                    dp[used][i] = (len(A[i]), A[i])\n                else:\n                    for j, last in enumerate(A):\n                        if i == j or (used >> j) & 1 != 1:\n                            continue\n                        l, pref = dp[used ^ mask][j]\n                        cand = pref + A[i][common[(j, i)] :]    \n                        if len(cand) < dp[used][i][0]:\n                            dp[used][i] = (len(cand), cand)\n                if used == end - 1 and dp[used][i][0] < le:\n                    le, res = dp[used][i]\n        return res\n\n\n# class Solution:\n    \n#     def addCost(self, from_word, to_word):\n#         n = min(len(from_word), len(to_word))\n#         cost = len(to_word)\n#         for i in range(n):\n#             if from_word[-i-1] == to_word[i]:\n#                 cost -= 1\n#         return cost \n    \n#     def shortestSuperstring(self, A: List[str]) -> str:\n#         # initalize 2D adjacency matrix\n#         n = len(A)\n#         adj_mat = [[0,] * n, ] * n\n#         # travers words list, memo the cost by adj_mat\n#         for i in range(n):\n#             for j in range(n):\n#                 if r != c:\n#                     from_word, to_word = A[i], A[j]\n#                     adj_mat[i][j] = self.addCost(from_word, to_word)\n#         # DP memo, the length of start words as the initial values \n#         # dp = [len(w) for w in A] * n \n#         dp = [0, ] * n\n#         for i, w in enumerate(A):\n#             visited = {w}\n#             dp[i] = len(w)\n#             while len(visited) < n:\n#                 from_w = w\n#                 to_w = min(adj_mat[from_w])\n                \n        \n        \n", "class Solution:\n    def int2arr(self,x,n):\n        arr = []\n        x1 = x\n        for i in range(n):\n            arr.append(x1 % 2)\n            x1 = x1 // 2\n        return arr\n        \n    def arr2int(self,arr):\n        x=0\n        for i in range(len(arr)):\n            x+=arr[i]*2**i\n        return x\n    \n    \n    \n    def shortestSuperstring(self, A: List[str]) -> str:\n        n = len(A)\n        overlap={}\n        for i in range(n):\n            for j in range(n):\n                short = min(len(A[i]),len(A[j]))\n                for k in range(short,-1,-1):\n                    if A[i][(len(A[i])-k):(len(A[i]))]==A[j][0:k]:\n                        break\n                overlap[(i,j)]=k\n        #print(self.int2arr(7,5))\n        #print(self.arr2int([1, 1, 1, 0, 0]))\n        state_order = []\n        for i in range(0,n+2):\n            state_order.append([])\n        for i in range(0,2**(n)):\n            arr = self.int2arr(i,n)\n            #print(i,arr,sum(arr))\n            state_order[sum(arr)].append(i)\n        #print(state_order)\n        \n        m={}\n        conn={}\n        for i in range(n):\n            x = 2**i\n            m[x,i]=len(A[i])\n            conn[x,i]=A[i]\n        for l in range(2,n+1):\n            for x in state_order[l]:\n                arr = self.int2arr(x,n)\n                for end in range(n):\n                    if arr[end]==1:\n                        m[x,end]=100000\n                        x_prev = x-2**end\n                        arr_prev = self.int2arr(x_prev,n)\n                        for prev in range(n):\n                            if arr_prev[prev]==1 and m[x_prev,prev]+len(A[end])-overlap[prev,end]< m[x,end]:\n                                m[x,end] = m[x_prev,prev]+len(A[end])-overlap[prev,end]\n                                conn[x,end]=conn[x_prev,prev]+A[end][overlap[prev,end]:len(A[end])]\n                         \n        ans = 100000\n        for i in range(n):\n            if m[2**n-1,i]<ans:\n                ans = m[2**n-1,i]\n                ans_str = conn[2**n-1,i]\n        \n        return ans_str\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"]
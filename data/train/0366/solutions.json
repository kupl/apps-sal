["class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(sp, k) for sp in s.split(c))\n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         \n         # This works it just exceeds time limit\n         characters = {}\n         separators = set([])\n \n         for char in s:\n             char_count = characters.get(char, 0)\n             characters[char] = char_count + 1\n \n         for char, count in characters.items():\n             if count < k:\n                 separators.add(char)\n \n         for i, char in enumerate(s):\n             if char in separators:\n                 return max(self.longestSubstring(s[0:i].rstrip(char), k), self.longestSubstring(s[i+1:].lstrip(char), k))\n \n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if not s:\n             return 0\n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(t, k) for t in s.split(c))\n         \n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         for i in set(s):\n             if s.count(i)<k:\n                 return max(self.longestSubstring(t,k) for t in s.split(i))\n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if not s:\n             return 0\n         for c in set(s):\n             if s.count(c) < k:\n                 return max([self.longestSubstring(t, k) for t in s.split(c)])\n         \n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         \n         if len(s) < k:\n             return 0\n         \n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(ss, k) for ss in s.split(c))\n             \n         return len(s)\n             \n         \n", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         # str.count is much faster than collections.Counter under certain conditions\n         # collections.Counter is intended to be a general tool\n         # while str.count is much optimized C code to do just one thing \n         # (Counter in Py3 is written in C too)\n         # see this SO question:\n         # https://stackoverflow.com/questions/41594940/why-is-collections-counter-so-slow\n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(sub, k) for sub in s.split(c))\n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(t, k) for t in s.split(c))\n         return len(s)", "class Solution:\n     def longestSubstring(self, s, k):\n         \"\"\"\n         :type s: str\n         :type k: int\n         :rtype: int\n         \"\"\"\n         s_set = set(s)\n         ans = -2147483647\n         for c in s_set:\n             if s.count(c) < k:\n                 return max([self.longestSubstring(_s, k) for _s in s.split(c)])\n         return len(s)\n"]
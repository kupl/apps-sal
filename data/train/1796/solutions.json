["def to_postfix (infix):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3, '(': 0}\n    postfix = []\n    stack = []\n    for ch in infix:\n        if ch in '0123456789':\n            postfix.append(ch)\n        elif ch in '(':\n            stack.append(ch)\n        elif ch in ')':\n            while stack and stack[-1] != '(':\n                postfix.append(stack.pop())\n            stack.pop()\n        else:\n            while stack and prec[stack[-1]] >= prec[ch]:\n                postfix.append(stack.pop())\n            stack.append(ch)\n            \n    while stack:\n        postfix.append(stack.pop())\n    return ''.join(postfix)", "LEFT  = lambda a,b: a>=b\nRIGHT = lambda a,b: a>b\nPREC  = {'+': 2, '-': 2, '*': 3, '/': 3, '^': 4, '(': 1, ')': 1}\n\nOP_ASSOCIATION = {'+': LEFT, '-': LEFT, '*': LEFT, '/': LEFT, '^': RIGHT}\n\n\ndef to_postfix (infix):\n    stack, output = [], []\n    for c in infix:\n        prec = PREC.get(c)\n        \n        if prec is None: output.append(c)\n        elif c == '(':   stack.append(c)\n        elif c == ')':\n            while stack and stack[-1] != '(':\n                output.append( stack.pop() )\n            stack.pop()\n        else:\n            while stack and OP_ASSOCIATION[c](PREC[stack[-1]], prec):\n                output.append( stack.pop() )\n            stack.append(c)\n            \n    return ''.join(output + stack[::-1])", "import ast\n\ndef to_postfix (infix):\n    class PostFixVisitor(ast.NodeVisitor): \n        def visit_BinOp(self, node):\n            self.visit(node.left)\n            self.visit(node.right)\n            self.visit(node.op)\n\n        def visit_Num(self, node):\n            postfix.append(str(node.n))\n            \n        def visit_Add(self, node):\n            postfix.append('+')\n\n        def visit_Sub(self, node):\n            postfix.append('-')\n\n        def visit_Mult(self, node):\n            postfix.append('*')\n\n        def visit_Div(self, node):\n            postfix.append('/')\n\n        def visit_Pow(self, node):\n            postfix.append('^')\n\n    postfix = []\n    p = ast.parse(infix.replace('^', '**'))\n    PostFixVisitor().visit(p)\n    return ''.join(postfix)\n", "#Infix to Postfix Converter: Implements Dijkstra's Shunting-yard algorithm\n\n#simple stack class to be used by the conversion from infix to postfix\nclass Stack(object):\n    def __init__(self):\n        self.stack = []\n\n    def getStack(self):\n        return ''.join(self.stack)\n\n    def peek(self):\n        try:\n            return self.stack[0]\n        except IndexError as e:\n            raise ValueError(e)\n        \n    def isEmpty(self):\n        return len(self.stack)==0\n    \n    def pop(self):\n        try:\n            return self.stack.pop(0)\n        except IndexError as e:\n            raise ValueError(e)\n\n    def push(self, v):\n        self.stack.insert(0, v)\n#end stack class\n\n\n\n#Implements the Shunting-yard algorithm\nclass Ifix2PfixConverter():\n    __EXP_OP = '^'\n    __MUL_OP = '*'\n    __DIV_OP = '/'\n    __ADD_OP = '+'\n    __SUB_OP = '-'\n    __L_PAREN = '('\n    __R_PAREN = ')'\n\n    __precidenceTable = { __EXP_OP : 4,\n                          __MUL_OP : 3, __DIV_OP : 3,\n                          __ADD_OP : 2, __SUB_OP : 2 }\n\n    __associativityTable  = { __EXP_OP : 'right',\n                              __MUL_OP : 'left', __DIV_OP : 'left',\n                              __ADD_OP : 'left', __SUB_OP : 'left' }\n\n    def __init__(self, eqn):\n        self.infixEqn = eqn\n        self.postfixEqn = []\n        self.stack = Stack()\n        self.convertToPostfix()\n\n    def isLeftAssociative(self, k):\n        return 'left' == self.__associativityTable[k]\n\n    def getPostfixEquation(self):\n        return ''.join(self.postfixEqn)\n\n    def isOperator(self, k):\n        return  (k in self.__precidenceTable)\n\n    def precidence(self,k):\n        return self.__precidenceTable[k]\n\n    def isOperand(self, k):\n        return k.isalnum()\n\n    def isLeftParen(self,k):\n        return k==self.__L_PAREN\n\n    def isRightParen(self,k):\n        return k==self.__R_PAREN\n\n\n    #Implementation of Dijkstra's Shunting-yard algorithm\n    def convertToPostfix(self):\n\n        for c in self.infixEqn:\n            if self.isOperand(c):\n                self.postfixEqn.append(c)\n            elif self.isLeftParen(c):\n                self.stack.push(c)\n            elif self.isRightParen(c):\n                while  not self.stack.isEmpty()  and   not self.isLeftParen(self.stack.peek()): \n                    self.postfixEqn.append(self.stack.pop())\n                self.stack.pop() #toss the left parenthesis\n            elif self.isOperator(c):\n                while not self.stack.isEmpty()  and  self.isOperator(self.stack.peek()) \\\n                      and ( (self.precidence(self.stack.peek()) > self.precidence(c))  or (self.precidence(self.stack.peek()) == self.precidence(c) and self.isLeftAssociative(c))):\n                    self.postfixEqn.append(self.stack.pop())\n                self.stack.push(c)\n            else:\n                raise ValueError('Uknown Character [',c,'] Encountered')\n\n        while not self.stack.isEmpty():\n            self.postfixEqn.append(self.stack.pop())\n#---end class\n\ndef to_postfix (infix):\n    converter = Ifix2PfixConverter(infix)\n    return converter.getPostfixEquation()\n#---end function\n", "operand = set(\"0123456789\")\noperator = {'+':1, '-':1, '*':2, '/':2, '^':3}\n\ndef to_postfix (infix):\n    stack, res = [], []\n    for c in \"({})\".format(infix):\n        if c in operand:\n            res.append(c)\n        elif c == '(':\n            stack.append(c)\n        elif c == ')':\n            while stack[-1] != '(':\n                res.append(stack.pop())\n            del stack[-1]\n        elif c in operator:\n            while operator.get(stack[-1], 0) >= operator[c]:\n                res.append(stack.pop())\n            stack.append(c)\n        else:\n            raise Exception(\"Character {} unknown\".format(c))\n    return ''.join(res)", "def to_postfix (infix):\n    postfix = \"\"\n    rop = []\n    priority = []\n    for i, d in enumerate(infix):\n        if d in \"0123456789\":\n            postfix += d\n        elif d == \"(\":\n            priority.append(len(rop))\n        elif d == \")\":\n            priority.pop()\n            postfix += rop.pop()\n        else:\n            if len(rop) > 0 and (len(priority)==0 or len(rop)>priority[-1]):\n                if d in \"+-\":\n                    postfix += \"\".join(rop[::-1])\n                    rop = []\n                elif rop[-1] in \"*/^\":\n                    postfix += rop.pop()\n            rop.append(d)\n    return postfix + \"\".join(rop[::-1])"]
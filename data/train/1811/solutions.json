["class StockSpanner:\n\n    def __init__(self):\n        self.s=[]\n        \n\n    def next(self, price: int) -> int:\n        stk=self.s\n        curr_span=1\n        \n        while stk and stk[-1][0]<=price: #curr_price is > stack[-1][0]\n            prev_price,prev_span=stk.pop()\n            curr_span+=prev_span\n        stk.append((price,curr_span))\n        return curr_span\n            \n            \n        \n            \n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.s = list()\n        \n\n    def next(self, price: int) -> int:\n        weight = 1 \n        stack = self.s\n        while(stack and stack[-1][0] <= price):\n            weight += stack[-1][-1] \n            stack.pop()\n        stack.append((price, weight))\n        return weight \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.span = []\n\n    def next(self, price: int) -> int:\n        res = 1\n        if not self.stack or price < self.stack[-1]:\n            self.stack.append(price)\n            self.span.append(1)\n        else:\n            while self.stack and price >= self.stack[-1]:\n                self.stack.pop()\n                res += self.span.pop()\n            self.stack.append(price)\n            self.span.append(res)\n        return res\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n        \n    def next(self, price: int) -> int:\n        cnt = 1\n        while self.st and price >= self.st[-1][0]:\n            cnt += self.st.pop()[1]\n        self.st.append((price, cnt))\n        print((self.st))\n        return cnt\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stocks = []\n        self.spans = []\n\n    def next(self, price: int) -> int:\n        self.stocks.append(price)\n        self.spans.append(1)\n        if len(self.stocks) == 1:\n            return self.spans[0]\n        idx = len(self.stocks) - 2\n        cur_span = self.spans[-1]\n        while(idx >= 0):\n            if price < self.stocks[idx]:\n                break\n            else:\n                cur_span += self.spans[idx]\n                idx -= self.spans[idx]\n        self.spans[-1] = cur_span\n        return self.spans[-1]\n                \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "'''\n[100, 80, 60, 70, 60, 75, 85]\n[1,    1,  1,  2,  1,  4,  6]\nAssume that the span always has to include the current day.\n\nKeep a stack of where spans start from left to right.\nOn a new price, pop elems from stack until the top is bigger than the current elem.\nThen the top elem is the elem that ends the current day's span.\n\n\n\n'''\n\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = list()\n        self.ix = -1\n\n    def next(self, price: int) -> int:\n        self.ix += 1\n        if not self.stack:\n            self.stack.append((price, self.ix))\n            return 1\n        else:\n            while self.stack and self.stack[-1][0] <= price:\n                self.stack.pop()\n            span_start = self.stack[-1][1] if self.stack else -1\n            self.stack.append((price, self.ix))\n            return self.ix - span_start\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    # Description\n    # - Collect daily price quotes for some stock\n    # - Return the span of that stock's price for the \n    #   current day\n    #   - max number of consecutive days (starting from\n    #     today and going backwards) for which the price of\n    #     the stock was less than or equal to today's price\n    # [1,2,3,3,3,4] => span = [1,2,3,4,5,6]\n    # \n    # conditions\n    # - Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5\n    # - calls <= 10000 to StockSpanner.next per test\n    # - calls <= 150000 to StockSpanner.next across all test cases\n    #\n    # Approach\n\n    def __init__(self):\n        self.history = []\n        self.output = []\n\n    def next(self, price: int) -> int:\n        less_than_count = 1\n        while self.history and self.history[-1][0] <= price:\n            less_than_count += self.history.pop()[1]\n        self.output.append(less_than_count)\n        self.history.append((price, less_than_count))\n        return self.output[-1]\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = [[float('inf'),-1]]\n        self.idx = 0\n        \n\n    def next(self, price: int) -> int:\n        while self.stack and self.stack[-1][0] <= price:\n            self.stack.pop()\n        ans = self.idx-self.stack[-1][1]\n        self.stack.append([price, self.idx])\n        self.idx += 1\n        return ans\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        \n        count = 1\n        \n        while self.stack and price >= self.stack[-1][0]:\n            count += self.stack[-1][1]\n            del self.stack[-1]\n            \n        self.stack.append([price, count])\n        \n        return self.stack[-1][1]\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.idx = 0\n        self.stack.append((float(\\\"inf\\\"),0))\n        \n\n    def next(self, price: int) -> int:\n        self.idx += 1\n        while(self.stack and self.stack[-1][0] <= price):\n            self.stack.pop()\n        self.stack.append((price,self.idx))\n        if(self.idx == 1):\n            return 1\n        else:\n            return self.stack[-1][1] - self.stack[-2][1]\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)", "class StockSpanner:\n\n    def __init__(self):\n        self.q = []\n        \n\n    def next(self, price: int) -> int:\n        if not self.q or self.q[-1][0]>price:\n            self.q.append((price,1))\n            return 1\n        elif self.q and self.q[-1][0] == price:\n            c,l = self.q.pop()\n            self.q.append((price,l+1))\n            return l+1\n        elif self.q:\n            level=1\n            while(self.q and self.q[-1][0]<=price):\n                c,l = self.q.pop()\n                level+=l\n            self.q.append((price,level))\n            return level\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.spanStk = []\n\n    def next(self, price: int) -> int:\n        if len(self.spanStk) == 0:\n            self.spanStk.append((price, 1))\n        else:\n            new_weight = 1\n            while len(self.spanStk) != 0 and self.spanStk[-1][0] <= price:\n                new_weight += self.spanStk[-1][1]\n                self.spanStk.pop()\n            self.spanStk.append((price, new_weight))\n        return self.spanStk[-1][1]\n                \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    '''\n        [100, 80, 60, 70, 60, 75, 85]\n        \n        [100] -> (100, 0, 0)\n        [100, 80] -> (100, 0, 0), (80, 1, 1)\n        [100, 80, 60] -> (100, 0, 0), (80, 1, 1), (60, 2, 2)\n        [100, 80, 60, 70] -> (100, 0, 0), (80, 1, 1), (70, 2, 3)\n        [100, 80, 60, 70, 60] -> (100, 0, 0), (80, 1, 1), (70, 2, 3), (60, 4, 4)\n        [100, 80, 60, 70, 60, 75] -> (100, 0, 0), (80, 1, 1), (75, 2, 5)\n        [100, 80, 60, 70, 60, 75, 85] -> (100, 0, 0), (85, 1, 6)                \n    '''\n\n    def __init__(self):\n        self.stack = list()\n        self.date = 0\n        \n        \n    def next(self, price: int) -> int:\n        if self.date == 0:\n            self.date  += 1\n            self.stack.append([price, 0])\n            return 1\n        else:            \n            s, e = self.date, self.date\n            while len(self.stack) > 0 and self.stack[-1][0] <= price:\n                s = self.stack[-1][1]\n                self.stack.pop()\n            self.stack.append([price, s])\n            self.date += 1\n            return (e - s + 1)\n                \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.arr = []\n\n    def next(self, price: int) -> int:\n        if len(self.arr) == 0:\n            self.arr.append([price, 1])\n            return 1\n        \n        i = len(self.arr) - 1\n        count = 1\n        while i >= 0 and price >= self.arr[i][0]:\n            count += self.arr[i][1]\n            i -= self.arr[i][1]\n        \n        self.arr.append([price, count])\n        return count\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self._data = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        while self._data and self._data[-1][0] <= price:\n            span += self._data.pop()[1]\n\n        self._data.append((price, span))\n        return span\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    '''\n        [100, 80, 60, 70, 60, 75, 85]\n        \n        [100] -> (100, 0, 0)\n        [100, 80] -> (100, 0, 0), (80, 1, 1)\n        [100, 80, 60] -> (100, 0, 0), (80, 1, 1), (60, 2, 2)\n        [100, 80, 60, 70] -> (100, 0, 0), (80, 1, 1), (70, 2, 3)\n        [100, 80, 60, 70, 60] -> (100, 0, 0), (80, 1, 1), (70, 2, 3), (60, 4, 4)\n        [100, 80, 60, 70, 60, 75] -> (100, 0, 0), (80, 1, 1), (75, 2, 5)\n        [100, 80, 60, 70, 60, 75, 85] -> (100, 0, 0), (85, 1, 6)                \n    '''\n\n    def __init__(self):\n        self.stack = list()\n        self.date = 0\n        \n        \n    def next(self, price: int) -> int:      \n        s, e = self.date, self.date\n        while len(self.stack) > 0 and self.stack[-1][0] <= price:\n            s = self.stack[-1][1]\n            self.stack.pop()\n        self.stack.append([price, s])\n        self.date += 1\n        return (e - s + 1)\n                \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.cur = -1\n        self.stack = []\n        self.prices = {}#[]\n        \n\n    def next(self, price: int) -> int:\n        self.cur += 1\n        # self.prices.append(price)\n        self.prices[self.cur] = price\n        while self.stack and self.prices[self.stack[-1]]<=price:\n            self.prices.pop(self.stack.pop())\n        \n        res = self.cur-self.stack[-1] if self.stack else self.cur+1\n        self.stack.append(self.cur)\n        return res\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = [[0,1]]   \n    def next(self, price: int) -> int:\n        if price < self.stack[-1][0]:\n            self.stack.append([price,1])\n            return 1\n        else:\n            days = 0\n            while self.stack and price >= self.stack[-1][0]:\n                p, d = self.stack.pop()\n                days += d # stack previous days\n            try:\n                days +=self.stack[-1][1] \n                self.stack[-1][1] = days # insert\n            except:\n                self.stack.append([0,days])\n            self.stack.append([price,1])\n        return days\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.idx = 0\n        self.q = []\n\n    def next(self, price: int) -> int:\n        self.idx += 1\n        if len(self.q) == 0 or self.q[-1][1] > price:\n            self.q.append([self.idx, price])\n            return 1\n        else:\n            while len(self.q) > 0 and self.q[-1][1] <= price:\n                self.q.pop()\n            if len(self.q) == 0:\n                self.q.append([self.idx, price])\n                return self.idx\n            else:\n                self.q.append([self.idx, price])\n                return self.idx - self.q[-2][0]\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.pre_less = []\n        self.i = 0\n\n    def next(self, price: int) -> int:\n        self.i += 1\n        while self.stack and self.stack[-1][1] <= price:\n            self.stack.pop()\n        \n        result = None\n        if not self.stack:\n            result = self.i\n        else:\n            result = self.i - self.stack[-1][0]\n        self.stack.append((self.i, price))\n        return result\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        self.stack.append([price, 1])\n        \n        while len(self.stack) > 1 and self.stack[-1][0] >= self.stack[-2][0]:\n            self.stack[-2][0] = self.stack[-1][0]\n            self.stack[-2][1] += self.stack[-1][1]\n            del self.stack[-1]\n        return self.stack[-1][1]\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.idx = 0\n        self.q = []\n\n    def next(self, price: int) -> int:\n        self.idx += 1\n        if len(self.q) == 0 or self.q[-1][1] > price:\n            self.q.append([self.idx, price])\n            return 1\n        else:\n            while len(self.q) > 0 and self.q[-1][1] <= price:\n                self.q.pop()\n            if len(self.q) == 0:\n                self.q.append([self.idx, price])\n                return self.idx\n            else:\n                self.q.append([self.idx, price])\n                return self.idx - self.q[-2][0]\n\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    '''\n        [100, 80, 60, 70, 60, 75, 85]\n        \n        [100] -> (100, 0, 0)\n        [100, 80] -> (100, 0, 0), (80, 1, 1)\n        [100, 80, 60] -> (100, 0, 0), (80, 1, 1), (60, 2, 2)\n        [100, 80, 60, 70] -> (100, 0, 0), (80, 1, 1), (70, 2, 3)\n        [100, 80, 60, 70, 60] -> (100, 0, 0), (80, 1, 1), (70, 2, 3), (60, 4, 4)\n        [100, 80, 60, 70, 60, 75] -> (100, 0, 0), (80, 1, 1), (75, 2, 5)\n        [100, 80, 60, 70, 60, 75, 85] -> (100, 0, 0), (85, 1, 6)                \n    '''\n\n    def __init__(self):\n        self.stack = list()\n        self.date = 0\n        \n        \n    def next(self, price: int) -> int:\n        if self.date == 0:\n            self.date  += 1\n            self.stack.append([price, 0, 0])\n            return 1\n        else:            \n            s, e = self.date, self.date\n            while len(self.stack) > 0 and self.stack[-1][0] <= price:\n                s = self.stack[-1][1]\n                self.stack.pop()\n            self.stack.append([price, s, e])\n            self.date += 1\n            return (e - s + 1)\n                \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n\n    def __init__(self):\n        \n        self.stack = []\n        self.ind = 0\n        self.vals = []\n\n    def next(self, price):\n\n        #print(price, self.stack, self.ind, self.vals)\n        \n        self.vals+=[price]\n        \n        while len(self.stack)>0 and self.vals[self.stack[-1]]<=price:\n            self.stack.pop()\n\n        if len(self.stack)>0:\n            res = self.ind - self.stack[-1]\n        else:\n            res = self.ind+1\n\n        self.stack+=[self.ind]\n\n        self.ind+=1\n        \n        #print(\\\"at end \\\", price, self.stack, self.ind, self.vals)\n\n        if self.ind==1:\n            return 1\n\n        return res\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.dp = []\n        self.price = []\n    def next(self, price: int) -> int:\n        if len(self.price)==0 or price<self.price[-1] : \n            self.dp.append(1)        \n        else :\n            i = len(self.price)-1\n            tmp = 1\n            while price>=self.price[i] and i>=0 :\n                tmp += self.dp[i]\n                i -= self.dp[i]\n                \n            self.dp.append(tmp)\n                \n        self.price.append(price)\n        return self.dp[-1]\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.monotone_stack = []\n        \n\n    def next(self, price: int) -> int:\n        stack = self.monotone_stack\n        current_price, current_span = price, 1\n        while stack and stack[-1][0]<=current_price:\n            pre_price, pre_span = stack.pop()\n            current_span+=pre_span\n        stack.append((current_price, current_span))\n        \n        return current_span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n        \n    def next(self, price):\n        span = 1\n        while (len(self.st)>0) and self.st[-1][0] <= price:\n            span = span + self.st[-1][1]\n            self.st.pop()\n        self.st.append((price,span))\n        return span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    # start from back\n    # from collections import deque\n    # queue=deque()\n    \n    def __init__(self):\n        # self.queue=deque()\n        self.stack=[]\n    # if for the prev number is less than price we can just add one to its span, if its preceding bigger price is bigger than curr price\n    def next(self, price: int) -> int:\n        # span=1\n        # stoppage_price=-1\n        # for p,stop_price,s in self.queue:\n        #     if p<=price and stop_price>price:\n        #         span=s+span\n        #         break\n        #     elif p<=price and stop_price<=price:\n        #         span+=1\n        #     else:\n        #         stoppage_price=p\n        #         break\n        # self.queue.appendleft((price,stoppage_price,span))\n        # return span\n        #add to stack\n        # same as above sol but pop off same elements so the worst case is avoided\n        res = 1\n        while self.stack and self.stack[-1][0] <= price:\n            res += self.stack.pop()[1]\n        self.stack.append([price, res])\n        return res\n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    def __init__(self):\n        self.stack = []\n        self.uid = 1\n        \n    def next(self, price):\n        while self.stack and self.stack[-1][0] <= price:\n            self.stack.pop()\n        if self.stack:\n            res = self.uid - self.stack[-1][1]\n        else:\n            res = self.uid\n        self.stack.append([price, self.uid])\n        self.uid += 1\n        return res       ", "class StockSpanner:\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price):\n        res = 1\n        while self.stack and self.stack[-1][0] <= price:\n            res += self.stack.pop()[1]\n        self.stack.append([price, res])\n        return res", "from collections import OrderedDict\nclass StockSpanner(OrderedDict):\n\n    def __init__(self):\n        self.counts = 0\n        \n    def next(self, price: int) -> int:\n        i = len(self) - 1\n        idx = self.counts\n        items = list(self.items())\n        while i >= 0 and items[i][0] <= price:\n            idx = self[items[i][0]]\n            self.popitem(last = True)\n            i -= 1\n        self[price] = idx\n        self.counts += 1\n        return self.counts - idx\n        \n            \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        res = 1\n        while self.stack and price >= self.stack[-1][1]:\n            res += self.stack.pop()[0]\n            \n        self.stack.append((res, price))\n        \n        return res", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.i = 0\n\n    def next(self, price: int) -> int:\n        while self.stack and self.stack[-1][1] <= price:\n            self.stack.pop()\n        index = self.stack[-1][0] if self.stack else -1\n        diff = self.i - index\n        self.stack.append((self.i, price))\n        self.i += 1\n        return diff", "class StockSpanner:\n\n    def __init__(self):\n        \n        self.stack = []\n     \n      \n    def next(self, price: int) -> int:\n        \n        cnt = 1\n        while self.stack and self.stack[-1][0] <= price:\n            \n            p, c = self.stack.pop()\n            cnt += c\n        self.stack.append([price, cnt])\n        \n        return cnt\n            \n            \n", "\nclass StockSpanner:\n\n    def __init__(self):\n        self.prices = []\n        self.spans = []\n        \n    def next(self, price: int) -> int:\n        self.prices.append(price)\n        value = 1\n        index = len(self.spans)-1\n        while(index>=0):\n            if self.prices[index]<=price:\n                value +=self.spans[index]\n                index -=self.spans[index]\n            else:\n                break\n        self.spans.append(value)\n        return value\n        \n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        res = 1\n        while self.stack and self.stack[-1][0] <= price:\n            res += self.stack.pop()[1]\n        self.stack.append([price, res])\n        return res\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "import bisect\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n    def next(self, price: int) -> int:\n        total = 1\n        while self.stack and self.stack[-1][0] <= price:\n            total += self.stack.pop()[1]\n        self.stack.append((price, total))            \n        return total\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n\n    def next(self, price: int) -> int:\n        ans = 1\n        while self.st and price >= self.st[-1][0]:\n            ans += self.st.pop()[1]\n        self.st.append([price, ans])\n        return ans\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.day = 1\n        self.ascendingStack = [(0, float(\\\"inf\\\"))]\n    \n    def next(self, price: int) -> int:\n        while self.ascendingStack[-1][1] <= price:\n            self.ascendingStack.pop()\n            \n        days = self.day - self.ascendingStack[-1][0]\n        self.ascendingStack.append((self.day, price))\n        self.day+=1\n        \n        return days\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack and self.stack[-1][0]<=price:\n            weight += self.stack.pop()[1]\n        \n        self.stack.append([price, weight])\n        return weight\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stock = [] # a list that stores tuples (date_stock_price, span_start_index)\n    \n    def next(self, price: int) -> int:\n        if not self.stock or (price < self.stock[-1][0]):\n            span = 1\n            self.stock.append((price, len(self.stock)))\n        else:\n            i = self.stock[-1][1]-1\n            while i >= 0 and self.stock[i][0] <= price:\n                i -= 1\n            span = len(self.stock) - i\n            self.stock.append((price, i+1))\n        return span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.prices = []\n        self.lastP = 0\n        self.lastCount = 0\n        \n        \n\n    def next(self, price: int) -> int:\n        if len(self.prices) == 0:\n            \n            self.lastCount = 1\n            self.lastP = 0\n            self.prices.append(price)\n            return 1\n        count = self.lastCount\n        #print(self.prices)\n        if price == self.prices[-1]:\n            count +=1\n            self.lastCount = count\n        elif price > self.prices[-1]:\n            count+=1\n            isB = False\n            for i in range(self.lastP-1,-1,-1):\n                if self.prices[i] <= price:\n                    count+=1\n                    self.lastP = i\n                else:\n                    isB = True\n                    break\n            if isB:\n                self.lastP = i+1\n            else:\n                self.lastP = 0\n            self.lastCount = count\n        elif price < self.prices[-1]:\n            count = 1\n            self.lastCount = count\n            self.lastP = len(self.prices)\n        self.prices.append(price)\n        return count\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n\n    def next(self, price: int) -> int:\n        # stack, almost by myself. Idea is simple. Brute force - store prices in stack, and at every new price iterate all over stack. Innefficient!\n        # But we could push to stack price and how much times we occured smaller values. For example, no need to store in stack [1,2,3,4,13], just store stack[13: 5] - and if next price would be greater than 13 - maybe 40 - we just pop 13,5 from stack and append 5 to result. Then push [40,6] to stack\n        # monotonically decreasing stack?\n        # good explanation here - https://leetcode.com/problems/online-stock-span/discuss/168311/C%2B%2BJavaPython-O(1)\n        result = 1\n        while self.stack and self.stack[-1][0] <= price:\n            previous_calculated_result = self.stack.pop()[1]\n            result += previous_calculated_result\n\n        self.stack.append([price, result])\n        print((self.stack))\n        return result\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n\n    def next(self, price: int) -> int:\n        # stack, almost by myself. Idea is simple. Brute force - store prices in stack, and at every new price iterate all over stack. Innefficient!\n        # But we could push to stack price and how much times we occured smaller values. For example, no need to store in stack [1,2,3,4,13], just store stack[13: 5] - and if next price would be greater than 13 - maybe 40 - we just pop 13,5 from stack and append 5 to result. Then push [40,6] to stack\n        # monotonically decreasing stack?\n        result = 1\n        while self.stack and self.stack[-1][0] <= price:\n            previous_calculated_result = self.stack.pop()[1]\n            result += previous_calculated_result\n\n        self.stack.append([price, result])\n        print((self.stack))\n        return result\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n      \n        \n\n    def next(self, price):\n        weight = 1\n        print((self.stack))\n        while self.stack and self.stack[-1][0] <= price:\n            weight += self.stack.pop()[1]\n        self.stack.append((price, weight))\n        return weight\n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        # from collections import defaultdict\n        self.Dict = defaultdict(int)\n        self.s = []\n        self.count = 0\n    def next(self, price: int) -> int:\n        if len(self.s) == 0:\n            self.s.append((self.count, price))\n            self.Dict[(self.count, price)] += 1\n            ans = self.Dict[(self.count, price)]\n            self.count += 1\n            return ans\n        else:\n            while len(self.s) != 0 and price >= self.s[-1][1]:\n                self.Dict[(self.count, price)] += self.Dict[(self.s[-1][0], self.s[-1][1])] \n                self.s.pop(-1)\n            self.s.append((self.count, price))\n            self.Dict[(self.count, price)] += 1\n            ans = self.Dict[(self.count, price)]\n            self.count += 1\n            return ans\n            \n                \n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack and self.stack[-1][0]<=price:\n            weight+=self.stack.pop()[1]\n        self.stack.append((price, weight))\n        return weight\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.prices = []\n        self.counter = []\n        \n\n    def next(self, price: int) -> int:\n        self.prices.append(price)\n        length = len(self.prices)\n        \n        if length == 1:\n            self.counter.append(1)\n            \n        else:\n            if self.prices[-2] <= price:\n                cnt = 0\n                for i in range(length-self.counter[-1]-1, -1,-1):\n                    if self.prices[i] <= price:\n                        cnt += 1\n                    else: \n                        break\n                self.counter.append(self.counter[-1]+cnt)\n            else:\n                self.counter.append(1)\n        return self.counter[-1]\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n    \\\"\\\"\\\"\n    Solution:\n        1. use a stack to store the current max price, and the corresponding span\n        2. comprare the comming price, and merge to the stack if needed\n    Time complexity: O(n)\n    Space complexity: O(n) if the span is always 1\n    \\\"\\\"\\\"\n    def __init__(self):\n        self.stack = []\n        \n\n    def next(self, price: int) -> int:\n        if not self.stack:\n            self.stack.append([price, 1])\n            return self.stack[-1][1]\n        count = 1\n        while self.stack and price >= self.stack[-1][0]:\n            count += self.stack[-1][1]\n            self.stack.pop()\n        self.stack.append([price, count])\n        \n        return self.stack[-1][1]\n            \n        \n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stocks = []\n        self.spans = []\n\n    def next(self, price: int) -> int:\n        if not self.spans:\n            self.spans.append(1)\n            self.stocks.append(price)\n            return 1\n        elif price < self.stocks[-1]:\n            self.spans.append(1)\n            self.stocks.append(price)\n            return 1\n        else:\n            newSpan = self.spans[-1]\n            i = -1 * newSpan - 1\n            while i >= -1 * len(self.stocks) and price >= self.stocks[i]:\n                newSpan += 1\n                i -= 1\n            newSpan += 1\n            self.spans.append(newSpan)\n            self.stocks.append(price)\n            return newSpan\n            \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        count = 1\n        while self.stack and self.stack[-1][0]<=price: count+=self.stack.pop()[1]\n        self.stack.append([price,count])\n        return count\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = [[0,1]]   \n    def next(self, price: int) -> int:\n        if  not self.stack:\n            self.stack.append([price,1])\n            return 1\n        elif self.stack and price < self.stack[-1][0]:\n            self.stack.append([price,1])\n            return 1\n        else:\n            days = 0\n            while self.stack and price >= self.stack[-1][0]:\n                p, d = self.stack.pop()\n                days += d # stack previous days\n            try:\n                days +=self.stack[-1][1] \n                self.stack[-1][1] = days # insert\n            except:\n                self.stack.append([0,days])\n        \n            self.stack.append([price,1])\n            print((self.stack))\n        return days\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack=[]\n        \n\n    def next(self, price: int) -> int:\n        w=1\n        while self.stack and self.stack[-1][0]<=price:\n            w+=self.stack.pop()[1]\n        self.stack.append([price,w])\n        return w\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.monotone_stack = []\n        \n\n    def next(self, price: int) -> int:\n        stack = self.monotone_stack\n        cur_price_quote, cur_price_span = price , 1\n        while stack and stack[-1][0] <= cur_price_quote:\n            prev_price_quote, prev_price_span = stack.pop()\n            cur_price_span += prev_price_span\n        stack.append((cur_price_quote, cur_price_span))\n        return cur_price_span\n\n\n\n\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n    def next(self, price: int) -> int:\n        res = 1\n        i = len(self.stack)\n        while self.stack and self.stack[-1][0] <= price:\n            (x,c) = self.stack.pop()\n            res += c\n        self.stack.append((price,res))\n        return res\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.num = 0\n        self.stack.append((float('inf'), 0))\n\n    def next(self, price: int) -> int:\n        ret = 1\n        self.num += 1\n        while self.stack[-1][0] <= price:\n            self.stack.pop()\n        topIndex = self.stack[-1][1]\n        self.stack.append((price, self.num))\n        return self.num - topIndex\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        \n        self.stack = []\n\n    def next(self, price: int) -> int:\n        \n        days = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            days += self.stack.pop()[1]\n        print((self.stack))\n        self.stack.append((price,days))\n        return days\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\nclass StockSpanner:\n\n    def __init__(self):\n        self.s = []\n        self.i = 0\n\n    def next(self, price: int) -> int:\n        s = self.s\n        i = self.i\n\n        while len(s) and s[-1][0] <= price:\n            s.pop()\n\n        ans = i + 1\n        if len(s):\n            ans = i - s[-1][1]\n        s.append((price, i))\n        self.i += 1\n        return ans\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n\\\"\\\"\\\"\ns = StockSpanner()\n\nprint(s.next(100))\nprint(s.next(80))\nprint(s.next(60))\nprint(s.next(70))\nprint(s.next(60))\nprint(s.next(75))\nprint(s.next(85))\n\\\"\\\"\\\"\n", "class StockSpanner:\n\n    def __init__(self):\n        self.priceList = []\n        self.n=0\n        self.prevSpan = 0\n        self.curSpan = 0\n    def next(self, price: int) -> int:\n        if not self.priceList:\n            self.priceList.append(price)\n            self.n+=1\n            self.curSpan = 1\n            self.prevSpan = self.curSpan\n            return self.curSpan\n        prev = self.priceList[-1]\n        self.priceList.append(price)\n        self.n+=1\n        if price<prev:\n            self.curSpan = 1\n            self.prevSpan = self.curSpan\n            return self.curSpan\n        else:\n            self.curSpan = 1+self.prevSpan\n            i = self.n-self.curSpan-1\n            # if i >= 0:\n            #     cur = priceList[i]\n            while i>=0 and self.priceList[i]<=price:\n                self.curSpan+=1\n                i = self.n-self.curSpan-1\n            self.prevSpan = self.curSpan\n            return self.curSpan\n                \n        \n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        \n        c = 1\n        while self.stack and self.stack[-1][0] <= price:\n            c += self.stack.pop()[1]\n            \n        self.stack.append([price,c])\n        return c\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "from collections import deque\n\nclass StockSpanner:\n\n    def __init__(self):\n        # self.running_count = 0\n        self.stack = deque()\n        \n\n    def next(self, price: int) -> int:\n        \n        weight = 1\n        \n        while self.stack and self.stack[-1][0] <= price:\n            weight += self.stack.pop()[1]\n        \n        self.stack.append((price, weight))\n        \n        return weight\n        \n        \n        \n        \n        \n        \n        \n        \n#         self.running_count += 1\n\n#         if not self.queue:\n#             self.queue.append((price, self.running_count))\n#             return self.running_count \n        \n#         if price < self.queue[-1][0]:\n#             self.queue.append((price, self.running_count))\n#             return 1\n        \n#         else:\n#             while self.queue and price >= self.queue[-1][0]:\n#                 self.queue.pop()\n            \n#             if not self.queue:\n#                 self.queue.append((price, self.running_count))\n#                 return self.running_count\n            \n#             ans = self.running_count - self.queue[-1][1]                    \n#             self.queue.append((price, self.running_count))\n            \n#             return ans\n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner(object):\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price):\n        weight = 1\n        while self.stack and self.stack[-1][0] <= price:\n            weight += self.stack.pop()[1]\n        self.stack.append((price, weight))\n        return weight", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack and self.stack[-1][0] <= price:\n            weight += self.stack.pop()[1]\n        self.stack.append((price, weight))\n        return weight\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.cnt = 0\n\n    def next(self, price: int) -> int:\n        # self.cnt += 1\n        if not self.stack:\n            self.stack.append((price, 1))\n            return 1\n        else:\n            cnt_removed = 1\n            while self.stack and self.stack[-1][0] <= price:\n                cnt_removed += self.stack.pop()[1]\n            self.stack.append((price, cnt_removed))\n            return cnt_removed\n            \n            \n            \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.nums = []\n        self.larger_pos = []\n        \n\n    def next(self, price: int) -> int:\n        if not self.nums:\n            self.nums.append(price)\n            self.larger_pos.append(-1)\n            return 1\n        num = self.nums[-1]\n        pos = len(self.larger_pos) - 1\n        while price >= num:\n            pos = self.larger_pos[pos]\n            if pos == -1:\n                self.nums.append(price)\n                self.larger_pos.append(-1)\n                return len(self.nums)\n            num = self.nums[pos]\n        self.nums.append(price)\n        self.larger_pos.append(pos)\n        return len(self.nums) - 1 - pos\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        # while there is a stack and the top of the stack(aka the previous values) has a value that's less than or equal to the current price\n        while self.stack and self.stack[-1][0] <= price: \n            span = span + self.stack.pop()[1]  # update the span\n        self.stack.append([price, span])\n    \n        return span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n        \n    def next(self, price: int) -> int:\n        cnt = 1\n        while self.st and price >= self.st[-1][0]:\n            cnt += self.st.pop()[1]\n        self.st.append((price, cnt))\n        return cnt\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n\n    def next(self, price: int) -> int:\n        sp = 1\n        while self.st and self.st[-1][0]<=price:\n            sp += self.st.pop()[1]\n        self.st.append([price,sp])\n        return sp\n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack=[]\n        \n\n    def next(self, price: int) -> int:\n        count=1\n        while self.stack and price>=self.stack[-1][0]:\n            count+=self.stack.pop()[1]\n        self.stack.append((price,count))\n        return count\n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class MyStack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, data: int):\n        self.stack.append(data)\n\n    def pop(self) -> int:\n        if self.isEmpty():\n            return \\\"No element in the Stack\\\"\n        else:\n            return self.stack.pop()\n\n    def top(self) -> int:\n        if self.isEmpty():\n            return (\\\"No element in the Stack\\\")\n        else:\n            return self.stack[-1]\n\n    def isEmpty(self) -> bool:\n        return len(self.stack) == 0\n\nclass StockSpanner:\n\n    def __init__(self):\n        self.maxStack = MyStack()\n        self.nums = []\n        self.index = -1\n\n    def next(self, price: int) -> int:\n        self.index += 1\n        while not self.maxStack.isEmpty() and self.nums[self.maxStack.top()] <= price:\n            self.maxStack.pop()\n        if self.maxStack.isEmpty():\n            p = -1\n        else:\n            p = self.maxStack.top()\n        self.maxStack.push(self.index)\n        self.nums.append(price)\n        return self.index - p", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        res = 1\n        while self.stack and self.stack[-1][0] <= price:\n            res += self.stack.pop()[1]\n        self.stack.append([price, res])\n        return res\n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stock = []\n\n    def next(self, price: int) -> int:\n        val = 1\n        while self.stock and self.stock[-1][0] <= price:\n            val += self.stock.pop()[1]\n        \n        self.stock.append((price, val))\n        return val\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price):\n        res = 1\n        while self.stack and self.stack[-1][0] <= price:\n            res += self.stack.pop()[1]\n        self.stack.append([price, res])\n        return res\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack and self.stack[-1][0] <= price:\n            weight += self.stack.pop()[1]\n        self.stack.append((price,weight))\n        return weight\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        count = 1\n        while self.stack and self.stack[-1][0] <= price:\n            s, c = self.stack.pop()\n            count += c\n        self.stack.append((price, count))\n        return count\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stacks = []\n\n    def next(self, price: int) -> int:\n        if len(self.stacks) == 0:\n            self.stacks.append([price,1])\n            return 1\n        else:\n            p = 1\n            while( len(self.stacks) > 0 and  self.stacks[-1][0] <= price):\n                ele = self.stacks.pop()\n                p += ele[1]\n            self.stacks.append([price,p])\n            return p\n            \n                \n            \n        \n        \n\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and price >= self.stack[-1][0]:\n            span += self.stack.pop()[1]\n        self.stack.append((price, span))\n        return span\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.cnt = 0\n\n    def next(self, price: int) -> int:\n        # self.cnt += 1\n        if not self.stack:\n            self.stack.append((price, 1))\n            return 1\n        else:\n            cnt_removed = 1\n            while self.stack and self.stack[-1][0] <= price:\n                node = self.stack.pop()\n                cnt_removed += node[1]\n            self.stack.append((price, cnt_removed))\n            if cnt_removed > 1:\n                return cnt_removed\n            else:\n                return 1\n            \n            \n            \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price):\n        res = 1\n        while self.stack and self.stack[-1][0] <= price:\n            res += self.stack.pop()[1]\n        self.stack.append([price, res])\n        return res\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack and self.stack[-1][0] <= price:\n            weight += self.stack.pop()[1]\n        self.stack.append((price, weight))\n        return weight\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n        \n\n    def next(self, price: int) -> int:\n        idx =1\n        while self.stack and self.stack[-1][0]<= price:\n            idx += self.stack.pop()[1]\n        self.stack.append([price,idx])      \n        return idx\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack != [] and price >= self.stack[-1][0]:\n            weight += self.stack.pop()[1]\n        self.stack.append((price, weight))\n        return weight\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stocks = []\n        self.topStocks = []\n\n    def next(self, price: int) -> int:\n        \n        while(len(self.topStocks)>0 and self.stocks[self.topStocks[-1]] <= price):\n            self.topStocks.pop()\n        flag = self.topStocks[-1] if len(self.topStocks)>0 else -1\n        self.topStocks.append(len(self.stocks))\n        self.stocks.append(price)\n        return len(self.stocks) - flag-1\n            \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack=[]\n        self.len=-2\n        \n\n    def next(self, price: int) -> int:\n        if not self.stack:\n            self.stack.append([price,1])\n            return 1\n        \n        ans=0\n        while(self.stack and self.stack[-1][0]<=price):\n            elm=self.stack.pop()\n            ans+=elm[1]\n        self.stack.append([price,ans+1])\n        return ans+1\n                \n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "\n'''\ncurr=0\n[[inf,0]]\n\n'''\nfrom collections import deque\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack=deque()\n        self.counter=0\n        self.stack.append([float('inf'),0])\n    \n    def update_stack(self,value):\n        while(value>=self.stack[len(self.stack)-1][0]):\n            self.stack.pop()\n\n    def next(self, price: int) -> int:\n        self.counter+=1\n        self.update_stack(price)\n        diff=abs(self.counter-self.stack[len(self.stack)-1][1])\n        self.stack.append([price,self.counter])\n        return diff\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.st = []\n        self.idx = 0\n        \n\n    def next(self, price: int) -> int:\n        while len(self.st) and self.st[-1][0] <= price:\n            self.st.pop()\n        ans = self.idx - (0 if not len(self.st) else self.st[-1][1])+1\n        self.st.append((price, self.idx+1))\n        self.idx += 1\n        return ans\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.prices = []\n        # left[i]: index of first price on the left > prices[i]\n        self.left = []\n\n    def next(self, price: int) -> int:\n        cur = len(self.prices) - 1\n        while cur >= 0 and self.prices[cur] <= price:\n            cur = self.left[cur]\n        \n        self.left.append(cur)\n        self.prices.append(price)\n        return len(self.prices) - 1 - cur\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.prices = []\n        self.decreasing_stack = []\n\n    def next(self, price: int) -> int:\n        while self.decreasing_stack and self.prices[self.decreasing_stack[-1]]<=price:\n            self.decreasing_stack.pop()\n        ret = len(self.prices)-self.decreasing_stack[-1] if self.decreasing_stack else len(self.prices)+1\n        self.decreasing_stack.append(len(self.prices))\n        self.prices.append(price)\n        return ret\n        \n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.s=[]\n        self.O=[]\n        \n\n    def next(self, price: int) -> int:\n        self.s.append(price)\n        o = 0\n        if len(self.s)==1:\n            self.O.append(1)\n            return 1\n        l = len(self.s)\n        i = l-2\n        o =1\n        # print(self.O,self.s,i)\n        while i>=0:\n            # print(self.s[i])\n            if self.s[i]<=price:\n                o+=self.O[i]\n                i-=self.O[i]\n            else:\n                break\n        self.O.append(o)\n        return o\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        self.indx = -1\n        self.results = []\n\n    def next(self, price: int) -> int:\n        self.indx += 1\n        while len(self.stack) > 0 and self.stack[-1][1] <= price:\n            self.stack.pop()\n        if len(self.stack) == 0:\n            self.stack.append([self.indx, price])\n            return self.indx + 1\n        result = self.stack[-1][0]\n        self.stack.append([self.indx, price])\n        \n        return self.indx - result\n            \n            \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n\n    def next(self, price: int) -> int:\n        weight = 1\n        while self.stack and self.stack[-1][0] <= price:\n            _, currentWeight = self.stack.pop()\n            weight += currentWeight\n        self.stack.append((price, weight))\n        return weight\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n\n    def __init__(self):\n        self.s = [float('inf')]\n        self.pos = [0]\n        self.num = 1\n        \n\n    def next(self, price: int) -> int:\n        while self.s and self.s[-1] <= price:\n            self.s.pop()\n            self.pos.pop()\n        r = self.num - self.pos[-1]\n        self.s.append(price)\n        self.pos.append(self.num)\n        self.num += 1\n        return r\n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n"]
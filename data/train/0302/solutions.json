["class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         \n         def length(x,y):\n             return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1])\n    \n         res = []\n         a1 = length(p1,p2)\n         a2 = length(p1,p3)\n         a3 = length(p1,p4)\n         a4 = length(p2,p3)      \n         a5 = length(p2,p4)\n         a6 = length(p3,p4)  \n         res = [a1,a2,a3,a4,a5,a6]   \n         res = sorted(res);\n     \n         for i in range(3):\n             if res[i] == res[i+1]:\n                 continue\n             else:\n                 return False\n         if res[4] != res[5]:\n             return False\n         if res[0] != 0:\n             return True\n         else: \n             return False", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         \n         p1 = [p1[0]*4, p1[1]*4]\n         p2 = [p2[0]*4, p2[1]*4]\n         p3 = [p3[0]*4, p3[1]*4]\n \n         p4 = [p4[0]*4, p4[1]*4]\n \n         \n         center_x = (p1[0] + p2[0] + p3[0] + p4[0]) / 4\n         center_y = (p1[1] + p2[1] + p3[1] + p4[1]) / 4\n         print((center_x, \" \", center_y))\n \n         #if center_x != center_y:\n             #return False\n         #print(center_x, \" \", center_y)\n \n         if p1 == [center_x, center_y]:\n             return False\n         \n         #print(center_x, \" \", center_y)\n         \n         center_to_p1 = [center_x - p1[0], center_y - p1[1]]\n         e_p2 = [(int)(center_x - (center_y - p1[1])), (int)(center_y + (center_x - p1[0]))]\n         e_p3 = [(int)(center_x + center_x - p1[0]), (int)(center_y + center_y - p1[1])]\n         e_p4 = [(int)(center_x + (center_y - p1[1])), (int)(center_y - (center_x - p1[0]))]\n         \n         #print (\"e_p2 \", e_p2, \" e_p3 \", e_p3, \" e_p4 \", e_p4)\n         \n         #print (\"p2 \", p2, \" p3 \", p3, \" p4 \", p4)\n         \n         if (e_p2 == p2 or e_p2 == p3 or e_p2 == p4) and (e_p3 == p2 or e_p3 == p3 or e_p3 == p4) and (e_p4 == p2 or e_p4 == p3 or e_p4 == p4):\n             return True\n         else:\n             return False\n", "class Solution(object):\n     def validSquare(self, p1, p2, p3, p4):\n         points = [p1, p2, p3, p4]\n         \n         dists = collections.Counter()\n         for i in range(len(points)):\n             for j in range(i+1, len(points)):\n                 dists[self.getDistance(points[i], points[j])] += 1\n         \n         return len(list(dists.values()))==2 and 4 in list(dists.values()) and 2 in list(dists.values())\n         \n     def getDistance(self, p1, p2):\n         return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         def distance(m1,m2):\n             x1 = m1[0]\n             y1 = m1[1]\n             x2 = m2[0]\n             y2 = m2[1]\n             return (((y2-y1)**2) + ((x2-x1)**2) )**0.5\n \n         m = [d1,d2,d3,d4,d5,d6] = distance(p1,p2),distance(p2,p3),distance(p3,p4),distance(p4,p1),distance(p2,p4),distance(p3,p1)\n         m = sorted(list(m))\n         print(m)\n         c=0\n         x = m[0]\n         if m[0] ==0.0 and m[1] == 0.0 and m[2] == 0.0 and m[3] == 0.0:\n             return False\n         for i in m:\n             if c == 4:\n                 return True\n             if i == m[0]:\n                 c +=1\n             else:\n                 m[0] = i\n                 c = 0\n         return False\n         \n", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         \n         p1 = [p1[0]*4, p1[1]*4]\n         p2 = [p2[0]*4, p2[1]*4]\n         p3 = [p3[0]*4, p3[1]*4]\n \n         p4 = [p4[0]*4, p4[1]*4]\n \n         \n         center_x = (p1[0] + p2[0] + p3[0] + p4[0]) / 4\n         center_y = (p1[1] + p2[1] + p3[1] + p4[1]) / 4\n         #print(center_x, \" \", center_y)\n \n         #if center_x != center_y:\n             #return False\n         #print(center_x, \" \", center_y)\n \n         if p1 == [center_x, center_y]:\n             return False\n         \n         #print(center_x, \" \", center_y)\n         \n         center_to_p1 = [center_x - p1[0], center_y - p1[1]]\n         e_p2 = [(int)(center_x - (center_y - p1[1])), (int)(center_y + (center_x - p1[0]))]\n         e_p3 = [(int)(center_x + center_x - p1[0]), (int)(center_y + center_y - p1[1])]\n         e_p4 = [(int)(center_x + (center_y - p1[1])), (int)(center_y - (center_x - p1[0]))]\n         \n         #print (\"e_p2 \", e_p2, \" e_p3 \", e_p3, \" e_p4 \", e_p4)\n         \n         #print (\"p2 \", p2, \" p3 \", p3, \" p4 \", p4)\n         \n         if (e_p2 == p2 or e_p2 == p3 or e_p2 == p4) and (e_p3 == p2 or e_p3 == p3 or e_p3 == p4) and (e_p4 == p2 or e_p4 == p3 or e_p4 == p4):\n             return True\n         else:\n             return False\n", "class Solution:\n     def dist(self, p1, p2):\n         return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n     \n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         ps = [p1, p2, p3, p4]\n         ds = []\n         for i in range(3):\n             for j in range(i+1, 4):\n                 ds.append(self.dist(ps[i], ps[j]))\n         ds.sort()\n         return ds[0] > 0 and ds[0] == ds[1] == ds[2] == ds[3] and ds[4] == ds[5]\n", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         \n         p = []\n         for i in range(1,5):\n             p.append( eval('p'+str(i)) )\n         e = {}    \n         for i in range(4):\n             for j in range(4):\n                 for k in range(j+1,4):\n                     if( i== j or i == k or j == k):\n                         continue\n                     dij = (p[i][0] - p[j][0])**2 + (p[i][1] - p[j][1])**2     \n                     dik = (p[i][0] - p[k][0])**2 + (p[i][1] - p[k][1])**2     \n                     djk = (p[j][0] - p[k][0])**2 + (p[j][1] - p[k][1])**2     \n                     if( dij == dik and dij + dik == djk ):\n                         if dij in e:\n                             e[dij] += 1\n                         else:\n                             e[dij] = 1 \n                             \n         for k in e:\n             print((e[k]))\n         if( len(e) != 1 ):\n             return False\n                     \n         for k in e:\n             if e[k] == 4:\n                 return True\n             else:\n                 return False\n                 \n \n", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         ps = sorted([p1,p2,p3,p4])\n         return ps[0][0]+ps[3][0]==ps[1][0]+ps[2][0] and ps[0][1]+ps[3][1]==ps[1][1]+ps[2][1] and ps[2][0]-ps[1][0]==abs(ps[3][1]-ps[0][1]) and not ps[0]==ps[1]\n", "class Solution:\n     def validSquare(self, A, B, C, D):\n         \"\"\"\n         A B   A D   A C\n         C D   B C   D B\n     \n         A C   A B   A D     \n         B D   D C   C B     \n         \n         - figure out which orientation this is\n         - B-A == D-C and C-A == D-B\n         - D-A == C-B and B-A == C-D \n         - C-A == B-D and D-A == B-C\n         \n         - if one of those is true, just need to check angles\n         - check length of two perpendicular sides is same\n             - enough to check -y, x?\n             \n         4     A(2,4)\n         3\n         2 C(0,2)  B(4,2)\n         1\n         0     D(2,0)\n           0 1 2 3 4\n           \n         [1,0]\n         [-1,0]\n         [0,-1]\n         [0,1]\n         \n         1       D\n         \n         0  B         A\n         \n        -1       C\n         \n           -1    0    1\n         \n         \n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         def sub(p2, p1):\n             return [p2[0]-p1[0], p2[1]-p1[1]]\n         \n #         def add(p1, p2):\n #             return [p1[0]+p2[0], p1[1]+p2[1]]\n             \n         if sub(A, B) == [0, 0]:\n             return False\n         \n         if sub(B, A) == sub(D, C) and sub(C, A) == sub(D, B):\n             print((1))\n             diff1 = sub(B, A)\n             diff2 = sub(A, C)\n             print((diff1, diff2))\n             if diff1 == [-diff2[1], diff2[0]] or diff1 == [diff2[1], -diff2[0]]:\n                 return True\n             \n         elif sub(D, A) == sub(C, B) and sub(B, A) == sub(C, D):\n             print((2))\n             diff1 = sub(D, A)\n             diff2 = sub(A, B)\n             print((diff1, diff2))\n             if diff1 == [-diff2[1], diff2[0]] or diff1 == [diff2[1], -diff2[0]]:\n                 return True\n             \n             \n         elif sub(C, A) == sub(B, D) and sub(D, A) == sub(B, C):\n             print((3))\n             diff1 = sub(C, A)\n             diff2 = sub(A, D)\n             print((diff1, diff2))  # [-1, -1] [1, -1]\n             if diff1 == [-diff2[1], diff2[0]] or diff1 == [diff2[1], -diff2[0]]:\n                 return True\n             \n         else:\n             print((0))\n             \n         return False\n             \n         \n", "class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         \"\"\"\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         \"\"\"\n         l = [p1, p2, p3, p4]\n         s = set()\n         for i in range(len(l)):\n             for j in range(i+1, len(l)):\n                 d = self.dist(l[i], l[j])\n                 if d == 0:\n                     return False\n                 s.add(d)\n         return len(s) == 2\n                     \n     \n     def dist(self, a, b):\n         return (a[0] - b[0])**2 + (a[1] - b[1])**2"]
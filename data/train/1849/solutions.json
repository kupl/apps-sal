["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         queue, res = [root], []\n         while any(queue):\n             tmp = []\n             for _ in range(len(queue)):\n                 node = queue.pop(0)\n                 tmp.append(node.val)\n                 if node.left:\n                     queue.append(node.left)\n                 if node.right:\n                     queue.append(node.right)\n             res.append(tmp)\n         return res", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n         level = [root]\n \n         while root and level:\n             res.append([node.val for node in level])\n             level = [child for node in level for child in (node.left, node.right) if child]\n \n         return res\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def traverse(self, root, ordered, level=0):\n         if root.left:\n             self.traverse(root.left, ordered, level=level+1)\n         for create in range(level-len(ordered)+1):\n             ordered.append([])\n         ordered[level].append(root.val)\n         if root.right:\n             self.traverse(root.right, ordered, level=level+1)\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         ordered = [[]]\n         self.traverse(root, ordered, level=0)\n         return ordered", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         result = []\n         if not root:\n             return result\n         curr_level = [root]\n         while curr_level:\n             level_result = []\n             next_level = []\n             for temp in curr_level:\n                 level_result.append(temp.val)\n                 if temp.left:\n                     next_level.append(temp.left)\n                 if temp.right:\n                     next_level.append(temp.right)\n             result.append(level_result)\n             curr_level = next_level\n         return result\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         q = [(0, root)]\n         res = [[]]\n         while q:\n             level, node = q.pop()\n             if level > len(res) - 1:\n                 res.append([node.val])\n             else:\n                 res[level] += [node.val]\n             if node.left:\n                 q.insert(0,(level + 1, node.left))\n             \n             if node.right:\n                 q.insert(0, (level + 1, node.right))\n         return res", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root == None:\n             return []\n         \n         queue = collections.deque()\n         \n         reslist = []\n         \n         queue.append(root)\n         \n         while queue:\n             level = []\n             for i in range(len(queue)):\n                 node = queue.popleft()\n                 level.append(node.val)\n                 if node.left != None:\n                     queue.append(node.left)\n                 if node.right != None:\n                     queue.append(node.right)\n             reslist.append(level)\n         \n         return reslist", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         queue = [root]\n         result = []\n         while len(queue) > 0:\n             k = len(queue)\n             sublist = []\n             for i in range(k):\n                 node = queue.pop(0)\n                 sublist.append(node.val)\n                 if node.left is not None:\n                     queue.append(node.left)\n                 if node.right is not None:\n                     queue.append(node.right)\n             result.append(sublist)\n         return result\n                     ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         vals = []\n         self.traverse(root, vals, 0)\n         return vals\n         \n     def traverse(self, node, vals, depth):\n         if node is None:\n             return\n         self.traverse(node.left, vals, depth + 1)\n         while len(vals) - 1 < depth:\n             #print(depth)\n             vals.append([])\n         vals[depth].append(node.val)   \n         self.traverse(node.right, vals, depth + 1)\n         return\n \n             \n \n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n import queue\n class Solution:\n     \n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root == None:\n             return []\n         ret = []\n         bfs = []\n         bfs.append(root)\n         cur = 0\n         nextl = len(bfs)\n         \n         while (cur<nextl):\n             cur_level = []\n             for i in range(cur,nextl):\n                 cur_node = bfs[i]\n                 if cur_node.left != None:\n                     bfs.append(cur_node.left)\n                 if cur_node.right != None:\n                     bfs.append(cur_node.right)            \n                 cur_level.append(bfs[i].val)\n             ret.append(cur_level)\n             cur,nextl = nextl, len(bfs)\n         return ret\n             \n     \n     \n         \n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n         if not root:\n             return res\n         \n         stack = [root]\n         row = [root.val]\n         \n         while stack:\n             res += [row]\n             tempstack = []\n             temprow = []\n             \n             for n in stack:\n                 if n.left:\n                     tempstack += [n.left]\n                     temprow += [n.left.val]\n                 if n.right:\n                     tempstack += [n.right]\n                     temprow += [n.right.val]\n             row = temprow\n             stack = tempstack\n         return res\n                     \n                 \n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         visited = []\n         queue = collections.deque()\n         if not root:\n             return []\n         level = []\n         currLv = 1\n         queue.append((root, currLv))\n         hights = {}\n         while queue:\n             node, currLv = queue.popleft()\n             if currLv not in hights:\n                 hights[currLv] = [node.val]\n             else:\n                 hights[currLv].append(node.val)\n             currLv += 1\n             if node.left:\n                 queue.append((node.left, currLv))\n             if node.right:\n                 queue.append((node.right, currLv))\n             \n         return [lv for lv in hights.values()]", "from queue import Queue\n \n # Definition for a binary tree node.\n # class TreeNode(object):\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution(object):\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         results = []\n         if root is None:\n             return results\n         q = Queue()\n         q.put(root)\n         while not q.empty():\n             size  = q.qsize()\n             sublist = []\n             for i in range(size):\n                 node = q.get()\n                 if node.left is not None:\n                     q.put(node.left)\n                 if node.right is not None:\n                     q.put(node.right)\n                 sublist.append(node.val)\n             results.append(sublist)\n         return results\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import queue\n \n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         q = queue.Queue()\n         q.put(root)\n         curNode = root\n         levels = []\n         while curNode is not None and not q.empty():\n             level = []\n             newQ = queue.Queue()\n             while not q.empty():\n                 curNode = q.get()\n                 level.append(curNode.val)\n                 if curNode.left is not None:\n                     newQ.put(curNode.left)\n                 if curNode.right is not None:\n                     newQ.put(curNode.right)\n             levels.append(level)\n             q = newQ\n         return levels", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         from queue import Queue\n         \n         q1, q2 = Queue(), Queue()\n         q1.put(root)\n         ret = []\n         \n         while (q1.empty() and not q2.empty()) or (not q1.empty() and q2.empty()):\n             rst = []\n             if not q1.empty():\n                 # print(\"q1 not empty\")\n                 while not q1.empty():\n                     node = q1.get()\n                     if not node:\n                         continue\n                     else:\n                         # print(\"q1:\", node.val)\n                         rst.append(node.val)\n                         q2.put(node.left)\n                         q2.put(node.right)\n             else:\n                 # print(\"q2 not empty\")\n                 while not q2.empty():\n                     node = q2.get()\n                     if not node:\n                         continue\n                     else:\n                         # print(\"q2:\", node.val)\n                         rst.append(node.val)\n                         q1.put(node.left)\n                         q1.put(node.right) \n             if len(rst) > 0:\n                 ret.append(rst)\n         return ret\n                 \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n import queue\n \n class Solution(object):\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         \n         q = queue.Queue()\n         q.put(root)\n         ret = []\n         while not q.empty():\n             nq = queue.Queue()\n             level = []\n             while not q.empty():\n                 node = q.get()\n                 level.append(node.val)\n                 \n                 if node.left:\n                     nq.put(node.left)\n                 if node.right:\n                     nq.put(node.right)\n             ret.append(level)\n             q = nq\n         return ret\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         q = [(root, 0)]\n         res = []\n         prev_lvl = -1\n         while q:\n             current, lvl = q[0]\n             q.pop(0)\n             if lvl > prev_lvl:\n                 res.append([current.val])\n             else:\n                 res[-1].append(current.val)\n             prev_lvl = lvl\n             if current.left:\n                 q.append((current.left, lvl + 1))\n             if current.right:\n                 q.append((current.right, lvl + 1))\n         return res\n         \n         \n         "]
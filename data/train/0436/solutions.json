["import functools\nclass Solution:\n    @functools.lru_cache()\n    def minDays(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        return 1 + min(n%2 + self.minDays(n//2), n%3 + self.minDays(n//3))\n            \n", "memo={}; f=min\nclass Solution:\n    def minDays(self, n: int) -> int:\n        if n<2: return n\n        if n in memo: return memo[n]\n        a=1+f(self.minDays(n//2)+n%2, self.minDays(n//3)+n%3);memo[n]=a        \n        return a\n\n\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        @lru_cache(None)\n        def dp(m):\n            if m == 0: return 0\n            if m == 1: return 1\n            return 1 + min(\n                m % 2 + dp(m // 2),\n                m % 3 + dp(m // 3)\n            )\n        return dp(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        ONE_LIMIT = 50\n        TWO_LIMIT = 23\n        f = {1:1}\n        def search(n, one, two):\n            # if n == 1 return 1\n            if one > ONE_LIMIT:\n                return 1000\n            if two > TWO_LIMIT:\n                return 1000\n            if n in f:\n                return f[n]\n            ans = 1000\n            if n % 3 == 0:\n                ans = min(ans, search(n//3, one, two))\n            if n % 2 == 0:\n                ans = min(ans, search(n//2, one, two + 1))\n            ans = min(ans, search(n-1, one+1, two))\n            f[n] = 1 + ans\n            return f[n]\n        \n        search(n,0,0)\n        \n        return f[n]", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        \n        def t(n):\n\n            stack={n}\n            ct=0\n            while stack:\n                tmp=set()\n                for i in stack:\n                    if i==0:\n                        return ct\n\n                    if i%2==0:\n                        tmp.add(i//2)\n                    if i%3==0:\n                        tmp.add(i//3)\n                    tmp.add(i-1)\n\n                ct+=1\n                stack=tmp\n                    \n        return t(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        dp = [0]*(1000)\n        \n        \n        for i in range(1,1000):\n            dp[i] = dp[i-1]+1\n            if i % 2 == 0:\n                dp[i] = min(dp[i//2]+1, dp[i])\n            if i % 3 == 0:\n                dp[i] = min(dp[i//3]+1, dp[i])\n        #print(dp)\n        \n        #for i in range(25,35):\n        #    print(i, dp[i])\n        \n        \n        d ={}\n        d[0] = 0\n        d[1] = 1\n        \n        def cal(k):\n            if k in d:\n                return d[k]\n            \n            a = k\n            a = min(a, cal(k // 3) + k % 3+1)\n            a = min(a, cal(k // 2) + k % 2+1)\n            d[k] = a\n            return d[k]\n        \n        for i in range(1,999):\n            if(dp[i]!=cal(i)):\n                print((i,dp[i],cal(i)))\n        \n        return cal(n)\n        \n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        if n == 0:\n            return 0\n        \n        current = set([n])\n        level = 0\n        \n        while True:\n\n            level += 1\n            temp = set()\n            \n            for num in current:\n                \n                if num == 1:\n                    return level\n                \n                if num % 2 == 0:\n                    temp.add(num//2)\n                if num % 3 == 0:\n                    temp.add(num//3)\n                temp.add(num-1)\n                \n            current = temp\n", "class Solution:\n    def mp_gen(self):\n        dp = [[0] * 32 for _ in range(32)]\n        dp[0][0] = 1\n        mp = {}\n        for i in range(32):\n            for j in range(32):\n                k = 2**i*3**j\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + 1\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + 1\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n                mp[k] = dp[i][j]\n        return mp        \n        \n    def minDays(self, n: int) -> int:\n        # @lru_cache(None)\n        # def helper(n):\n            # if n in self.mp:\n            #     return self.mp[n]\n            if n == 1:\n                return 1\n            cnt = 0\n            st = set()\n            st.add(n)\n            while st:\n                cnt += 1\n                # cand = n + 1\n                st_temp = set()\n                for v in st:\n                    # if v in self.mp:\n                    #     cand = min(cand, self.mp[v])\n                    if v == 1:\n                        return cnt\n                    st_temp.add(v - 1)\n                    if v % 2 == 0:\n                        st_temp.add(v // 2)\n                    if v % 3 == 0:\n                        st_temp.add(v // 3)\n                # if cand != n + 1:\n                #     return cand + cnt\n                st = st_temp\n            return -1\n        # self.mp = self.mp_gen()\n        # return helper(n)\n", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        days = 0\n        visited = set()\n        \n        while q:\n            days += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == 1:\n                    print(visited)\n                    return days\n                if node % 3 == 0 and node % 3 not in visited:\n                    q.append(node // 3)\n                    visited.add(node // 3)\n                if node % 2 == 0 and node % 2 not in visited:\n                    q.append(node // 2)\n                    visited.add(node // 2)\n                if node - 1 not in visited:\n                    q.append(node - 1)\n                    visited.add(node - 1)", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        queue = collections.deque()\n        \n        queue.append(n)\n        level = 0\n        while queue:\n            subList = set()\n            for i in range(len(queue)):\n                oranges = queue.popleft()\n                \n                subList.add(oranges-1)\n                if oranges%2 == 0:\n                    subList.add(oranges - (oranges//2))\n                if oranges%3 == 0:\n                    subList.add(oranges - (2*(oranges//3)))\n            \n            level += 1\n            if 0 in subList:\n                return level\n            for val in subList:\n                queue.append(val)\n            \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        i = 1\n        c_set = {n}\n        while 1 not in c_set:\n            new_set = set()\n            for a in c_set:\n                new_set.add(a - 1)\n                if a % 2 == 0:\n                    new_set.add(a // 2) \n                if a % 3 == 0:\n                    new_set.add(a // 3) \n            c_set = new_set\n            i += 1\n        return i\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue = collections.deque()\n        \n        queue.append(n)\n        level = 0\n        seen = set()\n        while queue:\n            subList = set()\n            for i in range(len(queue)):\n                oranges = queue.popleft()\n                if oranges not in seen:\n                    subList.add(oranges-1)\n                    if oranges%2 == 0:\n                        subList.add(oranges - (oranges//2))\n                    if oranges%3 == 0:\n                        subList.add(oranges - (2*(oranges//3)))\n            \n            level += 1\n            if 0 in subList:\n                return level\n            for val in subList:\n                queue.append(val)\n            \n", "class Solution:\n    def helper(self, n):\n        if n in self.dp:\n            return self.dp[n]\n        if n < 0:\n            return float('inf')\n        elif n == 0:\n            return 0\n        ret = self.helper(n-1)\n        if n % 3 == 0:\n            ret = min(ret, self.helper(n-2*(n//3)))\n        if n % 2 == 0:\n            ret = min(ret, self.helper(n//2))\n        self.dp[n] = 1 + ret\n        return self.dp[n]\n    \n    def minDays(self, n: int) -> int:\n        '''\n        # DFS => MLE\n        sys.setrecursionlimit(2000000000)\n        self.dp = {}\n        return self.helper(n)\n        '''\n        \n        '''\n        # BFS\n        '''\n        q = [n]\n        step = 0\n        while q:\n            nxts = set()\n            for nn in q:\n                if nn == 0: return step\n                nxts.add(nn-1)\n                if nn % 2 == 0: nxts.add(nn//2)\n                if nn % 3 == 0: nxts.add(nn-2*(nn//3))\n            step += 1\n            q = deque(nxts)", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = set([n])\n        level = 1\n        while q:\n            new_q = set()\n            for node in q:\n                if node - 1 == 0:\n                    return level\n                \n                new_q.add(node-1)\n                if node % 2 == 0:\n                    new_q.add(node // 2)\n                if node % 3 == 0:\n                    new_q.add(node // 3)\n            level += 1\n            q = new_q\n", "class Solution:\n  def minDays(self, n: int) -> int:\n    frontier, res = [n], 0\n    while frontier:\n      new_frontier = set()\n\n      for el in frontier:\n        if el == 1:\n          return res + 1\n        \n        new_frontier.add(el - 1)\n        if el % 2 == 0:\n          new_frontier.add(el // 2)\n        if el % 3 == 0:\n          new_frontier.add(el // 3)\n      \n      res += 1\n      frontier = list(new_frontier)", "from queue import Queue\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = Queue()\n        q.put(n)\n        vis = set()\n        vis.add(n)\n        ans = 1\n        while True:\n            sz = q.qsize()\n            for rep in range(sz):\n                u = q.get()\n                if u == 1:\n                    return ans\n                if u - 1 not in vis:\n                    vis.add(u - 1)\n                    q.put(u - 1)\n                if u % 2 == 0 and u // 2 not in vis:\n                    vis.add(u // 2)\n                    q.put(u // 2)\n                if u % 3 == 0 and u // 3 not in vis:\n                    vis.add(u // 3)\n                    q.put(u // 3)\n            ans += 1\n        return -1", "class Solution:\n    def minDays(self, n: int) -> int:\n        s = {n}\n        step = 0\n        while s:\n            ns = set()\n            for curr in s:\n                if curr == 0: return step\n                if curr - 1 not in s: ns.add(curr - 1)\n                if curr % 2 == 0 and curr // 2 not in s: ns.add(curr // 2 )\n                if curr % 3 == 0 and curr // 3 not in s: ns.add(curr // 3 )\n            step += 1\n            s = ns\n        return step\n                    \n                \n", "from math import log,ceil\n\nclass Solution:\n    def minDays( self, n: int) -> int:\n        def one_day(apples):\n            if apples%2==0 and apples%3!=0:\n                return (apples/2,apples-1)\n            elif apples%3==0 and apples%2!=0:\n                return (apples/3,apples-1)\n            elif apples%3==0 and apples%2==0:\n                return (apples/3,apples/2)\n            elif apples%3!=0 and apples%2!=0:\n                return (apples-1,)\n\n\n        poses=[(n,0)]#(#apples remained,days passed)\n        min_apples=min([pos[0] for pos in poses])\n\n        while min_apples!=0:\n            new_poses=[]\n            for pos in poses:\n                apples=pos[0]\n                days=pos[1]\n                new_pos=[(new_apples,days+1)for new_apples in one_day(apples)]\n                if min([pos[0] for pos in new_pos])==0:\n                    return sorted(new_pos,key=lambda x:x[0])[0][1]\n                new_poses+=new_pos\n            min_apples=min([pos[0] for pos in new_poses])\n            poses=sorted(list(set(new_poses)))\n            # print(poses)\n\n        days=sorted(poses,key=lambda x:x[0])[0][1]\n\n        return days", "class Solution:\n    def minDays(self, n: int) -> int:\n        @lru_cache(None)\n        def dp(m):\n            if m == 0: return 0\n            if m == 1: return 1\n            return min(\n                m % 2 + 1 + dp(m // 2),\n                m % 3 + 1 + dp(m // 3)\n            )\n        return dp(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        days = 0\n        s0 = set()\n        s1 = set()\n        s1.add(n)\n        while True:\n            days += 1\n            for si in s1:\n                if si == 1:\n                    return days\n                if si % 2 == 0:\n                    s0.add(si // 2)\n                if si % 3 == 0:\n                    s0.add(si - 2 * (si / 3))\n                s0.add(si - 1)\n            s1 = s0\n            s0 = set()\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        @lru_cache(None)\n        def eat(remaining, day):\n            if remaining == 0:\n                return day\n\n            e_3 = eat(remaining - (2*(remaining//3)), day + 1) if remaining % 3 == 0 else eat(remaining - remaining % 3, day + remaining % 3)\n            e_2 = eat(remaining - (remaining // 2), day + 1) if remaining % 2 == 0 else eat(remaining - 1, day + 1)\n            \n            return min(e_3, e_2)\n        return eat(n, 0)", "from queue import Queue\n\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = Queue()\n        seen = set()\n        \n        q.put((n, 0))\n        seen.add(n)\n        \n        while not q.empty():\n            cur, days = q.get()\n            \n            if cur == 1:\n                return days + 1\n            \n            q.put((cur - 1, days + 1))\n            seen.add(cur - 1)\n            \n            if cur % 2 == 0 and cur // 2 not in seen:\n                q.put((cur // 2, days + 1))\n                seen.add(cur // 2)\n                \n            if cur % 3 == 0 and cur // 3 not in seen:\n                q.put((cur // 3, days + 1))\n                seen.add(cur // 3)", "class Solution:\n    def minDays(self, n: int) -> int:\n        dp = [n,n,n]\n        last = set([n])\n        # dp = [[n] * 3 for _ in range(n+1)]\n        \n        def min_2(nums):\n            xs = [x for x in nums if x % 2 == 0]\n            if not xs:\n                return min(nums)\n            return min(xs) // 2\n        \n        def min_3(nums):\n            xs = [x for x in nums if x % 3 == 0]\n            if not xs:\n                return min(nums)\n            return min(xs) // 3\n        \n        for i in range(1, n+1):\n            curr = set()\n            for n in last:\n                curr.add(n - 1)\n                \n            for n in last:\n                if n % 2 == 0:\n                    curr.add(n // 2)\n                    \n            for n in last:\n                if n % 3 == 0:\n                    curr.add(n // 3)\n                    \n            last = last | curr\n            # print(last)\n            if any(n == 0 for n in last):\n                return i\n            # dp[0] = min(last) - 1\n            # dp[1] = min_2(last)\n            # dp[2] = min_3(last)\n            # print(dp, last)\n            # if any(dp[i] == 0 for i in range(3)):\n            #     return i\n            # for d in dp:\n            #     last.add(d)\n            # dp = dp[:]\n        # print('-' * 20)\n        return n", "class Solution:\n    def minDays(self, n: int) -> int:\n        last = {n}\n        cnt = 0\n        while 1:\n            neo = set()\n            for i in last:\n                if i == 0:\n                    return cnt\n                neo.add(i - 1)\n                if i % 2 == 0:\n                    neo.add(i//2)\n                if i % 3 == 0:\n                    neo.add(i // 3)\n            cnt += 1\n            last = neo\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        q = {n}\n        seen = set()\n        ans = 1\n        while q:\n            q2 = set()\n            for num in q:\n                if num == 1:\n                    return ans\n                seen.add(num)\n                q2.add(num-1)\n                if num%2 == 0:\n                    q2.add(num//2)\n                if num%3 == 0:\n                    q2.add(num//3)\n            q = q2\n            ans += 1\n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        l = {n}\n        count = 0\n        while not l.__contains__(0):\n            count += 1\n            t = set()\n            for i in l:\n                t.add(i-1)\n                if (i%2==0):\n                    t.add(i/2)\n                if (i%3==0):\n                    t.add(i/3)\n            l = t\n        return count", "class Solution:\n    \n    def minDays(self, n: int) -> int:\n        mem = {1:1}\n        def calCulatedays(num):\n            if not num: return 0\n            if num in mem:\n                return mem[num]\n            summ = num\n            oneCheck = 0\n            if num%3 == 0 :\n                oneCheck+=1\n                summ=min(calCulatedays(num/3),summ)\n            if num%2 == 0 :\n                oneCheck+=1\n                summ=min(calCulatedays(num/2),summ)\n            if oneCheck!=2:\n                summ=min(calCulatedays(num-1),summ)\n            mem[num] = summ+1\n            return mem[num]\n        return calCulatedays(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        @lru_cache(None)\n        def days(m: int, steps: int):\n            nonlocal maxSteps\n            if steps >= maxSteps:\n                return\n            if m == 0:\n                maxSteps = steps\n            if m > 0:\n                if m % 3 == 0:\n                    days(m // 3, steps + 1)\n                if m % 2 == 0:\n                    days(m // 2, steps + 1)\n                days(m - 1, steps + 1)\n             \n        maxSteps = n\n        days(n, 0)\n        return maxSteps", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n<4:\n            return 1 if n==1 else 2\n        res, cur = 0, {n}\n        def Op(i):\n            ans = {i-1}\n            if not i%2:\n                ans.add(i//2)\n            if not i%3:\n                ans.add(i//3)\n            return ans\n        while 0 not in cur:\n            cur = {x for i in cur for x in Op(i)}\n            res += 1\n        return res\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        dic = {n:0}\n        while 0 not in dic:\n            tmp = {}\n            for m in dic:\n                tmp[m-1] = min(dic[m-1],dic[m]+1) if m-1 in dic else dic[m] + 1\n                if m % 2 == 0: tmp[m//2] = min(dic[m//2],dic[m]+1) if m//2 in dic else dic[m] + 1\n                if m % 3 == 0: tmp[m//3] = min(dic[m//3],dic[m]+1) if m//3 in dic else dic[m] + 1\n            dic = tmp\n        return dic[0]\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        ONE_LIMIT = 100\n        TWO_LIMIT = 30\n        f = {1:1}\n        def search(n, one, two):\n            # if n == 1 return 1\n            if one > ONE_LIMIT:\n                return 1000\n            if two > TWO_LIMIT:\n                return 1000\n            if n in f:\n                return f[n]\n            ans = 1000\n            if n % 3 == 0:\n                ans = min(ans, search(n//3, one, two))\n            if n % 2 == 0:\n                ans = min(ans, search(n//2, one, two + 1))\n            ans = min(ans, search(n-1, one+1, two))\n            f[n] = 1 + ans\n            return f[n]\n        \n        search(n,0,0)\n        \n        return f[n]", "class Solution:\n    def __init__(self):\n      self.dp = {}\n    def dfs(self, i, count):\n      if count >= 110:\n        return 99999;\n      if i in self.dp:\n        return self.dp[i]\n      tmp = 90\n      if i%3 == 0 : tmp = min(tmp, self.dfs(i//3, count + 1))\n      if tmp < 100 and i%2 == 0 : tmp = min(tmp, self.dfs(i//2 , count + 1))\n      \n      if tmp < 100 : tmp = min(tmp, self.dfs(i - 1, count + 1))\n      self.dp[i] = 1 + tmp\n      return self.dp[i]\n    def minDays(self, n: int) -> int:\n      self.dp[0] = 0\n      self.dp[1] = 1\n      self.dp[2] = 2\n      self.dp[3] = 2\n      self.dp[4] = 3\n      return self.dfs(n, 0)", "from collections import deque\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q1 = deque([0, None])\n        q2 = deque([n, None])\n        visited1 = {0}\n        visited2 = {n}\n        \n        for i in range(n):\n            while True:\n                n = q1.popleft()\n                if n is None:\n                    q1.append(None)\n                    break\n                for m in [n + 1, n * 2, n * 3]:\n                    if m in visited2:\n                        return i * 2 + 1\n                    if m not in visited1:\n                        visited1.add(m)\n                        q1.append(m)\n            \n            while True:\n                n = q2.popleft()\n                if n is None:\n                    q2.append(None)\n                    break\n                l = [n - 1]\n                if n % 2 == 0:\n                    l.append(n // 2)\n                if n % 3 == 0:\n                    l.append(n // 3)\n                for m in l:\n                    if m in visited1:\n                        return i * 2 + 2\n                    if m not in visited2:\n                        visited2.add(m)\n                        q2.append(m)\n\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         # self.hit0 = 0\n#         # self.hit1 = 0\n#         # self.total = 0\n        \n#         # cache = {0: 0}\n#         # return self._find(n, cache, inf)\n        \n#         return self._find(n, {0: 0}, inf)\n        \n#         # self._find(n, cache, inf)\n#         # hit = self.hit0 + self.hit1\n#         # print(self.total, hit, self.hit0, self.hit1, hit / self.total, self.hit0 / hit)\n        \n#         # print(cache)\n#         # return cache[n]\n\n\n#     def _find(self, n, cache, terminate):\n        \n#         if n in cache:\n#             return cache[n]\n        \n#         # # self.total += 1\n#         # if n in cache:\n#         #     if cache[n] > terminate:\n#         #         # self.hit0 += 1\n#         #         return inf\n#         #     # self.hit1 += 1\n#         #     return cache[n]\n        \n#         if terminate <= 0:\n#             return inf\n        \n#         oldTerminate = terminate\n#         ret = inf\n#         if n % 3 == 0:\n#             ret = 1 + self._find(n // 3, cache, terminate - 1)\n#             terminate = min(terminate, ret - 1)\n#         if n % 2 == 0:\n#             ret = min(ret, 1 + self._find(n // 2, cache, terminate - 1))\n#             terminate = min(terminate, ret - 1)\n#         ret = min(ret, 1 + self._find(n - 1, cache, terminate - 1))\n        \n#         # if ret < inf:\n#         #     cache[n] = ret\n#         # return ret\n        \n#         if ret <= oldTerminate:\n#             cache[n] = ret\n#             return ret\n#         return inf\n\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         return self._find(n, {0: 0}, inf)\n    \n    \n#     def _find(self, n, cache, terminate):\n\n#         if n in cache:\n#             return cache[n]\n        \n#         if terminate <= -15:\n#             return inf\n        \n#         ret = inf\n#         if n % 3 == 0:\n#             ret = 1 + self._find(n // 3, cache, terminate - 1)\n#             terminate = min(terminate, ret - 1)\n#         if n % 2 == 0:\n#             ret = min(ret, 1 + self._find(n // 2, cache, terminate - 1))\n#             terminate = min(terminate, ret - 1)\n#         ret = min(ret, 1 + self._find(n - 1, cache, terminate - 1))\n        \n#         if ret < inf:\n#             cache[n] = ret\n#         return ret\n\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         arr = [0]\n#         for i in range(1, n + 1):\n#             n = arr[-1]\n#             if i % 2 == 0:\n#                 n = min(n, arr[i // 2])\n#             if i % 3 == 0:\n#                 n = min(n, arr[i // 3])\n#             arr.append(n + 1)\n        \n#         return arr[-1]\n", "# class Solution:\n#     def minDays(self, n: int) -> int:\n#         return self._find(n, {0: 0})\n    \n    \n#     def _find(self, n, cache):\n\n#         if n in cache:\n#             return cache[n]\n        \n#         ret = inf\n#         if n % 3 == 0:\n#             ret = 1 + self._find(n // 3, cache)\n#         if n % 2 == 0:\n#             ret = min(ret, 1 + self._find(n // 2, cache))\n#         if n < 50000:\n#             ret = min(ret, 1 + self._find(n - 1, cache, terminate - 1))\n        \n\n#         return ret\n\n\n# from collections import deque\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         q1 = deque([0, None])\n#         q2 = deque([n, None])\n#         visited = {n}\n        \n#         for i in range(n):\n#             tmp = set()\n#             while True:\n#                 n = q1.popleft()\n#                 if n is None:\n#                     q1.append(None)\n#                     break\n#                 for m in [n + 1, n * 2, n * 3]:\n#                     if m in visited:\n#                         return i * 2 + 1\n#                     if m not in tmp:\n#                         tmp.add(m)\n#                         q1.append(m)\n#             visited = tmp\n            \n#             tmp = set()\n#             while True:\n#                 n = q2.popleft()\n#                 if n is None:\n#                     q2.append(None)\n#                     break\n#                 l = [n - 1]\n#                 if n % 2 == 0:\n#                     l.append(n // 2)\n#                 if n % 3 == 0:\n#                     l.append(n // 3)\n#                 for m in l:\n#                     if m in visited:\n#                         return i * 2 + 2\n#                     if m not in tmp:\n#                         q2.append(m)\n#                         tmp.add(m)\n#             visited = tmp\n\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q1 = deque([0, None])\n        q2 = deque([n, None])\n        visited1 = {0}\n        visited2 = {n}\n        \n        for i in range(n):\n            while True:\n                n = q1.popleft()\n                if n is None:\n                    q1.append(None)\n                    break\n                for m in [n + 1, n * 2, n * 3]:\n                    if m in visited2:\n                        return i * 2 + 1\n                    if m not in visited1:\n                        visited1.add(m)\n                        q1.append(m)\n            \n            while True:\n                n = q2.popleft()\n                if n is None:\n                    q2.append(None)\n                    break\n                l = [n - 1]\n                if n % 2 == 0:\n                    l.append(n // 2)\n                if n % 3 == 0:\n                    l.append(n // 3)\n                for m in l:\n                    if m in visited1:\n                        return i * 2 + 2\n                    if m not in visited2:\n                        q2.append(m)\n                        visited2.add(m)\n\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         # self.hit0 = 0\n#         # self.hit1 = 0\n#         # self.total = 0\n        \n#         # cache = {0: 0}\n#         # return self._find(n, cache, inf)\n        \n#         return self._find(n, {0: 0}, inf)\n        \n#         # self._find(n, cache, inf)\n#         # hit = self.hit0 + self.hit1\n#         # print(self.total, hit, self.hit0, self.hit1, hit / self.total, self.hit0 / hit)\n        \n#         # print(cache)\n#         # return cache[n]\n\n\n#     def _find(self, n, cache, terminate):\n        \n#         if n in cache:\n#             return cache[n]\n        \n#         # # self.total += 1\n#         # if n in cache:\n#         #     if cache[n] > terminate:\n#         #         # self.hit0 += 1\n#         #         return inf\n#         #     # self.hit1 += 1\n#         #     return cache[n]\n        \n#         if terminate <= 0:\n#             return inf\n        \n#         oldTerminate = terminate\n#         ret = inf\n#         if n % 3 == 0:\n#             ret = 1 + self._find(n // 3, cache, terminate - 1)\n#             terminate = min(terminate, ret - 1)\n#         if n % 2 == 0:\n#             ret = min(ret, 1 + self._find(n // 2, cache, terminate - 1))\n#             terminate = min(terminate, ret - 1)\n#         ret = min(ret, 1 + self._find(n - 1, cache, terminate - 1))\n        \n#         # if ret < inf:\n#         #     cache[n] = ret\n#         # return ret\n        \n#         if ret <= oldTerminate:\n#             cache[n] = ret\n#             return ret\n#         return inf\n\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         return self._find(n, {0: 0}, inf)\n    \n    \n#     def _find(self, n, cache, terminate):\n\n#         if n in cache:\n#             return cache[n]\n        \n#         if terminate <= -15:\n#             return inf\n        \n#         ret = inf\n#         if n % 3 == 0:\n#             ret = 1 + self._find(n // 3, cache, terminate - 1)\n#             terminate = min(terminate, ret - 1)\n#         if n % 2 == 0:\n#             ret = min(ret, 1 + self._find(n // 2, cache, terminate - 1))\n#             terminate = min(terminate, ret - 1)\n#         ret = min(ret, 1 + self._find(n - 1, cache, terminate - 1))\n        \n#         if ret < inf:\n#             cache[n] = ret\n#         return ret\n\n\n# class Solution:\n#     def minDays(self, n: int) -> int:\n#         arr = [0]\n#         for i in range(1, n + 1):\n#             n = arr[-1]\n#             if i % 2 == 0:\n#                 n = min(n, arr[i // 2])\n#             if i % 3 == 0:\n#                 n = min(n, arr[i // 3])\n#             arr.append(n + 1)\n        \n#         return arr[-1]\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue, steps = [n], 0\n        appears = dict()\n        while queue:\n            n_queue = []\n            for ele in queue:\n                appears[ele] = 1\n                \n            for ele in queue:\n                if ele < 2:\n                    return (steps+ele)\n                if ele-1 not in appears:\n                    n_queue.append(ele-1)\n                if ele%2==0 and ele/2 not in appears:\n                    n_queue.append(ele//2)\n                if ele%3==0 and ele/3 not in appears:\n                    n_queue.append(ele//3)\n            \n            steps += 1\n            queue = n_queue\n        \n        return steps", "class Solution:\n    def minDays(self, n: int) -> int:\n        return self.dfs(n)\n    \n    @lru_cache(None)\n    def dfs(self, n):\n        if n < 2:\n            return n\n        if n < 0:\n            return -sys.maxsize\n        ans = sys.maxsize\n        if n % 3 == 0:\n            ans = min(1 + self.dfs(n // 3), ans)\n        if n % 2 == 0:\n            ans = min(1 + self.dfs(n // 2), ans)\n        if (n - 1) % 3 == 0 or (n - 1) % 2 == 0:\n            ans = min(1 + self.dfs(n - 1), ans)\n        if (n - 2) % 3 == 0:\n            ans = min(2 + self.dfs(n - 2), ans)\n        return ans", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        self.best = math.inf\n        \n        @lru_cache(None)\n        def f(n, steps):\n            if n == 0:\n                self.best = min(self.best, steps)\n                return\n            \n            if steps > self.best:\n                return\n\n            if n % 2 == 0:\n                f(n // 2, steps + 1)\n            if n % 3 == 0:\n                f(n // 3, steps + 1)\n            f(n-1, steps + 1)\n        \n        f(n, 0)\n        return self.best", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        self.best = math.inf\n        \n        @lru_cache(None)\n        def f(n, steps):\n            if n == 0:\n                self.best = min(self.best, steps)\n                return steps\n            \n            if steps > self.best:\n                return math.inf\n            if n % 3 == 0:\n                f(n // 3, steps + 1)\n            if n % 2 == 0:\n                f(n // 2, steps + 1)\n\n            f(n-1, steps + 1)\n        \n        f(n, 0)\n        return self.best", "class Solution:\n    def minDays(self, n: int) -> int:\n        def bfs(n):\n            q1, q2 = [n], [0]\n            seen1, seen2 = {n:0}, {0:0}\n            step1, step2 = 0, 0\n            \n            while q1 or q2:\n                p1 = []\n                p2 = []\n                step1 += 1      \n                step2 += 1\n                \n                while q1:\n                    curr1 = q1.pop()\n                    if curr1 in seen2:\n                        return seen1[curr1] + seen2[curr1]\n                    \n                    if curr1 % 3 == 0:\n                        nx = curr1 // 3\n                        if nx not in seen1:\n                            seen1[nx] = step1\n                            p1.append(nx)\n                    \n                    if curr1 % 2 == 0:\n                        nx = curr1 // 2\n                        if nx not in seen1:\n                            seen1[nx] = step1\n                            p1.append(nx)\n                    \n                    if curr1 - 1 not in seen1:\n                        seen1[curr1 - 1] = step1\n                        p1.append(curr1 - 1)\n\n\n                while q2:\n                    curr2 = q2.pop()\n                    if curr2 in seen1:\n                        return seen1[curr2] + seen2[curr2]\n                    \n                    for nx in [curr2 * 3, curr2 * 2, curr2 + 1]:\n                        if nx <= n and nx not in seen2:\n                            seen2[nx] = step2\n                            p2.append(nx)\n                q1, q2 = p1, p2\n                \n                \n            return -1\n        \n        return bfs(n)\n            \n                    \n                    \n", "from queue import Queue\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q=Queue()\n        q.put((n,0))\n        visited=set()\n        num=n\n        while num!=0:\n            num,days=q.get()\n            if num not in visited:\n                visited.add(num)\n                if num%3==0:\n                    q.put((num//3,days+1))\n                if num%2==0:\n                    q.put((num//2,days+1))\n                q.put((num-1,days+1))\n        return days", "from queue import Queue\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q=Queue()\n        q.put((n,0))\n        visited=set()\n        while True:\n            num,days=q.get()\n            if num not in visited:\n                visited.add(num)\n                if num==0:\n                    return days\n                if num%3==0:\n                    q.put((num//3,days+1))\n\n                if num%2==0:\n                    q.put((num//2,days+1))\n                q.put((num-1,days+1))", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        @lru_cache(None)\n        def eat(remaining, day):\n            if remaining == 0:\n                return day\n            e3 = (\n                eat(remaining - (2*remaining//3), day+1) if not remaining % 3 else\n                eat(remaining - remaining % 3, day + remaining % 3)\n            )\n            e2 = (\n                eat(remaining - (remaining//2),day+1) if not remaining % 2 else\n                eat(remaining - 1, day + 1)\n            )\n            return min(e3, e2)\n        \n        return eat(n, 0)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = [n]\n        days = 1\n        seen = set()\n        while q:\n            new_q = []\n            for each in q:\n                if each == 1:\n                    return days\n                seen.add(each)\n                if each % 2 == 0 and each // 2 not in seen:\n                    new_q.append(each // 2)\n                if each % 3 == 0 and each // 3 not in seen:\n                    new_q.append(each // 3)\n                if each - 1 not in seen:\n                    new_q.append(each - 1)\n            q = new_q\n            days += 1", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        dp = dict()\n        def dfs(n, l):\n            if l > 100:\n                return sys.maxsize\n            \n            if n in dp:\n                return dp[n]\n            \n            if n == 1:\n                dp[n] = 1\n                return dp[n]\n            \n            dp[n] = sys.maxsize\n            \n            if n % 3 == 0:\n                dp[n] = min(dp[n], dfs(n//3, l+1)+1)\n                \n            if n % 2 == 0:\n                dp[n] = min(dp[n], dfs(n//2, l+1)+1)\n                \n            dp[n] = min(dp[n], dfs(n-1, l+1)+1)\n            \n            return dp[n]\n        \n        return dfs(n, 0)", "class Solution:\n    def minDays(self, n: int) -> int:\n        m = collections.defaultdict(int)\n        m[0] = 0\n        m[1] = 1\n        \n        def helper(n):\n            if n in m:\n                return m[n]\n            res = float('inf')\n            if n % 3 == 0:\n                res = min(res, 1 + helper(n // 3))\n            if n % 2 == 0:\n                res = min(res, 1 + helper(n // 2))\n            if n % 3 == 1:\n                res = min(res, 1 + helper(n - 1))\n            if n % 3 == 2:\n                res = min(res, 2 + helper(n - 2))\n            if n % 2 != 0:\n                res = min(res, 1 + helper(n - 1))\n            m[n] = res\n            return res\n        \n        return helper(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        self.best = math.inf\n        \n        @lru_cache(None)\n        def f(n, steps):\n            if n == 0:\n                self.best = min(self.best, steps)\n                return steps\n            \n            if steps > self.best:\n                return math.inf\n            if n % 3 == 0:\n                f(n // 3, steps + 1)\n            if steps > self.best:\n                return math.inf\n            \n            if n % 2 == 0:\n                f(n // 2, steps + 1)\n            if steps > self.best:\n                return math.inf\n\n            f(n-1, steps + 1)\n        \n        f(n, 0)\n        return self.best", "class Solution:\n    # @lru_cache()\n    # ^\n    # what's this?\n    def minDays(self, n: int) -> int:\n        # # Method 1: DP -> TLE\n        self.m = 10000\n        self.dp = [0, 1] + [float('inf')] * (self.m-1)\n        for i in range(2,self.m+1):\n            v = []\n            v.append(self.dp[i-1])\n            if i % 2 == 0:\n                v.append(self.dp[i//2])\n            if i % 3 == 0:\n                v.append(self.dp[i//3])\n            self.dp[i] = min(v) + 1\n        # return dp[-1]\n        \n        # # Method 3: Gready -> Dijkstra?\n        def dfs(n):\n            # print(n)\n            if n <= self.m:\n                return self.dp[n]\n            else:\n                return 1 + min(n%2 + dfs(n//2), n%3 + dfs(n//3))\n        return dfs(n)\n        \n        # # Method 2: DP -> TLE\n        # dp = [0, 1] + [float('inf')] * (n-1)\n        # for i in range(1, n+1):\n        #     if i+1 <= n:\n        #         dp[i+1] = min(dp[i+1], dp[i] + 1)\n        #     if i*2 <= n:\n        #         dp[i*2] = min(dp[i*2], dp[i] + 1)\n        #     if i*3 <= n:\n        #         dp[i*3] = min(dp[i*3], dp[i] + 1)\n        # return dp[-1]\n        \n        # # Method 4: DFS\n        # # DFS\n        # def dfs(n):\n        #     if n == 1:\n        #         return 1\n        #     else:\n        #         print(n)\n        #         if n % 3 == 0:\n        #             print(\\\"case 3\\\")\n        #             v3 = dfs(n//3) + 1\n        #             self.ans.append(v3)\n        #         if n % 2 == 0:\n        #             print('case 2')\n        #             v2 = dfs(n//2) + 1\n        #             self.ans.append(v2)\n        #         if n - 1 > 1:\n        #             print('case 1')\n        #             v1 = dfs(n-1) + 1\n        #             self.ans.append(v1)\n        # dfs(n)\n        # return min(self.ans)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = [n]\n        v = set()\n        steps = 0\n        while len(q) > 0:\n            newq = []\n            for node in q:\n                if node == 0: return steps\n                v.add(node)\n                if node % 3 == 0 and node // 3 not in v: newq.append(node // 3)\n                if node % 2 == 0 and node // 2 not in v: newq.append(node // 2)\n                if node - 1 not in v: newq.append(node - 1)\n            q = newq\n            steps += 1\n        return -1", "class Solution:\n    # @lru_cache()\n    # ^\n    # what's this?\n    def minDays(self, n: int) -> int:\n        # # # Method 1: DP -> TLE\n        # dp = [0, 1] + [float('inf')] * (n-1)\n        # for i in range(2,n+1):\n        #     v = []\n        #     v.append(i%2 + dp[i//2])\n        #     v.append(i%3 + dp[i//3])\n        #     dp[i] = min(v) + 1\n        # return dp[-1]\n        \n        # Method 2 -> Dijkstra?\n        \n        # # Method 3: Gready + DP -> AC\n        self.m = 10000\n        self.dp = [0, 1] + [float('inf')] * (self.m-1)\n        for i in range(2,self.m+1):\n            v = []\n            v.append(self.dp[i-1])\n            if i % 2 == 0:\n                v.append(self.dp[i//2])\n            if i % 3 == 0:\n                v.append(self.dp[i//3])\n            self.dp[i] = min(v) + 1\n            \n        def dfs(n):\n            # print(n)\n            if n <= self.m:\n                return self.dp[n]\n            else:\n                return 1 + min(n%2 + dfs(n//2), n%3 + dfs(n//3))\n        return dfs(n)\n        \n        # # Method 4: DP -> TLE\n        # dp = [0, 1] + [float('inf')] * (n-1)\n        # for i in range(1, n+1):\n        #     if i+1 <= n:\n        #         dp[i+1] = min(dp[i+1], dp[i] + 1)\n        #     if i*2 <= n:\n        #         dp[i*2] = min(dp[i*2], dp[i] + 1)\n        #     if i*3 <= n:\n        #         dp[i*3] = min(dp[i*3], dp[i] + 1)\n        # return dp[-1]\n        \n        # # Method 5: DFS\n        # # DFS\n        # def dfs(n):\n        #     if n == 1:\n        #         return 1\n        #     else:\n        #         print(n)\n        #         if n % 3 == 0:\n        #             print(\\\"case 3\\\")\n        #             v3 = dfs(n//3) + 1\n        #             self.ans.append(v3)\n        #         if n % 2 == 0:\n        #             print('case 2')\n        #             v2 = dfs(n//2) + 1\n        #             self.ans.append(v2)\n        #         if n - 1 > 1:\n        #             print('case 1')\n        #             v1 = dfs(n-1) + 1\n        #             self.ans.append(v1)\n        # dfs(n)\n        # return min(self.ans)\n", "class Solution:\n    from collections import deque\n    def minDays(self, n: int) -> int:\n        \n        q=deque()\n        q.append(n)\n        seen=set()\n        ans=1\n        \n        while q:\n            \n            new=deque()\n            \n            while q:\n                k=q.popleft()\n\n                if k==1:\n                    return ans\n                seen.add(k)\n\n\n                if k%3==0 and k//3 not in seen:\n                    new.append(k//3)\n                if k%2==0 and k//2 not in seen:\n                    new.append(k//2)\n                if k-1 not in seen:\n                    new.append(k-1)\n            \n            q=new\n            \n            ans+=1\n", "class Solution:\n    # @lru_cache()\n    def minDays(self, n: int) -> int:\n        # # Method 1: DP -> TLE\n        self.m = 10000\n        self.dp = [0, 1] + [float('inf')] * (self.m-1)\n        for i in range(2,self.m+1):\n            v = []\n            v.append(self.dp[i-1])\n            if i % 2 == 0:\n                v.append(self.dp[i//2])\n            if i % 3 == 0:\n                v.append(self.dp[i//3])\n            self.dp[i] = min(v) + 1\n        # return dp[-1]\n        \n        # # Method 3: Gready -> Dijkstra?\n        def dfs(n):\n            # print(n)\n            if n <= self.m:\n                return self.dp[n]\n            else:\n                return 1 + min(n%2 + dfs(n//2), n%3 + dfs(n//3))\n        return dfs(n)\n        \n        # # Method 2: DP -> TLE\n        # dp = [0, 1] + [float('inf')] * (n-1)\n        # for i in range(1, n+1):\n        #     if i+1 <= n:\n        #         dp[i+1] = min(dp[i+1], dp[i] + 1)\n        #     if i*2 <= n:\n        #         dp[i*2] = min(dp[i*2], dp[i] + 1)\n        #     if i*3 <= n:\n        #         dp[i*3] = min(dp[i*3], dp[i] + 1)\n        # return dp[-1]\n        \n        # # Method 4: DFS\n        # # DFS\n        # def dfs(n):\n        #     if n == 1:\n        #         return 1\n        #     else:\n        #         print(n)\n        #         if n % 3 == 0:\n        #             print(\\\"case 3\\\")\n        #             v3 = dfs(n//3) + 1\n        #             self.ans.append(v3)\n        #         if n % 2 == 0:\n        #             print('case 2')\n        #             v2 = dfs(n//2) + 1\n        #             self.ans.append(v2)\n        #         if n - 1 > 1:\n        #             print('case 1')\n        #             v1 = dfs(n-1) + 1\n        #             self.ans.append(v1)\n        # dfs(n)\n        # return min(self.ans)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue, steps = [n], 0\n        appears = dict()\n        while queue:\n            n_queue = []\n            \n            for k in range(len(queue)-1, -1, -1):\n                appears[queue[k]] = 1\n                if queue[k] < 2:\n                    return (steps+queue[k])\n                if queue[k]-1 not in appears:\n                    n_queue.append(queue[k]-1)\n                if queue[k]%2==0 and queue[k]/2 not in appears:\n                    n_queue.append(queue[k]//2)\n                if queue[k]%3==0 and queue[k]/3 not in appears:\n                    n_queue.append(queue[k]//3)\n            \n            steps += 1\n            queue = n_queue\n        \n        return steps", "class Solution:\n    def minDays(self, n: int) -> int:\n        dp = {}\n        dp[0] = 1\n        def getMinDays(n, dp):\n            if n == 0:\n                return 0\n            if n-1 in dp:\n                return dp[n-1]\n            eat2 = n % 2 + getMinDays(n//2, dp) + 1\n            eat3 = n % 3 + getMinDays(n//3, dp) + 1\n            dp[n-1] = min(eat2, eat3)\n            return dp[n-1]\n        return getMinDays(n, dp)\n            \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        ans = 0\n        q1, q2 = [n], []\n        seen = set()\n        while q1:\n            for u in q1:\n                if u == 0:\n                    return ans\n                seen.add(u)\n                if u % 2 == 0 and u // 2 not in seen:\n                    q2.append(u // 2)\n                if u % 3 == 0 and u // 3 not in seen:\n                    q2.append(u // 3)\n                if u - 1 not in seen:\n                    q2.append(u - 1)\n            q1, q2 = q2, []\n            ans += 1\n        return ans\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        visited = set()\n        days = -1\n        q = [n]\n        \n        while q:\n            days += 1\n            nxt_q = []\n            while q:\n                cur = q.pop()\n                visited.add(cur)\n                if cur == 0:\n                    return days\n                nxt_q.append(cur-1)\n                if cur%2 == 0:\n                    if (cur//2) not in visited: nxt_q.append(cur//2)\n                if cur%3 == 0:\n                    if (cur//3) not in visited:nxt_q.append(cur//3)\n            q = nxt_q\n        \n        return n\n", "import functools\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        \n        min_cnt = {}\n        visited = set()\n        \n        @functools.lru_cache(maxsize=None)\n        def dfs(num, cnt):\n            visited.add(num)\n            if num == 1:\n                return cnt+1\n\n            minres = 2*10**9\n\n            if num in min_cnt:\n                min_cnt[num] = min(min_cnt[num], cnt)\n            else:\n                min_cnt[num] = cnt\n            \n            if num%3 == 0:\n                minres = min(minres, dfs(num//3, cnt+1))\n            if num%2 == 0:\n                minres = min(minres, dfs(num//2, cnt+1))\n            if not (num+3 in min_cnt and cnt >= min_cnt[num+3]) or (num-1 in min_cnt and cnt + 1 < min_cnt[num-1]):\n                minres = min(minres, dfs(num-1, cnt+1))\n        \n            return minres\n        \n        return dfs(n, 0)", "class Solution:\n    @lru_cache()\n    def minDays(self, n: int) -> int:\n        q=deque()\n        q.append(n)\n        v=set()\n        ans=0\n        while(len(q)):\n            l=len(q)\n            for _ in range(l):\n                x=q.popleft()\n                if(x-1== 0):\n                    ans=ans+1\n                    return ans\n                if(x%3==0 and x//3 not in v):\n                    v.add(x)\n                    q.append(x//3)\n                if(x%2==0 and x//2 not in v):\n                    v.add(x)\n                    q.append(x//2)\n                if(x-1 not in v):\n                    v.add(x)\n                    q.append(x-1)\n            ans+=1      \n                \n        return ans            \n                \n                \n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = [n]\n        v = set()\n        steps = 0\n        while len(q) > 0:\n            newq = []\n            while len(q) > 0:\n                node = q.pop()\n                if node == 0: return steps\n                v.add(node)\n                if node % 3 == 0 and node // 3 not in v: newq.append(node // 3)\n                if node % 2 == 0 and node // 2 not in v: newq.append(node // 2)\n                if node - 1 not in v: newq.append(node - 1)\n            q = newq\n            steps += 1\n        return -1", "class Solution:\n    def minDays(self, n: int) -> int:\n        @lru_cache(None)\n        def ok(n, x):\n            if n == 0:\n                return True\n            elif x == 0:\n                return False\n            else:\n                if n % 2 == 0 and ok(n // 2, x - 1):\n                    return True\n                if n % 3 == 0 and ok(n - 2 * n // 3, x - 1):\n                    return True\n                return ok(n - 1, x - 1)\n            \n        left = 0\n        right = n + 1\n        while right - left > 1:\n            mid = (left + right) // 2\n            if ok(n, mid):\n                right = mid\n            else:\n                left = mid\n        return right\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n == 1:\n            return 1\n        \n        from collections import deque\n        queue = deque([n])\n        level = 0\n        seen = set()\n        \n        while queue:\n            if 0 in queue:\n                break\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node not in seen:\n                    seen.add(node)\n                    \n                if node % 2 == 0:\n                    if (node - node // 2) not in seen:\n                        queue.append(node - node // 2)\n                \n                if node % 3 == 0:\n                    if (node - 2 * node // 3) not in seen:\n                        queue.append(node - 2 * node // 3)\n                \n                if node - 1 not in seen:\n                    queue.append(node - 1)\n            level += 1\n\n        return level \n            \n        \n        \n", "class Solution:\n    \n    def minDays(self, n: int) -> int:\n        mem = {1:1}\n        @lru_cache(None)\n        def calCulatedays(num):\n            if not num: return 0\n            if num in mem:\n                return mem[num]\n            summ = num\n            oneCheck = 0\n            if num%3 == 0 :\n                oneCheck+=1\n                summ=min(calCulatedays(num/3),summ)\n            if num%2 == 0 :\n                oneCheck+=1\n                summ=min(calCulatedays(num/2),summ)\n            if oneCheck!=2:\n                summ=min(calCulatedays(num-1),summ)\n            mem[num] = summ+1\n            return mem[num]\n        return calCulatedays(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        self.best = math.inf\n        \n        @lru_cache(None)\n        def f(n, steps):\n            if n == 0:\n                self.best = min(self.best, steps)\n                return steps\n            \n            if steps > self.best:\n                return math.inf\n            ans = math.inf\n            if n % 3 == 0:\n                ans = min(ans, f(n // 3, steps + 1))\n            if n % 2 == 0:\n                ans = min(ans, f(n // 2, steps + 1))\n\n            ans = min(ans, f(n-1, steps + 1))\n            return ans\n        \n        return f(n, 0)", "class Solution:\n    def minDays(self, n: int) -> int: \n        memo = {}\n        def check(num_orange, days_left):\n            if days_left <= 0: return False\n            if num_orange == 1: return True\n            t = (num_orange, days_left)\n            if t in memo: return memo[t]\n            one = check(num_orange - 1, days_left - 1)\n            two = three = False\n            if num_orange % 2 == 0:\n                two = check(num_orange // 2, days_left - 1)\n            if num_orange % 3 == 0:\n                three = check(num_orange // 3, days_left - 1)\n            memo[t] = one or two or three\n            return memo[t]\n            \n        for i in range(1, 50):\n            if check(n, i):\n                return i\n           \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        days = 0\n        tosee = deque([n])\n        seen = set([])\n        while tosee:\n            s = len(tosee)\n            while s:\n                s -= 1\n                cur = tosee.popleft()\n                seen.add(cur)\n                if cur == 0:\n                    return days\n                if cur % 2 == 0 and cur // 2 not in seen:\n                    tosee.append(cur // 2)\n                if cur % 3 == 0 and cur // 3 not in seen:\n                    tosee.append(cur // 3)\n                if cur - 1 not in seen:\n                    tosee.append(cur - 1)\n            days += 1\n        return -1", "from queue import Queue\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q=Queue()\n        q.put((n,0))\n        visited=set()\n        while True:\n            num,days=q.get()\n            if num in visited:\n                continue\n            visited.add(num)\n            if num==0:\n                return days\n            days+=1\n            if num%3==0:\n                q.put((num//3,days))\n            \n            if num%2==0:\n                q.put((num//2,days))\n            q.put((num-1,days))", "class Solution:\n    def minDays(self, n: int) -> int:\n        step = 0\n        seen1 = set([0])\n        seen2 = set([n])\n        q1 = collections.deque([0])\n        q2 = collections.deque([n])\n        if n == 1:\n            return 1\n        while q1 and q2:\n            for _ in range(len(q1)):\n                node = q1.popleft()\n                if node in seen2:\n                    return step\n                if node * 3 < n and node * 3 not in seen1:\n                    q1.append(node * 3)\n                    seen1.add(node * 3)\n                if node * 2 < n and node * 2 not in seen1:\n                    q1.append(node * 2)\n                    seen1.add(node * 2)\n                if node + 1 not in seen1:\n                    q1.append(node + 1)\n                    seen1.add(node + 1)\n            # print(q1, seen1, step)\n            step += 1\n            for _ in range(len(q2)):\n                node = q2.popleft()\n                if node in seen1:\n                    return step\n                if node % 3 == 0 and node // 3 not in seen2:\n                    q2.append(node // 3)\n                    seen2.add(node // 3)\n                if node % 2 == 0 and node // 2 not in seen2:\n                    q2.append(node // 2)\n                    seen2.add(node // 2)\n                if node - 1 not in seen2:\n                    q2.append(node - 1)\n                    seen2.add(node - 1)\n            step += 1\n        return -1\n", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        def bfs(n, days):\n            possible = -1\n            q = deque([(n, 0)])\n            seen= set([])\n            while q:\n                left, days = q.pop()\n                # print(left ,days)\n\n                if left == 0: \n                    return days\n                seen.add(left)\n                if left % 2 == 0 and (left//2 not in seen): q.appendleft((left//2, days + 1))\n                if left % 3 == 0 and (left//3 not in seen): q.appendleft((left//3, days + 1))\n                if left - 1 not in seen: q.appendleft((left -1, days + 1))\n                    \n        return bfs(n,0)\n        \n        \n                \n            \n                \n            \n            \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        import math\n        ans = {}\n\n        def dfs(n, k):\n            if n in ans.keys():\n                return ans[n]\n            if n == 1:\n                return 1\n            if k > 2 * math.log(n)//math.log(2) + 100:\n                return 1e10\n            if n == 0:\n                return 0\n            \n            if n % 3 == 0:\n                op3 = dfs(n//3, k+1) + 1\n            else:\n                op3 = 1e10\n\n            if n % 2 == 0:\n                op2 = dfs(n//2, k+1) + 1\n            else:\n                op2 = 1e10\n        \n            op1 = dfs(n-1, k+1)+1\n            \n            ans[n] = min(op1, min(op2, op3))\n            \n            return ans[n]\n        \n        return dfs(n, 0)", "class Solution:\n    def minDays(self, n: int) -> int:\n        return self.dfs(n)\n    \n    @lru_cache(None)\n    def dfs(self, n):\n        if n < 2:\n            return n\n        if n < 0:\n            return -1\n        ans = sys.maxsize\n        if n % 3 == 0:\n            ans = min(1 + self.dfs(n // 3), ans)\n        if n % 2 == 0:\n            ans = min(1 + self.dfs(n // 2), ans)\n        if (n - 1) % 3 == 0 or (n - 1) % 2 == 0:\n            ans = min(1 + self.dfs(n - 1), ans)\n        if (n - 2) % 3 == 0:\n            ans = min(2 + self.dfs(n - 2), ans)\n        return ans", "class Solution:\n    def minDays(self, n: int) -> int:\n        q=[n]\n        seen = set()\n        res=0\n        while q:\n            nq=[]\n            for x in q: # SIMPLE BFS\n                if x==0: \n                    return res\n                cur=x\n                seen.add(cur)\n                if cur%2==0 and cur/2 not in seen:\n                    nq.append(cur/2)\n                if cur%3==0 and cur/3 not in seen:\n                    nq.append(cur/3)\n                if cur-1 not in seen:\n                    nq.append(cur-1)\n            q=nq\n            res+=1\n", "class Solution:\n    # @lru_cache()\n    def minDays(self, n: int) -> int:\n        # # Method 1: DP -> TLE\n        self.m = 1000\n        self.dp = [0, 1] + [float('inf')] * (self.m-1)\n        for i in range(2,self.m+1):\n            v = []\n            v.append(self.dp[i-1])\n            if i % 2 == 0:\n                v.append(self.dp[i//2])\n            if i % 3 == 0:\n                v.append(self.dp[i//3])\n            self.dp[i] = min(v) + 1\n        # return dp[-1]\n        \n        # # Method 3: Gready -> Dijkstra?\n        def dfs(n):\n            # print(n)\n            if n <= self.m:\n                return self.dp[n]\n            else:\n                return 1 + min(n%2 + dfs(n//2), n%3 + dfs(n//3))\n        return dfs(n)\n        \n        # # Method 2: DP -> TLE\n        # dp = [0, 1] + [float('inf')] * (n-1)\n        # for i in range(1, n+1):\n        #     if i+1 <= n:\n        #         dp[i+1] = min(dp[i+1], dp[i] + 1)\n        #     if i*2 <= n:\n        #         dp[i*2] = min(dp[i*2], dp[i] + 1)\n        #     if i*3 <= n:\n        #         dp[i*3] = min(dp[i*3], dp[i] + 1)\n        # return dp[-1]\n        \n        # # Method 4: DFS\n        # # DFS\n        # def dfs(n):\n        #     if n == 1:\n        #         return 1\n        #     else:\n        #         print(n)\n        #         if n % 3 == 0:\n        #             print(\\\"case 3\\\")\n        #             v3 = dfs(n//3) + 1\n        #             self.ans.append(v3)\n        #         if n % 2 == 0:\n        #             print('case 2')\n        #             v2 = dfs(n//2) + 1\n        #             self.ans.append(v2)\n        #         if n - 1 > 1:\n        #             print('case 1')\n        #             v1 = dfs(n-1) + 1\n        #             self.ans.append(v1)\n        # dfs(n)\n        # return min(self.ans)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = collections.deque()\n        q.append(n)\n        lvl = 0\n        seen = set()\n        while q:\n            size = len(q)\n            for _ in range(size):\n                num = q.popleft()\n                if num == 0:\n                    return lvl\n                seen.add(num)\n                if num % 3 == 0 and num//3 not in seen:\n                    q.append(num//3)\n                if num % 2 == 0 and num//2 not in seen:\n                    q.append(num//2)\n                if num-1 not in seen:\n                    q.append(num-1)\n            \n            lvl += 1\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        q = collections.deque([])\n        q.append((n, 0))\n        seen = set()\n        while q:\n            os, days = q.popleft()\n            # print(os, days)\n            if os == 0:\n                return days\n            if os % 2 == 0:\n                if (os/2, days+1) not in seen:\n                    q.append((os/2, days+1))\n                    seen.add((os/2, days+1))\n            if os % 3 == 0:\n                if (os-(2*(os/3)), days+1) not in seen:\n                    q.append((os-(2*(os/3)), days+1))\n                    seen.add((os-(2*(os/3)), days+1))\n\n            if (os-1, days+1) not in seen:\n                q.append((os-1, days+1))\n                seen.add((os-1, days+1))\n                    \n        return days + 1 if not q else days", "import sys\nsys.setrecursionlimit(1500000)\nfrom functools import lru_cache\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        \n        @lru_cache(None)\n        def helper(n, days,decrement=0):\n            if decrement > 2:\n                return math.inf\n            if n==0:\n                return days;\n\n            best = 1e100\n            best = min(best, helper(n-1,days+1,decrement+1))\n            if n%2==0:\n                best = min(best, helper(n-n/2, days+1))\n            if n%3==0:\n                best = min(best, helper(n-2*(n/3), days+1)) \n                           \n            return best\n                       \n        return helper(n,0)", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue=[[n,0]]\n        seen=set()\n        for i,d in queue:\n            if i==0:\n                return d\n            seen.add(i)\n            if i%3==0 and i//3 not in seen:\n                queue.append([i//3,d+1])\n            if i%2==0 and i//2 not in seen:\n                queue.append([i//2,d+1])\n            if i-1 not in seen:\n                queue.append([i-1,d+1])\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        def nex(n):\n            ans = [n-1]\n            if n % 2 == 0: ans.append(n // 2)\n            if n % 3 == 0: ans.append(n // 3)\n            return ans\n        step = 0\n        states = [n]\n        seen = {n}\n        while True:\n            states = [v for s in states for v in nex(s) if v not in seen]\n            for s in states: seen.add(s)\n            step += 1\n            if 0 in seen: return step\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        from functools import lru_cache\n        import math\n        ans = {}\n        @lru_cache(None)\n        def dfs(n, k):\n            if n in ans.keys():\n                return ans[n]\n            if n == 1:\n                return 1\n            if k > 2 * math.log(n)//math.log(2) + 100:\n                return 1e10\n            if n == 0:\n                return 0\n            \n            if n % 3 == 0:\n                op3 = dfs(n//3, k+1) + 1\n            else:\n                op3 = 1e10\n\n            if n % 2 == 0:\n                op2 = dfs(n//2, k+1) + 1\n            else:\n                op2 = 1e10\n        \n            op1 = dfs(n-1, k+1)+1\n            \n            ans[n] = min(op1, min(op2, op3))\n            \n            return ans[n]\n        \n        return dfs(n, 0)", "class Solution:\n    def minDays(self, n: int) -> int:\n        q,res,seen = [n], 0, set()\n        while q:\n            tmp = set()\n            if 0 in q:\n                return res\n            for p in q:\n                if p-1 not in seen:\n                    tmp.add(p-1)\n                    seen.add(p-1)\n                if p%3 == 0 and p//3 not in seen:\n                    tmp.add(p//3)\n                    seen.add(p//3)\n                if p%2 == 0 and p//2 not in seen:\n                    tmp.add(p//2)\n                    seen.add(p//2)\n            q = tmp\n            res += 1\n        return res", "import math\nfrom collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        if n < 2: return n\n        queue = deque()\n        running_count = n\n        min_days = 0\n        queue.append((min_days,n))\n        seen = set()\n        while queue:\n            level_len = len(queue)\n            for i in range(level_len):\n                local_min, local_n = queue.popleft()\n                seen.add(local_n)\n                if local_n < 0: continue\n                if local_n == 0: return local_min\n                    \n                if local_n%2 == 0 and local_n-local_n//2 not in seen:\n                    queue.append((local_min+1,(local_n-local_n//2)))\n                if local_n%3 == 0 and local_n-2*(local_n//3) not in seen:\n                    queue.append((local_min+1,(local_n-2*(local_n//3))))\n                queue.append((local_min+1,local_n-1))\n        return min_days\n        \n        \n        \n# SEMI OPTIMIZED SOLUTION         \n#     def minDays(self, n: int) -> int:\n#         if n < 2: return n\n#         dp = [math.inf for _ in range(n+1)]\n#         dp[0] = 0\n#         dp[1] = 1\n#         dp[2] = 2\n        \n#         for i in range(3,n+1):\n#             c1,c2,c3 = math.inf,math.inf,math.inf\n#             if i%2 == 0:\n#                 c1 = dp[i - i//2]+1\n#             if i%3 == 0:\n#                 c2 = dp[i - 2*(i//3)]+1\n#             c3 = dp[i-1]+1\n#             dp[i] = min(c1,c2,c3)\n            \n#         return dp[n]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n# ##### BRUTE FORCE        ####\n#     def minDays(self, n: int) -> int:\n#         self.dic = {}\n#         return self.helper(n,0)\n    \n#     def helper(self, days_left, count):\n#         if days_left == 0: return count\n#         c1,c2,c3 = math.inf, math.inf, math.inf\n#         c1 = self.helper(days_left-1,count+1)\n#         if days_left %2 ==0:\n#             c2 = self.helper(days_left//2,count+1)\n#         if days_left % 3 ==0:\n#             c3 = self.helper(days_left//3,count+1)\n        \n#         return min(c1,c2,c3)\n\n\n\n#     def minDays(self, n: int) -> int:\n#         if n < 2: return n\n#         dp = [math.inf for _ in range(n+1)]\n#         dp[0] = 0\n#         dp[1] = 1\n#         dp[2] = 2\n        \n#         for i in range(3,n+1):\n#             c1,c2,c3 = math.inf,math.inf,math.inf\n#             if i%2 == 0:\n#                 c1 = dp[i - i//2]+1\n#             if i%3 == 0:\n#                 c2 = dp[i - 2*(i//3)]+1\n#             c3 = dp[i-1]+1\n#             dp[i] = min(c1,c2,c3)\n            \n#         return dp[n]\n", "# from functools import lru_cache\n\n# # \u66b4\u529bbfs\u80fd\u8fc7\uff0c\u4f46\u662f\u662ftop-down\u7684\uff0c\u6bd4\u8d5b\u7684\u65f6\u5019\u6211\u641e\u9519\u4e86\n# class Solution:\n#     def minDays(self, n: int) -> int:\n        \n#         vis = set()\n#         q = collections.deque([n])\n#         cost = 1\n#         while True:\n#             for i in range(len(q)):\n#                 cur = q.popleft()\n#                 if cur <= 1:\n#                     return cost\n#                 if cur in vis:\n#                     continue\n#                 vis.add(cur)\n#                 q.append(cur-1)\n#                 if not cur % 2:\n#                     q.append(cur//2)\n#                 if not cur % 3:\n#                     q.append(cur//3)\n#             cost += 1\n                \n#         return dfs(n)\n    \n## \u4e4b\u540e\u662f\u526a\u679d\n\n## \u526a\u679d\u4e00\uff0c\nclass Solution:\n    def minDays(self, n: int) -> int:\n        ans = 1\n        queue = [n]\n        seen = set()\n        while queue: #bfs \n            newq = []\n            for x in queue: \n                if x == 1: return ans \n                seen.add(x)\n                if x-1 not in seen: newq.append(x-1)\n                if x % 2 == 0 and x//2 not in seen: newq.append(x//2)\n                if x % 3 == 0 and x//3 not in seen: newq.append(x//3)\n            ans += 1\n            queue = newq \n            \n            \n## \u526a\u679d2 https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794088/Intuitive-solution-with-Proof\n\n# from functools import lru_cache\n# class Solution:\n#     def minDays(self, n: int) -> int:\n        \n#         @lru_cache(None)\n#         def helper(n, one=0):\n#             if one >= 3:\n#                 return math.inf\n#             if n < 1: return n\n            \n#             prev = helper(n - 1, one + 1)\n#             if not n % 2:\n#                 prev = min(prev, helper(n // 2))\n#             if not n % 3:                \n#                 prev = min(prev, helper(n // 3))\n#             return prev + 1                \n        \n#         return helper(n)\n\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        ans = 1\n        bfs = [n]\n        seen = set()\n        while bfs: #bfs \n            bfs2 = []\n            for x in bfs: \n                if x == 1: return ans \n                seen.add(x)\n                if x-1 not in seen: bfs2.append(x-1)\n                if x % 2 == 0 and x//2 not in seen: bfs2.append(x//2)\n                if x % 3 == 0 and x//3 not in seen: bfs2.append(x//3)\n            ans += 1\n            bfs = bfs2 ", "class Solution:\n    def minDays(self, n: int) -> int:\n        ans = 1 \n        queue = [n]\n        seen = set()\n        while queue:\n            newq = []\n            for x in queue:\n                if x == 1: return ans\n                seen.add(x)\n                if x - 1 not in seen: newq.append(x - 1)\n                if x % 2 == 0 and x // 2 not in seen: newq.append(x // 2)\n                if x % 3 == 0 and x // 3 not in seen: newq.append(x // 3)\n            ans += 1\n            queue = newq\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        def fun(n,d):\n            if(n<=1):\n                return n\n            if(n in d):\n                return d[n]\n            d[n]=min(n%2+fun(n//2,d),n%3+fun((n)//3,d))+1\n            return d[n]\n            # t=0\n            # if(n%3==0):\n            #     b=fun(n-2*n//3,d)+1\n            #     t=1\n            # elif(n%3==1):\n            #     b=fun((n-1)-2*(n-1)//3,d)+2\n            #     #b=float(\\\"inf\\\")\n            #     n=n-1\n            #     t=1\n            # else:\n            #     b=float(\\\"inf\\\")\n            # #v=fun(n-1,d)+1\n            # if(t==0):\n            #     if(n%2==0):\n            #         a=fun(n//2,d)+1\n            #     elif(n%2==1):\n            #         a=fun((n-1)-(n-1)//2,d)+2\n            #         n=n-1\n            # else:\n            #     a=float(\\\"inf\\\")\n            # #if(v1==v2):\n            # #      d[v1]=min(a,b)\n            # d[n]=min(a,b)\n            # return d[n]\n        d={}\n        return fun(n,d)", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = deque()\n        \n        q.append(n)\n        days=0\n        seen = set()\n        while q:\n            days+=1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == 1:\n                    return days\n                \n                if node%3 == 0 and node//3 not in seen:\n                    q.append(node//3)\n                    seen.add(node//3)\n                if node%2 == 0 and node//2 not in seen:\n                    q.append(node//2)\n                    seen.add(node//2)\n                if node-1 not in seen:\n                    q.append(node-1)\n                    seen.add(node-1)", "# class Solution:\n#     def minDays(self, n: int) -> int:\n#         memo = {}\n#         def helper(n):\n#             # base case\n#             if n<=1:\n#                 return n\n#             if n in memo:\n#                 return memo[n]\n#             minDays = float(\\\"inf\\\")\n#             # don't need to check helper(n-1)\n#             # if n is not divisible by 2, we eat 1 by 1 until it is divisible\n#             # if n is not divisible by 3, we eat 1 by 1 until it is divisible\n#             minDays = min(n%2 + helper(n//2), n%3 + helper(n//3)) + 1\n#             memo[n] = minDays\n#             return minDays\n        \n#         return helper(n)\n\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        ans = 0\n        visited = set([n])\n        q = collections.deque([n])\n        while q:\n            size = len(q)\n            for _ in range(size):\n                cur = q.popleft()\n                if cur == 0:\n                    return ans\n                if cur-1 not in visited:\n                    visited.add(cur-1)\n                    q.append(cur-1)\n                if cur%2==0 and cur//2 not in visited:\n                    visited.add(cur//2)\n                    q.append(cur//2)\n                if cur%3==0 and cur//3 not in visited:\n                    visited.add(cur//3)\n                    q.append(cur//3)\n            ans += 1\n        return -1", "class Solution:\n    def minDays(self, n):\n        # \u597d\u9898\n        # \u4e00\u5171\u6709n\u4e2a\u6a58\u5b50\n        # \u6bcf\u5929\u67093\u4e2d\u9009\u9879\u5403\u6a58\u5b50\n        # \u8981\u4e48\u5403\u4e00\u4e2a\n        # \u5982\u679c\u6a58\u5b50\u6570\u5b57\u53ef\u4ee5\u88ab2\u6574\u9664\uff0c\u5403\u4e00\u534a\n        # \u5982\u679c\u6a58\u5b50\u6570\u5b57\u53ef\u4ee5\u88ab3\u6574\u9664\uff0c\u54031 / 3\n        # \u95ee\u6700\u5c11\u51e0\u5929\u5403\u5b8c\n\n        # \u601d\u8def\uff1a\u7ecf\u5178bfs\uff0cqueue\u91cc\u653e\u5f53\u524d\u5269\u4e0b\u7684\u6a58\u5b50\u6570\u5b57\u5373\u53ef\n        queue = deque([n])\n        visited = set()\n        steps = 0\n        \n        # bfs\u4e2d\u5f88\u7ecf\u5178\u7684\u4e00\u4e2a\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u4f18\u5316\u5c31\u662f\u5229\u7528visited\u6570\u7ec4\n        while queue:\n            q_len = len(queue)\n            for _ in range(q_len):\n                remain = queue.popleft()\n                if remain == 0:\n                    return steps\n                if remain - 1 not in visited:\n                    queue.append((remain - 1))\n                    visited.add(remain - 1)\n                if remain // 2 > 0 and remain % 2 == 0 and remain // 2 not in visited:\n                    queue.append(remain // 2)\n                    visited.add(remain // 2)\n                if remain // 3 > 0 and remain % 3 == 0 and remain // 3 not in visited:\n                    queue.append(remain // 3)\n                    visited.add(remain // 3)\n            steps += 1\n        return steps", "class Solution:\n    def minDays(self, n):\n        queue = deque([n])\n        visited = set()\n        visited.add(n)\n        \n        steps = 0\n        \n        while queue:\n            q_len = len(queue)\n            for _ in range(q_len):\n                curr = queue.popleft()\n                if curr == 0:\n                    return steps\n                if curr - 1 not in visited:\n                    queue.append(curr - 1)\n                    visited.add(curr - 1)\n                if curr % 2 == 0 and curr // 2 > 0 and curr // 2 not in visited:\n                    queue.append(curr // 2)\n                    visited.add(curr // 2)\n                if curr % 3 == 0 and curr // 3 > 0 and curr // 3 not in visited:\n                    queue.append(curr // 3)\n                    visited.add(curr // 3)\n            steps += 1\n        return -1", "class Solution:\n    def minDays(self, n):\n        # \u597d\u9898\n        # \u4e00\u5171\u6709n\u4e2a\u6a58\u5b50\n        # \u6bcf\u5929\u67093\u4e2d\u9009\u9879\u5403\u6a58\u5b50\n        # \u8981\u4e48\u5403\u4e00\u4e2a\n        # \u5982\u679c\u6a58\u5b50\u6570\u5b57\u53ef\u4ee5\u88ab2\u6574\u9664\uff0c\u5403\u4e00\u534a\n        # \u5982\u679c\u6a58\u5b50\u6570\u5b57\u53ef\u4ee5\u88ab3\u6574\u9664\uff0c\u54031 / 3\n        # \u95ee\u6700\u5c11\u51e0\u5929\u5403\u5b8c\n\n        # \u601d\u8def\uff1a\u7ecf\u5178bfs\uff0cqueue\u91cc\u653e\u5f53\u524d\u5269\u4e0b\u7684\u6a58\u5b50\u6570\u5b57\u5373\u53ef\n        queue = deque([n])\n        visited = set()\n        steps = 1\n        \n        # bfs\u4e2d\u5f88\u7ecf\u5178\u7684\u4e00\u4e2a\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u4f18\u5316\u5c31\u662f\u5229\u7528visited\u6570\u7ec4\n        while queue:\n            q_len = len(queue)\n            for _ in range(q_len):\n                remain = queue.popleft()\n                if remain == 0:\n                    return steps - 1\n                if remain - 1 not in visited:\n                    queue.append((remain - 1))\n                    visited.add(remain - 1)\n                if remain // 2 > 0 and remain % 2 == 0 and remain // 2 not in visited:\n                    queue.append(remain // 2)\n                    visited.add(remain // 2)\n                if remain // 3 > 0 and remain % 3 == 0 and remain // 3 not in visited:\n                    queue.append(remain // 3)\n                    visited.add(remain // 3)\n            steps += 1\n        return steps", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n <= 0:\n            return 0\n        q = [n]\n        ans = 0\n        visited = {n}\n        while q:\n            size = len(q)\n            for _ in range(size):\n                i = q.pop(0)\n                if i == 1:\n                    return ans + 1\n\n                if i % 3 == 0:\n                    next = i - 2 * i // 3\n                    if next not in visited:\n                        q.append(next)\n                        visited.add(next)       \n\n                if i % 2 == 0:\n                    next = i // 2\n                    if next not in visited:\n                        q.append(next)\n                        visited.add(next)\n                \n                if (i - 1) not in visited:\n                    q.append(i-1)\n                    visited.add(i-1)\n            ans += 1\n        return 0", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue = deque([n])\n        visited = set()\n        steps = 1\n        \n        while queue:\n            q_len = len(queue)\n            for _ in range(q_len):\n                remain = queue.popleft()\n                if remain == 0:\n                    return steps - 1\n                if remain - 1 not in visited:\n                    queue.append((remain - 1))\n                    visited.add(remain - 1)\n                if remain // 2 > 0 and remain % 2 == 0 and remain // 2 not in visited:\n                    queue.append(remain // 2)\n                    visited.add(remain // 2)\n                if remain // 3 > 0 and remain % 3 == 0 and remain // 3 not in visited:\n                    queue.append(remain // 3)\n                    visited.add(remain // 3)\n            steps += 1\n        return steps\n        \n        \n#         queue = deque([(n, 1)])\n#         steps = 1\n        \n#         while queue:\n#             q_len = len(queue)\n#             for _ in range(q_len):\n#                 remain, curr = queue.popleft()\n#                 remain -= curr\n#                 if remain == 0:\n#                     print('hehe')\n#                     return steps\n#                 queue.append((remain, 1))\n#                 if remain // 2 > 0 and remain % 2 == 0:\n#                     queue.append((remain, remain // 2))\n#                 if remain - 2 * remain // 3 > 0 and remain % 3 == 0:\n#                     queue.append((remain, remain - 2 * remain // 3))\n#             steps += 1\n#         return steps\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        from collections import deque\n        q = deque()\n        q.append((n, 0))\n        visited = set()\n        while q:\n            \n            new_n, days = q.pop()\n            if new_n == 0:\n                return days\n\n            if new_n in visited:\n                continue\n                \n            q.appendleft((new_n - 1, days + 1))\n            if new_n % 2 == 0:\n                q.appendleft((new_n // 2, days + 1))\n            if new_n % 3 == 0:\n                q.appendleft((new_n // 3, days + 1))           \n            \n            visited.add(new_n)\n        \n        return -1\n        \n    def find(self, n, memo):\n        # DFS\n        if n <= 1:\n            return n\n        \n        if n in memo:\n            return memo[n]\n        \n        min_val = self.find(n-1, memo)\n        \n        if n % 2 == 0:\n            min_val = min(min_val, self.find(n // 2, memo))\n        \n        if n % 3 == 0:\n            min_val = min(min_val, self.find((n // 3), memo))\n        \n        memo[n] = min_val + 1\n        return memo[n]\n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n#         Iterative DFS(Time Limit Exceded)\n\n#         stack = [(n, 0)]\n#         minDays = float('inf')\n#         seen = {}\n#         while stack:\n#             numOrgs, curDays = stack.pop()\n            \n#             if numOrgs == 0:\n#                 minDays = min(minDays, curDays)\n#                 continue\n            \n#             if numOrgs < 0:\n#                 continue\n            \n#             stack.append((numOrgs - 1, curDays + 1))\n            \n#             if numOrgs % 2 == 0:\n#                 stack.append((numOrgs - (numOrgs // 2), curDays + 1))\n            \n#             if numOrgs % 3 == 0:\n#                 stack.append((numOrgs - 2 * (numOrgs // 3), curDays + 1))\n        \n#         return minDays\n\n\n\n#         DFS with cache(reached max depth)\n\n#         def dfs(numOrngs):\n#             if numOrngs in seen:\n#                 return seen[numOrngs]\n            \n#             if numOrngs == 0:\n#                 return 1\n            \n#             if numOrngs < 0:\n#                 return float('inf')\n            \n#             a = dfs(numOrngs - 1)\n            \n#             b = float('inf')\n#             if numOrngs % 2 == 0:\n#                 b = dfs(numOrngs - (numOrngs // 2))\n            \n#             c = float('inf')\n#             if numOrngs % 3 == 0:\n#                 c = dfs(numOrngs - 2 * (numOrngs // 3))\n            \n#             seen[numOrngs] = min(a, b, c) + 1\n            \n#             return seen[numOrngs]\n        \n#         seen = {}\n#         return dfs(n) - 1\n        \n        def dfs(numOrngs):\n            \n            if numOrngs in seen:\n                return seen[numOrngs]\n            \n            if numOrngs == 0:\n                return 0\n            \n            if numOrngs < 0:\n                return float('inf')\n            \n            seen[numOrngs] = min((numOrngs % 2) + dfs(numOrngs // 2), (numOrngs % 3) + dfs(numOrngs // 3)) + 1\n            \n            return seen[numOrngs]\n        \n        seen = {}\n        return dfs(n) - 1", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        c = {n: 0}\n        q = collections.deque([n])\n        \n        while 1:\n            x = q.popleft()\n            if x == 0: return c[x]\n            if x%3 == 0 and x/3 not in c:\n                c[x/3] = c[x]+1\n                q.append(x/3)\n            if x%2 == 0 and x/2 not in c:\n                c[x/2] = c[x]+1\n                q.append(x/2)\n            if x-1 not in c:\n                c[x-1] = c[x]+1\n                q.append(x-1)", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = collections.deque([n])\n        day = 0\n        visited = set([n])\n        while q:\n            day+=1\n            l = len(q)\n            for i in range(l):\n                tmp = q.popleft()\n                if tmp-1 not in visited:\n                    if tmp-1 == 0:\n                        return day\n                    visited.add(tmp-1)\n                    q.append(tmp-1)\n                if tmp%2 == 0 and tmp/2 not in visited:\n                    visited.add(tmp/2)\n                    q.append(tmp/2)\n                if tmp%3 == 0 and tmp/3 not in visited:\n                    visited.add(tmp/3)\n                    q.append(tmp/3)", "from collections import deque\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = deque()\n        visited = set()\n        q.append((n, 0))\n        while len(q) > 0:\n            cur, step = q.popleft()\n            if cur in visited:\n                continue\n            visited.add(cur)\n            if cur == 0:\n                return step\n            if cur % 2 == 0:\n                q.append((cur // 2, step + 1))\n            if cur % 3 == 0:\n                q.append((cur // 3, step + 1))\n            q.append((cur - 1, step + 1))\n        \n        return n\n        \n", "import sys\nsys.setrecursionlimit(1500000)\nclass Solution:\n    def minDays(self, n: int) -> int:\n        # \u6211\u5f53\u65f6\u770b\u5230\u6570\u636e\u8303\u56f4n\u89c9\u5f97\u76f4\u63a5dp(n)\u4f1a\u8d85\u65f6\u56e0\u6b64\u6211\u5c31\u6ca1\u505a\u3002\n        # \u4f46\u662f\u5b9e\u9645\u4e0a\u6bcf\u6b21\u90fd\u662f\u6574\u96642\u6574\u96643\u5176\u5b9e\u53ea\u9700\u8981log(n)\u65f6\u95f4\u5c31\u641e\u5b9a\uff01\n        @lru_cache(None)\n        def go(x):\n            if x == 0:\n                return 0\n            \n            best = 1e100\n            if x % 2 == 0:\n                best = min(best, go(x // 2) + 1)\n            if x % 3 == 0:\n                best = min(best, go(x // 3) + 1)\n            \n            if x <= (1024) or x % 2 > 0 or x % 3 > 0:\n                best = min(best, go(x - 1) + 1)\n                \n            return best\n        return go(n)\n        '''\n        @lru_cache(None)\n        def dp(x):\n            if x <= 1: return x\n            res = x\n            res = min(res, dp(x//3) + x % 3 + 1)\n            res = min(res, dp(x//2) + x % 2 + 1)\n            return res\n        return dp(n)\n        '''", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        dq = deque([(0,n)])\n        res = 0\n        \n        seen = set()\n        \n        while dq:\n            layer,num = dq.popleft()\n            if num in seen:\n                continue\n            else:\n                seen.add(num)\n            if num==0:\n                return layer\n            if num%3 == 0:\n                dq.append((layer+1,num/3))\n            if num%2 == 0:\n                dq.append((layer+1,num/2))\n            dq.append((layer+1,num-1))\n        return 0\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        days = 0\n        fringe = deque([n])\n        seen = set()\n        \n        while fringe:\n            for _ in range(len(fringe)):\n                n = fringe.popleft()\n                if n == 0:\n                    return days\n                \n                if n - 1 not in seen:\n                    fringe.append(n - 1)\n                    seen.add(n - 1)\n                if n % 2 == 0 and n // 2 not in seen:\n                    fringe.append(n // 2)\n                    seen.add(n // 2)\n                if n % 3 == 0 and n // 3 not in seen:\n                    fringe.append(n // 3)\n                    seen.add(n // 3)\n        \n            days += 1\n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        res = 0\n        hashmap = {}\n        queue = [n]\n        while queue:\n            new = []\n            for item in queue:\n                if item in hashmap:\n                    continue \n                if item == 0:\n                    return res\n                if item%2==0:\n                    new.append(item-item//2)\n                if item%3 == 0:\n                    new.append(item-((item//3)*2))\n                hashmap[item] = res\n                new.append(item-1)\n            res += 1\n            queue = new\n        \n", "class Solution:\n    @lru_cache()\n    def minDays(self, n: int) -> int:\n        x=y=z=sys.maxsize\n        if n <= 1:\n            return n;\n        if(n%2==0):\n            x= 1+ self.minDays(n // 2)\n        if(n%3==0):\n            y= 1+ self.minDays(n // 3)\n        if(n%3!=0 or n%2!=0):\n            z= 1+ self.minDays(n-1)\n            \n        return  min(x,y,z);  \n                \n                \n            \n                \n        \n            \n", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        \n        d={}\n        q=deque([n])\n        d[n]=0\n        while q and 0 not in d:\n            item=q.popleft()\n            day=d[item]+1\n            temp=[item-1]\n            if item%2==0:\n                temp.append(item//2)\n            if item%3==0:\n                temp.append(item//3)\n                \n            for i in temp:\n                if i not in d:\n                    d[i]=day\n                    q.append(i)\n                    \n        \n        return d[0]\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n", "memo={}; f=min\nclass Solution:\n    def minDays(self, n: int) -> int:\n        if n<2: return n\n        if n in memo: return memo[n]\n        a=1+f(self.minDays(n//2)+n%2, self.minDays(n//3)+n%3);memo[n]=a        \n        return a\n        \n\n\n", "class Solution:\n    def minDays(self, N: int) -> int:\n        def find_edges(x):\n            edges=[]\n            if x-1>=0:\n                edges.append(x-1)\n            if x%2==0:\n                edges.append(x//2)\n            if x%3==0:\n                edges.append(x//3)\n            return edges\n    \n        q = [N] # make queue\n        dist = {N:0} # distance dictionary. can use this as visited dictionary too!\n        #parent = {N:None}\n        while q:\n            v=q.pop(0)\n            v_edges = find_edges(v)\n            for edge in v_edges:\n                if not dist.get(edge,False):\n                    if edge == 0:\n                        return dist[v]+1\n                    dist[edge]=dist[v]+1\n                    #parent[edge] = v\n                    q.append(edge)\n        return dist[0]\n", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        visit = {}\n        q = deque()\n        q.append((n,0))\n        visit[n] = True\n        while q:\n            num_oranges, num_days = q.popleft()\n            if num_oranges == 0:\n                return num_days\n            \n            if  not (num_oranges-1 in visit):\n                q.append((num_oranges-1, num_days+1))\n                visit[num_oranges-1] = True\n            if num_oranges%2 == 0 and not(num_oranges//2 in visit):\n                q.append((num_oranges//2, num_days+1))\n                visit[num_oranges//2] = True\n            if num_oranges%3 == 0 and not(num_oranges//3 in visit):\n                q.append((num_oranges//3, num_days+1))\n                visit[num_oranges//3] = True", "class Solution:\n    def minDays(self, n: int) -> int:\n\n        q = collections.deque([])\n        q.append((n, 0))\n        seen = set()\n        while q:\n            oranges, days = q.popleft()\n            if oranges <= 3:\n                return days + min(2, oranges)\n            if oranges % 2 == 0:\n                if oranges/2 not in seen:\n                    q.append((oranges/2, days+1))\n                    seen.add(oranges/2)\n            if oranges % 3 == 0:\n                if oranges-(2*(oranges/3)) not in seen:\n                    q.append((oranges-(2*(oranges/3)), days+1))\n                    seen.add(oranges-(2*(oranges/3)))\n\n            if oranges-1 not in seen:\n                q.append((oranges-1, days+1))\n                seen.add(oranges-1)\n", "from collections import deque\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        res = 0\n        if n == 0:\n            return res\n        q = deque([n])\n        seen = set([n])\n        while q:\n            res += 1\n            s = len(q)\n            while s > 0:\n                s -= 1\n                i = q.popleft()\n                if i % 2 == 0:\n                    c = i // 2\n                    if not c in seen:\n                        seen.add(c)\n                        q.append(c)\n                if i % 3 == 0:\n                    c = i // 3\n                    if not c in seen:\n                        seen.add(c)\n                        q.append(c)\n                if i - 1 == 0:\n                    return res\n                if not i - 1 in seen:\n                    seen.add(i - 1)\n                    q.append(i - 1)\n        return -1     ", "class Solution:\n    def minDays(self, n: int) -> int:\n        from collections import deque\n        q = deque([(n, 1)])\n        seen = set([n])\n        \n        while q:\n            # print(q)\n            node, lvl = q.popleft()\n            if node==1:\n                return lvl\n            if node-1 not in seen:\n                q.append((node-1, lvl+1))\n                seen.add(node-1)\n            if node%2==0 and node//2 not in seen:\n                q.append((node//2, lvl+1))\n                seen.add(node//2)\n            if node%3==0 and node - 2*(node)//3 not in seen:\n                q.append((node - 2*(node)//3, lvl+1))\n                seen.add(node - 2*(node)//3)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        q = collections.deque()\n        q.append([n, 0])\n        visited = set([n])\n        while len(q) > 0:\n            x, d = q.popleft()\n            if x == 0:\n                return d\n            \n            neighbors = [x-1]\n            if x % 2 == 0:\n                neighbors.append(x//2)\n            if x % 3 == 0:\n                neighbors.append(x//3)\n            \n            for y in neighbors:\n                if y in visited:\n                    continue\n                q.append([y, d + 1])\n                visited.add(y)\n            \n        \n        g = {1: 1}\n        x = 1\n        for i in range(0, 30):\n            for j in range(0, 20):\n                x = (2**i) * (3**j)\n                if x <= 1000000000:\n                    g[x] = i + j\n        days = 0\n        while n > 1 and n not in g:\n            days += 1\n            n -= 1\n        if n in g:\n            days += g[n]\n        return days\n        \n        f = [None] * (n + 1)\n        f[1] = 1\n        for k in range(2, n + 1):\n            f[k] = 1 + f[k-1]\n            if k % 2 == 0:\n                f[k] = min(f[k], 1 + f[k//2])\n            if k % 3 == 0:\n                f[k] = min(f[k], 1 + f[k//3])\n        return f[n]", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        q = deque()\n        \n        q.append((n, 0))\n        \n        visited = set()\n        visited.add(n)\n        \n        while q:\n            cur, numSteps = q.popleft()\n            \n            if cur == 0:\n                return numSteps\n            \n            if cur - 1 not in visited:\n                q.append((cur - 1, numSteps + 1))\n                visited.add(cur - 1)\n            \n            if cur % 2 == 0 and cur // 2 not in visited:\n                q.append((cur // 2, numSteps + 1))\n                visited.add(cur // 2)\n            \n            if cur % 3 == 0 and cur // 3 not in visited:\n                q.append((cur // 3, numSteps + 1))\n                visited.add(cur // 3)\n        \n        return 0\n                \n            \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        cache = {n: 1}\n        q = [n]\n        level = 0\n        while q:\n            _q = []\n            for val in q:\n                if val == 0:\n                    return level\n            \n                _val = val - 1\n                if _val not in cache and _val >= 0:\n                    cache[_val] = 1\n                    _q.append(_val)\n\n                _val = val - val // 2\n                if _val not in cache and val % 2 == 0 and _val >= 0:\n                    cache[_val] = 1\n                    _q.append(_val)\n\n                _val = val - (2 * val) // 3\n                if _val not in cache and val % 3 == 0 and _val >= 0:\n                    cache[_val] = 1\n                    _q.append(_val)\n            q = _q\n            level += 1\n        return -1", "class Solution:\n    def minDays(self, n: int) -> int:\n        \n        @lru_cache(None)\n        def solve(n):\n            if n <= 1:\n                return n\n            return 1 + min(n%2 + solve(n//2), n%3 + solve(n//3))\n        return solve(n)", "import heapq\nclass Solution:\n    def minDays(self, n: int) -> int:\n\n        heap = [[0,n]] # BFS\n        \n        covered = set()\n        \n        while True:\n            \n            # print(heap, \\\" ||| \\\", covered)\n            node = heapq.heappop(heap)\n            \n            if node[1] == 0:\n                return node[0]\n            \n            if node[1] not in covered:\n                covered.add(node[1])\n                heapq.heappush(heap, [node[0]+1, node[1]-1])\n            \n            if node[1]%2 == 0 and node[1]//2 not in covered:\n                covered.add(node[1])\n                heapq.heappush(heap, [node[0]+1, node[1]//2])\n                \n            if node[1]%3 == 0 and node[1]//3 not in covered:\n                covered.add(node[1])\n                heapq.heappush(heap, [node[0]+1, node[1]//3])\n                \n        \n", "class Solution:\n    def minDays(self, N: int) -> int:\n        def find_edges(x):\n            edges=[]\n            if x-1>=0:\n                edges.append(x-1)\n            if x%2==0:\n                edges.append(x//2)\n            if x%3==0:\n                edges.append(x//3)\n            return sorted(edges)\n    \n        q = [N] # make queue\n        dist = {N:0} # distance dictionary. can use this as visited dictionary too!\n        #parent = {N:None}\n        while q:\n            v=q.pop(0)\n            v_edges = find_edges(v)\n            for edge in v_edges:\n                if not dist.get(edge,False):\n                    if edge == 0:\n                        return dist[v]+1\n                    dist[edge]=dist[v]+1\n                    #parent[edge] = v\n                    q.append(edge)\n        return dist[0]\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue = set([n])\n        res = 0\n        \n        while queue:\n            tmp = set()\n            res += 1\n            for a in queue:\n                if a == 1: return res\n                if a % 2 == 0 and a//2 not in queue:\n                    tmp.add(a//2)\n                if a % 3 == 0 and a//3 not in queue:\n                    tmp.add(a//3)\n                tmp.add(a-1)\n\n            queue = tmp\n            \n        return res", "class Solution:\n    def minDays(self, n: int) -> int:\n\n        q = collections.deque([])\n        q.append((n, 0))\n        seen = set()\n        while q:\n            os, days = q.popleft()\n            if os == 0:\n                return days\n            if os % 2 == 0:\n                if os/2 not in seen:\n                    q.append((os/2, days+1))\n                    seen.add(os/2)\n            if os % 3 == 0:\n                if os-(2*(os/3)) not in seen:\n                    q.append((os-(2*(os/3)), days+1))\n                    seen.add(os-(2*(os/3)))\n\n            if os-1 not in seen:\n                q.append((os-1, days+1))\n                seen.add(os-1)\n                    \n        return days + 1 if not q else days\n", "class Solution:\n    \n    def minDays(self, n: int) -> int:\n        def recur(n: int) -> int:\n            if n <= 1:\n                return n;\n            if n>=self.N or self.arr[n]==-1: \n                ans=1 + min(n % 2 + recur(n // 2), n % 3 + recur(n // 3))\n                if n<self.N: self.arr[n]=ans\n            else:\n                ans=self.arr[n]\n            return ans;   \n    \n        self.N=min(100000,n)\n        self.arr=[-1]*self.N\n\n        return recur(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        frontier = deque()\n        visited = dict()\n        visited[n] = 0\n        frontier.append(n)\n        \n        while frontier:\n            curr = frontier.popleft()\n            \n            if curr == 0:\n                return visited[curr]\n            \n            neighbors = [curr - 1]\n            \n            if curr % 2 == 0:\n                neighbors.append(curr//2)\n            \n            if curr % 3 == 0:\n                neighbors.append(curr//3)\n            \n            for nbr in neighbors:\n                if nbr not in visited:\n                    visited[nbr] = visited[curr] + 1\n                    frontier.append(nbr)\n        return -1", "class Solution:\n    def minDays(self, n: int) -> int:\n        self.ans = float('inf')\n        @lru_cache(None)\n        def search(days,num):\n            if num==0:\n                if days<self.ans:\n                    self.ans = days\n                return\n            if days+int(math.log(num)/math.log(3))+1>=self.ans:\n                return\n            days += 1\n            if not num%3:\n                search(days,num//3)\n            if not num%2:\n                search(days,num//2)\n            search(days,num-1)\n            return\n        \n        search(0,n)\n        return self.ans", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n == 1:\n            return 1\n        q = collections.deque([(n, 0)])\n        visited = set([n])\n        \n        while q:\n            c, step = q.pop()\n            step += 1\n            \n            if c % 3 == 0:\n                nc = c // 3\n                if nc == 1:\n                    return step + 1\n                if nc not in visited:\n                    visited.add(nc)\n                    q.appendleft((nc, step))\n            if c % 2 == 0:\n                nc = c // 2\n                if nc == 1:\n                    return step + 1\n                if nc not in visited:\n                    visited.add(nc)\n                    q.appendleft((nc, step))\n            \n            if c - 1 == 1:\n                return step + 1\n            q.appendleft((c-1, step))\n            \n        return -1\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        import sys\n        from collections import deque\n        MAX = sys.maxsize\n        mem = {}\n        \n        q = deque()\n        q.append((n,0)) # n remain, op\n        \n        while q:\n            i, op = q.popleft()\n            if i == 0:\n                return op\n            if i not in mem:\n                # get 1\n                q.append((i-1, op+1))\n                # get m1 when /2\n                if i % 2 == 0:\n                    q.append((int(i-(i/2)), op+1))\n                # get m2 when /3\n                if i % 3 == 0:\n                    q.append((int(i-(i/3)*2), op+1))\n                mem[i] = op\n", "memo={}; f=min\nclass Solution:\n    def minDays(self, n: int) -> int:\n        if n==0: \n            return 0\n        if n==1:\n            return 1\n        if n in memo:\n            return memo[n]\n        \n        \n        sol = min(self.minDays(n//2)+n%2+1, self.minDays(n//3)+n%3+1)\n        memo[n]=sol\n        \n        return sol\n        \n\n\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        level = 0\n        visited = set()\n        while q:\n            # print(q)\n            size = len(q)\n            for i in range(size):\n                cur = q.popleft()\n                if cur == 0:\n                    return level\n                if cur % 2 == 0 and cur-cur//2 not in  visited:\n                    visited.add(cur-cur//2)\n                    q.append(cur-cur//2)\n                if cur % 3 == 0 and cur-2*cur//3 not in visited:\n                    visited.add(cur-2*cur//3)\n                    q.append(cur-2*cur//3)\n                if cur-1 not in visited:\n                    visited.add(cur-1)\n                    q.append(cur-1)\n            level += 1\n", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        days = 0\n        visited = set()\n        \n        while q:\n            days += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == 1:\n                    #print(visited)\n                    return days\n                if node % 3 == 0 and node % 3 not in visited:\n                    q.append(node // 3)\n                    visited.add(node // 3)\n                if node % 2 == 0 and node % 2 not in visited:\n                    q.append(node // 2)\n                    visited.add(node // 2)\n                if node - 1 not in visited:\n                    q.append(node - 1)\n                    visited.add(node - 1)", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        day=0\n        q=deque([n])\n        visited=set()\n        while q:\n            day+=1\n            for _ in range(len(q)):\n                v =q.popleft()\n                if v==1:\n                    return day\n                if v%3==0 and v%3 not in visited:\n                    q.append(v//3)\n                    visited.add(v//3)\n                if v%2==0:\n                    q.append(v//2)\n                    visited.add(v//3)\n                if v-1 not in visited:\n                    q.append(v-1)\n                    visited.add(v-1)", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        days = 0\n        visited = set()\n        \n        while q:\n            days += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == 1:\n                    return days\n                if node % 3 == 0 and node % 3 not in visited :\n                    q.append(node//3)\n                    visited.add(node//3)\n                if node % 2 == 0 and node % 3 not in visited:\n                    q.append(node//2)\n                    visited.add(node//2)\n                if node - 1 not in visited:\n                    q.append(node-1)\n                    visited.add(node-1)", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        days = 0\n        visited = set()\n        while q:\n            days+=1\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if cur == 1:\n                    return days\n                if cur%2 == 0 and cur%2 not in visited:\n                    q.append(cur//2)\n                    visited.add(cur//2)\n                if cur%3 == 0 and cur%3 not in visited:\n                    q.append(cur//3)\n                    visited.add(cur//3)\n                if cur-1 not in visited:\n                    q.append(cur-1)\n                    visited.add(cur-1)\n", "class Solution:\n    def minDays(self, n: int) -> int:        \n        q = deque([n])\n        days = 0\n        visited = set()\n        \n        while q:\n            days += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == 1:\n                    print(visited)\n                    return days\n                if node % 3 == 0 and node % 3 not in visited:\n                    q.append(node // 3)\n                    visited.add(node // 3)\n                if node % 2 == 0 and node % 2 not in visited:\n                    q.append(node // 2)\n                    visited.add(node // 2)\n                if node - 1 not in visited:\n                    q.append(node - 1)\n                    visited.add(node - 1)", "class Solution:\n    def minDays(self, n: int) -> int:\n        # ret=0\n        # while n>=3:\n        #     if n%3:\n        #         n-=1\n        #         ret+=1\n        #     else:\n        #         n//=3\n        #         ret+=1\n        # if n==2:\n        #     return ret+2\n        # if n==1:\n        #     return ret+1\n        q = deque([(n,0)])\n        seen = {n}\n        while q:\n            curr,cost=q.popleft()\n            if curr==0:\n                return cost\n            for nxt in [curr-1,curr/3,curr/2]:\n                if nxt!=int(nxt):\n                    continue\n                nxt=int(nxt)\n                if nxt in seen:\n                    continue\n                seen.add(nxt)\n                q.append([nxt,cost+1])\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        days = 0\n        visited = set()\n        \n        while q:\n            days += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node == 1:\n                    print(visited)\n                    return days\n                if node % 3 == 0 and node % 3 not in visited:\n                    q.append(node // 3)\n                    visited.add(node // 3)\n                if node % 2 == 0 and node % 2 not in visited:\n                    q.append(node // 2)\n                    visited.add(node // 2)\n                if node - 1 not in visited:\n                    q.append(node - 1)\n                    visited.add(node - 1)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n#         dp = [0] * (n+1)\n#         # dp[0] = 1\n        \n#         for i in range(1, n + 1):\n#             # print(i, dp[i-1], i - i/2, i - (2*i/3), i%2, i%3)\n#             dp[i] = 1 + min(dp[i-1], 1e9 if i % 2 != 0 else dp[i - int(i/2)], 1e9 if (i % 3 != 0 or i < 2*i/3) else dp[i - int(2*i/3)])\n            \n#         # print(dp)\n            \n#         return dp[n]\n        queue = deque([[n, 0]])\n        vis = set()\n        \n        while(len(queue)):\n            curr, days = queue.popleft()\n            if curr in vis:\n                continue\n                \n            if curr == 0:\n                return days\n\n            vis.add(curr)\n            \n            if curr % 3 == 0:\n                queue.append([curr/3, days+1])     \n                \n            if curr % 2 == 0:\n                queue.append([curr/2, days+1])\n\n            queue.append([curr - 1, days+1])\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        def number_of_steps(i):\n            Q = deque()\n            seen_before = set()\n            steps = 0\n            Q.append((i, steps))\n            while True:\n                j, steps = Q.popleft()\n                if j == 1:\n                    return steps\n                if j % 3 == 0:\n                    branch(Q, seen_before, steps, j - (2 * j // 3))\n                if j % 2 == 0:\n                    branch(Q, seen_before, steps, j // 2)\n                branch(Q, seen_before, steps,  j - 1)\n\n        def branch(Q, seen_before, steps, k):\n            if k not in seen_before:\n                seen_before.add(k)\n                Q.append((k, steps + 1))\n        return number_of_steps(n) + 1", "import sys\nclass Solution:\n    def minDays(self, n: int) -> int:\n        sys.setrecursionlimit(10**6) \n        return self.helperFunction(n, {})\n    def helperFunction(self, n, d):\n        if(n<=0):\n            return 0\n        if(d.get(n) is not None):\n            return d[n]\n        d[n]=999999\n        if(n%2==0):\n            d[n]=min(d[n], 1+self.helperFunction(n-(n/2), d))\n        if(n%3==0):\n            d[n]=min(d[n], 1+self.helperFunction(n-((2*n)/3), d))\n        if(n<=1024 or (n%2)>0 or (n%3)>0):\n            d[n]=min(d[n], 1+self.helperFunction(n-1, d))\n        return d[n]", "class Solution:\n    def minDays(self, n: int) -> int:\n        d = 1\n        poss = set([n])\n        while 1 not in poss:\n            d+=1\n            new_poss = set()\n            for i in poss:\n                new_poss.add(i-1)\n                if i%2 == 0:\n                    new_poss.add(i//2)\n                if i%3 == 0:\n                    new_poss.add(i//3)\n            poss = new_poss\n        return d\n            \n                    \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        buf = {n}\n        for i in range(1, n + 1):\n            if 1 in buf: return i\n            old, buf = buf, set()\n            for x in old:\n                buf.add(x - 1)\n                if x % 2 == 0: buf.add(x // 2)\n                if x % 3 == 0: buf.add(x // 3)\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n == 1: return 1\n        cnt = 0\n        st = set([n])\n        while st:\n            cnt += 1\n            st_temp = set()\n            for v in st:\n                if v == 1:\n                    return cnt\n                st_temp.add(v - 1)\n                if v % 2 == 0:\n                    st_temp.add(v // 2)\n                if v % 3 == 0:\n                    st_temp.add(v // 3)\n            st = st_temp\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n == 1: return 1\n        cnt = 0\n        st = set([n])\n        while st:\n            cnt += 1\n            st_temp = set()\n            for v in st:\n                if v == 1:\n                    return cnt\n                st_temp.add(v - 1)\n                if v % 2 == 0:\n                    st_temp.add(v // 2)\n                if v % 3 == 0:\n                    st_temp.add(v // 3)\n            st = st_temp\n            # print(len(st_temp))\n        return -1\n", "import sys\nsys.setrecursionlimit(1500000)\nclass Solution:\n    def minDays(self, n: int) -> int:\n        @lru_cache(None)\n        def go(x):\n            if x == 0:\n                return 0\n            \n            best = 1e100\n            if x % 2 == 0:\n                best = min(best, go(x // 2) + 1)\n            if x % 3 == 0:\n                best = min(best, go(x // 3) + 1)\n            \n            if x <= (1024) or (x % 2 > 0 or x % 3 > 0):\n                best = min(best, go(x - 1) + 1)\n                \n            return best\n        return go(n)", "class Solution:\n    def minDays(self, n: int) -> int:\n        result = 0\n        q = [n]\n        while q:\n            #next = []\n            next = set()\n            for remain in q:\n                if remain == 1:\n                    return result + 1\n                if remain % 2 == 0:\n                    next.add(remain // 2)\n                if remain % 3 == 0:\n                    next.add(remain // 3)\n                next.add(remain - 1)\n            result += 1\n            q = next\n        return result", "class Solution:\n    def minDays(self, n: int) -> int:\n        state = set([n])\n        steps = 0\n        while 0 not in state:\n            nstate = set()\n            for x in state:\n                nstate.add(x-1)\n                if x%2 == 0:\n                    nstate.add(x//2)\n                if x%3 == 0:\n                    nstate.add(x//3)\n            steps += 1\n            state = nstate\n        return steps", "class Solution:\n    def minDays(self, n: int) -> int:\n        day = 0\n        options = set([n])\n        while 0 not in options:\n            new_options = set()\n            day += 1\n            for o in options:\n                new_options.add(o - 1)\n                if not o % 2:\n                    new_options.add(o // 2)\n                if not o % 3:\n                    new_options.add(o // 3)\n            options = set(new_options)\n        return day\n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = [n]\n        res = 0\n        while q:\n            tmp = set()\n            for curr in q:\n                if curr == 0:\n                    return res\n                tmp.add(curr-1)\n                if curr % 3 == 0:\n                    tmp.add(curr//3)\n                if curr % 2 == 0:\n                    tmp.add(curr//2)\n            q = tmp\n            res += 1\n        return res", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue = [(n,0)]\n        visited = set()\n        while queue:\n            remain, day = queue.pop(0)\n            if remain == 0: return day\n            if remain % 2 == 0 and remain//2 not in visited:\n                queue.append((remain//2, day+1))\n                visited.add(remain//2)\n            if remain % 3 == 0 and remain//3 not in visited:\n                queue.append((remain//3, day+1))\n                visited.add(remain//3)\n            if remain-1 not in visited:\n                queue.append((remain - 1, day+1))\n            \n            \n        # dp = {}\n        # dp[0] = 0\n        # dp[1] = 1\n        # for i in range(2, n+1):\n        #     if i % 2 == 0 and i % 3 == 0:\n        #         dp[i] = min(dp[i//2], dp[i//3], dp[i-1]) + 1\n        #     elif i % 2 == 0:\n        #         dp[i] = min(dp[i//2], dp[i-1]) + 1\n        #     elif i % 3 == 0:\n        #         dp[i] = min(dp[i//3], dp[i-1]) + 1\n        #     else:\n        #         dp[i] = dp[i-1] + 1\n        # return dp[n]\n", "class Solution:\n\n    \n    def minDays(self, n: int) -> int:\n        cur={n}\n        res=0\n        while cur:\n            temp=set()\n            for x in cur:\n                if x==0: return res\n                temp.add(x-1)\n                if x%2==0: temp.add(x//2)\n                if x%3==0: temp.add(x//3)\n            res+=1\n            cur=temp\n        return res\n                \n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        s = {n}\n        for i in itertools.count(1):\n            if 1 in s: return i\n            nxt = set()\n            for x in s:\n                nxt.add(x-1)\n                if x % 2 == 0: nxt.add(x>>1)\n                if x % 3 == 0: nxt.add(x//3)\n            s = nxt", "class Solution:\n    def minDays(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        q = set([n])\n        level = 0\n        \n        while q:\n            nq = set()\n            level += 1\n            \n            for item in q:\n                if item == 1: return level\n                \n                nq.add(item - 1)\n                \n                if item % 2 == 0:\n                    nq.add(item // 2)\n                    \n                if item % 3 == 0:\n                    nq.add(item // 3)\n            \n            q = nq\n        \n        \n        \n        \n                    \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = [(0,n)]\n        visited = set()\n        while q:\n            x, curr = heapq.heappop(q)\n            if curr==1: return x+1\n            if curr not in visited:\n                visited.add(curr)\n                heapq.heappush(q,(x+1+curr%2, curr//2))\n                heapq.heappush(q,(x+1+curr%3, curr//3))\n        return n\n", "class Solution:\n    def minDays(self, n: int) -> int:\n        queue = [[0, n]]\n        visit = set()\n        while queue:\n            curr, num = heapq.heappop(queue)\n            if num == 0:\n                return curr\n            if num not in visit:\n                visit.add(num)\n                if num % 3 == 0:\n                    heapq.heappush(queue, [curr+1, num//3])\n                if num % 2 == 0:\n                    heapq.heappush(queue, [curr+1, num//2])\n                heapq.heappush(queue, [curr+1, num-1])", "from collections import defaultdict\nclass Solution:\n    def minDays(self, n):\n        dic = {n:0}\n        while 0 not in dic:\n            temp = defaultdict(int)\n            for i,v in list(dic.items()):\n                if i % 2 == 0:\n                    temp[i//2] = v + 1\n                if i % 3 == 0:\n                    temp[i//3] = v + 1\n                temp[i-1] = v + 1\n            dic = temp.copy()\n        return dic[0]\n", "from collections import deque\nclass Solution:\n    def minDays(self, n: int) -> int:\n        q = deque([n])\n        days = 0\n        visited = set()\n        \n        while q:\n            days += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                #print(node,q,visited,days)\n                if node == 1:\n                    #print(visited)\n                    return days\n                if node % 3 == 0 and node % 3 not in visited:\n                    q.append(node // 3)\n                    visited.add(node // 3)\n                if node % 2 == 0 and node % 2 not in visited:\n                    q.append(node // 2)\n                    visited.add(node // 2)\n                if node - 1 not in visited:\n                    q.append(node - 1)\n                    visited.add(node - 1)\n                    \n                    \n            \n        \n        \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        step = 0\n        cur = {n}\n        while 0 not in cur:\n            new_cur = set()\n            for i in cur:\n                new_cur.add(i-1)\n                if not i % 2:\n                    new_cur.add(i//2)\n                if not i % 3:\n                    new_cur.add(i//3)\n            cur = new_cur\n            step += 1\n        return step", "from math import log,ceil\n\nclass Solution:\n    def minDays(self, n: int) -> int:\n        def one_day(apples):\n            if apples%2==0 and apples%3!=0:\n                return (apples/2,apples-1)\n            elif apples%3==0 and apples%2!=0:\n                return (apples/3,apples-1)\n            elif apples%3==0 and apples%2==0:\n                return (apples/3,apples/2)\n            elif apples%3!=0 and apples%2!=0:\n                return (apples-1,)\n\n\n        poses=[(n,0)]#(#apples remained,days passed)\n        min_apples=min([pos[0] for pos in poses])\n\n        while min_apples!=0:\n            new_poses=[]\n            for pos in poses:\n                apples=pos[0]\n                days=pos[1]\n                new_pos=[(new_apples,days+1)for new_apples in one_day(apples)]\n                new_poses+=new_pos\n            min_apples=min([pos[0] for pos in new_poses])\n            poses=set(new_poses)\n\n        days=sorted(poses,key=lambda x:x[0])[0][1]\n\n        return days", "class Solution:\n    def minDays(self, n: int) -> int:\n        step = 0\n        tries = set([n])\n        while len(tries) > 0:\n            nt = set()\n            step += 1\n            for t in tries:\n                if t == 1:\n                    return step\n                if t % 2 == 0:\n                    nt.add(t // 2)\n                if t % 3 == 0:\n                    nt.add(t // 3)\n                nt.add(t - 1)\n            tries = nt\n        return -1", "class Solution:\n    def minDays(self, n: int) -> int:\n        day_dict = set([n])\n        day = 0\n        while True:\n            day_next = []\n            for num in day_dict:\n                if num%2 == 0:\n                    day_next.append(num//2)\n                if num%3 == 0:\n                    day_next.append(num//3)\n                day_next.append(num-1)\n            day += 1\n            day_dict = set(day_next)\n            if 0 in day_next:\n                return day\n        return\n                \n", "class Solution:\n    def minDays(self, n: int) -> int:\n        q = collections.deque()\n        days = 0\n        q.append(n)\n        seen = set()\n        seen.add(n)\n        while q:\n            size = len(q)\n            for i in range(size):\n                cur = q.popleft()\n                if cur == 0:\n                    return days\n                if cur - 1 not in seen:\n                    seen.add(cur - 1)\n                    q.append(cur - 1)\n                if cur % 2 == 0 and cur % 2 not in seen:\n                    q.append(cur // 2)\n                if cur % 3 == 0 and cur % 3 not in seen:\n                    q.append(cur // 3)\n            days += 1\n        return -1"]
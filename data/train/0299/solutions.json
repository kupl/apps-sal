["from collections import deque\n\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        right, left, down, up = (0, 1), (0, -1), (1, 0), (-1, 0)\n        \n        direction_map = {\n            1: right,\n            2: left,\n            3: down,\n            4: up\n        }\n        \n        directions = [right, left, down, up]\n        visited = set()\n        \n        def in_bounds(i, j):\n            return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n        \n        def dfs(i, j):                                           \n            # not in bounds\n            if not in_bounds(i, j) or (i, j) in visited:\n                return []\n            \n            visited.add((i, j))\n\n            sign = grid[i][j]\n            direction = direction_map[sign]\n            next_i, next_j = i + direction[0], j + direction[1]\n            return [(i, j)] + dfs(next_i, next_j)\n                \n                    \n        reachable = dfs(0, 0)\n        curr_cost = 0\n        while reachable:\n            next_reachable = []\n            for (i, j) in reachable:\n                if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                    return curr_cost\n                \n                for d in directions:\n                    next_reachable += dfs(i + d[0], j + d[1])\n            reachable = next_reachable\n            curr_cost += 1\n                    \n        return -1\n                \n                    \n"]
["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from collections import deque\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         self.queue = deque([])\n         self.queue.append(root)\n         return self.bfs()\n \n     def bfs(self):\n         while len(self.queue):\n             node = self.queue.popleft()\n             if node.right:\n                 self.queue.append(node.right)\n             if node.left:\n                 self.queue.append(node.left)\n         return node.val\n         ", "class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         dealArr = []\n         indexNum = self.dealTree(root, dealArr, 0)\n         # print(indexNum, dealArr[indexNum - 1][0])\n         return dealArr[indexNum - 1][0]\n     def dealTree(self, root, dealArr, indexNum):\n         if root == None:\n             return indexNum\n         # if not dealArr[indexNum]:\n         if len(dealArr) <= indexNum :\n             dealArr.append([])\n         dealArr[indexNum].append(root.val)\n         # print(root.val, dealArr, len(dealArr))\n         indexNum1 = self.dealTree(root.left, dealArr, indexNum + 1)\n         indexNum2 = self.dealTree(root.right, dealArr, indexNum + 1)\n         return max(indexNum1, indexNum2)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         \n         leftmost = []\n         \n         def recurse(node, path):\n             nonlocal leftmost\n             \n             if node is None:\n                 return\n             \n             if len(path) > len(leftmost):\n                 leftmost = path\n                 \n             if 0 < len(path) == len(leftmost):\n                 if int(''.join(path), 2) < int(''.join(leftmost), 2):\n                     leftmost = path\n             \n             recurse(node.left, path + ['0'])\n             recurse(node.right, path + ['1'])\n \n         recurse(root, [])\n             \n         node = root\n         while leftmost:\n             if leftmost.pop(0) == '0':\n                 node = node.left\n             else:\n                 node = node.right\n                 \n         return node.val", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         last = [root]\n         now = []\n         for node in last:\n             if node.left:\n                 now.append(node.left)\n             if node.right:\n                 now.append(node.right)\n         \n         while now:\n             last, now = now, []\n             for node in last:\n                 if node.left:\n                     now.append(node.left)\n                 if node.right:\n                     now.append(node.right)   \n         \n         return last[0].val", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         q = [root]\n         while any(q):\n             res = q[0]\n             q = [kid for node in q for kid in (node.left, node.right) if kid]\n         return res.val", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         q = [(root,1)]\n         cur = (root,1)\n         while (q!=[]):\n             node,depth = q.pop(0)\n             if depth > cur[1]:\n                 cur = (node,depth)\n             if node.left != None:\n                 q.append((node.left,depth + 1))\n             if node.right != None:\n                 q.append((node.right,depth + 1))\n         return cur[0].val", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         queue=[root]\n         \n         while queue:\n             new_queue=[]\n             for node in queue:\n                 if node.left:\n                     new_queue.append(node.left)\n                 if node.right:\n                     new_queue.append(node.right)\n             if new_queue==[]:\n                 return queue[0].val\n             queue=new_queue", "class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         self.maxHeight = 0\n         self.leftNode = None\n         self.findNode(root, 1)\n         return self.leftNode\n \n     def findNode(self, root, height):\n         if not root:\n             return\n         if height > self.maxHeight:\n             self.leftNode = root.val\n             self.maxHeight = height\n         self.findNode(root.left, height+1)\n         self.findNode(root.right, height+1)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         if root==None:\n             return []\n         if root.left == None and root.right == None:\n             return root.val\n         queue = [root]\n         answer = [root.val]\n         while queue != []:\n             temp = []\n             for curr in queue:\n                 if curr.left != None and curr.right != None:\n                     temp.append(curr.left.val) \n                     temp.append(curr.right.val)\n                 elif curr.left == None and curr.right!=None:\n                     temp.append(curr.right.val)\n                 elif curr.right == None and curr.left!=None:\n                     temp.append(curr.left.val)\n             if temp:\n                 answer.append(temp)\n             nt = []\n             for curr in queue:\n                 if curr.left != None and curr.right != None: \n                     nt.append(curr.left)\n                     nt.append(curr.right)\n                 elif curr.left == None and curr.right!=None:\n                     nt.append(curr.right)\n                 elif curr.right == None and curr.left!=None:\n                     nt.append(curr.left)\n             queue = nt\n         if answer[-1] != None:\n             return answer[-1][0]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         queue = [root]\n         i = 0\n         while i < len(queue):\n             queue += filter(lambda node: bool(node), [queue[i].right, queue[i].left])\n             i += 1\n \n         return queue[-1].val", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         q = [root]\n         lastRow = [root]\n         # store = [[root]]\n \n         while len(q) > 0:\n             row = []\n     \n             while len(q) > 0:\n                 popped = q[0]\n                 q = q[1:]\n             \n                 if popped.left:\n                     row.append(popped.left)\n                 if popped.right:\n                     row.append(popped.right)\n             \n             q = row\n             if len(row) > 0:\n                 # store.append(row)\n                 lastRow = row\n         return lastRow[0].val\n         # return store[-1][0].val\n \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         q = [root]\n         lastRow = [root]\n         # store = [[root]]\n \n         while len(q) > 0:\n             row = []\n     \n             while len(q) > 0:\n                 popped = q[0]\n                 q = q[1:]\n             \n                 if popped.left:\n                     row.append(popped.left)\n                 if popped.right:\n                     row.append(popped.right)\n             \n             q = row\n             if len(row) > 0:\n                 # store.append(row)\n                 lastRow = row\n         return lastRow[0].val\n         # return store[-1][0].val\n \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         r=[]\n         l=[]\n         rorl=[]\n         def record(root,level,rl):\n             if not root:\n                 return\n             r.append(root.val)\n             l.append(level)\n             rorl.append(rl)\n             record(root.left,level+1,rl-1)\n             record(root.right,level+1,rl+1)\n         record(root,0,0)\n         lastlevel=max(l)\n         index=[]\n         for i in range(len(l)):\n             if l[i]==lastlevel:\n                 index.append(i)\n         tmp=r[index[0]]\n         rr=rorl[index[0]]\n         for ind in index:\n             if rorl[ind]<rr:\n                 rr=rorl[ind]\n                 tmp=r[ind]\n         return tmp\n             \n             \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         # nonlocal lowest\n         lowest = {'depth':-1, 'horz':0, 'value':0}\n         \n         def check_and_update_lowest(depth, horz, value):\n             if (depth > lowest['depth']) or (depth == lowest['depth'] and horz < lowest['horz']):\n                 lowest['depth'] = depth\n                 lowest['horz'] = horz\n                 lowest['value'] = value\n             \n                 \n         \n         def deeper(node, level= 0, horz = 0):\n             \n             if node is None:\n                 return\n             \n             if not(node.left or node.right):\n                 check_and_update_lowest(level, horz, node.val)\n                 return\n             \n             deeper(node.left,level+1, horz-1)\n             deeper(node.right,level+1, horz+1)\n             \n         deeper(root)\n         \n         return lowest['value']\n             \n             "]
["class Solution:\n    def longestPrefix(self, strn: str) -> str:\n        max_prefs = [0]*len(strn)\n\n        curr = 0\n        for idx in range(1, len(strn)):\n            while True:\n                if curr == 0:\n                    if strn[idx] == strn[0]:\n                        curr = 1\n                    max_prefs[idx] = curr\n                    break\n                else:\n                    if strn[idx] == strn[curr]:\n                        curr += 1\n                        max_prefs[idx] = curr\n                        break\n                    else:\n                        curr = max_prefs[curr-1]\n\n        return strn[:max_prefs[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        lps = [0] * n\n        j = 0\n        for i in range(1, n):\n            if s[i] == s[j]:\n                j += 1\n                lps[i] = j\n            else:\n                while j > 0:\n                    j = lps[j-1]\n                    if s[j] == s[i]:\n                        j += 1\n                        break\n                lps[i] = j\n        return s[:lps[-1]]", "from collections import defaultdict\n\nclass TrieNode:\n    def __init__(self, x=None):\n        self.val = x\n        self.end = False\n        self.children = defaultdict(TrieNode)\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        self.max_len = 0\n    \n    def insert(self, word):\n        node = self.root\n        for i, w in enumerate(word):\n            node.children[w].val = w\n            node = node.children[w]\n            self.root.children[w] = node\n            if i == len(w) - 1:\n                node.end = True\n    \n    def find(self, word):\n        node = self.root\n        d = 0\n        for w in word[:-1]:\n            print(w, node.children.keys())\n            node = node.children[w]\n            d += 1\n            if node.end:\n                print(node.val, node.end)\n                self.max_len = max(self.max_len, d)\n    \nclass Solution:\n    def longestPrefix(self, s):\n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n        for i in range(len(s) - 1):\n            l = (l * 128 + ord(s[i])) % mod\n            r = (r + pow(128, i, mod) * ord(s[~i])) % mod\n            if l == r: res = i + 1\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s):\n        # res stores the index of the end of the prefix, used for output the result\n        # l stores the hash key for prefix\n        # r stores the hash key for suffix\n        # mod is used to make sure that the hash value doesn't get too big, you can choose another mod value if you want.\n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n\n        # now we start from the beginning and the end of the string\n        # note you shouldn't search the whole string! because the longest prefix and suffix is the string itself\n        for i in range(len(s) - 1):\n\n            # based on an idea that is similar to prefix sum, we calculate the prefix hash in O(1) time.\n            # specifically, we multiply the current prefix by 128 (which is the length of ASCII, but you can use another value as well)\n            # then add in the ASCII value of the upcoming letter\n            l = (l * 128 + ord(s[i])) % mod\n\n            # similarly, we can calculate the suffix hash in O(1) time.\n            # Specifically, we get the ith letter from the end using s[~i], note ~i is -i-1\n            # we find the pow(128, i, mod) and multiply by the letter's ASCII value\n            # Actually, if we don't care about the beautifulness of the code, you can have a variable to keep track of pow(128, i, mod) as you increase i\n            r = (r + pow(128, i, mod) * ord(s[~i])) % mod\n\n           # we check if the prefix and suffix agrees, if yes, we find yet another longer prefix, so we record the index\n            if l == r: res = i + 1\n\n       # after we finish searching the string, output the prefix\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s):\n        # res stores the index of the end of the prefix, used for output the result\n        # l stores the hash key for prefix\n        # r stores the hash key for suffix\n        # mod is used to make sure that the hash value doesn't get too big, you can choose another mod value if you want.\n        num_chars = 26\n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n\n        # now we start from the beginning and the end of the string\n        # note you shouldn't search the whole string! because the longest prefix and suffix is the string itself\n        for i in range(len(s) - 1):\n\n            # based on an idea that is similar to prefix sum, we calculate the prefix hash in O(1) time.\n            # specifically, we multiply the current prefix by num_chars (which is the length of ASCII, but you can use another value as well)\n            # then add in the ASCII value of the upcoming letter\n            l = (l * num_chars + ord(s[i])) % mod\n\n            # similarly, we can calculate the suffix hash in O(1) time.\n            # Specifically, we get the ith letter from the end using s[~i], note ~i is -i-1\n            # we find the pow(num_chars, i, mod) and multiply by the letter's ASCII value\n            # Actually, if we don't care about the beautifulness of the code, you can have a variable to keep track of pow(num_chars, i, mod) as you increase i\n            r = (r + pow(num_chars, i, mod) * ord(s[~i])) % mod\n\n           # we check if the prefix and suffix agrees, if yes, we find yet another longer prefix, so we record the index\n            if l == r: res = i + 1\n\n       # after we finish searching the string, output the prefix\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        '''\n        res keeps track of the index of the end of the prefix, used to output the happy prefix\n        l stores the hash key for prefix\n        r tracks the hash key for suffix\n        '''\n        res, l, r = 0, 0, 0\n        mod = 10**9 + 5 # used to ensure that the hash value doesn't overflow\n        '''\n        now start from the beginning and end of the string\n        - note you shouldn't search teh whole string because the longest prefix/suffix is the string itself\n        '''\n        for i in range(len(s)-1):\n            # hash the prefix/suffix in o(1); 128 can be substituted with any value; it just happens to be the length of ASCII\n            '''\n            for a given string 'elkmmmelk', prefix elk will be hashed in ascending order.\n            e: 'e': hash[e] = ord(e)\n            l: 'el': hash[el] = hash(e)*128 + ord(l)\n            k: 'elk': hash[elk] = hash(el)*128 + ord(k)\n            which translates to (l * 128 + ord(s[i]))\n\n            suffix elk will be hashed in descending order\n            k: 'k': hash[k] = ord(k)\n            l: 'lk': hash[lk] = ord(k) + ord(l) * 128\n            e: 'elk': hash[elk] = ord(k) + ord(l) * 128 + ord(e) * 128^2\n            which translates to r + pow(128, i, mod)\n            '''\n            l = (l * 128 + ord(s[i])) % mod\n            r = (r + pow(128, i, mod) * ord(s[-i-1])) % mod\n            if l == r: # if both hash values match, update res\n                res = i + 1\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s):\n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n        for i in range(len(s) - 1):\n            l = (l * 128 + ord(s[i])) % mod\n            r = (r + pow(128, i, mod) * ord(s[~i])) % mod\n            if l == r:\n                res = i + 1\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        best = ''\n        \n        left = 0\n        right = len(s) - 1\n        \n        left_s = ''\n        right_s = ''\n        \n        hash_left = 0\n        hash_right = 0\n        \n        while left < len(s) - 1 and right > 0:\n            hash_left += ord(s[left])\n            hash_right += ord(s[right])\n            \n            left_s += s[left]\n            right_s = s[right] + right_s\n            \n            if hash_left == hash_right:\n                if left_s == right_s:\n                    best = left_s\n            \n            left += 1\n            right -= 1\n        \n        return best\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        ans = ''\n        l, r = 0, 0\n        mod = 10**9 + 7\n        for i in range(len(s) - 1):\n            l = (l * 31 + ord(s[i])) % mod\n            r = (r + ord(s[len(s) - i - 1]) * pow(31, i, mod)) % mod\n            if l == r:\n                ans = s[:i + 1]\n        return ans", "class Solution:\n    def longestPrefix(self, st: str) -> str:\n        a = st\n        l = len(a)\n        leng = 0\n        lps = [0]\n        i = 1\n        while i < l:\n            if a[i] == a[leng]:\n                leng += 1\n                lps.append(leng)\n                i += 1\n            else:\n                if leng > 0:\n                    leng = lps[leng - 1]\n                else:\n                    lps.append(0)\n                    i += 1\n        return st[:lps[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        ans = ''\n        l, r = 0, 0\n        mod = 10**9 + 7\n        for i in range(len(s) - 1):\n            l = (l * 31 + ord(s[i])) % mod\n            r = (r + ord(s[len(s) - i - 1]) * pow(31, i, mod)) % mod\n            if l == r and s[: i + 1] == s[len(s) - i - 1:]:\n                ans = s[:i + 1]\n        return ans", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        ls = len(s)\n        id = -1\n        for i in range(ls-1):\n            if s[0:i+1] == s[ls-i-1:ls]:\n                id = i\n        return s[:id+1]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        ans = 0\n        for l in range(len(s)):\n            if s[:l] == s[-l:]:\n                ans = l\n        \n        return s[:ans]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        \n        max_index = -1\n        \n        for index, _ in enumerate(s[:-1]):\n            \n            if s[:index+1] == s[-1*(index+1):]:\n                max_index = index\n        \n        return s[:max_index+1]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        i,j,l=0,1,len(s)\n        m=0\n        while(i<l-1):\n            if(s[0:i+1]==s[l-i-1: ]):\n                m=i+1\n                #print(\\\"i=\\\",i,s[0:i+1],\\\" \\\",s[l-i-1: ])\n            i+=1\n        if(m==l-1):\n            return s[ :l-1]\n        else:\n            return s[0:m]\n                \n                \n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        solution = ''\n        for i in range(len(s)):\n            prefix = s[0:i]\n            suffix = s[-len(prefix):]\n            if prefix == suffix:\n                solution = prefix\n        return solution", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        if len(s) < 2:\n            return ''\n        length = len(s)\n        res = ''\n        for i in range(len(s) - 1):\n            if s[ : i + 1] == s[length - i - 1 : ]:\n                res = s[ : i + 1]\n        return res", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        answer = ''\n\n        for n in range(1,len(s)):\n            prefix = s[:n]\n            suffix = s[-n:]\n\n            if prefix  == suffix:\n                answer = prefix\n\n        return answer", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        long = 0\n        for x in range(0,len(s)-1):\n            # print(s[0:x+1] ,s[len(s)-1-x:])\n            # print(s[0:x+1]==s[len(s)-1-x:])\n            if s[0:x+1]==s[len(s)-1-x:]:\n                long = max(long, len(s[0:x+1]))\n                # print(long)\n        return s[:long]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        res = ''\n        i, j = 0, len(s) - 1\n        while i < len(s)-1:\n            if s[:i+1] == s[j:]:\n                res = s[:i+1]\n            i += 1\n            j -= 1\n        return res\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        #KMP\n        lps = [0] * len(s)\n        j = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[j] != s[i]:\n                j = lps[j - 1]\n            if s[j] == s[i]:\n                lps[i] = j + 1\n                j += 1\n        return s[:lps[-1]]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        long = 0\n        for x in range(0,len(s)-1):\n            a = s[0:x+1]\n            b = s[len(s)-1-x:]\n            if a==b:\n                long = max(long, len(a))\n        return s[:long]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        long = 0\n        for x in range(0,len(s)-1):\n            if s[0:x+1]==s[len(s)-1-x:]:\n                long = max(long, len(s[0:x+1]))\n        return s[:long]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        i=0\n        string=str()\n        ans=0\n        j=len(s)-1\n        while i<len(s)-1 and j>0:\n            if s[0:i+1]==s[j:len(s)]:\n                if i+1>ans:\n                    ans=i+1\n                    string=s[0:i+1]\n            i=i+1\n            j=j-1\n        return string\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        ans=''\n        for i in range(len(s)):\n            if s[:i]==s[-i:] and len(s[:i])>=len(ans):\n                ans=s[:i]\n        return ans", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        result = ''\n        \n        left = 0\n        right = len(s) - 1\n        \n        hash_left = 0\n        hash_right = 0\n        \n        while left < len(s) - 1 and right > 0:\n            # hash_left += ord(s[left])\n            # hash_right += ord(s[right])\n            \n            # if hash_left == hash_right:\n            if s[:left + 1] == s[right:]:\n                result = s[right:]\n            \n            left += 1\n            right -= 1\n        \n        return result\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n#         prefixes = []\n#         for i in range(1, len(s)):\n#             prefixes.append(s[0:i])\n            \n#         # print(prefixes)\n        \n        \n#         suffixes = []\n#         for i in range(1, len(s)):\n#             suffixes.append(s[len(s)-i:])\n        \n#         # print(suffixes)\n        \n#         common = set(prefixes).intersection(set(suffixes))\n        \n#         # print(common)\n        \n#         ans = ''\n#         for s in common:\n#             if len(s) > len(ans):\n#                 ans = s\n#         return ans \n        i = 1\n        ans = ''\n        while i < len(s):\n            # print(s[0:i], s[len(s)-i:])\n            if s[0:i] == s[len(s)-i:]:\n                ans = s[0:i]\n            i += 1\n        return ans\n                \n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n#         n = len(s)\n#         r = -1\n#         i = 0\n#         while i < (n-1):\n#             if s[0:(i+1)] == s[(n-i-1):]:\n#                 r = i\n#             i += 1\n#             if i >= (n-1):\n#                 break\n\n        \n#         return s[0:(r+1)]\n    \n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n\n        # now we start from the beginning and the end of the string\n        # note you shouldn't search the whole string! because the longest prefix and suffix is the string itself\n        for i in range(len(s) - 1):\n\n            # based on an idea that is similar to prefix sum, we calculate the prefix hash in O(1) time.\n            # specifically, we multiply the current prefix by 128 (which is the length of ASCII, but you can use another value as well)\n            # then add in the ASCII value of the upcoming letter\n            l = (l * 128 + ord(s[i])) % mod\n\n            # similarly, we can calculate the suffix hash in O(1) time.\n            # Specifically, we get the ith letter from the end using s[~i], note ~i is -i-1\n            # we find the pow(128, i, mod) and multiply by the letter's ASCII value\n            # Actually, if we don't care about the beautifulness of the code, you can have a variable to keep track of pow(128, i, mod) as you increase i\n            r = (r + pow(128, i, mod) * ord(s[~i])) % mod\n\n           # we check if the prefix and suffix agrees, if yes, we find yet another longer prefix, so we record the index\n            if l == r: res = i + 1\n\n       # after we finish searching the string, output the prefix\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        i = 0\n        maxi = ''\n        while i<n:\n            print()\n            if s[:i] == s[n-i:]: \n                maxi = max(maxi, s[:i])\n            i += 1\n        print('maxi', maxi)\n        return maxi", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        best = ''\n        \n        for i in range(1, len(s)):\n            pattern = s[:i]\n            if s.startswith(pattern) and s.endswith(pattern):\n                best = pattern\n        \n        return best", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(list(s))\n        for i in range(0,n):\n            if s[0:i] == s[n-i:n]:\n                result = s[0:i]\n        return result", "class KMP:\n    def Build(self, p):\n        m = len(p)\n        nxt = [0, 0]\n        j = 0\n        for i in range(1, m):\n            while j > 0 and p[i] != p[j]:\n                j = nxt[j]\n            if p[i] == p[j]:\n                j += 1\n            nxt.append(j)\n            \n        return nxt\n    \n    def Match(self, s, p):\n        n = len(s)\n        m = len(p)\n        nxt = self.Build(p)\n        ans = []\n        j = 0\n        for i in range(n):\n            while j > 0 and s[i] != p[j]:\n                j = nxt[j]\n            if s[i] == p[j]:\n                j += 1\n            if j == m:\n                ans.append(i - m + 1)\n                j = nxt[j]\n        return ans\n\n\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        kmp = KMP()\n        nxt = kmp.Build(s)\n        return s[:nxt[-1]]\n        \n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        len_s = len(s)\n        nxts = [0] * len_s\n        i, j = 1, 0\n        while i < len_s:\n            while s[j] != s[i] and j > 0:\n                j = nxts[j - 1] # \u9000\u800c\u6c42\u5176\u6b21 \u8003\u8651 s[:j - 1], \u8fd9\u4e2a\u7b97\u8fc7\u4e86\u662fnxt(s[j - 1])\n            if s[j] == s[i]: # while stop only two\n                j = j + 1 \n                nxts[i] = j\n            i = i + 1\n        return s[len_s-nxts[-1]:]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        pre = self.get_pre(s)\n        return s[0:pre[-1]]\n        \n    def get_pre(self, pattern):\n        pre = [0]\n        n = len(pattern)\n        j = 0\n        for i in range(1, n):\n            while j and pattern[j] != pattern[i]:\n                j = pre[j-1]\n                \n            if pattern[i] == pattern[j]:\n                j +=1\n            pre.append(j)\n        return pre", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        len_s = len(s)\n        nxts = [0] * len_s\n        i = 1\n        j = 0\n        while i < len_s:\n            while j > 0 and s[j] != s[i]:\n                j = nxts[j - 1] # \u9000\u800c\u6c42\u5176\u6b21 \u8003\u8651 s[:j - 1], \u8fd9\u4e2a\u7b97\u8fc7\u4e86\u662fnxt(s[j - 1])\n            if s[j] == s[i]: # while stop only two\n                j = j + 1 \n            nxts[i] = j\n            i = i + 1\n        return s[len_s-nxts[-1]:]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        arr = [0 for i in range(n)]\n        \n        i = 1\n        j = 0\n        try:\n            while i<n:\n                if j==0 and s[i]!=s[j]:\n                    arr[i] = 0\n                    i+=1\n                else:\n                    if s[i]==s[j]:\n                        arr[i] = j+1\n                        i+=1\n                        j+=1\n                    else:\n                        j = arr[j-1]\n\n            return s[:arr[n-1]]\n        \n        except:\n            return i\n        \n    '''\n    a a b a a b a a a\n    0 1 2 3 4 5 6 7 8\n    0 1 0 1 2 3 4 5 2\n    \n    '''", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        \n        n = len(s)\n        \n        lps = [0]*n\n        \n        for i in range(1, n):\n            \n            j = lps[i-1]\n            \n            while j>0 and s[j]!=s[i]:\n                j = lps[j-1]\n            \n            if s[j]==s[i]:\n                lps[i] = j+1\n        \n        \n        return s[:lps[n-1]]\n            \n        \n            \n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        def build(p):\n            m = len(p)\n            nxt = [0,0]\n            j = 0\n            for i in range(1,m):\n                while j > 0 and s[i] != s[j]:\n                    j = nxt[j]\n                if s[i] == s[j]:\n                    j += 1\n                nxt.append(j)\n            return nxt\n        \n        nxt = build(s)\n        return s[:nxt[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        len_s = len(s)\n        nxts = [0]\n        i = 1\n        j = 0\n        while i < len_s:\n            while j > 0 and s[j] != s[i]:\n                j = nxts[j - 1] # \u9000\u800c\u6c42\u5176\u6b21 \u8003\u8651 s[:j - 1], \u8fd9\u4e2a\u7b97\u8fc7\u4e86\u662fnxt(s[j - 1])\n            if s[j] == s[i]:\n                j = j + 1\n            i = i + 1\n            nxts.append(j)\n        return s[len_s-nxts[-1]:]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        len_s = len(s)\n        nxts = [0]\n        i = 1\n        j = 0\n        while i < len_s:\n            while j > 0 and s[j] != s[i]:\n                j = nxts[j - 1] # \u9000\u800c\u6c42\u5176\u6b21\n            if s[j] == s[i]:\n                j = j + 1\n            else:\n                j = 0\n            i = i + 1\n            nxts.append(j)\n        return s[len_s-nxts[-1]:]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        l = len(s)\n        nx = [-1] * (l + 1)\n        i, j = 0, -1\n        while i < l:\n            while j == -1 or (i < l and s[i] == s[j]): \n                i += 1\n                j += 1\n                nx[i] = j\n            if i < l and s[i] != s[j]: j = nx[j]\n        return s[:nx[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        i, j = 0, -1\n        t = [0 for _ in range(len(s)+1)]\n        t[0] = -1\n        while i < len(s):\n            if j == -1 or s[i] == s[j]:\n                i += 1\n                j += 1\n                t[i] = j\n            else:\n                j = t[j]\n        return s[:t[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        \n        def build():\n            hashtable = [0 for _ in s]\n            \n            for i in range(1, len(s)):\n                j = hashtable[i - 1]\n                \n                while j > 0 and s[i] != s[j]:\n                    j = hashtable[j - 1]\n                \n                if s[i] == s[j]:\n                    hashtable[i] = j + 1\n            \n            return hashtable\n        \n        table = build()\n        \n        return s[len(s) - table[-1]:]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        par = [0] * len(s)\n        \n        for i in range(1, len(s)):\n            j = par[i-1]\n            while j and s[j] != s[i]:\n                j = par[j-1]\n            j += int(s[i] == s[j])\n            par[i] = j\n        \n        return s[:par[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        pi = [0]*n\n        for i in range(1, n):\n            j = pi[i - 1]\n            while j > 0 and s[j] != s[i]:\n                j = pi[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            pi[i] = j\n        return s[:pi[n-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        \n        lps = [0]\n        for i in range(1, len(s)):\n            pos = lps[-1]\n            if s[pos] == s[i]:\n                lps.append(1+lps[-1])\n            else:\n                pos = lps[lps[-1]-1]\n                if s[pos] == s[i]:\n                    lps.append(1+pos)\n                else:               \n                    lps.append(0)\n        return s[:lps[-1]]", "class Solution:\n    def longestPrefix(self, st: str) -> str:\n        a=st\n        l=len(a)\n        leng=0\n        i=1\n        lps=[0]\n        while i<l:\n            if a[leng]==a[i]:\n                leng+=1\n                lps.append(leng)\n                i+=1\n            else:\n                if leng>0:\n                    leng=lps[leng-1]\n                else:\n                    lps.append(0)\n                    i+=1\n        return st[:lps[-1]]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        LPS=[0]*n\n        \n        i=1\n        longestprefix=0\n        while i<n:\n            if s[longestprefix]==s[i]:\n                longestprefix+=1\n                LPS[i]=longestprefix\n                i+=1\n            else:\n                if longestprefix>0:\n                    longestprefix=LPS[longestprefix-1]\n                else:\n                    i+=1\n        return s[:LPS[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        lps=[0]*len(s)\n        i=1\n        l=0\n        while(i<len(s)):\n            if(s[i]==s[l]):\n                l=l+1\n                lps[i]=l\n                i=i+1\n            else:\n                if(l):\n                    l=lps[l-1]\n                else:\n                    lps[i]=0\n                    i=i+1\n        m=lps[-1]\n        index=len(s)-1\n        #print(lps)\n        #for i in range(len(s)):\n         #   if(lps[i]>m):\n          #      m=lps[i]\n           #     index=i\n        \n        #print(m,index)\n        return s[abs(m-index-1):index+1]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        t = [-1]\n        pos, cnd = 1, 0\n        while pos < len(s)-1:\n            if s[pos] == s[cnd]:\n                t.append(t[cnd])\n            else:\n                t.append(cnd)\n                cnd = t[cnd]\n                while cnd >= 0 and s[pos] != s[cnd]:\n                    cnd = t[cnd]\n            pos += 1\n            cnd += 1\n        t.append(cnd)\n        \n        j, k = 1, 0\n        while j < len(s):\n            if s[k] == s[j]:\n                j += 1\n                k += 1\n                if k == len(s):\n                    k = t[k]\n            else:\n                k = t[k]\n                if k < 0:\n                    j += 1\n                    k += 1\n        return s[:k]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        prefix, suffix = 0, 0\n        base, mod, mul = 31, 1000000007, 1\n        happy = 0\n        for i in range(1, n):\n            prefix = (prefix * base + (ord(s[i - 1]) - 97)) % mod\n            suffix = (suffix + (ord(s[n - i]) - 97) * mul) % mod\n            if prefix == suffix:\n                happy = i\n            mul = mul * base % mod\n        return s[:happy]\n\n", "MOD = 100000007\n\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        \n        r = 0\n        \n        L = R = 0\n        multi = 1\n        for i in range(len(s)-1):\n            L = (26*L + ord(s[i]) - ord('a')) % MOD\n            R = ((ord(s[~i]) - ord('a')) * multi + R) % MOD\n            multi = multi * 26 % MOD\n            if L == R:\n                r = i + 1\n   \n        return s[:r]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        if(n < 2):\n            return ''\n\n        i = 1; j = 0\n        f = [0 for _ in range(n)]\n        \n        while(i < n):\n            if(s[i] == s[j]):\n                j += 1\n                f[i] = j\n                i += 1\n\n            elif(j > 0):\n                j = f[j - 1]\n            \n            else:\n                i += 1\n        return s[:f[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        for i in range(1, n):\n            if s.startswith(s[i:]):\n                return s[i:]\n        return ''\n\nclass Solution2:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        dp = [[ 0 ] * n for _ in range(n)]\n        for i in range(n - 1):\n            for j in range(i +1, n):\n                if s[i] == s[j]:\n                    if i == 0:\n                        dp[i][j] = 1\n                    elif dp[i-1][j - 1]:\n                        dp[i][j] = dp[i-1][j - 1] + 1\n        max_len = 0\n        for i in range(n): max_len = max(max_len, dp[i][n-1])\n        return s[-max_len:] if max_len else ''\n", "class Solution:\n  def longestPrefix(self, s: str) -> str:\n    # rolling hash\n    # use large prime as hash function, pay attention to the possible hash collision.\n    # fibonacci primes: 2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, \n    #  99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917, ..\n    M = 19134702400093278081449423917\n    n, h, t = len(s), 0, 0\n    v = list(map(lambda x: ord(x) - ord('a'), s))\n    l, p = 0, 1\n    for i in range(n - 1):\n      h = (h * 26 + v[i]) % M\n      t = (v[n - 1 - i] * p + t) % M\n      p = p * 26 % M\n      if h == t:\n        l = i + 1\n    return s[:l]", "class Solution:\n    MOD = 10 ** 9 + 7\n    def longestPrefix(self, s: str) -> str:\n        N = len(s)\n        left_i, right_i = 0, N - 1\n        left_val = right_val = 0\n        \n        best_left = -1\n        right_multiplier = 1\n        for i in range(N - 1):\n            left_char, right_char = s[i], s[N-i-1]\n            left_val = left_val * 26 + (ord(left_char) - ord('a'))\n            right_val = (ord(right_char) - ord('a')) * right_multiplier + right_val\n            right_multiplier *= 26\n            \n            left_val %= Solution.MOD\n            right_val %= Solution.MOD\n            right_multiplier %= Solution.MOD\n            if left_val == right_val:\n                best_left = i\n\n        return s[:best_left+1]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        if len(s) == 1: return ''\n        \n        def KMPSearch(pat, txt): \n            M, N = len(pat), len(txt) \n            lps = failure(pat)\n\n            i = 0 # index for txt[] \n            j = 0 # index for pat[] \n            while i < N: \n                if pat[j] == txt[i]: \n                    i += 1\n                    j += 1\n                elif i < N and pat[j] != txt[i]: \n                    if j != 0: \n                        j = lps[j-1] \n                    else: \n                        i += 1\n                if i >= N:                        \n                    return i - j \n\n        def failure(pat): \n            res = [0]\n            i, target = 1, 0\n            while i < len(pat): \n                if pat[i]== pat[target]: \n                    target += 1\n                    res += target,\n                    i += 1\n                elif target: \n                    target = res[target-1] \n                else: \n                    res += 0,\n                    i += 1\n            return res                        \n                        \n        l = len(s) - 1 - KMPSearch(s[:-1], s[1:])\n        return s[:l]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        if n<=1: return ''\n        \n        prefix, suffix,base=0,0,1\n        NUM=10**9+7\n        ans=''\n        for i in range(1,n):\n            # i is the length of prefix and suffix\n            x=ord(s[i-1])-ord('a')\n            prefix=(26*prefix+x) % NUM\n            \n            x=ord(s[n-i])-ord('a')\n            suffix=(suffix+x*base) % NUM\n            base=(base*26) % NUM\n            \n            if prefix==suffix:\n                if s[0:i]==s[n-i:n]: ans=s[0:i]\n        return ans", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        result = ''\n        \n        left = 0\n        right = len(s) - 1\n        \n        hash_left = 0\n        hash_right = 0\n        \n        while left < len(s) - 1 and right > 0:\n            hash_left += ord(s[left])\n            hash_right += ord(s[right])\n            \n            if hash_left == hash_right:\n                if s[:left + 1] == s[right:]:\n                    result = s[right:]\n            \n            left += 1\n            right -= 1\n        \n        return result\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        # https://leetcode.com/problems/longest-happy-prefix/discuss/547237/JavaPython-Rolling-Hash\n        # https://leetcode.com/problems/longest-happy-prefix/discuss/547446/C%2B%2BJava-with-picture-incremental-hash-and-KMP\n        n = len(s)\n        prefix = [0]*n\n        j, i = 0, 1\n        while i < n:\n            if s[j] == s[i]:\n                j += 1\n                prefix[i] = j\n            elif j > 0:\n                j = prefix[j-1]\n                i -= 1\n            i += 1\n        return s[:j]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        best = ''\n        \n        left = 0\n        right = len(s) - 1\n        \n        \n        hash_left = 0\n        hash_right = 0\n        \n        while left < len(s) - 1 and right > 0:\n            hash_left += ord(s[left])\n            hash_right += ord(s[right])\n            \n            if hash_left == hash_right:\n                if s[:left + 1] == s[right:]:\n                    best = s[right:]\n            \n            left += 1\n            right -= 1\n        \n        return best\n", "class Solution:\n    # kmp, time: O(n), space: O(n)\n    # build the LPS table; lps: longest proper prefix which is also suffix.\n    # lps[i]: for pattern[:i], the longest prefix which is a also the suffix\n    def build(self, p):\n        leng = 0\n        i = 1\n        lps = [0]\n        while i < len(p):\n            if p[i] == p[leng]:\n                i += 1\n                leng += 1\n                lps.append(leng)\n            else:\n                if leng:\n                    leng = lps[leng - 1]\n                else:\n                    lps.append(0)\n                    i += 1\n        return lps\n    \n    def longestPrefix2(self, s: str) -> str:\n        lps = self.build(s)\n        return s[:lps[-1]]\n\n    \n    \n    \n    # rolling hash\n    # for the string of i size, the hash is: s[0] * 26 ^ (i - 1) + s[1] * 26 ^ (i -2) + ... + s[i - 2] * 26 + s[i - 1].\n    def longestPrefix(self, s: str) -> str:\n        mul = 1; mod = pow(10, 9) + 7\n        i = 0; j = len(s) - 1\n        res = 0\n        hash1 = 0; hash2 = 0\n        while i < len(s) - 1 and j > 0:\n            hash1 = (hash1 * 26 + ord(s[i]) - ord('a')) % mod\n            # s[n-1] -> s[n-2]*26 + s[n-1] -> s[n-3]*26^2 + s[n-2]*26 + s[n-1]\n            hash2 = (hash2 + mul * (ord(s[j]) - ord('a'))) % mod \n            mul = mul * 26 % mod\n            if hash1 == hash2:\n                res = i + 1\n            i += 1\n            j -= 1\n        return s[:res]\n            \n            \n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        length = len(s)\n        for i in range(1, length):\n            if s[i] == s[0] and s[i:] == s[:length - i]:\n                return s[i:]\n        return ''", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        p1 = s[0]\n        length = len(s)\n        for i in range(1, len(s)):\n            if s[i] == p1:\n                if s[i:] == s[:length - i]:\n                    return s[i:]\n        return ''", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        p1 = s[0]\n        length = len(s)\n        for i in range(1, len(s)):\n            if s[i] == p1 and s[i:] == s[:length - i]:\n                return s[i:]\n        return ''", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        for i in range(len(s)-1,-1,-1):\n            if s[:i] == s[-i:]:\n                return s[:i]\n        return ''", "'''\nUsing Rabin-Karp incremental hash\nReference:\nhttps://leetcode.com/problems/longest-happy-prefix/discuss/547446/C%2B%2BJava-with-picture-incremental-hash-and-KMP\n'''\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        index = 0\n        MOD = 10**9 + 7\n        mul = 1\n        sLen = len(s)\n        prefixHash, suffixHash = 0, 0\n        j = sLen-1\n        \n        for i in range(sLen-1):\n            first = ord(s[i]) - ord('a')\n            last = ord(s[j]) - ord('a')\n            prefixHash = (prefixHash*26 + first) % MOD\n            suffixHash = (last*mul + suffixHash) % MOD\n            mul = (mul*26) % MOD\n            j-=1\n            if prefixHash == suffixHash:\n                index = i+1\n        \n        return s[:index]\n", "#ababdababc\n#0012012340\n\nclass Solution:\n    def computelps(self, p: str):\n        m = len(p)\n        lps = [0] * m\n        i = 1\n        j = 0\n        \n        while i < m:\n            if p[i] != p[j]:\n                if j == 0:\n                    i += 1\n                else:\n                    j = lps[j-1]\n            else:\n                j += 1\n                lps[i] = j\n                i += 1\n        return lps\n        \n        \n    def longestPrefix(self, s: str) -> str:\n        lps = self.computelps(s)\n        \n        return s[:lps[-1]]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = len(s)\n        k = n - 1\n        while k > 0:\n          if s[:k] == s[-k:]:\n            break\n          k -= 1\n        return s[:k]", "class Solution:\n    def longestPrefix(self, st: str) -> str:\n        a=st\n        l=len(a)\n        leng=0\n        i=1\n        lps=[0]\n        while i<l:\n            if a[leng]==a[i]:\n                leng+=1\n                lps.append(leng)\n                i+=1\n            else:\n                if leng>0:\n                    leng=lps[leng-1]\n                else:\n                    lps.append(0)\n                    i+=1\n        return st[:lps[-1]]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        sLen = len(s)\n        if sLen == 1:\n            return ''\n        \n        def happyNow(x):\n            if s[:x] == s[-x:]:\n                return True\n            return False \n        \n        for length in range(sLen-1, 0, -1):\n            if happyNow(length):\n                return s[:length]\n        return ''", "class Solution:\n    def longestPrefix(self, st: str) -> str:\n        a = st\n        l = len(a)\n        i = 1\n        leng = 0\n        lps = [0]\n        while i < l:\n            if a[i] == a[leng]:\n                leng += 1\n                lps.append(leng)\n                i += 1\n            else:\n                if leng > 0:\n                    leng = lps[leng - 1]\n                else:\n                    lps.append(0)\n                    i += 1\n        return st[:lps[-1]]\n", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        for i in range(len(s)-1,0,-1):\n            # print(s[:i],s[len(s)-i:])\n            if s[:i]==s[len(s)-i:]:\n                return s[:i]\n        return ''", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n\n        # now we start from the beginning and the end of the string\n        # note you shouldn't search the whole string! because the longest prefix and suffix is the string itself\n        for i in range(len(s) - 1):\n\n            # based on an idea that is similar to prefix sum, we calculate the prefix hash in O(1) time.\n            # specifically, we multiply the current prefix by 128 (which is the length of ASCII, but you can use another value as well)\n            # then add in the ASCII value of the upcoming letter\n            l = (l * 128 + ord(s[i])) % mod\n\n            # similarly, we can calculate the suffix hash in O(1) time.\n            # Specifically, we get the ith letter from the end using s[~i], note ~i is -i-1\n            # we find the pow(128, i, mod) and multiply by the letter's ASCII value\n            # Actually, if we don't care about the beautifulness of the code, you can have a variable to keep track of pow(128, i, mod) as you increase i\n            r = (r + pow(128, i, mod) * ord(s[~i])) % mod\n\n           # we check if the prefix and suffix agrees, if yes, we find yet another longer prefix, so we record the index\n            if l == r: res = i + 1\n\n       # after we finish searching the string, output the prefix\n        return s[:res]", "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        res, l, r , mod = 0,0,0, 10**9+7\n        for i in range(len(s)-1):\n            l = (l*128 + ord(s[i]))%mod\n            r = (ord(s[~i])*(pow(128,i,mod)) + r)%mod\n            if l==r: res = i+1\n        return s[:res ]\n        \n   \n        \n        \n        \n    def longestPrefix_bychance_Brute(self, s: str) -> str:\n        res = ''\n        for i in range(1, len(s)):\n            if s[:i]==s[-i:]:\n                res =s[:i]\n        return res\n", "class Solution:\n  def longestPrefix(self, s: str) -> str:\n    j, prefix, suffix = 0, 0, 0\n    mod = 10**9 + 9\n    for i in range(len(s)-1):\n      prefix = (prefix * 128 + ord(s[i])) % mod\n      suffix = (suffix + pow(128, i, mod) * ord(s[-i-1])) % mod\n      if prefix == suffix:\n        j = i + 1\n    return s[:j]\n"]
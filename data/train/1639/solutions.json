["import math\n\ndef gta(limit, *args):\n    return sum_up(limit, make_pattern(limit, *args)) \n\ndef binomial_coeff(n, k):\n    \"\"\"N choose K\"\"\"\n    return math.factorial(n) / math.factorial(n-k)\n\ndef sum_up(limit, items):\n    \"\"\"\n    Basic Idea: \n    \n    The number of cominations is simply N choose K. We calcuate this n-times up to the limit.\n    \n    To sum up all the digits we don't have to calculate the sum of each permuation, rather, we simply have to \n    realise that the digit \"1\" will appear N times.\n    \n        For example: [1,2,3], pick = 3.  \n        \n        If there are 6 combinations of length 3 for 3 numbers then each number much appear once in each combination. \n        Thus the sum is: (1 * 6) + (2 * 6) + (3 * 6)\n    \n        In cases where we have N numbers and need to pick K of them then that means not all numbers appear in all combinations.\n        It turns out combinations_total / (N / limit) gives us how many times N appears in the list of all combinations. \n        \n        For example: [1,2,3] pick 2\n        [1,2]\n        [2,1]\n        [1,3]\n        [3,1]\n        [2,3]\n        [3,2]\n        \n        We can see that 1 appears 4/6 times. \n        combinations_total = 6, N = 3, limit = 2.\n        \n        6 / (3/2) = 4\n    \"\"\"\n    total = 0\n    for i in range(1, limit + 1):\n        combin = binomial_coeff(len(items), i)\n        ratio = len(items) / float(i) \n\n        for element in items:\n            total += (element * (combin / ratio))\n\n    return total\n    \ndef make_pattern(limit, *args):\n\n    seen = set()\n    pattern = []\n    items = list(map(str, args))\n    \n    k = 0\n    while len(pattern) < limit:    \n        for i in range(len(items)):\n            try:\n                v = items[i][k]\n            except IndexError:\n                pass\n            \n            if v not in seen:\n                seen.add(v)\n                pattern.append(int(v))\n                if len(pattern) == limit:\n                    break\n        k += 1\n    \n    return pattern", "def gta(limit, *args):\n    args = [str(n).ljust(limit, '.') for n in args]\n    unique, frequency, fact = set(), 0, 1\n    for c in zip(*args):\n        for d in c:\n            if d == '.' or d in unique: continue\n            limit -= 1\n            unique.add(d)\n            frequency += fact * len(unique)\n            fact *= limit\n            if not limit:\n                return frequency * sum(map(int, unique))", "def gta(limit, *args):\n    ns = []\n    for i in args:\n        a = list(str(i))\n        a.reverse()\n        ns.append(a)\n        \n        \n    base_list=[]\n    while ns and len(base_list)<limit:\n        n = ns.pop(0)\n        if n:\n            b = int(n.pop())\n            if b not in base_list:\n                base_list.append(b)\n            if n:\n                ns.append(n)\n                \n                \n    base = sum(base_list)\n    times = 0\n    for i in range(1,1+limit):\n        t = i\n        for j in range(i-1):\n            t *= limit - j - 1\n        times += t\n    return base*times\n\n", "from math import e, factorial\n\ndef gta(limit, *nums):\n    iternums, l, i, base= [(int(d) for d in str(n)) for n in nums], len(nums), 0, []\n    while len(base) < limit:\n        d, i = next(iternums[i % l], None), i+1\n        if d is not None and d not in base:\n            base.append(d)\n    return (int(e * factorial(limit)) * (limit - 1) + 1) * sum(base) // limit\n", "from math import factorial as fac\ndef gta(limit, *args): \n    x = [str(i) for i in args]\n    y = set()\n    while len(y) != limit:\n        for i in range(len(args)):\n            if x[i] != None:\n                if len(x[i])!=0:\n                    y.add(int(x[i][0]))\n                if len(x[i]) == 1:\n                    x[i] = None\n                elif len(x[i])==2:\n                    x[i] = x[i][1]\n                else:\n                    x[i] = x[i][1:]\n                if len(y) == limit:\n                    break\n    y,l = list(y),len(y) \n    tot = [fac(l)/fac(i)*(sum(y)*1.0/l)*(l-i) for i in range(l)]\n    return round(sum(tot),0)\n", "import itertools\n\ndef gta(limit, *args): # find the base_list first\n\n    x = max(len(str(l)) for l in args)\n\n    y = ''\n    for i in range(x):\n        for ix in args:\n            try:\n              if str(ix)[i] in y:\n                  continue\n              y += str(ix)[i]\n            except:\n                pass\n    ans = 0   \n    for i in range(1, limit+1):\n        for xc in itertools.permutations(y[:limit], i):\n            ans += sum([sum(map(int, xc))])\n    \n    return ans", "from itertools import cycle, permutations\ndef gta(limit, *args):\n    nums = []\n    numbers = [str(n) for n in args]\n    for i in cycle(range(len(numbers))):\n        if numbers[i]:\n            if int(numbers[i][0]) not in nums:\n                nums.append(int(numbers[i][0]))\n                if len(nums) == limit: break\n            numbers[i] = numbers[i][1:]\n        elif \"\".join(numbers) == \"\": break\n    ans = 0\n    for n in range(1, len(nums) + 1):\n        for arr in permutations(nums, n):\n            ans += sum(arr)\n    return ans"]
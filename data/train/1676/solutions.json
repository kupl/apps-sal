["import sys\n\nblocks = {}\n\nfor i in range(1, 10):\n    blocks[i] = [(0, 0)]\nfor i in range(2, 10, 2):\n    for j in range(1, i / 2 + 1):\n        blocks[i].append((j, 0))\n        blocks[i + 1].append((0, j))\n# print blocks\nblocks[10] = [(0, 0), (0, 1), (1, 0), (1, 1)]\nblocks[11] = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\nblocks[12] = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\nblocks[13] = [(0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]\nblocks[14] = [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\nblocks[15] = [(0, 0), (0, 1), (0, 2), (1, 0), (2, 0)]\nblocks[16] = [(0, 0), (0, 1), (1, 0)]\nblocks[17] = [(0, 0), (0, 1), (1, 1)]\nblocks[18] = [(0, 1), (1, 0), (1, 1)]\nblocks[19] = [(0, 0), (1, 0), (1, 1)]\n\ngrid = [['.'] * 10] * 10\n# print grid\n\nid1, id2, id3 = list(map(int, input().split()))\nwhile not (id1 == id2 == id3 == -1):\n    print('-1 -1 -1 -1 -1 -1 -1 -1 -1')\n    sys.stdout.flush()\n    id1, id2, id3 = list(map(int, input().split()))\n", "\nimport fileinput\nimport sys\nfrom collections import Counter\nfrom math import sqrt\n\ndef get_input():\n    return [line for line in fileinput.input()]\n\nclass NewGame2:\n    N = 10\n    map = [[0 for i2 in range(0, N)] for j2 in range(0, N)]\n    score = 0\n    moves = 0\n    debug = False\n\n    def __init__(self):\n        pass\n\n    def play(self, pieces):\n        clear = False\n        # clear = True\n        if self.moves > 3:\n            return '-1 -1 -1 -1 -1 -1 -1 -1 -1'\n\n        res = self.getMoves(pieces)\n\n        placed = 0\n\n        gameOver = False\n        for i in range(0, len(res)):\n            if res[i] == -1:\n                gameOver = True\n\n        if not gameOver:\n            clearRows = 0\n            clearColumns = 0\n\n            for i in range(0, len(res), 3):\n                p = self.defi[pieces[res[i]-1]]\n                posy = res[i+1] - len(p)\n                posx = res[i+2] - 1\n\n                for py in range(0, len(p)):\n                    for px in range(0, len(p[0])):\n                        if p[py][px] > 0:\n                            self.map[posy+py][posx+px] = pieces[res[i]-1] +1;\n                            placed += 1\n\n                # clear\n                rows = [False for i in range(0, self.N)]\n                columns = [False for i in range(0, self.N)]\n\n                for y in range(0, self.N):\n                    fill = 0\n                    for x in range(0, self.N):\n                        if self.map[y][x] > 0:\n                            fill += 1\n                    if fill == self.N:\n                        rows[y] = True\n                        clearRows += 1\n\n                for x in range(0, self.N):\n                    fill = 0\n                    for y in range(0, self.N):\n                        if self.map[y][x] > 0:\n                            fill += 1\n                    if fill == self.N:\n                        columns[y] = True\n                        clearColumns += 1\n\n                for y in range(0, self.N):\n                    for x in range(0, self.N):\n                        if (rows[y] or columns[x]) and clear:\n                            self.map[y][x] = 0\n\n            size = 0\n            for y in range(0, self.N):\n                for x in range(0, self.N):\n                    if self.map[y][x] > 0:\n                        size += 1\n\n            if size == 0:\n                self.score += 500\n\n            self.score += placed\n            self.score += clearColumns * clearColumns + clearRows * clearRows + (5 * clearRows * clearColumns)\n            self.moves += 1\n\n        output = \"\";\n        for i in range(0, len(res)):\n            if (i > 0):\n                output += \" \"\n\n            output += str(res[i])\n\n        return output\n\n    def getMoves(self, pieces):\n        res = [-1 for i in range(0, 9)]\n        tMap = [[0 for i2 in range(0, self.N)] for j2 in range(0, self.N)]\n\n        for y in range(0, self.N):\n            for x in range(0, self.N):\n                tMap[y][x] = self.map[y][x]\n\n        for i in range(0, len(pieces)):\n            p = self.defi[pieces[i]]\n\n            found_move = False\n            for y in range(0, self.N):\n                for x in range(0, self.N):\n                    if not found_move:\n                        valid = True\n                        for py in range(0, len(p)):\n                            for px in range(0, len(p[0])):\n                                if valid and (y+py >= self.N or x+px >= self.N or (p[py][px] > 0 and tMap[y+py][x+px] != 0)):\n                                    valid = False\n                                    break\n                        if (valid):\n                            for py in range(0, len(p)):\n                                for px in range(0, len(p[0])):\n                                    if (p[py][px] > 0):\n                                        tMap[y+py][x+px] = pieces[i] +1\n\n                            res[i*3 + 0] = i+1\n                            res[i*3 + 1] = y+len(p)\n                            res[i*3 + 2] = x+1\n                            found_move = True\n                            break\n\n        return res\n\n    defi = [\n        [\n            [1],\n        ],\n        [\n            [1],\n            [1],\n        ],\n        [\n            [1, 1],\n        ],\n        [\n            [1],\n            [1],\n            [1],\n        ],\n        [\n            [1, 1, 1],\n        ],\n        [\n            [1],\n            [1],\n            [1],\n            [1],\n        ],\n        [\n            [1, 1, 1, 1],\n        ],\n        [\n            [1],\n            [1],\n            [1],\n            [1],\n            [1],\n        ],\n        [\n            [1, 1, 1, 1, 1],\n        ],\n        [\n            [1, 1],\n            [1, 1],\n        ],\n        [\n            [1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1],\n        ],\n        [\n            [1, 1, 1],\n            [0, 0, 1],\n            [0, 0, 1],\n        ],\n        [\n            [0, 0, 1],\n            [0, 0, 1],\n            [1, 1, 1],\n        ],\n        [\n            [1, 0, 0],\n            [1, 0, 0],\n            [1, 1, 1],\n        ],\n        [\n            [1, 1, 1],\n            [1, 0, 0],\n            [1, 0, 0],\n        ],\n        [\n            [1, 1],\n            [1, 0],\n        ],\n        [\n            [1, 1],\n            [0, 1],\n        ],\n        [\n            [0, 1],\n            [1, 1],\n        ],\n        [\n            [1, 0],\n            [1, 1],\n        ],\n    ]\n\n\nclass JUNE16:\n    def __init__(self):\n        self.CHNWGM()\n\n    def CHNWGM(self):\n        game = NewGame2()\n        while True:\n            a = [int(x)-1 for x in input().split()]\n            # print \"in: %s\" % a\n            if a[0] < 0:\n                return\n            print(game.play(a))\n\n            sys.stdout.flush()\n            sys.stdin.flush()\n\n\ndef __starting_point():\n    JUNE16()\n\n__starting_point()", "\nimport fileinput\nimport sys\nfrom collections import Counter\nfrom math import sqrt\n\ndef get_input():\n    return [line for line in fileinput.input()]\n\nclass NewGame2:\n    N = 10\n    map = [[0 for i2 in range(0, N)] for j2 in range(0, N)]\n    score = 0\n    moves = 0\n    debug = False\n\n    def __init__(self):\n        pass\n\n    def play(self, pieces):\n        clear = False\n        clear = True\n        if self.moves > 3:\n            return '-1 -1 -1 -1 -1 -1 -1 -1 -1'\n\n        res = self.getMoves(pieces)\n\n        placed = 0\n\n        gameOver = False\n        for i in range(0, len(res)):\n            if res[i] == -1:\n                gameOver = True\n\n        if not gameOver:\n            clearRows = 0\n            clearColumns = 0\n\n            for i in range(0, len(res), 3):\n                p = self.defi[pieces[res[i]-1]]\n                posy = res[i+1] - len(p)\n                posx = res[i+2] - 1\n\n                for py in range(0, len(p)):\n                    for px in range(0, len(p[0])):\n                        if p[py][px] > 0:\n                            self.map[posy+py][posx+px] = pieces[res[i]-1] +1;\n                            placed += 1\n\n                # clear\n                rows = [False for i in range(0, self.N)]\n                columns = [False for i in range(0, self.N)]\n\n                for y in range(0, self.N):\n                    fill = 0\n                    for x in range(0, self.N):\n                        if self.map[y][x] > 0:\n                            fill += 1\n                    if fill == self.N:\n                        rows[y] = True\n                        clearRows += 1\n\n                for x in range(0, self.N):\n                    fill = 0\n                    for y in range(0, self.N):\n                        if self.map[y][x] > 0:\n                            fill += 1\n                    if fill == self.N:\n                        columns[y] = True\n                        clearColumns += 1\n\n                for y in range(0, self.N):\n                    for x in range(0, self.N):\n                        if (rows[y] or columns[x]) and clear:\n                            self.map[y][x] = 0\n\n            size = 0\n            for y in range(0, self.N):\n                for x in range(0, self.N):\n                    if self.map[y][x] > 0:\n                        size += 1\n\n            if size == 0:\n                self.score += 500\n\n            self.score += placed\n            self.score += clearColumns * clearColumns + clearRows * clearRows + (5 * clearRows * clearColumns)\n            self.moves += 1\n\n        output = \"\";\n        for i in range(0, len(res)):\n            if (i > 0):\n                output += \" \"\n\n            output += str(res[i])\n\n        return output\n\n    def getMoves(self, pieces):\n        res = [-1 for i in range(0, 9)]\n        tMap = [[0 for i2 in range(0, self.N)] for j2 in range(0, self.N)]\n\n        for y in range(0, self.N):\n            for x in range(0, self.N):\n                tMap[y][x] = self.map[y][x]\n\n        for i in range(0, len(pieces)):\n            p = self.defi[pieces[i]]\n\n            found_move = False\n            for y in range(0, self.N):\n                for x in range(0, self.N):\n                    if not found_move:\n                        valid = True\n                        for py in range(0, len(p)):\n                            for px in range(0, len(p[0])):\n                                if valid and (y+py >= self.N or x+px >= self.N or (p[py][px] > 0 and tMap[y+py][x+px] != 0)):\n                                    valid = False\n                                    break\n                        if (valid):\n                            for py in range(0, len(p)):\n                                for px in range(0, len(p[0])):\n                                    if (p[py][px] > 0):\n                                        tMap[y+py][x+px] = pieces[i] +1\n\n                            res[i*3 + 0] = i+1\n                            res[i*3 + 1] = y+len(p)\n                            res[i*3 + 2] = x+1\n                            found_move = True\n                            break\n\n        return res\n\n    defi = [\n        [\n            [1],\n        ],\n        [\n            [1],\n            [1],\n        ],\n        [\n            [1, 1],\n        ],\n        [\n            [1],\n            [1],\n            [1],\n        ],\n        [\n            [1, 1, 1],\n        ],\n        [\n            [1],\n            [1],\n            [1],\n            [1],\n        ],\n        [\n            [1, 1, 1, 1],\n        ],\n        [\n            [1],\n            [1],\n            [1],\n            [1],\n            [1],\n        ],\n        [\n            [1, 1, 1, 1, 1],\n        ],\n        [\n            [1, 1],\n            [1, 1],\n        ],\n        [\n            [1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1],\n        ],\n        [\n            [1, 1, 1],\n            [0, 0, 1],\n            [0, 0, 1],\n        ],\n        [\n            [0, 0, 1],\n            [0, 0, 1],\n            [1, 1, 1],\n        ],\n        [\n            [1, 0, 0],\n            [1, 0, 0],\n            [1, 1, 1],\n        ],\n        [\n            [1, 1, 1],\n            [1, 0, 0],\n            [1, 0, 0],\n        ],\n        [\n            [1, 1],\n            [1, 0],\n        ],\n        [\n            [1, 1],\n            [0, 1],\n        ],\n        [\n            [0, 1],\n            [1, 1],\n        ],\n        [\n            [1, 0],\n            [1, 1],\n        ],\n    ]\n\n\nclass JUNE16:\n    def __init__(self):\n        self.CHNWGM()\n\n    def CHNWGM(self):\n        game = NewGame2()\n        while True:\n            a = [int(x)-1 for x in input().split()]\n            if a[0] < 0 or a[1] < 0 or a[2] < 0:\n                return\n            print(game.play(a))\n\n            sys.stdout.flush()\n            sys.stdin.flush()\n\n\ndef __starting_point():\n    JUNE16()\n\n__starting_point()", "arr = input().split()\nprint(-1, -1, -1, -1, -1, -1, -1, -1, -1)\n", "print(-1, -1, -1, -1, -1, -1, -1, -1, -1)\n", "# -*- coding: utf-8 -*-\n\n\nxyz = [\n\t[-1, -1],\n\t[1, 1],\n\t[2, 9],\n\t[1, 2],\n\t[3, 10],\n\t[1, 4],\n\t[6, 9],\n\t[2, 1],\n\t[8, 10],\n\t[3, 1],\n\t[2, 7],\n\t[5, 6],\n\t[6, 1],\n\t[8, 6],\n\t[7, 1],\n\t[8, 5],\n\t[10, 1],\n\t[10, 3],\n\t[10, 5],\n\t[10, 7]\n]\n\ndim = [\n\t[-1, -1],\n\t[0, 0],\n\t[1, 0],\n\t[0, 0],\n\t[2, 0],\n\t[0, 0],\n\t[3, 0],\n\t[0, 0],\n\t[4, 0],\n\t[0, 0],\n\t[1, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[1, 0],\n\t[1, 0],\n\t[1, 0],\n\t[1, 0]\n]\n\nA, B, C = list(map(int, input().split()))\nprint('1', dim[A][0]+1, dim[A][1]+1, '2', 5+dim[B][0]+1, 5+dim[B][1]+1, '3', 5+dim[C][0]+1, dim[C][0]+1)\nprint('-1 '*9)\n# print '2', xyz[C][0], xyz[C][1], '3', xyz[B][0], xyz[B][1], '-1 '*3 \n", "# -*- coding: utf-8 -*-\n\n\nxyz = [\n\t[-1, -1],\n\t[1, 1],\n\t[2, 9],\n\t[1, 2],\n\t[3, 10],\n\t[1, 4],\n\t[6, 9],\n\t[2, 1],\n\t[8, 10],\n\t[3, 1],\n\t[2, 7],\n\t[5, 6],\n\t[6, 1],\n\t[8, 6],\n\t[7, 1],\n\t[8, 5],\n\t[10, 1],\n\t[10, 3],\n\t[10, 5],\n\t[10, 7]\n]\n\ndim = [\n\t[-1, -1],\n\t[0, 0],\n\t[1, 0],\n\t[0, 0],\n\t[2, 0],\n\t[0, 0],\n\t[3, 0],\n\t[0, 0],\n\t[4, 0],\n\t[0, 0],\n\t[1, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[2, 0],\n\t[1, 0],\n\t[1, 0],\n\t[1, 0],\n\t[1, 0]\n]\n\nA, B, C = list(map(int, input().split()))\nprint('1', dim[A][0]+1, dim[A][1]+1, '2', 5+dim[B][0], 5+dim[B][1], '-1 '*3)\n# print '2', xyz[C][0], xyz[C][1], '3', xyz[B][0], xyz[B][1], '-1 '*3 \n", "# -*- coding: utf-8 -*-\n\n\nxyz = [\n\t[-1, -1],\n\t[1, 1],\n\t[2, 9],\n\t[1, 2],\n\t[3, 10],\n\t[1, 4],\n\t[6, 9],\n\t[2, 1],\n\t[8, 10],\n\t[3, 1],\n\t[2, 7],\n\t[5, 6],\n\t[6, 1],\n\t[8, 6],\n\t[7, 1],\n\t[8, 5],\n\t[10, 1],\n\t[10, 3],\n\t[10, 5],\n\t[10, 7]\n]\n\nA, B, C = list(map(int, input().split()))\nprint('3', xyz[C][0], xyz[C][1], '-1 '*6) \n", "A = list(map(int, input().split()))\nprint('-1 '*9)", "from sys import stdin,stdout\nfrom itertools import permutations\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef bounded(x,y):\n return 0<=x<=9 and 0<=y<=9\ndef adjzero(tempGrid,block,x,y):\n ones=0\n for i in range(5):\n  for j in range(5):\n   if bounded(x+i,y+j) and blocks[block][i][j]:\n    if bounded(x+i-1,y+j) and (i==0 or blocks[block][i-1][j]==0 )and tempGrid[x+i-1][y+j]==0: ones+=1\n    if bounded(x+i,y+j-1) and (j==0 or blocks[block][i][j-1]==0) and tempGrid[x+i][y+j-1]==0: ones+=1\n    if bounded(x+i,y+j+1) and (j==4 or blocks[block][i][j+1]==0) and tempGrid[x+i][y+j+1]==0: ones+=1\n    if bounded(x+i+1,y+j) and (i==4 or blocks[block][i+1][j]==0) and tempGrid[x+i+1][y+j]==0: ones+=1\n return ones\ndef adjnon(tempGrid,block,x,y):\n ones=0\n for i in range(5):\n  for j in range(5):\n   if bounded(x+i,y+j) and blocks[block][i][j]:\n    if bounded(x+i-1,y+j) and (i==0 or blocks[block][i-1][j]==0 )and tempGrid[x+i-1][y+j]: ones+=1\n    if bounded(x+i,y+j-1) and (j==0 or blocks[block][i][j-1]==0) and tempGrid[x+i][y+j-1]: ones+=1\n    if bounded(x+i,y+j+1) and (j==4 or blocks[block][i][j+1]==0) and tempGrid[x+i][y+j+1]: ones+=1\n    if bounded(x+i+1,y+j) and (i==4 or blocks[block][i+1][j]==0) and tempGrid[x+i+1][y+j]: ones+=1\n return ones\ndef boundary(tempGrid,block,x,y):\n bnd=0\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j] and  (x+i+1==10 or x+i-1==-1): bnd+=1\n   if blocks[block][i][j] and(y+j+1==10 or y+j-1==-1): bnd+=1\n return bnd\ndef points(block,x,y):\n # creatw a local copy\n # place it on grid\n tempGrid=[i[:] for i in grid] \n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    tempGrid[i+x][j+y]=block\n #calculate lines heuristics\n lines=0\n for i in range(10):\n  for j in range(10):\n   if tempGrid[i][j]==0: break\n  else: lines+=1\n for j in range(10):\n  for i in range(10):\n   if tempGrid[i][j]==0: break\n  else: lines+=1\n #caculatw nearby non zeroes\n nearby=adjnon(tempGrid,block,x,y)\n nearholes=adjnon(tempGrid,block,x,y)\n #calculate boundary close points\n bndcls=boundary(tempGrid,block,x,y)\n return 20.0*lines+0.25*nearby+0.1*bndcls\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n horz=[]\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: horz.append(i)\n vertz=[]\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: vertz.append(j)\n for i in horz: clearLine(i,True)\n for i in vertz: clearLine(i,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n pos=[]\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block) : \n    pos.append((points(block,i,j),i,j))\n #print pos\n if pos: return max(pos)\n return (-1,-1,-1)\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n if (a,b,c)==(-1,-1,-1): break\n li=[(a,1),(b,2),(c,3)]\n perms=permutations(li)\n maxp=[]\n maxv=-10\n pos=[]\n for p in perms:\n  tempGrid=[i[:] for i in grid]\n  t1=findPos(p[0][0])\n  if t1!=(-1,-1,-1):\n   placeBlock(p[0][0],t1[1],t1[2])\n   clearFilledLines()\n  t2=findPos(p[1][0])\n  if t2!=(-1,-1,-1):\n   placeBlock(p[1][0],t2[1],t2[2])\n   clearFilledLines()\n  t3=findPos(p[2][0])\n  if t3!=(-1,-1,-1):\n   placeBlock(p[2][0],t3[1],t3[2])\n   clearFilledLines()\n  if (t1[0]+t2[0]+t3[0])>maxv:\n   maxv=(t1[0]+t2[0]+t3[0])\n   pos=[t1[1:],t2[1:],t3[1:]]\n   maxp=p\n  grid=tempGrid\n outstr=[]\n count=0\n for pi in range(len(maxp)):\n  if pos[pi][0]!=-1:\n    i=maxp[pi]\n    x=pos[pi][0]\n    y=pos[pi][1]\n    #print x,y\n    placeBlock(i[0],x,y)\n    clearFilledLines()\n    #printGrid()\n    outstr.extend([i[1],x+1+leftBelow[i[0]][0],y+1])\n    count+=1\n for i in range(3-count):\n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()\n ", "from sys import stdin,stdout\nfrom itertools import permutations\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef bounded(x,y):\n return 0<=x<=9 and 0<=y<=9\ndef adjzero(tempGrid,block,x,y):\n ones=0\n for i in range(5):\n  for j in range(5):\n   if bounded(x+i,y+j) and blocks[block][i][j]:\n    if bounded(x+i-1,y+j) and (i==0 or blocks[block][i-1][j]==0 )and tempGrid[x+i-1][y+j]==0: ones+=1\n    if bounded(x+i,y+j-1) and (j==0 or blocks[block][i][j-1]==0) and tempGrid[x+i][y+j-1]==0: ones+=1\n    if bounded(x+i,y+j+1) and (j==4 or blocks[block][i][j+1]==0) and tempGrid[x+i][y+j+1]==0: ones+=1\n    if bounded(x+i+1,y+j) and (i==4 or blocks[block][i+1][j]==0) and tempGrid[x+i+1][y+j]==0: ones+=1\n return ones\ndef adjnon(tempGrid,block,x,y):\n ones=0\n for i in range(5):\n  for j in range(5):\n   if bounded(x+i,y+j) and blocks[block][i][j]:\n    if bounded(x+i-1,y+j) and (i==0 or blocks[block][i-1][j]==0 )and tempGrid[x+i-1][y+j]: ones+=1\n    if bounded(x+i,y+j-1) and (j==0 or blocks[block][i][j-1]==0) and tempGrid[x+i][y+j-1]: ones+=1\n    if bounded(x+i,y+j+1) and (j==4 or blocks[block][i][j+1]==0) and tempGrid[x+i][y+j+1]: ones+=1\n    if bounded(x+i+1,y+j) and (i==4 or blocks[block][i+1][j]==0) and tempGrid[x+i+1][y+j]: ones+=1\n return ones\ndef boundary(tempGrid,block,x,y):\n bnd=0\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j] and  (x+i+1==10 or x+i-1==-1): bnd+=1\n   if blocks[block][i][j] and(y+j+1==10 or y+j-1==-1): bnd+=1\n return bnd\ndef points(block,x,y):\n # creatw a local copy\n # place it on grid\n tempGrid=[i[:] for i in grid] \n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    tempGrid[i+x][j+y]=block\n #calculate lines heuristics\n lines=0\n for i in range(10):\n  for j in range(10):\n   if tempGrid[i][j]==0: break\n  else: lines+=1\n for j in range(10):\n  for i in range(10):\n   if tempGrid[i][j]==0: break\n  else: lines+=1\n #caculatw nearby non zeroes\n nearby=adjnon(tempGrid,block,x,y)\n nearholes=adjnon(tempGrid,block,x,y)\n #calculate boundary close points\n bndcls=boundary(tempGrid,block,x,y)\n return 20.0*lines+0.25*nearby+0.5*bndcls\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n horz=[]\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: horz.append(i)\n vertz=[]\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: vertz.append(j)\n for i in horz: clearLine(i,True)\n for i in vertz: clearLine(i,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n pos=[]\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block) : \n    pos.append((points(block,i,j),i,j))\n #print pos\n if pos: return max(pos)\n return (-1,-1,-1)\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n if (a,b,c)==(-1,-1,-1): break\n li=[(a,1),(b,2),(c,3)]\n perms=permutations(li)\n maxp=[]\n maxv=-10\n pos=[]\n for p in perms:\n  tempGrid=[i[:] for i in grid]\n  t1=findPos(p[0][0])\n  if t1!=(-1,-1,-1):\n   placeBlock(p[0][0],t1[1],t1[2])\n   clearFilledLines()\n  t2=findPos(p[1][0])\n  if t2!=(-1,-1,-1):\n   placeBlock(p[1][0],t2[1],t2[2])\n   clearFilledLines()\n  t3=findPos(p[2][0])\n  if t3!=(-1,-1,-1):\n   placeBlock(p[2][0],t3[1],t3[2])\n   clearFilledLines()\n  if (t1[0]+t2[0]+t3[0])>maxv:\n   maxv=(t1[0]+t2[0]+t3[0])\n   pos=[t1[1:],t2[1:],t3[1:]]\n   maxp=p\n  grid=tempGrid\n outstr=[]\n count=0\n for pi in range(len(maxp)):\n  if pos[pi][0]!=-1:\n    i=maxp[pi]\n    x=pos[pi][0]\n    y=pos[pi][1]\n    #print x,y\n    placeBlock(i[0],x,y)\n    clearFilledLines()\n    #printGrid()\n    outstr.extend([i[1],x+1+leftBelow[i[0]][0],y+1])\n    count+=1\n for i in range(3-count):\n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()\n ", "from sys import stdin,stdout,exit\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n horz=[]\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: horz.append(i)\n vertz=[]\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: vertz.append(j)\n for i in horz: clearLine(i,True)\n for i in vertz: clearLine(i,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n if (a,b,c)==(-1,-1,-1): break\n li=[(a,1),(b,2),(c,3)]\n outstr=[]\n count=0\n while li:\n  for i in li:\n   x,y=findPos(i[0])\n   if x!=-1:\n    placeBlock(i[0],x,y)\n    clearFilledLines()\n    #printGrid()\n    li.remove(i)\n    outstr.extend([i[1],x+1+leftBelow[i[0]][0],y+1])\n    count+=1\n    break\n  else: break\n for i in range(3-count):\n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()\n ", "from sys import stdin,stdout,exit\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n horz=[]\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: horz.append(i)\n vertz=[]\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: vertz.append(j)\n for i in horz: clearLine(i,True)\n for i in vertz: clearLine(i,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n# print pattern[a],pattern[b],pattern[c]\n if (a,b,c)==(-1,-1,-1): break\n outstr=[]\n x,y=findPos(a)\n count=0\n if x==-1:\n  count+=1\n else:\n  outstr.extend([1,x+1+leftBelow[a][0],y+1])\n  placeBlock(a,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(b)\n if x==-1: count+=1\n else:\n  outstr.extend([2,x+1+leftBelow[b][0],y+1])\n  placeBlock(b,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(c)\n if x==-1: count+=1\n else:\n  outstr.extend([3,x+1+leftBelow[c][0],y+1])\n  placeBlock(c,x,y)\n  clearFilledLines()\n  #printGrid()\n #printGrid()\n for i in range(count): \n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()", "from sys import stdin,stdout,exit\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(i,True)\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(j,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\ncnt=15\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n# print pattern[a],pattern[b],pattern[c]\n if (a,b,c)==(-1,-1,-1): break\n cnt-=1\n if not cnt:\n  print(\"-1 -1 -1 -1 -1 -1 -1 -1 -1\")\n  stdout.flush()\n  continue\n outstr=[]\n x,y=findPos(a)\n count=0\n if x==-1:\n  count+=1\n else:\n  outstr.extend([1,x+1+leftBelow[a][0],y+1])\n  placeBlock(a,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(b)\n if x==-1: count+=1\n else:\n  outstr.extend([2,x+1+leftBelow[b][0],y+1])\n  placeBlock(b,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(c)\n if x==-1: count+=1\n else:\n  outstr.extend([3,x+1+leftBelow[c][0],y+1])\n  placeBlock(c,x,y)\n  clearFilledLines()\n  #printGrid()\n# printGrid()\n for i in range(count): \n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()", "from sys import stdin,stdout,exit\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(i,True)\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(j,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\ncnt=10\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n# print pattern[a],pattern[b],pattern[c]\n if (a,b,c)==(-1,-1,-1): break\n cnt-=1\n if not cnt:\n  print(\"-1 -1 -1 -1 -1 -1 -1 -1 -1\")\n  stdout.flush()\n  continue\n outstr=[]\n x,y=findPos(a)\n count=0\n if x==-1:\n  count+=1\n else:\n  outstr.extend([1,x+1+leftBelow[a][0],y+1])\n  placeBlock(a,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(b)\n if x==-1: count+=1\n else:\n  outstr.extend([2,x+1+leftBelow[b][0],y+1])\n  placeBlock(b,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(c)\n if x==-1: count+=1\n else:\n  outstr.extend([3,x+1+leftBelow[c][0],y+1])\n  placeBlock(c,x,y)\n  clearFilledLines()\n  #printGrid()\n# printGrid()\n for i in range(count): \n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()", "from sys import stdin,stdout,exit\nfrom random import random\ndef printBS(li):\n s=[str(i) for i in li]\n print(\" \".join(s))\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\npattern={1: \"dot\",2: \"vert 2 line\",3: \"hor 2 line\", 4: \"vert 3\",5: \"hor 3\",6:\"vert 4\",7: \"hor 4\", 8: \"vert 5\",9: \"hor 5\",10: \"2*2\",11:\"3*3\",12: \" 3T3R\", 13: \"3R3B\",14: \"3L3B\",15:\"3L3T\",16:\"2L2T\",17:\"2R2T\",18: \"2R2B\",19:\"2L2B\"}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=block\ndef clearFilledLines():\n #check horizontal\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(i,True)\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(j,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(\"%02d\"%grid[i][j], end=' ')\n  print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\ncnt=5\nwhile True:\n a,b,c=list(map(int,stdin.readline().split()))\n# print pattern[a],pattern[b],pattern[c]\n if (a,b,c)==(-1,-1,-1): break\n cnt-=1\n if not cnt:\n  print(\"-1 -1 -1 -1 -1 -1 -1 -1 -1\")\n  stdout.flush()\n  continue\n outstr=[]\n x,y=findPos(a)\n count=0\n if x==-1:\n  count+=1\n else:\n  outstr.extend([1,x+1+leftBelow[a][0],y+1])\n  placeBlock(a,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(b)\n if x==-1: count+=1\n else:\n  outstr.extend([2,x+1+leftBelow[b][0],y+1])\n  placeBlock(b,x,y)\n  clearFilledLines()\n  #printGrid()\n x,y=findPos(c)\n if x==-1: count+=1\n else:\n  outstr.extend([3,x+1+leftBelow[c][0],y+1])\n  placeBlock(c,x,y)\n  clearFilledLines()\n  #printGrid()\n# printGrid()\n for i in range(count): \n  outstr.extend([-1,-1,-1])\n printBS(outstr)\n stdout.flush()", "from sys import stdin,stdout\nfrom random import random\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=1\ndef clearFilledLines():\n #check horizontal\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(i,True)\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(j,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(grid[i][j], end=' ')\n  print() \n print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]==1:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]==1: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\nresCount=0\na,b,c=list(map(int,stdin.readline().split()))\nwhile (a,b,c)!=(-1,-1,-1):\n outstr=[]\n x,y=findPos(a)\n count=0\n if x==-1:\n  count+=1\n else:\n  outstr.extend([1,x+1+leftBelow[a][0],y+1])\n  placeBlock(a,x,y)\n  clearFilledLines()\n #printGrid()\n x,y=findPos(b)\n if x==-1: count+=1\n else:\n  outstr.extend([2,x+1+leftBelow[b][0],y+1])\n  placeBlock(b,x,y)\n  clearFilledLines()\n #printGrid()\n x,y=findPos(c)\n if x==-1: count+=1\n else:\n  outstr.extend([3,x+1+leftBelow[c][0],y+1])\n  placeBlock(c,x,y)\n  clearFilledLines()\n #printGrid()\n for i in range(count): \n  outstr.extend([-1,-1,-1])\n stdout.write(\" \".join([str(i) for i in outstr])+\"\\n\")\n stdout.flush()\n resCount+=1\n a,b,c=list(map(int,stdin.readline().split()))\n if resCount>10:\n  print(\"-1 -1 -1 -1 -1 -1 -1 -1 -1\")\n  stdout.flush()\n  a=stdin.readline()\n  break", "from sys import stdin,stdout\nfrom random import random\n#grid defined as array 10x10 of 0's and 1's 1 means occupied\ngrid=[[0]*10 for i in range(10)]\nblocks=({1:[[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,2:[[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,3:[[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,4:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 5:[[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 6:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0]] \n       , 7:[[1,1,1,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  8:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]] \n     ,   9:[[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 10:[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 11:[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 12:[[1,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 13:[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n      ,  14:[[1,0,0,0,0],[1,0,0,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 15:[[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n       , 16:[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]  \n       , 17:[[1,1,0,0,0],[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n      ,  18:[[0,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] \n        ,19:[[1,0,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]})\nleftBelow={1:(0,0),2:(1,0),3:(0,0),4:(2,0),5:(0,0),6:(3,0),7:(0,0),8:(4,0),9:(0,0),10:(1,0),11:(2,0),12:(2,0),13:(2,0),14:(2,0),15:(2,0),16:(1,0),17:(1,0),18:(1,0),19:(1,0)}\ndef clearLine(lineNo,isRow):\n if isRow:\n  for i in range(10):\n   grid[lineNo][i]=0\n else:\n  for i in range(10):\n   grid[i][lineNo]=0\ndef placeBlock(block,x,y):\n for i in range(min(5,10-x)):\n  for j in range(min(5,10-y)):\n   if blocks[block][i][j]==1:\n    grid[i+x][j+y]=1\ndef clearFilledLines():\n #check horizontal\n for i in range(10):\n  for j in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(i,True)\n #check vertical\n for j in range(10):\n  for i in range(10):\n   if grid[i][j]==0: break\n  else: clearLine(j,False)\ndef printGrid():\n for i in range(10):\n  for j in range(10):\n   print(grid[i][j], end=' ')\n  print() \n print()\ndef checkPos(x,y,block):\n for i in range(5):\n  for j in range(5):\n   if blocks[block][i][j]==1:\n    if x+i>9 or y+j>9: return False\n    if grid[i+x][j+y]==1: return False\n return True\ndef findPos(block):\n for i in range(10):\n  for j in range(10):\n   if checkPos(i,j,block): return i,j\n return -1,-1\nresCount=0\na,b,c=list(map(int,stdin.readline().split()))\nwhile (a,b,c)!=(-1,-1,-1):\n outstr=[]\n x,y=findPos(a)\n count=0\n if x==-1:\n  count+=1\n else:\n  outstr.extend([1,x+1+leftBelow[a][0],y+1])\n  placeBlock(a,x,y)\n  clearFilledLines()\n #printGrid()\n x,y=findPos(b)\n if x==-1: count+=1\n else:\n  outstr.extend([2,x+1+leftBelow[b][0],y+1])\n  placeBlock(b,x,y)\n  clearFilledLines()\n #printGrid()\n x,y=findPos(c)\n if x==-1: count+=1\n else:\n  outstr.extend([3,x+1+leftBelow[c][0],y+1])\n  placeBlock(c,x,y)\n  clearFilledLines()\n #printGrid()\n for i in range(count): \n  outstr.extend([-1,-1,-1])\n stdout.write(\" \".join([str(i) for i in outstr])+\"\\n\")\n stdout.flush()\n resCount+=1\n a,b,c=list(map(int,stdin.readline().split()))\n if resCount>5:\n  print(\"-1 -1 -1 -1 -1 -1 -1 -1 -1\")\n  stdout.flush()\n  a=stdin.readline()\n  break", "import sys\nmp=[[0 for i in range(10)] for j in range(10)]\nan=[0,0]\nx=[]\ny=[]\ndef smx(index):\n    if index==1:\n        y=[0]\n    elif index==2:\n        y=[0,1]\n    elif index==3:\n        y=[0,0]\n    elif index==4:\n        y=[0,1,2]\n    elif index==5:\n        y=[0,0,0]\n    elif index==6:\n        y=[0,1,2,3]\n    elif index==7:\n        y=[0,0,0,0]\n    elif index==8:\n        y=[0,1,2,3,4]\n    elif index==9:\n        y=[0,0,0,0,0]\n    elif index==10:\n        y=[0,1,0,1]\n    elif index==11:\n        y=[0,1,2,0,1,2,0,1,2]\n    elif index==12:\n        y=[0,0,0,1,2]\n    elif index==13:\n        y=[2,2,0,1,2]\n    elif index==14:\n        y=[0,1,2,2,2]\n    elif index==15:\n        y=[0,1,2,0,0]\n    elif index==16:\n        y=[0,1,0]\n    elif index==17:\n        y=[0,0,1]\n    elif index==18:\n        y=[1,0,1]\n    elif index==19:\n        y=[0,1,1]\n    return max(y)\ndef chk():\n    for i in range(10):\n        if sum(mp[i])==10:\n            for j in range(10):\n                mp[i][j]=0\n    for j in range(10):\n        flag=1\n        for i in range(10):\n            if mp[i][j]==0:\n                flag=0\n                break\n        if flag==1:\n            for i in range(10):\n                mp[i][j]=0\ndef fil(y,x):\n    for i1 in range(len(x)):\n        if an[0]+x[i1]<10 and an[1]+y[i1]<10:\n            mp[an[0]+x[i1]][an[1]+y[i1]]=1\n    #chk()\ndef ind(y,x):\n    for i in range(10):\n        for j in range(10):\n            flag=1\n            for i1 in range(len(x)):\n                if i+x[i1]<10 and j+y[i1]<10 and mp[i+x[i1]][j+y[i1]]!=0:\n                    flag=-1\n                    break\n                if i+x[i1]>=10 or j+y[i1]>=10:\n                    flag=-1\n                    break\n            if flag==1:\n                an[0]=i\n                an[1]=j\n                return True\n    return False\ndef find(index):\n    if index==1:\n        x=[0]\n        y=[0]\n    elif index==2:\n        x=[0,0]\n        y=[0,1]\n    elif index==3:\n        x=[0,1]\n        y=[0,0]\n    elif index==4:\n        x=[0,0,0]\n        y=[0,1,2]\n    elif index==5:\n        x=[0,1,2]\n        y=[0,0,0]\n    elif index==6:\n        x=[0,0,0,0]\n        y=[0,1,2,3]\n    elif index==7:\n        x=[0,1,2,3]\n        y=[0,0,0,0]\n    elif index==8:\n        x=[0,0,0,0,0]\n        y=[0,1,2,3,4]\n    elif index==9:\n        x=[0,1,2,3,4]\n        y=[0,0,0,0,0]\n    elif index==10:\n        x=[0,0,1,1]\n        y=[0,1,0,1]\n    elif index==11:\n        x=[0,0,0,1,1,1,2,2,2]\n        y=[0,1,2,0,1,2,0,1,2]\n    elif index==12:\n        x=[0,1,2,2,2]\n        y=[0,0,0,1,2]\n    elif index==13:\n        x=[0,1,2,2,2]\n        y=[2,2,0,1,2]\n    elif index==14:\n        x=[0,0,0,1,2]\n        y=[0,1,2,2,2]\n    elif index==15:\n        x=[0,0,0,1,2]\n        y=[0,1,2,0,0]\n    elif index==16:\n        x=[0,0,1]\n        y=[0,1,0]\n    elif index==17:\n        x=[0,1,1]\n        y=[0,0,1]\n    elif index==18:\n        x=[0,1,1]\n        y=[1,0,1]\n    elif index==19:\n        x=[0,0,1]\n        y=[0,1,1]\n    if ind(x,y):\n        fil(x,y)\n        return True\n    return False\na,b,c=list(map(int,input().split()))\nwhile(a!=-1):\n    ans=\"\"\n    flag=0\n    if find(a):\n       ans+=\"1 \"+ str(an[0]+1+smx(a))+\" \"+str(an[1]+1)+\" \"\n    else:\n        flag+=1\n    if find(b):\n       ans+=\"2 \"+ str(an[0]+1+smx(b))+\" \"+str(an[1]+1)+\" \"\n    else:\n        flag+=1\n    if find(c):\n       ans+=\"3 \"+ str(an[0]+1+smx(c))+\" \"+str(an[1]+1)+\" \"\n    else:\n        flag+=1\n    while(flag>0):\n        ans+=\"-1 -1 -1 \"\n        flag-=1\n    print(ans)\n    sys.stdout.flush()\n    a,b,c=list(map(int,input().split()))\n", "import sys\na,b,c=list(map(int,input().split()))\nrr=[0,0,5,5]\ncc=[0,5,0,5]\ncur=0\nwhile(a!=-1):\n    ans=\"\"\n    for i in range(3):\n        if cur<4:\n            ans+=str(i+1)+\" \"+str(rr[cur]+5)+\" \"+str(cc[cur]+1)+\" \"\n        else:\n            ans+=\"-1\"+\" -1\"+\" -1\"+\" \"\n        cur+=1\n    print(ans)\n    sys.stdout.flush()\n    a,b,c=list(map(int,input().split()))\n"]
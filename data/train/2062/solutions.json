["def main():\n    mod = 10**9+7\n    inv_n = [0]*1001\n    nCr = [[1]*(i+1) for i in range(1001)]\n    for i in range(1001):\n        inv_n[i] = pow(i, mod-2, mod)\n    for i in range(2, 1001):\n        for j in range(1, i):\n            nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j]) % mod\n    n, a, b, c, d = list(map(int, input().split()))\n    dp = [0]*(n+1)\n    dp[0] = 1\n\n    for A in range(b, a-1, -1):\n        dp2 = [i for i in dp]\n        for N in range(n-c*A, -1, -1):\n            e = dp[N]\n            if e:\n                temp = 1\n                for C in range(1, c):\n                    temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                for C in range(c, min(d, (n-N)//A)+1):\n                    temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                    dp2[N+C*A] = (dp2[N+C*A]+temp*e) % mod\n        dp = dp2\n    print((dp[-1]))\n\n\nmain()\n", "MOD = 10 ** 9 + 7\n\ndef power(x, n, MOD):\n    ans = 1\n    while n:\n        if n % 2 == 1:\n            ans = (ans * x) % MOD\n        x = (x * x) % MOD\n        n //= 2\n    return ans\n\ndef getFacts(n, MOD):\n    facts = [1] + [0] * n\n    for x in range(1, n + 1):\n        facts[x] = (facts[x - 1] * x) % MOD\n    return facts\n\ndef getInvFacts(n, factN, MOD):\n    invFacts = [0] * (n + 1)\n    invFacts[n] = power(factN, MOD - 2, MOD)\n    for x in reversed(list(range(n))):\n        invFacts[x] = (invFacts[x + 1] * (x + 1)) % MOD\n    return invFacts\n\ndef getInvss(B, D, facts, MOD):\n    invss = [[0] * (D + 1) for _ in range(B + 1)]\n    invss[B][D] = power(power(facts[B], D, MOD), MOD - 2, MOD)\n    for i in reversed(list(range(B))):\n        invss[i][D] = (invss[i + 1][D] * power(i + 1, D, MOD)) % MOD\n    for i in range(B + 1):\n        for k in reversed(list(range(D))):\n            invss[i][k] = (invss[i][k + 1] * facts[i]) % MOD\n    return invss\n\n\nN, A, B, C, D = list(map(int, input().split()))\n\nfacts = getFacts(N, MOD)\ninvFacts = getInvFacts(N, facts[N], MOD)\ninvss = getInvss(B, D, facts, MOD)\n\n# dp[i][j]: i\u4eba\u4ee5\u4e0b\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u307f\u3067\u3001j\u4eba\u4f7f\u3063\u3066\u3044\u308b\u5834\u5408\u306e\u6570\ndp = [[0] * (N + 1) for _ in range(B + 1)]\ndp[A - 1][0] = 1\n\nfor i in range(A, B + 1):\n    for j in range(N + 1):\n        dp[i][j] = dp[i - 1][j]\n        for k in range(C, min(D, j // i) + 1):\n            dp[i][j] += facts[N - j + i * k] * invFacts[N - j] * invss[i][k] * invFacts[k] * dp[i - 1][j - i * k]\n            dp[i][j] %= MOD\n\nprint((dp[B][N]))\n", "def main():\n    mod = 10**9+7\n    inv_n = [0]*1001\n    nCr = [[1]*(i+1) for i in range(1001)]\n    for i in range(1001):\n        inv_n[i] = pow(i, mod-2, mod)\n    for i in range(2, 1001):\n        for j in range(1, i):\n            nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j]) % mod\n    n, a, b, c, d = map(int, input().split())\n    dp = [0]*(n+1)\n    dp[0] = 1\n\n    for A in range(b, a-1, -1):\n        dp2 = [i for i in dp]\n        for N in range(n-c*A, -1, -1):\n            e = dp[N]\n            if e:\n                temp = 1\n                for C in range(1, c):\n                    temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                for C in range(c, min(d, (n-N)//A)+1):\n                    temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                    dp2[N+C*A] = (dp2[N+C*A]+temp*e) % mod\n        dp = dp2\n    print(dp[-1])\n\n\nmain()", "N, A, B, C, D = map(int, input().split())\nMOD = 10 ** 9 + 7\nfact = [1] * (N + 1)\nfrev = [1] * (N + 1)\n\ndp = [0] * (N + 1)\ndp[0] = 1\n\nfor i in range(1, N + 1):\n    v = fact[i] = (fact[i - 1] * i) % MOD\n    frev[i] = pow(v, MOD - 2, MOD)\n\nY = [None] * (N + 1)\nfor g in range(A, min(N // C, B) + 1):\n    p = C * g\n    q = D * g\n    y = frev[g]\n    Y[p: min(q, N) + 1: g] = (pow(y, j, MOD) * frev[j]\n                              for j in range(C, min(D, N // g) + 1))\n    dp[p:] = (dp[i] + frev[N - i] * sum(dp[i - j] * fact[N - i + j] * Y[j]\n              for j in range(p, min(q, i) + 1, g)) % MOD\n              for i in range(p, N + 1))\n\nprint(dp[N] % MOD)", "mod = 10**9+7\ndef inpl(): return [int(i) for i in input().split()]\nN, A, B, C, D = inpl()\nfac = [1 for _ in range(N+1)]\nfor i in range(N):\n    fac[i+1] = (i+1)*fac[i] %mod\ninv = [1 for _ in range(N+1)]\nfor i in range(2,N+1):\n    inv[i] = (-(mod//i) * inv[mod%i]) %mod    \nfacinv = [1 for _ in range(N+1)]\nfor i in range(N):\n    facinv[i+1] = inv[i+1]*facinv[i] %mod\nfacinvp = [facinv]\nfor i in range(N-1):\n    p = facinvp[-1]\n    q = [p[i]*facinv[i]%mod for i in range(N+1)]\n    facinvp.append(q)\n    \ndp = [[0 for _ in range(N+1)] for _ in range(B+1)]\ndp[A-1][0] = 1\n\nfor i in range(A-1,B):\n    for j in range(N+1):\n        dp[i+1][j] = dp[i][j]\n        for k in range(C,1+min(D, j//(i+1))):\n            x = j - k*(i+1)\n            dp[i+1][j] += fac[j]*facinv[x]*facinvp[k-1][i+1]*facinv[k]*dp[i][x]%mod\n        dp[i+1][j] %= mod\nprint(dp[B][N])", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f = f * m % MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv = inv * m % MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef solve(n, a, b, c, d, MOD):\n    facts, invs = prepare(n, MOD)\n\n    pre = {}\n    for i in range(a, b + 1):\n        iv = invs[i]\n        for k in range(c, d + 1):\n            if i * k > n:\n                break\n            pre[i, k] = pow(iv, k, MOD) * invs[k] % MOD\n\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for i in range(a, b + 1):\n        iv = invs[i]\n        for j in range(i * c, n + 1):\n            base = dp[j]\n            for k in range(c, d + 1):\n                ik = i * k\n                if ik > j:\n                    break\n                dp[j - ik] = (dp[j - ik] + base * pre[i, k]) % MOD\n    return dp[0] * facts[n] % MOD\n\n\nn, a, b, c, d = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nprint((solve(n, a, b, c, d, MOD)))\n", "import sys\nsys.setrecursionlimit(1000000)\n\nMOD = 10**9 + 7\n\ndef ex_euclid(a,b,c,d):\n    if (b == 1) : return d\n    x = a // b\n    y = a % b\n    return ex_euclid(b,y,d,(c[0]-x*d[0],c[1]-x*d[1]))\n    \n \ndef mod_inv(a,p):\n    x = ex_euclid(p,a,(1,0),(0,1))\n    return x[1] % p\n\nn,a,b,c,d = map(int,input().split())\n\ngp = b-a+1\n\ndp = [[-1 for j in range(n+1)] for i in range(gp)]\n\ntb1=[0,1]\ntb2=[1] #\u4fbf\u5b9c\u4e0a0\u306e\u9006\u5143\u306f0\u306b\u3059\u308b\nfor i in range(2,n+1):\n    tb1.append((tb1[i-1]*i) % MOD)\nfor i in range(1,n+1):\n    tb2.append(mod_inv(tb1[i],MOD))\n    \n\nfor i in range(gp):dp[i][0] = 1\n\n\ndef dfs(sum,k):\n    summ = sum\n    if(k < 0):\n        if (sum != 0):return 0\n        else : return 1\n    if dp[k][sum] != -1: return dp[k][sum]\n    kk = k+a\n    temp = dfs(sum,k-1)\n    temp1 = 1\n    for i in range(c-1):\n        if (sum < 0):break\n        temp1 = (temp1 * tb1[sum] * tb2[sum-kk]*tb2[kk]) % MOD \n        sum -= kk\n    for i in range(c,d+1):\n        if(sum-kk < 0) : break\n        temp1 = (temp1 * tb1[sum] * tb2[sum-kk]*tb2[kk]) % MOD\n        sum -= kk\n        temp = (temp + temp1*dfs(sum,k-1)*tb2[i]) % MOD\n\n    dp[k][summ] = temp\n    return temp\n    \n\n        \nans = dfs(n,gp-1)\n\n\n\nprint(ans)", "mod=10**9+7\nMAX=10**3+100\n\n#g1\u306f\u968e\u4e57\u3001g2\u306f\u305d\u306e\u9006\u5143\ng1=[1,1]\ng2=[1,1]\nfor i in range(2,MAX+1):\n    num_1=g1[-1]*i%mod\n    g1.append(num_1)\n    g2.append(pow(num_1,mod-2,mod))\n    \ndef cmb(n,r,MOD):\n    return g1[n]*g2[r]*g2[n-r]%MOD\n\n\n\nN,A,B,C,D=list(map(int,input().split()))\n\ndata=[[] for i in range(B+1)]\nfor i in range(A,B+1):\n    for j in range(C,D+1):\n        if i*j>N:\n            break\n        data[i].append([i*j, pow(g2[i], j, mod)*g2[j]%mod])\n\ndp=[0]*(N+1)\ndp[0]=1\nfor i in range(A,B+1):\n    H=dp[:]\n    for u,v in data[i]:\n        for j in range(u,N+1):\n            H[j]=(H[j]+dp[j-u]*v)%mod\n    dp=H\nprint((dp[N]*g1[N]%mod))\n\n", "from functools import lru_cache\nn,a,b,c,d=map(int,input().split())\n\nmod=10**9+7\nfac=[1]*(n+3)\nfinv=[1]*(n+3)\n\nt=1\nfor i in range(1,n+1):\n    t*=i\n    t%=mod\n    fac[i]=t\nt=1\nfor i in range(1,n+1):\n    t*=pow(i,mod-2,mod)\n    t%=mod\n    finv[i]=t\n\nfinvp = [finv]\nfor i in range(n-1):\n    p=finvp[-1]\n    q=[p[i]*finv[i]%mod for i in range(n+1)]\n    finvp.append(q)\n\ndp = [[0 for _ in range(n+1)] for _ in range(b+1)]\ndp[a-1][0] = 1\n\nfor i in range(a-1,b):\n    for j in range(n+1):\n        dp[i+1][j]=dp[i][j]\n        for k in range(c,1+min(d,j//(i+1))):\n            x=j-k*(i+1)\n            dp[i+1][j]+=fac[j]*finv[x]*finvp[k-1][i+1]*finv[k]*dp[i][x]%mod\n        dp[i+1][j]%=mod\nprint(dp[b][n])", "mod = 10**9+7\n\nNN = 10**4 # \u4f7f\u3046\u30c7\u30fc\u30bf\u306b\u3088\u3063\u3066\u5909\u3048\u308b\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, NN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN, A, B, C, D = list(map(int, input().split()))\n\nMap = [[] for _ in range(N+1)]\nfor n in range(1, N+1):\n    a = 1\n    for _ in range(N+1):\n        Map[n].append(a)\n        a = a * g2[n] % mod\n\nL = [[] for _ in range(N+1)]\nfor n in range(A, B+1):\n    for c in range(C, D+1):\n        if n*c > N:\n            continue\n        L[n].append(c)\n\ndp = [0]*(N+1)\ndp[0] = 1\nfor n in range(1, N+1):\n    for i, c in enumerate(L[n]):\n        if i == 0:\n            dp2 = dp[:]\n        for nn in range(N+1-n*c):\n            dp2[nn+n*c] = (dp2[nn+n*c] + dp[nn] * Map[n][c] % mod * Map[c][1] % mod) % mod\n        if i == len(L[n])-1:\n            dp = dp2\n\nans = dp[N] * g1[N] % mod\nprint(ans)\n", "N, A, B, C, D = list(map(int,input().split()))\nMOD = 10**9+7\n\nMAX = 10**3+1\ninv_t = [0,1]\nfor i in range(2,MAX+1):\n  inv_t.append(inv_t[MOD % i] * (MOD - int(MOD / i)) % MOD)\nfact_inv = [1,1]\nfor i in range(2,MAX+1):\n  fact_inv.append(fact_inv[-1]*inv_t[i] % MOD)\n  \nDP = [[0 for _ in range(N+1)] for _ in range(B+1)]\nDP[0][0] = 1\n\n#\u914d\u308bDP\ndiv_fct = fact_inv[C] * pow(fact_inv[A],C,MOD)\nDP[A][0] = 1\nfor c in range(C,D+1):\n  if c*A > N: break\n  DP[A][c*A] += div_fct\n  DP[A][c*A] %= MOD\n  div_fct *= fact_inv[A]*inv_t[c+1]\n  div_fct %= MOD\n\nfor E in range(A,B):\n  div_fct_0 = fact_inv[C] * pow(fact_inv[E+1],C,MOD)\n  for n in range(N+1):\n    now = DP[E][n]\n    #print(E,n,now)\n    DP[E+1][n] += DP[E][n]\n    if now == 0: continue\n    div_fct = div_fct_0\n    for c in range(C,D+1):#\u914d\u308bDP\n      nxt = n + c*(E+1)\n      if nxt > N: break\n      DP[E+1][nxt] += now * div_fct\n      DP[E+1][nxt] %= MOD\n      div_fct *= fact_inv[E+1]*inv_t[c+1]\n      div_fct %= MOD\n\nfact_N = 1\nfor i in range(1,N+1):\n  fact_N *= i\n  fact_N %= MOD\n#print(*DP, sep=\"\\n\")  \nprint((DP[B][N]*fact_N % MOD))\n  \n", "N,A,B,C,D=list(map(int,input().split()))\nmod=10**9+7\n\nF=[1]*(N+1)\nfor i in range(1,N+1):\n  F[i]=F[i-1]*(i)%mod\ndef power(x,y):\n  if y==0:\n    return 1\n  elif y==1:\n    return x%mod\n  elif y%2==0:\n    return power(x,y//2)**2%mod\n  else:\n    return (power(x,y//2)**2)*x%mod\n\ninvF=[1]*(N+1)\ninvF[N]=power(F[N],mod-2)\nfor i in range(0,N)[::-1]:\n  invF[i]=(invF[i+1]*(i+1))%mod\ninvp=[[0]*(N+1) for i in range(N+1)]\nfor i in range(N+1):  \n  for k in range(N+1):\n    if k==0:\n      invp[i][k]=1\n    else:\n      invp[i][k]=(invp[i][k-1]*invF[i])%mod\ndp=[[0]*(N+1) for i in range(B-A+2)]\ndp[0][0]=1\nfor i in range(A,B+1):\n  for j in range(N+1):\n    dp[i-A+1][j]=dp[i-A][j]\n    for k in range(C,min(D,j//i)+1):\n      dp[i-A+1][j]+=(dp[i-A][j-k*i]*F[N-j+k*i]*invF[N-j]*invp[i][k]*invF[k])%mod\n      dp[i-A+1][j]%=mod\n    \nprint(((dp[B-A+1][N])%mod))\n\n\n        \n  \n\n\n    \n", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN,A,B,C,D = map(int,input().split())\n\nMOD = 10 ** 9 + 7\n\nfact = [1] * (N+1)\nfact_inv = [1] * (N+1)\nfor n in range(1,N+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[N] = pow(fact[N], MOD-2, MOD)\nfor n in range(N,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\nfact = np.array(fact, dtype=np.int64)\nfact_inv = np.array(fact_inv, dtype=np.int64)\n\ncomb = np.zeros((N+1,N+1), dtype=np.int64)\ncomb[:,0] = 1\nfor n in range(1,N+1):\n    comb[n,1:] = (comb[n-1,1:] + comb[n-1,:-1]) % MOD\n\ndp = np.zeros(N+1, dtype=np.int64)\ndp[0] = 1\nfor x in range(A,B+1):\n    # \u4f7f\u3046\u306a\u3089\u3001C\uff5eD\u4eba\u3067\u4f7f\u3046\n    prev = dp\n    dp = prev.copy()\n    for n in range(C,D+1):\n        y = n * x\n        if y > N:\n            break\n        # x\u4eba\u7d44\u3092n\u7d44\u3068\u308b\n        # dp[i] += dp[i-y] * comb((N-i+y),y) * (y! / (x!)^n / n!)\n        coef = fact[y] * pow(int(fact_inv[x]), n, MOD) % MOD * fact_inv[n] % MOD\n        #print(x,n,coef)\n        dp[y:] += prev[:-y] * comb[N:y-1:-1,y] % MOD * coef\n        dp %= MOD\n\nanswer = dp[N]\nprint(answer)", "SIZE=5*10**3; MOD=10**9+7 #998244353 #\u3053\u3053\u3092\u5909\u66f4\u3059\u308b\n\nSIZE += 1\ninv = [0]*SIZE  # inv[j] = j^{-1} mod MOD\nfac = [0]*SIZE  # fac[j] = j! mod MOD\nfinv = [0]*SIZE # finv[j] = (j!)^{-1} mod MOD\nfac[0] = fac[1] = 1\nfinv[0] = finv[1] = 1\nfor i in range(2,SIZE):\n    fac[i] = fac[i-1]*i%MOD\nfinv[-1] = pow(fac[-1],MOD-2,MOD)\nfor i in range(SIZE-1,0,-1):\n    finv[i-1] = finv[i]*i%MOD\n    inv[i] = finv[i]*fac[i-1]%MOD\n\ndef choose(n,r): # nCk mod MOD \u306e\u8a08\u7b97\n    if 0 <= r <= n:\n        return (fac[n]*finv[r]%MOD)*finv[n-r]%MOD\n    else:\n        return 0\n\ndef chofuku(ball,box): # nHk mod MOD \u306e\u8a08\u7b97\n    return choose(box+ball-1,box)\n\n# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,a,b,c,d = list(map(int,read().split()))\n\n\n\ndp = [0]*(n+1) # i \u307e\u3067\u898b\u3066\u3001x\u4eba\u30b0\u30eb\u30fc\u30d7\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\ndp[0] = 1\n\n\n#for i in range(b,a-1,-1):\nfor i in range(a,b+1):\n    invmod = [1]\n    for p in range(1001//i+2): invmod.append(invmod[-1]*finv[i]%MOD)\n    coeff = [fac[i*p]*invmod[p]%MOD*finv[p]%MOD for p in range(1001//i+2)]    \n    \n    ndp = dp[:]\n    for j in range(n+1):\n        for p in range(c,d+1):\n            if j+i*p > n: break\n            ndp[j+i*p] += coeff[p]*dp[j]%MOD*choose(n-j,i*p)\n            ndp[j+i*p] %= MOD\n\n    #print(invmod,i)\n    #print(coeff)\n    dp = ndp\n    #if i < 100:break\n    #print(dp,i)    \nprint((dp[n]%MOD))    \n    \n\n\n\n\n\n\n    \n    \n    \n"]
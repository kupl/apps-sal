["def isqrt(num):\n    '''Compute int(sqrt(n)) for n integer > 0\n    O(log4(n)) and no floating point operation, no division'''\n    res, bit = 0, 1\n    while bit <= num:\n        bit <<= 2\n    bit >>= 2\n\n    while bit:\n        if num >= res + bit:\n            num -= res + bit\n            res += bit << 1\n        res >>= 1\n        bit >>= 2\n    return res\n\ndef factorize(n):\n    for q in 2, 3:\n        m = 0\n        while not n % q:\n            m += 1\n            n //= q\n        if m: yield q, m\n    \n    m, d, q, maxq = 0, 4, 1, isqrt(n)\n    while q <= maxq:\n        q, d = q + d, 6 - d\n        while not n % q:\n            m += 1\n            n //= q\n        if m:\n            yield q, m\n            m, d, q, maxq = 0, 4, 1, isqrt(n)\n    if n > 1: yield n, 1\n\ndef count_factor(n, f):\n    s = 0\n    while n >= f:\n        n //= f\n        s += n\n    return s\n\ntrailing_zeros = lambda n, b: min(count_factor(n, f)//m for f, m in factorize(b))", "from collections import defaultdict\n\ndef pf(n):\n    primes = defaultdict(lambda: 0); i=2\n    while n>1 and i*i<=n:\n        if n%i==0:\n            while n%i==0: primes[i] = primes[i]+1; n/=i;\n        i+=1\n    if n>1: primes[n]=primes[n]+1\n    return primes\n\nreduce = lambda n,p: 0 if n<p else n//p + reduce(n//p,p)\n\ndef trailing_zeros(num, base):\n    mx = float('inf'); primes = pf(base)\n    for p in primes: mx = min(mx,reduce(num,p)//primes[p])\n    return mx", "def get_factors(n):\n    r = []\n    k = 2\n    while k*k <= n:\n        if n % k == 0:\n            cnt = 0\n            while n % k == 0:\n                n /= k\n                cnt += 1\n            r.append((k, cnt))\n        k += 1\n    if n > 1:\n        r.append((n, 1))\n    return r\n\ndef trailing_zeros(num, base):\n    factors = get_factors(base)\n    zeros = 1<<10000 # infinity\n    for f, p in factors:\n        cnt = 0\n        k = f\n        while k <= num:\n            cnt += num // k\n            k *= f\n        zeros = min(zeros, cnt // p)\n    return zeros", "def trailing_zeros(number, base):\n    smallest_prime_by_pow = {}\n    p = 2\n    b = base\n    while b > 1 and p * p <= base:\n        count_p_pow = 0\n        while b % p == 0:\n            count_p_pow += 1\n            b //= p\n\n        if count_p_pow:\n            smallest_prime_by_pow[count_p_pow] = p\n\n        p += 1 if p == 2 else 2\n\n    if b > 1:\n        smallest_prime_by_pow[1] = b\n\n    # print(smallest_prime_by_pow)\n    res = number\n    \n    for count_p_pow, p in list(smallest_prime_by_pow.items()):\n        count_p_in_fact = 0\n        f = p\n        while f <= number:\n            # print(f, number // f)\n            count_p_in_fact += number // f\n            f *= p\n        \n        res = min(res, count_p_in_fact // count_p_pow)\n        # print(count_p_in_fact)\n\n    return res\n", "f = lambda n, p: 0 if n < p else n//p + f(n//p, p)\n\n\ndef factors(n):\n    p = 2\n    while p*p <= n:\n        cnt = 0\n        while n % p == 0:\n            cnt += 1\n            n //= p\n        yield p, cnt\n        p += 1\n    if n != 1:\n        yield n, 1\n\ndef trailing_zeros(number, base):\n    return min(f(number, num) // cnt for num, cnt in factors(base) if cnt != 0)", "def factors(number):\n    div = 2\n    while div*div <= number:\n        cnt = 0\n        while number % div == 0:\n            cnt += 1\n            number //= div\n        if cnt:\n            yield div, cnt\n        div += 1\n    if number != 1:\n        yield number, 1\n\n\ndef get_prime_power(n, p):\n    res = 0\n    div = p\n    while div <= n:\n        res += n // div\n        div *= p\n    return res\n    \ndef trailing_zeros(number, base):\n    return min(get_prime_power(number, num) // cnt for num, cnt in factors(base))", "from itertools import cycle, groupby\n\ndef trailing_zeros(num, base):\n    return min((exponent(num, p) // len(list(g)) for (p, g) in groupby(factor(base))))\n\ndef exponent(n, p):\n    e = 0\n    while n > 0:\n        n //= p\n        e += n\n    return e\n\ndef factor(n):\n    if n < 1: raise ValueError('factor: n must be > 0')\n    for d in [2, 3, 5]:\n        while n % d == 0:\n            yield d\n            n = n // d\n    d = 7\n    wheel = cycle([4, 2, 4, 2, 4, 6, 2, 6])\n    while n > 1 and d * d <= n:\n        if n % d == 0:\n            yield d\n            n = n // d\n        else:\n            d += next(wheel)\n    if n > 1:\n        yield n\n", "def trailing_zeros(num, base):\n    primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n    plist = []\n    pow = []\n    b = base\n    for p in primes:\n        if b % p == 0:\n            plist.append(p)\n            ctr = 0\n            while b % p == 0:\n                b //= p\n                ctr += 1\n            pow.append(ctr)\n    i = 101\n    iinc = 2\n    while  b > 1:\n        if b % i == 0:\n            if isprime(i):\n                plist.append(i)\n                ctr = 0\n                while b % i == 0:\n                    b = b // i\n                    ctr += 1\n                pow.append(ctr)\n        i+=iinc\n        iinc = 6 - iinc\n        if i*i > b: i = b\n    if len(plist) == 0: return 0\n    plist.sort()\n    accmax = 1e1000\n    while len(plist)>0 :\n        acc = 0\n        a = plist[-1]    # biggest prime factor of base\n        aa = pow[-1]\n        n = num\n        while n!=0:\n            n = n // a\n            acc += n\n        acc = acc // aa\n        plist.pop()\n        pow.pop()\n        if acc < accmax: accmax=acc\n    return accmax\n\ndef isprime(n):\n    if n<=1 : return False\n    if n==2 or n==3: return True\n    if n % 2 == 0: return False\n    if n % 3 == 0: return False\n    a=5\n    ainc=2\n    while a*a<=n:\n        if n % a == 0: return False\n        a += ainc\n        ainc = 6-ainc\n    return True\n\n", "from gmpy2 import is_prime,next_prime\ndef trailing_zeros(n,b):\n    F,p=[],1\n    while 1<b:\n        p,c=next_prime(p),0\n        while b%p==0:b,c=b//p,c+1\n        F+=[(p,c)]*(0<c)\n        if is_prime(b):F,b=F+[(b,1)],1\n    Z=[]\n    for e,c in F:\n        m,t=n,0\n        while 1<m:m,t=m//e,t+m//e\n        Z+=[t//c]\n    return min(Z)", "from gmpy2 import is_prime,next_prime\ndef trailing_zeros(n,b):\n    F,p=[],1\n    while 1<b:\n        p,c=next_prime(p),0\n        while b%p==0:b,c=b//p,c+1\n        F+=[(p,c)]*(0<c)\n        if is_prime(b):F,b=F+[(b,1)],1\n    Z=[]\n    for e,c in F:\n        m,t=n,0\n        while 1<m:\n            m,_=divmod(m,e)\n            t+=m\n        Z+=[t//c]\n    return min(Z)"]
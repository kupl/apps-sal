["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.res = 0\n        def helper(node, path_max, path_min):\n            if not node:\n                return 0\n            path_max = max(path_max, node.val)\n            path_min = min(path_min, node.val)\n            self.res = max(self.res, path_max - path_min)\n            helper(node.left, path_max, path_min)\n            helper(node.right, path_max, path_min)\n        if not root:\n            return 0\n        helper(root, root.val, root.val)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    answer = 0\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, max_v, min_v):\n            # max\uac12 (answer) \uac31\uc2e0\n            self.answer = max(self.answer, abs(max_v - node.val))\n            self.answer = max(self.answer, abs(min_v - node.val))\n                \n            if node.left:\n                dfs(node.left, max(max_v, node.val), min(min_v, node.val))\n            if node.right:\n                dfs(node.right, max(max_v, node.val), min(min_v, node.val))\n        \n        dfs(root, root.val, root.val)\n        return self.answer", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# Think: For each subtree, find the minimum value and maximum value of its descendants.\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.res = 0\n        def helper(node, max_val, min_val):\n            # think: we use the recursive way to traverse through the tree.\n            if not node:\n                self.res = max(self.res, max_val - min_val)\n                return\n            helper(node.left, max(max_val, node.val), min(min_val, node.val))\n            helper(node.right, max(max_val, node.val), min(min_val, node.val))\n        helper(root, 0, 100000)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        \n        self.max_diff = -float(\\\"inf\\\")\n        \n        \n        def helper(root, ancestors):\n            if root is None:\n                return\n            \n            for ancestor in ancestors:\n                if abs(root.val - ancestor) > self.max_diff:\n                    self.max_diff = abs(root.val - ancestor)\n            \n            helper(root.left, ancestors + [root.val])\n            helper(root.right, ancestors + [root.val])\n        \n        helper(root, [root.val])\n        \n        return self.max_diff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return self.maxAncestorDiffHelper(root, [], 0)\n    \n    def maxAncestorDiffHelper(self, root: TreeNode, ancestors, maxV: int) -> int:\n        if root is None:\n            return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        for a in ancestors:\n            maxV = max(maxV, abs(a-root.val))\n        ancestors.append(root.val)\n        maxV = max(\n            maxV,\n            self.maxAncestorDiffHelper(root.left, ancestors, maxV),\n            self.maxAncestorDiffHelper(root.right, ancestors, maxV)\n        )\n        ancestors.pop()\n        return maxV\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return self.helper(root, [], 0)\n    \n    def helper(self, root, anc,prevmax):\n        if root == None:\n            return prevmax\n        real_prev = prevmax\n        for a in anc:\n            prevmax = max(prevmax, abs(a-root.val))\n        anc.append(root.val)\n        real_anc = list(anc)\n        left = self.helper(root.left, anc, prevmax)\n        right = self.helper(root.right, real_anc, prevmax)\n        return max(left,right)\n", "def maxDiff(root, arr):\n        a = 0\n        for i in arr:\n            a = max(a,abs(i-root.val))\n        b = 0\n        c = 0\n        if (root.left):\n            b = maxDiff(root.left, arr+[root.val])\n        if (root.right):\n            c = maxDiff(root.right, arr+[root.val])\n        return max(a,b,c)\n#Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return maxDiff(root,[])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def helper(root):\n            if(root==None):\n                return([])\n            left = helper(root.left)\n            right = helper(root.right)\n            temp = []\n            for i in range(len(left)):\n                if(abs(left[i]-root.val) > self.ans):\n                    self.ans = abs(left[i]-root.val)\n                temp.append(left[i])\n            for i in range(len(right)):\n                if(abs(right[i]-root.val)> self.ans):\n                    self.ans = abs(right[i]-root.val)\n                temp.append(right[i])\n            temp.append(root.val)\n            return(temp)\n        self.ans= 0\n        helper(root)\n        return(self.ans)", "def findMaxDiff(node, collected):\n    if not node:\n        return float('-inf')\n    cur_max = 0\n    for v in collected:\n        cur_max = max(cur_max, abs(v - node.val))\n    left_max = findMaxDiff(node.left, collected + [node.val])\n    right_max = findMaxDiff(node.right, collected + [node.val])\n    return max(cur_max, left_max, right_max)\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return findMaxDiff(root, [])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        maxel = -float('inf')\n        \n        def traverse(root,anc,maxel):\n            if root:\n            \n                for i in anc:\n                    val = abs(i-root.val)\n                    # print(val,maxel)\n                    maxel = max(maxel,val)\n                anc.append(root.val)\n                maxel = traverse(root.right,anc,maxel)\n                maxel = traverse(root.left,anc,maxel)\n                anc.pop(-1)\n            return maxel\n        return traverse(root,[],maxel)\n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxAncestorDiff(self, root):\n        \\\"\\\"\\\"\n        :type root: TreeNode\n        :rtype: int\n        \\\"\\\"\\\"\n        if not root: return 0\n        return self.helper(root, root.val, root.val)\n    \n    def helper(self, node, high, low):\n        if not node:\n            return high - low\n        high = max(high, node.val)\n        low = min(low, node.val)\n        return max(self.helper(node.left, high, low), self.helper(node.right,high,low))\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.ans = 0\n        \n        def preorder(root, minval, maxval):\n            if not root:\n                self.ans = max(self.ans, abs(minval-maxval))\n                return\n            \n            preorder(root.left, min(minval, root.val), max(maxval, root.val))\n            preorder(root.right, min(minval, root.val), max(maxval, root.val))\n            \n        preorder(root, float('inf'), float('-inf'))\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def recur(node):\n            if not node:\n                return (None,None,None)\n            lmaxi, lmini, lres = recur(node.left)\n            rmaxi, rmini, rres = recur(node.right)\n            print(\\\"node.val\\\", node.val)\n            print(\\\"lmaxi, lmini, lres\\\", lmaxi, lmini, lres)\n            print(\\\" rmaxi, rmini, rres\\\", rmaxi, rmini, rres)\n            curr = node.val\n            cv = [lmaxi, lmini, rmaxi, rmini]\n            res = [lres, rres]\n            res = res + [abs(curr-val) for val in cv if val!=None]\n            res = [val for val in res if val!=None]\n            \n            minr = [lmini, rmini, curr]\n            maxr = [lmaxi, rmaxi, curr]\n            minr = [val for val in minr if val!=None]\n            maxr = [val for val in maxr if val!=None]\n            \n            mini = min(minr)\n            maxi = max(maxr)\n            print(\\\"res arr\\\", res)\n            res = max([0] + res)\n            print(\\\"node, maxi, mini, res\\\", node.val, maxi, mini, res)\n            return (maxi, mini, res)\n        _,_,res = recur(root)\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.ans = 0\n        \n        def preorder(root, minval, maxval):\n            if not root:\n                self.ans = max(self.ans, abs(minval-maxval))\n                return\n            \n            minval, maxval = min(minval, root.val), max(maxval, root.val)\n            preorder(root.left, minval, maxval)\n            preorder(root.right, minval, maxval)\n            \n        preorder(root, float('inf'), float('-inf'))\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return self.helper(root)[1]\n    \n    def helper(self,root):\n        if root == None:\n            return (None,0,None) #(lowest,largest,highest)\n        elif root.left == None and root.right == None:\n            return (root.val,0,root.val)\n        elif root.left == None:\n            (r_low,r_long,r_high) = self.helper(root.right)\n            return (min(r_low,root.val),max(r_long,abs(root.val - r_low ),abs(root.val - r_high)),max(r_high,root.val))\n        elif root.right == None:\n            (l_low,l_long,l_high) = self.helper(root.left)\n            return (min(l_low,root.val),max(l_long,abs(root.val - l_low ),abs(root.val - l_high)),max(l_high,root.val))\n        else:\n            (r_low,r_long,r_high) = self.helper(root.right)\n            (l_low,l_long,l_high) = self.helper(root.left)\n            print(root,r_high,l_high,l_long,r_long)\n            return (min(l_low,root.val,r_low),max(r_long,l_long,abs(root.val - min(l_low,r_low)),abs(root.val - max(r_high,l_high))),max(r_high,l_high,root.val))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# for each node\n# i get:\n#     left_min, right_min\n#     left_max, right_max\n    \n# val = node.val\n# current_min = min(left_min, right_min)\n# current_max = max(left_max, right_max)\n\n# max_dist = max(abs(val-current_min), abs(val-current_max))\n# self.result = max(self.result, max_dist)\n\n# return (current_min, current_max)\n\n# after recursion return self.result\n\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        def recurse(node):\n            if node is None:\n                return float('inf'), float('-inf')\n            else:\n                left_min, left_max = recurse(node.left)\n                right_min, right_max = recurse(node.right)\n                \n                current_min = min(left_min, right_min)\n                current_max = max(left_max, right_max)\n                \n                val = node.val\n                \n                d = 0\n                if current_min != float('inf'):\n                    d = max(d, abs(current_min - val))\n                    \n                if current_max != float('-inf'):\n                    d = max(d, abs(current_max - val))\n                    \n                self.maxDist = max(self.maxDist, d)\n                \n                return min(current_min, val), max(current_max, val)\n        \n        self.maxDist = 0\n        recurse(root)\n        return self.maxDist\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.ans = 0\n        def traverse(node, max_v, min_v):\n            self.ans = max( self.ans, abs(max_v- min_v) )\n            _ = any(traverse(adj, max(max_v, adj.val), min(min_v, adj.val)) for adj in [node.left, node.right] if adj) \n        \n        traverse(root, root.val, root.val)\n        return self.ans\n", "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n\n        def findMaxDiff(node, max_sf, min_sf):\n            if not node:\n                return float('-inf')\n            cur_max = max(abs(node.val - max_sf), abs(node.val - min_sf))\n            max_sf, min_sf = max(max_sf, node.val), min(min_sf, node.val)\n            left_max = findMaxDiff(node.left, max_sf, min_sf)\n            right_max = findMaxDiff(node.right, max_sf, min_sf)\n            return max(cur_max, left_max, right_max)\n\n        return findMaxDiff(root, root.val, root.val)        \n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        #O(n) where n is the amount of nodes in tree\n        def mdiff(root, maxval, minval):\n            if not root:\n                return -1\n            maxval = max(root.val, maxval)\n            minval = min(minval, root.val)\n            return max(abs(maxval - minval), mdiff(root.left, maxval, minval), mdiff(root.right, maxval, minval))\n        \n        return mdiff(root, 0, 100000)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, node: TreeNode) -> int:\n        def helper(node, max_val, min_val):\n            if not node:\n                return 0\n            \n            diff = max(abs(max_val - node.val), abs(min_val - node.val))\n            max_val = max(node.val, max_val)\n            min_val = min(node.val, min_val)\n            return max(helper(node.left, max_val, min_val), helper(node.right, max_val, min_val), diff)\n        \n        if not node:\n            return 0\n        \n        return helper(node, node.val, node.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, path):\n            if node.left == None and node.right == None: \n                if len(path) >1:\n                    res[0] = max(res[0], abs(max(path) - min(path)))\n                    # res[0] = max(res[0], max([abs(j - node.val) for j in path]))\n                return \n            \n            else:\n                \n                if node.left:\n                    dfs(node.left, path  + [node.left.val])\n                \n                if node.right: \n                    dfs(node.right, path + [node.right.val])\n                    \n                return \n                \n            \n            \n            \n    \n        res = [-1*float('infinity')]\n        \n        dfs(root, [root.val])\n        \n        # print(res)\n        \n        \n        return res[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, path):\n            if node.left == None and node.right == None: \n                if len(path) >1:\n                    res[0] = max(res[0], abs(max(path) - min(path)))\n                    # res[0] = max(res[0], max([abs(j - node.val) for j in path]))\n                return \n            \n            else:\n                \n                if node.left:\n                    dfs(node.left, path  + [node.left.val])\n                \n                if node.right: \n                    dfs(node.right, path + [node.right.val])\n                    \n                return \n                \n            \n            \n            \n    \n        res = [-1*float('infinity')]\n        \n        dfs(root, [root.val])\n        \n        print(res)\n        \n        \n        return res[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        def dfs(root: TreeNode, path: List[int]) -> None:\n            if root is None:\n                return\n            \n            path = path + [root.val]\n            \n            if root.left is None and root.right is None:\n                result.append(path)\n            else:\n                dfs(root.left, path)\n                dfs(root.right, path)\n                    \n        \n        result = []\n        dfs(root, path=[])\n        return max([ abs(max(arr) - min(arr)) for arr in result ])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nimport numpy as np\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        global_max = 0  \n        \n        def dfs(t):\n            if t is None:\n                return []\n            \n            lim_span_l = dfs(t.left)\n            lim_span_r = dfs(t.right)\n\n            nonlocal global_max\n\n            lim_span = [t.val]\n            if lim_span_l:\n                global_max = max(global_max, np.max(np.abs(t.val - np.array(lim_span_l))))\n                lim_span.extend(lim_span_l)\n\n            if lim_span_r:\n                global_max = max(global_max, np.max(np.abs(t.val - np.array(lim_span_r))))\n                lim_span.extend(lim_span_r)\n            \n            return [min(lim_span), max(lim_span)]\n        \n        intv = dfs(root)\n        return global_max", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, path):\n            if node.left == None and node.right == None: \n                if len(path) >1:\n                    res[0] = max(res[0], abs(max(path) - min(path)))\n                return \n            \n            else:\n                \n                if node.left:\n                    dfs(node.left, path  + [node.left.val])\n                \n                if node.right: \n                    dfs(node.right, path + [node.right.val])\n                    \n                return \n                    \n        res = [-1*float('infinity')]\n        \n        dfs(root, [root.val])\n        \n        \n        return res[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nimport numpy as np\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.global_max = 0  \n        \n        def dfs(t):\n            if t is None:\n                return []\n            \n            global_max = self.global_max\n\n            lim_span_l = dfs(t.left)\n            lim_span_r = dfs(t.right)\n\n            lim_span = [t.val]\n            if lim_span_l:\n                global_max = max(global_max, np.max(np.abs(t.val - np.array(lim_span_l))))\n                lim_span.extend(lim_span_l)\n\n            if lim_span_r:\n                global_max = max(global_max, np.max(np.abs(t.val - np.array(lim_span_r))))\n                lim_span.extend(lim_span_r)\n            \n            self.global_max = max(self.global_max, global_max)\n\n            return [min(lim_span), max(lim_span)]\n        \n        intv = dfs(root)\n        return self.global_max", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, path):\n            if node.left == None and node.right == None: \n                if len(path) >1:\n                    res[0] = max(res[0], abs(max(path) - min(path)))\n                return \n            \n            else:\n                \n                if node.left:\n                    dfs(node.left, path  + [node.left.val])\n                \n                if node.right: \n                    dfs(node.right, path + [node.right.val])\n                    \n                return \n                \n    \n        res = [-1*float('infinity')]\n        \n        dfs(root, [root.val])\n        \n        \n        return res[0]", "from bisect import insort\nfrom copy import copy\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\n    def traverse(self, root, path = []):\n        if root is None:\n            return\n        \n        path = copy(path)\n        insort(path, root.val)\n        \n        if root.left is None and root.right is None:\n            path_abs_diff = max(path) - min(path)\n            self.max_abs_diff = max(self.max_abs_diff, path_abs_diff)\n\n        self.traverse(root.left, path)\n        self.traverse(root.right, path)\n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_abs_diff = 0\n        \n        self.traverse(root)\n        \n        return self.max_abs_diff\n        \n        \n        \n                \n        \n            \n", "from bisect import insort\nfrom copy import copy\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\n    def traverse(self, root, path = []):\n        if root is None:\n            return\n        \n        path = copy(path)\n        insort(path, root.val)\n        \n        if root.left is None and root.right is None:\n            path_abs_diff = path[-1] - path[0]\n            self.max_abs_diff = max(self.max_abs_diff, path_abs_diff)\n\n        self.traverse(root.left, path)\n        self.traverse(root.right, path)\n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_abs_diff = 0\n        \n        self.traverse(root)\n        \n        return self.max_abs_diff\n        \n        \n        \n                \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\n    def traverse(self, root, path = []):\n        if root is None:\n            return\n        \n        path = path + [root.val]\n        \n        if root.left is None and root.right is None:\n            path_abs_diff = max(path) - min(path)\n            self.max_abs_diff = max(self.max_abs_diff, path_abs_diff)\n        elif root.left is None:\n            self.traverse(root.right, path)\n        elif root.right is None:\n            self.traverse(root.left, path)\n        else:\n            self.traverse(root.left, path)\n            self.traverse(root.right, path)\n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_abs_diff = 0\n        \n        self.traverse(root)\n        \n        return self.max_abs_diff\n        \n        \n        \n                \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return self.recursiveMax(root, root.val, root.val)\n        \n    def recursiveMax(self, root, largest, smallest):\n        if root is None:\n            return 0\n        else:\n            diff1 = abs(root.val - largest)\n            diff2 = abs(root.val - smallest)\n            largest = max(root.val, largest)\n            smallest = min(root.val, smallest)\n            return max(diff1, diff2, self.recursiveMax(root.left, largest, smallest),\n                      self.recursiveMax(root.right, largest, smallest))\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        paths=[]\n        def pathsToLeafs(root,comp):\n            if not root:\n                return\n            if not root.left and not root.right:\n                paths.append(comp+[root.val])\n                return\n            pathsToLeafs(root.left,comp+[root.val])\n            pathsToLeafs(root.right,comp+[root.val])\n        pathsToLeafs(root,[])\n        #now this is converted to buy and sell stock atmost one time for all paths\n        def maxDiff(a):\n            val=0\n            n=len(a)\n            dp=[0]*n\n            for i in range(1,n):\n                val=max(val+a[i]-a[i-1],dp[i])\n                dp[i]=max(val,dp[i-1])\n            return dp[-1]\n                \n                \n        res=0\n        for path in paths:\n            res=max(res,maxDiff(path),maxDiff(path[::-1]))\n        return res\n            \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \\\"\\\"\\\"\n        IDEA: \u6bcf\u689dpath\u6642\u62c9\u51famax_diff\uff0c\u6253\u64c2\u53f0!\n        1. max_diff \u67e5\u6cd5\u8907\u96dc\u5ea6\u5206\u6790\uff1a\n            a. \u5c0d\u65bc\u4e00\u689dpath\uff0c\u6700\u7cdf\u62c9\u6210\u4e00\u689d:5000 * 5000 + 5000\uff0c\u8c8c\u4f3c\u53ef\u884c\n                    ==> O(N^2)\n            b. \u512a\u5316\uff1a\u7576path\u4e0a\u90a3\u4e00\u9846\u5927\u65bc\u6211\uff0c\u5c31\u8b93\u5b83\u4f5c\u70ba ref_value \u53bb\u8ddf\u518d\u5f8c\u9762\u7684\u76f8\u526a\n                    ==> O(N)\n        \\\"\\\"\\\"\n        \\\"\\\"\\\"\n        ISSUES:\n        1. [0,null,1], \u6211\u89ba\u5f97\u8a72\u662f 0, \u4f46answer\u8aaa\u662f1,\n            Sol, WRONG: \u8449\u7bc0\u9ede\u6642\uff0c\u8449\u5b50\u81ea\u5df1\u7684\u503c\u4e5f\u653e\u5165\u6253\u64c2\u53f0 X\n            Sol, calc_max_diff \u4e2d\uff0c\u5148\u8a08\u7b97diff\u5f8c\uff0c\u5982\u679cj\u6307\u7684\u5730\u65b9\u6bd4i\u5927\uff0c\u518d\u628ai\u6307\u5230j\u4e0a\u9762\u53bb\n        \\\"\\\"\\\"\n        \n        if not root:\n            return 0\n        max_diff = [0]  # [max, min]\n        # self.helper(root, [], max_diff)               # 3000 ms, \u9019\u500b\u5982\u679c\u5728 calc_max_diff \u6642\u4e0d\u4f5c O(N^2) -> O(N) \u7684\u512a\u5316\uff0c\u5c31\u6703TLE\n        self.helper_early_return(root, [], max_diff)    # 220 ms\n        return max(max_diff[0], 0)  # \u907f\u514d\u6240\u6709\u7684\u7956\u5148\u90fd\u6bd4\u5b50\u5b6b\u5011\u90fd\u5c0f\n    \n        min_max = [root.val, root.val]\n        self.helper2_FAILED(root, [], max_diff, min_max)   # WRONG! \u540c\u6b65\u5b58\u5132 min_max\uff0cFAILED... \u56e0\u70babacktrack\u6642\u5f97\u628a\u90a3\u689d\u8def\u5f91\u6240\u8ca2\u737b\u7684min\u6216max\u653e\u56de\u53bb\u2026 \u591a\u4e8b\u53c8\u9ebb\u7169\n        # return res[0] - res[1]\n        return min_max[1] - min_max[0]\n\n    def helper2_FAILED(self, root, items, max_diff, min_max): # min_max at the same time\n        if not root:\n            # return\n            # if not root.left and not root.right:\n            cur_max_diff = min_max[1] - min_max[0]\n            print(items, min_max)\n            max_diff[0] = max(cur_max_diff, max_diff[0])\n            return \n        min_max[0], min_max[1] = min(min_max[0], root.val), max(min_max[1], root.val)\n        self.helper2(root.left, items + [root.val], max_diff, min_max)\n        self.helper2(root.right, items + [root.val], max_diff, min_max)\n    \n    \n    def helper(self, root, items, max_diff):\n        if not root:\n            cur_max_diff = self.calc_max_diff(items)\n            max_diff[0] = max(cur_max_diff, max_diff[0])\n            return \n            \n        self.helper(root.left, items + [root.val], max_diff)\n        self.helper(root.right, items + [root.val], max_diff)\n    \n    def helper_early_return(self, root, items, max_diff):\n        if not root:\n            return\n        if not root.left and not root.right:\n            cur_max_diff = self.calc_max_diff(items + [root.val])\n            max_diff[0] = max(cur_max_diff, max_diff[0])\n            return \n            \n        self.helper_early_return(root.left, items + [root.val], max_diff)\n        self.helper_early_return(root.right, items + [root.val], max_diff)\n        \n    def calc_max_diff(self, items):\n        \\\"\\\"\\\" 8 3 6 7 \n            i j\n        \\\"\\\"\\\"\n        n = len(items)\n        # print(items)\n        i = 0\n        \\\"\\\"\\\" O(N) Optimization in calc_max_diff! \\\"\\\"\\\"\n        cur_max = cur_min = items[0]\n        for i in range(n):\n            cur_max = max(cur_max, items[i])\n            cur_min = min(cur_min, items[i])\n        return cur_max-cur_min\n    \n        \\\"\\\"\\\" Orig O(N^2) calc_max_diff \\\"\\\"\\\"\n        cur_max_diff = 0\n        while i < n:\n            for j in range(i+1, n):\n                diff = abs(items[i] - items[j])\n                cur_max_diff = max(diff, cur_max_diff)\n            i += 1\n        return cur_max_diff\n    \n#     def calc_max_diff_WRONG(self, items):   # \u9019\u662f\u8981\u6c42parent\u5fc5\u6bd4\u8f03\u5927\u6642\u7684\u512a\u5316\n#         \\\"\\\"\\\" 8 3 6 7 \n#             i j\n#         \\\"\\\"\\\"\n        \n#         n = len(items)\n#         print(items)\n#         i = 0\n#         cur_max_diff = 0\n#         while i < n:\n#             for j in range(i+1, n):\n#                 diff = items[i] - items[j]\n#                 cur_max_diff = max(diff, cur_max_diff)\n#                 if items[j] > items[i]:\n#                     i = j\n#                     # break\n#                     continue\n\n#             i += 1\n#         return cur_max_diff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \\\"\\\"\\\"\n        IDEA: \u6bcf\u689dpath\u6642\u62c9\u51famax_diff\uff0c\u6253\u64c2\u53f0!\n        1. max_diff \u67e5\u6cd5\u8907\u96dc\u5ea6\u5206\u6790\uff1a\n            a. \u5c0d\u65bc\u4e00\u689dpath\uff0c\u6700\u7cdf\u62c9\u6210\u4e00\u689d:5000 * 5000 + 5000\uff0c\u8c8c\u4f3c\u53ef\u884c\n                    ==> O(N^2)\n            b. \u512a\u5316\uff1a\u7576path\u4e0a\u90a3\u4e00\u9846\u5927\u65bc\u6211\uff0c\u5c31\u8b93\u5b83\u4f5c\u70ba ref_value \u53bb\u8ddf\u518d\u5f8c\u9762\u7684\u76f8\u526a\n                    ==> O(N)\n        \\\"\\\"\\\"\n        \\\"\\\"\\\"\n        ISSUES:\n        1. [0,null,1], \u6211\u89ba\u5f97\u8a72\u662f 0, \u4f46answer\u8aaa\u662f1,\n            Sol, WRONG: \u8449\u7bc0\u9ede\u6642\uff0c\u8449\u5b50\u81ea\u5df1\u7684\u503c\u4e5f\u653e\u5165\u6253\u64c2\u53f0 X\n            Sol, calc_max_diff \u4e2d\uff0c\u5148\u8a08\u7b97diff\u5f8c\uff0c\u5982\u679cj\u6307\u7684\u5730\u65b9\u6bd4i\u5927\uff0c\u518d\u628ai\u6307\u5230j\u4e0a\u9762\u53bb\n        \\\"\\\"\\\"\n        \n        if not root:\n            return 0\n        max_diff = [0]  # [max, min]\n        # self.helper(root, [], max_diff)\n        self.helper_early_return(root, [], max_diff)\n        return max(max_diff[0], 0)  # \u907f\u514d\u6240\u6709\u7684\u7956\u5148\u90fd\u6bd4\u5b50\u5b6b\u5011\u90fd\u5c0f\n    \n        min_max = [root.val, root.val]\n        self.helper2_FAILED(root, [], max_diff, min_max)   # WRONG! \u540c\u6b65\u5b58\u5132 min_max\uff0cFAILED... \u56e0\u70babacktrack\u6642\u5f97\u628a\u90a3\u689d\u8def\u5f91\u6240\u8ca2\u737b\u7684min\u6216max\u653e\u56de\u53bb\u2026 \u591a\u4e8b\u53c8\u9ebb\u7169\n        # return res[0] - res[1]\n        return min_max[1] - min_max[0]\n\n    def helper2_FAILED(self, root, items, max_diff, min_max): # min_max at the same time\n        if not root:\n            # return\n            # if not root.left and not root.right:\n            cur_max_diff = min_max[1] - min_max[0]\n            print(items, min_max)\n            max_diff[0] = max(cur_max_diff, max_diff[0])\n            return \n        min_max[0], min_max[1] = min(min_max[0], root.val), max(min_max[1], root.val)\n        self.helper2(root.left, items + [root.val], max_diff, min_max)\n        self.helper2(root.right, items + [root.val], max_diff, min_max)\n    \n    \n    def helper(self, root, items, max_diff):\n        if not root:\n            cur_max_diff = self.calc_max_diff(items)\n            max_diff[0] = max(cur_max_diff, max_diff[0])\n            return \n            \n        self.helper(root.left, items + [root.val], max_diff)\n        self.helper(root.right, items + [root.val], max_diff)\n    \n    def helper_early_return(self, root, items, max_diff):\n        if not root:\n            return\n        if not root.left and not root.right:\n            cur_max_diff = self.calc_max_diff(items + [root.val])\n            max_diff[0] = max(cur_max_diff, max_diff[0])\n            return \n            \n        self.helper_early_return(root.left, items + [root.val], max_diff)\n        self.helper_early_return(root.right, items + [root.val], max_diff)\n        \n    def calc_max_diff(self, items):\n        \\\"\\\"\\\" 8 3 6 7 \n            i j\n        \\\"\\\"\\\"\n        n = len(items)\n        # print(items)\n        i = 0\n        \\\"\\\"\\\" O(N) Optimization in calc_max_diff! \\\"\\\"\\\"\n        cur_max = cur_min = items[0]\n        for i in range(n):\n            cur_max = max(cur_max, items[i])\n            cur_min = min(cur_min, items[i])\n        return cur_max-cur_min\n    \n        \\\"\\\"\\\" Orig O(N^2) calc_max_diff \\\"\\\"\\\"\n        cur_max_diff = 0\n        while i < n:\n            for j in range(i+1, n):\n                diff = abs(items[i] - items[j])\n                cur_max_diff = max(diff, cur_max_diff)\n            i += 1\n        return cur_max_diff\n    \n#     def calc_max_diff_WRONG(self, items):   # \u9019\u662f\u8981\u6c42parent\u5fc5\u6bd4\u8f03\u5927\u6642\u7684\u512a\u5316\n#         \\\"\\\"\\\" 8 3 6 7 \n#             i j\n#         \\\"\\\"\\\"\n        \n#         n = len(items)\n#         print(items)\n#         i = 0\n#         cur_max_diff = 0\n#         while i < n:\n#             for j in range(i+1, n):\n#                 diff = items[i] - items[j]\n#                 cur_max_diff = max(diff, cur_max_diff)\n#                 if items[j] > items[i]:\n#                     i = j\n#                     # break\n#                     continue\n\n#             i += 1\n#         return cur_max_diff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        paths=[]\n        def pathsToLeafs(root,comp):\n            if not root:\n                return\n            if not root.left and not root.right:\n                paths.append(comp+[root.val])\n                return\n            pathsToLeafs(root.left,comp+[root.val])\n            pathsToLeafs(root.right,comp+[root.val])\n        pathsToLeafs(root,[])\n        #now this is converted to buy and sell stock atmost one time for all paths\n        def maxDiff(a):\n            val=0\n            n=len(a)\n            dp=[0]*n\n            for i in range(1,n):\n                val=max(val+a[i]-a[i-1],dp[i])\n                dp[i]=max(val,dp[i-1])\n            return dp[-1]\n                \n                \n        res=0\n        for path in paths:\n            print(path)\n            res=max(res,maxDiff(path),maxDiff(path[::-1]))\n        return res\n            \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def solve(self, lst, root):\n        max_current = lst[-1][1]\n        min_current = lst[-1][0]\n        if root is not None:          \n            current_value = root.val\n            if current_value > max_current:\n                max_current = current_value\n            if current_value < min_current:\n                min_current = current_value\n            lst.append((min_current, max_current))\n            return max(self.solve(lst[:], root.left), self.solve(lst[:], root.right))\n        else:\n            max_val =  max_current - min_current\n            return max_val\n\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        lst = [(root.val, root.val)]\n        return max(self.solve(lst[:], root.left), self.solve(lst[:], root.right))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\n    def traverse(self, root, path = []):\n        if root is None:\n            return\n        \n        path = path + [root.val]\n        \n        if root.left is None and root.right is None:\n            path_abs_diff = max(path) - min(path)\n            self.max_abs_diff = max(self.max_abs_diff, path_abs_diff)\n\n        self.traverse(root.left, path)\n        self.traverse(root.right, path)\n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_abs_diff = 0\n        \n        self.traverse(root)\n        \n        return self.max_abs_diff\n        \n        \n        \n                \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# do not assume binary trees are balanced or sorted!\n\nLEFT_PROCESSED = 1\nRIGHT_PROCESSED = 2\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def recurse_func(node, parent_vals, best_answer):\n            # check if we can compute a better answer with this node\n            if parent_vals:\n                ans = abs(min(parent_vals) - node.val)\n                if ans > best_answer:\n                    best_answer = ans\n                ans = abs(max(parent_vals) - node.val)\n                if ans > best_answer:\n                    best_answer = ans\n            \n            # check our children\n            # there is some optimization that can occur here to prune entire branches if we detect the best answer is larger\n            # than the largest value we expect to find in the tree branch, but we would need to record whether we came down the left or right branch of the parent\n            parent_vals.append(node.val)\n            if node.left:\n                best_answer = recurse_func(node.left, parent_vals, best_answer)\n            if node.right:\n                best_answer = recurse_func(node.right, parent_vals, best_answer)\n            parent_vals.pop()\n            \n            # return best_answer\n            return best_answer\n    \n        return recurse_func(root, [], 0)\n\n    \n#         best_answer = 0\n#         parent_nodes = [[root, 0]]\n#         while parent_nodes:\n#             cn = parent_nodes[-1]\n#             for n in parent_nodes:\n#                 ans = abs(n[0].val - cn[0].val)\n#                 if ans > best_answer:\n#                     best_answer = ans\n\n#             n = cn[0]                    \n#             if not (cn[1] & LEFT_PROCESSED):\n#                 cn[1] = cn[1] | LEFT_PROCESSED\n#                 if n.left:\n#                     parent_nodes.append([n.left, 0])\n#                 continue\n#             if not (cn[1] & RIGHT_PROCESSED):\n#                 cn[1] = cn[1] | RIGHT_PROCESSED\n#                 if n.right:\n#                     parent_nodes.append([n.right, 0])\n#                 continue\n#             if (cn[1] & LEFT_PROCESSED) and (cn[1] & RIGHT_PROCESSED):\n#                 parent_nodes.pop()\n#         return best_answer\n        \n    \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        maximum = -float(\\\"inf\\\")\n        stack = []\n        def dfs(root):\n            nonlocal maximum\n            if not root:\n                maximum = max(abs(max(stack) - min(stack)), maximum)\n                return\n            stack.append(root.val)\n            dfs(root.left)\n            dfs(root.right)\n            stack.pop()\n        dfs(root)\n        return maximum\n            \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.v_max = 0\n        \n        def find(node, path):\n            if not node:                \n                return \n \n            tmp = max(abs(max(path) - node.val), abs(min(path) - node.val))\n            self.v_max = max(self.v_max, tmp)\n            \n            path.append(node.val)\n            \n            find(node.left, path)\n            find(node.right, path)\n            \n            path.pop()\n            \n        find(root, [root.val])\n        return self.v_max", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        stack = [(root,root.val,root.val)]\n        maxDiff = -1\n        while stack:\n            node, maxVal, minVal = stack.pop()\n            maxVal = max(maxVal,node.val)\n            minVal = min(minVal,node.val)\n            maxDiff = max(maxDiff,maxVal-minVal)\n            if node.left:\n                stack.append((node.left,maxVal,minVal))\n            if node.right:\n                stack.append((node.right,maxVal,minVal))\n        return maxDiff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    maxDiff = 0\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        currPath = []\n        \n        def dfs(currNode, currPath):\n            currPath.append(currNode.val)\n            \n            if currNode.left:\n                dfs(currNode.left, currPath)\n                \n            if currNode.right:\n                dfs(currNode.right, currPath)\n                \n            self.maxDiff = max(self.maxDiff, max(currPath) - min(currPath))\n        \n            currPath.pop()\n        \n        dfs(root, currPath)\n        return self.maxDiff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    maxDiff = 0\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        currPath = []\n        \n        def dfs(currNode, currPath):\n            if not currNode:\n                if len(currPath) > 0:\n                    self.maxDiff = max(self.maxDiff, max(currPath) - min(currPath))\n                    \n                return\n            \n            currPath.append(currNode.val)\n            \n            dfs(currNode.left, currPath)\n            dfs(currNode.right, currPath)\n                \n            currPath.pop()\n        \n        dfs(root, currPath)\n        return self.maxDiff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.mx=0\n        path=[]\n        def getpath(root):\n            if not root:\n                return\n            path.append(root.val)\n            if len(path)>1:\n                self.mx=max(self.mx,abs(min(path[:-1])-path[-1]))\n                self.mx=max(self.mx,abs(max(path[:-1])-path[-1]))\n                #print(path)\n            getpath(root.left)\n            getpath(root.right)\n            path.pop()\n            \n        getpath(root)\n        return self.mx", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_diff = -float('inf')\n        self.dfs(root, [])\n        return self.max_diff\n\n    def dfs(self, root, path):\n        if not root:\n            # print(path)\n            self.max_diff = max(self.max_diff, max(path) - min(path))\n            return\n        self.dfs(root.left, path + [root.val])\n        self.dfs(root.right, path + [root.val])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.maxval = float('-inf')\n        def dfs(node, ans):\n            if node:\n                if ans:\n                    self.maxval = max(self.maxval, abs(max(ans) - node.val))\n                    self.maxval = max(self.maxval, abs(min(ans) - node.val))\n                \n                dfs(node.left, ans + [node.val])\n                dfs(node.right, ans + [node.val])\n        dfs(root, [])\n        return self.maxval\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_diff = -float('inf')\n        self.dfs(root, [])\n        return self.max_diff\n\n    def dfs(self, root, path):\n        if not root:\n            self.max_diff = max(self.max_diff, max(path) - min(path))\n            return\n        self.dfs(root.left, path + [root.val])\n        self.dfs(root.right, path + [root.val])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def traverse(root, prev_min, prev_max):\n            if root:\n                prev_min = min(root.val, prev_min)\n                prev_max = max(root.val, prev_max)\n                return max(traverse(root.left, prev_min, prev_max), traverse(root.right, prev_min, prev_max))\n            else:\n                return prev_max - prev_min\n\n        return traverse(root, root.val, root.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.res = float(-inf)\n        self.dfs(root, [])\n        \n        return self.res\n    \n    def dfs(self, node, path):\n        if not node:\n            self.res = max(self.res, max(path) - min(path))\n            return\n        \n        self.dfs(node.left, path+[node.val])\n        self.dfs(node.right, path+[node.val])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        # initialize a difference variable for the difference value\n        # have to account for if max is a negative number. 0 is > -num\n        self.max_diff = -float(\\\"inf\\\")\n        # call helper function passing in the root (where you start) and an empty list [] (holds the path of travel)\n        self.dfs(root, [])\n        \n        # return out the max difference value\n        return self.max_diff\n    \n    # helper method to track path and perform subtraction\n    def dfs(self, root, path):\n        # if there is not root\n        if not root:\n            # print(\\\"PATH: \\\", path)\n            self.max_diff = max(self.max_diff, max(path) - min(path))\n            return\n        self.dfs(root.left, path + [root.val])\n        self.dfs(root.right, path + [root.val])\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_diff = -float('inf')\n        \n        def helper(node, vals):\n            \n            if not node:\n                self.max_diff = max(self.max_diff,abs(max(vals)-min(vals)))\n                return \n            \n            helper(node.left,vals + [node.val])\n            helper(node.right,vals + [node.val])\n                \n        helper(root, [root.val])\n        \n        return self.max_diff\n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.dist = 0\n\n        def dfs(node, ancesVal):\n            #print(ancesVal)\n            if not node:\n                self.dist = max(self.dist, abs(max(ancesVal) -  min(ancesVal)))\n                return\n            \n            dfs(node.left, ancesVal + [node.val])\n\n            dfs(node.right, ancesVal + [node.val])\n            return \n      \n        dfs(root, [])\n        return self.dist", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        ##### Using dfs and finding diff of min and max values\n        self.mx=0\n        path=[]\n        def getpath(root):\n            if not root:\n                return\n            path.append(root.val)\n            self.mx=max(self.mx,abs(min(path)-max(path)))\n            #print(path)\n            getpath(root.left)\n            getpath(root.right)\n            path.pop()\n            \n        getpath(root)\n        return self.mx\n       \n                    \n                    \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_diff = -float('inf')\n        self.dfs(root, [], [])\n        return self.max_diff\n\n    def dfs(self, root, path, res):\n        if not root:\n            # print(path)\n            self.max_diff = max(self.max_diff, max(path) - min(path))\n            return\n        self.dfs(root.left, path + [root.val], res)\n        self.dfs(root.right, path + [root.val], res)", "class Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_diff = -float('inf')\n        self.dfs(root, [])\n        return self.max_diff\n\n    def dfs(self, root, path):\n        if not root:\n            # print(path)\n            self.max_diff = max(self.max_diff, max(path) - min(path))\n            return\n        self.dfs(root.left, path + [root.val])\n        self.dfs(root.right, path + [root.val])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return self.recursiveMax(root, root.val, root.val, 0)\n        \n    def recursiveMax(self, root, largest, smallest, max_so_far):\n        if root is None:\n            return max_so_far\n        else:\n            diff1 = abs(root.val - largest)\n            diff2 = abs(root.val - smallest)\n            largest = max(root.val, largest)\n            smallest = min(root.val, smallest)\n            max_so_far = max(max_so_far, diff1, diff2)\n            return max(max_so_far, self.recursiveMax(root.left, largest, smallest, max_so_far),\n                      self.recursiveMax(root.right, largest, smallest, max_so_far))\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_diff = 0\n        self.dfs(root, [])\n        return self.max_diff\n\n    def dfs(self, root, path):\n        if not root:\n            # print(path)\n            self.max_diff = max(self.max_diff, max(path) - min(path))\n            return\n        self.dfs(root.left, path + [root.val])\n        self.dfs(root.right, path + [root.val])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        stack = [[root, [root.val]]]\n        res = 0\n        while stack:\n            node, ancestors = stack[0]\n            res = max(res, abs(node.val - ancestors[0]), abs(node.val - ancestors[-1]))\n            for i in range(len(ancestors)):\n                if node.val >= ancestors[i]:\n                    new_ancestors = ancestors[0:i] + [node.val] + ancestors[i:]\n                    break \n                if i == len(ancestors) - 1:\n                    new_ancestors = ancestors + [node.val]\n            if node.left != None:\n                stack.append([node.left, new_ancestors])\n            if node.right != None:\n                stack.append([node.right, new_ancestors])\n            stack = stack[1:]\n        return(res)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        maxDiff = 0\n        stk = [root]\n        ancDict = {}\n        ancDict[root.val] = []\n        while len(stk)!=0:\n            root = stk.pop()\n            if root.left is not None:\n                stk.append(root.left)\n                if root.left not in ancDict:\n                    ancDict[root.left.val] = []\n                ancDict[root.left.val].append(root.val)\n                ancDict[root.left.val].extend(ancDict[root.val])\n            if root.right is not None:\n                stk.append(root.right)\n                if root.right not in ancDict:\n                    ancDict[root.right.val] = []\n                ancDict[root.right.val].append(root.val)\n                ancDict[root.right.val].extend(ancDict[root.val])\n        for k in ancDict:\n            for v in ancDict[k]:\n                if abs(v - k) > maxDiff:\n                    maxDiff = abs(v - k)\n        return maxDiff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nimport queue\nfrom collections import defaultdict\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        maxDiff = 0\n        dq = queue.deque()\n        dq.append(root)\n        data = []\n        nodes = defaultdict(list)\n        \n        while any(dq):\n            node = dq.popleft()\n            data.append(node.val)\n            if node.left:\n                dq.append(node.left)\n                nodes[node.left.val].append(node.val)\n                nodes[node.left.val].extend(nodes[node.val])\n            if node.right:\n                dq.append(node.right)\n                nodes[node.right.val].append(node.val)\n                nodes[node.right.val].extend(nodes[node.val])\n        for key, value in list(nodes.items()):\n            if not value: continue\n            s = 0\n            for val in value:\n                if abs(key-val) > s:\n                    s = abs(key-val)\n            if s > maxDiff:\n                maxDiff = s\n                \n        return maxDiff\n        \n                \n                \n            \n            \n            \n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.ans = -1\n        \n        def solve(r: TreeNode, ancestors: List[int]):\n            if r is None:\n                return\n            \n            # print(f'{ancestors} {r.val}')\n            v = r.val\n            if len(ancestors) > 0:\n                tmp = max([abs(a - v) for a in ancestors])\n                self.ans = max(tmp, self.ans)\n                \n            ancestors.append(v)\n            solve(r.left, ancestors)\n            solve(r.right, ancestors)\n            ancestors.pop()\n        \n        solve(root, [])\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef calculateDifference(root,parent):\n    maxi = 0\n    for i in parent:\n        if abs(root.val-i) > maxi:\n            maxi = abs(root.val-i)\n    if root.left:\n        maxi = max(maxi,calculateDifference(root.left,parent+[root.val]))\n    if root.right:\n        maxi = max(maxi,calculateDifference(root.right,parent+[root.val]))\n        \n    return maxi\n\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        \n        \n        return calculateDifference(root,[])\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        def recAncestors(root, ancestors,dif):\n            left_dif=0\n            right_dif=0\n            for node in ancestors:\n                if dif<abs(root.val-node):\n                    dif=abs(root.val-node)\n            father=ancestors+[root.val]\n            if root.left:\n                left_dif=recAncestors(root.left,father,dif)\n            if root.right:\n                right_dif=recAncestors(root.right,father,dif)\n            return max(left_dif,right_dif,dif)        \n        nodes=[root.val]\n        right_wing, left_wing = 0,0\n        if root.right:\n            right_wing=recAncestors(root.right, nodes ,0)\n        if root.left:\n            left_wing=recAncestors(root.left,nodes,0)\n        return max(right_wing,left_wing)\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        # Walk the tree\n        \n        def recurse_func(node, parent_vals, best_answer):\n            # check if we can compute a better answer with this node\n            for x in parent_vals:\n                ans = abs(x - node.val)\n                if ans > best_answer:\n                    best_answer = ans\n            \n            # check our children\n            # there is some optimization that can occur here to prune entire branches if we detect the best answer is larger\n            # than the largest value we expect to find in the tree branch, but we would need to record whether we came down the left or right branch of the parent\n            parent_vals.append(node.val)\n            if node.left:\n                best_answer = recurse_func(node.left, parent_vals, best_answer)\n            if node.right:\n                best_answer = recurse_func(node.right, parent_vals, best_answer)\n            parent_vals.pop()\n            \n            # return best_answer\n            return best_answer\n    \n        return recurse_func(root, [], 0)\n    \n                    \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        \n        def traverse(root,anc,diff):\n            \n            if root:\n                for an in anc:\n                    if abs(root.val-an)>diff:\n                        diff=abs(root.val-an)                \n                \n                diff=traverse(root.left,anc+[root.val],diff)\n                diff=traverse(root.right,anc+[root.val],diff)\n     \n            return diff\n\n        return traverse(root,[],0)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        def maxDiff(root, ancestors):\n            if root is None:\n                return 0\n            \n            maxRightHere = 0\n            for ancestor in ancestors:\n                difference = abs(ancestor - root.val)\n                if difference > maxRightHere:\n                    maxRightHere = difference\n            \n            ancestors.append(root.val)\n            maxLeft = maxDiff(root.left, ancestors)\n            \n            maxRight = maxDiff(root.right, ancestors)\n            ancestors.pop()\n            \n            return max(maxRightHere, maxLeft, maxRight)\n        \n        return maxDiff(root, [])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nfrom dataclasses import dataclass\n\nMIN_VALUE = -2**31\nMAX_VALUE = 2**31\n\n\n@dataclass\nclass State:\n    min_: int\n    max_: int\n    val: int\n\n\ndef max_ancestor_diff(root: TreeNode) -> State:\n    if not root:\n        return State(MAX_VALUE, MIN_VALUE, 0)\n    \n    left = max_ancestor_diff(root.left)\n    right = max_ancestor_diff(root.right)\n    \n    min_ = min(left.min_, right.min_, root.val)\n    max_ = max(left.max_, right.max_, root.val)\n    val = max(left.val, right.val, max_ - root.val, root.val - min_)\n    return State(min_, max_, val)\n    \n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return max_ancestor_diff(root).val\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        maxDiff = 0\n        def dfs(node):\n            if not node:\n                return []\n            \n            vals = dfs(node.left)\n            vals.extend(dfs(node.right))\n            \n            nonlocal maxDiff\n            localMaxDiff = max([abs(v - node.val) for v in vals]) if vals else 0            \n            maxDiff = max(maxDiff, localMaxDiff)\n            vals.append(node.val)\n            return vals\n        \n        dfs(root)\n        return maxDiff\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        #DFS\n        stack = [(root, [])]\n        maxDiff = 0\n        while stack:\n            node, anc = stack.pop()\n            if anc:\n                maxDiff = max(maxDiff, \n                         max(abs(node.val - v) for v in anc))\n            if node.left:\n                stack.append((node.left, anc + [node.val]))\n            if node.right:\n                stack.append((node.right, anc + [node.val]))\n        return maxDiff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self,root,output,maxValue):\n        if(root is None):\n            return \n        for ele in output:\n            if(abs(root.val-ele)>maxValue[0]):\n                maxValue[0]=abs(root.val-ele)\n        # if(len(output)>1):\n        #     ele1=output[-1]\n        #     ele2=output[-2]\n        #     if(abs(root.val-ele1)>maxValue[0]):\n        #         maxValue[0]=abs(root.val-ele1)\n        #     if(abs(root.val-ele2)>maxValue[0]):\n        #         maxValue[0]=abs(root.val-ele2)\n        # elif(len(output)==1):\n        #     ele1=output[-1]\n            # if(abs(root.val-ele1)>maxValue[0]):\n            #     maxValue[0]=abs(root.val-ele1)\n        output.append(root.val)\n        self.helper(root.left,output,maxValue)\n        self.helper(root.right,output,maxValue)\n        output.pop()\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        maxValue=[0]\n        output=list()\n        self.helper(root,output,maxValue)\n        return maxValue[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(node, path):\n            if node.left == None and node.right == None: \n                res[0] = max(res[0], max([abs(j - node.val) for j in path]))\n                return \n            \n            else:\n                if len(path)>0:\n                    res[0] = max(res[0], max([abs(j - node.val) for j in path]))\n                \n                if node.left:\n                    dfs(node.left, path  + [node.val])\n                \n                if node.right: \n                    dfs(node.right, path + [node.val])\n                    \n                return \n                \n            \n            \n            \n    \n        res = [-1*float('infinity')]\n        \n        dfs(root, [])\n        \n        print(res)\n        \n        \n        return res[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.max_diff = -1\n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        def max_diff_calc(root):\n            if not root:\n                return []\n            ancestors = max_diff_calc(root.left)\n            ancestors.extend(max_diff_calc(root.right))\n            for ans in ancestors:\n                if abs(root.val - ans) > self.max_diff:\n                    self.max_diff = abs(root.val - ans)\n            ancestors.append(root.val)\n            return ancestors\n        \n        max_diff_calc(root)\n        return self.max_diff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        res = 0\n        if not root:\n            return \n        \n        def dfs(node, a):\n            nonlocal res          \n            tmp = max(abs(x-node.val) for x in a) if a else 0\n            res = max(res, tmp)\n            if node.left:\n                a.append(node.left.val)\n                dfs(node.left, a)#;print('111', node.left.val, a)\n                a.pop()\n            if node.right:\n                a.append(node.right.val)\n                dfs(node.right, a) #;print('222', node.right.val, a)\n                a.pop()\n            return\n        \n        dfs(root, [root.val])\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def tranverse(node, ansestors, res):\n          res = max(\n            res,\n            max([\n              abs(val - node.val)\n              for val in ansestors\n            ]) if ansestors else 0,\n          )\n          ansestors.append(node.val)\n          \n          if node.left:\n            res = tranverse(node.left, ansestors, res)\n          \n          if node.right:\n            res = tranverse(node.right, ansestors, res)\n          \n          ansestors.pop()\n          return res\n        \n        return tranverse(root, [], 0)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, root, path, ans):\n        if not root:\n            return\n        if path:\n            ans[0] = max(ans[0], max([abs(root.val-x) for x in path]))\n        path.append(root.val)\n        self.helper(root.left, path.copy(), ans)\n        self.helper(root.right, path.copy(), ans)\n\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        ans = [-float('inf')]\n        self.helper(root, [], ans)\n        return ans[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return(self.helper(root)[1])\n    \n    def helper(self,root,myMax=0):\n        myList = []\n        if root.left:\n            temp1,temp2 = self.helper(root.left)\n            myList.extend(temp1)\n            if temp2 > myMax:\n                myMax = temp2\n        if root.right:\n            temp1,temp2 = self.helper(root.right)\n            myList.extend(temp1)\n            if temp2 > myMax:\n                myMax = temp2\n        myList.append(root.val)\n        for i in range(len(myList)-1):\n            if abs(root.val - myList[i]) > myMax:\n                myMax = abs(root.val - myList[i])\n        return (myList,myMax)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    res = 0\n    \n    def dfs(self, root):\n        if not root:\n            return (0, 0)        \n        if not root.left and not root.right:\n            return (root.val, root.val)        \n        left_min = right_min = float('inf')\n        left_max = right_max = float('-inf')\n        if root.left:\n            left_min, left_max = self.dfs(root.left)        \n        if root.right:\n            right_min, right_max = self.dfs(root.right)\n        min_val = min(left_min, right_min)\n        max_val = max(left_max, right_max)        \n        self.res = max(self.res, abs(root.val - min_val), abs(root.val - max_val))\n        return (min(min_val, root.val), max(max_val, root.val))\n    \n    def maxAncestorDiff(self, root):\n        \\\"\\\"\\\"\n        :type root: TreeNode\n        :rtype: int\n        \\\"\\\"\\\"\n        self.dfs(root)        \n        return self.res\n    ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        best = {0:-1}\n        def maxmin(root,path):\n            if root == None:\n                return 200000\n            else:\n                best[0] = max(best[0],max([0]+[abs(root.val-val) for val in path]))\n                maxmin(root.left,path+[root.val])    \n                maxmin(root.right,path+[root.val])\n        maxmin(root,[])\n        return best[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        if not root or not root.left and not root.right:\n            return 0\n        self.max_val = 0\n        self.traverseWithAncestor(root, [])\n        \n        \n        return self.max_val\n    \n    def traverseWithAncestor(self, root, ancestors):\n\n        # base case\n        if not root:\n            return \n    \n        for v in ancestors:\n            if (res := abs(root.val-v)) > self.max_val:\n                self.max_val = res\n        \n        if not root.left and not root.right:\n            return\n        \n        newAncestors = list(ancestors)\n        newAncestors.append(root.val)\n        if root.left:\n            self.traverseWithAncestor(root.left, newAncestors)\n        if root.right:\n            self.traverseWithAncestor(root.right, newAncestors)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        if not root or not root.left and not root.right:\n            return 0\n        self.max_val = 0\n        self.traverseWithAncestor(root, [])\n        \n        \n        return self.max_val\n    \n    def traverseWithAncestor(self, root, ancestors):\n\n        # base case\n        if not root:\n            return \n    \n        for v in ancestors:\n            if (res := abs(root.val-v)) > self.max_val:\n                self.max_val = res\n        \n        if not root.left and not root.right:\n            return\n        \n        newAncestors = list(ancestors)\n        newAncestors.append(root.val)\n        self.traverseWithAncestor(root.left, newAncestors)\n        self.traverseWithAncestor(root.right, newAncestors)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # pairs = []\n    abs_max = -99999\n    \n    def construct_all_pairs(self, subtree):\n        if subtree is None:\n            return []\n        else:\n            lp = self.construct_all_pairs(subtree.left)\n            rp = self.construct_all_pairs(subtree.right)\n            for l in lp:\n                # self.pairs.append((subtree.val, l))\n                if abs(subtree.val - l) > self.abs_max:\n                    self.abs_max = abs(subtree.val - l)\n            for r in rp:\n                # self.pairs.append((subtree.val, r))\n                if abs(subtree.val - r) > self.abs_max:\n                    self.abs_max = abs(subtree.val - r)\n            return [subtree.val] + lp + rp\n        \n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.construct_all_pairs(root)\n        return self.abs_max\n        # print(self.pairs)\n        # return max(map(lambda x : abs(x[0]-x[1]) , self.pairs))\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    ans = 0\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def visit(root, ancs):\n            if root is None: return\n            if ancs:\n                self.ans = max(self.ans, max(abs(root.val - o) for o in ancs))\n            visit(root.left, ancs+[root.val])\n            visit(root.right, ancs+[root.val])\n            \n        visit(root, [])\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        def maxDiff(root: TreeNode, ancestors: List[int]) -> int:\n            if not root:\n                return 0\n            \n            left_max = maxDiff(root.left, ancestors + [root.val])\n            right_max = maxDiff(root.right, ancestors + [root.val])\n            diffs = [abs(ancestor - root.val) for ancestor in ancestors]\n            return max(diffs + [left_max, right_max])\n        \n        return maxDiff(root, [])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.mx = 0\n        def dfs(node, visited):\n            if node is None:\n                return\n            else:\n                for v in visited:\n                    if abs(v-node.val) > self.mx:\n                        self.mx = abs(v-node.val)\n            dfs(node.left, visited+[node.val])\n            dfs(node.right, visited+[node.val])\n            return\n        dfs(root, [])\n        return self.mx", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def dfs(self, root, ancestors):\n        if ancestors:\n            for anc in ancestors:\n                potential = abs(root.val - anc)\n                if potential > self.ans:\n                    self.ans = potential \n        \n        if root.left:\n            self.dfs(root.left, ancestors + [root.val])\n        if root.right:\n            self.dfs(root.right, ancestors + [root.val])\n    \n    \n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.ans = 0\n        self.dfs(root, [])\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.max_val = 0\n        \n        def traversal(root,parent):\n\n            if not root:\n                return\n            for i in parent:\n                \n                if self.max_val < abs(i-root.val):\n                    self.max_val = abs(i-root.val)\n            if root.left:\n                traversal(root.left,parent+[root.val])\n            if root.right:\n                traversal(root.right,parent+[root.val])\n            return\n        traversal(root,[]) \n        return self.max_val", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        self.max_d = 0\n        def get_distance_list(node, dist_list):\n            dist_list_new = []\n            if not (node.left or node.right):\n                return [0]\n            else:\n                if node.left:\n                    dist_list_l = get_distance_list(node.left, dist_list)\n                    diff_l = node.val - node.left.val\n                    dist_list_l = [d+diff_l for d in dist_list_l]\n                    dist_list_new += dist_list_l\n                    dist_list_new.append(diff_l)\n                if node.right:\n                    dist_list_r = get_distance_list(node.right, dist_list)\n                    diff_r = node.val - node.right.val\n                    dist_list_r = [d+diff_r for d in dist_list_r]\n                    dist_list_new += dist_list_r\n                    dist_list_new.append(diff_r)\n            for d in dist_list_new:\n                if abs(d)>self.max_d:\n                    self.max_d = abs(d)\n            return dist_list_new\n        \n        get_distance_list(root, [])\n        return self.max_d\n                \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        # Use DFS, and a max diff tracker.\n        # Each node has a min-max ancestor.\n        # Time: O(N), Space: O(log(N))\n        self.max_p_diff = 0\n        def max_diff(node, p_min, p_max):\n            if not node:\n                return\n            self.max_p_diff = max(self.max_p_diff, max(abs(node.val-p_min), abs(p_max-node.val)))\n            p_min = min(node.val, p_min)\n            p_max = max(node.val, p_max)\n            max_diff(node.left, p_min, p_max)\n            max_diff(node.right, p_min, p_max)\n        max_diff(root, root.val, root.val)\n        return self.max_p_diff\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def util(root, maxDiff):\n            if not root:\n                return [], maxDiff\n            lArr, maxDiff = util(root.left, maxDiff)\n            rArr, maxDiff = util(root.right, maxDiff)\n            \n            for node in lArr:\n                if abs(root.val - node.val) > maxDiff:\n                    maxDiff = abs(root.val - node.val)\n            for node in rArr:\n                if abs(root.val - node.val) > maxDiff:\n                    maxDiff = abs(root.val - node.val)\n            return [root] + lArr + rArr, maxDiff\n        arr, maxDiff = util(root, float('-inf'))\n        return maxDiff", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        \n        def dfs(root: TreeNode, ancestors_values) -> int:\n            \n            result = [-1]\n            this_ancestors_values = [root.val] + ancestors_values\n            \n            if root.left is not None:\n                max_ancestors_diff = max([abs(a - root.left.val) for a in this_ancestors_values])\n                left_result = dfs(root.left, this_ancestors_values)\n                left_result = max(left_result, max_ancestors_diff)\n                result.append(left_result)\n            if root.right is not None:\n                max_ancestors_diff = max([abs(a - root.right.val) for a in this_ancestors_values])\n                right_result = dfs(root.right, this_ancestors_values)\n                right_result = max(right_result, max_ancestors_diff)\n                result.append(right_result)\n            \n            return max(result)\n            \n        result = dfs(root, [])\n        return result\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        stack=[root]\n        parent={root:None}\n        while stack:\n            p=stack.pop()\n            if p.right:\n                stack.append(p.right)\n                parent[p.right]=p\n            if p.left:\n                stack.append(p.left)\n                parent[p.left]=p\n        \n        ans=0\n        for nodes in parent:\n            res=[]\n            while nodes:\n                res.append(nodes.val)\n                nodes=parent[nodes]\n            ans=max(ans,max(res)-min(res))\n        \n        return ans", "from typing import List\n\n\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n#     def __repr__(self):\n#         return str(self.val)\n\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return max_ancestor_diff(root, [])\n\n\ndef max_ancestor_diff(node: TreeNode, lineage: List[TreeNode]) -> int:\n    if node is None:\n        return 0\n\n    if lineage:\n        max_diff = max([abs(node.val - n.val) for n in lineage])\n    else:\n        max_diff = 0\n\n    if node.left is not None:\n        max_diff = max(max_diff, max_ancestor_diff(\n            node.left, lineage + [node]))\n\n    if node.right is not None:\n        max_diff = max(max_diff, max_ancestor_diff(\n            node.right, lineage + [node]))\n\n    return max_diff\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        deque = collections.deque([[root, []]])\n        result = 0\n        while deque:\n            node, anc = deque.popleft()\n            max_abs = 0 if not len(anc) else max(abs(node.val - a.val) for a in anc)\n            result = max(result, max_abs)\n            if node.left:\n                deque.append([node.left, anc + [node]])\n            if node.right:\n                deque.append([node.right, anc + [node]])\n        return result", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root:\n                vals.add(root.val)\n                dfs(root.left)\n                dfs(root.right)\n                \n        def dfs2(root, anss):\n            if root:\n                for a in anss:\n                    v = abs(a-root.val)\n                    if v in vals and v > self.ans:\n                        self.ans = v\n                dfs2(root.left, anss+[root.val])\n                dfs2(root.right, anss+[root.val])\n                \n        vals = set()\n        dfs(root)\n        self.ans = float(\\\"-inf\\\")\n        dfs2(root, [])\n        return self.ans\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        # Map each node with a list of its ancestors\n        # We can do that by iterating with DFS and path\n        \n        q = [(root, [])]\n        \n        from collections import defaultdict\n        \n        anc = {}\n        \n        while q: \n            cur, path = q.pop(0)\n            \n            \n            anc[cur.val] = path\n            \n            path.append(cur.val)\n            \n            if cur.left: \n                q.append((cur.left, path[:]))\n            \n            if cur.right: \n                q.append((cur.right, path[:]))\n                \n        \n        max_diff = float('-inf')\n        \n        for n, ancs in list(anc.items()):\n            for a in ancs: \n                max_diff = max(max_diff, abs(a - n))\n                \n        \n        return max_diff\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        # Map each node with a list of its ancestors\n        # We can do that by iterating with DFS and path\n        \n        q = [(root, [])]\n        \n        from collections import defaultdict\n        \n        anc = {}\n        \n        while q: \n            cur, path = q.pop(0)\n            \n            \n            anc[cur.val] = path[:]\n            \n            path.append(cur.val)\n            \n            if cur.left: \n                q.append((cur.left, path[:]))\n            \n            if cur.right: \n                q.append((cur.right, path[:]))\n                \n        \n        max_diff = float('-inf')\n        \n        for n, ancs in list(anc.items()):\n            for a in ancs: \n                max_diff = max(max_diff, abs(a - n))\n                \n        \n        return max_diff\n", "from typing import List\nfrom functools import lru_cache\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return str(self.val)\n\n\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return max_ancestor_diff(root, [])\n\n\n@lru_cache\ndef get_max_lineage_diff(node: TreeNode, lineage) -> int:\n    if lineage:\n        return max([abs(node.val - n.val) for n in lineage])\n    else:\n        return 0\n\n\ndef max_ancestor_diff(node: TreeNode, lineage: List[TreeNode]) -> int:\n    if node is None:\n        return 0\n\n    max_diff = get_max_lineage_diff(node, frozenset(lineage))\n\n    if node.left is not None:\n        max_diff = max(max_diff, max_ancestor_diff(\n            node.left, lineage + [node]))\n\n    if node.right is not None:\n        max_diff = max(max_diff, max_ancestor_diff(\n            node.right, lineage + [node]))\n\n    return max_diff\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        return self.maxAncestorDiffHelper(root, [], 0)\n    \n    def maxAncestorDiffHelper(self, root: TreeNode, ancestors, maxV: int) -> int:\n        if root is None:\n            return 0\n        for a in ancestors:\n            maxV = max(maxV, abs(a-root.val))\n        ancestors.append(root.val)\n        maxV = max(\n            maxV,\n            self.maxAncestorDiffHelper(root.left, ancestors, maxV),\n            self.maxAncestorDiffHelper(root.right, ancestors, maxV)\n        )\n        ancestors.pop()\n        return maxV\n    \n    #TODO should be able to make this faster\n"]
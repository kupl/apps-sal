["def next_smaller(n):\n    s = list(str(n))\n    i = j = len(s) - 1\n    while i > 0 and s[i - 1] <= s[i]: i -= 1\n    if i <= 0: return -1\n    while s[j] >= s[i - 1]: j -= 1\n    s[i - 1], s[j] = s[j], s[i - 1]\n    s[i:] = reversed(s[i:])\n    if s[0] == '0': return -1\n    return int(''.join(s))", "def next_smaller(n):\n    \n    ## Create a list of each digit in n\n    numbers = [int(i) for i in str(n)]\n\n    ## Loop over each digit in the numbers list, from right to left\n    for i in range(len(numbers) - 1, 0, -1):\n    \n        ## If a number is less than the number to its left, split into 2 lists\n        if numbers[i] < numbers[i -1]:\n            rearrange_list = numbers[i - 1:]  ## numbers on the right of i -1\n            original_list = numbers[:i - 1]   ## numbers on the left of i -1\n            less_than_values = []             ## will contain possible substitutions for i -1\n            \n            ## Loop over the rearrange_list\n            for i in rearrange_list:\n            \n                ## if the number is smaller than i, append it to less_than_values\n                if i < rearrange_list[0]:\n                    less_than_values.append(i)\n    \n            ## Add the max value from less_than_values to the end of the original_list, \n            ## then add the rest of the sorted values from rearrange_list to the original_list\n            original_list.append(max(less_than_values))\n            rearrange_list.remove(max(less_than_values))\n            original_list += sorted(rearrange_list, reverse=True)\n            \n            ## Join the list together to get the output\n            output = int(''.join([str(num) for num in original_list]))\n\n            ## If the output starts with 0, return -1. Otherwise, return the ouput.\n            if len(str(output)) < len(str(n)):\n                return -1\n            else:\n                return output\n    \n    ## Return -1 if n is None, or if there are no smaller numbers\n    return -1            \n", "def swap(s, a, b):\n    s = list(s)\n    s[a], s[b] = s[b], s[a]\n    return ''.join(s)\n    \ndef maximized_range(s, left): # Maximize value in range [left, end]\n    return s[:left] + ''.join(sorted(s[left:], reverse=True))\n\ndef next_smaller(n):\n    s = str(n)\n    k = len(s)\n    for i in range(k-1, -1, -1):\n        for j in range(k-1, i, -1):\n            if s[j] < s[i]:\n                t = swap(s, i, j)\n                if t[0] != '0':\n                    return int(maximized_range(t, i+1))\n    return -1", "from operator import itemgetter\n\ndef next_smaller(n):\n    s        = str(n)\n    LR_Pairs = list(enumerate(zip(s,s[1:])))                                                    # Association pair (l,r) and index of left char of the pair\n    iP,pivot = next( ((i,l) for i,(l,r) in reversed(LR_Pairs) if l>r), (-1,-1) )                # Extract first increasing pair, coming from the end,...\n                                                                                                # ... then get the left char (pivot) and it's index\n    if iP == -1: return -1                                                                      # No smaller number...\n    \n    iM,mx = max( ((i,c) for i,c in enumerate(s[iP+1:],iP+1) if c < pivot), key=itemgetter(1))   # Highest char smaller than 'pivot' and its index\n    nextS = s[:iP] + mx + ''.join(sorted(s[iP:iM]+s[iM+1:], reverse=True))                      # Move 'mx' in place of 'pivot', then sort all the remaining chars, descending\n    \n    return int(nextS) if nextS[0] != '0' else -1", "#\u5148\u786e\u5b9a\u8981\u6539\u53d8\u7684\u8303\u56f4\uff0c\u7136\u540e\u5728\u5bf9\u6307\u5b9a\u8303\u56f4\u8fdb\u884c\u6539\u52a8\n#itertools\u662f\u5f88\u597d\u7528\u7684\u5305\uff0c\u6ce8\u610f\u5b66\u4e60\nimport itertools\ndef next_smaller(n):\n    print(n)\n    a=list(str(n))\n    b=len(a)\n    if b==1:\n        return -1\n    for j in range(b-2,-1,-1):\n        if a[j] > a[j+1]:         \n            t=a[j:]\n            m=max([x for x in t if x<t[0]])\n            t.remove(m)\n            c=[]\n            while len(t)>0:\n                d=max(t)\n                c.append(d)\n                t.remove(d)\n            a[j:]=[m]+c\n            if a[0]=='0':\n                return -1\n            return int(''.join(a))\n    return -1\n", "def next_smaller(n):\n    nums = list(map(int, list(str(n))))\n    seen = []\n    for i in reversed(range(1, len(nums))):\n        if nums[i - 1] > nums[i]:\n            seen.append(nums[i])\n            seen.append(nums[i-1])\n            seen = sorted(seen, reverse=True)\n            for j in range(len(seen)):\n                if seen[j] < nums[i-1]:\n                    winner = seen.pop(j)\n                    break\n            if winner == 0 and i == 1:\n                return -1\n\n            nums = nums[:i-1]\n            nums.append(winner)\n            nums.extend(seen)\n            return int(''.join(map(str, nums)))\n        else:\n            seen.append(nums[i])\n\n    return -1", "def f(s):\n    if ''.join(sorted(s)) == s:\n        return ''\n    ss = s[1:]\n    if ''.join(sorted(ss)) == ss:\n        xs = sorted(s, reverse=True)\n        next_1st_digit = max(x for x in set(xs) if x < s[0])\n        xs.remove(next_1st_digit)\n        return next_1st_digit + ''.join(sorted(xs, reverse=True))\n    return s[0] + str(f(ss))\n    \ndef next_smaller(n):\n    s = f(str(n))\n    return int(s) if s and not s.startswith('0') else -1", "def next_smaller(n):\n    s = str(n)\n    i = next((i for i in range(len(s)-1,0,-1) if s[i-1]>s[i]),len(s))\n    j = next((j for j in range(len(s)-1,i-1,-1) if s[i-1]>s[j]),-1)\n    s = s[:i-1]+s[j]+(s[i:j]+s[i-1]+s[j+1:])[::-1]\n    return [int(s),-1][s[0]=='0' or j<0]\n", "def next_smaller(n):\n    num = list(str(n))\n\n    try:\n        pivot = next(i for i in reversed(range(len(num) - 1)) if num[i] > num[i + 1])\n    except StopIteration:\n        return -1\n    swap  = next(i for i in reversed(range(len(num))) if num[pivot] > num[i])\n\n    num[pivot], num[swap] = num[swap], num[pivot]\n    num[pivot + 1:] = reversed(num[pivot + 1:])\n\n    if num[0] == '0':\n        return -1\n\n    return int(''.join(num))", "def next_smaller(n):\n    list_number = list(map(lambda x: int(x), str(n)))\n\n    center = None\n\n    for i in range(len(list_number) - 1, 0, -1):\n        if list_number[i] < list_number[i-1]:\n            center = list_number[i-1]\n            left = list_number[:i-1]\n            right = list_number[i:len(list_number)]\n            break\n\n    if center is None:\n        return -1\n    else:\n        right.sort(reverse=True)\n        for i in right:\n            if i < center:\n                right.append(center)\n                center = i\n                right.remove(i)\n                right.sort(reverse=True)\n                left.append(center)\n                left.extend(right)\n                if left[0] == 0:\n                    return -1\n                return int(''.join(str(n) for n in left))"]
["N, a, b = list(map(int, input().split())); a -= 1; b -= 1\nP = []\nQ = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    P.append((x-y, x+y, i))\n    Q.append((x+y, x-y, i))\n\nd = max(abs(P[a][0] - P[b][0]), abs(P[a][1] - P[b][1]))\n\n*parent, = list(range(N))\ndef root(x):\n    if x == parent[x]:\n        return x\n    y = parent[x] = root(parent[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nC = [0]*N\nD = [0]*N\n\ndef check(P0, i0, j0):\n    return abs(P0[i0][0] - P0[j0][0]) == abs(P0[i0][1] - P0[j0][1])\n\ndef solve(P0):\n    P = P0[:]\n    P.sort()\n\n    s = t = 0; prev = -1\n    for i in range(N):\n        x, y, i0 = P[i]\n        while t < N and P[t][0] < x-d or (P[t][0] == x-d and P[t][1] <= y+d): t += 1\n        while s < N and (P[s][0] < x-d or (P[s][0] == x-d and P[s][1] < y-d)): s += 1\n        if s < t:\n            j0 = P[s][2]\n            unite(i0, j0)\n            if check(P0, i0, j0):\n                D[i0] += 1\n            else:\n                C[i0] += 1\n            if s < t-1:\n                j0 = P[t-1][2]\n                if check(P0, i0, j0):\n                    D[i0] += 1\n                    C[i0] += t-s-2\n                else:\n                    C[i0] += t-s-1\n            for j in range(max(prev, s), t-1):\n                unite(P[j][2], P[j+1][2])\n            prev = t-1\nsolve(P)\nsolve(Q)\n\nS = T = 0\nr = root(a)\nfor i in range(N):\n    if root(i) == r:\n        S += C[i]; T += D[i]\nprint((S + T//2))\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nimport bisect\n\nINF = 10 ** 12\n\nN,a,b = map(int,input().split())\nX_to_Y = defaultdict(lambda: [-INF,INF])\nY_to_X = defaultdict(lambda: [-INF,INF])\nfor i in range(1,N+1):\n    x,y = map(int,input().split())\n    x,y = x+y,x-y\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n    if i == a:\n        sx,sy = x,y\n    elif i == b:\n        tx,ty = x,y\n\nR = max(abs(sx-tx), abs(sy-ty))\n\nfor key, arr in X_to_Y.items():\n    arr.sort()\n    L = len(arr)\n    move_right = list(range(1,L)) + [None]\n    X_to_Y[key] = [arr,move_right]\n    \nfor key, arr in Y_to_X.items():\n    arr.sort()\n    L = len(arr)\n    move_right = list(range(1,L)) + [None]\n    Y_to_X[key] = [arr,move_right]\n\nequiv_class = set([(sx,sy), (tx,ty)])\n\nanswer = 0\ntask = [(sx,sy), (tx,ty)]\n\nwhile task:\n    x,y = task.pop()\n    # \u65e2\u51fa\u306e\u5143\u3082\u542b\u3081\u3066\u8fba\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    # \u672a\u51fa\u306e\u5143\u3092\u540c\u5024\u306b\u8ffd\u52a0\n    # x,y\u4e21\u65b9\u6e80\u305f\u3059\u3082\u306e\u306f\u3001x\u5074\u306b\u3060\u3051\u5165\u308c\u308b\n    for x1 in [x-R,x+R]:\n        if not (x1 in X_to_Y):\n            continue\n        arr, move_right = X_to_Y[x1]\n        left = bisect.bisect_left(arr, y-R)\n        right = bisect.bisect_right(arr, y+R)\n        # [left, right) \u304c\u8fba\u3067\u7d50\u3079\u308b\u30bf\u30fc\u30b2\u30c3\u30c8\n        answer += right - left # \u8fba\u306e\u500b\u6570\n        i = left\n        while i < right:\n            y1 = arr[i]\n            if (x1,y1) not in equiv_class:\n                equiv_class.add((x1,y1))\n                task.append((x1,y1))\n            # \u306a\u308b\u3079\u304f\u3001\u65e2\u306b\u5c45\u306a\u3044\u5143\u306f\u898b\u306a\u3044\u3067\u6e08\u307e\u305b\u308b\u3088\u3046\u306b\n            next_i = move_right[i]\n            if next_i >= right:\n                break\n            move_right[i] = right\n            i = next_i\n    for y1 in [y-R,y+R]:\n        if not y1 in Y_to_X:\n            continue\n        arr, move_right = Y_to_X[y1]\n        left = bisect.bisect_left(arr, x-R+1)\n        right = bisect.bisect_right(arr, x+R-1)\n        # [left, right) \u304c\u8fba\u3067\u7d50\u3079\u308b\u30bf\u30fc\u30b2\u30c3\u30c8\n        answer += right - left # \u8fba\u306e\u500b\u6570\n        i = left\n        while i < right:\n            x1 = arr[i]\n            if (x1,y1) not in equiv_class:\n                equiv_class.add((x1,y1))\n                task.append((x1,y1))\n            # \u306a\u308b\u3079\u304f\u3001\u65e2\u306b\u5c45\u306a\u3044\u5143\u306f\u898b\u306a\u3044\u3067\u6e08\u307e\u305b\u308b\u3088\u3046\u306b\n            next_i = move_right[i]\n            if next_i >= right:\n                break\n            move_right[i] = right\n            i = next_i\n\nanswer //= 2 # \u4e21\u65b9\u5411\u304b\u3089\u8fba\u3092\u898b\u305f\nprint(answer)"]
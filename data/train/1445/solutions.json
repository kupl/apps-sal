["t= int(input())\nfor _ in range(t):\n n = int(input())\n ar = []\n y = []\n for i in range(n):\n  ar.append( list(map(int,input().split())) )\n  y.append(ar[-1][1])\n  ar[-1].append(i)\n \n y.sort()\n mny = y[0]\n mxy = y[-1]\n ar.sort()\n ssx,ssy,ssi = ar[0]\n bbx,bby,bbi = ar[-1]\n \n sbx,sby,sbi = ar[0]\n bsx,bsy,bsi = ar[-1]\n \n for i in range(len(ar)):\n  if ar[i][0]>ssx:\n   sbx,sby,sbi = ar[i-1]\n   break\n \n for i in range(len(ar)-1,-1,-1):\n  if ar[i][0]<bsx:\n   bsx,bsy,bsi = ar[i+1]\n   break \n \n if (ssy <=mny):\n  print(1)\n  print(ssi+1,'NE')\n  continue\n if (sby>=mxy):\n  print(1)\n  print(sbi+1,'SE')\n  continue\n if (bsy <=mny):\n  print(1)\n  print(bsi+1,'NW')\n  continue\n if (bby>=mxy):\n  print(1)\n  print(bbi+1,'SW')\n  continue \n \n print(2)\n if(ssy<bby):\n  print(ssi+1,'NE')\n  print(bbi+1,'SW')\n else:\n  print(ssi+1,'SE')\n  print(bbi+1,'NW')\n \n", "for cas in range(eval(input())):\n n = eval(input())\n pts = []\n for i in range(n):\n  x, y = list(map(int, input().strip().split()))\n  pts.append((x, y))\n\n minx = min(x for x, y in pts)\n maxx = max(x for x, y in pts)\n miny = min(y for x, y in pts)\n maxy = max(y for x, y in pts)\n\n for i in range(n):\n  if pts[i] == (minx, miny):\n   print(\"1\\n%d NE\" % (i+1))\n   break\n  if pts[i] == (minx, maxy):\n   print(\"1\\n%d SE\" % (i+1))\n   break\n  if pts[i] == (maxx, miny):\n   print(\"1\\n%d NW\" % (i+1))\n   break\n  if pts[i] == (maxx, maxy):\n   print(\"1\\n%d SW\" % (i+1))\n   break\n else:\n  mini = min(list(range(n)), key=lambda i: pts[i]) #vvi: finding \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minium in set of 0 to n-1 based comparison of key which takes pts[i] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0through lambda\n  maxi = max(list(range(n)), key=lambda i: pts[i])\n  \n  if pts[mini][1] < pts[maxi][1]:\n   print(\"2\\n%d NE\\n%d SW\" % (mini+1, maxi+1))\n  else:\n   print(\"2\\n%d SE\\n%d NW\" % (mini+1, maxi+1))\n", "for cas in range(eval(input())):\n n = eval(input())\n pts = []\n for i in range(n):\n  x, y = list(map(int, input().strip().split()))\n  pts.append((x, y))\n\n minx = min(x for x, y in pts)\n maxx = max(x for x, y in pts)\n miny = min(y for x, y in pts)\n maxy = max(y for x, y in pts)\n\n for i in range(n):\n  if pts[i] == (minx, miny):\n   print(\"1\\n%d NE\" % (i+1))\n   break\n  if pts[i] == (minx, maxy):\n   print(\"1\\n%d SE\" % (i+1))\n   break\n  if pts[i] == (maxx, miny):\n   print(\"1\\n%d NW\" % (i+1))\n   break\n  if pts[i] == (maxx, maxy):\n   print(\"1\\n%d SW\" % (i+1))\n   break\n else:\n  mini = min(range(n), key=lambda i: pts[i])\n  maxi = max(range(n), key=lambda i: pts[i])\n\n  if pts[mini][1] < pts[maxi][1]:\n   print(\"2\\n%d NE\\n%d SW\" % (mini+1, maxi+1))\n  else:\n   print(\"2\\n%d SE\\n%d NW\" % (mini+1, maxi+1))", "class island:\n 'number, x, y' \n def __init__(self, x,y, number):\n  self.x = x\n  self.y = y\n  self.number = number\n\ndef onelighthouseenough(islands, leftbottom):\n bottomleft = min(islands, key = lambda a : (a.y, a.x))\n\n if(leftbottom == bottomleft):\n  print(1)\n  print(leftbottom.number, end=' ')\n  print(' NE')\n  return True\n\n rightbottom = min(islands, key = lambda a : (-a.x, a.y))\n bottomright = min(islands, key = lambda a : (a.y, -a.x))\n\n if(rightbottom == bottomright):\n  print(1)\n  print(rightbottom.number, end=' ')\n  print(' NW')\n  return True\n\n lefttop = min(islands, key = lambda a : (a.x, -a.y))\n topleft = min(islands, key = lambda a : (-a.y, a.x))\n\n if(lefttop == topleft):\n  print(1)\n  print(lefttop.number, end=' ')\n  print(' SE')\n  return True\n\n righttop = min(islands, key = lambda a : (-a.x, -a.y))\n topright = min(islands, key = lambda a : (-a.y, -a.x))\n\n if(righttop == topright):\n  print(1)\n  print(righttop.number, end=' ')\n  print(' SW')\n  return True\n return False\n\ndef lighthouses(islands):\n leftbottom = min(islands, key = lambda a : (a.x, a.y))\n if(onelighthouseenough(islands, leftbottom)):\n  return\n\n islands.remove(leftbottom)\n nextleft = min(islands, key = lambda a : a.x)\n\n if(leftbottom.y < nextleft.y):\n  print(2)\n  print(leftbottom.number, end=' ')\n  print(' NE')\n  print(nextleft.number, end=' ')\n  print(' SE')\n else:\n  print(2)\n  print(leftbottom.number, end=' ')\n  print(' SE')\n  print(nextleft.number, end=' ')\n  print(' NE')\n\n\nT = int(input())\n\nfor i in range(T):\n N = int(input())\n islands = []\n for j in range(N):\n  x, y = list(map(int, input().split()))\n  islands.append(island(x,y, j+1))\n lighthouses(islands)\n \n", "class island:\n 'number, x, y' \n def __init__(self,x,y,number):\n  self.x = x\n  self.y = y\n  self.number = number\n\ndef lighthouses(islands):\n low = high = left = right = islands[0]\n\n left = min(islands, key = lambda a : a.x)\n right= max(islands, key = lambda a : a.x)\n low = min(islands, key = lambda a : a.y)\n high = max(islands, key = lambda a : a.y)\n\n if left == low:\n  print(1)\n  print(str(left.number) + ' NE')\n elif left == high:\n  print(1)\n  print(str(left.number) + ' SE')\n elif right == low:\n  print(1)\n  print(str(right.number) + ' NW')\n elif right == high:\n  print(1)\n  print(str(right.number) + ' SW')\n else:\n  islands.remove(left)\n  nextleft = min(islands, key = lambda a : a.x)\n   \n  if left.y < nextleft.y:\n   print(2)\n   print(str(left.number) + ' NE')\n   print(str(nextleft.number) + ' SE')\n  else:\n   print(2)\n   print(str(left.number) + ' SE')\n   print(str(nextleft.number) + ' NE')\n\n\nT = int(input())\nfor i in range(T):\n N = int(input())\n islands = []\n for j in range(N):\n  x, y = list(map(int, input().split()))\n  islands.append(island(x,y,j+1))\n lighthouses(islands)\n", "class island:\n 'number, x, y' \n def __init__(self,x,y,number):\n  self.x = x\n  self.y = y\n  self.number = number\n\ndef lighthouses(islands):\n low = high = left = right = islands[0]\n\n left = min(islands, key = lambda a : a.x)\n right= max(islands, key = lambda a : a.x)\n low = min(islands, key = lambda a : a.y)\n high = max(islands, key = lambda a : a.y)\n\n if left == low:\n  print(1)\n  print(str(left.number) + ' NE')\n elif left == high:\n  print(1)\n  print(str(left.number) + ' SE')\n elif right == low:\n  print(1)\n  print(str(right.number) + ' NW')\n elif right == high:\n  print(1)\n  print(str(right.number) + ' SW')\n else:\n  islands.remove(left)\n  nextleft = min(islands, key = lambda a : a.x)\n   \n  if left.y < nextleft.y:\n   print(2)\n   print(str(left.number) + ' NE')\n   print(str(nextleft.number) + ' SE')\n  else:\n   print(2)\n   print(str(left.number) + ' SE')\n   print(str(nextleft.number) + ' NE')\n\n\nT = int(input())\nfor i in range(T):\n N = int(input())\n islands = []\n for j in range(N):\n  x, y = list(map(int, input().split()))\n  islands.append(island(x,y,j+1))\n lighthouses(islands)\n", "t=int(input())\n\nans=[]\nwhile(t):\n X=[];\n Y=[];\n XY=[]\n \n t-=1;\n n=int(input());\n st='';\n for i in range(1,n+1):\n  xi,yi=list(map(int,input().split()));\n  X.append(xi);\n  Y.append(yi);\n  XY.append((xi,yi));\n lborder=X.index(min(X));\n rborder=X.index(max(X));\n tborder=Y.index(max(Y));\n bborder=Y.index(min(Y));\n if((X[lborder],Y[tborder])in XY):\n  st='1\\n'+str(XY.index((X[lborder],Y[tborder]))+1)+' SE';\n elif((X[lborder],Y[bborder])in XY):\n  st='1\\n'+str(XY.index((X[lborder],Y[bborder]))+1)+' NE';\n elif((X[rborder],Y[tborder])in XY):\n   st='1\\n'+str(XY.index((X[rborder],Y[tborder]))+1)+' SW';\n elif((X[rborder],Y[bborder])in XY):\n   st='1\\n'+str(XY.index((X[rborder],Y[bborder]))+1)+' NW';\n elif((rborder==lborder)):\n   st='1\\n'+str(tborder+1)+' SE';\n elif(tborder==bborder):\n   st='1\\n'+str(lborder+1)+' NE';\n else:\n   if(Y[lborder]>=Y[rborder]):\n    st='2\\n'+str(lborder+1)+' SE\\n'+str(rborder+1)+' NW';\n   else:\n    st='2\\n'+str(lborder+1)+' NE\\n'+str(rborder+1)+' SW';\n\n\n ans.append(st);\nfor x in ans:\n print(x)\n"]
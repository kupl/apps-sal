["class Solution:\n \n     def findFrequentTreeSum(self, root):\n         self.sums = []\n         if not root:\n             return []\n         self.traverse(root)\n         res = collections.Counter(self.sums)\n         frequent = max(res.values())\n         return [x for x in res if res[x] == frequent]\n \n \n     def traverse(self, root):\n         if not root:\n             return 0\n         \n         self_sum = root.val + self.traverse(root.left) + self.traverse(root.right)\n \n         self.sums.append(self_sum)\n         return self_sum\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root == None: return []\n         m = collections.defaultdict(int)\n         self.helper(root, m)\n         max_value = max(m.values())\n         res = []\n         for v in m.keys():\n             if m.get(v) == max_value:\n                 res.append(v)\n         return res\n         \n     def helper(self, node, m):\n         if not node:\n             return 0\n         left, right = self.helper(node.left, m), self.helper(node.right, m)\n         m[node.val+left+right]+=1\n         return node.val + left + right", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n from collections import defaultdict\n \n class Solution:\n   def findFrequentTreeSum(self, root):\n     \"\"\"\n     :type root: TreeNode\n     :rtype: List[int]\n     \"\"\"\n     def get_sum(node):\n       if node == None:\n         return 0\n       sum = node.val + get_sum(node.left) + get_sum(node.right)\n       sum_freq[sum] += 1\n       return sum\n \n     # Calculate sum for all subtrees and save them in dict `sum_freq`\n     sum_freq = defaultdict(lambda: 0)\n     get_sum(root)\n     if not sum_freq:\n       return []\n     # Filter sums by the highest frequency\n     max_freq = max(sum_freq.values())\n     return [sum for (sum, freq) in sum_freq.items() if freq == max_freq]\n \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root == None: return []\n         m = collections.defaultdict(int)\n         self.helper(root, m)\n         max_value = max(m.values())\n         res = []\n         for v in m.keys():\n             if m[v] == max_value:\n                 res.append(v)\n         return res\n         \n     def helper(self, node, m):\n         if not node:\n             return 0\n         left, right = self.helper(node.left, m), self.helper(node.right, m)\n         m[node.val+left+right]+=1\n         return node.val + left + right", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n from collections import defaultdict\n \n class Solution:\n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return []\n         self.convert_tree(root)\n         self.counter = defaultdict(int)\n         self.dfs(root)\n         \n         max_ct = max(self.counter.values())\n         return [k for k, ct in self.counter.items() if ct == max_ct]\n \n     def convert_tree(self, node):\n         \"\"\"\n         Convert each node's 'val' into it's subtree sum\n         \"\"\"\n         if not node:\n             return\n         \n         if node.left:\n             self.convert_tree(node.left)\n             node.val += node.left.val\n         if node.right:\n             self.convert_tree(node.right)\n             node.val += node.right.val\n     \n     def dfs(self, node):\n         if node:\n             self.counter[node.val] += 1\n             self.dfs(node.left)\n             self.dfs(node.right)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         res = dict()\n         def helper(root):\n             if not root:\n                 return 0\n             val = root.val + helper(root.left) + helper(root.right)\n             if val in res:\n                 res[val] += 1\n             else:\n                 res[val] = 1\n             return val\n             \n         helper(root)\n         if not res:\n             return []\n         \n         max_val = max(res.values())\n         return [k for k, v in res.items() if v == max_val]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root: return []\n         D = dict()\n         def AccuTree(root):\n             if not root: return 0\n             leftA = AccuTree(root.left)\n             rightA = AccuTree(root.right)\n             Accu = leftA + rightA + root.val\n             if D.get(Accu): D[Accu] += 1\n             else: D[Accu] = 1\n             return Accu\n         AccuTree(root)\n         maxVal = max(D.values())\n         return [x for x in D.keys() if D[x] == maxVal]", "from collections import defaultdict\n # Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     \"\"\"\n     :type root: TreeNode\n     :rtype: map{sum:int : frequency:int} \n     \"\"\"\n     def __init__(self):\n         self._iter = 0\n     def getAllSums(self, root):\n         if not root:\n             return defaultdict(int), 0\n         all_sums, left_sum = self.getAllSums(root.left)\n         all_right_sums, right_sum = self.getAllSums(root.right)    \n         # mege both maps\n         for key,val in all_right_sums.items():\n             all_sums[key] += val\n         cur_sum = right_sum + root.val + left_sum\n         all_sums[cur_sum] += 1\n         return all_sums, cur_sum\n         \n     def findFrequentTreeSum(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         all_sums,_ = self.getAllSums(root)\n         result = []\n         max_occurence = 0\n         for key,val in all_sums.items():\n             max_occurence = max(max_occurence,val)\n         for key,val in all_sums.items():\n             if val == max_occurence:\n                 result.append(key)\n         return result\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n   def findFrequentTreeSum(self, root):\n     from collections import defaultdict\n     f = defaultdict(int)    \n     def treeSum(root):\n       if not root: return 0\n       s = root.val + treeSum(root.left) + treeSum(root.right)\n       f[s] += 1   \n       return s\n     treeSum(root)\n     ans = []\n     if not f: return ans    \n     max_freq = max(f.values())    \n     for s in f:\n       if f[s] == max_freq: \n         ans.append(s)\n     return ans\n     \n         "]
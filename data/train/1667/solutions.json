["unflatten=lambda m,d,c=0:m if c==d else unflatten(parse(m,[0,1][c&1]),d,c+1)\n\ndef parse(ar, lr):\n      sub, i = [], [0, len(ar) - 1][lr]\n      while 0 <= i < len(ar):\n          j, r = ar[i], lr == 1\n          if isinstance(j, list):\n              sub.append(parse(j, lr))\n              i += [1, -1][r]\n          else:\n              mod = j % len([ar[i:],ar[:i + 1]][r])\n              sub.append([j, ar[i:i + (mod * [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod>=3])\n              i += [mod,1][mod<3] * [1,-1][r]\n      return sub[::[1, -1][lr]]", "def unflatten(arr, depth, isLeft=1):\n    lst,it =  [], enumerate(arr if isLeft else reversed(arr))\n    for i,x in it:\n        if isinstance(x,list):\n            lst.append( unflatten(x,1,isLeft) )\n            continue\n            \n        n = x % (len(arr)-i)\n        if n < 3:\n            lst.append(x)\n        else:\n            gna = [x] + [next(it)[1] for _ in range(n-1)]\n            lst.append(gna if isLeft else gna[::-1])\n            \n    if not isLeft: lst = lst[::-1]\n    \n    return lst if depth==1 else unflatten(lst, depth-1, isLeft^1)", "import enum\n\n\nclass IterDirection(enum.Enum):\n    \"\"\" Direction in which we iterate/walk. \"\"\"\n    TowardsRight = 1,\n    TowardsLeft = 2\n\n\ndef unflatten(arr, depth):\n\n    def is_iterable(obj):\n        try:\n            iter(obj)\n        except TypeError:\n            return False\n        else:\n            return True\n\n    def walk(arr, direction):\n        if direction == IterDirection.TowardsLeft:\n            a = arr[::-1]\n        else:\n            a = list(arr)\n        index = 0\n\n        def walk_subarray(subarray):\n            if direction == IterDirection.TowardsRight:\n                yield list(walk(current_element, direction))\n            else:\n                yield list(walk(current_element, direction))[::-1]\n\n        while index < len(a):\n            current_element = a[index]\n            if is_iterable(current_element):\n                yield from walk_subarray(current_element)\n                index += 1\n            else:\n                n_elements_left = len(arr[index:])\n                remainder = current_element % n_elements_left\n\n                if remainder < 3:\n                    yield current_element\n                    index += 1\n                else:\n                    if direction == IterDirection.TowardsLeft:\n                        yield a[index: index + remainder][::-1]\n                    else:\n                        yield a[index: index + remainder]\n                    index += remainder\n\n    from itertools import cycle, islice\n    directions = (IterDirection.TowardsRight, IterDirection.TowardsLeft)\n\n    arr_copy = list(arr)\n\n    for direction in (islice(cycle(directions), depth)):\n        if direction == IterDirection.TowardsLeft:\n            arr_copy = list(walk(arr_copy, IterDirection.TowardsLeft))[::-1]\n        else:\n            arr_copy = list(walk(arr_copy, IterDirection.TowardsRight))\n    return arr_copy\n", "def unflatten(flat_array, depth, direction = 1):\n    if depth == 0:\n        return flat_array\n    ind = 0\n    array = []\n    flat_array = flat_array[::direction]\n    while ind < len(flat_array):\n        nleft = len(flat_array) - ind\n        elem = flat_array[ind]\n        if type(flat_array[ind]) is list:\n            array.append(unflatten(flat_array[ind], 1, direction))\n            ind += 1\n        elif elem % nleft < 3:\n            array.append(elem)\n            ind += 1\n        else:\n            array.append(flat_array[ind:ind + elem % nleft][::direction])\n            ind += elem % nleft\n    return unflatten(array[::direction], depth-1, -direction)", "def unflatten(flat_array, depth):\n    left = True\n    i = 0\n    new_array = flat_array\n\n    for d in range(depth):\n        new_array = unflatten_list(new_array, left, i)\n        left = not left\n        if left:\n            i = 0\n        else:\n            i = len(new_array) - 1\n    return new_array\n        \n#true = left, false = right\ndef unflatten_list(array, direction, i):\n    new_list = []\n    while (direction == True and i < len(array)) or (direction == False and i >= 0):\n        elem = array[i]\n        if type(elem) == list:\n            if direction:\n                index = 0\n                new_list.append(unflatten_list(elem, direction, index))\n                i += 1\n            else:\n                index = len(elem) - 1\n                new_list.insert(0,unflatten_list(elem, direction, index))\n                i -= 1\n        else:\n            if direction:\n                residual = elem  % (len(array) - i)\n            else:\n                residual = elem % (i + 1)\n            if residual < 3:\n                if direction:\n                    new_list.append(elem)\n                    i += 1\n                else:\n                    new_list.insert(0,elem)\n                    i -= 1\n            else:\n                if direction:\n                    if(i + residual <= len(array)):\n                        new_list.append(array[i:i+residual])\n                        i = i + residual\n                    else:\n                        new_list.append(array[i:])\n                        i = len(array)\n                else:\n                    if(i - residual <= len(array)):\n                        new_list.insert(0,array[i - residual + 1: i + 1])\n                        i = i - residual\n                    else:\n                        new_list.insert(0,array[:i+1])\n                        i = -1\n                    \n    return new_list\n\n\n", "def unflatten(flat_array, depth):\n    r=flat_array\n    direction=1\n    for d in range(depth):\n        r=_unflatten(r,direction)\n        direction*=-1\n    return r\n\ndef _unflatten(flat_array, direction):\n    q=flat_array[:]\n    r=[]\n    while(q):\n        if direction>0:\n            x=q.pop(0)\n        else:\n            x=q.pop()\n        if type(x)==list:\n            if direction>0:\n                r.append(_unflatten(x,direction))\n            else:\n                r.insert(0,_unflatten(x,direction))\n        elif x%(len(q)+1)<3:\n            if direction>0:\n                r.append(x)\n            else:\n                r.insert(0,x)\n        else:\n            t=[x]\n            for _ in range(x%(len(q)+1)-1):\n                if not q:\n                    break\n                if direction>0:\n                    t.append(q.pop(0))\n                else:\n                    t.append(q.pop())\n            if direction>0:\n                r.append(t)\n            else:\n                r.insert(0,t[::-1])\n    return r", "def unflatten(flat_array, depth, direction=1):\n    if depth == 0: return flat_array\n    if direction == 1:\n      result, j = [], 0\n      length = len(flat_array)\n      while j < length:\n        if isinstance(flat_array[j], list):\n          result.append(unflatten(flat_array[j], 1, direction=1))\n          j += 1\n        else:\n          remainder = flat_array[j] % (length - j)\n          if remainder < 3:\n              result.append(flat_array[j])\n              j += 1\n          else:\n              result.append(flat_array[j:j+remainder])\n              j += remainder\n      return unflatten(result, depth-1, direction=-1)\n    else:\n      length = len(flat_array)\n      result, j = [], length - 1\n      while j >= 0:\n        if isinstance(flat_array[j], list):\n          result.append(unflatten(flat_array[j], 1, direction=-1))\n          j -= 1\n        else:\n          remainder = flat_array[j] % (j + 1)\n          if remainder < 3:\n              result.append(flat_array[j])\n              j -= 1\n          else:\n              result.append(flat_array[j-remainder+1:j+1])\n              j -= remainder\n      return unflatten(result[::-1], depth-1, direction=1)", "def unflatten(flat_array, depth):\n    right = True\n    length = len(flat_array)\n    for _ in range(depth):\n        flat_array = unflatten_helper(flat_array, right)\n        right = not right\n    return flat_array\n        \n        \ndef unflatten_helper(arr, right):\n    newArr = []\n    length = len(arr)\n    if right:\n        i = 0\n        while i < length:\n            if isinstance(arr[i], list):\n                newArr.append(unflatten_helper(arr[i], right))\n                i += 1\n            else:\n                rem = arr[i] % (length - i)\n                if rem > 2:\n                    newArr.append(arr[i:rem+i])\n                    i += rem\n                else:\n                    newArr.append(arr[i])\n                    i += 1\n    else:\n        i = length - 1\n        while i >= 0:\n            if isinstance(arr[i], list):\n                newArr.append(unflatten_helper(arr[i], right))\n                i -= 1\n            else:\n                rem = arr[i] % (i + 1)\n                if rem > 2:\n                    newArr.append(arr[i-rem+1:i+1])\n                    i -= rem\n                else:\n                    newArr.append(arr[i])\n                    i -= 1\n        newArr = newArr[::-1]\n    return newArr\n", "def unflatten(flat_array, depth):\n    bLeft=True\n    for i in range(depth):\n        flat_array=oneunflatten(flat_array,bLeft)\n        if bLeft==False:\n            flat_array=flat_array[::-1]\n        bLeft = not bLeft\n    return flat_array\n    \ndef oneunflatten(flat_array, bLeft):\n    if bLeft:\n        arr = flat_array[:]\n        for i, v in enumerate(arr):\n            if isinstance(v,int):\n                if v%(len(arr)-i) > 2:\n                    arr[i], arr[i+1:i+v%(len(arr)-i)] = arr[i:i+v%(len(arr)-i)], []\n            else:\n                arr[i]=oneunflatten(v,bLeft)\n        return arr\n    else:\n        arr = flat_array[::-1]\n        for i, v in enumerate(arr):\n            if isinstance(v,int):\n                if v%(len(arr)-i) > 2:\n                    arr[i], arr[i+1:i+v%(len(arr)-i)] = arr[i:i+v%(len(arr)-i)], []\n            else:\n                arr[i]=oneunflatten(v,bLeft)\n        for i, v in enumerate(arr):\n            if isinstance(v,int):\n                pass\n            else:\n                arr[i]=arr[i][::-1]\n        return arr", "def uf_f(arr):\n    a, i = [], 0\n    while i < len(arr):\n        if isinstance(arr[i], list):\n            a.append(uf_f(arr[i]))\n            i += 1\n        else:\n            r = arr[i] % (len(arr) - i)\n            if r < 3:\n                a.append(arr[i])\n                i += 1\n            else:\n                a.append(arr[i: i+r])\n                i += r\n    return a\n\ndef uf_r(arr):\n    a, i = [], len(arr) - 1\n    while i >= 0:\n        if isinstance(arr[i], list):\n            a.insert(0, uf_r(arr[i]))\n            i -= 1\n        else:\n            r = arr[i] % (i + 1)\n            if r < 3:\n                a.insert(0, arr[i])\n                i -= 1\n            else:\n                a.insert(0, arr[i-r+1: i+1])\n                i -= r\n    return a\n\n\ndef unflatten(array, depth):\n    while depth:\n        array = uf_f(array)\n        depth -= 1\n        if depth:\n            array = uf_r(array)\n            depth -= 1\n    return array\n    \n"]
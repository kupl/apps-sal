["class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         dp=[1,2]\n         for i in range(2,32):\n             dp.append(dp[i-1]+dp[i-2])\n         \n         bnum=bin(num)[2:]\n         size=len(bnum)\n         ans=dp[size]\n         for i in range(1,size):\n             if bnum[i-1]==bnum[i]=='1':\n                 #\u5173\u952e \u5a25\u5a25 \u5bf9 \u56e0\u4e3a\u4ed6\u5c31\u662f\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\u5728\u8fd9\u513f\u5faa\u73af\u5462\n                 #\u6240\u4ee5\u4ed6\u53ef\u4ee5\u8fd9\u6837\n                 break\n             if bnum[i-1]==bnum[i]=='0':\n                 ans-=dp[size-i]-dp[size-i-1]\n                 #\u5176\u5b9e\u95ee\u9898\u5c31\u662f\u5728\u4e8e\u8fd9\u513f \u662f\u5728\u5e72\u4ec0\u4e48 \u4e3a\u4ec0\u4e48\u4f1a\u6709\u8fd9\u4e48\u4e00\u90e8 \u7b97\u4e86 \u5148\u8bb0\u4f4f\n         return ans", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         f = [0 for i in range(32)]\n         f[0] = 1\n         f[1] = 2\n         for i in range(2, 32):\n             f[i] = f[i-1] + f[i-2]\n         ans = 0\n         numL = list(map(int, bin(num)[2:]))\n         l = len(numL)\n         for i, n in enumerate(numL):\n             if n == 1:\n                 ans += f[l - i - 1]\n                 if i > 0 and numL[i-1] == 1:\n                     return ans\n         return ans + 1 # include itself since we know if num contains two 1s, it will return before\n", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         A=bin(num)[2:][::-1]\n         \n         \n         a=[0 for _ in range(len(A))]\n         \n         b=[0 for _ in range(len(A))]\n         \n         a[0]=1\n         b[0]=1\n         \n         for i in range(1,len(A)):\n             a[i]=a[i-1]+b[i-1]\n             b[i]=a[i-1]\n         \n         n=len(A)\n         res=a[n-1]+b[n-1]\n         for i in range(n-2,-1,-1):\n             if A[i]=='1' and A[i+1]=='1':\n                 break\n             elif A[i]=='0' and A[i+1]=='0':\n                 res-=b[i]\n         return res", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         if num<3:\n             return num+1\n         if num==3:\n             return num\n         import math\n         bits = int(math.log(num,2))\n         f = [0]*(bits+1)\n         f[0],f[1],f[2] =2,3,4\n         for i in range(3,bits+1):\n             f[i] = f[i-1]+f[i-2]-1\n \n         g = [0]*(bits+1)\n         n = num\n         b = 0\n         res = [0]*(bits+1)\n         while n: \n             cur = n%2\n             g[b] = cur\n             if cur:\n                 if not b:\n                     res[b] = f[b]\n                 elif not res[b-1]:\n                     res[b] = f[b]+res[b-1]\n                     \n                 elif not g[b-1]:\n                     res[b] = f[b]+res[b-1]-1\n                 else:\n                     res[b] = f[b]+f[b-1]-2\n                                     \n             else:\n                 res[b] = res[b-1]\n             n = int(n/2)\n             b = b+1\n         #print(g,f,res)\n         return res[-1]\n", "class Solution(object):\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         # A[0] is the lowest bit, A[-1] is the highest bit\n         A = bin(num)[2:][::-1]\n         # dp[i][0] is the number of integers with (i+1)bits, highest bit is 0 and without consecutive ones\n         # dp[i][1] is the number of integers with (i+1)bits, highest bit is 1 and without consecutive ones\n         dp = [[1,1] for _ in range(len(A))]\n         # res is the number of integers less than A[:i] without consecutive ones.\n         res = 1 if A[0] == '0' else 2\n         for i in range(1, len(A)):\n             dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n             dp[i][1] = dp[i - 1][0]\n             # try to get the number of integers less than A[:i+1]\n             if A[i - 1: i + 1] == '01':\n                 # if A[i-1:i+1]=='01', we can append '1' after integers less than A[:i] without consecutive ones, \n                 # also any integer with (i+1) bits, highest bit is '0', without consecutive ones\n                 # is less than A[:i+1]\n                 res += dp[i][0]\n             elif A[i - 1: i + 1] == '11':\n                 # if A[i-1:i+1]=='11', then any integer with i+1 bits and without consecutive ones \n                 # is less than A[:i+1]\n                 res = dp[i][0] + dp[i][1]\n             # if A[i]=='0', the number of integers  with i+1 bits, less than A[:i+1]  and without \n             # consecutive ones is the same as A[:i]\n         return res\n", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         \n         n = bin(num)[2:]        \n         mem = [-1] * (len(n) + 1)\n         mem[0] = 0\n         mem[1] = 0\n         def cons(n):\n             \n             count = 0\n             if n == '' or n == '1':\n                 return 0\n             \n             if n[0] == '0':\n                 count += cons(n[1:])\n             else:\n                 if (mem[len(n[1:])] == -1):\n                     mem[len(n[1:])] =  cons('1'* len(n[1:]))\n                     \n                 count += mem[len(n[1:])]\n                   \n                 if n[1] == '1':\n                     count += 1\n                     if(n[2:] != ''):\n                         count += int(n[2:], 2)\n                     count += mem[len(n[2:])]\n                 else:\n                     count += cons(n[2:])\n                 \n             return count\n         \n         \n         c = cons(n)    \n         \n         return num + 1 - c", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         if num<3:\n             return num+1\n         if num==3:\n             return num\n         import math\n         bits = int(math.log(num,2))\n         f = [0]*(bits+1)\n         f[0],f[1],f[2] =2,3,4\n         for i in range(3,bits+1):\n             f[i] = f[i-1]+f[i-2]-1\n \n         res = 0\n         pre = 0\n         flag = False\n         for i in range(bits+1):\n             if num&(1<<i):\n                 \n                 if pre:\n                     res = f[i]+f[i-1]-2\n \n                 elif flag:\n                     res = f[i]+res-1\n                 else:\n                     res = f[i]+res\n                     flag = True\n             pre = num&(1<<i)\n             #print(pre)\n         return res\n", "class Solution:\n     def findIntegers(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         def func(num):\n             if num<3:\n                 return num+1\n             t,k=num,-1\n             while t:\n                 t>>=1\n                 k+=1\n             if (num>>(k-1))^3==0:\n                 return a[k-1]+a[k]\n             return a[k]+func(num-(1<<k))\n         \n         t,k,a=num,-1,[1,2]\n         while t:\n             t>>=1\n             k+=1\n         for i in range(1,k):\n             a.append(a[-1]+a[-2])\n         return func(num)"]
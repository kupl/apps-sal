["def blast_sequence(aliensStart,position):\n    \n    def moveAliens(aliens, furthest):\n        lst, shootPath = [], []\n        for x,y,s in aliens:\n            y += s\n            if not (0 <= y < N):                                           #Out of the grid: move down and reverse\n                x, s = x+1, -s\n                y = -y-1 if y < 0 else 2*N-y-1\n            (shootPath if y == Y else lst).append((x,y,s))\n            if x > furthest: furthest = x\n        return lst, shootPath, furthest\n    \n    def shootTarget(shootPath):\n        if shootPath:\n            z = max(shootPath, key=lambda a: (a[0], abs(a[2]), a[2]))     # Furthest, fastest, going right is considered the highest\n            shootPath.remove(z)                                           # MUTATION\n            shots.append(turn)                                            # MUTATION\n    \n    (X,Y), N = position, len(aliensStart[0])\n    aliens   = [(x,y,s) for x,r in enumerate(aliensStart) for y,s in enumerate(r) if s]\n    shots, furthest, turn = [], 0, -1\n    \n    while aliens and furthest < X:\n        turn += 1\n        aliens, shootPath, furthest = moveAliens(aliens, furthest)        # Move all the aliens, splitting them in 2 groups: those facing \"my\" ship (shootPath) and the others\n        shootTarget(shootPath)                                            # Extract the target in shootPath and pop it if possible (mutation). Mutate 'shots' list at the same time\n        aliens += shootPath                                               # Put the remaining aliens in the list\n    \n    return shots if not aliens else None", "class Ship():\n    columns = 0\n\n    def __init__(self, row, col, speed):\n        self.row = row\n        self.col = col\n        self.speed = speed\n\n    def move(self):\n        new_col = self.col + self.speed\n        if new_col < 0 or new_col >= Ship.columns:\n            self.row += 1\n            self.speed = -self.speed\n            if new_col < 0:\n                new_col = -new_col - 1\n            else:\n                new_col = 2 * Ship.columns - new_col - 1\n        self.col = new_col\n\n\ndef blast_sequence(aliens, position):\n    rows, column = position\n    Ship.columns = len(aliens[0])\n    ships = []\n    for nrow, row in enumerate(aliens):\n        ships.extend(Ship(nrow, ncol, speed) for ncol, speed in enumerate(row) if speed)\n    shots, turn = [], 0\n    while ships:\n        for ship in ships:\n            ship.move()\n            if ship.row == rows:\n                return None\n        ships.sort(key=lambda x: x.speed, reverse=True)\n        ships.sort(key=lambda x: abs(x.speed), reverse=True)\n        ships.sort(key=lambda x: x.row, reverse=True)\n        targets = [ship for ship in ships if ship.col == column]\n        if targets:\n            ships.remove(targets[0])\n            shots.append(turn)\n        turn += 1\n    return shots", "def blast_sequence(aliens, position):\n    board_len = len(aliens[0])\n    aliens   = {(x, y, steps) for y, lst in enumerate(aliens) for x, steps in enumerate(lst) if steps != 0}\n    solution = []\n    turn     = -1\n    while all(alien[1] != position[0] for alien in aliens) and aliens:\n        turn   += 1\n        aliens = {(alien[0] + alien[2], alien[1], alien[2]) if 0 <= alien[0] + alien[2] < board_len\n                                                            else (-1 * (alien[0] + alien[2] + 1) % (board_len), alien[1] + 1, alien[2] * -1) for alien in aliens}\n        alien  = max((alien for alien in aliens if alien[0] == position[1]), \n                     key     = lambda alien: (alien[1], abs(alien[2]), alien[2]),\n                     default = None)\n        if alien:\n            aliens ^= {alien}\n            solution.append(turn)\n    return solution if not aliens else None", "def blast_sequence(aliens,position):\n    result = []\n    aliens_lst = [[y, x, speed] for x, row in enumerate(aliens) for y, speed in enumerate(row) if speed != 0]\n    time = 0\n    while aliens_lst:\n        for alien in aliens_lst:\n            for _ in range(abs(alien[2])):\n                if alien[0] == 0 and alien[2] < 0 or alien[0] == len(aliens[0])-1 and alien[2] > 0:\n                    alien[1] += 1\n                    alien[2] *= -1\n                    if alien[1] == position[0]: \n                        return None\n                else: alien[0] += (1 if alien[2] > 0 else -1)\n                \n        targets = [alien for alien in aliens_lst if alien[0] == position[1]]\n        targets.sort(key=lambda alien: (alien[1], abs(alien[2]), alien[2]))\n        if targets:\n            target = targets.pop()\n            aliens_lst.remove(target)\n            result.append(time)\n            \n        time += 1\n        \n    return result", "def blast_sequence(aliens,shooter):\n    row, column = len(aliens[0]), shooter[0] + 1\n    board = [[0 for _ in range(row)] for _ in range(column)]\n    for i, j in enumerate(aliens) : board[i] = j\n    find_pos = [[i, k, l] for i, j in enumerate(aliens) for k, l in enumerate(j) if l]\n    def parse(x, y, z):\n        c = 0\n        while c < abs(z):\n            if z > 0 : y += 1\n            else : y -= 1\n            if y == row : x += 1  ; z, y = -z, row -1\n            elif y == -1 : x += 1 ; z, y = -z, 0\n            c += 1\n        return [x, y, z]\n    turn, shoots = 0, []\n    while find_pos and all(k[0] != shooter[0] for k in find_pos):\n        for i, j in enumerate(find_pos):\n            find_pos[i] = parse(*j)\n        targets = [k for k in find_pos if k[1] == shooter[1]]\n        if targets:\n            shoots.append(turn)\n            find_pos.remove(max(targets, key=lambda x: (x[0], abs(x[2]), x[2])))\n        turn += 1\n    return [shoots,None][bool(find_pos)]", "def blast_sequence(aliens, position):\n    \n    si, sj = position\n    rows, cols = si + 1, len(aliens[0])\n    board = [[[a] if a else [] for a in alien] for alien in aliens] + [[[]] * cols for c in range(rows - len(aliens))]\n    \n    count = len([a for al in aliens for i, a in enumerate(al) if a])\n    turn = 0\n    res = []\n    \n    while count > 0: \n        \n        board = move(board, rows, cols)\n        if not board: return None\n        \n        for pi in range(rows - 2, -1, -1):\n            col = board[pi][sj]\n            if not col: continue\n            if len(col) == 1: \n                board[pi][sj] = []\n            else: \n                dead = sorted(col, key = lambda v: (abs(v), v)).pop()\n                board[pi][sj].remove(dead)\n            res.append(turn)\n            count -= 1\n            break\n        turn += 1\n    \n    return res\n\ndef move(board, rows, cols): \n    if any(l for l in board[-1]): return None\n    \n    temp = [[[] for a in row] for row in board]\n    \n    for i, row in enumerate(board): \n        for j, alien_list in enumerate(row):\n            if not alien_list: continue\n            for k, alien in enumerate(alien_list):\n                ni = i                    \n                nj = j + alien\n                if nj < 0: \n                    nj = abs(nj) - 1\n                    ni += 1\n                    alien *= -1\n                elif nj >= cols:\n                    nj = cols - 1 - nj % cols\n                    ni += 1\n                    alien *= -1\n                \n                if ni == rows - 1: return None\n                temp[ni][nj].append(alien)\n        \n    return temp        ", "class alien:\n    def __init__(self, speed, i, j):\n        self.speed=speed\n        self.positionI=i\n        self.positionJ=j\n\nclass model:\n\n    def __del__(self):\n        print(' ')\n\n    def __init__ (self, aliens, defender):\n        self.listOfAllAliens=[]\n        self.listOfShootableAliens=[]\n        self.countOfStaticAliens=0\n        self.blastSequence=[]\n        self.roundOfGame=0\n        self.gameWon=False\n        self.gameOver=False\n        self.TESTnumberOfAliens=0\n\n        self.positionOfDefenderI=defender[1]\n        self.positionOfDefenderJ=defender[0]\n\n        self.lenOfFieldJ=defender[0]\n        self.lenOfFieldI=len(aliens[0])\n\n        self.createAliens(aliens)\n\n        self.countStaticAliens()\n\n    def createAliens(self, aliens):\n        posJ=-1\n\n        for line in aliens:\n            posJ = posJ + 1\n            for i in range (0, len(aliens[0])):\n                newAlien = alien (line[i], i, posJ)\n                self.TESTnumberOfAliens = self.TESTnumberOfAliens + 1\n                self.listOfAllAliens.append(newAlien)\n\n    def countStaticAliens(self):\n        for alien in self.listOfAllAliens:\n            if (alien.speed == 0):\n                self.countOfStaticAliens = self.countOfStaticAliens+1\n\n    def increaseRoundOfGame (self):\n        self.roundOfGame = self.roundOfGame + 1\n\n\n    def moveAliens (self):\n\n        for alien in self.listOfAllAliens:\n            self.calculateAlienMovement(alien)\n\n            if (alien.positionJ == self.positionOfDefenderJ):\n                self.gameOver=True\n            \n            if (alien.positionI == self.positionOfDefenderI):\n                # for whatever reason, static aliens are not shot\n                if(alien.speed != 0):\n                    self.putAlienInListOfShootableAliens(alien)\n        \n\n    \n    def calculateAlienMovement(self, alien):\n        speed=alien.speed\n        distance = speed+alien.positionI\n\n\n\n        TESTdistance = abs(speed)\n        distance_remaining = 0\n\n        TESTpositionI = alien.positionI\n        TESTpositionJ = alien.positionJ\n\n        # only horizontal movement\n        if (distance <= self.lenOfFieldI-1 and distance >= 0):\n            alien.positionI = distance\n            TESTdistance = 0\n        \n        # vertical movement right\n        elif(distance >= self.lenOfFieldI):\n            # move to rightmost column\n            distance_right = self.lenOfFieldI -1 - alien.positionI\n            distance_remaining = abs(alien.speed) - distance_right\n            alien.positionI = alien.positionI + distance_right \n\n            TESTdistance = TESTdistance - distance_right\n            \n            # move up\n            alien.positionJ = alien.positionJ+1\n            distance_remaining = distance_remaining - 1\n\n            TESTdistance = TESTdistance - 1\n            \n            alien.speed = -alien.speed\n\n            # move left\n            alien.positionI = alien.positionI -distance_remaining\n\n            TESTdistance = TESTdistance - distance_remaining\n            \n        \n        # vertical movement left\n        elif(distance < 0):\n\n            # move to leftmost column\n            distance_left = alien.positionI\n            distance_remaining = abs(alien.speed) - distance_left\n            alien.positionI = 0\n\n            TESTdistance = TESTdistance - distance_left\n\n            # move up\n            alien.positionJ = alien.positionJ+1\n            distance_remaining = distance_remaining - 1\n\n            TESTdistance = TESTdistance - 1\n            \n            alien.speed = -alien.speed\n\n            # move right\n            alien.positionI = distance_remaining\n\n            TESTdistance = TESTdistance - distance_remaining\n        \n\n        else:\n            if(speed !=0):\n                print('error! alien movement could not be calculated')\n\n        if (\n            (TESTpositionI == alien.positionI) \n        and (TESTpositionJ == alien.positionJ)\n        and (alien.speed!=0)\n        ):\n            print('error! alien did not move this round')\n\n        if(TESTdistance != 0):\n            print('error! calculation went wrong. remaining or negative distance left.')\n\n        \n\n    def putAlienInListOfShootableAliens (self, shootableAlien):\n        self.listOfShootableAliens.append(shootableAlien)\n\n\n\n    def shoot(self):\n\n        if not (len(self.listOfShootableAliens)==0):\n            # there will be a shot!\n            alienToBeShot = self.findAlienToBeShot()\n            \n            self.deleteShotAlienFromListOfAllAliens(alienToBeShot)\n\n            self.addRoundToBlastSequence()\n\n        # in any case:\n        self.clearListOfShootableAliens()\n\n\n    def clearListOfShootableAliens(self):\n        self.listOfShootableAliens=[]\n\n    def findAlienToBeShot(self):\n        iterator = self.lenOfFieldJ-1\n        alienFound = False\n        killingList=[]\n\n        while ((iterator >= 0) and (alienFound == False)):\n            # iterate through the field by lines\n            for shootableAlien in self.listOfShootableAliens:\n                if ((shootableAlien.positionJ == iterator) and (shootableAlien.positionI == self.positionOfDefenderI)):\n                    killingList.append(shootableAlien)\n                    alienFound = True\n            iterator = iterator -1\n\n        # TEST\n        if(len(killingList)==0):\n            print((\"error! no alien to be shot found, also there are some!\"\n            + \"in the listofshootable Aliens\", self.listOfShootableAliens))\n            return None\n        \n        elif (len(killingList)==1):\n            return killingList[0]\n        \n        else:\n            return self.findAlienWithHighestAbsoluteSpeed(killingList)\n\n\n    def findAlienWithHighestAbsoluteSpeed(self, killingList):\n        maxAbsSpeed=0\n        highestAlien=[]\n\n        # calculate highest speed\n        for alien in killingList:\n            if ( abs(alien.speed) > maxAbsSpeed):\n                maxAbsSpeed = abs(alien.speed)\n\n        # find fastest alien\n        for alien in killingList:\n            if ( abs(alien.speed) == maxAbsSpeed):\n                highestAlien.append(alien)\n        \n        #more than one fastest aliens \n        if (len(highestAlien)>1):\n            # choose a right-moving alien\n            for alien in highestAlien:\n                if (alien.speed > 0):\n                    return alien\n\n        # return any of the remaining aliens\n        return highestAlien[0]\n        \n\n    def addRoundToBlastSequence (self):\n        self.blastSequence.append(self.roundOfGame)\n\n    def deleteShotAlienFromListOfAllAliens(self, shotAlien):\n  \n        if (shotAlien.speed == 0):\n            self.countOfStaticAliens = self.countOfStaticAliens-1\n            print(('error! static alien shot in round',self.roundOfGame ))\n\n        self.listOfAllAliens.remove(shotAlien)\n\n\n\n    def checkIfGameOverOrGameWon (self):\n\n        if ((len(self.listOfAllAliens)-self.countOfStaticAliens) == 0):\n            self.gameWon = True\n\n        if ((self.gameOver == True) or (self.gameWon == True)):\n            return True\n\n        else:\n            return False\n\n\n\n# Section of Testing\n\n    def TESTNumberOfAliens (self):\n\n        if (self.TESTnumberOfAliens != (len(self.listOfAllAliens) + len(self.blastSequence))):\n            print(\"error! Something went wrong. the number of aliens is not matching\" )\n            \n        if(self.TESTnumberOfAliens < len(self.blastSequence)):\n            print('error! more aliens shot than existed')\n\n\n\ndef blast_sequence(aliens,position):\n    \n    game = model(aliens, position)\n    check = False\n\n    while (not check):\n        game.TESTNumberOfAliens()\n        game.moveAliens()\n        game.shoot()\n        check = game.checkIfGameOverOrGameWon()\n        game.increaseRoundOfGame()\n    \n    isGameWon = game.gameWon\n    solution = game.blastSequence\n    del game\n    if (isGameWon):\n        return solution\n    else:\n        return None\n\n\n", "class Ship():\n    def __init__(self, x, y, speed):\n        self.x = x\n        self.y = y\n        self.speed = speed\n\ndef blast_sequence(aliens,position):\n    result = []\n    ships = [Ship(x, y, speed) for x, row in enumerate(aliens) for y, speed in enumerate(row) if speed]\n    turn = 0\n    while ships:\n        for ship in ships:\n            for _ in range(abs(ship.speed)):\n                if ship.y == 0 and ship.speed < 0 or ship.y == len(aliens[0])-1 and ship.speed > 0:\n                    ship.x += 1\n                    ship.speed *= -1\n                    if ship.x == position[0]: \n                        return None\n                else: ship.y += (1 if ship.speed > 0 else -1)\n                \n        targets = [ship for ship in ships if ship.y == position[1]]\n        targets.sort(key=lambda ship: (ship.x, abs(ship.speed), ship.speed))\n        if targets:\n            target = targets.pop()\n            ships.remove(target)\n            result.append(turn)\n            \n        turn += 1\n        \n    return result", "def blast_sequence(aliens, position):\n    dal = []\n    wdh = len(aliens[0])\n    for y in range(len(aliens)):\n        for x in range(len(aliens[y])):\n            if aliens[y][x] != 0:\n                dal.append((y, x, aliens[y][x]))\n    yp, xp = position\n    hgh = yp + 1\n    dr = []\n    i = -1\n    while len(dal) > 0:\n        i += 1\n        ddel = []\n        for k in range(len(dal)):\n            y, x, v = dal[k]\n            # print(y, x, v)\n            x += v\n            if x < 0:\n                v = -v\n                x = -x - 1\n                y += 1\n                if y == yp:\n                    return None\n            elif x >= wdh:\n                v = -v\n                x = wdh + wdh - 1 - x\n                y += 1\n                if y == yp:\n                    return None\n            dal[k] = (y, x, v)\n            if x == xp:\n                ddel.append(k)\n        if len(ddel) > 0:\n            ymax = 0\n            for k in ddel:\n                y, x, v = dal[k]\n                ymax = max(ymax, y)\n            ddel2 = []\n            for k in ddel:\n                y, x, v = dal[k]\n                if y == ymax:\n                    ddel2.append(k)\n            if len(ddel2) == 1:\n                kdel = ddel2[0]\n            else:\n                vmax = 0\n                for k in ddel2:\n                    y, x, v = dal[k]\n                    vmax = max(vmax, abs(v))\n                ddel = []\n                for k in ddel2:\n                    y, x, v = dal[k]\n                    if abs(v) == vmax:\n                        ddel.append(k)\n                if len(ddel) == 1:\n                    kdel = ddel[0]\n                else:\n                    for k in ddel:\n                        y, x, v = dal[k]\n                        if v > 0:\n                            kdel = k\n                            break\n            dr.append(i)\n            dal.pop(kdel)\n    return dr\n", "def blast_sequence(aliens_input, position):\n    SHIP_X = position[1]\n    HEIGHT = position[0] + 1\n    WIDTH = len(aliens_input[0])\n    turn = 0\n    seq = []\n    class Alien:\n        def __init__(self, coords, cell):\n            self.x, self.y = coords\n            self.moves = abs(cell)\n            self.dir = 1 if cell > 0 else -1\n    aliens = [Alien((x, y), cell) for y, row in enumerate(aliens_input) for x, cell in enumerate(aliens_input[y]) if cell]\n    \n    def moveAlien(alien):\n        for i in range(alien.moves):\n            if alien.dir == -1 and alien.x == 0 or alien.dir == 1 and alien.x == WIDTH - 1:\n                alien.dir *= -1\n                alien.y += 1\n                if alien.y == HEIGHT - 1:\n                    return True\n            else:\n                alien.x += alien.dir\n    def moveAliens():\n        for alien in aliens:\n            if moveAlien(alien):\n                return True\n    def fireCannon():\n        aliensInLine = list(filter(lambda a: a.x == SHIP_X, aliens))\n        if not aliensInLine:\n            return\n        targetAlien = None\n        for alien in aliensInLine:\n            if (\n                not targetAlien or\n                alien.y > targetAlien.y or\n                alien.y == targetAlien.y and (\n                    alien.moves > targetAlien.moves or\n                    alien.moves == targetAlien.moves and alien.dir == 1\n                )\n            ):\n                targetAlien = alien\n        aliens.remove(targetAlien)\n        seq.append(turn - 1)\n    def makeTurn():\n        nonlocal turn\n        turn += 1\n        if moveAliens():\n            return True\n        fireCannon()\n    \n    while aliens:\n        if makeTurn():\n            return None\n    return seq"]
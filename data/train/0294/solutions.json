["class Solution:\n     def totalNQueens(self, n):\n         def dfs(lst, xy_dif, xy_sum):\n             p=len(lst)\n             if p==n: res.append(lst)\n             for q in range(n):\n                 if (q not in lst) and (p-q not in xy_dif) and (p+q not in xy_sum):\n                     dfs(lst+[q], xy_dif+[p-q], xy_sum +[p+q])\n             \n         res=[]\n         dfs([],[],[])\n         return len(res)", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         result=[]\n         self.DFS(n,0,\"\",[],[],[],result)\n         print(result)\n         return len(result) \n             \n     def DFS(self, n, row, sss, check_col,check_diag1,check_diag2, result):\n         \"\"\" sss is solution string, all other checks are checks for occupied places \"\"\"\n         if (len(sss) == n):\n             result.append('.')\n             return\n         \n         for col in range(0,n):\n             if (col in check_col): continue\n             if (row+col in check_diag1): continue\n             if (row-col in check_diag2): continue\n             self.DFS(n, row+1, sss+str(col), check_col+[col], \n                  check_diag1+[row+col], check_diag2+[row-col],result)", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         placement = []\n         \n         def can_place_queen(row, col):\n             for i, j in enumerate(placement):\n                 if col == j or abs(col - j) == row - i:\n                     # Same column as, or diagonally from other queen\n                     return False\n             return True\n \n         def place_in_row(row):\n             if row == n:\n                 return 1\n             \n             count = 0\n             for col in range(n):\n                 if can_place_queen(row, col):\n                     placement.append(col)\n                     count += place_in_row(row + 1)\n                     placement.pop()\n             return count\n         return place_in_row(0)\n", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         rl=[0]\n         col=[False for x in range(n)]\n         dia1=[False for x in range(2*n-1)]\n         dia2=[False for x in range(2*n-1)]\n         self.putQueen(n,col,dia1,dia2,rl,0)\n         return rl[0]\n     \n     def putQueen(self,n,col,dia1,dia2,rl,index):\n         if index==n:\n             rl[0]+=1\n             return True\n         for i in range(n):\n             if not col[i] and not dia1[index+i] and not dia2[index-i+n-1]:\n                 col[i]=True\n                 dia1[index+i]=True\n                 dia2[index-i+n-1]=True\n                 self.putQueen(n,col,dia1,dia2,rl,index+1)\n                 col[i]=False\n                 dia1[index+i]=False\n                 dia2[index-i+n-1]=False", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n <= 0:\n             return 0\n         diag_lr = [True] * (2*n-1)\n         diag_rl = [True] * (2*n-1)\n         vert = [True] * n\n         res = []\n \n         def _check_board(x, y):\n             return vert[y] and diag_lr[y-x+n-1] and diag_rl[x+y]\n \n         def _helper(x):\n             if x == n:\n                 res.append(1)\n                 return\n             for y in range(n):\n                 if _check_board(x, y):\n                     vert[y] = False\n                     diag_lr[y-x+n-1] = False\n                     diag_rl[x+y] = False\n                     _helper(x+1)\n                     vert[y] = True\n                     diag_lr[y-x+n-1] = True\n                     diag_rl[x+y] = True\n \n         _helper(0)\n         return len(res)", "class Solution:\n     def __init__(self):\n         self.board = []\n         self.col_status = []\n         self.row_status = []\n         self.dia_status_1 = []\n         self.dia_status_2 = []\n         self.result = 0\n \n     def placeQueen(self, row, n):\n         if row == n:\n             tmp = [''.join(el) for el in self.board]\n             self.result += 1\n             return\n         for i in range(n):\n             if self.col_status[i] and self.dia_status_1[i+row] and self.dia_status_2[row-i]:\n                 self.board[row][i] = 'Q'\n                 self.col_status[i] = False\n                 self.dia_status_1[i+row] = False\n                 self.dia_status_2[row-i] = False\n                 self.placeQueen(row+1, n)\n                 self.board[row][i] = '.'\n                 self.col_status[i] = True\n                 self.dia_status_1[i+row] = True\n                 self.dia_status_2[row-i] = True\n \n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[List[str]]\n         \"\"\"\n         self.board = [['.' for i in range(n)] for j in range(n)]\n         self.col_status = [True for i in range(n)]\n         self.row_status = [True for i in range(n)]\n         self.dia_status_1 = [True for i in range(2*n-1)]\n         self.dia_status_2 = [True for i in range(2*n-1)]\n         self.placeQueen(0, n)\n         return self.result", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         ans = []\n         def dfs(queens, xy_dif, xy_sum):\n             p = len(queens)\n             if p == n:\n                 result.append(queens)\n                 return None\n \n             for q in range(n):\n                 if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                     dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n \n         result = []\n         dfs([], [], [])\n         \n         return len(result)", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         def dfs(cols, diag_45, diag_135, depth=0):\n             nonlocal result\n             row = len(cols)\n             if row == n:\n                 result += 1\n                 return \n             for col in range(n):\n                 if col not in cols and (row - col) not in diag_45 and (row + col) not in diag_135:\n                     dfs(cols + [col], diag_45 + [row - col], diag_135 + [row + col], depth + 1)\n \n         result = 0\n         dfs([], [], [])\n         return result", "class Solution:\n     \n     def find_arrangements(self, arrangement, diag1_used, diag2_used, col_used, x, n):\n         if x == n:\n             return 1\n         res = 0\n         for y in range(n):\n             diag1 = x + y\n             diag2 = x - y + n\n             if not diag1_used[diag1] and not diag2_used[diag2] and not col_used[y]:\n                 arrangement.append(y)\n                 diag1_used[diag1] = True\n                 diag2_used[diag2] = True\n                 col_used[y] = True\n                 cur_res = self.find_arrangements(arrangement, diag1_used, diag2_used, col_used, x + 1, n)\n                 arrangement.pop()\n                 diag1_used[diag1] = False\n                 diag2_used[diag2] = False\n                 col_used[y] = False\n                 res += cur_res\n                 \n         return res\n         \n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         arrangement = []\n         diag1_used = [False] * (2 * n)\n         diag2_used = [False] * (2 * n)\n         col_used = [False] * n\n         return self.find_arrangements(arrangement, diag1_used, diag2_used, col_used, 0, n)", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         \n         count = 0\n         def solve(rows, cols, diag0, diag1, n):\n             nonlocal count\n             \n             freerows = {i for i in range(n)} - rows\n             if not freerows:\n                 count += 1\n                 return\n             \n             i = freerows.pop()\n             candidates = []\n             for j in range(n):\n                 if j in cols:\n                     continue\n                 if i + j in diag0:\n                     continue\n                 if i - j in diag1:\n                     continue\n                 \n                 rows.add(i)\n                 cols.add(j)\n                 diag0.add(i+j)\n                 diag1.add(i-j)\n                 \n                 solve(rows, cols, diag0, diag1, n)\n                 \n                 rows.remove(i)\n                 cols.remove(j)\n                 diag0.remove(i+j)\n                 diag1.remove(i-j)\n         \n         solve(set(), set(), set(), set(), n)\n         return count\n", "class Solution:\n     def totalNQueens(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         row = [x for x in range(n)]\n         table = []\n         for i in range(n):\n             table.append(row.copy())\n         result = self.solve(table,0)\n         return len(result)\n     def solve(self,table,n):\n         if table[n]==[]:return []\n         elif n==len(table)-1:\n             table[n] = table[n][0]\n             return [table]\n         else:\n             result=[]\n             for x in table[n]:\n                 table1 = [(x if type(x)==int else x.copy()) for x in table]\n                 table1[n] = x\n                 for row in range(n+1,len(table)):\n                     if x in table1[row]:\n                         table1[row].remove(x)\n                     if x+row-n in table1[row]:\n                         table1[row].remove(x+row-n)\n                     if x-(row-n) in table1[row]:\n                         table1[row].remove(x-(row-n))\n                 result.extend(self.solve(table1,n+1))\n             return result"]
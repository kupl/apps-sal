["from itertools import count\n\nALL_MOVES  = [(1,1), (0,1), ( 1,0), (-1,0), (0,-1), (-1,1), ( 1,-1), (-1,-1)]       # Natural directions of moves for king or queen (one step)\nAMA_MOVES  = [(1,2), (2,1), (-1,2), (2,-1), (1,-2), (-2,1), (-1,-2), (-2,-1)]       # Knight moves for amazon queen\n\n\ndef amazon_check_mate(*args):\n\n    def posInBoard(x,y):  return 0 <= x < 8 and 0 <= y < 8\n    \n    def getCoveredPos(start, king=None):                                            # Working with the amazon queen is king is provided\n        covered = {start}\n        for m in (AMA_MOVES if king else ALL_MOVES):                                # All \"one step\" moves (either for queen or king)\n            pos = tuple( z+dz for z,dz in zip(start,m) )\n            if posInBoard(*pos): covered.add(pos)\n        \n        if king:                                                                    # Get long range moves, for queen only (meaning: if king is provided!)\n            for dx,dy in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0]+dx*n, start[1]+dy*n)\n                    if not posInBoard(*pos) or pos == king: break                   # Abort if not in board or if white king is on the way\n                    covered.add(pos)\n        \n        return covered\n    \n    \n    K, Q      = [(ord(s[0])-97, ord(s[1])-49) for s in args]                   # King and Queen positions as tuples\n    kCover    = getCoveredPos(K)                                                    # Positions protected by white king\n    fullCover = getCoveredPos(Q,K) | kCover                                         # All position protected by white pieces\n    freeQueen = Q not in kCover                                                     # Queen not protected by king\n    counts    = [0] * 4                                                             # Indexes: 2 * \"is not check\" + 1 * \"safe position available around\"\n    \n    for x in range(8):\n        for y in range(8):\n            black = (x,y)\n            \n            if black in kCover or black == Q: continue                              # No adjacent kings and no king copulating with an amazon...\n            \n            safePosAround = any( posInBoard(*neigh) and (neigh not in fullCover or neigh == Q and freeQueen)   # Neighbour is in board and is a safe place or is the queen and isn't protected by white king\n                                 for neigh in ((x+dx, y+dy) for dx,dy in ALL_MOVES) )\n                                    \n            counts[ 2*(black not in fullCover) + safePosAround ] += 1               # Update the correct index of \"ans\"\n            \n    return counts\n", "from collections import namedtuple\nfrom functools import reduce\nimport enum\nimport sys\n\nclass Outcomes:\n    \"\"\"Enapsulation of outcomes to which tracks results as named attributes\n    and can return the array expected by the kata.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize situational count members to 0.\n        \"\"\"\n\n        self.checkmates = 0\n        self.checks = 0\n        self.stalemates = 0\n        self.alives = 0\n\n    def as_array(self):\n        \"\"\"Return the array ordered as expected by the kata definition.\n        \n        Returns:\n            array -- integer array of counts of squares by chess condition.\n        \"\"\"\n\n        return [self.checkmates, self.checks, self.stalemates, self.alives]\n\nclass GameSquareConditions:\n    \"\"\"Gameplay conditions of a square.\n    \"\"\"\n\n    def __init__(self, is_threatened=False, is_occupied=False, is_inhibited=False):\n        self.is_threatened = is_threatened\n        self.is_occupied = is_occupied\n        self.is_inhibited = is_inhibited\n\n    @property\n    def is_safe(self):\n        \"\"\"Property to return the inverse of is_threatened.\n        \"\"\"\n        return not self.is_threatened\n\nclass GameSquareOutcome(enum.Enum):\n    CHECKMATE = enum.auto()\n    CHECK = enum.auto()\n    STALEMATE = enum.auto()\n    ALIVE = enum.auto()\n    UNKNOWN = enum.auto()\n\n@enum.unique\nclass MovementDirection(enum.Enum):\n    \"\"\"Enumeration of movement directions.\n    \"\"\"\n    NORTH = (0, 1)\n    NORTH_EAST = (1, 1)\n    EAST = (1, 0)\n    SOUTH_EAST = (1, -1)\n    SOUTH = (0, -1)\n    SOUTH_WEST = (-1, -1)\n    WEST = (-1, 0)\n    NORTH_WEST = (-1, 1)\n\n    def __init__(self, x_offset, y_offset):\n        self.x_offset = x_offset\n        self.y_offset = y_offset\n\n    @property\n    def cartesian_offset(self):\n        \"\"\"Return an (x,y) tuple offset for the direction. This method assumes\n        the cartesian grid lower left is 0,0 with positive x to the right and\n        positive y up.\n        \"\"\"\n        return (self.x_offset, self.y_offset)\n\n    @property\n    def reciprical(self):\n        \"\"\"Return the opposite direction.\n        \"\"\"\n        if self == self.NORTH:\n            return self.SOUTH\n        elif self == self.NORTH_EAST:\n            return self.SOUTH_WEST\n        elif self == self.EAST:\n            return self.WEST\n        elif self == self.SOUTH_EAST:\n            return self.NORTH_WEST\n        elif self == self.SOUTH:\n            return self.NORTH\n        elif self == self.SOUTH_WEST:\n            return self.NORTH_EAST\n        elif self == self.WEST:\n            return self.EAST\n        elif self == self.NORTH_WEST:\n            return self.SOUTH_EAST\n\n        raise ValueError(\"Unknown direction to recipricate!\")\n        \n    def move_from(self, x, y):\n        \"\"\"Apply the movement to the provided X, Y cartesian coordinates.\n        \n        Arguments:\n            x {int} -- Starting X cartesian coordinate to move from.\n            y {int} -- Starting Y cartesian coordinate to move from.\n\n        Returns:\n            Tuple (x,y) cartesian coordinates resulting from the move.\n        \"\"\"\n        offset = self.cartesian_offset\n        return (x + offset[0], y + offset[1])\n\nclass GameSquare:\n    \"\"\"Square on the gameboard.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the neighbors in all directions to None.\n        \"\"\"\n        self.neighbors = {}\n        self.condition = GameSquareConditions()\n        self.outcome = GameSquareOutcome.UNKNOWN\n\n    def has_neighbor(self, direction):\n        \"\"\"Check if there is a neighboring square in the given direction.\n        \n        Arguments:\n            direction {MovementDirection} -- Direction to check.\n        \"\"\"\n        return self.neighbor(direction) is not None\n\n    def neighbor(self, direction):\n        \n        \"\"\"Return the neighboring game square in the direction. If no neighbor\n        has been set, None.\n        \n        Arguments:\n            direction {MovementDirection} -- Direction to get neighbor in.\n\n        Return:\n            GameSquare or None.\n        \"\"\"\n        return self.neighbors.get(direction, None)\n\n    def set_neighbor(self, neighbor, direction):\n        \"\"\"Store the neighbor to the specified direction.\n\n        Side effects:\n        Neighbor status is also set in the reciprical direction of the\n        provided neighbor. If the neighbor is already set on that\n        direction, it is cleared.\n\n        If the provided neighbor is 'self' a \n        \n        Arguments:\n            neighbor {GameSquare} -- Neighboring game square to connect.\n            direction {MovementDirection} -- Direction to get neighbor in.\n        \"\"\"\n        if neighbor is self:\n            raise ValueError(\"Cannot set yourself as a neighbor!\")\n\n        existing_neighbor = self.neighbor(direction)\n        if existing_neighbor is not None and existing_neighbor is not neighbor:\n            raise ValueError(\"Another neighbor is already in that direction!\")\n\n        recip_direction = direction.reciprical\n        existing_recip_neighbor = neighbor.neighbor(recip_direction)\n        if existing_recip_neighbor is not None and existing_recip_neighbor is not self:\n            raise ValueError(\"Input neighbor already has neighbor in opposite direction!\")\n\n        self.neighbors[direction] = neighbor\n        neighbor.neighbors[recip_direction] = self\n\n    def neighbor_conditions(self):\n        \"\"\"Return a list of all conditions for neighboring squares.\n        \"\"\"\n        return [n.condition for n in list(self.neighbors.values())]\n\n    def render(self, out_dest):\n        \"\"\"Simple grid rendering to the output stream.\n\n        Arguments:\n            out_dest -- Output stream to render to.\n        \"\"\"\n        \n        marker = \" \"\n        if self.condition.is_threatened:\n            marker = \"v\"\n        elif self.condition.is_occupied:\n            marker = \"*\"\n        elif self.condition.is_inhibited:\n            marker = \"-\"\n        out_dest.write(marker)\n\n    def render_outcome(self, out_dest):\n        \"\"\"Simple grid rendering of the outcome to the output stream.\n\n        Arguments:\n            out_dest -- Output stream to render to.\n        \"\"\"\n        \n        marker = \"?\"\n        if self.outcome == GameSquareOutcome.CHECKMATE:\n            marker = \"!\"\n        elif self.outcome == GameSquareOutcome.CHECK:\n            marker = \":\"\n        elif self.outcome == GameSquareOutcome.STALEMATE:\n            marker = \"o\"\n        elif self.outcome == GameSquareOutcome.ALIVE:\n            marker = \".\"\n        out_dest.write(marker)\n\nclass Gameboard:\n    \"\"\"Gameboard comprised of rows and columns of GameSquares.\n    The origin of the gameboard is the \"lower-left\".\n    \"\"\"\n\n    def __init__(self, num_rows, num_cols):\n        \"\"\"Initialize the gameboard with a num_rows x num_cols grid of \n        GameSquares.\n        \n        Arguments:\n            num_rows {int} -- Number of rows on the gameboard\n            num_cols {int} -- Number of columns on the gameboard\n        \"\"\"\n        if num_rows < 1:\n            fmt = \"Gameboard initialized with number of rows < 1 ({})!\"\n            msg = fmt.format(num_rows)\n            raise ValueError()\n\n        if num_cols < 1:\n            fmt = \"Gameboard initialized with number of columns < 1 ({})!\"\n            msg = fmt.format(num_cols)\n            raise ValueError(msg)\n\n        self.num_rows = num_rows\n        self.num_cols = num_cols\n\n        self.board = {}\n        for row in range(num_rows):\n            for col in range(num_cols):\n                key = (row, col)\n                self.board[key] = GameSquare()\n\n        for row in range(num_rows):\n            for col in range(num_cols):\n                current = self.square_at(row, col)\n                for direction in MovementDirection:\n                    try:\n                        neighbor_x, neighbor_y = direction.move_from(row, col)\n                        neighbor = self.square_at(neighbor_x, neighbor_y)\n                        current.set_neighbor(neighbor, direction)\n                    except KeyError:\n                        pass\n\n    def square_at(self, row, col):\n        \"\"\"Return the GameSquare at the specified row and column.\n\n        If row or col are out of bounds, an KeyError is raised.\n        \n        Arguments:\n            row {int} -- 0 based index of the row to return the square from.\n            col {int} -- 0 based index of the column to return the square from.\n\n        Return:\n            GameSquare at the specified index.\n        \"\"\"\n        key = (row, col)\n        return self.board[key]\n\n    def render(self, out_dest):\n        \"\"\"Simple grid rendering to the output stream. The board is rendered\n        with the \"top\" row on \"top\".\n\n        Arguments:\n            out_dest -- Output stream to render to.\n        \"\"\"\n        out_dest.write(\"\\n\\nGameboard\\n\")\n        for y in range(self.num_cols - 1, -1, -1):\n            for x in range(self.num_rows):\n                out_dest.write(\"|\")\n                self.square_at(x, y).render(out_dest)\n            out_dest.write(\"|\\n\")\n\n    def render_outcome(self, out_dest):\n        \"\"\"Simple grid rendering to the output stream. The board is rendered\n        with the \"top\" row on \"top\".\n\n        Arguments:\n            out_dest -- Output stream to render to.\n        \"\"\"\n        out_dest.write(\"\\n\\nOutcomes\\n\")\n        for y in range(self.num_cols - 1, -1, -1):\n            for x in range(self.num_rows):\n                out_dest.write(\"|\")\n                self.square_at(x, y).render_outcome(out_dest)\n            out_dest.write(\"|\\n\")\n\nclass DestinationMover:\n    \"\"\"The DestinationMover attempts to move along a path to reach\n    a GameSquare. Only the final destination is returned.\n    \"\"\"\n\n    def __init__(self, *args):\n        \"\"\"Initialize the path to move to.\n\n        Arguments:\n            *args {MovementDirection} -- Path to move along.\n        \"\"\"\n        self.movement_path = list(args)\n\n    def append_path(self, *args):\n        \"\"\"Append the provided MovementDirections to the path.\n        \"\"\"\n\n        self.movement_path = self.movement_path + list(args)\n\n    def execute(self, origin):\n        \"\"\"Follow the stored movement path from the provided origin.\n        \n        Arguments:\n            origin {GameSquare} -- Position on the gameboard to be move from.\n\n        Return:\n            List of 1 item where the move terminated, or an empty list if the\n            movement path cannot be completed.\n        \"\"\"\n        current_location = origin\n        for move in self.movement_path:\n            next_location = current_location.neighbor(move)\n            if next_location == None:\n                return []\n            current_location = next_location\n        return [current_location]\n\n    def __str__(self):\n        \"\"\"Return a nice, printable representation of the DestinationMover.\n        \"\"\"\n        path = \"-\".join(p.name for p in self.movement_path)\n        return \"DestinationMover: \" + path\n\nclass VectorMover:\n    \"\"\"The VectorMover moves from an origin location in a constant direction\n    and returns each GameSquare along the movement path. The mover stops a \n    GameSquare is occupied or there is no next neighbor in the direction.\n    \"\"\"\n\n    def __init__(self, direction = None):\n        self.direction = direction\n\n    def execute(self, origin):\n        \"\"\"Follow the stored direction until there are no neighboring squares or\n        if a square is occupied.\n        \n        Arguments:\n            origin {GameSquare} -- Position on the gameboard to be move from.\n\n        Return:\n            List of squares moved along the path.\n        \"\"\"\n        if self.direction is None:\n            return []\n        \n        visited = []\n        neighbor = origin.neighbor(self.direction)\n        while neighbor is not None and not neighbor.condition.is_occupied:\n            visited.append(neighbor)\n            neighbor = neighbor.neighbor(self.direction)\n\n        return visited\n\n    def __str__(self):\n        \"\"\"Return a nice, printable representation of the VectorMover.\n        \"\"\"\n        return \"VectorMover: \" + self.direction.name\n\nclass GamePiece:\n\n    def __init__(self, inhibit_as_well_as_threaten = False):\n        self.inhibit_as_well_as_threaten = inhibit_as_well_as_threaten\n        self.location = None\n        self.movers = []\n\n    def place_on_board(self, gamesquare):\n        \"\"\"Set the piece on the specified gamesquare.\n        \n        Arguments:\n            gamesquare {GameSquare} -- Location on the gameboard to place piece.\n        \"\"\"\n        self.location = gamesquare\n        self.location.condition.is_occupied = True\n\n    def impart_force(self):\n        \"\"\"Update the game squares based on the force abilities of the\n        piece.\n\n        Arguments:\n            location {GameSquare} -- Position on the gameboard of the piece.\n\n        Returns a list of the updated game squares.\n        \"\"\"\n        if self.location is None:\n            return []\n\n        result = []\n        for mover in self.movers:\n            result = result + mover.execute(self.location)\n\n        for square in result:\n            square.condition.is_threatened = True\n            if self.inhibit_as_well_as_threaten:\n                square.condition.is_inhibited = True\n            \n        return result\n\n    def __str__(self):\n        \"\"\"Return a nice, printable representation of the GamePiece.\n        \"\"\"\n        mover_content = \"\\n  \".join([str(x) for x in self.movers])\n        r = \"\\n  \".join(['GamePiece', mover_content])\n        return r\n\ndef create_knight_movers():\n    \"\"\"Create the DestinationMovers for the possible knight moves.\n    \n    Returns:\n        [list(DesintationMover)] -- List of movers to execute knight moves.\n    \"\"\"\n\n    knight_paths = []\n    knight_paths.append((MovementDirection.NORTH,\n                         MovementDirection.NORTH,\n                         MovementDirection.WEST))\n\n    knight_paths.append((MovementDirection.NORTH,\n                         MovementDirection.NORTH,\n                         MovementDirection.EAST))\n\n    knight_paths.append((MovementDirection.NORTH,\n                         MovementDirection.WEST,\n                         MovementDirection.WEST))\n\n    knight_paths.append((MovementDirection.NORTH,\n                         MovementDirection.EAST,\n                         MovementDirection.EAST))\n\n    knight_paths.append((MovementDirection.SOUTH,\n                         MovementDirection.SOUTH,\n                         MovementDirection.WEST))\n\n    knight_paths.append((MovementDirection.SOUTH,\n                         MovementDirection.SOUTH,\n                         MovementDirection.EAST))\n\n    knight_paths.append((MovementDirection.SOUTH,\n                         MovementDirection.WEST,\n                         MovementDirection.WEST))\n\n    knight_paths.append((MovementDirection.SOUTH,\n                         MovementDirection.EAST,\n                         MovementDirection.EAST))\n\n    return [DestinationMover(*x) for x in knight_paths]\n\ndef create_rook_movers():\n    \"\"\"Create the VectorMovers for the possible rook moves.\n    \n    Returns:\n        [list(VectorMover)] -- List of movers to execute rook moves.\n    \"\"\"\n    directions = (MovementDirection.NORTH, \n                  MovementDirection.SOUTH,\n                  MovementDirection.EAST,\n                  MovementDirection.WEST)\n    return [VectorMover(direction) for direction in directions]\n\ndef create_bishop_movers():\n    \"\"\"Create the VectorMovers for the possible bishop moves.\n    \n    Returns:\n        [list(VectorMover)] -- List of movers to execute bishop moves.\n    \"\"\"\n    directions = (MovementDirection.NORTH_EAST,\n                  MovementDirection.NORTH_WEST,\n                  MovementDirection.SOUTH_EAST,\n                  MovementDirection.SOUTH_WEST)\n    return [VectorMover(direction) for direction in directions]\n\ndef create_amazon():\n    piece = GamePiece()\n\n    for mover in create_knight_movers():\n        piece.movers.append(mover)\n\n    for mover in create_rook_movers():\n        piece.movers.append(mover)\n\n    for mover in create_bishop_movers():\n        piece.movers.append(mover)\n\n    return piece\n\ndef create_king():\n    piece = GamePiece(inhibit_as_well_as_threaten=True)\n    for direction in MovementDirection:\n        mover = DestinationMover()\n        mover.append_path(direction)\n        piece.movers.append(mover)    \n\n    return piece\n\ndef chess_location_to_game_indicies(pos_string):\n    \"\"\"Convert chess locations (ex A1) to index for a gameboard.\n\n    Arguments:\n            pos_string {string} -- Chess notation location on the board.\n\n    Return:\n        (x,y) tuple to index the gameboard.\n    \"\"\"\n    first = ord(pos_string[0].upper()) - ord('A')\n    second = int(pos_string[1]) - 1\n    return (first, second)\n\ndef determine_square_status_and_update_outcome(my_condition, \n                                               neighbor_conditions, \n                                               outcome):\n    \"\"\"Determine the status of the square from the square's condition and\n    the neighboring conditions. Update and return the outcome.\n    \n    Return the outcome type.\n\n    Arguments:\n        my_condition {GameSquareConditions} -- Condition of the square to evaluate\n        neighbor_conditions {list(GameSquareConditions)} -- Conditions of nieghbors\n        outcome {Outcomes} -- Cumulative outcome of the gameboard.\n    \"\"\"\n    outcome_type = GameSquareOutcome.UNKNOWN\n    if my_condition.is_occupied or my_condition.is_inhibited:\n        return outcome_type\n\n    can_move_to_safety = any([x.is_safe for x in neighbor_conditions])\n    if my_condition.is_threatened:\n        if can_move_to_safety:\n            outcome.checks += 1\n            outcome_type = GameSquareOutcome.CHECK\n        else:\n            outcome.checkmates += 1\n            outcome_type = GameSquareOutcome.CHECKMATE\n\n    else:\n        if can_move_to_safety:\n            outcome.alives += 1\n            outcome_type = GameSquareOutcome.ALIVE\n        else:\n            outcome.stalemates += 1\n            outcome_type = GameSquareOutcome.STALEMATE\n\n    return outcome_type\n\ndef amazon_check_mate(king, amazon):\n    \n    outcomes = Outcomes()\n    king_coords = chess_location_to_game_indicies(king)\n    amazon_coords = chess_location_to_game_indicies(amazon)\n\n    board = Gameboard(8, 8)\n    king_piece = create_king()\n    amazon_piece = create_amazon()\n\n    king_piece.place_on_board(board.square_at(*king_coords))\n    amazon_piece.place_on_board(board.square_at(*amazon_coords))\n\n    king_piece.impart_force()\n    amazon_piece.impart_force()\n \n    for square in list(board.board.values()):\n        determine_square_status_and_update_outcome(square.condition,\n                                                   square.neighbor_conditions(),\n                                                   outcomes)\n\n    return outcomes.as_array()\n", "def amazon_check_mate(k, q):\n    import numpy\n    board = numpy.array([[0,1,1,1,1,1, 1, 0, 1,1,1,1,1,1,0],\n                     [1,0,1,1,1,1, 1, 0, 1,1,1,1,1,0,1],\n                     [1,1,0,1,1,1, 1, 0, 1,1,1,1,0,1,1],\n                     [1,1,1,0,1,1, 1, 0, 1,1,1,0,1,1,1],\n                     [1,1,1,1,0,1, 1, 0, 1,1,0,1,1,1,1],\n                     [1,1,1,1,1,0, 0, 0, 0,0,1,1,1,1,1],\n                     [1,1,1,1,1,0,-1,-1,-1,0,1,1,1,1,1],\n                     [0,0,0,0,0,0,-1,-2,-1,0,0,0,0,0,0],\n                     [1,1,1,1,1,0,-1,-1,-1,0,1,1,1,1,1],\n                     [1,1,1,1,1,0, 0, 0, 0,0,1,1,1,1,1],\n                     [1,1,1,1,0,1, 1, 0, 1,1,0,1,1,1,1],\n                     [1,1,1,0,1,1, 1, 0, 1,1,1,0,1,1,1],\n                     [1,1,0,1,1,1, 1, 0, 1,1,1,1,0,1,1],\n                     [1,0,1,1,1,1, 1, 0, 1,1,1,1,1,0,1],\n                     [0,1,1,1,1,1, 1, 0, 1,1,1,1,1,1,0]])\n\n    # Determine xy positions\n    qx,qy = ord(q[0])-97, int(q[1])-1\n    kx,ky = ord(k[0])-97, int(k[1])-1\n    # Place king on superboard\n    board[max(0,6+qy-ky):9+qy-ky, max(0,6-qx+kx):9-qx+kx]=-2\n    # Crop superboard\n    board = board[qy:qy+8, 7-qx:15-qx]\n    \n    # Fix board due to king's position\n    if abs(qx-kx)>1 or abs(qy-ky)>1 : # King not securing queen\n        board[board==-1] = 0; board[7-qy,qx] = 2\n    if qy==ky : # Blocking horizontal\n        if kx+2-(qx>kx)*4 >=0 : board[7-ky, kx+2-(qx>kx)*4::1-(qx>kx)*2] = 1\n    elif qx==kx : # Blocking vertical\n        if 7-ky-2+(qy>ky)*4>=0: board[7-ky-2+(qy>ky)*4::-1+(qy>ky)*2, kx] = 1\n    elif kx+ky==qx+qy : # King blocking backdiag (\\)\n        newb = board[7-ky::1-(qx>kx)*2, kx::1-(qx>kx)*2]\n        newb[newb==0] = 1\n        board[7-ky::1-(qx>kx)*2, kx::1-(qx>kx)*2] = newb\n    elif kx-ky==qx-qy : # King blocking forwdiag (/)\n        newb = board[7-ky::-1+(qx>kx)*2, kx::1-(qx>kx)*2]\n        newb[newb==0] = 1\n        board[7-ky::-1+(qx>kx)*2, kx::1-(qx>kx)*2] = newb\n    \n    # Count answers\n    ans = [0,0,0,0]\n    ansb = numpy.empty(shape=(8,8),dtype=object)\n    for nx in range(8):\n        for ny in range(8):\n            c = board[7-ny,nx]\n            if   c==1  :\n                pos = numpy.count_nonzero(board[max(0,6-ny):9-ny, max(0,nx-1):nx+2] > 0) - 1\n                if pos : ans[3] += 1; ansb[7-ny,nx] = \"o\"\n                else   : ans[2] += 1; ansb[7-ny,nx] = \"\u25a1\"\n            elif c==0  :\n                pos = numpy.count_nonzero(board[max(0,6-ny):9-ny, max(0,nx-1):nx+2] > 0)\n                if pos : ans[1] += 1; ansb[7-ny,nx] = \"+\"\n                else   : ans[0] += 1; ansb[7-ny,nx] = \"x\"\n            elif c==-1 : ans[0] += 1; ansb[7-ny,nx] = \"x\"\n            else       : ansb[7-ny,nx] = \" \" # 2 or -2, incorrect starting positions\n    print(k,q)\n    print(board)\n    print(ans)\n    print(ansb)\n    return ans", "def amazon_check_mate(king, amazon):\n    if king == amazon:\n        return []\n    king_pos = [ ord(king[1])-ord('1'), ord(king[0])-ord('a') ]\n    amazon_pos = [ ord(amazon[1])-ord('1'), ord(amazon[0])-ord('a') ]\n    board = [[' '] * 8, [' '] * 8, [' '] * 8, [' '] * 8, [' '] * 8, [' '] * 8, [' '] * 8, [' '] * 8]\n    board[king_pos[0]][king_pos[1]] = \"K\"\n    board[amazon_pos[0]][amazon_pos[1]] = 'A'\n    dirs = [[1,0],[0,1],[-1,0],[0,-1],[1,-1],[-1,1],[1,1],[-1,-1],[1,2],[2,1],[1,-2],[2,-1],[-1,2],[-2,1],[-2,-1],[-1,-2]]\n    # king\n    for i in range(8):\n        row, col = king_pos[0]+dirs[i][0], king_pos[1]+dirs[i][1]\n        if (0 <= row < 8) and (0 <= col < 8): \n            board[row][col] = 'B' if (board[row][col] == ' ') else 'C'\n    # amazon\n    for i in range(16):\n        row, col = amazon_pos[0]+dirs[i][0], amazon_pos[1]+dirs[i][1]\n        while (0 <= row < 8) and (0 <= col < 8) and board[row][col] in [' ','B']:\n            if board[row][col] == ' ':\n                board[row][col] = 'X'\n            if 8 <= i:    \n                break\n            row, col = row+dirs[i][0], col+dirs[i][1]\n    # count\n    res = [0,0,0,0]\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] not in ['K','B','A','C']:\n                check = (board[row][col] == 'X')\n                valid_around = 0\n                for i in range(8):\n                    row_, col_ = row+dirs[i][0], col+dirs[i][1]\n                    if (0 <= row_ < 8) and (0 <= col_ < 8) and board[row_][col_] in [' ','A']:\n                        valid_around += 1\n                if check:\n                    res[0 if (valid_around == 0) else 1] += 1\n                elif valid_around == 0:\n                    res[2] += 1\n                else:\n                    res[3] += 1\n    return res", "from itertools import product\n\ndef get_pos(coord):\n    x = ord(coord[0]) - ord('a')\n    y = int(coord[1]) - 1\n    return [y, x]\n\ndef place_pieces(board, king, amazon, connected):\n    coord_king = get_pos(king)\n    board[coord_king[0]][coord_king[1]] = 8\n    coord_amazon = get_pos(amazon)\n    board[coord_amazon[0]][coord_amazon[1]] = 9\n    if coord_king[0] - 1 <= coord_amazon[0] <= coord_king[0] + 1 \\\n    and coord_king[1] - 1 <= coord_amazon[1] <= coord_king[1] + 1:\n        connected[0] = 1\n    mark_attacked_squares(board, coord_king, coord_amazon)\n    \ndef mark_attacked_squares(board, coord_king, coord_amazon):\n    mark_queen(board, coord_amazon)\n    mark_knight(board, coord_amazon)\n    mark_king(board, coord_king)\n    board[coord_amazon[0]][coord_amazon[1]] = 9\n    \ndef mark_king(board, coord_king):\n    y = coord_king[0]\n    x = coord_king[1]\n    for i in product([-1, 0, 1], repeat=2):\n        if 0 <= y + i[0] < 8 and 0 <= x + i[1] < 8:\n            board[y + i[0]][x + i[1]] = 3\n    \ndef mark_knight(board, coord_amazon):\n    y = coord_amazon[0]\n    x = coord_amazon[1]\n    for i in product([-2, -1, 1, 2], repeat=2):\n        if 0 <= y + i[0] < 8 and 0 <= x + i[1] < 8:\n            if board[y + i[0]][x + i[1]] == 0:\n                board[y + i[0]][x + i[1]] = 2\n\ndef mark_queen(board, coord_amazon):\n    y = coord_amazon[0]\n    x = coord_amazon[1]\n    while y >= 0:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break\n        y -= 1\n    y = coord_amazon[0]\n    while y < 8:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break \n        y += 1\n    y = coord_amazon[0]\n    while x >= 0:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break\n        x -= 1\n    x = coord_amazon[1]\n    while x < 8:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break \n        x += 1\n    x = coord_amazon[1]\n    while x >= 0 and y >= 0:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break \n        x -= 1\n        y -= 1\n    y = coord_amazon[0]\n    x = coord_amazon[1]\n    while x < 8 and y >= 0:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break \n        x += 1\n        y -= 1\n    y = coord_amazon[0]\n    x = coord_amazon[1]\n    while x >= 0 and y < 8:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break \n        x -= 1\n        y += 1\n    y = coord_amazon[0]\n    x = coord_amazon[1]\n    while x < 8 and y < 8:\n        if board[y][x] == 0:\n            board[y][x] = 2\n        if board[y][x] == 8:\n            break \n        x += 1\n        y += 1\n    y = coord_amazon[0]\n    x = coord_amazon[1]\n\ndef check_safe(board, y, x, connected):\n    for i in product([-1, 0, 1], repeat=2):\n        if 0 <= y + i[0] < 8 and 0 <= x + i[1] < 8:\n            if not (i[0] == 0 and i[1] == 0) and \\\n            (board[y + i[0]][x + i[1]] == 0 or \\\n            (connected[0] == 0 and board[y + i[0]][x + i[1]] == 9)):\n                return 1\n    return 0\n\ndef count_states(board, connected):\n    stalemate = check = checkmate = safe = 0\n    for y in range(8):\n        for x in range(8):\n            if board[y][x] == 0:\n                if check_safe(board, y, x, connected) == 1:\n                    safe += 1\n                else:\n                    stalemate += 1\n            elif board[y][x] == 2:\n                if check_safe(board, y, x, connected) == 0:\n                    checkmate += 1\n                else:\n                    check += 1\n    return [checkmate, check, stalemate, safe]\n\ndef amazon_check_mate(king, amazon):\n    board = [[0 for i in range(8)] for j in range(8)]\n    connected = [1]\n    connected[0] = 0\n    place_pieces(board, king, amazon, connected)\n    return count_states(board, connected)\n    # 0 = safe\n    # 8 = whiteking\n    # 9 = amazon\n    # 2 = attacked\n    # 3 = black king can't be here\n", "def isaban(i, j, ki, kj):\n    if i < 0 or i > 7 or j < 0 or j > 7: return True\n    if ki - 2 < i and i < ki + 2 and kj - 2 < j and j < kj + 2: return True\n    return False\n\n\ndef ischeck(i, j, ki, kj, ai, aj):\n    if i == ai and j == aj: return False\n    # Rook\n    if i == ai:\n        if ai != ki or (kj < j and kj < aj) or (kj > j and kj > aj): return True\n    if j == aj:\n        if aj != kj or (ki < i and ki < ai) or (ki > i and ki > ai): return True\n    # Bishop\n    if i + j == ai + aj:\n        if ai + aj != ki + kj or (ki < i and ki < ai) or (ki > i and ki > ai): return True\n    if i - j == ai - aj:\n        if ai - aj != ki - kj or (ki < i and ki < ai) or (ki > i and ki > ai): return True\n    # Knight\n    Knight = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    for item in Knight:\n        if ai == i + item[0] and aj == j + item[1]: return True\n    # Not checked\n    return False\n\n\ndef ismate(i, j, ki, kj, ai, aj):\n    if i == ai and j == aj: return False\n    move = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for item in move:\n        ti, tj = i + item[0], j + item[1]\n        if not isaban(ti, tj, ki, kj):\n            if ti == ai and tj == aj: return False\n            if not ischeck(ti, tj, ki, kj, ai, aj):\n                return False\n    return True\n\n\ndef amazon_check_mate(king, amazon):\n    ki, kj = (ord(king[0]) - ord('a'), int(king[1]) - 1)\n    ai, aj = (ord(amazon[0]) - ord('a'), int(amazon[1]) - 1)\n    ans = [0, 0, 0, 0]\n    for i in range(8):\n        for j in range(8):\n            if not isaban(i, j, ki, kj):\n                if ischeck(i, j, ki, kj, ai, aj):\n                    if ismate(i, j, ki, kj, ai, aj):\n                        if i != ai or j != aj:\n                            ans[0] += 1\n                    else:\n                        ans[1] += 1\n                else:\n                    if ismate(i, j, ki, kj, ai, aj):\n                        ans[2] += 1\n                    else:\n                        ans[3] += 1\n    if not isaban(ai, aj, ki, kj): ans[3] -= 1\n    return ans", "from math import isclose\n\nadjacents = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]  # adjacents moves\nknight = [(1, -2), (1, 2), (2, -1), (2, 1), (-2, 1), (-2, -1), (-1, 2), (-1, -2)]   # knight moves\ndistance = lambda x1, y1, x2, y2: ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** .5           # distance between points\nis_diagonal=lambda a, b, i, j : abs(a - i) == abs(b - j)                            # is point A diagonally aligned with point B?\nis_ok = lambda a,b : 0<=a<8 and 0<=b<8                                              # check for corners\n\ndef amazon_check_mate(king, amazon):    \n    \n    board = [['-' for _ in range(8)] for _ in range(8)]\n    \n    king = (8 - int(king[1]), 'abcdefgh'.index(king[0]))\n    amazon = (8 - int(amazon[1]), 'abcdefgh'.index(amazon[0]))\n    \n    board[king[0]][king[1]] = 'K'\n    board[amazon[0]][amazon[1]] = 'A'\n    \n    get_adjacents=lambda i, j, s=0:[[board[i+k][j+l],(i+k,j+l)][s] for k, l in adjacents if is_ok(i+k,j+l)]        # all adjacents of point A\n\n    def assign_check():                                                                                            # assign checks to king from amazon \n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == '-' and (i == amazon[0] or j == amazon[1] or is_diagonal(*amazon,i,j)) and \\\n                  not isclose(distance(*amazon, *king) + distance(*king, i, j), distance(*amazon, i, j),abs_tol=10e-5) : board[i][j] = '#'      # is diagonally aligned and there is not king in between amazon and point A\n        for i, j in knight:                                             \n            ni, nj = amazon[0] + i, amazon[1] + j\n            if is_ok(ni,nj) and board[ni][nj] != 'K' : board[ni][nj] = '#'\n    \n    def assign_king_check():                                                      # our king checks\n        for i, j in adjacents:\n            ni, nj = king[0] + i, king[1] + j\n            if is_ok(ni,nj) and board[ni][nj] != 'A':board[ni][nj] = '$'\n      \n    def assign_checkmates():                                                      # assign checkmates from amazon\n        exceptions = set(get_adjacents(*amazon,1))\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == '#' and (i, j) not in exceptions and all(n != '-' for n in get_adjacents(i,j)): board[i][j] = '*' \n    \n    def king_amazon_adj():                                                       # special case where amazon and opp. king is adjacent\n        adj = get_adjacents(*amazon)\n        return adj.count('#') if 'K' in adj else 0\n    \n    def assign_safe_not_safe():                                                  # for condition 4\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == '-' and all(n != '-' for n in get_adjacents(i, j)) : board[i][j] = '@'\n    \n    def _count():                                                                 # count all the requiremets and characters used \n        assign_check()                                                              # '*' => checkmate\n        assign_king_check()                                                         # '#' => check\n        assign_checkmates()                                                         # '@' => king is on a safe square but it cannot make a valid move\n        assign_safe_not_safe()                                                      # '-' => on safe and can make safe move \n        d = {'*': king_amazon_adj(), '#': -king_amazon_adj(), '@': 0, '-': 0}\n        for i in board:\n            for j in i:\n                if j not in 'KA$' : d[j] += 1\n        return list(d.values())\n        \n    return _count()                                                               # return final count", "def amazon_check_mate(king, amazon):\n    ranks = '87654321'\n    fyles = 'abcdefgh'\n\n    # row,col\n    am = (ranks.index(amazon[1]), fyles.index(amazon[0]))\n    ki = (ranks.index(king[1]), fyles.index(king[0]))\n    \n    amazon_attacks = set()\n    knight_moves = [(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1),(-2,1),(-1,2)]\n    for dr,dc in knight_moves:\n        row,col = am[0]+dr, am[1]+dc\n        if 0<= row <=7 and 0<= col <=7:\n            amazon_attacks.add( (row,col) )\n    \n    rays = [(0,1),(0,-1),(1,0),(-1,0),(1,1),(1,-1),(-1,1),(-1,-1)]\n    for dr,dc in rays:\n        for d in range(1,8):\n            row,col = am[0]+d*dr, am[1]+d*dc\n            if not (0<= row <=7) or not (0<= col <=7):\n                break\n            amazon_attacks.add( (row,col) )\n            if (row,col) == ki:\n                break\n\n    king_attacks = set()\n    for dr,dc in rays:\n        row,col = ki[0]+dr, ki[1]+dc\n        if 0<= row <=7 and 0<= col <=7:\n            king_attacks.add( (row,col) )\n\n    attacked = amazon_attacks | king_attacks\n\n    def has_safe_move(r,c):\n        for dr,dc in rays:\n            row,col = r+dr,c+dc\n            if (0<= row <=7 and 0<= col <=7) and (row,col) not in attacked:\n                return True\n        return False\n    \n    checkmates, checks, stalemates, safe = 0,0,0,0\n    for r in range(8):\n        for c in range(8):\n            if (r,c) in king_attacks or (r,c) == am or (r,c) == ki:\n                continue\n            if (r,c) in attacked:\n                if has_safe_move(r,c):\n                    checks += 1\n                else:\n                    checkmates += 1\n            else:\n                if has_safe_move(r,c):\n                    safe += 1\n                else:\n                    stalemates += 1\n\n    return [checkmates,checks,stalemates,safe]", "import numpy as np\n\ndef amazon_check_mate(king, amazon):\n    nogo_board = np.full((24, 24), True)\n    nogo_board[8:16, 8:16] = False\n    king_sq = (ord(king[1]) - ord('1') + 8, ord(king[0]) - ord('a') + 8)\n    nogo_board[(king_sq[0] - 1):(king_sq[0] + 2), (king_sq[1] - 1):(king_sq[1] + 2)] = True\n    amazon_sq = (ord(amazon[1]) - ord('1') + 8, ord(amazon[0]) - ord('a') + 8)\n    for di, dj in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n        nogo_board[amazon_sq[0]  + di, amazon_sq[1] +dj] = True\n    directions = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)]\n    blocked = [False]*8\n    for ii in range(1, 8):\n        for index, dd in enumerate(directions):\n            if amazon_sq[0] + ii*dd[0] == king_sq[0] and amazon_sq[1] + ii*dd[1] == king_sq[1]:\n                blocked[index] = True\n            elif not blocked[index]:\n                nogo_board[amazon_sq[0] + ii*dd[0], amazon_sq[1] + ii*dd[1]] = True\n    if abs(king_sq[0] - amazon_sq[0]) <= 1 and abs(king_sq[1] - amazon_sq[1]) <= 1:\n        nogo_board[amazon_sq[0], amazon_sq[1]] = True\n    print(king_sq, amazon_sq)\n    answer = [0, 0, 0, 0]\n    for ii in range(8, 16):\n        for jj in range(8, 16):\n           if (abs(ii - king_sq[0]) > 1 or abs(jj - king_sq[1]) > 1) and\\\n              (ii != amazon_sq[0] or jj != amazon_sq[1]):\n               if nogo_board[(ii - 1):(ii + 2), (jj - 1):(jj + 2)].all():\n                   answer[0] += 1\n               elif nogo_board[ii, jj]:\n                   answer[1] += 1\n               elif nogo_board[(ii - 1):(ii + 2), (jj - 1):(jj + 2)].sum() == 8:\n                   answer[2] += 1\n               else:\n                   answer[3] += 1\n                   \n    return answer", "d = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\nimport numpy as np\n\n# for x,i in for range(7)\n# iam the king, what is my situation\n# en rango 1 K, es king zone\n\ndef get_area(board,x,y):\n  return board[x-1 if x-1 >= 0 else 0 : x+2 if x+2<= 8 else 8 , y-1 if y-1 >= 0 else 0 : y+2 if y+2<= 8 else 8]\n\ndef get_neig(board,x,y):\n  rtrn = []\n  if x-1>=0:\n    if y-1 >= 0: rtrn.append(board[x-1,y-1])\n    rtrn.append(board[x-1,y])\n    if y+1 <8 : rtrn.append(board[x-1,y+1])\n  if y -1 >= 0: rtrn.append(board[x,y-1])\n  if y +1 < 8 : rtrn.append(board[x,y+1])\n  if x+1 <8:\n    if y-1 >= 0: rtrn.append(board[x+1,y-1])\n    rtrn.append(board[x+1,y])\n    if y+1 <8 : rtrn.append(board[x+1,y+1])\n    \n  return rtrn\n#   area=board[x-1 if x-1 >= 0 else 0 : x+2 if x+2<= 8 else 8 , y-1 if y-1 >= 0 else 0 : y+2 if y+2<= 8 else 8]\n        \n\ndef amazon_check_mate(king, amazon):\n    print(king,amazon)\n    board = np.array([['O']*8 for i in range (8)])\n    kingx, kingy = int(king[1])-1, d[king[0]]\n    amazonx, amazony = int(amazon[1])-1, d[amazon[0]]\n    board[kingx][kingy]= 'K'\n    board[amazonx][amazony] = 'A'\n    \n    # King y alrededores\n    subarray = get_area(board,kingx,kingy)\n    for (x,y) in np.ndenumerate(subarray):\n        if y == 'O':\n          subarray[x] = \"N\" # kingzone - Non posible  (numpy slices are views of the 'parent' matrix, so it will modify board[[]])\n        if y == 'A':\n          subarray[x] = 'F' # Defended, fortified Amazon\n    \n    #Amazon y alrededores (the king breaks!!)\n    \n#     for xy in range(amazonx,len(board[0])):\n    for xy in range(amazony,8):\n      if board[amazonx, xy] == 'K': break\n      elif board[amazonx, xy] == 'O':\n        board[amazonx, xy] = 'W'\n    for xy in range(amazony,-1,-1):\n      if board[amazonx, xy] == 'K': break\n      elif board[amazonx, xy] == 'O':\n        board[amazonx, xy] = 'W'\n\n    for yx in range(amazonx,8):\n      if board[yx,amazony] == 'K': break\n      elif board[yx,amazony] == 'O':\n        board[yx,amazony] = 'W'\n    for yx in range(amazonx,-1,-1):\n      if board[yx,amazony] == 'K': break\n      elif board[yx,amazony] == 'O':\n        board[yx,amazony] = 'W'\n    \n    diag = np.diagonal(board,amazony-amazonx) #,amazony,amazonx)\n    diag.setflags(write=True)\n    if 'A' in diag:\n      for di in range(np.where(diag=='A')[0][0] ,len(diag)):\n        if diag[di] == 'K': break\n        if diag[di] == 'O':\n          diag[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n      for di in range(np.where(diag=='A')[0][0] ,-1,-1):\n        if diag[di] == 'K': break\n        if diag[di] == 'O':\n          diag[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n    if 'F' in diag:\n      for di in range(np.where(diag=='F')[0][0] ,len(diag)):\n        if diag[di] == 'K': break\n        if diag[di] == 'O':\n          diag[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n      for di in range(np.where(diag=='F')[0][0] ,-1,-1):\n        if diag[di] == 'K': break\n        if diag[di] == 'O':\n          diag[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n        \n    diag2 = np.rot90(board).diagonal(-8+amazonx+amazony+1) #,amazony,amazonx)\n    diag2.setflags(write=True)\n    if 'A' in diag2:\n      for di in range(np.where(diag2=='A')[0][0] ,len(diag2)):\n        if diag2[di] == 'K': break\n        if diag2[di] == 'O':\n          diag2[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n      for di in range(np.where(diag2=='A')[0][0] ,-1,-1):\n        if diag2[di] == 'K': break\n        if diag2[di] == 'O':\n          diag2[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n    if 'F' in diag:\n      for di in range(np.where(diag2=='F')[0][0] ,len(diag2)):\n        if diag2[di] == 'K': break\n        if diag2[di] == 'O':\n          diag2[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n      for di in range(np.where(diag2=='F')[0][0] ,-1,-1):\n        if diag2[di] == 'K': break\n        if diag2[di] == 'O':\n          diag2[di] ='W'   # In new numpy diag is also a view, so we are modifing board.\n    \n    #like a horse\n    if amazonx - 2 >= 0:\n      if amazony-1 >= 0 and board[amazonx-2,amazony-1] == 'O': board[amazonx-2,amazony-1] = 'W'\n      if amazony+1 < 8 and board[amazonx-2,amazony+1] == 'O': board[amazonx-2,amazony+1] = 'W'\n    if amazonx+2 < 8:\n      if amazony-1 >= 0 and board[amazonx+2,amazony-1] == 'O': board[amazonx+2,amazony-1] = 'W'\n      if amazony+1 < 8 and board[amazonx+2,amazony+1] == 'O': board[amazonx+2,amazony+1] = 'W'\n    if amazony -2 >= 0:\n      if amazonx-1 >= 0 and board[amazonx-1,amazony-2] == 'O': board[amazonx-1,amazony-2] = 'W'\n      if amazonx+1 < 8 and board[amazonx+1,amazony-2] == 'O': board[amazonx+1,amazony-2] = 'W'\n    if amazony +2 < 8:\n      if amazonx-1 >= 0 and board[amazonx-1,amazony+2] == 'O': board[amazonx-1,amazony+2] = 'W'\n      if amazonx+1 < 8 and board[amazonx+1,amazony+2] == 'O': board[amazonx+1,amazony+2] = 'W'\n\n    \n    # traverse\n#     if is O and no O arround, is stalemate. = S\n#     if is W and no O or A arround is checkmate = C\n    for i in range(8):\n      for j in range(8):\n        neigs = get_neig(board,i,j)\n        if board[i,j] == 'O' and neigs.count('O')==0:\n          board[i,j] = 'S'\n        if board[i,j] == 'W' and neigs.count('O')+neigs.count('A')+neigs.count('S')==0:\n          board[i,j] = 'C'\n   \n\n    checkmate,warning,stalemate,safe = 0,0,0,0\n    for p in np.nditer(board):\n      if p == 'C':\n        checkmate+=1\n      elif p == 'W':\n        warning+=1\n      elif p == 'S':\n        stalemate +=1\n      elif p == 'O':\n        safe+=1\n    return [checkmate,warning,stalemate,safe]"]
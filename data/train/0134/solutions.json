["class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        # N -> total numbers less than or equal to N\n        # We will calculate the integers with all different digits (which are less than/equal to N)\n        # Then the answer would be: N - nums_with_different_digits\n        \n        # Calculate the number of digits in N\n        NN, dd = N, 0\n        nums = [] # store the digits\n        while(NN):\n            dd += 1\n            nums.append(NN % 10)\n            NN //= 10\n        nums.reverse()\n        \n        \n        # numbers with less digits than that of N\n        numbers = 0\n        for i in range(dd-1):\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\n        \n        \n        # find the N-digit numbers (all-different)\n        already_visited_digits = set()\n        \n        def fac2(n, k):\n            return math.factorial(n) // math.factorial(n-k)\n        \n        for i,n in enumerate(nums):\n            k = 0\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\n                if(j in already_visited_digits):\n                    continue\n                k += 1\n            numbers += k * fac2(10-i-1, dd-i-1)\n            if n in already_visited_digits:\n                # All the numbers with this prefix will have at least one common digit\n                break\n            already_visited_digits.add(n)\n            \n        return N - numbers", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        ## https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digit\n#     \\\"\\\"\\\"\n#     The corner case is too hard to manage...\n\n#     count res as N - total number without duplicated digits.\n#     turns into a math and permutation problem.\n\n#     select m out of n\n#     P(m, n): n! / (n-m)!\n\n#     Algorithm:\n\n#     lets say N has k digits.\n#     1) count number less than k digits\n#     lets say number with i digits\n#     first digit 1 ~ 9, following option is 0 ~ 9 without first digit\n#     count = 9 * P(i-1,9)\n\n#     2) count number has k digits. \n#     Calculate digits with same prefix. \n#     Prefix cannot has duplicate digits.\n#     for case like 77xxx, we should stop the calculation.\n#     \\\"\\\"\\\"\n        \n        def numPerm(n, r):\n            return math.factorial(n)//math.factorial(n-r)\n        \n        \n        # N + 1 as padding.\n        nums = [int(d) for d in str(N + 1)]\n        K = len(nums) # N has K digits\n        cnt = 0 # number with no repeated val\n         # count **postive number with digits less than K\n        for i in range(1, K):\n            cnt += 9*numPerm(9, i-1)\n            \n        # count number with K digits\n        seen = set() # seen digit\n        for i in range(K): \n            # prefix = nums[:i] + currentDigit\n            # currentDigit < nums[i]\n            for x in range(1 if i == 0 else 0, nums[i]):\n                if x in seen: continue # avoid duplication\n                # cnt += P(K - (i + 1), 10 - (i + 1))\n                cnt += numPerm(10 - (i + 1), K - (i + 1))\n            \n            # since next iteration, prefix has duplicate digits, break\n            if nums[i] in seen: break\n            seen.add(nums[i])\n        \n        return N - cnt\n        \n       \n        \n", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        k = 0\n        num = []\n        t = N\n        while t:\n            num.append(t%10)\n            t = t//10\n            k += 1\n        num = num[::-1]\n        digits = [i for i in range(10)]\n        dp = [[0 for _ in range(2)] for _  in range(k+1)]\n        def count(dp, dig, state, d1, seen):\n            if dig == k:\n                return 1\n            if dp[dig][state]:\n                return dp[dig][state]\n            \n            seen.add(d1)\n            for d in digits:\n                if d in seen:\n                    continue\n                if state == 0:\n                    dp[dig][state] += count(dp, dig + 1, state, d, seen)\n                elif state == 1:\n                    if d > num[dig]:\n                        continue\n                    if d < num[dig]:\n                        dp[dig][state] += count(dp, dig + 1, state^1, d, seen)\n                    elif d == num[dig]:\n                        dp[dig][state] += count(dp, dig + 1, state, d, seen)\n            \n            seen.remove(d1)\n            return dp[dig][state]\n        \n        v = 0\n        # print(k)\n        for d in range(1, 10):\n            seen = set()\n            if d < num[0]:\n                v += count(dp, 1, 0, d, seen)\n            elif d == num[0]:\n                v += count(dp, 1, 1, d, seen)\n        \n        \n        for i in range(1, k):\n            for p in range(1, 10):\n                seen = set()\n                dp = [[0 for _ in range(2)] for _  in range(k+1)]\n                v += count(dp, i + 1, 0, p, seen)\n            # print(v)\n        # print(dp[3][0])\n        return N - v ", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        # https://leetcode.com/problems/numbers-with-repeated-digits/discuss/592922/Python-Well-commented-solution-with-easy-to-follow-recursion   \n        memo = {}\n        def f(digits_of_N, i, digits_used, any_digit):\n            if i == k:\n                return 1\n            \n            key = (i, digits_used, any_digit)\n            if key in memo:\n                return memo[key]\n            cnt = 0\n            min_digit = 1 if i == 0 else 0\n            max_digit = 9 if any_digit else digits_of_N[i]\n            for d in range(min_digit, max_digit + 1):\n                if digits_used & (1 << d) != 0:\n                    continue\n                cnt += f(digits_of_N, i + 1, digits_used | (1 << d), any_digit or (d < digits_of_N[i]))\n            \n            memo[key] = cnt\n            return cnt\n        if N <= 9:\n            return 0\n        k = len(str(N))\n        cnt = 0\n        for i in range(1, k):\n            all_possible_ints = 9 * 10**(i-1)\n            ints_with_unique_digits = 9\n            nb_choices = 9\n            for j in range(1, i):\n                ints_with_unique_digits *= nb_choices\n                nb_choices -= 1\n            cnt += all_possible_ints - ints_with_unique_digits\n            \n        all_ints_with_k_digits = N - int('9'*(k-1))\n        digits_of_N = [int(d) for d in str(N)]\n        ints_with_unique_k_digits = f(digits_of_N, 0, 0, False)\n        cnt += all_ints_with_k_digits - ints_with_unique_k_digits\n        \n        return cnt", "def f(n,s,e,ci,di,v):\n    if n==ci:\n        return 1\n    a=0\n    if (e,ci,v) in di:\n        return di[e,ci,v]\n    for i in range(10):\n            if e==0:\n                if not v>>i&1:\n                    eee=v|(1<<i)\n                    a+=f(n,s,0,ci+1,di,eee)\n            else:\n                if i>int(s[ci]):\n                    break\n                if int(s[ci])==i:\n                    if not v>>i&1:\n                        eee=v|(1<<i)\n                        a+=f(n,s,1,ci+1,di,eee)\n                    break\n                if not v>>i&1:\n                    eee=v|(1<<i)\n                    a+=f(n,s,0,ci+1,di,eee)\n    di[e,ci,v]=a\n    return a\nclass Solution:\n    def numDupDigitsAtMostN(self, n: int) -> int:\n        if n<=10:\n            return 0\n        s=str(n)\n        l=len(s)\n        ans=10\n        prev=9\n        for i in range(9,9-l+2,-1):\n            ans+= prev*i\n            prev=prev*i\n        a=0\n        di={}\n        v=0\n        for i in range(1,10):\n            if i>int(s[0]):\n                break\n            if i==int(s[0]):\n                e=1<<i\n                a+=f(l,s,1,1,di,e)\n                break\n            e=1<<i\n            a+=f(l,s,0,1,di,e)\n        return n-a-ans+1", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        digits = []\n        M=N+1\n        while M>0:\n            digits.append(M%10)\n            M//=10\n            \n        part_1 = 0\n        prod=9\n        i_1=9\n        \n        n = len(digits)\n        \n        for i in range(n-1):\n            part_1+=prod\n            # print(i,part_1,prod)\n            if i_1>1:\n                if i>0:\n                    i_1-=1\n                prod*=i_1\n        i_1=9\n        seen = set([])\n        cols = [0 for i in range(10)]\n        while len(digits)>0:\n            digit = digits.pop()\n            if len(digits)==n-1:\n                prod = digit-1\n            else:\n                prod = digit-cols[digit]\n            j_1=i_1\n            for i in range(len(digits)):\n                prod*=j_1\n                j_1-=1\n            i_1-=1\n            part_1+=prod\n            \n            if digit in seen:\n                break\n            else:\n                seen.add(digit)\n            for i in range(digit+1,10):\n                cols[i]+=1\n        return N -part_1", "def f(n,s,e,ci,di,v):\n    if n==ci:\n        return 1\n    a=0\n    if (e,ci,v) in di:\n        return di[e,ci,v]\n    for i in range(10):\n            if e==0:\n                if not v>>i&1:\n                    eee=v|(1<<i)\n                    a+=f(n,s,0,ci+1,di,eee)\n            else:\n                if i>int(s[ci]):\n                    break\n                if int(s[ci])==i:\n                    if not v>>i&1:\n                        eee=v|(1<<i)\n                        a+=f(n,s,1,ci+1,di,eee)\n                    break\n                if not v>>i&1:\n                    eee=v|(1<<i)\n                    a+=f(n,s,0,ci+1,di,eee)\n    di[e,ci,v]=a\n    return a\nclass Solution:\n    def numDupDigitsAtMostN(self, n: int) -> int:\n        if n<=10:\n            return 0\n        s=str(n)\n        l=len(s)\n        ans=10\n        prev=9\n        for i in range(9,9-l+2,-1):\n            ans+= prev*i\n            prev=prev*i\n        a=0\n        di={}\n        v=0\n        for i in range(1,10):\n            if i>int(s[0]):\n                break\n            if i==int(s[0]):\n                e=1<<i\n                a+=f(l,s,1,1,di,e)\n                break\n            e=1<<i\n            a+=f(l,s,0,1,di,e)\n        return n-a-ans+1\n", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        N = str(N)\n        \n        @lru_cache(None)\n        def dfs(i, r, m):\n            if i == len(N):\n                return 1\n            \n            ans = 0\n            limit = int(N[i]) if r else 9\n            for k in range(0,limit+1):\n                if m & (1 << k) == 0:\n                    mask =  m | (1 << k) if m or k > 0 else 0\n                    if k < limit or not r:\n                        ans += dfs(i+1, False, mask)\n                    else:\n                        ans += dfs(i+1, True, mask)\n            return ans\n        \n        return int(N) - dfs(0, True, 0) + 1", "from functools import lru_cache\nclass Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        @lru_cache(None)\n        def dfs(state, x, lz=False):\n            n = len(str(x))\n            if x < 10:\n                res = 0\n                if not lz:\n                    for i in range(1, x + 1):\n                        if state & (1 << i) == 0:\n                            res += 1\n                else:\n                    for i in range(x + 1):\n                        if state & (1 << i) == 0:\n                            res += 1\n                # print(bin(state), x, lz, res)\n                return res\n            if not lz:\n                res = dfs(state, 10 ** (n - 1) - 1)\n            else:\n                if state & 1 == 0:\n                    res = dfs(state | 1, 10 ** (n - 1) - 1, True)\n                else:\n                    res = 0\n            for i in range(1, int(str(x)[0])):\n                if state & (1 << i) == 0:\n                    res += dfs(state | (1 << i), 10 ** (n - 1) - 1, True)\n            if state & (1 << int(str(x)[0])) == 0:\n                if not (x % 10 ** (n - 1) == 0 and n >= 3):\n                    if x % 10 ** (n - 1) >= 10 ** (n - 2) or n <= 2:\n                        res += dfs(state | (1 << int(str(x)[0])), x % 10 ** (n - 1), True)\n                    elif n >= 3 and 1 & state == 0 and x % 10 ** (n - 1) >= 10 ** (n - 3):\n                        res += dfs(state | (1 << int(str(x)[0])) + 1, x % 10 ** (n - 1), True)\n            # print(bin(state), x, lz, res)\n            return res\n        \n        return N - dfs(0, N)\n", "class Solution:\n    def numDupDigitsAtMostN(self, n: int) -> int:\n        s = str(n)\n        @lru_cache(None)\n        def dp(i, smaller, nonzero, used):\n            if i==len(s):\n                return nonzero\n            ret = 0\n            if smaller:\n                for dig in range(10):\n                    if dig==0 and not nonzero:\n                        ret += dp(i+1, True, False, used)\n                    else:\n                        if (1<<dig)&used:\n                            continue\n                        ret += dp(i+1, True, True, used|(1<<dig))\n            else:\n                for dig in range(10):\n                    if dig>int(s[i]):\n                        break\n                    elif dig==int(s[i]):\n                        if (1<<dig)&used:\n                            continue\n                        ret += dp(i+1, False, True, used|(1<<dig))\n                    else:\n                        if dig==0 and not nonzero:\n                            ret += dp(i+1, True, False, used)\n                        else:\n                            if (1<<dig)&used:\n                                continue\n                            ret += dp(i+1, True, True, used|(1<<dig))\n            # print(i, smaller, nonzero, bin(used), ret)\n            return ret\n        # print(dp(0, False, False, 0))\n        return n - dp(0, False, False, 0)", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        L = list(map(int, str(N + 1)))\n        res, n = 0, len(str(N + 1))\n\n        def A(m, n):\n            return 1 if n == 0 else A(m, n - 1) * (m - n + 1)\n\n        for i in range(1, n): res += 9 * A(9, i - 1)\n        s = set()\n        for i, x in enumerate(L):\n            for y in range(0 if i else 1, x):\n                if y not in s:\n                    res += A(9 - i, n - i - 1)\n            if x in s: break\n            s.add(x)\n        return N - res\n", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        list_N = list(map(int, str(N + 1)))\n        solution = 0\n        def permutation(m, n):\n            return 1 if n == 0 else permutation(m, n - 1) * (m - n + 1)\n        for i in range(1, len(list_N)):\n            solution += 9 * permutation(9, i - 1)\n        seen_set = set()\n        for i, x in enumerate(list_N):\n            for y in range(0 if i else 1, x):\n                if y not in seen_set:\n                    solution += permutation(9 - i, len(list_N) - i - 1)\n            if x in seen_set:\n                break\n            seen_set.add(x)\n        return N - solution", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        if N < 100:\n            return N // 11\n        \n        s = str(N)\n        l = len(s)\n        \n        if l > 10:\n            return N - 8877690\n        \n        mapping = {\n         0:  0,\n         1:  9,\n         2:  90,\n         3:  738,\n         4:  5274,\n         5:  32490,\n         6:  168570,\n         7:  712890,\n         8:  2345850,\n         9:  5611770,\n         10: 8877690}\n        \n        seen = set()\n\n        for i, d in enumerate(s):\n            d = int(d)\n            if d > 0:\n                f = sum(1 for j in range((1 if i == 0 else 0), d) if j not in seen)\n                for j in range(l-i-1):\n                    f *= (9-i-j)\n                N -= f\n            \n            if i == l - 1 and d not in seen:\n                N -= 1\n            if d in seen:\n                break\n            seen.add(d)\n        return N - mapping[l-1]", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        digits = list(map(int, str(N)))\n        n = len(digits)\n        d = 0\n        for i in range(1, n):\n            d += 9 * math.factorial(9) // math.factorial(10 - i)\n        for i, j in enumerate(digits):\n            for k in range(1 if i == 0 else 0, j):\n                if k in digits[:i]:\n                    continue\n                x = 10 - i - 1\n                d += math.factorial(x) // math.factorial(x - (n - i - 1))\n            if j in digits[:i]:\n                break\n            else:\n                if i == n - 1:\n                    d += 1\n        return N - d", "class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n         # N -> total numbers less than or equal to N\n        # We will calculate the integers with all different digits (which are less than/equal to N)\n        # Then the answer would be: N - nums_with_different_digits\n        \n        # Calculate the number of digits in N\n        NN, dd = N, 0\n        nums = [] # store the digits\n        while(NN):\n            dd += 1\n            nums.append(NN % 10)\n            NN //= 10\n        nums.reverse()\n        \n        \n        # numbers with less digits than that of N\n        numbers = 0\n        for i in range(dd-1):\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\n        \n        \n        # find the N-digit numbers (all-different)\n        already_visited_digits = set()\n        \n        def fac2(n, k):\n            return math.factorial(n) // math.factorial(n-k)\n        \n        for i,n in enumerate(nums):\n            k = 0\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\n                if(j in already_visited_digits):\n                    continue\n                k += 1\n            numbers += k * fac2(10-i-1, dd-i-1)\n            if n in already_visited_digits:\n                # All the numbers with this prefix will have at least one common digit\n                break\n            already_visited_digits.add(n)\n            \n        return N - numbers", "def parcfact(m):\n    return sum([fact(m1)    for m1 in range(1,m)])\n\ndef fact(m):\n    p = 1;\n    for ii in range(m):\n        p = p*min(9,10-ii)\n    return p\n\n\nclass Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        found = {}\n        NS = str(N)        \n        res = parcfact(len(NS))\n        found = {}\n        def count(par):\n#            print(par,len(par),NS)\n            res = 0\n            if len(par)==len(NS) and par<=NS:\n                return 1\n            elif len(par)<len(NS):\n                for ii in range(10):\n                    if par.find(str(ii))<0 and par+str(ii)<=NS[:len(par)+1]:\n                        if par+str(ii)<NS[:len(par)+1]:\n                            if not(len(par)) in found:\n                                found[len(par)] = count(par+str(ii))\n                            res = res+found[len(par)]\n                        else:\n                            res = res+count(par+str(ii))\n            return res\n        for ii in range(1,int(NS[0])+1):\n            res = res+count(str(ii)) \n#        print(res,print(found))\n        return(N-res)\n"]
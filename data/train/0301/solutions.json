["class Solution:\n    def maxUncrossedLines(self, A, B):\n        # Optimization\n        #commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        #A = [x for x in A if x in commons]\n        #B = [x for x in B if x in commons]\n\n        N1, N2 = len(A), len(B)\n        dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        return dp[N1][N2]\n    \nclass Solution:\n    def maxUncrossedLines(self, A, B):\n        \n        commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n        N1, N2 = len(A), len(B)\n        dp = [0 for _ in range(N2+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            tmp = [0 for _ in range(N2+1)]\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    tmp[i2] = dp[i2-1] + 1\n                else:\n                    tmp[i2] = max(dp[i2], tmp[i2-1])\n            dp = tmp\n        return dp[N2]\n    \nfrom collections import defaultdict\nclass Solution:\n    def maxUncrossedLines(self, A, B):\n        f = defaultdict(list)\n        for idx, val in enumerate(B):\n            f[val].insert(0, idx)\n        dp = [0] * len(B)\n        for val in A:\n            for j in f[val]:\n                dp[j] = max(dp[j], max(dp[:j], default=0) + 1)\n        return max(dp)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [0] * len(B)\n        d = {}\n        for i in range(len(B)):\n            b = B[i]\n            if b in d:\n                d[b].append(i)\n            else:\n                d[b] = [i]\n        for a in A:\n            if a in d:\n                for k in d[a][::-1]:\n                    if k == 0:\n                        dp[k] = 1\n                    else:\n                        dp[k] = dp[k - 1] + 1\n                    for i in range(k + 1, len(dp)):\n                        if dp[i] < dp[i - 1]:\n                            dp[i] = dp[i - 1]\n                        else:\n                            break\n                    # print(dp)\n        return max(dp)\n        \n                    \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = defaultdict(list)\n        \n        for i, n in enumerate(B):\n            memo[n].append(i)\n           \n        @lru_cache(None)\n        def helper(index, taken):\n            if index >= len(A):\n                return 0\n            count = 0\n            if A[index] in memo:\n                for i in memo[A[index]]:\n                    if i > taken:\n                        count = 1 + helper(index+1, i)\n                        break\n            count = max(count, helper(index+1, taken))\n            return count\n            \n        return helper(0, -1)\n            \n            \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = {}\n        \n        def helper(a_idx, b_idx):\n            if (a_idx, b_idx) in memo:\n                return memo[(a_idx, b_idx)]\n            \n            if a_idx == len(A) or b_idx == len(B):\n                return 0\n            \n            c1 = 0\n            if A[a_idx] == B[b_idx]:\n                c1 = 1 + helper(a_idx + 1, b_idx + 1)\n            \n            c2 = helper(a_idx + 1, b_idx)\n            c3 = helper(a_idx, b_idx + 1)\n            \n            memo[(a_idx, b_idx)] = max(c1, c2, c3)\n            \n            return memo[(a_idx, b_idx)]\n        \n        return helper(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        dp = {}\n\n        def func(indexA, indexB):\n            if indexA == len(A) or indexB == len(B):\n                return 0\n\n            if (indexA,indexB) in dp:\n                return dp[indexA,indexB]\n\n            if A[indexA] == B[indexB]:\n                dp[indexA,indexB] = func(indexA + 1, indexB + 1) + 1\n            else:\n                dp[indexA,indexB] = max(func(indexA + 1, indexB),func(indexA, indexB + 1))\n\n            return dp[indexA,indexB]\n        \n        return func(0, 0)", "from collections import defaultdict\nfrom functools import lru_cache\n\n\nclass Solution:\n    \n    @lru_cache(None, False)\n    def solve(self, a_from: int, b_from: int):\n        if a_from >= len(self.A) or b_from >= len(self.B):\n            return 0\n        else:\n            max_line = 0\n            \n            for b_pos in self.b_index[self.A[a_from]]:\n                if b_pos >= b_from:\n                    if_draw = 1 + self.solve(a_from+1, b_pos+1)\n                    max_line = max(max_line, if_draw)\n            max_line = max(self.solve(a_from+1, b_from), max_line)\n            \n            return max_line\n            \n    \n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        self.A = A\n        self.B = B\n        \n        self.b_index = defaultdict(list)\n        \n        for i, b in enumerate(B):\n            self.b_index[b].append(i)\n        \n        return self.solve(0, 0)\n            \n            \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        def help(i, j, mem):\n            if i>=len(A) or j>=len(B):\n                return 0\n            if (i,j) in mem:\n                return mem[(i,j)]\n            if A[i]==B[j]:\n                mem[(i, j)] = 1 + help(i+1, j+1, mem)\n                return mem[(i,j)]\n            mem[(i, j)] = max(help(i+1, j, mem), help(i, j+1, mem))\n            return mem[(i, j)]\n        mem = {}\n        return help(0, 0, mem)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        return self.findMaxConnectLines(0, 0, A, B, {})\n        \n        \n    def findMaxConnectLines(self, i, j, A, B, dic):\n        if i == len(A) or j == len(B):\n            return 0\n        \n        if (i, j) in dic: return dic[(i, j)]\n        \n        a = self.findMaxConnectLines(i+1, j, A, B, dic)\n        b = float('-inf')\n        for k in range(j, len(B)):\n            if B[k] == A[i]:\n                b = self.findMaxConnectLines(i+1, k+1, A, B, dic) + 1\n                break\n        dic[(i, j)] = max(a, b)\n        return dic[(i, j)]\n        \n        \n        \n#   1, 4, 2 ,3, 5\n#   1, 2, 3, 5, 4\n#   every number has choices: not connect or connect (first encounter connect)\n# \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = {}\n        return self.helper(0,0,A,B,memo)\n            \n    def helper(self,a_index,b_index,A,B,memo):\n        if a_index == len(A) or B == len(B):\n            return 0\n        elif (a_index,b_index) in memo:\n            return memo[(a_index,b_index)]\n        else:\n            put_ = 0\n            noput_ = 0\n            for i in range(b_index,len(B)):\n                if B[i] == A[a_index]:\n                    put_ =  1 + self.helper(a_index + 1,i + 1,A,B,memo)\n                    break\n            noput_ =  self.helper(a_index + 1,b_index,A,B,memo)\n            memo[(a_index,b_index)] = max(put_,noput_)\n            return memo[(a_index,b_index)]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = {}\n        \n        def helper(a_idx, b_idx):\n            if a_idx == len(A) or b_idx == len(B):\n                return 0\n            \n            if (a_idx, b_idx) in memo:\n                return memo[(a_idx, b_idx)]\n            \n            c1 = 0\n            if A[a_idx] == B[b_idx]:\n                c1 = 1 + helper(a_idx + 1, b_idx + 1)\n            \n            c2 = helper(a_idx + 1, b_idx)\n            c3 = helper(a_idx, b_idx + 1)\n            \n            memo[(a_idx, b_idx)] = max(c1, c2, c3)\n            \n            return memo[(a_idx, b_idx)]\n        \n        return helper(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        b_dict = {}\n        for idx, b in enumerate(B):\n            if b not in b_dict:\n                b_dict[b] = []\n            b_dict[b].append(idx)\n        a_ptrs = []\n        for key in b_dict:\n            b_dict[key].reverse()\n        for a in A:\n            if a in b_dict:\n                a_ptrs = a_ptrs + b_dict[a]\n        lis = []\n        for idx, a in enumerate(a_ptrs):\n            lis_len = 0\n            for i in reversed(range(idx)):\n                if a_ptrs[i] < a:\n                    lis_len = max(lis_len, lis[i])\n            lis_len += 1\n            lis.append(lis_len)\n        if len(lis) == 0:\n            return 0\n        return max(lis)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if len(A)>len(B): A, B=B, A\n        DP=[0]* (len(A)+1)\n        coll={j:[-1]+[i for i in range(len(A)) if A[i]==j] for j in set(B)}\n        for iB in B[::-1]:\n            for i in range(1, len(coll[iB])):\n                DP[coll[iB][i]] = max(DP[coll[iB][i]], DP[coll[iB][i]+1]+1)\n                for j in range(coll[iB][i], coll[iB][i-1], -1):\n                    DP[j]=max(DP[j], DP[j+1])\n        return DP[0]\n", "def longest_substr(A, B, i, j, cache):\n    if i == len(A) or j == len(B):\n        return 0\n    \n    res = cache.get(i, {}).get(j, None)\n    if res is not None:\n        return res\n    \n    length1 = 0\n    if A[i] == B[j]:\n        length1 = 1 + longest_substr(A, B, i + 1, j + 1, cache)\n    length2 = longest_substr(A, B, i + 1, j, cache)\n    length3 = longest_substr(A, B, i, j + 1, cache)\n    \n    length = max(length1, length2, length3)\n    cache[i][j] = length\n    return length\n        \n\n\nclass Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        cache = defaultdict(dict)\n        return longest_substr(A, B, 0, 0, cache)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        from bisect import bisect\n        \n        a, b = len(A), len(B)\n        indA = defaultdict(list)\n        indB = defaultdict(list)\n        for i,num in enumerate(A):\n            indA[num].append(i)\n        for i,num in enumerate(B):\n            indB[num].append(i)\n        \n        dp = {}\n        for i, num1 in enumerate(A):\n            for j, num2 in enumerate(B):\n                if num1 == num2:\n                    dp[(i,j)] = 1 + (dp[(i-1,j-1)] if min(i,j) > 0 else 0)\n                else:\n                    ii = bisect(indB[num1], j) if num1 in indB else 0\n                    jj = bisect(indA[num2], i) if num2 in indA else 0\n                    iii = -1 if ii == 0 else indB[num1][ii-1]\n                    jjj = -1 if jj == 0 else indA[num2][jj-1]\n                    dp[i,j] = dp[i-1,j-1] if min(i,j)>0 else 0\n                    if iii >= 0:\n                        dp[i,j] = max(dp[i,j], 1+dp[i-1,iii-1] if min(i,iii)>0 else 1)\n                    if jjj >= 0:\n                        dp[i,j] = max(dp[i,j], 1+dp[jjj-1,j-1] if min(j,jjj)>0 else 1)\n        \n        return dp[a-1,b-1]\n                          \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = collections.defaultdict(int)\n        m, n = len(A), len(B)\n        \n        for x in range(m):\n            for y in range(n):\n                cur = 0\n                if A[x] == B[y]:\n                    cur = 1\n                dp[(x, y)] = max(dp[(x - 1, y - 1)] + cur, dp[(x - 1, y)], dp[(x, y - 1)])\n                \n        return dp[(m - 1, n - 1)]", "class Solution:\n    def fonction(self, a, b, i, j, dp):\n        if j==len(b) or i==len(a):\n            return 0\n        if dp[i][j]!=-1:\n            return dp[i][j]\n        if a[i]==b[j]:\n            dp[i][j] = 1+self.fonction(a,b,i+1,j+1,dp) \n            return dp[i][j]\n        dp[i][j] = max(self.fonction(a,b,i+1,j+1,dp),self.fonction(a,b,i,j+1,dp),self.fonction(a,b,i+1,j,dp))\n        return dp[i][j]\n    \n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = []\n        for i in range(len(A)):\n            dp.append([-1] * len(B))\n        return self.fonction(A,B,0,0,dp)", "class Solution:\n    def build_value_index_map(self,arr):\n        value_idx_map = collections.defaultdict(list)\n        \n        for i in range(len(arr)):\n            value_idx_map[arr[i]].append(i)\n        return value_idx_map\n        \n        \n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        b_value_idx_map = self.build_value_index_map(B)\n        \n        \n        memo = {}\n        \n        def helper(a_idx,b_max_idx,memo):\n            if a_idx == len(A) or b_max_idx == len(B):\n                return 0\n            \n            \n            if (a_idx,b_max_idx) in memo:\n                return memo[a_idx,b_max_idx]\n            \n            curr_num = A[a_idx]                \n            res = 0\n\n            for b_idx in b_value_idx_map.get(curr_num,[]):\n                if b_idx > b_max_idx:\n                    temp = 1 + helper(a_idx+1,b_idx,memo)\n                    res = max(res,temp)\n            \n            memo[a_idx,b_max_idx] = max(res,helper(a_idx+1,b_max_idx,memo))\n            return memo[a_idx,b_max_idx]\n    \n        res=  helper(0,-1,memo)\n        return res\n            \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m, n = len(A), len(B)\n        if m == 0 or n == 0: return 0\n        memo = dict()\n        def dfs(i, j):\n            if i == m or j == n:\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            res = max(dfs(i+1, j), dfs(i, j+1))\n            if A[i] == B[j]:\n                res = max(res, 1 + dfs(i+1, j+1))\n            memo[(i, j)] = res\n            return res\n        return dfs(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        B_index = collections.defaultdict(list)\n        for i in range(len(B)):\n            B_index[B[i]].append(i)\n    \n        memory = {}\n    \n        def helper(A_i_, B_i):\n            \n            A_i = A_i_\n            if (A_i, B_i) in memory:\n                return memory[(A_i, B_i)]\n            \n            while A_i < len(A):\n                \n                # check A match with B:\n                if A[A_i] in B_index:\n                    for b_i in B_index[A[A_i]]:\n                        if b_i < B_i:\n                            continue\n                        res = max(1 + helper(A_i+1, b_i+1), helper(A_i+1, B_i))\n                        memory[(A_i_, B_i)] = res   \n                        return res\n    \n                A_i += 1\n            \n            memory[(A_i_, B_i)] = 0\n            return 0\n        \n        return helper(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        cache = {}\n        def recur(A,B,i,j):\n            key = str(i) + '$' + str(j)\n            if key in cache:\n                return cache[key]\n            if i >= len(A) or j >= len(B):\n                cache[key] = 0\n                return cache[key]\n            if A[i] == B[j]:\n                cache[key] = 1 + recur(A,B, i + 1, j + 1)\n            else:\n                cache[key] = max(recur(A,B, i + 1, j), recur(A,B,i,j + 1))\n            return cache[key]\n        return recur(A,B,0,0);\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m, n = len(A), len(B)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n      \n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                left = dp[i][j-1] \n                up = dp[i-1][j]\n                leftup = dp[i-1][j-1]\n                dp[i][j] = max(left, up, leftup + int(A[i-1]==B[j-1]))\n                print(left, up, leftup)\n        \n        return dp[m][n]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = []\n        for i in range(len(A)):\n            dp.append([0] * len(B))\n\n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    dp[i][j] = max(dp[i][j],1)\n                    if i - 1 >= 0 and j - 1 >= 0 :\n                        dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1)\n\n                else:\n                    if i - 1 >= 0 and j - 1 >= 0:\n                        dp[i][j] = max(dp[i][j],dp[i-1][j-1])\n                    if j - 1 >= 0:\n                        dp[i][j] = max(dp[i][j],dp[i][j-1])\n                    if i - 1 >= 0:\n                        dp[i][j] = max(dp[i][j],dp[i-1][j])\n        return dp[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        @lru_cache(None)\n        def helper(i: int, j: int) -> int:\n            if i < 0 or j < 0:\n                return 0\n            return max([\n                helper(i - 1, j - 1) + (A[i] == B[j]),\n                helper(i - 1, j),\n                helper(i, j - 1)\n            ])\n        \n        return helper(len(A) - 1, len(B) - 1)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m, n = len(A), len(B)\n        dp = [[0] * n for _ in range(m)]\n        \n        # dp[0][0] = int(A[0] == B[0])\n        \n        for i in range(m):\n            for j in range(n):\n                left = dp[i][j-1] if j>0 else 0\n                up = dp[i-1][j] if i>0 else 0\n                leftup = dp[i-1][j-1] if i>0 and j>0 else 0\n                dp[i][j] = max(left, up, leftup + int(A[i]==B[j]))\n                print(left, up, leftup)\n        \n        return dp[m-1][n-1]", "from collections import defaultdict\n\nclass Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:        \n        dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        vals_A = defaultdict(list)\n        for i in range(len(A)):\n            vals_B = defaultdict(list)\n            for j in range(len(B)):\n                dp[i + 1][j + 1] = max(dp[i][j], dp[i + 1][j], dp[i][j + 1])\n                if A[i] == B[j]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1)\n\n                for pos in vals_A[B[j]]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[pos][j] + 1)\n                for pos in vals_B[A[i]]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][pos] + 1)\n\n                vals_B[B[j]] += [j]\n            \n            vals_A[A[i]] += [i]\n            \n        return dp[len(A)][len(B)]", "from collections import defaultdict\n\nclass Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if len(A) < len(B):\n            A, B = B, A\n        \n        dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        vals_A = defaultdict(list)\n        for i in range(len(A)):\n            vals_B = defaultdict(list)\n            for j in range(len(B)):\n                dp[i + 1][j + 1] = max(dp[i][j], dp[i + 1][j], dp[i][j + 1])\n                if A[i] == B[j]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1)\n\n                for pos in vals_A[B[j]]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[pos][j] + 1)\n                for pos in vals_B[A[i]]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][pos] + 1)\n\n                vals_B[B[j]] += [j]\n            \n            vals_A[A[i]] += [i]\n            \n        return dp[len(A)][len(B)]", "from collections import defaultdict\n\nclass Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = {}\n        \n        def r_search(aindex, bindex):\n            if aindex == len(A) or bindex == len(B):\n                return 0\n            if (aindex, bindex) in memo:\n                return memo[(aindex, bindex)]\n            \n            best = 0\n            best = max(best, r_search(aindex + 1, bindex))\n            best = max(best, r_search(aindex, bindex + 1))\n            if A[aindex] == B[bindex]:\n                best = max(best, r_search(aindex + 1, bindex + 1) + 1)\n            memo[(aindex, bindex)] = best\n            return best\n        \n        return r_search(0, 0)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        # self.res = float('-inf')\n        self.A, self.B = A, B\n        self.seen = {}\n        return self.dfs(0, 0)\n                \n    def dfs(self, a, b):\n            m, n = len(self.A), len(self.B)\n            if a >= m or b >= n:\n                return 0\n            if (a, b) in self.seen:\n                return self.seen[(a, b)]\n            \n            res = float('-inf')\n            cur_b = b\n            if self.A[a] == self.B[b]:\n                res = max(res, self.dfs(a + 1, b + 1) + 1)\n#             while cur_b < n:\n#                 if self.A[a] == self.B[cur_b]:\n#                     res = max(res, self.dfs(a + 1, cur_b + 1) + 1)\n#                     break\n#                 cur_b += 1\n                \n#             cur_a = a\n#             while cur_a < m:\n#                 # print(cur_a, b)\n#                 if self.A[cur_a] == self.B[b]:\n#                     res = max(res, self.dfs(cur_a + 1, b + 1) + 1)\n#                     break\n#                 cur_a += 1\n            res = max(res, self.dfs(a + 1, b))\n            res = max(res, self.dfs(a, b + 1))\n            \n            self.seen[(a, b)] = res\n            return res", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        # self.res = float('-inf')\n        self.A, self.B = A, B\n        self.seen = {}\n        return self.dfs(0, 0)\n                \n    def dfs(self, a, b):\n            if a >= len(self.A) or b >= len(self.B):\n                return 0\n            if (a, b) in self.seen:\n                return self.seen[(a, b)]\n            \n            res = float('-inf')\n            if self.A[a] == self.B[b]:\n                res = max(res, self.dfs(a + 1, b + 1) + 1)\n            res = max(res, self.dfs(a + 1, b))\n            res = max(res, self.dfs(a, b + 1))\n            \n            self.seen[(a, b)] = res\n            return res", "class Solution:\n    def getMaxUncrossedLinesFrom(self, A, B, min_a_ix, min_b_ix):\n        max_count = 0\n        key = (min_a_ix, min_b_ix)\n        if key in self.cache:\n            return self.cache[key]\n        \n        for i_a in range(min_a_ix, len(A)):\n            val_a = A[i_a]\n            b_match_indexes = self.b_lookup.get(val_a)\n            if not b_match_indexes:\n                continue\n            for b_ix in b_match_indexes:\n                if b_ix >= min_b_ix:\n                    ct = 1 + self.getMaxUncrossedLinesFrom(A, B, i_a + 1, b_ix + 1)\n                    max_count = max(max_count, ct)\n        self.cache[key] = max_count\n        return max_count\n    \n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        b_lookup = defaultdict(list)\n        for i, n in enumerate(B):\n            b_lookup[n].append(i)\n        self.b_lookup = b_lookup\n        self.cache = {}\n        \n        return self.getMaxUncrossedLinesFrom(A, B, 0, 0)\n", "from functools import lru_cache\n\n\nclass Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        len_a = len(A)\n        len_b = len(B)\n        \n        @lru_cache(None)\n        def helper(i, j):\n            nonlocal A, B, len_a, len_b, b_index_data\n\n            if i >= len_a or j >= len_b:\n                return 0\n\n            ans = float('-inf')\n            for x in b_index_data.get(A[i], []):\n                if x >= j:\n                    ans = 1 + helper(i + 1, x + 1)\n                    break\n            return max(ans, helper(i + 1, j))\n\n        b_index_data = {}\n        for i, val in enumerate(B):\n            l = b_index_data.setdefault(val, [])\n            l.append(i)\n\n        return helper(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if len(A) <len(B):\n            A,B = B,A\n        n = len(B)\n        prev = [0] * (n+1)\n        for i in range(1,n+1):\n            if A[0] == B[i-1]:\n                prev[i] = 1\n            else:\n                prev[i] = prev[i-1]\n        curr = [0] * (n+1)\n        for i in range(1,len(A)):\n            for j in range(1,n+1):\n                if A[i] == B[j-1]:\n                    curr[j] = 1+prev[j-1]\n                else:\n                    curr[j] = max(curr[j-1],prev[j])\n            prev,curr = curr,prev\n        return prev[-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        prev, crnt = [0] * (1 + len(B)), [0] * (1 + len(B))\n        for a in range(len(A)):\n            prev, crnt = crnt, prev\n            for b in range(len(B)):\n                if A[a] == B[b]:\n                    crnt[b + 1] = prev[b] + 1\n                else:\n                    crnt[b + 1] = max(crnt[b], prev[b + 1])\n        return crnt[len(B)]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if len(A)<len(B): A, B=B, A\n        DP=[0]* (len(A)+1)\n        coll={j:[-1] for j in set(B)}\n        for i in range(len(A)):\n            if A[i] in coll: coll[A[i]].append(i)\n        \n        for iB in B[::-1]:\n            for i in range(1, len(coll[iB])):\n                if DP[coll[iB][i]]<DP[coll[iB][i]+1]+1:\n                    DP[coll[iB][i]] = DP[coll[iB][i]+1]+1\n                    for j in range(coll[iB][i], coll[iB][i-1], -1):\n                        DP[j]=max(DP[j], DP[j+1])\n        return DP[0]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        ga = collections.defaultdict(list)\n        # gb = collections.defaultdict(list)\n        \n        for i, v in enumerate(A):\n            ga[v].append(i)\n            \n        # for j, v in enumerate(B):\n        #     gb[v].append(j)\n            \n        def pd(i, start_a):\n            if i >= len(B) or start_a >= len(A):\n                return 0\n            \n            if (i, start_a) in memo:\n                return memo[(i, start_a)]\n            \n            res = pd(i + 1, start_a)\n            \n            if B[i] in ga:\n                \n                new_start_a = -1\n                \n                for cand in ga[B[i]]:\n                    if cand > start_a:\n                        new_start_a = cand\n                        break\n                        \n                if new_start_a >= start_a:\n                    res = max(res, 1 + pd(i + 1, new_start_a))\n                \n            memo[(i, start_a)] = res\n            \n            return res\n        \n        memo = dict()\n        \n        return pd(0, -1)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m = len(A)\n        n = len(B)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        # dp[0][0] = 1\n        for i in range(1, m+1):\n            if A[i-1] == B[0]:\n                dp[i][1] = 1\n        for j in range(1, n+1):\n            if B[j-1] == A[0]:\n                dp[1][j] = 1\n                \n        for i, a in enumerate(A, 1):\n            for j, b in enumerate(B, 1):\n                if a == b:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        M, N = len(A), len(B)\n        dp = [0]*(N+1)\n        res = 0\n        for i in range(1, M+1):\n            dp2 = [0]*(N+1)\n            for j in range(1, N+1):\n                if A[i-1]==B[j-1]:\n                    dp2[j] = dp[j-1]+1\n                else:\n                    dp2[j] = max(dp[j], dp2[j-1])\n            \n            dp = dp2\n            res = max(res, max(dp))\n                \n        return res", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [[0] * (len(B)+1) for _ in range(2)]\n        flag = 1\n        \n        for i in range(len(A)-1, -1, -1):\n            for j in range(len(B)-1, -1, -1):\n                if A[i] == B[j]:\n                    dp[flag][j] = dp[flag^1][j+1] + 1\n                else:\n                    dp[flag][j] = max(dp[flag][j+1], dp[flag^1][j])\n            flag ^= 1\n        \n        return dp[flag^1][0]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        A = [-1] + A\n        B = [-1] + B\n        lenA, lenB = len(A), len(B)\n        dp = [[0] * lenA for _ in range(lenB)]\n        for y in range(1, lenB):\n            for x in range(1, lenA):\n                if A[x] == B[y]:\n                    dp[y][x] = dp[y-1][x-1] + 1\n                else:\n                    dp[y][x] = max(dp[y-1][x], dp[y][x-1])\n        \n        return dp[-1][-1]\n    \n    \n#             A = [ -1 ] + A\n#         B = [ -1 ] + B\n        \n#         h, w = len(A), len(B)\n#         dp_table = [ [ 0 for _ in range(w) ] for _ in range(h) ]\n        \n        \n        \n#         for y in range(1, h):\n#             for x in range(1, w):\n                \n#                 if A[y] == B[x]:\n#                     # current number is matched, add one more uncrossed line\n#                     dp_table[y][x] = dp_table[y-1][x-1] + 1\n                    \n#                 else:\n#                     # cuurent number is not matched, backtracking to find maximal uncrossed line\n#                     dp_table[y][x] = max( dp_table[y][x-1], dp_table[y-1][x] )\n\n                    \n#         return dp_table[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        l,w = len(A), len(B)\n        dp = [[0]*(w+1) for _ in range(l+1)]\n        for i in range(l):\n            for x in range(w):\n                if A[i] == B[x]:\n                    dp[i+1][x+1] = dp[i][x] + 1\n                else:\n                    dp[i+1][x+1] = max(dp[i+1][x], dp[i][x+1])\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if(len(A)==0 or len(B)==0):\n            return 0\n        A = [ -1 ] + A\n        B = [ -1 ] + B\n        res = [ [ 0 for _ in range(len(B)) ] for _ in range(len(A)) ]\n        for i in range(1,len(A)):\n            for j in range(1,len(B)):\n                if(A[i]==B[j]):\n                    res[i][j]=res[i-1][j-1]+1\n                else:\n                    res[i][j]=max(res[i-1][j],res[i][j-1])\n        return res[-1][-1]\n                \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        # A = [-1] + A\n#         B = [-1] + B\n#         lenA, lenB = len(A), len(B)\n#         dp = [[0] * lenB for _ in range(lenA)]\n#         for y in range(lenA):\n#             for x in range(lenB):\n#                 if A[y] == B[x]:\n#                     dp[y][x] = dp[y-1][x-1] + 1\n#                 else:\n#                     dp[y][x] = max(dp[y-1][x], dp[y][x-1])\n        \n#         return dp[-1][-1]\n    \n    \n        A = [ -1 ] + A\n        B = [ -1 ] + B\n        \n        h, w = len(A), len(B)\n        dp_table = [ [ 0 for _ in range(w) ] for _ in range(h) ]\n        \n        \n        \n        for y in range(1, h):\n            for x in range(1, w):\n                \n                if A[y] == B[x]:\n                    # current number is matched, add one more uncrossed line\n                    dp_table[y][x] = dp_table[y-1][x-1] + 1\n                    \n                else:\n                    # cuurent number is not matched, backtracking to find maximal uncrossed line\n                    dp_table[y][x] = max( dp_table[y][x-1], dp_table[y-1][x] )\n\n                    \n        return dp_table[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        # padding one dummy -1 to represent empty list\n        A = [ -1 ] + A\n        B = [ -1 ] + B\n        \n        h, w = len(A), len(B)\n        dp_table = [ [ 0 for _ in range(w) ] for _ in range(h) ]\n        \n        \n        \n        for y in range(1, h):\n            for x in range(1, w):\n                \n                if A[y] == B[x]:\n                    # current number is matched, add one more uncrossed line\n                    dp_table[y][x] = dp_table[y-1][x-1] + 1\n                    \n                else:\n                    # cuurent number is not matched, backtracking to find maximal uncrossed line\n                    dp_table[y][x] = max( dp_table[y][x-1], dp_table[y-1][x] )\n\n                    \n        return dp_table[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [[0 for b in range(len(B)+1)] for a in range(len(A)+1)]\n        \n        for a in range(1, len(A)+1):\n            for b in range(1, len(B)+1):\n                if A[a-1] == B[b-1]:\n                    dp[a][b] = dp[a-1][b-1] + 1\n                else:\n                    dp[a][b] = max(dp[a-1][b], dp[a][b-1])\n        \n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A, B):\n        # Optimization\n        #commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        #A = [x for x in A if x in commons]\n        #B = [x for x in B if x in commons]\n\n        N1, N2 = len(A), len(B)\n        dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        return dp[N1][N2]\n    \nclass Solution:\n    def maxUncrossedLines(self, A, B):\n        \n        commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n        N1, N2 = len(A), len(B)\n        dp = [0 for _ in range(N2+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            tmp = [0 for _ in range(N2+1)]\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    tmp[i2] = dp[i2-1] + 1\n                else:\n                    tmp[i2] = max(dp[i2], tmp[i2-1])\n            dp = tmp\n        return dp[N2]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        lenA, lenB = len(A), len(B)\n        dp = [[0 for _ in range(lenB+1)] for _ in range(lenA + 1) ]\n        for i in range(lenA):\n            for j in range(lenB):\n                if A[i]==B[j]:\n                    dp[i+1][j+1] = 1 + dp[i][j]\n                else:\n                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])\n        #print(dp)\n        return dp[lenA][lenB]\n", "class Solution:\n    def maxUncrossedLines(self, A, B):\n        dp = [[0 for j in range(len(B)+1)] for i in range(len(A)+1)]\n\n        for i in range(1,len(A)+1):\n            for j in range(1,len(B)+1):\n                if A[i-1] == B[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        len_a = len(A)+1\n        len_b = len(B)+1\n\n        dp = [[0 for i in range(len_b)] for i in range(len_a)]\n\n        for i in range(1, len_a):\n            for j in range(1, len_b):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[len_a-1][len_b-1] ", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n                # padding one dummy -1 to represent empty list\n        A = [ 1 ] + A\n        B = [ 1 ] + B\n        \n        h, w = len(A), len(B)\n        dp_table = [ [ 0 for _ in range(w) ] for _ in range(h) ]\n        \n        \n        \n        for y in range(1, h):\n            for x in range(1, w):\n                \n                if A[y] == B[x]:\n                    # current number is matched, add one more uncrossed line\n                    dp_table[y][x] = dp_table[y-1][x-1] + 1\n                    \n                else:\n                    # cuurent number is not matched, backtracking to find maximal uncrossed line\n                    dp_table[y][x] = max( dp_table[y][x-1], dp_table[y-1][x] )\n\n                \n        print (dp_table)\n        return dp_table[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        # idea: 0. dp[i, j] is the max number of uncrossed lines in A[0,i] and B[0,j]\n        #       1. init: fill dp with 0\n        #       2. transition function: loop(expand) B for each in A\n        #           dp[i][j] = max(dp[i-1][j],dp[i][j-1]) to have at least the same number supposing when A[i] was expanded, it won't be connected; or B[j] was expanded, it won't be connected;\n        #           then if B[j-1] == A[i-1], dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)\n        # time: O( len(A) x len(B) )\n        # space:O( len(A) x len(B) )\n        \n        dp: List[List[int]] = [[0 for i in range(len(B)+1)] for j in range(len(A)+1)]\n        for i in range(1, len(A)+1):\n            for j in range(1, len(B)+1):\n                dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n                if B[j-1] == A[i-1]:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)\n        return dp[len(A)][len(B)]\n        \n        \n        \n        \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        La = len(A)\n        Lb = len(B)\n        dp = [[0]*Lb  for i in range(La)]\n        \n        for i in range(La):\n            for j in range(Lb):\n                if i==0:\n                    if A[i]==B[j]:\n                        dp[i][j] = 1\n                    elif j!=0:\n                        dp[i][j] = dp[i][j-1]\n                else:\n                    if j==0:\n                        if A[i]==B[j]:\n                            dp[i][j] = 1\n                        else:\n                            dp[i][j] = dp[i-1][j]\n                    else:\n                        \n                        if A[i]==B[j]:\n                            dp[i][j] = dp[i-1][j-1] + 1\n                        else:\n                            dp[i][j] = dp[i-1][j] \n                        dp[i][j] = max(dp[i][j],dp[i][j-1])\n        #print(dp)\n        return dp[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        for i in range(len(A)):\n            for j in range(len(B)):\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j], dp[i][j] + (A[i] == B[j]))\n        return dp[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        rows = len(A)\n        cols = len(B)\n        dp = [[0 for i in range(cols+1)] for j in range(rows+1)]\n        \n        for i in range(rows):\n            for j in range(cols):\n                if A[i]==B[j]:\n                    dp[i+1][j+1]= 1 + dp[i][j]\n                else:\n                    dp[i+1][j+1]= max(dp[i][j+1],dp[i+1][j],dp[i][j])\n        \n        return dp[rows][cols]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m=len(A)\n        n=len(B)\n        dp=[[0 for i in range(n+1)] for j in range(m+1)]\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if A[i-1]==B[j-1]:\n                    dp[i][j]=1+dp[i-1][j-1]\n                else:\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])\n        return dp[m][n]", "class Solution:\n    def maxUncrossedLines(self, A, B):\n        # Optimization\n        #commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        #A = [x for x in A if x in commons]\n        #B = [x for x in B if x in commons]\n\n        N1, N2 = len(A), len(B)\n        dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        return dp[N1][N2]\n    \nclass Solution:\n    def maxUncrossedLines(self, A, B):\n        commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n        N1, N2 = len(A), len(B)\n        dp = [0 for _ in range(N2+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            tmp = [0 for _ in range(N2+1)]\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    tmp[i2] = dp[i2-1] + 1\n                else:\n                    tmp[i2] = max(dp[i2], tmp[i2-1])\n            dp = tmp\n        return dp[N2]\n    \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [[0 for i in range(len(B) + 1)] for j in range(len(A) + 1)]\n        \n        for i in range(len(A)):\n            for j in range(len(B)):\n                if A[i] == B[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                \n                else:\n                    dp[i + 1][j + 1] = max(dp[i][j], dp[i][j + 1], dp[i + 1][j])\n\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if((len_A := len(A)) == 0 or (len_B := len(B)) == 0):\n            return 0\n        matrix = [[0 for i in range(len_B+1)] for k in range(len_A + 1)]\n        for i in range(1, len_A+1):\n            for k in range(1, len_B+1):\n                if(A[i-1] == B[k-1]):\n                    matrix[i][k] = matrix[i-1][k-1] + 1\n                else:\n                    matrix[i][k] = max(matrix[i-1][k-1], matrix[i-1][k], matrix[i][k-1])\n        return matrix[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        self.result = 0\n        mem = collections.defaultdict()\n        n = len(A)\n        m = len(B)\n        def dfs(pos_a, pos_b):\n            if pos_a >= n or pos_b >= m:\n                return 0\n            if (pos_a, pos_b) in mem:\n                return mem[(pos_a, pos_b)]\n            best = 0\n            for i in range(pos_a, n):\n                for j in range(pos_b, m):\n                    if A[i] == B[j]:\n                        best = max(best, dfs(i+1, j+1) + 1)\n                    best = max(best, dfs(i+1, j), dfs(i, j+1))\n            mem[(pos_a, pos_b)] = best\n            return best\n        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if A[i-1] == B[j-1]:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)\n                dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i][j-1])\n        return dp[-1][-1]\n        #return dfs(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if not A or not B:\n            return 0\n        \n        dp = [[0 for _ in range(len(A)+1)] for _ in range(len(B)+1)]\n        \n        for i in range(len(B)+1):\n            for j in range(len(A)+1):\n                if i==0 or j==0:\n                    dp[i][j]=0\n                elif B[i-1]==A[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i][j-1],dp[i-1][j])\n                \n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = [[0]*len(A) for _ in range(len(B))]\n        \n        for i in range(len(memo)):\n            for j in range(len(memo[0])):\n                \n                if B[i] == A[j]:\n                    memo[i][j] = 1\n                    if i-1 >= 0 and j-1 >= 0:\n                        memo[i][j] += memo[i-1][j-1]\n                sub_a = 0\n                if j-1 >= 0:\n                    sub_a = memo[i][j-1] \n                sub_b = 0\n                if i-1 >= 0:\n                    sub_b = memo[i-1][j]\n                memo[i][j] = max(memo[i][j], sub_a, sub_b)\n        return memo[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        len_a = len(A)\n        dp = [0] * len_a\n        for n in B:\n            prev = dp[0]\n            if n == A[0]:\n                dp[0] = 1\n            for idx in range(1,len_a):\n                if n == A[idx]:\n                    prev, dp[idx] = dp[idx],prev+1\n                else:\n                    prev, dp[idx] = dp[idx],max(dp[idx-1], dp[idx])\n\n        return dp[-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        M, N = len(A), len(B)\n        dp = [[0]*(N+1) for _ in range(M+1)]\n        res = 0\n        for i in range(1, M+1):\n            for j in range(1, N+1):\n                if A[i-1]==B[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                    \n                res = max(res, dp[i][j])\n                \n        return res", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        max_lines = 0\n        dp = [[0]*(len(B)+1) for _ in range(len(A)+1)]\n        for i in range(1,len(A)+1):\n            for j in range(1,len(B)+1):\n                temp = int(A[i-1]==B[j-1])\n                dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+temp)\n        return dp[-1][-1]\n", "class Solution:\n    # Time Onm\n    # Space Onm\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        l1, l2 = len(A), len(B)\n        lcs = [[0] * (l1+1) for _ in range(l2+1)]\n        # print(lcs)\n        for i in range(1, l2+1):\n            for j in range(1, l1+1):\n                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1], lcs[i-1][j-1]+(B[i-1]==A[j-1]))\n        return lcs[l2][l1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m, n = len(A), len(B)\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 0\n        \n        for i in range(n + 1):\n            dp[0][i] = 0\n            \n        ret = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i-1][j-1] + 1 if A[i-1] == B[j-1] else max(dp[i-1][j], dp[i][j-1])\n                ret = max(ret, dp[i][j])\n            \n        \n        return ret", "class Solution:\n    def maxUncrossedLines(self, A, B):\n        # Optimization\n        commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n\n        N, M = len(A), len(B)\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\n        for i in range(N):\n            for j in range(M):\n                if A[i] == B[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        mat=[[0]*(len(B)+1) for j in range(len(A)+1)]\n        for i in range(1,len(A)+1):\n            for j in range(1,len(B)+1):\n                if A[i-1]==B[j-1]:\n                    mat[i][j]=mat[i-1][j-1]+1\n                else:\n                    mat[i][j]=max(mat[i-1][j],mat[i][j-1])\n        return mat[-1][-1]", "class Solution:\n    \n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        \n        # Make a grid of 0's with len(text2) + 1 columns \n        # and len(text1) + 1 rows.\n        dp_grid = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]\n        \n        # Iterate up each column, starting from the last one.\n        for col in reversed(list(range(len(text2)))):\n            for row in reversed(list(range(len(text1)))):\n                # If the corresponding characters for this cell are the same...\n                if text2[col] == text1[row]:\n                    dp_grid[row][col] = 1 + dp_grid[row + 1][col + 1]\n                # Otherwise they must be different...\n                else:\n                    dp_grid[row][col] = max(dp_grid[row + 1][col], dp_grid[row][col + 1])\n        \n        # The original problem's answer is in dp_grid[0][0]. Return it.\n        return dp_grid[0][0]\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp_grid = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        for col in reversed(list(range(len(B)))):\n            for row in reversed(list(range(len(A)))):\n                if B[col] == A[row]:\n                    dp_grid[row][col] = 1 + dp_grid[row+1][col+1]\n                else:\n                    dp_grid[row][col] = max(dp_grid[row + 1][col], dp_grid[row][col + 1])\n        return dp_grid[0][0]\n                \n        \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        na, nb = len(A), len(B)\n        dp = [[0 for i in range(nb+1)] for j in range(na+1)]\n        for i in range(na):\n            for j in range(nb): \n                if A[i] == B[j]: dp[i+1][j+1] = 1 + dp[i][j]\n                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i+1][j], dp[i][j+1])\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        m = len(A)\n        n = len(B)\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\n        for i in range(m+1):\n            for j in range(n+1):\n                if(i==0 or j==0):\n                    dp[i][j] = 0\n                elif(A[i-1]==B[j-1]):\n                    dp[i][j] = 1 + dp[i-1][j-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        \n        print(dp)\n        return dp[m][n]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        M, N = len(A), len(B)\n        dp = [0] * (N+1)\n        for i in range(M):\n            for j in range(N)[::-1]:\n                if B[j] == A[i]:\n                    dp[j+1] = dp[j] + 1\n            for j in range(N):\n                dp[j+1] = max(dp[j+1], dp[j])\n        return dp[-1]\n        \n", "class Solution:\n     def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = collections.defaultdict(int)\n        def maxUncrossedLinesHelper(ai:int, bi:int)->int:\n            result = 0\n            if ai >= len(A): return 0\n            if bi >= len(B): return 0\n            if (ai,bi) in memo: return memo[(ai,bi)]\n            \n            if A[ai] == B[bi]:\n                result = maxUncrossedLinesHelper(ai+1, bi+1) + 1\n                memo[(ai,bi)] = result\n         ##       return result            \n            \n            chooseA = 0\n            try:\n                ainb = B.index(A[ai], bi)\n            except:\n                ainb = -1\n\n            if ainb > 0:\n                chooseA = maxUncrossedLinesHelper(ai+1, ainb+1) + 1\n\n            chooseB = 0\n            try:\n                bina = A.index(B[bi], ai)\n            except:\n                bina = -1\n\n            if bina > 0:\n                chooseB = maxUncrossedLinesHelper(bina+1, bi+1) + 1\n\n            notchooseAB = maxUncrossedLinesHelper(ai+1, bi+1)\n\n            result = max(chooseA, chooseB, notchooseAB,result)\n            memo[(ai,bi)] = result\n            return result\n        \n        result = maxUncrossedLinesHelper(0, 0)\n        return result\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n                \n        a, b = len(A), len(B)\n        dp = {}\n        for i, num1 in enumerate(A):\n            for j, num2 in enumerate(B):\n                if num1 == num2:\n                    dp[(i,j)] = 1 + dp[i-1,j-1] if min(i,j) > 0 else 1\n                else:\n                    dp[(i,j)] = max(dp[i-1,j] if i > 0 else 0, \n                                    dp[i,j-1] if j > 0 else 0\n                                   )\n                 \n        return dp[a-1,b-1]\n                          \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        # DP : option #1 : Connect A to B\n        #      option #2 : Skip B and look for another candidate\n        # Longest Common Subsequence\n        # if A[i] == B[j], connect and move i-1, j-1\n        n, m = len(A), len(B)\n        @lru_cache(None)\n        def dp(i, j):\n            if i < 0 or j < 0: return 0\n            if A[i] == B[j]:\n                return dp(i-1, j-1) + 1\n            return max(dp(i-1, j), dp(i, j-1))\n        return dp(n-1, m-1)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        M,N=len(A),len(B)\n\n        @lru_cache(None)\n        def dfs(i,j):\n            if i==M or j==N:\n                return 0\n            if A[i]==B[j]:\n                return 1+dfs(i+1,j+1)\n            else:\n                return max(\n                    dfs(i+1,j),\n                    dfs(i,j+1)\n                )\n        \n        return dfs(0,0)", "class Solution:\n  def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n    if len(A) > len(B): return self.maxUncrossedLines(B, A)\n    if not A or not B: return 0\n#     try:\n#       idx = B.index(A[0])\n#       return max(1+self.maxUncrossedLines(A[1:], B[idx+1:]), self.maxUncrossedLines(A[1:], B))\n#     except:\n#       return self.maxUncrossedLines(A[1:], B)\n      \n\n# i = 0..len(A)-1    2  5 1 2 5\n# j = 0..len(B)-1    10 5 2 1 5 2\n\n    dp = [[0]*len(B) for _ in range(len(A))]\n    indexB = collections.defaultdict(list)\n    for i, num in enumerate(B):\n      indexB[num].append(i)\n\n    for i in reversed(list(range(len(A)))):\n      for j in reversed(list(range(len(B)))):\n        # find A[i] in B[j:]\n        found = False\n        for idx in indexB.get(A[i], []):\n          if idx >= j: \n            found = True\n            break\n\n        if found:\n          dp[i][j] = max(1+(dp[i+1][idx+1] if i+1<len(A) and idx+1<len(B) else 0), dp[i+1][j] if i+1<len(A) else 0)\n        else:\n          dp[i][j] = dp[i+1][j] if i+1 < len(A) else 0\n    return dp[0][0]\n", "class Solution:\n    def maxUncrossedLines(self, A, B):\n        commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n        N1, N2 = len(A), len(B)\n        dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        return dp[N1][N2]\n    \n\n    \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        A = [-1] + A\n        B = [-1] + B\n        \n        #142\n        #121\n        \n        #0000\n        #0111\n        #0111\n        #0122\n        \n        w = len(A)\n        h = len(B)\n        \n        dp_table = [[0 for _ in range(w)]  for _ in range(h) ]\n        \n        for x in range(1,w):\n            for y in range(1,h):\n                if A[x] == B[y]:\n                    dp_table[y][x] = dp_table[y-1][x-1] +1 \n                else:\n                    dp_table[y][x] = max(dp_table[y][x-1],dp_table[y-1][x])\n        print(dp_table)          \n        return dp_table[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        a = len(A)\n        b = len(B)\n        memo = {}\n        for i in range(a):\n            for j in range(b):\n                if A[i] == B[j]:\n                    memo[(i,j)] = memo.get((i-1, j-1), 0) + 1\n                else:\n                    memo[(i,j)] = max(memo.get((i-1,j), 0), memo.get((i,j-1), 0))\n        return max(memo.values())\n                    \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        a = len(A)\n        b = len(B)\n        memo = {}\n        for i in range(a):\n            for j in range(b):\n                if A[i] == B[j]:\n                    memo[(i,j)] = memo.get((i-1, j-1), 0) + 1\n                else:\n                    memo[(i,j)] = max(memo.get((i-1,j), 0), memo.get((i,j-1), 0))\n        return memo.get((a-1, b-1), 0)\n                    \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        n = len(A);m = len(B)\n        \n        @lru_cache(None)\n        def fun(i,j):\n            if i == n or j == m:\n                return 0\n            if A[i] == B[j]:\n                return 1 + fun(i+1,j+1)\n            else:\n                return max(fun(i+1,j),fun(i,j+1))\n        \n        return fun(0,0) ", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n        last_a = {}\n        last_b = {}\n        for i in range(len(A)):\n            last_a[A[i]] = i\n            for j in range(len(B)):\n                last_b[B[j]] = j\n                if A[i] == B[j]:\n                    dp[i + 1][j + 1] = max(dp[i][j] + 1, dp[i + 1][j], dp[i][j + 1])\n                else:\n                    dp[i + 1][j + 1] = max(dp[i][j], dp[i + 1][last_b.get(A[i], -1) + 1], dp[last_a.get(B[j], -1) + 1][j + 1])\n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        na, nb = len(A), len(B)\n        dp = [[0 for i in range(nb+1)] for j in range(na+1)]\n        for i in range(na): \n            for j in range(nb):\n                if A[i] == B[j]: dp[i+1][j+1] = 1 + dp[i][j]\n                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j+1], dp[i+1][j])\n        return dp[-1][-1]\n                \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = collections.defaultdict(int)\n        m = len(A)\n        n = len(B)\n        \n        for i in range(m):\n            for j in range(n):\n                dp[i,j] = max(dp[i-1,j], dp[i,j-1], dp[i-1,j-1] + (A[i] == B[j]))\n        return dp[m-1,n-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        dp, m, n = collections.defaultdict(int), len(A), len(B)\n        for i in range(m):\n            for j in range(n):\n                dp[i, j] = max(dp[i - 1, j - 1] + (A[i] == B[j]), dp[i - 1, j], dp[i, j - 1])\n        return dp[m - 1, n - 1]", "class Solution:\n    def maxUncrossedLines(self, A, B):\n        # optimization\n        commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n        N1, N2 = len(A), len(B)\n        dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        return dp[N1][N2]\n    \n\n    \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m, n = len(A), len(B)\n        dp = collections.defaultdict(int)\n        for i in range(m):\n            for j in range(n):\n                match = 1 if A[i] == B[j] else 0\n                dp[i, j] = max(dp[i - 1, j - 1] + match, dp[i - 1, j], dp[i, j - 1])\n        return dp[m - 1, n - 1]", "# https://www.youtube.com/watch?v=7qr4j_fB9S4\n# https://leetcode.com/problems/uncrossed-lines/discuss/652102/Python-3-today's-one-liner\n\nclass Solution:\n  def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n    dp, n, m = defaultdict(int), len(A), len(B)\n    for a,b in product(range(n), range(m)):\n      dp[a,b] = max(dp[a-1,b-1] + (A[a]==B[b]), dp[a-1,b], dp[a,b-1])\n    return dp[n-1, m-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        @lru_cache(None)\n        def max_connections(A_index, B_index):\n            if A_index > len(A) - 1 or B_index > len(B) - 1:\n                return 0\n\n            if A[A_index] == B[B_index]:\n                return max(0, 1 + max_connections(A_index + 1, B_index + 1))\n            else:\n                return max(0, max_connections(A_index + 1, B_index), max_connections(A_index, B_index + 1) )\n        \n        return max_connections(0, 0) ", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = defaultdict(int)\n        N, M = len(A), len(B)\n        \n        for i in range(N):\n            for j in range(M):\n                dp[i,j] = max(dp[i-1,j-1] + (A[i] == B[j]), dp[i-1,j], dp[i,j-1])\n        return dp[N-1,M-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m = len(A)\n        n = len(B)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if A[i-1]==B[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                \n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i][j])\n                    \n        return dp[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        dp, m, n = collections.defaultdict(int), len(A), len(B)\n        for i in range(m):\n            for j in range(n):\n                dp[i, j] = max(dp[i - 1, j - 1] + (A[i] == B[j]), dp[i - 1, j], dp[i, j - 1])\n                \n        return dp[m - 1, n - 1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def helper(a_idx, b_idx):\n            if a_idx == len(A) or b_idx == len(B):\n                return 0\n            \n            c1 = 0\n            if A[a_idx] == B[b_idx]:\n                c1 = 1 + helper(a_idx + 1, b_idx + 1)\n            \n            c2 = helper(a_idx + 1, b_idx)\n            c3 = helper(a_idx, b_idx + 1)\n            \n            return max(c1, c2, c3)\n        \n        return helper(0, 0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        if len(A)<len(B): A, B=B, A\n        DP=[0]* (len(A)+1)\n        coll={j:[-1]+[i for i in range(len(A)) if A[i]==j] for j in set(B)}\n        for iB in B[::-1]:\n            for i in range(1, len(coll[iB])):\n                DP[coll[iB][i]] = max(DP[coll[iB][i]], DP[coll[iB][i]+1]+1)\n                for j in range(coll[iB][i], coll[iB][i-1], -1):\n                    DP[j]=max(DP[j], DP[j+1])\n        return DP[0]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m, n = len(A), len(B)\n        @lru_cache(None)\n        def dfs(i, j):\n            if i == -1 or j == -1:\n                return 0\n            if A[i] == B[j]:\n                return dfs(i - 1, j - 1) + 1\n            \n            return max(dfs(i - 1, j), dfs(i, j - 1))\n        \n        return dfs(m - 1, n - 1)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        dp = [[0 for _ in B] for _ in A]\n        for i in range(len(B)):\n            if A[0] == B[i]:\n                dp[0][i] = 1\n            elif i != 0:\n                dp[0][i] = dp[0][i-1]\n        for i in range(len(A)):\n            if B[0] == A[i]:\n                dp[i][0] = 1\n            elif i != 0:\n                dp[i][0] = dp[i-1][0]\n        for i in range(1,len(A)):\n            for j in range(1,len(B)):\n                if A[i] == B[j]:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]+1)\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        return dp[-1][-1]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        n1 = len(A)\n        n2 = len(B)\n        dp = [[-1 for _ in range(n2)] for _ in range(n1)]\n        return self.recur(0,0,A,B,n1,n2, dp)\n    \n    def recur(self,i,j,A,B,n1,n2,dp):\n        if i == n1 or j == n2:\n            return 0\n        \n        \n        if dp[i][j] != -1:\n            return dp[i][j]\n        if A[i] == B[j]:\n            dp[i][j] =  1 + self.recur(i+1,j+1,A,B,n1,n2,dp)\n        else:\n            c1 = self.recur(i+1,j,A,B,n1,n2,dp)\n            c2 = self.recur(i,j+1,A,B,n1,n2,dp)\n            dp[i][j] = max(c1,c2)\n            \n        return dp[i][j]\n            \n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        max_val = 0\n        m, n = len(A), len(B)\n        dp = [\n            [0 for i in range(n + 1)]\n            for j in range(m + 1)\n        ]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = max(\n                        dp[i-1][j-1] + 1, dp[i-1][j], dp[i][j-1]\n                    )\n                else:\n                    dp[i][j] = max(\n                        dp[i-1][j-1], dp[i-1][j], dp[i][j-1]\n                    )\n                max_val = max(max_val, dp[i][j])\n        return max_val\n", "class Solution:\n\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = {}\n        def helper(A, B, a, b):\n            if (a,b) in memo:\n                return memo[(a,b)]\n            ret = 0\n            if a == len(A) or len(B) == b:\n                return 0\n            if A[a] == B[b]:\n                memo[(a,b)] = 1+ helper(A,B, a+1, b+1)\n                return memo[(a,b)]\n            ret = max(ret, helper(A,B,a, b+1),\n                 helper(A,B,a+1, b))\n            memo[(a,b)] = ret\n            return ret\n        return helper(A,B,0,0)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        A = [ -1 ] + A\n        B = [ -1 ] + B\n        \n        dp_table = {}\n        \n        def helper( idx_a, idx_b ):\n            \n            if (idx_a, idx_b) in dp_table:\n                return dp_table[(idx_a, idx_b)]\n            \n            \n            if idx_a == 0 or idx_b == 0:\n                # Any list compared to empty list give no uncrossed line\n                return 0\n            \n            elif A[idx_a] == B[idx_b]:\n                \n                dp_table[(idx_a, idx_b)] = helper(idx_a-1, idx_b-1) + 1\n                return dp_table[(idx_a, idx_b)]\n            else:\n                dp_table[(idx_a, idx_b)] = max( helper(idx_a-1, idx_b), helper(idx_a, idx_b-1))\n                return dp_table[(idx_a, idx_b)]\n        \n        # --------------------------------------------\n        return helper( len(A)-1, len(B)-1 )", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        # Longest common subsequence\n        dp = collections.defaultdict(int)\n        for i in range(len(A)):\n            for j in range(len(B)):\n                dp[i, j] = max(dp[i - 1, j - 1] + (A[i] == B[j]), dp[i - 1, j], dp[i, j - 1])\n        return dp[len(A) - 1, len(B) - 1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        l = max(len(A),len(B))\n        \n        dp = [[-1 for i in range(l+1)]for j in range(l+1)]\n    \n        def func(indexA, indexB):\n            if indexA >= len(A) or indexB >= len(B):\n                return 0\n            print\n            if dp[indexA][indexB] != -1:\n                return dp[indexA][indexB]\n\n            if A[indexA] == B[indexB]:\n                dp[indexA][indexB] = func(indexA + 1, indexB + 1) + 1\n            else:\n                dp[indexA][indexB] = max(func(indexA + 1, indexB),func(indexA, indexB + 1))\n\n            return dp[indexA][indexB]\n\n        return func(0, 0)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n      store = {}    \n      a_len = len(A)\n      b_len = len(B)\n      \n      def f(a, b):\n        if (a, b) in store: return store[(a, b)]\n        \n        if a == a_len or b == b_len: \n          store[(a, b)] = 0\n          return 0\n        \n        if A[a] == B[b]:\n          store[(a, b)] = 1 + f(a + 1, b + 1)\n        else:  \n          store[(a, b)] = max(f(a + 1, b), f(a, b + 1))\n          \n        return store[(a, b)]  \n      \n      \n      return f(0, 0)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        ab_dict = {a:[] for a in A}\n        for i, b in enumerate(B):\n            if b in ab_dict:\n                ab_dict[b].append(i)\n        \n        lenA, lenB = len(A), len(B)\n        subSolutions = [[None]*lenB for _ in range(lenA)]\n        \n        def subSolve(i,j):\n            if i >= lenA or j >= lenB: return 0\n            if subSolutions[i][j]: return subSolutions[i][j]\n            if not ab_dict[A[i]]:\n                subSolutions[i][j] = 0\n                return subSolve(i+1, j)\n            if A[i] in ab_dict and j in ab_dict[A[i]]:\n                subSolutions[i][j] = 1 + subSolve(i+1, j+1)\n                return subSolutions[i][j]\n            # if you include A[i]:\n            next_j = None\n            for b in ab_dict[A[i]]:\n                if j < b:\n                    next_j = b\n                    break\n            if next_j is None:\n                subSolutions[i][j] = 0\n                return subSolve(i+1, j)\n            subSolutions[i][j] = max(subSolve(i, next_j), subSolve(i+1, j))\n            return subSolutions[i][j]\n        \n        return subSolve(0,0)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m=len(A)\n        n=len(B)\n        dp=[[0 for _ in range(n+1)] for _ in range(m+1)]\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if(A[i-1]==B[j-1]):\n                    dp[i][j]=dp[i-1][j-1]+1\n                else: \n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])\n        return dp[m][n]\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        A = [ -1 ] + A\n        B = [ -1 ] + B\n        \n        dp_table = {}\n        \n        def helper( idx_a, idx_b ):\n            \n            if (idx_a, idx_b) in dp_table:\n                return dp_table[(idx_a, idx_b)]\n            \n            \n            if idx_a == 0 or idx_b == 0:\n                # Any list compared to empty list give no uncrossed line\n                return 0\n            \n            elif A[idx_a] == B[idx_b]:\n                \n                dp_table[(idx_a, idx_b)] = helper(idx_a-1, idx_b-1) + 1\n                return dp_table[(idx_a, idx_b)]\n            else:\n                dp_table[(idx_a, idx_b)] = max( helper(idx_a-1, idx_b), helper(idx_a, idx_b-1))\n                return dp_table[(idx_a, idx_b)]\n        \n        # --------------------------------------------\n        return helper( len(A)-1, len(B)-1 )        ", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        n = len(A);m = len(B)\n        \n        @lru_cache(None)\n        def fun(i,j):\n            if i == n or j == m:\n                return 0\n            loc = -1\n            for k in range(j,m):\n                if B[k]== A[i]:\n                    loc = k\n                    break\n            if loc == -1:\n                return fun(i+1,j)\n            else:\n                return max(fun(i+1,j),1 + fun(i+1,loc+1))\n        \n        return fun(0,0) ", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        memo = [[None for i in range(len(B))] for i in range(len(A))]\n        return self.uncrossRec(A,B,0,0,memo)\n    \n    def uncrossRec(self, A: List[int], B: List[int], i: int, j: int, memo):\n        if j == len(B) or i == len(A):\n            return 0 \n        if memo[i][j] != None:\n            return memo[i][j]\n        if A[i] == B[j]:\n            memo[i][j] = 1 + self.uncrossRec(A,B,i+1,j+1,memo)\n        else:\n            x =self.uncrossRec(A,B,i,j+1,memo)\n            y = self.uncrossRec(A,B,i+1,j,memo)\n            memo[i][j] = max(x,y)\n        return memo[i][j]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        m,n = len(A),len(B)\n        \n        grid = [[0 for i in range(n)]for i in range(m)]\n        \n        for j in range(m):\n            for i in range(n):\n                av = A[j]\n                bv = B[i]\n                \n                topleft = 0\n                top = 0\n                left = 0\n                if 0 <= j-1 < m and 0 <= i - 1 < n:\n                    topleft = grid[j-1][i-1]\n                if 0 <= j-1 < m:\n                    top = grid[j-1][i]\n                if 0 <= i-1 < n:\n                    left = grid[j][i-1]\n                    \n                if av == bv:\n                    grid[j][i] = topleft + 1\n                else:\n                    grid[j][i] = max(top,left)\n                \n        return grid[-1][-1]", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        nA, nB = len(A), len(B)\n        if nA == 0 or nB == 0: return 0\n        \n        cache = {}\n        \n        def process(iA, iB):\n            if iA < 0 or iB < 0: return 0\n            \n            if not (iA, iB) in cache:\n                ans = 0\n                if A[iA] == B[iB]:\n                    ans = 1 + process(iA-1, iB-1)\n                else:\n                    ans = max(process(iA-1, iB), process(iA, iB-1))\n                cache[(iA, iB)] = ans\n            return cache[(iA, iB)]\n        \n        return process(nA-1, nB-1)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        mul_result = {}\n        def get_mul(high, low):\n            if high == -1 or low == -1:\n                return 0\n            if (high, low) in mul_result:\n                return mul_result[(high, low)]\n            result = get_mul(high-1, low-1)\n            \n            if A[high] in B[:low+1]:\n                for i in range(low, -1, -1):\n                    if B[i] == A[high]:\n                        break\n                result = max(result, get_mul(high-1, i-1) + 1)\n            \n            if B[low] in A[:high+1]:\n                for i in range(high, -1, -1):\n                    if A[i] == B[low]:\n                        break\n                result = max(result, get_mul(i-1, low-1) + 1)\n            mul_result[(high, low)] = result\n            return result\n        return get_mul(len(A) - 1, len(B) - 1)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        N_a=len(A)\n        N_b=len(B)\n        pair2maxlines=defaultdict(int)\n        def max_lines(a,b):\n            if pair2maxlines.get((a,b)) is None:\n                if a==N_a or b==N_b:\n                    pair2maxlines[(a,b)]=0\n                    return 0\n                if A[a]==B[b]:\n                    output =1+max_lines(a+1,b+1)\n                    pair2maxlines[(a,b)]=output\n                    return output\n                output = max(max_lines(a+1,b),max_lines(a,b+1))\n                pair2maxlines[(a,b)]=output\n                return output\n            else:\n                return pair2maxlines[(a,b)]\n        return max_lines(0,0)\n", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        n=len(A)\n        m=len(B)\n        d={}\n        def helper(i,j):\n            if i==n or j==m:\n                return 0\n            if (i,j) in d:\n                return d[(i,j)]\n            if A[i]==B[j]:\n                d[(i,j)]=1+helper(i+1,j+1)\n            else:\n                d[(i,j)]=max(helper(i+1,j),helper(i,j+1))\n            return d[(i,j)]\n        return helper(0,0)", "class Solution:\n    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:\n        \n        def help(i, j, mem):\n            if i>=len(A) or j>=len(B):\n                return 0\n            if (i,j) in mem:\n                return mem[(i, j)]\n            if A[i]==B[j]:\n                mem[(i,j)]= 1+help(i+1, j+1, mem)\n                return mem[(i,j)]\n            \n            mem[(i,j)]= max(help(i,j+1, mem), help(i+1,j,mem))\n            return mem[(i,j)]\n        mem = {}\n        return help(0,0, mem)"]
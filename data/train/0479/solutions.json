["class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         d = {}\n         for i in wall:\n             suma = 0\n             for j in range(len(i)-1):\n                 suma += i[j]\n                 if suma in d:\n                     d[suma] += 1\n                 else:\n                     d[suma] = 1\n         if len(d) == 0:\n             return len(wall)\n         return len(wall) - max(d.values())\n", "class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         x_to_edge_dict = {}\n         rows = len(wall)\n         cols = 0\n         if rows > 0:\n             cols = len(wall[0])\n             \n         for row in range(rows):\n             last_pos = 0\n             for brick in wall[row][:-1]: # -1 to ignore end of last brick\n                 end = last_pos + brick\n                 if end not in x_to_edge_dict:\n                     x_to_edge_dict[end] = 1\n                 else:\n                     x_to_edge_dict[end] += 1\n                 last_pos = end\n         \n         #print(x_to_edge_dict)\n         if x_to_edge_dict == {}:\n             return rows\n         else:\n             return rows - max(x_to_edge_dict.values())\n                 \n         \n                 \n                 \n", "class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         # use a hash to store edge location => number of bricks whose edge is on it\n         # then the result is total_height - edge that has max of bricks\n         if not wall: return 0\n         hsh = collections.defaultdict(int)\n         for row in wall:\n             distance_from_left = 0\n             # Notice you cannot go to the last one because the last edge will all be the width of the wall\n             for brick_width in row[:-1]:\n                 distance_from_left += brick_width\n                 hsh[distance_from_left] += 1\n         # notice hsh might be empty\n         return len(wall) - max(list(hsh.values())+[0])\n                 \n \n         \n", "class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         edges = collections.defaultdict(int)\n         length = sum(wall[0])\n         for row in wall:\n             total = 0\n             for brick in row:\n                 total += brick\n                 if total < length:\n                     edges[total] += 1\n         if not edges:\n             return len(wall)\n         return len(wall) - max(edges.values())\n", "class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not wall:\n             return 0\n         \n         width = sum(wall[0])\n         length = len(wall)\n         columns = collections.defaultdict(lambda: length)\n         \n         for r in range(len(wall)):\n             col = 0\n             for c in range(len(wall[r])-1):\n                 col += wall[r][c]\n                 columns[col] -= 1\n         \n         return length if len(columns) == 0 else min(columns.values())\n", "class Solution:\n     def leastBricks(self, wall):\n         \"\"\"\n         :type wall: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \"\"\"\n         Time O(r*c) because we iterate through the wall once and do O(1) work for each element\n         in the wall.\n         Space O(c) because in the worst case, our hashmap will have length c.\n         \"\"\"\n         if not wall:\n             return 0\n         \n         \"\"\"\n         The maximum number of bricks we have to intersect is the equal to the number of rows,\n         in the case that we have to intersect a brick at every row.\n         columns will be a map from a column to the number of bricks that would be intersected\n         if we drew a line through that column. For now, we assume that every column will intersect\n         the maximum number of bricks, which is the number of rows in the wall.\n         \"\"\"\n         numRows = len(wall)\n         columns = collections.defaultdict(lambda: numRows)\n         \n         for r in range(len(wall)):\n             \"\"\"\n             col will be the current column that we are considering drawing a line through.\n             If a brick in this row ends at column col, then we can avoid intersecting that\n             brick by drawing a line through column col.\n             \"\"\"\n             col = 0\n             for c in range(len(wall[r])-1):\n                 \"\"\"\n                 Add the length of the current brick to col to find the column where\n                 this brick ends.\n                 \"\"\"\n                 col += wall[r][c]\n                 \"\"\"\n                 Because this brick ends at col, it won't be intersected if we draw a line\n                 at column col. So we can decrement the number of bricks that will be intersected \n                 if we draw a line at column col.\n                 \"\"\"\n                 columns[col] -= 1\n         \n         return numRows if len(columns) == 0 else min(columns.values())\n"]
["import sys\nn, x, y = input().split(' ')\nn = int(n)\nx = int(x)\ny = int(y)\ncontests = {}\n\nfor i in range(n):\n s, e = input().split(' ')\n s = int(s)\n e = int(e)\n contests[(s, e)] = abs(s-e)\n\nv_time = input().split(' ')\nw_time = input().split(' ')\n\nv_time, w_time = list(map(int, v_time)), list(map(int, w_time))\nv_time.sort()\nw_time.sort()\n\n\nscore = sys.maxsize\n\ncontests = dict(sorted(contests.items(), key=lambda item: item[1]))\nfor k, v in contests.items():\n start=-1\n end = sys.maxsize\n for i in range(x):\n  if v_time[i] > k[0]:\n   break\n  start = v_time[i]\n for j in range(y):\n  if w_time[j] >= k[1]:\n   end = w_time[j]\n   break\n if start == -1:\n  continue\n score = min(score, (end-start+1))\n if score-1 <= v:\n  break\n\nprint(score)", "# cook your dish here\nimport sys\nimport bisect\ninput=sys.stdin.readline\nl=input().split()\nn=int(l[0])\nx=int(l[1])\ny=int(l[2])\nok=[]\nfor i in range(n):\n l=input().split()\n li=[int(i) for i in l]\n ok.append(li)\nl=input().split()\nxi=[int(i) for i in l]\nl=input().split()\nyi=[int(i) for i in l]\nxi.sort()\nyi.sort()\nmina=10**18\nfor i in range(n):\n num1=bisect.bisect_right(xi,ok[i][0])\n num2=bisect.bisect_left(yi,ok[i][1])\n if(num1>=1 and num2<y):\n  mina=min(yi[num2]-xi[num1-1],mina)\nprint(mina+1)\n\n", "import bisect\ndef wormholes(tlist,vlist,wlist):\n sumlist=[]\n for i in range(len(tlist)):\n  if tlist[i][0] not in vlist:\n   x=bisect.bisect_left(vlist,tlist[i][0])\n   x=x-1\n   if x<0:\n    continue\n  else:\n   x=vlist.index(tlist[i][0])\n  if tlist[i][1] not in wlist:\n   y=bisect.bisect_right(wlist,tlist[i][1])\n   if y>=len(wlist):\n    continue\n  else:\n   y=wlist.index(tlist[i][1])\n  sumlist.append(wlist[y]-vlist[x]+1)\n return min(sumlist)\nn,x,y=input().split()\nn,x,y=int(n),int(x),int(y)\ntimelist=[]\nfor i in range(n):\n s,e=input().split()\n s,e=int(s),int(e)\n timelist.append([s,e])\nv=list(map(int,input().strip().split()))\nw=list(map(int,input().strip().split()))\nv.sort()\nw.sort()\nmiv=min(v)\nmaw=max(w)\nfor i in range(n):\n if timelist[i][0]<miv or timelist[i][1]>maw:\n  timelist[i]=[0,0]\nwhile [0,0] in timelist:\n timelist.remove([0,0])\nprint(wormholes(timelist,v,w))\n", "import bisect\ndef wormholes(tlist,vlist,wlist):\n sumlist=[]\n miv=min(vlist)\n maw=max(wlist)\n for i in range(len(tlist)):\n  if tlist[i][0]<miv or tlist[i][1]>maw:\n   continue\n  if tlist[i][0] not in vlist:\n   x=bisect.bisect_left(vlist,tlist[i][0])\n   x=x-1\n   if x<0:\n    continue\n  else:\n   x=vlist.index(tlist[i][0])\n  if tlist[i][1] not in wlist:\n   y=bisect.bisect_right(wlist,tlist[i][1])\n   if y>=len(wlist):\n    continue\n  else:\n   y=wlist.index(tlist[i][1])\n  sumlist.append(wlist[y]-vlist[x]+1)\n return min(sumlist)\nn,x,y=input().split()\nn,x,y=int(n),int(x),int(y)\ntimelist=[]\nfor i in range(n):\n s,e=input().split()\n s,e=int(s),int(e)\n timelist.append([s,e])\nv=list(map(int,input().strip().split()))\nw=list(map(int,input().strip().split()))\nv.sort()\nw.sort()\nprint(wormholes(timelist,v,w))\n", "import bisect\ndef wormholes(tlist,vlist,wlist):\n sumlist=[]\n for i in range(len(tlist)):\n  if tlist[i][0] not in vlist:\n   x=bisect.bisect_left(vlist,tlist[i][0])\n   x=x-1\n   if x<0:\n    continue\n  else:\n   x=vlist.index(tlist[i][0])\n  if tlist[i][1] not in wlist:\n   y=bisect.bisect_right(wlist,tlist[i][1])\n   if y>=len(wlist):\n    continue\n  else:\n   y=wlist.index(tlist[i][1])\n  sumlist.append(wlist[y]-vlist[x]+1)\n return min(sumlist)\nn,x,y=input().split()\nn,x,y=int(n),int(x),int(y)\ntimelist=[]\nfor i in range(n):\n s,e=input().split()\n s,e=int(s),int(e)\n timelist.append([s,e])\nv=list(map(int,input().strip().split()))\nw=list(map(int,input().strip().split()))\nv.sort()\nw.sort()\nprint(wormholes(timelist,v,w))\n", "import bisect\ndef wormholes(tlist,vlist,wlist):\n sumlist=[]\n for i in range(len(tlist)):\n  if tlist[i][0] not in vlist:\n   x=bisect.bisect_left(vlist,tlist[i][0])\n   x=x-1\n  else:\n   x=vlist.index(tlist[i][0])\n  if tlist[i][1] not in wlist:\n   y=bisect.bisect_right(wlist,tlist[i][1])\n  else:\n   y=wlist.index(tlist[i][1])\n  if y<len(wlist) and x>=0:\n   sumlist.append(wlist[y]-vlist[x]+1)\n return min(sumlist)\nn,x,y=input().split()\nn,x,y=int(n),int(x),int(y)\ntimelist=[]\nfor i in range(n):\n s,e=input().split()\n s,e=int(s),int(e)\n timelist.append([s,e])\nv=list(map(int,input().strip().split()))\nw=list(map(int,input().strip().split()))\nv.sort()\nw.sort()\nprint((wormholes(timelist,v,w)))# cook your dish here\n", "import bisect\ndef wormholes(tlist,vlist,wlist):\n sumlist=[]\n for i in range(len(tlist)):\n  if tlist[i][0] not in vlist:\n   x=bisect.bisect_left(vlist,tlist[i][0])\n   x=x-1\n  else:\n   x=vlist.index(tlist[i][0])\n  if tlist[i][1] not in wlist:\n   y=bisect.bisect_right(wlist,tlist[i][1])\n  else:\n   y=wlist.index(tlist[i][1])\n  if y<len(wlist) and x>=0:\n   sumlist.append(wlist[y]-vlist[x]+1)\n return min(sumlist)\nn,x,y=input().split()\nn,x,y=int(n),int(x),int(y)\ntimelist=[]\nfor i in range(n):\n s,e=input().split()\n s,e=int(s),int(e)\n timelist.append([s,e])\nv=list(map(int,input().strip().split()))\nw=list(map(int,input().strip().split()))\nv.sort()\nw.sort()\nprint((wormholes(timelist,v,w)))# cook your dish here\n", "# cook your dish here\ndef bs1(arr,x):\n low = 0 \n high = len(arr) - 1 \n p = 0 \n while(low<=high):\n  mid = (low + high)//2\n  if(arr[mid]==x):\n   return arr[mid]\n  elif(arr[mid]<x):\n   p = mid\n   low = mid + 1 \n  else:\n   high = mid - 1 \n   \n if arr[p] <= x:\n  return arr[p]\n else:\n  return 0\n \n\n\ndef bs2(arr, x):\n low = 0 \n high = len(arr)-1 \n p = 0\n while(low<=high):\n  mid = (low + high)//2 \n  if(arr[mid]==x):\n   return arr[mid]\n  elif(arr[mid]<x):\n   low = mid + 1 \n  else:\n   p = mid\n   high = mid - 1 \n if arr[p] >= x:\n  return arr[p]\n else:\n  return 1000000\n  \n\n\nn,a,b = list(map(int,input().strip().split()))\ns = []\ne = []\nfor i in range(n):\n c,d = list(map(int,input().strip().split()))\n s.append(c)\n e.append(d)\nws = list(map(int,input().strip().split()))\nvs = list(map(int,input().strip().split()))\nws.sort()\nvs.sort()\nr = 1000000\nfor i in range( n):\n s1 = bs1(ws,s[i])\n e1 = bs2(vs,e[i])\n r1 = e1-s1+1 \n if(r1<r):\n  r = r1\nprint(r)", "# cook your dish here\nn,a,b = list(map(int,input().strip().split()))\ns = []\ne = []\nfor i in range(n):\n c,d = list(map(int,input().strip().split()))\n s.append(c)\n e.append(d)\nws = list(map(int,input().strip().split()))\nvs = list(map(int,input().strip().split()))\nws.sort(reverse = True)\nvs.sort()\nr = 1000000\nfor i in range( n):\n s1 = 0\n e1 = 1000000\n for j in range(a):\n  if(ws[j]<=s[i]):\n   s1 = ws[j]\n   break\n for j in range(b):\n  if(vs[j]>=e[i]):\n   e1 = vs[j]\n   break\n r1 = e1-s1+1 \n if(r1<r):\n  r = r1\nprint(r)", "# cook your dish here\nn, v, w = list(map(int,input().strip().split()))\ns = []\ne = []\nfor i in range(n):\n o, u = list(map(int,input().strip().split()))\n s.append(o)\n e.append(u)\nvs = list(map(int,input().strip().split()))\nws = list(map(int,input().strip().split()))\nvs.sort()\nws.sort()\nr = 1000000\nfor i in range(n):\n s1 = 0 \n e1 = 1000000\n for j in vs:\n  if(s[i]>= j):\n   s1 = j \n  else:\n   break\n for j in range(len(ws)-1,-1,-1):\n  if(e[i]<= ws[j]):\n   e1 = ws[j]\n  else:\n   break\n r1 = e1 - s1 + 1\n if(r1<r):\n  r = r1\nprint(r)\n \n   \n\n", "# cook your dish here\nimport sys\nimport bisect\ninput=sys.stdin.readline\nl=input().split()\nn=int(l[0])\nx=int(l[1])\ny=int(l[2])\nok=[]\nfor i in range(n):\n l=input().split()\n li=[int(i) for i in l]\n ok.append(li)\nl=input().split()\nxi=[int(i) for i in l]\nl=input().split()\nyi=[int(i) for i in l]\nxi.sort()\nyi.sort()\nmina=10**18\nfor i in range(n):\n num1=bisect.bisect_right(xi,ok[i][0])\n num2=bisect.bisect_left(yi,ok[i][1])\n if(num1>=1 and num2<y):\n  mina=min(yi[num2]-xi[num1-1],mina)\nprint(mina+1)\n", "import itertools\n# cook your dish here\n\nN, X, Y = list(map(int, input().split()))\ncontests = []\nfor _ in range(N):\n contests.append(list(map(int, input().split())))\n\ninto = list(map(int, input().split()))\nouto = list(map(int, input().split()))\n\n \nworthwole = [(x,y) for x, y in itertools.product(into, outo) if x < y]\nworthwole = sorted(worthwole, key = lambda x : x[1] - x[0])\n# print(worthwole)\n\nresult = 0\nfound = False\nfor w in worthwole:\n for c in contests : \n  if w[0] <= c[0] and w[1] >= c[1] : \n   result = w[1] - w[0] + 1\n   found = True\n   break\n \n if found : break\n\nprint(result)\n", "# cook your dish here\nimport sys\nfrom operator import itemgetter\nn, x, y = map(int, input().strip().split())\ntests=[]\nfor _ in range(n):\n start, end = map(int, input().strip().split())\n tests.append([start,end,1+end-start])\nstart=[]\nstart[:]=map(int, input().strip().split())\nstart.sort()\nend=[]\nend[:]=map(int, input().strip().split())\nend.sort()\ntests.sort(key=itemgetter(0))\nwhile tests[0][0]<start[0]:\n tests.pop(0)\n n-=1\nj=0\nfor i in range(n):\n while j<x-1 and start[j+1]<=tests[i][0]:\n  j+=1\n tests[i][2]+=tests[i][0]-start[j]\ntests.sort(key=itemgetter(1))\nwhile tests[-1][1]>end[-1]:\n tests.pop()\n n-=1\nj=y-1\nfor i in range(n-1,-1,-1):\n while j>0 and end[j-1]>=tests[i][1]:\n  j-=1\n tests[i][2]+=end[j]-tests[i][1]\nminimo=tests[0][2]\nfor i in range(n):\n minimo=min(minimo, tests[i][2])\nprint(minimo)", "nk = [int(i) for i in input().split()]\nn = nk[0]\nx = nk[1]\ny = nk[2]\ncontests = []\ntime = []\nwhile n > 0 :\n contests.append([int(i) for i in input().split()])\n n = n - 1\nn = nk[0]\nvworm = [int(i) for i in input().split()]\nwworm = [int(i) for i in input().split()]\nvworm.sort(reverse=True)\nwworm.sort()\nt1=0\nt2=0\nmint = 10**6\n\nfor contest in contests :\n  if contest[1] - contest[0] > mint :\n   continue\n\n  t1 =0\n  for vbus in vworm :\n   if vbus <= contest[0] :\n    t1 = vbus\n    break\n\n  t2=0\n  for wbus in wworm :\n   if wbus >= contest[1]:\n    t2 = wbus\n    break\n\n  if t1 > 0 and t2 > 0 and t2 >= t1:\n   t = t2 - t1 + 1\n   if t <= mint  :\n    mint = t\n\n\nprint(mint)\n", "# cook your dish here\ndef ub(arr,item):\n n=len(arr)\n low=0;high=n-1\n while low<=high:\n  mid=low+(high-low)//2\n  if arr[mid]==item:\n   return mid\n  elif arr[mid]<item:\n   low=mid+1\n  else:\n   high=mid-1\n \n return low\n\n\ndef lb(arr,item):\n low=0;high=len(arr)-1\n while low<=high:\n  mid=low+(high-low)//2\n  if arr[mid]==item:\n   return mid\n  elif arr[mid]<item:\n   low=mid+1\n  else:\n   high=mid-1\n return high\n\ndef main():\n n,x,y=map(int,input().split())\n timing=[]\n for i in range(n):\n  p,q=map(int,input().split())\n  timing.append((p,q))\n  \n  \n\n v=list(map(int,input().split()))\n\n w=list(map(int,input().split()))\n timing.sort()\n v.sort()\n w.sort()\n\n mn=1e18\n \n\n for i in range(n):\n  s=lb(v,timing[i][0])\n  e=ub(w,timing[i][1])\n  if s>=0 and e<y:\n   mn=min(mn,abs(v[s]-w[e])+1)\n  \n print(mn)\nmain()", "# cook your dish here\ndef ub(arr,item):\n n=len(arr)\n low=0;high=n-1\n while low<=high:\n  mid=low+(high-low)//2\n  if arr[mid]==item:\n   return mid\n  elif arr[mid]<item:\n   low=mid+1\n  else:\n   high=mid-1\n \n return low\n\n\ndef lb(arr,item):\n low=0;high=len(arr)-1\n while low<=high:\n  mid=low+(high-low)//2\n  if arr[mid]==item:\n   return mid\n  elif arr[mid]<item:\n   low=mid+1\n  else:\n   high=mid-1\n return high\n\ndef main():\n n,x,y=list(map(int,input().split()))\n timing=[]\n for i in range(n):\n  p,q=list(map(int,input().split()))\n  timing.append((p,q))\n  \n  \n\n v=list(map(int,input().split()))\n\n w=list(map(int,input().split()))\n timing.sort()\n v.sort()\n w.sort()\n\n mn=1e18\n \n\n for i in range(n):\n  s=lb(v,timing[i][0])\n  e=ub(w,timing[i][1])\n  if s>=0 and e<y:\n   mn=min(mn,abs(v[s]-w[e])+1)\n  \n print(mn)\nmain()\n     \n    \n   \n    \n\n", "def ub(arr,item):\n n=len(arr)\n low=0;high=n-1\n while low<=high:\n  mid=low+(high-low)//2\n  if arr[mid]==item:\n   return mid\n  elif arr[mid]<item:\n   low=mid+1\n  else:\n   high=mid-1\n \n return low\n\n\ndef lb(arr,item):\n low=0;high=len(arr)-1\n while low<=high:\n  mid=low+(high-low)//2\n  if arr[mid]==item:\n   return mid\n  elif arr[mid]<item:\n   low=mid+1\n  else:\n   high=mid-1\n return high\n\ndef main():\n n,x,y=list(map(int,input().split()))\n timing=[]\n for i in range(n):\n  p,q=list(map(int,input().split()))\n  timing.append((p,q))\n  \n  \n\n v=list(map(int,input().split()))\n\n w=list(map(int,input().split()))\n timing.sort()\n v.sort()\n w.sort()\n\n mn=1e18\n \n\n for i in range(n):\n  s=lb(v,timing[i][0])\n  e=ub(w,timing[i][1])\n  if s>=0 and e<y:\n   mn=min(mn,abs(v[s]-w[e])+1)\n  \n print(mn)\nmain()\n     \n    \n   \n    \n", "# cook your dish here\nfrom sys import stdin, stdout\nimport math\n\n\ndef lower_bound(arr, ele):\n low = 0\n high = len(arr)-1\n while low <= high:\n  mid = (low+high)//2\n  if arr[mid] == ele:\n   return arr[mid]\n  elif ele < arr[mid]:\n   high = mid-1\n  else:\n   low = mid+1\n if high > len(arr)-1 or high < 0:\n  return -1\n return arr[high]\n\n\ndef upper_bound(arr, ele):\n low = 0\n high = len(arr)-1\n while low <= high:\n  mid = (low+high)//2\n  if arr[mid] == ele:\n   return arr[mid]\n  elif ele < arr[mid]:\n   high = mid-1\n  else:\n   low = mid+1\n if low > len(arr)-1 or low < 0:\n  return -1\n return arr[low]\n\n\ndef main():\n n, n_x, n_y = list(map(int, stdin.readline().split()))\n contests = [None]*n\n for i in range(n):\n  start, end = list(map(int, stdin.readline().split()))\n  contests[i] = (start, end)\n V = [int(x) for x in stdin.readline().split()]\n W = [int(x) for x in stdin.readline().split()]\n V.sort()\n W.sort()\n ans = math.inf\n for (start, end) in contests:\n  opv = lower_bound(V, start)\n  opw = upper_bound(W, end)\n  if opv == -1 or opw == -1:\n   continue\n  ans = min(ans, opw - opv + 1)\n print(ans)\n\n\ndef __starting_point():\n main()\n\n__starting_point()"]
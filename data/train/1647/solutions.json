["import itertools\ndef next_bigger(n):\n    s = list(str(n))\n    for i in range(len(s)-2,-1,-1):\n        if s[i] < s[i+1]:\n            t = s[i:]\n            m = min([x for x in t if x>t[0]])\n            t.remove(m)\n            t.sort()\n            s[i:] = [m] + t\n            return int(\"\".join(s))\n    return -1\n", "def next_bigger(n):\n    # algorithm: go backwards through the digits\n    # when we find one that's lower than any of those behind it,\n    # replace it with the lowest digit behind that's still higher than it\n    # sort the remaining ones ascending and add them to the end\n    digits = list(str(n))\n    for pos, d in reversed(tuple(enumerate(digits))):\n        right_side = digits[pos:]\n        if d < max(right_side):\n            # find lowest digit to the right that's still higher than d\n            first_d, first_pos = min((v, p) for p, v in enumerate(right_side) if v > d)\n\n            del right_side[first_pos]\n            digits[pos:] = [first_d] + sorted(right_side)\n\n            return int(''.join(digits))\n\n    return -1\n", "def next_bigger(n):\n    n = str(n)[::-1]\n    try:\n        i = min(i+1 for i in range(len(n[:-1])) if n[i] > n[i+1])\n        j = n[:i].index(min([a for a in n[:i] if a > n[i]]))\n        return int(n[i+1::][::-1]+n[j]+''.join(sorted(n[j+1:i+1]+n[:j]))) \n    except:\n        return -1\n", "def next_bigger(n):\n    nums = list(str(n))\n    for i in reversed(range(len(nums[:-1]))):\n        for j in reversed(range(i, len(nums))):\n            if nums[i] < nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                nums[i + 1:] = sorted(nums[i + 1:])\n                return int(''.join(nums))\n    return -1", "def next_bigger(n):\n    i, ss = n, sorted(str(n))\n\n    if str(n) == ''.join(sorted(str(n))[::-1]):\n        return -1;\n\n    while True:\n        i += 1;\n        if sorted(str(i)) == ss and i != n:\n            return i;\n", "def next_bigger(n):\n    prefix = list(str(n))\n    postfix = [prefix.pop()]\n\n    while prefix and prefix[-1] >= max(postfix):\n        postfix.append(prefix.pop())\n\n    if not prefix:\n        return -1\n\n    postfix.sort()\n    i = next(i for i, d in enumerate(postfix) if d > prefix[-1])\n    postfix[i], prefix[-1] = prefix[-1], postfix[i]\n    return int(''.join(prefix + postfix))", "def next_bigger(n):\n    if str(n) == ''.join(sorted(str(n))[::-1]):\n        return -1\n    a = n\n    while True:\n        a += 1\n        if sorted(str(a)) == sorted(str(n)):\n            return a", "def next_bigger(n):\n    nums = list(str(n))\n    length = len(nums) - 1\n    suffix = length\n    while nums[suffix - 1] >= nums[suffix] and suffix > 0:\n        suffix -= 1\n    if suffix <= 0:\n        return -1\n\n    rightmost = length\n    while nums[rightmost] <= nums[suffix - 1]:\n        rightmost -= 1\n    nums[suffix - 1], nums[rightmost] = nums[rightmost], nums[suffix - 1]\n\n    nums[suffix:] = nums[length:suffix - 1:-1]\n    return int(''.join(nums))\n", "def next_bigger(n):\n    m = [d for d in str(n)]\n    for d in range(len(m)-1, 0, -1):\n        if max(m[d:]) > m[d-1]:\n            i = min((x for x in range(d, len(m)) if m[x] > m[d-1]), key = lambda k : m[k])\n            m[d-1], m[i] = m[i], m[d-1]\n            m[d:] = sorted(m[d:])\n            break\n    else:\n        return -1\n    return int(\"\".join(m))"]
["class Solution:\n    def maxSumAfterPartitioning(self, arr, k):\n        res = [0]\n        \n        for idx, val in enumerate(arr):\n            max_val, cur_val = 0, 0\n            \n            for i in range(max(0, idx-k+1), idx+1)[::-1]:\n                \n                if arr[i] > max_val:\n                    max_val = arr[i]\n                    \n                if res[i] + (idx-i+1)*max_val > cur_val:\n                    cur_val = res[i] + (idx-i+1)*max_val\n                    \n            res.append(cur_val)\n        return res[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n#         i = 0\n#         temp = deque()\n#         orig_k = K\n#         while i < len(A):\n#             temp.append(max(A[i:K]))\n#             i = K\n#             K *= 2\n#         print(temp)\n        \n#         answer = deque()\n#         while temp:\n#             for _ in range(len(temp)):\n#                 current_max = max(temp)\n#                 #print(current_max)\n#                 for _ in range(orig_k):\n#                     answer.append(current_max)\n#                     if len(answer) == len(A):\n#                         break\n#                     print(answer)\n#                 temp.remove(current_max)\n#         return sum(answer)\n\n        ans=[0]\n        \n        for r, n in enumerate(A):\n            maxVal, curVal = 0, 0\n            \n            for l in range(max(0, r-K+1), r+1)[::-1]:\n                if A[l]>maxVal:\n                    maxVal=A[l]\n                \n                if ans[l]+(r-l+1)*maxVal>curVal:\n                    curVal=ans[l]+(r-l+1)*maxVal\n           \n            ans.append(curVal)\n        \n        return ans[-1]\n                    \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [A[0]]\n        \n        \n        for i in range(1, len(A)):\n            max_partition_sum = A[i] + dp[-1]\n            max_element = A[i]\n            end = i - K\n            \n            \n            if (end < -1):\n                end = -1\n                \n                \n            for j in range(i - 1, end, -1):\n                if (A[j] > max_element):\n                    max_element = A[j]\n                    \n                partition_sum = (i - j + 1) * max_element\n                \n                \n                if (j > 0):\n                    partition_sum += dp[j - 1]\n                    \n                    \n                if (partition_sum > max_partition_sum):\n                    max_partition_sum = partition_sum\n                    \n            dp.append(max_partition_sum)\n            \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        return self.dp(arr, 0, k, {})\n    \n    \n    def dp(self, arr, i, k, hashmap):\n        if i>=len(arr):\n            return 0\n        \n        if i in hashmap:\n            return hashmap[i]\n        \n        largest = 0\n        ans = 0\n        for idx in range(k):\n            if idx + i >=len(arr):\n                break\n            largest = max(largest, arr[i+idx])\n            ans = max(ans, largest*(idx+1) + self.dp(arr, i+idx+1, k, hashmap))\n        \n        hashmap[i] = ans\n        return ans\n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        return self.recur(arr, len(arr)-1, k, {})\n\n    def recur(self, arr, index, k, hashMap):\n        if index < 0:\n            return 0\n        \n        if index in hashMap:\n            return hashMap[index]\n        result = 0\n        maxV = 0\n        for i in range(k):\n            if index - i < 0:\n                continue\n            maxV = max(maxV, arr[index-i])\n            result = max(result, maxV * (i +1 ) + self.recur(arr, index-i-1, k, hashMap))\n        \n        hashMap[index] =  result\n        return result", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        self.dp = {}\n        \n        def recur(index,arr,k):\n            if index >= len(arr):\n                return 0\n            if index in self.dp:\n                return self.dp[index]\n            maxi = 0\n            res = 0\n            for i in range(k):\n                if index+i < len(arr):\n                    maxi = max(maxi, arr[index+i])\n                    res = max(res, maxi * (i+1) + recur(index + i + 1, arr, k))\n            self.dp[index] = res\n            return res\n        return recur(0, arr, k)", "class Solution:\n    def util(self,i,n,A,K,d) :\n        if i >= n :\n            return 0\n        if i not in d :\n            count=0\n            ma=A[i]\n            temp=-1\n            while (i + count < n) and count<=K-1 :\n                if A[i+count] > ma :\n                    ma=A[i+count]\n                nex=self.util(i+count+1,n,A,K,d)\n                if (count+1)*ma+nex > temp :\n                    temp=(count+1)*ma+nex\n                count+=1\n            d[i]=temp\n        return d[i]\n    \n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n=len(A)\n        d={}\n        return self.util(0,n,A,K,d)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        visited={}\n        \n        def recurse(index):\n            if index>=len(A):\n                return 0\n            if index in visited:\n                return visited[index]\n            mxx=0\n            ans=0\n            for i in range(K):\n                if index+i<len(A):\n                    mxx=max(mxx,A[i+index])\n                    ans=max(ans,mxx*(i+1)+recurse(i+index+1))\n            visited[index]=ans\n            return ans\n        return recurse(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = {}\n        def recur(index,arr,k):\n            if index >= len(arr):\n                return 0\n            if index in dp:\n                return dp[index]\n            maxi = 0\n            res = 0\n            for i in range(k):\n                if index+i < len(arr):\n                    maxi = max(maxi, arr[index+i])\n                    res = max(res, maxi * (i+1) + recur(index + i + 1, arr, k))\n            dp[index] = res\n            return res\n        return recur(0, arr, k)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0]*(n+1)\n        for i in range(n):\n            curMax = 0\n            for k in range(1, min(K,i+1)+1 ):\n                curMax = max(curMax, A[i-k+1])\n                dp[i] = max(dp[i], dp[i-k]+curMax*k)\n        \n        print(dp)\n        return dp[n-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = {}\n        def recur(i,arr,k):\n            if i >= len(arr):\n                return 0\n            if i in dp:\n                return dp[i]\n            maxi,res = 0,0\n            for j in range(k):\n                if i+j < len(arr):\n                    maxi = max(maxi, arr[i+j])\n                    res = max(res, maxi * (j+1) + recur(i + j + 1, arr, k))\n            dp[i] = res\n            return res\n        return recur(0, arr, k)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp=[0]*len(arr)\n        dp[0]=arr[0]\n        max_value=arr[0]\n        max_sum=arr[0]\n        for i in range(1,k):\n            max_value=max(max_value,arr[i])\n            dp[i]=max_value*(i+1)\n        for i in range(k,len(arr)):\n            max_value=0\n            for j in range(k):\n                max_value=max(max_value,arr[i-j])\n                dp[i]=max(dp[i],dp[i-j-1]+max_value*(j+1))\n        return dp[-1]\n", "from collections import deque\n\nclass Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = deque([0 for i in range(K)])\n        for i in range(1, len(A)+1):\n            maxA, maxP = float('-inf'), float('-inf')\n            for j in range(1, min(K+1, i+1)):\n                maxA = max(maxA, A[i-j])\n                maxP = max(maxP, dp[-j] + j*maxA)\n            dp.popleft()\n            dp.append(maxP)\n        return dp[-1]", "from collections import deque\n\nclass Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = deque([0 for i in range(K)])\n        for i in range(1, len(A)+1):\n            maxA, maxP = float('-inf'), float('-inf')\n            for j in range(1, min(K, i)+1):\n                maxA = max(maxA, A[i-j])\n                maxP = max(maxP, dp[-j] + j*maxA)\n            dp.popleft()\n            dp.append(maxP)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        inf = 0x3f3f3f3f\n        dp = [[(-inf, -inf) for _ in range(k+1)] for _ in range(2)]\n        last_max = 0\n        dp[0][0] = (0, 0)\n        for i in range(1, len(arr) + 1):\n            for j in range(1, k + 1):\n                if j == 1:\n                    dp[i%2][j] = (last_max + arr[i-1], arr[i-1])\n                    last_max = dp[i%2][j][0]\n                elif i >= j:\n                    last_s, last_n = dp[(i-1)%2][j-1]\n                    n = max(last_n, arr[i-1])\n                    s = last_s - last_n * (j-1) + n * j\n                    dp[i%2][j] = (s, n)\n                    last_max = max(last_max, s)\n            #    print(i, j, dp[i][j])\n        return last_max", "class Solution:\n    def maxSumAfterPartitioning(self, A, K):\n            N = len(A)\n            dp = [0] * (N + 1)\n            for i in range(N):\n                curMax = 0\n                for k in range(1, min(K, i + 1) + 1):\n                    curMax = max(curMax, A[i - k + 1])\n                    dp[i] = max(dp[i], dp[i - k] + curMax * k)\n                    \n            return dp[N - 1]\n    \n    #Time Complexity- O(N*K)\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        if K == 1 or N == 1:\n            return sum(A)\n        \n        dp = [0] * (N + 1)\n        dp[0] = 0\n        for i in range(N):\n            mv = A[i]\n            dp[i+1] = dp[i] + A[i]\n            for j in range(1, min(i+1, K)):\n                mv = max(mv, A[i-j])\n                dp[i+1] = max(dp[i+1], dp[i-j] + (j+1)*mv)\n                \n        # print(dp)\n        return dp[N]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:    \n        size = len(A)\n        if K == 1: return sum(A)\n        dp = [0] * (size+1)\n        for i in range(size):\n            cur_max = A[i]\n            block_size = 1\n            while block_size <= K and i - block_size + 1 >= 0:\n                cur_max = max(cur_max, A[i-block_size + 1])\n                dp[i+1] = max(dp[i+1], dp[i-block_size + 1] + block_size * cur_max)\n                block_size += 1\n        \n        return dp[size]\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n       \n        n=len(arr)\n        dp=[[-1]*(n+1) for _ in range(n+1)]\n        def maxsum(i=0):\n            if i>=n:return 0 \n            \n            elif dp[i][n]!=-1:\n                return dp[i][n]\n            else:\n                \n                \n                mx=0\n                for j in range(i,min(i+k,n)): \n                    mx=max(arr[j],mx)\n                    dp[i][j]=mx*(j-i+1)\n                    dp[i][n]=max(dp[i][n],dp[i][j]+maxsum(j+1))\n                return dp[i][n]\n        return maxsum()\n                    \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * (n := len(arr))\n        dp[0] = curr_max = arr[0]\n        for i in range(1, k):\n            curr_max = max(curr_max, arr[i])\n            dp[i] = (i + 1) * curr_max\n        for i in range(k, n):\n            curr_max = arr[i]\n            for j in range(k):\n                curr_max = max(curr_max, arr[i-j])\n                dp[i] = max(dp[i], dp[i-j-1] + (j + 1) * curr_max)\n        return dp[-1]\n        \n        # @lru_cache(None)\n        # def dp(idx):\n        #     if idx < 0:\n        #         return 0\n        #     left = max(idx - k + 1, 0)\n        #     curr_max = arr[idx]\n        #     res = arr[idx]\n        #     for i in range(idx, left - 1, -1):\n        #         curr_max = max(curr_max, arr[i])\n        #         res = max(res, dp(i-1) + (idx - i + 1) * curr_max)\n        #     return res\n        # return dp(len(arr) - 1)\n        \n        # A = arr\n        # dp = [0] * (n := len(arr))\n        # dp[0] = curr_max = arr[0]\n        # for i in range(1, k):\n        #     curr_max = max(curr_max, A[i])\n        #     dp[i] = (i + 1) * curr_max\n        # for i in range(k, n):\n        #     curr_max = A[i]\n        #     for j in range(k):\n        #         curr_max = max(curr_max, A[i-j])\n        #         dp[i] = max(dp[i], dp[i-j-1] + curr_max * (j + 1))\n        # return dp[-1]\n", "from collections import deque\n\nclass Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = deque([0 for i in range(K)])\n        for i in range(1, len(A)+1):\n            maxA, maxP = float('-inf'), float('-inf')\n            for j in range(1, min(K+1, i+1)):\n                maxA = max(maxA, A[i-j])\n                maxP = max(maxP, dp[-j] + j*maxA)\n            dp.popleft()\n            dp.append(maxP)\n        return dp.pop()", "'''\nwhat would be the state ? \ni: current position \npartition start \n\njust try allof them is probably the answer\n\n[1,15,7,9,2,5,10]\n\ntry all possible partitions and keep track of the max and sum so far \n\n\nhelper(start, i)\n\n    for j in range(i, k - i + start + 1): # these are the possible ends \n        helper(start, j)\n    \n    \nif i = 2 and start = 1 and k = 3\nfrom i=2 to 5 - 1 = 4\ninstead it should be 1, 2, 3, so only one more so i + 1 = i + k - i \n\nif i = 2 and start = 1 and k = 4\nit shld be 1, 2, 3, 4\n\ni just want to know much left to get to k \nk = end - start \nk = j + i - start -> j = k - i + start\n\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        def helper(i, left, curr_max, sum_so_far):\n            print(\\\"helper i =\\\", i, \\\", left =\\\", left, \\\", curr_max =\\\", curr_max)\n            \n            if i == len(arr):\n                self.res = max(self.res, sum_so_far + (curr_max * (k - left)))\n                return 0\n            \n            # continue current partition\n            choice1 = float('-inf')\n            if left > 0:\n                choice1 = helper(i + 1, left - 1, max(curr_max, arr[i]), sum_so_far)\n            \n            # start a new partition\n            choice2 = helper(i + 1, k, arr[i], sum_so_far + (curr_max * (k - left)))\n            \n            print(\\\"choice1 =\\\", choice1, \\\", choice2 =\\\", choice2)\n            return max(choice1, choice2)\n            \n        self.res = float('-inf')\n        helper(0, k, arr[0], 0)\n        return self.res\n'''\n\n'''\ndp[i]: max sum for arr ending at i \n'''\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], K: int) -> int:\n        n = len(arr)\n        dp = [0 for _ in range(n+1)]\n        for i in range(n): # i is considered the end of the partition \n            currMax = 0\n            for k in range(1, min(K, i + 1) + 1):\n                currMax = max(currMax, arr[i - k + 1])\n                dp[i] = max(dp[i], dp[i-k] + (currMax * k))\n        return dp[n-1]\n\n        \n        \n        \n        \n\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        if arr is None or len(arr) == 0:\n            return 0\n        \n        dp = [0 for _ in range(len(arr))]\n        \n        for i in range(len(arr)):\n            max_elem = arr[i]\n            j = 1\n            \n            while j <= k and i - j + 1 >= 0:\n                \n                max_elem = max(max_elem, arr[i - j + 1])\n                \n                if i - j >= 0:\n                    dp[i] = max(dp[i], max_elem * j + dp[i - j])\n                    \n                else:\n                    dp[i] = max(dp[i], max_elem * j)\n                \n                j += 1\n                    \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n+1)\n        for i, a in enumerate(A):\n            r = a\n            for j in range(1, K+1):\n                r = max(r, A[i-j+1] if i-j+1>=0 else float('-inf'))\n                # print(i, j, r, dp)\n                if i-j+1 >= 0:\n                    dp[i+1] = max(dp[i+1], dp[i-j+1] + r*j)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        cacheMax=[[0]*len(arr) for i in range(len(arr))]\n        for i in range(len(arr)):\n            cacheMax[i][i]=arr[i]\n        for i in range(1,len(arr)):\n            for j in range(i):\n                cacheMax[j][i] = max(cacheMax[j][i-1],arr[i])\n        \n        \n        \n        \n        dp=[0]*(len(arr)+1)\n        dp[1]=arr[0]\n        for i in range(1,len(arr)):\n            for j  in range(max(0,i-k+1),i+1):\n                dp[i+1]=max(dp[i+1],dp[j]+cacheMax[j][i]*(i-j+1))\n                \n            \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        self.dp = [-1 for i in range(n)]\n        def helper(pos:int)->int:\n            if pos >= n:\n                return 0\n            if self.dp[pos] != -1:\n                return self.dp[pos]\n            current_max = arr[pos]\n            ret = arr[pos] + helper(pos+1)\n            for i in range(1, k):\n                pos2 = pos + i\n                if pos2 >= n:\n                    break\n                current_max = max(current_max, arr[pos2])\n                ret = max(ret, current_max * (i+1) + helper(pos2+1))\n            self.dp[pos] = ret\n            return ret\n        return helper(0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        # maxSum[i] = max(A[i] + maxSum[i+1], max(A[i], A[i+1]) + maxSum[i+2], max(A[i], A[i+1], A[i+2], maxSum[i+3]))\n        maxSum = [0] * n;\n        for i in range(-1, -K-1, -1):\n            maxSum[i] = max(A[i:])*(-i)\n        for i in range(n-K-1, -1, -1):\n            ms = 0\n            for k in range(1, K+1):\n                ms = max(ms, max(A[i:i+k]) * k + maxSum[i+k])\n                # print(i,k,ms)\n            maxSum[i] = ms\n        # print(maxSum)\n        return maxSum[0]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        @lru_cache(None)\n        def helper(index, start, mx):\n            if index == len(arr):\n                return (index - start)* mx\n            \n            if index - start + 1 <= k:\n                return max(helper(index + 1, start, max(arr[index], mx)), (index - start)*mx + helper(index + 1, index , arr[index]))\n            \n            return (index - start)*mx + helper(index + 1, index , arr[index])\n        \n        return helper(0, 0, arr[0])", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        inf = 0x3f3f3f3f\n        dp = [[(-inf, -inf) for _ in range(k+1)] for _ in range(len(arr)+1)]\n        last_max = 0\n        dp[0][0] = (0, 0)\n        for i in range(1, len(arr) + 1):\n            for j in range(1, k + 1):\n                if j == 1:\n                    dp[i][j] = (last_max + arr[i-1], arr[i-1])\n                    last_max = dp[i][j][0]\n                elif i >= j:\n                    last_s, last_n = dp[i-1][j-1]\n                    n = max(last_n, arr[i-1])\n                    s = last_s - last_n * (j-1) + n * j\n                    dp[i][j] = (s, n)\n                    last_max = max(last_max, s)\n            #    print(i, j, dp[i][j])\n        return last_max", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0] * len(A)\n        for i in range(K):\n            dp[i] = max(A[:(i + 1)]) * (i + 1)\n        for i in range(K, len(A)):\n            dp[i] = max([dp[i - j] + max(A[(i - j + 1):(i + 1)]) * j for j in range(1, K + 1)])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        '''\n        For each element, it can either go to the previous group, or start a new group\n        dp[i][j] = largest sum before i when last group's size is j, last group's largest value\n        '''\n        dp = [[(0, 0)] * k for _ in range(len(arr)+1)]\n        for i in range(1, len(arr)+1):\n            for j in range(min(i, k)):\n                if j == 0:\n                    dp[i][j] = max((dp[i-1][m][0] + arr[i-1], arr[i-1]) for m in range(min(i, k)))\n                else:\n                    new_max = max(dp[i-1][j-1][1], arr[i-1])\n                    dp[i][j] = dp[i-1][j-1][0] - j * dp[i-1][j-1][1] + new_max * (j + 1), new_max\n        #print(dp)\n        return max(dp[-1])[0]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*n\n        for i in range(n-1, -1, -1):\n            curr_max = arr[i]\n            for j in range(0, k):\n                index = min(n-1, i+j)\n                curr_max = max(curr_max, arr[index])\n                if i+j+1 >= n:\n                    dp[i] = (n-i)*curr_max\n                else:\n                    dp[i] = max(dp[i], dp[i+j+1] + (j+1)*curr_max)\n        return dp[0]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        if not arr:\n            return 0\n        \n        \n        local_max = {(idx, idx+1) :arr[idx] for idx in range(len(arr))}\n        for l in range(2, k+1):\n            for start in range(len(arr)-l+1):\n                local_max[(start, start+l)] = max(local_max[(start, start+l-1)], local_max [(start+1, start+l)])\n        \n                \n        f = [0]\n        for end in range(1, len(arr)+1):\n            _local = 0\n            for start in range(max(0, end-k), end):\n                _local = max(f[start]+local_max[(start, end)]*(end-start), _local)\n            f.append(_local)\n        return f[-1]\n    \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n=len(arr)\n        memo=[0]*n\n        for i in range(n):\n            if i<k:\n                memo[i]=(i+1)*max(arr[:i+1])\n            else:\n                memo[i]=max(memo[i-j-1]+(j+1)*max(arr[i-j:i+1]) for j in range(k))\n        return memo[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        # \u52a8\u6001\u89c4\u5212\n        length = len(arr)\n        dp = [0]*(length+1)\n        maxval = [[0]*length for _ in range(length)]\n        for i in range(length):\n            for j in range(i, length):\n                if i == j:\n                    maxval[i][j] = arr[i]\n                else:\n                    maxval[i][j] = max(maxval[i][j-1], arr[j])\n        # print(maxval)\n        for i in range(1, length+1):\n            temp = 0\n            # print(\\\"------{}------\\\".format(i))\n            for t in range(1, k+1):\n                temp = max(temp, dp[i-t]+maxval[i-t][i-1]*t)\n                # print(temp)\n            dp[i] = temp\n        # print(dp)\n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        dp = [0] * len(A)\n        \n        for i in range(K):\n            dp[i] = (i+1) * max(A[:i+1])\n        \n        for i in range(K,len(A)):\n            maximum = 0\n            for j in range(1,K+1):\n                if i-j<0:\n                    break\n                temp = dp[i-j] + max(A[i-j+1:i+1]) * j\n                if temp>maximum:\n                    maximum = temp\n            dp[i] = maximum\n            \n        print(dp)\n            \n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        def dfs(i, j, max_num=0):\n            if i == -1:\n                return max_num * j\n\n            if opt[i][j] == -1:\n                a, b = 0, 0\n                if j < K:\n                    a = dfs(i - 1, j + 1, max(max_num, A[i]))\n                b = j * max_num + dfs(i - 1, 1, A[i])\n                opt[i][j] = max(a, b)\n            return opt[i][j]\n\n        n = len(A)\n        opt = [[-1] * (K + 1) for _ in range(n)]\n        return dfs(n - 1, 0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        l = len(arr)\n        results = [0] * l\n        for idx, num in enumerate(arr):\n            if idx < k:\n                results[idx] = max(arr[:idx+1]) * (idx + 1)\n            else:\n                res = 0\n                for i in range(1, k+1):\n                    start = idx -i\n                   \n                    tmp = results[start] + max(arr[start+1:idx+1]) * i\n                \n                    res = max(res, tmp)\n                results[idx] = res\n\n        return results[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        max_sums = [0]*len(arr)\n\n        for i in range(len(arr)):\n\n            if i<=k-1:\n\n                max_sums[i] = (i+1)*max(arr[:i+1])\n\n            else:\n             \n                res = 0\n\n                for j in range(1,k+1):\n\n                    first = max_sums[i-j]\n                    second = j*max(arr[i-j+1:i+1])\n\n                    #print(i, j)\n                    #print(arr[:i-j+1], arr[i-j+1:i+1])\n                    #print(\\\"first, second \\\", first, second)\n                    \n                    res = max(res, first+second)        \n                    \n                max_sums[i] = res\n\n            #print(max_sums)\n\n        #print(max_sums)\n\n        return max_sums[-1]\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        maxx = arr[0]\n        dp = []\n        for i,_ in enumerate(arr[:k]):\n            maxx=max(arr[i], maxx)\n            dp.append(maxx*(i+1))\n            \n        for i, _ in enumerate(arr[k::]):\n            i+=k\n            max_sum = 0\n            for j in range(k):\n                max_sum = max(\n                    max_sum,dp[i-j-1] + (max(arr[i-j:i+1])*(j+1))\n                )\n                \n            dp.append(max_sum)\n            \n        return dp[-1]\n                    \n            \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        A=arr\n        K=k\n        n=len(A)\n        dp=[0]*n\n        for i in range(K):\n            dp[i]=max(A[:i+1])*(i+1)\n        for i in range(K,n):\n            for j in range(1,K+1):\n                dp[i]=max(dp[i],dp[i-j]+max(A[i-j+1:i+1])*j)\n        return dp[-1]\n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        size = len(arr)\n        dp = [0]*size\n        for i in range(k):\n            dp[i] = max(arr[:i+1])*(i+1)\n        \n        for i in range(k,size):\n            for j in range(1,k+1):\n                dp[i] = max(dp[i],dp[i-j]+max(arr[i-j+1:i+1])*j)\n\n        return dp[-1]", "class Solution:\n    def printm(self,arr):\n        [print(arr[i]) for i in range(len(arr))]\n    def maxSumAfterPartitioning(self, A,K):\n        size = len(A)\n        dp = [0]*size\n        for i in range(K):\n            dp[i] = max(A[:i+1])*(i+1)\n        # printm(dp)\n\n        for i in range(K,size):\n            for j in range(1,K+1):\n                dp[i] = max(dp[i],dp[i-j]+max(A[i-j+1:i+1])*j)\n        # self.printm(dp)\n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        L = len(arr)\n        dp = [0] * L\n        for i in range(k):\n            dp[i] = max(arr[:i+1])*(i+1)\n        for i in range(k,L):\n            dp[i] = dp[i-k] + max(arr[i-k+1:i+1])*k\n            for j in range(1,k):\n                dp[i] = max(dp[i],dp[i-j] + max(arr[i-j+1:i+1])*j)\n        return dp[-1]", "# dynamic programming\n# time complexity: O(A*K*K)\n# dp[i] = max sum of A[:i] after partitioning\nclass Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        dp = [float('-inf')] * (N+1)\n        for i in range(1,N+1):\n            if i <= K:\n                dp[i] = max(A[:i]) * i\n            else:\n                for j in range(1,K+1):\n                    dp[i] = max(dp[i], dp[i-j]+max(A[i-j:i])*j)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * len(arr)\n        for i in range(k):\n            dp[i] = max(arr[:i+1]) * (i+1)\n\n        for i in range(k, len(arr)):\n            for j in range(1,k+1):\n                dp[i] = max(dp[i], dp[i-j] + j * max(arr[i-j+1:i+1]))\n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        M = [0 for i in range(len(arr))]\n        \n        M[0] = arr[0]\n        \n        for i in range(1, len(arr)):\n            \n            if i < k:\n                M[i] = max(arr[:i+1]) * (i+1)\n            else:\n                for j in range(1, min(k+1, i+1)):\n                    M[i] = max(M[i], M[i-j] + max(arr[i-j+1:i+1]) * j)\n            \n        return M[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        rec = {}\n        def helper(idx):\n            if idx in rec:\n                return rec[idx]            \n            if len(arr)-idx <= k:\n                temp = max(arr[idx:])*(len(arr)-idx)\n                rec[idx] = temp\n                return temp\n            pre_max = float('-inf')\n            temp = float('-inf')\n            for j in range(idx, min(idx+k, len(arr))):\n                pre_max = max(pre_max, arr[j])\n                temp = max(temp, pre_max*(j-idx+1)+helper(j+1))\n            rec[idx] = temp\n            return temp\n        \n        return helper(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0]*len(arr)\n        for i in range(k):\n            dp[i] = max(arr[:i+1])*(i+1)\n        #print(dp)\n        for i in range(k,len(arr)):\n            for j in range(1,k+1):\n                dp[i] = max(dp[i],dp[i-j]+max(arr[i-j+1:i+1])*j)\n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        def maxSum(i, mem):\n            if i in mem: return mem[i]\n            \n            if len(A) - i <= K:\n                mem[i] = max(A[i:]) * (len(A) - i)\n                return mem[i]\n            \n            ans = -float('inf')\n            for j in range(i+1, i+1+K):\n                if j > len(A): break\n                ans = max(ans, max(A[i:j]) * (j-i) + maxSum(j, mem))\n            mem[i] = ans\n            return mem[i]\n        \n        mem = {}\n        return maxSum(0, mem)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        largest_sums = []\n        for i in range(len(A)):\n            if i < K:\n                largest_sums.append(max(A[:i+1]) * (i + 1))\n                continue\n            \n            max_sum = 0\n            for j in range(K):\n                if i - (j+1) < 0:\n                    continue\n                # print(j, i-j-1, largest_sums[i - j-1], max(A[i-j:i+1]))\n                cur_sum = largest_sums[i - j-1] + max(A[i-j:i+1]) * (j + 1)\n                if cur_sum > max_sum:\n                    max_sum = cur_sum\n            \n            # print(i, max_sum)\n            largest_sums.append(max_sum)\n        \n        return largest_sums[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        def dfs(i, j, max_num=0):\n            if i == -1:\n                return max_num * j\n\n            if opt[i][j] == -1:\n                ans = 0\n                if j < K:\n                    ans = max(ans, dfs(i - 1, j + 1, max(max_num, A[i])))\n                ans = max(ans, j * max_num + dfs(i - 1, 1, A[i]))\n                opt[i][j] = ans\n            return opt[i][j]\n\n        n = len(A)\n        opt = [[-1] * (K + 1) for _ in range(n)]\n        return dfs(n - 1, 0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0 for i in range(len(arr))]\n        for i in range(k):\n            dp[i] = (i+1)*max(arr[:i+1])\n        for i in range(k,len(arr)):\n            for j in range(k):\n                dp[i] = max(dp[i], dp[i-j-1]+(j+1)*max(arr[i-j:i+1]))\n        return dp[len(arr)-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * n\n        \n        for i in range(K):\n            dp[i] = max(A[:i+1]) * (i + 1)\n        \n        for i in range(K, n):\n            for d in range(1, K + 1):\n                dp[i] = max(dp[i], dp[i - d] + max(A[i - d + 1: i + 1]) * d)\n                \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        mm = [[a for a in arr]]\n        for i in range(len(arr) - 1):\n            mm.append([0] * len(arr))\n        for i in range(1, k):\n            for j in range(i, len(arr)):\n                mm[i][j] = max(mm[i - 1][j - 1], arr[j])\n        dp = [0] * (len(arr) + 1)\n        for i in range(1, len(arr) + 1):\n            for j in range(max(k, i)):\n                dp[i] = max(dp[i], dp[i - j - 1] + mm[j][i - 1] * (j + 1))\n        print(dp)\n        return dp[-1]\n                \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        aLen = len(A)\n        dp = {}\n        def helper(i0):\n            if i0 in dp:\n                return dp[i0]\n            if aLen - i0 <= K:\n                dp[i0] = max(A[i0:])*(aLen-i0)\n                return dp[i0]\n            subAns = 0\n            thisMax = A[i0]\n            for ki in range(1, K+1):\n                thisMax = max(thisMax, A[i0+ki-1])\n                subAns = max(subAns, thisMax*ki + helper(i0 +ki))\n            dp[i0] = subAns\n            return subAns\n        return helper(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        maxes = [[None for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            maxes[i][i] = arr[i]\n        for i in range(n):\n            for j in range(i+1, n):\n                maxes[i][j] = max(arr[j], maxes[i][j-1])\n                \n        dp = [None for _ in range(n+1)]\n        dp[n] = 0\n        for i in range(n-1, -1, -1):\n            m = float('-inf')\n            for j in range(min(n-i,k)):\n                m = max(m, (j+1)*maxes[i][min(n-1, i+j)] + dp[min(n, i+j+1)])\n            dp[i] = m\n        return dp[0]\n        \n                \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        \n        def helper(index, start, mx):\n            key = (index, start, mx)\n            if key in d:\n                return d[key]\n            if index == len(arr):\n                return (index - start)* mx\n            \n            if index - start + 1 <= k:\n                d[key] = max(helper(index + 1, start, max(arr[index], mx)), (index - start)*mx + helper(index + 1, index , arr[index]))\n                return d[key]\n            d[key] = (index - start)*mx + helper(index + 1, index , arr[index])\n            return d[key]\n        d = dict()\n        return helper(0, 0, arr[0])", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        @lru_cache(None)\n        def checkSum(i, j, k):\n            if j - i <= k:\n                return max(A[i:j]) * (j - i)\n            else:\n                best = 0\n                for nk in range(1, K + 1):\n                    best = max(best, checkSum(i, i + nk, K) + checkSum(i+nk, j, K))\n            return best\n        return checkSum(0, len(A), K)\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        arr = [[(0,0)]*(K+1) for _ in range(N)]\n        prev=0\n        for i in range(N):\n            arr[i][1] = (A[i]+prev,A[i])\n            prev+=A[i]\n            for j in range(2,min(i+2,K+1)):\n                mx = max(arr[i-1][j-1][1],A[i])\n                s = arr[i-1][j-1][0] - arr[i-1][j-1][1]*(j-1) + mx*j\n                arr[i][j] = (s,mx)\n                prev = max(prev,s)\n            # print(prev,arr[i][1:])\n        return max(arr[-1][k][0] for k in range(1,K+1))\n                \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        if not A:\n            return 0\n        N = len(A)\n        if K == N:\n            return N*max(A)\n        dp = [0 for i in range(N)]\n        for i in range(K):\n            dp[i] = max(A[:i+1])*(i+1)\n        for i in range(K, N):\n            a = max(A[i-K+1:i+1])\n            # print(a, dp[i-K], dp[i-1])\n            # dp[i] = max(dp[i-K]+K*a, dp[i-1]+A[i])\n            dp[i] = max([dp[i-j]+j*max(A[i-j+1:i+1]) for j in range(1, K+1)])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        @lru_cache(None)\n        def help(A,K):\n            n = len(A)\n            if K==1:\n                return sum(A)\n            if K>=n:\n                return n*max(A)\n            cMax = [A[0]]\n            for i in range(1,K):\n                cMax.append(max(cMax[-1],A[i]))\n            return max((i+1)*cMax[i] + help(A[i+1:],K) for i in range(K))\n        return help(tuple(A),K)\n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n      #dpdp\n      grid = [0]*len(arr)\n      for i in range(len(arr)-1, -1, -1):\n        if len(arr) - i <= k:\n          grid[i] = max(arr[i:len(arr)])*(len(arr)-i)\n        else:\n          maxi = 0\n          current_max = 0\n          for t in range(k):\n            current_max = max(current_max, arr[i+t])\n            maxi = max(maxi, current_max*(t+1) + grid[i+t+1])\n          grid[i] = maxi\n      return grid[0]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        if not arr:\n            return 0\n        \n        if k==1:\n            return sum(arr)\n        \n        self.memo={}\n        \n        def makepart(arr,n):\n            \n            if n in self.memo:\n                return self.memo[n]\n            \n            if not arr:\n                return 0\n            \n            l=min(k,len(arr))\n            maxele=0\n            total=0\n            \n            for i in range(l):\n                \n                maxele=max(maxele,arr[i])\n                \n                temp=(maxele*(i+1))+makepart(arr[i+1:],n+i+1)\n                \n                total=max(total,temp)\n                \n            self.memo[n]=total\n            \n            return total\n        \n        return makepart(arr,0)\n                \n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\n        def dfs(i, j, max_num=0):\n            if i == -1:\n                return max_num * j\n\n            if (i, j, max_num) not in opt:\n                ans = 0\n                if j < k:\n                    ans = max(ans, dfs(i - 1, j + 1, max(max_num, A[i])))\n                ans = max(ans, j * max_num + dfs(i - 1, 1, A[i]))\n                opt[(i, j, max_num)] = ans\n            return opt[(i, j, max_num)]\n        \n        n = len(A)\n        opt = dict()\n        return dfs(n - 1, 0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr, k: int) -> int:\n        n = len(arr)\n        mask = [[0] * n for i in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                mask[i][j] = max(arr[j], mask[i][j - 1] if j > i else 0)\n\n        for i in range(n):\n            for j in range(i, n):\n                mask[i][j] = (j + 1 - i) * mask[i][j]\n        dp = [0]*n\n        for i in range(n):\n            for h in range(1,k+1):\n                dp[i]= max((dp[i-h] if i-h>=0 else 0)+(mask[i-h+1][i] if i-h+1<n else 0), dp[i])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr, k: int) -> int:\n        n = len(arr)\n        mask = [[0] * n for i in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                mask[i][j] = max(arr[j], mask[i][j - 1] if j > i else 0)\n\n        for i in range(n):\n            for j in range(i, n):\n                mask[i][j] = (j + 1 - i) * mask[i][j]\n                \n        dp = [0]*n\n        for i in range(n):\n            for h in range(1,k+1):\n                dp[i]= max((dp[i-h] if i-h>=0 else 0)+(mask[i-h+1][i] if i-h+1<n else 0), dp[i])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        self.answer = {}\n        def max_starting_i (index_A):\n            array = A[index_A:]\n            if index_A in self.answer:\n                return self.answer[index_A]\n            #print (array)\n            if len(array) == 0:\n                self.answer[index_A] = 0\n                return 0\n            if len(array) <= K:\n                self.answer[index_A] =  max(array) * len(array) \n                return self.answer[index_A] \n            max_start_here = 0\n            for i in range(0,K):\n                #print (i)\n                max_split_here = (i+1)*max(array[:i+1]) + max_starting_i(index_A+i+1)\n                max_start_here = max(max_start_here, max_split_here)\n            self.answer[index_A]  = max_start_here\n            return max_start_here\n        \n        return max_starting_i(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n      #dpdp\n      grid = [0]*len(arr)\n      for i in range(len(arr)-1, -1, -1):\n        if len(arr) - i <= k:\n          grid[i] = max(arr[i:len(arr)])*(len(arr)-i)\n        else:\n          maxi = 0\n          for t in range(k):\n            maxi = max(maxi, max(arr[i:i+t+1])*(t+1) + grid[i+t+1])\n          grid[i] = maxi\n      return grid[0]\n", "class Solution:\n    def maxSumAfterPartitioning(self, l: List[int], k: int) -> int:\n        def _max_sum(l, start, k, memo):\n            if (len(l)-start) <= k:\n                return (len(l)-start)*max(l[start:])\n\n            if start in memo:\n                return memo[start]\n\n            max_sum = l[start]\n            for i in range(1, k+1):\n                curr_sum = max(l[start:start+i])*i + _max_sum(l, start+i, k, memo)\n                max_sum = max(max_sum, curr_sum)\n\n            memo[start] = max_sum\n            return max_sum\n\n\n        if not l:\n            return 0\n\n        return _max_sum(l, 0, k, dict())", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n#         fMax = [A[0]]\n#         for num in A[1:]:\n#             fMax.append(max(fMax[-1], num))\n        aLen = len(A)\n#         bMax = [num for num in A]\n#         for i in range(aLen-2, -1, -1):\n#             bMax[i] = max(bMax[i], bMax[i+1])\n        \n#         ans = 0\n#         for i in range(aLen-1):\n#             ans = max(ans, (i+1)*fMax[i] + (aLen-i-1)*bMax[i+1])\n#         return ans\n        dp = {}\n        def helper(i0):\n            if i0 in dp:\n                return dp[i0]\n            if aLen - i0 <= K:\n                dp[i0] = max(A[i0:])*(aLen-i0)\n                return dp[i0]\n            subAns = 0\n            thisMax = A[i0]\n            for ki in range(1, K+1):\n                thisMax = max(thisMax, A[i0+ki-1])\n                subAns = max(subAns, thisMax*ki + helper(i0 +ki))\n            dp[i0] = subAns\n            return subAns\n        return helper(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        self.dp = [-1] * (len(arr)+k)\n        return self.solve(arr, 0, k)\n    \n    def solve(self, arr, start, k):\n        if start >= len(arr):\n            return 0\n        \n        if start + k >= len(arr):\n            end = min(len(arr), start+k)            \n            return max(arr[start:end]) * (end-start)\n        \n        if self.dp[start] != -1:\n            return self.dp[start]\n        \n        result = float('-inf')\n        for p in range(1, k+1):\n            temp = max(arr[start:start+p]) * p + self.solve(arr, start+p, k)\n            result = max(temp, result)\n        \n        self.dp[start] = result\n        return result", "class Solution:\n    def partition(self, arr, k, index, memo):\n        if len(arr) == 0:\n            return 0\n        \n        if index in memo:\n            return memo[index]\n        \n        maxNum = arr[0]\n        maxSum = maxNum\n        for i in range(1, min(k+1, len(arr)+1)):\n            maxNum = max(maxNum, arr[i-1])\n            subarr = arr[:i]\n            sumArr = self.partition(arr[i:], k, index + i, memo)\n            # i is the size of the array you're examining\n            sumArr += maxNum * (i)\n            maxSum = max(sumArr, maxSum)\n        \n        memo[index] = maxSum\n        return maxSum\n            \n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        memo = {}\n        num = self.partition(arr, k, 0, memo)\n        print(memo)\n        return num", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        self.cache = {}\n        \n        def helper(arr, k, start):\n            if start in self.cache:\n                return self.cache[start]\n\n            _arr = arr[start:]\n            if len(_arr) == 0:\n                return 0\n            if len(_arr) <= k:\n                return max(_arr) * len(_arr)\n\n            ans = -1\n            for i in range(1, k + 1):\n                ans = max(ans, i * max(_arr[:i]) + helper(arr, k, start + i))\n\n            self.cache[start] = ans\n            return ans\n    \n        return helper(arr, k, 0)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n+1)\n        for i in range(1,n+1):\n            # m = float('-inf')\n            for j in range(1,K+1):\n                if i - j >= 0:\n                    m = max(A[i-j:i])\n                    dp[i] = max(dp[i],dp[i-j]+m*j)\n        return dp[-1]", "import typing\n\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: typing.List[int], k: int) -> int:\n        storage = {}\n        def getSumRec(arr:list,i:int,k:int)->int:\n            if i in storage:\n                return storage[i]\n\n            if not i<len(arr):\n                return 0\n\n            if len(arr) - i < k:\n                return max(arr[i:])*len(arr[i:])\n\n            listOfSums = []\n            for offset in range(k):\n                listOfSums.append( max(arr[i:i+offset+1] )*(offset+1) + getSumRec(arr,i+offset+1,k))\n\n            storage[i] = max(listOfSums)\n            return storage[i]\n\n        return getSumRec(arr,0,k)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n         \n        best_a = [0] * len(A)\n        best_a[0] = A[0]\n       \n        for i in range(1, len(A)):\n            max_v = 0\n            for j in range(i, max(-1, i-K), -1):\n                sa = A[j:i+1]\n                v = best_a[j-1] + max(sa) * len(sa)\n                if v > max_v:\n                    max_v = v\n                #print(best_a,max_v,i,j,sa)\n            best_a[i] = max_v\n        \n        return best_a[-1]\n        \n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * (len(arr)+1)\n        for i in range(0, len(arr)):\n            m = 0\n            for j in range(i, i-k, -1):\n                if j < 0:\n                    break\n                t = max(arr[j:i+1]) * (i - j + 1) + dp[j] \n                if t > m:\n                    m = t\n            dp[i+1] = m\n            \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        best_a = [0] * len(A)\n        best_a[0] = A[0]\n        \n        for i in range(1,len(A)):\n            maxv = 0\n            for j in range(i,max(-1,i - K),-1):\n                sa = A[j:i + 1]\n                v = best_a[j - 1] + max(sa) * len(sa)\n                \n                if v > maxv:\n                    maxv = v\n            best_a[i] = maxv\n        return best_a[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n=len(arr)\n        dp_sum=[0]*n\n        \n        dp_sum[0]=arr[0]\n        max_so_far=arr[0]\n        \n        for i in range(1,k):\n            max_so_far = max(max_so_far, arr[i])\n            dp_sum[i] = (i+1)*max_so_far\n        \n        for i in range(k,n):\n            partition_max = 0\n            for back in range(k):\n                partition_max = max(partition_max, arr[i-back])\n                \n                dp_sum[i] = max(dp_sum[i], dp_sum[i-back-1] + (back+1)*partition_max)\n        \n        return dp_sum[-1]\n", "class Solution:\n    \n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        opt = [arr[0]]\n        for i in range(1, len(arr)):\n\n            opt.append(0)  # At index i\n            \n            subseqLenMax = min(k, i+1)  # To avoid counting past index 0\n            \n            # For the length of each possible subsequence which includes (and ends at) index i:\n            for subseqLen in range(1, subseqLenMax+1):\n                \n                # Find the max possible sum of the subsequence\n                subseqSum = subseqLen * max(arr[i-subseqLen+1 : i+1])\n                \n                # Add to the optimal solution from before\n                if subseqLen < i+1:\n                    prevOpt = opt[i-subseqLen]\n                else:  # Entire arr\n                    prevOpt = 0\n                optTemp = prevOpt + subseqSum\n                \n                # print('for opt', i, ' sublen =', subseqLen, '   subseqSum = ',subseqSum, ' optTemp = ', optTemp)\n                \n                # Compare to the other possible subsequence sums\n                if optTemp > opt[i]:\n                    opt[i] = optTemp\n\n            # print(opt)\n            \n        return opt[len(opt)-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        if K == 1:\n            return sum(A)\n        \n        # dp[i]: ans considering A[0:i]\n        dp = [0] * (len(A)+1)\n\n        for i in range(1, len(A)+1):\n            cand = []\n            for j in range(1, K+1):\n                # consider to A[i-j:i]\n                if j > i:\n                    break\n                temp = dp[i-j] + max(A[i-j:i]) * j\n                cand.append(temp)\n            \n            dp[i] = max(cand)\n        \n        print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            for w in range(1, K + 1):\n                if i - w < 0: break\n                dp[i] = max(dp[i], dp[i - w] + max(A[i - w:i]) * w)\n            \n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0 for i in range(len(A)+1)]\n        \n        dp[0] = 0\n        dp[1] = A[0]\n        for i in range(1, len(A)):\n            result = 0\n            for j in range(max(0, i-K+1), i+1):\n                result = max(result, dp[j] + max(A[j:i+1])*(i-j+1))\n            dp[i+1] = result\n                                \n        return dp[-1]\n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            for j in range(1, min(k+1,i+1)):\n                dp[i]= max(dp[i], dp[i-j]+ max(arr[i-j:i])*j)\n        \n        \n        return dp[n]\n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0]* (len(arr)+1)\n        dp[1] = arr[0]\n        for i in range(2, len(dp)):\n            for j in range(1, k+1):\n                if i-j < 0:\n                    continue\n                #print(i, j, i-j, i)\n                dp[i] = max(dp[i], dp[i-j] + j * max(arr[i-j:i]))\n        \n        print(dp)\n        return dp[len(arr)]\n                \n            \n            \n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n\n        if not arr:\n            return 0\n        \n        if n == 1:\n            return arr[0]\n        \n        if n < k:\n            return sum(arr)\n        \n        dp = [0] * (n)\n        \n        for i in range(n):\n            for j in range(i, max(-1, i-k), -1): \n                dp[i] = max(dp[i], max(arr[j:i+1]) * (i-j+1) + (dp[j-1] if j-1 >= 0 else 0))\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        N = len(arr)\n        T = [0] * (N+1)\n        for i in range(1, N+1):\n            for j in range(1, k+1):\n                if j > i: break\n                #if i == 2: print(max(arr[(i-j): i]), arr[(i-j): i], j)\n                T[i] = max(T[i], T[i-j] + max(arr[(i-j): i]) * j)\n        #print(T)\n        return T[N]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        \n        M = [0 for i in range(len(arr))]\n        \n        M[0] = arr[0]\n        \n        #if len(arr) > 1:\n        #    M[1] = max(arr[0],arr[1]) * 2\n            \n        #if len(arr) > 2:\n        #    M[2] = max(arr[0],arr[1],arr[2]) * 3\n            \n        for i in range(1, len(arr)):\n            \n            if i < k:\n                M[i] = max(arr[:i+1]) * (i+1)\n            \n            for j in range(1, min(k+1, i+1)):\n                \n                M[i] = max(M[i], M[i-j] + max(arr[i-j+1:i+1]) * j)\n            \n        #print(M)\n            \n        return M[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        if k == 1:\n            return sum(arr)\n        \n        if k == len(arr):\n            max_val = max(arr)\n            return max_val * len(arr)\n        \n        sums = [-1 for index in range(k)]\n        maxs = [-1 for index in range(k)]\n        max_sum = 0\n        \n        sums[0] = arr[0]\n        maxs[0] = arr[0]\n        \n        for idx in range(1, len(arr)):\n            val = arr[idx]\n            max_sum = max(sums)\n            for ki in range(k-1, 0, -1):\n                max_val = maxs[ki-1]\n                if not max_val < 0:\n                    if val <= max_val:\n                        maxs[ki] = max_val\n                        sums[ki] = sums[ki-1] + max_val\n                    else:\n                        maxs[ki] = val\n                        sums[ki] = sums[ki-1] - max_val * ki + val * (ki + 1)\n            sums[0] = max_sum + val\n            maxs[0] = val\n        return max(sums)\n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*n\n        currMax = 0\n        \n        for i in range(n):\n            if i < k:\n                currMax = max(currMax,arr[i])\n                dp[i] = currMax * (i+1)\n            else:\n                currMax = 0\n                for j in range(1,k+1):\n                    currMax = max(currMax,arr[i-j+1])\n                    dp[i] = max(dp[i], dp[i-j]+currMax*j)\n        return dp[n-1]\n                    \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        '''Dynamic program using a list named dp, where dp[i] indicates the largest sum of the array arr[:i].'''\n        dp = [0] * len(arr)\n        for i in range(len(arr)):\n            maxsum = 0\n            for j in range(k):\n                if i - j >= 1:\n                    maxsum = max(maxsum, (j + 1) * max(arr[i - j: i + 1]) + dp[i - j - 1])\n                elif i - j >= 0:\n                    maxsum = max(maxsum, (j + 1) * max(arr[i - j: i + 1]))\n            dp[i] = maxsum\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [float('-inf') for _ in range(n + 1)]\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            j = i - 1\n            cnt = k\n            \n            while j >= 0 and cnt >= 1:\n                maximum = max(arr[j:i])\n                dp[i] = max(dp[i], dp[j] + maximum*(i-j))\n                j -= 1\n                cnt -= 1\n            \n        return dp[-1]\n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n+1)\n        for i, a in enumerate(A, 1):\n            for j in range(1, K+1):\n                # print(i, j, dp)\n                if i-j >= 0:\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j:i])*j)\n                else:\n                    break\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        # dp(i) = max array sum using elements up to index i\n        # dp(i) = for j = 1 to k, find max of dp(i-j) + j * max(arr[i-j:i])\n        \n        dp = [0 for i in range(len(arr))]\n        dp[0] = arr[0]\n        \n        for i in range(1, len(arr)):\n            ans = 0\n            for j in range(1, k+1):\n                if i-j >= 0:\n                    ans = max(ans, dp[i-j] + j * max(arr[i-j+1:i+1]))\n                elif i-j == -1:\n                    ans = max(ans, j * max(arr[i-j+1: i+1]))\n                    \n            dp[i] = ans\n        \n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n#don't really understand question. how did they partition exactly????        \n        \n        \n        #dynamic programming! \n        #let d[i] be the answer for A[0]...A[i-1]\n        ''' \n        S: d[i] be the answer for A[0]...A[i] answer = max sum of given array after partition. \n        R: want maximum of elements within K away from i. from hint 2:\n        d[i] = d[i-j] + max{A[i-j],..., A[i]}*j, for j between 1 and k. \n        #times j because the max of that partition becomes the corresponding max for all            the positions in transformed A. \n        B = d[0]\n        \n        '''\n        #base case:   \n\n        #reference: https://leetcode.com/problems/partition-array-for-maximum-sum/discuss/783353/dp-with-python-and-some-comments-of-idea\n        dp = [0]*(len(A)+1)\n        for i in range(1, len(A)+1):\n            temp = []\n            for j in range(1, K+1): #go through all possible values of j\n                if i - j >= 0:\n                    k = dp[i-j] + max(A[i-j:i])*j\n                    temp.append(k)\n                    # print(k)\n                    # dp[i] = max(k, dp[i]) \n                    #storing stuff in the same index so replacing it every time. \n\n            dp[i] = max(temp)\n        return dp[len(A)]\n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if (i-j)>=0:\n                    dp[i]= max(dp[i], dp[i-j]+ max(arr[i-j:i])*j)\n        \n        \n        return dp[n]\n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0]\n        for i in range(len(A)):\n            curr = 0\n            for j in range(i, max(-1, i - K), -1):\n                curr = max(max(A[j: i + 1]) * (i - j + 1) + dp[j], curr)\n            dp.append(curr)\n        print(dp)\n        return dp[-1]\n                \n                \n                \n\n                \n    \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        # dp[i] is the answer for array A[0] ... A[i-1]\n        # for j = 1 .. k, \n        #     dp[i] is the max of dp[i-j] + max(A[i-1] ... A[i-j]) * j\n        \n        # j = 1\n        #         dp[i-1] + max(A[i-1]) * 1\n        #         dp[i-2] + max(A[i-1], A[i-2]) * 2\n        #         dp[i-3] + max(A[i-1], A[i-2], A[i-3]) * 3\n        # ...\n        #         dp[i-k] + max(A[i-1], ..., A[i-k]) * 3\n        \n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if i-j>=0:\n                    dp[i] = max(dp[i], dp[i-j] + max(arr[i-j:i]) * j) # from i-j to i-1, with i-1-i+j+1 = j elements\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n=len(arr)\n        dp=[0]*(n+1)\n        for i in range(n):\n            m=-1\n            for j in range(1,k+1):\n                if (i-j+1)<0:\n                    break\n                m=max(m,dp[i-j+1]+max(arr[i-j+1:i+1])*(j))\n            dp[i+1]=m\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0 for _ in range(k + 1)]\n        rolling_max = -1\n        for i in range(0, k):\n            rolling_max = max(rolling_max, arr[i])\n            dp[i] = rolling_max * (i + 1)\n        for i in range(k, len(arr)):\n            rolling_max = arr[i]\n            for j in range(1, k + 1):\n                rolling_max = max(rolling_max, arr[i - j + 1])\n                dp[i % (k + 1)] = max(rolling_max * j + dp[(i - j) % (k + 1)], dp[i % (k + 1)])\n        return dp[(len(arr) - 1) % (k + 1)]", "# 10:28 -> misunderstood the problem\n# dp\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0 for num in arr]\n        for i in range(len(arr)):\n            prev_sum = 0 if i - 1 < 0 else dp[i - 1]\n            max_at_i = arr[i] + prev_sum\n            possible_ks = i if i < k - 1 else k - 1\n            for j in range(1, possible_ks + 1):\n                current_window = arr[i - j: i + 1]\n                current_max = max(current_window)\n                current_window_sum = len(current_window) * current_max\n                prev_window_sum = 0 if i - j - 1 < 0 else dp[i - j - 1]\n                total_sum = current_window_sum + prev_window_sum\n                if total_sum > max_at_i:\n                    max_at_i = total_sum\n            dp[i] = max_at_i\n            # print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        L=len(arr)\n        record=dict()\n        record[0]=0\n        for idx in range(1,L+1):\n            r=-float('inf')\n            for gap in range(1,k+1):\n                if idx-gap<0:\n                    continue\n                else:\n                    r=max(r,max(arr[idx-gap:idx])*gap+record[idx-gap])\n            record[idx]=r\n        return record[L]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n+1)\n        for i, a in enumerate(A, 1):\n            for j in range(1, K+1):\n                # print(i, j, dp)\n                if i-j >= 0:\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j:i])*j)\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * (len(arr) + 1)\n        dp[0] = 0\n        for i in range(len(arr)):\n            dp[i+1] = dp[i] + arr[i]\n            for j in range(k, 1, -1):\n                if i-j+1 >= 0:\n                    dp[i+1] = max(dp[i+1], dp[i-j+1] + max(arr[i-j+1:i+1]) * j)\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        hashmap = {}\n        def partitionMatrix(lst, currScore):\n            key = tuple(lst)\n            if key in hashmap:\n                return hashmap[key] + currScore\n            if lst == []:\n                hashmap[key] = 0\n                return currScore\n            for i in range(1, k + 1):\n                if len(lst) == i:\n                    hashmap[key] = (max(lst) * i)\n                    return currScore + (max(lst) * i)\n            best = currScore\n            for i in range(1, k + 1):\n                subScore = max(lst[:i]) * i\n                best = max(best, partitionMatrix(lst[i:], currScore + subScore))\n            hashmap[key] = best - currScore\n            return best\n        return partitionMatrix(arr, 0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp=[0]*(len(arr)+1)\n        dp[1]=arr[0]\n        for i in range(1,len(arr)):\n            for j  in range(max(0,i-k+1),i+1):\n                dp[i+1]=max(dp[i+1],dp[j]+max(arr[j:i+1])*(i-j+1))\n                \n            \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [[0 for _ in range(len(A))] for _ in range(2)]\n        \n        dp2 = [0 for _ in range(len(A))]\n        \n        for i in range(len(A)):\n            # we have 2 options - to partition or not to partition.\n            \n#             if i - K + 1 < 0:\n#                 maxCand = max(A[:i+1])\n#                 size = i + 1\n#             else:\n#                 maxCand = max(A[i - K + 1:i+1])\n#                 size = K\n                \n#             # if we choose not to partition\n#             dp[0][i] = size * maxCand + max(dp[0][i - K], dp[1][i - K])\n            \n#             # if we choose to partition at this candidate\n#             dp[1][i] = A[i] + max(dp[0][i - 1], dp[1][i - 1])\n\n            startIndex = max(0, i - K + 1)\n    \n            while startIndex <= i:\n                if startIndex - 1 >= 0:\n                    dp2[i] = max(dp2[startIndex - 1] + max(A[startIndex:i+1])*(i + 1 - startIndex), dp2[i])\n                else:\n                    dp2[i] = max(A[:i+1]) * (i + 1)\n                    \n                startIndex += 1\n                    \n        print(dp2)   \n        return dp2[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        # \n        def rec(l,h):\n            if h-l<K:\n                dp[l][h] = (h-l+1)*max(A[l:h+1])\n                return dp[l][h]\n            m = []\n            if dp[l][h]>0:\n                return dp[l][h]\n            for i in range(0,K):\n                m += [rec(l,l+i) + rec(l+i+1,h)]\n            dp[l][h] = max(m)\n            return dp[l][h]\n        \n        dp = [0]*len(A)\n        dp = [[0]*len(A) for i in range(len(A))]\n        \n        rec(0,len(A)-1)\n        \n        return dp[0][len(A)-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        size = len(arr)\n        mem = [0] * size\n\n        for i in range(size):\n            mem[i] = arr[i]\n            for j in range(0, k):\n                if i - j > 0:\n                    candidate = max(arr[i - j: i + 1]) * (j + 1) + mem[i - j - 1]\n                    mem[i] = max(mem[i], candidate)\n                elif i - j == 0:\n                    candidate = max(arr[i - j: i + 1]) * (j + 1)\n                    mem[i] = max(mem[i], candidate)\n                else:\n                    break\n        return mem[size - 1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        A = arr\n        dp = [0] * (n := len(arr))\n        dp[0] = curr_max = arr[0]\n        \n        for i in range(1, k):\n            curr_max = max(curr_max, A[i])\n            dp[i] = (i + 1) * curr_max\n        \n        for i in range(k, n):\n            curr_max = A[i]\n            for j in range(k):\n                curr_max = max(curr_max, A[i - j])\n                dp[i] = max(dp[i], dp[i - j - 1] + curr_max * (j + 1))\n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0]\n        for i in range(len(arr)):\n            max_sum = -float('inf')\n            for j in range(1, k+1):\n                if i - j + 1 < 0:\n                    break\n                max_sum = max(max_sum, max(arr[i-j + 1: i+1]) * j + dp[i - j + 1])\n            dp.append(max_sum)\n        return dp[-1]", "class Solution:\n    def getMax(self, arr, k, idx, cache):\n        # I am partitioning 1 element\n        if idx == len(arr) - 1:\n            return arr[idx]\n        # I need to get max sum after partitioning\n        maxSum = 0\n        \n        # [1,2,9,30]\n        # I need to try partitioning from 1 -> K elements\n        for numInPartition in range(1, k + 1):\n            # I cannot choose elements if I would be choosing too many elements\n            if idx + numInPartition > len(arr):\n                break\n            \n            startOfRecursiveIndex = idx + numInPartition\n            # select max value in first 'k' elements\n            maxVal = max(arr[idx:startOfRecursiveIndex])\n            \n            # generates sum for this subset\n            partSum = maxVal * numInPartition\n            \n            # I need to get the partition sum for the rest of the elements\n            \n            rest = cache[startOfRecursiveIndex] if startOfRecursiveIndex in cache else self.getMax(arr, k, startOfRecursiveIndex, cache)\n            \n            cache[startOfRecursiveIndex] = rest\n            \n            maxSum = max(maxSum, partSum + rest)\n        return maxSum\n            \n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        '''\n        Input:\n            A: int[] - Array of numbers\n            K: int - Max length allowable for subarray\n            \n        Output:\n            Return largest sum after partitioning.\n        \n        Steps:\n            1. Make partition\n            2. Change all elements to max value\n            \n           v            \n        [1,2,9,30], 2\n        \n        {1,2}{9,30} => {2,2}{30,30} => 4 + 60 = 64\n        {1}{2,9}{30} => {1}{9,9}{30} => 1 + 18 + 30 = 49\n        \n        \n        Example:\n            [1]\n            {1} = 1\n            \n            [1,2]\n            {1}{2} => 1+2 = 3\n            {1,2} => {2,2} => 4\n                 v\n            [1,2,9]\n            {1,2}{9} => {2,2} + {9} => 4 + 9 = 13\n            {1}{2,9} => {1},{9,9} = 1 + 18 = 19\n            {1,2,9}\n            \n            {1}{2,9}{30} => {1}{9,9}{30} => 19 + 30 => 49\n            {1,2}{9,30} => {2,2}{30,30} => 4 + 60 => 64\n            \n                 v\n            [1,2,9,30]\n            {1,2,9} {30} => 30 + getMaxSum([1,2,9]) => 30 + 19 => 49\n            {1,2} {9,30} => 60 + getMaxSum([1,2]) => 60 + 4 = 64\n            \n            {1}{2,9,30}\n            {1,2}{9,30}\n            {1,2,9}{30}\n        \n        All about subproblems!!\n        \n        Approach:\n            - Let's look into sliding window.\n            - We can frame this problem in terms of choices.\n                When considering an element, we can place it into its own partition OR with the preceeding partition.\n                Choice:\n                    K-way choice\n                    Do I group my current element in the last [1,k] elements?\n                Constraint:\n                    Subset needs to be contiguous?\n                Goal:\n                    Maximum sum\n                \n            1. When placing\n        Approach:\n            [0,0,0,0]\n            maxSum[i] = max(maxSum[i-1] + A[i] * 1, maxSum[i-2] + max(last two elements) * 2) and so on\n        '''\n        \n        cache = {}\n        return self.getMax(A, K, 0, cache)\n       \n    \n    \n    \n    \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        mem = {}\n        \n        def find(s, e):\n            if (s,e) in mem:\n                return mem[(s,e)]\n            \n            if e-s == 1:\n                return arr[s]\n            elif e-s == 0:\n                return 0\n            else:\n                m = None\n                for i in range(s+1, min(s+k+1, len(arr)+1)):\n                    subsum = max(arr[s:i])*(i-s) + find(i,e)\n                    if m is None or subsum > m:\n                        m = subsum\n                mem[(s,e)] = m\n                return m\n            \n        return find(0, len(arr))", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        if not arr:\n            return 0\n        n = len(arr)\n        dp = [0] * n\n        for i in range(n):\n            for j in range(k):\n                if i - j < 0:\n                    continue\n                _max = max(arr[i-j : i+1])\n                _sum = _max * (j+1) if i-j == 0 else dp[i-j-1] + _max*(j+1)\n                dp[i] = max(dp[i], _sum)\n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [nums[0]] + [0] * (n - 1)\n        for i in range(1, n):\n            for j in range(max(0, i - k + 1), i + 1):\n                dp[i] = max(dp[i], dp[j - 1] + max(nums[j:i + 1]) * (i + 1 - j))\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        from functools import lru_cache\n        @lru_cache(None)        \n        def dp(i):\n            ans=0\n            for k in range(K):\n                if i-k>=0:\n                    ans=max(ans,max(A[i-k:i+1])*(k+1)+dp(i-k-1))\n                    \n            return ans\n        \n        return dp(len(A)-1)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        if not arr:\n            return 0\n        \n        n = len(arr)\n        dp = [0]*n\n\n        for i in range(n):\n            for j in range(k):\n                if i-j < 0:\n                    continue\n                _max = max(arr[i-j:i+1])\n                _sum = _max*(j+1) if i-j == 0 else dp[i-j-1] + _max*(j+1)\n                dp[i] = max(dp[i], _sum)\n\n        return dp[-1]\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr, k):\n        if not arr:\n            return 0\n        \n        dp = [0]*len(arr)\n        \n        for i in range(len(arr)):\n            for j in range(k):\n                if i-j < 0 :\n                    continue\n                max_val = max(arr[i-j : i+1])\n                if i-j == 0:\n                    total = max_val * (j+1)\n                else:\n                    total = dp[i-j-1] + max_val * (j+1)\n                dp[i] = max(dp[i], total)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        dp = [0] * N\n        dp[0] = A[0]\n\n        for i in range(1, N):\n            for j in range(0, min(K, i+1)):\n                current_subarray = A[i-j:i+1]\n                if i >= K:\n                    dp[i] = max(dp[i], dp[i-j-1] + max(current_subarray)*(j+1))\n                else:\n                    dp[i] = max(dp[i], max(current_subarray)*(j+1))\n            \n        return dp[-1]\n            \n            \n        # [1,15,7,9,2,5,10] k = 3\n        # No need to inspect all combination, focus on growth\n        \n        # (1)\n        # [1] -> 1 - max(A[i])*1\n        \n        # (1,15)\n        # [1,15] -> 30 - max(A[i-1], A[i])*2\n        # [1][15] -> 16 - DP[i-1] + A[i]\n        \n        0,1\n        1,1\n        \n        # (1,15,7)\n        # [1,15,7] -> 45 max(A[i]. A[i-1], A[-2])*3\n        # [1][15,7] -> 23 - DP[i-2] + max(A[i-1], A[i])*2\n        # [1,15][7] -> 37 - DP[i-1] + A[i]\n        \n        # (1,15,7,9)\n        # [1,15,7][9] -> 54 DP[i-1] + A[i]\n        # [1,15][7,9] -> 32 DP[i-2] + max(A[i-1], A[i])*2\n        # [1][15,7,9] -> 46 DP[i-3] + max(A[i-2], A[i-1], A[i])*3\n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * n\n        for i in range(n):\n            if i == 0:\n                dp[i] = A[0]\n            else:\n                # A[i-k+1, ..., i-1, i] is a subarray\n                # A[0, 1, 2, ..., i-k] is previous chuck with subarray length up to K\n                for k in range(1, K+1):\n                    if i-k+1 < 0:\n                        break\n                    elif i-k+1 == 0:\n                        dp[i] = max(dp[i], max(A[i-k+1:i+1]) * k)\n                    else:\n                        dp[i] = max(dp[i], dp[i-k] + max(A[i-k+1:i+1]) * k)\n        return dp[n-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        if not arr:\n            return 0\n        \n        n = len(arr)\n        dp = [0]*n\n\n        for i in range(n):\n            for j in range(k):\n                if i-j < 0:\n                    continue\n                _max = max(arr[i-j:i+1])\n                _sum = _max*(j+1) if i-j == 0 else dp[i-j-1] + _max*(j+1)\n                dp[i] = max(dp[i], _sum)\n\n        return dp[-1]", "class Solution:\n    \n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        n = len(A)\n        dp = [0] * (n + 1)\n        \n        for i in range(n):\n            for k in range(1,K+1):\n                if i-k > -2: dp[i+1] = max(dp[i+1], max(A[max(0,i-k+1):i+1]) * k + dp[i+1-k])\n                \n        return dp[n]", "class Solution:\n    \n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        n = len(A)\n        dp = [0] * (n + 1)\n        \n        for i in range(n):\n            dp_ix = i+1\n            for k in range(1,K+1):\n                if i-k > -2:\n                    dp[dp_ix] = max(dp[dp_ix], max(A[max(0,i-k+1):i+1]) * k + dp[dp_ix-k])\n                \n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [[0 for _ in range(len(A))] for _ in range(2)]\n        \n        dp2 = [0 for _ in range(len(A))]\n        \n        for i in range(len(A)):\n            # we have 2 options - to partition or not to partition.\n            \n#             if i - K + 1 < 0:\n#                 maxCand = max(A[:i+1])\n#                 size = i + 1\n#             else:\n#                 maxCand = max(A[i - K + 1:i+1])\n#                 size = K\n                \n#             # if we choose not to partition\n#             dp[0][i] = size * maxCand + max(dp[0][i - K], dp[1][i - K])\n            \n#             # if we choose to partition at this candidate\n#             dp[1][i] = A[i] + max(dp[0][i - 1], dp[1][i - 1])\n\n            startIndex = max(0, i - K + 1)\n            currMax = 0\n            while startIndex <= i:\n                currMax = max(currMax, A[startIndex])\n                if startIndex - 1 >= 0:\n                    dp2[i] = max(dp2[startIndex - 1] + max(A[startIndex:i+1])*(i + 1 - startIndex), dp2[i])\n                else:\n                    dp2[i] = max(A[:i+1]) * (i + 1)\n                    \n                startIndex += 1\n                    \n        print(dp2)   \n        return dp2[-1]", "\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * len(arr)\n        \n        for i in range(len(arr)):\n            print(arr[i])\n            max_so_far = arr[i] + (dp[i-1] if i > 0 else 0)\n            for j in range(1, min(i+1, k)):\n                max_in_range = max(arr[i-j:i+1])\n                max_so_far = max(max_so_far, dp[i-j-1] + max_in_range * (j+1))\n            dp[i] = max_so_far\n        return dp[len(arr)-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * (len(arr))\n        dp[0] = arr[0]\n        for i,val in enumerate(arr):\n            if i == 0: continue\n            cur_max = val + dp[i-1]\n            cur_k = 1\n            while(i-cur_k>=0 and cur_k < k):\n                temp = arr[i-cur_k:i+1]\n                m = max(temp)\n                if i-cur_k==0: cur_max = max(cur_max, m* (cur_k+1) )\n                else:\n                    cur_max = max(cur_max,( m * (cur_k+1)) + dp[i-cur_k-1] )\n                cur_k += 1\n            dp[i] = cur_max\n        return dp[-1]\n            \n        '''    \n        #[1,4,1, 5, 7, 3, 6, 1, 9, 9, 3]\n        # 1 5\n        \n        \n        \n        \n        \n        \n        '''\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        DP = [0 for _ in range(len(arr)+1)]\n        for i in range(1,len(DP)):\n            loc = max(i-k,0)\n            run_max = 0\n            for j in range(loc,i):\n                run_max = max(run_max,DP[j]+max(arr[j:i])*(i-j))\n            DP[i] = run_max\n        return DP[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        if not K or K == 1:\n            return sum(A)\n        if not A:\n            return 0\n\n        dp = [0] * len(A)\n        for index, num in enumerate(A):\n            possible = []\n            for group in range(K):\n                if index - group >= 0:\n                    if index - group - 1 >= 0:\n                        previous = dp[index - group - 1]\n                    else:\n                        previous = 0\n                    possible.append(\n                        previous + max(A[index - group : index + 1]) * (group + 1)\n                    )\n\n            dp[index] = max(possible)\n            # print(f\\\"{index=} {dp[index]=}\\\")\n        return dp[-1]\n", "class Solution:\n    \n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        self.arr = arr\n        self.dp = {}\n        \n        def helper(i,j,k):\n            \n            if j <= i:\n                return 0\n            \n            if (i,j) in self.dp:\n                return self.dp[(i,j)]\n            \n            maxsum = -sys.maxsize\n            \n            for length in range(1,k+1):\n                \n                if i+length <= j:\n                    \n                    currsum = (max(self.arr[i:i+length]) * length) + helper(i+length,j,k)\n                    maxsum = max(maxsum,currsum)\n            \n            self.dp[(i,j)] = maxsum\n            return self.dp[(i,j)]\n        \n        return helper(0,len(arr),k)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        \n        dp=[0 for _ in A]\n        \n        for i,num in enumerate(A):\n            for j in range(K):\n                ans=0            \n                if i-j>=0:\n                    ans = ans + (j+1)*max(A[i-j:i+1])\n                if i-j-1>=0:\n                    ans = ans + dp[i-j-1]\n                dp[i]=max(dp[i],ans)\n                \n                \n#                 if i-p-1>=0:\n#                     ans=dp[i-p-1]+(p+1)*max(A[i-p:i+1])\n#                     print(A[i-p-1],(p+1)*max(A[i-p:i+1]))\n#                     dp[i]=max(dp[i],ans)\n        \n        #print(dp)\n        \n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        d = [0] * (1 + len(arr) + k)\n        for ind in range(1, len(arr) + 1):\n            for sub_arr_st in range(min(ind, k)):\n                if arr[ind - sub_arr_st - 1] > arr[ind - 1]:\n                    break\n                for sub_arr_len in range(sub_arr_st + 1, k + 1):\n                    ind_x = ind - sub_arr_st + sub_arr_len - 1\n                    d[ind_x] = max(d[ind_x], d[ind - sub_arr_st - 1] + arr[ind - 1] * sub_arr_len)\n        return d[len(arr)]", "class Solution:\n    \n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp=[0]*(len(arr)+1)\n        dp[0]=arr[0]\n        for i in range(1,len(arr)):\n            ans=-100000\n            for z in range(max(0,i-k+1) ,  i+1):\n                # print(z,i+1)\n                ans=max(dp[z-1]+max(arr[z:i+1])*(i-z+1) , ans)\n                # ans=max(dp[i-z-1]+max(arr[i-z-1:i+1])*(z+1),ans)\n            dp[i]=ans\n        return dp[-2]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        cacheMax=[[0]*len(arr) for i in range(len(arr))]\n        for i in range(len(arr)):\n            cacheMax[i][i]=arr[i]\n        for i in range(1,len(arr)):\n            for j in range(i):\n                cacheMax[j][i] = max(cacheMax[j][i-1],arr[i])\n        \n        \n        \n        \n        dp=[0]*(len(arr)+1)\n        dp[1]=arr[0]\n        for i in range(1,len(arr)):\n            for j  in range(max(0,i-k+1),i+1):\n                dp[i+1]=max(dp[i+1],dp[j]+max(arr[j:i+1])*(i-j+1))\n                \n            \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        memo = {}\n\n        l_arr = len(arr)\n\n        for chain_len in range(0, k, 1):\n            for i in range(0, l_arr - chain_len, 1):\n                memo[(i, i + chain_len)] = max(arr[i : i + chain_len + 1]) * (chain_len + 1)\n        res_memo = {}    \n\n        def dfs(idx):\n            if idx == l_arr:\n                return 0\n\n            if idx in res_memo:\n                return res_memo[idx]\n\n            res_memo[idx] = max( memo[(idx, idx + j)] + dfs(idx + j + 1) for j in range(k) if idx + j < l_arr )\n            return res_memo[idx]\n\n        return dfs(0)", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        # use dp to solve this question\n        n = len(A)\n        dp = [0] * (n + 1)\n        # dp[i] is the answer for array A[0] ... A[i-1]\n        # for j = 1 .. k, \n        #     dp[i] is the max of dp[i-j] + max(A[i-1] ... A[i-j]) * j\n        \n        # j = 1\n        #         dp[i-1] + max(A[i-1]) * 1\n        #         dp[i-2] + max(A[i-1], A[i-2]) * 2\n        #         dp[i-3] + max(A[i-1], A[i-2], A[i-3]) * 3\n        # ...\n        #         dp[i-k] + max(A[i-1], ..., A[i-k]) * 3\n        \n        for i in range(1, n+1):\n            for j in range(1, K+1):\n                if i-j>=0:\n                    dp[i] = max(dp[i], dp[i-j] + max(A[i-j:i]) * j) # from i-j to i-1, with i-1-i+j+1 = j elements\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0 for i in range(len(A)+1)]\n        for i in range(1, len(A)+1):\n            dp[i] = max([dp[i-j] + j * max(A[i-j:i]) for j in range(1, K+1) if j <= i])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        res = [0] * (len(arr) + 1)\n        \n        for i in range(1, len(arr) + 1):\n            for j in range(1, k + 1):\n                if i - j > -1:\n                    res[i] = max(res[i], res[i - j] + max(arr[i - j : i]) * j)\n        \n        return res[-1] ", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        ar_len = len(arr)\n        dp= [0] * (ar_len+1)\n        for i in range(1,len(dp)):\n            tmp_max = []\n            for j in range(1,k+1):\n                if i-j >=0:\n                    max_t = dp[i-j] + max(arr[i-j:i]) * j\n                    tmp_max.append(max_t)\n            dp[i] = max(tmp_max)\n            \n        return dp[-1]\n                \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        if k == n: return n * max(arr)\n        dp = collections.deque([0] * k)\n        for i in range(n - 1, -1, -1):\n            m = 0\n            result = 0\n            for j in range(min(k, n - i)):\n                m = max(m, arr[i + j])\n                result = max(result, m * (j + 1) + dp[j])\n            dp.appendleft(result)\n            dp.pop()\n        return dp[0]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        dp = [0] * N\n        dp[0] = A[0]\n        #print('DP:', dp)\n        #print()\n        for i in range(1, N):\n            for j in range(0, min(K, i+1)):\n                current_subarray = A[i-j:i+1]\n                #print( max(current_subarray)*(j+1), current_subarray, i, j)\n                if i >= K:\n                    dp[i] = max(dp[i], dp[i-j-1] + max(current_subarray)*(j+1))\n                else:\n                    dp[i] = max(dp[i], max(current_subarray)*(j+1))\n            \n            \n            #print('DP:', dp)\n            #print()\n            \n        return dp[-1]\n            \n            \n        # [1,15,7,9,2,5,10] k = 3\n        # No need to inspect all combination, focus on growth\n        \n        # (1)\n        # [1] -> 1 - max(A[i])*1\n        \n        # (1,15)\n        # [1,15] -> 30 - max(A[i-1], A[i])*2\n        # [1][15] -> 16 - DP[i-1] + A[i]\n        \n        0,1\n        1,1\n        \n        # (1,15,7)\n        # [1,15,7] -> 45 max(A[i]. A[i-1], A[-2])*3\n        # [1][15,7] -> 23 - DP[i-2] + max(A[i-1], A[i])*2\n        # [1,15][7] -> 37 - DP[i-1] + A[i]\n        \n        # (1,15,7,9)\n        # [1,15,7][9] -> 54 DP[i-1] + A[i]\n        # [1,15][7,9] -> 32 DP[i-2] + max(A[i-1], A[i])*2\n        # [1][15,7,9] -> 46 DP[i-3] + max(A[i-2], A[i-1], A[i])*3\n        \n        \n        \n        \n        \n        \n        \n                # N = len(A)\n        # dp = [0] * (N + 1)\n        # for i in range(N):\n        #     curMax = 0\n        #     for k in range(1, min(K, i + 1) + 1):\n        #         curMax = max(curMax, A[i - k + 1])\n        #         dp[i] = max(dp[i], dp[i - k] + curMax * k)\n        #         print(dp)\n        #     print()\n        # return dp[N - 1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, nums: List[int], k: int) -> int:\n        '''\n        \n               v\n        [1,30,45,_,_,_,_,????]\n        [1,15,7, 9,2,5,10], 2\n        \n        dp[i] = max( (windowSize * maxInWindow) + dp[i - windowSize] ) for valid windowSize from 1 to k\n        \n        return dp[-1]\n        \n        30 + [7] => 37\n        1  + [15,7] => 31\n        0  + [1,15,7] => 45 <<<<<\n        [1,15]\n        '''\n        \n        dp = [0] * len(nums)\n        \n        for i in range(len(nums)):\n            \n            # generate all window sizes\n            # [1,2,3]\n            # if k = 3\n            for windowSize in range(1, k + 1):\n                startIndex = i - windowSize + 1\n                \n                # Bounding Function to make sure that I don't run out of bounds\n                if startIndex < 0:\n                    break\n                \n                #         v\n                #           v \n                # # [1,15,7,9,2,5,10]\n                \n                maxVal = max(nums[startIndex: i + 1])\n                \n                currVal = windowSize * maxVal\n                \n                \n                currSum = currVal\n                \n                if startIndex > 0:\n                    currSum += dp[startIndex - 1]\n                    \n                dp[i] = max(dp[i], currSum)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        memo = {n:0}\n        def helper(arr, i):\n            if i in memo:\n                return memo[i]\n            res = 0\n            for j in range(i, min(n,i+k)):\n                res = max(res, helper(arr, j+1)+max(arr[i:j+1])*(j+1-i))\n            memo[i] = res\n            return res\n        return helper(arr, 0)", "class Solution:\n    def maxSumAfterPartitioning(self, nums: List[int], k: int) -> int:\n        '''\n        \n               v\n        [1,30,45,_,_,_,_,????]\n        [1,15,7, 9,2,5,10], 2\n        \n        dp[i] = max( (windowSize * maxInWindow) + dp[i - windowSize] ) for valid windowSize from 1 to k\n        \n        return dp[-1]\n        \n        30 + [7] => 37\n        1  + [15,7] => 31\n        0  + [1,15,7] => 45 <<<<<\n        [1,15]\n        '''\n        \n        dp = [0] * len(nums)\n        \n        for i in range(len(nums)):\n            \n            # generate all window sizes\n            # [1,2,3]\n            # if k = 3\n            for windowSize in range(1, k + 1):\n                startIndex = i - windowSize + 1\n                \n                # Bounding Function to make sure that I don't run out of bounds\n                if startIndex < 0:\n                    break\n                \n                #         v\n                #           v \n                # # [1,15,7,9,2,5,10]\n                \n                maxVal = max(nums[startIndex: i + 1])\n                \n                currVal = windowSize * maxVal\n                \n                \n                currSum = currVal\n                \n                if startIndex > 0:\n                    currSum += dp[startIndex - 1]\n                    \n                dp[i] = max(dp[i], currSum)\n        print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0 for i in range(len(A)+1)]\n        for i in range(1, len(A)+1):\n            dp[i] = max([dp[i-j] + j * max(A[i-j:i]) for j in range(1, K+1) if j <= i])\n        print(dp)\n        return dp[-1]", "\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * len(arr)\n        \n        for i in range(len(arr)):\n            max_so_far = arr[i] + (dp[i-1] if i > 0 else 0)\n            for j in range(1, min(i+1, k)):\n                max_in_range = max(arr[i-j:i+1])\n                max_so_far = max(max_so_far, dp[i-j-1] + max_in_range * (j+1))\n            dp[i] = max_so_far\n        return dp[len(arr)-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        result = [0]*len(arr)\n        result[0] = arr[0]\n        max_val = result[0]\n        for i in range(1,k):\n            max_val = max(max_val,arr[i])\n            result[i] = max_val*(i+1)\n        #print(result)\n        for i in range(k,len(arr)):\n            max_val = arr[i]\n            for j in range(1,k+1):\n                max_val = max(max_val,arr[i-j+1])\n                result[i] = max(result[i],result[i-j]+max_val*j)\n                #print(i,j,max_val,result[i])\n        #print(result)\n        return result[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        A = arr\n        \n        K = k\n        \n        n = len(A)\n        dp = [0] * n\n        curMax = 0\n        for i in range(n):\n            if i < K: \n                curMax = max(curMax, A[i])\n                dp[i] = curMax * (i + 1)\n            else:\n                curMax = 0\n                for j in range(1, K + 1):\n                    curMax = max(A[i - j + 1], curMax)\n                    dp[i] = max(dp[i], dp[i - j] + curMax * j)\n                    \n                    \n        # print(dp)\n        \n        return dp[n - 1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        if not arr:\n            return 0\n        n = len(arr)\n        dp = [0] * n\n        curr_max = arr[0]\n        for i in range(k):\n            curr_max = max(curr_max, arr[i])\n            dp[i] = curr_max * (i + 1)\n        \n        for i in range(k, n):\n            dp[i] = arr[i]\n            curr_max = arr[i]\n            for j in range(k):\n                curr_max = max(curr_max, arr[i-j])\n                dp[i] = max(dp[i], dp[i-j-1] + curr_max * (j + 1))\n        return dp[-1]\n            \n        \n        # @lru_cache(None)\n        # def dp(idx):\n        #     if idx < 0:\n        #         return 0\n        #     left = max(0, idx - k + 1)\n        #     curr_max = arr[idx]\n        #     res = arr[idx]\n        #     for i in range(idx, left - 1, -1):\n        #         curr_max = max(curr_max, arr[i])\n        #         res = max(res, dp(i-1) + curr_max * (idx - i + 1))\n        #     return res\n        # return dp(len(arr)-1)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        for i in range(1, n+1):\n            max_val = float('-inf')\n            for j in range(1, min(i, k)+1):\n                max_val = max(max_val, arr[i-j])\n                dp[i] = max(dp[i], dp[i-j] + j*max_val)\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp=[0]*len(arr)\n        dp[0]=arr[0]\n        max1=arr[0]\n        for i in range(1,k):\n            max1=max(max1,arr[i])\n            dp[i]=max1*(i+1)\n     \n        for i in range(k,len(arr)):\n            max1=arr[i]\n           \n            for j in range(1,k+1):\n                dp[i]=max(dp[i],max1*j+dp[i-j])\n                max1=max(arr[i-j],max1)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n\n        f = [0]\n        for end in range(1, len(arr)+1):\n            _local = 0\n            _cur_max = 0\n            for start in range(end-1, max(0, end-k)-1, -1):\n                _cur_max = max(_cur_max, arr[start])\n                _local = max(_cur_max *(end - start)+f[start], _local)\n                \n                \n            f.append(_local)\n        return f[-1]\n    \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr, k):\n        n = len(arr)\n        dp = [0]*(n+1)\n        for i in range(n):\n            cmax = 0\n            for j in range(1, min(k, i+1) + 1):\n                cmax = max(cmax, arr[i-j+1])\n                dp[i] = max(dp[i], dp[i-j] + cmax*j)\n        return dp[-2]\n                \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            curMax = 0\n            for j in range(1, min(k, i + 1) + 1):\n                curMax = max(curMax, arr[i - j + 1])\n                dp[i] = max(dp[i], dp[i - j] + curMax * j)\n        return dp[n - 1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        best_sums = [0] * (len(arr)+1)\n        for i in range(len(arr)):\n            curr_max = 0\n            for j in range(1,min(k+1,i+2)):\n                curr_max = max(curr_max, arr[i-j+1])\n                best_sums[i] = max(best_sums[i], best_sums[i-j] + j*curr_max)\n        return best_sums[-2]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        DP=[0]*len(arr)\n        N=len(arr)\n        DP[0]=arr[0]\n        m=arr[0]\n        for i in range(k):\n            m=max(m,arr[i])\n            DP[i]=m*(i+1)\n            \n      #  print(DP)\n        for i in range(k,N):\n            mm=arr[i]\n            DP[i]=DP[i-1]+arr[i]\n        #    print(DP[i],i)\n          #  print(i,DP,mm,arr[i])\n            for j in range(1,k):\n                mm=max(mm,arr[i-j])\n             #   print(i,mm,arr[i-j],DP[i-j])\n                DP[i]=max(DP[i],DP[i-j-1]+mm*(j+1))\n            #DP[i]=max(DP[i-1]+arr)\n    #    print(DP)\n        return DP[-1]\n  #  [5,7,7,7,7]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n=len(arr)\n        dp=[0]*(n+1)\n        \n        \n        for i in range(n):\n            cur=0\n            for j in range(1,min(k,i+1)+1):\n                cur=max(cur,arr[i-j+1])\n                dp[i]=max(dp[i],cur*j+dp[i-j])\n        return dp[-2]\n                \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        \n        for i in range(n):\n            cur_max = 0\n            for j in range(1, min(k, i + 1) + 1):\n                cur_max = max(cur_max, arr[i - j + 1])\n                dp[i] = max(dp[i], dp[i - j] + cur_max * j)\n                \n        return dp[n - 1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        @lru_cache(None)\n        def dp(idx):\n            if idx < 0:\n                return 0\n            left = max(idx - k + 1, 0)\n            curr_max = arr[idx]\n            res = arr[idx]\n            for i in range(idx, left - 1, -1):\n                curr_max = max(curr_max, arr[i])\n                res = max(res, dp(i-1) + (idx - i + 1) * curr_max)\n            return res\n        # print(dp(3))\n        return dp(len(arr) - 1)\n        \n        # A = arr\n        # dp = [0] * (n := len(arr))\n        # dp[0] = curr_max = arr[0]\n        # for i in range(1, k):\n        #     curr_max = max(curr_max, A[i])\n        #     dp[i] = (i + 1) * curr_max\n        # for i in range(k, n):\n        #     curr_max = A[i]\n        #     for j in range(k):\n        #         curr_max = max(curr_max, A[i-j])\n        #         dp[i] = max(dp[i], dp[i-j-1] + curr_max * (j + 1))\n        # return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:        \n        N = len(arr)\n        dp = [0] * (N+1)\n        for i in range(N):\n            cur_max = 0\n            for j in range(1, min(k, i+1)+1):\n                cur_max = max(cur_max, arr[i-j+1]) # \u4ece\u5f53\u524d\u5143\u7d20\u5f00\u59cb\n                dp[i] = max(dp[i], dp[i-j]+cur_max*j)\n        return dp[N-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        # O(NK) coming sooooon\n\n        N = len(arr)\n        dp = [0 for _ in range(N)] \n\n        dp[0] = arr[0]\n        max_so_far = arr[0]\n        for i in range(1, k):\n            max_so_far = max(max_so_far, arr[i])\n            dp[i] = (i+1) * max_so_far\n        \n        # now the actual thing\n        for i in range(k, N):\n            max_so_far = -sys.maxsize\n\n            for j in range(i, i-k, -1):\n                max_so_far = max(max_so_far, arr[j])\n                dp[i] = max(dp[i], dp[j-1] + (i-j+1) * max_so_far)\n        \n        return dp[N-1]\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            max_val = float('-inf')\n            for w in range(1, K + 1):\n                if i - w < 0: break\n                max_val = max(max_val, A[i - w])\n                dp[i] = max(dp[i], dp[i - w] + max_val * w)\n            \n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            cur = 0\n            for j in range(1, K + 1):\n                if i >= j:\n                    cur = max(cur, A[i - j])\n                    dp[i] = max(dp[i], dp[i - j] + cur * j)\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n+1)\n        for i in range(1,n+1):\n            j = i - 1\n            mx = -float('inf')\n            while i - j <= k and j >= 0:\n                mx = max(mx,arr[j])\n                dp[i] = max(dp[i],dp[j]+mx * (i - j))\n                j -= 1\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        n = len(A)\n        dp = [0] * (n+1)\n        for i in range(1,n+1):\n            j = i - 1\n            mx = -float('inf')\n            while i - j <= K and j >= 0:\n                mx = max(mx,A[j])\n                dp[i] = max(dp[i],dp[j]+mx * (i - j))\n                j -= 1\n        return dp[n]\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * (len(arr)+1)\n        for i in range(1, len(dp)):\n            maxone = 0\n            for j in range(i, i-k, -1):\n                if j >= 1:\n                    maxone = max(maxone, arr[j-1])\n                    dp[i] = max(dp[i], dp[j-1]+maxone * (i-j+1))\n        return dp[-1]", "class Solution:     \n    def maxSumAfterPartitioning(self, A, K):\n        N = len(A)\n        dp = [0] * (N + 1)\n        for i in range(N):\n            curMax = 0\n            for k in range(1, min(K, i + 1) + 1):\n                curMax = max(curMax, A[i - k + 1])\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\n        return dp[N - 1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        DP = [0]*(N+1)\n        for i in range(N):\n            curMax = 0\n            for k in range(1, min(K, i+1) + 1):\n                curMax = max(curMax, A[i-k+1])\n                DP[i] = max(DP[i], DP[i-k] + curMax * k)\n        return DP[N-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n+1)\n        for i in range(n):\n            cur_max = 0\n            for d in range(1, min(k, i+1)+1):\n                cur_max = max(cur_max, arr[i-d+1])\n                dp[i+1] = max(dp[i+1], dp[i+1-d] + cur_max * d) \n            # print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n=len(arr)\n        dp=[0]*(n+1)\n        for i in range(n):\n            m=-1\n            x=-1\n            for j in range(1,k+1):\n                if (i-j+1)<0:\n                    break\n                x=max(x,arr[i-j+1])\n                m=max(m,dp[i-j+1]+x*j)\n            dp[i+1]=m\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0 for _ in arr]\n        rolling_max = -1\n        for i in range(0, k):\n            rolling_max = max(rolling_max, arr[i])\n            dp[i] = rolling_max * (i + 1)\n        for i in range(k, len(arr)):\n            rolling_max = arr[i]\n            for j in range(1, k + 1):\n                rolling_max = max(rolling_max, arr[i - j + 1])\n                dp[i] = max(rolling_max * j + dp[i - j], dp[i])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0]\n        for i in range(1, len(arr) + 1) :\n            max_arr_num = 0\n            now_max = 0\n            for j in range(1, k + 1) :\n                idx = i - j\n                if idx >= 0 :\n                    max_arr_num = max(max_arr_num, arr[idx])\n                    now_max = max(now_max, dp[idx] + max_arr_num * j)\n            dp.append(now_max)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        dp = [0] * (n+1)\n        for i in range(1,n+1):\n            m = float('-inf')\n            for j in range(1,K+1):\n                if i - j >= 0:\n                    m = max(A[i-j],m)\n                    dp[i] = max(dp[i],dp[i-j] + m*j)\n        return dp[-1]\n        \n        \n        # n = len(A)\n        # dp = [0] * (n+1)\n        # for i in range(1,n+1):\n        #     m = float('-inf')\n        #     for j in range(1,K+1):\n        #         if i - j >= 0:\n        #             m = max(A[i-j],m)\n        #             dp[i] = max(dp[i],dp[i-j]+m*j)\n        # return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        n = len(A)\n        \n        dp = [0] * (n+1)\n        res = 0 \n        for i in range(n):\n            max_val = 0\n            for k in range(1, min(K, i+1)+1):\n                max_val = max(max_val, A[i-k+1])\n                dp[i] = max(dp[i], dp[i-k] + max_val*k)\n        return dp[n-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0] * (len(arr))\n        dp[0] = arr[0]\n        for i,val in enumerate(arr):\n            if i == 0: continue\n            cur_max = val + dp[i-1]\n            cur_k = 1\n            m = val\n            while(i-cur_k>=0 and cur_k < k):\n                # temp = arr[i-cur_k:i+1]\n                m = max(m,arr[i-cur_k])\n                if i-cur_k==0: cur_max = max(cur_max, m* (cur_k+1) )\n                else:\n                    cur_max = max(cur_max,( m * (cur_k+1)) + dp[i-cur_k-1] )\n                cur_k += 1\n            dp[i] = cur_max\n        return dp[-1]\n            \n        '''    \n        #[1,4,1, 5, 7, 3, 6, 1, 9, 9, 3]\n        # 1 5\n        \n        \n        \n        \n        \n        \n        '''\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        d = [0] * (len(arr) + 1)\n\n        for i in range(len(arr)):\n            cur_max = 0\n\n            for kk in range(1, k + 1):\n                if i - kk + 1 < 0:\n                    continue\n\n                cur_max = max(cur_max, arr[i-kk+1])\n\n                # print(i, kk, \\\",\\\", i - kk + 1, cur_max, arr[i-kk+1], ':', d[i], d[i-kk])\n\n                d[i] = max(d[i], d[i-kk] + cur_max*kk)\n\n        print(d)\n\n        return d[-2]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        N = len(A)\n        dp = [0]*(N+1)\n        \n        for i in range(N):\n            curr_max = 0\n            for j in range(1, K+1):\n                if i+j>N: break\n                curr_max = max(curr_max, A[i+j-1])\n                dp[i+j] = max(dp[i+j], dp[i]+curr_max*j)\n                \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [float('-inf') for i in range(len(A)+1)]\n        dp[-1] = 0\n        dp[-2] = A[-1]\n        \n        for j in reversed(list(range(len(A)-1))):\n            cur_max = float('-inf')\n            for k in range(K):\n                if j+k == len(A):\n                    break\n                cur_max = max(cur_max, A[j+k])\n                dp[j] = max(dp[j], (k+1)*cur_max + dp[j+k+1])\n        \n        return dp[0]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp=[0]*len(arr)\n        dp[0]=arr[0]\n        for i in range(1, len(arr)):\n            maxval=arr[i]\n            for j in range(i, i-k, -1):\n                if j<0:\n                    break\n                maxval=max(maxval, arr[j])\n                temp=dp[j-1] if j-1>=0 else 0\n                temp+=maxval*(i-j+1)\n                dp[i]=max(dp[i], temp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\n        N = len(A)\n        dp = [0] * (N+1)\n        \n        for i in range(N):\n            mx = 0\n            #print('i={}'.format(i))\n            for j in range(i, max(-1, i-k), -1):\n                mx = max(mx, A[j])\n                #print('  j={}, mx={}'.format(j, mx))\n                p = dp[i+1]\n                dp[i+1] = max(dp[i+1], dp[j] + mx * (i-j+1)) \n                #print('  p={}, c={}'.format(p, dp[i+1]))       \n            #print('c={}'.format(dp[i+1]))       \n        return dp[N]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n            dp = [float('-inf') for i in range(len(A)+1)]\n            dp[-1] = 0\n            dp[-2] = A[-1]\n\n            for j in reversed(range(len(A)-1)):\n                cur_max = float('-inf')\n                for k in range(K):\n                    if j+k == len(A):\n                        break\n                    cur_max = max(cur_max, A[j+k])\n                    dp[j] = max(dp[j], (k+1)*cur_max + dp[j+k+1])\n\n            return dp[0]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0] * (len(A) + 1)\n        \n        for i in range(1, len(A) + 1):\n            \n            tmp = 0\n            tmp_max = 0\n            \n            for j in range(1, min(i,K) + 1):\n                tmp_max = max(A[i-j], tmp_max)\n                tmp = max(tmp, dp[i-j] + tmp_max * j)\n            \n            dp[i] = tmp\n        \n        return dp[len(A)]\n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, A, K):\n        # https://leetcode.com/problems/partition-array-for-maximum-sum/discuss/290863/JavaC%2B%2BPython-DP\n        # Use dp (record[i+1]) to record the maximum sum can be obtained from A[0]-A[i]\n        # For each position, we loop back 1 to k elements and find the maximum within each range\n        # And replace them all with the maximum and try to find the maximum sum based on record[i-k+1]\n        n = len(A)\n        record = [0]*(n+1)\n        for i in range(n):\n            curMax = 0\n            for k in range(1,min(K,i+1)+1):\n                curMax = max(curMax,A[i-k+1])\n                record[i+1] = max(record[i+1],record[i-k+1]+curMax*k)\n        return record[n]\n        \n        # N = len(A)\n        # dp = [0] * (N + 1)\n        # for i in range(N):\n        #     curMax = 0\n        #     for k in range(1, min(K, i + 1) + 1):\n        #         curMax = max(curMax, A[i - k + 1])\n        #         dp[i+1] = max(dp[i+1], dp[i+1 - k] + curMax * k)\n        # return dp[N]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0] * (len(A) + 1)\n        for i in range(len(A)):\n            value = A[i]\n            for j in range(1, K + 1):\n                if i + j - 1 >= len(A):\n                    break\n                value = max(A[i + j - 1], value)\n                dp[i + j] = max(dp[i] + value * j, dp[i + j])\n        return dp[-1]\n       \n        \n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            m = -float('inf')\n            d = 0\n            while d < k and i - d > 0:\n                m = max(m, arr[i - 1 - d])\n                dp[i] = max(dp[i], dp[i - d - 1] + m * (d + 1))\n                d += 1\n        return dp[n]\n", "'''\nSo this can be a subproblem of different lengths of k and subarrays\n\nso f([1,15,7,9,2,5,10]) = 1 + f([15,7,9,2,5,10]]) or 15 * 2 + f([7,9,2,5,10]]) or \n                            15 * 3 + f([7,9,2,5,10]])\n                            \nif not arr, then we return\n'''\nclass Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        N = len(arr)\n\n        memo = {}\n        def maxSum2(i):\n            if i >= N:\n                return 0\n            if i in memo: return memo[i]\n            val = -1\n            sol = -1\n            # traverse k times or until end of array. + 1 to offset 0 index so we can multiply val * j straight up\n            for j in range(1, min(k+1, N - i + 1)):\n                val = max(val, arr[i + j -1])\n                sol = max(sol, val * j + maxSum2(i + j))\n            memo[i] = sol\n            return sol\n        return maxSum2(0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            currMax = arr[i]\n            size = 1\n            while size <= k and i - size + 1 >= 0:\n                currMax = max(currMax, arr[i - size + 1])\n                dp[i + 1] = max(dp[i + 1], dp[i + 1 - size] + (currMax * size))\n                size += 1\n\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        memo = {}\n        def max_sum(idx):\n            if idx >= len(arr):\n                return 0\n\n            if idx in memo:\n                return memo[idx]\n            \n            subarr_max = float('-inf')\n            options = []\n            for end in range(idx, min(idx + k, len(arr))):\n                subarr_max = max(subarr_max, arr[end])\n                subarr_sum = subarr_max * (end - idx + 1)\n                options.append(subarr_sum + max_sum(end + 1))\n            \n            memo[idx] = max(options)\n            \n            return memo[idx]\n            \n        return max_sum(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        memo = {}\n        def dfs(i):\n            if i >= n:\n                return 0\n            \n            if i in memo:\n                return memo[i]\n            \n            res = float('-inf')\n            cur_max = float('-inf')\n            for j in range(i, min(i + k, n)):\n                cur_max = max(cur_max, arr[j])\n                res = max(res, cur_max * (j - i + 1) + dfs(j + 1))\n            \n            memo[i] = res\n            return res\n        \n        return dfs(0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        N = len(arr)\n        maxSoFar = [0]*N\n        for i in range(N):\n            curMax = 0\n            for prev in range(1,min(i+1,k)+1):\n                curMax = max(curMax,arr[i-prev+1])\n                lastPartition = maxSoFar[i-prev] if i >= prev else 0\n                maxSoFar[i] = max(maxSoFar[i], lastPartition + curMax*prev)\n        return maxSoFar[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        current_max = 0\n        dp = [0] * n\n        \n        for i in range(n):\n            if i < k:\n                current_max = max(current_max, arr[i])\n                dp[i] = (i+1) * current_max\n            else:\n                current_max = 0\n                for j in range(1, k+1):\n                    current_max = max(current_max, arr[i - j + 1])\n                    dp[i] = max(dp[i], dp[i-j] + current_max * j)\n                \n        return dp[-1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, A, K):\n        N = len(A)\n        dp = [0] * (N + 1)\n        for i in range(N):\n            curMax = 0\n            for k in range(1, min(K, i + 1) + 1):\n                curMax = max(curMax, A[i - k + 1])\n                dp[i+1] = max(dp[i+1], dp[i+1 - k] + curMax * k)\n        print(dp)\n        return dp[N]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * n\n        for i in range(n):\n            currMax = arr[i]\n            size = 1\n            while size <= k and i - size + 1 >= 0:\n                currMax = max(currMax, arr[i - size + 1])\n                dp[i] = max(dp[i], (dp[i - size] if i - size >= 0 else 0) + (currMax * size))\n                size += 1\n\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        d = [0] * (len(arr))\n\n        for i in range(len(arr)):\n            cur_max = 0\n\n            for kk in range(1, k + 1):\n                if i - kk + 1 < 0:\n                    continue\n\n                cur_max = max(cur_max, arr[i-kk+1])\n\n                # print(i, kk, \\\",\\\", i - kk + 1, cur_max, arr[i-kk+1], ':', d[i], d[i-kk])\n                \n                if i - kk < 0:\n                    prev = 0\n                else:\n                    prev = d[i-kk]\n\n                d[i] = max(d[i], prev + cur_max*kk)\n\n        print(d)\n\n        return d[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0 for i in range(len(arr)+1)]\n        \n        for i in range(len(arr)):\n            val = arr[i]\n            for j in range(1, k+1):\n                if i + j -1 >= len(arr):\n                    break\n                val = max(arr[i+j-1], val)\n                dp[i+j] = max(dp[i] + val *j, dp[i+j])\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        dp = (len(arr) + 1)  * [0]\n\n        for i in range(0, len(arr)):\n            sub_max = 0\n            for j in range(k):\n                if j <= i:\n                    sub_max = max(sub_max, arr[i-j])\n                    dp[i + 1] = max(dp[i+1], sub_max * (j + 1) + dp[i-j])\n        \n        return dp[len(arr)]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        def dfs(start, memo):\n            if start in memo:\n                return memo[start]\n            N = len(A)\n            if start >= N:\n                return 0\n            maxSum = 0\n            maxEle = 0\n            for i in range(start, min(N, start + K)):\n                maxEle = max(maxEle, A[i])\n                maxSum = max(maxSum, maxEle * (i - start + 1) + dfs(i+1, memo))\n            memo[start] = maxSum\n            return maxSum\n        return dfs(0, {})\n        \n#         max_heap = []\n#         counter = collections.defaultdict(int)\n#         N = len(A)\n#         result = []\n#         for i in range(K):\n#             heappush(max_heap, -A[i])\n#             counter[A[i]] += 1\n            \n#         for i, n in enumerate(A):\n#             if i+k < N:\n#                 result.append(-heap[0][0])\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        N = len(arr)\n        dp = [0] * (N + 1)\n        for i in range(N):\n            curMax = 0\n            for j in range(1, min(k, i + 1) + 1):\n                curMax = max(curMax, arr[i - j + 1])\n                dp[i] = max(dp[i], dp[i - j] + curMax * j)\n        return dp[N - 1]\n\n    \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [-1] * (len(arr) + 1)\n        dp[0] = 0\n        \n        for i in range(len(arr)):\n            cur_max = -1\n            for j in range(k):\n                if (i - j) < 0:\n                    dp[i + 1] = max(dp[i + 1], arr[i])\n                    break\n                cur_max = max(cur_max, arr[i-j])\n                dp[i + 1] = max(dp[i + 1], dp[i-j] + cur_max * (j + 1))\n        \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        if arr == [] or k == 0:\n            return 0 \n        \n        if len(arr) == 1 and k == 1:\n            return arr[0] \n        \n        l = len(arr)\n        res = [0]*(l)\n\n        for i in range(0, l):\n            sub_max = 0\n            for j in range(k):\n                if j <= i:\n                    sub_max = max(sub_max, arr[i-j])\n                    res[i] = max(res[i], sub_max*(j + 1) + (res[i-j-1] if i-j-1 >=0 else 0))\n        \n        return res[l-1]\n\n     \n\n        \n        \n\n            \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*(n+1)\n        \n        dp[0] = 0\n        \n        for i in range(1,n+1):\n            mx=0\n            for j in range(k):\n                if(i-j-1>=0):\n                    mx = max(mx, arr[i-j-1])\n                    dp[i] = max(dp[i], mx*(j+1) + dp[i-j-1])\n                \n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        dp = len(arr)  * [0]\n        dp[0] = arr[0]\n        for i in range(1, len(arr)):\n            sub_max = 0\n            for j in range(k):\n                if j <= i:\n                    sub_max = max(sub_max, arr[i-j])\n                    dp[i] = max(dp[i], sub_max * (j + 1) + (dp[i-j-1] if i-j-1 >= 0 else 0))\n        \n        return dp[len(arr)-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        # walk through list: at every element, look backwards up to K spaces\n        # compare combination of 1, 2 .. K repeats of current segment max\n        # vs total sum, and retain the largest (dp_sum memoization)\n        # dummy index dp_sum[0] for index bound checking\n        # O(AK) time, O(A) extra space\n\n        dp_sum = [0 for _ in range(len(A)+1)]\n\n        for i in range(len(A)):\n            seg_max = A[i]\n\n            for j in range(1, K+1):\n                if i-j+1 < 0: break\n\n                seg_max = max(seg_max, A[i-j+1])\n\n                tmp = dp_sum[i-j+1] + seg_max * j\n                dp_sum[i+1] = max(dp_sum[i+1], tmp)\n\n        return dp_sum[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], k: int) -> int:\n        L=len(A)\n        vis={}\n        def pos(n):\n            if n>=L:\n                return 0\n            if n in vis:\n                return vis[n]\n            currmax=A[n]\n            ans=A[n]+pos(n+1)\n            for i in range(1,k):\n                n1=n+i\n                if n1>=L:\n                    break\n                currmax=max(currmax,A[n1])\n                ans=max(ans,currmax*(i+1)+pos(n1+1))\n            vis[n]=ans\n            return vis[n]\n        return pos(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        if not arr:\n            return 0\n        n = len(arr)\n        dp = [0 for _ in range(n)]\n        for i in range(n):\n            temp_max = arr[i]\n            j = 1\n            while i-j+1>=0 and j<=k:\n                temp_max = max(temp_max, arr[i-j+1])\n                if i>=j:\n                    dp[i] = max(dp[i], dp[i-j]+(temp_max*j))\n                else:\n                    dp[i] = max(dp[i], temp_max*j)\n                j+=1\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [-1 for _ in range(n)]\n        def max_sum(i):  \n            # print(i)\n            if i >= n:\n                return 0\n            if i == (n - 1):\n                return arr[i]\n            \n            if dp[i] != -1:\n                return dp[i]\n            \n            ans = float('-inf')\n            maxi = arr[i]\n            for p in range(1, k + 1):\n                v = maxi*p + max_sum(i + p)\n                # print(i, p, v)\n                ans = max(v, ans)\n                if (i + p) < n:\n                    maxi = max(maxi, arr[i + p])\n                else:\n                    break\n            dp[i] = ans\n            return ans\n        \n        v =  max_sum(0)\n        return v", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        size = len(arr)\n        mem = [0] * size\n\n        for i in range(size):\n            maxArr = 0\n            for j in range(0, k):\n                if i - j >= 0:\n                    maxArr = max(maxArr, arr[i - j])\n                    candidate = maxArr * (j + 1)\n                    candidate += 0 if i - j == 0 else mem[i - j - 1]\n                    mem[i] = max(mem[i], candidate)\n                else:\n                    break\n        return mem[size - 1]\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \n        dp = {}\n        \n        def help(arr,k, start=0):\n            \n            if start == len(arr):\n                return 0\n            \n            if start in dp:\n                return dp[start]\n            \n            dp[start] = -float('inf')\n            maxval = arr[start]\n            \n            for i in range(start,min(start+k,len(arr))):\n                maxval = max(maxval,arr[i])\n                dp[start] = max(dp[start],maxval*(i-start+1)+help(arr,k,i+1))\n                \n            return dp[start]\n        \n        return help(arr,k)\n                \n            \n                \n                \n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        N = len(arr)\n        K = k\n        dp = [0] * (N + 1)\n        for i in range(N):\n            curMax = 0\n            for k in range(1, min(K, i + 1) + 1):\n                curMax = max(curMax, arr[i - k + 1])\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\n        return dp[N - 1]\n                \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        # Recursive approach\n        memo = {} \n        \n        def getMax(arr, k, idx):\n            \n            # if reached end\n            if idx == len(arr): return 0\n            if idx in memo: return memo[idx]\n            \n            maxSum, maxInSub = 0, 0\n            for i in range(idx, min(idx+K, len(arr))):\n                maxInSub = max(maxInSub, arr[i])\n                maxSum = max(maxSum, maxInSub*(i-idx+1) + getMax(arr, k, i+1))\n            \n            memo[idx] = maxSum\n            return maxSum\n            \n        \n        return getMax(A, K, 0)\n        \n#         # dp[i] will hold the maximum sum \n#         # from [0, i)\n#         dp[i] = [0] * (len(A)+1)\n        \n        \n        \n        \n", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        dp = [0]*len(A)\n        dp[0] = A[0]\n        partition_max = A[0]\n        for x in range(1,K):\n            partition_max = max(partition_max, A[x])\n            dp[x] = (x+1)*partition_max\n        print(dp)\n        for i in range(K, len(dp)):\n            partition_max = float('-inf')\n            for j in range(K):\n                partition_max = max(partition_max, A[i-j])\n                dp[i] = max(dp[i], dp[i-j-1] + (j+1)*partition_max)\n        print(dp)\n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:    \n        size = len(A)\n        if K == 1: return sum(A)\n        dp = [0] * (size + 1)\n        for i in range(size):\n            cur_max = float('-inf')\n            block_size = 1\n            while block_size <= K and i - block_size + 1 >= 0:\n                cur_max = max(cur_max, A[i - block_size + 1])\n                #cur_max = max(A[i - block_size + 1:i+1]) if i - block_size + 1 >= 0 else max(A[:i+1])\n                dp[i+1] = max(dp[i+1], dp[i - block_size + 1] + block_size * cur_max)\n                block_size += 1\n        \n        return dp[size]\n\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            cur_max = 0\n            for j in range(1, min(k, i)+1 ):\n                cur_max = max(cur_max, arr[i-j])\n                dp[i] = max(dp[i], cur_max*j + dp[i-j])\n        return dp[-1]\n                \n            \n        # n = len(arr)\n        # memo = {n:0}\n        # def helper(arr, i):\n        #     if i in memo:\n        #         return memo[i]\n        #     res = 0\n        #     for j in range(i, min(n,i+k)):\n        #         res = max(res, helper(arr, j+1)+max(arr[i:j+1])*(j+1-i))\n        #     memo[i] = res\n        #     return res\n        # return helper(arr, 0)\n", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*n\n        \n        for i in range(n):\n            dp[i] = arr[i] + (dp[i-1] if i-1>=0 else 0)\n            tmp = arr[i]\n            \n            for j in range(1,k):\n                if i-j>=0:\n                    \n                    tmp = max(tmp, arr[i-j])\n                    \n                    dp[i] = max(dp[i], tmp*(i-(i-j)+1)+ (dp[i-j-1] if i-j-1>=0 else 0))\n                    \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n+1)\n        dp[1] = arr[0]\n        for i in range(2, n+1):\n            dp[i] = dp[i-1] + arr[i-1]\n            cur_max = arr[i-1]\n            for j in range(1, k+1): ## j: number of elements in the last group\n                cur_max = max(cur_max, arr[i-j])\n                if i-j>=0:\n                    dp[i] = max(dp[i], dp[i-j]+j*cur_max)\n        return dp[n]", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp = [0]*(len(arr)+1)\n        \n        for i in range(1, len(arr)+1):\n            dp[i] = float('-inf')\n            curr_max = arr[i-1]\n            for p in range(1, k+1):\n                if p > i:\n                    break\n                curr_max = max(curr_max, arr[i-p])\n                dp[i] = max(dp[i], p*curr_max + dp[i-p])\n        \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        \n        self.max_sum = float('-inf')\n        self.dic = {}\n        \n        # @functools.lru_cache(None)\n        def getSum(i):\n            \n            if i>=len(A):\n                # if cur_sum>self.max_sum:\n                #     self.max_sum = cur_sum\n                return 0\n            if i in self.dic:\n                return self.dic[i]\n            cur_max = A[i]\n            ret = cur_max + getSum(i+1)\n            for j in range(1,K):\n                if i+j<len(A):\n                    if A[i+j]>cur_max:\n                        cur_max = A[i+j]\n                    ret = max(cur_max*(j+1) + getSum(i+j+1), ret)\n                else:\n                    break\n            self.dic[i] = ret\n            return ret\n        \n        return getSum(0)\n\n                \n                \n        \n                \n", "class Solution:\n    @lru_cache(None)\n    def rec(self, idx):\n        if idx>len(self.A):\n            return 0\n        \n        max_yet = 0\n        max_score = 0\n        \n        for i in range(self.K):\n            if idx+i>=len(self.A):\n                break\n                \n            max_yet = max(max_yet, self.A[idx+i])\n            \n            max_score = max(max_score, max_yet*(i+1) + self.rec(idx+i+1))\n        \n        return max_score\n        \n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        self.A = A\n        self.K = K\n        \n        return self.rec(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        cacheMax=[[0]*len(arr) for i in range(len(arr))]\n        for i in range(len(arr)):\n            cacheMax[i][i]=arr[i]\n        for i in range(1,len(arr)):\n            for j in range(max(i-k+1,0),i+1):\n                cacheMax[j][i] = max(cacheMax[j][i-1],arr[i])\n        \n        \n        \n        \n        dp=[0]*(len(arr)+1)\n        dp[1]=arr[0]\n        for i in range(1,len(arr)):\n            for j  in range(max(0,i-k+1),i+1):\n                dp[i+1]=max(dp[i+1],dp[j]+cacheMax[j][i]*(i-j+1))\n                \n            \n        return dp[-1]", "class Solution:\n    def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:\n        def DPHelper(index):\n            if(index >= len(A)):\n                return 0\n            \n            if(memo.get(index) is not None):\n                return memo[index]\n            \n            res = 0\n            curr_max = 0\n            \n            for i in range(index, min(index + K, len(A))):\n                curr_max = max(curr_max, A[i])\n                res = max(res, (curr_max * (i - index + 1)) + DPHelper(i + 1))\n            \n            memo[index] = res\n            \n            return res\n        \n        memo = {}\n        \n        return DPHelper(0)", "class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        dp  = [0] * (len(arr) + 1)\n        for i in range(1, len(arr) + 1):\n            curM = arr[i-1]\n            for j in range(1, min(i , k) + 1):\n                curM = max(curM, arr[i-j])\n                dp[i] = max(dp[i], dp[i-j] + curM * j)\n        return dp[-1]\n    \n    \n        # def maxSumAfterPartitioning(self, A, K):\n        # N = len(A)\n        # dp = [0] * (N + 1)\n        # for i in xrange(N):\n        #     curMax = 0\n        #     for k in xrange(1, min(K, i + 1) + 1):\n        #         curMax = max(curMax, A[i - k + 1])\n        #         dp[i] = max(dp[i], dp[i - k] + curMax * k)\n        # return dp[N - 1]\n"]
["class Solution(object):\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         size = len(nums)\n         if size < 3:\n             return 0\n         nums.sort()\n         i = 0 # fix the first index\n         ans = nums[0] + nums[1] + nums[size - 1] # ans is used to record the solution\n         while i < size - 2:\n             tmp = target - nums[i]\n             j = i + 1\n             k = size - 1\n             while j < k:\n                 if nums[j] + nums[k] == tmp:\n                     return target\n                 if nums[j] + nums[k] > tmp:\n                     if nums[j] + nums[j + 1] >= tmp:\n                         if nums[j] + nums[j + 1] - tmp < abs(ans - target):\n                             ans = nums[i] + nums[j] + nums[j + 1]\n                         break\n                     tmpans = nums[i] + nums[j] + nums[k]\n                     if tmpans - target < abs(ans - target):\n                         ans = tmpans\n                     k -= 1\n                 else:\n                     if nums[k] + nums[k - 1] <= tmp:\n                         if tmp - nums[k] -nums[k - 1] < abs(ans - target):\n                             ans = nums[i] + nums[k - 1] + nums[k]\n                         break\n                     tmpans = nums[i] + nums[j] + nums[k]\n                     if target - tmpans < abs(ans - target):\n                         ans = tmpans\n                     j += 1\n             i += 1\n             if ans == target:\n                 return target\n         return ans", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         Solution: Sort the list then use three pointers (i, j, k) to find the sum of 3 values that is closest to target.\n         Store the current closest value and the distance from target.\n         Current closest value can be compared using abs(target - value) and comparing to the stored distance from target.\n         \"\"\"\n         arr, i, closest, dist = nums, 0, None, None\n         arr.sort()\n \n         if len(arr) == 3:\n             return arr[0] + arr[1] + arr[2]\n \n         while i < len(arr) - 2:\n             if i > 0 and arr[i] > target:\n                 return closest\n             if i == 0 or arr[i] != arr[i - 1]:\n                 j, k = i + 1, len(arr) - 1\n                 while j < k:\n                     val = arr[i] + arr[j] + arr[k]\n                     if val == target:\n                         return val\n                     temp_dist = abs(target - val)\n                     # print('VALS', arr[i], arr[j], arr[k], val, temp_dist)\n                     if dist == None or temp_dist < dist:\n                         closest = val\n                         dist = temp_dist\n                     if val < target:\n                         j += 1\n                     else:\n                         k -= 1\n \n             i += 1\n         return closest", "class Solution:\n     def threeSumClosest(self, array, target):\n         \"\"\" Returns sum of integers from array closest to target.\n         Time complexity: O(n ^ 2). Space complexity: O(n),\n         where n is len(array).\n         \"\"\"\n         array.sort()\n \n         n = len(array)\n         best_sum = float(\"inf\")  # closest sum of 3 integers so far\n         for i in range(n - 2):  # choosing the 1st integer\n             if i > 0 and array[i] == array[i - 1]:  # skip duplicates\n                 continue\n \n             diff = target - array[i]  # best sum for 2 other integers\n             x, y = i + 1, n - 1\n             best_diff = float(\"inf\")\n             while x < y:\n                 curr_diff = array[x] + array[y]\n                 if curr_diff == diff:  # exact sum we're looking for\n                     return target\n                 elif curr_diff < diff:  # increase current sum of 2 integers\n                     x += 1\n                 else:  # curr_diff > diff, decrease current sum of 2 integers\n                     y -= 1\n                 # update best difference so far\n                 if abs(curr_diff - diff) < abs(best_diff - diff):\n                     best_diff = curr_diff\n \n             # update best sum if needed\n             curr_sum = array[i] + best_diff\n             if abs(curr_sum - target) < abs(best_sum - target):\n                 best_sum = curr_sum\n         return best_sum", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         if len(nums) < 3:\n             return sum(nums)\n         elif len(nums) == 3:\n             return sum(nums)\n         nums = sorted(nums)\n         res = nums[0]+nums[1]+nums[2]\n         for i in range(len(nums) - 2):\n             if i!= 0 and nums[i] == nums[i-1]:\n                 continue\n             j = i+1\n             k = len(nums) - 1\n             while j < k:\n                 s = nums[i] + nums[j] + nums[k]\n                 if s == target:\n                     return target\n                 if s < target:\n                     j += 1\n                 else:\n                     k -= 1                \n                 if abs(s-target) < abs(res-target):\n                     res = s\n         return res", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         nums = sorted(nums)\n         res, diff = None, None\n         for first in range(len(nums) - 2):\n             if first and nums[first] == nums[first - 1]:\n                 continue\n                 \n             second, third = first + 1, len(nums) - 1\n             if diff is None:\n                 res = nums[first] + nums[second] + nums[third]\n                 diff = abs(res - target)\n             while second < third:\n                 three_sum = nums[first] + nums[second] + nums[third]\n                 if three_sum == target:\n                     return target\n                 elif three_sum < target:\n                     partial = nums[first] + nums[third]\n                     while second < third and nums[second] + partial  < target:\n                         second += 1\n                     tmp = nums[second - 1] + partial\n                     if abs(tmp - target) < diff:\n                         diff = abs(tmp - target)\n                         res = tmp\n                 else:\n                     partial = nums[first] + nums[second]\n                     while second < third and partial + nums[third] > target:\n                         third -= 1\n                     tmp = partial + nums[third + 1]\n                     if abs(tmp - target) < diff:\n                         diff = abs(tmp - target)\n                         res = tmp\n         return res\n             \n", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         '''\n         nums = sorted(nums)\n         size = len(nums)\n         res = list()\n         for i in range(size-2):\n             if i and nums[i] == nums[i-1]:\n                 continue\n             left, right = i+1, size-1\n             while left < right:\n                 sums = nums[i] + nums[left] + nums[right]\n                 if sums == target:\n                     return target\n                 else:\n                     res.append(sums)\n                     if sums < target:\n                         while left < right and nums[left] == nums[left+1]:\n                             left += 1\n                         left += 1\n                     else:\n                         while left < right and nums[right] == nums[right-1]:\n                             right -= 1\n                         right -= 1\n         return self.helper(res, target)\n     \n     def helper(self, nums, target):\n         if not nums:\n             return\n         goal = abs(nums[0] - target)\n         res = nums[0]\n         for num in nums[1:]:\n             if abs(num-target) < goal:\n                 goal = abs(num-target)\n                 res = num\n         return res\n \n         '''        \n         nums = sorted(nums)\n         size = len(nums)\n         res = None\n         diff = None\n         for i in range(size-2):\n             if i and nums[i] == nums[i-1]:\n                 continue\n             left, right = i+1, size-1\n             if not diff:\n                 res = nums[i] + nums[left] + nums[right]\n                 diff = abs(res-target)\n             while left < right:\n                 sums = nums[i] + nums[left] + nums[right]\n                 if sums == target:\n                     return target\n                 elif sums < target:\n                     partial = nums[i] + nums[right]\n                     while left < right and nums[left] == nums[left+1]:\n                         left += 1\n                     while left < right and partial+nums[left] < target:\n                         left += 1\n                     tmp = partial + nums[left-1]\n                     if abs(tmp-target) < diff:\n                         res, diff = tmp, abs(tmp-target)\n                 else:\n                     partial = nums[i] + nums[left]\n                     while left < right and nums[right] == nums[right-1]:\n                         right -= 1\n                     while left < right and partial+nums[right] > target:\n                         right -= 1\n                     tmp = partial + nums[right+1]\n                     if abs(tmp-target) < diff:\n                         res, diff = tmp, abs(tmp-target)\n         return res\n", "class Solution(object):\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         size = len(nums)\n         if size < 3:\n             return 0\n         nums.sort()\n         i = 0 # fix the first index\n         ans = nums[0] + nums[1] + nums[size - 1] # ans is used to record the solution\n         while i < size - 2:\n             tmp = target - nums[i]\n             j = i + 1\n             k = size - 1\n             while j < k:\n                 if nums[j] + nums[k] == tmp:\n                     return target\n                 if nums[j] + nums[k] > tmp:\n                     if nums[j] + nums[j + 1] >= tmp:\n                         if nums[j] + nums[j + 1] - tmp < abs(ans - target):\n                             ans = nums[i] + nums[j] + nums[j + 1]\n                         break\n                     tmpans = nums[i] + nums[j] + nums[k]\n                     if tmpans - target < abs(ans - target):\n                         ans = tmpans\n                     k -= 1\n                 else:\n                     if nums[k] + nums[k - 1] <= tmp:\n                         if tmp - nums[k] -nums[k - 1] < abs(ans - target):\n                             ans = nums[i] + nums[k - 1] + nums[k]\n                         break\n                     tmpans = nums[i] + nums[j] + nums[k]\n                     if target - tmpans < abs(ans - target):\n                         ans = tmpans\n                     j += 1\n             i += 1\n             if ans == target:\n                 return target\n         return ans", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         nums.sort()\n         result = nums[0]+nums[1]+nums[2]\n         for i in range(len(nums) - 2):\n             if i > 0 and nums[i] == nums[i - 1]:\n                 continue\n             if nums[i] + nums[i + 1] + nums[i + 2] > target + abs(result - target):\n                 return result\n             st = i + 1\n             ed = len(nums) - 1\n             while st < ed:\n                 dis = nums[i] + nums[st] + nums[ed] - target\n                 if dis == 0:\n                     return target\n                 elif dis > 0:\n                     while st < ed and nums[i] + nums[st] + nums[ed] - target > 0:\n                         ed -= 1\n                     if abs(nums[i] + nums[st] + nums[ed + 1] - target) < abs(result - target):\n                         result = nums[i] + nums[st] + nums[ed + 1]\n                 else:\n                     while st < ed and nums[i] + nums[st] + nums[ed] - target < 0:\n                         st += 1\n                     if abs(nums[i] + nums[st - 1] + nums[ed] - target) < abs(result - target):\n                         result = nums[i] + nums[st - 1] + nums[ed]\n         return result", "class Solution:\n     def threeSumClosest(self, nums, target):\n         res = 0\n         nlen = len(nums)\n         if nlen < 3:\n             for num in nums:\n                 res += num\n             return res\n \n         lastdiff = sys.maxsize\n         previous = None\n         nums = sorted(nums)\n         for idx in range(nlen - 2):\n             num = nums[idx]\n             if num == previous:\n                 continue\n             i = idx + 1\n             j = nlen - 1\n             previous = num\n             cur_sum = num\n \n             while i < j:\n                 diff = 0\n                 cur_sum += (nums[i] + nums[j])\n                 if cur_sum == target:\n                     return cur_sum\n                 if cur_sum < target:\n                     diff = target - cur_sum\n                     i += 1\n                 else:\n                     diff = cur_sum - target\n                     j -= 1\n                 if diff < lastdiff:\n                     lastdiff = diff\n                     res = cur_sum\n                 cur_sum = num\n \n         return res", "class Solution:\n     def threeSumClosest(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         if len(nums) <= 3:\n             return sum(nums)\n         nums.sort()\n         diff=float('inf')\n         \n         for idx, num in enumerate(nums[:-2]):\n             if idx>= 1 and num == nums[idx-1]:\n                 continue\n             start, end = idx + 1, len(nums) - 1\n             while start < end:\n                 temp_sum = nums[start] + nums[end]\n                 new_target = target - num\n                 if temp_sum == new_target:\n                     return target\n                 elif temp_sum > new_target:\n                     end -= 1\n                 else:\n                     start += 1\n                 \n                 if abs(new_target - temp_sum) < diff:\n                     if new_target - temp_sum < 0:\n                         sign = -1\n                     else:\n                         sign = 1\n                     diff = abs(new_target - temp_sum)\n \n \n         return target - sign*diff\n \n             \n                     \n"]
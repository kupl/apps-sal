["class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=Counter(A)\n        c_list=sorted(list(cache),key=abs)\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=collections.Counter(A)\n        c_list=sorted(list(cache),key=abs)\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if len(A) % 2 == 1: return False\n        if not A: return True\n        nums = sorted(set(A))\n        nums = [x for x in nums if x < 0][::-1] + [x for x in nums if x >= 0]\n        c = Counter(A)\n        done = set()\n        for num in nums:\n            if num in done:\n                continue\n            if 2*num not in c:\n                return False\n            if c[2*num] < c[num]:\n                return False\n            \n            c[2*num] -= c[num]\n            if c[2*num] == 0: \n                done.add(2*num)\n            \n            c[num] = 0\n            done.add(num)\n            \n        return True", "import collections\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        ''' Place all values into dicts and start counting from the bottom\n        '''\n        if not A:\n            return True\n        \n        pos = collections.defaultdict(int)\n        neg = collections.defaultdict(int)\n        zero = 0\n        \n        # O(n)\n        for v in A:\n            if v > 0:\n                pos[v] += 1\n            if v < 0:\n                neg[-v] += 1\n            if v == 0:\n                zero += 1\n        \n        b = self.check(pos)\n        if not b:\n            return False\n        b = self.check(neg)\n        if not b:\n            return False\n        \n        return zero % 2 == 0\n        \n        \n    def check(self, d):\n        \n        # worst case O(n), done n times\n        while d:\n            v = min(d) \n            if not 2 * v in d:\n                return False\n            if d[v] > d[2 * v]:\n                return False\n\n            elif d[v] == d[2*v]:\n                del d[v]\n                del d[2*v]\n            else:\n                d[2*v] -= d[v]\n                del d[v]\n        return True\n            \n                \n                    \n            \n        \n", "\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        ''' Place all values into dicts and start counting from the bottom\n        '''\n        if not A:\n            return True\n        \n        pos = {}\n        neg = {}\n        zero = 0\n        \n        # O(n)\n        for v in A:\n            if v > 0:\n                pos[v] = pos.get(v, 0) + 1\n            if v < 0:\n                neg[-v] = neg.get(-v, 0) + 1\n            if v == 0:\n                zero += 1\n        \n        b = self.check(pos)\n        if not b:\n            return False\n        b = self.check(neg)\n        if not b:\n            return False\n        \n        return zero % 2 == 0\n        \n        \n    def check(self, d):\n        \n        # worst case O(n), done n times\n        while d:\n            v = min(d) \n            if not 2 * v in d:\n                return False\n            if d[v] > d[2 * v]:\n                return False\n\n            elif d[v] == d[2*v]:\n                del d[v]\n                del d[2*v]\n            else:\n                d[2*v] -= d[v]\n                del d[v]\n        return True\n            \n                \n                    \n            \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        i = 0\n        j = 0\n        A.sort()\n        while i < len(A) and A[i] <= 0:\n            if A[i] % 2 != 0:\n                return False\n            while j < len(A) and A[j] < 0 and 2 * A[j] < A[i]:\n                j += 1\n            if j >= len(A) or 2 * A[j] > A[i]:\n                return False\n            A[j] = None\n            j += 1\n            i += 1\n            while i < len(A) and A[i] is None:\n                i += 1\n                \n        while i < len(A):\n            while j < len(A) and A[j] < 2 * A[i]:\n                j += 1\n            if j >= len(A) or A[j] > 2 * A[i]:\n                return False\n            A[j] = None\n            j += 1\n            i += 1\n            while i < len(A) and A[i] is None:\n                i += 1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = {}\n        zero_count = 0\n        for num in A:\n            if num == 0:\n                zero_count += 1\n            elif num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        if zero_count % 2 != 0:\n            return False\n        \n        A.sort()\n        for num in A:\n            double = num * 2\n            if num in count and double in count:\n                count[double] -= 1\n                count[num] -= 1\n                if count[double] == 0:\n                    count.pop(double)\n                if count[num] == 0:\n                    count.pop(num)\n        \n        return count == {}\n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if len(A) % 2 == 1:\n            return False\n        \n        count = collections.defaultdict(int)\n        for num in A:\n            count[num] += 1\n        A.sort()\n        for num in A:\n            if count[num] > 0:\n                # print(f\\\"checking {num}\\\")\n                double = num * 2\n                # print(half, double)\n\n                if double in count and count[double] > 0:\n                    # print(\\\"found\\\", double)\n                    count[num] -= 1                    \n                    count[double] -= 1\n                    # print(count)\n                    # print(\\\"all good\\\")\n        # print(count)     \n        for num in count:\n            if count[num] != 0:\n                return False\n        return True\n            \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n\n        for x in sorted(A, key=abs):\n            if(count[x] == 0):\n                continue\n            if(count[2*x] == 0):\n                return False\n            count[x] -= 1\n            count[2*x] -= 1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=dict()\n        for a in A:\n            cache[a]=cache.get(a,0)+1\n        while len(cache)>0:\n            temp=[abs(k) for k in cache.keys()]\n            curr=min(temp)\n            if curr==0:\n                if cache[0]%2>0:\n                    return False\n                else:\n                    cache.pop(0)\n            else:\n                if curr in cache:\n                    if cache[curr]==0:\n                        cache.pop(curr)\n                    elif (2*curr not in cache) or cache[2*curr]<cache[curr]:\n                        return False\n                    else:\n                        cache[2*curr]-=cache[curr]\n                        cache.pop(curr)\n                if -curr in cache:\n                    if cache[-curr]==0:\n                        cache.pop(-curr)\n                    elif (-2*curr not in cache) or cache[-2*curr]<cache[-curr]:\n                        return False\n                    else:\n                        cache[-2*curr]-=cache[-curr]\n                        cache.pop(-curr)\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        ''' Place all values into dicts and start counting from the bottom\n        '''\n        counter = collections.Counter(A)\n        \n        for v in sorted(counter, key = abs):\n            if counter[2 * v] < counter[v]:\n                return False\n            counter[2 * v] -= counter[v]\n        return True\n        \n            \n                \n                    \n            \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counts = defaultdict(int)\n        for x in sorted(A):\n            counts[x] += 1\n            if x < 0 and x * 2 in counts:\n                while counts[x] > 0 and counts[x * 2] > 0:\n                    counts[x] -= 1\n                    counts[x * 2] -= 1\n            if x >= 0 and x / 2 in counts:\n                while counts[x] > 0 and counts[x / 2] > 0:\n                    counts[x] -= 1\n                    counts[x / 2] -= 1\n        return sum(c for v, c in counts.items()) == 0", "import collections\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        ''' Place all values into dicts and start counting from the bottom\n        '''\n        if not A:\n            return True\n        \n        counter = collections.Counter(A)\n        \n        for v in sorted(counter, key = abs):\n            if counter[2 * v] < counter[v]:\n                return False\n            counter[2 * v] -= counter[v]\n        return True\n        \n            \n                \n                    \n            \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        result = True\n        numLen = len(A)\n        C = Counter(A)\n        val = list(C.keys())\n        val.sort()\n        for i in range(len(val)):\n            if val[i] < 0:\n                if val[i] % 2 == 0:\n                    if val[i]/2 in val and C[val[i]/2] >= C[val[i]]:\n                        C[val[i] / 2] = C[val[i]/2] - C[val[i]]\n                        C[val[i]] = 0\n                    else:\n                        result = False\n                        # break\n            else:\n                if val[i] * 2 in val and C[val[i]*2] >= C[val[i]]:\n                    C[val[i] * 2] = C[val[i]*2] - C[val[i]]\n                    C[val[i]] = 0\n                else:\n                    result = False\n                    # Break\n        nums = list(C.values())\n        if nums == [0]*len(nums):\n            result = True\n        else:\n            result = False\n        return result", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        dd = Counter(A)\n        A.sort(key = lambda a : abs(a))\n\n        for a in A:\n            if a in dd and dd[a]:\n                if 2*a in dd and dd[2*a]:\n                    dd[a] -= 1\n                    dd[2*a] -= 1\n                    if dd[a] == 0:\n                        del dd[a]\n                    if dd[a*2] == 0:\n                        del dd[a*2]\n                else:\n                    return False\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        pos = [x for x in A if x >= 0]\n        neg = [x for x in A if x < 0]\n        for L in (pos,neg):\n            count = collections.Counter(L)\n            for x in sorted(L, key=abs):\n                if count[x] == 0: continue\n                if count[2*x] == 0: return False\n                count[x] -= 1\n                count[2*x] -= 1\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort(key=lambda x: (x>0, abs(x)))\n        right = 1\n        size = len(A)\n        for i in range(size):\n            if A[i] is None:\n                continue\n\n            while right < size and 2 * A[i] != A[right]:\n                right += 1\n\n            if right == size:\n                return False\n\n            A[right] = None\n\n        return True", "class Solution:\n    def canReorderDoubled(self, arr):\n        arr.sort()\n        negl = [x for x in arr if x < 0][::-1]\n        posl = [x for x in arr if x >= 0]\n        cnt = {}\n        for x in arr:\n            if x not in cnt:\n                cnt[x] = 1\n            else:\n                cnt[x] = cnt[x] + 1\n\n        while True :\n            x = None\n            if negl != [] :\n                x = negl.pop(0)\n            else:\n                if posl != [] :\n                    x = posl.pop(0)\n                else:\n                    break\n            if cnt[x] == 0 :\n                continue\n            y = x * 2\n            if y not in cnt:\n                return False\n            else:\n                if cnt[y] > 0 and cnt[x] > 0:\n                    cnt[y] = cnt[y] - 1\n                    cnt[x] = cnt[x] - 1\n                else:\n                    return False\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        seen = {}\n        \n        A.sort()\n        for i in A:\n            #Logic for checking half and double of number\n            if i/2 in seen:\n                seen[i/2] -= 1\n                if seen[i/2] == 0:\n                    del seen[i/2]\n            \n            elif 2*i in seen:\n                seen[2*i] -= 1\n                if seen[2*i] == 0:\n                    del seen[2*i]\n            else:\n                if i in seen:\n                    seen[i] += 1\n                else:\n                    seen[i] = 1\n        \n        return not bool(seen)", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counter=Counter(A)\n        for a in sorted(A, key=abs):\n            if counter[a]==0:\n                continue\n            if counter[2*a]==0:\n                return False\n            counter[a]-=1\n            counter[2*a]-=1\n        return True\n", "import collections\nclass Solution:\n    def canReorderDoubled(self, a: List[int]) -> bool:\n        count=collections.Counter(a)\n        for elem in sorted(a,key=abs):\n            if count[elem]==0:\n                continue\n            if count[2*elem]==0:\n                return False\n            count[elem]-=1\n            count[2*elem]-=1\n        return True\n", "from collections import defaultdict\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if not A:\n            return True\n        \n        count = 0\n        d = defaultdict(int)\n        for i in A:\n            d[i] += 1\n        \n        for num in sorted(A):\n            if num*2 in d and d[num] and d[num*2]:\n                d[num] -= 1\n                d[num*2] -= 1\n                count += 1\n        \n        return count == (len(A) // 2)\n\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # Eliminate zero\n        negative = []\n        positive = []\n        \n        zero_numbers = 0\n        for a in A:\n            if a < 0:\n                negative.append(abs(a))\n            elif a > 0:\n                positive.append(a)\n            else:\n                zero_numbers += 1\n        \n        if zero_numbers % 2:\n            return False\n        \n        negative.sort()\n        positive.sort()\n        # print(negative, positive)\n        \n        return self.helper(negative) and self.helper(positive)\n    \n    def helper(self, nums):        \n        while nums:\n            cur_num = nums[0]\n            idx = self.binarySearch(nums, 2 * cur_num)\n            # print('helper',nums[0], idx)\n            if idx == -1:\n                return False\n            nums.pop(idx)\n            nums.pop(0)\n            if len(nums) == 1:\n                return False\n        \n        return True\n    \n    def binarySearch(self, nums, key):\n        \n        head = 0\n        tail = len(nums) - 1\n        # print(nums, key)\n        \n        while head <= tail:\n            mid = (head + tail)//2\n            if nums[mid] > key:\n                tail = mid - 1\n            elif nums[mid] < key:\n                head = mid + 1\n            else:\n                return mid\n        \n        return -1", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for a in sorted(count, key = lambda x: abs(x)):\n            if count[a] > count[2 * a]:\n                return False\n            count[2 * a] -= count[a]\n        return True", "import numpy as np\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        a = np.array(sorted(A))\n        non_pos_idxs = np.where(a >= 0)[0]\n        if len(non_pos_idxs) > 0:\n            non_pos_idx = non_pos_idxs[0]\n        else:\n            non_pos_idx = len(a)\n        b = a[:non_pos_idx][::-1]\n        a = a[non_pos_idx:]\n        if len(b) % 2 != 0:\n            return False\n        \n        if not self.check_doubled(a):\n            return False\n        if not self.check_doubled(b):\n            return False\n        return True\n    \n    def check_doubled(self, a):\n        if len(a) == 0:\n            return True\n        count_dict = {}\n        for val in a:\n            if count_dict.get(val, 0) > 0:\n                count_dict[val] -= 1\n            else:\n                count_dict[2 * val] = count_dict.get(2 * val, 0) + 1\n        for val in list(count_dict.values()):\n            if val > 0:\n                return False\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        seen = {}\n        A.sort()\n        for ind,i in enumerate(A):\n            #Logic for checking half and double of number\n            if i/2 in seen:\n                seen[i/2] -= 1\n                if seen[i/2] == 0:\n                    del seen[i/2]\n            \n            elif 2*i in seen:\n                seen[2*i] -= 1\n                if seen[2*i] == 0:\n                    del seen[2*i]\n            else:\n                if i in seen:\n                    seen[i] += 1\n                else:\n                    seen[i] = 1\n        \n        print(seen)\n        \n        return not bool(seen)", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if not A:\n            return True\n        d=defaultdict(int)\n        for x in A:\n            d[x]+=1\n        n=len(A)//2\n        A.sort()\n        for x in A:\n            if d[x]>0:\n                if 2*x in d and d[2*x]>0:\n                    d[2*x]-=1\n                    d[x]-=1\n                    n-=1\n                    if n==0:\n                        return True\n            #print(x,d,n)\n        return False\n                \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        d = collections.defaultdict(int)\n        for a in A:\n            if d[2*a] > 0:\n                d[2*a] -= 1\n            elif d[a/2] > 0:\n                d[a/2] -= 1\n            else:\n                d[a] += 1\n        return not any(d.values())\n", "from collections import Counter\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counts = [0]*(10**5+1)\n        for a in A:\n            if a >= 0:\n                counts[a] += 1\n        for i in range(10**5+1):\n            while counts[i] != 0:\n                counts[i] -= 1\n                if counts[i] < 0:\n                    return False\n                counts[2*i] -= 1\n                if counts[2*i] < 0:\n                    return False\n        if not all(n == 0 for n in counts):\n            return False\n\n        for a in A:\n            if a < 0:\n                counts[-a] += 1\n        for i in range(10**5+1):\n            while counts[i] != 0:\n                counts[i] -= 1\n                if counts[i] < 0:\n                    return False\n                counts[2*i] -= 1\n                if counts[2*i] < 0:\n                    return False\n        if not all(n == 0 for n in counts):\n            return False\n        return True", "class Solution:\n    def canReorderDoubled(self, arr: List[int]) -> bool:\n        dicti=dict()\n        for var in arr:\n            if var in list(dicti.keys()):\n                dicti[var]+=1\n            else:\n                dicti[var]=1\n        arr.sort(key=lambda x: abs(x))\n        for var in arr:\n            if dicti[var]==0:\n                continue\n            if(2*var not in list(dicti.keys())):\n                return False\n            if dicti[2*var]<=0:\n                return False\n            dicti[var]-=1\n            dicti[2*var]-=1\n        return True\n\n", "class Solution:\n    def get_result(self, sl, d):\n        for k in sl:\n            if d[k]==0:\n                continue\n            if 2*k not in d:\n                return False\n            v = d[k]\n            v2 = d[2*k]\n            if v>v2:\n                return False\n            d[k] -= v\n            d[2*k] -= v\n        return True\n            \n    def canReorderDoubled(self, A: List[int]) -> bool:\n        d = dict()\n        num_zeros = 0\n        for a in A:\n            if a==0:\n                num_zeros += 1\n                continue\n            if a in d:\n                d[a] += 1\n            else:\n                d[a] = 1\n        neg = [k for k in list(d.keys()) if k<0]\n        pos = [k for k in list(d.keys()) if k>0]\n        if num_zeros%2!=0:\n            return False\n        sorted_pos = sorted(pos)\n        sorted_neg = sorted(neg, reverse=True)\n        res = self.get_result(sorted_pos, d)\n        if not res:\n            return False\n        res = self.get_result(sorted_neg, d)\n        if not res:\n            return False\n        return sum(list(d.values()))==0\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cnt = collections.Counter(A)\n        # It handles the case where there is odd number of 0, since the total number is even, there should be a number which cannot match because of the extra 0\n        for k in sorted(cnt, key=abs):\n            if cnt[k] > cnt[2*k]:\n                return False\n            \n            cnt[2*k] -= cnt[k]\n            \n        return True", "from collections import Counter\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # Greedy\n        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        # count = Counter(A)\n        # for x in sorted(A, key=abs):\n        #     if count[x] == 0: continue\n        #     if count[2 * x] == 0: return False\n        #     count[x] -= 1\n        #     count[2 * x] -= 1\n        # return True\n\n\n        count = Counter(A)\n        for x in sorted(count, key=abs):\n            if count[x] > count[2 * x]:\n                return False\n            count[2 * x] -= count[x]\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for i in sorted(count, key=abs):\n            count[2*i] -= count[i]\n            if count[2*i] < 0:\n                return False\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        freq = dict()\n        for i in A:\n            freq[i] = freq.get(i, 0) + 1\n\n        for k in sorted(list(freq.keys()), key=lambda x: abs(x)):\n            if freq[k] == 0: continue\n            if freq[k] > freq.get(2*k, 0):\n                return False\n            freq[2*k] -= freq[k]\n            \n        return True\n", "from collections import Counter\n    \n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if not A: return True\n        c = Counter(A)\n        keys = sorted(c.keys())\n        for k in keys:\n            if k == 0:\n                if c[k] % 2 == 0:\n                    c[k] = 0\n                else:\n                    return False\n            if k < 0 and c[k] > 0:\n                if k/2 in c:\n                    c[k/2] -= c[k]\n                    c[k] = 0\n            if k > 0 and c[k] > 0:\n                if k*2 in c:\n                    c[k*2] -= c[k]\n                    c[k] = 0\n            \n        return set(c.values()) == {0}\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=collections.Counter(A)\n        c_list=sorted(list(cache),key=lambda x: (abs(x),x))\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        d = collections.Counter(A)\n        if 0 in d:\n          if d[0] & 1 == 1:\n            return False\n          d.pop(0)\n\n        keys = sorted(d.keys())\n        for i in keys:\n          if i in d:\n            if i < 0:\n              if i / 2 not in d:\n                return False\n              if d[i] > d[i/2]:\n                return False\n              d[i/2] -= d[i]\n              if d[i/2] == 0:\n                d.pop(i/2)\n              d.pop(i)\n            else:\n              if i * 2 not in d:\n                return False\n              if d[i] > d[i*2]:\n                return False\n              d[i*2] -= d[i]\n              if d[i*2] == 0:\n                d.pop(i*2)\n              d.pop(i)\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        B = OrderedDict()\n        for x in A:\n            if x in B:\n                B[x] += 1\n            else:\n                B[x] = 1\n        \n        while B:\n            x = next(iter(B))\n            freq = B.pop(x)\n            \n            #print(x,freq)\n            \n            if x<0:\n                if x%2:\n                    return False\n                if (x//2 not in B) or B[x//2]<freq:\n                    return False\n                B[x//2] -= freq\n                if B[x//2] == 0:\n                    B.pop(x//2)\n            \n            elif x==0:\n                if freq%2:\n                    return False\n                \n            else:\n                if (x*2 not in B) or B[x*2]<freq:\n                    return False\n                B[x*2] -= freq\n                if B[x*2] == 0:\n                    B.pop(x*2)\n        \n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c = collections.Counter(A)\n        cc = sorted(c, key=abs)\n        #print(cc)\n        for x in cc:\n            #print(str(x), end=\\\": \\\")\n            #print(c)\n            if c[x] > c[2 * x]:\n                return False\n            c[2 * x] -= c[x]\n        #print(c)\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        neg = dict()\n        pos = dict()\n        zero = 0\n        for n in A:\n            if n < 0:\n                if -n not in neg:\n                    neg[-n] = 0\n                neg[-n] += 1\n            elif n >0:\n                if n not in pos:\n                    pos[n] = 0\n                pos[n] += 1\n            else:\n                zero += 1\n        if zero % 2 != 0:\n            return False\n        #print(pos,neg)\n        def helper(nums):\n            num_sorted = sorted(list(nums.keys()),reverse = True)\n            while num_sorted:\n                a = num_sorted.pop()\n                if nums[a] == 0:\n                    continue\n                if 2*a not in nums or nums[a]>nums[2*a]:\n                    return False\n                nums[2*a] -= nums[a]\n            return True\n        return helper(pos) and helper(neg)\n                \n", "from collections import defaultdict\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        s = defaultdict(int)\n        for a in A:\n            if a <= 0:\n                if 2 * a in s:\n                    s[2*a] -= 1\n                    if not s[2*a]:\n                        del s[2*a]\n                else:\n                    s[a] += 1\n            else:\n                if a % 2 == 0 and a // 2 in s:\n                    s[a // 2] -= 1\n                    if not s[a // 2]:\n                        del s[a // 2]\n                else:\n                    s[a] += 1\n        return not s", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        hashtable = {}\n        zero_count  = 0\n        for i in range(len(A)):\n            if A[i]==0:\n                zero_count+=1\n                continue\n            if A[i] in list(hashtable.keys()):\n                hashtable[A[i]]+=1\n                \n            else:\n                hashtable[A[i]]=1\n                \n                \n        if zero_count%2==1:\n            return False\n        else:\n            key_list = []\n            pair_count = 0\n            for key in list(hashtable.keys()):\n                key_list.append(key)\n                \n            key_list.sort()\n            \n            for key in key_list:\n                if key%2==0 and key//2 in list(hashtable.keys()):\n                    m = min(hashtable[key],hashtable[key//2])\n                    hashtable[key]-=m\n                    hashtable[key//2]-=m\n                    pair_count+=m\n                    \n            if pair_count*2 + zero_count==len(A):\n                return True\n            else:\n                return False\n            \n            \n", "from collections import Counter\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # O(NlogN) time        \n        # O(N) space\n        \n        if not A:\n            return True\n        \n        counts = Counter(A)        \n        \n        for key in sorted(counts.keys()):\n            if counts[key] == 0:\n                continue\n            \n            factor = .5 if key < 0 else 2\n            if counts[key] > counts[factor*key]:\n                return False\n            counts[factor*key] -= counts[key]\n        \n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort(key=lambda x: abs(x))\n        freq = dict()\n\n        for i in A:\n            freq[i] = freq.get(i, 0) + 1\n\n        for k in sorted(list(freq.keys()), key=lambda x: abs(x)):\n            if freq[k] == 0: continue\n            if freq[k] > freq.get(2*k, 0):\n                return False\n            freq[2*k] -= freq[k]\n            \n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        D = {}\n        for x in A:\n            D[x] = D.get(x, 0) + 1\n            \n        D = dict([x for x in sorted(list(D.items()), key =lambda x:x[0] )])\n        \n        for x in D:\n            while D[x] > 0:\n                D[x] -= 1\n                if x <= 0:\n                    pair_x = x / 2\n                else:\n                    pair_x = x * 2\n                    \n                if D.get(pair_x, 0) > 0:\n                    D[pair_x] -= 1\n                else:\n                    return False\n                \n        return True\n            \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cnt = collections.Counter(A)\n        for k in sorted(cnt, key=abs):\n            a = cnt[k]\n            if cnt[k] == 0:\n                continue\n            b = cnt.get(2 * k, 0)\n            if b < a:\n                return False\n            cnt[2 * k] -= a\n            \n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        def update_map(count, small, large):\n            small_count = count[small]\n            large_count = count[large]\n            min_count = min(small_count, large_count)\n            \n            count[small] += -min_count\n            if small != large:\n                count[large] += -min_count\n            \n        if not A:\n            return True\n        element_count = {}\n        ordered_elements = list(set(A))\n        ordered_elements.sort()\n        \n        for number in A:\n            if number not in element_count:\n                element_count[number] = 0\n            element_count[number] += 1\n        \n        for number in ordered_elements:\n            number_count = element_count[number]\n            double_number = number * 2\n            if double_number in element_count:\n                update_map(element_count, number, double_number)\n            \n        for number in element_count:\n            if element_count[number] != 0:\n                return False\n        return True\n                    \n                \n", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c=Counter(A)\n        A=sorted(A)\n        for num,v in sorted(list(c.items()), key= lambda item:item[0]):\n            if num>0 and c[num]>0:\n                if c[num]!=0 and c[num]>c[2*num]:\n                    return False\n                c[2*num]-=c[num]\n                c[num]=0\n            elif num<0 and c[num]>0:\n                if num%2==1:\n                    return False\n                if c[num]!=0 and c[num]>c[num//2]:\n                    return False\n                c[num//2]-=c[num]\n                c[num]=0\n        return True\n            \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if not A:\n            return True\n        positive_heap = []\n        negative_heap = []\n        zero = 0\n        positive_d = defaultdict(int)\n        negative_d = defaultdict(int)\n        for i in A:\n            if i == 0:\n                zero += 1\n            elif i < 0:\n                heappush(negative_heap, -i)\n                negative_d[-i] += 1\n            else:\n                heappush(positive_heap, i)\n                positive_d[i] += 1\n        if zero % 2 != 0:\n            return False\n        if not self.check(positive_heap, positive_d):\n            return False\n        if not self.check(negative_heap, negative_d):\n            return False\n        return True\n    \n    def check(self, h, d):\n        for _ in range(len(h)):\n            i = heappop(h)\n            if d[i] == 0:\n                continue\n            if 2*i not in d:\n                return False\n            elif d[2*i] < d[i]:\n                return False\n            else:\n                d[2*i] -= d[i]\n                d[i] = 0\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        zcount = 0\n        pos = []\n        neg = []\n        for n in A:\n            if n==0:\n                zcount+=1\n            elif n>0:\n                pos.append(n)\n            else:\n                neg.append(-n)\n        def verifypos(A):\n            count = collections.Counter(A)\n            for x in sorted(A, key = abs):\n                if count[x] == 0: continue\n                if count[2*x] == 0: return False\n                count[x] -= 1\n                count[2*x] -= 1\n\n            return True\n        return verifypos(pos) and verifypos(neg)", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for x in sorted(A, key=abs):\n            if count[x] == 0:\n                continue\n            if x == 0 and x % 2:\n                return False\n            if count[x] > count[2 * x]:\n                return False\n            count[x], count[2 * x] = 0, count[2 * x] - count[x]\n        \n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        D = {}\n        for x in A:\n            D[x] = D.get(x, 0) + 1\n        D = dict([kv for kv in sorted(list(D.items()), key =lambda x:x[0] )])\n        \n        for x in D:\n            while D[x] > 0:\n                D[x] -= 1\n                if x <= 0:\n                    pair_x = x / 2\n                else:\n                    pair_x = x * 2\n                    \n                if D.get(pair_x, 0) > 0:\n                    D[pair_x] -= 1\n                else:\n                    return False\n                \n        return True\n            \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        dic = {}\n        for i in A:\n            if i % 2 == 0 and i/2 in dic:\n                i = i / 2\n                dic[i] -= 1\n                if dic[i] == 0:\n                    del dic[i]\n            elif i * 2 in dic:\n                i = i * 2\n                dic[i] -= 1\n                if dic[i] == 0:\n                    del dic[i]\n            else:\n                dic[i] = dic.setdefault(i, 0) + 1\n                continue\n        return len(dic) == 0", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # https://blog.csdn.net/fuxuemingzhu/article/details/84925747\n        A.sort()\n        N = len(A)\n        count = collections.Counter(A)\n        for i in range(N):\n            if A[i] == 0 or A[i] not in count: continue\n            elif A[i] < 0:\n                if A[i] % 2 == 1 or count[A[i] / 2] == 0:\n                    return False\n                else:\n                    count[A[i] / 2] -= count[A[i]]\n                    if count[A[i] / 2] == 0:\n                        del count[A[i] / 2]\n                    del count[A[i]]\n            else:\n                if count[A[i] * 2] == 0:\n                    return False\n                else:\n                    count[A[i] * 2] -= count[A[i]]\n                    if count[A[i] * 2] == 0:\n                        del count[A[i] * 2]\n                    del count[A[i]]\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c = collections.Counter(A)\n        for x in sorted(c):\n            if c[x] == 0: continue\n\n            if c[x] < 0:\n                return False\n            if x == 0:\n                if c[x] % 2 != 0:\n                    return False\n                else:\n                    continue\n            if x > 0:\n                temp = 2*x\n            elif x % 2:\n                return False\n            else:\n                \n                temp =  x//2\n\n\n            if c[temp] < c[x]:\n                return False\n            else:\n                c[temp] -= c[x]\n\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        pos_set = set()\n        neg_set = set()\n        pos_dict = {}\n        neg_dict = {}\n        pos_count = 0\n        for num in A:\n            if num >= 0:\n                pos_set.add(num)\n                pos_dict[num] = 1 + pos_dict.get(num,0)\n                pos_count += 1\n            else:\n                neg_set.add(abs(num))\n                neg_dict[abs(num)] = 1 + neg_dict.get(abs(num),0)\n        if pos_count % 2 != 0:\n            return False\n        else:\n            return self.helper(pos_set,pos_dict) and self.helper(neg_set,neg_dict)\n    \n    def helper(self,set_,dict_):\n        sorted_ = sorted(list(set_))\n        for num in sorted_:\n            if num * 2 in sorted_ and num != 0:\n                small_ = dict_[num] \n                large_ = dict_[num * 2]\n                usage = min(small_,large_)\n                dict_[num] -= usage\n                dict_[num * 2] -= usage\n            elif num == 0:\n                if dict_[0] % 2 != 0:\n                    return False\n                else:\n                    dict_[0] = 0\n                \n        for key in dict_:\n            if dict_[key] != 0:\n                return False\n        return True\n                \n", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if not A: return True\n        C = Counter(A)\n        K = sorted(C.keys())\n        for k in K:\n            if k == 0:\n                if C[k] & 1:\n                    return False\n                else:\n                    C[k] = 0\n            if k < 0 and C[k] > 0:\n                if k % 2 == 0 and (k // 2 in C):\n                    C[k//2] -= C[k]\n                    C[k] = 0\n            if k > 0 and C[k] > 0:\n                if k * 2 in C:\n                    C[k*2] -= C[k]\n                    C[k] = 0\n        return set(C.values()) == {0}", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c = Counter(A)\n        for n in sorted(list(c.keys()), key=abs):\n            while c[n] > 0 and c[(double := 2 * n)] > 0:\n                c[n] -= 1\n                c[double] -= 1\n        return all(not v for v in list(c.values()))\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        def factorize(num):\n            power = 0\n            while num  % 2 == 0:\n                num, power = num//2, power+1\n            return (num, power)\n        \n        counts = defaultdict(lambda : [0]*17)\n        zeros = 0\n        for a in A:\n            if a == 0:\n                zeros += 1\n            else:\n                n, p = factorize(a)\n                counts[n][p] += 1\n        \n        if zeros % 2 == 1:\n            return False\n        \n        \n        for key in counts:\n            carry = 0\n            for p in counts[key]:\n                carry = p - carry\n                if carry < 0: return False\n            if carry != 0: return False\n        \n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # https://www.cnblogs.com/seyjs/p/10092569.html\n        A.sort()\n        dic = {}\n        for i in A:\n            if i % 2 == 0 and i/2 in dic:\n                i = i / 2\n                dic[i] -= 1\n                if dic[i] == 0:\n                    del dic[i]\n            elif i * 2 in dic:\n                i = i * 2\n                dic[i] -= 1\n                if dic[i] == 0:\n                    del dic[i]\n            else:\n                dic[i] = dic.setdefault(i, 0) + 1\n                continue\n        return len(dic) == 0", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort(key=lambda x: abs(x))\n        c={}\n        for v in A:\n            if v/2 in c:\n                c[v/2]-=1\n                if not c[v/2]:\n                    del c[v/2]\n            else:\n                if v not in c: c[v]=0\n                c[v]+=1\n        return len(c)==0", "import collections\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        neg = collections.Counter()\n        pos = collections.Counter()\n        for n in A:\n            if n >= 0:\n                pos[n] += 1\n            else:\n                neg[n] += 1\n                \n        for n in sorted(neg, reverse = True):\n            if neg[n*2] < neg[n]:\n                return False\n            neg[n*2] -= neg[n]\n            del neg[n]\n            if neg[n*2] == 0:\n                del neg[n*2]\n        if len(neg) != 0:\n            return False\n        for n in sorted(pos):\n            if pos[n*2] < pos[n]:\n                return False\n            pos[n*2] -= pos[n]\n            del pos[n]\n            if pos[n*2] == 0:\n                del pos[n*2]\n        if len(pos) != 0:\n            return False\n        return True\n                \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        freq = dict()\n        for i in A:\n            freq[i] = freq.get(i, 0) + 1\n        for i in A:\n            if freq.get(i, 0) == 0: continue\n\n            if i < 0:\n                if i % 2 != 0:\n                    return False\n                elif not freq.get(i // 2, 0) > 0:\n                    return False\n            elif i > 0 and not freq.get(i * 2, 0) > 0:\n                return False\n            \n            if i < 0:\n                freq[i // 2] -= 1\n            else:\n                freq[i*2] -=1\n            freq[i] -= 1\n            \n        return True\n", "from collections import Counter\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        negs = [a for a in A if a < 0]\n        pos = [a for a in A if a > 0]\n        zeros = [a for a in A if a == 0]\n        \n        if any(map(lambda x: len(x) % 2 != 0, [negs, pos, zeros])):\n            return False\n        \n        if not self.is_valid(negs, True) or not self.is_valid(pos, False):\n            return False\n        return True\n        \n    \n    def is_valid(self, A, neg=False):\n        A = sorted(A)\n        N = len(A)\n        \n        if neg:\n            A = A[::-1]\n\n        c = Counter(A)\n        for a in A:\n            if c[a] == 0:\n                continue\n            target = a * 2\n            if c[target] == 0:\n                return False\n            c[a] -= 1\n            c[target] -= 1\n        return True", "from collections import defaultdict\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        A.sort()\n        \n        arr = defaultdict(int)\n        \n        for item in A:\n            \n            if 2*item in arr and arr[2*item] > 0:\n                arr[2*item] -= 1\n            elif item % 2 == 0 and (item // 2) in arr and arr[item // 2] > 0:\n                arr[item // 2] -= 1\n            else:\n                arr[item] += 1\n                \n            \n        return sum([x for x in arr.values() if x != 0]) == 0", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x]==0: continue # x may be end of a pair\n            if count[2*x]==0: \n                return False # x exsist, we have to match it with a 2x\n            count[2*x] -= 1\n            count[x] -= 1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=Counter(A)\n        c_list=sorted(list(cache),key=abs)\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True\n        \n        '''\n        if not A:\n            return True\n        positive_heap = []\n        negative_heap = []\n        zero = 0\n        positive_d = defaultdict(int)\n        negative_d = defaultdict(int)\n        for i in A:\n            if i == 0:\n                zero += 1\n            elif i < 0:\n                heappush(negative_heap, -i)\n                negative_d[-i] += 1\n            else:\n                heappush(positive_heap, i)\n                positive_d[i] += 1\n        if zero % 2 != 0:\n            return False\n        if not self.check(positive_heap, positive_d):\n            return False\n        if not self.check(negative_heap, negative_d):\n            return False\n        return True\n    \n    def check(self, h, d):\n        for _ in range(len(h)):\n            i = heappop(h)\n            if d[i] == 0:\n                continue\n            if 2*i not in d:\n                return False\n            elif d[2*i] < d[i]:\n                return False\n            else:\n                d[2*i] -= d[i]\n                d[i] = 0\n        return True\n    '''\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        table = collections.defaultdict(int)\n        for num in A:\n            table[num] += 1\n        A.sort()\n        for num in A:\n            if table[num] == 0:\n                continue\n            pair = num * 2\n            if num < 0:\n                pair = num / 2\n            if table[pair] < 1:\n                return False\n            table[num] -= 1\n            table[pair] -= 1\n        return True\n            \n            \n                \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count=collections.Counter(A)\n        for x in sorted(A,key=abs):\n            if count[x]==0:\n                continue\n            if count[2*x]==0:\n                return False\n            count[x]-=1\n            count[2*x]-=1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        \n        ## Time Complexity: O(N LOG N) , Space: O(N)\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # Array of Doubled Pairs 9/24 8/31/20\n        # 1:43 9/1/2020\n#         c = collections.Counter(A)\n#         for x in sorted(c, key=abs):\n#             if c[x] > c[x * 2]:\n#                 return False\n#             c[x*2] -= c[x]\n        \n#         return True\n        \n\n    \n        A = [abs(num) for num in A ]\n        A.sort()\n        dic = collections.defaultdict(collections.deque)\n        for i, num in enumerate(A):\n            dic[num].append(i)\n        \n        visited = [0]*len(A)\n        cnt = 0\n        i = 0\n        # while cnt < len(A) // 2 :\n        while i < len(A):\n            if visited[i]:\n                i += 1\n                continue\n            val, val_double = A[i], 2 * A[i]\n            if val_double in dic and dic[val_double]:\n                if val not in dic or not dic[val]:\n                    return False\n                dic[val].popleft()\n                if not dic[val_double]:\n                    return False\n                index = dic[val_double].popleft()\n                visited[index] = 1\n                \n            else:\n                return False\n            i += 1\n            # cnt += 1\n            \n        return True\n    \n#         A = [abs(num) for num in A ]\n#         A.sort()\n#         dic = collections.defaultdict(int)\n#         for num in A:\n#             dic[num] += 1\n        \n#         visited = [0]*len(A)\n#         cnt = 0\n#         i = 0\n#         while cnt < len(A) // 2 :\n#             if visited[i]:\n#                 i += 1\n#                 continue\n#             val_small = A[i]\n#             if 2*val_small in dic:\n#                 dic[2*val_small] -= 1\n#                 dic[val_small] -= 1\n#                 if dic[2*val_small] < 0 or dic[val_small] < 0:\n#                     return False\n#                 search_index = A.index(2*val_small, i+1)\n#                 while visited[search_index]:\n#                     search_index = A.index(2*val_small, search_index+1)\n#                 visited[search_index] = 1\n#             else:\n#                 return False\n#             i += 1\n#             cnt += 1\n            \n#         return True\n                \n\n            \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counts = collections.Counter(A)\n        count = 0\n        A.sort()\n        for num in A: #range(0,len(A)//2):\n            #num = A[i] \n            if counts[num] and counts[num * 2]:\n                counts[num*2]-=1\n                counts[num]-=1\n                count+=1\n        return count*2 == len(A) ", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counter = collections.Counter(A)\n        for e in sorted(A, key=abs):\n            if 2*e in counter and counter[2*e] > 0 and counter[e] > 0: \n                counter[e] -= 1\n                counter[2*e] -= 1\n        print(counter)\n        return sum(counter.values()) == 0", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        seen = Counter()\n        for num in A:\n            if num>0 and num%2:\n                seen[num]+=1\n                continue\n            elem = 2*num if num<0 else num//2\n            if seen[elem]>0:\n                seen[elem]-=1\n            else:\n                seen[num]+=1\n\n        if sum(seen.values()):\n            return False\n        return True", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # if len(A)%2==1:\n        #     return False\n        # counter = Counter(A)\n        # # print(counter)\n        # Skey = set(counter.keys())\n        # key = counter.keys()\n        # for i in key:\n        #     if 2*i in Skey:\n        #         counter[i]=0\n        #         counter[i*2]-=counter[i]\n        # val = list(counter.values())\n        # print(val)\n        # for i in val:\n        #     if i !=0:\n        #         return False\n        # return True\n        \n        cnt = collections.Counter(A)\n        for a in sorted(A, key = abs):\n            if cnt[a] and cnt[a * 2]:\n                cnt[a] -= 1\n                cnt[a * 2] -= 1  \n        return all(cnt[a] == 0 for a in A)", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=collections.Counter(A)\n        c_list=sorted(cache, key=lambda x: abs(x))\n        print(cache, c_list)\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True", "import numpy as np\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        statdict = {}\n        flag = True\n#        print(A)\n        for i in A:\n#            print(statdict)\n            if i in statdict:\n                statdict[i] = statdict[i] + 1\n            elif i < 0:\n                if i*2 in statdict:\n                    statdict[i*2] = statdict[i*2] - 1\n                    if statdict[i*2] == 0:\n                        statdict.pop(i*2)\n                else:\n                    statdict[i] = 1\n            else:\n                if (i%2 == 0) and i/2 in statdict:\n                    statdict[int(i/2)] = statdict[int(i/2)] - 1\n                    if statdict[int(i/2)] == 0:\n                        statdict.pop(int(i/2))\n                else:\n                    statdict[i] = 1\n        return (len(statdict) == 0) or (len(statdict) == 1 and 0 in statdict and statdict[0] % 2 == 0)", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c = collections.Counter(A)\n                \n        for i in sorted(A, key=abs):\n            if c[i] and c[i*2]:\n                c[i] -= 1\n                c[i*2] -= 1\n        \n        return all(c[i] == 0 for i in A)\n                \n                \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        B = []\n        for x in A:\n            if x>0:\n                B.append(x)\n            else:\n                B.append(-x)\n        count = collections.Counter(B)\n        for x in sorted(B):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            else:\n                count[x] -=1\n                count[2*x] -=1\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        D1 = collections.Counter()\n        D2 = collections.Counter()\n        zero = 0\n        \n        for a in A:\n            if a < 0:\n                D1[a] += 1\n            else:\n                D2[a] += 1\n        \n        for d in sorted(D1, reverse=1):\n            if D1[d]:\n                if D1[ d*2 ] < D1[d]:\n                    return False\n                D1[ d*2 ] -= D1[d]\n\n        for d in sorted(D2):\n            if D2[d]:\n                if D2[ d*2 ] < D2[d]:\n                    return False\n                D2[ d*2 ] -= D2[d]\n        \n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        n = len(A)\n        #A[2*i+1] = 2*A[2*i]\n        #[-2,-4,2,4]\n        #A[1] == 2*A[0]\n        #A[3] == 2*A[2]\n        neg = sorted(list([x for x in A if x<0]))\n        pos = sorted(list([x for x in A if x>0]), reverse=True)\n        nl, pl = len(neg), len(pos)\n        if nl % 2 or pl % 2: return False\n        d1 = collections.Counter(neg)\n        cnt = 0\n        for i in range(nl):\n            if d1[2*neg[i]] > 0:\n                d1[2*neg[i]] -= 1\n                d1[neg[i]] -= 1\n                cnt += 1\n        if cnt < nl // 2: return False        \n        d2 = collections.Counter(pos)\n        cnt = 0\n        for i in range(pl):    \n            if d2[2*pos[i]] > 0:\n                print((pos[i]*2, pos[i]))\n                d2[2*pos[i]] -= 1\n                d2[pos[i]] -= 1\n                cnt += 1\n        if cnt < pl // 2: return False        \n        return True    \n", "class Solution(object):\n    def canReorderDoubled(self, A):\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A.sort()\n        d=Counter()\n        c=[]\n        e=[]\n        for i in A:\n            if(i<0):\n                c.append(i)\n            elif(i>=0):\n                e.append(i)\n        c.sort(reverse=True)\n        c.extend(e)\n        A=c\n        print(A)\n        for i in A:\n            d[i]+=1\n        if(d[0]%2!=0):\n            return False\n        d[0]=0\n        for i in A:\n            if(2*i in d)and(d[i]<=d[2*i]):\n                d[2*i]-=d[i]\n                d[i]=0\n            elif(d[i]==0):\n                continue\n            else:\n                return False\n        return True\n            \n                \n            \n                    \n", "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        d = dict()\n        num_zeros = 0\n        for x in A:\n            if x == 0:\n                num_zeros += 1\n                continue\n            x = abs(x)\n            y = x\n            while y % 2 == 0:\n                y //= 2\n            if y in d:\n                d[y].update([x])\n            else:\n                d[y] = Counter([x])\n        \n        if num_zeros % 2:\n            return False\n\n        for base, counter in d.items():\n            keys = sorted(counter)\n            for key in keys:\n                if counter[key] <= counter[2 * key]:\n                    counter[2 * key] -= counter[key]\n                    counter[key] -= counter[key]\n                else:\n                    return False\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c=collections.Counter(A)\n        \n        for x in sorted(A,key=abs):\n            if c[x]==0:\n                continue\n            if c[2*x]==0:\n                return False\n            c[x]-=1\n            c[2*x]-=1\n        return True\n", "# 20201007 12:08 \u9009\u53c2\u8003\u7b54\u6848\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=Counter(A)\n        c_list=sorted(list(cache),key=abs)\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counter=collections.Counter(A)\n        counter=dict(sorted(counter.items(),key=lambda x:abs(x[0])))\n        nums=[]\n        for num in counter.keys():\n            for _ in range(counter[num]):\n                nums.append(num)\n        for num in nums:\n            if counter[num]:\n                if 2*num in counter and counter[2*num]!=0:\n                    counter[num]-=1\n                    counter[num*2]-=1\n                else:\n                    return False\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if len(A) == 0 :\n            return True\n        \n        mydict = {}\n        for _ in range(0,len(A)):\n            if A[_] in mydict:\n                mydict[A[_]] += 1\n            else:\n                mydict[A[_]] = 1\n        \n        A_sorted = sorted(A)\n        \n        #print(A_sorted)\n        #print(mydict)\n        not_valid = set()\n        for num in A_sorted:\n            if len(mydict) == 0:\n                return True \n            if num in not_valid:\n                continue\n                \n            if (2 * num) in mydict and num in mydict:\n                double = 2*num\n                mydict[num] -= 1\n                mydict[double] -= 1\n\n                if mydict[num] == 0:\n                    mydict.pop(num)\n                    not_valid.add(num)\n                #deals with duplicates\n                if num == double:\n                    continue\n                elif mydict[2*num] == 0:\n                    mydict.pop(2*num)\n                    not_valid.add(2*num)\n            elif (num/2 in mydict and num in mydict):\n                half = num/2\n                mydict[num] -= 1\n                mydict[num/2] -= 1\n\n                if mydict[num] == 0:\n                    mydict.pop(num)\n                    not_valid.add(num)\n                if mydict[num/2] == 0:\n                    mydict.pop(num/2)\n                    not_valid.add(num/2)\n            else:\n                return False", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        # Divide an conquer\n        # Sort items according to their magnitude\n        # For each item, make sure it's double exists later in the list\n        # When a double is used, mark it with a mask\n        \n        used = [False]*len(A)\n        A.sort(key = lambda n: abs(n))\n        bank = collections.Counter(A)\n        \n        for num in A:\n            \n            if bank[num] == 0:\n                continue\n            \n            bank[num] -= 1\n            if bank.get(2*num, 0) == 0:\n                return False\n            bank[2*num] -= 1\n        \n        return True\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "from collections import Counter\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        # Greedy\n        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        count = Counter(A)\n        for x in sorted(A, key=abs):\n            if count[x] == 0: continue\n            if count[2 * x] == 0: return False\n            count[x] -= 1\n            count[2 * x] -= 1\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A_sorted = sorted(A, key=abs)\n        count = collections.Counter(A)\n        for a in A_sorted:\n            if count[a] == 0: \n                continue\n            if count[a * 2] == 0:\n                return False\n            count[a] -= 1\n            count[a * 2] -= 1\n            \n        return True", "class Solution(object):\n    def canReorderDoubled(self, A):\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n", "class Solution(object):\n    def canReorderDoubled(self, A):\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c = collections.Counter(A)\n        for k in sorted(c, key=abs):\n            if c[k] > c.get(2*k, 0):\n                return False\n            c[2*k] -= c[k]\n            \n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        st = {}\n        A = sorted(A,reverse=True)\n        for i in A:\n            if i in st:st[i]+=1\n            else: st[i] = 1\n        #print(st)\n        for num in A:\n            if (num*2) in st and st[num] > 0 and st[(num*2)] > 0:\n                st[num*2]-=1\n                st[num]-=1\n            #print(num,st)\n        for num in st:\n            if st[num] > 0:return False\n        return True\n", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count_a = Counter(A)\n        A.sort(key=lambda x: abs(x))\n        for elem in A:\n            if count_a[elem] == 0: continue\n            if count_a[elem * 2] == 0: return False\n            count_a[elem] -= 1\n            count_a[elem * 2] -= 1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0:\n                continue\n            if count[x*2] == 0:\n                return False\n            count[x] -= 1\n            count[2*x] -= 1\n            \n        return True\n    \n    \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        A.sort() \n        map = {}\n        \n        for item in A:\n            if item in map : map[item] +=1\n            else : map[item] =1\n        \n        for item in A:\n            if map[item]==0 : continue\n            if item <0 :\n                if item/2 in map : \n                    if map[item/2]==0 : return False\n                    map[item] -=1\n                    map[item/2] -=1\n                else : return False\n            else :\n                if item *2 in map:\n                    if map[2*item]==0: return False\n                    map[item] -=1\n                    map[item*2] -=1\n                else : return False\n        \n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        seen = dict()\n        for x in A:\n            if x not in seen:\n                seen[x] = 0\n            seen[x] += 1\n\n        for x in sorted(seen, key=lambda x : x**2):\n            if seen[x] == 0:\n                continue\n            if (2*x not in seen) or (seen[x] > seen[2*x]):\n                return False\n            else:\n                seen[2*x] -= seen[x]\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            print(x)\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True", "from collections import Counter\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        a = sorted(A,key=lambda x:abs(x),reverse = True)\n        b = dict(Counter(A))\n        while a:\n            \n            aa = a.pop()\n            if aa in b:\n\n                b[aa] -= 1\n                if b[aa]==0:\n                    del b[aa]\n\n                if 2*aa in b:\n                    b[2*aa] -= 1\n                else:\n                    return False\n                if b[2*aa]==0:\n                    del b[2*aa]\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        \n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: continue\n            if count[2*x] == 0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n        \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        counter = collections.Counter(A)\n        for x in sorted(counter,key=abs):\n            if counter[x] > counter[2*x]:\n                return False\n            counter[2*x] -= counter[x]\n        return True    ", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        if len(A) % 2 == 1:\n            return False\n        \n        count = collections.defaultdict(int)\n        for num in A:\n            count[num] += 1\n        A.sort()\n        for num in A:\n            if count[num] > 0:\n                double = num * 2\n                if double in count and count[double] > 0:\n                    # print(\\\"found\\\", double)\n                    count[num] -= 1                    \n                    count[double] -= 1\n                    \n        for num in count:\n            if count[num] != 0:\n                return False\n        return True\n            \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        c = collections.Counter(A)\n        for x in sorted(c, key=abs):\n            if c[x] > c[2 * x]:\n                return False\n            c[2 * x] -= c[x]\n        return True\n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        d={}\n        for i in A:\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n        A.sort()\n      \n        if 0 in d:\n            if d[0]%2!=0:\n                return False\n            d.pop(0)\n                \n        for i in A:\n            #print(i,d)\n            if i not in d:\n                continue\n           \n            if  i*2 in d:\n                if d[i]>d[i*2]:\n                    d[i]-=d[i*2]\n                    d[i*2]=0\n                else:\n                    d[i*2]-=d[i]\n                    d[i]=0\n                if d[i]==0:\n                    d.pop(i)\n                if d[i*2]==0:\n                    d.pop(i*2)\n            elif i%2==0 and i//2 in d:\n                if d[i]>d[i//2]:\n                    d[i]-=d[i//2]\n                    d[i//2]=0\n                else:\n                    d[i//2]-=d[i]\n                    d[i]=0\n                if d[i]==0:\n                    d.pop(i)\n                if d[i//2]==0:\n                    d.pop(i//2)\n            else:\n                return False\n        return len(d)==0\n", "import collections\n\nclass Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        ''' Place all values into dicts and start counting from the bottom\n        '''\n        counter = collections.Counter(A)\n        \n        for v in sorted(counter, key = abs):\n            if counter[2 * v] < counter[v]:\n                return False\n            counter[2 * v] -= counter[v]\n        return True\n        \n            \n                \n                    \n            \n        \n", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        A = sorted(A, key=lambda x: abs(x))\n        M = Counter()\n        \n        for e in A:\n            M[e] += 1\n        \n        # print(M)\n        # print(A)\n        \n        for e in A:\n            # print(e, M[2*e], M)\n            if M[e] and M[2*e]:\n                M[2*e] -= 1\n                M[e] -= 1\n                # print('->', 2*e, M[2*e])\n            elif M[e]:\n                # print(M, e)\n                return False\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x]==0: continue\n            if count[2*x]==0: return False\n            count[x] -= 1\n            count[2*x] -= 1\n        return True", "class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        dic=collections.defaultdict(int)\n        for i in range(len(A)):\n            dic[A[i]]+=1\n        ki=list(dic.keys())\n        ki.sort(key=lambda x:abs(x))\n        for k in ki:\n            if dic[2*k]<dic[k]:\n                return False\n            dic[2*k]-=dic[k]\n            dic[k]=0\n        return True"]
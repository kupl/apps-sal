["class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        memo = [[0 for j in range(cols)] for i in range(rows)]\n        ans = 0\n        \n        if grid[0][0] == 1:\n            memo[0][0] = (1,1)\n            ans = 1\n        else:\n            memo[0][0] = (0,0)\n        \n        for i in range(1,rows):\n            if grid[i][0] == 0:\n                memo[i][0] = (0,0)\n            else:\n                memo[i][0] = (memo[i-1][0][0]+1,1)\n                ans = 1\n        \n        for j in range(1,cols):\n            if grid[0][j] == 0:\n                memo[0][j] = (0,0)\n            else:\n                memo[0][j] = (1,memo[0][j-1][1]+1)\n                ans = 1\n            \n        for i in range(1,rows):\n            for j in range(1,cols):\n                if grid[i][j] == 0:\n                    memo[i][j] = (0,0)\n                else:\n                    memo[i][j] = (memo[i-1][j][0]+1, memo[i][j-1][1]+1)\n                    ans = 1\n        \n        for i in range(rows-1,0,-1):\n            for j in range(cols-1,0,-1):\n                l_min = min(memo[i][j][0],memo[i][j][1])\n                \n                while l_min>ans:\n                    if memo[i][j-l_min+1][0]>=l_min and memo[i-l_min+1][j][1]>=l_min:\n                        ans = l_min\n                    l_min -= 1\n        return ans*ans\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        maxVal = 0\n        m = len(grid)\n        n = len(grid[0])\n        hor = [[0]*n for i in range(m)]\n        ver = [[0]*n for i in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    hor[i][j] = 1 if j == 0 else 1 + hor[i][j-1]\n                    ver[i][j] = 1 if i == 0 else 1 + ver[i-1][j]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1, -1, -1):\n                small = min(hor[i][j], ver[i][j])\n                while small > maxVal:\n                    if ver[i][j-small+1] >= small and hor[i-small+1][j] >= small:\n                        maxVal = small\n                    small -= 1\n        return maxVal**2", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        h = [row[:] for row in grid]\n        v = [row[:] for row in grid]\n        for row in range(m):\n            for col in range(1, n):\n                if h[row][col] != 0:\n                    h[row][col] += h[row][col-1]\n        for col in range(n):\n            for row in range(1, m):\n                if v[row][col] != 0:\n                    v[row][col] += v[row-1][col]\n        for row in range(m):\n            for col in range(n):\n                curr = grid[row][col]\n                if not curr: continue\n                side = h[row][col] if h[row][col] < v[row][col] else v[row][col]\n                res = 1\n                for x in range(side, 0, -1):\n                    if v[row][col-x+1] >= x and h[row-x+1][col] >= x:\n                        res = x*x\n                        break\n                if res > ans:\n                    ans = res\n        return ans", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n        dp = [[0] * len(grid[0]) for i in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0 and j > 0:\n                    print(f'i{i}')\n                    print(f'j{j}')\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                elif j == 0 and i > 0:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                if i >= 1 and j >= 1:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp [i -1][j - 1] + grid[i][j]\n            \n                \n        res = 0\n        print(dp)\n        length_range = min(len(grid), len(grid[0]))\n        for length in range(length_range):\n            for x1 in range(len(grid)- length):\n                for y1 in range(len(grid[0]) - length):\n                    if x1 == 1 and y1 ==0:\n                        print(\\\"denug\\\")\n                    if (self.getLength(grid, dp, x1, y1, x1 + length, y1) == length + 1 and\n                       self.getLength(grid, dp, x1, y1, x1, y1 + length) == length + 1 and\n                       self.getLength(grid, dp, x1 + length, y1, x1 + length, y1 + length) == length + 1 and\n                       self.getLength(grid, dp, x1, y1 + length, x1 + length, y1 + length) == length + 1):\n                        res = (length+1)*(length+1)\n        return res               \n                    \n    def getLength(self, grid, dp, x1, y1, x2, y2):\n        area_1 = dp[x1 - 1][y2] if x1 - 1 >= 0 else 0\n        area_2 = dp[x2][y1 -1] if y1 -1 >= 0 else 0\n        area_3 = dp[x1 -1][y1 - 1] if x1 -1 >= 0 and y1 -1 >= 0 else 0\n        return dp[x2][y2] - area_1 - area_2 + area_3", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if not grid: return 0\n        edge, m, n = 0, len(grid), len(grid[0])\n        left, top = [[0 for j in range(n+1)] for i in range(m+1)], [[0 for j in range(n+1)] for i in range(m+1)]\n        for i in range(m):\n            for j in range(n):\n                left[i+1][j+1] = (0 if grid[i][j]==0 else 1+left[i+1][j])\n                top[i+1][j+1] = (0 if grid[i][j]==0 else 1+top[i][j+1])\n                left_ones, top_one = left[i+1][j+1], top[i+1][j+1]\n                for length in range(min(left_ones, top_one), edge, -1):\n                    if min(left[i+2-length][j+1], top[i+1][j+2-length])  >= length:\n                        edge = max(edge,length)\n                        break\n        return edge**2\n\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        dpdown =[[0] * n for i in range(m)]\n        dpright =[[0] * n for i in range(m)]\n        for i in range(m):\n            cur = 0\n            for j in range(n-1,-1,-1):\n                if grid[i][j] == 1:\n                    cur+=1\n                    dpright[i][j] = cur\n                else:\n                    cur = 0\n        for j in range(n):\n            cur = 0\n            for i in range(m-1,-1,-1):\n                if grid[i][j] == 1:\n                    cur+=1\n                    dpdown[i][j] = cur\n                else:\n                    cur = 0                    \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                for k in range(min(dpright[i][j],dpdown[i][j])):\n                    if dpright[i+k][j]>k and dpdown[i][j+k]>k:\n                        res = max(k+1,res)\n        return res**2", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        ones_up_to_index_rows = [[0] for i in range(len(grid))]\n        ones_up_to_index_columns = [[0] for i in range(len(grid[0]))]\n        ret = 0\n        \n        \n        for row in range(len(grid)):\n            for column in range(len(grid[0])):\n                ones_up_to_index_rows[row].append(ones_up_to_index_rows[row][-1] + grid[row][column])\n                ones_up_to_index_columns[column].append(ones_up_to_index_columns[column][-1] + grid[row][column])\n                \n\n        for row in range(len(grid)):\n            column = 0\n            \n            \n            if (len(grid) - row > ret):\n                for column in range(len(grid[0])):\n                    next_column = column\n\n\n                    while (next_column < len(grid[0]) and grid[row][next_column] == 1):\n                        next_column += 1\n\n\n                    for i in range(next_column - 1, column - 1, -1):\n                        side_length = i - column + 1\n\n\n                        if (side_length <= ret):\n                            break\n\n                        row_index_dp = row + side_length - 1\n\n\n                        if (row_index_dp < len(grid) and \n                           ones_up_to_index_columns[i][row_index_dp + 1] - ones_up_to_index_columns[i][row] == side_length and\n                           ones_up_to_index_rows[row_index_dp][i + 1] - ones_up_to_index_rows[row_index_dp][column] == side_length and\n                           ones_up_to_index_columns[column][row_index_dp + 1] - ones_up_to_index_columns[column][row] == side_length):\n                            ret = side_length\n                            break\n            else:\n                break\n                    \n        return ret ** 2  ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        \n        lefts = [l[:] for l in grid]\n        ups = [l[:] for l in grid]\n        \n        for i in range(n):\n            for j in range(1,m):\n                if lefts[i][j]:\n                    lefts[i][j]+= lefts[i][j-1]\n\n        for j in range(m):\n            for i in range(1,n):\n                if ups[i][j]:\n                    ups[i][j]+= ups[i-1][j]\n        \n        rec = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    rec = max(rec,1)\n                    k = min(ups[i][j], lefts[i][j])\n                    for r in range(1,k):\n                        if lefts[i-r][j]>=r+1 and ups[i][j-r]>=r+1:\n                            rec=max(rec, (r+1)**2)\n        \n        return rec", "import numpy as np\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        R, C, count = len(grid), len(grid[0]), 0\n        dp=[[[0,0]for _ in range(C +1)]for _ in range(R + 1)]\n        for i in range(1,R + 1):\n            for j in range(1,C + 1):\n                if grid[i - 1][j - 1]==1:\n                    dp[i][j][0], dp[i][j][1] = dp[i - 1][j][0] + 1, dp[i][j - 1][1] + 1\n                    for k in range(min(dp[i][j][0], dp[i][j][1]), count, -1):\n                        if min(dp[i - k + 1][j][1], dp[i][j - k + 1][0]) >= k:\n                            count = max(count, k)\n                            break\n        return count**2", "import numpy as np\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        R, C, count = len(grid), len(grid[0]), 0\n        dp=[[[0,0]for _ in range(C + 1)]for _ in range(R + 1)]\n        for i in range(1,R + 1):\n            for j in range(1,C + 1):\n                if grid[i - 1][j - 1]==1:\n                    dp[i][j][0], dp[i][j][1] = dp[i - 1][j][0] + 1, dp[i][j - 1][1] + 1\n                    for k in range(min(dp[i][j][0], dp[i][j][1]), count, -1):\n                        if k <= min(dp[i - k + 1][j][1], dp[i][j - k + 1][0]):\n                            count = max(count, k)\n                            break\n        return count**2", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        M,N,count=len(grid),len(grid[0]),0\n        dp=[[[0,0]for _ in range(N+1)]for _ in range(M+1)]\n        for i in range(1,M+1):\n            for j in range(1,N+1):\n                if grid[i-1][j-1]==1:\n                    dp[i][j][0],dp[i][j][1]=dp[i-1][j][0]+1,dp[i][j-1][1]+1\n                    for k in range(min(dp[i][j][0],dp[i][j][1]),count,-1):\n                        if min(dp[i-k+1][j][1],dp[i][j-k+1][0])>=k:\n                            count=max(count,k)\n                            break\n        return count**2\n", "class Solution:\n    import copy\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        ROWS = len(grid)\n        COLS = len(grid[0]) if ROWS else 0\n        \n        right = copy.deepcopy(grid)\n        down = copy.deepcopy(grid)\n        for r in reversed(range(ROWS)):\n            for c in reversed(range(COLS-1)):\n                if right[r][c]:\n                    right[r][c] += right[r][c+1]\n                    \n        for r in reversed(range(ROWS-1)):\n            for c in reversed(range(COLS)):\n                if down[r][c]:\n                    down[r][c] += down[r+1][c]\n        \n        # print(grid)\n        # print(down)\n        # print(right)\n        \n        RET = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                CAP = min(right[r][c], down[r][c])\n                for shift in reversed(range(RET, CAP)):\n                    if right[r+shift][c] > shift and down[r][c+shift] > shift:\n                        RET = shift+1\n                        break\n        return RET**2", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        #depth search\n        N = len(grid)\n        M = len(grid[0])\n        row = copy.deepcopy(grid)\n        col = copy.deepcopy(grid)\n        for i in range(N):\n            start = M\n            prev = 0\n            for j in range(M):\n                if not prev and grid[i][j]:\n                    start = j\n                elif prev and not grid[i][j]:\n                    row[i][start:j] = list(range(j-start,0,-1))\n                    start = M\n                prev = grid[i][j]\n            row[i][start:M] = list(range(M-start,0,-1))\n        for i in range(M):\n            start = N\n            prev = 0\n            for j in range(N):\n                if not prev and grid[j][i]:\n                    start = j\n                elif prev and not grid[j][i]:\n                    for k in range(j-start):\n                        col[start+k][i] = j-start-k\n                    start = N\n                prev = grid[j][i]\n            for k in range(N-start):\n                col[start+k][i] = N-start-k\n        maxS = 0\n        for i in range(N):\n            for j in range(M):\n                mS = min(row[i][j], col[i][j])\n                for k in range(mS, 0, -1):\n                    if k <= maxS:\n                        break\n                    if row[i+k-1][j] >= k and col[i][j+k-1] >= k:\n                        maxS = k\n        return maxS*maxS\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        left = [[0 for j in range(n)] for i in range(m)]\n        right = [[0 for j in range(n)] for i in range(m)]\n        top = [[0 for j in range(n)] for i in range(m)]\n        bottom = [[0 for j in range(n)] for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    if i:\n                        top[i][j] = top[i - 1][j] + 1\n                    else:\n                        top[i][j] = 1\n                    if j:\n                        left[i][j] = left[i][j - 1] + 1\n                    else:\n                        left[i][j] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j]:\n                    if i == m - 1:\n                        bottom[i][j] = 1\n                    else:\n                        bottom[i][j] = bottom[i + 1][j] + 1\n                    if j == n - 1:\n                        right[i][j] = 1\n                    else:\n                        right[i][j] = right[i][j + 1] + 1\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    res = max(res, 1)\n                    side = min(left[i][j], top[i][j])\n                    for k in range(side, 0, -1):\n                        x, y = i - k + 1, j - k + 1\n                        if right[x][y] >= k and bottom[x][y] >= k:\n                            res = max(res, k ** 2)\n                            break\n        return res", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        n = len(grid)\n        m = len(grid[0])\n        \n        up = [[0] * m for _ in range(n)]\n        left = [[0] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    up[i][j] = 1 + up[i-1][j] if i > 0 else 1\n                    left[i][j] = 1 + left[i][j-1] if j > 0 else 1\n        \n        max_len = 0\n        for i in range(n-1, -1, -1):\n            for j in range(m-1, -1, -1):\n                if grid[i][j] == 1:\n                    length = min(up[i][j], left[i][j])\n                    for k in range(length-1, -1, -1):\n                        if up[i][j-k] >= k+1 and left[i-k][j] >= k+1:\n                            max_len = max(max_len, k+1)\n        return max_len * max_len", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        x = min(m, n)\n        \n        right = [[0 for i in range(n)] for j in range(m)]\n        down = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if grid[i][j] == 0:\n                    continue\n                \n                right[i][j] = 1 + (right[i][j+1] if j+1 < n else 0)\n                down[i][j] = 1 + (down[i+1][j] if i+1 < m else 0)\n                \n        for l in range(x, 0, -1):\n            for i in range(0, m-l+1):\n                for j in range(0, n-l+1):\n                    if right[i][j] >= l and down[i][j] >= l and right[i+l-1][j] >= l and down[i][j+l-1] >= l:\n                        return l * l\n        return 0", "class Solution:\n    def getLeftandTopOnes(self, grid: List[List[int]]):\n        leftGrid = [[0] * len(grid[0]) for i in range(len(grid))]\n        topGrid = [[0] * len(grid[0]) for i in range(len(grid))]\n                \n        i = 0\n        while (i < len(grid)):\n            j = 0\n            while (j < len(grid[0])):\n                if (i > 0):\n                    if (grid[i-1][j] == 1):\n                        topGrid[i][j] = topGrid[i-1][j] + 1\n                    elif (grid[i-1][j] == 0):\n                        topGrid[i][j] = 0\n                if (j > 0):\n                    if (grid[i][j-1] == 1):\n                        leftGrid[i][j] = leftGrid[i][j-1] + 1\n                    elif (grid[i][j-1] == 0):\n                        leftGrid[i][j] = 0\n                j += 1\n            i += 1\n        return (leftGrid, topGrid)\n\n    \n    def getRightandDownOnes(self, grid: List[List[int]]):\n        rightGrid = [[0] * len(grid[0]) for i in range(len(grid))]\n        downGrid = [[0] * len(grid[0]) for i in range(len(grid))]\n        \n        i = len(grid) - 1\n        while (i >= 0):\n            j = len(grid[0]) - 1\n            while (j >= 0):\n                if (i < len(grid) - 1):\n                    if (grid[i+1][j] == 1):\n                        downGrid[i][j] = downGrid[i+1][j] + 1\n                    elif (grid[i+1][j] == 0):\n                        downGrid[i][j] = 0\n                if (j < len(grid[0]) - 1):\n                    if (grid[i][j+1] == 1):\n                        rightGrid[i][j] = rightGrid[i][j+1] + 1\n                    elif (grid[i][j+1] == 0):\n                        rightGrid[i][j] = 0\n                j -= 1\n            i -= 1\n        return (rightGrid, downGrid)            \n           \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        leftOnes, topOnes = self.getLeftandTopOnes(grid)\n        \n        print(leftOnes)\n        print(topOnes)\n        \n        rightOnes, downOnes = self.getRightandDownOnes(grid)\n        \n        print(rightOnes)\n        print(downOnes)\n        \n        maxBorder = 0\n        i = 0\n        seenOne = False\n        while (i < len(grid)):\n            j = 0\n            while (j < len(grid[0])):\n                if (grid[i][j] == 1):\n                    seenOne = True\n                    length = min(topOnes[i][j], leftOnes[i][j])\n                    \n                    while (length >= 0):\n                        if (i - length < 0 or j - length < 0):\n                            length -= 1\n                            continue\n                            \n                        if (length == 0):\n                            break\n                            \n                        if (topOnes[i][j-length] >= length and \n                             leftOnes[i-length][j] >= length):\n                            break\n                        length -= 1\n                    maxBorder = max(maxBorder, length)\n                j += 1\n            i += 1\n        \n        if (not seenOne):\n            return 0\n        else:\n            return (maxBorder + 1) ** 2\n", "class Solution:\n    class Tup:\n        def __init__(self, u, l):\n            self.u = u\n            self.l = l\n        def __str__(self):\n            return f\\\"({self.u}, {self.l})\\\"\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        yl = len(grid)\n        xl = len(grid[0])\n        mem = []\n        for y in range(0, yl):\n            for x in range(0, xl):\n                if x == 0:\n                    mem.append([])\n                row = mem[y]\n                if grid[y][x] == 0:\n                    row.append((0,0))\n                    continue\n                u = grid[y][x] if y == 0 else mem[y - 1][x][0] + 1\n                l = grid[y][x] if x == 0 else mem[y][x - 1][1] + 1\n                row.append((u, l))\n        ml = 0\n        print(mem)\n        for y in range(0, yl):\n            for x in range(0, xl):\n                for l in range(0, min(mem[y][x])):\n                    if mem[y - l][x][1] >= l + 1 and mem[y][x - l][0] >= l + 1:\n                        ml = max(ml, l + 1)\n        return ml * ml\n                \n        ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0]) if m > 0 else 0\n        \n        up = [[0]*n for _ in range(m)]\n        left = [[0]*n for _ in range(m)]\n        down = [[0]*n for _ in range(m)]\n        right = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    up[i][j] = 1 + (up[i-1][j] if i > 0 else 0)\n                    left[i][j] = 1 + (left[i][j-1] if j > 0 else 0)\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if grid[i][j] == 1:\n                    down[i][j] = 1 + (down[i+1][j] if i+1<m else 0)\n                    right[i][j] = 1 + (right[i][j+1] if j+1<n else 0)\n        \n        print(up)\n        print(left)\n        print(down)\n        print(right)\n        \n        ans = -1\n        for i in range(m):\n            for j in range(n):\n                min_1 = min(up[i][j], left[i][j])\n                for k in range(min_1):\n                    if min(down[i-k][j-k], right[i-k][j-k]) >= k:\n                        ans = max(ans, k)\n        \n        return (ans+1)**2\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        table = [[(0, 0) for _ in range(cols)] for _ in range(rows)]\n\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    hor = 1 if j == 0 else table[i][j-1][0] + 1\n                    ver = 1 if i == 0 else table[i-1][j][1] + 1\n\n                    table[i][j] = (hor, ver)\n\n        # for i in table:\n        #     print(i)\n\n        ans = float('-inf')\n\n        for i in reversed(range(rows)):\n            for j in reversed(range(cols)):\n                if table[i][j] != (0, 0):\n                    min_ = min(table[i][j])\n                    while min_ > ans:\n                        up = i - min_ + 1\n                        left = j - min_ + 1\n                        if table[i][left][1] >= min_ and table[up][j][0] >= min_ and min_ > ans:\n                            ans = min_\n                        min_ -= 1\n\n        return ans * ans if ans != float('-inf') else 0", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        iMax = len(grid)\n        jMax = len(grid[0])\n        \n        table = [[[0, 0] for j in range(jMax+1)] for i in range(iMax+1)]\n        \n        ans = 0\n        \n        for i in range(1, iMax+1):\n            for j in range(1, jMax+1):\n                if grid[i-1][j-1] == 1:\n                    table[i][j][0] = table[i-1][j][0]+ 1\n                    table[i][j][1] = table[i][j-1][1] + 1\n                for k in range(min(table[i][j]), 0, -1):\n                    if min(table[i-k+1][j][1], table[i][j-k+1][0]) >= k:\n                        ans = max(ans, k)\n                        break\n        return ans*ans", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        r, c = len(grid), len(grid[0])\n        dp = [[[0, 0] for i in range(c + 1)] for j in range(r + 1)]\n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] == 1:\n                    dp[i + 1][j + 1][0] = dp[i][j + 1][0] + 1 #hor\n                    dp[i + 1][j + 1][1] = dp[i + 1][j][1] + 1 #ver\n        \n        ans = 0\n        # print(dp)\n        for i in range(r - 1, -1 , -1):\n            for j in range(c - 1, -1 , -1):\n                poss_length = min(dp[i + 1][j + 1])\n                while poss_length > ans:\n                    if dp[i + 1][j - poss_length + 2][0] >= poss_length and dp[i - poss_length + 2][j + 1][1] >= poss_length:\n                        ans = poss_length\n                        \n                    poss_length -= 1\n            \n        return ans ** 2", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        max = 0\n        hor = [[0] * m for _ in range(n)]\n        ver = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    hor[i][j] = hor[i][j-1] + 1 if j > 0 else 1\n                    ver[i][j] = ver[i-1][j] + 1 if i > 0 else 1\n        \n        for i in range(n-1, -1, -1):\n            for j in range(m-1, -1, -1):\n                small = min(ver[i][j], hor[i][j])\n                while small > max:\n                    if hor[i-small+1][j] >= small and ver[i][j-small+1] >= small:\n                        max = small\n                        break\n                    small -= 1\n        return max**2\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        left_reach = [row[:] for row in grid]\n        up_reach = [row[:] for row in grid]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    if j > 0:\n                        left_reach[i][j] = left_reach[i][j - 1] + 1\n                    if i > 0:\n                        up_reach[i][j] = up_reach[i - 1][j] + 1\n        \n        for size in range(min(m, n), 0, -1):\n            for i in range(m - size + 1):\n                for j in range(n - size + 1):\n                    if left_reach[i][j + size - 1] >= size and left_reach[i + size - 1][j + size - 1] >= size \\\\\n                    and up_reach[i + size - 1][j] >= size and up_reach[i + size - 1][j + size - 1] >= size:\n                        return size * size\n        return 0\n\n\n\n#         m, n = len(grid), len(grid[0])\n#         left_reach = [[0] * n for _ in range(m)]\n#         up_reach = [[0] * n for _ in range(m)]\n#         for i in range(m):\n#             ones = 0\n#             for j, num in enumerate(grid[i]):\n#                 if num:\n#                     ones += 1\n#                 else:\n#                     ones = 0\n#                 left_reach[i][j] = ones\n#             ones = 0\n        \n#         for j in range(n):\n#             ones = 0\n#             for i in range(m):\n#                 if grid[i][j]:\n#                     ones += 1\n#                 else:\n#                     ones = 0\n#                 up_reach[i][j] = ones\n                \n#         for size in range(min(m, n), 0, -1):\n#             for i in range(m - size + 1):\n#                 for j in range(n - size + 1):\n#                     if left_reach[i][j + size - 1] >= size and left_reach[i + size - 1][j + size - 1] >= size \\\\\n#                     and up_reach[i + size - 1][j] >= size and up_reach[i + size - 1][j + size - 1] >= size:\n#                         return size * size\n#         return 0\n        \n        \n        \n#         m, n = len(grid), len(grid[0])\n#         left_reach = [[0] * n for _ in range(m)]\n#         right_reach = [[0] * n for _ in range(m)]\n#         up_reach = [[0] * n for _ in range(m)]\n#         down_reach = [[0] * n for _ in range(m)]\n#         for i in range(m):\n#             ones = 0\n#             for j, num in enumerate(grid[i]):\n#                 if num:\n#                     ones += 1\n#                 else:\n#                     ones = 0\n#                 left_reach[i][j] = ones\n#             ones = 0\n#             for j in range(n - 1, -1, -1):\n#                 if grid[i][j]:\n#                     ones += 1\n#                 else:\n#                     ones = 0\n#                 right_reach[i][j] = ones\n        \n#         for j in range(n):\n#             ones = 0\n#             for i in range(m):\n#                 if grid[i][j]:\n#                     ones += 1\n#                 else:\n#                     ones = 0\n#                 up_reach[i][j] = ones\n#             ones = 0\n#             for i in range(m - 1, -1, -1):\n#                 if grid[i][j]:\n#                     ones += 1\n#                 else:\n#                     ones = 0\n#                 down_reach[i][j] = ones\n                \n#         for size in range(min(m, n), 0, -1):\n#             for i in range(m - size + 1):\n#                 for j in range(n - size + 1):\n#                     if right_reach[i][j] >= size and down_reach[i][j] >= size and left_reach[i + size - 1][j + size - 1] >= size and up_reach[i + size - 1][j + size - 1] >= size:\n#                         return size * size\n#         return 0\n                       ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        entries = []\n        res = 0\n        for r, row in enumerate(grid):\n            for c, item in enumerate(row):\n                if item == 0: continue\n                if c == 0: res = 1\n                else:\n                    grid[r][c] += grid[r][c-1]\n                    entries.append((r, c))\n        rows = len(grid)\n        for r, c in entries:\n            for length in range(grid[r][c], 0, -1):\n                if r + length - 1 >= rows\\\\\n                    or grid[r+length-1][c] < length\\\\\n                    or c - length + 1 < 0\\\\\n                    or any(grid[i][c] < 1 or grid[i][c-length+1] < 1\\\\\n                        for i in range(r + 1, r + length - 1)): continue\n                res = max(res, length * length)\n                break\n        return res", "import itertools as it\n\n\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        nrows = len(grid)\n        ncols = len(grid[0])\n        cum_rows = [\n            list(it.accumulate(grid[row], initial=0))\n            for row in range(nrows)\n        ]\n        cum_cols = [\n            list(it.accumulate((grid[row][col] for row in range(nrows)), initial=0))\n            for col in range(ncols)\n        ]\n        ans = 0\n        for row1, col1 in it.product(range(nrows), range(ncols)):\n            if grid[row1][col1] == 0:\n                continue\n            side = 0\n            while row1 + side < nrows and col1 + side < ncols and grid[row1 + side][col1] == 1 and grid[row1][col1 + side] == 1:\n                row2 = row1 + side\n                col2 = col1 + side\n                if (\n                    cum_cols[col2][row2 + 1] - cum_cols[col2][row1] == side + 1\n                    and cum_rows[row2][col2 + 1] - cum_rows[row2][col1] == side + 1\n                ):\n                    ans = max(ans, (side + 1) ** 2)\n                side += 1\n        return ans", "import itertools as it\n\n\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        nrows = len(grid)\n        ncols = len(grid[0])\n        cum_rows = [\n            list(it.accumulate(grid[row], initial=0))\n            for row in range(nrows)\n        ]\n        cum_cols = [\n            list(it.accumulate((grid[row][col] for row in range(nrows)), initial=0))\n            for col in range(ncols)\n        ]\n        ans = 0\n        for row1, col1 in it.product(range(nrows), range(ncols)):\n            side = 0\n            while row1 + side < nrows and col1 + side < ncols and grid[row1 + side][col1] == 1 and grid[row1][col1 + side] == 1:\n                row2 = row1 + side\n                col2 = col1 + side\n                if (\n                    cum_cols[col2][row2 + 1] - cum_cols[col2][row1] == side + 1\n                    and cum_rows[row2][col2 + 1] - cum_rows[row2][col1] == side + 1\n                ):\n                    ans = max(ans, (side + 1) ** 2)\n                side += 1\n        return ans", "class Solution:\n        \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        if n == 0: return 0\n        m = len(grid[0])\n        \n        top = Solution.fill_top(grid, n, m)\n        left = Solution.fill_left(grid, n, m)\n        bottom = Solution.fill_bottom(grid, n, m)\n        right = Solution.fill_right(grid, n, m)\n        \n        def top_left(i, j):\n            return min(top[i][j], left[i][j])\n        \n        def bottom_right(i, j):\n            return min(bottom[i][j], right[i][j])\n        \n        square = 0\n        \n        for i in range(n):\n            for j in range(m):\n                sliding = top_left(i, j)\n                \n                for s in range(sliding-1, -1, -1):\n                    k = i - s\n                    l = j - s\n                    if bottom_right(k, l) >= (s + 1):\n                        square = max(square, s + 1)\n                        \n        return square ** 2\n                        \n        \n    @staticmethod\n    def empty(n, m):\n        return [[0] * m for _ in range(n)]\n    \n    @staticmethod\n    def fill_top(grid, n, m):\n        top = Solution.empty(n, m)\n        \n        for i in range(n):\n            if i == 0:\n                for j in range(m):\n                    top[0][j] = grid[0][j]\n            else:\n                for j in range(m):\n                    top[i][j] = top[i-1][j] + 1 if grid[i][j] == 1 else 0\n        return top\n    \n    @staticmethod\n    def fill_left(grid, n, m):\n        left = Solution.empty(n, m)\n        \n        for j in range(m):\n            if j == 0:\n                for i in range(n):\n                    left[i][0] = grid[i][0]\n            else:\n                for i in range(n):\n                    left[i][j] = left[i][j - 1] + 1 if grid[i][j] == 1 else 0\n        return left\n        \n    @staticmethod    \n    def fill_bottom(grid, n, m):\n        bottom = Solution.empty(n, m)\n        \n        for i in range(n-1, -1, -1):\n            if i == n - 1:\n                for j in range(m):\n                    bottom[n-1][j] = grid[n-1][j]\n            else:\n                for j in range(m):\n                    bottom[i][j] = bottom[i + 1][j] + 1 if grid[i][j] == 1 else 0\n        return bottom\n    \n    @staticmethod\n    def fill_right(grid, n, m):\n        right = Solution.empty(n, m)\n            \n        for j in range(m-1, -1, -1):\n            if j == m-1:\n                for i in range(n):\n                    right[i][m-1] = grid[i][m-1]\n            else:\n                for i in range(n):\n                    right[i][j] = right[i][j + 1] + 1 if grid[i][j] == 1 else 0\n        return right\n                        \n    \n        \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        m, n = len(grid), len(grid[0])\n        \n        LU = [[(0,0)]*(n+1) for _ in range(m+1)]\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] > 0:\n                    LU[r+1][c+1] = (1 + LU[r+1][c][0], 1 + LU[r][c+1][1])\n        \n        area = 0\n        for r in range(m):\n            for c in range(n):\n                x, y = LU[r+1][c+1]\n                for i in range(min(x,y)-1,-1,-1):\n                    if min(LU[r+1-i][c+1][0], LU[r+1][c+1-i][1]) >= i+1:\n                        area = max(area, (i+1)**2)\n        \n        return area\n                    \n        \n", "class Solution:\n    \n    def checkForSquare(self, grid: List[List[int]], i: int, j: int, squareLen: int) -> bool:\n        maxRowBound = i + squareLen - 1\n        maxColBound = j + squareLen - 1\n        #print(\\\"Checking for square at \\\" + str(maxRowBound) + \\\",\\\" + str(maxColBound))\n        #print(\\\"Square_len: \\\" + str(squareLen))\n        if (self.accessGrid(grid, maxRowBound, maxColBound) == 1):\n            # check bottom line\n            k = maxColBound\n            while (k != j and self.accessGrid(grid, maxRowBound, k) == 1):\n                k -= 1    \n            if (k != j):\n                return False\n            \n            # check rightmost line\n            s = maxRowBound\n            while (s != i and self.accessGrid(grid, s, maxColBound) == 1):\n                s -= 1    \n            if (s == i):\n                #print(\\\"Found square at \\\" + str(maxRowBound) + \\\",\\\" + str(maxColBound))\n                #print(\\\"Square_len: \\\" + str(squareLen))\n                return True\n            \n        return False\n    \n    def accessGrid(self, grid: List[List[int]], i: int, j: int) -> int:\n        if (i < self.rows and j < self.cols):\n            return grid[i][j]\n        else:\n            return -1\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        self.rows = len(grid)\n        self.cols = len(grid[0])\n        \n        # brute-force\n        \n        i = 0\n        j = 0\n        largest_square = 0\n        \n        #print(\\\"Rows: \\\" + str(self.rows))\n        #print(\\\"Cols: \\\" + str(self.cols))\n        \n        while (i < self.rows):\n            while (j < self.cols):\n                #print(\\\"Checking \\\" + str(i) + \\\",\\\" + str(j))\n                search_increment = 1\n                if (grid[i][j] == 1):\n                    if (largest_square == 0):\n                        largest_square = 1\n                    if (j != self.cols - 1):\n                        #print(\\\"Searching for square at \\\" + str(i) + \\\",\\\" + str(j))\n                        # Find possible bounds of the square\n                        max_col_bound = j\n                        max_row_bound = i\n                        while (self.accessGrid(grid, i, max_col_bound) == 1):\n                            max_col_bound += 1\n                        square_len = max_col_bound - j\n\n                        if (square_len > 0):\n                            while (self.accessGrid(grid, max_row_bound, j) == 1):\n                                max_row_bound += 1\n\n                        square_len = min(square_len, max_row_bound - i)\n                        while (square_len ** 2 > largest_square):\n                            if (self.checkForSquare(grid, i, j, square_len)):\n                                largest_square = square_len ** 2\n                                search_increment = square_len - 1\n                            else:\n                                square_len -= 1\n                j += search_increment\n\n                # If the largest square is bigger than the rest of the column\n                # search space, we can move to the next row\n                remaining_search_space = (self.cols - j) ** 2\n                if (largest_square >= remaining_search_space):\n                    break\n            i += 1\n            j = 0\n            # If the largest square is bigger than the rest of the\n            # search space, we can return\n            remaining_search_space = (self.rows - i) ** 2\n            if (largest_square >= remaining_search_space):\n                return largest_square\n        \n        return largest_square\n                        \n                        \n                        \n               \n                \n        \n        \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        horizon = [[0]*len(grid[0]) for _ in range(len(grid))]\n        vertical = [[0]*len(grid[0]) for _ in range(len(grid))]\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    horizon[i][j] = horizon[i][j-1] + 1\n\n        for i in range(len(grid[0])):\n            for j in range(len(grid)):\n                if grid[j][i] == 1:\n                    vertical[j][i] = vertical[j-1][i] + 1\n                    \n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                \n                s = min(horizon[i][j], vertical[i][j])\n                for k in range(s, 0, -1):\n                    if horizon[i-k+1][j] >= k and vertical[i][j-k+1] >= k:\n                        res = max(res, k)\n                        break\n                        \n                \n        return res*res\n                \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        dp = [[None] * cols for _ in range(rows)]\n        maxSize = 0\n        for i in range(rows):\n            for j in range(cols):\n                x, y = 0, 0\n                if grid[i][j] == 1:\n                    if i > 0 and dp[i-1][j]:\n                        x = dp[i-1][j][0] + 1\n                    if j > 0 and dp[i][j-1]:\n                        y = dp[i][j-1][1] + 1\n                    dp[i][j] = (x,y)\n                    sqlen = min(x,y)\n                    while sqlen >= maxSize:\n                        left = dp[i][j-sqlen]\n                        up = dp[i-sqlen][j]\n                        if left[0] >= sqlen and up[1] >= sqlen:\n                            maxSize = sqlen + 1\n                        sqlen -= 1\n        return maxSize * maxSize\n                    \n                    \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        dp = [[None] * len(grid[0]) for _ in range(len(grid))]\n        dp[0][0] = (1,1) if grid[0][0] == 1 else (0,0)\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                \n                if r == 0 and c == 0: continue\n                #handle first row\n                elif r == 0:\n                    if grid[0][c] == 1:\n                        newR = 1\n                        newC = 1 + dp[0][c-1][1]\n                        dp[r][c] = (newR,newC)\n                    else:\n                        dp[r][c] = (0,0)\n                \n                elif c == 0:\n                    if grid[r][0] == 1:\n                        newR = 1 + dp[r-1][0][0]\n                        newC = 1\n                        dp[r][c] = (newR,newC)\n                    else:\n                        dp[r][c] = (0,0)\n                else:\n                    if grid[r][c] == 1:\n                        newR = 1 + dp[r-1][c][0]\n                        newC = 1+ dp[r][c-1][1]\n                        dp[r][c] = (newR,newC)\n                    else:\n                        dp[r][c] = (0,0)\n        \n        # print(dp)\n        maxGrid = 0\n        # now lets iterate from bottom right to upper left\n        for r in range(len(grid)-1,-1,-1):\n            for c in range(len(grid[0])-1,-1,-1):\n                \n                minSpan = min(dp[r][c][0],dp[r][c][1])\n                if minSpan == 0: continue\n                # print('r',r,'c',c,'minSpan',minSpan)\n                # we need to loop through min span\n                for span in range(minSpan,-1,-1):\n                    #check left dp span and see if its row == minSpan\n                    cSpanLeft = c-span+1\n                    rSpanUp = r-span+1\n                    # print(r,c,cSpanLeft,rSpanUp)\n                    # print('dp[r][cSpanLeft][0]',dp[r][cSpanLeft][0],'dp[rSpanUp][c][1]',dp[rSpanUp][c][1] )\n                    if dp[r][cSpanLeft][0] >= span and dp[rSpanUp][c][1] >= span:\n                        # print('maxis', minSpan)\n                        maxGrid = max(maxGrid,span**2)\n                        break\n        \n        return maxGrid\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        horizon = [row[:] for row in grid]\n        for i in range(m):\n            for j in range(1,n):\n                if horizon[i][j] != 0:\n                    horizon[i][j] = horizon[i][j-1] + 1\n        vertical = [row[:] for row in grid]\n        for i in range(n):\n            for j in range(1,m):\n                if vertical[j][i] != 0:\n                    vertical[j][i] = vertical[j-1][i] + 1\n            \n        result = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    side = min(horizon[i][j], vertical[i][j])\n                    eval = 0\n                    for dis in range(side,0,-1):\n                        if horizon[i-dis+1][j] >= dis and vertical[i][j-dis+1] >= dis:\n                            eval = dis * dis\n                            break\n                    if eval > result:\n                        result = eval\n        return result\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        ylen, xlen = len(grid), len(grid[0])\n        rights = [[0 for i in range(xlen)] for j in range(ylen)]\n        downs = [[0 for i in range(xlen)] for j in range(ylen)]\n        for y in range(ylen-1, -1, -1):\n            for x in range(xlen-1, -1, -1):\n                if y < ylen-1 and grid[y+1][x] == 1:\n                    downs[y][x] = downs[y+1][x] + 1\n                if x < xlen-1 and grid[y][x+1] == 1:\n                    rights[y][x] = rights[y][x+1] + 1\n        ans = 0\n        for y,row in enumerate(grid):\n            for x,val in enumerate(row):\n                if val == 1:\n                    ans = max(ans, 1)\n                    offset = 1\n                    while y+offset < ylen and x+offset < xlen:\n                        cury, curx = y + offset, x + offset\n                        if grid[cury][x] == 1 and grid[y][curx] == 1:\n                            if rights[cury][x] >= offset and downs[y][curx] >= offset:\n                                ans = max(ans, 1+offset)\n                        else:\n                            break\n                        offset += 1\n        return ans**2", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        result = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    continue\n                l = (grid[i][j - 1] & 0xff if j else 0) + 1\n                u = ((grid[i - 1][j] >> 8) & 0xff if i else 0) + 1\n                grid[i][j] = u << 8 | l\n                s = 1\n                for k in reversed(list(range(min(l, u)))):\n                    if (grid[i][j - k] >> 8) > k and (grid[i - k][j] & 0xff) > k:\n                        s = k + 1\n                        break\n                result = max(result, s * s)\n        return result\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        left = []\n        right = []\n        up = []\n        down = []\n        for i in range(len(grid)):\n            left.append([0] * len(grid[0]))\n            right.append([0] * len(grid[0]))\n            up.append([0] * len(grid[0]))\n            down.append([0] * len(grid[0]))\n        for i in range(len(grid)):\n            left[i][0] = grid[i][0]\n            right[i][-1] = grid[i][-1]\n            for j in range(1, len(grid[0])):\n                if grid[i][j] == 1:\n                    left[i][j] = left[i][j-1] + 1\n                if grid[i][len(grid[0]) - j - 1] == 1:\n                    right[i][len(grid[0]) - j - 1] = right[i][len(grid[0]) - j] + 1\n        for j in range(len(grid[0])):\n            up[0][j] = grid[0][j]\n            down[-1][j] = grid[-1][j]\n            for i in range(1, len(grid)):\n                if grid[i][j] == 1:\n                    up[i][j] = up[i-1][j] + 1\n                if grid[len(grid) - 1 - i][j] == 1:\n                    down[len(grid) - 1 - i][j] = down[len(grid) - i][j] + 1\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                left[i][j] = min(left[i][j], up[i][j])\n                right[i][j] = min(right[i][j], down[i][j])\n        maxium = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if right[i][j] != 0:\n                    k = 1\n                    while k <= right[i][j] and i + k - 1 < len(grid) and j + k - 1 < len(grid[0]):\n                        if left[i+k-1][j+k-1] >= k:\n                            maxium = max(maxium, k)\n                        k += 1\n        return maxium ** 2", "class Solution:\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0:\n                    return 1\n            \n            for ind in range(k+1):\n                if grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return 2\n                \n            return 0\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n        min_ = 0\n\n        for i in range(n):\n            \n            if max_ > (n-i-1)**2:\n                break\n            for j in range(m):\n                \n                if grid[i][j] == 1:\n                    bound = min(n-i, m-j)\n                \n                    if max_ > (bound-1)**2:\n                        break\n                    else:\n                        min_=1\n                        for k in range(1, bound):\n                            result = checkSquare(i,j, k)\n                            if result == 0:\n                                max_ = max(max_, (k+1)**2)\n                            elif result == 1:\n                                break\n                              \n        return max(max_, min_)\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        rows, cols = len(grid), len(grid[0])\n        ans = 0\n        \n        for row in range(rows):\n            for col in range(cols):\n                ans = max(ans, self.dfs(grid,row,col))\n        \n        return ans\n        \n    def dfs(self, grid, i, j):\n        rows, cols = len(grid), len(grid[0])\n        # make sure the curr element is a 1\n        \n        if not grid[i][j]:\n            return 0\n        \n        last = 0\n        for offset in (range(min(rows-i,cols-j))):\n            # make sure no 0s\n            if not grid[i][j+offset] or not grid[i+offset][j]:\n                return (last+1)*(last+1)\n            \n            if self.isValid(grid, [i,j+offset], [i+offset,j]):\n                last = offset\n            \n        return (last+1)*(last+1)\n    \n    def isValid(self, grid, right, down):\n        while True:\n            if not grid[right[0]][right[1]] or not grid[down[0]][down[1]]:\n                return False\n            if right == down:\n                return True\n            right[0] += 1\n            down[1] += 1\n            \n\\\"\\\"\\\"\n[[1,1,1],[1,1,0],[1,1,1],[0,1,1],[1,1,1]]\n        1       1       1\n        1       1       0\n        1       1       1\n        0       1       1\n        1       1       1\n\\\"\\\"\\\"\n        ", "class Solution:\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0:\n                    return 1\n            \n            for ind in range(k+1):\n                if grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return 2\n                \n            return 0\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n        min_ = 0\n\n        for i in range(n):\n            \n            if max_ > (n-i-1)**2:\n                break\n                \n            for j in range(m):\n                \n                if grid[i][j] == 1:\n                    bound = min(n-i, m-j)\n                \n                    if max_ > (bound-1)**2:\n                        break\n                    else:\n                        min_=1\n                        for k in range(1, bound):\n                            result = checkSquare(i,j, k)\n                            if result == 0:\n                                max_ = max(max_, (k+1)**2)\n                            elif result == 1:\n                                break\n                              \n        return max(max_, min_)\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        dp1=[[0]*len(grid[0]) for i in range(len(grid))]\n        dp2=[[0]*len(grid[0]) for i in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]==0:\n                    continue\n                dp1[i][j]=(dp1[i-1][j] if i-1>=0 else 0)+1\n                dp2[i][j]=(dp2[i][j-1] if j-1>=0 else 0)+1\n        ret=0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]==0:\n                    continue\n                for k in range(min(dp1[i][j],dp2[i][j]),0,-1):\n                    if k<=min(dp2[i-k+1][j],dp1[i][j-k+1]):\n                        ret=max(ret,k**2)\n                        break\n        return ret\n                    \n", "class Solution:\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0:\n                    return 1\n            \n            for ind in range(k+1):\n                if grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return 2\n                \n            return 0\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n        min_ = 0\n\n        for i in range(n):\n            for j in range(m):\n                \n                if grid[i][j] == 1:\n                    bound = min(n-i, m-j)\n                \n                    if max_ > (bound-1)**2:\n                        continue\n                        \n                    else:\n                        min_=1\n\n                        for k in range(1, bound):\n                            result = checkSquare(i,j, k)\n                            if result == 0:\n                                max_ = max(max_, (k+1)**2)\n                            elif result == 1:\n                                break\n                              \n        return max(max_, min_)\n", "class Solution:\n    def largest1BorderedSquare(self, A: List[List[int]]) -> int:\n        n, m = len(A), len(A[0])\n        V, H = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]\n        for col in range(m):\n            for row in range(n):\n                if row == 0:\n                    V[row][col] = A[row][col]\n                else:\n                    V[row][col] = 0 if A[row][col] == 0 else V[row - 1][col] + 1\n        \n        for row in range(n):\n            for col in range(m):\n                if col == 0:\n                    H[row][col] = A[row][col]\n                else:\n                    H[row][col] = 0 if A[row][col] == 0 else H[row][col - 1] + 1\n        \n        res = 0\n        for row in range(n):\n            for col in range(m):\n                small = min(H[row][col], V[row][col])\n                while small > res:\n                    if V[row][col - small + 1] >= small and H[row - small + 1][col] >= small:\n                        res = small\n                        break\n                    small -= 1\n        \n        return res * res\n", "class Solution:\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0:\n                    return 1\n            \n            for ind in range(k+1):\n                if grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return 2\n                \n            return 0\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n        min_ = 0\n\n        for i in range(n):\n            for j in range(m):\n                bound = min(n-i, m-j)\n                \n                if max_ > (bound-1)**2:\n                    continue\n                \n                elif grid[i][j] == 1:\n                    min_=1\n\n                    for k in range(1, bound):\n                        result = checkSquare(i,j, k)\n                        if result == 0:\n                            max_ = max(max_, (k+1)**2)\n                        elif result == 1:\n                            break\n                              \n        return max(max_, min_)\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        nrow, ncol = len(grid), len(grid[0])\n        up, left = [], []\n        for _ in range(nrow):\n            up.append([0] * ncol)\n            left.append([0] * ncol)\n        for r in range(nrow):\n            for c in range(ncol):\n                if grid[r][c] == 1:\n                    if c - 1 >= 0:\n                        left[r][c] = left[r][c-1] + 1\n                    else:\n                        left[r][c] = 1\n        for c in range(ncol):\n            for r in range(nrow):\n                if grid[r][c] == 1:\n                    if r - 1 >= 0:\n                        up[r][c] = up[r-1][c] + 1\n                    else:\n                        up[r][c] = 1\n        # print(left, up)\n        \n        ret = 0\n        for r in range(nrow):\n            for c in range(ncol):\n                if grid[r][c] == 0: continue\n                for dist in range(0, min(r, c)+1):\n                    \n                    r2, c2 = r - dist, c - dist\n                    # print(r, c, dist, r2, c2)\n                    if grid[r2][c] == 0 or grid[r][c2] == 0:\n                        break\n                    if left[r2][c] >= dist + 1 and up[r][c2] >= dist + 1:\n                        ret = max(ret, dist+1)\n                        \n        return ret ** 2\n                \n                    \n                    \n                \n                \n        \n        \n        \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        down =  [[0 for i in range(len(grid[0]))] for j in range(len(grid))]\n        up = [[0 for i in range(len(grid[0]))] for j in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0:\n                    down[i][j] = grid[i][j]\n                else:\n                    if grid[i][j] == 0:\n                        continue\n                    down[i][j] = down[i-1][j] + grid[i][j]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if j == 0:\n                    up[i][j] = grid[i][j]\n                else:\n                    if grid[i][j] == 0:\n                        continue\n                    up[i][j] = up[i][j-1] + grid[i][j]\n        \n        ans = 0\n        mx = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                toSubtract = min(down[i][j], up[i][j])\n                while(toSubtract > mx):\n                    nj = j - toSubtract + 1\n                    ni = i - toSubtract + 1\n                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and down[i][nj] >= toSubtract and up[ni][j] >= toSubtract:\n                        ans = max(ans, toSubtract)\n                    toSubtract -= 1\n        \n        return ans*ans", "class Solution:\n    \n    def checkForSquare(self, grid: List[List[int]], i: int, j: int, squareLen: int) -> bool:\n        maxRowBound = i + squareLen - 1\n        maxColBound = j + squareLen - 1\n        print(\\\"Checking for square at \\\" + str(maxRowBound) + \\\",\\\" + str(maxColBound))\n        print(\\\"Square_len: \\\" + str(squareLen))\n        if (self.accessGrid(grid, maxRowBound, maxColBound) == 1):\n            # check bottom line\n            k = maxColBound\n            while (k != j and self.accessGrid(grid, maxRowBound, k) == 1):\n                k -= 1    \n            if (k != j):\n                return False\n            \n            # check rightmost line\n            s = maxRowBound\n            while (s != i and self.accessGrid(grid, s, maxColBound) == 1):\n                s -= 1    \n            if (s == i):\n                print(\\\"Found square at \\\" + str(maxRowBound) + \\\",\\\" + str(maxColBound))\n                print(\\\"Square_len: \\\" + str(squareLen))\n                return True\n            \n        return False\n    \n    def accessGrid(self, grid: List[List[int]], i: int, j: int) -> int:\n        if (i < self.rows and j < self.cols):\n            return grid[i][j]\n        else:\n            return -1\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        self.rows = len(grid)\n        self.cols = len(grid[0])\n        \n        # brute-force\n        \n        i = 0\n        j = 0\n        largest_square = 0\n        \n        #print(\\\"Rows: \\\" + str(self.rows))\n        #print(\\\"Cols: \\\" + str(self.cols))\n        \n        while (i < self.rows):\n            while (j < self.cols):\n                #print(\\\"Checking \\\" + str(i) + \\\",\\\" + str(j))\n                search_increment = 1\n                if (grid[i][j] == 1):\n                    if (largest_square == 0):\n                        largest_square = 1\n                    if (j != self.cols - 1):\n                        #print(\\\"Searching for square at \\\" + str(i) + \\\",\\\" + str(j))\n                        # Find possible bounds of the square\n                        max_col_bound = j\n                        max_row_bound = i\n                        while (self.accessGrid(grid, i, max_col_bound) == 1):\n                            max_col_bound += 1\n                        square_len = max_col_bound - j\n\n                        if (square_len > 0):\n                            while (self.accessGrid(grid, max_row_bound, j) == 1):\n                                max_row_bound += 1\n\n                        square_len = min(square_len, max_row_bound - i)\n                        while (square_len ** 2 > largest_square):\n                            if (self.checkForSquare(grid, i, j, square_len)):\n                                largest_square = square_len ** 2\n                                search_increment = square_len - 1\n                            else:\n                                square_len -= 1\n                # If the largest square is bigger than the rest of the search\n                # space, we can return\n                remaining_search_space = max((self.rows - i) ** 2, (self.cols - search_increment) ** 2)\n                if (largest_square >= remaining_search_space):\n                    return largest_square\n                j += search_increment\n            i += 1\n            j = 0\n        \n        return largest_square\n                        \n                        \n                        \n               \n                \n        \n        \n        ", "class Solution:\n    \n    def checkForSquare(self, grid: List[List[int]], i: int, j: int, squareLen: int) -> bool:\n        maxRowBound = i + squareLen - 1\n        maxColBound = j + squareLen - 1\n        #print(\\\"Checking for square at \\\" + str(maxRowBound) + \\\",\\\" + str(maxColBound))\n        #print(\\\"Square_len: \\\" + str(squareLen))\n        if (self.accessGrid(grid, maxRowBound, maxColBound) == 1):\n            # check bottom line\n            k = maxColBound\n            while (k != j and self.accessGrid(grid, maxRowBound, k) == 1):\n                k -= 1    \n            if (k != j):\n                return False\n            \n            # check rightmost line\n            s = maxRowBound\n            while (s != i and self.accessGrid(grid, s, maxColBound) == 1):\n                s -= 1    \n            if (s == i):\n                #print(\\\"Found square at \\\" + str(maxRowBound) + \\\",\\\" + str(maxColBound))\n                #print(\\\"Square_len: \\\" + str(squareLen))\n                return True\n            \n        return False\n    \n    def accessGrid(self, grid: List[List[int]], i: int, j: int) -> int:\n        if (i < self.rows and j < self.cols):\n            return grid[i][j]\n        else:\n            return -1\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        self.rows = len(grid)\n        self.cols = len(grid[0])\n        \n        # brute-force\n        \n        i = 0\n        j = 0\n        largest_square = 0\n        \n        #print(\\\"Rows: \\\" + str(self.rows))\n        #print(\\\"Cols: \\\" + str(self.cols))\n        \n        while (i < self.rows):\n            while (j < self.cols):\n                #print(\\\"Checking \\\" + str(i) + \\\",\\\" + str(j))\n                search_increment = 1\n                if (grid[i][j] == 1):\n                    if (largest_square == 0):\n                        largest_square = 1\n                    if (j != self.cols - 1):\n                        #print(\\\"Searching for square at \\\" + str(i) + \\\",\\\" + str(j))\n                        # Find possible bounds of the square\n                        max_col_bound = j\n                        max_row_bound = i\n                        while (self.accessGrid(grid, i, max_col_bound) == 1):\n                            max_col_bound += 1\n                        square_len = max_col_bound - j\n\n                        if (square_len > 0):\n                            while (self.accessGrid(grid, max_row_bound, j) == 1):\n                                max_row_bound += 1\n\n                        square_len = min(square_len, max_row_bound - i)\n                        while (square_len ** 2 > largest_square):\n                            if (self.checkForSquare(grid, i, j, square_len)):\n                                largest_square = square_len ** 2\n                                search_increment = square_len - 1\n                            else:\n                                square_len -= 1\n                # If the largest square is bigger than the rest of the search\n                # space, we can return\n                remaining_search_space = max((self.rows - i) ** 2, (self.cols - search_increment) ** 2)\n                if (largest_square >= remaining_search_space):\n                    return largest_square\n                j += search_increment\n            i += 1\n            j = 0\n        \n        return largest_square\n                        \n                        \n                        \n               \n                \n        \n        \n", "# https://www.acwing.com/solution/LeetCode/content/3171/\n# \u627e\u51fa\u8fb9\u754c\u5168\u90e8\u7531 1 \u7ec4\u6210\u7684\u6700\u5927\u6b63\u65b9\u5f62\u5b50\u7f51\u683c\u5e76\u8fd4\u56de\u8be5\u5b50\u7f51\u683c\u4e2d\u7684\u5143\u7d20\u6570\u91cf\n# \u679a\u4e3e\u6bcf\u4e00\u4e2a\u5b50\u6b63\u65b9\u5f62, \u7b2c\u4e00\u91cd\u5faa\u73af\u679a\u4e3e\u6b63\u65b9\u5f62\u7684\u957f\u5ea6 length, \u7b2c\u4e8c\u4e09\u91cd\u5faa\u73af\u679a\u4e3e\u5de6\u4e0a\u89d2\u7684\u9876\u70b9\u7684 x \u548c y \u5750\u6807\u4f4d\u7f6e\n# \u5bf9\u4e8e\u6bcf\u4e2a\u6b63\u65b9\u5f62, \u5728\u7ebf\u6027\u65f6\u95f4\u5185\u5224\u65ad\u5b83\u662f\u5426\u5408\u6cd5\n# sum_row[i][j] \u8868\u793a\u7b2c i \u884c\u524d j \u5217\u6570\u5b57\u7684\u548c, sum_col[j][i] \u8868\u793a\u7b2c j \u5217\u524d i \u884c\u7684\u548c, \u56e0\u4e3a\u662f\u524d\u7f00\u548c, \u8fd9\u91cc\u7684 i \u548c j \u90fd\u4ece\u4e0b\u6807 1 \u5f00\u59cb\n# \u63d0\u524d\u8ba1\u7b97\u51fa prefix sum \u7528\u4e8e\u4e4b\u540e\u5728\u7ebf\u6027\u590d\u6742\u5ea6\u5185\u5224\u65ad\u6b63\u65b9\u5f62\u662f\u5426\u5408\u6cd5 (\u5224\u65ad\u56db\u6761\u8fb9\u7684\u533a\u95f4\u548c\u662f\u4e0d\u662f\u7b49\u4e8e length)\n# O(n \u2217 m \u2217 min(n, m)) time complexity, O(nm) space complexity\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        sum_row, sum_col = [[0] * (m + 1) for _ in range(n + 1)], [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(n + 1):\n            for j in range(m + 1):\n                sum_row[i][j] = sum_row[i][j - 1] + grid[i - 1][j - 1]\n        for j in range(m + 1):\n            for i in range(n + 1):\n                sum_col[j][i] = sum_col[j][i - 1] + grid[i - 1][j - 1]\n        \n        for length in range(min(n, m), 0, -1):\n            for i in range(n - length + 1):\n                for j in range(m - length + 1):\n                    x, y = i + length - 1, j + length - 1\n                    if sum_row[i + 1][y + 1] - sum_row[i + 1][j] == length \\\\\n                    and sum_row[x + 1][y + 1] - sum_row[x + 1][j] == length \\\\\n                    and sum_col[j + 1][x + 1] - sum_col[j + 1][i] == length \\\\\n                    and sum_col[y + 1][x + 1] - sum_col[y + 1][i] == length:\n                        return length * length\n        return 0\n", "class Solution:\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0:\n                    return 1\n            \n            for ind in range(k+1):\n                if grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return 2\n                \n            return 0\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n        min_ = 0\n\n        for i in range(n):\n            for j in range(m):\n                \n                if grid[i][j] == 1:\n                    min_=1\n\n                    bound = min(n-i, m-j)\n\n                    for k in range(1, bound):\n                        result = checkSquare(i,j, k)\n                        if result == 0:\n                            max_ = max(max_, (k+1)**2)\n                        elif result == 1:\n                            break\n                              \n        return max(max_, min_)\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        horizon = [[0]*len(grid[0]) for _ in range(len(grid))]\n        vertical = [[0]*len(grid[0]) for _ in range(len(grid))]\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    horizon[i][j] = horizon[i][j-1] + 1\n\n        for i in range(len(grid[0])):\n            for j in range(len(grid)):\n                if grid[j][i] == 1:\n                    vertical[j][i] = vertical[j-1][i] + 1\n                    \n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                tmp = 0\n                s = min(len(grid)-i, len(grid[0])-j)\n                while tmp < s:\n                    if horizon[i][j+s-1] >= s and horizon[i+s-1][j+s-1] >= s and vertical[i+s-1][j] >= s and vertical[i+s-1][j+s-1] >= s:\n                        tmp = s\n                    s -= 1\n                res = max(res, tmp)\n                \n        return res*res\n                \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        left_top = []\n        for r in range(len(grid)):\n            left_top.append([0]*len(grid[0])) \n        right_bottom = []\n        for r in range(len(grid)):\n            right_bottom.append([0]*len(grid[0]))\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                ans = 0\n                while r - ans >= 0 and c - ans >= 0 and grid[r-ans][c] == 1 and grid[r][c-ans] == 1:\n                    ans += 1\n                left_top[r][c] = ans\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                ans = 0\n                while r + ans < len(grid) and c + ans < len(grid[0]) and grid[r+ans][c] == 1 and grid[r][c+ans] == 1:\n                    ans += 1\n                right_bottom[r][c] = ans                     \n\n        max_len = 0        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                ans = 0\n                for i in range(left_top[r][c]):\n                    if right_bottom[r-i][c-i] > i:\n                        ans = i + 1\n                max_len = max(max_len, ans)\n        return max_len**2", "class Solution:\n\n    def correct(self, i: int, j: int, n: int, m: int) -> bool:\n        return 0 <= i < n and 0 <= j < m\n\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        lu = [[0] * m for i in range(n)]\n        rd = [[0] * m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                k = 0\n                while self.correct(i - k, j, n, m) and self.correct(i, j - k, n, m) \\\\\n                      and grid[i - k][j] == 1 and grid[i][j - k] == 1:\n                    k += 1\n                lu[i][j] = k\n        for i in range(n):\n            for j in range(m):\n                k = 0\n                while self.correct(i + k, j, n, m) and self.correct(i, j + k, n, m) \\\\\n                      and grid[i + k][j] == 1 and grid[i][j + k] == 1:\n                    k += 1\n                rd[i][j] = k\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for k in range(rd[i][j] - 1, -1, -1):\n                    if lu[i + k][j + k] > k:\n                        res = max(res, (k + 1) ** 2)\n                        break\n        return res", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        if not grid:\n            return 0\n        \n        \n        m = len(grid)\n        n = len(grid[0])\n        # brute force\n        max_len = max(m, n)\n        \n        row_count = [[grid[i][0]] for i in range(m)]\n        for i in range(m):\n            for j in range(1, n):\n                if grid[i][j]:\n                    row_count[i].append(row_count[i][j-1]+1)\n                else:\n                    row_count[i].append(0)\n        \n        col_count = [[grid[0][j] for j in range(n)]]\n        for i in range(1, m):\n            col_count.append([])\n            for j in range(n):\n                if grid[i][j]:\n                    col_count[i].append(col_count[i-1][j]+1)\n                else:\n                    col_count[i].append(0)\n        \n        for l in range(max_len, 0, -1):\n            for i in range(m-l+1):\n                for j in range(n-l+1):\n                    if self.find_board(i, j, l, row_count, col_count):\n                        return l*l\n        return 0\n        \n        \n        \n    \n    def find_board(self, i, j, l, row_count, col_count):\n        if l==1:\n            return row_count[i][j] == 1\n        \n        l = l-1\n        #check four coners\n        x, y = i+l, j+l\n        \n        if row_count[i][y] <= l:\n            return False\n        \n        if row_count[x][y] <= l:\n            return False\n        \n        if col_count[x][j] <= l:\n            return False\n        \n        if col_count[x][y] <= l:\n            return False\n            \n        \n        return True\n        \n            \n        \n", "class Solution:\n\n    def correct(self, i: int, j: int, n: int, m: int) -> bool:\n        return 0 <= i < n and 0 <= j < m\n\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        lu = [[0] * m for i in range(n)]\n        rd = [[0] * m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                k = 0\n                while self.correct(i - k, j, n, m) and self.correct(i, j - k, n, m) \\\\\n                      and grid[i - k][j] == 1 and grid[i][j - k] == 1:\n                    k += 1\n                lu[i][j] = k\n        for i in range(n):\n            for j in range(m):\n                k = 0\n                while self.correct(i + k, j, n, m) and self.correct(i, j + k, n, m) \\\\\n                      and grid[i + k][j] == 1 and grid[i][j + k] == 1:\n                    k += 1\n                rd[i][j] = k\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                for k in range(rd[i][j] - 1, -1, -1):\n                    if lu[i + k][j + k] > k:\n                        res = max(res, (k + 1) ** 2)\n        return res", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        right, below = [([0] * m) for i in range(n)], [([0] * m) for i in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    below[n-1-i][m-1-j] = grid[n-1-i][m-1-j]\n                else:\n                    below[n-1-i][m-1-j] = grid[n-1-i][m-1-j] * (1+below[n-i][m-1-j])\n                        \n                if j == 0:\n                    right[n-1-i][m-1-j] = grid[n-1-i][m-1-j]\n                else:\n                    right[n-1-i][m-1-j] = grid[n-1-i][m-1-j] * (1+right[n-1-i][m-j])\n        \n        max_s = 0\n        \n        for i in range(n):\n            for j in range(n-i):\n                for k in range(m-j):\n                    if (below[i][k] >= j+1) & (right[i][k] >= j+1):\n                        if (below[i][k+j] >= j+1) & (right[i+j][k] >= j+1):\n                            if j+1 > max_s:\n                                max_s = j+1\n        \n        return max_s ** 2", "import copy\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    # step1, O(N^2), dp, count the consecutive 1s start at (i, j) to top, left, down, right, (t, l, d, r)\n    # step2, O(N^3), straightforward, at (i, j), take (i + k, j + k), for k in range(1, min(d,r)-at-(i,j)), \n    #  see if min(t,l)-at-(i+k, j+k) >= k for k-square, often, k is limited and early break, so the overall\n    #  performance is expected to be close to O(N^2) instead of O(N^3).\n    m, n = len(grid), len(grid[0])\n    # tldr: 4 x m x n\n    tldr = [copy.deepcopy(grid) for _ in range(4)]\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          if i:\n            tldr[0][i][j] = tldr[0][i - 1][j] + 1\n          if j:\n            tldr[1][i][j] = tldr[1][i][j - 1] + 1\n    for j in range(n - 1, -1, -1):\n      for i in range(m - 1, -1, -1):\n        if grid[i][j]:\n          if i + 1 < m:\n            tldr[2][i][j] = tldr[2][i + 1][j] + 1\n          if j + 1 < n:\n            tldr[3][i][j] = tldr[3][i][j + 1] + 1\n    # diagonal only\n    mk = 0\n    for i in range(m):\n      for j in range(n):\n        k0 = 0 if i == 0 or j == 0 else min(tldr[2][i - 1][j - 1], tldr[3][i - 1][j - 1])\n        for k in range(min(tldr[2][i][j], tldr[3][i][j]) - 1, k0 - 1, -1):\n          if min(tldr[0][i + k][j + k], tldr[1][i + k][j + k]) >= k:\n            mk = max(mk, k + 1)\n            break\n    return mk * mk", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n\n        def expand_square(r, c):\n            left, top = [r, c], [r, c]\n            side = 0\n            area = 0\n            while left[0] < n and top[1] < m and grid[left[0]][left[1]] == 1 and grid[top[0]][top[1]] == 1:\n                valid = True\n                for row in range(top[0], left[0] + 1):\n                    if grid[row][top[1]] == 0:\n                        valid = False\n                        break\n                for col in range(left[1], top[1] + 1):\n                    if grid[left[0]][col] == 0:\n                        valid = False\n                        break\n                if valid:\n                    area = (side + 1) ** 2\n                top[1] += 1\n                left[0] += 1\n                side += 1\n\n            return area\n\n        max_area = 0\n        for r in range(n):\n            for c in range(m):\n                max_area = max(max_area, expand_square(r, c))\n        return max_area\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        horizon = [[0]*len(grid[0]) for _ in range(len(grid))]\n        vertical = [[0]*len(grid[0]) for _ in range(len(grid))]\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    horizon[i][j] = horizon[i][j-1] + 1\n\n        for i in range(len(grid[0])):\n            for j in range(len(grid)):\n                if grid[j][i] == 1:\n                    vertical[j][i] = vertical[j-1][i] + 1\n                    \n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                s = min(len(grid)-i, len(grid[0])-j)\n                for k in range(s):\n                    if horizon[i][j+k] >= k+1 and horizon[i+k][j+k] >= k+1 and vertical[i+k][j] >= k+1 and vertical[i+k][j+k] >= k+1:\n                        res = max(res, k+1)\n                \n        return res*res\n                \n", "class Solution:\n    def getLeftandTopOnes(self, grid: List[List[int]]):\n        leftGrid = [[0] * (len(grid[0])+1) for i in range(len(grid)+1)]\n        topGrid = [[0] * (len(grid[0])+1) for i in range(len(grid)+1)]\n            \n        for row in range(1, len(grid)+1):\n            for col in range(1, len(grid[0])+1):\n                if (grid[row-1][col-1] == 0):\n                    continue\n                leftGrid[row][col] = leftGrid[row][col-1] + 1\n                topGrid[row][col] = topGrid[row-1][col] + 1\n        return (leftGrid, topGrid)          \n           \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        leftOnes, topOnes = self.getLeftandTopOnes(grid)        \n        \n        print(leftOnes)\n        print(topOnes)\n        \n        maxBorder = 0\n        for row in range(1, len(grid)+1):\n            for col in range(1, len(grid[0])+1):\n                dist = min(topOnes[row][col], leftOnes[row][col])\n                while (dist > 0):\n                    if (topOnes[row][col-dist+1] >= dist and leftOnes[row-dist+1][col] >= dist):\n                        maxBorder = max(maxBorder, dist*dist)\n                        break\n                    dist -= 1\n        return maxBorder\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        # O(m*n*min(m,n))\n        up = [[0 for _ in range(len(grid[0])+1)] for _ in range(len(grid)+1)]\n        left = [[0 for _ in range(len(grid[0])+1)] for _ in range(len(grid)+1)]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                    if grid[i][j]:\n                        up[i+1][j+1] = up[i][j+1] + 1\n                        left[i+1][j+1] = left[i+1][j] + 1\n        maxlen = 0       \n        MAXSQ = min(len(grid[0]), len(grid))\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):   \n                for slen in range(maxlen+1, MAXSQ+1):\n                    if up[i+1][j+1] >= slen and left[i+1][j+1] >= slen and i+1-(slen-1) > 0 and j+1-(slen-1) > 0 and \\\\\n                            up[i+1][j+1-(slen-1)] >= slen and left[i+1-(slen-1)][j+1] >= slen:\n\n                        maxlen = max(maxlen, slen)\n        return maxlen * maxlen\n                ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        m, n = len(grid), len(grid[0])\n        res = 0\n        top, left = [a[:] for a in grid], [a[:] for a in grid]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    if i:\n                        top[i][j] = top[i-1][j]+1\n                    if j:\n                        left[i][j] = left[i][j-1]+1\n        \n        for r in range(min(m,n), 0, -1):\n            for i in range(m-r+1):\n                for j in range(n-r+1):\n                    if min(top[i+r-1][j], top[i+r-1][j+r-1],\n                           left[i][j+r-1], left[i+r-1][j+r-1])>=r:\n                        return r*r\n        return 0\n        \n", "class Solution:\n    def largest1BorderedSquare(self, A: List[List[int]]) -> int:\n        m, n = len(A), len(A[0])\n        res = 0\n        top, left = [a[:] for a in A], [a[:] for a in A]\n        for i in range(m):\n            for j in range(n):\n                if A[i][j]:\n                    if i: top[i][j] = top[i - 1][j] + 1\n                    if j: left[i][j] = left[i][j - 1] + 1\n        for r in range(min(m, n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                           [j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        return 0", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        res = 0\n        top, left = [a[:] for a in grid], [a[:] for a in grid]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    if i: top[i][j] = top[i - 1][j] + 1\n                    if j: left[i][j] = left[i][j - 1] + 1\n        for r in range(min(m, n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i][j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        return 0", "import itertools as it\n\n\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        nrows = len(grid)\n        ncols = len(grid[0])\n        cum_rows = [\n            list(it.accumulate(grid[row], initial=0))\n            for row in range(nrows)\n        ]\n        cum_cols = [\n            list(it.accumulate((grid[row][col] for row in range(nrows)), initial=0))\n            for col in range(ncols)\n        ]\n        ans = 0\n        for row1, col1 in it.product(range(nrows), range(ncols)):\n            if grid[row1][col1] == 0:\n                continue\n            side = 0\n            while row1 + side < nrows and col1 + side < ncols:\n                row2 = row1 + side\n                col2 = col1 + side\n                if (\n                    cum_cols[col1][row2 + 1] - cum_cols[col1][row1] == side + 1\n                    and cum_cols[col2][row2 + 1] - cum_cols[col2][row1] == side + 1\n                    and cum_rows[row1][col2 + 1] - cum_rows[row1][col1] == side + 1\n                    and cum_rows[row2][col2 + 1] - cum_rows[row2][col1] == side + 1\n                ):\n                    ans = max(ans, (side + 1) ** 2)\n                side += 1\n        return ans", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        # check discussion\n        # Time: O(N^3)\n        # Step1: Need two auxillary matrix to record the number of consecutive 1s on the vertical and horizontal direction\n        # Step2: check every possible candidate width from min(m, n) to 1\n        \n        m, n = len(grid), len(grid[0])\n        # Key: initialize them to SAME as grid, because value=0 got length 0, value=1 got length 1\n        horizontal_len = [row[:] for row in grid]\n        vertical_len = [row[:] for row in grid]\n        # calculate maximum length of one in two directions\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    if i > 0:\n                        vertical_len[i][j] = vertical_len[i - 1][j] + 1\n                    if j > 0:\n                        horizontal_len[i][j] = horizontal_len[i][j - 1] + 1\n        \n        for width in range(min(m, n), 0, -1):\n            for i in range(m - width + 1):\n                for j in range(n - width + 1):\n                    # Key: check the length on the 4 vertex in the horizontal/vertical direction, which indicate the maximum length\n                    valid_width = min(horizontal_len[i][j + width - 1],\n                                     horizontal_len[i + width - 1][j + width - 1],\n                                     vertical_len[i + width - 1][j],\n                                     vertical_len[i + width - 1][j + width - 1])\n                    # Key: NOT return valid_width, because \\\"width\\\" is the currently checking width, while valid_width MIGHT misleading. grid=[[0,1,0,1],[1,1,1,1],[1,1,0,1],[1,1,1,1]], i=1,j=1, valid_width is 4, but TRUE valid width is ONLY 3. If TRUR width is 4, we SHOULD find it when i=0,j=0\n                    if valid_width >= width:\n                        return width ** 2\n        return 0\n", "class Solution:\n    def largest1BorderedSquare(self, A):\n            m, n = len(A), len(A[0])\n            res = 0\n            top, left = [a[:] for a in A], [a[:] for a in A]\n            for i in range(m):\n                for j in range(n):\n                    if A[i][j]:\n                        if i: top[i][j] = top[i - 1][j] + 1\n                        if j: left[i][j] = left[i][j - 1] + 1\n            for r in range(min(m, n), 0, -1):\n                for i in range(m - r + 1):\n                    for j in range(n - r + 1):\n                        if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                               [j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                            return r * r\n            return 0", "class Solution:\n    def largest1BorderedSquare(self, A: List[List[int]]) -> int:\n        m=len(A)\n        n=len(A[0])\n        \n        top=[a[:] for a in A]\n        left=[a[:] for a in A]\n        \n        for i in range(m):\n            for j in range(n):\n                if A[i][j]:\n                    if i :\n                        top[i][j]=top[i-1][j]+1\n                    if j:\n                        left[i][j]=left[i][j-1]+1\n        \n\n        for r in range(min(m,n),0,-1):\n            for  i in range(m-r+1):\n                for j in range(n-r+1):\n                    \n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                           [j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        return 0\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        res = 0\n        top, left = [a[:] for a in grid], [a[:] for a in grid]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if i: top[i][j] = top[i - 1][j] + 1\n                    if j: left[i][j] = left[i][j - 1] + 1\n        for r in range(min(m, n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                           [j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        return 0", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        n = min(rows,cols)\n        rs = [row[:] for row in grid]\n        cs = [row[:] for row in grid]\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col]:\n                    if row:\n                        cs[row][col] = cs[row-1][col] + 1\n                    if col:\n                        rs[row][col] = rs[row][col-1] + 1\n        for size in range(n, 0, -1):\n            for row in range(rows-size+1):\n                for col in range(cols-size+1):\n                    if min(cs[row+size-1][col], cs[row+size-1][col+size-1], rs[row][col+size-1], rs[row+size-1][col+size-1]) >= size:\n                        return size*size\n        return 0\n                    \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        h = [row[:] for row in grid]\n        v = [row[:] for row in grid]\n        for row in range(m):\n            for col in range(1, n):\n                if h[row][col] != 0:\n                    h[row][col] += h[row][col-1]\n        for col in range(n):\n            for row in range(1, m):\n                if v[row][col] != 0:\n                    v[row][col] += v[row-1][col]\n        for row in range(m):\n            for col in range(n):\n                curr = grid[row][col]\n                if not curr: continue\n                side = h[row][col] if h[row][col] < v[row][col] else v[row][col]\n                res = 1\n                for x in range(side, 0, -1): \n                    if v[row][col-x+1] >= x and h[row-x+1][col] >= x: #\u8fde\u7eed\u76841\u8981\u5927\u4e8e\u8fb9\u957f\n                        res = x*x\n                        break\n                if res > ans:\n                    ans = res\n        return ans", "class Solution:\n    def largest1BorderedSquare(self, A):\n        m, n = len(A), len(A[0])\n        res = 0\n        top, left = [a[:] for a in A], [a[:] for a in A]\n        for i in range(m):\n            for j in range(n):\n                if A[i][j]:\n                    if i: top[i][j] = top[i - 1][j] + 1\n                    if j: left[i][j] = left[i][j - 1] + 1\n        for r in range(min(m, n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                           [j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        return 0", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        left = [a[:] for a in grid]\n        top = [a[:] for a in grid]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    left[i][j] = left[i][j-1]+1 if j else 1\n                    top[i][j] = top[i-1][j]+1 if i else 1\n        \n        for l in range(min(m,n), 0, -1):\n            for i in range(m-l+1):\n                for j in range(n-l+1):\n                    if min(top[i+l-1][j], top[i+l-1][j+l-1],\n                          left[i][j+l-1], left[i+l-1][j+l-1]) >= l:\n                        return l * l\n                    \n        return 0", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\nfrom math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\\\"\\\"\\\"\nstartSI\nnextSI\ntotalUsed\n\ncurEnd = si + (cnt - 1) * (m+1)\nif curEnd >= nextSI:\n    nextSI = curEnd + 1\n\nif startSI\n\ntotalUsed += cnt\n\n123123144 -> 143124123 -> 12312412455\n14312412355\n\n\n\\\"\\\"\\\"\n\nfrom math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\nfrom math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\n\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\\\"\\\"\\\"\npossible[weight][N] = possible[N - weight][N - 1], or \n\\\"\\\"\\\"\n\n\nclass Solution:\n\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        M = len(grid[0])\n        left0i = [[-1 for _ in range(M)] for _ in range(N)]\n        down0i = [[-1 for _ in range(M)] for _ in range(N)]\n\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j]:\n                    if j:\n                        left0i[i][j] = left0i[i][j - 1]\n                else:\n                    left0i[i][j] = j\n\n\n#        print(left0i)\n\n        for j in range(M):\n            for i in range(N):\n                if grid[i][j]:\n                    if i:\n                        down0i[i][j] = down0i[i - 1][j]\n                else:\n                    down0i[i][j] = i\n\n        for l in range(min(M, N), 0, -1):\n            for i in range(l - 1, N):\n                for j in range(l - 1, M):\n                    bottom = j - left0i[i][j]\n                    top = j - left0i[i - l + 1][j]\n                    left = i - down0i[i][j - l + 1]\n                    size = min(bottom, i - down0i[i][j], left, top)\n                    if size >= l:\n                        return l * l\n        return 0", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        # O(m*n*min(m,n))\n        up = [[0 for _ in range(len(grid[0])+1)] for _ in range(len(grid)+1)]\n        left = [[0 for _ in range(len(grid[0])+1)] for _ in range(len(grid)+1)]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                    if grid[i][j]:\n                        up[i+1][j+1] = up[i][j+1] + 1\n                        left[i+1][j+1] = left[i+1][j] + 1\n        res = 0       \n        for d in up:\n            print(d)\n        for l in left:\n            print(l)\n        MAXSQ = min(len(grid[0]), len(grid))\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):   \n                for slen in range(1, MAXSQ+1):\n                    if up[i+1][j+1] >= slen and left[i+1][j+1] >= slen and i+1-(slen-1) > 0 and j+1-(slen-1) > 0 and \\\\\n                            up[i+1][j+1-(slen-1)] >= slen and left[i+1-(slen-1)][j+1] >= slen:\n\n                        res = max(res, slen*slen)\n                # while i+1-slen > 0 and j+1-slen > 0 and left[i+1-slen][j+1] >= slen and up[i+1][j+1-slen] >= slen:\n                #     slen += 1\n                    \n        return res\n                ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        top = [a[:] for a in grid]\n        left = [a[:] for a in grid]\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    if i > 0:\n                        top[i][j] = top[i-1][j] + 1\n                    if j > 0:\n                        left[i][j] = left[i][j-1] + 1\n        \n        for r in range(min(m,n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i][j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        \n        return 0", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n=len(grid)\n        m=len(grid[0])\n        rows=[[0 for j in range(m+1)] for i in range(1+n)] # along rows\n        cols=[[0 for j in range(m+1)] for i in range(1+n)] # along cols\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                rows[i][j]=rows[i][j-1]+grid[i-1][j-1]\n                cols[i][j]=cols[i-1][j]+grid[i-1][j-1]\n        res = 0\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if grid[i-1][j-1]:\n                    k=1\n                    res=max(res,1)\n                    while i+k<=n and j+k<=m:\n                        if rows[i][j + k] - rows[i][j - 1] == rows[i + k][j + k] - rows[i + k][j - 1] == cols[i + k][j] - cols[i - 1][j] == cols[i + k][j + k] - cols[i - 1][j + k] == k + 1:\n                            res=max(res,(k+1)*(k+1))\n                        k+=1\n        return res", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        sum_row = []\n        sum_col = []\n        for i in range(m):\n            sum_row.append([0]*n)\n            sum_col.append([0]*n)\n        for i in range(m):\n            # print(i)\n            sum_row[i][0] = grid[i][0]\n            # print(sum_row[i][0], grid[i][0])\n            # print(sum_row[0], sum_row[1], sum_row[2])\n            for j in range(1, n):\n                # print(i, j)\n                sum_row[i][j] = sum_row[i][j-1] + grid[i][j]\n                # print(sum_row)\n        # print(sum_row, 'end') \n        for j in range(n):\n            sum_col[0][j] = grid[0][j]\n            for i in range(1, m):\n                sum_col[i][j] = sum_col[i-1][j] + grid[i][j]\n        # print(sum_col, 'end')\n        # scan all possible squares\n        num_ele = 0\n        for i in range(m):\n            for j in range(n):\n                l = min(i, j)\n                # print(i, j, l)\n                for k in range(l+1):\n                    slen = l-k\n                    length = slen + 1\n                    # print(i, j, l, k, slen, length)\n                    if ((sum_row[i-slen][j] - sum_row[i-slen][j-slen] + grid[i-slen][j-slen]) == length\n                    and (sum_row[i][j] - sum_row[i][j-slen] + grid[i][j-slen]) == length\n                    and (sum_col[i][j-slen] - sum_col[i-slen][j-slen] + grid[i-slen][j-slen]) == length\n                    and (sum_col[i][j] - sum_col[i-slen][j] + grid[i-slen][j]) == length):\n                        if length*length > num_ele:\n                            num_ele = length*length\n                        break\n        return num_ele\n                    \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        R, C = len(grid), len(grid[0])\n        top, left = copy.deepcopy(grid), copy.deepcopy(grid)\n        \n        # count ones\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]:\n                    if i > 0:\n                        top[i][j] = top[i-1][j] + 1\n                    if j > 0:\n                        left[i][j] = left[i][j-1] + 1\n        \n        # print(top, left)\n        # check for each possible squares\n        ans = 0\n        for s in range(min(R, C), 0, -1):\n            for i in range(R-s+1):\n                for j in range(C-s+1):\n                   # check top/left one counts for bottom 2 points\n                    if min(top[i+s-1][j], top[i+s-1][j+s-1], left[i][j+s-1], left[i+s-1][j+s-1]) >= s:\n                        return s * s\n        \n        return 0\n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        row=[0]*len(grid[0])\n        dph=[]\n        dpv=[]\n        for i  in range(len(grid)):\n            dph.append([0]*len(grid[0]))\n            dpv.append([0]*len(grid[0]))\n                       \n                       \n        \n        for i in range(len(grid)):\n            if grid[i][0]!=0:\n                dph[i][0]=1\n            else:\n                dph[i][0]=0\n                \n                \n            for j in range(1,len(grid[0])):\n                if grid[i][j]!=0:\n                    print((i,j))\n                    dph[i][j]=dph[i][j-1]+1\n\n                else:\n                     \n                    dph[i][j]=0\n                    \n                    \n        for j in range(len(grid[0])):\n            if grid[0][j]!=0:\n                dpv[0][j]=1\n            else:\n                dpv[0][j]=0\n                          \n            for i in range(1,len(grid)):\n                if grid[i][j]!=0:\n                    dpv[i][j]=dpv[i-1][j]+1\n\n                else:\n                    dpv[i][j]=0 \n       \n        print(dpv)\n        print(dph)\n        \n\n                        \n        maxl=0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]>0 :\n                    startl=min(dpv[i][j],dph[i][j])\n                    if startl>maxl:#\u53ef\u80fd\u7684\u5176\u5b9e\u8fb9\u6846\u957f\u5ea6\u8981\u5927\u4e8e\u76ee\u524d\u627e\u5230\u7684\u6700\u5927\u8fb9\u6846\n                    \n                        for k in range(startl,maxl,-1):\n                            left=j-k+1\n                            top=i-k+1\n                            if dpv[i][left]>=k and dph[top][j]>=k:\n                                maxl=k\n                                break\n        return maxl*maxl\n            \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n=len(grid)\n        m=len(grid[0])\n        row=[[0]*(m+1) for i in range(n+1)]\n        col=[[0]*(m+1) for i in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                row[i][j]=row[i][j-1]+grid[i-1][j-1]\n                col[i][j]=col[i-1][j]+grid[i-1][j-1]\n        res=0\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if grid[i-1][j-1]:\n                    k=1\n                    res=max(res,1)\n                    while i+k<=n and j+k<=m:\n                        if row[i][j+k]-row[i][j-1]==row[i+k][j+k]-row[i+k][j-1]==col[i+k][j]-col[i-1][j]==col[i+k][j+k]-col[i-1][j+k]==k+1:\n                            res=max(res,(k+1)*(k+1))\n                        k+=1\n        return res\n        \n        \n        \n        \n", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        if not grid:\n            return 0\n        \n        \n        m = len(grid)\n        n = len(grid[0])\n        # brute force\n        max_len = max(m, n)\n        \n        for l in range(max_len, 0, -1):\n            \n            for i in range(m-l+1):\n                for j in range(n-l+1):\n                    if self.find_board(i, j, l, grid):\n                        return l*l\n        return 0\n        \n        \n        \n    \n    def find_board(self, i, j, l, grid):\n        if l==1:\n            return grid[i][j] == 1\n        x1, x2 = i, i+l-1\n        for y in range(j, j+l):\n            if grid[x1][y] == 0: return False\n            if grid[x2][y] == 0: return False\n        \n        y1, y2 = j, j+l-1\n        for x in range(i+1, i+l-1):\n            if grid[x][y1] == 0: return False\n            if grid[x][y2] == 0: return False\n        \n        return True\n        \n            \n        \n", "def getArea(x1, y1, x2, y2, dp):\n    return dp[x2][y2] - dp[x2][y1-1] - dp[x1-1][y2] + dp[x1-1][y1-1]\n\nclass Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        if len(grid) == 0: return 0\n        if len(grid[0]) == 0: return 0\n        h, w = len(grid), len(grid[0])\n        dp = [[0 for j in range(w+1)] for i in range(h+1)]\n        for i in range(1, h+1):\n            for j in range(1, w+1):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + grid[i-1][j-1]\n        for l in range(min(h, w), 0, -1):\n            for x1 in range(1, h+1):\n                for y1 in range(1, w+1):\n                    x2 = x1 + l - 1\n                    y2 = y1 + l - 1\n                    if x2 > h or y2 > w:\n                        continue\n                    if (getArea(x1, y1, x2, y1, dp) == l \\\\\n                          and getArea(x1, y1, x1, y2, dp) == l \\\\\n                          and getArea(x1, y2, x2, y2, dp) == l\n                          and getArea(x2, y1, x2, y2, dp) == l):\n                        return l*l\n        return 0\n                    ", "class Solution:\n    def largest1BorderedSquare(self, grid):\n        n=len(grid)\n        m=len(grid[0])\n        rows=[[0 for j in range(m+1)] for i in range(1+n)] # along rows\n        cols=[[0 for j in range(m+1)] for i in range(1+n)] # along cols\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                rows[i][j]=rows[i][j-1]+grid[i-1][j-1]\n                cols[i][j]=cols[i-1][j]+grid[i-1][j-1]\n        res = 0\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if grid[i-1][j-1]:\n                    k=1\n                    res=max(res,1)\n                    while i+k<=n and j+k<=m:\n                        if rows[i][j + k] - rows[i][j - 1] == rows[i + k][j + k] - rows[i + k][j - 1] == cols[i + k][j] - cols[i - 1][j] == cols[i + k][j + k] - cols[i - 1][j + k] == k + 1:\n                            res=max(res,(k+1)*(k+1))\n                        k+=1\n        return res", "class Solution:\n    # Why would there be a situation that min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i][j + r - 1], left[i + r - 1][j + r - 1]) > r???\n    def largest1BorderedSquare(self, A):\n        m, n = len(A), len(A[0])\n        res = 0\n        top, left = [a[:] for a in A], [a[:] for a in A]\n        for i in range(m):\n            for j in range(n):\n                if A[i][j]:\n                    if i: top[i][j] = top[i - 1][j] + 1\n                    if j: left[i][j] = left[i][j - 1] + 1\n        for r in range(min(m, n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                           [j + r - 1], left[i + r - 1][j + r - 1]) == r:\n                        return r * r\n                    elif min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                               [j + r - 1], left[i + r - 1][j + r - 1]) > r:\n                        print(i,j,r,min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                               [j + r - 1], left[i + r - 1][j + r - 1]),m,n)\n                        return r * r\n        return 0", "class Solution:\n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0 or grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return False\n                \n            return True\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n        min_ = 0\n\n        for i in range(n):\n            for j in range(m):\n                \n                if grid[i][j] == 1:\n                    min_=1\n                    \n                    \n                    bound = min(n-i, m-j)\n                    \n                    \n                    for k in range(1, bound):\n                        if checkSquare(i,j, k):\n                            max_ = max(max_, (k+1)**2)\n                              \n        return max(max_, min_)\n", "class Solution:\n    \n    \\\"\\\"\\\"\n    1,1,1\n    1,1,1\n    1,1,1\n    \n    \\\"\\\"\\\"\n                \n                \n    \n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \n        \n        def checkSquare(i, j, k):\n            \n            for ind in range(k+1):\n                if grid[i][j+ind] == 0 or grid[i+ind][j] == 0 or grid[i+ind][k+j] == 0 or grid[i+k][j+ind] ==0:\n                    return False\n                \n            return True\n            \n        n = len(grid)\n        m = len(grid[0])\n        max_ = 0\n\n\n        for i in range(n):\n            for j in range(m):\n                \n                if grid[i][j] == 1:\n                    max_ = max(max_, 1)\n                    \n                    bound = min(n-i, m-j)\n                    \n                    \n                    for k in range(1,bound):\n                        if checkSquare(i,j, k):\n                            max_ = max(max_, (k+1)**2)\n                              \n        return max_\n            ", "class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        def Check(i,j):\n            ans = 1\n            Dis = min(m - i, n - j)\n            for k in range(max_dis, Dis):\n                ok = True\n                for h in range(i,i+k+1):\n                    if grid[h][j] == 0:\n                        ok = False\n                        break\n                    if grid[h][j+k] == 0:\n                        ok = False\n                        break\n                for h in range(j,j+k+1):\n                    if grid[i][h] == 0:\n                        ok = False\n                        break\n                    if grid[i+k][h] == 0:\n                        ok = False\n                        break\n                if ok:\n                    ans = max(ans, (k+1) * (k+1))\n            return ans\n        \n        m = len(grid)\n        n = len(grid[0])\n        max_so_far = 0\n        max_dis = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and i + max_dis < m and j + max_dis < n:\n                    max_so_far = max(max_so_far, Check(i,j))\n                    max_dis = int(math.sqrt(max_so_far))\n        return max_so_far\n                \n        \n        \n"]
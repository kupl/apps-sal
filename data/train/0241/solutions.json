["class Solution:\n    def move(self, pos, direction):\n        x, y = pos\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        elif direction == 3:\n            x -= 1\n        return (x, y)\n    \n    def isRobotBounded(self, instructions: str) -> bool:\n        direction = 0 # 0 for north, 1 for east, 2 for south, 3 for west\n        pos = (0, 0)\n        for i in instructions:\n            if i == 'G':\n                pos = self.move(pos, direction)\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'R':\n                direction = (direction + 1) % 4\n        if pos == (0, 0) or direction != 0:\n            return True\n        else:\n            return False\n", "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        \n        \n        mapping = {0: [1, 0], 1: [0, 1], 2: [-1, 0], 3: [0, -1]}\n        \n        direction = 0\n        current = [0, 0]\n        \n        for instr in instructions:\n            if instr == 'L':\n                direction -= 1\n            elif instr == 'R':\n                direction += 1\n            elif instr == 'G':\n                move = mapping[direction]\n                \n                current[0] += move[0]\n                current[1] += move[1]\n                \n            direction %= 4\n            \n        if current == [0, 0] or direction != 0:\n            return True\n        return False\n            \n", "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        x, y, dx, dy = 0, 0, 0, 1\n        for i in instructions:\n            if i == 'R': dx, dy = dy, -dx\n            if i == 'L': dx, dy = -dy, dx\n            if i == 'G': x, y = x + dx, y + dy\n        return (x, y) == (0, 0) or (dx, dy) != (0,1)\n", "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n      # loop through all the commands in the arr\n      # scenario the direction is not facing the same\n\n        def is_infinite_loop(command):\n            # iterate over all the commands \n            # direction 0: NameError\n            # x and y coordinates, if x and 0 is (0, 0) return True\n            direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n            d_index = 0\n            x, y = 0, 0\n            for move in command:\n                if move == 'G':\n                    x += direction[d_index][0]\n                    y += direction[d_index][1]\n                elif move == 'R':\n                    d_index = (d_index + 1) % 4\n                elif move == 'L':\n                    d_index = (d_index + 3) % 4\n            # if back at origin\n            # print(d_index)\n            if x == y == 0:\n                return True\n            if (x != 0 or y != 0) and d_index != 0:\n                return True\n            return False\n\n        return is_infinite_loop(instructions)\n\n# class Solution:\n#     def isRobotBounded(self, instructions: str) -> bool:\n#         L_occurances = instructions.count('L')\n#         R_occurances = instructions.count('R')\n#         difference = L_occurances - R_occurances\n        \n#         if difference % 4 == 0:\n#             # check if loop otherwise return False too\n#             directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # N, E, S, W\n#             d = 0                                           # start at North index\n#             point = [0, 0]\n#             for instruction in instructions:\n#                 if instruction == 'G':\n#                     point[0] += directions[d][0]\n#                     point[1] += directions[d][1]\n#                 elif instruction == 'L':\n#                     d = (d + 3) % 4\n#                 elif instruction == 'R':\n#                     d = (d + 1) % 4\n#             return True if point == [0, 0] else False\n#         else:\n#             return True\n        \n        \n#         # return True if L_occurances - R_occurances != 0 else False\n", "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        move = {'N':(0,1), 'S':(0,-1), 'E':(1,0), 'W':(-1,0)}\n        right = {'N':'E', 'S':'W', 'E':'S', 'W':'N'}\n        left = {'N':'W', 'S':'E', 'E':'N', 'W':'S'}\n        \n        pos = (0,0)\n        dire = 'N'\n        \n        for c in instructions:\n            if c=='G':\n                x, y = pos\n                dx, dy = move[dire]\n                pos = (x+dx, y+dy)\n            elif c=='L':\n                dire = left[dire]\n            else:\n                dire = right[dire]\n\n        return pos==(0,0) or dire!='N'\n", "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        move = {'N':(0,1), 'S':(0,-1), 'E':(1,0), 'W':(-1,0)}\n        right = {'N':'E', 'S':'W', 'E':'S', 'W':'N'}\n        left = {'N':'W', 'S':'E', 'E':'N', 'W':'S'}\n        \n        pos = (0,0)\n        dire = 'N'\n        i=0\n        while i<4:\n            for c in instructions:\n                if c=='G':\n                    x, y = pos\n                    dx, dy = move[dire]\n                    pos = (x+dx, y+dy)\n                elif c=='L':\n                    dire = left[dire]\n                else:\n                    dire = right[dire]\n            \n            if pos==(0,0) and dire=='N':\n                return True\n        \n            i+=1\n        \n        return False"]
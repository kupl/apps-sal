["def roll_dice (rolls, sides, threshold):\n    dp = [0] * (rolls * sides + 1)\n    for i in range(1, sides+1):\n        dp[i] = 1\n\n    for _ in range(rolls-1):\n        for x in range((rolls * sides), 0, -1):\n            dp[x] = sum(dp[max(1, x-sides):x])\n\n    return sum(dp[threshold:]) / sum(dp[1:])", "c = [[1]]\np = [1, 1]\nc.append(p)\nfor i in range(1, 2100):\n  a = [1]\n  for j in range(1, i+1):\n    a.append(p[j-1] + p[j])\n  a.append(1)\n  c.append(a)\n  p = a\n\ndef roll_dice (rolls, sides, threshold):\n  if threshold <= rolls: return 1\n  if threshold > rolls * sides: return 0\n  threshold -= rolls + 1;\n  sum_ = 0.0\n  i = 0\n  while (threshold >= 0):    \n    sum_ += (-1)**i * c[rolls][i] * c[threshold + rolls][threshold]\n    threshold -= sides\n    i += 1\n  return 1.0 - sum_ / (sides ** rolls)", "def roll_dice (rolls, sides, threshold):    \n    divisor = sides ** rolls\n\n    stack = [1 for i in range(sides)]\n    for i in range(1, rolls):\n        nstack = [0 for j in range(len(stack) + sides - 1)]\n        for j in range(len(nstack)):\n            start = j - sides + 1\n            if start < 0:\n                start = 0\n            end = j\n            if end >= len(stack):\n                end = len(stack) - 1    \n            nstack[j] = sum(stack[start: end + 1])\n        stack = nstack\n    \n    divend = sum(stack[threshold - rolls:])\n    \n    return divend / divisor", "from scipy.misc import comb\n\ndef Comb(c, n, k):\n    if c[n][k]: return c[n][k]\n    c[n][k] = comb(n,k)\n    return c[n][k]\n\ndef P(C_vect, p, n, s):\n    return sum((-1) ** k * Comb(C_vect, n, k) * Comb(C_vect, p - s*k - 1, n-1) for k in range((p-n) // s + 1)) / s ** n\n     \n    \ndef roll_dice (rolls, sides, threshold):\n    if threshold > sides*rolls: return 0\n    if threshold == sides**rolls: return 1/sides**rolls\n    if threshold <= rolls: return 1\n    k_max = max((threshold-rolls)//sides, rolls-1)\n    n_max = max(sides, threshold-1)\n    C_vect = [[0 for _ in range(k_max+1)] for _ in range(n_max+1)]\n    inv_prob = 0\n    for t in range(rolls, threshold):\n        inv_prob += P(C_vect, t, rolls, sides)\n    return 1 - inv_prob\n", "from math import*\n\ndef roll_dice (rolls, sides, threshold):\n    total = sides**rolls\n    f1, f2,outcomes = 1,1,0\n    \n    for j in range(rolls, min(threshold, rolls*sides - threshold + rolls + 1)):\n        k = (j - rolls)//sides\n        f1 = 1\n        for i in range(0, k+1):\n            f1 = factorial(rolls)//(factorial(i)*factorial(rolls-i))\n            f2 = factorial(j - sides*i - 1)//(factorial(j-sides*i - rolls)*factorial(rolls-1))\n            outcomes += ((-1)**i)*f1*f2\n\n    if threshold > sides*rolls: return 0.0\n    elif (threshold <= rolls*sides - threshold + rolls + 1): return 1 - (outcomes/total)\n    else: return (outcomes/total)", "memo={}\ndef roll_dice (rolls, sides, threshold):\n    memo={}\n    r=0\n    for i in range(rolls,threshold):\n        r+=_roll_dice(rolls,sides,i)\n    return 1-r\n  \ndef _roll_dice (rolls, sides, s):\n    if s<1:\n        return 0\n    elif rolls==1:\n        if s>sides:\n            return 0\n        return 1/sides\n    key=(rolls,sides,s)\n    if key in memo:\n        return memo[key]\n    r=0\n    for i in range(1,sides+1):\n       r+=_roll_dice(rolls-1,sides,s-i)\n    memo[key]=r/sides\n    return r/sides"]
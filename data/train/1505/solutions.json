["# cook your dish here\n\nT = int(input())\nl = list(map(int, input().strip().split(\" \")))\n\ndepth = 0\nmax_depth = 0\nmax_depth_index = 0\n\nmax_l=0\nmax_l_index=0\nlast_zero=-1\n\nfor i in range(T):\n    if l[i] == 1:\n        depth += 1\n        if depth > max_depth:\n            max_depth = depth\n            max_depth_index = i + 1\n    else:\n        depth-=1\n        if depth == 0:\n            length = i - last_zero\n            if length > max_l:\n                max_l = length\n                max_l_index = last_zero + 2\n            last_zero = i\n        \nprint(max_depth, max_depth_index, max_l, max_l_index)\n\n\"\"\"\n2 4 6 9\n\"\"\"", "N = int(input())\ns = input()\nd = 0\nmd = 0\nmdpos = 0\npl = 0\nmpl = 0\nplstart = 0\nfor i in range(N):\n    t = s[i*2]\n    if t == '1':\n        d += 1\n        if d > md :\n            md = d\n            mdpos = i\n    else:\n        d -= 1\n    pl += 1\n    if d == 0:\n        if pl> mpl:\n            mpl = pl\n            mplstart = plstart\n        plstart = i+1\n        pl = 0\nprint(md,mdpos+1,mpl,mplstart+1)\n\n", "n=int(input())\r\ns=list(map(int,input().split()))\r\ndans=0\r\nfd=0\r\nc=0\r\ncount=0\r\nmaxs=0\r\nfs=n\r\nfor i in range(n):\r\n    if s[i]==1:\r\n        c-=1\r\n        count+=1\r\n        if abs(c)>dans:\r\n            dans=abs(c)\r\n            if fd<i:\r\n                fd=i\r\n    else:\r\n        c+=1\r\n        if c==0: \r\n            if count>maxs:\r\n                maxs=count+1\r\n                fs=i-maxs+2\r\n\r\n            count=0\r\n        else:\r\n            count+=1\r\n\r\nprint(dans,fd+1,maxs,fs)\r\n", "# cook your dish here\nn = int(input())\na = list(map(int,input().strip().split()))\ni = 0\nx = 0\nz = 0\nnest = 1\npos = 0\nseq = 1 \nposq = 0\nwhile(i<n):\n    j= i + 1\n    x = 1\n    z = 1\n    q = i\n    while(j<n and x>0):\n        if(a[j] == 1):\n            x +=1 \n            z +=1\n            if(nest < x):\n                nest = x\n                pos = j\n            if(seq<z):\n                seq = z\n                posq = q\n        else:\n            x-=1\n        i = j + 1\n        j+=1\nprint(nest, pos+1, 2*seq, posq+1)\n", "n = int(input())\r\nseq = list(map(lambda x: 1 if x==\"1\" else -1, input().split()))\r\nsums = [seq[0]]\r\nfor i in seq[1:]:\r\n    sums.append(sums[-1]+i)\r\nfin_pos = -1\r\npos = -1\r\ncounter = -1\r\nm = -1\r\nfor i in range(n):\r\n    v = sums[i]\r\n    if counter == -1 and v == 1:\r\n        counter = 0\r\n        pos = i\r\n    elif v == 0:\r\n        if counter > m:\r\n            m = counter\r\n            fin_pos = pos\r\n        counter = -1\r\n    elif counter != -1:\r\n        counter += 1\r\n\r\nprint(max(sums), sums.index(max(sums))+1, m + 2, fin_pos+1)", "# cook your dish here\ndef is_seq_brackets_right(input_seq):\n    stack = []\n    highest_depth = 0\n    highest_depth_index = 0\n    max_inner_symbols_no = 0\n    max_inner_symbols_index = 0\n    for index_ in range(len(input_seq)):\n        i = input_seq[index_]\n        if i == \"1\":\n            stack.append([\"1\", index_])\n        else:\n            temp = stack.pop(-1)\n            if index_ - temp[1] + 1 > max_inner_symbols_no:\n                max_inner_symbols_no = index_ - temp[1] + 1\n                max_inner_symbols_index = temp[1]\n\n        if len(stack) > highest_depth:\n            highest_depth = len(stack)\n            highest_depth_index = index_\n    return len(stack) == 0, highest_depth, highest_depth_index + 1, max_inner_symbols_no, max_inner_symbols_index + 1\n\n\n\nN = int(input().strip())\ninput_string = input().strip()\nbracket_input = input_string.replace(\" \", \"\")\nans = is_seq_brackets_right(bracket_input)\nprint(ans[1], \" \", ans[2], \" \", ans[3], \" \", ans[4])\n", "# cook your dish here\n\ndef is_seq_brackets_right(input_seq):\n    stack = []\n    highest_depth = 0\n    highest_depth_index = 0\n    max_inner_symbols = []\n    max_inner_symbols_no = 0\n    max_inner_symbols_index = 0\n    for index_ in range(len(input_seq)):\n        i = input_seq[index_]\n        if i == \"(\":\n            stack.append(\"(\")\n            max_inner_symbols.append([index_, 1, True])\n        else:\n            stack.pop(-1)\n            max_inner_symbols.pop(-1)\n\n        for j in range(len(max_inner_symbols)):\n            max_inner_symbols[j][1] = max_inner_symbols[j][1] + 1\n            if max_inner_symbols[j][1] > max_inner_symbols_no:\n                max_inner_symbols_no = max_inner_symbols[j][1]\n                max_inner_symbols_index = max_inner_symbols[j][0]\n\n        if len(stack) > highest_depth:\n            highest_depth = len(stack)\n            highest_depth_index = index_\n    return len(stack) == 0, highest_depth, highest_depth_index + 1, max_inner_symbols_no, max_inner_symbols_index + 1\n\n\nN = int(input().strip())\ninput_string = input().strip()\nbracket_input = input_string.replace(\" \", \"\").replace(\"1\", \"(\").replace(\"2\", \")\")\nans = is_seq_brackets_right(bracket_input)\nprint(ans[1], \" \", ans[2], \" \", ans[3], \" \", ans[4])\n", "# cook your dish here\nimport sys\ninput=sys.stdin.readline\nn=int(input())\nl=input().split()\nstack=[]\nli=[int(i) for i in l]\nmaxa1=0\nans1=0\nmatch=[0 for i in range(n)]\nmaxa2=0\nans2=0\nfor i in range(n):\n    if(li[i]==2):\n        if(len(stack)>maxa1):\n            maxa1=len(stack)\n            ans1=stack[-1]\n        match[stack[-1]]=i\n        stack.pop(-1)\n    else:\n        stack.append(i)\nfor i in range(n):\n    if(match[i]-i>maxa2):\n        maxa2=match[i]-i\n        ans2=i\nprint(maxa1,ans1+1,maxa2+1,ans2+1)\n", "# cook your dish here\nN = int(input())\n\nenc = input().split()\nS = []\n\nfor e in enc : \n    if e == \"1\" : S.append(\"(\")\n    else : S.append(\")\")\n\n\n\n# task 1 : max depth \n\nclosures = []\nd = 0\nmax_d = 0\nmax_d_idx = 0\nstart = 0\nfor idx in range(N) :\n    \n    \n    s = S[idx]\n    if s == \"(\" : \n\n        d += 1\n        \n        if d > max_d : \n            max_d = d \n            max_d_idx = idx + 1\n        \n    else : \n        d -= 1\n    \n    if d == 0 : \n        finish = idx\n        closures.append([start, finish])\n        start = idx + 1\n    \n    \n    \n    \n# task 2 : maximum closure\n\n\ndiff = [x[1] - x[0] for x in closures]\nmax_diff = max(diff)\nmax_diff_idx = closures[diff.index(max_diff)][0] + 1\n\n\n        \nprint(max_d, max_d_idx, max_diff + 1, max_diff_idx)", "import sys\n# import math as mt\n# from collections import Counter\n# from itertools import permutations\n# from functools import reduce\n# from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\n\ndef get_inpt(): return sys.stdin.readline().strip()\ndef get_int(): return int(sys.stdin.readline().strip())\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\n\n# sys.setrecursionlimit(10**7)\nINF = float('inf')\n# MOD1, MOD2 = 1000000007, 998244353\n\nn = get_int()\narr = get_array()\n\ncurr_nest = 0\nmax_nest = 1\nnest_pos = 0\n\ncurr_symbols = 0\nmax_symbols = 2\nmax_symbols_open_pos = 0\n\nseq = 0\n\nfor ind in range(n):\n    \n   # curr_nest += 1\n   curr_symbols += 1\n   \n   if arr[ind] == 1:  # Open Parenthesis\n      seq += 1\n      if seq > max_nest:\n         max_nest = seq\n         nest_pos = ind\n     \n   else:  # Closed Parenthesis\n      seq -= 1\n      if seq == 0:\n         if curr_symbols > max_symbols:\n            max_symbols = curr_symbols\n            max_symbols_open_pos = ind - curr_symbols + 1\n         curr_symbols = 0\n\nprint(max_nest, nest_pos+1, max_symbols, max_symbols_open_pos+1)", "# cook your dish here\nimport sys\nn=int(input().strip())\nstringa=input().strip().split()\nstringa=''.join(stringa)\ncounter=0\nmax_width=0\nmax_depth=0\nfor i in range(n):\n    if stringa[i]=='1':\n        if counter==0:\n            start=i\n        counter+=1 \n    else:\n        if counter>max_depth:\n            max_depth=counter\n            depth_idx=i\n        counter-=1\n        if counter==0:\n            end=i\n            if end-start+1>max_width:\n                max_width=end-start+1\n                start_idx=start+1\nprint(max_depth, depth_idx, max_width, start_idx)", "n=int(input())\r\nx=[int(i) for i in input().split()]\r\na=0\r\nb=0\r\ny1=[]\r\ny2=[]\r\np=0\r\nq=0\r\nfor i in range(1,n+1):\r\n    if x[i-1]==1:\r\n        y1.append(i)\r\n        y2.append(i)\r\n    elif x[i-1]==2:\r\n        if len(y1)>a:\r\n            a=len(y1)\r\n            p=y1[-1]   \r\n        if len(y1)==1:\r\n            if len(y2)+1>b:\r\n                b=len(y2)+1\r\n                q=y2[0]\r\n            y2=[]\r\n        else:\r\n            y2.append(i)\r\n        y1.pop()\r\nprint(a,p,b,q)", "n=int(input())\n\na=[int(i) for i in input().split()]\n\nmd=0\nmr=0\nst1=[]\nst2=[]\ndno=0\nrno=0\n\nfor i in range(1,n+1):\n    if a[i-1]==1:\n        st1.append(i)\n        st2.append(i)\n    elif a[i-1]==2:\n        if len(st1)>md:\n            md=len(st1)\n            dno=st1[-1]\n            \n        if len(st1)==1:\n            if len(st2)+1>mr:\n                mr=len(st2)+1\n                rno=st2[0]\n            st2=[]\n        else:\n            st2.append(i)\n        st1.pop()\nprint(md,dno,mr,rno)\n                \n    \n", "# cook your dish here\nx = int(input())\ny = list(map(int, input().strip().split(\" \")))\nd, pd, l, pl = 0, 0, 0, 0\nmd, ml = 0, 0\nfor i in range(0,x):\n    if(y[i] == 1):\n        d = d+1\n        if(d > md): md, pd = d, i+1\n    if(y[i] == 2): d = d-1\n    if(d != 0):\n        l = l+1\n        if(l > ml): ml, pl = l, i-l+1\n    else:\n        l = 0\nprint(md, pd, ml+1, pl+1)", "# cook your dish here\nn = int(input())\nl = input().split()\n\nml = []\nmnd, mndi = -1, -1\nc = 1\nmaxc, maxci = 0, 0\nfor i in range(n):\n    if l[i] == '1':\n        ml.append('1')\n        if len(ml) > mnd:\n            mnd = len(ml)\n            mndi = i\n    if l[i] == '2':\n        ml.pop()\n        if ml == []:\n            if c > maxc:\n                maxc = c\n                maxci = i\n            c = 0\n    c += 1\nif c > maxc:\n    maxc = c\n    maxci = i\nprint(mnd, mndi+1, maxc, maxci-maxc+2)\n", "\ntry : \n    import sys\n    \n    num = int(input())\n    brackets = list(map(int, sys.stdin.readline().strip().split()))\n    \n    max_len_seq = 0\t\t\t #len of max sequence bw matching brackets\n    start_max_len_seq = 0\t #index where max length sequence occurs\n    max_depth = 0            \n    start_depth = 0\t\t\t #Index of where the nesting depth is achieved\n    \n    #temp vars\n    t1=0\n    t2=0\n    t3=0\n    t4=0\n    \n    n = 0   #number of brackets\n    \n    for i in range(num):\n        if n == 0:\n            t2 = i\n    \n        b = brackets[i]\n        \n        if b == 1: #opening bracket\n            n+=1\n            t3 +=1\n            t4 = i\n            t1+=1\n        \n        elif b == 2: #closing bracket\n            n-=1\n            t1+=1\n            t3-=1\n        \n        if t3 > max_depth:\n            max_depth = t3\n            start_depth = t4\n        \n        if t1 > max_len_seq:\n            max_len_seq = t1\n            start_max_len_seq = t2\n        \n        if n == 0:\n            t1=0\n            t2=0\n            t3=0\n            t4=0\n    \n    print(max_depth, start_depth+1, max_len_seq, start_max_len_seq+1)   # +1 since list index starts from 0\n\n\nexcept : pass", "# cook your dish here\n# cook your dish here\nl = int(input())\na = list(map(int, input().split()))\nstack = []\np, md, d = 0, 0, 0\nmp, ml, l = 0, 0, 0\nmpIndex = 0\n\nfor i in range(len(a)):\n    if(d == 0):\n        l = 0\n        mpIndex = i+1\n        \n    l += 1\n    \n    if(a[i] == 1):\n        d+=1\n    else:\n        d-=1\n    \n    if(d > md):\n        md = d\n        p = i+1\n    \n    if(l > ml):\n        ml = l\n        mp = mpIndex\n\nprint(md, p, ml, mp)", "# cook your dish here\nl = int(input())\na = list(map(int, input().split()))\nstack = []\np, md, d = 0, 0, 0\nmp, ml, l = 0, 0, 0\nmpIndex = 0\n\nfor i in range(len(a)):\n    if(d == 0):\n        l = 0\n        mpIndex = i+1\n        \n    l += 1\n    \n    if(a[i] == 1):\n        d+=1\n    else:\n        d-=1\n    \n    if(d > md):\n        md = d\n        p = i+1\n    \n    if(l > ml):\n        ml = l\n        mp = mpIndex\n\nprint(md, p, ml, mp)", "l = int(input())\na = list(map(int, input().split()))\nstack = []\np, md, d = 0, 0, 0\nmp, ml, l = 0, 0, 0\nmpIndex = 0\n\nfor i in range(len(a)):\n    if(d == 0):\n        l = 0\n        mpIndex = i+1\n        \n    l += 1\n    \n    if(a[i] == 1):\n        d+=1\n    else:\n        d-=1\n    \n    if(d > md):\n        md = d\n        p = i+1\n    \n    if(l > ml):\n        ml = l\n        mp = mpIndex\n\nprint(md, p, ml, mp)", "n=int(input())\na=list(map(int,input(\"\").strip().split()))[:n]\ns=list()\nli=list()\nk=0;\npos=0;\nsik=list()\nfor l in range(len(a)):\n    if a[l]==1:\n        li.append('(')\n        s.append('(')\n    elif a[l]==2:\n        s.append(')')\n        if len(li)!=0:\n            if k<len(li):\n                pos=l;\n                k=len(li)\n            del li[len(li)-1]\n        if len(li)==0:\n            sik.append(s);\n            s=list()\nle=0;\nfor i in sik:\n    if le<len(i):\n        le=len(i);\nse=0;\nfor i in sik:\n    if le==len(i):\n        break;\n    se+=len(i);\nprint(k,pos,le,se+1)\n", "n=int(input())\ntotal,distance,new_first=0,0,0\na=[]\nanswer = []\nlength =list(map(str,input().split()))\nstring =\"\".join(length)        \nfor i in range(len(string)):\n    if(string[i]=='1'):\n        a.append(i)\n        if(total<len(a)):\n            total=len(a)\n            start=a[len(a)-1]\n    elif(len(a)!=0 and string[i]=='2'):        \n        if(len(a)==1):\n            if(distance<i-a[len(a)-1]):\n                distance=i-a[len(a)-1]\n                new_first=a[len(a)-1]\n        a.pop()\nanswer.append(total)\nanswer.append(' ')\nanswer.append(start+1)\nanswer.append(' ')\nanswer.append(distance+1)\nanswer.append(' ')\nanswer.append(new_first+1)\nprint(''.join(map(str, answer)))   "]
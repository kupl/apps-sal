["import sys\n\nn = int(sys.stdin.readline())\n\nfor _ in range(n):\n p1, p2, m = list(map(int, sys.stdin.readline().split()))\n\n l = min(p1, p2)\n\n #while(m > 0 and l > 0):\n #    k = min(l, m)\n #    l -= k\n #    m -= 1\n\n q = min(p1, p2)\n d = min((m * (m + 1)) / 2, q)\n\n print(p1 - d + p2 - d)", "import sys\n\nn = int(sys.stdin.readline())\n\nfor _ in range(n):\n p1, p2, m = list(map(int, sys.stdin.readline().split()))\n\n l = min(p1, p2)\n\n while(m > 0 and l > 0):\n  k = min(l, m)\n  l -= k\n  m -= 1\n\n q = min(p1, p2)\n print(p1 - q + l + p2 - q + l)\n", "\nn = int(input())\n\nfor _ in range(n):\n p1, p2, m = list(map(int, input().split()))\n\n l = min(p1, p2)\n\n while(m > 0 and l > 0):\n  k = min(l, m)\n  l -= k\n  m -= 1\n\n q = min(p1, p2)\n print(p1 - q + l + p2 - q + l)\n", "import math\namb=math.factorial(10)\nt=eval(input())\nasa=pow(10,10)\nli=[]\nfor i in range(t):\n amb2=math.factorial(10)\n a,b,c=list(map(int,input().split()))\n asa2=pow(10,10)\n d=(c*(c+1))/2\n if d<=a and d<=b:\n  li.append(a+b-2*d)\n else:\n  amb2=math.factorial(10)\n  x=abs(a-b)\n  li.append(x)\nfor i in li:\n print(i)", "#t=int(raw_input())\nimport math\nt=eval(input())\nwhile t:\n str=input()\n a,b,r=str.split()\n a=int(a)\n b=int(b)\n r=int(r)\n #print(a,b,r)\n #b=input()\n #r=input()\n t=t-1\n m=min(a,b)\n max_can_remove=(r*(r+1))/2\n ans=0\n if max_can_remove > m:\n  ans=abs(a-b)\n else:\n  ans=a+b-(2*max_can_remove)\n print(ans)", "for _ in range(eval(input())):\n a,b,m=list(map(int,input().split()))\n gsum=(m+1)*m/2\n if gsum<min(a,b):\n  print(a+b-2*gsum)\n else:\n  print(abs(a-b))\n", "t = int(input())\nwhile t:\n n1,n2,m = [int(x) for x in input().split()]\n if n2<n1:\n  temp = n1\n  n1 = n2\n  n2 = temp\n sum_m = m*(m+1)/2\n if sum_m >= n1:\n  print(n2-n1)\n else:\n  print(n1+n2-2*sum_m)\n t-=1", "# CHEFST.py\n\nt = int(input());\nfor _ in range(t):\n n1,n2,m = list(map(int,input().split()))\n x = m*(m+1)\n x/=2;\n y = min(x,min(n1,n2));\n ans = (n1+n2)-(y+y)\n print(ans);", "def moves(n1, n2, m):\n lower = min(n1, n2)\n sum = max(n1, n2) - lower\n coverage = (m * (m + 1)) / 2\n if(coverage < lower):\n  sum = sum + (lower - coverage) * 2\n return sum \n\nT=int(input())\nwhile T > 0:\n T = T - 1\n list_num = [int(x) for x in input().split()]\n #print list_num\n print(moves(list_num[0], list_num[1], list_num[2]))", "import sys \nsys.setrecursionlimit(10000)\n\ndef find_min(m,W):\n i=1\n while i <= m :\n  if i not in W:\n   break\n  i+=1\n return i\n \ndef find_max(M,W,m):\n i=min(M,m)\n while i > 0 :\n  if i not in W:\n   break\n  i-=1\n return i\ncache = {}\ndef knap(M,W,m):\n if len(W)==m or M < find_min(m,W) or M==0 :\n  return 0\n if (M,tuple(W),m) in cache:\n  return cache[(M,tuple(W),m)]\n if m*(m+1)/2<M:\n  cache[(M,tuple(W),m)]=m*(m+1)/2\n  return cache[(M,tuple(W),m)]\n #if (M,W,m) in cache:\n #    return cache[(M,W,m)] \n val = find_max(M,W,m)\n W.add(val)\n #if val == M:\n #    return val\n #print val,M\n #cache[(M,W,m)] = \n cache[(M,tuple(W),m)] = val+knap(M-val,W,m)\n return cache[(M,tuple(W),m)]\n\n #return cache[(M,W,m)] \n \ntests = int(input())\nfor i in range(tests):\n n1,n2,m = ([int(x) for x in input().split(\" \")])\n W = set()\n M = min(n1,n2)\n print(max(n1,n2)-M + 2*(M-knap(M,W,m))) ", "def find_min(m,W):\n i=1\n while i <= m :\n  if i not in W:\n   break\n  i+=1\n return i\n \ndef find_max(M,W,m):\n i=min(M,m)\n while i > 0 :\n  if i not in W:\n   break\n  i-=1\n return i\ncache = {}\ndef knap(M,W,m):\n if len(W)==m or M < find_min(m,W) or M==0 :\n  return 0\n if (M,tuple(W),m) in cache:\n  return cache[(M,tuple(W),m)]\n if m*(m+1)/2<M:\n  cache[(M,tuple(W),m)]=m*(m+1)/2\n  return cache[(M,tuple(W),m)]\n #if (M,W,m) in cache:\n #    return cache[(M,W,m)] \n val = find_max(M,W,m)\n W.add(val)\n #if val == M:\n #    return val\n #print val,M\n #cache[(M,W,m)] = \n cache[(M,tuple(W),m)] = val+knap(M-val,W,m)\n return cache[(M,tuple(W),m)]\n\n #return cache[(M,W,m)] \n \ntests = int(input())\nfor i in range(tests):\n n1,n2,m = ([int(x) for x in input().split(\" \")])\n W = set()\n M = min(n1,n2)\n print(max(n1,n2)-M + 2*(M-knap(M,W,m))) ", "def find_min(m,W):\n i=1\n while i <= m :\n  if i not in W:\n   break\n  i+=1\n return i\n \ndef find_max(M,W,m):\n i=min(M,m)\n while i > 0 :\n  if i not in W:\n   break\n  i-=1\n return i\n \ndef knap(M,W,m):\n if len(W)==m or M < find_min(m,W) or M==0 :\n  return 0\n if m*(m+1)/2<M:\n  return m*(m+1)/2\n #if (M,W,m) in cache:\n #    return cache[(M,W,m)] \n val = find_max(M,W,m)\n W.add(val)\n #if val == M:\n #    return val\n #print val,M\n #cache[(M,W,m)] = \n return val+knap(M-val,W,m)\n #return cache[(M,W,m)] \n \ntests = int(input())\nfor i in range(tests):\n n1,n2,m = ([int(x) for x in input().split(\" \")])\n W = set()\n M = min(n1,n2)\n print(max(n1,n2)-M + 2*(M-knap(M,W,m))) "]
["class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         states = set()\n         for op_odd in [0, 1]:\n             for op_even in [0, 1]:\n                 for op_third in [0, 1]:\n                     op_all = m - op_odd - op_even - op_third\n                     if op_all >= 0:\n                         one = (op_odd + op_all + op_third) % 2\n                         two = (op_even + op_all) % 2\n                         three = op_odd % 2\n                         four = (op_even + op_all + op_third) % 2\n                         states.add((one, two, three, four)[:n])\n \n         return len(states)\n", "class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if m == 0:\n             return 1\n         lights = [True] * min(n, 3)\n         if m > 4:\n             if m & 1:\n                 m = 3\n             else:\n                 m = 4\n         return self.final(m, lights)\n         \n     def operate(self, num, array):\n         if num == 1:\n             array = [not i for i in array]\n         elif num == 2:\n             for i in range(len(array)):\n                 if i & 1:\n                     array[i] = not array[i]\n         elif num == 3:\n             for i in range(len(array)):\n                 if not i & 1:\n                     array[i] = not array[i]\n         elif num == 4:\n             for i in range(len(array)):\n                 if i%3 == 0:\n                     array[i] = not array[i]\n         return array\n \n     def final(self, num, array):\n         ops = [[[1] ,[2], [3], [4]],\n                [[], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]],\n                [[1] ,[2], [3], [4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]],\n                [[], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3, 4]]]\n         res = []\n         for op in ops[num-1]:\n             #print(op)\n             tmp = array.copy()\n             if not op:\n                 res.append(tmp)\n                 #print('  not op')\n             else:\n                 #print('  op')\n                 for i in op:\n                     tmp = self.operate(i, tmp)\n                 #print(' ', tmp)\n                 if not tmp in res:\n                     res.append(tmp)\n         return len(res)\n", "class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         n = min(n, 3)\n         if n == 0: return 0\n         if n == 1: return 2 if m > 0 else 1\n         if n == 2: \n             if m == 0: return 1\n             elif m == 1: return 3\n             else: return 4\n         if n == 3:\n             if m == 0: return 1\n             elif m == 1: return 4\n             elif m == 2: return 7\n             else: return 8\n         \n         \n         \n         \n", "class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if n==0:\n             return 0\n         if m==0:\n             return 1\n         if n==1:\n             return 2\n         if n==2:\n             if m>=2:\n                 return 4\n             if m==1:\n                 return 3\n         if n>=3:\n             if m>=3:\n                 return 8\n             if m==2:\n                 return 7\n             if m==1:\n                 return 4", "class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if m == 0:\n             return 1\n         lights = [True] * n\n         if m > 4:\n             if m & 1:\n                 m = 3\n             else:\n                 m = 4\n         return self.final(m, lights)\n         \n     def operate(self, num, array):\n         if num == 1:\n             array = [not i for i in array]\n         elif num == 2:\n             for i in range(len(array)):\n                 if i & 1:\n                     array[i] = not array[i]\n         elif num == 3:\n             for i in range(len(array)):\n                 if not i & 1:\n                     array[i] = not array[i]\n         elif num == 4:\n             for i in range(len(array)):\n                 if i%3 == 0:\n                     array[i] = not array[i]\n         return array\n \n     def final(self, num, array):\n         ops = [[[1] ,[2], [3], [4]],\n                [[], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]],\n                [[1] ,[2], [3], [4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]],\n                [[], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3, 4]]]\n         res = []\n         for op in ops[num-1]:\n             #print(op)\n             tmp = array.copy()\n             if not op:\n                 res.append(tmp)\n                 #print('  not op')\n             else:\n                 #print('  op')\n                 for i in op:\n                     tmp = self.operate(i, tmp)\n                 #print(' ', tmp)\n                 if not tmp in res:\n                     res.append(tmp)\n         return len(res)\n", "class Solution(object):\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if not n: return 0\n         n,b=min(6,n),set()\n         b.add(tuple([1]*n))\n         for j in range(m):\n             c=set()\n             for x in b:\n                 for t in tuple([(x[i]+1)%2 for i in range(n)]),tuple([x[i] if i%2==0 else (x[i]+1)%2 for i in range(n)]),tuple([(x[i]+1)%2 if i%2==0 else x[i] for i in range(n)]),tuple([(x[i]+1)%2 if i%3==0 else x[i] for i in range(n)]):\n                     if t not in c:\n                         c.add(t)\n             b=c\n             if len(b)==8: return 8\n         return len(b)", "class Solution:\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if n == 0:\n             return 0\n         if m == 0:\n             return 1\n         if n == 1:\n             return 2\n         if n == 2 and m ==1:\n             return 3\n         if n == 2:\n             return 4\n         if m == 1:\n             return 4\n         if m == 2:\n             return 7\n         return 8\n         \n", "class Solution(object):\n \tdef flipLights(self, lightNum, performTime):\n \t\tif(lightNum == 0):\n \t\t\treturn(0)\n \n \t\tif(performTime == 0):\n \t\t\treturn(1)\n \n \t\tif(lightNum == 1):\n \t\t\treturn(2)\n \n \t\tstatuNumToStatu = dict()\n \t\tstatuNumToStatu[0] = (False,)*lightNum\n \t\tstatuNumToStatu[1] = (True,)*lightNum\n \t\tstatuNumToStatu[2] = tuple(True if(i%2 == 0) else False for i in range(1,lightNum+1))\n \t\tstatuNumToStatu[3] = tuple(True if(i%2 == 1) else False for i in range(1,lightNum+1))\n \t\tstatuNumToStatu[4] = tuple(True if(i%3 == 1) else False for i in range(1,lightNum+1))\n \t\tstatuNumToStatu[4] = tuple(True if(i%3 == 1) else False for i in range(1,lightNum+1))\n \t\tstatuNumToStatu[(1,4)] = tuple(True if(i%3 != 1) else False for i in range(1,lightNum+1))\n \t\tstatuNumToStatu[(2,4)] = tuple(True if((i%2 == 0)^(i%3 == 1)) else False for i in range(1,lightNum+1))\n \t\tstatuNumToStatu[(3,4)] = tuple(True if((i%2 == 1)^(i%3 == 1)) else False for i in range(1,lightNum+1))\n \n \t\t# for key in statuNumToStatu:\n \t\t\t# print(key,statuNumToStatu[key])\n \n \t\tstatuNumToNextStatuNums = {\n \t\t\t0:[1,2,3,4],\n \t\t\t1:[0,2,3,(1,4)],\n \t\t\t2:[0,1,3,(2,4)],\n \t\t\t3:[0,1,2,(3,4)],\n \t\t\t4:[0,(1,4),(2,4),(3,4)],\n \t\t\t(1,4):[1,4,(2,4),(3,4)],\n \t\t\t(2,4):[2,4,(1,4),(3,4)],\n \t\t\t(3,4):[3,4,(1,4),(2,4)],\n \t\t}\n \n \t\tprevStatuNums = {0}\n \t\tfor eachTime in range(performTime):\n \t\t\tnextStatuNums = set()\n \t\t\tfor eachStatuNum in prevStatuNums:\n \t\t\t\tfor eachNextStatu in statuNumToNextStatuNums[eachStatuNum]:\n \t\t\t\t\tnextStatuNums.add(eachNextStatu)\n \n \t\t\tprevStatuNums = nextStatuNums\n \n \t\tallStatus = set()\n \t\tfor eachStatuNum in prevStatuNums:\n \t\t\tallStatus.add(statuNumToStatu[eachStatuNum])\n \n \t\treturn(len(allStatus))", "class Solution(object):\n     def flipLights(self, n, m):\n         \"\"\"\n         :type n: int\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if not n: return 0\n         n,b=min(6,n),set()\n         b.add(tuple([1]*n))\n         for j in range(m):\n             c=set()\n             for x in b:\n                 for t in tuple([(x[i]+1)%2 for i in range(n)]),tuple([x[i] if i%2==0 else (x[i]+1)%2 for i in range(n)]),tuple([(x[i]+1)%2 if i%2==0 else x[i] for i in range(n)]),tuple([(x[i]+1)%2 if i%3==0 else x[i] for i in range(n)]):\n                     if t not in c:\n                         c.add(t)\n             b=c\n             if len(b)==8: return 8\n         return len(b)"]
["def least_rotation(S: str) -> int:\r\n    \"\"\"Booth's algorithm.\"\"\"\r\n    f = [-1] * len(S)  # Failure function\r\n    k = 0  # Least rotation of string found so far\r\n    for j in range(1, len(S)):\r\n        sj = S[j]\r\n        i = f[j - k - 1]\r\n        while i != -1 and sj != S[k + i + 1]:\r\n            if sj < S[k + i + 1]:\r\n                k = j - i - 1\r\n            i = f[i]\r\n        if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\r\n            if sj < S[k]:  # k+i+1 = k\r\n                k = j\r\n            f[j - k] = -1\r\n        else:\r\n            f[j - k] = i + 1\r\n    return k\r\n\r\n\r\nfor _ in range(int(input())):\r\n    l, s = input().split()\r\n    if int(l) == 1:\r\n        l = len(s)\r\n        s += s\r\n        k = least_rotation(s)\r\n        print(s[k:k+l])\r\n    else:\r\n        print(''.join(sorted(s)))", "import sys\r\n\r\ndef minshift(s):\r\n\ts += s\r\n\tn = len(s)\r\n\ti, ans = 0, 0\r\n\twhile i < n//2:\r\n\t\tans = i\r\n\t\tj, k = i+1, i\r\n\t\twhile j<n and s[k] <= s[j]:\r\n\t\t\tif s[k] < s[j]:\r\n\t\t\t\tk = i\r\n\t\t\telse:\r\n\t\t\t\tk += 1\r\n\t\t\tj += 1\r\n\r\n\t\twhile i <= k:\r\n\t\t\ti += j-k\r\n\r\n\treturn s[ans:ans + n//2]\r\n\r\nt = int(sys.stdin.readline().strip())\r\nfor _ in range(t):\r\n\tl, s = sys.stdin.readline().strip().split()\r\n\tl = int(l)\r\n\r\n\tarr = [0]*len(s)\r\n\tfor i in range(len(s)):\r\n\t\tarr[i] = s[i]\r\n\r\n\tif l >= 2:\r\n\t\tarr.sort()\r\n\t\tprint(*arr, sep='')\r\n\t\tprint('')\r\n\telse:\r\n\t\tprint(minshift(s))\r\n\r\n\t\t# minalph = min(arr)\r\n\r\n\t\t# pos = []\r\n\r\n\t\t# for i in range(len(s)):\r\n\t\t# \tif s[i] == minalph:\r\n\t\t# \t\tpos += [i]\r\n\r\n\t\t# # print(pos)\r\n\r\n\t\t# offset = 1\r\n\t\t# while True:\r\n\t\t# \ttempmin = 'z'\r\n\t\t# \tfor i in range(len(pos)):\r\n\t\t# \t\ttempmin = min(tempmin, s[(pos[i]+offset)%len(s)])\r\n\r\n\t\t# \ttemppos = []\r\n\t\t# \tfor i in range(len(pos)):\r\n\t\t# \t\tif s[(pos[i]+offset)%len(s)] == tempmin:\r\n\t\t# \t\t\ttemppos += [pos[i]]\r\n\r\n\t\t# \tpos = temppos[:]\r\n\t\t# \toffset += 1\r\n\t\t# \t# print(offset)\r\n\t\t# \t# print(pos)\r\n\r\n\t\t# \tif tempmin == minalph:\r\n\t\t# \t\tbreak\r\n\r\n\t\t# start = pos[0]\r\n\t\t# for i in range(len(s)):\r\n\t\t# \tprint(s[(start+i)%len(s)], end='')\r\n\t\t# print('')", "def least_rotation(S):\r\n    S += S  # Concatenate string to it self to avoid modular arithmetic\r\n    f = [-1] * len(S)  # Failure function\r\n    k = 0  # Least rotation of string found so far\r\n    for j in range(1, len(S)):\r\n        sj = S[j]\r\n        i = f[j - k - 1]\r\n        while i != -1 and sj != S[k + i + 1]:\r\n            if sj < S[k + i + 1]:\r\n                k = j - i - 1\r\n            i = f[i]\r\n        if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\r\n            if sj < S[k]:  # k+i+1 = k\r\n                k = j\r\n            f[j - k] = -1\r\n        else:\r\n            f[j - k] = i + 1\r\n    return k\r\n\r\ntest = int(input())\r\nfor tc in range(test):\r\n    l,st = input().split()\r\n    l=int(l)\r\n    if l==1:\r\n        kk = least_rotation(st)\r\n        ln = len(st)\r\n        mt = \"\"\r\n        for i in range(len(st)):\r\n            mt+=str(st[(kk+i)%ln])\r\n        print(mt)\r\n    else:\r\n        lst = []\r\n        for i in range(len(st)):\r\n            lst.append(st[i])\r\n        lst.sort()\r\n        mt = \"\"\r\n        for i in range(len(lst)):\r\n            mt+=str(lst[i])\r\n        print(mt)", "def least_rotation(S: str):\r\n    \"\"\"Booth's algorithm.\"\"\"\r\n    S += S  # Concatenate string to it self to avoid modular arithmetic\r\n    f = [-1] * len(S)  # Failure function\r\n    k = 0  # Least rotation of string found so far\r\n    for j in range(1, len(S)):\r\n        sj = S[j]\r\n        i = f[j - k - 1]\r\n        while i != -1 and sj != S[k + i + 1]:\r\n            if sj < S[k + i + 1]:\r\n                k = j - i - 1\r\n            i = f[i]\r\n        if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\r\n            if sj < S[k]:  # k+i+1 = k\r\n                k = j\r\n            f[j - k] = -1\r\n        else:\r\n            f[j - k] = i + 1\r\n    return k\r\nt=int(input())\r\nfor _ in range(t):\r\n    l,s=input().split()\r\n    l=int(l)\r\n    n=len(s)\r\n    if(l==1):\r\n        o=least_rotation(s)\r\n        s+=s\r\n        print(s[o:o+n])\r\n    else:\r\n        v=''.join(sorted(s))\r\n        print(str(v))", "def least_rotation(S: str) -> int:\n    \"\"\"Booth's algorithm.\"\"\"\n    S += S  # Concatenate string to it self to avoid modular arithmetic\n    f = [-1] * len(S)  # Failure function\n    k = 0  # Least rotation of string found so far\n    for j in range(1, len(S)):\n        sj = S[j]\n        i = f[j - k - 1]\n        while i != -1 and sj != S[k + i + 1]:\n            if sj < S[k + i + 1]:\n                k = j - i - 1\n            i = f[i]\n        if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\n            if sj < S[k]:  # k+i+1 = k\n                k = j\n            f[j - k] = -1\n        else:\n            f[j - k] = i + 1\n    return k\n\nt=int(input())\nfor _ in range(t):\n    l,s=input().split()\n    if(l=='1'):\n        k=least_rotation(s)\n        ans=\"\"\n        n=len(s)\n        s+=s\n        for i in range(k,k+n):\n            ans+=s[i]\n        print(ans)\n    else:\n        s=sorted(s)\n        print(''.join(s))", "def solve(s,l,ans):\r\n    n = len(s)\r\n    s = list(s)\r\n    if l > 1:\r\n        s.sort()\r\n        ans.append(s)\r\n        return\r\n    \r\n    indices = []\r\n    min_val = min(s)\r\n    for i in range(len(s)):\r\n        if s[i] == min_val:\r\n            indices.append((i,1))\r\n\r\n\r\n    while True:\r\n        min_val = 'z'\r\n        found = False\r\n        for index,count in indices:\r\n            min_val = min(min_val,s[index])\r\n            if count == n:\r\n                found = True\r\n                \r\n        if found:\r\n            break\r\n\r\n        new_indices = []\r\n        for index,count in indices:\r\n            if s[index] == min_val:\r\n                if index+1 == n:\r\n                    new_indices.append((0,count+1))\r\n                else:\r\n                    new_indices.append((index+1,count+1))\r\n\r\n        indices = new_indices[:]\r\n\r\n    s1 = []\r\n    index = indices[0][0]\r\n    count = 0\r\n    while index >= 0:\r\n        s1.append(s[index])\r\n        count += 1\r\n        index -= 1\r\n\r\n    index = n-1\r\n    while count != n:\r\n        s1.append(s[index])\r\n        index -= 1\r\n        count += 1\r\n\r\n    s1.reverse()\r\n    ans.append(s1)\r\n\r\ndef main():\r\n    t = int(input())\r\n    ans = []\r\n    for i in range(t):\r\n        l,s = map(str,input().split())\r\n        l = int(l)\r\n        solve(s,l,ans)\r\n\r\n    for i in ans:\r\n        for j in i:\r\n            print(j,end = '')\r\n\r\n        print()\r\n\r\n\r\nmain()\r\n"]
["class Solution:\n    def minFlips(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        \n        start = sum(val << (i*n + j) for i, row in enumerate(mat) for j, val in enumerate(row))\n        \n        queue = collections.deque([(start, 0)])\n        seen = { start }\n        \n        dirs = [[0, 0], [0,1], [1, 0], [0, -1], [-1, 0]]\n        while queue:\n            # print(queue)\n            current, d = queue.popleft()\n            if current == 0:\n                return d\n            \n            # for each index in matrix find neighbour\n            for i in range(len(mat)):\n                for j in range(len(mat[0])):\n                    next_state = current\n                    \n                    # importants dirs has [0, 0] we need flip the current element and neigbour\n                    for dir_ in dirs:\n                        new_i = i + dir_[0]\n                        new_j = j + dir_[1]\n                        \n                        if new_i >= 0 and new_i < len(mat) and new_j >= 0 and new_j < len(mat[0]):\n                            next_state ^= (1 << (new_i * n + new_j )) # 0 xor 1 = 1, 1 xor 1 = 0\n                    \n                    if next_state not in seen:\n                        seen.add(next_state)\n                        queue.append((next_state, d + 1))\n        \n        return -1\n"]
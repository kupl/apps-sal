["def main():\n    import sys\n    input = sys.stdin.readline\n\n    import heapq\n    def dijkstra_heap(s,g,edge):\n        #\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n        d = [10**20] * (n+2)\n        used = [True] * (n+2) #True:\u672a\u78ba\u5b9a\n        d[s] = 0\n        used[s] = False\n        edgelist = []\n        sx,sy,sr=edge[s][0],edge[s][1],edge[s][2]\n        for i in range(n+2):\n            x,y,r=edge[i][0],edge[i][1],edge[i][2]\n            dist=((x-sx)**2+(y-sy)**2)**(1/2)\n            heapq.heappush(edgelist,(max(dist-r-sr,0),i))\n        while len(edgelist):\n            minedge = heapq.heappop(edgelist)\n            #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n            v = minedge[1]\n            if not used[v]:\n                continue\n            d[v] = minedge[0]\n            used[v] = False\n            bx,by,br=edge[v][0],edge[v][1],edge[v][2]\n            for i in range(n+2):\n                x,y,r=edge[i][0],edge[i][1],edge[i][2]\n                dist=((x-bx)**2+(y-by)**2)**(1/2)\n                if used[i]:\n                    heapq.heappush(edgelist,(max(dist-r-br,0)+d[v],i))\n            if not used[g]:\n                break\n        return d[g]\n\n    sx,sy,gx,gy = map(int,input().split()) #n:\u9802\u70b9\u6570\u3000w:\u8fba\u306e\u6570\n    n=int(input())\n    edge=[(sx,sy,0),(gx,gy,0)]\n    for i in range(2,n+2):\n        x,y,r=map(int,input().split())\n        edge.append((x,y,r))\n    print(dijkstra_heap(0,1,edge))\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef dijkstra(n, s, cost):\n    res = [f_inf] * n\n    res[s] = 0\n    checked = [False] * n\n    while True:\n        v = -1\n        for k in range(n):\n            if (not checked[k]) and (v == -1):\n                v = k\n            elif (not checked[k]) and res[k] < res[v]:\n                v = k\n        if v == -1:\n            break\n        checked[v] = True\n        for m in range(n):\n            res[m] = min(res[m], res[v] + cost[v][m])\n    return res\n\n\ndef resolve():\n    def calc_dist(x1, y1, x2, y2):\n        return pow(pow(x1 - x2, 2) + pow(y1 - y2, 2), 0.5)\n\n    sx, sy, gx, gy = list(map(int, input().split()))\n    n = int(input())\n    node = [[sx, sy, 0]] + [list(map(int, input().split())) for _ in range(n)] + [[gx, gy, 0]]\n    cost = [[0] * (n + 2) for _ in range(n + 2)]\n    for i in range(n + 2):\n        x1, y1, r1 = node[i]\n        for j in range(i + 1, n + 2):\n            x2, y2, r2 = node[j]\n            dist = max(0, calc_dist(x1, y1, x2, y2) - (r1 + r2))\n            cost[i][j] = dist\n            cost[j][i] = dist\n\n    res = dijkstra(n + 2, 0, cost)\n    print((res[-1]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nfrom heapq import heapify,heappop,heappush\ndef dijkstra(G,s = 0): #s\u3092\u59cb\u70b9\u3068\u3057\u305f\u6700\u77ed\u7d4c\u3092\u6c42\u3081\u308b\n    n = len(G)\n    dist = [INF] * n\n    dist[s] = 0\n    q = [(0,s)]\n    while q:\n        d,v = heappop(q)\n        if dist[v] < d:\n            continue\n        for e,cost in G[v]:\n            if dist[e] > dist[v] + cost:\n                dist[e] = dist[v] + cost\n                heappush(q,(dist[e],e))\n    return dist\n\nfrom math import hypot\ndef main():\n    sy,sx,gy,gx = map(int,input().split())\n    N = int(input())\n    circles = [(sy,sx,0)] + [tuple(map(int,input().split())) for _ in range(N)] + [(gy,gx,0)]\n    N += 2\n\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        x,y,z = circles[i]\n        for j in range(i + 1,N):\n            p,q,r = circles[j]\n            d = max(0,hypot(x - p,y - q) - z - r)\n            G[i].append((j,d))\n            G[j].append((i,d))\n    \n    dist = dijkstra(G)\n    ans = dist[-1]\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsx,sy,tx,ty=list(map(int,input().split()))\nn=int(input())\np=[(sx,sy,0)]\nfor _ in range(n):\n  x,y,r=list(map(int,input().split()))\n  p.append((x,y,r))\np.append((tx,ty,0))\nn+=2\nedge=[[]for _ in range(n)]\nfor i in range(n-1):\n  for j in range(i+1,n):\n    sx,sy,sr=p[i]\n    tx,ty,tr=p[j]\n    t=(abs(sx-tx)**2+abs(sy-ty)**2)**0.5\n    c=max(0,t-(sr+tr))\n    edge[i].append((j,c))\n    edge[j].append((i,c))\nfrom heapq import heappop,heappush\ninf=10**20\nans=[inf]*n\nans[0]=0\nroot=[-1]*n\nh=[(0,0)]\nwhile h:\n  c,v=heappop(h)\n  if ans[v]<c:continue\n  for u,t in edge[v]:\n    if c+t<ans[u]:\n      ans[u]=c+t\n      root[u]=v\n      heappush(h,(c+t,u))\nprint((ans[n-1]))\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef dijkstra(n, s, cost):\n    res = [f_inf] * n\n    res[s] = 0\n    checked = [False] * n\n    while True:\n        v = -1\n        for k in range(n):\n            if (not checked[k]) and (v == -1):\n                v = k\n            elif (not checked[k]) and res[k] < res[v]:\n                v = k\n        if v == -1:\n            break\n        checked[v] = True\n        for m in range(n):\n            res[m] = min(res[m], res[v] + cost[v][m])\n    return res\n\n\ndef resolve():\n    def calc_dist(x1, y1, x2, y2):\n        return pow(pow(x1 - x2, 2) + pow(y1 - y2, 2), 0.5)\n\n    sx, sy, gx, gy = list(map(int, input().split()))\n    n = int(input())\n    node = [[sx, sy, 0]] + [list(map(int, input().split())) for _ in range(n)] + [[gx, gy, 0]]\n    cost = [[0] * (n + 2) for _ in range(n + 2)]\n    for i in range(n + 2):\n        x1, y1, r1 = node[i]\n        for j in range(i + 1, n + 2):\n            x2, y2, r2 = node[j]\n            dist = max(0, calc_dist(x1, y1, x2, y2) - (r1 + r2))\n            cost[i][j] = dist\n            cost[j][i] = dist\n\n    res = dijkstra(n + 2, 0, cost)\n    print((res[-1]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import numpy as np\nfrom scipy.spatial.distance import cdist\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\nxs, xy, xt, yt = map(int, input().split())\nN = int(input())\nbarriers = np.array([(xs, xy, 0), (xt, yt, 0)] + [tuple(map(int, input().split())) for _ in range(N)])\ndist = cdist(barriers[:, :2], barriers[:, :2])\ndist = np.maximum(dist - barriers[:, 2] - barriers[:, 2][:, None], 0)\n\nlength = dist.ravel()\nfrm = np.repeat(np.arange(N + 2), N + 2)\nto = np.tile(np.arange(N + 2), N + 2)\n\nmatr = csr_matrix((length, (frm, to)), shape=(N + 2, N + 2))\nans = dijkstra(matr, indices=0)[1]\nprint(ans)", "from heapq import heappop, heappush\nfrom math import sqrt\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nINF = 10**15\n\ndef dijkstra(E, s, g):\n    d = [INF] * len(E)\n    d[0] = 0\n\n    queue = []\n    heappush(queue, (0, s))\n\n    while queue:\n        dist_v, v = heappop(queue)\n        if dist_v > d[v]:\n            continue\n        \n        for e, w in E[v]:\n            tmp = d[v] + w\n            if tmp < d[e]:\n                d[e] = tmp\n                heappush(queue, (tmp, e))\n    \n    return d[g]\n\n\ndef main():\n    x_s, y_s, x_t, y_t = list(map(int, readline().split()))\n    N,*xyr = list(map(int, read().split()))\n\n    XYR = []\n    XYR.append((x_s, y_s, 0))\n    XYR.append((x_t, y_t, 0))\n    for x, y, r in zip(*[iter(xyr)]*3):\n        XYR.append((x, y, r))\n    \n    E = [[] for _ in range(N+2)]\n    for i in range(N+1):\n        x_i, y_i, r_i = XYR[i]\n        for j in range(i+1, N+2):\n            x_j, y_j, r_j = XYR[j]\n            d = sqrt((x_i - x_j)**2 + (y_i - y_j)**2)\n            d -= r_i + r_j\n            d = max(0, d)\n            E[i].append((j, d))\n            E[j].append((i, d))\n\n    ans = dijkstra(E, 0, 1)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nxs,ys,xt,yt = list(map(int,readline().split()))\nn, = list(map(int,readline().split()))\n\nxyr = [tuple(map(int,readline().split())) for _ in range(n)] + [(xs,ys,0),(xt,yt,0)]\n\n\n\"\"\"\nd: \u96a3\u63a5\u884c\u5217\u306b\u5bfe\u3059\u308b Dijkstra\nO(N^2)\n\"\"\"\ndef Dijkstra_matrix(d,start):\n    n = len(d)\n    #INF = 1<<61\n    INF = float(\"inf\")\n    dist = d[start][:] #start\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n\n    used = [0]*n # \u6700\u77ed\u8ddd\u96e2\u304c\u6c7a\u307e\u3063\u305f\u9802\u70b9\n    used[start] = 1\n    for _ in range(n-1):\n        d0  = INF\n        idx = -1\n        for i in range(n):\n            if not used[i] and dist[i] < d0:\n                idx = i\n                d0  = dist[i]\n        if idx == -1:\n            return dist\n        else:\n            used[idx] = 1\n            for j in range(n):\n                if not used[j] and dist[j] > dist[idx]+d[idx][j]:\n                    dist[j] = dist[idx]+d[idx][j]\n    return dist\n\nfrom math import hypot\nd = [[max(0.0,hypot((xi-xj),(yi-yj))-ri-rj) for xj,yj,rj in xyr] for xi,yi,ri in xyr]\n\n#print(d)\ndist = Dijkstra_matrix(d,n)\nprint((dist[-1]))\n#print(dist)\n\n\n\n\n\n\n", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nxs,ys,xt,yt = list(map(int, input().split()))\nn = int(input())\nxyr = [None]*(n+2)\nfor i in range(n):\n    xyr[i] = tuple(map(int, input().split()))\nfrom itertools import product\n# ns = [[] for _ in range(n+2)]\ndata = []\nrs = []\ncs = []\ns = n\nt = n+1\nxyr[s] = (xs,ys,0)\nxyr[t] = (xt,yt,0)\nfor i,j in product(range(n+2), range(n+2)):\n    if i<j:\n        d = max(0, ((xyr[i][0]-xyr[j][0])**2 + (xyr[i][1]-xyr[j][1])**2)**0.5 - (xyr[i][2]+xyr[j][2]))\n        data.append(d)\n        rs.append(i)\n        cs.append(j)\nimport scipy.sparse\nm = scipy.sparse.csr_matrix((data, (rs, cs)), shape=(n+2, n+2))\nans = scipy.sparse.csgraph.dijkstra(m, indices=t, directed=False)\nprint(ans[s])", "from math import sqrt\nimport numpy as np\nfrom scipy.sparse.csgraph import csgraph_from_dense, shortest_path\ndef distance(x0, y0, x1, y1):\n    return sqrt((x1-x0)**2 + (y1-y0)**2)\n\nxs, ys, xt, yt, n, *XYR = map(int, open(0).read().split())\nP = [(xs, ys, 0), (xt, yt, 0)] + list(zip(XYR[::3], XYR[1::3], XYR[2::3]))\n\nedges = np.zeros((n+2, n+2))\nfor i in range(n+1):\n    for j in range(i+1, n+2):\n        dist = distance(P[i][0], P[i][1], P[j][0], P[j][1])\n        dist = max(dist - P[i][2] - P[j][2], 0.0)\n        edges[i, j] = edges[j, i] = dist\n\nG = csgraph_from_dense(edges, null_value=-1)\nprint(shortest_path(G, indices=0)[1])", "import bisect, copy, heapq, math, sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\ndef celi(a,b):\n    return -(-a//b)\nsys.setrecursionlimit(5000000)\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nxy=list(map(int,input().split()))\nn=int(input())\nxyr=[list(map(int,input().split())) for i in range(n)]\n\ndef dijkstra(s,e):\n    hq = [(0, s)]\n    heapq.heapify(hq) # \u30ea\u30b9\u30c8\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u306b\u5909\u63db\n    cost = [float('inf')] * n # \u884c\u3063\u305f\u3053\u3068\u306e\u306a\u3044\u3068\u3053\u308d\u306finf\n    cost[s] = 0 # \u958b\u59cb\u5730\u70b9\u306f0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v]: # \u30b3\u30b9\u30c8\u304c\u73fe\u5728\u306e\u30b3\u30b9\u30c8\u3088\u308a\u3082\u9ad8\u3051\u308c\u3070\u30b9\u30eb\u30fc\n            continue\n        for d, u in e[v]:\n            tmp = d + cost[v]\n            if tmp < cost[u]:\n                cost[u] = tmp\n                heapq.heappush(hq, (tmp, u))\n    return cost\n\n################################\nn,w = n,(n+2)*(n+1)//2 #n:\u9802\u70b9\u6570\u3000w:\u8fba\u306e\u6570\n\nedge = [[] for i in range(n+2)]\n#edge[i] : i\u304b\u3089\u51fa\u308b\u9053\u306e[\u91cd\u307f,\u884c\u5148]\u306e\u914d\u5217\nfor i in range(n):\n    for j in range(i+1,n):\n        x1,y1,r1=xyr[i]\n        x2,y2,r2=xyr[j]\n        dis=math.sqrt((x2-x1)**2+(y2-y1)**2)\n        edge[i+1].append((max(0,dis-r1-r2),j+1))\n        edge[j+1].append((max(0,dis-r1-r2),i+1))\nfor i in range(n):\n    x1,y1,r1=xyr[i]\n    dis=math.sqrt((xy[0]-x1)**2+(xy[1]-y1)**2)\n    edge[0].append((max(0,dis-r1),i+1))\n    edge[i+1].append((max(0,dis-r1),0))\n    dis=math.sqrt((xy[2]-x1)**2+(xy[3]-y1)**2)\n    edge[n+1].append((max(0,dis-r1),i+1))\n    edge[i+1].append((max(0,dis-r1),n+1))\nedge[0].append((math.sqrt((xy[0]-xy[2])**2+(xy[1]-xy[3])**2),n+1))\nedge[n+1].append((math.sqrt((xy[0]-xy[2])**2+(xy[1]-xy[3])**2),0))\n# print(edge)\nn=n+2\nprint(dijkstra(0,edge)[-1])", "import sys\nfrom heapq import heappush, heappop\n\ninput = sys.stdin.readline\nxs, ys, xt, yt = map(int, input().split())\nN = int(input())\n\nx_list = []\ny_list = []\nr_list = []\nx_list.append(xs)\ny_list.append(ys)\nr_list.append(0)\nx_list.append(xt)\ny_list.append(yt)\nr_list.append(0)\nfor _ in range(N):\n    x, y, r = map(int, input().split())\n    x_list.append(x)\n    y_list.append(y)\n    r_list.append(r)\n\nedges = [[] for _ in range(N+2)]\nfor i in range(N+1):\n    for j in range(i+1, N+2):\n        x1, y1, r1 = x_list[i], y_list[i], r_list[i]\n        x2, y2, r2 = x_list[j], y_list[j], r_list[j]\n        d = max(0, ((x1 - x2)**2 + (y1 - y2)**2)**0.5 - r1 - r2)\n        edges[i].append((j, d))\n        edges[j].append((i, d))\n# print(edges)\n\nINF = 10**10\ndist = [INF] * (N+2)\nhq = [(0, 0)] # (distance, node)\ndist[0] = 0\nwhile hq:\n    cost, node = heappop(hq)\n    if cost > dist[node]:\n        continue\n    for next, cost in edges[node]:\n        if dist[node] + cost < dist[next]:\n            dist[next] = dist[node] + cost\n            heappush(hq, (dist[next], next))\n\n# print(dist)\nprint(dist[1])", "def resolve():\n    import sys\n    input = sys.stdin.readline\n\n    import heapq\n    def dijkstra_heap(s,g,edge):\n        #\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n        d = [10**20] * (n+2)\n        used = [True] * (n+2) #True:\u672a\u78ba\u5b9a\n        d[s] = 0\n        used[s] = False\n        edgelist = []\n        sx,sy,sr=edge[s][0],edge[s][1],edge[s][2]\n        for i in range(n+2):\n            x,y,r=edge[i][0],edge[i][1],edge[i][2]\n            dist=((x-sx)**2+(y-sy)**2)**(1/2)\n            heapq.heappush(edgelist,(max(dist-r-sr,0),i))\n        while len(edgelist):\n            minedge = heapq.heappop(edgelist)\n            #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n            v = minedge[1]\n            if not used[v]:\n                continue\n            d[v] = minedge[0]\n            used[v] = False\n            bx,by,br=edge[v][0],edge[v][1],edge[v][2]\n            for i in range(n+2):\n                x,y,r=edge[i][0],edge[i][1],edge[i][2]\n                dist=((x-bx)**2+(y-by)**2)**(1/2)\n                if used[i]:\n                    heapq.heappush(edgelist,(max(dist-r-br,0)+d[v],i))\n            if not used[g]:\n                break\n        return d[g]\n\n    sx,sy,gx,gy = map(int,input().split()) #n:\u9802\u70b9\u6570\u3000w:\u8fba\u306e\u6570\n    n=int(input())\n    edge=[(sx,sy,0),(gx,gy,0)]\n    for i in range(2,n+2):\n        x,y,r=map(int,input().split())\n        edge.append((x,y,r))\n    print(dijkstra_heap(0,1,edge))\n\ndef __starting_point():\n    resolve()\n__starting_point()", "from math import dist\nfrom scipy.sparse.csgraph import dijkstra, csgraph_from_dense\nfrom numpy import full, inf\nfrom itertools import combinations\n\nsx, sy, tx, ty, N, *XYR = map(int, open(0).read().split())\n\nA = [(sx, sy, 0), (tx, ty, 0)] + list(zip(*[iter(XYR)] * 3))\n\nD = full((N + 2, N + 2), inf)\nfor (i, (ax, ay, ad)), (j, (bx, by, bd)) in combinations(enumerate(A), 2):\n    D[i][j] = max(\n        0,\n        dist((ax, ay), (bx, by)) - ad - bd\n    )\n\nprint(dijkstra(csgraph_from_dense(D, null_value=inf), False, 0)[1])", "from heapq import heappush,heappop\nxs,ys,xt,yt = map(int,input().split())\nn = int(input())\nXY = [list(map(int,input().split())) for i in range(n)]\nXY.append([xs,ys,0])\nXY.append([xt,yt,0])\n\ne = [[10**15]*(n+2) for i in range(n+2)]\nfor i in range(n+1):\n    for j in range(i+1,n+2):\n        xi,yi,ri = XY[i]\n        xj,yj,rj = XY[j]\n        dif = max(0.0,((xi-xj)**2+(yi-yj)**2)**0.5-ri-rj)\n        e[i][j] = e[j][i] = dif\n\nh = []\nheappush(h,(0,n))\ndis = [10**15]*(n+2)\ndis[n] = 0\nwhile h:\n    cost,now = heappop(h)\n    if cost > dis[now]:\n        continue\n    for nex,dif in enumerate(e[now]):\n        if dis[nex] > dis[now]+dif:\n            dis[nex] = dis[now]+dif\n            heappush(h,(dis[nex],nex))\nprint(dis[-1])", "from struct import pack, unpack\nimport math\nfrom heapq import heapify, heappush as hpush, heappop as hpop\nxs, ys, xt, yt = map(int, input().split())\nN = int(input())\nX = [(xs, ys, 0), (xt, yt, 0)]\nfor _ in range(N):\n    x, y, r = map(int, input().split())\n    X.append((x, y, r))\n\nN += 2\nDD = [[0] * N for _ in range(N)]\nfor i in range(N):\n    xi, yi, ri = X[i]\n    for j in range(N):\n        xj, yj, rj = X[j]\n        DD[i][j] = max(math.sqrt((xi-xj)**2 + (yi-yj)**2) - (ri+rj), 0)\n\ndef dijkstra(n, E, i0=0):\n    D = [1 << 40] * n\n    D[i0] = 0\n    Q = set([i for i in range(n)])\n    while Q:\n        d = 1 << 40\n        for q in Q:\n            if D[q] < d:\n                i = q\n                d = D[q]\n        Q.remove(i)\n        for j, w in enumerate(DD[i]):\n            if j == i: continue\n            nd = d + w\n            if D[j] > nd:\n                D[j] = nd\n    return D\n\nprint(dijkstra(N, X)[1])", "a,b,c,d=map(int, input().split())\nN=int(input())\ndef dijkstra(s,n,w,cost):\n    #\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    #n:\u9802\u70b9\u6570,\u3000w:\u8fba\u306e\u6570, cost[u][v] : \u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\n    d = [float(\"inf\")] * n\n    used = [False] * n\n    d[s] = 0\n    \n    while True:\n        v = -1\n        #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n        for i in range(n):\n            if (not used[i]) and (v == -1):\n               v = i\n            elif (not used[i]) and d[i] < d[v]:\n                v = i\n        if v == -1:\n               break\n        used[v] = True\n               \n        for j in range(n):\n               d[j] = min(d[j],d[v]+cost[v][j])\n    return d\nR=[0]*(N+2)\nA=[]\nfor i in range(N):\n  x,y,r=map(int, input().split())\n  A.append((x,y))\n  R[i]=r\nA.append((a,b))\nA.append((c,d))\ncost=[[float('inf') for i in range(N+2)] for i in range(N+2)]\nfor i in range(N+1):\n  for j in range(i+1,N+2):\n    d=(A[i][0]-A[j][0])**2+(A[i][1]-A[j][1])**2\n    cost[i][j]=max(0,d**0.5-(R[i]+R[j]))\n    cost[j][i]=max(0,d**0.5-(R[i]+R[j]))\nD=dijkstra(N,N+2,(N+2)*(N+1)//2,cost)\nprint(D[N+1])", "from heapq import heappush,heappop\nxs,ys,xt,yt = map(int,input().split())\nn = int(input())\nXY = [list(map(int,input().split())) for i in range(n)]\nXY.append([xs,ys,0])\nXY.append([xt,yt,0])\ninf = 10**14\ne = [[inf]*(n+2) for i in range(n+2)]\nfor i in range(n+1):\n    for j in range(i+1,n+2):\n        xi,yi,ri = XY[i]\n        xj,yj,rj = XY[j]\n        dif = max(0,((xi-xj)**2+(yi-yj)**2)**0.5-ri-rj)\n        e[i][j] = e[j][i] = dif\n\nh = []\nheappush(h,(0,n))\ndis = [inf]*(n+2)\ndis[n] = 0\nwhile h:\n    cost,now = heappop(h)\n    if cost > dis[now]:\n        continue\n    for nex,dif in enumerate(e[now]):\n        if dis[nex] > dis[now]+dif:\n            dis[nex] = dis[now]+dif\n            heappush(h,(dis[nex],nex))\nprint(dis[-1])", "#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n#R = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\n#import math,heapq\nfrom math import sqrt\nfrom heapq import heappush,heappop\n\ndef pdist(x1,y1,x2,y2):\n    return sqrt((x2-x1)**2+(y2-y1)**2)\n\nxs,ys,xt,yt = inm()\nn = inn()\ncir = []\nfor i in range(n):\n    x,y,r = inm()\n    cir.append((x,y,r))\ndst = [[0]*(n+2) for i in range(n+2)]\ndst[n][n+1] = dst[n+1][n] = pdist(xs,ys,xt,yt)\nfor i in range(n):\n    x,y,r = cir[i]\n    dst[n][i] = dst[i][n] = max(0.0,pdist(xs,ys,x,y)-r)\n    dst[n+1][i] = dst[i][n+1] = max(0.0,pdist(xt,yt,x,y)-r)\n    for j in range(i+1,n):\n        xx,yy,rr = cir[j]\n        dst[j][i] = dst[i][j] = \\\n          max(0.0,pdist(xx,yy,x,y)-rr-r)\n\nif False and DBG:\n    for i in range(n+2):\n        ddprint(dst[i])\n\ncost = [float(BIG)]*(n+2)\nq = [(0.0,n)]\nwhile len(q)>0:\n    d,p = heappop(q)\n    #ddprint(f\"{d=} {p=}\")\n    if cost[p]<=d:\n        continue\n    cost[p] = d\n    for v in range(n+2):\n        newdist = d+dst[p][v]\n        if v!=p and newdist<cost[v]:\n            heappush(q,(newdist, v))\n\nprint(cost[n+1])\n", "from heapq import heapify,heappop,heappush\nimport sys\nimport math\n\ninput = sys.stdin.readline\n\nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\n\nA = [(xs,ys,0)]\nfor i in range(N):\n  A.append(tuple(map(int, input().split()))) # x, y, r = map(int, input().split())\nA.append((xt,yt,0)) \n\ntask = [[0.,0]]\nheapify(task)\nvisited = set()\nwhile task:\n  #print(task)\n  while task:\n    c, p = heappop(task)\n    if p not in visited:\n      break\n    if not task:\n      print(\"error\")\n      return\n  if p == N+1:\n    print(c)\n    return\n     \n  visited.add(p)\n  xp, yp, rp = A[p] \n  \n  for q in range(N+2):\n    if q not in visited:\n      xq, yq, rq = A[q]\n      l = max(0.,math.sqrt((xq - xp)**2 + (yq - yp)**2)-rq-rp)\n      heappush(task,[c+l, q])\n  \n  \n    \n    \n      \n  \n  \n", "from math import sqrt\nimport heapq\n\ndef calc(arr, i, j):\n    d = sqrt((arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2)\n    if arr[i][2] + arr[j][2] <= d:\n        return d - arr[i][2] - arr[j][2]\n    else:\n        return 0\n\ndef main():\n    xs, ys, xt, yt = map(int, input().split())\n    n = int(input())\n    arr = [list(map(int, input().split())) for _ in range(n)]\n    arr.append([xs, ys, 0])\n    arr.append([xt, yt, 0])\n    n += 2\n    st = set()\n    for i in range(n):\n        st.add(i)\n    dist = [float(\"inf\")]*n\n    dist[n-2] = 0\n    dist[n-1] = calc(arr, n-2, n-1)\n    hq = []\n    heapq.heappush(hq, [0, n-2])\n    while len(hq) > 0:\n        _, p = heapq.heappop(hq)\n        if p in st:\n            st.remove(p)\n            for nxt in st:\n                d = calc(arr, p, nxt)\n                if dist[nxt] > dist[p] + d:\n                    dist[nxt] = dist[p] + d\n                    heapq.heappush(hq, [dist[nxt], nxt])\n    print(dist[-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import *\n\nsx, sy, tx, ty = list(map(int, input().split()))\nN = int(input())\ncircles = [tuple(map(int, input().split())) for _ in range(N)]\n\ns = N\nt = N + 1\nadj_matrix = [[0] * (N + 2) for _ in range(N + 2)]\nadj_matrix[s][t] = adj_matrix[t][s] = ((tx-sx)**2 + (ty-sy)**2 )** 0.5 \nfor v, (x, y, r) in enumerate(circles):\n    adj_matrix[s][v] = adj_matrix[v][s] = max(0, ((x-sx)**2 + (y-sy)**2) ** 0.5 - r)\n    adj_matrix[t][v] = adj_matrix[v][t] = max(0, ((x-tx)**2 + (y-ty)**2)** 0.5 - r)\n    \nfor v1, (x1, y1, r1) in enumerate(circles):\n    for v2, (x2, y2, r2) in enumerate(circles[v1+1:], start=v1+1):\n        adj_matrix[v1][v2] = adj_matrix[v2][v1] = max(0, ( ((x1-x2)**2 + (y1-y2)**2)**0.5 - r1 - r2))\n\ndp = [float('inf')] * (N + 2)\ndp[t] = 0\nvis = [False] * (N + 2)\npq = [(0, t)]\nwhile pq:\n    cost, v = heappop(pq)\n    if vis[v]:\n        continue\n    vis[v] = True\n    for nv, dist in enumerate(adj_matrix[v]):\n        if dp[nv] > cost + dist:\n            dp[nv] = cost + dist\n            heappush(pq, (dp[nv], nv))\n\n# print(dp)\nprint((dp[s]))\n", "def main():\n    from math import hypot\n    import sys\n    input = sys.stdin.readline\n\n    inf = 1 << 60\n\n    xs, ys, xt, yt = list(map(int, input().split()))\n    N = int(input())\n\n    def dist(p1, p2):\n        d = hypot(p1[0] - p2[0], p1[1] - p2[1])\n        return max(0, d - (p1[2] + p2[2]))\n\n    ps = [(xs, ys, 0)]\n    ps += (tuple(map(int, input().split())) for _ in range(N))\n    ps += [(xt, yt, 0)]\n\n    adj = [[inf] * (N + 2) for _ in range(N + 2)]\n\n    for i, p1 in enumerate(ps):\n        for j, p2 in enumerate(ps):\n            if i <= j: break  # \u81ea\u5df1\u8fba\u306a\u3057\n            adj[i][j] = adj[j][i] = dist(p1, p2)\n\n    def dijkstra(s):\n        dist = [inf] * (N + 2)\n        dist[s] = 0\n        det = [0] * (N + 2)\n\n        c, v = 0, s\n        det[s] = 1\n        while True:\n            for u, dc in enumerate(adj[v]):\n                nc = c + dc\n                if dist[u] <= nc: continue\n                dist[u] = nc\n\n            c, v = -1, -1\n            for u, d in enumerate(dist):\n                if det[u]: continue\n                if ~v and c <= d: continue\n                c, v = d, u\n            if not (~v): break\n            det[v] = 1\n\n        return dist\n\n    print((dijkstra(s=0)[N + 1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    INF = 10 ** 10\n\n    from math import sqrt\n\n    xs, ys, xg, yg = map(int, input().split())\n\n    N = int(input())\n    XYR = [tuple(map(int, input().split())) for _ in range(N)]\n\n    G = [[] for _ in range(N + 2)]\n\n    def diff1(i, j):\n        tmp = (XYR[i][0] - XYR[j][0]) ** 2 + (XYR[i][1] - XYR[j][1]) ** 2\n        R = XYR[i][2] + XYR[j][2]\n        return max(0, sqrt(tmp) - R)\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            tmp = diff1(i, j)\n            G[i].append((tmp, j))\n            G[j].append((tmp, i))\n\n    def diff2(x, y, i):\n        tmp = (x - XYR[i][0]) ** 2 + (y - XYR[i][1]) ** 2\n        R = XYR[i][2]\n        return max(0, sqrt(tmp) - R)\n\n    for i in range(N):\n        tmp = diff2(xs, ys, i)\n        G[N].append((tmp, i))\n        G[i].append((tmp, N))\n\n\n    for i in range(N):\n        tmp = diff2(xg, yg, i)\n        G[N + 1].append((tmp, i))\n        G[i].append((tmp, N + 1))\n\n    tmp = (xs - xg) ** 2 + (ys - yg) ** 2\n    G[N].append((sqrt(tmp), N + 1))\n    G[N + 1].append((sqrt(tmp), N))\n\n    d = [INF] * (N + 2) #\u9802\u70b9s\u304b\u3089\u306e\u8ddd\u96e2\n\n    def dijksrea(s): #\u59cb\u70b9s\n        from heapq import heappop, heappush\n        d[s] = 0 #\u59cb\u70b9\u306e\u8ddd\u96e2\u30920\u306b\u3059\u308b\n        pque = []\n        heappush(pque, (0, s)) #\u8981\u7d20\u3092[\u8ddd\u96e2\u3001\u9802\u70b9]\u3068\u3057\u3066\u7ba1\u7406\u3000\u6700\u521d\u306e\u4f4d\u7f6e\u3092\u5165\u308c\u308b\n\n        while pque: #que\u306e\u4e2d\u306b\u8981\u7d20\u304c\u6b8b\u3063\u3066\u3044\u308b\u6642\n            p = heappop(pque) #\u6700\u3082\u8ddd\u96e2\u304c\u77ed\u3044\u3082\u306e\u3092\u53d6\u308a\u51fa\u3059\n            v = p[1] #\u8ddd\u96e2\u304c\u6700\u3082\u77ed\u3044\u9802\u70b9\n            if d[v] < p[0]: #\u53d6\u308a\u51fa\u3057\u305f\u5024\u3088\u308a\u65e2\u306b\u5c0f\u3055\u3044\u5024\u304cd\u306b\u5165\u3063\u3066\u3044\u308b\u3068\u304d\u306f\u7121\u8996\u3057\u3066\u6b21\u3078\n                continue\n            for i in range(len(G[v])): #\u9802\u70b9v\u306e\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u8d70\u67fb\n                e = G[v][i]\n                if d[e[1]] > d[v] + e[0]: #\u8ddd\u96e2\u304c\u66f4\u65b0\u3067\u304d\u308b\u304b\u3092\u691c\u8a0e\n                    d[e[1]] = d[v] + e[0]\n                    heappush(pque, (d[e[1]], e[1])) #\u66f4\u65b0\u3067\u304d\u305f\u5834\u5408\u3001\u305d\u306e\u5024\u3092pque\u306b\u5165\u308c\u308b\n\n    dijksrea(N)\n    print (d[N + 1])\n\n    # print (d)\n\ndef __starting_point():\n    main()\n__starting_point()", "# Cosmic rays\nimport math\nimport heapq\n\nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\n\nd = [((xs, ys), 0, 0)]\n# node,radius\n\nfor _ in range(N):\n    x, y, r = list(map(int, input().split()))\n    d.append(((x, y), _+1, r))\n\ngraph = {i: [] for i in range(N+2)}\n\nd.append(((xt, yt), N+1, 0))\nfor i in range(N+2):\n    for j in range(i+1, N+2):\n        p, point, rad = d[i]\n        q, point2, rad2 = d[j]\n        D = math.hypot(p[0]-q[0], p[1]-q[1])\n        if D > (rad+rad2):\n            graph[i].append((D-rad-rad2, j))\n            graph[j].append((D-rad-rad2, i))\n        else:\n            graph[i].append((0, j))\n            graph[j].append((0, i))\n\n\ndef dijkstra(s, graph):\n    n = len(graph)\n    dist = [float(\"inf\") for i in range(n+1)]\n    dist[s] = 0\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (0, s))\n    while pq:\n        mini_dis, node = heapq.heappop(pq)\n        if dist[node] < mini_dis:\n            continue\n        for w, point in graph[node]:\n            if dist[point] < w:\n                continue\n            newlen = dist[node]+w\n            if newlen < dist[point]:\n                heapq.heappush(pq, (newlen, point))\n                dist[point] = newlen\n    return dist\n\nK=dijkstra(0,graph)[N+1]\nprint(K)\n", "from heapq import heappop, heappush, heapify\nfrom collections import deque\n\nclass Graph():  #non-directed\n    def __init__(self, n, edge, indexed=1):\n        self.n = n\n        self.edge = edge\n        self.indexed = indexed\n        self.graph = [[] for _ in range(n)]\n        for e in edge:\n            self.graph[e[0] - indexed].append((e[1] - indexed, e[2]))\n            self.graph[e[1] - indexed].append((e[0] - indexed, e[2]))\n\n    def dijkstra(self, s, INF=10**18, restore_to=None):\n        dist = [INF for _ in range(self.n)]\n        dist[s] = 0\n        heap = [(0, s)]\n        prev = [None for _ in range(self.n)]\n        while heap:\n            cost, node = heappop(heap)\n            if dist[node] < cost:\n                continue\n            for adj, adjcost in self.graph[node]:\n                if dist[node] + adjcost < dist[adj]:\n                    dist[adj] = dist[node] + adjcost\n                    prev[adj] = node\n                    heappush(heap, (dist[adj], adj))\n        if restore_to is not None:\n            g = restore_to\n            if dist[g] == INF:\n                return dist, False\n            path = [g]\n            node = g\n            while node != s:\n                node = prev[node]\n                path.append(node)\n            return dist, path[::-1]\n        return dist\n\ndef dist(p, q):\n    px, py = p\n    qx, qy = q\n    return ((px - qx)**2 + (py - qy)**2)**0.5\n\nxs, ys, xt, yt = map(int, input().split())\ns = (xs, ys)\nt = (xt, yt)\n\nN = int(input())\n\nbarrier = [tuple(map(int, input().split())) for _ in range(N)]\nedge = []\n\nedge.append((0, N + 1, dist(s, t)))\n\nfor i in range(N):\n    xi, yi, ri = barrier[i]\n    pi = (xi, yi)\n    d = max(dist(s, pi) - ri, 0)\n    edge.append((0, i + 1, d))\n\nfor i in range(N):\n    xi, yi, ri = barrier[i]\n    pi = (xi, yi)\n    d = max(dist(t, pi) - ri, 0)\n    edge.append((N + 1, i + 1, d))\n\nfor i in range(N - 1):\n    for j in range(i + 1, N):\n        xi, yi, ri = barrier[i]\n        xj, yj, rj = barrier[j]\n        pi = (xi, yi)\n        pj = (xj, yj)\n        d = max(dist(pi, pj) - ri - rj, 0)\n        edge.append((i + 1, j + 1, d))\n\ng = Graph(N + 2, edge, 0)\n\nprint(g.dijkstra(0)[N + 1])", "from heapq import heappush,heappop\nxs,ys,xt,yt = map(int,input().split())\nn = int(input())\nXY = [list(map(int,input().split())) for i in range(n)]\nXY.append([xs,ys,0])\nXY.append([xt,yt,0])\n\ne = [[9999999999]*(n+2) for i in range(n+2)]\nfor i in range(n+1):\n    for j in range(i+1,n+2):\n        xi,yi,ri = XY[i]\n        xj,yj,rj = XY[j]\n        dif = max(0.0,((xi-xj)**2+(yi-yj)**2)**0.5-ri-rj)\n        e[i][j] = e[j][i] = dif\n\nh = []\nheappush(h,(0,n))\ndis = [float(\"INF\")]*(n+2)\ndis[n] = 0\nwhile h:\n    cost,now = heappop(h)\n    if cost > dis[now]:\n        continue\n    for nex,dif in enumerate(e[now]):\n        if dis[nex] > dis[now]+dif:\n            dis[nex] = dis[now]+dif\n            heappush(h,(dis[nex],nex))\nprint(dis[-1])", "from scipy.sparse.csgraph import csgraph_from_dense,dijkstra\nxs,ys,xt,yt = map(int,input().split())\nN=int(input())\nxyr = [tuple(map(int,input().split())) for _ in range(N)]\nxyr.append((xs,ys,0))\nxyr.append((xt,yt,0))\nb = [[-1]*(N+2) for _ in range(N+2)]\nfor i in range(N+2):\n    x1, y1, r1 = xyr[i]\n    for j in range(i+1,N+2):\n        x2,y2,r2 = xyr[j]\n        r = max(0, ((x1-x2)**2+(y1-y2)**2)**0.5-(r1+r2))\n        b[i][j] = r\n        b[j][i] = r\nGraph = csgraph_from_dense(b, null_value=-1)\nstart = N\nend = N+1\nprint(dijkstra(Graph, indices=start)[end])", "import sys\nimport heapq\nmy_input = sys.stdin.readline\n\ndef main():\n    xs, ys, xt, yt = list(map(int, my_input().split()))\n    N = int(my_input())\n    C = [(xs, ys, 0), (xt, yt, 0)]\n    C += [tuple(map(int, my_input().split())) for i in range(N)]\n\n    G = [[] for i in range(N+2)]\n    for i in range(N + 2):\n        for j in range(i + 1, N + 2):\n            cost = max(0, ((C[i][0] - C[j][0]) ** 2 + (C[i][1] - C[j][1]) ** 2) ** 0.5 - (C[i][2] + C[j][2]))\n            G[i].append((j, cost))\n            G[j].append((i, cost))\n\n\n    def dijkstra(graph, start, inf=float('inf')):\n        import heapq\n        n = len(graph)\n        distances = [inf] * n\n        distances[start] = 0\n        visited = [False] * n\n\n        # \u8ddd\u96e2\u30fb\u9802\u70b9\n        hq = [(0, start)]\n        while hq:\n            dist, fr = heapq.heappop(hq)\n            visited[fr] = True\n            if distances[fr] < dist:\n                continue\n            if fr == 1:\n                return distances\n\n\n            for to, cost in graph[fr]:\n                new_dist = distances[fr] + cost\n                if (visited[to]) or (distances[to] <= new_dist):\n                    continue\n\n                distances[to] = new_dist\n                heapq.heappush(hq, (new_dist, to))\n\n        return distances\n\n\n    dist = dijkstra(G, 0)\n    print((dist[1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nxs,ys,xt,yt = list(map(int, input().split()))\nn = int(input())\nxyr = [None]*(n+2)\nfor i in range(n):\n    xyr[i] = tuple(map(int, input().split()))\nfrom itertools import product\nns = [[] for _ in range(n+2)]\ns = n\nt = n+1\nxyr[s] = (xs,ys,0)\nxyr[t] = (xt,yt,0)\nfor i,j in product(list(range(n+2)), list(range(n+2))):\n    if i<j:\n        d = max(0, ((xyr[i][0]-xyr[j][0])**2 + (xyr[i][1]-xyr[j][1])**2)**0.5 - (xyr[i][2]+xyr[j][2]))\n        ns[i].append((d,j))\n        ns[j].append((d,i))\ndef dijkstra(start):\n    import heapq\n    vals = [None] * (n+2)\n    h = [(0, start)] # (\u8ddd\u96e2, \u30ce\u30fc\u30c9\u756a\u53f7)\n    vals[start] = 0\n    while h:\n        val, u = heapq.heappop(h)\n        if u==t:\n            break\n        if val>vals[u]:\n          continue\n        for d, v in ns[u]:\n            if vals[v] is None or vals[v]>val+d:\n                vals[v] = val+d\n                heapq.heappush(h, (vals[v], v))\n    return vals\nvals = dijkstra(s)\nans = vals[t]\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nimport heapq\n\ndef dijkstra(n, s, edges):\n    hq = [(0, s)]\n    cost = [float('inf')] * n\n    cost[s] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v]:\n            continue\n        for d, u in edges[v]:\n            tmp = d + cost[v]\n            if tmp < cost[u]:\n                cost[u] = tmp\n                heapq.heappush(hq, (tmp, u))\n    return cost[-1]\n\ndef main():\n    xs, ys, xt, yt = map(int, input().split())\n    n = int(input())\n    circles = []\n    circles.append([xs, ys, 0])\n    for _ in range(n):\n        circles.append(list(map(int, input().split())))\n    circles.append([xt, yt, 0])\n    edges = [[] for _ in range(n + 2)]\n    for i in range(n + 2):\n        for j in range(i + 1, n + 2):\n            dx = circles[i][0] - circles[j][0]\n            dy = circles[i][1] - circles[j][1]\n            d = (dx ** 2 + dy ** 2) ** 0.5\n            r = circles[i][2] + circles[j][2]\n            edges[i].append([max(0, d - r), j])\n            edges[j].append([max(0, d - r), i])\n\n    ans = dijkstra(n + 2, 0, edges)\n    print(ans)\n    \nmain()", "xs,ys,xt,yt=list(map(int,input().split()))\nN=int(input())\nXY=[tuple(map(int,input().split())) for i in range(N)]\nD=[[0]*(N+2) for i in range(N+2)]\nXY.append((xs,ys,0))\nXY.append((xt,yt,0))\n\n\nfor i in range(N+1):\n  x1,y1,r1=XY[i]\n  for j in range(i+1,N+2):\n    x2,y2,r2=XY[j]\n    d = (x1-x2)**2 + (y1-y2)**2\n    d = d **(0.5)\n    D[i][j] = max(0,d-r1-r2)\n    D[j][i]=D[i][j]\nimport heapq\nhq=[]\nhq.append((0,N))\ns=set([i for i in range(N+2)])\n\nwhile(hq):\n  \n  c,x=heapq.heappop(hq)\n  if x==N+1:\n    print(c)\n    return\n  if x in s:\n    \n    s.remove(x)\n  else:\n    continue\n  for i in s:\n    heapq.heappush(hq,(c+D[x][i],i))\n  \n  \n", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\nxs, ys, xt, yt = map(int, input().split())\nN = int(input())\nxyr = [list(map(int, input().split())) for i in range(N)]\n\ndef dist(x1, y1, x2, y2):\n  return ((x1-x2)**2 + (y1-y2)**2)**0.5\n\nrow = [0]\ncol = [1]\ndata = [dist(xs, ys, xt, yt)]\nfor i, (xi, yi, ri) in enumerate(xyr, 2):\n  d1 = max(0, dist(xi, yi, xs, ys) - ri)\n  d2 = max(0, dist(xi, yi, xt, yt) - ri)\n  row.extend([0, 1])\n  col.extend([i, i])\n  data.extend([d1, d2])\n  for j in range(i-1, N):\n    xj, yj, rj = xyr[j]\n    dij = max(0, dist(xi, yi, xj, yj) - ri - rj)\n    row.append(i)\n    col.append(j+2)\n    data.append(dij)\n\ngraph = csr_matrix((data, (row, col)), shape=(N+2, N+2))\ndist = dijkstra(graph, directed=False, indices=0)\nprint(dist[1])", "from scipy.sparse.csgraph import csgraph_from_dense, dijkstra\nimport numpy as np\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    x_s, y_s, x_t, y_t = list(map(int, readline().split()))\n    A = np.array([[x_s, y_s, 0],\n                  [x_t, y_t, 0]], dtype=np.int)\n    \n    N = int(readline())\n    B = np.array(read().split(), dtype=np.int).reshape(-1, 3)\n    XY, R = np.hsplit(np.concatenate((A, B)), [2])\n    \n    d = np.expand_dims(XY, axis=1) - np.expand_dims(XY, axis=0)\n    d = np.sqrt(np.sum(np.square(d), axis=-1))\n    d -= R + R.reshape(1, -1)\n    d = np.maximum(d, 0)\n    np.fill_diagonal(d, -1)\n    d = csgraph_from_dense(d, null_value=-1)\n     \n    ans = dijkstra(d, indices=0)[1]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "xs,yx,xt,yt = map(int,input().split())\nN = int(input())\nl = [[],[xs,yx,0],[xt,yt,0]]\nfor i in range(N):\n  l.append(list(map(int,input().split())))\n##\u8ddd\u96e2\u30ea\u30b9\u30c8\nd = [[0]*(N+3) for _ in range(N+3)]\nfor i in range(1,N+3):\n  d[i][i] = 0\n#O(10**6)\nfor i in range(1,N+3):\n  for j in range(i+1,N+3):\n    sa = (l[i][0]-l[j][0])**2 + (l[i][1]-l[j][1])**2\n    kyori = max(0,sa**(1/2)-l[i][2]-l[j][2])\n    d[i][j] = kyori\n    d[j][i] = kyori\n\nmd = [float(\"inf\")]*(N+3)\nh = [i for i in range(1,N+3)]\nfor i in range(1,N+3):\n  md[i]=d[1][i]\nseen = [False]*(N+3)\nseen[1] = True\nwhile True:\n  #v\u3092\u51fa\u3059\n  v = -1\n  for i in h:\n    if seen[i] == False and v == -1:\n      v = i\n    elif seen[i] == False and md[i] < md[v]:\n      v = i\n  if v == -1:\n    break\n  seen[v] = True\n  for j in range(1,N+3):\n    md[j] = min(md[j],md[v]+d[v][j])\nprint(md[2])      ", "from heapq import heappush,heappop\nxs,ys,xt,yt = map(int,input().split())\nn = int(input())\nXY = [list(map(int,input().split())) for i in range(n)]\nXY.append([xs,ys,0])\nXY.append([xt,yt,0])\ninf = 10**14\ne = [[inf]*(n+2) for i in range(n+2)]\nfor i in range(n+1):\n    for j in range(i+1,n+2):\n        xi,yi,ri = XY[i]\n        xj,yj,rj = XY[j]\n        dif = max(0.0,((xi-xj)**2+(yi-yj)**2)**0.5-ri-rj)\n        e[i][j] = e[j][i] = dif\n\nh = []\nheappush(h,(0,n))\ndis = [inf]*(n+2)\ndis[n] = 0\nwhile h:\n    cost,now = heappop(h)\n    if cost > dis[now]:\n        continue\n    for nex,dif in enumerate(e[now]):\n        if dis[nex] > dis[now]+dif:\n            dis[nex] = dis[now]+dif\n            heappush(h,(dis[nex],nex))\nprint(dis[-1])", "import heapq\n\nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\nXYR = [list(map(int, input().split())) for i in range(N)]\nXYR.append([xs, ys, 0])\nXYR.append([xt, yt, 0])\nL = [[9999999999]*(N+2) for i in range(N+2)]\nfor i in range(N+2):\n    for j in range(i, N+2):\n        x1, y1, r1 = XYR[i]\n        x2, y2, r2 = XYR[j]\n        L[i][j] = L[j][i] = max(((x1-x2)**2+(y1-y2)**2)**0.5-r1-r2, 0.0)\n\n\n# \u8a08\u7b97\u91cf O((E+V)logV)\nnum = N+2  # \u30b0\u30e9\u30d5\u306e\u30ce\u30fc\u30c9\u6570\nstart = num-2\n\ndistance = [float('inf') for i in range(num)]  # \u59cb\u70b9\u304b\u3089\u5404\u9802\u70b9\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u683c\u7d0d\u3059\u308b\nprev = [float('inf') for i in range(num)]  # \u6700\u77ed\u7d4c\u8def\u306b\u304a\u3051\u308b\uff0c\u305d\u306e\u9802\u70b9\u306e\u524d\u306e\u9802\u70b9\u306eID\u3092\u683c\u7d0d\u3059\u308b\ndistance[start] = 0\nq = []  # \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\uff0e\u5404\u8981\u7d20\u306f\uff0c(start\u304b\u3089\u3042\u308b\u9802\u70b9v\u307e\u3067\u306e\u4eee\u306e\u8ddd\u96e2, \u9802\u70b9v\u306eID)\u304b\u3089\u306a\u308b\u30bf\u30d7\u30eb\nheapq.heappush(q, (0, start))  # \u59cb\u70b9\u3092push\n\nwhile len(q) != 0:\n    prov_cost, src = heapq.heappop(q)  # pop\n\n    # \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u6700\u77ed\u8ddd\u96e2\u304c\uff0c\u73fe\u5728\u8a08\u7b97\u3067\u304d\u3066\u3044\u308b\u6700\u77ed\u8ddd\u96e2\u3088\u308a\u5927\u304d\u3051\u308c\u3070\uff0cdist\u306e\u66f4\u65b0\u3092\u3059\u308b\u5fc5\u8981\u306f\u306a\u3044\n    if distance[src] < prov_cost:\n        continue\n\n    # \u4ed6\u306e\u9802\u70b9\u306e\u63a2\u7d22\n    for destination, cost in enumerate(L[src]):\n        if distance[destination] > distance[src] + cost:\n            distance[destination] = distance[src] + cost  # dist\u306e\u66f4\u65b0\n            heapq.heappush(q, (distance[destination], destination))  # \u30ad\u30e5\u30fc\u306b\u65b0\u305f\u306a\u4eee\u306e\u8ddd\u96e2\u306e\u60c5\u5831\u3092push\n            prev[destination] = src  # \u524d\u306e\u9802\u70b9\u3092\u8a18\u9332\n\nprint((distance[-1]))\n", "from heapq import heapify, heappop, heappush\nxs,ys,xt,yt = map(int,input().split()); INF = float(\"inf\")\nN = int(input())\nZ = []\nfor i in range(N):\n  x,y,r = map(int,input().split())\n  Z.append((x,y,r,i)) #x,y,r,ID\nG = [[] for _ in range(N+2)]\nfor i in range(N):\n  dis = ((Z[i][0]-xs)**2 + (Z[i][1]-ys)**2)**0.5\n  dis -= Z[i][2]\n  dis = max(0,dis)\n  G[0].append((dis,i+1))\ndis = ((xt-xs)**2 + (yt-ys)**2)**0.5\nG[0].append((dis,N+1))\n              \nfor i in range(N):\n  for j in range(N):\n    if i == j:\n      continue\n    dis = ((Z[i][0]-Z[j][0])**2 + (Z[i][1]-Z[j][1])**2)**0.5\n    dis -= Z[i][2]+Z[j][2]\n    dis = max(0,dis)\n    G[i+1].append((dis,j+1)) #1index\n  dis = ((Z[i][0]-xt)**2 + (Z[i][1]-yt)**2)**0.5\n  dis -= Z[i][2]\n  dis = max(0,dis)\n  G[i+1].append((dis,N+1))\n#print(G)\n\ndef dijkstra_heap2(s,G):\n  #S:start, V: node, E: Edge, G: Graph\n  V = len(G)\n  d = [INF for _ in range(V)]\n  d[s] = 0\n  PQ = []\n  heappush(PQ,(0,s))\n  \n  while PQ:\n    c,v = heappop(PQ)\n    if d[v] < c:\n      continue\n    d[v] = c\n    for cost,u in G[v]:\n      if d[u] <= cost + d[v]:\n        continue\n      d[u] = cost + d[v]\n      heappush(PQ,(d[u], u))\n  \n  return d\n\nret = dijkstra_heap2(0,G)\n#print(ret)\nans = ret[N+1]\nprint(ans)", "import heapq\nfrom math import sqrt\ndef dijkstra(s, n, g): # s: start, n: |V|, g; glaph \n    INF = 10**18\n    d = [INF] * n\n    #-- record the prev vertex of each one for restoring the route --\n    # prev_vl = [-1]*n \n    d[s] = 0\n    que = [] # (a,b): a... shortest dist, b... v\n    heapq.heappush(que, (0, s))\n\n    while que:\n        dist, v = heapq.heappop(que)\n        if d[v] < dist: continue # if v has been already used -> continue\n        for next_v, cost in g[v]:\n            if d[next_v] > d[v] + cost:\n                d[next_v] = d[v] + cost\n                # prev_vl[next_v] = v\n                heapq.heappush(que, (d[next_v], next_v))\n\n    return d\n\n\n\nxs,ys,xg,yg = map(int, input().split())\nxyrl = []\nxyrl.append((xs,ys,0))\nxyrl.append((xg,yg,0))\nn = int(input())\nfor _ in range(n):\n    x,y,r = map(int, input().split())\n    xyrl.append((x,y,r))\n\ng = [[] for _ in range(n+2)]\nfor i in range(n+2):\n    for j in range(n+2):\n        if i == j: continue\n        x1,y1,r1 = xyrl[i]\n        x2,y2,r2 = xyrl[j]\n        d = sqrt( (x2-x1)**2 + (y2-y1)**2 )-r1-r2\n        if d < 0: d = 0\n        g[i].append((j,d))\n\ndists = dijkstra(0,n+2,g)\nprint(dists[1])", "from struct import pack, unpack\nimport math\nfrom heapq import heapify, heappush as hpush, heappop as hpop\nclass FibonacciHeap():\n    def __init__(self, mm):\n        self.inf = 1 << 100\n        self.mm = mm\n        self.roots = [[] for _ in range(mm)]\n        self.min = self.inf\n        self.minroot = None\n    \n    def add(self, v):\n        nd = self.node(v)\n        self.add_node(nd)\n        return nd\n    \n    def add_node(self, nd):\n        k = nd.order\n        if nd.value < self.min:\n            self.min = nd.value\n            self.minroot = nd\n        self.roots[k].append(nd)\n    \n    def setmin(self):\n        mi = self.inf\n        mirt = None\n        for i, rt in enumerate(self.roots):\n            while len(rt) >= 2:\n                nd1 = rt.pop()\n                nd2 = rt.pop()\n                self.roots[i+1].append(nd1.meld(nd2))\n            if len(rt) and rt[0].value < mi:\n                mi = rt[0].value\n                mirt = rt[0]\n        self.min = mi\n        self.minroot = mirt\n        return self.minroot\n    \n    def pop(self):\n        nd = self.minroot\n        mi = nd.value\n        self.roots[nd.order].remove(nd)\n        ch = nd.repChild\n        if ch:\n            nd = ch.right\n            while 1:\n                nnd = nd.right\n                self.add_node(nd)\n                l = nd.left\n                r = nd.right\n                if r != nd:\n                    nd.right = nd\n                    nd.left = nd\n                    l.right = r\n                    r.left = l\n                nd.parent = None\n                if nd == ch:\n                    break\n                nd = nnd\n        self.setmin()\n        return mi\n    class node():\n        def __init__(self, value):\n            self.parent = None\n            self.left = self\n            self.right = self\n            self.repChild = None\n            self.order = 0\n            self.marked = 0\n            self.value = value\n        \n        def meld(self, other):\n            if self.value > other.value:\n                return other.meld(self)\n            other.parent = self\n            if not self.repChild:\n                self.repChild = other\n            else:\n                l = self.repChild\n                r = l.right\n                l.right = other\n                r.left = other\n                other.left = l\n                other.right = r\n            self.order += 1\n            return self\n    \n    def movetop(self, nd):\n        p = nd.parent\n        nd.marked = 0\n        if not p: return nd\n        l = nd.left\n        r = nd.right\n        if r != nd:\n            p.repChild = r\n            nd.right = nd\n            nd.left = nd\n            l.right = r\n            r.left = l\n        else:\n            p.repChild = None\n        nd.parent = None\n        self.add_node(nd)\n        if not p.parent:\n            self.roots[p.order].remove(p)\n            p.order -= 1\n            self.add_node(p)\n        \n    def prioritize(self, nd, v):\n        p = nd.parent\n        nd.value = v\n        if v < self.min:\n            self.min = v\n            self.minroot = nd\n        if not p or p.value <= v:\n            return nd\n        self.movetop(nd)\n        nn = p\n        while nn.parent:\n            if nn.marked == 0:\n                nn.marked = 1\n                break\n            else:\n                p = nn.parent\n                self.movetop(nn)\n                nn = p\n        return nd\n            \n    def debug(self):\n        def _debug(nd):\n            if not nd: return \"\"\n            s = str(nd.value) + (\"(\" + str(nd.left.value) + \"-\" + str(nd.right.value) + \")\" if nd != nd.right else \"\")\n            if nd.repChild: s += \"[C=\" + str(nd.repChild.value) + \"]\"\n            if nd.parent: s += \"[P=\" + str(nd.parent.value) + \"]\"\n            if not nd.repChild: return s\n            ss = []\n            ch = nd.repChild\n            idch = id(ch)\n            nd = ch.right\n            while 1:\n                ss.append(_debug(nd))\n                if id(nd) == idch: break\n                nd = nd.right\n            s += \"[\" + \", \".join(map(str, ss)) + \"]\"\n            return s\n        RE = []\n        for i, root in enumerate(self.roots):\n            for nd in root:\n                if nd: RE.append(\"<\" + str(i) + \">\" + _debug(nd))\n        s = \"min=\" + str(self.min) + \" \"\n        print((s + \" - \".join(map(str, RE))))\n        \nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\nX = [(xs, ys, 0), (xt, yt, 0)]\nfor _ in range(N):\n    x, y, r = list(map(int, input().split()))\n    X.append((x, y, r))\n\nN += 2\nDD = [[0] * N for _ in range(N)]\nfor i in range(N):\n    xi, yi, ri = X[i]\n    for j in range(N):\n        xj, yj, rj = X[j]\n        DD[i][j] = max(math.sqrt((xi-xj)**2 + (yi-yj)**2) - (ri+rj), 0)\n\nm = 1023\ndef dijkstra(n, E, i0=0):\n    fb = FibonacciHeap(100)\n    inf = unpack(\"q\", pack(\"d\", 10 ** 10 / 1))[0]\n    D = [10 ** 10 / 1] * n\n    done = [0] * n\n    D[i0] = 0\n    V = []\n    for i in range(n):\n        v = (unpack(\"q\", pack(\"d\", (0.0 if i == i0 else 10 ** 10 / 1)))[0] | m) - (m - i)\n        V.append(fb.add(v))\n    while fb.minroot:\n        di = fb.pop()\n        d, i = unpack(\"d\", pack(\"q\", (di | m) - m))[0], di & m\n        done[i] = 1\n        for j, w in enumerate(DD[i]):\n            if done[j] or j == i: continue\n            nd = d + w\n            if D[j] > nd:\n                v = (unpack(\"q\", pack(\"d\", nd))[0] | m) - (m - j)\n                fb.prioritize(V[j], v)\n                D[j] = nd\n    return D\n\nprint((dijkstra(N, X)[1]))\n\n\n\n\n", "sx,sy,gx,gy = list(map(int,input().split()))\nN = int(input())\nzone = [list(map(int,input().split())) for i in range(N)]\n\nzone = [[sx,sy,0]] + zone + [[gx,gy,0]]\n\nG = [[0] * (N + 2) for i in range(N + 2)]\nfor i in range(len(zone) - 1):\n  for j in range(i + 1, len(zone)):\n    dist = ((zone[i][0] - zone[j][0]) ** 2 + (zone[i][1] - zone[j][1]) ** 2) ** 0.5\n    dist = max(0, dist - (zone[i][2] + zone[j][2]))\n    G[i][j] = dist\n    G[j][i] = dist\n\nimport heapq as hq\n# \u6d74\u3073\u305f\u8ddd\u96e2, \u9802\u70b9\nq = [(0, 0)]\nhq.heapify(q)\nseen = set()\nwhile q:\n  dist, v = hq.heappop(q)\n  if v in seen:\n    continue\n  seen.add(v)\n  if v == N + 1:\n    print(dist)\n    break\n  for i in range(len(G[v])):\n    if i in seen:\n      continue\n    hq.heappush(q, (dist + G[v][i], i))\n", "xs,ys,xe,ye=list(map(int,input().split()))\nn=int(input())\nxyr=[tuple(map(int,input().split())) for _ in range(n)]\nxyr.append((xs,ys,0))\nxyr.append((xe,ye,0))\nd=[[0]*(n+2) for _ in range(n+2)]\nfor i in range(n+1):\n  for j in range(i+1,n+2):\n    x,y,r=xyr[i]\n    nx,ny,nr=xyr[j]\n    tmp=((x-nx)**2+(y-ny)**2)**0.5\n    tmp-=r+nr\n    tmp=max(tmp,0)\n    d[i][j]=tmp\n    d[j][i]=tmp\n\n\n\ninf=float('inf')\nseen=[inf]*(n+2)\nseen[-2]=0\nmi=set(range(n+2))\n# n->n+1\nwhile mi:\n  min_idx=0\n  min_d=inf\n  for v in mi:\n    if min_d>seen[v]:\n      min_d=seen[v]\n      min_idx=v\n  v=min_idx\n  mi.discard(v)\n  if v==n+1:break\n  for nv in mi:\n    seen[nv]=min(seen[nv],seen[v]+d[v][nv])\nprint((seen[-1]))\n\n", "import heapq\n\nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\nXYR = [(xs, ys, 0), (xt, yt, 0)]\nfor _ in range(N):\n  XYR.append(tuple(map(int, input().split())))\n\nD = [[0]*(N+2) for _ in range(N+2)]\nfor i, (xi, yi, ri) in enumerate(XYR):\n  for j, (xj, yj, rj) in enumerate(XYR[:i]):\n    dx = xj - xi\n    dy = yj - yi\n    d = (dx*dx+dy*dy)**0.5\n    D[i][j] = D[j][i] = max(0, d-ri-rj)\n\nQ = [(0, 0)]\ndist = [-1]*(N+2)\nnvisited = 0\nwhile nvisited<N+2:\n  d, n = heapq.heappop(Q)\n  if dist[n] != -1: continue\n  dist[n] = d\n  nvisited += 1\n\n  for e, d_ne in enumerate(D[n]):\n    if dist[e] == -1:\n      heapq.heappush(Q, (d+d_ne, e))\n\nprint((dist[1]))\n", "from scipy.sparse.csgraph import csgraph_from_dense,dijkstra\n\nsx,sy,gx,gy=map(int,input().split())\nn=int(input())\narr=[[sx,sy,0]]+[list(map(int,input().split())) for _ in range(n)]+[[gx,gy,0]]\ng=[[-1]*(n+2) for _ in range(n+2)]\nfor i in range(n+2):\n  x1,y1,r1=arr[i]\n  for j in range(n+2):\n    x2,y2,r2=arr[j]\n    g[i][j]=max(0.0,((x1-x2)**2+(y1-y2)**2)**0.5-(r1+r2))\ng=csgraph_from_dense(g,null_value=-1)\nans=((sx-gx)**2+(sy-gy)**2)**0.5\nprint(min(ans,dijkstra(g,indices=0)[n+1]))", "xs,ys,xt,yt = list(map(int,input().split()))\nn = int(input())\n\nv = [(xs,ys,0),(xt,yt,0)]\nfor i in range(n):\n    x,y,r = list(map(int,input().split()))\n    v.append((x,y,r))\npath = [[] for i in range(n+2)]\nfor i in range(n+1):\n    for j in range(i+1,n+2):\n        l = max(0, ((v[i][0] - v[j][0])**2 + (v[i][1] - v[j][1])**2)**0.5 - v[i][2] - v[j][2])\n        path[i].append((j,l))\n        path[j].append((i,l))\n\nimport heapq\ndef Dijkstra(edge,start,v):\n    d = [float('inf')]*v\n    d[start] = 0\n    pq = [(0,start)]\n    heapq.heapify(pq)\n    while pq:\n        dist,p = heapq.heappop(pq)\n        if dist > d[p]:continue\n        for to,cost in edge[p]:\n            if d[to] <= dist + cost:continue\n            d[to] = dist + cost\n            heapq.heappush(pq, (d[to], to))\n    return d\n\nd = Dijkstra(path, 0, n+2)\nprint((d[1]))\n", "import sys\ninput = sys.stdin.readline\nimport heapq\n\ndef main():\n    xs, ys, xt, yt = map(int, input().split())\n    n = int(input())\n    \n    def dijkstra(s):\n        hq = [(0, s)]\n        cost = [float('inf')] * (n + 2)\n        cost[s] = 0\n        while hq:\n            c, v = heapq.heappop(hq)\n            if c > cost[v]:\n                continue\n            for d, u in edges[v]:\n                tmp = d + cost[v]\n                if tmp < cost[u]:\n                    cost[u] = tmp\n                    heapq.heappush(hq, (tmp, u))\n        return cost[-1]\n    \n    circles = []\n    circles.append([xs, ys, 0])\n    for _ in range(n):\n        circles.append(list(map(int, input().split())))\n    circles.append([xt, yt, 0])\n    edges = [[] for _ in range(n + 2)]\n    for i in range(n + 2):\n        for j in range(i + 1, n + 2):\n            dx = circles[i][0] - circles[j][0]\n            dy = circles[i][1] - circles[j][1]\n            d = (dx ** 2 + dy ** 2) ** 0.5\n            r = circles[i][2] + circles[j][2]\n            edges[i].append([max(0, d - r), j])\n            edges[j].append([max(0, d - r), i])\n\n    ans = dijkstra(0)\n    print(ans)\n    \nmain()", "from collections import defaultdict as dd\nfrom heapq import heappop, heappush\nimport math\nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\nCs = [list(map(int, input().split())) for _ in range(N)]\nCs.append([xs, ys, 0])\nCs.append([xt, yt, 0])\n\nEs = dd(dict)\nfor i in range(N+2):\n    xi, yi, ri = Cs[i]\n    for j in range(i+1, N+2):\n        xj, yj, rj = Cs[j]\n        Es[i][j] = Es[j][i] = max(0, math.sqrt((xi-xj)**2 + (yi-yj)**2) - ri - rj)\n\n# dists: sortest path\nINF = float('inf')\ndists = [INF] * (N+2)\ndists[N] = 0\n\n# dijk\nq = []\nclose = set()\nstart = N\nheappush(q, (0, start))\nwhile q:\n    d, node = heappop(q)\n    if dists[node] < d:\n        continue\n    close.add(node)\n    for to, c in list(Es[node].items()):\n        if to in close or dists[to] <= d + c:\n            continue\n        dists[to] = d + c\n        heappush(q, (dists[to], to))\nprint((dists[N+1]))\n", "import heapq\ndef dijkstra_heap(N,s,edge):\n    d = [float(\"inf\")] * N #\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    used = [False] * N\n    d[s] = 0\n    used[s] = True\n    edgelist = []\n    #edgelist : [s\u304b\u3089\u306e\u66ab\u5b9a(\u672a\u78ba\u5b9a)\u6700\u77ed\u8ddd\u96e2,\u9802\u70b9]\u306e\u30ea\u30b9\u30c8\n    #edge[s] : s\u304b\u3089\u51fa\u308b\u679d\u306e[\u91cd\u307f,\u7d42\u70b9]\u306e\u30ea\u30b9\u30c8\n    for v,w in enumerate(edge[s]):\n        heapq.heappush(edgelist,(w,v)) #s\u306e\u96a3\u306e\u70b9\u306f\u679d\u306e\u91cd\u3055\u304c\u305d\u306e\u307e\u307e\u66ab\u5b9a\u6700\u77ed\u8ddd\u96e2\u3068\u306a\u308b\n    while len(edgelist):\n        #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\u2192\u78ba\u5b9a\u3055\u305b\u308b\n        minedge = heapq.heappop(edgelist)\n        #minedge : [s\u304b\u3089\u306e(\u78ba\u5b9a)\u6700\u77ed\u8ddd\u96e2,\u9802\u70b9]\n        v = minedge[1]\n        if used[v]:\n            continue\n        d[v] = minedge[0]\n        used[v] = True\n        for u,w in enumerate(edge[v]):\n            if not used[u]:\n                heapq.heappush(edgelist,(d[v]+w,u))\n    return d\n\n\n################################\nA, B, C, D = map(int, input().split())\nN = int(input())\n\nd = [[0]*(N+2) for _ in range(N+2)]\n\nX = [0]*N\nY = [0]*N\nR = [0]*N\nfor i in range(N):\n    X[i],Y[i],R[i] = map(int, input().split())\nd[0][-1] = ((C-A)**2+(D-B)**2)**0.5\nd[-1][0] = ((C-A)**2+(D-B)**2)**0.5\nfor i in range(1,N+1):\n    d_s = max(0,((X[i-1]-A)**2+(Y[i-1]-B)**2)**0.5-R[i-1])\n    d_e = max(0,((X[i-1]-C)**2+(Y[i-1]-D)**2)**0.5-R[i-1])\n    d[0][i],d[i][0] = d_s,d_s\n    d[N+1][i],d[i][N+1] = d_e,d_e\n    for j in range(1,N+1):\n        d[i][j] = max(((X[i-1]-X[j-1])**2+(Y[i-1]-Y[j-1])**2)**0.5-R[i-1]-R[j-1],0)\ns = 0 #\u59cb\u70b9\nd = dijkstra_heap(N+2,s,d)\nprint(d[-1])", "from heapq import *\n\nsx, sy, tx, ty = list(map(int, input().split()))\nN = int(input())\ncircles = [tuple(map(int, input().split())) for _ in range(N)]\n\ns = N\nt = N + 1\nadj_matrix = [[0] * (N + 2) for _ in range(N + 2)]\nadj_matrix[s][t] = adj_matrix[t][s] = ((tx-sx)**2 + (ty-sy)**2 )** 0.5 \nfor v, (x, y, r) in enumerate(circles):\n    adj_matrix[s][v] = adj_matrix[v][s] = max(0, ((x-sx)**2 + (y-sy)**2) ** 0.5 - r)\n    adj_matrix[t][v] = adj_matrix[v][t] = max(0, ((x-tx)**2 + (y-ty)**2)** 0.5 - r)\n    \nfor v1, (x1, y1, r1) in enumerate(circles):\n    for v2, (x2, y2, r2) in enumerate(circles[v1+1:], start=v1+1):\n        adj_matrix[v1][v2] = adj_matrix[v2][v1] = max(0, ( ((x1-x2)**2 + (y1-y2)**2)**0.5 - r1 - r2))\n\ndp = [float('inf')] * (N + 2)\ndp[t] = 0\npq = [(0, t)]\nwhile pq:\n    cost, v = heappop(pq)\n    if dp[v] < cost:\n        continue\n    for nv, dist in enumerate(adj_matrix[v]):\n        if dp[nv] > cost + dist:\n            dp[nv] = cost + dist\n            heappush(pq, (dp[nv], nv))\n\n# print(dp)\nprint((dp[s]))\n", "xs, ys, xt, yt = map(int,input().split())\nN = int(input())\nL = [[xs, ys, 0], [xt, yt, 0]]\n\nfor _ in range(N):\n    L.append(list(map(int,input().split())))\n\nV = N + 2\nG = [[] for _ in range(N+2)]\ns = 0\n\nfor i in range(N+2):\n    for j in range(N+2):\n        if i != j:\n            G[i].append([j, max(0, ((L[i][0] - L[j][0]) ** 2 + (L[i][1] - L[j][1]) ** 2) ** 0.5 - (L[i][2] + L[j][2]))])\n\n\nINF = float('inf')\n\nimport heapq\n\ndef dijkstra(s):\n    d = [INF for _ in range(V)]\n    d[s] = 0\n    que = []\n    heapq.heappush(que, (0, s))\n    \n    while len(que) != 0:\n        p = heapq.heappop(que)\n        v = p[1]\n        if d[v] < p[0]:\n            continue\n        for i in range(len(G[v])):\n            e = G[v][i]\n            if d[e[0]] > d[v] + e[1]:\n                d[e[0]] = d[v] + e[1]\n                heapq.heappush(que, (d[e[0]], e[0]))\n\n    return d\n\nd = dijkstra(0)\nprint(d[1])", "from heapq import heappush,heappop\nxs,ys,xt,yt = map(int,input().split())\nn = int(input())\nXY = [list(map(int,input().split())) for i in range(n)]\nXY.append([xs,ys,0])\nXY.append([xt,yt,0])\n\ne = [[9999999999]*(n+2) for i in range(n+2)]\nfor i in range(n+1):\n    for j in range(i+1,n+2):\n        xi,yi,ri = XY[i]\n        xj,yj,rj = XY[j]\n        dif = max(0.0,((xi-xj)**2+(yi-yj)**2)**0.5-ri-rj)\n        e[i][j] = e[j][i] = dif\n\nh = []\nheappush(h,(0,n))\ndis = [10**15]*(n+2)\ndis[n] = 0\nwhile h:\n    cost,now = heappop(h)\n    if cost > dis[now]:\n        continue\n    for nex,dif in enumerate(e[now]):\n        if dis[nex] > dis[now]+dif:\n            dis[nex] = dis[now]+dif\n            heappush(h,(dis[nex],nex))\nprint(dis[-1])", "from heapq import heappop,heappush\nfrom math import sqrt\ndef distf(xyr,i,j):\n  x,y,r=xyr[i]\n  x1,y1,r1=xyr[j]\n  d=max(0,sqrt((x-x1)**2+(y-y1)**2)-r-r1)\n  return d\n\ndef main():\n  xs,ys,xt,yt=list(map(int,input().split()))\n  n=int(input())\n  xyr=[list(map(int,input().split())) for _ in range(n)]\n  xyr.append([xs,ys,0])\n  xyr.append([xt,yt,0])\n  inf=float('inf')\n  dist=[[inf]*(n+2) for _ in range(n+2)]\n  for i in range(n+2):\n    dist[i][i]=0\n  for i in range(n+1):\n    for j in range(i+1,n+2):\n      dist[i][j]=distf(xyr,i,j)\n      dist[j][i]=dist[i][j]\n  seen=[inf]*(n+2)\n  seen[n]=0\n  mi=set(range(n+2))\n  while mi:\n    d,v=inf,-1\n    for j in mi:\n      if d>seen[j]:\n        d=seen[j]\n        v=j\n    mi.remove(v)\n    for nv in mi:\n      nd=dist[v][nv]\n      if seen[nv]>seen[v]+nd:\n        seen[nv]=seen[v]+nd\n  print((seen[n+1]))\ndef __starting_point():\n  main()\n\n__starting_point()", "import typing\nimport sys\nimport math\nimport collections\nimport bisect\nimport itertools\nimport heapq\nimport decimal\nimport copy\nimport operator\n\n# sys.setrecursionlimit(10000001)\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\n# buffer.readline()\u306f\u3053\u3069\u3075\u3049\u3067\u6b7b\u306c\n\n\ndef ni(): return int(sys.stdin.readline())\ndef ns(): return list(map(int, sys.stdin.readline().split()))\ndef na(): return list(map(int, sys.stdin.readline().split()))\ndef na1(): return list([int(x)-1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\ndef dist(l1, l2):\n    return max(0, math.sqrt((l1[0]-l2[0])**2+(l1[1]-l2[1])**2)-l1[2]-l2[2])\n\n\ndef main():\n    xs, ys, xt, yt = ns()\n    n = ni()\n    pos = [na() for _ in range(n)]\n    pos.insert(0, [xs, ys, 0])\n    pos.append([xt, yt, 0])\n    d = [[dist(pos[i], pos[j]) for i in range(n+2)] for j in range(n+2)]\n\n    mind = [INF for _ in range(n+2)]\n    visited = [False for _ in range(n+2)]\n\n    hq = []\n    heapq.heappush(hq, (0, 0))\n    # dist,idx\n    mind[0] = 0\n    while hq:\n        dis, idx = heapq.heappop(hq)\n        if visited[idx]:\n            continue\n        visited[idx]=True\n        \n        if idx==n+1:\n            break\n        for i in range(n+2):\n            if i == idx:\n                continue\n            ndist = dis+d[idx][i]\n            if ndist < mind[i] and ndist < mind[n+1]:\n                mind[i] = ndist\n                heapq.heappush(hq, (ndist, i))\n\n    print((mind[n+1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom heapq import heappop,heappush\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n\nxs,ys,xt,yt = MI()\nN = I()\nXYR = []\nfor _ in range(N):\n    XYR.append(tuple(MI()))\nXYR.append((xs,ys,0))  # \u59cb\u70b9\u3092\u534a\u5f840\u306e\u30d0\u30ea\u30a2\u3068\u307f\u306a\u3059\nXYR.append((xt,yt,0))  # \u7d42\u70b9\u3092\u534a\u5f840\u306e\u30d0\u30ea\u30a2\u3068\u307f\u306a\u3059\n\nGraph = [[0]*(N+2) for _ in range(N+2)]  # Graph[i][j] = \u30d0\u30ea\u30a2 i \u304b\u3089\u30d0\u30ea\u30a2 j \u307e\u3067\u306e'\u8ddd\u96e2'\nfor i in range(N+1):\n    x0,y0,r0 = XYR[i]\n    for j in range(i+1,N+2):\n        x1,y1,r1 = XYR[j]\n        Graph[i][j] = max(0,((x1-x0)**2+(y1-y0)**2)**.5-r0-r1)\n        Graph[j][i] = max(0,((x1-x0)**2+(y1-y0)**2)**.5-r0-r1)\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\n\ndist = [10**10]*(N+2)  # dist[i] = \u30d0\u30ea\u30a2 N \u304b\u3089\u30d0\u30ea\u30a2 i \u3078\u306e\u6700\u77ed'\u8ddd\u96e2'\ndist[N] = 0\nq = []\nheappush(q,(0,N))\nflag = [0]*(N+2)\nwhile q:\n    d,i = heappop(q)\n    if flag[i] == 1:\n        continue\n    flag[i] = 1\n\n    for j in range(N+2):\n        if flag[j] == 0:\n            new_d = d+Graph[i][j]\n            if new_d < dist[j]:\n                dist[j] = new_d\n                heappush(q,(new_d,j))\n\nprint((dist[N+1]))\n", "inf=10**18\ndef D(a,b,c,d):\n\treturn ((c-a)**2+(d-b)**2)**0.5\nxs,ys,xt,yt=map(int,input().split())\nn=int(input())\nxyr=[(xs,ys,0)]\nfor i in range(n):\n\txyr.append(tuple(map(int,input().split())))\nxyr.append((xt,yt,0))\ndis=[[inf]*(n+2) for i in range(n+2)]\nfor i in range(n+2):\n\tdis[i][i]=0\nfor i in range(n+2):\n\tfor j in range(i):\n\t\ta,b,r1=xyr[i]\n\t\tc,d,r2=xyr[j]\n\t\tr=D(a,b,c,d)-(r1+r2)\n\t\tr=max(0,r)\n\t\tdis[i][j]=r\n\t\tdis[j][i]=r\ncost=[inf]*(n+2)\ncost[0]=0\nvisited=[0]*(n+2)\nnow=0\nfor i in range(n+2):\n\tvisited[now]=1\n\tMIN=inf\n\tpre_now=-1\n\tfor j in range(n+2):\n\t\tif visited[j]==0:\n\t\t\tcost[j]=min(cost[now]+dis[now][j],cost[j])\n\t\t\tif MIN>cost[j]:\n\t\t\t\tMIN=cost[j]\n\t\t\t\tpre_now=j\n\tnow=pre_now\t\t\t\nprint(cost[n+1])", "from heapq import *\n\ndef dijkstra(graph, initial):\n    ''' Dijkstra's shortest path algorithm. '''\n    visited = {initial: 0}\n    h, path = [(0, initial)], {}\n    nodes = set(graph.keys())\n\n    while nodes and h:\n        current_weight, min_node = heappop(h)\n        while h and (min_node not in nodes):\n            current_weight, min_node = heappop(h)\n        if not h and (min_node not in nodes):\n            break\n\n        nodes.remove(min_node)\n        for v, w in graph[min_node]:\n            weight = w + current_weight # weight update step\n            if v not in visited or weight < visited[v]:\n                visited[v] = weight\n                heappush(h, (weight, v))\n                path[v] = min_node\n    return visited, path\n\nxstart, ystart, xtarget, ytarget = map(int, input().split())\nN = int(input())\ncircs = [tuple(map(int, input().split())) for _ in range(N)]\n\ngraph = {i: [] for i in range(N+2)}\n\nfrom math import sqrt\n\nfor i in range(N):\n  xi, yi, ri = circs[i]\n  for j in range(i):\n    xj, yj, rj = circs[j]\n    d = max(sqrt((xi-xj)**2 + (yi-yj)**2) - ri - rj, 0)\n    graph[i].append((j, d))\n    graph[j].append((i, d))\n  \n  # start\n  dst = max(sqrt((xi-xstart)**2 + (yi-ystart)**2) - ri, 0)\n  graph[i].append((N, dst))\n  graph[N].append((i, dst))\n  \n  dtgt = max(sqrt((xi-xtarget)**2 + (yi-ytarget)**2) - ri, 0)\n  graph[i].append((N+1, dtgt))\n  graph[N+1].append((i, dtgt))\n\ndsrctgt = sqrt((xstart-xtarget)**2 + (ystart-ytarget)**2)\ngraph[N].append((N+1, dsrctgt))\ngraph[N+1].append((N, dsrctgt))\n  \nvisited, _ = dijkstra(graph, N)\nprint(visited[N+1])", "import sys\nimport math\nimport heapq\n\ninput = sys.stdin.readline\n\nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def move(self, x, y):\n        return Vec(self.x+x, self.y+y)\n\n    def rotate(self, theta):\n        x = self.x * math.cos(theta) - self.y * math.sin(theta)\n        y = self.x * math.sin(theta) + self.y * math.cos(theta)\n        return Vec(x, y)\n\n    def theta(self):\n        if self.x == 0:\n            if self.y > 0:\n                return math.pi/2\n            elif self.y < 0:\n                return 3* math.pi / 2\n            else:\n                return 0\n        ret = math.atan(self.y / self.x)\n        if self.x < 0:\n            ret += math.pi\n        return ret\n\n    def dist(self, other):\n        return math.sqrt((self.x - other.x)** 2 + (self.y - other.y)** 2)\n\n    def __str__(self):\n        return f'{self.x}, {self.y}'\n\n\nxs, ys, xt, yt = list(map(int, input().split()))\nN = int(input())\ncircles = [(Vec(xs, ys), 0)] # pos, r\nfor _ in range(N):\n    x, y, r = list(map(int, input().split()))\n    circles.append((Vec(x, y), r))\ncircles.append((Vec(xt, yt), 0))\n\nd = [[math.inf]*(N+2) for _ in range(N+2)]\nfor i in range(N+2):\n    for j in range(i, N+2):\n        tmp = max(0, circles[i][0].dist(circles[j][0])-(circles[i][1]+circles[j][1]))\n        d[i][j] = tmp\n        d[j][i] = tmp\nq = [(0, 0)]\nvisited = [False]*(N+2)\nans = math.inf\nwhile q:\n    c, i = heapq.heappop(q)\n    if visited[i]:\n        continue\n    if i == N+1:\n        print(c)\n        return\n    visited[i] = True\n    for j in range(N+2):\n        if visited[j]:\n            continue\n        heapq.heappush(q, (c+d[i][j], j))\n", "from scipy.sparse.csgraph import dijkstra, csgraph_from_dense\nxs,ys,xg,yg = map(int, input().split())\nN = int(input())\nxyr = [(xs,ys,0)]\nxyr.extend([list(map(int, input().split())) for i in range(N)])\nxyr.append((xg,yg,0))\ngraph = [[0] * (N+2) for _ in range(N+2)]\n\nmax_val = 10**9\n\nfor i in range(N+2):\n    graph[i][i] = max_val\n\nfor i in range(N+2):\n    for j in range(i+1,N+2):\n        x1,y1,r1 = xyr[i]\n        x2,y2,r2 = xyr[j]\n        d = max(0, ((x1-x2)**2 + (y1-y2)**2) ** 0.5 - r1 - r2)\n        graph[i][j] = graph[j][i] = d\n\ng = csgraph_from_dense(graph,null_value=max_val)\nprint(dijkstra(g,indices=0)[-1])", "from heapq import heappush,heappop,heapify\nINF=10**30\n\ndef dijkstra(G,s,n):\n    que=[(0,s)]\n    dist=[INF]*n\n    dist[s]=0\n    while que:\n        mincost,u=heappop(que)\n        if(mincost>dist[u]):\n            continue\n        for c,v in G[u]:\n            if(dist[u]+c<dist[v]):\n                dist[v]=dist[u]+c\n                heappush(que,(dist[v],v))\n    return dist\n\nsx,sy,gx,gy=map(int,input().split())\nN=int(input())\nX,Y,R=[sx,gx],[sy,gy],[0,0]\nfor i in range(N):\n    t,m,p=map(int,input().split())\n    X.append(t);Y.append(m);R.append(p)\nG=[[] for i in range(N+2)]\nfor i in range(N+2):\n    for j in range(i):\n        d=max(0,((X[i]-X[j])**2+(Y[i]-Y[j])**2)**0.5-R[i]-R[j])\n        G[i].append((d,j))\n        G[j].append((d,i))\ndist=dijkstra(G,0,N+2)\nprint(dist[1])", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    xs, ys, xt, yt = list(map(int, input().split()))\n    n = int(input())\n    XYR = [[xs, ys, 0], [xt, yt, 0]]\n    for _ in range(n):\n        x, y, r = list(map(int, input().split()))\n        XYR.append([x, y, r])\n\n    cost = [[0] * (n + 2) for _ in range(n + 2)]\n    for i in range(n + 2):\n        x1, y1, r1 = XYR[i]\n        for j in range(n + 2):\n            x2, y2, r2 = XYR[j]\n            dist = max(0, pow(pow(x1 - x2, 2) + pow(y1 - y2, 2), 0.5) - (r1 + r2))\n            cost[i][j] = cost[j][i] = dist\n\n    def dijkstra(s):\n        # \u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n        # n:\u9802\u70b9\u6570, cost[u][v]:\u8fbauv\u306e\u30b3\u30b9\u30c8(\u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u306finf)\n        d = [f_inf] * (n + 2)\n        used = [False] * (n + 2)\n        d[s] = 0\n\n        while True:\n            v = -1\n            # \u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n            for k in range(n + 2):\n                if (not used[k]) and (v == -1):\n                    v = k\n                elif (not used[k]) and d[k] < d[v]:\n                    v = k\n            if v == -1:\n                break\n            used[v] = True\n\n            for m in range(n + 2):\n                d[m] = min(d[m], d[v] + cost[v][m])\n        return d\n\n    res = dijkstra(0)\n    print((res[1]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "XS,YS,XT,YT=map(int,input().split())\nN=int(input())\nV=[[XS,YS,0],[XT,YT,0]]\nfor i in range(N):\n  V.append(list(map(int,input().split())))\nINF=10**12\nG=[[INF]*len(V) for i in range(len(V))]\ndef d(a,b):\n  return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\nfor i in range(len(V)):\n  G[i][i]=0\n  for j in range(len(V)):\n    G[i][j]=max(0,d(V[i][:2],V[j][:2])-V[i][2]-V[j][2])\nD=[0]*len(V)\nU=[0]*len(V)\ndef ijk(s):\n  nonlocal D,U,G,V,INF\n  for i in range(len(V)):\n    D[i]=INF\n    U[i]=False\n  D[s]=0\n  v=0\n  while True:\n    v=-1\n    for i in range(len(V)):\n      if not(U[i]) and (v==-1 or D[i]<D[v]):\n        v=i\n    if v==-1:\n      break\n    U[v]=True\n    for i in range(len(V)):\n      D[i]=min(D[i],D[v]+G[v][i])\n\nijk(0)\nprint(D[1])", "from heapq import heappop, heappush\n\nsx, sy, tx, ty = list(map(int, input().split()))\nn = int(input())\nbarriers = [tuple(map(int, input().split())) for _ in range(n)]\nbarriers.append((tx, ty, 0))\nbarriers.append((sx, sy, 0))\ns = n + 1\nt = n\nq = [(0., s)]\nvisited = [False] * (n + 2)\nwhile q:\n    cost, v = heappop(q)\n    if v == t:\n        print(cost)\n        break\n    if visited[v]:\n        continue\n    visited[v] = True\n    vx, vy, vr = barriers[v]\n    for u in range(n + 1):\n        if visited[u]:\n            continue\n        ux, uy, ur = barriers[u]\n        new_cost = max(0, ((vx - ux) ** 2 + (vy - uy) ** 2) ** 0.5 - vr - ur)\n        heappush(q, (cost + new_cost, u))\n", "from scipy.sparse.csgraph import csgraph_from_dense, dijkstra\nimport numpy as np\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    x_s, y_s, x_t, y_t = list(map(int, readline().split()))\n    A = np.array([[x_s, y_s, 0],\n                  [x_t, y_t, 0]], dtype=np.int)\n    \n    N = int(readline())\n    B = np.array(read().split(), dtype=np.int).reshape(-1, 3)\n    XY, R = np.hsplit(np.concatenate((A, B)), [2])\n    \n    d = np.expand_dims(XY, axis=1) - np.expand_dims(XY, axis=0)\n    d = np.sqrt(np.sum(d ** 2, axis=-1))\n    d -= R + R.reshape(1, -1)\n    d = np.maximum(d, 0)\n    np.fill_diagonal(d, -1)\n    d = csgraph_from_dense(d, null_value=-1)\n     \n    ans = dijkstra(d, indices=0)[1]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import sqrt\n\nxs, ys, xt, yt = map(int, input().split())\nn = int(input())\nxyr = [list(map(int, input().split())) for i in range(n)]\nxyr.insert(0, [xs, ys, 0])\nxyr.append([xt, yt, 0])\nGraph = [[0] * (n + 2) for i in range(n + 2)]\nfor i in range(n + 2):\n    for j in range(n + 2):\n        Graph[i][j] = max(0, sqrt((xyr[i][0] - xyr[j][0]) ** 2 + (xyr[i][1] - xyr[j][1]) ** 2) - (xyr[i][2] + xyr[j][2]))\nINF = 10 ** 18\ndist = [INF] * (n + 2)\nvisited = [False] * (n + 2)\ndist[0] = 0\nwhile True:\n    v = -1\n    for i in range(n + 2):\n        if not visited[i] and (v == -1 or dist[i] < dist[v]):\n            v = i\n    if v == -1:\n        break\n    visited[v] = True\n    for i in range(n + 2):\n        dist[i] = min(dist[i], dist[v] + Graph[v][i])\nprint(dist[-1])", "sx,sy,tx,ty=map(int,input().split())\nn=int(input())\nl=[list(map(int,input().split())) for i in range(n)]\nl.append([sx,sy,0])\nl.append([tx,ty,0])\n\ndef dijkstra(s,n,cost):\n  d=[float(\"inf\")]*n\n  used=[False]*n\n  d[s]=0\n  while True:\n    v=-1\n    for i in range(n):\n      if (not used[i]) and (v==-1):\n        v=i\n      elif (not used[i]) and d[i]<d[v]:\n        v=i\n    if v==-1:\n      break\n    used[v]=True\n    for j in range(n):\n      d[j]=min(d[j],d[v]+cost[v][j])\n  return d\n\ncost=[[float(\"inf\") for i in range(n+2)] for i in range(n+2)] \nfor i in range(n+2):\n  for j in range(n+2):\n    cost[i][j]=max(((l[i][0]-l[j][0])**2+(l[i][1]-l[j][1])**2)**0.5-l[i][2]-l[j][2],0)\n    cost[j][i]=max(((l[i][0]-l[j][0])**2+(l[i][1]-l[j][1])**2)**0.5-l[i][2]-l[j][2],0)\nprint(dijkstra(n,n+2,cost)[n+1])", "# Cosmic rays\nimport math\nimport heapq\n\nxs, ys, xt, yt = map(int, input().split())\nN = int(input())\n\nd = [((xs, ys), 0, 0)]\n# node,radius\n\nfor _ in range(N):\n    x, y, r = map(int, input().split())\n    d.append(((x, y), _+1, r))\n\ngraph = {i: [] for i in range(N+2)}\n\nd.append(((xt, yt), N+1, 0))\nfor i in range(N+2):\n    for j in range(i+1, N+2):\n        p, point, rad = d[i]\n        q, point2, rad2 = d[j]\n        D = math.hypot(p[0]-q[0], p[1]-q[1])\n        if D > (rad+rad2):\n            graph[i].append((D-rad-rad2, j))\n            graph[j].append((D-rad-rad2, i))\n        else:\n            graph[i].append((0, j))\n            graph[j].append((0, i))\n\n\ndef dijkstra(s, graph):\n    n = len(graph)\n    dist = [float(\"inf\") for i in range(n+1)]\n    dist[s] = 0\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (0, s))\n    while pq:\n        mini_dis, node = heapq.heappop(pq)\n        if dist[node] < mini_dis:\n            continue\n        for w, point in graph[node]:\n            if dist[point] < w:\n                continue\n            newlen = dist[node]+w\n            if newlen < dist[point]:\n                heapq.heappush(pq, (newlen, point))\n                dist[point] = newlen\n    return dist\n\nK=dijkstra(0,graph)[N+1]\nprint(K)", "from heapq import heappop,heappush\nfrom math import sqrt\ndef distf(xyr,i,j):\n  x,y,r=xyr[i]\n  x1,y1,r1=xyr[j]\n  d=max(0,sqrt((x-x1)**2+(y-y1)**2)-r-r1)\n  return d\n\ndef main():\n  # \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u3092\u4f7f\u308f\u306a\u3044\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\n  xs,ys,xt,yt=list(map(int,input().split()))\n  n=int(input())\n  xyr=[list(map(int,input().split())) for _ in range(n)]\n  xyr.append([xs,ys,0])\n  xyr.append([xt,yt,0])\n  inf=float('inf')\n  dist=[[inf]*(n+2) for _ in range(n+2)]\n  for i in range(n+2):\n    dist[i][i]=0\n  for i in range(n+1):\n    for j in range(i+1,n+2):\n      dist[i][j]=distf(xyr,i,j)\n      dist[j][i]=dist[i][j]\n  seen=[inf]*(n+2)\n  seen[n]=0\n  mi=set(range(n+2))\n  while mi:\n    d,v=inf,-1\n    for j in mi:\n      if d>seen[j]:\n        d=seen[j]\n        v=j\n    mi.remove(v)\n    for nv in mi:\n      nd=dist[v][nv]\n      if seen[nv]>seen[v]+nd:\n        seen[nv]=seen[v]+nd\n  print((seen[n+1]))\ndef __starting_point():\n  main()\n\n__starting_point()", "from heapq import heappush, heappop\n\nsX, sY, tX, tY = list(map(int, input().split()))\nN = int(input())\n\nXYR = [tuple(map(int, input().split())) for _ in range(N)] + [(sX, sY, 0), (tX, tY, 0)]\nS, T = N, N + 1\nN += 2\n\nedges = [[] for _ in range(N)]\nfor i, (x, y, r) in enumerate(XYR):\n    for j, (u, v, w) in enumerate(XYR[i + 1:], start=i + 1):\n        dist = max(0, ((x - u)**2 + (y - v)**2)**0.5 - (r + w))\n        edges[i].append((j, dist))\n        edges[j].append((i, dist))\n\nminDist = [10**18] * N\nminDist[S] = 0\nque = [(0, S)]\nwhile que:\n    dist, now = heappop(que)\n    if minDist[now] < dist:\n        continue\n    for to, cost in edges[now]:\n        d = dist + cost\n        if minDist[to] > d:\n            minDist[to] = d\n            heappush(que, (d, to))\nprint((minDist[T]))\n", "import sys\nimport heapq\nmy_input = sys.stdin.readline\n\ndef main():\n    xs, ys, xt, yt = list(map(int, my_input().split()))\n    N = int(my_input())\n    C = [(xs, ys, 0), (xt, yt, 0)]\n    C += [tuple(map(int, my_input().split())) for i in range(N)]\n\n    G = [[] for i in range(N+2)]\n    for i in range(N + 2):\n        for j in range(i + 1, N + 2):\n            cost = max(0, ((C[i][0] - C[j][0]) ** 2 + (C[i][1] - C[j][1]) ** 2) ** 0.5 - (C[i][2] + C[j][2]))\n            G[i].append((j, cost))\n            G[j].append((i, cost))\n\n\n    def dijkstra(graph, start, inf=float('inf')):\n        import heapq\n        n = len(graph)\n        distances = [inf] * n\n        distances[start] = 0\n        visited = [False] * n\n\n        # \u8ddd\u96e2\u30fb\u9802\u70b9\n        hq = [(0, start)]\n        while hq:\n            dist, fr = heapq.heappop(hq)\n            if distances[fr] < dist:\n                continue\n            if fr == 1:\n                return distances\n            visited[fr] = True\n\n            for to, cost in graph[fr]:\n                new_dist = distances[fr] + cost\n                if (visited[to]) or (distances[to] <= new_dist):\n                    continue\n\n                distances[to] = new_dist\n                heapq.heappush(hq, (new_dist, to))\n\n        return distances\n\n\n    dist = dijkstra(G, 0)\n    print((dist[1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from math import hypot\n    import sys\n    input = sys.stdin.readline\n\n    inf = 1 << 60\n\n    xs, ys, xt, yt = list(map(int, input().split()))\n    N = int(input())\n    N += 2\n\n    def dist(p1, p2):\n        d = hypot(p1[0] - p2[0], p1[1] - p2[1])\n        return max(0, d - (p1[2] + p2[2]))\n\n    s = (xs, ys, 0, 0)\n    g = (xt, yt, 0, N - 1)\n    ps = [s, g]  # x,y,r,idx\n    adj = [[inf] * N for _ in range(N)]\n    adj[0][N - 1] = adj[N - 1][0] = dist(s, g)\n    for idx1 in range(1, N - 1):\n        *p1, = list(map(int, input().split()))  # x,y,r\n        p1.append(idx1)\n        for *p2, idx2 in ps:\n            d = dist(p1, p2)\n            adj[idx1][idx2] = adj[idx2][idx1] = d\n        ps.append(p1)\n\n    def dijkstra(s):\n        from heapq import heappop, heappush\n\n        dist = [inf] * N\n\n        h = [(0, s)]  # c,v\n        dist[s] = 0\n\n        while h:\n            c, v = heappop(h)\n            if dist[v] < c: continue\n\n            for u, dc in enumerate(adj[v]):\n                nc = c + dc\n                if dist[u] <= nc: continue\n                dist[u] = nc\n                heappush(h, (nc, u))\n\n        return dist\n\n    print((dijkstra(s=0)[N - 1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(x_s: int, y_s: int, x_t: int, y_t: int, N: int, x: \"List[int]\", y: \"List[int]\", r: \"List[int]\"):\n    import numpy as np\n    from scipy.sparse import csr_matrix\n    from scipy.sparse.csgraph import dijkstra\n    x.extend([x_s, x_t])\n    y.extend([y_s, y_t])\n    r.extend([0, 0])\n    p = np.column_stack((x, y))\n    diff = np.expand_dims(p, axis=1) - np.expand_dims(p, axis=0)\n    dist = np.sqrt(np.sum(diff ** 2, axis=-1))\n    delta = 0.5\n    mat = csr_matrix(((dist - r).T - r).clip(min=0)-delta)\n    mat.data += delta\n    return dijkstra(mat, indices=N)[N+1]\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    x_s = int(next(tokens))  # type: int\n    y_s = int(next(tokens))  # type: int\n    x_t = int(next(tokens))  # type: int\n    y_t = int(next(tokens))  # type: int\n    N = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\"\n    y = [int()] * (N)  # type: \"List[int]\"\n    r = [int()] * (N)  # type: \"List[int]\"\n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n        r[i] = int(next(tokens))\n    print((solve(x_s, y_s, x_t, y_t, N, x, y, r)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(x_s: int, y_s: int, x_t: int, y_t: int, N: int, x: \"List[int]\", y: \"List[int]\", r: \"List[int]\"):\n    import numpy as np\n    from scipy.sparse import csr_matrix, coo_matrix\n    from scipy.sparse.csgraph import dijkstra\n    x.extend([x_s, x_t])\n    y.extend([y_s, y_t])\n    r.extend([0, 0])\n    p = np.column_stack((x, y))\n    diff = np.expand_dims(p, axis=1) - np.expand_dims(p, axis=0)\n    dist = np.sqrt(np.sum(diff ** 2, axis=-1))\n    mat = ((dist - r).T - r).clip(min=1e-20)    \n    return '{:.10f}'.format(dijkstra(csr_matrix(mat), indices=N)[N+1])\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    x_s = int(next(tokens))  # type: int\n    y_s = int(next(tokens))  # type: int\n    x_t = int(next(tokens))  # type: int\n    y_t = int(next(tokens))  # type: int\n    N = int(next(tokens))  # type: int\n    x = [int()] * (N)  # type: \"List[int]\"\n    y = [int()] * (N)  # type: \"List[int]\"\n    r = [int()] * (N)  # type: \"List[int]\"\n    for i in range(N):\n        x[i] = int(next(tokens))\n        y[i] = int(next(tokens))\n        r[i] = int(next(tokens))\n    print((solve(x_s, y_s, x_t, y_t, N, x, y, r)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "def main():\n    from math import hypot\n    import sys\n    input = sys.stdin.readline\n\n    inf = 1 << 60\n\n    xs, ys, xt, yt = list(map(int, input().split()))\n    N = int(input())\n\n    def dist(p1, p2):\n        d = hypot(p1[0] - p2[0], p1[1] - p2[1])\n        return max(0, d - (p1[2] + p2[2]))\n\n    ps = [(xs, ys, 0)]\n    ps += (tuple(map(int, input().split())) for _ in range(N))\n    ps += [(xt, yt, 0)]\n\n    adj = [[inf] * (N + 2) for _ in range(N + 2)]\n\n    for i, p1 in enumerate(ps):\n        for j, p2 in enumerate(ps):\n            if i <= j: break  # \u81ea\u5df1\u8fba\u306a\u3057\n            adj[i][j] = adj[j][i] = dist(p1, p2)\n\n    def dijkstra(s):\n        dist = [inf] * (N + 2)\n        dist[s] = 0\n        det = [0] * (N + 2)\n\n        c, v = 0, s\n        det[s] = 1\n        for _ in range(N + 1):\n            for u, dc in enumerate(adj[v]):\n                nc = c + dc\n                if dist[u] <= nc: continue\n                dist[u] = nc\n\n            c, v = -1, -1\n            for u, d in enumerate(dist):\n                if det[u]: continue\n                if ~v and c <= d: continue\n                c, v = d, u\n            det[v] = 1\n\n        return dist\n\n    print((dijkstra(s=0)[N + 1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nINFTY = 10**10\ndef f(x,y):\n    return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\nxs,ys,xt,yt = map(int,input().split())\nN = int(input())\nA = [list(map(int,input().split())) for _ in range(N)]\nA.insert(0,[xs,ys,0])\nA.append([xt,yt,0])\ndist = [INFTY for _ in range(N+2)]\nhist = [0 for _ in range(N+2)]\nheap = [(0,0)]\ndist[0]=0\nhist[0]=1\nwhile heap:\n    d,x = heapq.heappop(heap)\n    if dist[x]<d:continue\n    hist[x]=1\n    for i in range(N+2):\n        if hist[i]==0:\n            if dist[i]>d+max(f(A[x][:2],A[i][:2])-(A[x][2]+A[i][2]),0):\n                dist[i]=d+max(f(A[x][:2],A[i][:2])-(A[x][2]+A[i][2]),0)\n                heapq.heappush(heap,(dist[i],i))\nprint(dist[N+1])", "from math import sqrt\nfrom scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\nxs, ys, xt, yt = list(map(int, input().split()))\nn = int(input())\nxyr = [list(map(int, input().split())) for _ in range(n)]\n\nxyr.append([xs, ys, 0])\nxyr.append([xt, yt, 0])\n\nrow = []\ncol = []\ncost = []\n\nfor i, (xi, yi, ri) in enumerate(xyr):\n    for j, (xj, yj, rj) in enumerate(xyr[i+1:], i+1):\n        row.append(i)\n        col.append(j)\n        dist = max(0, sqrt((xi - xj) ** 2 + (yi - yj) ** 2) - ri - rj)\n        cost.append(dist)\n\ng = csr_matrix((cost, (row, col)), shape=(n + 2, n + 2))\nd = dijkstra(g, directed=False, indices=n)\nans = d[n+1]\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef dijkstra(edges, size, src):\n    from heapq import heappush, heappop\n\n    INF = 10**18\n    dist = [INF] * size\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        d, v = heappop(pq)\n        if d > dist[v]:\n            continue\n        for u, weight in edges[v]:\n            nd = d + weight\n            if dist[u] > nd:\n                dist[u] = nd\n                heappush(pq, (nd, u))\n    return dist\n\nxs, ys, xt, yt = map(int, input().split())\nN = int(input())\nxyr = [tuple(map(int, input().split())) for _ in range(N)]\nxyr.append((xs, ys, 0))\nxyr.append((xt, yt, 0))\nedges = [[] for _ in range(N+2)]\nfor i in range(N+1):\n    for j in range(i, N+2):\n        xi, yi, ri = xyr[i]\n        xj, yj, rj = xyr[j]\n        d = max(0, ((xj-xi)**2 + (yj-yi)**2)**0.5 - (ri + rj))\n        edges[i].append((j, d))\n        edges[j].append((i, d))\nd = dijkstra(edges, N+2, N)\nprint(d[N+1])"]
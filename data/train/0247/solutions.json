["class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        i, window, result = 0, 0, float('inf')\n        premin = [float('inf')]*len(arr)\n        for j, num in enumerate(arr):\n            window += num\n            while window > target:\n                window -= arr[i]\n                i+=1\n            if window == target:\n                curr = j - i + 1\n                result = min(result, curr + premin[i-1])\n                premin[j] = min(curr, premin[j-1])\n            else:\n                premin[j] = premin[j-1]\n        return result if result < float('inf') else -1 \n\n        \n        \n        \n# class Solution:\n#     def minSumOfLengths(self, arr: List[int], target: int) -> int:\n#         i, window, result = 0, 0, float('inf')\n#         premin = [float('inf')] * len(arr)\n#         for j, num in enumerate(arr):\n#             window += num\n#             while window > target:\n#                 window -= arr[i]\n#                 i += 1\n#             if window == target:\n#                 curr = j - i + 1\n#                 result = min(result, curr + premin[i - 1])\n#                 premin[j] = min(curr, premin[j - 1])\n#             else:\n#                 premin[j] = premin[j - 1]\n#         return result if result < float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        dp = [float('inf')] * n \n        ans = float('inf'); s = 0; j = 0\n        for i in range(n):\n            s += arr[i]\n            while s > target:\n                s -= arr[j]\n                j += 1\n            if s == target:\n                cur = i - j + 1\n                ans = min(ans, cur + dp[j-1])\n                dp[i] = min(cur, dp[i-1])\n            else:\n                dp[i] = dp[i-1]\n        return ans if ans < float('inf') else -1\n\n'''             \nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        i, window, result = 0, 0, float('inf')\n        premin = [float('inf')] * len(arr)\n        for j, num in enumerate(arr):\n            window += num\n            while window > target:\n                window -= arr[i]\n                i += 1\n            if window == target:\n                curr = j - i + 1\n                result = min(result, curr + premin[i - 1])\n                premin[j] = min(curr, premin[j - 1])\n            else:\n                premin[j] = premin[j - 1]\n        return result if result < float('inf') else -1\n'''", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        if not arr:\n            return -1\n        \n        def getMinSub(arr, target):\n            dp = [float('inf')]*len(arr)\n            total = 0\n            lookup = defaultdict(int)\n            for index, val in enumerate(arr):\n                total += val\n                if total == target:\n                    dp[index] = index - 0 + 1\n                elif total - target in lookup:\n                    dp[index] = min(index - lookup[total-target] + 1, dp[index-1])\n                else:\n                    dp[index] = dp[index-1]\n                \n                lookup[total] = index + 1\n            return dp \n        \n        forward = getMinSub(arr, target)\n        backward = getMinSub(arr[::-1], target)[::-1]\n        \n        minresult = float('inf')\n        for i in range(1,len(arr)):\n            minresult = min(minresult,forward[i-1]+ backward[i])\n            \n        return minresult if minresult != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n        return -1 if ans == math.inf else ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # prefix[i] is the min len of subarray with sum in arr[:i]\n        # suffix[i] is the min len of subarray with sum in arr[i:]\n        prefix, suffix = [float('inf')] * len(arr), [float('inf')] * len(arr)\n        curSum, l = 0, 0\n        for r in range(1, len(arr)):\n            prefix[r] = prefix[r - 1]\n            curSum += arr[r - 1]\n            while curSum >= target:\n                if curSum == target:\n                    prefix[r] = min(prefix[r], r - l)\n                curSum -= arr[l]\n                l += 1\n        curSum, r = 0, len(arr)\n        for l in range(len(arr) - 1, 0, -1):\n            if l < len(arr) - 1:\n                suffix[l] = suffix[l + 1]\n            curSum += arr[l]\n            while curSum >= target:\n                if curSum == target:\n                    suffix[l] = min(suffix[l], r - l)\n                curSum -= arr[r - 1]\n                r -= 1\n\n        res = len(arr) + 1\n        for i in range(1, len(arr) - 1):\n            res = min(res, prefix[i] + suffix[i])\n        return res if res <= len(arr) else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        left_presum = {0 : 0}\n        left_dp = [float('inf')] * (n + 1)\n        total = 0\n        for i in range(1, n + 1):\n            total += arr[i - 1]\n            if total - target in left_presum:\n                left_dp[i] = min(i - left_presum[total - target], left_dp[i - 1])\n            else:\n                left_dp[i] = left_dp[i - 1]\n            left_presum[total] = i\n        \n        total = 0\n        right_presum = {0 : n}\n        right_dp = [float('inf')] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            total += arr[i]\n            if total - target in right_presum:\n                right_dp[i] = min(right_dp[i + 1], right_presum[total - target] - i)\n            else:\n                right_dp[i] = right_dp[i + 1]\n            right_presum[total] = i\n        \n        print(right_dp)\n        ans = float('inf')\n        for i in range(1, n):\n            if left_dp[i] == float('inf') or right_dp[i] == float('inf'):\n                continue\n            ans = min(ans, left_dp[i] + right_dp[i])\n        \n        return -1 if ans == float('inf') else ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        i, window, result = 0, 0, float('inf')\n        premin = [float('inf')] * len(arr)\n        for j, num in enumerate(arr):\n            window += num\n            while window > target:\n                window -= arr[i]\n                i += 1\n            if window == target:\n                curr = j - i + 1\n                result = min(result, curr + premin[i - 1])\n                premin[j] = min(curr, premin[j - 1])\n            else:\n                premin[j] = premin[j - 1]\n        return result if result < float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        def get_min(arr):\n            min_left = [float('inf')] * n\n            window = 0\n            l = 0\n            for r in range(n):\n                window += arr[r]\n                while window > target:\n                    window -= arr[l]\n                    l += 1\n                if window == target:\n                    min_left[r] = r - l + 1\n                if r > 0:\n                    min_left[r] = min(min_left[r], min_left[r - 1])\n                    \n            return min_left\n        \n        min_left = get_min(arr)\n        min_right = get_min(arr[::-1])[::-1]\n        \n        best = float('inf')\n        for i in range(1, n):\n            best = min(best, min_left[i - 1] + min_right[i])\n        \n        return best if best < float('inf') else -1\n                \n                \n", "class Solution:\n  # 864 ms\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = count = 0\n    # preMin: store previous shortest length\n    preMin = [(-1, inf)]\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n     # print(preMin)\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: current length\n        curr = j - i + 1\n        n = 0 \n        # find first minimal length n before window start i\n        for index, length in preMin[::-1]:\n          if index <= i-1: \n            n = length           \n            break\n        # update result \n        if result > curr + n: result = curr + n\n            \n        # update shortest length\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\n          \n        # early stopping if found two single targets\n      #  if curr == 1: count += 1\n      #  if count == 2: return 2\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        record = collections.defaultdict()\n        record[0] = 0\n        l1 = l2 = float('Inf')\n        tmp_sum = 0\n        res = float('Inf')\n        dp = [float('Inf') for _ in range(len(arr) + 1)]\n        \n        for i in range(len(arr)):\n            tmp_sum += arr[i]\n            if tmp_sum - target in record:\n                dp[i+1] = i - record[tmp_sum - target] + 1\n                res = min(res, dp[i+1] + dp[record[tmp_sum - target]])\n            \n            record[tmp_sum] = i + 1\n            \n            dp[i+1] = min(dp[i+1], dp[i])\n        \n            \n        return res if res<float('Inf') else -1\n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        pre_index, curr_sum = 0, 0 \n        f = [100001] * (len(arr) + 1)\n        ans = 100001\n        for index, a in enumerate(arr):\n            curr_sum += a\n            while curr_sum > target:\n                curr_sum -= arr[pre_index] \n                pre_index += 1\n            if curr_sum == target:    \n                ans = min(f[pre_index] + index + 1 - pre_index, ans)\n                f[index + 1] = min(f[index], index + 1 - pre_index) \n            else:    \n                f[index + 1] = f[index]\n        return -1 if ans >= 100001 else ans", "import numpy as np\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        cumsum = np.cumsum(arr)\n        h2idx = {}\n        \n        print(cumsum)\n        minSum = []\n        for idx,c in enumerate(cumsum):\n            # print(c, target, target-c, h2idx)\n            if c == target: \n                minSum.append(idx+1)\n            if (c - target) in h2idx:\n                minSum.append(idx - h2idx[c - target])\n            h2idx[c] = idx\n        if len(minSum) < 2: return -1\n        return sum(list(sorted(minSum))[:2])\n            \n# t = 7\n# [ 2, 2, 3, 4, 3, 4]\n\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n        return -1 if ans == math.inf else ans\n    \n    \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        cumsum = np.cumsum(arr)\n        h2idx = {}\n        INF = math.inf\n        best_at_i = [INF] * len(arr)\n        best = INF\n        for idx,c in enumerate(cumsum):\n            if c == target: \n                best_at_i[idx] = min(best_at_i[idx-1], idx+1)\n            if (c-target) in h2idx:\n                left = h2idx[c-target]\n                best = min(best, best_at_i[left] + idx - left)\n                best_at_i[idx] = min(best_at_i[left], idx - left)\n            h2idx[c] = idx\n            best_at_i[idx] = min(best_at_i[idx-1], best_at_i[idx])\n            \n        return best if best != INF else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        sumArr = []\n        sumMap = {}\n        sumMap[0] = -1\n        \n        for i in range(len(arr)):\n            sumArr.append(arr[i] + (sumArr[i-1] if i-1 > -1 else 0))\n            sumMap[sumArr[i]] = i\n            \n        #print(sumArr)\n        #print(sumMap)\n        \n        res = math.inf\n        \n        dp = [math.inf for i in range(len(arr))]\n        \n        for i in range(0, len(arr)):\n            if sumMap.get(sumArr[i] - target) != None:\n                dp[i] = min(i - sumMap[sumArr[i] - target], dp[i-1] if i>0 else math.inf)\n            else:\n                dp[i] = dp[i-1] if i>0 else math.inf\n                \n        print(dp)\n        \n        for i in range(len(arr)-1, -1, -1):\n            #print(\\\"arr:%d\\\"%(sumArr[i]))\n            #print(sumMap.get(sumArr[i] - target))\n            if sumMap.get(sumArr[i] - target) != None:\n                j = sumMap.get(sumArr[i] - target)\n                print(j)\n                l1 = i - j\n                if j > -1 and dp[j] != math.inf:\n                    res = min(res, l1 + dp[j])\n                \n                \n        return -1 if res == math.inf else res", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        acc = dict()\n        acc[-1] = 0\n        for i in range(0, n):\n            acc[i] = acc[i-1] + arr[i]\n        best_to = [n + 1 for _ in range(n)]\n        best_from = dict()\n        min_total = n + 1 # Naturally impossible length. Will be updated if any possible case exist. Will tell when no possible case\n        s_left = 0\n        \n        for i in range(n):\n            if acc[i] - acc[s_left-1] == target:\n                best_to[i] = i - s_left + 1\n                best_from[s_left] = i - s_left + 1\n            elif acc[i] - acc[s_left-1] > target:\n                while s_left < i:\n                    s_left += 1\n                    if acc[i] - acc[s_left-1] < target:\n                        break\n                    if acc[i] - acc[s_left-1] == target:\n                        best_to[i] = i - s_left + 1\n                        best_from[s_left] = i - s_left + 1\n                        break\n        \n        for i in range(1, n):\n            best_to[i] = min(best_to[i], best_to[i-1])\n        \n        for i in range(n - 1):\n            if best_to[i] > n:\n                continue\n            \n            if i + 1 in best_from:\n                min_total = min(min_total, best_to[i] + best_from[i + 1])\n        \n        if min_total > n:\n            return -1\n        \n        return min_total\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        lengths = [len(arr) + 1]*(len(arr) + 1)\n        i = 0\n        j = 0\n        s = 0\n        min_two_sum = len(arr) + 1\n        while j <= len(arr):\n            if s < target:\n                if j == len(arr):\n                    break\n                if j > 0:\n                    lengths[j] = lengths[j - 1]\n                s += arr[j]\n                j += 1\n            elif s > target:\n                s -= arr[i]\n                i += 1\n            else:\n                lengths[j] = min(lengths[j - 1], j - i)\n                min_two_sum = min(min_two_sum, lengths[i] + j - i)\n                if j == len(arr):\n                    break\n                s += arr[j]\n                j += 1\n        if min_two_sum > len(arr):\n            min_two_sum = -1\n        return min_two_sum\n", "from collections import defaultdict\nclass Solution:\n    def getSubArray(self, array, target):\n        dic = defaultdict(int)\n        minSub = [float('inf')] * len(array) \n        currentSum = 0\n        for i, num in enumerate(array):\n            currentSum += num\n            if currentSum == target:\n                minSub[i] = i - 0 + 1\n            elif currentSum - target in dic:\n                minSub[i] = i - dic[currentSum - target]\n            minSub[i] = min(minSub[i - 1], minSub[i])\n            dic[currentSum] = i\n        return minSub\n        \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        result = float('inf')\n        leftMinSub = self.getSubArray(arr, target)\n        rightMinSub = self.getSubArray(arr[::-1], target)[::-1]\n        \n        for i in range(1, n):\n            result = min(result, leftMinSub[i-1] + rightMinSub[i])\n        if result == float('inf'):\n            return -1\n        else:\n            return result", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0:-1}\n        best_sofar_arr = [math.inf]\n        best_sofar = math.inf\n        curr_best = math.inf\n        ans = math.inf\n        new_ans = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            prefix[curr] = i\n            if curr - target in prefix:\n                curr_best = (i-prefix[curr - target]) \n                best_sofar = min(best_sofar, curr_best)\n                best_sofar_arr.append(best_sofar)\n                if i > 0 :\n                    new_ans = curr_best + best_sofar_arr[prefix[curr - target]+1]\n                ans = min(new_ans, ans)            \n            else:\n                best_sofar_arr.append(best_sofar)\n        return -1 if ans==math.inf else ans", "class Solution:\n  def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        sums = {0:-1}\n        prefix = 0\n        dp = [math.inf for _ in range(len(arr)+1)]\n        ans = math.inf\n        for idx, num in enumerate(arr):\n            prefix += num\n            dp[idx+1] = min(dp[idx+1], dp[idx])\n            if prefix-target in sums:\n                ans = min(ans, idx-sums[prefix-target] + dp[sums[prefix-target]+1])\n                dp[idx+1] = min(dp[idx+1], idx-sums[prefix-target])\n            sums[prefix] = idx\n        \n        return ans if ans != math.inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        #    h[key] stores list of indices, let ind = h[key][-1] \n        #    Here, run[ind] == key (INCLUDING arr[ind - 1]) \n        run = [0, arr[0]]\n        h = {0: 0, arr[0]: 1}\n        prefix = [len(arr)] \n        for i in range(1, len(arr)):\n            if run[i] - target in h:\n                prefix.append(min(prefix[-1], i - h[run[i] - target]))\n            else:\n                prefix.append(prefix[-1])\n            run.append(run[-1] + arr[i])\n            h[run[-1]] = i + 1\n        suffix = [len(arr) for i in range(len(arr))]\n        if arr[-1] == target:\n            suffix[-1] = 1\n        for i in range(len(arr) - 2, -1, -1):\n            if run[i] + target in h:\n                suffix[i] = min(suffix[i + 1], h[run[i] + target] - i)\n            else:\n                suffix[i] = suffix[i + 1]\n        res = len(arr) + 1\n        for i in range(len(arr)):\n            if not (prefix[i] == len(arr) or suffix[i] == len(arr)):\n                res = min(res, prefix[i] + suffix[i])\n        if res == len(arr) + 1:\n            return -1\n        return res", "from collections import defaultdict\nclass Solution:\n    def getSubArray(self, array, target):\n        dic = defaultdict(int)\n        minSub = [float('inf')] * len(array) \n        currentSum = 0\n        for i, num in enumerate(array):\n            currentSum += num\n            if currentSum == target:\n                minSub[i] = min(minSub[i - 1], i - 0 + 1) \n            elif currentSum - target in dic:\n                minSub[i] =  min(minSub[i - 1], i - dic[currentSum - target]) \n            else:\n                minSub[i] = min(minSub[i - 1], minSub[i])\n            dic[currentSum] = i\n        return minSub\n        \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        result = float('inf')\n        leftMinSub = self.getSubArray(arr, target)\n        rightMinSub = self.getSubArray(arr[::-1], target)[::-1]\n        \n        for i in range(1, n):\n            result = min(result, leftMinSub[i-1] + rightMinSub[i])\n        if result == float('inf'):\n            return -1\n        else:\n            return result", "from collections import defaultdict\nclass Solution:\n    def getSubArray(self, array, target):\n        dic = defaultdict(int)\n        minSub = [float('inf')] * len(array) \n        currentSum = 0\n        for i, num in enumerate(array):\n            currentSum += num\n            if currentSum == target:\n                minSub[i] = i - 0 + 1\n            elif currentSum - target in dic:\n                minSub[i] = i - dic[currentSum - target] + 1\n            minSub[i] = min(minSub[i - 1], minSub[i] )\n            dic[currentSum] = i + 1\n        return minSub\n        \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        result = float('inf')\n        leftMinSub = self.getSubArray(arr, target)\n        rightMinSub = self.getSubArray(arr[::-1], target)[::-1]\n        \n        for i in range(1, n):\n            result = min(result, leftMinSub[i-1] + rightMinSub[i])\n        if result == float('inf'):\n            return -1\n        else:\n            return result", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        INF = len(arr) + 1\n        best_idx = [INF]*len(arr)\n        best = INF        \n        csum = 0\n        \n        left = 0\n        for right in range(len(arr)):\n            csum += arr[right]\n            \n            while csum > target and left<=right:\n                csum -= arr[left]\n                left +=1\n            \n            if csum == target:\n                best = min(best, best_idx[left-1] + right - left + 1 )\n                best_idx[right] = min(best_idx[right-1], right - left + 1)\n            else:\n                best_idx[right] = best_idx[right-1]\n                \n            \n        if INF == best:\n            return -1\n        return best\n              \n'''\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        INF = len(arr) + 1\n        best_at_i = [INF]*len(arr) # the ith index represents the smallest length subarray we've found ending <= i that sums to target\n        best = INF # output \n        curr_sum = 0 # current sum between left and right\n        \n        left = 0\n        for right in range(len(arr)):\n            # update the running sum\n            curr_sum += arr[right]\n            \n            # arr is strictly positive, so shrink window until we're not above target\n            while curr_sum > target and left <= right:\n                curr_sum -= arr[left]\n                left += 1\n                \n            if curr_sum == target:\n                # we have a new shortest candidate to consider\n                best = min(best, best_at_i[left-1] + right - left + 1)\n                best_at_i[right] = min(best_at_i[right-1], right - left + 1)\n            else:\n                # best we've seen is the previous best (overlaps to end if right == 0)\n                best_at_i[right] = best_at_i[right-1]\n\n        if best == INF:\n            return -1\n        return best'''", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        N = len(arr)\n        prefix = [N+1] * N\n        suffix = [N+1] * N\n\n        presum = dict()\n        total = 0\n        presum[0] = -1\n        for i in range(N):\n            total += arr[i]\n            presum[total] = i\n\n        prefix[0] = N+1\n        total = 0\n        for i in range(0, N):\n            total += arr[i]\n            t = N+1\n            xx = total - target\n            if xx in presum:\n                #   \u627e\u5230\u4e00\u4e2atarget\n                t = i - presum[xx]\n            prefix[i] = min(prefix[i-1], t)\n\n        sufsum = dict()\n        total = 0\n        sufsum[0] = N\n        for i in range(N-1, -1, -1):\n            total += arr[i]\n            sufsum[total] = i\n\n        total = 0\n        if arr[-1] == target:\n            suffix[-1] = 1\n        total = arr[-1]\n        for i in range(N-2, -1, -1):\n            total += arr[i]\n            t = N+1\n            xx = total - target\n            if xx in sufsum:\n                #   \u627e\u5230\u4e00\u4e2atarget\n                t = sufsum[xx] - i\n            suffix[i] = min(suffix[i+1], t)\n                \n        # print(prefix)\n        # print(suffix)\n        \n        rtv = N+1\n        for i in range(N-1):\n            cur = prefix[i] + suffix[i+1]\n            rtv = min(rtv, cur)\n        if rtv > N:\n            return -1\n        return rtv", "import collections\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        def get_sub_arrays( arr ):\n            lookup = collections.defaultdict(int)\n            running_sum = 0\n            dp = [float('inf')] * len(arr)\n            \n            for i, num in enumerate(arr):\n                running_sum += num\n                if running_sum == target:\n                    dp[i] = i - 0 + 1\n                elif running_sum - target in lookup:\n                    dp[i] = i - lookup[running_sum - target] + 1\n                lookup[running_sum] = i+1\n                dp[i] = min( dp[i-1], dp[i] )\n            return dp\n        \n        dp_left = get_sub_arrays( arr )                     # from front\n        dp_right = get_sub_arrays( arr[::-1] )[::-1]        # from backwards\n        \n        ans = float('inf')\n        for i in range( 1, len(arr) ):\n            ans = min( ans, dp_left[i-1] + dp_right[i] )\n        return ans if( ans != float('inf') ) else -1\n", "class Solution:\n  # 864 ms\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = count = 0\n    # preMin: store previous shortest length\n    preMin = deque([(-1, inf)])\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n        \n      while len(preMin) >= 2 and preMin[1][0] <= i-1:\n        preMin.popleft()\n      \n      if window == target:\n        # curr: current length\n        curr = j - i + 1\n\n        # find first minimal length n before window start i\n        n = preMin[0][1]\n        # update result if less    \n        if result > curr + n: result = curr + n\n            \n        # update shortest length if less\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\n          \n        # early stopping if found two single targets\n        if curr == 1: count += 1\n        if count == 2: return 2\n\n    return result if result < inf else -1", "class Solution:\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = 0\n    premin = [inf] * len(arr)\n\n    # i: window start, j: window end\n    for j in range(len(arr)):\n      window += arr[j]\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: length\n        curr = j - i + 1\n        if result > curr + premin[i - 1]:\n            result = curr + premin[i - 1]\n        premin[j] = curr if curr < premin[j - 1] else premin[j - 1]\n        \n      else:\n        premin[j] = premin[j - 1]\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        def get_min(arr):\n            min_left = [float('inf')] * n\n            window = 0\n            l = 0\n            for r in range(n):\n                window += arr[r]\n                while window > target:\n                    window -= arr[l]\n                    l += 1\n                if window == target:\n                    min_left[r] = r - l + 1\n                if r > 0:\n                    min_left[r] = min(min_left[r], min_left[r - 1])\n                    \n            return min_left\n        \n        def get_min_right():\n            min_right = [float('inf') for _ in range(n)]\n            window = 0\n            r = n - 1\n            for l in range(n - 1, -1, -1):\n                window += arr[l]\n                while window > target:\n                    window -= arr[r]\n                    r -= 1\n                if window == target:\n                    min_right[l] = r - l + 1\n                if l < n - 1:\n                    min_right[l] = min(min_right[l], min_right[l - 1])\n            return min_right\n        \n        min_left = get_min(arr)\n        min_right = get_min_right() # get_min(arr[::-1])[::-1]\n        print((min_right[::-1]))\n        \n        best = float('inf')\n        for i in range(1, n):\n            best = min(best, min_left[i - 1] + min_right[i])\n        \n        return best if best < float('inf') else -1\n                \n                \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        result = float('inf')\n        # prefix shortest length read from left to right\n        leftmin = self.getMinLen(arr, target, True)\n        # suffix shortest length read from right to left\n        rightmin = self.getMinLen(arr, target, False)\n        for i in range(0, len(arr)-1):\n            result = min(result, leftmin[i] + rightmin[i+1])\n        return result if result != float('inf') else -1\n        \n    def getMinLen(self, arr, target, l2r):\n        # if it's reading from right to left, then reverse input array\n        if not l2r:\n            arr = arr[::-1]\n        memo = {0: 0}\n        result = [float('inf')] * len(arr)\n        curSum = 0\n        for i, num in enumerate(arr):\n            if i > 0:\n                result[i] = result[i-1]\n            curSum += num\n            if curSum - target in memo:\n                curLen = i - memo[curSum - target] + 1\n                result[i] = min(result[i], curLen)\n            memo[curSum] = i + 1\n        if not l2r:\n            result = result[::-1]\n        return result\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        prefix = [float('INF')] * (n+1)\n        suffix = [float('INF')] * (n+1)\n        \n        tmp = 0\n        start = 0\n        for i in range(n):\n            if arr[i] == target:\n                prefix[i+1] = 1\n            elif tmp + arr[i] < target:\n                tmp += arr[i]\n            else:  # tmp + arr[i] > target\n                tmp += arr[i]\n                while tmp > target and start < i:\n                    tmp -= arr[start]\n                    start += 1\n                if tmp == target:\n                    prefix[i+1] = i - start + 1\n            \n            prefix[i+1] = min(prefix[i+1], prefix[i])\n                \n        tmp = 0\n        start = -1\n        for i in range(-1,-n-1,-1):\n            if arr[i] == target:\n                suffix[i] = 1\n            elif tmp + arr[i] < target:\n                tmp += arr[i]\n            else:  # tmp + arr[i] > target\n                tmp += arr[i]\n                while tmp > target and start > i:\n                    tmp -= arr[start]\n                    start -= 1\n                if tmp == target:\n                    suffix[i] = start -i + 1\n            \n            suffix[i] = min(suffix[i], suffix[i+1])  \n            \n#         print(prefix)\n#         print(suffix)\n        \n        min_val = float('INF')\n        for i in range(n):\n            min_val = min(min_val, prefix[i] + suffix[i+1])\n    \n        return min_val if min_val != float('INF') else -1\n        \n            \n                \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        acc = dict()\n        acc[-1] = 0\n        for i in range(0, n):\n            acc[i] = acc[i-1] + arr[i]\n        best_to = [n + 1 for _ in range(n)]\n        best_from = dict()\n        min_total = n + 1 # Naturally impossible length. Will be updated if any possible case exist. Will tell when no possible case\n        min_left = n + 1\n        sum_left = 0\n        s_left = 0\n        \n        for i in range(n):\n            sum_left = acc[i] - acc[s_left-1]\n            # if i == 3:\n                # print(s_left)\n                # print(sum_left)\n            if sum_left == target:\n                best_to[i] = i - s_left + 1\n                best_from[s_left] = i - s_left + 1\n            elif sum_left > target:\n                while s_left < i:\n                    s_left += 1\n                    if acc[i] - acc[s_left-1] < target:\n                        break\n                    if acc[i] - acc[s_left-1] == target:\n                        best_to[i] = i - s_left + 1\n                        best_from[s_left] = i - s_left + 1\n                        break\n        \n        for i in range(1, n):\n            best_to[i] = min(best_to[i], best_to[i-1])\n            \n        # print(best_to)\n        # print(best_from)\n        \n        for i in range(n - 1):\n            if best_to[i] > n:\n                continue\n            \n            if i + 1 in best_from:\n                min_total = min(min_total, best_to[i] + best_from[i + 1])\n        \n        if min_total > n:\n            return -1\n        \n        return min_total\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        dp = [len(arr) + 1] * len(arr)  # min valid subarray length for arr[:i + 1]\n        table = {0: -1}  # key: prefix sum, value: latest index\n        s = 0\n        min_sum = len(arr) + 1\n        for i in range(len(arr)):\n            s += arr[i]\n            if i > 0:\n                dp[i] = dp[i - 1]\n            if s - target in table:\n                length = i - table[s - target]\n                dp[i] = min(dp[i], length)\n                if length <= i:\n                    min_sum = min(min_sum, length + dp[i - length])\n                \n            table[s] = i\n            \n        if min_sum == len(arr) + 1:\n            return -1\n        else:\n            return min_sum", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix={0:-1}\n        current=0\n        queue=[]\n        for i in range(len(arr)):\n            current+=arr[i]\n            prefix[current]=i\n            if not prefix.get(current-target) is None:\n                if len(queue)==0 or prefix[current-target]+1>queue[-1][0]:\n                    queue.append((prefix[current-target]+1,i))\n        if len(queue)<2:\n            return -1\n        min_q=[]\n        current=len(arr)\n        for i in range(len(queue)-1,-1,-1):\n            current=min(current,queue[i][1]-queue[i][0]+1)\n            min_q.append(current)\n        min_q=min_q[::-1]\n        pointer1=0\n        pointer2=1\n        res=-1\n        #print(queue,min_q)\n        while(pointer2<len(queue)):\n            if queue[pointer2][0]<=queue[pointer1][1]:\n                pointer2+=1\n                continue\n            #print(pointer1,pointer2,res)\n            if res<0:\n                res=queue[pointer1][1]-queue[pointer1][0]+1+min_q[pointer2]\n            else:\n                res=min(res,queue[pointer1][1]-queue[pointer1][0]+1+min_q[pointer2])\n            pointer1+=1\n        return res\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        l = r = 0\n        s = arr[l]        \n        res = []\n        while r < len(arr):\n            if s == target:\n                ln = r - l + 1\n                res.append((ln, l, r))\n            \n            if s <= target:\n                r += 1\n                if r < len(arr):\n                    s += arr[r]\n            else:\n                l += 1\n                s -= arr[l-1]\n                if l > r:\n                    r += 1\n                    if r < len(arr):\n                        s += arr[r]\n    \n        msl = [math.inf] * len(arr) #minimum interval length so far from left\n        msr = [math.inf] * len(arr) # minimum interval length so far fromm right\n        \n        \n        mi = math.inf\n        resi = -1\n        for i in range(len(arr)):\n            if resi + 1 < len(res) and res[resi+1][2] == i:\n                resi += 1\n                mi = min(mi,res[resi][0])\n            msl[i] = mi\n            \n        mi = math.inf\n        resi = len(res)\n        for i in range(len(arr) - 1, -1 , -1):\n            if resi-1 >= 0 and res[resi-1][1] == i:\n                resi -= 1\n                mi = min(mi,res[resi][0])\n            msr[i] = mi\n        \n\n        mn = math.inf\n        for i in range(len(arr) - 1):\n            mn = min(mn, msl[i] + msr[i+1])\n        \n        \n        if mn == math.inf:\n            return -1\n        return mn\n        \n", "class Solution:\n  # 864 ms\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = count = 0\n    # preMin: store previous shortest length\n    preMin = [(-1, inf)]\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: current length\n        curr = j - i + 1\n        n = 0 \n        # find first minimal length before window start i\n        for index, length in preMin[::-1]:\n          if index <= i-1: \n            n = length           \n            break\n        # update result if less    \n        if result > curr + n:\n            result = curr + n\n        # update shortest length if less\n        if curr < preMin[-1][-1]:\n          preMin.append((j, curr))\n        # early stopping if found two single targets\n      #  if curr == 1: count += 1\n      #  if count == 2: return 2\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        min_range = None\n        left = self.get_list(arr, target)\n        right = list(reversed(self.get_list(list(reversed(arr)), target)))\n        print(left)\n        print(right)\n        min_length = None\n        for i in range(len(arr) - 1):\n            if left[i] != -1 and right[i+1] != -1:\n                if not min_length:\n                    min_length = left[i] + right[i+1]\n                else:\n                    min_length = min(left[i] + right[i+1], min_length)\n                    \n        return -1 if not min_length else min_length\n        \n    def get_list(self, arr, target):\n\n        prefix_d = dict()\n        prefix_d[0] = -1\n\n        min_range_list = []\n        current_min = -1\n        current = 0\n        for i in range(len(arr)):\n            current += arr[i]\n            if current - target in prefix_d:\n                prev_idx = prefix_d[current - target]\n                dis = i - prev_idx\n                if current_min == -1:\n                    current_min = dis\n                else:\n                    current_min = min(current_min, dis)\n\n            min_range_list.append(current_min)\n            \n            prefix_d[current] = i\n        \n        return min_range_list\n        \n    \n                \n            \n        \n\n                    \n                    \n            \n        \n        \n                    \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        MAX = float('inf')\n        n = len(arr)+1\n        best_till = [MAX for i in range(n+1)] # best subarray length until reach index i (exclusive)\n        presum = 0\n        maps = {} # key: sum, val: index\n        maps[0] = -1\n        ans = best = MAX\n        for i, v in enumerate(arr):\n            presum += v\n            # check if we have a subarray\n            key = presum - target\n            if key in maps:\n                left_idx = maps[key]  # sums(arr[left_idx+1:i+1])\n                curr_len = i - left_idx\n                best = min(best, curr_len) \n                \n                # check if this could be a second subarray\n                if left_idx > -1:\n                    first_len = best_till[left_idx]\n                    ans = min(ans, first_len + curr_len)\n                    \n            best_till[i] = best \n            maps[presum] = i\n            \n        if ans == MAX:\n            return -1\n        return ans\n    \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # dp_left\u306f\u3001\u53f3\u304b\u3089\u898b\u305f\u3068\u304d\u306e\u6700\u5c0f\u9577\u3055array\u3092\u4fdd\u5b58\n        # dp_right\u306f\u3001\u5de6\u304b\u3089\u898b\u305f\u3068\u304d\u306e\u6700\u5c0f\u9577\u3055array\u3092\u4fdd\u5b58\n        def get_sub_arrays( arr ):\n            lookup = collections.defaultdict(int)\n            running_sum = 0\n            dp = [float('inf')] * len(arr)\n            \n            for i, num in enumerate(arr):\n                running_sum += num\n                if running_sum == target:\n                    dp[i] = i - 0 + 1\n                elif running_sum - target in lookup:\n                    dp[i] = i - lookup[running_sum - target] + 1\n                lookup[running_sum] = i+1\n                dp[i] = min( dp[i-1], dp[i] )\n            return dp\n        \n        dp_left = get_sub_arrays( arr )                     # from front\n        dp_right = get_sub_arrays( arr[::-1] )[::-1]        # from backwards\n        \n        ans = float('inf')\n        for i in range( 1, len(arr) ):\n            ans = min( ans, dp_left[i-1] + dp_right[i] )\n        return ans if( ans != float('inf') ) else -1\n", "INF = int(1e9)\n\nclass Solution:\n    def shortest_subarrays(self, a, target):\n        cum = [0]\n        for x in a:\n            cum.append(cum[-1] + x)\n        hist = {0: 0}\n        ret = [INF]\n        for i in range(1, len(cum)):\n            ci = cum[i]\n            begin = hist.get(ci - target, -1)\n            if begin >= 0:\n                ret.append(min(i - begin, ret[-1]))\n            else:\n                ret.append(ret[-1])\n            hist[ci] = i\n        return ret\n\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        forward = self.shortest_subarrays(arr, target)\n        backward = self.shortest_subarrays(reversed(arr), target)\n\n        ret = INF\n        for i in range(1, len(arr) - 1 + 1):\n            ret = min(ret, forward[i] + backward[len(arr) - i])\n        if ret >= INF:\n            return -1\n        return ret", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        curr_sum = 0 \n        h = {0 : 0}\n        f = [100001] * (len(arr) + 1)\n        ans = 100001\n        for index, a in enumerate(arr):\n            curr_sum += a\n            if curr_sum - target in h:\n                ans = min(f[h[curr_sum - target]] + index + 1 - h[curr_sum - target], ans)\n                f[index + 1] = min(f[index], index + 1 - h[curr_sum - target]) \n            else:\n                f[index + 1] = f[index]\n            h[curr_sum] = index + 1\n        return -1 if ans >= 100001 else ans", "class Solution:\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = count = 0\n    # preMin: store previous shortest length\n    preMin = [(-1, inf)]\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: current length\n        curr = j - i + 1\n        n = 0 \n        # find first minimal length before window start i\n        for index, length in preMin[::-1]:\n          if index <= i-1: \n            n = length           \n            break\n        # update result if less    \n        if result > curr + n:\n            result = curr + n\n        # update shortest length if less\n        if curr < preMin[-1][-1]:\n          preMin.append((j, curr))\n        # early stopping if found two single targets\n        if curr == 1: count += 1\n        if count == 2: return 2\n\n    return result if result < inf else -1", "from typing import List\nimport math\nimport sys\n\n\nclass Solution:\n    def __init__(self):\n        self.preceeding_soln_lens = []\n\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # What's the best I can do ENDING at this index.\n        self.preceeding_soln_lens = [sys.maxsize] * len(arr)\n        min_len_sum = sys.maxsize\n        buffer = []\n        buffer_sum = 0\n        buffer_len = 0\n\n        i = 0\n        # O(N)\n        while i < len(arr):\n            # update state\n            buffer_sum += arr[i]\n            buffer_len += 1\n            buffer.append(i)\n\n            sub_array_end_idx = buffer[-1]\n\n            # check constraint\n            if buffer_sum < target:\n                # copy over the previous one\n                self.preceeding_soln_lens[sub_array_end_idx] = self.preceeding_soln_lens[sub_array_end_idx-1]\n\n            while buffer_sum >= target:\n                popped_idx = buffer.pop(0)\n\n                if buffer_sum == target:\n                    # check for the min\n                    self.preceeding_soln_lens[sub_array_end_idx] = min(buffer_len, self.preceeding_soln_lens[sub_array_end_idx-1])\n\n                    if popped_idx > 0:\n                        non_overlapping_previous_soln_idx = popped_idx - 1\n                        min_len_sum = min(min_len_sum, self.preceeding_soln_lens[non_overlapping_previous_soln_idx] + buffer_len)\n                else:\n                    self.preceeding_soln_lens[sub_array_end_idx] = self.preceeding_soln_lens[sub_array_end_idx-1]\n\n                buffer_len -= 1\n                buffer_sum -= arr[popped_idx]\n\n            i += 1\n\n        if min_len_sum == sys.maxsize:\n            return -1\n        return min_len_sum", "from typing import List\nimport heapq\nimport math\nimport sys\n\n\nclass Solution:\n    def __init__(self):\n        self.preceeding_soln_lens = []\n        self.segment_tree = []\n\n    def has_overlap(self, rng, list_of_ranges):\n        s, e = rng\n        if len(list_of_ranges):\n            os, oe = list_of_ranges[-1]\n            if e < os or oe < s:\n                pass\n            else:\n                return True\n\n        return False\n\n    def find_min(self, s, e):\n        min_val = sys.maxsize\n        for i in range(s, e):\n            if self.preceeding_soln_lens[i]:\n                min_val = min(min_val, self.preceeding_soln_lens[i])\n        if min_val == sys.maxsize:\n            return None\n        return min_val\n\n    def n2_find(self, i, lengths):\n        len_one = self.find_min(0,i)\n        if len_one:\n            len_two = self.find_min(i + len_one - 1, len(self.preceeding_soln_lens))\n            if len_two:\n                heapq.heappush(lengths, len_one+len_two)\n\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # What's the best I can do ENDING at this index.\n        self.preceeding_soln_lens = [sys.maxsize] * len(arr)\n        min_len_sum = sys.maxsize\n        buffer = []\n        buffer_sum = 0\n        buffer_len = 0\n\n        i = 0\n        # O(N)\n        while i < len(arr):\n            # update state\n            buffer_sum += arr[i]\n            buffer_len += 1\n            buffer.append(i)\n\n            sub_array_end_idx = buffer[-1]\n\n            # check constraint\n            if buffer_sum < target:\n                # copy over the previous one\n                self.preceeding_soln_lens[sub_array_end_idx] = self.preceeding_soln_lens[sub_array_end_idx-1]\n\n            while buffer_sum >= target:\n                popped_idx = buffer.pop(0)\n\n                if buffer_sum == target:\n                    # check for the min\n                    self.preceeding_soln_lens[sub_array_end_idx] = min(buffer_len, self.preceeding_soln_lens[sub_array_end_idx-1])\n\n                    if popped_idx > 0:\n                        non_overlapping_previous_soln_idx = popped_idx - 1\n                        min_len_sum = min(min_len_sum, self.preceeding_soln_lens[non_overlapping_previous_soln_idx] + buffer_len)\n                else:\n                    self.preceeding_soln_lens[sub_array_end_idx] = self.preceeding_soln_lens[sub_array_end_idx-1]\n\n                buffer_len -= 1\n                buffer_sum -= arr[popped_idx]\n\n            i += 1\n\n        if min_len_sum == sys.maxsize:\n            return -1\n        return min_len_sum", "# Reference : https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/685486/JAVA-O(N)-Time-Two-Pass-Solution-using-HashMap.\n\n\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        # prefix sum\n        # in dictionary, store {sum_until_idx: idx}\n        \n        # iterate through the array and keep current sum\n        # 1. have a left_min_len to track the min length until current idx\n        # if current sum + target is in the dictionary, \n        # then it means there is a target in the right side of the array\n        prefix_sum = {0:-1}\n        cur_sum = 0\n        for i, val in enumerate(arr):\n            cur_sum += val\n            prefix_sum[cur_sum] = i\n        \n        left_min_len = float('inf')\n        ans = float('inf')\n        cur_sum = 0\n        for i, val in enumerate(arr):\n            cur_sum += val\n            if (cur_sum - target) in prefix_sum:\n                left_min_len = min(left_min_len, i-prefix_sum[cur_sum-target])\n            if (cur_sum + target) in prefix_sum:\n                ans = min(ans, left_min_len + prefix_sum[cur_sum+target]-i)\n        \n        return ans if ans < float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        left_min = self.getMinArr(arr, target, True)\n        right_min = self.getMinArr(arr, target, False)\n        \n        result = sys.maxsize\n        for i in range(0, len(arr)-1):\n            if max(left_min[i], right_min[i+1]) != sys.maxsize:\n                result = min(left_min[i] + right_min[i+1], result)\n        \n        return result if result < sys.maxsize else -1\n    \n    def getMinArr(self, arr, target, right):\n        result = [sys.maxsize] * len(arr)\n        current_sum = 0\n        num_map = {0: 0}\n        \n        nums = arr if right else arr[::-1]\n        for i, num in enumerate(nums):\n            if i > 0:\n                result[i] = result[i-1]\n            current_sum += num\n            \n            if current_sum - target in num_map:\n                current_len = i - num_map[current_sum-target] + 1\n                result[i] = min(result[i], current_len)\n            \n            num_map[current_sum] = i+1\n        \n        if not right:\n            result.reverse()\n        \n        return result\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        \n        def aux(arr):\n            h = {0:0}\n            preSum = 0\n            left = [n+1 for i in range(n)]\n            for i in range(1, n+1):\n                preSum = preSum + arr[i-1]\n                h[preSum] = i\n                if preSum-target in h:\n                    left[i-1] = i-h[preSum-target]\n                if i > 1:\n                    left[i-1] = min(left[i-2], left[i-1])\n            return left\n        \n        \n        left = aux(arr)\n        arr.reverse()\n        right = aux(arr)\n        \n        # print(left)\n        # print(right)\n        \n        ans = n+1\n        for i in range(n-1):\n            ans = min(ans, left[i] + right[n-1-(i+1)])\n        return ans if ans < n+1 else -1\n        \n        \n        \n        \n                \n            \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        def get_shortest(array):\n            shortest = [float('infinity') for _ in range(len(arr))]\n            prefix_pos = {}\n            prefix_sum = 0\n            \n            for i in range(len(array)):\n                prefix_sum += array[i]\n\n                if prefix_sum == target:\n                    if i == 0:\n                        shortest[i] = i+1\n                    else:\n                        shortest[i] = min(shortest[i-1], i+1)\n                elif prefix_sum - target in prefix_pos:\n                    shortest[i] = i - prefix_pos[prefix_sum-target] +1\n                shortest[i] = min(shortest[i-1], shortest[i])\n                prefix_pos[prefix_sum] = i+1\n            \n            return shortest\n        \n        left = get_shortest(arr)\n        right = get_shortest(arr[::-1])[::-1]\n        \n        res = float('infinity')\n        for i in range(len(left)-1):\n            res = min(res, left[i]+right[i+1])\n        \n        if res == float('infinity'):\n            return -1\n        return res\n\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        left_sub_array = [len(arr)]*len(arr)\n        \n        sub_sum, next_index = 0, 0\n        \n        for index in range(len(arr)):\n            \n            while sub_sum < target and next_index < len(arr):\n                sub_sum += arr[next_index]\n                \n                if sub_sum > target:\n                    sub_sum -= arr[next_index]\n                    break\n                else:\n                    if sub_sum == target :\n                        left_sub_array[next_index] = (next_index - index) + 1                        \n                    next_index += 1\n\n                    \n            sub_sum -= arr[index]\n            \n            left_sub_array[index] = min(left_sub_array[index], left_sub_array[index - 1])\n        \n        \n        r_arr = arr[::-1]\n        \n        right_sub_array = [len(r_arr)]*len(r_arr)\n        \n        sub_sum, next_index = 0, 0\n        \n        for index in range(len(r_arr)):\n            \n            while sub_sum < target and next_index < len(r_arr):\n                \n                sub_sum += r_arr[next_index]\n                                \n                if sub_sum > target:\n                    sub_sum -= r_arr[next_index]\n                    break\n                else:\n                    if sub_sum == target :\n                        right_sub_array[next_index] = (next_index - index) + 1\n                    next_index += 1\n                    \n            sub_sum -= r_arr[index]\n            right_sub_array[index] = min(right_sub_array[index], right_sub_array[index - 1])\n        \n        right_sub_array = right_sub_array[::-1]\n        \n        min_length = 2*len(arr)\n        \n        # print(left_sub_array, right_sub_array)\n        \n        for index, val in enumerate(left_sub_array[:-1]):\n            \n            min_length = min(min_length, val + right_sub_array[index + 1])\n        \n        \n        if min_length > len(arr):\n            return -1 \n        else:\n            return min_length\n            \n            \n        \n        \n        \n", "class Solution:\n    def getArraysx (self, arr,target):\n        leftSizes = {}\n        rightSizes = {}  #include start-range\n        posleft = 0\n        posright = 0\n        currSum = 0\n        while  posright < len(arr):\n            currSum += arr[posright]\n            if currSum  == target:\n                #update rifht of i, including i\n                rightList = rightSizes.get(posleft,[])\n                rightList.append(posright-posleft + 1)\n                rightSizes[posleft] = rightList\n                #update left of i, not including i\n                if (posright +1 < len(arr)):\n                    leftList = leftSizes.get(posright+1,[])\n                    leftList.append(posright-posleft + 1)\n                    leftSizes[posright+1]=leftList\n                #move pointers to the right\n                posright +=1\n                currSum -= arr[posleft]\n                posleft +=1\n            elif currSum  > target:\n                #remove leftmost element \n                currSum =  currSum - arr[posright] - arr[posleft] \n                posleft +=1\n            else: #currSum < target\n                #include current element move right pointer\n                posright +=1\n        #print ('left', leftSizes)   \n        #print('right', rightSizes)\n        leftArray = [0]*len(arr)\n        fullList = []\n        for i in range(len(arr)):\n            additional = leftSizes.get(i,[])\n            fullList.extend(additional)\n            if len(fullList) > 0:\n                leftArray[i] = min(fullList)\n            else:\n                leftArray[i] = -1\n            \n        rightArray = [0]*len(arr)\n        fullList = []\n        for j in range(len(arr)-1, -1,-1):\n            additional = rightSizes.get(j,[])\n            fullList.extend(additional)\n            if len(fullList) > 0:\n                rightArray[j] = min (fullList)\n            else:\n                rightArray[j] = -1\n                \n        return leftArray, rightArray\n    \n    def updateArrays (self, leftSizes, rightSizes, posleft, posright,maxvalue):\n        # 3 4 5\n        # 1 3 2.    target = 6\n        # update i  =3  for right or equal of 3\n        # update i = 6 for left of 6\n        \n        #update rifht of i, including i\n        value = rightSizes.get(posleft,maxvalue)\n        rightSizes[posleft] = min (value,posright-posleft + 1 )\n        #update left of i, not including i\n        if posright +1 < maxvalue:\n            value = leftSizes.get(posright+1,maxvalue)\n            leftSizes[posright+1]=min (value,posright-posleft + 1  )\n    \n    def getArrays (self, arr,target):\n        leftArray = [0]*len(arr)\n        rightArray = [0]*len(arr)\n        leftSizes = {}\n        rightSizes = {}  #include start-range\n    \n        posleft = 0\n        posright = 0\n        currSum = 0\n        while  posright < len(arr):\n            currSum += arr[posright]\n            if currSum  == target:\n                self.updateArrays(leftSizes,rightSizes, posleft, posright, len(arr))\n                #move pointers to the right\n                posright +=1\n                currSum -= arr[posleft]\n                posleft +=1\n            elif currSum  > target:\n                #remove leftmost element \n                currSum =  currSum - arr[posright] - arr[posleft] \n                posleft +=1\n            else: #currSum < target\n                #include current element move right pointer\n                posright +=1\n        #print ('left', leftSizes)   \n        #print('right', rightSizes)\n        leftArray = [len(arr)]*len(arr)\n        for i in range(1,len(arr)):\n            minValue = leftSizes.get(i,len(arr))\n            leftArray[i] = min(minValue, leftArray[i-1])\n            \n        rightArray = [len(arr)]*len(arr)\n        for j in range(len(arr)-1, -1,-1):\n            minValue = rightSizes.get(j,len(arr))\n            if j == len(arr)-1:\n                rightArray[j] = minValue\n            else:    \n                rightArray[j] = min (minValue, rightArray[j+1])\n\n                \n        return leftArray, rightArray\n    \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n\n        leftArray, rightArray = self.getArrays ( arr,target)\n        #print ('left', leftArray)\n        #print ('right', rightArray)  \n        #process hashmaps by i position\n        minSum = 2*len(arr)\n        for i in range (1,len(arr)):\n            if leftArray[i] < len(arr):\n                leftSize = leftArray[i]\n            else:\n                continue\n            if rightArray[i] < len(arr):\n                rightSize = rightArray[i]\n            else:\n                continue\n            #print (i, leftSize, rigthSize)\n            minSum = min(minSum, leftSize + rightSize)\n        if minSum == 2*len(arr):\n            minSum = -1\n        return minSum\n            \n                \n\n            \n        \n        \n    def minSumOfLengthsx(self, arr: List[int], target: int) -> int:\n        #two pointers \n        #loop until sum = target or > target\n        #if greather than target, move posleft one to the right \n\n        #keep array of lenghts and get the samllet two (this can be optimized)\n        #or get subarrays, even if they overlap, and then choose the smalles when overalp \n        \n        posleft = 0\n        posright = 0\n        lengths = [] # keeping two smallest?\n        currSum = 0\n        while  posright < len(arr):\n            currSum += arr[posright]\n            #`print (posleft, posright, currSum)\n            if currSum  == target:\n                lengths.append(posright-posleft + 1)\n                posright +=1\n                posleft = posright\n                currSum = 0\n                #if posright < len(arr):\n                #   currSum = arr[posright]\n                \n            elif currSum  > target:\n                #remove leftmost element \n                currSum =  currSum - arr[posright] - arr[posleft] \n                posleft +=1\n            else:\n                #include current element move right pointer\n                posright +=1\n                #if posright < len(arr):\n                #    currSum += arr[posright]\n        print(lengths)\n        if len(lengths) < 2:\n            return -1\n        lengths.sort()\n        return sum(lengths[0:2])\n            \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        \n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                \n                # j is on the left\n                # i is on the right\n                j = prefix[curr - target]\n                \n                if j > -1:\n                    # Update the ans, the current one and the non-overlapping best one\n                    ans = min(ans, i - j + best_till[j])\n                \n                # update the shortest length until i\n                best = min(best, i - j)\n                \n            best_till[i] = best\n            prefix[curr] = i\n            \n        return -1 if ans == math.inf else ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        record = collections.defaultdict()\n        record[0] = 0\n        l1 = l2 = float('Inf')\n        tmp_sum = 0\n        res = float('Inf')\n        dp = [float('Inf') for _ in range(len(arr))]\n        for i in range(len(arr)):\n            tmp_sum += arr[i]\n            if tmp_sum - target in record:\n                dp[i] = i - record[tmp_sum - target] + 1\n            record[tmp_sum] = i + 1\n            if i>0:\n                dp[i] = min(dp[i], dp[i-1])\n        \n        record.clear()\n        tmp_sum = 0\n        record[0] = len(arr)\n        for i in range(len(arr)-1, 0, -1):\n            tmp_sum += arr[i]\n            if tmp_sum - target in record:\n                res = min(res, dp[i-1] + record[tmp_sum - target] - i)\n            record[tmp_sum] = i\n            \n        return res if res<float('Inf') else -1\n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        def prefix_sum(arr):\n            lookup = {}\n            dp = [float('inf')] * len(arr)\n            cumsum = 0\n            \n            for i, num in enumerate(arr):\n                cumsum += num\n                if cumsum == target:\n                    dp[i] = i - 0 + 1\n                elif cumsum - target in lookup:\n                    dp[i] = i - lookup[cumsum - target]\n                    \n                lookup[cumsum] = i\n                dp[i] = min(dp[i-1], dp[i] )\n            return dp\n        \n        prefix = prefix_sum(arr)\n        suffix = prefix_sum(arr[::-1])[::-1]\n        \n        ans = float('inf')\n        for i in range(1, len(arr)):\n            ans = min(ans, prefix[i-1] + suffix[i])\n            \n        return ans if ans != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n      \n        if len(arr) < 2:\n            return -1\n        \n        n = len(arr)\n        curSum = 0\n        prefixSum = {0:-1}\n        dp = [float('inf')]*n\n        ans = float('inf')\n        \n        for i in range(n):\n            curSum += arr[i]\n            if curSum - target in prefixSum:\n                j = prefixSum[curSum - target] + 1\n                ans = min(ans, i - j + 1 + dp[j-1])\n                dp[i] = min(dp[i-1], i - j + 1)\n            else:\n                dp[i] = dp[i-1]\n            prefixSum[curSum] = i\n        \n\n        return ans if ans < float('inf') else -1", "class Solution:\n    def getMinArr(self, arr, target, right=False):\n        pre_sum = 0\n        res = [float('inf') for i in range(len(arr))]\n        sum_dict = {0:0}\n        if right:\n            arr = arr[::-1]\n        for i, num in enumerate(arr):\n            pre_sum += num\n            if i > 0:\n                res[i] = res[i-1]\n            if pre_sum - target in sum_dict:\n                cur_len = i - sum_dict[pre_sum - target] + 1\n                res[i] = min(res[i], cur_len)\n            sum_dict[pre_sum] = i + 1\n        if right:\n            res.reverse()\n        return res\n        \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        left_min = self.getMinArr(arr, target)\n        right_min = self.getMinArr(arr, target, True)\n        \n        min_len = float('inf')\n        for i in range(len(arr) - 1):\n            min_len = min(min_len, left_min[i] + right_min[i+1])\n        if min_len == float('inf'):\n            return -1\n        return min_len\n        \n        \n        \n        \n        \n        \n        \n        \n#         prefix_sum = [0 for i in range(len(arr) + 1)]\n#         for i in range(len(arr)):\n#             prefix_sum[i+1] = prefix_sum[i] + arr[i]\n            \n#         prefix = [float('inf') for i in range(len(arr))]\n#         suffix = [float('inf') for i in range(len(arr))]\n        \n#         for i in range(1, len(arr)):\n#             # found = False\n#             for j in range(i-1, -1, -1):\n#                 if prefix_sum[i] - prefix_sum[j] == target:\n#                     # found = True\n#                     prefix[i] = i - j\n#                     break\n        \n#         for i in range(len(arr) - 1, -1, -1):\n#             # found = False\n#             for j in range(i+1, len(arr) + 1):\n#                 if prefix_sum[j] - prefix_sum[i] == target:\n#                     # found = True\n#                     suffix[i] = j - i\n#                     break\n                \n#         for i in range(1, len(prefix)):\n#             prefix[i] = min(prefix[i], prefix[i-1])\n            \n#         for i in range(len(suffix) - 2, -1, -1):\n#             suffix[i] = min(suffix[i], suffix[i+1])\n            \n#         min_len = float('inf')\n#         for i in range(len(arr)):\n#             min_len = min(min_len, prefix[i] + suffix[i])\n#         if min_len == float('inf'):\n#             return -1\n#         return min_len\n", "import sys\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        table={0:-1}\n        cursum=0\n        dp1 = [sys.maxsize for i in range(len(arr))]\n        \n        for i in range(len(arr)):\n            if i>0:\n                dp1[i] = dp1[i-1]\n            cursum += arr[i]\n            if cursum - target in list(table.keys()):\n                dp1[i] = min(dp1[i],i-table[cursum-target])\n            table[cursum]=i\n            \n        #print(table)\n        #print(dp1)\n        \n        table={0:len(arr)}\n        cursum=0\n        dp2 = [sys.maxsize for i in range(len(arr))]\n        for i in range(len(arr)-1,-1,-1):\n            if i< len(arr)-1:\n                dp2[i] = dp2[i+1]\n            cursum += arr[i]\n            if cursum - target in list(table.keys()):\n                dp2[i] = min(dp2[i],table[cursum-target]-i)\n            table[cursum]=i\n        \n        #print(table)\n        #print(dp2)\n    \n        \n        res = sys.maxsize\n        \n        for i in range(len(dp1)-1):\n            if dp1[i] != sys.maxsize and dp2[i+1] != sys.maxsize:\n                res = min(res,dp1[i]+dp2[i+1])\n        \n        if res == sys.maxsize:\n            return -1\n        else:\n            return res\n                    \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)        \n        \n        def get_dp(arr):\n            dp = []\n            ptr = 0\n            total = 0\n            min_val = float('inf')\n            for i in range(n):\n                total += arr[i]\n                while ptr < i and total > target:\n                    total -= arr[ptr]\n                    ptr += 1\n                if total == target:\n                    min_val = min(min_val, i - ptr + 1)\n                dp.append(min_val)\n            return dp\n        dp_left = get_dp(arr)\n        dp_right = get_dp(arr[::-1])[::-1]\n        \n        min_val = float('inf')\n        for i in range(n-1):\n            min_val = min(min_val, dp_left[i] + dp_right[i+1])\n        return min_val if min_val != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = [0]\n        d = {0: -1}\n        for i in range(len(arr)):\n            prefix.append(arr[i] + prefix[-1])\n            d[prefix[-1]] = i\n\n        ans = first = second = float('inf')\n        for i in range(len(arr)):\n            if (prefix[i + 1] - target) in d:\n                first = min(first, i - d[(prefix[i + 1] - target)])\n            if first < float('inf') and (prefix[i + 1] + target) in d:\n                second = d[(prefix[i + 1] + target)] - i\n                ans = min(ans, first + second)\n        \n        return -1 if ans == float('inf') else ans\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        preSum = [0]\n        for val in arr:\n            preSum.append(preSum[-1] + val)\n        sumMap = {}\n        preCands = [sys.maxsize] * len(arr)\n        sufCands = [sys.maxsize] * len(arr)\n        for i, val in enumerate(preSum):\n            if val - target in sumMap:\n                sufCands[sumMap[val - target]] = i - sumMap[val - target]\n                preCands[i - 1] = i - sumMap[val - target]\n            sumMap[val] = i\n        # print(preCands)\n        # print(sufCands)\n        \n        prefixSum = [sys.maxsize] * len(arr)\n        suffixSum = [sys.maxsize] * len(arr)\n        for i, val in enumerate(preCands):\n            if i + 1 < len(prefixSum):\n                prefixSum[i + 1] = min(preCands[i],  prefixSum[i])\n        for i, val in reversed(list(enumerate(sufCands))):\n            if i + 1 < len(suffixSum):\n                suffixSum[i] = min(sufCands[i], suffixSum[i + 1])\n            else:\n                suffixSum[i] = sufCands[i]\n        # print(prefixSum)\n        # print(suffixSum)\n        \n        res = sys.maxsize\n        for i in range(len(arr)):\n            res = min(res, prefixSum[i] + suffixSum[i])\n            \n        return res if res != sys.maxsize else -1\n                \n        \n        \n#         t = 6\n        \n# idx         0 1 2 3 4 5 6 7 8\n        \n# arr         1 2 3 3 2 1 1 1 1\n#                 3 3\n#             1 2 3\n#                   3 2 1\n#                      2 1 1 1 1\n        \n# preSum      0 1 3 6 9 11 12 13 14 15\n        \n# preCands    M M 3 2 M 3 M M 5\n# sufCands    3 M 2 3 5 M M M M\n        \n# prefix      M M M 3 2 2 2 2 2\n# suffix      2 2 2 3 5 M M M M\n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        length=len(arr)\n        cumulative=[0]*length\n        reverse_cumulative=[0]*length\n        s=0\n        sr=0\n        for i in range(length):\n            s=s+arr[i]\n            cumulative[i]=s\n            \n            sr+=arr[(length-1)-i]\n            reverse_cumulative[i]=sr\n        \n        d={0:-1}\n        dr={0:-1}\n        \n        \n        forward_vals=[math.inf]*length\n        backward_vals=[math.inf]*length\n        best1=math.inf\n        best2=math.inf\n        i=0\n        \n        while i<length:\n            d[cumulative[i]]=i\n            \n            dr[reverse_cumulative[i]]=i\n                   \n            if (cumulative[i]-target) in d:\n            #    print(\\\"found\\\",cumulative[i]-target,\\\"!\\\")\n                l=i-d[cumulative[i]-target]\n                best1=min(best1,l)\n            \n            forward_vals[i]=best1    \n                \n             #   print(\\\"the subarray with sum=target is\\\",(start+1,i))\n            if (reverse_cumulative[i]-target) in dr:\n                l=i-dr[reverse_cumulative[i]-target]\n                best2=min(best2,l)\n                \n            backward_vals[i]=best2\n                \n            \n            i+=1\n       # print(cumulative,reverse_cumulative)\n        #print(d,dr)\n        #print(forward_vals,backward_vals)\n        best1=math.inf\n        for i in range(len(forward_vals)-1):\n            best1=min(best1,forward_vals[i]+backward_vals[(length-2)-i])\n        \n        if best1==math.inf:\n            return -1\n        return best1\n        #print(d)\n        \n        \n", "class Solution:\n  # 872 ms\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = 0\n    premin = [inf] * len(arr)\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: length\n        curr = j - i + 1\n        if result > curr + premin[i - 1]:\n            result = curr + premin[i - 1]\n        premin[j] = curr if curr < premin[j - 1] else premin[j - 1]\n        \n      else:\n        premin[j] = premin[j - 1]\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        '''\n        1 1 1 2 2 3 1 1 1 1 1  target : 5\n        '''\n        \n        sP = 0\n        fP = 0\n        \n        intervalHeap = []\n        sumSoFar = 0\n        while fP < len(arr):\n            sumSoFar += arr[fP]\n            if sumSoFar >= target:\n                if sumSoFar == target:\n                    heapq.heappush(intervalHeap, (fP - sP + 1, sP, fP))\n                    \n                while sumSoFar >= target:\n                    sumSoFar -= arr[sP]\n                    sP += 1\n                    if sumSoFar == target:\n                        heapq.heappush(intervalHeap, (fP - sP + 1, sP, fP))\n                \n            fP += 1\n        \n        if len(intervalHeap) > 1:\n            first = heapq.heappop(intervalHeap)\n            second = heapq.heappop(intervalHeap)\n            \n            if first[2] < second[1] or second[2] < first[1]:\n                return first[0] + second[0]\n            else:\n                while intervalHeap:\n                    third = heapq.heappop(intervalHeap)\n                    if third and first[2] < third[1] or third[2] < first[1]:\n                        return first[0] + third[0]\n                    elif third and second[2] < third[1] or third[2] < second[1]:\n                        return second[0] + third[0]\n        \n        return -1\n", "import numpy as np\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        cumsum = np.cumsum(arr)\n        h2idx = {}\n        \n        print(cumsum)\n        minSum = []\n        for idx,c in enumerate(cumsum):\n            # print(c, target, target-c, h2idx)\n            if c == target: \n                minSum.append(idx+1)\n            if (c - target) in h2idx:\n                minSum.append(idx - h2idx[c - target])\n            h2idx[c] = idx\n        if len(minSum) < 2: return -1\n        return sum(list(sorted(minSum))[:2])\n            \n# t = 7\n# [ 2, 2, 3, 4, 3, 4]\n\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n        return -1 if ans == math.inf else ans\n    \n    \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        cumsum = np.cumsum(arr)\n        h2idx = {}\n        INF = math.inf\n        print(cumsum)\n        best_at_i = [INF] * len(arr)\n        best = INF\n        for idx,c in enumerate(cumsum):\n            # print(c, target, target-c, h2idx)\n            if c == target: \n                # print('sdfjsldfjksdl')\n                # best = min(best, best_at_i[left-1] + idx+1)\n                best_at_i[idx] = min(best_at_i[idx-1], idx+1)\n            if (c-target) in h2idx:\n                # print('fhgjdkg')\n                left = h2idx[c-target]\n                best = min(best, best_at_i[left] + idx - left)\n                best_at_i[idx] = min(best_at_i[left], idx - left)\n                # print(idx, left, best_at_i[left], best)\n            h2idx[c] = idx\n            best_at_i[idx] = min(best_at_i[idx-1], best_at_i[idx])\n            \n        print(best_at_i, h2idx)\n        return best if best != INF else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        lim = len(arr)\n        pref = [arr[0]]\n        \n        d = dict()\n        e = dict()\n        d[arr[0]]=[0]\n        e[arr[0]]=1\n        for i in range(1,lim):\n            pref.append(pref[-1]+arr[i])\n            try:\n                d[pref[-1]].append(i)\n                e[pref[i]]+=1\n            except:\n                d[pref[-1]]=[i]\n                e[pref[i]]=1\n                \n        \n        A = [lim]*lim\n        \n        for i in range(0,lim):\n            val = target+pref[i]-arr[i]            \n            if val in d:                \n                l = 0\n                h = e[val]-1\n                mn = lim+1              \n                while l<=h:\n                    m = (l+h)//2                    \n                    if d[val][m]>=i:\n                        if d[val][m]<mn:\n                            mn = d[val][m]\n                        h = m-1\n                    else:\n                        l = m+1\n                if mn!=lim+1:                    \n                    A[i]=mn-i+1                    \n            if arr[i]==target:\n                A[i]=1\n        \n        pmn = lim\n        p = [lim]*lim\n        s = [lim]*lim\n        \n        for i in range(0,lim):\n            if i+A[i]<lim and p[i+A[i]]>A[i]:p[i+A[i]]=A[i]\n        smn = lim\n        if A[-1]<lim:\n            smn=A[-1]\n        \n        for i in range(lim-1,-1,-1):\n            \n            if A[i]<smn:\n                smn = A[i]\n            s[i]=smn\n        \n        mn = lim+1\n        for i in range(0,lim):\n            if p[i]+s[i]<mn:\n                mn = p[i]+s[i]\n        \n        if mn>=lim+1:return -1\n        return mn\n                    \n                    \n", "class Solution:\n  def minSumOfLengths(self, arr, target):\n    inf = 2**31-1\n    i, window, result = 0, 0, inf\n    premin = [inf] * len(arr)\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      \n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: length\n       # print(premin, i, j)\n        curr = j - i + 1\n        if result > curr + premin[i - 1]:\n            result = curr + premin[i - 1]\n        premin[j] = curr if curr < premin[j - 1] else premin[j - 1]\n        \n      else:\n        premin[j] = premin[j - 1]\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        prefix_sum = list(accumulate(arr))\n        suffix_sum = list(accumulate(arr[::-1]))\n        \n        def helper(prefix_sum, n, target):\n            dict_x = {0:-1}\n            l_1 = [n+1 for _ in range(n)]\n            for i in range(n):\n                t1 = prefix_sum[i]-target\n                x = n+1\n                if dict_x.get(t1, 'x') != 'x':\n                    x = i-dict_x[t1]\n                l_1[i] = min(x, l_1[i-1] if i > 0 else n+1)\n                dict_x[prefix_sum[i]] = i\n            return l_1\n        \n        l = helper(prefix_sum, n, target)\n        r = helper(suffix_sum, n, target)[::-1]\n        \n        ans = sys.maxsize\n        for i in range(n-1):\n            ans = min(ans, l[i]+r[i+1])\n        print(ans)\n        return ans if ans <= n else -1\n                \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        smallest = [math.inf] * len(arr) \n        q = deque()\n        curr_sum = 0\n        result = math.inf\n        for i, n in enumerate(arr):\n            curr_sum += n\n            q.append(i)\n            while curr_sum > target:\n                curr_sum -= arr[q.popleft()]\n            \n            if curr_sum == target:\n                if i == 0:\n                    smallest[i] = len(q)\n                else:\n                    smallest[i] = min(len(q), smallest[i-1])\n                    # if q[0] > 0:\n                    result = min(result, smallest[q[0]-1] + len(q))\n            else:\n                # if i > 0:\n                smallest[i] = smallest[i-1]\n        return -1 if result == math.inf else result", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n_arr = len(arr)\n        if n_arr == 0:\n            return -1\n        \n        def get_minlen_ending_before(array: List[int]) -> List[int]:\n            n_array = len(array)\n            minlen_array = [float('inf')] * n_array\n            curr_sum = array[0]\n            i = 0\n            j = 0\n            min_len = float('inf')\n            while i < n_array and j < n_array:\n                increment_i = False\n                increment_j = False\n                if curr_sum == target:\n                    min_len = min(min_len, j - i + 1)\n                    curr_sum -= array[i]\n                    increment_i = True\n                elif curr_sum < target:\n                    increment_j = True\n                    if j < n_array - 1:\n                        curr_sum += array[j+1]\n                elif curr_sum > target:\n                    curr_sum -= array[i]\n                    increment_i = True\n                if j < n_array - 1:\n                    minlen_array[j+1] = min_len\n                if increment_i:\n                    i += 1\n                if increment_j:\n                    j += 1\n                if j < i and i < n_array:\n                    j = i\n                    curr_sum = array[i]\n            return minlen_array\n        \n        prefix = get_minlen_ending_before(arr)\n        postfix = (get_minlen_ending_before(arr[::-1] + [0])[1:])[::-1]\n        \n        min_sum = float('inf')\n        for i in range(n_arr):\n            min_sum = min(min_sum, prefix[i] + postfix[i])\n        return min_sum if min_sum < float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        n = len(arr)\n        su = 0\n        s = 0\n        min_len = float('inf')\n        min_lens = [float('inf') for _ in range(n)]\n        ans = float('inf')\n        for e in range(n):\n            su += arr[e]\n            while su > target:\n                su -= arr[s]\n                s += 1\n                \n            if su == target:\n                cur_len = e - s + 1\n                if s > 0 and min_lens[s - 1] != float('inf'):\n                    ans = min(ans, cur_len + min_lens[s - 1])\n                min_len = min(min_len, cur_len)\n            min_lens[e] = min_len\n        return -1 if ans >= float('inf') else ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        left = list(itertools.accumulate(arr))\n        right = list(itertools.accumulate(arr[::-1]))\n        right = right[::-1]\n        \n        rans = [500000] * len(arr)\n        lans = [500000] * len(arr)\n        \n        i, j, n = 0, 0, len(arr)\n        \n        while i < n and j < n:\n            sm = left[j] - (left[i-1] if i else 0)\n            while sm > target and i <= j:\n                i += 1\n                sm = left[j] - (left[i-1] if i else 0)\n                \n            if sm == target:\n                lans[j] = min(lans[j], j - i + 1)\n                # i += 1\n            \n            j += 1\n        \n        i, j = n-1, n-1\n        while i > -1:\n            sm = right[i] - (right[j+1] if (j+1 < n) else 0)\n            # print(i, j, sm)\n            \n            while sm > target and j >= i:\n                j -= 1\n                sm = right[i] - (right[j+1] if (j+1 < n) else 0)\n                \n            if sm == target:\n                rans[i] = min(rans[i], j - i + 1)\n                # j -= 1\n            i -= 1\n        \n        ans = math.inf\n        # print(lans)\n        # print(rans)\n        mv = 999999999\n        for i in range(n):\n            mv= min(mv, lans[i])\n            lans[i] = mv\n        \n        mv = 212498174\n        for i in range(n-1,-1,-1):\n            mv = min(mv, rans[i])\n            rans[i] = mv\n        \n        \n        for i in range(n-1):\n            ans = min(ans, lans[i] + rans[i+1])\n        \n        return ans if ans < 500000 else -1\n", "from collections import deque\nimport heapq\n\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # record the best at outcome at each index\n        \n        shortest = sys.maxsize \n        record = {}\n        \n        left = 0\n        curr_sum = 0\n        for right in range(len(arr)):\n            curr_sum += arr[right]\n            \n            while curr_sum > target and left <= right:\n                # shrink the window\n                curr_sum -= arr[left]\n                left += 1\n                \n            \n            if curr_sum == target:\n                # found subarray\n                curr_len = right - left + 1\n                prev_len = record.get(left - 1, sys.maxsize)\n                record[right] = min(record.get(right - 1, sys.maxsize), curr_len)\n                \n                # update the result\n                shortest = min(shortest, curr_len + prev_len)\n            else:\n                # keep looking\n                record[right] = record.get(right - 1, sys.maxsize)\n                \n        if shortest == sys.maxsize:\n            return -1\n        \n        return shortest\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        res = [float('inf')] * len(arr)\n        ans = float('inf')\n        currMin = float('inf')\n        i = 0\n        s = 0\n        for j in range(len(arr)):\n            s += arr[j]\n            while s > target:\n                s -= arr[i]\n                i += 1\n            if s == target:\n                currMin = min(currMin, j - i + 1)\n                ans = min(ans, j - i + 1 + res[i-1])\n                \n            res[j] = currMin\n            \n        return ans if ans < float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        dp = [10000000] * n\n        \n        presum = {}\n        presum[0] = -1\n        s = 0\n        bestsofar = 10000000\n        ans = 10000000\n        for i in range(n):\n            s += arr[i]\n            if s - target in presum:\n                j = presum[s - target]\n                bestsofar = min(bestsofar, i - j)\n                \n                if j >= 0:\n                    ans = min(ans, dp[j] + i - j)\n            \n            presum[s] = i\n            dp[i] = bestsofar\n\n        return ans if ans < 10000000 else -1\n", "class Solution:\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i, window = 0, 0\n    premin = [inf] * len(arr)\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      \n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: length\n       # print(premin, i, j)\n        curr = j - i + 1\n        if result > curr + premin[i - 1]:\n            result = curr + premin[i - 1]\n        premin[j] = curr if curr < premin[j - 1] else premin[j - 1]\n        \n      else:\n        premin[j] = premin[j - 1]\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        if not arr:\n            return -1\n        \n        def getdp(arr):\n            dp = [float('inf')]*(len(arr))\n            summ = 0\n            lookup = defaultdict(int)\n            for index, num in enumerate(arr):\n                summ += num\n                if summ == target:\n                    dp[index] = index - 0 + 1\n                elif summ - target in lookup:\n                    dp[index] = min(index - lookup[summ-target] + 1, dp[index-1])\n                else:\n                    dp[index] = dp[index-1]\n\n                lookup[summ] = index + 1\n            return dp\n        \n        dp_left = getdp(arr)\n        dp_right = getdp(arr[::-1])[::-1]\n        \n        ans = float('inf')\n        for i in range(1, len(arr)):\n            ans = min(ans, dp_left[i-1] + dp_right[i])\n        return ans if (ans!=float('inf')) else -1", "class Solution(object):\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n        return -1 if ans == math.inf else ans\n    def OldminSumOfLengths(self, arr, target):\n        ans, l = math.inf, len(arr)\n        la = [math.inf] * l\n        \n        p1, p2, s, ml = 0, 0, arr[0], math.inf\n        while p1 < l and p2 < l:            \n            action = None\n            la[p2] = ml\n            curl = p2 - p1 + 1\n            if s == target:\n                ml = min(ml, curl)    \n                la[p2] = ml\n                if p1 - 1 >= 0: ans = min(ans, la[p1 - 1] + curl)                \n                p2 += 1 \n                action = 1\n            elif s < target:\n                p2 += 1\n                action = 1\n            elif s > target:\n                p1 += 1\n                action = -1\n            if p1 >= l or p2 >= l: break\n            elif p1 > p2:\n                p2 = p1\n                s = arr[p1]\n            else:                \n                if action == 1: s += arr[p2]\n                elif action == -1: s -= arr[p1 - 1]\n        return -1 if ans == math.inf else ans\n                \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        pref = { 0: -1 }\n        \n        result = best = math.inf\n        best_till = [math.inf] * len(arr)\n        \n        for i, curr in enumerate(itertools.accumulate(arr)):\n            diff = curr - target\n            if diff in pref:\n                left = pref[diff]\n                length = i - left\n                result = min(result, best_till[left] + length)\n                best = min(best, length)\n            \n            pref[curr] = i\n            best_till[i] = best\n        return result if result < math.inf else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # premin[i] is the min len of subarr with sum in arr[:i+1]\n        premin = [float('inf')] * len(arr)\n        l, cur, res = 0, 0, float('inf')\n        for r, num in enumerate(arr):\n            if r > 0: premin[r] = premin[r - 1]\n            cur += num\n            while cur > target:\n                cur -= arr[l]\n                l += 1\n            if cur == target:\n                size = r - l + 1\n                if l > 0: res = min(res, size + premin[l - 1])\n                premin[r] = min(premin[r], size)\n        return res if res < float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        psum={0:-1}\n        csum=0\n        re=100001\n        dp=[100001]*(len(arr))\n        best=100001\n        for i,csum in enumerate(itertools.accumulate(arr)):\n            psum[csum]=i\n            if csum-target in psum:\n                best=(min(best,i-psum[csum-target]))\n                re=min(re,dp[psum[csum-target]]+i-psum[csum-target])   \n            dp[i]=best\n        if re<100001:\n            return re\n        return -1\n    \n    # def minSumOfLengths(self, arr: List[int], target: int) -> int:\n    #     prefix = {0: -1}\n    #     best_till = [math.inf] * len(arr)\n    #     ans = best = math.inf\n    #     for i, curr in enumerate(itertools.accumulate(arr)):\n    #         if curr - target in prefix:\n    #             end = prefix[curr - target]\n    #             if end > -1:\n    #                 ans = min(ans, i - end + best_till[end])\n    #             best = min(best, i - end)\n    #         best_till[i] = best\n    #         prefix[curr] = i\n    #     return -1 if ans == math.inf else ans\n", "class Solution:\n  # 872 ms\n  def minSumOfLengths(self, arr, target):\n    if len(arr) < 2: return -1\n    if arr.count(target) >= 2: return 2\n    result = inf = 2**31-1\n    i = window = 0\n    premin = [inf] * len(arr)\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: length\n        curr = j - i + 1\n        if result > curr + premin[i - 1]:\n            result = curr + premin[i - 1]\n        premin[j] = curr if curr < premin[j - 1] else premin[j - 1]\n        \n      else:\n        premin[j] = premin[j - 1]\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix={0:-1}\n        best_till=[math.inf]*len(arr)\n        ans=best=math.inf\n        for i in range(1,len(arr)):\n            arr[i]+=arr[i-1]\n            \n        \n        for i,cur in enumerate(arr):\n            if cur-target in prefix:\n                end=prefix[cur-target]\n                \n                if end>-1:\n                    ans=min(ans,i-end+best_till[end])\n                best=min(best,i-end)\n            best_till[i]=best\n            prefix[cur]=i\n        return -1 if ans==math.inf else ans\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        psum={0:-1}\n        csum=0\n        re=100001\n        dp=[100001]*(len(arr))\n        best=100001\n        for i,csum in enumerate(itertools.accumulate(arr)):\n            psum[csum]=i\n            if csum-target in psum:\n                end=psum[csum-target]\n                best=(min(best,i-end))\n                if end>-1:\n                    re=min(re,dp[end]+i-end)   \n            dp[i]=best\n        if re<100001:\n            return re\n        return -1\n    \n    # def minSumOfLengths(self, arr: List[int], target: int) -> int:\n    #     prefix = {0: -1}\n    #     best_till = [math.inf] * len(arr)\n    #     ans = best = math.inf\n    #     for i, curr in enumerate(itertools.accumulate(arr)):\n    #         if curr - target in prefix:\n    #             end = prefix[curr - target]\n    #             if end > -1:\n    #                 ans = min(ans, i - end + best_till[end])\n    #             best = min(best, i - end)\n    #         best_till[i] = best\n    #         prefix[curr] = i\n    #     return -1 if ans == math.inf else ans\n", "class Solution:\n  def minSumOfLengths(self, arr, target):\n    i, window, result = 0, 0, float('inf')\n    premin = [float('inf')] * len(arr)\n    \n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        curr = j - i + 1\n        result = min(result, curr + premin[i - 1])\n        premin[j] = min(curr, premin[j - 1])\n      else:\n        premin[j] = premin[j - 1]\n\n    return result if result < float('inf') else -1", "class Solution:\n    def minSumOfLengthsOld(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        if n == 1:\n            return -1\n        i = 0\n        j = 0\n        sum_=arr[i]\n        interval = []\n        while i < n and j < n:\n            #print(i,j, sum_)\n            if sum_ == target:\n                interval.append([i,j, (j-i+1)])\n                sum_-=arr[i] \n                i+=1\n                j+=1\n                if j <n:\n                    sum_+=arr[j]\n            elif sum_<target:\n                if j < n-1:\n                    sum_+= arr[j+1]\n                j+=1\n            else:\n                sum_-=arr[i]\n                i+=1\n        if len(interval) == 0:\n            return -1\n        \n        interval.sort(key = lambda x: x[2] )\n        interval_val_sorted = [x for x in interval]\n        interval.sort(key = lambda x: x[0] )\n        '''\n        for i in range(len(interval)):\n            s, e, val = interval_val_sorted[i][0], interval_val_sorted[i][1], interval_val_sorted[i][2]\n            ind = findCeil(e, interval)\n            if ind == -1:\n                continue\n            val1 = ind[2]\n            return val + val1\n        '''\n        print(interval_val_sorted )\n        print(interval)\n        i_ , j_, l_ = interval[0][0], interval[0][1], interval[0][2]\n        #l_1 = 0\n        found = False\n        for i in range(1, len(interval), 1):\n            \n            i_1, j_1, l_1 = interval[i][0], interval[i][1], interval[i][2]\n            #print(i_1, j_1)\n            if i_1 >= i_ and i_1 <= j_:\n                continue\n            if i_ >=i_1 and i_ <=j_1:\n                continue\n            found = True\n            break\n        if found == False:\n            return -1\n        return l_ + l_1\n        \n    def findCeil(self, x, starts):\n        s = 0\n        e = len(starts) -1\n        res = -1\n        while s<=e:\n            mid = s+(e-s) // 2\n            if starts[mid] > x:\n                res = mid\n                e = mid -1\n            else:\n                s = mid +1\n        return res\n        \n        \n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        i = 0 \n        j = 0\n        overlaps = list()\n        #sum_ = arr[i]\n        sum_= 0\n        j = 0\n        while i < n and j < n:\n    \n            sum_+=arr[j]\n            \n            while j<n-1 and sum_ < target:\n                j+=1\n                #print(j)\n                sum_+= arr[j]\n                \n            #print(\\\"B:\\\", i,j, sum_)  \n            if sum_ == target:\n                overlaps.append([i, j])\n                \n            sum_-=arr[i]\n            sum_-=arr[j]\n            i+=1\n            #j+=1\n            #print(\\\"A:\\\", i,j, sum_)\n        if sum_== target:\n            if i <=n-1:\n                overlaps.append([i,j-1])\n        \n        starting = [x for [x,y] in overlaps]\n        length = [y-x+1 for [x,y] in overlaps]\n        l_o = len(length)\n        if l_o == 0:\n            return -1\n        min_arr = [length[-1]]\n        s = 1\n        min_ = length[-1]\n        for i in range(l_o-2, -1, -1):\n            min_ = min(length[i], min_)\n            min_arr.append(min_)\n            \n        min_length = sys.maxsize\n        #print(overlaps)\n        #print(starting)\n        #print(length)\n        #print(min_arr)\n        min_arr = list(reversed(min_arr))\n        for overlap in overlaps:\n            s, e = overlap[0], overlap[1]\n            indi = self.findCeil(e, starting)\n            #print(\\\"s,e, indi\\\", s, e, indi)\n            if indi == -1:\n                continue\n            min_length = min(min_length, e-s+1 + min_arr[indi])\n            #print(min_length)\n        if min_length == sys.maxsize:\n            return -1\n        \n        return min_length\n                \n            \n        \n        \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        left = self.shortestTails(arr, target, False)\n        right = self.shortestTails(arr, target, True)\n        \n        mn = float('inf')\n        for i in range(len(arr)-1):\n            if left[i][0] < float('inf') and right[i+1][0] < float('inf'):\n                mn = min(mn, left[i][0]+right[i+1][0])\n            \n        return mn if mn < float('inf') else -1\n            \n            \n    def shortestTails(self, arr, target, reverse):\n        end = len(arr)-1 if reverse else 0\n        \n        prefixSumMap = {\n            0: len(arr) if reverse else -1\n        }\n        s = 0\n        \n        shortestAt = [None]*len(arr)\n        shortest = (float('inf'), -1, -1)\n        \n        for _ in range(len(arr)):\n            s+=arr[end]\n            \n            diff = s-target\n            if diff in prefixSumMap:\n                start = prefixSumMap[diff]\n                \n                if abs(end-start) < shortest[0]:\n                    shortest = (abs(end-start), start, end)\n                \n            shortestAt[end] = shortest\n                \n            prefixSumMap[s] = end\n            end = end-1 if reverse else end+1\n        #print(shortestAt)\n        return shortestAt", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        mp = {}\n        sum_list = 0\n        mp[0] = -1;\n        for i, val in enumerate(arr):\n            sum_list += val\n            mp[sum_list] = i\n        \n        res = float('inf')\n        lvalue = float('inf')\n        sum_list = 0\n        # print(mp)\n        \n        for i, val in enumerate(arr):\n            sum_list += val\n            if sum_list - target in mp:\n                lvalue = min(lvalue, i - mp[sum_list - target])\n            \n            if sum_list + target in mp and lvalue != float('inf'):\n                res = min(res, lvalue + mp[sum_list + target] - i)\n        \n        return -1 if res == float('inf') else res\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        if not arr:\n            return 0\n        \n        min_at_curr = [float('inf')]*len(arr)\n        start = end = 0\n        currSum = 0\n        minSum = float('inf')\n        \n        while end < len(arr):\n            currSum += arr[end]\n            \n            while start <= end and currSum > target:\n                currSum -= arr[start]\n                start += 1\n                \n            if currSum == target:\n                minSum = min(minSum, min_at_curr[start-1] + (end-start) + 1)\n                min_at_curr[end] = min(min_at_curr[end-1], end-start+1)\n                \n            else:\n                min_at_curr[end] = min_at_curr[end-1]\n            \n            end += 1\n                \n        return minSum if minSum != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        # dp[i] means the minimum length of the sub-array with sum equal to target from 0 to i\n        dp = [100001] * (n)\n        presum = {0: -1}\n        s = 0\n        ans = 100001\n        best_so_far = sys.maxsize\n        for i in range(n):\n            s += arr[i]\n            presum[s] = i\n            \n            if s - target in presum:\n                j = presum[s - target]\n                best_so_far = min(best_so_far, i - j)\n                if j >= 0:\n                    ans = min(ans, dp[j] + i - j)\n            \n            dp[i] = best_so_far\n        \n        return ans if ans < 100001 else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        dp = [float('inf')] * n\n        sums, res = 0, float('inf')\n        \n        sum_record = {0: -1}\n        \n        for i, num in enumerate(arr):\n            sums += num\n            dp[i] = dp[i - 1]\n            if sums - target in sum_record:\n                cur_len = i - sum_record[sums - target]\n                if i - cur_len >= 0:\n                    res = min(res, cur_len + dp[i - cur_len])\n                dp[i] = min(dp[i - 1], cur_len)\n            sum_record[sums] = i\n        return res if res != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n\n        H = {0: -1}   \n        total = 0\n        M = len(arr) + 1\n        \n        for i, a in enumerate(arr):\n            total += a\n            H[total] = i\n            \n        result = M\n        minL = M\n        total = 0\n        for i, a in enumerate(arr):\n            total += a\n            \n            if total - target in H:\n                minL = min(minL, i - H[total - target])\n                \n            if total + target in H and minL < M:\n                result = min(result, minL + H[total + target] - i)\n                \n        return result if result < M else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n        return -1 if ans == math.inf else ans\n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        dp = [float('inf')]*(n+1)\n        s, e = 0, 0\n        total = 0\n        while e < n:\n            total += arr[e]\n            e += 1\n            while total > target:\n                total -= arr[s]\n                s += 1\n            if total == target:\n                dp[e] = e-s\n\n        ans = float('inf')\n        for i in range(1, n+1):\n            if dp[i]<= i:\n                ans = min(ans, dp[i-dp[i]]+dp[i])\n            dp[i] = min(dp[i], dp[i-1])\n\n        return ans if ans<float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        minlen = [float('inf')] * len(arr)\n        res = float('inf')\n        l, r, windsum = 0, 0, 0\n        for r in range(len(arr)):\n            windsum += arr[r]\n            while windsum > target:\n                windsum -= arr[l]\n                l += 1\n            if windsum == target:\n                if minlen[l-1] != float('inf'):\n                    temp = minlen[l-1] + r - l + 1\n                    res = min(res, temp)\n                minlen[r] = min(minlen[r-1], r - l + 1)\n            else:\n                minlen[r] = minlen[r-1]\n        return res if res < float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        accuArr = []\n        y = 0\n        for x in arr:\n            y += x\n            accuArr.append(y)\n        bestTill = [float('inf')] * len(arr)\n        bestTillNow = float('inf')\n        sum2Pos = dict()\n        sum2Pos[0] = -1\n        res = float('inf')\n        for i in range(len(accuArr)):\n            currAccu = accuArr[i]\n            preSum = currAccu - target\n            if preSum in sum2Pos:\n                preEnd = sum2Pos[preSum]\n                currLength = i - preEnd\n\n                if preEnd != -1:\n                    res = min(res, currLength + bestTill[preEnd])\n                    \n                bestTillNow = min(bestTillNow, currLength)\n                \n            \n            sum2Pos[currAccu] = i\n            bestTill[i] = bestTillNow\n        \n        return res if res != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        minLen = float('inf')\n        lsize = float('inf')\n        preSum = {0: -1}\n        curSum = 0\n        for i, val in enumerate(arr):\n            curSum += val\n            preSum[curSum] = i\n        curSum = 0\n        for i, val in enumerate(arr):\n            curSum += val\n            if curSum-target in preSum:\n                lsize = min(lsize, i-preSum[curSum-target])\n            if curSum+target in preSum and lsize != float('inf'):\n                minLen = min(minLen, preSum[curSum+target]-i+lsize)\n        return minLen if minLen != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # PreSum. for every i, find the minimum value of length of sub-array on the left or starting with i whose value is equal to target. Find another sub-array starting with i+1, whose sum is target. Update the result with the minimum value of the sum of both the sub-array. This is possible because all values are positive and the value of sum is strictly increasing, meaning arr[i]+target will always be on the right of i, and, if arr[i]+target exists, there will only be one answer (this condition also applies to arr[i]-target, there will only be one answer for each i if the answer exists, as the array is strictly increasing and there's no zeros) \n        \n        preSum = {0: -1}\n        n = len(arr)\n        curSum = 0\n        minLen = float('inf')\n        lsize = float('inf')\n        for i in range(n):\n            curSum += arr[i]\n            preSum[curSum] = i\n        curSum = 0\n        for i in range(n):\n            curSum += arr[i]\n            if curSum-target in preSum:\n                lsize = min(lsize, i-preSum[curSum-target])\n            if curSum+target in preSum and lsize != float('inf'):\n                minLen = min(minLen, preSum[curSum+target]-i+lsize)\n        return minLen if minLen != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        start, ans, sum = 0, float('inf'), 0\n        best = [float('inf')]*(len(arr))\n        best_so_far = float('inf')\n        \n        for i in range(len(arr)):\n            sum += arr[i]\n            while sum > target:\n                sum -= arr[start]\n                start += 1\n            if sum == target:\n                if start > 0 and best[start-1] != float('inf'):\n                    ans = min(ans, best[start-1] + i-start +1)\n                best_so_far = min(best_so_far, i-start+1)\n            best[i] = best_so_far\n        return -1 if ans == float('inf') else ans\n                    \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # PreSum. for every i, find the minimum value of length of sub-array on the left or starting with i whose value is equal to target. Find another sub-array starting with i+1, whose sum is target. Update the result with the minimum value of the sum of both the sub-array. This is possible because all values are positive and the value of sum is strictly increasing, meaning arr[i]+target will always be on the right of i, and, if arr[i]+target exists, there will only be one answer (this condition also applies to arr[i]-target, there will only be one answer for each i if the answer exists, as the array is strictly increasing and there's no zeros) \n        # Again the array is strictly increasing, so at each i, there may exist one left solution including i and one right solution including i, compare those against all prior left solutions and all prior right solutions. Now, no need to compare right solution if there has never been a left solution.\n        preSum = {0: -1}\n        n = len(arr)\n        curSum = 0\n        minLen = float('inf')\n        lsize = float('inf')\n        for i in range(n):\n            curSum += arr[i]\n            preSum[curSum] = i\n        curSum = 0\n        for i in range(n):\n            curSum += arr[i]\n            # compare current solution to hit curSum-target including i with all prior left solutions\n            if curSum-target in preSum:\n                lsize = min(lsize, i-preSum[curSum-target])\n            # If left solution exists, compare current solution to hit curSum+target including i with all prior right solutions\n            if curSum+target in preSum and lsize != float('inf'):\n                minLen = min(minLen, preSum[curSum+target]-i+lsize)\n        return minLen if minLen != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        res = n + 1\n\n        pre = {}\n        pre[0] = -1\n        dp = [float('inf')] * n\n\n        p = 0\n        for i, a in enumerate(arr):\n            p += a\n            dp[i] = dp[i - 1]\n            if (p - target) in pre:\n                cur = i - pre[p - target]\n                if pre[p - target] >= 0 and dp[pre[p - target]] != float('inf'):\n                    res = min(res, cur + dp[pre[p - target]])\n                dp[i] = min(i - pre[p - target], dp[i - 1])\n            pre[p] = i\n        \n        return -1 if res == n + 1 else res\n\n#https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/solution/biao-zhun-de-dong-tai-gui-hua-zhu-xing-jiang-jie-b/\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n\n        l = 0\n        currentSum = 0\n        res = -1\n        record = [-1] * len(arr)\n        for r in range(len(arr)):\n            currentSum += arr[r]\n            while currentSum > target and l < r:\n                currentSum -= arr[l]\n                l += 1\n            if currentSum == target:\n                curr = r - l + 1\n                print(curr)\n                if record[l-1] != -1:\n                    res = curr + record[l-1] if res == -1 else min(res, curr + record[l-1])\n                record[r] = curr if record[r-1]==-1 else min(record[r-1], curr)\n            else:\n                record[r] = record[r-1]\n        return res\n                \n        \n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix_sum2_idx = defaultdict(int)\n        prefix_sum2_idx[0] = -1\n        prefix_sum = 0 \n        n = len(arr)\n        \n        for i in range(n):\n            prefix_sum += arr[i]\n            prefix_sum2_idx[prefix_sum] = i\n        \n        prefix_sum = 0\n        l_min_len = float('inf')\n        min_len = float('inf')\n        \n        for i in range(n):\n            prefix_sum += arr[i]\n            # find min length whose right end point is i \n            if prefix_sum - target in prefix_sum2_idx:\n                l_min_len = min(l_min_len, i - prefix_sum2_idx[prefix_sum - target])\n            \n            # find min length whose left start point is i + 1\n            if prefix_sum + target in prefix_sum2_idx:\n                min_len = min(min_len, prefix_sum2_idx[prefix_sum + target] - i + l_min_len)\n            \n        return -1 if min_len == float('inf') else min_len\n        \n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        for i in range(1, len(arr)):\n            arr[i] += arr[i-1]\n        \n        # arr is now prefix_sum\n        \n        index = {0: -1} # map prefix_sum -> index of that sum\n        best_till = [float('inf')] * len(arr) # best_till[i] is best answer up till that\n        res = float('inf')\n        best = float('inf')\n        \n        for i,val in enumerate(arr):\n            if val-target in index:\n                start_of_window = index[val-target]\n                length = i - start_of_window\n                res = min(res, best_till[start_of_window+1] + length)\n                best = min(best, length)\n            if i+1 < len(best_till):\n                best_till[i+1] = best\n            index[val] = i\n        \n        return -1 if res == float('inf') else res\n        \n        \n'''\ntarget=7\n[1,6,1]\n\narr=[1,7,8]\nindex { 0->-1, 1->0, }\nbest_till= [inf, 2, 2]\nres = inf\n\ni=2, val=8\nstart_of_window = 0\nlength = 2\n\n'''", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        sums_list = [0]\n        sums_dict ={0:0}\n    \n        s=0\n        for i in range(len(arr)):\n            s += arr[i]\n            sums_dict[s] = i + 1\n            sums_list.append(s)\n\n            \n        lengths = [0]*len(sums_list)\n        min_length = float('+inf')\n        for start in range(len(sums_list) - 1, -1, -1):\n            #s[end] - s[start] = target\n            val = sums_list[start] + target\n            if val in sums_dict:\n                end = sums_dict[val]\n                min_length = min(min_length, end - start)\n            lengths[start] = min_length\n        \n        min_length = float('+inf')\n        for start in range(len(sums_list)):\n            val = sums_list[start] + target\n            if val in sums_dict:\n                end = sums_dict[val]\n\n                l = end - start + lengths[end]\n                min_length = min(min_length, l)\n        if min_length != float('+inf'):\n            return min_length\n        else:\n            return -1\n        \n            \n        \n        \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        \n#         def aux(arr):\n#             h = {0:0}\n#             preSum = 0\n#             left = [n+1 for i in range(n)]\n#             for i in range(1, n+1):\n#                 preSum = preSum + arr[i-1]\n#                 h[preSum] = i\n#                 if preSum-target in h:\n#                     left[i-1] = i-h[preSum-target]\n#                 if i > 1:\n#                     left[i-1] = min(left[i-2], left[i-1])\n#             return left\n        \n        \n#         left = aux(arr)\n#         arr.reverse()\n#         right = aux(arr)\n        \n#         ans = n+1\n#         for i in range(n):\n#             ans = min(ans, left[i] + right[n-1-(i+1)])\n#         return ans if ans < n+1 else -1\n        \n        \n        # h = {0:-1}\n        # preSum = [0 for i in range(n)]\n        # for i in range(n):\n        #     preSum[i] = preSum[i-1] + arr[i] if i > 0 else arr[0]\n        #     h[preSum[i]] = i\n        # left = [n+1 for i in range(n)]\n        # ans = n+1\n        # for i in range(n):\n        #     if preSum[i]-target in h:\n        #         left[i] = i-h[preSum[i]-target]\n        #     if i > 0:\n        #         left[i] = min(left[i-1], left[i])\n        #     if left[i] < n+1 and preSum[i]+target in h:\n        #         right = h[preSum[i]+target]-i\n        #         ans = min(ans, left[i]+right)\n        # return ans if ans < n+1 else -1\n                \n            \n        h = {0:-1}\n        preSum = 0\n        for i in range(n):\n            preSum = preSum + arr[i] if i > 0 else arr[0]\n            h[preSum] = i\n        ans = n+1\n        left = n+1\n        preSum = 0\n        for i in range(n):\n            preSum += arr[i]\n            if preSum-target in h:\n                left = min(left, i-h[preSum-target])\n            if left < n+1 and preSum+target in h:\n                right = h[preSum+target]-i\n                ans = min(ans, left+right)\n        return ans if ans < n+1 else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        mapsum = {}\n        mapsum[0] = -1\n        totsum = 0\n\n        best_till = [math.inf] * len(arr)\n        best = math.inf\n        end = -1\n        res = float('inf')\n\n        for i in range(len(arr)):\n            totsum += arr[i]\n            if (totsum - target) in mapsum :\n                end = mapsum[totsum-target]\n                if end > -1:\n                    res =  min(res, i-end+best_till[end])     \n                best = min(best,i-end)\n            best_till[i] = best\n            mapsum[totsum] = i    \n            \n            \n\n        if res < math.inf:\n            return res\n        return res if res < math.inf else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # They are all positive\n\n        n = len(arr)\n        # DP is shortest array up to i\n        dp = [float('inf') for _ in range(n+1)]\n        \n        ans = float('inf')\n        \n        start = 0\n        \n        curr_sum = 0\n        for end in range(n):\n            curr_sum += arr[end]\n            \n            while start < end and curr_sum > target:\n                curr_sum -= arr[start]\n                start += 1\n                \n            if curr_sum == target:\n                ans = min(ans, end - start + 1 + dp[start-1]) # or start - 1\n                dp[end] = min(dp[end-1], end - start + 1)\n            else:\n                dp[end] = dp[end-1]\n\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n\n        prefix = []\n        for n in arr:\n            if len(prefix) == 0: \n                prefix.append(n)\n            else:\n                prefix.append(prefix[-1] + n)\n        \n        indexMap = {}\n        indexMap[0] = -1\n        best = output = float('inf')\n        best_till = [float('inf')] * len(arr)\n        for i, p in enumerate(prefix):\n            if p - target in indexMap:\n                output = min(output, i - indexMap[p - target] + best_till[indexMap[p - target]])\n                best = min(best, i - indexMap[p - target])\n            best_till[i] = best\n            indexMap[p] = i\n        \n\n        return -1 if output == float('inf') else output", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        dp = [float('inf') for i in range(len(arr))]\n        curr_sum = 0\n        hist = {0:-1}\n        res = float('inf')\n        shortest_length = float('inf')\n        for i, num in enumerate(arr):\n            curr_sum += num\n            diff = curr_sum - target\n            if diff in hist:\n                index = hist[diff]\n                length = i - index\n                # print(i, index)\n                if index > 0 and dp[index] != float('inf'):\n                    res = min(res, dp[index] + length)\n                shortest_length = min(shortest_length, length)\n            hist[curr_sum] = i\n            dp[i] = shortest_length\n        # print(dp)\n        return res if res != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        p = [0]\n        m = {0: -1}\n        minLen = [float('inf')]\n        cur = 0\n        ans = best = float('inf')\n        for i, a in enumerate(arr):\n            cur += a\n            p.append(cur)\n            if cur-target in m:\n                ans = min(ans, i-m[cur-target]+minLen[m[cur-target]+1])\n                best = min(i-m[cur-target], best)\n            minLen.append(best)\n            m[cur] = i\n        \n        return ans if ans != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        start, window_sum, result = 0, 0, float('inf')\n        pre_min = len(arr) * [float('inf')]\n        for i, num in enumerate(arr):\n            window_sum += num\n            while window_sum > target:\n                window_sum -= arr[start]\n                start += 1\n            if window_sum == target:\n                curr_len = i - start + 1\n                result = min(result, curr_len + pre_min[start-1])\n                pre_min[i] = min(curr_len, pre_min[i-1])\n            else:\n                pre_min[i] = pre_min[i-1]\n        return result if result < float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        sums = {0:-1}\n        prefix = 0\n        dp = [math.inf for _ in range(len(arr)+1)]\n        ans = math.inf\n        for idx, num in enumerate(arr):\n            prefix += num\n            dp[idx+1] = min(dp[idx+1], dp[idx])\n            if prefix-target in sums:\n                ans = min(ans, idx-sums[prefix-target] + dp[sums[prefix-target]+1])\n                dp[idx+1] = min(dp[idx+1], idx-sums[prefix-target])\n            sums[prefix] = idx\n        \n        return ans if ans != math.inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefxSum, prefx=0, []\n        suffxSum, suffx=sum(arr), []\n        dct={0:-1}\n        dp = [float('inf')] * len(arr)\n        \n        for i in range(0, len(arr)):\n            x=arr[i]\n            prefxSum+=x\n            prefx.append(prefxSum)\n            suffx.append(suffxSum)\n            suffxSum-=x\n            dct[prefxSum]=i\n            \n        prefxSum=0\n        mn=float('inf')\n        for i in range(0, len(arr)):\n            prefxSum+=arr[i]\n            #if prefxSum==target:\n            #    dp[i]=1\n            '''\n                if prefxSum-arr[i] in dct:\n                    start=dct[prefxSum-arr[i]]\n                    if dp[start]!=float('inf'):\n                        mn=min(mn, dp[start]+dp[i])\n            '''   \n            if prefxSum-target in dct:\n                start=dct[prefxSum-target]\n                #print(\\\"i: \\\",i,\\\", j: \\\",dct[prefxSum-target])\n                if start>-1:\n                    if dp[start]!=float('inf'):\n                        mn=min(mn, dp[start]+i-start)\n                    dp[i]=min(dp[i-1], i-start)\n                else:\n                    dp[i]=i+1\n            elif i>0:\n                dp[i]=dp[i-1]\n        #print(dp)\n        return mn if mn!=float('inf') else -1\n        '''\n        below brute force DOES NOT WORK\n        idx=[]\n        for i in range(0, len(arr)):\n            for j in range(i, len(arr)):\n                if sum(arr[i:(j+1)])==target:\n                    idx.append([j-i+1,i, j])\n        #print(idx)            \n        if len(idx)<2:\n            return -1\n        idx=sorted(idx)\n        #print(idx)\n        \n        a1=idx[0][0]\n        L0, i,j=idx[0]\n        for k in range(1, len(idx)):\n            L, start, end=idx[k]\n            #if not (start<=i<=end or start<=j<=end):\n            if not (i<=start<=j or i<=end<=j):\n                #idx.append([j-i+1,i, j])\n                a2=end-start+1\n                return a1+a2\n                \n        #return idx[0][0] + idx[1][0]\n        return -1\n        '''", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        if not arr:\n            return 0\n        n = len(arr)\n        dp = [float('inf')] * n\n        presum = 0\n        indexes = {0: -1}\n        res = float('inf')\n        for i, a in enumerate(arr):\n            presum += a\n            if i > 0:\n                dp[i] = dp[i - 1]\n            if presum - target in indexes:\n                idx = indexes[presum - target]\n                l = i - idx\n                if dp[idx] != float('inf'):\n                    res = min(res, l + dp[idx])\n                dp[i] = min(dp[i], l)\n                \n            indexes[presum] = i\n        # print(indexes)\n        # print(dp)\n        return res if res < float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix_sum = [float('inf')] * len(arr)\n        suffix_sum = [float('inf')] * len(arr)\n        prefix_map = {0: -1}\n        suffix_map = {0: len(arr)}\n        cur_sum = 0\n        _min_till_now = float('inf')\n        for i in range(len(arr) - 1):\n            cur_sum += arr[i]\n            if cur_sum - target in prefix_map:\n                _min_till_now = min(_min_till_now, i - prefix_map[cur_sum - target])\n\n            prefix_sum[i + 1] = _min_till_now\n            prefix_map[cur_sum] = i\n\n        cur_sum = 0\n        _min_till_now = float('inf')\n        for i in range(len(arr) - 1, -1, -1):\n            cur_sum += arr[i]\n            if cur_sum - target in suffix_map:\n                _min_till_now = min(_min_till_now, suffix_map[cur_sum - target] - i)\n            suffix_sum[i] = _min_till_now\n            suffix_map[cur_sum] = i\n        \n        ans = min([x+y for x, y in zip(prefix_sum, suffix_sum)])\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        if not arr:\n            return -1\n        \n        \n        prefixes = [0] * len(arr)\n        suffixes = [0] * len(arr)\n        \n        left = right = 0\n        curr = 0\n        min_len = float('inf')\n        while right < len(arr):\n            curr += arr[right]\n            \n            while curr >= target and left <= right:\n                if curr == target:\n                    l = right - left + 1\n                    if l < min_len:\n                        min_len = l\n                        \n                curr -= arr[left]\n                left += 1\n                \n            prefixes[right] = min_len\n            right += 1\n            \n        left = right = len(arr)-1\n        curr = 0\n        min_len = float('inf')\n        while left >= 0:\n            curr += arr[left]\n             \n            while curr >= target and left <= right:\n                if curr == target:\n                    l = right - left + 1\n                    if l < min_len:\n                        min_len = l\n                        \n                curr -= arr[right]\n                right -= 1\n                \n                    \n            suffixes[left] = min_len\n            left -= 1\n        \n        #print(prefixes)\n        #print(suffixes)\n        \n        min_len = float('inf')\n        \n        for i in range(len(arr)-1):\n            s = prefixes[i] + suffixes[i+1]\n            if s < min_len:\n                min_len = s\n        return min_len if min_len != float('inf') else -1\n            \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        arr_len = len(arr)\n        dp = [sys.maxsize] * arr_len\n        left = right = 0\n        sum_tmp = 0\n        length, ans_len = sys.maxsize, sys.maxsize\n        while right < arr_len:\n            sum_tmp += arr[right]\n            while sum_tmp > target:\n                sum_tmp -= arr[left]\n                left += 1\n            if sum_tmp == target:\n                if left > 0 and dp[left-1] != sys.maxsize:\n                    length = min(length, dp[left-1] + right - left + 1)\n                ans_len = min(ans_len, right - left + 1)\n            dp[right] = ans_len\n            right += 1\n        \n        return length if length != sys.maxsize else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        best_to = [n + 1 for _ in range(n)]\n        best_from = dict()\n        min_total = n + 1 # Naturally impossible length. Will be updated if any possible case exist. Will tell when no possible case\n        min_left = n + 1\n        sum_left = 0\n        s_left = 0\n        \n        for i in range(n):\n            sum_left += arr[i]\n            if sum_left == target:\n                best_to[i] = i - s_left + 1\n                best_from[s_left] = i - s_left + 1\n            elif sum_left > target:\n                while s_left < i and sum_left > target:\n                    sum_left -= arr[s_left]\n                    s_left += 1\n                if sum_left == target:\n                    best_to[i] = i - s_left + 1\n                    best_from[s_left] = i - s_left + 1\n        \n        for i in range(1, n):\n            best_to[i] = min(best_to[i], best_to[i-1])\n        \n        for i in range(n - 1):\n            if best_to[i] > n:\n                continue\n            \n            if i + 1 in best_from:\n                min_total = min(min_total, best_to[i] + best_from[i + 1])\n        \n        if min_total > n:\n            return -1\n        \n        return min_total\n", "from collections import *\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        mapper = defaultdict(int)\n        prefix = [0] * len(arr)\n        prefix[0] = arr[0]\n        mapper[0] = -1\n        mapper[arr[0]] = 0\n        for i in range(1, len(arr)):\n            prefix[i] = prefix[i-1] + arr[i]\n            mapper[prefix[i]] = i\n        cumu = count = 0\n        l = r = None\n        ans = float('inf')\n        vis = []\n        # print(mapper)\n        for i, a in enumerate(arr):\n            cumu += a\n            # print(cumu, cumu - target in mapper)\n            if cumu - target in mapper:\n                if l == None:\n                    count += 1\n                    l = i - mapper[cumu - target]\n                    # print(i, mapper[cumu - target])\n                    vis.append((mapper[cumu - target] + 1, i))\n                else:\n                    l = min(l, i - mapper[cumu - target])\n            if l != None and cumu + target in mapper:\n                ans = min(ans, mapper[cumu+target]-i+l)\n        if ans == float('inf'):\n            return -1\n        return ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # left to right, compute min length of subarray using elems from 0 up to and including i\n        # right to left, compute min length of subarray using elems from i+1 to n-1\n        # go thru array, pick i s.t. leftmin[i] + rightmin[i] is smallest\n        \n        n = len(arr)\n        \n        # compute left to right\n        curr_sum = 0\n        curr_best = -1\n        \n        lo = hi = 0\n        lmin = []\n        while lo <= hi < n:\n            curr_sum += arr[hi]\n            \n            while curr_sum > target and lo <= hi:\n                curr_sum -= arr[lo]\n                lo += 1\n            \n            if curr_sum == target:\n                tmp = (hi-lo+1)\n                if tmp < curr_best or curr_best == -1:\n                    curr_best = tmp\n            \n            lmin.append(curr_best)\n            hi += 1\n        \n\n        # compute right to left\n        curr_sum = 0\n        curr_best = -1\n        \n        lo = hi = n-1\n        rmin = [-1] # since lo is exclusive, rmin[n-1] should be -1\n        while 0 < lo <= hi:\n            curr_sum += arr[lo]\n            \n            while curr_sum > target and lo <= hi:\n                curr_sum -= arr[hi]\n                hi -= 1\n            \n            if curr_sum == target:\n                tmp = (hi-lo+1)\n                if tmp < curr_best or curr_best == -1:\n                    curr_best = tmp\n            \n            rmin.append(curr_best)\n            lo -= 1\n\n        rmin = rmin[::-1]\n        \n        # print(lmin)\n        # print(rmin)\n        \n        # compute best\n        res = -1\n        for i in range(n):\n            if lmin[i] != -1 and rmin[i] != -1:\n                if res == -1 or lmin[i]+rmin[i] < res:\n                    res = lmin[i] + rmin[i]\n        \n        return res", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # O(n), Space: O(n)\n        n = len(arr)\n        min_lens = [sys.maxsize] * n\n        l = 0\n        min_len = sys.maxsize\n        prefix = 0\n        ans = sys.maxsize\n        \n        for r in range(n):\n            prefix += arr[r]\n            while prefix > target:\n                prefix -= arr[l]\n                l += 1\n            if prefix == target:\n                cur_len = r - l + 1\n                if l > 0 and min_lens[l - 1] != sys.maxsize:\n                    ans = min(ans, cur_len + min_lens[l - 1]) # find previous (before l - 1) sub-arrays, avoid overlapping\n                min_len = min(min_len, cur_len)\n            min_lens[r] = min_len\n        \n        return -1 if ans == sys.maxsize else ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        LARGE_NUMBER = 1000000000\n        \n        if not arr:\n            return -1\n        \n        psum = [0]*(len(arr)+1)\n        sum2i = {}\n        \n        for i in range(len(arr)):\n            psum[i+1] = psum[i] + arr[i]\n        \n        res = LARGE_NUMBER\n        \n        dp = [LARGE_NUMBER]*(len(arr)+1)\n        for i,x in enumerate(psum):\n            assert x not in sum2i\n            sum2i[x]=i\n            if i>0:\n                dp[i]=dp[i-1]\n            \n            if psum[i]-target in sum2i:\n                j = sum2i[psum[i]-target]\n                dp[i] = min(dp[i],i-j)\n                if dp[j]!=LARGE_NUMBER:\n                    res = min(res, dp[j]+i-j)\n        \n        \n        \n        \n        \n        \n        \n        \n        return res if res!=LARGE_NUMBER else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        presum = [0] * len(arr)\n        c = 0\n        for i in range(len(arr)):\n            c += arr[i]\n            presum[i] = c\n        dic ={0:-1}\n        index = [0] * len(arr)\n        short = [0] * len(arr)\n        temp = sys.maxsize\n        for i in range(len(arr)):\n            if presum[i] - target in dic:\n                index[i] =  (i -  dic[  presum[i] - target   ] ) \n                temp = min(temp, i -  dic[  presum[i] - target   ] )\n            dic[ presum[i]  ] = i\n            short[i] = temp\n        \n        ans = sys.maxsize\n        print((index, short))\n        for i in range(1, len(arr)):\n            \n            if index[i] > 0 and i - index[i]  >= 0 and (short[i - index[i]] != sys.maxsize):\n               \n                ans = min(ans, short[i - index[i]] + index[i])\n                \n        if ans == sys.maxsize:\n            return -1\n        return ans\n            \n            \n            \n        \n            \n                    \n                    \n                    \n        \n        \n        #[3,1,1,1,5,1,2,1]\n        #3 4 5 6 11 12 14 15\n        \n       # 1 0 0 3 0 0.  2. 2 \n", "from collections import deque\nfrom itertools import accumulate\n\nclass Solution:\n  def minSumOfLengths(self, arr: List[int], target: int) -> int:\n    # TC: O(N), SC: O(N), prefix sum + deque\n    x, n = list(accumulate(arr, initial=0)), len(arr)\n    s, d = [], {}\n    for i in range(n + 1):\n      y = x[i] - target\n      if y in d:\n        s.append([i - d[y], d[y], i])\n      d[x[i]] = i\n    # min length beyond index i-th\n    for k in range(len(s) - 2, -1, -1):\n      s[k][0] = min(s[k][0], s[k + 1][0])\n    ans, queue = float('inf'), deque([])\n    for d, i, j in s:\n      while queue and queue[0][-1] <= i:\n        ans = min(ans, queue.popleft()[0] + d)\n      queue.append((j - i, i, j))\n    return ans if ans < float('inf') else -1", "from collections import defaultdict\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = defaultdict(list)\n        best_till = [sys.maxsize] * len(arr)\n        res = sys.maxsize\n        prefix[0].append(-1)\n        temp_s = 0\n        for i, ele in enumerate(arr):\n            temp_s += ele\n            prefix[temp_s].append(i)\n            #print(i, temp_s)\n            if temp_s - target in prefix:\n                for index in prefix[temp_s - target]:\n                    best_till[i] = min(best_till[i - 1], i - index)\n                    if index != -1:\n                        res = min(res, best_till[index] + i - index) \n                    #print(\\\"found\\\", i, index, temp_s, best_till[i], res)\n            else:\n                if i >= 1:\n                    best_till[i] = best_till[i - 1]\n        #print(\\\"best_till\\\", best_till)\n        return -1 if res == sys.maxsize else res\n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        # m[i]: min length and and in i, included\n        \n        ptr1, ptr2 = 0, 0  # both inclusive\n        s = arr[0]  # cum sum\n        m = [-1]*len(arr)\n        ans = -1\n        global_min = -1\n        \n        while ptr2 < len(arr):\n            if global_min>0:\n                m[ptr2] = global_min\n            if s == target:\n                m[ptr2] = min(global_min, ptr2-ptr1+1) if global_min> 0 else ptr2-ptr1+1\n                global_min = m[ptr2] \n                if ptr1-1>=0 and m[ptr1-1]>0:\n                    ans = min(ans, m[ptr1-1]+ptr2-ptr1+1) if ans >0 else m[ptr1-1]+ptr2-ptr1+1\n                ptr1 += 1\n                ptr2 += 1\n                if ptr2 < len(arr):\n                    s = s- arr[ptr1-1] + arr[ptr2]\n            elif s> target:\n                ptr1 += 1\n                s = s- arr[ptr1-1] \n                if ptr1 > ptr2 and ptr2+1 < len(arr):\n                    ptr2 += 1\n                    s = s+arr[ptr2]                    \n            else:\n                ptr2 += 1\n                if ptr2 < len(arr):\n                    s = s+arr[ptr2]\n        \n        return ans\n                \n            \n            \n        \n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        nums=[0 for i in range(len(arr))]\n        nums[0]=arr[0]\n        for i in range(1,len(arr)):\n            nums[i]=nums[i-1]+arr[i]\n        best=[float('inf') for i in range(len(arr))]\n        ans=float('inf')\n        size=float('inf')\n        # count=2\n        l=0\n        r=0\n        window=0\n        while l<=r and r<len(arr):\n            \n            window+=arr[r]\n            while l<=r and window>target:\n                # print(l,r)\n                window-=arr[l]\n                \n                l+=1\n                \n            if window==target:\n                ans=min(ans,r-l+1+best[l-1])\n                best[r]=min(best[r-1],r-l+1)\n                      \n            else:\n                best[r]=best[r-1]\n                \n            r+=1\n            \n            \n        \n        if ans==float('inf'):\n            return -1\n        \n        else:\n            return ans\n                \n                \n        \n        \n        \n        \n        \n        \n#         dp=[0 for i in range(len(arr)+1)]\n        \n#         currSum=0\n#         l=[]\n#         i=0\n#         j=0\n        \n#         while i<=j and j<len(arr):\n            \n#             currSum=currSum+arr[j]\n#             print(i,j,currSum)\n#             if currSum==target or arr[j]==target:\n#                 l.append(j-i+1)\n#                 currSum=0\n#                 j+=1\n#                 i=j\n                \n#             elif currSum<target:\n#                 currSum+=arr[j]\n#                 j+=1\n                \n#             else:\n#                 # print(\\\"h\\\",currSum)\n#                 currSum=currSum-arr[i]\n#                 # print(currSum,arr[i])\n#                 i+=1\n                \n#         print(l)\n", "import bisect\n\nclass Solution:\n    def minSumOfLengths(self, arr, target):\n        # inclusive, inclusive sliding window pointers\n        lo = 0\n        hi = 0\n        cur = arr[0]\n\n        # store (end, start) pairs of valid subarrays\n        running_min = []\n\n        ans = 1e9\n\n        while lo <= hi and hi < len(arr):\n            if cur >= target:\n                if cur == target:\n                    best_range = hi - lo + 1\n                    if len(running_min):\n                        best_range = min(best_range, running_min[-1][1])\n                        prev_index = bisect.bisect(running_min, (lo, -1)) - 1\n\n                        if 0 <= prev_index < len(running_min):\n                            ans = min(ans, hi - lo + 1 + running_min[prev_index][1])\n\n                    running_min.append((hi, best_range))\n\n                cur -= arr[lo]\n                lo += 1\n                if hi < lo:\n                    hi = lo\n                else:\n                    continue\n            else:\n                hi += 1\n\n            if hi < len(arr):\n                cur += arr[hi]\n\n        return ans if ans != 1e9 else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        best_so_far = [float('inf') for i in range(len(arr)+1)]\n        prefix_sum = 0\n        prefix_sum_to_idx = {0:-1}\n        res = float('inf')\n        for i,v in enumerate(arr):\n            prefix_sum += v\n            best_so_far[i+1] = best_so_far[i]\n            prev_sum = prefix_sum - target\n            if prev_sum in prefix_sum_to_idx:\n                res = min(res, best_so_far[prefix_sum_to_idx[prev_sum]+1] + i - prefix_sum_to_idx[prev_sum])\n                best_so_far[i+1] = min(best_so_far[i], i - prefix_sum_to_idx[prev_sum])\n            prefix_sum_to_idx[prefix_sum] = i\n        return -1 if res == float('inf') else res \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # 1. Iterate i: 0 ~ n-2\n        #   1a. find min length to make target number in 0 ~ i\n        #   1b. if found, see if possible to make target number with consequent numbers starting from i+1\n        #   1c. if found, update min\n        \n        n = len(arr)\n        best_to = [n + 1 for _ in range(n)]\n        best_from = dict()\n        min_total = n + 1 # Naturally impossible length. Will be updated if any possible case exist. Will tell when no possible case\n        min_left = n + 1\n        sum_left = 0\n        s_left = 0\n        e_left = 0\n        \n        for i in range(n):\n            sum_left += arr[i]\n            if sum_left == target:\n                best_to[i] = i - s_left + 1\n                best_from[s_left] = i - s_left + 1\n            elif sum_left > target:\n                while s_left < i and sum_left > target:\n                    sum_left -= arr[s_left]\n                    s_left += 1\n                if sum_left == target:\n                    best_to[i] = i - s_left + 1\n                    best_from[s_left] = i - s_left + 1\n        \n        for i in range(1, n):\n            best_to[i] = min(best_to[i], best_to[i-1])\n        \n        for i in range(n - 1):\n            if best_to[i] > n:\n                continue\n            \n            if i + 1 in best_from:\n                min_total = min(min_total, best_to[i] + best_from[i + 1])\n        \n#         for i in range(n - 1):\n#             sum_left += arr[i]\n#             if sum_left == target:\n#                 # print(str(s_left) + '->' + str(e_left))\n#                 best[s_left] = e_left - s_left + 1\n#                 min_left = min(min_left, best[s_left])\n#             elif sum_left > target:\n#                 # Need to drop some numbers\n#                 while s_left < e_left and sum_left > target:\n#                     sum_left -= arr[s_left]\n#                     s_left += 1\n#                 if sum_left == target:\n#                     min_left = min(min_left, e_left - s_left + 1)\n#             # Skip if a subarray is not found on left\n#             if min_left > n:\n#                 continue\n            \n#             if i + 1 in \n#             sum_right = 0\n#             for j in range(i + 1, n):\n#                 sum_right += arr[j]\n#                 if sum_right == target:\n#                     min_total = min(min_total, min_left + j - i)\n#                 elif sum_right > target:\n#                     # Stop following as already exceeded\n#                     break\n        \n        if min_total > n:\n            return -1\n        \n        return min_total\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        curr = 0\n        for i in range(len(arr)):\n            curr += arr[i]\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n        return -1 if ans == math.inf else ans", "from collections import defaultdict as ddic\nclass Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        dic = ddic(int)\n        sum_ = 0\n        dic[0] = -1\n        L = len(arr)\n        dp = [0]*L\n        dp2 = [-1]*L\n        res = float('inf')\n        for i in range(L):\n            sum_ += arr[i]\n            dic[sum_] = i\n            if sum_ - target in dic:\n                dp[i] = i - dic[sum_-target]\n                dp2[i] = i - dic[sum_-target]\n                if i!=0:\n                    if dp2[i-1]!=-1:\n                        dp2[i] = min(dp2[i],dp2[i-1])\n                    \n                if dp2[dic[sum_-target]]!=-1:\n                    res = min(res, dp[i]+dp2[dic[sum_-target]])\n            if dp2[i]==-1:\n                if i!=0:\n                    dp2[i] = dp2[i-1]\n        #print(dp,dp2)\n        if res>L:\n            return -1\n        return res", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n=len(arr)\n        minlens=[float('inf')]*n\n        #min length of a valid subarray ends or before i.\n        res=float('inf')\n        sum1=0\n        s=0\n        min_len=float('inf')\n        for e in range(n):\n            sum1+=arr[e]\n            while sum1>target:\n                sum1-=arr[s]\n                s+=1\n            if sum1==target:\n                cur_len=e-s+1\n                if s>0 and minlens[s-1]!=float('inf'):\n                    res=min(res,cur_len+minlens[s-1])\n                min_len=min(min_len,cur_len)\n            minlens[e]=min_len\n        if res!=float('inf'):\n            return res\n        return -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \n        # subarr that has target sum\n        len_to_start = collections.defaultdict(list)\n        \n        # find \n        start, end = 0, 1\n        tmp_sum = arr[0]\n        earliest_end, latest_start = len(arr), 0\n        while start<len(arr):\n            while end<len(arr) and tmp_sum<target:\n                tmp_sum += arr[end]\n                end += 1\n            if tmp_sum==target:\n                len_to_start[end-start].append(start)\n                earliest_end = min(earliest_end, end)\n                latest_start = max(latest_start, start)\n            \n            tmp_sum -= arr[start]\n            start += 1\n          \n        if earliest_end>latest_start:\n            return -1\n\n        # find shortest\n        for l, starts in list(len_to_start.items()):\n            if len(starts)>2:\n                len_to_start[l] = [starts[0],starts[-1]]\n        \n        shortest=len(arr)\n        for l1 in len_to_start:\n            for s1 in len_to_start[l1]:\n                for l2 in len_to_start:\n                    for s2 in len_to_start[l2]:\n                        if l1+l2>=shortest:\n                            continue\n                        if s1<s2 and s1+l1<=s2:\n                            shortest = l1+l2\n                        if s2<s1 and s2+l2<=s1:\n                            shortest = l1+l2\n                            \n        return shortest\n                        \n", "class Solution:\n  # 864 ms\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = count = 0\n    # preMin: store previous shortest length\n    preMin = [(-1, inf)]\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: current length\n        curr = j - i + 1\n        n = 0 \n        # find first minimal length n before window start i\n        for index, length in preMin[::-1]:\n          if index <= i-1: \n            n = length           \n            break\n        # update result if less    \n        if result > curr + n: result = curr + n\n            \n        # update shortest length if less\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\n          \n        # early stopping if found two single targets\n      #  if curr == 1: count += 1\n      #  if count == 2: return 2\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        left, right = 0, 0\n        valid_subarray_lengths = [0 for _ in range(len(arr))]\n        cum_sum = 0\n        for i in range(len(arr)):\n            cum_sum += arr[i]\n            right = i\n            while cum_sum > target:\n                cum_sum -= arr[left]\n                left += 1\n            if cum_sum == target:\n                valid_subarray_lengths[i] = right - left + 1\n        prefix_min_lengths = [None for _ in range(len(valid_subarray_lengths))]\n        prefix_min = float('inf')\n        for i in range(len(valid_subarray_lengths)):\n            prefix_min = min(prefix_min, valid_subarray_lengths[i] if valid_subarray_lengths[i] else float('inf'))\n            prefix_min_lengths[i] = prefix_min\n        res = float('inf')\n        for i in range(len(valid_subarray_lengths)):\n            if valid_subarray_lengths[i] != 0 and i - valid_subarray_lengths[i] >= 0 and prefix_min_lengths[i - valid_subarray_lengths[i]] > 0:\n                res = min(res, valid_subarray_lengths[i] + prefix_min_lengths[i - valid_subarray_lengths[i]])\n        return res if res != float('inf') else -1", "class Solution:\n  # 864 ms\n  def minSumOfLengths(self, arr, target):\n    result = inf = 2**31-1\n    i = window = count = 0\n    # preMin: store previous shortest length\n    preMin = [(-1, inf)]\n\n    # i: window start, j: window end\n    for j, num in enumerate(arr):\n      window += num\n      while window > target:\n        window -= arr[i]\n        i += 1\n      if window == target:\n        # curr: current length\n        curr = j - i + 1\n        n = 0 \n        # find first minimal length before window start i\n        for index, length in preMin[::-1]:\n          if index <= i-1: \n            n = length           \n            break\n        # update result if less    \n        if result > curr + n: result = curr + n\n            \n        # update shortest length if less\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\n          \n        # early stopping if found two single targets\n        if curr == 1: count += 1\n        if count == 2: return 2\n\n    return result if result < inf else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        lens_s = [math.inf] * len(arr)\n        lens_e = [math.inf] * len(arr)\n        cs = s = e = 0\n        for i in range(len(arr)):\n            cs += arr[e]\n            while cs >= target:\n                if cs == target: \n                    lens_e[e] = lens_s[s] = e + 1 - s\n                cs -= arr[s]\n                s += 1\n            e += 1\n            \n        forward = [math.inf] * (len(arr) + 1)\n        for i in range(1, len(arr)):\n            forward[i] = min(lens_e[i-1], forward[i-1])\n            \n        backward = [math.inf] * (len(arr) + 1)\n        for i in reversed(list(range(0, len(arr)))):\n            backward[i] = min(lens_s[i], backward[i+1])\n            \n        best = math.inf\n        for f, b in zip(forward, backward):\n            best = min(best, f + b)\n            \n        if best == math.inf:\n            return -1\n        return best\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n=len(arr)\n        min_lens=[float('inf')]*n\n        ans=float('inf')\n        cur_sum=0\n        min_len=float('inf')\n        s=0\n        \n        for e in range(n):\n            cur_sum+=arr[e]\n            while cur_sum>target:\n                cur_sum-=arr[s]\n                s+=1\n            if cur_sum==target:\n                cur_len=e-s+1\n                if s>0 and min_lens[s-1]!=float('inf'):\n                    ans=min(ans, cur_len+min_lens[s-1])\n                min_len=min(cur_len, min_len)\n            min_lens[e]=min_len\n            \n        return (-1 if ans==float('inf') else ans) ", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        # They are all positive\n\n        n = len(arr)\n        # DP is shortest array up to i\n        dp = [float('inf') for _ in range(n+1)]\n        \n        ans = float('inf')\n        \n        start = 0\n        \n        curr_sum = 0\n        for end in range(n):\n            curr_sum += arr[end]\n            \n            while start < end and curr_sum > target:\n                curr_sum -= arr[start]\n                start += 1\n                \n            if curr_sum == target:\n                print(start, end)\n                ans = min(ans, end - start + 1 + dp[start-1]) # or start - 1\n                dp[end] = min(dp[end-1], end - start + 1)\n            else:\n                dp[end] = dp[end-1]\n                \n        print(dp)\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        res, best, dp = sys.maxsize, sys.maxsize, [sys.maxsize]*len(arr)\n        for i, acc in enumerate(itertools.accumulate(arr)):\n            if acc-target in prefix:\n                end = prefix[acc-target]\n                if end > -1:\n                    res = min(res, i-end+dp[end])\n                best = min(best, i-end)\n            dp[i] = best\n            prefix[acc] = i\n        return -1 if res==sys.maxsize else res\n", "import bisect, heapq\n\nclass Solution:\n    def minSumOfLengths(self, arr, target):\n        # inclusive, inclusive sliding window pointers\n        lo = 0\n        hi = 0\n        cur = arr[0]\n\n        # store (end, start) pairs of valid subarrays\n        pairs = []\n        \n        running_min = []\n\n        ans = 1e9\n\n        while lo <= hi and hi < len(arr):\n            # print(running_min)\n            # print(lo, hi, cur)\n            if cur >= target:\n                if cur == target:\n                    best_range = hi - lo + 1\n                    if len(running_min):\n                        best_range = min(best_range, running_min[-1][1])\n                        prev_index = bisect.bisect(running_min, (lo, -1)) - 1\n                        # print(\\\"Attempting to find %d... got %d\\\" % (lo, prev_index))\n                        if 0 <= prev_index < len(running_min):\n                            ans = min(ans, hi - lo + 1 + running_min[prev_index][1])\n\n                    running_min.append((hi, best_range))\n                    heapq.heappush(pairs, (hi, lo))\n\n                cur -= arr[lo]\n                lo += 1\n                if hi < lo:\n                    hi = lo\n                else:\n                    continue\n            else:\n                hi += 1\n\n            if hi < len(arr):\n                cur += arr[hi]\n\n        return ans if ans != 1e9 else -1", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        \n#         def aux(arr):\n#             h = {0:0}\n#             preSum = 0\n#             left = [n+1 for i in range(n)]\n#             for i in range(1, n+1):\n#                 preSum = preSum + arr[i-1]\n#                 h[preSum] = i\n#                 if preSum-target in h:\n#                     left[i-1] = i-h[preSum-target]\n#                 if i > 1:\n#                     left[i-1] = min(left[i-2], left[i-1])\n#             return left\n        \n        \n#         left = aux(arr)\n#         arr.reverse()\n#         right = aux(arr)\n        \n#         ans = n+1\n#         for i in range(n):\n#             ans = min(ans, left[i] + right[n-1-(i+1)])\n#         return ans if ans < n+1 else -1\n        \n        \n        h = {0:-1}\n        preSum = [0 for i in range(n)]\n        for i in range(n):\n            preSum[i] = preSum[i-1] + arr[i] if i > 0 else arr[0]\n            h[preSum[i]] = i\n        left = [n+1 for i in range(n)]\n        ans = n+1\n        for i in range(n):\n            if preSum[i]-target in h:\n                left[i] = i-h[preSum[i]-target]\n            if i > 0:\n                left[i] = min(left[i-1], left[i])\n            if left[i] < n+1 and preSum[i]+target in h:\n                right = h[preSum[i]+target]-i\n                ans = min(ans, left[i]+right)\n        return ans if ans < n+1 else -1\n                \n            \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        s = 0\n        j = 0\n        ans = float('inf')\n        res = [float('inf')] * len(arr)\n        currMin = float('inf')\n        for i in range(len(arr)):\n            \n            s += arr[i]\n            while s > target:\n                s -= arr[j]\n                j += 1\n            if s == target:\n                \n                \n                currMin = min(currMin, i - j + 1)\n                ans = min(ans, res[j-1] + i - j + 1)\n            \n            res[i] = currMin\n            \n        \n        return ans if ans < float('inf') else -1\n            \n            \n            \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        l = len(arr)\n        left, right, pre = [l]*l, [l]*l, {0:-1}\n        p = 0\n        for i in range(l):\n            p += arr[i]\n            if p - target in pre:\n                prev = pre[p - target]\n                left[i] = i - prev\n                if prev >= 0:\n                    right[prev] = min(right[prev], i - prev)\n            pre[p] = i\n        \n        for i in range(1, l):\n            left[i] = min(left[i], left[i-1])\n        \n        for i in range(l-2, -1, -1):\n            right[i] = min(right[i], right[i+1])\n        \n        ans = l + 1\n        \n        # for i in range(l):\n        #     if left[i] < l and right[i] < l:\n        #         ans = min(ans, left[i] + right[i])\n        ans = min( left[i] + right[i] if left[i] < l and right[i] < l else l + 1 for i in range(l) )\n        \n        return ans if ans < l + 1 else -1\n        \n        \n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        left = [float('inf')]*n\n        memo = {0:-1}\n        current = 0\n        for k in range(n):\n            if k > 0:\n                left[k] = left[k-1]\n            current += arr[k]\n            if current - target in memo:\n                left[k] = min(left[k], k - memo[current - target])\n            memo[current] = k\n        #print(left)\n        \n        right = [float('inf')]*n\n        memo = {0:n}\n        current = 0\n        for k in range(n-1, -1, -1):\n            if k < n-1:\n                right[k] = right[k+1]\n            current += arr[k]\n            if current - target in memo:\n                right[k] = min(right[k], memo[current-target] - k)\n            memo[current] = k\n        \n        ans = float('inf')\n        for k in range(n-1):\n            ans = min(ans, left[k] + right[k+1])\n        return ans if ans != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        prefix = {0: -1}\n        best_till = [math.inf] * len(arr)\n        ans = best = math.inf\n        for i, curr in enumerate(itertools.accumulate(arr)):\n            if curr - target in prefix:\n                end = prefix[curr - target]\n                if end > -1:\n                    ans = min(ans, i - end + best_till[end])\n                best = min(best, i - end)\n            best_till[i] = best\n            prefix[curr] = i\n\n        return -1 if ans == math.inf else ans", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        def getPrefix(arr):\n            m = {0:-1}\n            prefix = [float('inf')]\n            s = 0\n            for i, n in enumerate(arr):\n                s += n\n                minn = prefix[-1]\n                if (s - target) in m:\n                    minn = min(i - m[s-target], minn)\n                prefix.append(minn)\n                m[s] = i\n            prefix.pop(0)\n            return prefix\n        \n        prefix = getPrefix(arr)\n        sufix = list(reversed(getPrefix(reversed(arr))))\n        ans = float('inf')\n        for i in range(len(arr)-1):\n            ans = min(ans, prefix[i] + sufix[i+1])\n        return ans if ans != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        d = {}\n        d[0] = -1\n        possible_sum = {0}\n        cur_sum = 0\n        for i,a in enumerate(arr):\n            cur_sum += a\n            possible_sum.add(cur_sum)\n            d[cur_sum] = i\n        \n        till_len = [float('inf')] * len(arr)\n        for s in possible_sum:\n            if s + target in possible_sum:\n                till_len[d[s+target]] = d[s+target] - d[s]\n        \n        \n        ans = float('inf')\n        pre_min = [float('inf')] * len(arr)\n        for i, t in enumerate(till_len):        # t is the length of good subarrays until index i.\n            # if t == float('inf'): continue\n            if i == t - 1: \n                pre_min[i] = t\n            else:\n                pre_min[i] = min(t, pre_min[i-1])\n                if t < float('inf') and pre_min[i-t] < float('inf'):\n                    ans = min(ans, t + pre_min[i-t])\n        \n        return ans if ans < float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        prefixSum = [0] * n\n        targetSum = [sys.maxsize] * n\n        beforeSum = [sys.maxsize] * n\n        afterSum = [sys.maxsize] * n\n        sumDict = {0:-1}\n        total = 0\n        for i in range(n):\n            total += arr[i]\n            prefixSum[i] = total\n            if (total - target) in sumDict:\n                index = sumDict[total - target]\n                targetSum[i] = i - index\n            sumDict[total] = i\n\n        minValue = sys.maxsize\n        for i in range(n):\n            # if (targetSum[i] > 0):\n            minValue = min(targetSum[i], minValue)\n            beforeSum[i] = minValue\n\n        minValue = sys.maxsize\n        for i in reversed(list(range(1, n))):\n            # print(targetSum[i])\n            startIndex = i - targetSum[i]\n            if (startIndex >= 0):\n                afterSum[startIndex] = min(afterSum[startIndex], targetSum[i])\n                # print(f\\\"Setting aftersum[{startIndex}] = {afterSum[startIndex]}\\\")\n            # minValue = min(targetSum[i], minValue)\n            # afterSum[i - 1] = minValue\n                \n        # print(f\\\"targetSum = {targetSum}\\\")\n        # print(f\\\"afterSum = {afterSum}\\\")\n        # print(f\\\"beforeSum = {beforeSum}\\\")\n        minValue = sys.maxsize\n        for i in range(len(arr)):\n            minValue = min(minValue, beforeSum[i] + afterSum[i])\n        if (minValue == sys.maxsize):\n            minValue = -1\n        return minValue\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        curr_sum = 0 \n        intervals = [(-200002, -100001), (-200002, -100001)]\n        h = {0 : -1}\n        f = [[100001] * len(arr) for i in range(2)] \n        for index, a in enumerate(arr):\n            curr_sum += a\n            f[1][index] = min(f[0][h[curr_sum - target]] + index - h[curr_sum - target] if curr_sum - target in h else 100001, f[1][index - 1])\n            f[0][index] = min(f[0][index - 1] if index >= 1 else 100001, index - h[curr_sum - target] if curr_sum - target in h else 100001) \n            h[curr_sum] = index\n        return -1 if f[-1][-1] >= 100001 else f[-1][-1]", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        left = [float('inf')]*n\n        memo = {0:-1}\n        current = 0\n        for k in range(n):\n            if k > 0:\n                left[k] = left[k-1]\n            current += arr[k]\n            if current - target in memo:\n                left[k] = min(left[k], k - memo[current - target])\n            memo[current] = k\n        print(left)\n        \n        right = [float('inf')]*n\n        memo = {0:n}\n        current = 0\n        for k in range(n-1, -1, -1):\n            if k < n-1:\n                right[k] = right[k+1]\n            current += arr[k]\n            if current - target in memo:\n                right[k] = min(right[k], memo[current-target] - k)\n            memo[current] = k\n        \n        ans = float('inf')\n        for k in range(n-1):\n            ans = min(ans, left[k] + right[k+1])\n        return ans if ans != float('inf') else -1\n", "class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        l = len(arr)\n        left, right, pre = [l]*l, [l]*l, {0:-1}\n        p = 0\n        for i in range(l):\n            p += arr[i]\n            if p - target in pre:\n                prev = pre[p - target]\n                left[i] = i - prev\n                if prev >= 0:\n                    right[prev] = min(right[prev], i - prev)\n            pre[p] = i\n        \n        for i in range(1, l):\n            left[i] = min(left[i], left[i-1])\n        \n        for i in range(l-2, -1, -1):\n            right[i] = min(right[i], right[i+1])\n        \n        ans = l + 1\n        \n        for i in range(l):\n            if left[i] < l and right[i] < l:\n                ans = min(ans, left[i] + right[i])\n        \n        if ans < l + 1:\n            return ans\n        \n        return -1\n        \n        \n"]
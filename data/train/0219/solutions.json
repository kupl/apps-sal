["class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        ans, count, seen = 0, 0, {}\n        for i, hour in enumerate(hours):\n            count = count + 1 if hour > 8 else count - 1\n            if count > 0:\n                ans = i + 1\n            else:\n                if count not in seen:\n                    seen[count] = i\n                if count - 1 in seen:\n                    ans = max(ans, i - seen[count - 1])\n        return ans\n\n        \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        ans, cum, seen = 0, 0, {}\n        for i, hour in enumerate(hours):\n            cum = cum + 1 if hour > 8 else cum - 1\n            if cum > 0:\n                ans = i + 1\n            else:\n                if cum not in seen:\n                    seen[cum] = i\n                if cum - 1 in seen:\n                    ans = max(ans, i - seen[cum - 1])\n        return ans", "class Solution:\n    def findslavedays(self,hours):\n        a=0\n        b=0\n        slave=0\n        nonslave=0\n        slavedays=0\n        while b<len(hours):\n          #  print(a,b,slave,nonslave,slavedays)\n            if slave>nonslave:\n                slavedays=max(slavedays,b-a+slave-nonslave-1)\n            if a==b:\n                if hours[a]<=8:\n                    nonslave+=1\n                else:\n                    slave+=1\n                b+=1\n                continue\n            if slave<nonslave:\n                if hours[a]<=8:\n                    nonslave-=1\n                else:\n                    slave-=1\n                a+=1\n            elif slave>=nonslave:\n                if hours[b]<=8:\n                    nonslave+=1\n                else:\n                    slave+=1\n                b+=1\n            \n            if slave>nonslave:\n                slavedays=max(slavedays,b-a+slave-nonslave-1)\n        print(a,b)\n        while a>0:\n            a-=1\n            if hours[a]<=8:\n                nonslave+=1\n            else:\n                slave+=1\n            if slave>nonslave:\n                slavedays=max(slavedays,b-a+slave-nonslave-1)\n        if slave>nonslave:\n                slavedays=max(slavedays,b-a+slave-nonslave-1)        \n        return slavedays\n    def longestWPI(self, hours: List[int]) -> int:\n        isslave=[-1]*len(hours)\n        sumslave=0\n        for i in range(len(isslave)):\n            if hours[i]>8:\n                isslave[i]=1\n        dic={}\n        maxslavedays=0\n        print(isslave)\n        for i in range(len(isslave)):\n            \n            sumslave=isslave[i]+sumslave\n          #  print(sumslave)\n            if sumslave>0:\n                maxslavedays=max(maxslavedays,i+1)\n\n            if sumslave not in dic:\n                dic[sumslave]=i\n            if sumslave-1 in dic:\n                \n                maxslavedays=max(maxslavedays,i-dic[sumslave-1])\n        print(dic)\n        return maxslavedays\n    \n        print(isslave,sumslave)\n        a=-1\n        b=0\n        dic={}\n        dic[0]=-1\n        for i in range(len(isslave)):\n            \n            if sumslave[i]>0:\n                b=i\n                maxslavedays=max(maxslavedays,b-a)\n            if sumslave[i]<=0:\n                a=i\n        return maxslavedays\n            \n        #for i in range(1,len(isslave)):\n            \n        return 0\n        slavelength1=self.findslavedays(hours)\n        slavelength2=self.findslavedays(hours[::-1])\n        return max(slavelength1,slavelength2)", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        score=0\n        dic={}\n        result=0\n        for i,hour in enumerate(hours):\n            if hour >8:\n                score +=1\n            else:\n                score -=1\n\n            if score>0:\n                result = i+1\n                \n            if score not in dic:\n                dic[score] = i\n                \n            \n            if score-1 in dic:\n                result=max(result, i -dic[score-1])\n        return result    \n    \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        res = score = 0\n        seen = {}\n        for i in range(len(hours)):\n            h = hours[i]\n            score = score + 1 if h > 8 else score - 1\n            if score > 0:\n                res = i + 1\n            seen.setdefault(score, i)\n            if score - 1 in seen:\n                res = max(res, i - seen[score - 1])\n        return res", "import bisect\n\nclass Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        r, l, l_idx = [], [], []\n        d = []\n        for i, x in enumerate(hours):\n            if i == 0:\n                if x > 8:\n                    d.append(1)\n                else:\n                    d.append(-1)\n            else:\n                if x > 8:\n                    d.append(d[-1] + 1)\n                else:\n                    d.append(d[-1] - 1)\n                    \n        for i, x in enumerate(d):\n            while len(r) > 0 and r[-1][0] <= x:\n                r.pop()\n            r.append((x, i))\n            if len(l) == 0 or x < l[-1]:\n                l.append(x)\n                l_idx.append(i)\n        \n        ans = 0\n        l.reverse()\n        l_idx.reverse()\n        \n        for x in r:\n            if x[0] > 0:\n                ans = max(ans, x[1] + 1)\n            else:\n                idx = bisect.bisect_right(l, x[0] - 1)\n                if idx >= 1:\n                    ans = max(ans, x[1] - l_idx[idx - 1])\n        \n        return ans\n        \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        nums = []\n        for hour in hours:\n            if hour > 8:\n                nums.append(1)\n            else:\n                nums.append(-1)\n        prevsum, sumv = [], 0\n        for num in nums:\n            sumv += num\n            prevsum.append(sumv)\n        stack = []\n        prevsum = [0] + prevsum\n        for i, val in enumerate(prevsum):\n            if not stack or prevsum[stack[-1]] > val:\n                stack.append(i)\n        i, res = len(prevsum) - 1, 0\n        while i >= 0:\n            while stack and prevsum[stack[-1]] < prevsum[i]:\n                res = max(res, i - stack[-1])\n                stack.pop()\n            i -= 1\n        return res\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        d = {}\n        d[0] = -1\n        \n        res = 0\n        \n        for i in range(len(hours)):\n            hours[i] = (1 if hours[i] > 8 else -1) + (0 if i == 0 else hours[i-1])\n            \n            if hours[i] not in d:\n                d[hours[i]] = i\n            \n            if hours[i] > 0:\n                res = i+1\n                \n            target = hours[i] - 1\n            \n            if target in d:\n                res = max(res, i - d[target])\n        \n        print(hours)\n        print(d)\n        return res\n            \n            \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        hours = [1 if i > 8 else -1 for i in hours]\n        hsh = {}\n        vals = [0 for i in hours]\n        sm = 0\n        for i in range(len(hours)-1, -1, -1):\n            sm += hours[i]\n            if sm > 0:\n                vals[i] = max(vals[i], len(hours) - i)\n            hours[i] = sm\n            smo = hours[i] - 1\n            if smo in hsh:\n                v = hsh[smo]\n                vals[i] = max(vals[i], v - i + vals[v])\n                \n            if hours[i] not in hsh:\n                hsh[hours[i]] = i\n        \n        return max(vals)\n            \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        d = {}\n        P = [0] #prefix sum\n        F = [0 for i in range(len(hours))]\n        res = 0\n        for i in range(len(hours)):\n            P.append(P[-1] + (1 if hours[i] > 8 else -1))\n            if P[-1] > 0:\n                F[i] = i + 1\n            else:\n                s = d.get(P[-1] - 1, -1)\n                if s >= 0:\n                    F[i] = max(F[i], i - s + F[s])\n            if P[-1] not in d:\n                d[P[-1]] = i\n            res = max(res, F[i])   \n\n        return res", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        val = 0\n        result = 0\n        table = dict()\n        for i in range(len(hours)):\n            hour = hours[i]\n            if hour > 8:\n                val += 1\n            else:\n                val -= 1\n                \n            if val > 0:\n                result = i + 1\n            else:\n                if val not in table:\n                    table[val] = i\n                if val - 1 in table:\n                    dist = i - table[val - 1]\n                    if dist > result:\n                        result = dist\n        \n        return result", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        sum=0\n        ans=0\n        d={}\n        for i in range(len(hours)):\n            sum=sum+1 if hours[i] >8 else sum-1\n            if sum>0:\n                ans=i+1\n            else:\n                if sum not in d:\n                    d[sum]=i\n                if sum-1 in d:\n                    ans=max(ans,i-d[sum-1])\n        return ans\n        \n            \n                \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        seen = {}\n        result,score = 0,0\n        for i,num in enumerate(hours):\n            score += 1 if num > 8 else -1\n            if score > 0:\n                result = i+1\n            elif score -1 in seen:\n                result = max(result, i - seen[score -1])\n            seen.setdefault(score, i)\n        return result\n            \n                \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        \n        n = len(hours)\n        hashmap = dict()\n        total=0\n        res=0\n\n        for i in range(n):\n            if hours[i]<=8:\n                total-=1\n            else:\n                total+=1\n\n            if total>0:\n                res=i+1\n                continue\n            else:\n                if total not in hashmap:\n                    hashmap[total] = i\n                if (total-1) in hashmap:\n                    res = max(res, i-hashmap[total-1])\n        return res\n        \n        \n            \n            \n            \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        # Convert array to 0 and 1s\n        bits = [1 if x > 8 else -1 for x in hours]\n        # Problem becomes: find the longest interval bits[i:j] where sum(bits[i:j]) > 0\n        # Get prefix sum of bits\n        pref = [0] * (len(bits)+1)\n        for i in range(1, len(bits)+1):\n            pref[i] = pref[i-1] + bits[i-1]\n        # Problem becomes: find the longest interval pref[i:j] where pref[j] > pref[i]\n        # Sort index of pref by value. Problem becomes: find the largest sorted_pref[j]-sorted_pref[i] where j > i\n        # Greedy to solve the new problem\n        ans = 0\n        min_val = len(bits) + 1\n        for y in sorted(enumerate(pref), key=lambda x: (x[1], -x[0])):\n            min_val = min(min_val, y[0])\n            ans = max(ans, y[0] - min_val)\n        return ans\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        res = score = 0\n        seen = {}\n        for i, h in enumerate(hours):\n            score = score + 1 if h > 8 else score - 1\n            if score > 0:\n                res = i + 1\n            seen.setdefault(score, i)\n            if score - 1 in seen:\n                res = max(res, i - seen[score - 1])\n        return res\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        \n        s = 0\n        seen = {}\n        ans = 0\n        \n        for i,h in enumerate(hours):\n            if h > 8:\n                s += 1\n            else:\n                s -= 1\n                \n            if s > 0:\n                ans = i+1\n            \n            seen.setdefault(s, i)\n            \n            if s-1 in seen:\n                ans = max(ans, i-seen[s-1])\n        \n        return ans\n                \n        \n\n", "class Solution:\n    def longestWPI(self, hours):\n        \n        res = score = 0\n        seen = {}\n        \n        for i, h in enumerate(hours):\n            print((i,h))\n            \n            if h > 8: score += 1\n            else: score -= 1\n                \n            if score > 0:\n                res = i + 1\n            seen.setdefault(score, i)\n            if score - 1 in seen:\n                res = max(res, i - seen[score - 1])\n        return res\n    \n    \n#tiring_count = 1, not_tiring_count = 0, max_length = 1\n#tiring_count = 2, not_tiring_count = 0, max_length = 2\n#tiring_count = 2, not_tiring_count = 1, max_length = 3\n#tiring_count = 2, not_tiring_count = 2, tiring_count = 0\n#tiring_count = 0, nt = 3\n#nt = 4\n#tiring count += 1\n                    \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        hours = [1 if i > 8 else -1 for i in hours]\n        hsh = {hours[0]:0}\n        for i in range(1, len(hours)):\n            hours[i] += hours[i-1]\n            hsh[hours[i]] = i\n            \n        vals = [i+1 if hours[i] > 0 else 0 for i in range(len(hours))]\n        for i in range(len(hours)):\n            sm = hours[i] + 1\n            if sm in hsh:\n                v = hsh[sm]\n                vals[v] = max(vals[v], v-i+vals[i])\n                        \n        return max(vals)\n            \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        final = 0\n        score = 0\n        stack = {}\n        for i in range(len(hours)):\n            if hours[i] > 8 :\n                score += 1\n            else: \n                score -= 1\n            stack.setdefault(score,i)\n            if score > 0:\n                final = i + 1\n            if score - 1 in stack:\n                final = max(final, i - stack[score-1])\n        return final\n                \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        L = [1 if i > 8 else -1 for i in hours]\n        K = [1 if i > 8 else -1 for i in hours]\n        mp = {}\n        for i in range(0, len(hours)):\n            if i > 0:\n                s = L[i] = L[i] + L[i - 1]\n            else:\n                s = L[i]\n            if s not in mp:\n                mp[s] = {i: True}\n            else:\n                mp[s][i] = True\n        \n        #print(K)\n        #print(L)\n        result = 0\n        for i, c in enumerate(L):\n            if L[-1] > L[i]:\n                result = max(result, len(K) - i - 1)\n                #print(\\\"ss\\\", i, result)\n            if 0 < L[i]:\n                result = max(result, i + 1) \n                #print(\\\"ddd\\\", i)\n                \n            if i > 0 and L[i - 1] + 1 in mp:\n                s = mp[L[i - 1] + 1]\n                #print(result, s, i)\n                result = max(result, max(s) - i + 1)\n                #result = max(result, i + 1 - min(s))\n            if L[i] - 1 in mp:\n                s = mp[L[i] - 1]\n                #print(result, s, i)\n                # result = max(result, max(s) - i + 1)\n                result = max(result, i - min(s))\n            #print(result, i)\n        return result\n\n    \n    def longestWPI(self, hours: List[int]) -> int:\n        mp = {}\n        accu = 0\n        result = 0\n        for i, v in enumerate(hours):\n            accu += 1 if v > 8 else -1\n            # print(accu)\n            if accu > 0:\n                result = max(result, i + 1)\n                print((result, i))\n            if accu - 1 in mp:\n                result = max(result, i - mp[accu-1])\n                print((result, i))\n            if accu not in mp:\n                mp[accu] = i\n        return result\n                \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        ret = 0\n        overall = 0\n\n        totals = {}\n        for i, h in enumerate(hours):\n            if h > 8:\n                overall += 1 \n            else:\n                overall -= 1\n            \n            if overall > 0:\n                ret = i + 1\n            else:\n                if overall-1 in totals:\n                    length = i - totals[overall-1]\n                    ret = max(ret, length)\n                if overall not in totals:\n                    totals[overall] = i\n    \n        return ret", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        pre_sum = [0]\n        for i, v in enumerate(hours):\n            hours[i] = 1 if v > 8 else -1\n            pre_sum.append(pre_sum[-1] + hours[i])\n\n        dec_stack = [] # idx to pre_sum\n        for i, v in enumerate(pre_sum):\n            if len(dec_stack) == 0 or (len(dec_stack) > 0 and v < pre_sum[dec_stack[-1]]):\n                dec_stack.append(i)\n        max_r = -math.inf\n        max_width = 0\n        for r in range(len(pre_sum)-1, -1, -1):\n            n = pre_sum[r]\n            if n < max_r:\n                continue\n            max_r = n\n            while len(dec_stack) > 0:\n                # pop top < n\n                left_idx = dec_stack[-1]\n                if pre_sum[left_idx] < n:\n                    dec_stack = dec_stack[0:-1]\n                    max_width = max(max_width, r - left_idx)\n                else:\n                    break\n            if len(dec_stack) == 0:\n                break\n        return max_width", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        hours = [1 if h > 8 else -1 for h in hours]\n            \n        down = {1: 0}\n        s = 0\n        ans = 0\n        for i,h in enumerate(hours):\n            if h < 0:\n                if s not in down:\n                    down[s] = i\n            s += h\n            if s in down:\n                ans = max(ans, i - down[s])\n            if s > 0:\n                ans = max(ans, i+1)\n        return ans\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        days = [1 if hour > 8 else -1 for hour in hours] #find longest strictly positive subarr\n        prefSums = days[:]\n        for i in range(1, len(hours)):\n            prefSums[i] = days[i] + prefSums[i - 1]\n        result = 0\n        prefixLookup = {}\n        for i in range(len(hours)):\n            sumToHere = prefSums[i] #longest answer ending here \n            if sumToHere >= 1:\n                result = max(result, i + 1)\n            else:\n                earlierPrefSumNeeded = sumToHere - 1\n                if earlierPrefSumNeeded in prefixLookup:\n                    result = max(result, i - prefixLookup[earlierPrefSumNeeded])\n            if sumToHere not in prefixLookup:\n                prefixLookup[sumToHere] = i\n        return result\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        lt = []\n        for hour in hours:\n            if hour > 8:\n                lt.append(1)\n            else:\n                lt.append(-1)\n        seen = {}\n        s = 0\n        mx = 0\n        for idx, ele in enumerate(lt):\n            s += ele\n            print((s, idx, mx))\n            if s > 0 : #atleast more 9\n                mx = max(mx, (idx+1))\n            else:    \n                if (s-1) in seen:\n                    i = seen[s-1]\n                    mx = max(mx, idx-i)\n            if (s) not in seen:\n                seen[s] = idx\n        return mx        \n        \n                \n        \n", "# [9,9,6,0,6,6,9]\n\n# [1,1,-1,-1,-1,1]\n#  1 2  1  0  -1 0\n# [1,1,-1,-1,-1,1, 1]\nclass Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        prefix = []\n        for hour in hours:\n            if hour > 8:\n                prefix.append(1)\n            else:\n                prefix.append(-1)\n                \n        curr_sum = 0\n        seen = {0:-1}\n        res = 0\n        \n        for i, num in enumerate(prefix):\n            curr_sum += num\n            if curr_sum > 0:\n                res = i + 1\n                \n            if curr_sum - 1 in seen:\n                res = max(res, i - seen[curr_sum - 1])\n            \n            if curr_sum not in seen:\n                seen[curr_sum] = i\n        \n        return res\n    \n        \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        cur = res = 0\n        seen = {}\n        for i, h in enumerate(hours):\n            cur += 1 if h > 8 else -1\n            if cur > 0: res = max(res, i + 1)\n            else:\n                if cur - 1 in seen:\n                    res = max(res, i - seen[cur - 1])\n            if cur not in seen:\n                seen[cur] = i\n        \n        return res\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        n = len(hours)\n        hours = [1 if x > 8 else -1 for x in hours]\n        s = 0\n        idx = {}\n        ans = 0\n        for i in range(len(hours)):\n            s += hours[i]\n            if s > 0:\n                ans = i + 1\n            if s not in idx:\n                idx[s] = i\n            if (s - 1) in idx:\n                ans = max(ans, i - idx[s - 1])\n        return ans", "#https://leetcode.com/problems/longest-well-performing-interval/discuss/334565/JavaC%2B%2BPython-O(N)-Solution-Life-needs-996-and-669\n    \nclass Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        seen = dict()\n        cnt = 0\n        res = 0\n        for idx, h in enumerate(hours):\n            if h>8:\n                cnt += 1\n            else:\n                cnt -= 1\n            if cnt>0:\n                res = idx+1\n            else:\n                if cnt-1 in seen:\n                    res = max(res, idx-seen[cnt-1])\n            if cnt not in seen:\n                seen[cnt] = idx\n        return res\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        Sum, ans = 0, 0\n        cache = {}\n        for i, n in enumerate(hours):\n            Sum = Sum + 1 if n > 8 else Sum - 1\n            if Sum > 0: ans = i + 1\n            if Sum-1 in cache:\n                ans = max(ans, i - cache[Sum-1])\n            cache.setdefault(Sum, i)\n        return ans\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        hours = [1 if h > 8 else -1 for h in hours]\n        seen = {}\n        ans = cur = 0\n        for i, h in enumerate(hours):\n            cur += h\n            seen.setdefault(cur, i)\n            if cur > 0:\n                ans = i + 1\n            elif cur - 1 in seen:\n                ans = max(ans, i - seen[cur - 1])\n        return ans\n        \n        # hours = [1 if h > 8 else 0 for h in hours]\n        # acc = [0] + list(accumulate(hours))\n        # i, j = 0, len(hours) - 1\n        # cur = sum(hours)\n        # ans = 0\n        # while i <= j:\n        #     if cur > (j - i + 1) // 2:\n        #         return j - i + 1\n            \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        res = score = 0\n        seen = {}\n        for i, h in enumerate(hours):\n            score = score + 1 if h > 8 else score - 1\n            if score > 0:\n                res = i + 1\n            seen.setdefault(score, i)\n            if score - 1 in seen:\n                res = max(res, i - seen[score - 1])\n        return res", "class Solution:\n    def longestWPI(self, h: List[int]) -> int:\n        n=len(h)\n        for i in range(n):\n            if h[i]>8:\n                h[i]=1\n            else:\n                h[i]=-1\n        #longest subarray with sum >0\n        pre=[0]*n \n        pre[0]=h[0]\n        maxi=0\n        for i in range(1,n):\n            pre[i]=pre[i-1]+h[i]\n        d={}\n        print(pre)\n        for x in range(n):\n            if pre[x]>0:\n                maxi=x+1\n            if d.get(pre[x]-1,-1)!=-1:\n                #print(i,d[pre[x]])\n                maxi=max(maxi,x-d[pre[x]-1])\n            if d.get(pre[x],-1)==-1:\n                d[pre[x]]=x\n        return maxi", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        i=0\n        prefixSum=0\n        existed={0:0}\n        res=0\n        while i<=len(hours)-1:\n            if hours[i]>=9:\n                prefixSum+=1\n            else:\n                prefixSum-=1\n            \n            if prefixSum not in existed:\n                existed[prefixSum]=i+1\n            if prefixSum-1 in existed:\n                res=max(res, i+1-existed[prefixSum-1])\n            if prefixSum>=1:\n                res=max(res, i+1)\n            i+=1\n        #print(existed)\n        return res", "class Solution:\n    # Use an index to store where\n    #       score - 1            score\n    # |-----------|----------------|\n    #             |--------1-------|\n    def longestWPI(self, hours: List[int]) -> int:\n        score, longest = 0, 0\n        index = {}\n        for i, n in enumerate(hours):\n            score += 1 if n > 8 else -1\n            if score > 0:  # more tiring days so far\n                longest = max(longest, i + 1)\n            index.setdefault(score, i)  # record the earliest presum with score\n            if score - 1 in index:\n                longest = max(longest, i - index[score - 1])\n        return longest", "import bisect\n\nclass Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        \n        starts = []\n        startIndexes = []\n        counts = [0] * len(hours)\n        \n        for i in range(len(hours)):\n            if i > 0:\n                counts[i] = counts[i - 1]\n            if hours[i] > 8:\n                counts[i] += 1\n            else:\n                counts[i] -= 1\n                \n        counts = [0] + counts\n        \n        for i in range(len(counts) - 1, -1 , -1):\n            numGood = counts[i]\n            while starts and starts[-1] >= numGood:\n                starts.pop()\n                startIndexes.pop()\n                \n            starts.append(numGood)\n            startIndexes.append(i)\n            \n        maxLen = 0\n        for i, c in enumerate(counts):\n            target = c - 1 \n            # pos1 = len(starts) - 1\n            # while pos1 >= 0 and starts[pos1] > target:\n            #     pos1 -= 1\n            pos = bisect.bisect_right(starts, target)\n            if pos == len(starts) or starts[pos] > target:\n                pos -= 1\n            if pos >= 0:\n                lenHere = i - startIndexes[pos]\n                maxLen = max(maxLen, lenHere)\n                \n        return maxLen\n                \n           \n            \n        \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        hoursLen = len(hours)\n        tDay = []\n        preSum = 0\n        preSumDict = {0:-1}\n        preSumKeys = [0]\n        ans = 0\n        \n        def insertAt(x):\n            l = 0\n            r = len(preSumKeys)-1\n            if x < preSumKeys[l]:\n                return 0\n            if x > preSumKeys[r]:\n                return r + 1\n            while r > l:\n                m = (r + l)//2\n                if preSumKeys[m] < x:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n        \n        ans = 0\n        for i, hour in enumerate(hours):\n            if hour > 8:\n                tDay.append(1)\n                preSum += 1               \n            else:\n                tDay.append(-1)\n                preSum -= 1  \n            tempIndex = insertAt(preSum)\n            if preSum not in preSumDict:\n                preSumDict[preSum] = i\n                preSumKeys.insert(tempIndex, preSum)\n            if tempIndex > 0:\n                preSumDict[preSumKeys[tempIndex]] = min( preSumDict[preSumKeys[tempIndex-1]], preSumDict[preSumKeys[tempIndex]])\n                ans = max(ans, i - preSumDict[preSumKeys[tempIndex-1]])\n        # print(preSumKeys)\n        # print(preSum)\n        return ans", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        s = 0\n        maxLen = 0\n        seen = {}\n        for idx, hour in enumerate(hours):\n            if hour > 8:\n                s += 1\n            else:\n                s -=1\n            if s > 0:\n                res = idx + 1\n                maxLen = max(maxLen, res)\n            else:\n                if (s-1) in seen:\n                    res = (idx - seen[s-1])\n                    maxLen = max(maxLen, res)\n            \n            if s not in seen:\n                seen[s] = idx\n        return maxLen         \n                \n            \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        stack,res,first=0,0,{}\n        for day,i in enumerate(hours):\n            stack=stack+1 if i>8 else stack-1\n            first.setdefault(stack, day)\n            if stack>0:res=day+1\n            elif stack-1 in first:\n                res=max(res,day-first[stack-1])\n        return res", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        stack = []\n        ans = accu = 0\n        for i, h in enumerate(hours):\n            if h > 8:\n                accu += 1\n            else:\n                accu -= 1\n            if accu > 0:\n                ans = i + 1\n            else:\n                L, U = -1, len(stack)\n                while L + 1 < U:\n                    m = (L + U) // 2\n                    if stack[m][1] < accu:\n                        U = m\n                    else:\n                        L = m\n                if U < len(stack):\n                    ans = max(ans, i - stack[U][0])\n            if not stack or stack[-1][1] > accu:\n                stack.append((i, accu ))\n        return ans\n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        # ans, cum, seen = 0, 0, {}\n        # for i, hour in enumerate(hours):\n        #     cum = cum + 1 if hour > 8 else cum - 1\n        #     if cum > 0:\n        #         ans = i + 1\n        #     else:\n        #         if cum not in seen:\n        #             seen[cum] = i\n        #         if cum - 1 in seen:\n        #             ans = max(ans, i - seen[cum - 1])\n        # return ans\n    \n        res = score = 0\n        seen = {}\n        for i, h in enumerate(hours):\n            score = score + 1 if h > 8 else score - 1\n            if score > 0:\n                res = i + 1\n            seen.setdefault(score, i)\n            if score - 1 in seen:\n                res = max(res, i - seen[score - 1])\n        return res", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        total = res = 0\n        index = {}\n        for i, h in enumerate(hours):\n            total += 1 if h > 8 else -1\n            if total > 0:\n                res = i + 1\n            if total - 1 in index:\n                res = max(res, i - index[total-1])\n            index.setdefault(total, i)\n            \n        return res\n        \n        \n", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        s = []\n        for i in hours:\n            if i > 8:\n                s.append(1)\n            else:\n                s.append(-1)\n                \n        n = len(s)\n        presum = [0]*(n+1)\n        for i in range(1,(n+1)):\n            presum[i] = presum[i-1] + s[i-1]\n        \n        stack = []\n        n = len(presum)\n        for i in range(n):\n            if not stack or presum[stack[-1]] > presum[i]:\n                stack.append(i)\n        res = 0\n        i = n-1\n        while i > res:\n            while stack and presum[stack[-1]] < presum[i]:\n                res = max(res,i-stack[-1])\n                stack.pop()\n            i -=1\n        return res", "class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        presum = 0\n        res = 0\n        mem = {}\n        for i, h in enumerate(hours):\n            presum += (1 if h > 8 else -1)\n            if presum > 0:\n                res = i + 1\n            else:\n                if presum - 1 in mem:\n                    res = max(res, i - mem[presum - 1])\n            if presum not in mem:\n                mem[presum] = i\n        return res"]
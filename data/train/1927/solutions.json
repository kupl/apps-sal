["class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         l=len(asteroids)\n         if l<2:\n             return asteroids\n         ans=[]\n         stack=[]\n         for a in asteroids:\n             if a>0:\n                 stack.append(a)\n             else:\n                 a=-a\n                 equal_flag=False\n                 while stack:\n                     cur=stack.pop()                  \n                     if cur==a:\n                         equal_flag=True\n                         break\n                     elif cur>a:\n                         stack.append(cur)\n                         break              \n                 if equal_flag:\n                     continue            \n                 if not stack:\n                     ans.append(-a)\n         return ans+stack\n             \n", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         st, res = [], []\n         for ast in asteroids:\n             if ast > 0:\n                 st.append(ast)\n                 continue\n             elif not st:\n                 res.append(ast)\n                 continue\n             flag = True\n             while st:\n                 if abs(ast) < st[-1]:\n                     flag = False\n                     break\n                 ast1 = st.pop()\n                 if abs(ast) == ast1:\n                     flag = False\n                     break\n             if flag:\n                 res.append(ast)\n         return res + st\n                     \n", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         #O(N) time and O(N) space\n         #stack solution        \n         ans = []\n         for new in asteroids:\n             while True:\n                 if ans and new < 0 < ans[-1]:\n                     if ans[-1] < abs(new):\n                         ans.pop()\n                         continue\n                     elif ans[-1] == abs(new):\n                         ans.pop()\n                     break\n                 else:\n                     ans.append(new)\n                     break\n         return ans", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         stack = []\n         for a in asteroids:\n             if a >= 0 or a < 0 and (not stack or stack[-1] < 0):\n                 stack.append(a)\n             else:\n                 while a < 0 and stack and stack[-1] > 0:\n                     last = stack.pop() # last > 0\n                     a = a if -a > last else last if -a < last else 0\n                 if a != 0:\n                     stack.append(a)\n         \n         return stack", "#\n # [735] Asteroid Collision\n #\n # https://leetcode.com/problems/asteroid-collision/description/\n #\n # algorithms\n # Medium (37.15%)\n # Total Accepted:    6.6K\n # Total Submissions: 17.7K\n # Testcase Example:  '[5,10,-5]'\n #\n # \n # We are given an array asteroids of integers representing asteroids in a row.\n # \n # For each asteroid, the absolute value represents its size, and the sign\n # represents its direction (positive meaning right, negative meaning left).\n # Each asteroid moves at the same speed.\n # \n # Find out the state of the asteroids after all collisions.  If two asteroids\n # meet, the smaller one will explode.  If both are the same size, both will\n # explode.  Two asteroids moving in the same direction will never meet.\n # \n # \n # Example 1:\n # \n # Input: \n # asteroids = [5, 10, -5]\n # Output: [5, 10]\n # Explanation: \n # The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.\n # \n # \n # \n # Example 2:\n # \n # Input: \n # asteroids = [8, -8]\n # Output: []\n # Explanation: \n # The 8 and -8 collide exploding each other.\n # \n # \n # \n # Example 3:\n # \n # Input: \n # asteroids = [10, 2, -5]\n # Output: [10]\n # Explanation: \n # The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in\n # 10.\n # \n # \n # \n # Example 4:\n # \n # Input: \n # asteroids = [-2, -1, 1, 2]\n # Output: [-2, -1, 1, 2]\n # Explanation: \n # The -2 and -1 are moving left, while the 1 and 2 are moving right.\n # Asteroids moving the same direction never meet, so no asteroids will meet\n # each other.\n # \n # \n # \n # Note:\n # The length of asteroids will be at most 10000.\n # Each asteroid will be a non-zero integer in the range [-1000, 1000]..\n # \n #\n class Solution:\n     def asteroidCollision(self, asteroids):\n         stack = []\n         for a in asteroids:\n             if a == 0:\n                 continue\n             inserted = False\n             while not inserted:\n                 if len(stack) == 0 or a > 0 or (stack[-1]*a > 0):\n                     stack.append(a)\n                     inserted = True\n                 elif stack[-1] > 0 and a < 0:\n                     if stack[-1] > abs(a):\n                         inserted = True\n                     elif stack[-1] < abs(a):\n                         stack.pop()\n                     else:\n                         stack.pop()\n                         inserted = True\n         return stack\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         \n", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         if not asteroids:\n             return asteroids\n \n         remaining = []\n         for item in asteroids:\n                             \n             itemSign, itemVal = self.getItemDetails(item)\n             shouldAppend = False\n \n             while True:\n                 if not remaining:\n                     shouldAppend = True\n                     break\n                 \n                 topSign, topVal = self.getItemDetails(remaining[-1])\n \n                 if not (topSign and not itemSign):\n                     shouldAppend = True\n                     break\n \n                 if topVal > itemVal:\n                     break\n                 elif topVal == itemVal:\n                     remaining.pop()\n                     break\n                 else:\n                     remaining.pop()\n                                                                     \n             if shouldAppend:\n                 remaining.append(item)\n \n         return remaining\n \n     def getItemDetails(self, val):\n         return val > 0, abs(val)", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         \n         ret = []\n         \n         for val in asteroids:\n             \n             append_flag = True\n             \n             while len(ret) > 0:\n                 \n                 # both neg or pos\n                 if val * ret[-1] > 0:\n                     break\n                     \n                 if val > 0:\n                     break\n                 \n                 # val fails, ignore it\n                 if abs(val) < abs(ret[-1]):\n                     append_flag = False\n                     break\n \n                 # [-5, 5]\n                 if val + ret[-1] == 0:\n                     ret.pop()\n                     append_flag = False\n                     break\n                 \n                 ret.pop()\n                 \n             if append_flag:\n                 ret.append(val)\n                 \n         return ret\n     \n", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         stack = []\n         for a in asteroids:\n             if a >= 0 or a < 0 and (not stack or stack[-1] < 0):\n                 stack.append(a)\n             else:\n                 while a < 0 and stack and stack[-1] > 0:\n                     last = stack.pop() # last > 0\n                     a = a if -a > last else last if -a < last else 0\n                 if a != 0:\n                     stack.append(a)\n         \n         return stack", "class Solution:\n     def asteroidCollision(self, asteroids):\n         \"\"\"\n         :type asteroids: List[int]\n         :rtype: List[int]\n         \"\"\"\n         stack = []\n         for a in asteroids:\n             if a >= 0 or a < 0 and (not stack or stack[-1] < 0):\n                 stack.append(a)\n             else:\n                 while a < 0 and stack and stack[-1] > 0:\n                     last = stack.pop() # last > 0\n                     a = a if -a > last else last if -a < last else 0\n                 if a != 0:\n                     stack.append(a)\n         \n         return stack"]
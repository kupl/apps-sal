["class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n\n        queue = deque([(0, 0, True)])\n        dists = {(0, 0, True): 0}\n\n        while queue:\n            i, j, hor = queue.popleft()\n            if (i, j) == (m-1, n-2):\n                return dists[(i, j, hor)]\n            if hor:\n                if j+2 < n and not grid[i][j+2]:\n                    if (i, j+1, hor) not in dists:\n                        queue.append((i, j+1, hor))\n                        dists[(i, j+1, hor)] = dists[(i, j, hor)]+1\n                if i+1 < m and not grid[i+1][j] and not grid[i+1][j+1]:\n                    if (i+1, j, hor) not in dists:\n                        queue.append((i+1, j, hor))\n                        dists[(i+1, j, hor)] = dists[(i, j, hor)]+1\n                    if (i, j, not hor) not in dists:\n                        queue.append((i, j, not hor))\n                        dists[(i, j, not hor)] = dists[(i, j, hor)]+1\n            else:\n                if i+2 < m and not grid[i+2][j]:\n                    if (i+1, j, hor) not in dists:\n                        queue.append((i+1, j, hor))\n                        dists[(i+1, j, hor)] = dists[(i, j, hor)]+1\n                if j+1 < n and not grid[i][j+1] and not grid[i+1][j+1]:\n                    if (i, j+1, hor) not in dists:\n                        queue.append((i, j+1, hor))\n                        dists[(i, j+1, hor)] = dists[(i, j, hor)]+1\n                    if (i, j, not hor) not in dists:\n                        queue.append((i, j, not hor))\n                        dists[(i, j, not hor)] = dists[(i, j, hor)]+1\n        \n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        q = collections.deque([(0, 0, 0, 1, 0)])\n        visited = set([(0, 0, 0, 1)])\n        while q: \n            tailx, taily, headx, heady, steps = q.popleft()\n            if (tailx == n-1 and taily == n-2 and headx == n-1 and heady == n-1):\n                return steps\n            for n_tailx, n_taily, n_headx, n_heady in (\n                (tailx, taily+1, headx, heady+1),\n                (tailx+1, taily, headx+1, heady)): \n                if (0 <= n_tailx < n and 0<= n_taily < n  and\n                    0 <= n_headx < n and 0<= n_heady <n  and\n                    (n_tailx, n_taily, n_headx, n_heady) not in visited and\n                    grid[n_headx][n_heady] == 0 and grid[n_tailx][n_taily] == 0):\n                    visited.add((n_tailx, n_taily, n_headx, n_heady))\n                    #print(\\\"lr\\\", (n_tailx, n_taily, n_headx, n_heady, steps + 1)) \n                    q.append((n_tailx, n_taily, n_headx, n_heady, steps + 1))\n            if (tailx == headx):\n                if (tailx + 1 < n and \n                    grid[tailx + 1][taily] == 0 and \n                    grid[headx + 1][heady] == 0 and \n                    (tailx, taily, tailx+1, taily) not in visited):\n                    visited.add((tailx, taily, tailx+1, taily))\n                    #print(\\\"rc\\\",(tailx, taily, tailx+1, taily, steps + 1))\n                    q.append((tailx, taily, tailx+1, taily, steps + 1))\n            if (taily == heady):\n                if (taily + 1 < n and \n                    grid[tailx][taily + 1] == 0 and \n                    grid[headx][heady +1] == 0 and \n                    (tailx, taily, tailx, taily+1) not in visited):\n                    visited.add((tailx, taily, tailx, taily+1))\n                    #print(\\\"rcc\\\",(tailx, taily, tailx, taily+1, steps + 1))\n                    q.append((tailx, taily, tailx, taily+1, steps + 1))\n                    \n        return -1\n                    \n                    \n            \n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        start = (0, 0, 0, 1)\n        end = (n - 1, n - 2, n - 1, n - 1)\n        curr_level = {start}\n        moves = 0\n        visited = set()\n        while curr_level:\n            next_level = set()\n            for pos in curr_level:\n                visited.add(pos)\n                r1, c1, r2, c2 = pos\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\n                        \n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\n                        \n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\n                    if (r1, c1, r1 + 1, c1) not in visited:\n                        next_level.add((r1, c1, r1 + 1, c1))\n                        \n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\n                    if (r1, c1, r1, c1 + 1) not in visited:\n                        next_level.add((r1, c1, r1, c1 + 1))\n                        \n            if end in next_level:\n                return moves + 1\n            curr_level = next_level\n            moves += 1\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        start = (0, 0, 0, 1)\n        end = (n - 1, n - 2, n - 1, n - 1)\n        curr_level = {start}\n        moves = 0\n        visited = set()\n        while curr_level:\n            next_level = set()\n            for pos in curr_level:\n                visited.add(pos)\n                r1, c1, r2, c2 = pos\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\n                    if (r1, c1, r1 + 1, c1) not in visited:\n                        next_level.add((r1, c1, r1 + 1, c1))\n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\n                    if (r1, c1, r1, c1 + 1) not in visited:\n                        next_level.add((r1, c1, r1, c1 + 1))\n            if end in next_level:\n                return moves + 1\n            curr_level = next_level\n            moves += 1\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dq = collections.deque() # Front is left, back is right\n        dq.append(((0,1),1,0,\\\"first move\\\")) # position of head, orientation, distance travelled\n        seen = set()\n        while len(dq) > 0:\n            pos,orientation,dist,move = dq.popleft()\n            # print(pos,orientation,dist,move,dq)\n            i,j = pos\n            if (pos,orientation) not in seen:\n                seen.add((pos,orientation))\n                if pos == (n-1,n-1):\n                    if orientation == 1:\n                        return dist\n                    else:\n                        pass\n                else:\n                    if orientation == 1:\n                        if j < n - 1 and grid[i][j+1] == 0:\n                            dq.append(((i,j+1),orientation,dist+1,\\\"go right\\\"))\n                        if i < n - 1 and grid[i+1][j] == 0 and grid[i+1][j-1] == 0:\n                            dq.append(((i+1,j),orientation,dist+1,\\\"go down\\\"))\n                        if i < n - 1 and grid[i+1][j] == 0 and grid[i+1][j-1] == 0:\n                            dq.append(((i+1,j-1),1-orientation,dist+1,\\\"rotate clockwise\\\"))\n                    else:\n                        if i < n - 1 and grid[i+1][j] == 0:\n                            dq.append(((i+1,j),orientation,dist+1,\\\"go down\\\"))\n                        if j < n - 1 and grid[i][j+1] == 0 and grid[i-1][j+1] == 0:\n                            dq.append(((i,j+1),orientation,dist+1,\\\"go right\\\"))\n                        if j < n - 1 and grid[i][j+1] == 0 and grid[i-1][j+1] == 0:\n                            dq.append(((i-1,j+1),1-orientation,dist+1,\\\"rotate counterclockwise\\\"))\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        start = (0, 0, 0, 1)\n        end = (n - 1, n - 2, n - 1, n - 1)\n        curr_level = {start}\n        moves = 0\n        visited = set()\n        while curr_level:\n            next_level = set()\n            for pos in curr_level:\n                visited.add(pos)\n                r1, c1, r2, c2 = pos\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\n                    if (r1, c1, r1 + 1, c1) not in visited:\n                        next_level.add((r1, c1, r1 + 1, c1))\n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\n                    if (r1, c1, r1, c1 + 1) not in visited:\n                        next_level.add((r1, c1, r1, c1 + 1))\n            if end in next_level:\n                return moves + 1\n            curr_level = next_level\n            moves += 1\n        return -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        \n        n = len(grid)\n        q = [((0,1),(0,0))]\n        visited = set(q)\n        step = 0\n        while q:\n            l = len(q)\n            for _ in range(l):\n                (head, tail) = q.pop(0)\n                # print(head, tail)\n                if head==(n-1,n-1) and tail==(n-1,n-2): return step\n                if head[1]>tail[1]:\n\n                    if head[1]+1<n and grid[head[0]][head[1]+1]==0 and not ((head[0], head[1]+1), (tail[0],tail[1]+1)) in visited:\n                        q.append(((head[0], head[1]+1), (tail[0],tail[1]+1))) # move right\n                        visited.add(((head[0], head[1]+1), (tail[0],tail[1]+1)))\n                    if head[0]+1<n and grid[head[0]+1][head[1]]+grid[tail[0]+1][tail[1]]==0: \n                        if not ((head[0]+1, head[1]), (tail[0]+1,tail[1])) in visited:\n                            q.append(((head[0]+1, head[1]), (tail[0]+1,tail[1]))) # move down\n                            visited.add(((head[0]+1, head[1]), (tail[0]+1,tail[1])))\n                        if not ((head[0]+1,head[1]-1), tail) in visited:\n                            q.append(((head[0]+1,head[1]-1), tail)) # rotate clockwise\n                            visited.add(((head[0]+1,head[1]-1), tail))\n\n                else: # h[1] == t[1]\n\n                    if head[0]+1<n and grid[head[0]+1][head[1]] ==0 and not ((head[0]+1, head[1]), (tail[0]+1,tail[1])) in visited:\n                        q.append(((head[0]+1, head[1]), (tail[0]+1,tail[1]))) # move down\n                        visited.add(((head[0]+1, head[1]), (tail[0]+1,tail[1])))\n                    if head[1]+1<n and grid[head[0]][head[1]+1]+grid[tail[0]][tail[1]+1]==0:\n                        if not ((head[0], head[1]+1), (tail[0],tail[1]+1)) in visited:\n                            q.append(((head[0], head[1]+1), (tail[0],tail[1]+1))) # move right\n                            visited.add(((head[0], head[1]+1), (tail[0],tail[1]+1)))\n                        if not ((head[0]-1,head[1]+1), tail) in visited:\n                            q.append(((head[0]-1,head[1]+1), tail)) # rotate counterclockwise\n                            visited.add(((head[0]-1,head[1]+1), tail))\n            step += 1\n                \n            \n        return -1\n            \n            \n            \n            \n", "from collections import deque\nclass Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        # shortest path = standard BFS\n        n = len(grid)\n        visited = {(0,1,0,0)}\n        moves = -1\n        queue = deque([(0,1, 0,0)]) # [curr, last]\n        while queue:\n            level_len = len(queue)\n            moves +=1\n            for _ in range(level_len):\n                tp = queue.popleft()\n                curr, last = tp[:2], tp[2:]\n                if tp==(n-1,n-1,n-1,n-2):\n                    return moves\n                # 1. move right\n                if curr[1]+1<n and last[1]+1<n and grid[curr[0]][curr[1]+1]==0 and grid[last[0]][last[1]+1]==0 and (curr[0], curr[1]+1, last[0], last[1]+1) not in visited:\n                    visited.add((curr[0], curr[1]+1, last[0], last[1]+1))\n                    queue.append((curr[0], curr[1]+1, last[0], last[1]+1))\n                # 2. move down\n                if curr[0]+1<n and last[0]+1<n and grid[curr[0]+1][curr[1]]==0 and grid[last[0]+1][last[1]]==0 and (curr[0]+1, curr[1], last[0]+1, last[1]) not in visited:\n                    visited.add((curr[0]+1, curr[1], last[0]+1, last[1]))\n                    queue.append((curr[0]+1, curr[1], last[0]+1, last[1]))\n                # 3. rotate clockwise\n                if curr[0]==last[0] and curr[0]+1<n and grid[curr[0]+1][curr[1]]==0 and grid[last[0]+1][last[1]]==0 and (curr[0]+1, curr[1]-1, last[0], last[1]) not in visited:\n                    visited.add((curr[0]+1, curr[1]-1, last[0], last[1]))\n                    queue.append((curr[0]+1, curr[1]-1, last[0], last[1]))\n                # 4. rotate counterclockwise\n                if curr[1]==last[1] and curr[1]+1<n and grid[curr[0]][curr[1]+1]==0 and grid[last[0]][last[1]+1]==0 and (curr[0]-1, curr[1]+1, last[0], last[1]) not in visited:\n                    visited.add((curr[0]-1, curr[1]+1, last[0], last[1]))\n                    queue.append((curr[0]-1, curr[1]+1, last[0], last[1]))\n        return -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        q = collections.deque([(0, 0, 0, 1, 0)])\n        visited = set()\n        while q: \n            tailx, taily, headx, heady, steps = q.popleft()\n            if (tailx, taily, headx, heady) in visited: continue\n            visited.add((tailx, taily, headx, heady))\n            if (tailx == n-1 and taily == n-2 and headx == n-1 and heady == n-1):\n                return steps\n            for n_tailx, n_taily, n_headx, n_heady in (\n                (tailx, taily+1, headx, heady+1),\n                (tailx+1, taily, headx+1, heady)): \n                if (0 <= n_tailx < n and 0<= n_taily < n  and\n                    0 <= n_headx < n and 0<= n_heady <n  and\n                    (n_tailx, n_taily, n_headx, n_heady) not in visited and\n                    grid[n_headx][n_heady] == 0 and grid[n_tailx][n_taily] == 0):\n                    #print(\\\"lr\\\", (n_tailx, n_taily, n_headx, n_heady, steps + 1)) \n                    q.append((n_tailx, n_taily, n_headx, n_heady, steps + 1))\n            if (tailx == headx):\n                if (tailx + 1 < n and \n                    grid[tailx + 1][taily] == 0 and \n                    grid[headx + 1][heady] == 0 and \n                    (tailx, taily, tailx+1, taily) not in visited):\n                    #print(\\\"rc\\\",(tailx, taily, tailx+1, taily, steps + 1))\n                    q.append((tailx, taily, tailx+1, taily, steps + 1))\n            if (taily == heady):\n                if (taily + 1 < n and \n                    grid[tailx][taily + 1] == 0 and \n                    grid[headx][heady +1] == 0 and \n                    (tailx, taily, tailx, taily+1) not in visited):\n                    #print(\\\"rcc\\\",(tailx, taily, tailx, taily+1, steps + 1))\n                    q.append((tailx, taily, tailx, taily+1, steps + 1))\n                    \n        return -1\n                    \n                    \n            \n", "class Solution:\n\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        visited = set()\n        queue = deque()\n        n = len(grid)\n        queue.append((0, 0, 0, 1))\n        visited.add(queue[0])\n        res = 0\n        target = (n-1, n-2, n-1, n-1)\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                curr = queue.popleft()\n                if curr == target:\n                    return res\n                horizontal = curr[0] == curr[2]\n                \n                moves = []\n                \n                if curr[3] < n - 1 and grid[curr[0]][curr[1] + 1] == 0 and grid[curr[2]][curr[3] + 1] == 0:\n                    moves.append((curr[0], curr[1] + 1, curr[2], curr[3] + 1))\n                if curr[2] < n - 1 and grid[curr[0] + 1][curr[1]] == 0 and grid[curr[2] + 1][curr[3]] == 0:\n                    moves.append((curr[0] + 1, curr[1], curr[2] + 1, curr[3]))\n                if horizontal and curr[2] < n - 1 and grid[curr[0] + 1][curr[1]] == 0 and grid[curr[2] + 1][curr[3]] == 0:\n                    moves.append((curr[0], curr[1], curr[0] + 1, curr[1]))\n                if not horizontal and curr[3] < n - 1 and grid[curr[0]][curr[1] + 1] == 0 and grid[curr[2]][curr[3] + 1] == 0:\n                    moves.append((curr[0], curr[1], curr[0], curr[1] + 1))\n                \n                for move in moves:\n                    if move not in visited:\n                        visited.add(move)\n                        queue.append(move)\n            res += 1\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        dq = deque([(0, 0, 0, 1)])\n        seen = {(0, 0, 0, 1)}\n        steps = 0\n        \n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                r0, c0, r1, c1 = dq.popleft()\n                if r0==r1==M-1 and c0==N-2 and c1==N-1:\n                    return steps\n                \n                if r0==r1:\n                    # horizontal\n                    # rotate clockwise\n                    if r0+1<M and not grid[r0+1][c0] and not grid[r1+1][c1] \\\\\n                        and (r0, c0, r0+1, c0) not in seen:\n                        seen.add((r0, c0, r0+1, c0))\n                        dq.append((r0, c0, r0+1, c0))\n                elif c0==c1:\n                    # vertical\n                    # rotate counter clockwise\n                    if c1+1<N and not grid[r0][c0+1] and not grid[r1][c1+1] \\\\\n                        and (r0, c0, r0, c0+1) not in seen:\n                        seen.add((r0, c0, r0, c0+1))\n                        dq.append((r0, c0, r0, c0+1))\n                \n                # 1. move right\n                if c1+1<N and not grid[r0][c0+1] and not grid[r1][c1+1] \\\\\n                    and (r0, c0+1, r1, c1+1) not in seen:\n                    seen.add((r0, c0+1, r1, c1+1))\n                    dq.append((r0, c0+1, r1, c1+1))\n                    \n                # 2. move down\n                if r1+1<M and not grid[r0+1][c0] and not grid[r1+1][c1] \\\\\n                    and (r0+1, c0, r1+1, c1) not in seen:\n                    seen.add((r0+1, c0, r1+1, c1))\n                    dq.append((r0+1, c0, r1+1, c1))\n                    \n            steps += 1\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        stack = [(0, 0, 0, 0, 1)]\n        n = len(grid)\n        visited = set()\n        visited.add((0, 0, 0, 1))\n\n        while stack:\n            stepNow, ia, ja, ib, jb = heapq.heappop(stack)\n            \n            ia1, ja1, ib1, jb1 = ia, ja+1, ib, jb+1\n            if jb1 < n and grid[ib1][jb1] == 0 and grid[ia1][ja1] == 0 and (ia1, ja1, ib1, jb1) not in visited:\n                if (ia1, ja1, ib1, jb1) == (n-1, n-2, n-1, n-1):\n                    return stepNow+1\n                visited.add((ia1, ja1, ib1, jb1))\n                heapq.heappush(stack, (stepNow + 1, ia1, ja1, ib1, jb1))\n            \n            ia1, ja1, ib1, jb1 = ia+1, ja, ib+1, jb\n            if ia1 < n and ib1 < n and grid[ib1][jb1] == 0 and grid[ia1][ja1] == 0 and (ia1, ja1, ib1, jb1) not in visited:\n                if (ia1, ja1, ib1, jb1) == (n-1, n-2, n-1, n-1):\n                    return stepNow+1\n                visited.add((ia1, ja1, ib1, jb1))\n                heapq.heappush(stack, (stepNow + 1, ia1, ja1, ib1, jb1))\n            \n            if ia == ib and ja == jb-1:\n                if ia + 1< n and grid[ia+1][ja] == 0 and grid[ib+1][jb] == 0:\n                    ia1, ja1, ib1, jb1 = ia, ja, ia+1, ja\n                    if (ia1, ja1, ib1, jb1) not in visited:\n                        if (ia1, ja1, ib1, jb1) == (n-1, n-2, n-1, n-1):\n                            return stepNow+1\n                        visited.add((ia1, ja1, ib1, jb1))\n                        heapq.heappush(stack, (stepNow + 1, ia1, ja1, ib1, jb1)) \n            \n            if ja == jb and ia == ib-1:\n                if ja + 1 < n and grid[ia][ja+1] == 0 and grid[ib][jb+1] == 0:\n                    ia1, ja1, ib1, jb1 = ia, ja, ia, ja+1\n                    if (ia1, ja1, ib1, jb1) not in visited:\n                        if (ia1, ja1, ib1, jb1) == (n-1, n-2, n-1, n-1):\n                            return stepNow+1\n                        visited.add((ia1, ja1, ib1, jb1))\n                        heapq.heappush(stack, (stepNow + 1, ia1, ja1, ib1, jb1)) \n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        m = n = len(grid)\n        visited = {0}\n        @lru_cache(None)\n        def move(i, j, k, r):\n            if i == m - 1 and j == n - 1 and k == 0:\n                return 0\n            result = 1e9\n            if k == 0:\n                if j + 1 < n and grid[i][j + 1] != 1:\n                    result = min(result, 1 + move(i, j + 1, k, 0))\n                if i + 1 < m and grid[i + 1][j] != 1 and grid[i + 1][j - 1] != 1:\n                    result = min(result, 1 + move(i + 1, j, k, 0))\n                    if not r:\n                        result = min(result, 1 + move(i + 1, j - 1, 1, 1)) \n            else:\n                if i + 1 < m and grid[i + 1][j] != 1:\n                    result = min(result, 1 + move(i + 1, j, k, 0))\n                if j + 1 < n and grid[i][j + 1] != 1 and grid[i - 1][j + 1] != 1:\n                    result = min(result, 1 + move(i, j + 1, k, 0))\n                    if not r:\n                        result = min(result, 1 + move(i - 1, j + 1, 0, 1))\n            return result\n        \n        result = move(0, 1, 0, 0)\n        return result if result < 1e9 else -1", "class Solution:\n    def is_empty(self, xy):\n        if 0 <= xy[0] < self.m and 0 <= xy[1] < self.n: \n            return self.grid[xy[0]][xy[1]] == 0\n        else:\n            return False\n    \n    def next_positions(self, pos):\n        tail, head = pos\n        if tail[0] == head[0]:\n            if self.is_empty((head[0], head[1] + 1)):\n                yield head, (head[0], head[1] + 1)\n            if self.is_empty((tail[0] + 1, tail[1])) and self.is_empty((head[0] + 1, head[1])):\n                yield (tail[0] + 1, tail[1]), (head[0] + 1, head[1])\n                yield tail, (tail[0] + 1, tail[1])\n        else:\n            assert tail[1] == head[1]\n            if self.is_empty((head[0] + 1, head[1])):\n                yield head, (head[0] + 1, head[1])\n            if self.is_empty((tail[0], tail[1] + 1)) and self.is_empty((head[0], head[1] + 1)):\n                yield (tail[0], tail[1] + 1), (head[0], head[1] + 1)\n                yield tail, (tail[0], tail[1] + 1)\n            \n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.m = len(grid)\n        self.n = len(grid[0])\n        \n        layer = {((0, 0), (0, 1))}\n        visited = set()\n        dist = 0\n        target = ((self.m - 1, self.n - 2), (self.m - 1, self.n - 1))\n        \n        while layer:\n            if target in layer:\n                return dist\n            visited |= layer\n            next_layer = set()\n            for pos in layer:\n                for next_pos in self.next_positions(pos):\n                    if next_pos not in visited:\n                        next_layer.add(next_pos)\n            layer = next_layer\n            dist += 1\n        return -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        queue = collections.deque([(0, 0, 0, 1, 0)])\n        visited = {(0, 0, 0, 1)}\n        while queue:\n            r0, c0, r1, c1, steps = queue.popleft()\n            print(r0, c0, r1, c1, steps)\n            if r0 == n - 1 and r1 == n - 1 and c0 == n - 2 and c1 == n - 1:\n                return steps\n            if r0 == r1:\n                if 0 <= c1 + 1 < n and not grid[r1][c1 + 1] and (r1, c1, r1, c1 + 1) not in visited:\n                    visited.add((r1, c1, r1, c1 + 1))\n                    queue.append((r1, c1, r1, c1 + 1, steps + 1))\n                if 0 <= r0 + 1 < n and not grid[r0 + 1][c0] and not grid[r1 + 1][c1]:\n                    if (r0 + 1, c0, r1 + 1, c1) not in visited:\n                        visited.add((r0 + 1, c0, r1 + 1, c1))\n                        queue.append((r0 + 1, c0, r1 + 1, c1, steps + 1))\n                    if (r0, c0, r0 + 1, c0) not in visited:\n                        visited.add((r0, c0, r0 + 1, c0))\n                        queue.append((r0, c0, r0 + 1, c0, steps + 1))\n            else:\n                if 0 <= c0 + 1 < n and not grid[r0][c0 + 1] and not grid[r1][c1 + 1]:\n                    if (r0, c0 + 1, r1, c1 + 1) not in visited:\n                        visited.add((r0, c0 + 1, r1, c1 + 1))\n                        queue.append((r0, c0 + 1, r1, c1 + 1, steps + 1))\n                    if (r0, c0, r0, c0 + 1) not in visited:\n                        visited.add((r0, c0, r0, c0 + 1))\n                        queue.append((r0, c0, r0, c0 + 1, steps + 1))\n                if 0 <= r1 + 1 < n and not grid[r1 + 1][c1]:\n                    if (r1, c1, r1 + 1, c1) not in visited:\n                        visited.add((r1, c1, r1 + 1, c1))\n                        queue.append((r1, c1, r1 + 1, c1, steps + 1))\n        \n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        num_steps_horizontal = [[float('inf') for _ in range(n)] for _ in range(n)]\n        num_steps_vertical = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n        if not (grid[0][0] == grid[0][1] == 0):\n            raise ValueError\n\n        # initialization\n        num_steps_horizontal[0][0] = 0\n        for col in range(1, n - 1):\n            if grid[0][col + 1] == 0:\n                num_steps_horizontal[0][col] = 1 + num_steps_horizontal[0][col - 1]\n            else:\n                break\n\n        # iterate over num_steps_horizontal and num_steps_vertical\n        for row in range(n):\n            for col in range(n):\n                if col < n - 1 and grid[row][col] == grid[row][col + 1] == 0:\n                    num_steps_horizontal[row][col] = min(\n                        num_steps_horizontal[row][col],\n                        1 + num_steps_horizontal[row][col - 1], # from left \n                        1 + num_steps_horizontal[row - 1][col], # from above\n                        )\n                if row < n - 1 and grid[row][col] == grid[row + 1][col] == 0:\n                    num_steps_vertical[row][col] = min(\n                        num_steps_vertical[row][col],\n                        1 + num_steps_vertical[row][col - 1], # from left \n                        1 + num_steps_vertical[row - 1][col], # from above\n                        )\n                if (col < n - 1 and row < n - 1\n                   and grid[row][col] == grid[row][col + 1] == 0\n                   and grid[row + 1][col] == grid[row + 1][col + 1] == 0):\n                    num_steps_horizontal[row][col] = min(num_steps_horizontal[row][col], 1 + num_steps_vertical[row][col])\n                    num_steps_vertical[row][col] = min(num_steps_vertical[row][col], 1 + num_steps_horizontal[row][col])\n        \n        if num_steps_horizontal[-1][-2] < float('inf'):\n            return num_steps_horizontal[-1][-2]\n        else:\n            return -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        queue, visited, n = collections.deque([( (0, 0), (0, 1), 0)]), set(), len(grid)\n        target = ((n-1, n-2), (n-1, n-1))\n        while queue:\n            (r1, c1), (r2, c2), steps = queue.popleft()\n            if ((r1, c1), (r2, c2))==target:\n                return steps\n            if ((r1, c1), (r2, c2)) in visited:\n                continue\n            visited |= {((r1, c1), (r2, c2))}\n            # vertical\n            if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\n                queue.append(((r1, c1 + 1), (r2, c2 + 1), steps+1))\n            # horizontal\n            if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\n                queue.append(((r1 + 1, c1), (r2 + 1, c2), steps+1))\n            # vertical\n            if r1 == r2 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\n                queue.append(((r1, c1), (r1 + 1, c1), steps+1))\n            if c1 == c2 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\n                queue.append(((r1, c1), (r1, c1 + 1), steps+1))\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dp = [[[float('inf'), float('inf')] for _ in range(n + 1)] for _ in range(n + 1)]\n        dp[0][1][0] = dp[1][0][0] = -1\n        for r in range(1, n + 1):\n            for c in range(1, n + 1):\n                h, v = False, False\n                if grid[r - 1][c - 1] == 0 and c < n and grid[r - 1][c] == 0:\n                    dp[r][c][0] = min(dp[r - 1][c][0], dp[r][c - 1][0]) + 1\n                    h = True\n                if grid[r - 1][c - 1] == 0 and r < n and grid[r][c - 1] == 0:\n                    dp[r][c][1] = min(dp[r - 1][c][1], dp[r][c - 1][1]) + 1\n                    v = True\n                if v and c < n and grid[r][c] == 0:\n                    dp[r][c][1] = min(dp[r][c][1], dp[r][c][0] + 1)\n                if h and r < n and grid[r][c] == 0:\n                    dp[r][c][0] = min(dp[r][c][0], dp[r][c][1] + 1)\n        return dp[n][n - 1][0] if dp[n][n - 1][0] < float('inf') else -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        Inf = float('inf')\n        dp = [[(Inf, Inf)] * cols for _ in range(rows)]\n        dp[-1][-2] = (0, Inf)\n        out = lambda r, c: not (0 <= r < rows and 0 <= c < cols)\n        get = lambda r, c: (Inf, Inf) if out(r, c) else dp[r][c]\n        canBeHorizontal = lambda r, c: c < cols - 1 and grid[r][c+1] != 1\n        canBeVertical = lambda r, c: r < rows - 1 and grid[r+1][c] != 1\n        canTransform = lambda r, c: canBeVertical(r, c) and canBeHorizontal(r, c)\\\\\n            and (r < rows - 1 and c < cols - 1 and grid[r+1][c+1] != 1)\n        \n        HORIZONTAL = 0\n        VERTICAL = 1\n\n        for r in range(rows - 1, -1, -1):\n            for c in range(cols - 1, -1, -1):\n                if grid[r][c] or (r == rows - 1 and c == cols - 2): continue\n                hmove = vmove = Inf\n                moveDown = get(r + 1, c)\n                moveRight = get(r, c + 1)\n                if canBeHorizontal(r, c):\n                    hmove = 1 + min(moveDown[HORIZONTAL], moveRight[HORIZONTAL])\n                if canBeVertical(r, c):\n                    vmove = 1 + min(moveDown[VERTICAL], moveRight[VERTICAL])\n                if canTransform(r, c):\n                    hmove, vmove = min(hmove, 1 + vmove), min(vmove, 1 + hmove)\n                dp[r][c] = (hmove, vmove)\n        minSteps = dp[0][0][HORIZONTAL]\n        if minSteps == Inf: return -1\n        return minSteps\n        ", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        queue, visited, n = collections.deque([( (0, 0), (0, 1), 0)]), set(), len(grid)\n        target = ((n-1, n-2), (n-1, n-1))\n        while queue:\n            (r1, c1), (r2, c2), steps = queue.popleft()\n            if ((r1, c1), (r2, c2))==target:\n                return steps\n            if ((r1, c1), (r2, c2)) in visited:\n                continue\n            visited |= {((r1, c1), (r2, c2))}\n            if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\n                queue.append(((r1, c1 + 1), (r2, c2 + 1), steps+1))\n            if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\n                queue.append(((r1 + 1, c1), (r2 + 1, c2), steps+1))\n            if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\n                queue.append(((r1, c1), (r1 + 1, c1), steps+1))\n            if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\n                queue.append(((r1, c1), (r1, c1 + 1), steps+1))\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        q, seen, target = [(0, 0, 0, 0)], set(), (n - 1, n - 2, 0)              # row, column, row difference.\n        for r, c, dr, steps in q:\n            if (r, c, dr) == target: return steps                               # reach target.\n            if (r, c, dr) not in seen:                                          # prune duplicates.\n                seen.add((r, c, dr))\n                if dr:                                                          # vertical position. \n                    if c + 1 < n and grid[r][c + 1] + grid[r + 1][c + 1] == 0:  # the two cells right are emtpty.\n                        q += [(r, c + 1, 1, steps + 1), (r, c, 0, steps + 1)]   # right and counter-colock-wise rotate.\n                    if r + 2 < n and grid[r + 2][c] == 0:                       # the below cell is empty.\n                        q += [(r + 1, c, 1, steps + 1)]                         # down.\n                else:                                                           # horizontal position\n                    if r + 1 < n and grid[r + 1][c] + grid[r + 1][c + 1] == 0:  # the two cells below are empty.\n                        q += [(r + 1, c, 0, steps + 1), (r, c, 1, steps + 1)]   # down and colock-wise rotate.\n                    if c + 2 < n and grid[r][c + 2] == 0:                       # right cell is empty.\n                        q += [(r, c + 1, 0, steps + 1)]                         # right.\n        return -1\n    \n        \n                \n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        vis = set()\n        q = collections.deque([(0, 0, 0, 0)])\n        d = [[0, 1], [1, 0]]\n        n = len(grid)\n        while q:\n            # print(q)\n            node = q.popleft()\n            if node[0] == (n - 1) and node[1] == (n - 2) and node[2] == 0:\n                return node[3]\n            snake = [[node[0], node[1]], [node[0] + d[node[2]][0], node[1] + d[node[2]][1]]]\n            for i in d:\n                possible = True\n                for c in snake:\n                    nx = c[0] + i[0]\n                    ny = c[1] + i[1]\n                    if nx < 0 or ny < 0 or nx >= n or ny >= n:\n                        possible = False\n                        break\n                    if grid[nx][ny] != 0:\n                        possible = False\n                        break\n                if possible:\n                    nx = node[0] + i[0]\n                    ny = node[1] + i[1]\n                    if (nx, ny, node[2]) not in vis:\n                        vis.add((nx, ny, node[2]))\n                        q.append((nx, ny, node[2], node[3] + 1))\n                    if node[2] == 0 and i[0] == 1:\n                        if (node[0], node[1], 1) not in vis:\n                            vis.add((node[0], node[1], 1))\n                            q.append((node[0], node[1], 1, node[3] + 1))\n                    elif node[2] == 1 and i[0] == 0:\n                        if (node[0], node[1], 0) not in vis:\n                            vis.add((node[0], node[1], 0))\n                            q.append((node[0], node[1], 0, node[3] + 1))\n        return -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        q=[(0,0,0,1)]\n        moves = 0\n        visited = set([(0,0,0,1)])\n        while q:\n            size=len(q)\n            for _ in range(size):\n                x1,y1,x2,y2=q.pop(0)\n                if x1==n-1 and y1==n-2 and x2==n-1 and y2==n-1:\n                    return moves\n#\u6bcf\u4e00\u6b21\u86c7\u53ef\u4ee5\u5411\u53f3\u79fb\u52a8\uff0c\u5411\u4e0b\u79fb\u52a8\uff0c\n#\u539f\u5730\u8f6c\u5708\u6c34\u5e73\u53d8\u7ad6\u76f4\u4e0e\u7ad6\u76f4\u53d8\u6c34\u5e73\u5c3e\u5df4\u4e0d\u52a8\u5934\u53d8\n                if y1+1<n and grid[x1][y1+1]==0 and y2+1<n and grid[x2][y2+1] == 0:  #\u5411\u53f3\u79fb\u52a8\n                    if (x1,y1+1,x2,y2+1) not in visited:\n                        visited.add((x1,y1+1,x2,y2+1))\n                        q.append((x1,y1+1,x2,y2+1))\n                if x1+1<n and grid[x1+1][y1]==0 and x2+1<n and grid[x2+1][y2]==0:   #\u5411\u4e0b\u79fb\u52a8\n                    if ((x1+1,y1,x2+1,y2)) not in visited:\n                        visited.add((x1+1,y1,x2+1,y2))\n                        q.append((x1+1,y1,x2+1,y2))\n                if x1==x2 and y2==y1+1 and x1+1<n and grid[x1+1][y1]+grid[x1+1][y1+1]==0:\n                    if (x1,y1,x1+1,y1) not in visited:\n                        visited.add((x1,y1,x1+1,y1))\n                        q.append((x1,y1,x1+1,y1))\n                if y1==y2 and x2==x1+1 and y1+1<n and grid[x1][y1+1]+grid[x1+1][y1+1] == 0:  #\u7ad6\u76f4\u53d8\u6c34\u5e73\n                    if (x1,y1,x1,y1+1) not in visited:\n                        visited.add((x1,y1,x1,y1+1))\n                        q.append((x1,y1,x1,y1+1))\n            \n            moves += 1\n        return -1", "import heapq\nfrom typing import List\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n\n    self.grid = grid\n    self.R, self.C = len(grid), len(grid[0])\n    target = (self.R - 1, self.C - 1)\n\n    q = [(0, 0, 1, 0)]  # (distance traveled, row, column, orientation)\n    visited = [{(0, 1): 0}, {}]  # visited in horizontal state, visited in vertical state\n\n    while q:\n\n      d, r, c, o = heapq.heappop(q)\n\n      # Check if snake can shift down, shift right, or rotate\n      shift_d, shift_r, rot = self.shift_down(r, c, o), self.shift_right(r, c, o), self.rotate(r, c, o)\n\n      # increment distance traveled by 1\n      d += 1\n\n      # Update the queue and visited after the snake has shifted down, right, or rotated\n      if shift_d:\n        i, j = shift_d\n        if d < visited[o].get((i, j), float('inf')):\n          visited[o][(i, j)] = d\n          heapq.heappush(q, (d, i, j, o))\n\n      if shift_r:\n        i, j = shift_r\n        if d < visited[o].get((i, j), float('inf')):\n          visited[o][(i, j)] = d\n          heapq.heappush(q, (d, i, j, o))\n\n      if rot:\n        i, j = rot\n        if d < visited[1 - o].get((i, j), float('inf')):\n          visited[1 - o][(i, j)] = d\n          heapq.heappush(q, (d, i, j, 1 - o))\n\n    return visited[0].get(target, -1)\n\n  def shift_right(self, r, c, orient):\n    '''returns False if snake cannot move to the right, otherwise returns new head position'''\n    if (orient == 0) and ((c == self.C - 1) or self.grid[r][c + 1]): return False\n    if (orient == 1) and ((c == self.C - 1) or self.grid[r][c + 1] or self.grid[r - 1][c + 1]): return False\n    return (r, c + 1)\n\n  def shift_down(self, r, c, orient):\n    '''returns False if snake cannot move downwards, otherwise returns new head position'''\n    if (orient == 1) and ((r == self.R - 1) or self.grid[r + 1][c]): return False\n    if (orient == 0) and ((r == self.R - 1) or self.grid[r + 1][c] or self.grid[r + 1][c - 1]): return False\n    return (r + 1, c)\n\n  def rotate(self, r, c, orient):\n    '''returns False if the snake is blocked from rotating, otherwise returns new head position (r,c)'''\n    # horizontal to vertical CW rotation\n    if (orient == 0) and ((r == self.R - 1) or self.grid[r + 1][c] or self.grid[r + 1][c - 1]): return False\n    if (orient == 0): return (r + 1, c - 1)\n\n    # vertical to horizontal CCW rotation\n    if (c == self.C - 1) or self.grid[r][c + 1] or self.grid[r - 1][c + 1]: return False\n    return (r - 1, c + 1)\n", "class Solution:\n    def minimumMoves(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n = len(grid)\n        if grid[-1][-1] == 1:\n            return -1\n        dp = [[[float('inf'), float('inf')] for i in range(n)] for j in range(n)]\n        dp[0][0][0] = 0\n        for j in range(1, n - 1):\n            if grid[0][j + 1] == 0:\n                dp[0][j][0] = dp[0][j - 1][0] + 1\n            else:\n                break\n        for i in range(n):\n            for j in range(n):\n                if j < n - 1 and grid[i][j + 1] == 0 and grid[i][j] == 0:\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\n                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1)\n                if i < n - 1 and grid[i + 1][j] == 0 and grid[i][j] == 0:\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\n                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\n                if i < n - 1 and j < n - 1 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float('inf') else -1\n\n\n# class Solution:\n#     def minimumMoves(self, grid: List[List[int]]) -> int:\n#         n = len(grid)\n#         num_steps_horizontal = [[float('inf') for _ in range(n)] for _ in range(n)]\n#         num_steps_vertical = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n#         if not (grid[0][0] == grid[0][1] == 0):\n#             raise ValueError\n\n#         # initialization\n#         num_steps_horizontal[0][0] = 0\n#         for col in range(1, n - 1):\n#             if grid[0][col] == 0:\n#                 num_steps_horizontal[0][col] = 1 + num_steps_horizontal[0][col - 1]\n#             else:\n#                 break\n\n#         if grid[1][0] == grid[1][1] == 0:\n#             num_steps_vertical[0][0] = 1\n#             for row in range(1, n):\n#                 if grid[row][0] == 0:\n#                     num_steps_vertical[row][0] = 1 + num_steps_vertical[row - 1][0]\n#                 else:\n#                     break\n\n#         # iterate over num_steps_horizontal and num_steps_vertical\n#         for row in range(1, n):\n#             for col in range(1, n):\n#                 if col < n - 1 and grid[row][col] == grid[row][col + 1] == 0:\n#                     num_steps_horizontal[row][col] = 1 + min(\n#                         num_steps_horizontal[row][col - 1], # from left \n#                         num_steps_horizontal[row - 1][col], # from above\n#                         )\n#                 if row < n - 1 and grid[row][col] == grid[row + 1][col] == 0:\n#                     num_steps_vertical[row][col] = 1 + min(\n#                         num_steps_vertical[row][col - 1], # from left \n#                         num_steps_vertical[row - 1][col], # from above\n#                         )\n#                 if (col < n - 1 and row < n - 1\n#                    and grid[row][col] == grid[row][col + 1] == 0\n#                    and grid[row][col] == grid[row + 1][col] == 0):\n#                     num_steps_horizontal[row][col] = min(num_steps_horizontal[row][col], 1 + num_steps_vertical[row][col])\n#                     num_steps_vertical[row][col] = min(num_steps_vertical[row][col], 1 + num_steps_horizontal[row][col])\n                    \n#         if num_steps_horizontal[-1][-2] < float('inf'):\n#             return num_steps_horizontal[-1][-2]\n#         else:\n#             return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        rows,cols = len(grid),len(grid[0])\n        def getOr(x1,y1,x2,y2): return 'H' if y2 == y1 + 1 else 'V'\n        def inB(x,y): return x < rows and x >= 0 and y < cols and y >= 0 \n        dic = {(rows-1,cols - 2,rows-1,cols-1):0}\n        def dfs(x1,y1,x2,y2,visited):\n            mn = float('inf')\n            visited.add((x1,y1,x2,y2))\n            if (x1 == rows-1 and y1 == cols - 2 and x2 == rows-1 and y2 == cols-1): return 0\n            x,y = x1,y1\n            if getOr(x1,y1,x2,y2) == 'H': \n                r1,c1,r2,c2 =x,y+1,x,y+2\n                if(r1,c1,r2,c2) in dic: mn = min(mn, 1 + dic[(r1,c1,r2,c2)])\n                elif inB(r1,c1) and inB(r2,c2) and grid[r2][c2]==0 and (r1,c1,r2,c2) not in visited:\n                    mn = min(mn, 1 + dfs(r1,c1,r2,c2,visited))\n                r1,c1,r2,c2 =x+1,y,x+1,y+1\n                if(r1,c1,r2,c2) in dic: mn = min(mn, 1 + dic[(r1,c1,r2,c2)])\n                elif inB(r1,c1) and inB(r2,c2) and grid[r1][c1]==0 and grid[r2][c2]==0 and (r1,c1,r2,c2) not in visited:\n                    mn = min(mn, 1 + dfs(r1,c1,r2,c2,visited))\n                r1,c1,r2,c2 = x,y,x+1,y\n                if(r1,c1,r2,c2) in dic: mn = min(mn, 1 + dic[(r1,c1,r2,c2)])\n                elif inB(r1,c1) and inB(r2,c2) and grid[r2][c2]==0 and grid[r2][c2+1]==0  and (r1,c1,r2,c2) not in visited:\n                    mn = min(mn, 1 + dfs(r1,c1,r2,c2,visited))\n            else:\n                r1,c1,r2,c2 = x+1,y,x+2,y\n                if(r1,c1,r2,c2) in dic: mn = min(mn, 1 + dic[(r1,c1,r2,c2)])\n                elif inB(r1,c1) and inB(r2,c2) and grid[r2][c2]==0 and (r1,c1,r2,c2) not in visited:\n                    mn = min(mn, 1 + dfs(r1,c1,r2,c2,visited))\n                r1,c1,r2,c2 = x,y+1,x+1,y+1\n                if(r1,c1,r2,c2) in dic: mn = min(mn, 1 + dic[(r1,c1,r2,c2)])\n                elif inB(r1,c1) and inB(r2,c2) and grid[r1][c1]==0 and grid[r2][c2]==0 and (r1,c1,r2,c2) not in visited:\n                    mn = min(mn, 1 + dfs(r1,c1,r2,c2,visited))\n                r1,c1,r2,c2 = x,y,x,y+1\n                if(r1,c1,r2,c2) in dic: mn = min(mn, 1 + dic[(r1,c1,r2,c2)])\n                elif inB(r1,c1) and inB(r2,c2) and grid[r2+1][c2]==0 and grid[r2][c2]==0 and (r1,c1,r2,c2) not in visited:\n                    mn = min(mn, 1 + dfs(r1,c1,r2,c2,visited))\n            dic[(x1,y1,x2,y2)] = mn\n            return mn\n                                          \n        \n        d =  dfs(0,0,0,1,set())\n        return d if d != float('inf') else -1\n                \n                    \n                \n", "class Solution:\n    def minimumMoves(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n = len(grid)\n        if grid[-1][-1] == 1:\n            return -1\n        dp = [[[float('inf'), float('inf')] for i in range(n)] for j in range(n)]\n        dp[0][0][0] = 0\n        for j in range(1, n - 1):\n            if grid[0][j + 1] == 0:\n                dp[0][j][0] = dp[0][j - 1][0] + 1\n            else:\n                break\n        for i in range(n):\n            for j in range(n):\n                if j < n - 1 and grid[i][j + 1] == 0 and grid[i][j] == 0:\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\n                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1)\n                if i < n - 1 and grid[i + 1][j] == 0 and grid[i][j] == 0:\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\n                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\n                if i < n - 1 and j < n - 1 and grid[i][j] == 0 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float('inf') else -1\n\n\n# class Solution:\n#     def minimumMoves(self, grid: List[List[int]]) -> int:\n#         n = len(grid)\n#         num_steps_horizontal = [[float('inf') for _ in range(n)] for _ in range(n)]\n#         num_steps_vertical = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n#         if not (grid[0][0] == grid[0][1] == 0):\n#             raise ValueError\n\n#         # initialization\n#         num_steps_horizontal[0][0] = 0\n#         for col in range(1, n - 1):\n#             if grid[0][col] == 0:\n#                 num_steps_horizontal[0][col] = 1 + num_steps_horizontal[0][col - 1]\n#             else:\n#                 break\n\n#         if grid[1][0] == grid[1][1] == 0:\n#             num_steps_vertical[0][0] = 1\n#             for row in range(1, n):\n#                 if grid[row][0] == 0:\n#                     num_steps_vertical[row][0] = 1 + num_steps_vertical[row - 1][0]\n#                 else:\n#                     break\n\n#         # iterate over num_steps_horizontal and num_steps_vertical\n#         for row in range(1, n):\n#             for col in range(1, n):\n#                 if col < n - 1 and grid[row][col] == grid[row][col + 1] == 0:\n#                     num_steps_horizontal[row][col] = 1 + min(\n#                         num_steps_horizontal[row][col - 1], # from left \n#                         num_steps_horizontal[row - 1][col], # from above\n#                         )\n#                 if row < n - 1 and grid[row][col] == grid[row + 1][col] == 0:\n#                     num_steps_vertical[row][col] = 1 + min(\n#                         num_steps_vertical[row][col - 1], # from left \n#                         num_steps_vertical[row - 1][col], # from above\n#                         )\n#                 if (col < n - 1 and row < n - 1\n#                    and grid[row][col] == grid[row][col + 1] == 0\n#                    and grid[row + 1][col] == grid[row + 1][col + 1] == 0):\n#                     num_steps_horizontal[row][col] = min(num_steps_horizontal[row][col], 1 + num_steps_vertical[row][col])\n#                     num_steps_vertical[row][col] = min(num_steps_vertical[row][col], 1 + num_steps_horizontal[row][col])\n                    \n#         # print(num_steps_horizontal)\n#         print(num_steps_vertical)\n        \n#         if num_steps_horizontal[-1][-2] < float('inf'):\n#             return num_steps_horizontal[-1][-2]\n#         else:\n#             return -1", "class Solution:\n    def minimumMoves(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n = len(grid)\n        if grid[-1][-1] == 1:\n            return -1\n        dp = [[[float('inf'), float('inf')] for i in range(n)] for j in range(n)]\n        dp[0][0][0] = 0\n        for j in range(1, n - 1):\n            if grid[0][j + 1] == 0:\n                dp[0][j][0] = dp[0][j - 1][0] + 1\n            else:\n                break\n        \n        if grid[1][0] == grid[1][1] == 0:\n            for i in range(1, n - 1):\n                if grid[i][0] == 0:\n                    dp[i][0][1] = dp[i - 1][0][1] + 1\n                else:\n                    break\n\n        \n        for i in range(n):\n            for j in range(n):\n                if j < n - 1 and grid[i][j + 1] == 0 and grid[i][j] == 0:\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\n                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1)\n                if i < n - 1 and grid[i + 1][j] == 0 and grid[i][j] == 0:\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\n                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\n                if i < n - 1 and j < n - 1 and grid[i][j] == 0 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float('inf') else -1\n\n\n# class Solution:\n#     def minimumMoves(self, grid: List[List[int]]) -> int:\n#         n = len(grid)\n#         num_steps_horizontal = [[float('inf') for _ in range(n)] for _ in range(n)]\n#         num_steps_vertical = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n#         if not (grid[0][0] == grid[0][1] == 0):\n#             raise ValueError\n\n#         # initialization\n#         num_steps_horizontal[0][0] = 0\n#         for col in range(1, n - 1):\n#             if grid[0][col] == 0:\n#                 num_steps_horizontal[0][col] = 1 + num_steps_horizontal[0][col - 1]\n#             else:\n#                 break\n\n#         if grid[1][0] == grid[1][1] == 0:\n#             num_steps_vertical[0][0] = 1\n#             for row in range(1, n):\n#                 if grid[row][0] == 0:\n#                     num_steps_vertical[row][0] = 1 + num_steps_vertical[row - 1][0]\n#                 else:\n#                     break\n\n#         # iterate over num_steps_horizontal and num_steps_vertical\n#         for row in range(1, n):\n#             for col in range(1, n):\n#                 if col < n - 1 and grid[row][col] == grid[row][col + 1] == 0:\n#                     num_steps_horizontal[row][col] = 1 + min(\n#                         num_steps_horizontal[row][col - 1], # from left \n#                         num_steps_horizontal[row - 1][col], # from above\n#                         )\n#                 if row < n - 1 and grid[row][col] == grid[row + 1][col] == 0:\n#                     num_steps_vertical[row][col] = 1 + min(\n#                         num_steps_vertical[row][col - 1], # from left \n#                         num_steps_vertical[row - 1][col], # from above\n#                         )\n#                 if (col < n - 1 and row < n - 1\n#                    and grid[row][col] == grid[row][col + 1] == 0\n#                    and grid[row + 1][col] == grid[row + 1][col + 1] == 0):\n#                     num_steps_horizontal[row][col] = min(num_steps_horizontal[row][col], 1 + num_steps_vertical[row][col])\n#                     num_steps_vertical[row][col] = min(num_steps_vertical[row][col], 1 + num_steps_horizontal[row][col])\n                    \n#         # print(num_steps_horizontal)\n#         print(num_steps_vertical)\n        \n#         if num_steps_horizontal[-1][-2] < float('inf'):\n#             return num_steps_horizontal[-1][-2]\n#         else:\n#             return -1", "class Solution:\n    def minimumMoves(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n = len(grid)\n        if grid[-1][-1] == 1:\n            return -1\n        dp = [[[float('inf'), float('inf')] for i in range(n)] for j in range(n)]\n        dp[0][0][0] = 0\n        for j in range(1, n - 1):\n            if grid[0][j + 1] == 0:\n                dp[0][j][0] = dp[0][j - 1][0] + 1\n            else:\n                break\n        \n        if grid[1][0] == grid[1][1] == 0:\n            for i in range(1, n - 1):\n                if grid[i + 1][0] == 0:\n                    dp[i][0][1] = dp[i - 1][0][1] + 1\n                else:\n                    break\n\n        \n        for i in range(n):\n            for j in range(n):\n                if j < n - 1 and grid[i][j + 1] == 0 and grid[i][j] == 0:\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\n                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1)\n                if i < n - 1 and grid[i + 1][j] == 0 and grid[i][j] == 0:\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\n                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\n                if i < n - 1 and j < n - 1 and grid[i][j] == 0 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float('inf') else -1\n\n\n# class Solution:\n#     def minimumMoves(self, grid: List[List[int]]) -> int:\n#         n = len(grid)\n#         num_steps_horizontal = [[float('inf') for _ in range(n)] for _ in range(n)]\n#         num_steps_vertical = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n#         if not (grid[0][0] == grid[0][1] == 0):\n#             raise ValueError\n\n#         # initialization\n#         num_steps_horizontal[0][0] = 0\n#         for col in range(1, n - 1):\n#             if grid[0][col] == 0:\n#                 num_steps_horizontal[0][col] = 1 + num_steps_horizontal[0][col - 1]\n#             else:\n#                 break\n\n#         if grid[1][0] == grid[1][1] == 0:\n#             num_steps_vertical[0][0] = 1\n#             for row in range(1, n):\n#                 if grid[row][0] == 0:\n#                     num_steps_vertical[row][0] = 1 + num_steps_vertical[row - 1][0]\n#                 else:\n#                     break\n\n#         # iterate over num_steps_horizontal and num_steps_vertical\n#         for row in range(1, n):\n#             for col in range(1, n):\n#                 if col < n - 1 and grid[row][col] == grid[row][col + 1] == 0:\n#                     num_steps_horizontal[row][col] = 1 + min(\n#                         num_steps_horizontal[row][col - 1], # from left \n#                         num_steps_horizontal[row - 1][col], # from above\n#                         )\n#                 if row < n - 1 and grid[row][col] == grid[row + 1][col] == 0:\n#                     num_steps_vertical[row][col] = 1 + min(\n#                         num_steps_vertical[row][col - 1], # from left \n#                         num_steps_vertical[row - 1][col], # from above\n#                         )\n#                 if (col < n - 1 and row < n - 1\n#                    and grid[row][col] == grid[row][col + 1] == 0\n#                    and grid[row + 1][col] == grid[row + 1][col + 1] == 0):\n#                     num_steps_horizontal[row][col] = min(num_steps_horizontal[row][col], 1 + num_steps_vertical[row][col])\n#                     num_steps_vertical[row][col] = min(num_steps_vertical[row][col], 1 + num_steps_horizontal[row][col])\n                    \n#         # print(num_steps_horizontal)\n#         print(num_steps_vertical)\n        \n#         if num_steps_horizontal[-1][-2] < float('inf'):\n#             return num_steps_horizontal[-1][-2]\n#         else:\n#             return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        '''\n        BFS\n        Time: O(n^2)\n        Space: O(n)\n        '''\n        n = len(grid)\n        start = (0, 0, 0)\n        end = (n-1, n-2, 0)\n        queue = {start}\n        seen = set()\n        steps = 0\n        while queue:\n            newQueue = set()\n            for i, j, d in queue:\n                if (i, j, d) == end: return steps\n                seen.add((i, j, d))\n                if d == 0:\n                    if j + 2 < n and not grid[i][j+2]:\n                        if (i, j+1, 0) not in seen: newQueue.add((i, j+1, 0))\n                    if i + 1 < n and not grid[i+1][j] and not grid[i+1][j+1]:\n                        if (i+1, j, 0) not in seen: newQueue.add((i+1, j, 0))\n                        if (i, j, 1) not in seen: newQueue.add((i, j, 1))\n                else:\n                    if i + 2 < n and not grid[i+2][j]:\n                        if (i+1, j, 1) not in seen: newQueue.add((i+1, j, 1))\n                    if j + 1 < n and not grid[i][j+1] and not grid[i+1][j+1]:\n                        if (i, j+1, 1) not in seen: newQueue.add((i, j+1, 1))\n                        if (i, j, 0) not in seen: newQueue.add((i, j, 0))\n\n            queue = newQueue\n            steps += 1\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        if not grid[n - 1][n - 2] == grid[n - 1][n - 1] == 0:\n            return -1\n        \n        locs = set([(0, 0, 'h'), ]) #(i, j, alignment, just rotated)\n        visited = set(locs)\n        time = 0\n        while locs and (n-1, n-2, 'h') not in locs and (n-1, n-2, 'h') not in locs:\n            time += 1\n            new_locs = set()\n            for i, j, align in locs:\n                # move right\n                if align == 'h' and j + 2 < n and (i, j+1, 'h') not in visited and not grid[i][j+2]:\n                    new_locs.add((i, j + 1, 'h'))\n                if align == 'v' and j + 1 < n and (i, j+1, 'v') not in visited and not grid[i][j+1] and not grid[i+1][j+1]:\n                    new_locs.add((i, j + 1, 'v'))\n                # move down\n                if align == 'h' and i + 1 < n and (i+1, j, 'h') not in visited and not grid[i+1][j] and not grid[i+1][j+1]:\n                    new_locs.add((i+1, j, 'h'))\n                if align == 'v' and i + 2 < n and (i+1, j, 'v') not in visited and not grid[i+2][j]:\n                    new_locs.add((i+1, j, 'v'))\n                # hor -> vert\n                if align == 'h' and i + 1 < n and (i, j, 'v') not in visited and not grid[i+1][j] and not grid[i+1][j+1]:\n                    new_locs.add((i, j, 'v'))\n                # vert -> hor\n                if align == 'v' and j + 1 < n and (i, j, 'h') not in visited and not grid[i][j+1] and not grid[i+1][j+1]:\n                    new_locs.add((i, j, 'h'))\n            locs = set(new_locs)\n            visited |= locs\n            \n        if (n-1, n-2, 'h') in locs or (n-1, n-2, 'h') in locs:\n            return time\n        \n        else:\n            return -1\n", "class Solution:\n    def minimumMoves(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n = len(grid)\n        if grid[-1][-1] == 1:\n            return -1\n        dp = [[[float('inf'), float('inf')] for i in range(n)] for j in range(n)]\n        dp[0][0][0] = 0\n        for j in range(1, n - 1):\n            if grid[0][j + 1] == 0:\n                dp[0][j][0] = dp[0][j - 1][0] + 1\n            else:\n                break\n        for i in range(n):\n            for j in range(n):\n                if j < n - 1 and grid[i][j + 1] == 0:\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\n                    if grid[i][j] == 0:\n                        dp[i][j][0] = min(dp[i][j][0],dp[i - 1][j][0] + 1)\n                if i < n - 1 and grid[i + 1][j] == 0:\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\n                    if grid[i][j] == 0:\n                        dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\n                if i < n - 1 and j < n - 1 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float('inf') else -1\n\n\n# class Solution:\n#     def minimumMoves(self, grid: List[List[int]]) -> int:\n#         n = len(grid)\n#         num_steps_horizontal = [[float('inf') for _ in range(n)] for _ in range(n)]\n#         num_steps_vertical = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n#         if not (grid[0][0] == grid[0][1] == 0):\n#             raise ValueError\n\n#         # initialization\n#         num_steps_horizontal[0][0] = 0\n#         for col in range(1, n - 1):\n#             if grid[0][col] == 0:\n#                 num_steps_horizontal[0][col] = 1 + num_steps_horizontal[0][col - 1]\n#             else:\n#                 break\n\n#         if grid[1][0] == grid[1][1] == 0:\n#             num_steps_vertical[0][0] = 1\n#             for row in range(1, n):\n#                 if grid[row][0] == 0:\n#                     num_steps_vertical[row][0] = 1 + num_steps_vertical[row - 1][0]\n#                 else:\n#                     break\n\n#         # iterate over num_steps_horizontal and num_steps_vertical\n#         for row in range(1, n):\n#             for col in range(1, n):\n#                 if col < n - 1 and grid[row][col] == grid[row][col + 1] == 0:\n#                     num_steps_horizontal[row][col] = 1 + min(\n#                         num_steps_horizontal[row][col - 1], # from left \n#                         num_steps_horizontal[row - 1][col], # from above\n#                         )\n#                 if row < n - 1 and grid[row][col] == grid[row + 1][col] == 0:\n#                     num_steps_vertical[row][col] = 1 + min(\n#                         num_steps_vertical[row][col - 1], # from left \n#                         num_steps_vertical[row - 1][col], # from above\n#                         )\n#                 if (col < n - 1 and row < n - 1\n#                    and grid[row][col] == grid[row][col + 1] == 0\n#                    and grid[row][col] == grid[row + 1][col] == 0):\n#                     num_steps_horizontal[row][col] = min(num_steps_horizontal[row][col], 1 + num_steps_vertical[row][col])\n#                     num_steps_vertical[row][col] = min(num_steps_vertical[row][col], 1 + num_steps_horizontal[row][col])\n                    \n#         if num_steps_horizontal[-1][-2] < float('inf'):\n#             return num_steps_horizontal[-1][-2]\n#         else:\n#             return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        # BFS\n        orientation = 'h' # horizontal\n        head, tail = (0, 1), (0, 0)\n        q = collections.deque()\n        q.append((head, tail, orientation))\n        visited = set()\n        visited.add((head, tail, orientation))\n        moves = 0\n        n = len(grid)\n        target_head, target_tail = (n-1, n-1), (n-1, n-2)\n        \n        while q:\n            for _ in range(len(q)):\n                head, tail, orientation = q.popleft()\n                if head == target_head and tail == target_tail:\n                    return moves\n                head_x, head_y = head\n                tail_x, tail_y = tail\n                if orientation == 'h':\n                    # move right\n                    if head_y + 1 < n and grid[head_x][head_y + 1] == 0:\n                        node = ((head_x, head_y + 1), head, orientation)\n                        if node not in visited:\n                            q.append(node)\n                            visited.add(node)\n                    # move down\n                    if head_x + 1 < n and grid[head_x + 1][head_y] == 0 and grid[tail_x + 1][tail_y] == 0:\n                        node = ((head_x + 1, head_y), (tail_x + 1, tail_y), orientation)\n                        if node not in visited:\n                            q.append(node)\n                            visited.add(node)\n                    # rotate clockwise\n                    if head_x + 1 < n and grid[head_x + 1][head_y] == 0 and grid[head_x + 1][tail_y] == 0:\n                        node = ((tail_x + 1, tail_y), tail, 'v')\n                        if node not in visited:\n                            q.append(node)\n                            visited.add(node)\n                        \n                else:\n                    # move right\n                    if head_y + 1 < n and grid[head_x][head_y + 1] == 0 and grid[tail_x][tail_y + 1] == 0:\n                        node = ((head_x, head_y + 1), (tail_x, tail_y + 1), 'v')\n                        if node not in visited:\n                            q.append(node)\n                            visited.add(node)\n                    # move down\n                    if head_x + 1 < n and grid[head_x + 1][head_y] == 0:\n                        node = ((head_x + 1, head_y), head, 'v')\n                        if node not in visited:\n                            q.append(node)\n                            visited.add(node)\n                    # rotate counter-clockwise\n                    if head_y + 1 < n and grid[head_x][head_y + 1] == 0 and grid[tail_x][tail_y + 1] == 0:\n                        node = ((tail_x, tail_y + 1), tail, 'h')\n                        if node not in visited:\n                            q.append(node)\n                            visited.add(node)\n            moves += 1\n            \n        return -1\n", "class Solution:\n    def bfs(self, M: List[List[List[int]]]) -> int:\n        Q = deque()\n        visited = set()\n        Q.append((0, 0, 0, 0))\n        visited.add((0, 0, 0))\n        while(len(Q) != 0):\n            k, i, j, depth = Q.popleft()\n            if(depth > 25):\n                print(k, i, j, depth)\n            if((k, i, j) == (0, self.m-1, self.n-2)):\n                return depth\n            if(j+1 < len(M[k][i]) and (k, i, j+1) not in visited and M[k][i][j+1] == 0):\n                Q.append((k, i, j+1, depth + 1))\n                visited.add((k, i, j+1))\n            if(i+1 < len(M[k]) and (k, i+1, j) not in visited and M[k][i+1][j] == 0):\n                Q.append((k, i+1, j, depth + 1))\n                visited.add((k, i+1, j))\n            if(i+1 < self.n and j+1 < self.m and (k^1, i, j) not in visited and M[2][i][j] == 0):\n                Q.append((k^1, i, j, depth + 1))\n                visited.add((k^1, i, j))\n        return -1\n    \n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        self.m = len(grid)\n        self.n = len(grid[0])\n        M = [[[0] * (self.n-1) for i in range(self.m)], [[0] * (self.n) for i in range(self.m - 1)], [[0] * (self.n - 1) for i in range(self.m - 1)]]\n        for i in range(self.m):\n            for j in range(self.n):\n                if(j+1 < self.n):\n                    M[0][i][j] = (grid[i][j] | grid[i][j+1])\n                if(i+1 < self.m):\n                    M[1][i][j] = (grid[i][j] | grid[i+1][j])\n                if(i+1 < self.m and j+1 < self.n):\n                    M[2][i][j] = (grid[i][j] | grid[i+1][j] | grid[i][j+1] | grid[i+1][j+1])\n        return self.bfs(M)", "from collections import deque\n\nclass Solution:    \n    dx = [1, 0]\n    dy = [0, 1]\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        visit = set()\n        q = deque()\n        n = len(grid)\n        answer = float('inf')\n        #x1, y1, x2, y2, is_horizon, time\n        #   is_horozon = 1 : \uac00\ub85c\n        #   is_horizon = 0 : \uc138\ub85c\n        init_pos = [0, 0, 0, 1, 1, 0]\n        q.append(init_pos)\n        \n        while q:\n            x1, y1, x2, y2, is_horizon, cost = q.popleft()\n            if cost>=20:\n                print((x1,y1,x2,y2, is_horizon, cost))\n            \n            if is_horizon and x1==n-1 and x2==n-1 and y2==n-1 and y1==n-2:\n                answer = min(answer, cost)\n            \n            visit.add(((x1, y1), (x2, y2)))\n            \n            for i in range(2):\n                nx1 = x1 + self.dx[i]\n                ny1 = y1 + self.dy[i]\n                nx2 = x2 + self.dx[i]\n                ny2 = y2 + self.dy[i]\n                \n                if 0<=nx1<n and 0<=ny1<n and 0<=nx2<n and 0<=ny2<n and grid[nx1][ny1]==0 and grid[nx2][ny2]==0:\n                    if ((nx1, ny1),(nx2, ny2)) not in visit:\n                        nxt_hrizon = 1 if nx1==nx2 else 0\n                        visit.add(((nx1, ny1),(nx2, ny2)))\n                        q.append([nx1, ny1, nx2, ny2, nxt_hrizon, cost+1])\n            #rotataion\n            if is_horizon:\n                if x1 < n-1 and grid[x1+1][y1]==0 and grid[x2+1][y2]==0:\n                #clockwise\n                    if ((x1, y1), (x2+1, y2-1)) not in visit:\n                        visit.add(((x1, y1), (x2+1, y2-1)))\n                        q.append([x1, y1, x2+1, y2-1, 0, cost+1])\n                \n            else:\n                #counterclockwise\n                if y1 < n-1 and grid[x1][y1+1]==0 and grid[x2][y2+1]==0:\n                    if ((x1, y1), (x2-1, y2+1)) not in visit:\n                        visit.add(((x1, y1), (x2-1, y2+1)))\n                        q.append([x1, y1, x2-1, y2+1, 1, cost+1])\n        # print(answer)\n        if answer!=float('inf'):\n            return answer\n        else:\n            return -1\n                    \n", "from collections import deque\n\nclass Solution:    \n    dx = [1, 0]\n    dy = [0, 1]\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        visit = set()\n        q = deque()\n        n = len(grid)\n        answer = float('inf')\n        #x1, y1, x2, y2, is_horizon, time\n        #   is_horozon = 1 : \uac00\ub85c\n        #   is_horizon = 0 : \uc138\ub85c\n        init_pos = [0, 0, 0, 1, 1, 0]\n        q.append(init_pos)\n        \n        while q:\n            x1, y1, x2, y2, is_horizon, cost = q.popleft()\n            if cost>=20:\n                print((x1,y1,x2,y2, is_horizon, cost))\n            \n            if is_horizon and x1==n-1 and x2==n-1 and y2==n-1 and y1==n-2:\n                answer = min(answer, cost)\n            \n            visit.add(((x1, y1), (x2, y2)))\n            \n            for i in range(2):\n                nx1 = x1 + self.dx[i]\n                ny1 = y1 + self.dy[i]\n                nx2 = x2 + self.dx[i]\n                ny2 = y2 + self.dy[i]\n                \n                if 0<=nx1<n and 0<=ny1<n and 0<=nx2<n and 0<=ny2<n and grid[nx1][ny1]==0 and grid[nx2][ny2]==0:\n                    if ((nx1, ny1),(nx2, ny2)) not in visit:\n                        nxt_hrizon = 1 if nx1==nx2 else 0\n                        visit.add(((nx1, ny1),(nx2, ny2)))\n                        q.append([nx1, ny1, nx2, ny2, nxt_hrizon, cost+1])\n            #rotataion\n            if is_horizon:\n                if x1 < n-1 and grid[x1+1][y1]==0 and grid[x2+1][y2]==0:\n                #clockwise\n                    if ((x1, y1), (x2+1, y2-1)) not in visit:\n                        visit.add(((x1, y1), (x2+1, y2-1)))\n                        q.append([x1, y1, x2+1, y2-1, 0, cost+1])\n                \n            else:\n                #counterclockwise\n                if y1 < n-1 and grid[x1][y1+1]==0 and grid[x2][y2+1]==0:\n                    if ((x1, y1), (x2-1, y2+1)) not in visit:\n                        visit.add(((x1, y1), (x2-1, y2+1)))\n                        q.append([x1, y1, x2-1, y2+1, 1, cost+1])\n                        \n        return answer if answer!=float('inf') else -1\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        m = n = len(grid)\n        visited = {(1, 0)}\n        q = collections.deque([(1, 0)])\n        moves = 0\n        while q:\n            for _ in range(len(q)):\n                h, t = q.popleft()\n                ti, tj = divmod(t, n)\n                hi, hj = divmod(h, n)\n                if hi == n - 1 and hj == n - 1 and ti == n - 1:\n                    return moves\n                for di, dj in [[0, 1], [1, 0]]:\n                    hii = hi + di\n                    hjj = hj + dj\n                    tii = ti + di\n                    tjj = tj + dj\n                    if hii < n and hjj < n and tii < n and tjj < n and grid[hii][hjj] != 1 and grid[tii][tjj] != 1:\n                        next = (hii * n + hjj, tii * n + tjj)\n                        if hii == hjj == tii == n - 1:\n                            return moves + 1\n                        if next not in visited:\n                            q.append(next)\n                            visited.add(next)\n                        if di == 1 and hi == ti:\n                            next = (h + n - 1, t)\n                            if next not in visited:\n                                q.append(next)\n                                visited.add(next)\n                        if dj == 1 and hj == tj:\n                            next = (h - n + 1, t)\n                            if next not in visited:\n                                q.append(next)\n                                visited.add(next)\n            moves += 1\n        return -1\n", "\\\"\\\"\\\"\nDP bottom up time O(m*n) space O(m*n)\n\\\"\\\"\\\"\n\nclass Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        snake tail originally at grid[0][0]\n        mm[i][j][0] := steps to get to grid[i][j] in horizontal position\n        mm[i][j][1] := steps to get to grid[i][j] in vertical position\n        \\\"\\\"\\\"\n        if len(grid) == 0: return 0  # no dungeon\n        elif len(grid) == 1 and len(grid[0]) == 2: return 0\n\n        n = len(grid)  # number of rows\n        m = len(grid[0]) # number of columns\n        mm = [[[math.inf, math.inf] for _ in range(m+1)] for _ in range(n+1)]\n       \n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                ig = i-1\n                jg = j-1\n                if i==1 and j==1:\n                    mm[1][1][0] = 0 # initial tail position\n                else:\n                    # move from up or left\n                    if j<m and grid[ig][jg]==0 and grid[ig][jg+1]==0:\n                        mm[i][j][0] = min(mm[i][j-1][0], mm[i-1][j][0])+1\n                    # move from up or left\n                    if i<n and grid[ig][jg]==0 and grid[ig+1][jg]==0:\n                        mm[i][j][1] = min(mm[i][j-1][1], mm[i-1][j][1])+1\n                # rotate\n                if j<m and i<n and grid[ig][jg]==0 and grid[ig][jg+1]==0 and grid[ig+1][jg]==0 and grid[ig+1][jg+1]==0:\n                    mm[i][j][0] = min(mm[i][j][0], mm[i][j][1]+1)\n                    mm[i][j][1] = min(mm[i][j][1], mm[i][j][0]+1)\n        if mm[n][m-1][0]==math.inf:\n            return -1\n        return mm[n][m-1][0]\n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        \n        n = len(grid)\n        q = collections.deque()\n        q.append((0,0,0,0))\n        visited = set()\n        \n        while q:\n            r, c, direction, steps = q.popleft()\n            \n            if (r,c,direction) == (n-1, n-2, 0):\n                return steps\n            if (r,c, direction) not in visited:\n                visited.add((r,c, direction))\n                if direction:\n                    if c + 1 < n and grid[r][c + 1] + grid[r + 1][c + 1] == 0:\n                        q.append((r, c + 1, 1, steps + 1))\n                        q.append((r, c, 0, steps + 1))\n                    if r + 2 < n and grid[r + 2][c] == 0:\n                        q.append((r + 1, c, 1, steps + 1)) \n                else:\n                    if r + 1 < n and grid[r + 1][c] + grid[r + 1][c + 1] == 0:\n                        q.append((r + 1, c, 0, steps + 1))\n                        q.append((r, c, 1, steps + 1))\n\n                    if c + 2 < n and grid[r][c + 2] == 0: \n                        q.append((r, c + 1, 0, steps + 1))\n\n        return -1\n                    \n                \n                \n", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        '''\n        \u6700\u77ed\u6b65\u6570\uff0c\u5229\u7528BFS\u3002\u6709\u56db\u79cd\u79fb\u52a8\u65b9\u5f0f\n        \u5411\u53f3\uff0c\u5411\u4e0b\uff0c\u6c34\u5e73\u7ad6\u76f4\n        '''\n        n = len(grid)\n        q=[(0,0,0,1)]\n        moves = 0\n        visited = set([(0,0,0,1)])\n        while q:\n            size=len(q)\n            for _ in range(size):\n                x1,y1,x2,y2=q.pop(0)\n                if x1==n-1 and y1==n-2 and x2==n-1 and y2==n-1:\n                    return moves\n                #\u5411\u53f3\u79fb\u52a8\n                if y1+1<n and grid[x1][y1+1]==0 and y2+1<n and grid[x2][y2+1] == 0:\n                    if (x1,y1+1,x2,y2+1) not in visited:\n                        visited.add((x1,y1+1,x2,y2+1))\n                        q.append((x1,y1+1,x2,y2+1))\n                #\u5411\u4e0b\u79fb\u52a8\n                if x1+1<n and grid[x1+1][y1]==0 and x2+1<n and grid[x2+1][y2]==0:\n                    if ((x1+1,y1,x2+1,y2)) not in visited:\n                        visited.add((x1+1,y1,x2+1,y2))\n                        q.append((x1+1,y1,x2+1,y2))\n                #\u6c34\u5e73\u53d8\u7ad6\u76f4\n                if x1==x2 and y2==y1+1 and x1+1<n and grid[x1+1][y1]+grid[x1+1][y1+1]==0:\n                    if (x1,y1,x1+1,y1) not in visited:\n                        visited.add((x1,y1,x1+1,y1))\n                        q.append((x1,y1,x1+1,y1))\n                #\u7ad6\u76f4\u53d8\u6c34\u5e73\n                if y1==y2 and x2==x1+1 and y1+1<n and grid[x1][y1+1]+grid[x1+1][y1+1] == 0: \n                    if (x1,y1,x1,y1+1) not in visited:\n                        visited.add((x1,y1,x1,y1+1))\n                        q.append((x1,y1,x1,y1+1))\n            \n            moves += 1\n        return -1", "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        \n        \n        queue = deque()\n        \n        queue.append([0,0,0,0])\n        \n        visited = {(0,0,0):1}\n        n = len(grid)\n        \n        while(len(queue) >0):\n            \n            x, y, dic, step = queue.popleft()\n            #print(x, y, dic, step)\n            if x == n-1 and y == n-2 and dic == 0:\n                return step\n            \n            if dic == 0:\n                nx, ny = x, y+1\n                if nx >=0 and nx < n and ny >=0 and ny+1 < n:\n                    if grid[nx][ny+1] == 0 and (nx, ny, 0) not in visited:\n                        queue.append([nx, ny, 0, step + 1])\n                        visited[(nx, ny, 0)] =1\n            \n                nx, ny = x, y\n                checkx1, checky1 = x+1, y\n                checkx, checky = x+1, y+1\n                if checkx1 >=0 and checkx1 < n and checky1 >=0 and checky1 < n:\n                    if checkx >=0 and checkx < n and checky >=0 and checky < n:\n                        if grid[checkx1][checky1] == 0 and grid[checkx][checky] == 0 and(nx, ny, 1) not in visited:\n                            queue.append([nx, ny, 1, step + 1])\n                            visited[(nx, ny, 1)] =1  \n \n                        if grid[checkx1][checky1] == 0 and grid[checkx][checky] == 0 and(checkx1, checky1, 0) not in visited:\n                            queue.append([checkx1, checky1, 0, step + 1])\n                            visited[(checkx1, checky1, 0)] =1  \n\n            if dic == 1:\n                nx, ny = x+1, y\n                if nx >=0 and nx+1 < n and ny >=0 and ny < n:\n                    if grid[nx+1][ny] == 0 and (nx, ny, 1) not in visited:\n                        queue.append([nx, ny, 1, step + 1])\n                        visited[(nx, ny, 1)] =1\n            \n                nx, ny = x, y\n                checkx1, checky1 = x, y+1\n                checkx, checky = x+1, y+1\n                if checkx1 >=0 and checkx1 < n and checky1 >=0 and checky1 < n:\n                    if checkx >=0 and checkx < n and checky >=0 and checky < n:\n                        if grid[checkx1][checky1] == 0 and grid[checkx][checky] == 0 and(nx, ny, 0) not in visited:\n                            queue.append([nx, ny, 0, step + 1])\n                            visited[(nx, ny, 0)] =1\n                            #print(x, y, nx, ny, checkx1, checky1, grid[checkx1][checky1], dic)\n                        if grid[checkx1][checky1] == 0 and grid[checkx][checky] == 0 and(x, y+1, 1) not in visited:\n                            queue.append([x, y+1, 1, step + 1])\n                            visited[(x, y+1, 1)] =1           \n        return -1"]
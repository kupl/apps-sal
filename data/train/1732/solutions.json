["from collections import defaultdict\nfrom functools import reduce\nimport re\n\nP_EQ = re.compile(\"(?P<eq>=)|(?P<coef>[+-]?\\d*)(?P<var>[a-zA-Z]*)\")\n\n\ndef solve(*equations):\n    \n    eqsMap = list(map(parse, equations))                         # Transform each string in a dict {'var': coef}\n    vars   = reduce(set.union, (set(e) for e in eqsMap))         # Extract all the variables\n    vars   = list(set(vars)-{''}) + ['']                         # Push the \"constants\" at the end of the list\n    \n    if len(vars)-1 > len(equations): return None                 # Not enough equations to solve the system\n    \n    m = [ [eqm[v] for v in vars] for eqm in eqsMap]              # Build the matrix\n    \n    return solveMatrix(m, vars)                                  # Solve using Gauss elimination\n    \n\ndef parse(eq):\n    rev, dct = 1, defaultdict(int)\n    for m in P_EQ.finditer(eq.replace(\" \",\"\")):\n        if m['eq']:\n            rev = -1\n        else:\n            gc, gv = m['coef'], m['var']\n            if gc or gv:\n                coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                dct[ m['var'] ] += coef * rev\n    return dct\n\n\ndef solveMatrix(m, vars):\n    \n    EPS    = 1e-10\n    pivots = {}                                                  # dict of the indexes of the pivots (avoid to have to move the raws)\n    toDo   = set(range(len(m)))                                  # set with the indexes of all the lines where the pivot will have to be sought for\n    \n    for y in range(len(vars)-1):                                 # \"-1\" to avoid the constants\n        \n        _,px = max( ((abs(m[x][y]),x) for x in toDo if abs(m[x][y]) > 0), default=(-1,-1))\n        \n        if px == -1: continue                                    # No pivot found\n        pivots[px] = y\n        toDo.remove(px)\n        \n        maxP, m[px][y] = m[px][y], 1\n        for j in range(y+1,len(vars)):                           # Update the line of the current pivot\n            m[px][j] /= maxP\n            if abs(m[px][j]) < EPS: m[px][j] = 0                 # Handle floating point errors\n        \n        for x in range(0,len(m)):                                # Update all the lines, doing the elimination\n            if x==px: continue                                   # Skip the line of the current pivot\n            \n            coef, m[x][y] = m[x][y], 0\n            for j in range(y+1,len(vars)):                       # Update the line of the current pivot\n                m[x][j] -= coef * m[px][j]\n                if abs(m[x][j]) < EPS: m[x][j] = 0               # Handle floating point errors, again...\n        \n    \n    solvedDct = {}\n    for x in range(len(m)):                                      # Build the solution dict\n        yP = pivots.get(x, None)\n        if yP is None: continue\n        \n        solvedDct[ vars[yP] ] = -m[x][-1]\n    \n    if len(solvedDct) == len(vars)-1: return solvedDct           # Valid only if all the variables have been used as pivots \n", "from fractions import Fraction\na=0\nvariable=[]\ndef solve(*equations):\n    \n    sq = [i for i in equations]\n    print(sq)\n    \n    def extract_number(s):\n        temp = ''\n        variable = ''\n        L=[]\n        for i in range(len(s)):\n            try:\n                if s[i] in ['+','-'] and temp=='':\n                    temp+=s[i];\n                    if variable!='':L.append(variable);variable=''\n                elif s[i] in ['+','-'] and temp!='':   #2x=2-4y\n                    L.append(temp);temp=s[i]\n                else:\n                    temp+=str(int(s[i]))\n            except:\n                if s[i] not in ['+','-','=']:variable+=s[i]\n                if len(L)==0 and temp=='':L.append('1')                      #x+5=9\n                elif temp in ['+','-']:\n                    L.append(temp+'1')                    #7+x=9\n                elif temp!='' and s[i]!='=':L.append(temp);                  #7x+8y=9\n                elif temp!='' and s[i]=='=':L.extend([temp,'='])             #7x+8=9\n                elif temp=='' and s[i]=='=':\n                    if variable!='': \n                        L.append(variable);variable=''\n                    L.extend(['='])\n                else:pass\n                temp=''\n    \n        if temp!='':L.append(temp)\n        if variable!='':L.append(variable)\n        return L\n    \n    def refine(raw_matrix):\n        refine_dict = dict({})\n        flag=0\n        num=0\n        refine_dict['constant']=0\n        for i in raw_matrix:\n            try:\n                if num!=0 and str(int(i))!='':refine_dict['constant']+=num\n                if flag==0:\n                    num=int(i)\n                else:\n                    num=-int(i)\n            except:\n                if i!='=':\n                    if i not in refine_dict.keys():\n                        refine_dict[i]=num\n                    else:\n                        refine_dict[i]+=num\n                    num=0\n                else:\n                    flag=1\n        if num!=0:\n            refine_dict['constant']+=num\n        else:\n            refine_dict['constant']+=0\n        return refine_dict\n    \n    def reduction(List_of_dict):\n        L=[]\n        max_number=0;max_dict=dict({})\n        for findout in range(len(List_of_dict)):\n            if len(List_of_dict[findout])>max_number:\n                max_number=len(List_of_dict[findout])\n                max_dict = List_of_dict[findout]\n        nonlocal variable\n        variable = [i for i in max_dict.keys()][::-1]\n        insert = 0\n        for i in List_of_dict:\n            keys_list=[m for m in i.keys()]\n            temp_list=[]\n            for j in variable:\n                try:\n                    temp_list.append(i[j])\n                    keys_list.remove(j)\n                except:\n                    temp_list.append(0)\n            for k in keys_list:\n                variable.insert(-1,k)\n                temp_list.append(i[k])\n            L.append(temp_list)          \n        \n        print(variable)\n        \n        for i in range(len(List_of_dict)):\n            if L[i][i]==0:\n                for j in range(i,len(List_of_dict)):\n                    if L[j][i]!=0:\n                        temp_list = L[i]\n                        L[i] = L[j]\n                        L[j] = temp_list\n                        break\n            a=L[i][i]\n            if i==len(variable)-1 and a==0:return L\n            if L[i][:i+1]==[0]*(i+1) and L[i][-1]!=0 :return None\n            if L[i]==[0]*(len(L[i])) and i<len(variable)-1:return None\n            L[i] = list(map(lambda x:Fraction(x,a),L[i]))\n            K = [num for num in range(len(List_of_dict))]\n            del K[i]\n            for j in K:\n                if i<len(variable)-1:\n                    L[j]=[L[j][index]-L[i][index]*Fraction(L[j][i],L[i][i]) for index in range(len(L[j]))]\n                else:\n                    if a!=0:\n                        return None\n        return L\n    \n    \n    def sol(equation):\n        L=[]\n        for s in equation:\n            L.append(refine(extract_number(s)))\n        Ans = reduction(L)\n        if Ans!=None:\n            show = dict({})\n            keys = [i for i in variable]\n            nonlocal a\n            a=len(keys)\n            for i in Ans:\n                for j in range(len(i)):\n                    if i[j]==1:\n                        show[keys[j]]=float(-i[-1])\n                        break\n            return show\n        else:\n            return None\n        \n\n    solution = sol(sq)        \n    \n    if len(variable)-1>len(sq):return None\n\n    return solution", "import copy\nimport re\n\n\nclass Fraction:\n\n    def __init__(self, numerator, denominator):\n        self.numerator = numerator\n        self.denominator = denominator\n        if not (isinstance(self.numerator, int) and isinstance(self.denominator, int)):\n            raise ValueError('Expecting integer values.')\n        if not self.denominator:\n            raise ValueError('Division by 0.')\n        self.reduce()\n\n    def reduce(self):\n        gcd = self._gcd(self.numerator, self.denominator)\n        self.numerator = self.numerator // gcd\n        self.denominator = self.denominator // gcd\n\n    def to_float(self):\n        return self.numerator / self.denominator\n\n    @classmethod\n    def to_fraction(cls, obj):\n        if isinstance(obj, int):\n            return Fraction(obj, 1)\n        elif isinstance(obj, float):\n            i, j = str(obj).split('.')\n            return Fraction(int(j) + int(i) * 10 ** len(j), 10 ** len(j))\n        else:\n            raise ValueError('Only int or float.')\n\n    @staticmethod\n    def _gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def _lcm(self, x, y):\n        return abs(x * y) // self._gcd(x, y)\n\n    def __add__(self, other):\n        lcm = self._lcm(self.denominator, other.denominator)\n        numerator = (self.numerator * (lcm // self.denominator)) + (other.numerator * (lcm // other.denominator))\n        return Fraction(numerator, lcm)\n\n    def __sub__(self, other):\n        lcm = self._lcm(self.denominator, other.denominator)\n        numerator = (self.numerator * (lcm // self.denominator)) - (other.numerator * (lcm // other.denominator))\n        return Fraction(numerator, lcm)\n\n    def __mul__(self, other):\n        return Fraction(self.numerator * other.numerator, self.denominator * other.denominator)\n\n    def __truediv__(self, other):\n        return Fraction(self.numerator * other.denominator, self.denominator * other.numerator)\n\n    def __bool__(self):\n        return self.numerator != 0\n\n    def __str__(self):\n        return str(self.numerator) + '/' + str(self.denominator)\n\n\nclass LinearEquation:\n\n    PATTERN = '[+-]?([0-9]+[a-zA-Z]*|[a-zA-Z]+)([+-]([0-9]+[a-zA-Z]*|[a-zA-Z]+))*'\n\n    def __init__(self, eq):\n        self.eq = eq.replace(' ', '')\n        if not self._validation():\n            raise ValueError('Expecting correct Equation.')\n\n    def _validation(self):\n        if re.match('^' + LinearEquation.PATTERN + '=' + LinearEquation.PATTERN + '$', self.eq):\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def _tokenize(string):\n        tokens = re.findall('[+-]?(?:[0-9]+[a-zA-Z]*|[a-zA-Z]+)', string)\n        values = dict()\n        for token in tokens:\n            value, var = re.findall('^([+-]?[0-9]*)([a-zA-Z]*)$', token)[0]\n            if not value or value == '+':\n                value = Fraction(1, 1)\n            elif value == '-':\n                value = Fraction(-1, 1)\n            else:\n                value = Fraction.to_fraction(float(value))\n            if var in list(values.keys()):\n                values[var] += value\n            elif value:\n                values[var] = value\n        return values\n\n    def parse(self):\n        left_side, right_side = self.eq.split('=')\n        values = self._tokenize(left_side)\n        for var, value in list(self._tokenize(right_side).items()):\n            value *= Fraction(-1, 1)\n            if var in list(values.keys()):\n                values[var] += value\n            else:\n                values[var] = value\n        if '' not in list(values.keys()):\n            values[''] = Fraction(0, 1)\n        return values\n\n\nclass LinearEquationSystem:\n\n    def __init__(self, m, x, b):\n        self.m = m\n        self.x = x\n        self.b = b\n        if not self._validate():\n            raise ValueError('Wrong arguments.')\n\n    def _validate(self):\n        if not isinstance(self.m, list) and not isinstance(self.x, list) and not isinstance(self.b, list):\n            return False\n        if not (len(self.m) == len(self.b)):\n            return False\n        for eq in self.m:\n            if not isinstance(eq, list) and len(eq) == len(self.x):\n                return False\n        return True\n\n    @staticmethod\n    def _rank(m):\n        rank = min(len(m[0]), len(m))\n        ind = min(len(m[0]), len(m))\n        for i in range(ind):\n            if m[i][i]:\n                for j in range(i + 1, len(m)):\n                    multiplier = m[j][i] / m[i][i]\n                    for k in range(i, len(m[0])):\n                        m[j][k] -= (multiplier * m[i][k])\n            else:\n                reduce = True\n                for j in range(i + 1, len(m)):\n                    if m[j][i]:\n                        reduce = False\n                        m[i], m[j] = m[j], m[i]\n                        break\n                if reduce:\n                    rank -= 1\n                else:\n                    for j in range(i + 1, len(m)):\n                        multiplier = m[j][i] / m[i][i]\n                        for k in range(i, len(m[0])):\n                            m[j][k] -= (multiplier * m[i][k])\n        return rank, m\n\n    def solve(self):\n        m = copy.deepcopy(self.m)\n        m_rank, _ = self._rank(m)\n        m_b = copy.deepcopy(self.m)\n        for i, row in enumerate(m_b):\n            row.append(self.b[i])\n        m_b_rank, m_b = self._rank(m_b)\n\n        if m_rank == m_b_rank and m_rank == len(self.x):\n            solutions = dict()\n            b = list()\n\n            for row in m_b:\n                b.append(Fraction(-1, 1) * row[-1])\n                del row[-1]\n            while len(m_b) > len(m_b[0]):\n                del m_b[-1]\n\n            for i in range(len(m_b))[::-1]:\n                multiplier = None\n                for j in range(len(m_b[i])):\n                    if j == i:\n                        multiplier = Fraction(1, 1) / m_b[i][i]\n                    elif m_b[i][j]:\n                        b[i] -= (m_b[i][j] * solutions[self.x[j]])\n                solutions[self.x[i]] = b[i] * multiplier\n\n            for var in solutions:\n                solutions[var] = solutions[var].to_float()\n\n            return solutions\n\n        else:\n            return None\n\ndef solve(*eqs):\n    print(eqs)\n    values_list = list()\n    variables = set()\n    coefficient_matrix = list()\n    b = list()\n    for i, eq in enumerate(eqs):\n        values_list.append(LinearEquation(eq).parse())\n        for var in list(values_list[i].keys()):\n            variables.add(var)\n        coefficient_matrix.append(list())\n    variables = sorted(list(variables))\n    for i in range(len(eqs)):\n        for var in variables:\n            if not var:\n                b.append(values_list[i][var])\n            elif var in list(values_list[i].keys()):\n                coefficient_matrix[i].append(values_list[i][var])\n            else:\n                coefficient_matrix[i].append(Fraction(0, 1))\n    system = LinearEquationSystem(m=coefficient_matrix, x=variables[1::], b=b)\n    return system.solve()\n", "import re\nfrom functools import reduce\n\n# Parsing ###################################################################\n\n# Returns a dictionary {k:v} where k is the variable (or None for constant),\n# and v is the value. This dictionary is in effect a singleton term set.\ndef parse_term(term, scale):\n    parts = re.findall('[+-]?\\d+|[+-]|[^\\d]+', term)\n    \n    if parts[0] in '+-': parts[0] += \"1\"\n    \n    if len(parts) == 2:\n        return { parts[1] : int(parts[0]) * scale }\n    elif len(parts) == 1:\n        try:\n            return { None : int(parts[0]) * scale }\n        except ValueError:\n            return { parts[0] : scale }\n    else:\n        raise Exception('assertion failed')\n\ndef combine_term_dicts(a, b):\n    common_keys = set(a.keys()).intersection(b.keys())\n    \n    common_terms = {k:a[k]+b[k] for k in common_keys}\n\n    unique_terms = lambda c: {k:v for k,v in c.items() if k not in common_keys}\n    \n    return {**common_terms, **unique_terms(a), **unique_terms(b)}\n\n# Parses the expression in a single side of an equation\n# Parameter 'scale' is 1 for left-hand side, and -1 for right-hand side.\ndef parse_side(side, scale):\n    no_ws = re.sub(' ', '', side)\n\n    # The following regex will always produce an empty match at the\n    # end of string, which we remove at the end.\n    term_str = re.findall(\"[+-]?\\d*[^\\d+-]*\", no_ws)[0:-1]\n\n    term_lst = [parse_term(t, scale) for t in term_str]\n    \n    return reduce(combine_term_dicts, term_lst)\n\n# Parses a single equation\ndef parse_equation(eq):\n    sides = eq.split('=')\n    \n    lhs = parse_side(sides[0],  1)\n    rhs = parse_side(sides[1], -1)\n    \n    return combine_term_dicts(lhs, rhs)\n\n# Linear algebra ############################################################\n\ndef argmax(lst):\n    return [i for i in range(len(lst)) if lst[i] == max(lst)][0]\n\naug = [[1, -4, 0], [2, -8, 0], [1, 1, 5]]\n\ndef gaussian_elimination_inplace(aug):\n    n_equations = len(aug)\n    n_variables = len(aug[0]) - 1\n    \n    for i in range(min(n_variables, n_equations - 1)):\n        # find pivot row\n        p = i + argmax([abs(aug[j][i]) for j in range(i, n_equations)])\n        \n        if abs(aug[p][i]) < 1e-12:\n            raise ValueError('system is singular')\n\n        aug[i], aug[p] = aug[p], aug[i]\n\n        for j in range(i + 1, n_equations):\n            beta = aug[j][i] / aug[i][i]\n            \n            for k in range(n_variables + 1):\n                aug[j][k] -= aug[i][k] * beta\n\ndef backsolve(aug):\n    n_equations = len(aug)\n    n_variables = len(aug[0]) - 1\n    \n    sol = [aug[i][n_variables] for i in range(n_variables)]\n    \n    for i in reversed(range(n_variables)):\n        for j in range(i + 1, n_variables):\n            sol[i] -= aug[i][j] * sol[j]\n            \n        if abs(aug[i][i]) < 1e-12:\n            raise ValueError('system is singular')\n            \n        sol[i] /= aug[i][i]\n        \n    return sol\n\n# Driver ####################################################################\n\ndef solve(*equations):\n    lst = [parse_equation(eq) for eq in equations]\n    \n    variables = map(set, map(dict.keys, lst))\n    \n    variables = [v for v in reduce(set.union, variables) if v]\n    \n    n_variables = len(variables)\n    n_equations = len(equations)\n    \n    if n_equations < n_variables:\n        return None\n        \n    aug = [[0] * (n_variables + 1) for i in range(n_equations)]\n\n    for i in range(n_equations):\n        for j in range(n_variables):\n            aug[i][j] = lst[i].get(variables[j], 0)\n            \n        aug[i][n_variables] = -lst[i].get(None, 0)\n        \n    try:\n        gaussian_elimination_inplace(aug)\n        \n        sol = backsolve(aug)\n    except ValueError:\n        return None\n    \n    return {k:v for k,v in zip(variables, sol)}", "import re\nfrom math import gcd\n\ndef solve(*eqs):\n    # Print equations for reference\n    for e in eqs:\n        print(e)\n    # Parsed equations into values\n    parsed_eqs = []\n    for e in eqs:\n        e = ('' if e[0] == '-' else '+') + e\n        parts = re.match(r'\\A(([+-][0-9]*[a-z]*)+)=(([+-]?[0-9]*[a-z]*)+)\\Z', e).groups()\n        parts = parts[0], ('' if parts[2][0] == '-' else '+') + parts[2]\n        parts = [re.findall(r'[+-][0-9]*[a-z]*', p) for p in parts]\n        parts = [[[''.join(re.findall(r'\\A([+-][0-9]*)', i)), ''.join(re.findall(r'[a-z]', i))] for i in p] for p in parts]\n        parsed = {}\n        for i, p in enumerate(parts):\n            for v, k in p:\n                if k not in parsed:\n                    parsed[k] = 0\n                parsed[k] += (int(v) if v not in '-+' else int(v + '1')) * [1, -1][i]\n        parsed_eqs.append(parsed)\n    # Parsed values into matrix\n    keys = set()\n    for parsed_eq in parsed_eqs:\n        for key in parsed_eq:\n            keys.add(key)\n    for parsed_eq in parsed_eqs:\n        for key in keys:\n            if key not in parsed_eq:\n                parsed_eq[key] = 0\n    ordered_keys = sorted(keys - {''}) + ['']\n    print(('\\n' + str(ordered_keys)))\n    matrix = []\n    for parsed_eq in parsed_eqs:\n        matrix.append([[parsed_eq[k], 1] for k in ordered_keys])\n    for line in matrix:\n        print(line)\n    # Reduce the matrix with standard operations\n    def swap(i0, i1):\n        # matrix[i1], matrix[i0] = matrix[i0], matrix[i1]\n        tmp = matrix[i0]\n        matrix[i0] = matrix[i1]\n        matrix[i1] = tmp\n    def mul(i, n):\n        for l in matrix[i]:\n            l[0] *= n\n    def div(i, n):\n        for l in matrix[i]:\n            l[1] *= n\n    def add(io, it):\n        for c in range(len(matrix[0])):\n            matrix[it][c][0] = matrix[it][c][0] * matrix[io][c][1] + matrix[io][c][0] * matrix[it][c][1]\n            matrix[it][c][1] *= matrix[io][c][1]\n    def sub(io, it):\n        for c in range(len(matrix[0])):\n            matrix[it][c][0] = matrix[it][c][0] * matrix[io][c][1] - matrix[io][c][0] * matrix[it][c][1]\n            matrix[it][c][1] *= matrix[io][c][1]\n    def reduce(i):\n        for l in matrix[i]:\n            divisor = gcd(l[0], l[1])\n            if l[1] < 0:\n                divisor *= -1\n            if divisor != 0:\n                l[0], l[1] = l[0] // divisor, l[1] // divisor\n    # Convert to row echelon form\n    def ref(r0, c0):\n        print()\n        if r0 >= len(matrix) or c0 >= len(matrix[0])-1:\n            return\n        if matrix[r0][c0][0] == 0:\n            r = r0\n            while r < len(matrix) and matrix[r][c0][0] == 0:\n                r += 1\n            if r == len(matrix):\n                return ref(r0, c0+1)\n            swap(r0, r)\n        for i in range(r0, len(matrix)):\n            if matrix[i][c0][0] != 0:\n                div(i, matrix[i][c0][0])\n                reduce(i)\n        for i in range(r0, len(matrix)):\n            mul(i, matrix[i][c0][1])\n            reduce(i)\n        for i in range(r0+1, len(matrix)):\n            if matrix[i][c0][0] != 0:\n                sub(r0, i)\n                reduce(i)\n        return ref(r0+1, c0+1)\n    ref(0, 0)\n    # Remove lines that lack meaning\n    matrix = [line for line in matrix \n              if line != [[0, 1] for x in range(len(line))]]\n    print('REF:')\n    for line in matrix:\n        print(line)\n    # Generate reduced row echelon form by retracing up the matrix\n    def rref(r0, c0):\n        while r0 > 0 and c0 > 0 and matrix[r0][c0] != [1, 1]:\n            if r0 > 0 and matrix[r0][c0][0] == 0:\n                r0 -= 1\n            elif c0 > 0 and matrix[r0][c0] != [1, 1]:\n                c0 -= 1\n        if r0 <= 0 or c0 <= 0:\n            return\n        for i in range(0, r0):\n            matrix[-1] = [[0, 1] for x in range(len(matrix[0]))]\n            add(r0, -1)\n            div(-1, matrix[i][c0][1])\n            mul(-1, matrix[i][c0][0])\n            sub(-1, i)\n            reduce(i)\n        return rref(r0-1, c0-1)\n    matrix.append([[0, 1] for x in range(len(matrix[0]))])\n    rref(len(matrix)-2, len(matrix[0])-2)\n    matrix.pop()\n    print()\n    for line in matrix:\n        print(line)\n    print()\n    for line in matrix:\n        print(line)\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]) - 1:\n        print(('Bad dimensions: {}, {}'.format(len(matrix), len(matrix[0]))))\n        return None\n    result = {}\n    for i in range(len(matrix)):\n        result[ordered_keys[i]] = -matrix[i][-1][0]/matrix[i][-1][1]\n    return result\n", "import re\nfrom fractions import Fraction\ndef solve(*equations): \n        equations2 = []\n        for x in equations:\n           equations2.append(x)\n        equations = equations2\n        def parsing(equations):\n            vectconstant = []\n            matrixcoefficient = []\n            listvariables = []\n            for equation in equations :\n                eqvariables = re.findall('[A-Za-z]+' , equation )\n                listvariables = listvariables + eqvariables\n            listvariables = list(set(listvariables))  \n            for equation in equations :\n                listcoefficient = []\n                equation = re.sub('\\s' , '' , equation)\n                eqdivided = equation.split('=')\n                firstp , secondp = eqdivided[0] , eqdivided[1]\n                constantterm1 = re.findall('[\\-\\+]*\\d+\\.?\\d*(?=[+-])|[\\-\\+]*\\d+\\.?\\d*$', firstp)\n                constantterm2 = re.findall('[\\-\\+]*\\d+\\.?\\d*(?=[+-])|[\\-\\+]*\\d+\\.?\\d*$', secondp)\n                for x in range(len(constantterm1)):\n                    constantterm1[x] = '-' + constantterm1[x]\n                    constantterm1[x] = re.sub('\\+\\+|\\-\\-', '+', re.sub('\\+\\-|\\-\\+', '-',constantterm1[x]))\n                constantterm = Fraction((sum(list(map(float, constantterm1 + constantterm2)))))\n                vectconstant.append(constantterm)\n                for x in listvariables :\n                    values1 = re.findall('([\\-\\+]*[\\d.]*)'+re.escape(x)+'(?=[+-]|$)' , firstp)\n                    values2 = re.findall('([\\-\\+]*[\\d.]*)'+re.escape(x)+'(?=[+-]|$)', secondp)\n                    for x in range(len(values2)): \n                        values2[x] = '-' + values2[x]\n                        values2[x] = re.sub('\\+\\+|\\-\\-', '+', re.sub('\\+\\-|\\-\\+', '-',values2[x]))\n                    values = values1 + values2\n                    for x in range(len(values)):\n                        if values[x] == '' or values[x] == '+' :\n                            values[x] = '1'\n                        elif values[x] == '-' :\n                            values[x] = '-1'\n                        values[x] = float(values[x])\n                    coefficient = Fraction((sum(values)))\n                    listcoefficient.append(coefficient)\n                matrixcoefficient.append(listcoefficient)\n            return matrixcoefficient , vectconstant , listvariables\n        def eliminateuselessrows(matrixcoefficient,vectconstant):\n            newmatrix , newvector = [] , []\n            for t,x in enumerate(matrixcoefficient) :\n                for y in x :\n                    if y != Fraction(0,1) :\n                        newmatrix.append(x) , newvector.append(vectconstant[t])\n                        break\n            return newmatrix , newvector\n        def GaussReduction(matrixcoefficient,vectconstant) :\n            c = 0\n            while c < min(len(matrixcoefficient[0]),len(matrixcoefficient)):\n                if matrixcoefficient[c][c] == Fraction(0,1) :\n                    for t,x in enumerate(matrixcoefficient):\n                        if matrixcoefficient[t][c] != Fraction(0,1) :\n                            matrixcoefficient[c] , matrixcoefficient[t] = matrixcoefficient[t] , matrixcoefficient[c]\n                            vectconstant[c] , vectconstant[t] = vectconstant[t] , vectconstant[c]                \n                for t,x in enumerate(matrixcoefficient):\n                    factor = x[c]\n                    if t > c and  matrixcoefficient[c][c] != Fraction(0,1) :\n                        vectconstant[t] = vectconstant[t]-vectconstant[c]*factor/matrixcoefficient[c][c]\n                        for s,y in enumerate(x):\n                            matrixcoefficient[t][s] = y-matrixcoefficient[c][s]*factor/matrixcoefficient[c][c]\n                matrixcoefficient,vectconstant = eliminateuselessrows(matrixcoefficient,vectconstant)            \n                c=c+1\n            return matrixcoefficient , vectconstant\n        matrixcoefficient , vectconstant , listvariables = parsing(equations)        \n        matrixcoefficient , vectconstant = GaussReduction(matrixcoefficient , vectconstant)                \n        rk1 , rk2 = 0 , 0\n        for t,x in enumerate(matrixcoefficient) :\n            for y in x :\n                if y != Fraction(0,1) :\n                    rk1 = rk1 + 1\n                    rk2 = rk2 + 1\n                    break\n            else :\n                if vectconstant[t] != Fraction(0,1) :\n                    rk2 = rk2 + 1\n        if rk1 < rk2 :\n            return None\n        if rk1 == rk2 < len(listvariables) :\n            return None\n        matrixcoefficient,vectconstant = eliminateuselessrows(matrixcoefficient,vectconstant)\n        for x in matrixcoefficient:\n             x.reverse()\n        matrixcoefficient.reverse() , vectconstant.reverse() , listvariables.reverse()\n        matrixcoefficient , vectconstant = GaussReduction(matrixcoefficient , vectconstant)\n        for t,x in enumerate(matrixcoefficient):\n            vectconstant[t] = vectconstant[t]*(1/x[t])\n        dictsolutions ={}\n        for t,x in enumerate(vectconstant) :\n            dictsolutions.update({listvariables[t]:float(vectconstant[t])})\n        return dictsolutions", "import re\nfrom fractions import Fraction as fraction\n\ndef solve(*equations):\n    A, x, b = parse_equations(equations)\n    answer = gaussian_elimination(A, x, b)\n    return answer\n\ndef parse_equations(equations):\n    create_equation = Equation.from_string\n    equations = [create_equation(eq) for eq in equations]\n    x = []\n    for eq in equations:\n        for var in eq.variables.keys():\n            x.append(var)\n    seen = set()\n    x = [var for var in x if not (var in seen or seen.add(var))]\n    A = []\n    b = []\n    for i, eq in enumerate(equations):\n        A.append([])\n        b.append(eq.constant)\n        for var in x:\n            constant = eq.variables.get(var)\n            A[i].append(constant if constant else 0)\n    return A, x, b\n\ndef gaussian_elimination(A, x, b):\n    n = len(A)\n    if n < len(x):\n        return None #There will be free variables\n    for a, b in zip(A, b):\n        a.append(b)\n    for i in range(len(x)):\n        max_el = abs(A[i][i])\n        max_row = i\n        for j in range(i+1, n):\n            if abs(A[j][i]) > max_el:\n                max_el = abs(A[j][i])\n                max_row = j\n        if max_row != i:\n            A[i], A[max_row] = A[max_row], A[i]\n        a1 = A[i][i]\n        if round(a1, 9) == 0:\n            return None\n        for j in range(i + 1, n):\n            a2 = A[j][i]\n            if a2 == 0:\n                continue\n            c = -a2/a1\n            A[j][i] = 0\n            for k in range(i + 1, len(x) + 1):\n                A[j][k] += c*A[i][k]\n    return back_substitution(A, x)\n\ndef back_substitution(U, x):\n    answer = {}\n    col = len(x) - 1\n    for row in range(len(U) - 1, -1, -1):\n        if U[row][col] == 0:\n            if round(U[row][len(x)], 9) != 0: #b not in C(A)\n                return None\n            continue\n        answer[x[col]] = U[row][len(x)]/U[row][col]\n        for i in range(row -1, -1, -1):\n            U[i][len(x)] -= U[i][col]*answer[x[col]]\n        col -= 1\n    return answer\n\nclass Equation:\n    def __init__(self, variables, constant):\n        self.variables = variables\n        self.constant = constant\n\n    @classmethod\n    def from_string(cls, eq):\n        obj_list = [] #ax+by+cz-5=0 => [a,b,c]\n        obj_regex = re.compile(r\"-?\\d*[a-z]+|-?\\d+\")\n\n        substring = eq[0: eq.find(\"=\")]\n        found_obj = obj_regex.findall(substring)\n        if len(found_obj):\n            for obj in found_obj:\n                obj_list.append(obj)\n        \n        substring = eq[eq.find(\"=\") + 1:]\n        found_obj = obj_regex.findall(substring)\n        if len(found_obj):\n            for obj in found_obj:\n                obj = obj[1:] if \"-\" in obj else \"-\" + obj #Right hand objects become negative\n                obj_list.append(obj)\n        \n        s_regex = re.compile(r\"[a-z]+\")\n        constant = -sum(int(obj) for obj in obj_list if not s_regex.search(obj))\n        variable_list = [obj for obj in obj_list if s_regex.search(obj)]\n\n        variable_dict = {}\n        n_regex = re.compile(r\"-?\\d*\")\n        for obj in variable_list:\n            s = s_regex.search(obj).group()\n            n = n_regex.search(obj).group()\n            if n == \"-\":\n                n = -1\n            else:\n                if n == \"\":\n                    n = 1\n                else:\n                    n = int(n)\n            if variable_dict.get(s):\n                variable_dict[s] += n\n            else:\n                variable_dict[s] = n\n        return cls(variable_dict, constant)\n        \n    def __repr__(self):\n        return \"Variables: {}\\nConstant: {}\".format(self.variables, self.constant)", "import re\nfrom collections import defaultdict\n\ndef parse_terms(term, sn):\n    d = defaultdict(int)\n    for m in re.finditer('([+-]?)\\s*(\\d*)\\s*([a-z]*)', term):\n        s, n, v = m.groups()\n        if n or v:\n            n = sn * (int(n or 1) * (1, -1)[s == '-'])\n            d[v or '_'] += n    \n    return d\n\ndef parse_equations(equations):\n    res = []\n    for eq in equations:\n        a, b = eq.split('=')\n        d = parse_terms(a, 1)\n        for k, v in parse_terms(b, -1).items():\n            d[k] += v\n        res.append(d)\n    return res\n\ndef norm_mat(m, var_pos):\n    val = m[var_pos]\n    if abs(val) > 1e-8:\n        for a in range(len(m)):\n            m[a] /= val\n\ndef sub_mat(m1, m2, var_pos):\n    if non_zero(m1[var_pos]):\n        for c, v in enumerate(m2):\n            m1[c] -= v\n\ndef non_zero(x):\n    return abs(x) > 1e-8\n\ndef solve(*equations):\n    print(equations)\n    eqs = parse_equations(equations)\n    var = sorted({k for d in eqs for k in d}, reverse = True)\n    mat = [[d.get(k, 0) for k in var] for d in eqs]\n    num_of_vars = len(var) - 1\n    seen = set()\n    p = 0\n    while p < len(mat):\n        var_pos = next(c for c in range(num_of_vars) if non_zero(mat[p][c]) and c not in seen)\n        seen.add(var_pos)\n        norm_mat(mat[p], var_pos)\n        for n in range(p + 1, len(mat)):\n            norm_mat(mat[n], var_pos)\n            sub_mat(mat[n], mat[p], var_pos)\n        mat = [m for m in mat if any(map(non_zero, m))]\n        p += 1\n    seen.clear()\n\n    d = {}\n    while mat:\n        el = mat.pop()\n        p = next(a for a in range(num_of_vars) if el[a] == 1.0 and a not in d)\n        for k, v in d.items():\n            el[-1] += el[k] * v\n        d[p] = -el[-1]\n    \n    if len(d) == num_of_vars:\n        return {var[k] : v for k, v in d.items()}", "def decode_eq_side(eq_side):\n    result = {}\n    sign, factor, var_name = 1, \"\", \"\"\n\n    def add_variable():\n        nonlocal factor, var_name, result\n        if var_name:\n            result[var_name] = result.get(var_name, 0) + sign * int(factor) if factor else result.get(var_name, 0) + sign\n        elif factor:\n            result[\"\"] = result.get(var_name, 0) + sign * int(factor) if factor else result.get(var_name, 0) + sign\n        factor, var_name = \"\", \"\"\n\n    for i, s in enumerate(eq_side.replace(\" \", \"\")):\n        if s == \"+\":\n            add_variable()\n            sign = 1\n        elif s == \"-\":\n            add_variable()\n            sign = -1\n        elif s.isdigit():\n            factor += s\n        else:\n            var_name += s\n    else:\n        add_variable()\n    return result\n\n\ndef decode_equation(equation):\n    variables, variables2 = [decode_eq_side(side) for side in equation.split(\"=\")]\n    for var, factor in variables2.items():\n        variables[var] = variables.get(var, 0) - factor\n    variables[\"\"] = -1*variables.get(\"\", 0)\n    return variables\n\n\ndef solve(*equations):\n    # get equation variables and matrix\n    equations_variables = [decode_equation(equation) for equation in equations]\n    variable_names = {var_name for eq_vars in equations_variables for var_name in eq_vars}\n    variable_names.discard(\"\")\n    variable_names = list(variable_names)\n    if len(variable_names) > len(equations_variables):\n        return None\n    equations_matrix = [[variables.get(var_name, 0) for var_name in variable_names] + [variables.get(\"\", 0)] for variables in equations_variables]\n    del equations_variables\n    # gauss elimination\n    gauss_matrix = []\n    for i in range(len(variable_names)):\n        chosen_row = max(equations_matrix, key=lambda row: abs(row[i]))\n        # check if solution is indeterminate\n        if abs(chosen_row[i]) < 1e-10:\n            return None\n        equations_matrix.remove(chosen_row)\n        gauss_matrix.append([0]*i + [param/chosen_row[i] for param in chosen_row[i:]])\n        for row_i, row in enumerate(equations_matrix):\n            equations_matrix[row_i] = [0]*(i+1) + [param - row[i]*gauss_matrix[-1][i+j+1] for j, param in enumerate(row[i+1:])]\n    # check if there are no solution\n    if any(abs(row[-1]) > 1e-10 for row in equations_matrix):\n        return None\n    solution = []\n    for equation in reversed(gauss_matrix):\n        solution.append(equation[-1] - sum([equation[-(2+i)]*param for i, param in enumerate(solution)]))\n    return dict(zip(variable_names, reversed(solution)))", "import re\ndef solve(*eqs):\n    #put all equations in list of dictionaries\n    sysofeq = []\n    for x in eqs:\n        #check if it is an equation\n        if '=' not in x:\n            return None\n        else:\n            sysofeq.append(elabString(x))\n    \n    #create matrix and vector\n    #get all the variables\n    varis = {}\n    for eq in eqs:\n        va = re.findall(\"[a-z]+\",eq)\n        for char in va:\n                varis.update({char:0})\n    listofvars = list(varis.keys())\n    mat = []\n    vec = []\n    for eq in sysofeq:\n        row = []\n        for v in range(0,len(listofvars)):\n            if eq.get(listofvars[v]) == None:\n                row.append(0)\n            else:    \n                row.append(eq.get(listofvars[v]))\n        mat.append(row)\n        vec.append(eq.get(\"sum\"))\n    #check for number of equations\n    if len(listofvars) > len(mat):\n        return None\n    withPivot(mat, vec)\n    #check if number of equations is greater than num of variables\n    if len(mat) > len(mat[0]):\n            for x in range(len(mat[0]),len(vec)):\n                if abs(vec[x]) > 1e-6:\n                    return None\n    #check if pivot = 0\n    for pivot in range(0,len(mat[0])):\n        if abs(mat[pivot][pivot])<1e-8:\n            return None\n    result = {}\n    for x in range(0,len(listofvars)):\n        \n        result.update({listofvars[x]:vec[x]})\n    return result\ndef elabString(equation):\n    equation = re.sub(\"\\+\",\" + \",equation)\n    equation = re.sub(\"-\",\" - \",equation)\n    equation = re.sub(\"=\",\" = \",equation)\n    varis = {}\n    allvars = re.findall(\"[a-z]+\",equation)\n    for char in allvars:\n            varis.update({char:0})\n    varis.update({\"sum\":0})\n    leftpart = equation.split(\"=\")[0]\n    rightpart = equation.split(\"=\")[1][1:]\n    #elaborate leftparts\n    leftparts = leftpart.split(\" \")\n    for x in range(0,len(leftparts)):\n        if re.search(\"[a-z]+$\",leftparts[x]):\n            num = re.search(\"[0-9]*\",leftparts[x]).group()\n            if len(num)== 0:\n                num = '1'\n            if x > 0 and leftparts[x-1] == '-':\n                num = \"-\" + num\n            curvar = (re.search(\"[a-z]+$\",leftparts[x])).group()\n            curval = varis.get(curvar)\n            varis.update({re.search(\"[a-z]+$\",leftparts[x]).group():int(num)+curval})\n        if re.search(\"[0-9]$\",leftparts[x]):\n            origval = varis.get(\"sum\")\n            if x > 0 and leftparts[x-1] == '-':\n                varis.update({\"sum\":origval + int(leftparts[x])})\n            else:    \n                varis.update({\"sum\":origval - int(leftparts[x])})\n    #elaborate rightparts\n    rightparts = rightpart.split(\" \")\n    for x in range(0,len(rightparts)):\n        if re.search(\"[a-z]+$\",rightparts[x]):\n            num = re.search(\"[0-9]*\",rightparts[x]).group()\n            if len(num)== 0:\n                num = '1'\n            if x > 0 and rightparts[x-1] == '+':\n                num = \"-\" + num\n            if x == 0:\n                num = \"-\" + num\n            curvar = (re.search(\"[a-z]+$\",rightparts[x])).group()\n            curval = varis.get(curvar)\n            varis.update({re.search(\"[a-z]+$\",rightparts[x]).group():int(num)+curval})\n        if re.search(\"[0-9]$\",rightparts[x]):\n            origval = varis.get(\"sum\")\n            if x == 0:\n                varis.update({\"sum\":origval + int(rightparts[x])})\n            elif rightparts[x-1] == '-':    \n                varis.update({\"sum\":origval - int(rightparts[x])})\n            else:\n                varis.update({\"sum\":origval + int(rightparts[x])})\n    \n    return varis\ndef swapRows(matrix,vector,x,y):\n    rowx = matrix[x]\n    matrix[x] = matrix[y]\n    matrix[y] = rowx\n    varx = vector[x]\n    vector[x] = vector[y]\n    vector[y]= varx\ndef addRows(matrix,x,y,mul):\n    for p in range(0,len(matrix[0])):\n        matrix[y][p]=matrix[y][p]-mul*matrix[x][p]\ndef addScalar(vector,x,y,mul):\n    vector[y] = vector[y] - mul * vector[x]\ndef withPivot(matrix, vector):\n    for r in range(0,len(matrix[0])):\n        #find row number with max diagonal element\n        p = [r,matrix[r][r]]\n        for v in range(r,len(matrix)):\n            if abs(matrix[v][r])>abs(p[1]):\n                p = [v,matrix[v][r]]\n        swapRows(matrix, vector, r, p[0])\n        for q in range(r+1,len(matrix)):\n            if matrix[r][r] == 0:\n                return None\n            mult = matrix[q][r]/matrix[r][r]\n            addRows(matrix,r,q,mult)\n            addScalar(vector,r,q,mult)\n    for r in range(len(matrix[0])-1,0,-1):\n        for q in range(0,r):\n            if matrix[r][r] == 0:\n                return None\n            mult = matrix[q][r]/matrix[r][r]\n            addRows(matrix,r,q,mult)\n            addScalar(vector,r,q,mult)\n    for s in range(0,len(matrix[0])):\n        vector[s]= vector[s]/matrix[s][s]\n    return (matrix,vector)"]
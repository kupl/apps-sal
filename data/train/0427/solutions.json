["class Solution:\n    def countOrders(self, n: int) -> int:\n        \n        if n == 1:\n            return 1\n        \n        \n        p = (n-1)*2+1\n        \n        dp = [0 for i in range(n+1)]\n        dp[1] = 1\n        M= 10**9+7\n        for i in range(2,n+1):\n            \n            p = (i-1)*2+1\n            \n            dp[i] = (dp[i-1]%M * ((p*(p+1))//2)%M)%M\n        \n        return dp[n]\n", "class Solution:\n    def countOrders(self, n: int) -> int:\n\n        ans = 1\n        MOD = 1000000007\n        for i in range(2, n + 1):\n            ans *= ((2 * i - 1) * (i - 1) + (2 * i - 1))\n            ans %= MOD\n\n        return ans\n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        if n <= 1:\n            return n\n        num_spots = (n*2) - 1\n        return (((num_spots*(num_spots+1))//2) * self.countOrders(n-1)) % ((10**9)+7)\n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        F = [0, 1]\n        \n        for i in range(2, n+1):\n            one_way = i * 2 - 1\n            F.append(one_way * F[i-1] * i)\n        \n        return F[n]%(pow(10,9)+7)\n            \n        \n        \n", "import math\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        dp = [0 for _ in range(n+1)]\n        \n        dp[1] = 1\n        \n        for i in range(2,n+1):\n            N = (i-1)*2+1\n            dp[i] = (N + math.factorial(N)//(math.factorial(N-2)*2)) * dp[i-1] % MOD\n            \n        return dp[n]\n", "class Solution:\n    # bottom-up\n    def countOrders(self, n: int) -> int:\n        dp = {}\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            num_digit, res = 2 * (i-1), 0\n            for j in range(num_digit+1, 0, -1):\n                res += j\n            dp[i] = res * dp[i-1]\n        \n        return dp[n] % (10**9 + 7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        dp = [0 for _ in range(n+1)]\n        dp[1] = 1\n        mod = 10 ** 9 + 7\n        for i in range(2, n+1):\n            spaces = (i-1) * 2 + 1\n            permutations = sum(j for j in range(1, spaces+1))\n            dp[i] = (dp[i-1] * permutations) % mod\n        return dp[n]", "class Solution:\n    def countOrders(self, n: int) -> int:\n        if n == 1:\n            return 1\n        else:\n            positions = 2*(n-1) +1\n            all_possib = 0\n            for i in range(positions +1):\n                possibilities = positions -i\n                all_possib += possibilities\n            return (all_possib * self.countOrders(n-1) % 1000000007)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        \n        \n        \n        dp = [1 for i in range(n)]\n        \n        for i in range(1,n):\n            sequence = i+1\n            length = 2*(i)\n            temp = sum([j for j in range(1,length+2)])\n            dp[i] = temp*dp[i-1]\n        \n        print(dp)\n        return dp[-1]%(10**9+7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        dp = [0, 1]\n        \n        for i in range(2, n+1):\n            res = dp[i-1] * (2*(i-1)+1) * (2*(i-1)+2)//2\n            res = res%(10**9+7)\n            dp.append(res)\n        return dp[n]", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # 9:41\n        # we just want to make sure delivery i happens before pick up i\n        # we can save lot of recursive calls by using maths\n        \n#         n*[(n-1),1]\n#                    n-2\n                    \n#         p,d\n#         n,0\n        \n#         p=n\n#         d=0\n        \n#         p=n-1\n#         d=1\n        \n#         p=n-2   or p=n-1\n#                d=0\n#         d=2.\n        \n        # @lru_cache(None)\n        # def factorial(x):\n        #     fact=1\n        #     for i in range(1,x+1):\n        #         fact*=i\n        #     return fact\n        mod=10**9+7\n        facts=[1]\n        for i in range(1,n+1):\n            facts.append(facts[-1]*i)\n            \n        # @lru_cache(None)\n        # def ways(pickOptions,deliverOptions):\n        #     nonlocal mod\n        #     ans=0\n        #     if pickOptions>0 and deliverOptions>0:\n        #         ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n        #         ans+=ways(pickOptions,deliverOptions-1)*deliverOptions\n        #     elif pickOptions>0 and deliverOptions==0:\n        #         ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n        #     elif deliverOptions>0 and pickOptions==0:\n        #         ans+=facts[deliverOptions]\n        #     return ans%mod\n        # return ways(n,0)\n    \n        dp=[[0]*(n+1) for _ in range(n+1)]\n        for p in range(n+1):\n            for d in range(n-p+1):\n                if p>0 and d>0:\n                    dp[p][d]+=((dp[p-1][d+1]*p)%mod)\n                    dp[p][d]+=((dp[p][d-1]*d)%mod)\n                elif p>0 and d==0:\n                    dp[p][d]+=((dp[p-1][d+1]*p)%mod)\n                elif d>0 and p==0:\n                    dp[p][d]+=(facts[d]%mod)\n        return dp[n][0]\n    \n                \n                    \n                \n        \n                \n                \n                \n            \n        \n        \n        \n            \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # 9:41\n        # we just want to make sure delivery i happens before pick up i\n        # we can save lot of recursive calls by using maths\n        \n#         n*[(n-1),1]\n#                    n-2\n                    \n#         p,d\n#         n,0\n        \n#         p=n\n#         d=0\n        \n#         p=n-1\n#         d=1\n        \n#         p=n-2   or p=n-1\n#                d=0\n#         d=2.\n        \n        # @lru_cache(None)\n        # def factorial(x):\n        #     fact=1\n        #     for i in range(1,x+1):\n        #         fact*=i\n        #     return fact\n        mod=10**9+7\n        facts=[1]\n        for i in range(1,n+1):\n            facts.append(facts[-1]*i)\n            \n        # @lru_cache(None)\n        # def ways(pickOptions,deliverOptions):\n        #     nonlocal mod\n        #     ans=0\n        #     if pickOptions>0 and deliverOptions>0:\n        #         ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n        #         ans+=ways(pickOptions,deliverOptions-1)*deliverOptions\n        #     elif pickOptions>0 and deliverOptions==0:\n        #         ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n        #     elif deliverOptions>0 and pickOptions==0:\n        #         ans+=facts[deliverOptions]\n        #     return ans%mod\n        # return ways(n,0)\n    \n        dp=[[0]*(n+1) for _ in range(n+1)]\n        for p in range(n+1):\n            for d in range(n+1):\n                if d>n-p:continue\n                if p>0 and d>0:\n                    dp[p][d]+=((dp[p-1][d+1]*p)%mod)\n                    dp[p][d]+=((dp[p][d-1]*d)%mod)\n                elif p>0 and d==0:\n                    dp[p][d]+=((dp[p-1][d+1]*p)%mod)\n                elif d>0 and p==0:\n                    dp[p][d]+=(facts[d]%mod)\n        return dp[n][0]\n    \n                \n                    \n                \n        \n                \n                \n                \n            \n        \n        \n        \n            \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        MOD = int(1e9) + 7\n        d = [[0] * (n + 2) for _ in range(n + 2)]\n        d[0][0] = 1\n        for i in range(n + 1):\n            for j in range(i + 1):\n                d[i + 1][j] = (d[i + 1][j]+ d[i][j] * (n - i)) % MOD\n                d[i][j + 1] = (d[i][j + 1] + d[i][j] * (i - j)) % MOD\n        return d[n][n - 1]\n\n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # 9:41\n        # we just want to make sure delivery i happens before pick up i\n        # we can save lot of recursive calls by using maths\n        \n#         n*[(n-1),1]\n#                    n-2\n                    \n#         p,d\n#         n,0\n        \n#         p=n\n#         d=0\n        \n#         p=n-1\n#         d=1\n        \n#         p=n-2   or p=n-1\n#                d=0\n#         d=2.\n        \n        # @lru_cache(None)\n        # def factorial(x):\n        #     fact=1\n        #     for i in range(1,x+1):\n        #         fact*=i\n        #     return fact\n        mod=10**9+7\n        facts=[1]\n        for i in range(1,n+1):\n            facts.append(facts[-1]*i)\n        \n        \n        @lru_cache(None)\n        def ways(pickOptions,deliverOptions):\n            nonlocal mod\n            ans=0\n            if pickOptions>0 and deliverOptions>0:\n                ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n                ans+=ways(pickOptions,deliverOptions-1)*deliverOptions\n            elif pickOptions>0 and deliverOptions==0:\n                ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n            elif deliverOptions>0 and pickOptions==0:\n                ans+=facts[deliverOptions]\n            return ans%mod\n        return ways(n,0)\n    \n        # dp=[]\n        # for p in range(n+1):\n        #     for d in range()\n        \n                \n                \n                \n            \n        \n        \n        \n            \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        l = 2\n        num = 1\n        for i in range(2, n+1):\n            num = sum(num*(l-hole+1) for hole in range(l+1))\n            l += 2\n        return num % (10**9+7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # 9:41\n        # we just want to make sure delivery i happens before pick up i\n        # we can save lot of recursive calls by using maths\n        \n#         n*[(n-1),1]\n#                    n-2\n                    \n#         p,d\n#         n,0\n        \n#         p=n\n#         d=0\n        \n#         p=n-1\n#         d=1\n        \n#         p=n-2   or p=n-1\n#                d=0\n#         d=2.\n        \n        @lru_cache(None)\n        def factorial(x):\n            fact=1\n            for i in range(1,x+1):\n                fact*=i\n            return fact\n        mod=10**9+7\n        @lru_cache(None)\n        def ways(pickOptions,deliverOptions):\n            nonlocal mod\n            ans=0\n            if pickOptions>0 and deliverOptions>0:\n                ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n                ans+=ways(pickOptions,deliverOptions-1)*deliverOptions\n            elif pickOptions>0 and deliverOptions==0:\n                ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n            elif deliverOptions>0 and pickOptions==0:\n                ans+=factorial(deliverOptions)\n            return ans%mod\n        return ways(n,0)\n        \n                \n                \n                \n            \n        \n        \n        \n            \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # 9:41\n        # we just want to make sure delivery i happens before pick up i\n        # we can save lot of recursive calls by using maths\n        \n#         n*[(n-1),1]\n#                    n-2\n                    \n#         p,d\n#         n,0\n        \n#         p=n\n#         d=0\n        \n#         p=n-1\n#         d=1\n        \n#         p=n-2   or p=n-1\n#                d=0\n#         d=2.\n        \n        \n        pickup=n\n        delivery=0\n        def factorial(x):\n            fact=1\n            for i in range(1,x+1):\n                fact*=i\n            return fact\n        mod=10**9+7\n        @lru_cache(None)\n        def ways(pick,deliver):\n            nonlocal mod\n            ans=0\n            if pick>0 and deliver>0:\n                ans+=ways(pick-1,deliver+1)*pick\n                ans+=ways(pick,deliver-1)*deliver\n            elif pick>0 and deliver==0:\n                ans+=ways(pick-1,deliver+1)*pick\n            elif deliver>0 and pick==0:\n                ans+=factorial(deliver)\n            return ans%mod\n        return ways(n,0)\n        \n                \n                \n                \n            \n        \n        \n        \n            \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # 9:41\n        # we just want to make sure delivery i happens before pick up i\n        # we can save lot of recursive calls by using maths\n        \n#         n*[(n-1),1]\n#                    n-2\n                    \n#         p,d\n#         n,0\n        \n#         p=n\n#         d=0\n        \n#         p=n-1\n#         d=1\n        \n#         p=n-2   or p=n-1\n#                d=0\n#         d=2.\n        \n        \n        def factorial(x):\n            fact=1\n            for i in range(1,x+1):\n                fact*=i\n            return fact\n        mod=10**9+7\n        @lru_cache(None)\n        def ways(pickOptions,deliverOptions):\n            nonlocal mod\n            ans=0\n            if pickOptions>0 and deliverOptions>0:\n                ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n                ans+=ways(pickOptions,deliverOptions-1)*deliverOptions\n            elif pickOptions>0 and deliverOptions==0:\n                ans+=ways(pickOptions-1,deliverOptions+1)*pickOptions\n            elif deliverOptions>0 and pickOptions==0:\n                ans+=factorial(deliverOptions)\n            return ans%mod\n        return ways(n,0)\n        \n                \n                \n                \n            \n        \n        \n        \n            \n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        num = 1\n        for i in range(2, n+1):\n            num = sum(num*((i-1)*2-hole+1) for hole in range((i-1)*2+1))\n        return num % (10**9+7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        DP = [0]*(n+1)\n        DP[1] = 1\n        for i in range(2, n+1):\n            newpos = ((i*2-1)+1)*(i*2-1)//2\n            DP[i] = newpos*DP[i-1]\n        \n        return DP[-1]%(10**9+7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        def solve(remaining, pending):\n            # Base case: no remaining orders and one pending order\n            if remaining == 0 and pending == 1:\n                return 1\n            \n            # Memoization case\n            if memo[remaining][pending] != -1:\n                return memo[remaining][pending]\n            \n            count = 0\n            \n            # Recursive case 1: start a new order, there are remaining ways to do so\n            if remaining > 0:\n                count += remaining * solve(remaining - 1, pending + 1)\n            \n            # Recursive case 2: end an order; there are pending ways to do so\n            if pending > 0:\n                count += pending * solve(remaining, pending - 1)\n            \n            count %= MOD\n            memo[remaining][pending] = count \n            return count\n        \n        MOD = 10**9 + 7\n        memo = [[-1 for _ in range(n+1)] for _ in range(n+1)]\n        return solve(n, 0)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        '''\n        # Notes:\n            example n = 3\n                                P1         P2     P3 \n                             P2    P3   D1\n                        P3   D1  D2\n                     D1  D2 D3\n                  D2  D3\n        # Approach:\n            Dynamic Programming\n            opt[i][j]   i represents how many delivery are holding\n                        j represents how many remaining delivery\n                        output = opt[0][n]\n                       \n                                OPT[0][3]\n                                3*OPT[1][2]\n                        1*OPT[0][2]        2*OPT[2][1]\n                        2*OPT[1][1]     2*OPT[1][1]  1*OPT[3][0]\n                    1*OPT[0][1] 1*OPT[2][0]\n                    \n            OPT[i][j] = i*opt[i-1][j] + j*opt[i+1][j-1]\n                                \n        '''\n        opt = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\n        for j in range(n+1):\n            for i in range(n+1):\n                if j == n:\n                    opt[i][j] = j*opt[i+1][j-1]\n                    return opt[0][n] % (pow(10, 9)+7)\n                if i == 0 and j == 0:\n                    continue\n                if i == 0 and j == 1:\n                    opt[i][j] = 1\n                    continue\n                if i == 1 and j == 0:\n                    opt[i][j] = 1\n                    continue\n                if i == 0:\n                    opt[i][j] = j*opt[i+1][j-1]\n                elif j == 0:\n                    opt[i][j] = i*opt[i-1][j]\n                else:\n                    if i + j > n:\n                        break\n                    opt[i][j] = i*opt[i-1][j] + j*opt[i+1][j-1]\n                    \n        \n        #return opt[0][n] % (pow(10, 9)+7)\n        \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        orderResults = {}\n\n        def orderHelper(pickupsLeft, heldPackages):\n            key = (pickupsLeft, heldPackages)\n            if key in orderResults:\n                return orderResults[key]\n\n            if key == (0, 0):\n                return 0\n            elif key == (0, 1):\n                return 1\n            elif key == (1, 0):\n                return 1\n\n            res = 0\n            if pickupsLeft > 0:\n                res += pickupsLeft * orderHelper(pickupsLeft - 1, heldPackages + 1)  # pickup an available package\n            if heldPackages > 0:\n                res += heldPackages * orderHelper(pickupsLeft, heldPackages - 1)  # deliver a held package\n            res = res % (10**9 + 7)\n\n            orderResults[key] = res\n            return res\n\n        return orderHelper(n, 0)", "from itertools import permutations\n\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        dp = {}\n        MOD = 10**9 +7\n        dp[(0,0)] = 1\n        \n        \n        def helper(pick, deliver):\n            nonlocal dp\n            key = (pick, deliver)\n            if key in dp:\n                return dp[key]\n            elif pick > deliver:\n                return 0\n            \n            ans = 0\n            if pick > 0:\n                ans += helper(pick - 1, deliver) * pick %MOD\n            if deliver > 0 and pick < deliver:\n                ans += helper(pick, deliver - 1) * ( deliver-pick) %MOD\n            dp[key] = ans\n            return ans\n        \n        return helper(n,n)  %MOD\n            \n            \n            \n            \n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        MOD = int(1e9) + 7\n        d = [[0] * (n + 2) for _ in range(n + 2)]\n        d[0][0] = 1\n        for i in range(n + 1):\n            for j in range(i + 1):\n                d[i + 1][j] = (d[i + 1][j]+ d[i][j] * (n - i))\n                d[i][j + 1] = (d[i][j + 1] + d[i][j] * (i - j))\n        return d[n][n - 1] % MOD\n\n", "def oneMore(length: int) -> int:\n    if length < 2:\n        return 1\n    return int((length * (length + 1))/2 + length + 1)\n\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        acc = 1\n        for i in range(0, n*2, 2):\n            acc *= oneMore(i)\n            acc %= int(1E9 + 7)\n        return acc", "\nclass Solution:\n    import sys\n    \n    def countOrders(self, n: int) -> int:\n        \n        print(sys.getrecursionlimit())\n        #A = [0 for _ in range(n)]\n        \n        @lru_cache(None)\n        def helper(p,d):\n            #sys.setrecursionlimit(10**6)\n            if(p == n and d == n):\n                return 1\n            ans = 0\n            if(n>p):\n                ans += (n-p)*(helper(p+1,d))\n            if(p>d):\n                ans += (p-d)*(helper(p,d+1))\n            return ans\n        \n        return helper(0,0)%(10**9 + 7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        # m = m * 2\n        res = 1\n        for i in range(1, n + 1):\n            res = res * self.choose(2 * i, 2)\n        return res % int(math.pow(10, 9) + 7)\n    \n    def choose(self, n, k):\n        if 0 <= k <= n:\n            ntok = 1\n            ktok = 1\n            for t in range(1, min(k, n - k) + 1):\n                ntok *= n\n                ktok *= t\n                n -= 1\n            return ntok // ktok\n        else:\n            return 0", "class Solution:\n    def countOrders(self, n: int) -> int:\n        mod = 10 ** 9 + 7\n        # return (2n)! / (2 ^ n)\n        res = 1\n        for i in range(2*n, 0, -1):\n            res = res * i\n            if i & 1:\n                res /= 2\n                res = res % mod\n        return int(res)\n", "class Solution:\n    def countOrders(self, n: int) -> int:\n        MOD = 10**9 + 7\n        res = 1\n        for i in range(2, n + 1):\n            res = res * (2 * i - 1) * (2 * i) // 2 % MOD\n        return res", "class Solution:\n    def countOrders(self, n: int) -> int:\n        '''\nAssume we have already n - 1 pairs, now we need to insert the nth pair.\nTo insert the first element, there are n * 2 - 1 chioces of position\u3002\nTo insert the second element, there are n * 2 chioces of position\u3002\nSo there are (n * 2 - 1) * n * 2 permutations.\nConsidering that delivery(i) is always after of pickup(i), we need to divide 2.\nSo it's (n * 2 - 1) * n.\n\n        '''\n        res=1\n        for i in range(2,n+1):\n            res=res*i*(2*i-1)\n        return res%(10**9+7)", "class Solution:\n    def countOrders(self, n: int) -> int:\n        res = 1\n        for i in range(1, n+1):\n            x = (i-1)*2+1\n            possibilities = x*(x-1)//2+x\n            res = (res * possibilities)%(1000000000 + 7)\n        return res"]
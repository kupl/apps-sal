["def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    a.sort()\n    b=[0]*n\n    for i in range(n):\n        b[i]=a[i][1]\n  \n    print(LongestIncreasingSubsequenceLength(b, n)) \n", "# cook your dish here\ndef CeilIndex(A, l, r, key): \n\n\twhile (r - l > 1): \n\t\n\t\tm = l + (r - l)//2\n\t\tif (A[m] >= key): \n\t\t\tr = m \n\t\telse: \n\t\t\tl = m \n\treturn r \n\ndef LongestIncreasingSubsequenceLength(A, size): \n\n\t# Add boundary case, \n\t# when array size is one \n\n\ttailTable = [0 for i in range(size + 1)] \n\tlen = 0 # always points empty slot \n\n\ttailTable[0] = A[0] \n\tlen = 1\n\tfor i in range(1, size): \n\t\n\t\tif (A[i] < tailTable[0]): \n\n\t\t\t# new smallest value \n\t\t\ttailTable[0] = A[i] \n\n\t\telif (A[i] > tailTable[len-1]): \n\n\t\t\t# A[i] wants to extend \n\t\t\t# largest subsequence \n\t\t\ttailTable[len] = A[i] \n\t\t\tlen+= 1\n\n\t\telse: \n\t\t\t# A[i] wants to be current \n\t\t\t# end candidate of an existing \n\t\t\t# subsequence. It will replace \n\t\t\t# ceil value in tailTable \n\t\t\ttailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n\t\t\n\n\treturn len\n\nfor _ in range(int(input())):\n    t = int(input())\n    l = []\n    for _ in range(t):\n        (x,y) = map(int,input().split())\n        l.append([x,y])\n    l.sort()\n    # print(l)\n    kk = []\n    for (i,j) in l:\n        kk.append(j)\n    print(LongestIncreasingSubsequenceLength(kk, t))    ", "# Python program to find \r\n# length of longest \r\n# increasing subsequence \r\n# in O(n Log n) time \r\n\r\n# Binary search (note \r\n# boundaries in the caller) \r\n# A[] is ceilIndex \r\n# in the caller \r\ndef CeilIndex(A, l, r, key): \r\n\r\n\twhile (r - l > 1): \r\n\t\r\n\t\tm = l + (r - l)//2\r\n\t\tif (A[m] >= key): \r\n\t\t\tr = m \r\n\t\telse: \r\n\t\t\tl = m \r\n\treturn r \r\n\r\ndef LongestIncreasingSubsequenceLength(A, size): \r\n\r\n\t# Add boundary case, \r\n\t# when array size is one \r\n\r\n\ttailTable = [0 for i in range(size + 1)] \r\n\tlen = 0 # always points empty slot \r\n\r\n\ttailTable[0] = A[0] \r\n\tlen = 1\r\n\tfor i in range(1, size): \r\n\t\r\n\t\tif (A[i] < tailTable[0]): \r\n\r\n\t\t\t# new smallest value \r\n\t\t\ttailTable[0] = A[i] \r\n\r\n\t\telif (A[i] > tailTable[len-1]): \r\n\r\n\t\t\t# A[i] wants to extend \r\n\t\t\t# largest subsequence \r\n\t\t\ttailTable[len] = A[i] \r\n\t\t\tlen+= 1\r\n\r\n\t\telse: \r\n\t\t\t# A[i] wants to be current \r\n\t\t\t# end candidate of an existing \r\n\t\t\t# subsequence. It will replace \r\n\t\t\t# ceil value in tailTable \r\n\t\t\ttailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \r\n\t\t\r\n\r\n\treturn len\r\n\r\n\r\nT=int(input())\r\nwhile T:\r\n    N=int(input())\r\n    ls=[]\r\n    for i in range(N):\r\n        a,b=map(int,input().split())\r\n        ls.append([a,b])\r\n    ls.sort()\r\n    temp=[ls[i][1] for i in range(N)]\r\n    print(LongestIncreasingSubsequenceLength(temp,N))\r\n    T-=1"]
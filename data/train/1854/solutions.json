["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def superrob(node):\n             # returns tuple of size two (now, later)\n             # now: max money earned if input node is robbed\n             # later: max money earned if input node is not robbed\n \n             # base case\n             if not node: return (0, 0)\n \n             # get values\n             left, right = superrob(node.left), superrob(node.right)\n \n             # rob now\n             now = node.val + left[1] + right[1]\n \n             # rob later\n             later = max(left) + max(right)\n \n             return (now, later)\n \n         return max(superrob(root))\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         yield_value = {}\n         \n         def helper(node, can_rob):\n             if not node:\n                 return 0\n             \n             if (node.left, True) not in yield_value:\n                 left_yield_t = helper(node.left, True)\n                 yield_value[(node.left, True)] = left_yield_t\n             if (node.right, True) not in yield_value:\n                 right_yield_t = helper(node.right, True)\n                 yield_value[(node.right, True)] = right_yield_t            \n             if (node.left, False) not in yield_value:\n                 left_yield_f = helper(node.left, False)\n                 yield_value[(node.left, False)] = left_yield_f\n             if (node.right, False) not in yield_value:\n                 right_yield_f = helper(node.right, False)\n                 yield_value[(node.right, False)] = right_yield_f\n                 \n             if not can_rob:\n                 return yield_value[(node.left, True)] + yield_value[(node.right, True)]\n             \n             else:\n                 return max(\n                     (node.val + yield_value[(node.left, False)] + yield_value[(node.right, False)]), \n                     (yield_value[(node.left, True)] + yield_value[(node.right, True)] )\n                 )\n         \n         return helper(root, True)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         valMap = dict()\n         def solve(root, path):\n             if root is None: return 0\n             if path not in valMap:\n                 left, right = root.left, root.right\n                 ll = lr = rl = rr = None\n                 if left:  ll, lr = left.left, left.right\n                 if right: rl, rr = right.left, right.right\n                 passup = solve(left, path + 'l') + solve(right, path + 'r')\n                 grabit = root.val + solve(ll, path + 'll') + solve(lr, path + 'lr') \\\n                          + solve(rl, path + 'rl') + solve(rr, path + 'rr')\n                 valMap[path] = max(passup, grabit)\n             return valMap[path]\n         return solve(root, '')\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n \n class Solution(object):\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def superrob(node):\n             # returns tuple of size two (now, later)\n             # now: max money earned if input node is robbed\n             # later: max money earned if input node is not robbed\n             \n             # base case\n             if not node: return (0, 0)\n             \n             # get values\n             left, right = superrob(node.left), superrob(node.right)\n             \n             # rob now\n             now = node.val + left[1] + right[1]\n             \n             # rob later\n             later = max(left) + max(right)\n             \n             return (now, later)\n             \n         return max(superrob(root))", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def dfs(root):\n             if root == None:\n                 return [0, 0]\n             \n             left = dfs(root.left)\n             right = dfs(root.right)\n             res = [0, 0]\n             res[0] = root.val + left[1] + right[1]\n             res[1] = max(left[0], left[1]) + max(right[0], right[1])\n             return res\n         res = dfs(root)\n         print(res)\n         return max(res[0], res[1])\n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         return self.robSub(root, {})\n     \n     def robSub(self, root, dictionary):\n         if root == None:\n             return 0\n         if root in dictionary:\n             return dictionary[root]\n         value = 0\n         if root.left != None:\n             value += self.robSub(root.left.left, dictionary) + self.robSub(root.left.right, dictionary)\n         if root.right != None:\n             value += self.robSub(root.right.left, dictionary) + self.robSub(root.right.right, dictionary)\n         value = max(value+root.val, self.robSub(root.left,dictionary)+self.robSub(root.right,dictionary))\n         dictionary[root] = value\n         return value\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         \n         dp = {}\n         \n         def rob1(node):\n             if node.left and node.left not in dp:\n                 dp[node.left] = rob1(node.left)\n             if node.right and node.right not in dp:\n                 dp[node.right] = rob1(node.right)\n             \n             temp = node.val\n \n             if node.left and node.left.left:\n                 temp += dp[node.left.left]\n             if node.left and node.left.right:\n                 temp += dp[node.left.right]\n             if node.right and node.right.left:\n                 temp += dp[node.right.left]\n             if node.right and node.right.right:\n                 temp += dp[node.right.right]\n             \n             t = 0\n             if node.left:\n                 t += dp[node.left]\n             if node.right:\n                 t += dp[node.right]\n             \n             return max(t, temp)\n         \n         return rob1(root)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         self.dict = {}\n         return self.recurse(root)\n         \n     def recurse(self, root):\n         if root is None:\n             return 0\n         if root in self.dict:\n             return self.dict[root]\n         else:\n             x = self.recurse(root.left)\n             y = self.recurse(root.right)\n             a = 0 if root.left is None else self.recurse(root.left.left)\n             b = 0 if root.left is None else self.recurse(root.left.right)\n             c = 0 if root.right is None else self.recurse(root.right.left)\n             d = 0 if root.right is None else self.recurse(root.right.right)\n             ans = max(root.val+a+b+c+d , x+y)\n             self.dict[root] = ans\n             return ans", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         # if not root:\n         #     return 0\n         # res = 0\n         # if root.left:\n         #     if root.left.left:\n         #         res += self.rob(root.left.left)\n         #     if root.left.right:\n         #         res += self.rob(root.left.right)\n         # if root.right:\n         #     if root.right.left:\n         #         res += self.rob(root.right.left)\n         #     if root.right.right:\n         #         res += self.rob(root.right.right)\n         # return max(res + root.val, self.rob(root.left) + self.rob(root.right))\n         \n         print(self.helper(root))\n         return max(self.helper(root))\n         \n     def helper(self, root):\n         if not root:\n             return [0,0]\n         left = self.helper(root.left)\n         right = self.helper(root.right)\n         res = [0, 0] # index = 0 not rob, index 1 rob\n         res[0] = max(left) + max(right)\n         res[1] = left[0] + right[0] + root.val\n         return res\n         \n              \n             \n             \n         ", "class Solution:\n \n     def rob_node(self, node):\n         if not node.left:\n             rob_node_left, not_rob_node_left = 0, 0\n         else:\n             rob_node_left, not_rob_node_left = self.rob_node(node.left)\n         if not node.right:\n             rob_node_right, not_rob_node_right = 0, 0\n         else:\n             rob_node_right, not_rob_node_right = self.rob_node(node.right)\n         return node.val + not_rob_node_left + not_rob_node_right, \\\n                max(rob_node_left, not_rob_node_left) + max(rob_node_right, not_rob_node_right)\n \n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         rob_root, not_rob_root = self.rob_node(root)\n         return max(rob_root, not_rob_root)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     \n     def rob2(self, root):\n         \n         if root is None:\n             return (0,0)\n         \n         with_left, without_left = self.rob2(root.left)\n             \n         with_right, without_right = self.rob2(root.right)\n         \n         with_root = without_left + without_right + root.val\n         \n         without_root = max(with_left, without_left) + max(with_right, without_right)\n         \n         return (with_root, without_root)\n     \n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         return max(self.rob2(root))\n             \n         ", "class Solution:\n     def __init__(self):\n         self.data_dict = dict()\n \n     def rob(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n \n         if not root:\n             return 0\n \n         if root in self.data_dict:\n             return self.data_dict[root]\n \n         if not root.left and not root.right:\n             self.data_dict[root] = root.val\n             return root.val\n \n         res = 0\n \n         if root.left:\n             res += self.rob(root.left.left) + self.rob(root.left.right)\n \n         if root.right:\n             res += self.rob(root.right.left) + self.rob(root.right.right)\n \n         res = max(self.rob(root.left) + self.rob(root.right), res + root.val)\n         self.data_dict[root] = res\n \n         return res"]
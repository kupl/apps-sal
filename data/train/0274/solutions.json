["from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            res = max(res, j-i+1)\n        return res\n    \nfrom collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for val in nums:\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minHeap,maxHeap=[],[]\n        left=maxLen=0\n        for right in range(len(nums)):\n            heappush(minHeap,(nums[right],right))\n            heappush(maxHeap,(-nums[right],right))\n            \n            while nums[right]-minHeap[0][0]>limit:\n                left=max(left,(heappop(minHeap)[1])+1)\n            while -maxHeap[0][0]-nums[right]>limit:\n                left=max(left,(heappop(maxHeap)[1])+1)\n            maxLen=max(maxLen,right-left+1)\n        return maxLen", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) < 2:\n            return 1\n        longestSize = 1\n        left = 0\n        lo_q, hi_q = [], []\n        heapq.heappush(lo_q, (nums[0], 0))\n        heapq.heappush(hi_q, (-nums[0], 0))\n        for idx in range(1, len(nums)):\n            if lo_q and nums[idx] < lo_q[0][0]:\n                lo_q = []\n            elif hi_q and -nums[idx] < hi_q[0][0]:\n                hi_q = []\n            heapq.heappush(lo_q, (nums[idx], idx))\n            heapq.heappush(hi_q, (-nums[idx], idx))\n\n            while lo_q and abs(nums[idx] - lo_q[0][0]) > limit:\n                left = max(left, heapq.heappop(lo_q)[1] + 1)\n            while hi_q and abs(nums[idx] + hi_q[0][0]) > limit:\n                left = max(left, heapq.heappop(hi_q)[1] + 1)\n            longestSize = max(longestSize, idx - left + 1)\n        return longestSize", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_heap = []\n        max_heap = []\n        start = 0\n        best = 0\n        for idx, val in enumerate(nums):\n            heappush(min_heap, (val, idx))\n            heappush(max_heap, (-val, idx))\n\n            while start < idx and abs(min_heap[0][0] + max_heap[0][0]) > limit:\n                start += 1\n                while min_heap[0][1] < start:\n                    heappop(min_heap)\n                while max_heap[0][1] < start:\n                    heappop(max_heap)\n            best = max(best, idx - start + 1)\n        return best", "from heapq import *\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minH = []\n        maxH = []\n        l = 0\n        ans = 0\n        for r, n in enumerate(nums):\n            heappush(minH, (n,r))\n            heappush(maxH, (-n,r))\n            while -maxH[0][0] - minH[0][0] > limit:\n                l = min(maxH[0][1], minH[0][1]) + 1\n                while maxH[0][1] < l: heappop(maxH)\n                while minH[0][1] < l: heappop(minH)\n            # print(l, r, maxH, minH)\n            ans = max(ans, r-l+1)\n        return ans", "# https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/721619/Python-Rust-Sliding-Window-and-Deque\n'''\nThe problem description states that we need to find the window with the largest size that has max-min<=limit\nThis is clearly a sliding window problem. The brute force solution is to start from each index, keep on expanding, and once the max-min is larger than limit, we break. O(n^2)\n\nCan we do better? Well, we can actually use a classic technique in sliding window problems where we keep on expanding the window from the right until the window is no longer valid.\nOnce the window is invalid we keep on contracting it from the left until it becomes valid again. (Just like in the famous \\\"Longest Substring Without Repeating Characters\\\" problem.\n\nEvery iteration we need to answer the question, what is our current min and max? this leads us to using two heaps where one of them is a min heap and the other is a max heap.\n\nEvery iteration we push the new number to both heaps and then keep on popping from the min and max heaps until we're sure that we've maintained the invariant maxHeap[0] - minHeap[0] <= limit.\nWe do O(N) pushes and pops from the heaps and each push/pop is O(logN) so we end up with an O(NlogN) solution.\n\nHere is the code:\n'''\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minHeap, maxHeap = [], []\n        left = maxLen = 0\n        \n        for right, num in enumerate(nums):\n            heappush(minHeap, (num, right))\n            heappush(maxHeap, (-num, right))\n            \n            while num - minHeap[0][0] > limit:\n                left = max(left, heappop(minHeap)[1] + 1)\n            while -maxHeap[0][0] - num > limit:\n                left = max(left, heappop(maxHeap)[1] + 1)\n            \n            maxLen = max(maxLen, right - left + 1)\n        return maxLen", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        import heapq\n        mnq, mxq = [], []\n        res = 0\n        left = -1\n        for right, num in enumerate(nums):\n            heapq.heappush(mnq, (num, right))\n            heapq.heappush(mxq, (-num, right))\n            \n            while -mxq[0][0] - mnq[0][0] > limit:\n                left = min(mnq[0][1], mxq[0][1])\n                while mxq[0][1] <= left:\n                    heapq.heappop(mxq)\n                while mnq[0][1] <= left:\n                    heapq.heappop(mnq)\n            res = max(res, right - left)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        minh = []\n        maxh = []\n        start = 0\n        ans = 0\n        deleted = set()\n        for end in range(n):\n            x = nums[end]\n            heappush(minh, (x, end))\n            heappush(maxh, (-x, end))\n            while minh and minh[0][1] in deleted:\n                heappop(minh)\n            while maxh and maxh[0][1] in deleted:\n                heappop(maxh)                \n            while minh and maxh and -maxh[0][0] - minh[0][0] > limit and start <= end:\n                deleted.add(start)\n                start += 1\n                while minh and minh[0][1] in deleted:\n                    heappop(minh)\n                while maxh and maxh[0][1] in deleted:\n                    heappop(maxh)                                \n            ans = max(ans, end - start + 1)\n        return ans\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_heap, max_heap = deque([0]), deque([0])\n        res = 1\n        far = -1 #stores the index of the position where the array becomes invalid\n        for i in range(1, len(nums)) :\n\n            while min_heap and nums[min_heap[-1]] >nums[i]:\n                min_heap.pop()\n            while max_heap and nums[max_heap[-1]] <nums[i]:\n                max_heap.pop()\n            \n            while min_heap and abs(nums[min_heap[0]] - nums[i]) >limit:\n                far = max(far,min_heap.popleft())\n            while max_heap and abs(nums[max_heap[0]] - nums[i]) >limit:\n                far = max(far,max_heap.popleft())\n            \n            res = max(res,i-far)\n            \n            min_heap.append(i)\n            max_heap.append(i)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        #naive method in n2\n        #keep track of min and max\n        #sliding window: only when exceed limit then contract window\n        \n        \n        if not nums:\n            return 0\n        \n        minDeque = collections.deque()\n        maxDeque = collections.deque()\n        maxlength = 0\n        left = 0 \n        right = 0\n        \n        while right< len(nums):#not equal sign\n            while maxDeque and nums[right] > nums[maxDeque[-1]]:\n                maxDeque.pop()\n                #decreasign deque           \n            maxDeque.append(right)\n            \n            while minDeque and nums[right] < nums[minDeque[-1]]:\n                minDeque.pop()\n            minDeque.append(right)\n            \n            #it won't be empty, because the \\\"curr\\\" element will always be valid\n            while abs(nums[maxDeque[0]] - nums[minDeque[0]]) >limit:\n                if maxDeque[0] == left:\n                    maxDeque.popleft()\n                if minDeque[0] == left:\n                    minDeque.popleft()\n                left += 1\n                \n            maxlength = max(maxlength, right-left+1)\n            right += 1\n            \n        return maxlength", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minHeap =  []\n        maxHeap = []\n        \n        l = 0 \n        \n        maxSize = 0 \n        \n        for r,num in enumerate(nums):\n            heappush(minHeap, (num, r))\n            heappush(maxHeap, (-num, r))\n            \n            minElement, minIndex = minHeap[0]\n            maxElement, maxIndex = maxHeap[0]\n            \n            maxElement = -maxElement \n            \n            while maxElement - minElement > limit: \n                l+=1\n                \n                while minHeap[0][1] < l:\n                    heappop(minHeap)\n                    \n                while maxHeap[0][1] < l:\n                    heappop(maxHeap)\n                    \n                minElement, minIndex = minHeap[0]\n                maxElement, maxIndex = maxHeap[0]\n                \n                maxElement = -maxElement \n                \n            curSize = r-l+1\n            \n            maxSize = max(curSize, maxSize)\n            \n        return maxSize ", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        import heapq\n        mnq, mxq = [], []\n        res = 0\n        left = 0\n        for right, num in enumerate(nums):\n            heapq.heappush(mnq, (num, right))\n            heapq.heappush(mxq, (-num, right))\n            \n            while -mxq[0][0] - mnq[0][0] > limit:\n                left = min(mnq[0][1], mxq[0][1]) + 1\n                while mxq[0][1] < left:\n                    heapq.heappop(mxq)\n                while mnq[0][1] < left:\n                    heapq.heappop(mnq)\n            res = max(res, right - left + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxHeap = []\n        minHeap = []\n        ans = 0\n        i = 0\n        for j in range(len(nums)):\n            heapq.heappush(maxHeap, (-nums[j], j))\n            heapq.heappush(minHeap, (nums[j], j))\n            \n            while -maxHeap[0][0] - minHeap[0][0] > limit:\n                i = min(maxHeap[0][1], minHeap[0][1]) + 1\n                \n                while maxHeap[0][1] < i:\n                    heapq.heappop(maxHeap)\n                while minHeap[0][1] < i:\n                    heapq.heappop(minHeap)\n            ans = max(ans, j - i +1)\n        return ans\n", "import collections\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minDeque = collections.deque()\n        maxDeque = collections.deque()\n        \n        start = end = 0\n        \n        ans = 0\n        \n        while end < len(nums):\n            # print(start, end, ans)\n            n = nums[end]\n            while len(minDeque)>0 and nums[minDeque[-1]]>=n:\n                minDeque.pop()\n            \n            minDeque.append(end)\n            \n            while len(maxDeque)>0 and nums[maxDeque[-1]]<=n:\n                maxDeque.pop()\n            \n            maxDeque.append(end)\n            \n            \n            \n            if (nums[maxDeque[0]] - nums[minDeque[0]]) > limit:\n                start+=1\n                \n                while len(minDeque)>0 and minDeque[0]<start:\n                    minDeque.popleft()\n                    \n                while len(maxDeque)>0 and maxDeque[0]<start:\n                    maxDeque.popleft()\n            else:\n                ans = max(ans, (end-start)+1)\n                end+=1\n                    \n        return ans", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minheap,maxheap = [],[]\n        start = 0\n        res = 0\n        for j,elem in enumerate(nums):\n            heapq.heappush(minheap,(elem,j))\n            heapq.heappush(maxheap,(-elem,j))\n            while - maxheap[0][0] - minheap[0][0] > limit:\n                start = min(minheap[0][1],maxheap[0][1]) + 1\n                while maxheap[0][1]<start: \n                    heapq.heappop(maxheap)\n                while minheap[0][1]< start:\n                    heapq.heappop(minheap)\n            res = max(res,j-start+1)\n        return res\n                \n                    \n                    \n                    \n                    \n                    \n            \n            \n            \n            \n                \n                \n                \n            \n    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # we have to maintain two min/max heaps with both value and index\n        # slide right if subarray is still valid\n        # slide left until subarray is valid again: if min/max value's index is earlier than left, then pop it out\n        n = len(nums)\n        i, j, ans = 0, 0, 0\n        min_heap, max_heap = [], []\n        heapq.heapify(min_heap)\n        heapq.heapify(max_heap)\n        while i <= j < n:\n            heapq.heappush(min_heap, (nums[j], j))\n            heapq.heappush(max_heap, (-nums[j], j))\n            while i <= j < n and -max_heap[0][0]-min_heap[0][0] > limit:\n                i += 1\n                while min_heap and min_heap[0][1] < i:\n                    heapq.heappop(min_heap)\n                while max_heap and max_heap[0][1] < i:\n                    heapq.heappop(max_heap)\n            ans = max(ans, j-i+1)\n            j += 1\n        return ans", "import heapq\n\n# minMaxQueue:\n# max 4 5\n# min 4 3 3 2\n#     queue: [1, 6, 8, 2, 2]\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        longest = 0\n        mins = []\n        maxs = []\n        start = 0\n        i = 0\n        while i < len(nums):\n            x = nums[i]\n            heapq.heappush(mins, (x, i))\n            heapq.heappush(maxs, (-x, i))\n            \n            currMin, currMax = mins[0][0], -(maxs[0][0])\n            while mins and maxs and currMax - currMin > limit:\n                start += 1\n                while mins[0][1] < start:\n                    heapq.heappop(mins)\n                while maxs[0][1] < start:\n                    heapq.heappop(maxs)\n                \n                currMin, currMax = mins[0][0], -(maxs[0][0])\n            \n            longest = max(longest, i - start + 1)\n            i += 1\n            \n        return longest\n                    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minheap, maxheap = [], []        \n        res = 0\n        i = 0\n        for j,n in enumerate(nums):\n            heapq.heappush(minheap, (n, j))\n            heapq.heappush(maxheap, (-n, j))\n            while -maxheap[0][0] - minheap[0][0] > limit:\n                i = min(maxheap[0][1], minheap[0][1]) + 1\n                while maxheap[0][1] < i: heapq.heappop(maxheap)\n                while minheap[0][1] < i: heapq.heappop(minheap)\n            res = max(res, j - i + 1)\n        return res", "import heapq\n\n# minMaxQueue:\n# max 4 5\n# min 4 3 3 2\n#     queue: [1, 6, 8, 2, 2]\n\nclass Solution:\n#     O(N) time | O(N) space\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        longest = 0\n        mins = []\n        maxs = []\n        start = 0\n        i = 0\n        while i < len(nums): # O(N)\n            x = nums[i]\n            heapq.heappush(mins, (x, i)) # O()\n            heapq.heappush(maxs, (-x, i)) # O()\n            \n            currMin, currMax = mins[0][0], -(maxs[0][0])\n            while mins and maxs and currMax - currMin > limit:\n                start += 1\n                while mins[0][1] < start:\n                    heapq.heappop(mins)\n                while maxs[0][1] < start:\n                    heapq.heappop(maxs)\n                \n                currMin, currMax = mins[0][0], -(maxs[0][0])\n            \n            longest = max(longest, i - start + 1)\n            i += 1\n            \n        return longest\n                    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n    \n        maxq, minq = [], []\n        res = i = 0\n        for j, num in enumerate(nums):\n            heappush(maxq, (-num, j))\n            heappush(minq, (num, j))\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i:\n                    heappop(maxq)\n                while minq[0][1] < i:\n                    heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, A, limit):\n        M = collections.deque()\n        m = collections.deque()\n        i = 0\n        for a in A:\n            # a = A[j], A[i:j] is a candidate \n            # whose lenngth is j-i\n            # whose max is M[0] and min is m[0]\n            # if its max - min > limit we shrink the window\n            # if max or min changed we pop M and m from the left\n            while M and a > M[-1]: M.pop()\n            while m and a < m[-1]: m.pop()\n            M.append(a)\n            m.append(a)\n            if M[0] - m[0] > limit:\n                if M[0] == A[i]: M.popleft()\n                if m[0] == A[i]: m.popleft()\n                i += 1\n        return len(A) - i", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums or len(nums) == 0:\n            return 0\n        minDeque = deque()\n        maxDeque = deque()\n        left = 0\n        right = 0\n        result = 0\n        while right < len(nums):\n            # Maintain minDeque\n            while minDeque and nums[right] < nums[minDeque[-1]]:\n                minDeque.pop()\n            while maxDeque and nums[right] > nums[maxDeque[-1]]:\n                maxDeque.pop()\n            minDeque.append(right)\n            maxDeque.append(right)\n            while nums[maxDeque[0]] - nums[minDeque[0]] > limit:\n                while maxDeque[0] <= left:\n                    maxDeque.popleft()\n                while minDeque[0] <= left:\n                    minDeque.popleft()\n                left += 1\n            result = max(result, right - left + 1)\n            right += 1\n        return result", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        n = len(nums)\n        i = j = 0\n        curr_max = curr_min = nums[0]\n        maxes = [(-curr_max, 0)]\n        mins = [(curr_min, 0)]\n        best = 0\n        \n        while i <= j < n:\n            # print(\\\"i\\\", i, \\\"j\\\", j, \\\"max:\\\", -maxes[0][0], \\\"at idx\\\", maxes[0][1], \\\"min:\\\", mins[0][0], \\\"at idx\\\", mins[0][1])\n            \n            # advance j until difference exceeds limit\n            if abs(-maxes[0][0] - mins[0][0]) <= limit:\n                best = max(best, j-i+1)\n                j += 1\n                \n                if j < n:\n                    heapq.heappush(maxes, (-nums[j], j))\n                    heapq.heappush(mins, (nums[j], j))\n            else:\n                i += 1\n                \n                # lazily remove all values outside of the window\n                while not i <= maxes[0][1] <= j:\n                    heapq.heappop(maxes)\n                while not i <= mins[0][1] <= j:\n                    heapq.heappop(mins)\n                \n        \n        return best", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ans = 1\n        i = j = 0\n        minHeap = [(nums[0], 0)]\n        maxHeap = [(-nums[0], 0)]\n        while(j < len(nums)):\n            while(minHeap[0][1] < i):\n                heapq.heappop(minHeap)\n            while(maxHeap[0][1] < i):\n                heapq.heappop(maxHeap)\n            if(-maxHeap[0][0]-minHeap[0][0] > limit):\n                i += 1\n            else:\n                j += 1\n                ans = max(ans, j-i)\n                if(j < len(nums)):\n                    heapq.heappush(minHeap, (nums[j], j))\n                    heapq.heappush(maxHeap, (-nums[j], j))\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        if len(nums)<=1:\n            return len(nums)\n        \n        queue = [nums[0]]\n        small = queue[0]\n        large = queue[0]\n        \n        ans = 1\n        \n        for i in range(1, len(nums)):\n            \n            if abs(nums[i]-small)<=limit and abs(nums[i]-large)<=limit:\n                queue.append(nums[i])\n                small = min(small, nums[i])\n                large = max(large, nums[i])\n                ans = max(ans, len(queue))\n                                \n            else:\n                \n                if ans>len(nums)//2:\n                    break\n                \n                while queue and not(abs(nums[i]-small)<=limit and abs(nums[i]-large)<=limit):\n                    queue.pop(0)\n                    if queue:\n                        small = min(queue)\n                        large = max(queue)\n                    else:\n                        break\n                \n                if queue:\n                    queue.append(nums[i])\n                    small = min(queue)\n                    large = max(queue)\n                else:\n                    queue = [nums[i]]\n                    small = nums[i]\n                    large = nums[i]\n            \n        return ans\n", "class Solution:\n    # def longestSubarray(self, nums: List[int], limit: int) -> int:\n    #     start=0\n    #     end=1\n    #     result=1\n    #     while end<len(nums):\n    #         tmp=nums[end]\n    #         flag=0\n    #         for i in range(start,end):\n    #             if abs(nums[i]-tmp)>limit:\n    #                 flag=1\n    #                 start=i\n    #         if flag==0:\n    #             if end-start+1>result:\n    #                 result=end-start+1\n    #             end+=1\n    #         else:\n    #             start+=1\n    #     return result\n    def longestSubarray(self, A, limit):\n            maxq, minq = [], []\n            res = i = 0\n            for j, a in enumerate(A):\n                heapq.heappush(maxq, [-a, j])\n                heapq.heappush(minq, [a, j])\n                while -maxq[0][0] - minq[0][0] > limit:\n                    i = min(maxq[0][1], minq[0][1]) + 1\n                    while maxq[0][1] < i: heapq.heappop(maxq)\n                    while minq[0][1] < i: heapq.heappop(minq)\n                res = max(res, j - i + 1)\n            return res\n", "# lame implementation of random removal in min/max heaps, but i saw \n# phorum solutions about monotonic queues, quite interesting!\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        minh = []\n        maxh = []\n        start = 0\n        ans = 0\n        deleted = set()\n        for end in range(n):\n            x = nums[end]\n            heappush(minh, (x, end))\n            heappush(maxh, (-x, end))\n            while minh and minh[0][1] in deleted:\n                heappop(minh)\n            while maxh and maxh[0][1] in deleted:\n                heappop(maxh)                \n            while minh and maxh and -maxh[0][0] - minh[0][0] > limit and start <= end:\n                deleted.add(start)\n                start += 1\n                while minh and minh[0][1] in deleted:\n                    heappop(minh)\n                while maxh and maxh[0][1] in deleted:\n                    heappop(maxh)                                \n            ans = max(ans, end - start + 1)\n        return ans\n                \n", "class Solution:\n    def longestSubarray(self, A, limit):\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(A):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # HEAP SLIDING WINDOW SOLUTION\n        max_heap, min_heap = [], []\n        res = 0\n        l = 0\n        \n        for r, a in enumerate(nums):\n            heapq.heappush(max_heap, [-a, r])\n            heapq.heappush(min_heap, [a, r])\n            \n            while -max_heap[0][0] - min_heap[0][0] > limit:\n                # we need to kick all the elments before left pointer\n                while max_heap[0][1] <= l:\n                    heapq.heappop(max_heap)\n                \n                while min_heap[0][1] <= l:\n                    heapq.heappop(min_heap)\n                \n                l += 1\n                \n            res = max(res, r - l + 1)\n            \n        return res\n", "class Solution:\n    def longestSubarray(self, A: List[int], limit: int) -> int:\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while maxd and a > maxd[-1]: maxd.pop()\n            while mind and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: maxd.popleft()\n                if mind[0] == A[i]: mind.popleft()\n                i += 1\n        return len(A) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # HEAP SLIDING WINDOW SOLUTION\n        max_heap, min_heap = [], []\n        res = 0\n        l = 0\n        \n        for r, a in enumerate(nums):\n            heapq.heappush(max_heap, [-a, r])\n            heapq.heappush(min_heap, [a, r])\n            \n            while -max_heap[0][0] - min_heap[0][0] > limit:\n                while max_heap[0][1] <= l:\n                    heapq.heappop(max_heap)\n                \n                while min_heap[0][1] <= l:\n                    heapq.heappop(min_heap)\n                \n                l += 1\n                \n            res = max(res, r - l + 1)\n            \n        return res\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ans = 0\n        maxq, minq = [], []\n        i = 0\n        for num in nums:\n            while maxq and maxq[-1] < num:\n                maxq.pop()\n            while minq and minq[-1] > num:\n                minq.pop()\n            maxq.append(num)\n            minq.append(num)\n            if maxq[0] - minq[0] > limit:\n                if maxq[0] == nums[i]:\n                    maxq.pop(0)\n                if minq[0] == nums[i]:\n                    minq.pop(0)\n                i += 1\n        \n        return len(nums) - i\n            \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        hmin, hmax = [], []\n        heapq.heapify(hmin), heapq.heapify(hmax)\n        max_length = 0\n        i,j = 0, 0\n        heapq.heappush(hmin, (nums[0],0)), heapq.heappush(hmax, (-1*nums[0],0))\n        while j<len(nums):\n            while hmax[0][1]<i: heapq.heappop(hmax)\n            while hmin[0][1]<i: heapq.heappop(hmin)\n            if -1*(hmax[0][0]+hmin[0][0])<=limit: \n                max_length = max(max_length, j-i+1)\n                j+=1\n                if j>=len(nums): break\n                heapq.heappush(hmin, (nums[j], j))\n                heapq.heappush(hmax, (-1*nums[j], j))\n            else:\n                i+=1\n        return max_length", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        maxheap, minheap = [(-nums[0], 0)], [(nums[0], 0)]\n        \n        l, maxindex, res  = 0, 0, 1\n        for i, val in enumerate(nums[1:], 1): \n               \n            if val - minheap[0][0] <= limit and - maxheap[0][0] -val <= limit:\n                res = max(res, i - maxindex + 1)\n            else:\n                \n                while minheap and val - minheap[0][0] > limit:\n                    v, index = heapq.heappop(minheap)\n                    maxindex = max(maxindex, index + 1)\n                while maxheap and -maxheap[0][0] - val > limit:\n                    v, index = heapq.heappop(maxheap)\n                    maxindex = max(maxindex, index + 1)\n            \n            heapq.heappush(minheap, (val, i))\n            heapq.heappush(maxheap, (-val, i))\n        \n            \n        return res \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maximums = [(-nums[0], 0, )]\n        minimums = [(nums[0], 0, )]\n        left = 0 if len(nums) > 1 else 1\n        right = 1\n        \n        \n        while (right < len(nums)):\n            heapq.heappush(maximums, (-nums[right], right, ))\n            heapq.heappush(minimums, (nums[right], right, ))\n            right += 1\n            \n            \n            while (maximums[0][1] < left):\n                heapq.heappop(maximums)\n                \n                \n            while (minimums[0][1] < left):\n                heapq.heappop(minimums)\n            \n            \n            while (-maximums[0][0] - minimums[0][0] <= limit and right < len(nums)):\n                heapq.heappush(maximums, (-nums[right], right, ))\n                heapq.heappush(minimums, (nums[right], right, ))\n                right += 1\n                \n            left += 1\n            \n            \n        if (-maximums[0][0] - minimums[0][0] <= limit):\n            return right - left + 1\n        else:\n            return right - left", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        l, r = 0, 0\n        res = 0\n        for r in range(len(nums)):\n            heapq.heappush(maxq, [-nums[r], r])\n            heapq.heappush(minq, [nums[r], r])\n            while -maxq[0][0] - minq[0][0] > limit:\n                # condition not satisfied, move left pointer ahead\n                l = min(maxq[0][1], minq[0][1])+1\n                #all values before left pointer are now useless\n                while maxq[0][1] < l:\n                    heapq.heappop(maxq)\n                while minq[0][1] < l:\n                    heapq.heappop(minq)\n            res = max(res, r-l+1)\n        return res\n", "from heapq import heapify , heappop , heappush\nclass Solution:\n    def longestSubarray(self, lis: List[int], limit: int) -> int:\n        n = len(lis)\n        miheap=[]\n        mxheap=[]\n        heapify(miheap)\n        heapify(mxheap)\n        ans=1\n        heappush(miheap,[lis[0],0])\n        heappush(mxheap,[-lis[0],0])\n        tmp=0\n        for i in range(1,n):\n            heappush(miheap,[lis[i],i])\n            heappush(mxheap,[-lis[i],i])\n            while miheap and abs(miheap[0][0]+mxheap[0][0])>limit:\n                tmp = min(mxheap[0][1], miheap[0][1]) + 1\n                while mxheap[0][1] < tmp: heapq.heappop(mxheap)\n                while miheap[0][1] < tmp: heapq.heappop(miheap)\n            ans = max(ans,i-tmp+1)\n            #print(miheap,mxheap)\n        return ans\n            \n            \n        \n", "class Solution:\n    def longestSubarray(self, A: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(A):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "# can get a o(n logn runtime)\n# use min and max heaps \n\nfrom heapq import *\nfrom collections import Counter\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        min_heap = []\n        max_heap = []\n        \n        lazy_delete_min_heap = Counter()\n        lazy_delete_max_heap = Counter()\n        \n        l = 0\n        longest = 0\n        for r in range(len(nums)):\n            heappush(min_heap, nums[r])\n            heappush(max_heap, -nums[r])\n                \n            while abs(nums[r] - min_heap[0]) > limit or abs(nums[r] + max_heap[0]) > limit:\n                \n                lazy_delete_min_heap[nums[l]] += 1\n                lazy_delete_max_heap[nums[l]] += 1\n                \n                while lazy_delete_min_heap[min_heap[0]] > 0:\n                    lazy_delete_min_heap[min_heap[0]] -= 1\n                    heappop(min_heap)\n                \n                while lazy_delete_max_heap[-max_heap[0]] > 0:\n                    lazy_delete_max_heap[-max_heap[0]] -= 1\n                    heappop(max_heap)\n                \n                l += 1\n                \n            longest = max(longest, r - l + 1)\n                \n        return longest\n    \n    \n    \n    \n    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        res = 0\n        maxq = []\n        minq = []\n        j = 0\n        for i,n in enumerate(nums):\n            heapq.heappush(maxq, [-n,i] )\n            heapq.heappush(minq, [n,i] )\n            \n            while -maxq[0][0] - minq[0][0] > limit:\n                ind = min( maxq[0][1], minq[0][1] )\n                while maxq[0][1] <= ind:\n                    heapq.heappop(maxq)\n                while minq[0][1] <= ind:\n                    heapq.heappop(minq)\n                j = ind+1\n            res = max(res, i - j +1 )\n            \n        return res\n                \n        \n        \n        \n        \n        \n#         res = 0\n        \n#         i = 0\n#         arr = [] # space O(res)\n#         for n in nums:  # O(n) time\n#             bisect.insort(arr, n) # O(res)\n#             while arr[-1] - arr[0] > limit:\n#                 ind = bisect.bisect_right(arr, nums[i])  # O( log res )\n#                 arr.pop(ind-1)  # O(res)\n#                 i += 1\n#             res = max(res, len(arr))\n            \n#         return res\n                \n        \n        \n        \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minq,maxq = [],[]\n        l = 0\n        res = 0\n        for i in range(len(nums)):\n            heapq.heappush(minq,[nums[i],i])\n            heapq.heappush(maxq,[-nums[i],i])\n            while -maxq[0][0] - minq[0][0] > limit:\n                l = min(maxq[0][1], minq[0][1])+1\n                while maxq[0][1] < l:\n                    heapq.heappop(maxq)\n                while minq[0][1] < l:\n                    heapq.heappop(minq)\n            res = max(res,i-l+1)\n        return res", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            #res = max(res, j-i+1)\n        return len(nums) - i", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res\n            \n        \n            \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque, max_deque = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\n                min_deque.pop()\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            if nums[max_deque[0]] - nums[min_deque[0]] <= limit:\n                ans = max(ans, r - l + 1)\n                r += 1\n            elif nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                while min_deque[0] <= l:\n                    min_deque.popleft()\n                while max_deque[0] <= l:\n                    max_deque.popleft()\n                l += 1\n                \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq=[]\n        minq=[]\n        res=0\n        i=0\n        for j,c in enumerate(nums):\n            heapq.heappush(maxq,[-c,j])\n            heapq.heappush(minq,[c,j])\n            while -maxq[0][0]-minq[0][0]>limit:\n                i=min(maxq[0][1],minq[0][1])+1\n                while maxq[0][1]<i:\n                    heapq.heappop(maxq)\n                while minq[0][1]<i:\n                    heapq.heappop(minq)\n            res=max(res,j-i+1)\n        return res\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         minheap=[]\n#         maxheap=[]\n#         heapq.heapify(minheap)\n#         heapq.heapify(maxheap)\n#         length=1\n#         i=0\n#         j=1\n#         heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n#         heapq.heappush(maxheap,[-nums[0],0])\n#         while j < len(nums):\n#             if nums[j]-minheap[0][0]<=limit and maxheap[0][0]*-1-nums[j]<= limit:\n#                 length=max(length,j-i+1)\n#                 heapq.heappush(minheap,[nums[j],j])\n#                 heapq.heappush(maxheap,[-nums[j],j])\n#                 j=j+1\n#             else:\n#                 while len(minheap)>0 and nums[j]-minheap[0][0]>limit:\n#                     ele,index=heapq.heappop(minheap)\n#                     i=max(i,index + 1)\n#                 while len(maxheap)>0 and -maxheap[0][0]-nums[j]>limit:\n#                     ele,index=heapq.heappop(maxheap)\n#                     i=max(i,index + 1)\n#                 # i=maxindex+1   # update i and now  we are not concerned with element before ith index\n#                 heapq.heappush(minheap,[nums[j],j]) # add  element and its index\n#                 heapq.heappush(maxheap,[-nums[j],j])\n#                 j=j+1\n            \n#         return length\n        begin = end = 0\n        l = len(nums)\n        d = 0\n        \n        heap_min = []\n        heap_max = []\n        \n        heapq.heapify(heap_min)\n        heapq.heapify(heap_max)\n        \n        while end < l:\n            heapq.heappush(heap_min, (nums[end], end))\n            heapq.heappush(heap_max, (-1 * nums[end], end))\n            \n            while len(heap_min) > 0 and nums[end] - heap_min[0][0] > limit:\n                value, idx = heapq.heappop(heap_min)\n                begin = max(begin, idx + 1)\n            \n            while len(heap_max) > 0 and -heap_max[0][0] - nums[end] > limit:\n                value, idx = heapq.heappop(heap_max)\n                begin = max(begin, idx + 1)\n            \n            if end - begin + 1 > d:\n                d = end - begin + 1\n            \n            end += 1\n        return d", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        N = len(nums)\n        if N == 0:\n            return 0\n\n        minQ = []\n        maxQ = []\n\n        l = 0\n        maxL = 0\n        for r in range(N):\n            num = nums[r]\n\n            idx_rightmost = l - 1\n            while minQ and (num - minQ[0][0] > limit or minQ[0][1]<=idx_rightmost):\n                [val,idx] = heapq.heappop(minQ)\n                idx_rightmost = max(idx_rightmost,idx)\n\n            while maxQ and (-maxQ[0][0] - num > limit or maxQ[0][1]<=idx_rightmost):\n                [val,idx] = heapq.heappop(maxQ)\n                idx_rightmost = max(idx_rightmost,idx)        \n            l = idx_rightmost + 1        \n            heapq.heappush(minQ, [nums[r],r])\n            heapq.heappush(maxQ, [-nums[r],r])\n            maxL = max(maxL, r-l+1)\n\n        return maxL\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        small = []\n        large = []\n        res = 1\n        left = 0\n        for i in range(len(nums)):\n            while small and nums[small[-1]] > nums[i]:\n                small.pop()\n            while large and nums[large[-1]] < nums[i]:\n                large.pop()\n            small.append(i)\n            large.append(i)\n            if small and large and nums[large[0]] - nums[small[0]] > limit:\n                left += 1\n                if small[0] < left:\n                    small.pop(0)\n                if large[0] < left:\n                    large.pop(0)\n            res = max(res, i-left+1)\n        return res", "import heapq\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: \n                    heapq.heappop(maxq)\n                while minq[0][1] < i: \n                    heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        # sliding window, but we only need to keep the min and max in this window along with the index. at the same time, we set a variable, to check what is the window starting point, we will do\n        length = len(nums)\n        start = 0\n        min_heap = []\n        max_heap = []\n        \n        res = 1\n        for i, num in enumerate(nums):\n            heapq.heappush(min_heap, (num, -i))\n            heapq.heappush(max_heap, (-num, -i))\n            # while -min_heap[0][1] < start:\n            #     heapq.heappop(min_heap)\n            # while -max_heap[0][1] < start:\n            #     heapq.heappop(max_heap)\n           \n            ### bug bug here: \u52a0\u5165\u51fa\u73b0\u73b0\u5728\u7684number\u5bfc\u81f4\u8d85\u8fc7\u4e86limit\uff0c\u90a3\u4e48\u4f60\u9700\u8981\u4e00\u76f4\u79fb\u52a8\u81ea\u52a8\u4f60\u627e\u5230\u4e00\u4e2aindex\uff1b\n            while -max_heap[0][0] - min_heap[0][0] > limit:\n                start += 1\n                while -min_heap[0][1] < start:\n                    heapq.heappop(min_heap)\n                while -max_heap[0][1] < start:\n                    heapq.heappop(max_heap)\n\n  \n            res = max(res, i - start + 1)\n\n        return res ", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minQue = deque()\n        maxQue = deque()\n        start, end = 0, 0\n        longest = 1\n        while end < len(nums):\n            current = nums[end]\n            while minQue and nums[minQue[-1]] >= current:\n                minQue.pop()\n            minQue.append(end)\n            while maxQue and nums[maxQue[-1]] <= current:\n                maxQue.pop()\n            maxQue.append(end)\n            if nums[maxQue[0]] - nums[minQue[0]] > limit:\n                start += 1\n                while maxQue and start > maxQue[0]:\n                    maxQue.popleft()\n                while minQue and start > minQue[0]:\n                    minQue.popleft()\n            else:\n                longest = max(longest, end - start + 1)\n                end += 1\n        return longest\n                \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        from collections import deque\n        mnq = deque([])\n        mxq = deque([])\n        left = 0\n        \n        for right, num in enumerate(nums):\n            while mxq and mxq[-1] < num:\n                mxq.pop()\n            while mnq and mnq[-1] > num:\n                mnq.pop()\n            mxq.append(num)\n            mnq.append(num)\n            if mxq[0] - mnq[0] > limit:\n                if mxq[0] == nums[left]:\n                    mxq.popleft()\n                if mnq[0] == nums[left]:\n                    mnq.popleft()\n                left += 1\n        return len(nums) - left", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n# Solution 1: Use two heaps\n# Time O(NogN)\n# Space O(N)\n\n\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "from collections import deque\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        hq = deque()\n        hq.append([nums[0], 0])\n        lq = deque()\n        lq.append([nums[0], 0])\n        l = 0\n        \n        ans = 1\n        for i in range(1, len(nums)):\n            n = nums[i]\n            while hq[0][1] < l:\n                hq.popleft()\n            while lq[0][1] < l:\n                lq.popleft()\n                \n            while hq and hq[-1][0] <= n:\n                hq.pop()\n            else:\n                hq.append([n, i])\n            \n            while lq and lq[-1][0] >= n:\n                lq.pop()\n            else:\n                lq.append([n, i])\n                \n            if hq[0][0] - n > limit:\n                ans = max(ans, i - l)\n                while hq[0][0] - n > limit:\n                    l = hq[0][1] + 1\n                    hq.popleft()\n            elif n - lq[0][0] > limit:\n                ans = max(ans, i - l)\n                while n - lq[0][0] > limit:\n                    l = lq[0][1] + 1\n                    lq.popleft()\n            else:\n                ans = max(ans, i - l + 1)\n            \n        return ans\n", "class Solution:\n    def longestSubarray(self, A: List[int], limit: int) -> int:\n        import heapq\n        maxd = []\n        mind = []\n        res = i = 0\n        \n        for j, a in enumerate(A):\n            heapq.heappush(maxd, [-a, j])\n            heapq.heappush(mind, [a, j])\n            while - maxd[0][0] - mind[0][0] > limit:\n                i = min(maxd[0][1], mind[0][1]) + 1\n                while maxd[0][1] < i: heapq.heappop(maxd)\n                while mind[0][1] < i: heapq.heappop(mind)\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        begin, end = 0, 0\n        n = len(nums)\n        \n        heap_min = []\n        heapq.heapify(heap_min)\n        heap_max = []\n        heapq.heapify(heap_max)\n        \n        heapq.heappush(heap_min, (nums[0], 0))\n        heapq.heappush(heap_max, (-nums[0], 0))\n        \n        max_length = 1\n        while end < n - 1:\n            end += 1\n            if abs(nums[end] - heap_min[0][0]) > limit or abs(-heap_max[0][0] - nums[end]) > limit: # Need to know the min and max\n                # Make it valid!\n                while len(heap_min) > 0 and nums[end] - heap_min[0][0] > limit:\n                    value, idx = heapq.heappop(heap_min)\n                    begin = max(begin, idx + 1)\n                while len(heap_max) > 0 and -heap_max[0][0] - nums[end] > limit:\n                    value, idx = heapq.heappop(heap_max)\n                    begin = max(begin, idx + 1)\n            \n            heapq.heappush(heap_min, (nums[end], end))\n            heapq.heappush(heap_max, (-nums[end], end))\n\n            max_length = max(max_length, end - begin + 1)\n            \n        return max_length", "'''\n1. example: [8,2,4,7]\n\n- Subarrays can be created by taking one element at a time and moving forward\n- difference can be found by finding the difference between two elements in the array. \n\n\n\n'''\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res\n            \n                        \n            \n            \n                \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        res = i = 0\n        maxh = []\n        minh = []\n        for j, val in enumerate(nums):\n            heapq.heappush(maxh, [-val, j])\n            heapq.heappush(minh, [val, j])\n            while -maxh[0][0] - minh[0][0] > limit:\n                i = min(maxh[0][1], minh[0][1]) + 1\n                while maxh[0][1] < i:\n                    heapq.heappop(maxh)\n                while minh[0][1] < i:\n                    heapq.heappop(minh)\n            res = max(res, j - i + 1)\n        return res\n                \n            \n        \n        \n", "class minMonotonicQueue(object):\n    \n    def __init__(self):\n        self.queue = collections.deque([]) # non-descreasing\n    \n    def push(self, num, idx):\n        while len(self.queue) != 0 and self.queue[-1][0] > num:\n            self.queue.pop()\n        self.queue.append((num, idx))\n    \n    def pop(self, idx):\n        if self.queue[0][1] == idx:\n            self.queue.popleft()\n    \nclass maxMonotonicQueue(object):\n    \n    def __init__(self):\n        self.queue = collections.deque([]) # non-increasing\n    \n    def push(self, num, idx):\n        while len(self.queue) != 0 and self.queue[-1][0] < num:\n            self.queue.pop()\n        self.queue.append((num, idx))    \n        \n    def pop(self, idx):\n        if self.queue[0][1] == idx:\n            self.queue.popleft()\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ptr1, ptr2 = 0, 0\n        res = 0\n        minQ, maxQ = minMonotonicQueue(), maxMonotonicQueue()\n        while ptr1 < len(nums) and ptr2 < len(nums):\n            \n            # push  \n            minQ.push(nums[ptr2], ptr2)\n            maxQ.push(nums[ptr2], ptr2)\n            \n            # print (ptr1, ptr2, minQ.queue, maxQ.queue)\n            while maxQ.queue[0][0] - minQ.queue[0][0] > limit:\n                ptr1 += 1\n                \n                if ptr1 > maxQ.queue[0][1]:\n                    maxQ.pop(maxQ.queue[0][1])\n                \n                if ptr1 > minQ.queue[0][1]:\n                    minQ.pop(minQ.queue[0][1])\n            \n                # print ('*', ptr1, ptr2, minQ.queue, maxQ.queue)\n            res = max(res, ptr2 - ptr1 + 1)\n            ptr2 += 1\n        return res\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        res = 1\n        \n        slow = 0\n        fast = 0\n        min_queue = deque()\n        max_queue = deque()\n        while fast < len(nums):\n            while min_queue and nums[fast] <= nums[min_queue[-1]]:\n                min_queue.pop()\n            while max_queue and nums[fast] >= nums[max_queue[-1]]:\n                max_queue.pop()\n            min_queue.append(fast)\n            max_queue.append(fast)\n            # print(min_queue, max_queue)\n            while nums[max_queue[0]] - nums[min_queue[0]] > limit:\n                slow += 1\n                if max_queue[0] < slow:\n                    max_queue.popleft()\n                if min_queue[0] < slow:\n                    min_queue.popleft()\n            \n            res = max(res, fast - slow + 1)\n            fast += 1\n        return res\n", "class Solution:\n    def longestSubarray(self, A, limit):\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(A):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res\n            \n                \n            \n            \n            \n                \n                \n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                elif minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_q = deque()\n        min_q = deque()\n        left = 0\n        \n        result = 0\n        for i, n in enumerate(nums):\n            while max_q and nums[max_q[-1]] <= n:\n                max_q.pop()\n            max_q.append(i)\n            \n            while min_q and nums[min_q[-1]] >= n:\n                min_q.pop()\n            min_q.append(i)\n            \n            while left < i and nums[max_q[0]] - nums[min_q[0]] > limit:\n                if left == max_q[0]:\n                    max_q.popleft()\n                if left == min_q[0]:\n                    min_q.popleft()\n                    \n                left += 1\n            \n            result = max(result, i - left + 1)\n        return result", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq = []\n        minq = []\n        left = 0\n        res = 0\n        for right,num in enumerate(nums):\n            heapq.heappush(maxq, [-num, right])\n            heapq.heappush(minq, [num, right])\n            \n            while - maxq[0][0] - minq[0][0] > limit:\n                left = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < left:\n                    heapq.heappop(maxq)\n                while minq[0][1] < left:\n                    heapq.heappop(minq)\n            res = max(res, right - left + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # dp = [[0 for _ in range(len(nums))] for _ in range(len(nums))]\n        # result = 1\n        # for i in range(len(nums)-2, -1, -1):\n        #     for j in range(i+1, len(nums)):\n        #         dp[i][j] = max(dp[i][j-1], dp[i+1][j] ,abs(nums[i] - nums[j]))\n        #         # print(dp[i][j])\n        #         if dp[i][j] <= limit:\n        #             result = max(result, j - i + 1)\n        # return result\n    \n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            # print(maxq, minq)\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n            # print(maxq)\n            # print(minq)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for pos, val in enumerate(nums):\n            heapq.heappush(maxq, [-val, pos])\n            heapq.heappush(minq, [val, pos])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, pos - i + 1)\n        return res\n            \n                \n            \n            \n            \n                \n                \n", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        # sliding window, but we only need to keep the min and max in this window along with the index. at the same time, we set a variable, to check what is the window starting point, we will do\n        length = len(nums)\n        start = 0\n        min_heap = []\n        max_heap = []\n        \n        res = 1\n        for i, num in enumerate(nums):\n            heapq.heappush(min_heap, (num, -i))\n            heapq.heappush(max_heap, (-num, -i))\n            while -min_heap[0][1] < start:\n                heapq.heappop(min_heap)\n            while -max_heap[0][1] < start:\n                heapq.heappop(max_heap)\n            # if num == 96:\n            #     print(num)\n            \n            ### bug bug here: \u52a0\u5165\u51fa\u73b0\u73b0\u5728\u7684number\u5bfc\u81f4\u8d85\u8fc7\u4e86limit\uff0c\u90a3\u4e48\u4f60\u9700\u8981\u4e00\u76f4\u79fb\u52a8\u81ea\u52a8\u4f60\u627e\u5230\u4e00\u4e2aindex\uff1b\n            while -max_heap[0][0] - min_heap[0][0] > limit:\n                start += 1\n                while -min_heap[0][1] < start:\n                    heapq.heappop(min_heap)\n                while -max_heap[0][1] < start:\n                    heapq.heappop(max_heap)\n                # if num == min_heap[0][0]:\n                #     start = -max_heap[0][1]+1\n                # if num == -max_heap[0][0]:\n                #     start = -min_heap[0][1]+1\n  \n            res = max(res, i - start + 1)\n            #print(i, start, res) \n            #if num == 3:\n                #print(sorted(max_heap))\n                #print(sorted(min_heap))\n        return res ", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        best = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, (-a, j))\n            heapq.heappush(minq, (a, j))\n            while (-maxq[0][0] - minq[0][0]) > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            best = max(best, j -i + 1)\n        \n        return best\n                \n                \n                \n            \n            \n            \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxd, mind = collections.deque(), collections.deque()\n        l, r, res = 0, 0, 0\n        while r < len(nums):\n            while len(maxd) and maxd[-1] < nums[r]:\n                maxd.pop()\n            while len(mind) and mind[-1] > nums[r]:\n                mind.pop()\n            maxd.append(nums[r])\n            mind.append(nums[r])\n            while maxd[0] - mind[0] > limit:\n                if nums[l] == maxd[0]:\n                    maxd.popleft()\n                if nums[l] == mind[0]:\n                    mind.popleft()\n                l += 1\n            res = max(r-l+1, res)\n            r += 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        \n        left = 0\n        right = 0\n        \n\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        max_len = 1\n   \n        # while left <= right and right < len(nums):\n        for right in range(len(nums)):\n            curr_max = max(curr_max, nums[right])\n            curr_min = min(curr_min, nums[right])\n\n            if curr_max - curr_min <= limit:\n                max_len = max(max_len, right - left + 1)\n                \n            else:\n                if nums[left] == curr_max:\n                    \n                    curr_max = max(nums[left + 1: right + 1])\n            \n                if nums[left] == curr_min:\n                    curr_min = min(nums[left + 1: right + 1])\n                left += 1\n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        currmax = currmin = nums[0]\n        start = 0\n        res = 1\n        for i in range(1,len(nums)):\n            currmax = max(currmax,nums[i])\n            currmin = min(currmin,nums[i])\n            \n            if currmax - currmin <= limit:\n                res = max(res,i-start+1)\n            \n            else:\n                if currmax == nums[start]:\n                    currmax = max(nums[start+1:i+1])\n                if currmin == nums[start]:\n                    currmin = min(nums[start+1: i+1])\n                start += 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        \n        left = 0\n        right = 0\n        \n\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        max_len = 1\n   \n        # while left <= right and right < len(nums):\n        for right in range(len(nums)):\n            curr_max = max(curr_max, nums[right])\n            curr_min = min(curr_min, nums[right])\n\n            if curr_max - curr_min <= limit:\n                max_len = max(max_len, right - left + 1)\n                \n            else:\n                if nums[left] == curr_max:\n                    \n                    curr_max = max(nums[left + 1: right + 1])\n            \n                if nums[left] == curr_min:\n                    curr_min = min(nums[left + 1: right + 1])\n                left += 1\n            right += 1\n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        left=0\n        n=len(nums)\n        l=0\n        r=1\n        maxVal=nums[0]\n        minVal=nums[0]\n        res=1\n        while(l<r and r<n):\n            maxVal=max(maxVal,nums[r])\n            minVal=min(minVal,nums[r])\n            if(maxVal-minVal<=limit):\n                res=max(res,r-l+1)\n            else:\n                if(nums[l]==maxVal):\n                    maxVal=max(nums[l+1:r+1])\n                if(nums[l]==minVal):\n                    minVal=min(nums[l+1:r+1])\n                l+=1\n            r+=1\n        return res\n                \n                \n        return res\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_queue = collections.deque()\n        min_queue = collections.deque()\n        l = r = 0\n        max_len = 0\n        while r < len(nums):\n            while max_queue and nums[r] >= max_queue[-1][0]:\n                max_queue.pop()\n            max_queue.append((nums[r], r))\n            while min_queue and nums[r] <= min_queue[-1][0]:\n                min_queue.pop()\n            min_queue.append((nums[r], r))\n            r += 1\n            while max_queue[0][0] - min_queue[0][0] > limit:\n                l += 1\n                if max_queue[0][1] < l:\n                    max_queue.popleft()\n                if min_queue[0][1] < l:\n                    min_queue.popleft()\n            max_len = max(max_len, r - l)\n            \n                \n        return max_len\n            \n            \n                    \n                \n", "from heapq import heappush, heapify, heappop\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_subsize, right, left = 0, 0, 0\n        max_vals, min_vals = [], []\n        heapify(max_vals)\n        heapify(min_vals)\n        \n        while right < len(nums):\n            diff = max_vals[0][0] * -1 - min_vals[0][0] if max_vals and min_vals else 0\n            #print(diff, left, right)\n            if diff <= limit:\n                max_subsize = max(max_subsize, right - left)\n                heappush(min_vals, (nums[right], right))\n                heappush(max_vals, (nums[right] * -1, right))\n                right += 1\n            else:\n                left += 1\n                while max_vals and max_vals[0][1] < left:\n                    heappop(max_vals)\n                while min_vals and min_vals[0][1] < left:\n                    heappop(min_vals)\n            diff = max_vals[0][0] * -1 - min_vals[0][0] if max_vals and min_vals else 0\n            if diff <= limit:\n                max_subsize = max(max_subsize, right - left)\n        \n        return max_subsize", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minheap=[]\n        maxheap=[]\n        heapq.heapify(minheap)\n        heapq.heapify(maxheap)\n        length=1\n        i=0\n        j=1\n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n        heapq.heappush(maxheap,[-nums[0],0])\n        while j < len(nums):\n            if abs(minheap[0][0]-nums[j])<=limit and abs(abs(maxheap[0][0])-nums[j])<= limit:\n                length=max(length,j-i+1)\n                heapq.heappush(minheap,[nums[j],j])\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            else:\n                while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(minheap)\n                    i=max(i,index + 1)\n                while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(maxheap)\n                    i=max(i,index + 1)\n                # i=maxindex+1   # update i and now  we are not concerned with element before ith index\n                heapq.heappush(minheap,[nums[j],j]) # add  element and its index\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            \n        return length\n#         begin = end = 0\n#         l = len(nums)\n#         d = 0\n        \n#         heap_min = []\n#         heap_max = []\n        \n#         heapq.heapify(heap_min)\n#         heapq.heapify(heap_max)\n        \n#         while end < l:\n#             heapq.heappush(heap_min, (nums[end], end))\n#             heapq.heappush(heap_max, (-1 * nums[end], end))\n            \n#             while len(heap_min) > 0 and nums[end] - list(heap_min)[0][0] > limit:\n#                 value, idx = heapq.heappop(heap_min)\n#                 begin = max(begin, idx + 1)\n            \n#             while len(heap_max) > 0 and (list(heap_max)[0][0]*-1) - nums[end] > limit:\n#                 value, idx = heapq.heappop(heap_max)\n#                 begin = max(begin, idx + 1)\n            \n#             if end - begin + 1 > d:\n#                 d = end - begin + 1\n            \n#             end += 1\n#         return d\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        p1, p2, ans, cnt, min_, max_ = 0, 0, 0, {nums[0]: 1}, nums[0], nums[0]\n        while True:\n            if max_ - min_ <= limit:\n                ans = max(ans, p2-p1+1)\n                if p2 == len(nums)-1:\n                    return ans\n                p2 += 1\n                if nums[p2] in cnt:\n                    cnt[nums[p2]] += 1\n                else:\n                    cnt[nums[p2]] = 1\n                max_ = max(max_, nums[p2])\n                min_ = min(min_, nums[p2])\n            else:\n                num = nums[p1]\n                p1 += 1\n                if cnt[num] == 1:\n                    del cnt[num]\n                    if max_ == num:\n                        max_ = max(cnt.keys())\n                    if min_ == num:\n                        min_ = min(cnt.keys())\n                else:\n                    cnt[num] -= 1", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        res, last = 0, -1\n        maxQ, minQ = deque(), deque()\n        for i, val in enumerate(nums):\n            while maxQ and nums[maxQ[0]] - val > limit:  # decrease\n                last = max(last, maxQ.popleft())\n            while maxQ and val >= nums[maxQ[-1]]:\n                maxQ.pop()\n            maxQ.append(i)\n                \n            while minQ and val - nums[minQ[0]] > limit:  # increase\n                last = max(last, minQ.popleft())\n            while minQ and val <= nums[minQ[-1]]:\n                minQ.pop()\n            minQ.append(i)\n            \n            res = max(res, i - last)\n        return res\n    \nclass Solution:\n    def longestSubarray(self, A, limit):\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while len(maxd) and a > maxd[-1]: maxd.pop()\n            while len(mind) and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: maxd.popleft()\n                if mind[0] == A[i]: mind.popleft()\n                i += 1\n        return len(A) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if(not(nums)):\n            return 0\n        if(len(nums) == 1):\n            return 1\n        #n = len(nums)\n        start = 0\n        end = 1\n        maxi = nums[0]\n        mini = nums[0]\n        max_l = 1\n        while(start <= end and end < len(nums)):\n            maxi = max(maxi, nums[end])\n            mini = min(mini, nums[end])\n            if(maxi - mini <= limit):\n                max_l = max(max_l, end-start+1)\n            else:\n                #max_l = max(max_l, end-start)\n                if(nums[start] == maxi):\n                    maxi = max(nums[start+1:end+1])\n                if(nums[start] == mini):\n                    mini = min(nums[start+1:end+1])\n                start += 1\n            end += 1\n\n        return max_l\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        left=0\n        n=len(nums)\n        l=0\n        r=1\n        maxVal=nums[0]\n        minVal=nums[0]\n        res=1\n        while(l<r and r<n):\n            maxVal=max(maxVal,nums[r])\n            minVal=min(minVal,nums[r])\n            if(maxVal-minVal<=limit):\n                res=max(res,r-l+1)\n            else:\n                if(nums[l]==maxVal):\n                    maxVal=max(nums[l+1:r+1])\n                if(nums[l]==minVal):\n                    minVal=min(nums[l+1:r+1])\n                l+=1\n            r+=1\n        return res\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        \n        \n        \n        \n        \n        l = 0\n        r = 1\n        \n        curr_max = nums[0]\n        curr_min = nums[0]\n        max_len = 1\n        while l <= r and r < len(nums):\n            \n            curr_max = max(curr_max, nums[r])\n            curr_min = min(curr_min, nums[r])\n            \n            \n            if curr_max - curr_min <= limit:\n                max_len = max(max_len, r - l + 1)\n                \n            else:\n                \n                if curr_max == nums[l]:\n                    curr_max = max(nums[l+1:r+1])\n                if curr_min == nums[l]:\n                    curr_min = min(nums[l+1:r+1])\n                l+=1\n                \n            r+=1\n            \n        return max_len\n                    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_h = [(nums[0], 0)]\n        max_h = [(-nums[0], 0)]\n        \n        heapq.heapify(min_h)\n        heapq.heapify(max_h)\n        \n        max_v, min_v = nums[0], nums[0]\n        l, r = 0, 0\n        res = 1\n        while r < len(nums):\n            if max_v - min_v <= limit:\n                r += 1\n                if r < len(nums):\n                    heapq.heappush(min_h, (nums[r], r))\n                    heapq.heappush(max_h, (-nums[r], r))\n                    max_v, min_v = -max_h[0][0], min_h[0][0]\n            else:\n                res = max(res, r-l)\n                l += 1\n                while min_h[0][1] < l:\n                    heapq.heappop(min_h)\n                while max_h[0][1] < l:\n                    heapq.heappop(max_h)\n            max_v, min_v = -max_h[0][0], min_h[0][0]\n        \n        return max(res, r-l)", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_q = deque()\n        min_q = deque()\n        \n        i = 0\n        res = 0\n        for j, num in enumerate(nums):\n            while max_q and num > max_q[-1]:\n                max_q.pop()\n            while min_q and num < min_q[-1]:\n                min_q.pop()\n            \n            max_q.append(num)\n            min_q.append(num)\n            \n            while max_q[0] - min_q[0] > limit:\n                if max_q[0] == nums[i]:\n                    max_q.popleft()\n                if min_q[0] == nums[i]:\n                    min_q.popleft()\n                i += 1\n            \n            res = max(res, j - i + 1)\n        \n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        start = 0\n        end = 0\n        longest_size = 0\n        maxa = nums[0]\n        mina = nums[0]\n        while end < len(nums):\n            if maxa - mina <= limit:\n                longest_size = max(longest_size, end-start)\n                maxa = max(maxa, nums[end])\n                mina = min(mina, nums[end])\n                end += 1\n            else:\n                remove = nums[start]\n                start += 1\n                if remove == mina:\n                    while nums[start] <= mina:\n                        start += 1\n                    mina = min(nums[start:end+1])\n                if remove == maxa:\n                    while nums[start] >= maxa:\n                        start += 1\n                    maxa = max(nums[start:end+1])\n        if maxa-mina <= limit:\n                longest_size = max(longest_size, end-start)\n        return longest_size\n                \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        max_stack = collections.deque([0])  # Used to track maximum number\n        min_stack = collections.deque([0])  # Used to track minimum number\n        begin, end, longest = 0, 0, 0\n        \n        while end < n:\n            while True:\n                diff = nums[max_stack[0]] - nums[min_stack[0]]\n                if diff > limit:\n                    if min_stack[0] == begin:\n                        min_stack.popleft()\n                    if max_stack[0] == begin:\n                        max_stack.popleft()\n                    begin += 1\n                else:\n                    longest = max(longest, end - begin + 1)\n                    break\n            end += 1\n            if end < n:\n                while min_stack and nums[end] <= nums[min_stack[-1]]:\n                    min_stack.pop()\n                min_stack.append(end)\n                while max_stack and nums[end] >= nums[max_stack[-1]]:\n                    max_stack.pop()\n                max_stack.append(end)\n        return longest", "class Solution:\n    def longestSubarray(self, A, limit):\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while len(maxd) and a > maxd[-1]: maxd.pop()\n            while len(mind) and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: maxd.popleft()\n                if mind[0] == A[i]: mind.popleft()\n                i += 1\n        return len(A) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums or len(nums) == 1:\n            return len(nums)\n        \n        n = len(nums)\n        i = 0\n        j = 1\n        res = 1\n        min_in_window = nums[0]\n        max_in_window = nums[0]\n        while j < n:\n            max_in_window = max(max_in_window, nums[j])\n            min_in_window = min(min_in_window, nums[j])\n            diff = abs(min_in_window - max_in_window)\n            if diff <= limit:\n                j += 1\n                res = max(res, j - i)\n            else:\n                tmp = nums[i]\n                while i <= j and i < n - 1 and nums[i] == nums[i+1]:\n                    i += 1\n                if nums[i] == min_in_window:\n                    min_in_window = min(nums[i+1:j+1])\n                if nums[i] == max_in_window:\n                    max_in_window = max(nums[i+1:j+1])\n                i += 1\n                j += 1\n                    \n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         if not nums:\n#             return 0\n#         if len(nums) == 1: \n#             return 1\n        \n#         l, r = 0, 1\n#         res = 1\n#         min_in_window = nums[0]\n#         max_in_window = nums[0]\n#         while r < len(nums):\n#             min_in_window = min(min_in_window, nums[r])\n#             max_in_window = max(max_in_window, nums[r])\n#             if abs(min_in_window - max_in_window) <= limit:\n#                 res = max(res, r - l + 1)\n#             else:\n#                 while l <= r and l < len(nums) - 1 and nums[l] == nums[l+1]:\n#                     l += 1\n#                 if nums[l] == min_in_window:\n#                     min_in_window = min(nums[l+1:r+1])\n#                 if nums[l] == max_in_window:\n#                     max_in_window = max(nums[l+1:r+1])\n#                 l += 1\n#             r += 1\n#         return res\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_len, start, end = 1, 0, 0\n        pqmin, pqmax = [], []\n        \n        for end in range(len(nums)):\n            heapq.heappush(pqmin, (nums[end], end))\n            heapq.heappush(pqmax, (-nums[end], end))\n            \n            while start < end and abs(pqmax[0][0] + pqmin[0][0]) > limit:\n                start += 1\n                while pqmax and pqmax[0][1] < start: heapq.heappop(pqmax)\n                while pqmin and pqmin[0][1] < start: heapq.heappop(pqmin)\n            \n            max_len = max(max_len, end - start + 1)\n            \n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minheap=[]\n        maxheap=[]\n        heapq.heapify(minheap)\n        heapq.heapify(maxheap)\n        length=1\n        i=0\n        j=1\n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n        heapq.heappush(maxheap,[-nums[0],0])\n        while j < len(nums):\n            if nums[j]-minheap[0][0]<=limit and maxheap[0][0]*-1-nums[j]<= limit:\n                length=max(length,j-i+1)\n                heapq.heappush(minheap,[nums[j],j])\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            else:\n                while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(minheap)\n                    i=max(i,index + 1)\n                while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(maxheap)\n                    i=max(i,index + 1)\n                # i=maxindex+1   # update i and now  we are not concerned with element before ith index\n                heapq.heappush(minheap,[nums[j],j]) # add  element and its index\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            \n        return length\n#         begin = end = 0\n#         l = len(nums)\n#         d = 0\n        \n#         heap_min = []\n#         heap_max = []\n        \n#         heapq.heapify(heap_min)\n#         heapq.heapify(heap_max)\n        \n#         while end < l:\n#             heapq.heappush(heap_min, (nums[end], end))\n#             heapq.heappush(heap_max, (-1 * nums[end], end))\n            \n#             while len(heap_min) > 0 and nums[end] - list(heap_min)[0][0] > limit:\n#                 value, idx = heapq.heappop(heap_min)\n#                 begin = max(begin, idx + 1)\n            \n#             while len(heap_max) > 0 and (list(heap_max)[0][0]*-1) - nums[end] > limit:\n#                 value, idx = heapq.heappop(heap_max)\n#                 begin = max(begin, idx + 1)\n            \n#             if end - begin + 1 > d:\n#                 d = end - begin + 1\n            \n#             end += 1\n#         return d\n", "class Solution:\n    def longestSubarray(self, A, limit):\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while len(maxd) and a > maxd[-1]: \n                maxd.pop()\n            while len(mind) and a < mind[-1]: \n                mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: \n                    maxd.popleft()\n                if mind[0] == A[i]: \n                    mind.popleft()\n                i += 1\n        return len(A) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        answer = 1\n        counts = {nums[0] : 1}\n        subarray = deque([nums[0]])\n        max_val = nums[0]\n        min_val = nums[0]\n        \n        for i in range(1, len(nums)):\n            counts[nums[i]] = counts.get(nums[i], 0) + 1\n            max_val = max(max_val, nums[i])\n            min_val = min(min_val, nums[i])\n            subarray.append(nums[i])\n            \n            if abs(max_val - min_val) > limit:\n                while subarray:\n                    num = subarray.popleft()\n                    counts[num] -= 1 \n\n                    if counts[num] == 0:\n                        if max_val == num:\n                            if subarray:\n                                max_val = max(subarray)\n                            else:\n                                max_val = 0\n                            \n                            break\n                        \n                        elif min_val == num:\n                            if subarray:\n                                min_val = min(subarray)\n                            else:\n                                min_val = 10 ** 9 + 1\n                            \n                            break\n    \n            answer = max(answer, len(subarray))\n        \n        return answer\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i=0\n        j=1\n        n=len(nums)\n        if n==0:\n            return 0\n        mn=nums[0]\n        mx=nums[0]\n        l=1\n        while i<=j and j<n:\n            if mn>nums[j]:\n                mn=nums[j]\n            if mx<nums[j]:\n                mx=nums[j]\n            #print(i,j,mn,mx)\n            if mx-mn<=limit:\n                if j-i+1>l:\n                    l=j-i+1\n            else:\n                if mn==nums[i]:\n                    mn=min(nums[i+1:j+1])\n                if mx==nums[i]:\n                    mx=max(nums[i+1:j+1])\n                i+=1\n            j+=1\n        return l\n", "import heapq\n\nclass Solution:\n    '''def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # TC is O(N^2)\n        start = 0\n        L = []\n        maxlen = 0\n\n        for end, item in enumerate(nums):\n            # insert the current item in appropriate position\n            bisect.insort(L, item) # insort is O(N)\n            # if the difference between start and end is more than expected, keep popping the start indexes\n            while L[-1] - L[0] > limit:\n                #*****bisect will give you the index but it is ALWAYS +1\n                idx = bisect.bisect(L, nums[start]) - 1 # logN TC\n                L.pop(idx) # pop that shit and recompute max-min difference again\n                start += 1\n            maxlen = max(maxlen, end-start+1)\n        return maxlen'''\n\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # insort was expesive in above O(N) so use 2 heaps to maintain max and min\n        maxheap = []\n        minheap = []\n        start = 0\n        maxlen = 0\n        \n        for end, item in enumerate(nums):\n            heapq.heappush(minheap, (item, end))\n            heapq.heappush(maxheap, (-item, end))\n            #print(minheap, maxheap)\n            while maxheap and minheap and -maxheap[0][0]-minheap[0][0]>limit:\n                #print()\n                #print('heap', minheap, maxheap)\n                # find the minimum index of max or min\n                start = min(maxheap[0][1], minheap[0][1]) + 1\n                # it will be either of min or max, make sure to pop shit just above start so we dont have the max and min item below start\n                while maxheap[0][1] < start:\n                    heapq.heappop(maxheap)\n                while minheap[0][1] < start:\n                    heapq.heappop(minheap)\n                #print('heap', minheap, maxheap)\n            maxlen = max(maxlen, end-start+1)\n\n        return maxlen\n\n\n        \n    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        res = 0 \n        left, right = 0, 0\n        inc, dec = collections.deque(), collections.deque()\n        while right < n:\n            while inc and nums[inc[-1]] >= nums[right]: # \u5141\u8bb8\u76f8\u540c\u5143\u7d20\u5b58\u5728\uff0c\u8fd9\u6837\u7684\u8bdd\u6ed1\u52a8\u7a97\u53e3pop\u7684\u65f6\u5019\u624d\u80fd\u6b63\u786e\u7684pop\u5b8c\uff0c\u5426\u5219\u4f1a\u51fa\u73b0\u8fc7\u65e9\u7684pop\u5b8c\u4f46left\u8fd8\u6ca1\u8ddf\u4e0a\u7684\u60c5\u51b5\n                inc.pop()\n            inc.append(right)\n            while dec and nums[dec[-1]] <= nums[right]:\n                dec.pop()\n            dec.append(right)\n            right += 1            \n            while nums[dec[0]] - nums[inc[0]] > limit:\n                if inc[0] == left:\n                    inc.popleft()\n                if dec[0] == left:\n                    dec.popleft()\n                left += 1\n            res = max(res, right - left)\n            # print(left, right, res, inc, dec, )\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # asc stack\n        # desc stack\n        asc, desc = deque(), deque()\n        left = 0\n        longest = 0\n        for i, n in enumerate(nums):\n            if not asc:\n                asc.append([n, i])\n            else:\n                while asc and asc[-1][0] > n:\n                    asc.pop()\n                asc.append([n, i])\n            if not desc:\n                desc.append([n, i])\n            else:\n                while desc and desc[-1][0] < n:\n                    desc.pop()\n                desc.append([n, i])\n                \n            while desc[0][0] - asc[0][0] > limit:\n                if desc[0][1] < asc[0][1]:\n                    left = desc.popleft()[1] + 1\n                else:\n                    left = asc.popleft()[1] + 1\n            \n            longest = max(longest, i-left+1)\n            \n        return longest", "class Solution:\n  def longestSubarray(self, nums, limit):\n    _min = _max = nums[0]\n    \n    count = 0\n    res, start =1, 0\n\n    for right in range(len(nums)):\n      if _min>nums[right]: _min = nums[right]\n      if _max<nums[right]: _max = nums[right]\n\n      if _max-_min <= limit:\n        count += 1\n        if res < count: res = count\n\n      else:\n        _min=_max=nums[right]\n        count = 1\n        left = right - 1\n        while (left>=start and abs(_max - nums[left])<=limit \n               and abs(_min - nums[left]) <= limit):\n          if _min>nums[left]: _min = nums[left]\n          if _max<nums[left]: _max = nums[left]\n          count += 1\n          left -= 1\n\n        start = right+1\n\n    return res\n", "class Solution:\n    def longestSubarray(self, A, limit):\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while len(maxd) and a > maxd[-1]: maxd.pop()\n            while len(mind) and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: maxd.popleft()\n                if mind[0] == A[i]: mind.popleft()\n                i += 1\n        return len(A) - i\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = r = 0\n        minq = collections.deque()\n        maxq = collections.deque()\n        ans = 0\n        \n        while r < len(nums):\n            while minq and nums[minq[-1]] >= nums[r]:\n                minq.pop()\n            while maxq and nums[maxq[-1]] <= nums[r]:\n                maxq.pop()\n                \n            minq.append(r)\n            maxq.append(r)\n            \n            while nums[maxq[0]] - nums[minq[0]] > limit:\n                l += 1\n                if l > minq[0]:\n                    minq.popleft()\n                if l > maxq[0]:\n                    maxq.popleft()\n                    \n            ans = max(ans, r - l + 1)\n            r += 1\n            \n        return ans\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums)==1:\n            return 1\n        \n        #nums.sort()\n        #nums = [8,2,4,7]\n        \n        maxL=0\n        beg=0\n        #end=1\n        '''\n        while beg<len(nums)-1:\n            #mx=max(nums[beg:(end+1)])\n            #mn=min(nums[beg:(end+1)])\n            while end<len(nums) and max(nums[beg:(end+1)])-min(nums[beg:(end+1)])<=limit:\n                maxL=max(maxL, end-beg+1)\n                end+=1\n            beg+=1\n            end=beg+1\n        return maxL\n        '''\n        minQueue, maxQueue = collections.deque([]), collections.deque([])\n        #minQueue, maxQueue=[], []\n        #minQueue increasing, maxQueue decreasing\n        \n        #minQueue.append(nums[beg])\n        #maxQueue.append(nums[beg])\n        end=beg  \n        while end<len(nums):\n            \n            #need while loop because if minQueue=[3,4,7], nums[end]=2\n            #then since minQueue must be increasing and need to append nums[end]=2\n            #so must remove 3,4, and 7\n            while len(minQueue)>0 and nums[end]<minQueue[-1]:\n                minQueue.pop()\n            minQueue.append(nums[end]) #[2]\n            \n            #print(\\\" min: \\\", minQueue)\n            \n            while len(maxQueue)>0 and nums[end]>maxQueue[-1]:\n                maxQueue.pop()\n            maxQueue.append(nums[end]) #[7,2]\n            \n            \n            if maxQueue[0]-minQueue[0]<=limit:\n                maxL=max(maxL, end-beg+1)\n            else:\n                if maxQueue[0]==nums[beg]:\n                    maxQueue.popleft()  #[1]\n                    #maxQueue.pop(0)  #[1]\n                if minQueue[0]==nums[beg]:\n                    minQueue.popleft()  #[1]\n                    #minQueue.pop(0)  #[1]\n                beg+=1\n            end+=1\n            \n        return maxL", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque = collections.deque()\n        max_deque = collections.deque()\n        left = 0\n        right = 0\n        max_size = 0\n        while right < len(nums):\n            while min_deque and nums[min_deque[-1]] >= nums[right]:\n                min_deque.pop()\n            while max_deque and nums[max_deque[-1]] <= nums[right]:\n                max_deque.pop()\n                \n            min_deque.append(right)\n            max_deque.append(right)\n            \n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                left += 1\n                \n                if max_deque[0] < left:\n                    max_deque.popleft()\n                if min_deque[0] < left:\n                    min_deque.popleft()\n            right += 1\n            max_size = max(max_size, right - left)\n        return max_size\n                    \n            \n                \n    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        import collections\n        min_deque = deque() \n        max_deque = deque()\n        l = 0 \n        r = 0\n        ans = 0\n        \n        while r < len(nums):\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\n                min_deque.pop()\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            \n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                l += 1\n                if l > min_deque[0]:\n                    min_deque.popleft()\n                if l > max_deque[0]:\n                    max_deque.popleft()\n            \n            ans = max(ans, r - l + 1)\n            r += 1\n                \n        return ans", "import heapq\n# import collections\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        \n        for j in range(len(nums)):\n            heapq.heappush(maxq, (-nums[j], j))\n            heapq.heappush(minq, (nums[j], j))\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while i > maxq[0][1]:\n                    heapq.heappop(maxq)\n                while i > minq[0][1]:\n                    heapq.heappop(minq)\n                    \n            res = max(res, j-i+1)\n        return res\n                    \n#         maxq = collections.deque()\n#         minq = collections.deque()\n#         res = i = 0\n        \n#         for j in range(len(nums)):\n#             while maxq and nums[maxq[-1]] < nums[j]: maxq.pop()\n#             while minq and nums[minq[-1]] > nums[j]: minq.pop()\n            \n#             maxq.append(j)\n#             minq.append(j)\n            \n#             while nums[maxq[0]] - nums[minq[0]] > limit:\n#                 i = min(maxq[0], minq[0]) + 1\n#                 while i > maxq[0]: maxq.popleft()\n#                 while i > minq[0]: minq.popleft()\n            \n#             res = max(res, j-i+1)\n            \n#         return res\n", "from heapq import heappush,heappop\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i = j = best = 0\n        minHeap, maxHeap = [], []\n\n        while j < len(nums):\n            heappush(minHeap,(nums[j],j))\n            heappush(maxHeap,(-nums[j],j))\n            \n            while abs(nums[j] + maxHeap[0][0]) > limit:\n                i = max(i, heappop(maxHeap)[1] + 1)\n            while abs(nums[j] - minHeap[0][0]) > limit:\n                i = max(i, heappop(minHeap)[1] + 1)\n            j+= 1\n            best = max(best, j - i)\n        return best\n", "import collections\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minq = collections.deque()\n        maxq = collections.deque()\n        j = 0\n        count = 0\n        for i, val in enumerate(nums):\n            \n            while len(minq) > 0 and minq[-1] > val:\n                minq.pop()\n            while len(maxq) > 0 and maxq[-1] < val:\n                maxq.pop()\n                \n            minq.append(val)\n            maxq.append(val)\n            \n            \n            while len(minq) > 0 and len(maxq) > 0 and maxq[0] - minq[0] > limit:\n                if nums[j] == maxq[0]:\n                    maxq.popleft()\n                    \n                if nums[j] == minq[0]:\n                    minq.popleft()\n                    \n                j += 1\n                \n            count = max(count, i - j + 1)\n            \n        return count\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in nums:\n            while len(maxd) and a > maxd[-1]: maxd.pop()\n            while len(mind) and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == nums[i]: maxd.popleft()\n                if mind[0] == nums[i]: mind.popleft()\n                i += 1\n        return len(nums) - i", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums or limit < 0:\n            return 0\n        \n        anchor = ans = 0\n        hi, lo = float('-inf'), float('inf')\n        \n        for i in range(len(nums)):\n            hi = max(hi, nums[i])\n            lo = min(lo, nums[i])\n            \n            if (hi - lo) <= limit:\n                ans = max(ans, i - anchor + 1)\n            else:\n                if nums[anchor] == hi:\n                    hi = max(nums[anchor + 1 : i + 1])\n                elif nums[anchor] == lo:\n                    lo = min(nums[anchor + 1 : i + 1])\n                    \n                anchor += 1\n                \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        \n        l = 0\n        r = 1\n         \n        cur_mx = nums[0]\n        cur_mn = nums[0]\n        \n        max_l = 1\n         \n        while l <= r and r < len(nums):\n            cur_mx = max(cur_mx, nums[r])\n            cur_mn = min(cur_mn, nums[r])\n\n            if cur_mx - cur_mn <= limit:\n                max_l = max(max_l, r - l + 1)\n            else:\n                if nums[l] == cur_mx:                     \n                    cur_mx = max(nums[l + 1:r + 1])  \n                if nums[l] == cur_mn:\n                    cur_mn = min(nums[l + 1:r + 1])\n                l += 1\n            r += 1\n        return max_l", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        cur_max = nums[0]\n        cur_min = nums[0]\n        l=0\n        r=1\n        max_l = 1\n        \n        while l<=r and r<len(nums):\n            cur_max = max(cur_max, nums[r])\n            cur_min = min(cur_min, nums[r])\n            if cur_max-cur_min <=limit:\n                max_l = max(max_l, r-l+1)\n            else:\n                if nums[l] == cur_max:\n                    cur_max = max(nums[l+1:r+1])\n                if nums[l] == cur_min:\n                    cur_min = min(nums[l+1:r+1])\n                l+=1\n            r+=1\n        return max_l", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # we keep two pointers and we keep track of min and max between those pointers\n        # if the new number being added is having difference from both min and max within the range we increase j and update min and max if necessary else we increase i till we get the difference less than target while changing i and also we keep on updating the min and max\n        # it can mark the beginning of a new sub array\n        # however if we can make this update faster constant time and at max we need to increase i from i to j by deleting each number then also it is in worse case O(nk) instead of linear we can save sometime\n        # we do not need indices and so we can use SortedList instead of SortedDict to make processing of finding min and max after changing i faster\n        minheap = [[nums[0],0]]\n        maxheap = [[-nums[0],0]]\n        left = -1\n        res = 1\n        for i,val in enumerate(nums[1:]):\n            j = i+1\n            while len(maxheap) and len(minheap) and max(val,-maxheap[0][0]) - min(val,minheap[0][0]) > limit:\n                if val == max(val,-maxheap[0][0]):\n                    v,l = heapq.heappop(minheap)\n                if minheap and val == min(val,minheap[0][0]):\n                    v,l = heapq.heappop(maxheap)\n                left = max(l,left)\n            res = max(j-left,res)\n            heapq.heappush(minheap,[val,j])\n            heapq.heappush(maxheap,[-val,j])\n        return res\n        \n        '''\n        s = SortedList()\n        # we keep on adding new values to the sortedList and when we get max - min greater than target then we keep on removing values from the list till the sorted list becomes valid again\n        # thus we have a solution with O(nlogn) complexity and faster than the one with sortedDict although it is having same complexity\n        max_length = 0\n        j = 0\n        for i in range(len(nums)):\n            s.add(nums[i])\n            while s and s[-1] - s[0] > limit:\n                s.remove(nums[j])\n                j += 1\n            max_length = max(max_length,i-j + 1)\n        return max_length\n        '''\n        # for the following approach also the time limit gets exceeded because although operations on dictionary are O(logn) we are doing them for more number of times then expected\n        '''\n        # i.e. if min is our problem then we need to increase i till we find new min \n        # i.e we need to start from i = i + max_index of current_min\n        # and if max is our problem then we need to increase i till we find new max\n        # i.e we need to start from i = i + max_index of current_max\n        # and if both are a problem then we need to increase i till max when both are changed\n        # this we can do if we use a hashmap mapping each value from i to j with its max index in the array we do not care for intermediate indices\n        max_length = -float('inf')\n        mapping = SortedDict()\n        Min = nums[0]\n        Max = nums[0]\n        mapping[Min] = 0\n        i = 0\n        while i < len(nums):\n            j = i\n            # print('a',i,j,Max,Min)\n            while j < len(nums) and abs(nums[j] - Min) <= limit and abs(nums[j] - Max) <= limit:\n                Max = max(Max,nums[j])\n                Min = min(Min,nums[j])\n                # we are just concerned with the max value\n                mapping[nums[j]] = j\n                j += 1\n                max_length = max(max_length,j - i)\n                \n            # print('b',i,j,Min,Max)\n            if j >= len(nums)-1:\n                break\n            else:\n                mapping[nums[j]] = j\n                while i <= j and (abs(nums[j] - Min) > limit or abs(nums[j] - Max) > limit):\n                    if abs(nums[j] - Min) > limit and abs(nums[j] - Max) > limit:\n                        i = max(i,max(mapping[Min],mapping[Max]) + 1)\n                        del mapping[Max]\n                        if Min in mapping.keys():\n                            del mapping[Min]\n\n                    elif abs(nums[j] - Min) > limit:\n                        i = max(i,mapping[Min] + 1)\n                        del mapping[Min]\n                        \n                    elif abs(nums[j] - Max) > limit:\n                        i = max(i,mapping[Max] + 1)\n                        del mapping[Max]\n                    # after each update we need to update min and max and the following steps will take O(n)\n                    Min = mapping.peekitem(0)[0]\n                    Max = mapping.peekitem()[0]\n                    while mapping[Min] < i:\n                        del mapping[Min]\n                        Min = mapping.peekitem(0)[0]\n                    while mapping[Max] < i:\n                        del mapping[Max]\n                        Max = mapping.peekitem()[0]\n                    \n                # print(mapping)\n                # print('c',i,j,Max,Min)\n        return max_length\n        \n        '''\n        # for the following approach time limit gets exceeded\n        '''\n        max_length = -float('inf')\n        Min = nums[0]\n        Max = nums[0]\n        i = 0\n        while i < len(nums):\n            j = i \n            #print('a',i,j,Max,Min)\n            while j < len(nums) and abs(nums[j] - Min) <= limit and abs(nums[j] - Max) <= limit:\n                Max = max(Max,nums[j])\n                Min = min(Min,nums[j])\n                j += 1\n                max_length = max(max_length,j - i)\n            #print('b',i,j,Max,Min,len(nums))\n            if j >= len(nums)-1:\n                break\n            else:\n                while i < j and nums[i] != Min and nums[i] != Max:\n                    i += 1\n                while i < j and (abs(nums[j] - Min) > limit or abs(nums[j] - Max) > limit):\n                    i += 1\n                    #print(i)\n                    Min = min(nums[i:j+1])\n                    Max = max(nums[i:j+1])\n                    #print('c',i,j,Max,Min)\n        return max_length\n        '''            \n        \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxLen = 1\n        curMax = curMin = nums[0]\n        l = r = 0\n        while r < len(nums):\n            curMax = max(curMax, nums[r])\n            curMin = min(curMin, nums[r])\n            if curMax - curMin <= limit:\n                maxLen = max(maxLen, r-l+1)\n            else:\n                if nums[l] == curMin:\n                    curMin = min(nums[l+1:r+1])\n                if nums[l] == curMax:\n                    curMax = max(nums[l+1:r+1])\n                l += 1\n            r += 1\n        return maxLen\n        \n", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        '''\n        Find the longest non-empty subarray s where max(s) - min(s) <= limit\n        '''\n        max_q, min_q = [[nums[0], 0]], [[nums[0], 0]]\n        ans = 1\n        i = j = 0\n        while j < len(nums):\n            heapq.heappush(max_q, [-nums[j], j])\n            heapq.heappush(min_q, [nums[j], j])\n            if -max_q[0][0] - min_q[0][0] <= limit:\n                ans = max(ans, j-i+1)\n                j += 1\n            else:\n                # Fast forward i\n                i = min(max_q[0][1], min_q[0][1]) + 1\n                while max_q[0][1] < i: heapq.heappop(max_q)\n                while min_q[0][1] < i: heapq.heappop(min_q)\n        return ans\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        \n        left = 0\n        right = 0\n        curr_min = nums[0]\n        curr_max = nums[0]\n        max_len = 1\n        \n        while left <= right and right < len(nums):\n            curr_max = max(curr_max, nums[right])\n            curr_min = min(curr_min, nums[right])\n\n            \n            if curr_max - curr_min <= limit:\n                max_len = max(max_len, right - left + 1)\n                \n            else:\n                if nums[left] == curr_max:\n                    curr_max = max(nums[left + 1: right + 1])\n                if nums[left] == curr_min:\n                    curr_min = min(nums[left + 1: right + 1])\n                left += 1\n            right += 1\n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:        \n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n\n        ans = 1\n        minelement = maxelement = nums[0]\n        l = 0\n        r = 1\n        \n        while (r<n and l<=r):\n            minelement = min(minelement, nums[r])\n            maxelement = max(maxelement, nums[r])\n\n            if maxelement-minelement  <= limit:\n                ans = max(ans, r-l+1)\n            else:\n                # recompute min and max\n                if minelement == nums[l]:\n                    minelement = min(nums[l+1: r+1])\n                if maxelement == nums[l]:\n                    maxelement = max(nums[l+1: r+1])\n                l += 1\n            r += 1        \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if (len(nums)==0):\n            return 0\n        if(len(nums)==1):\n            return 1\n        \n        ans = 1\n        minNum = nums[0]\n        maxNum = nums[0]\n         \n        i=0\n        j=0\n        n = len(nums)\n        \n        while i<n and j<n:\n            \n            maxNum = max(maxNum, nums[i])\n            minNum = min(minNum, nums[i])\n            \n            if(abs(maxNum - minNum) > limit):\n                if(nums[j] == maxNum):\n                    maxNum = max(nums[j+1:i+1])\n                elif(nums[j] == minNum):\n                    minNum = min(nums[j+1:i+1])\n                j+=1\n            else:\n                ans = max(ans, i-j+1)\n            i+=1\n        return ans", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        res, last = 0, -1\n        maxQ, minQ = deque(), deque()\n        for i, val in enumerate(nums):\n            while maxQ and nums[maxQ[0]] - val > limit:\n                last = max(last, maxQ.popleft())\n            while minQ and val - nums[minQ[0]] > limit:\n                last = max(last, minQ.popleft())\n            res = max(res, i - last)\n            while maxQ and val >= nums[maxQ[-1]]:\n                maxQ.pop()\n            maxQ.append(i)\n            while minQ and val <= nums[minQ[-1]]:\n                minQ.pop()\n            minQ.append(i)\n        return res\n    \nfrom collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        res, last = 0, -1\n        maxQ, minQ = deque(), deque()\n        for i, val in enumerate(nums):\n            while maxQ and nums[maxQ[0]] - val > limit:\n                last = max(last, maxQ.popleft())\n            while minQ and val - nums[minQ[0]] > limit:\n                last = max(last, minQ.popleft())\n            #res = max(res, i - last)\n            if i - last > res: res = i - last\n            while maxQ and val >= nums[maxQ[-1]]:\n                maxQ.pop()\n            maxQ.append(i)\n            while minQ and val <= nums[minQ[-1]]:\n                minQ.pop()\n            minQ.append(i)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n\n        l, r = 0 , 0\n        n = len(nums)\n        ll = 0\n        mmin = nums[0]\n        mmax = nums[0]\n        while l <= r and r < n:\n            mmax = max(mmax, nums[r])\n            mmin = min(mmin, nums[r])\n            if abs(mmax - mmin) <= limit:\n                ll = max(ll, r -l + 1)\n            else:\n                if nums[l] == mmax:\n                    mmax = max(nums[l+1: r+1])\n                if nums[l] == mmin:\n                    mmin = min(nums[l+1:r+1])\n                \n                l += 1\n            r += 1\n    \n        return ll", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        currmax = currmin = nums[0]\n        start = 0\n        res = 1\n        for i in range(1,len(nums)):\n            currmax = max(currmax,nums[i])\n            currmin = min(currmin,nums[i])\n            \n            print(currmax,currmin)\n            if currmax - currmin <= limit:\n                res = max(res,i-start+1)\n            \n            else:\n                if currmax == nums[start]:\n                    currmax = max(nums[start+1:i+1])\n                if currmin == nums[start]:\n                    currmin = min(nums[start+1: i+1])\n                start += 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        smallest = largest = nums[0]\n        start, end, window = 0, 1, 1\n        \n        while end < len(nums):\n            smallest, largest = min(smallest, nums[end]), max(largest, nums[end])\n            \n            if largest - smallest <= limit:\n                window = max(window, end - start + 1)\n            else:\n                if nums[start] == smallest:\n                    smallest = min(nums[start+1:end+1])\n                if nums[start] == largest:\n                    largest = max(nums[start+1:end+1])\n                start += 1\n                \n            end += 1\n            \n        return window", "import collections\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque = collections.deque()        \n        max_deque = collections.deque()        \n        longest_subarray = 0\n        \n        i, j = 0, 0\n        min_deque.append((nums[0], 0))\n        max_deque.append((-nums[0], 0))\n        \n        while j < len(nums) and len(nums)-i+1 > longest_subarray:\n            # Remove elements from the min and max that are stale\n            while min_deque and min_deque[0][1] < i: min_deque.popleft()\n            while max_deque and max_deque[0][1] < i: max_deque.popleft()\n                \n            # Keep adding elements if the invariant is true    \n            while i > j or (j < len(nums)-1 and (max(-max_deque[0][0], nums[j+1]) - min(min_deque[0][0], nums[j+1]) <= limit)):\n                j += 1\n                self.insert_to_deque(min_deque, nums[j], j)\n                self.insert_to_deque(max_deque, -nums[j], j)\n                \n            longest_subarray = max(longest_subarray, j-i+1)    \n            i += 1\n            \n        return longest_subarray    \n    \n    def insert_to_deque(self, deque_object, value, index):\n        # Keep popping from the right until the new value is smaller\n        while len(deque_object) > 0 and deque_object[-1][0] >= value:\n            deque_object.pop()\n        deque_object.append((value, index))    ", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        currMax = nums[ 0 ]\n        currMin = nums[ 0 ]\n        maxSize = 1\n        beg = 0\n        end = 0\n        while end < len( nums ):\n            currMax = max( currMax, nums[ end ] )\n            currMin = min( currMin, nums[ end ] )\n            if currMax - currMin > limit:\n                beg += 1\n                if currMax == nums[ beg - 1 ]:\n                    while currMax == nums[ beg ]:\n                        beg += 1\n                    currMax = max( nums[ beg : end + 1 ] )\n                if currMin == nums[ beg - 1 ]:\n                    while currMin == nums[ beg ]:\n                        beg += 1\n                    currMin = min( nums[ beg : end + 1 ] )\n            else:\n                end += 1\n            maxSize = max( maxSize, end - beg )\n        return maxSize", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        min_heap, max_heap = [], []\n        res, i = 0, 0\n        for j, num in enumerate(nums):\n            heapq.heappush(min_heap, [num, j])\n            heapq.heappush(max_heap, [-num, j])\n            while abs(min_heap[0][0]+max_heap[0][0]) > limit:\n                i = min(min_heap[0][1], max_heap[0][1]) + 1\n                while min_heap[0][1] < i:\n                    heapq.heappop(min_heap)\n                while max_heap[0][1] < i:\n                    heapq.heappop(max_heap)\n            res = max(res, j-i+1)\n        return res", "from heapq import heappush, heappop\nfrom collections import deque\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # min_stack = []\n        # max_stack = []\n        # for i, number in enumerate(nums):\n        #     _index = i\n        #     while max_stack and number > max_stack[-1][0]:\n        #         _, _index = max_stack.pop()\n        #     max_stack.append((number, _index))\n        #     _index = i\n        #     while min_stack and number < min_stack[-1][0]:\n        #         _, _index = min_stack.pop()\n        #     min_stack.append((number, _index))\n        # longest = -1\n        # start_index = len(nums) - 1\n        # print(max_stack)\n        # print(min_stack)\n        # while max_stack[-1][0] - min_stack[-1][0] <= limit:\n        #     longest = max(\n        #         longest,\n        #         abs(max_stack[-1][1] - min_stack[-1][1])\n        #     )\n        #     if max_stack[-1][1] > min_stack[-1][1]:\n        #         max_stack.pop()\n        #     else:\n        #         min_stack.pop()\n        # return longest\n            \n            \n        left = 0\n        min_q = deque()\n        max_q = deque()\n        longest = 0\n        for right, number in enumerate(nums):\n            _index = right\n            while max_q and number > max_q[-1][0]:\n                _, _index = max_q.pop()\n            max_q.append((number, _index))\n            _index = right\n            while min_q and number <= min_q[-1][0]:\n                _, _index =min_q.pop()\n            min_q.append((number, _index))\n            while max_q[0][0] - min_q[0][0] > limit:\n                if max_q[0][1] > min_q[0][1]:\n                    if len(min_q) == 1:\n                        q = max_q\n                    else:\n                        q = min_q\n                else:\n                    if len(max_q) == 1:\n                        q = min_q\n                    else:\n                        q = max_q\n                _, _index = q.popleft()\n            left = max(min_q[0][1], max_q[0][1])\n            longest = max(longest, right - left + 1)\n        return longest\n                \n    \n    def calc_diff(self, a, b):\n        return abs(a - b)\n    \n", "class Solution:\n#     def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         min_h = [(nums[0], 0)]\n#         max_h = [(-nums[0], 0)]\n        \n#         heapq.heapify(min_h)\n#         heapq.heapify(max_h)\n        \n#         max_v, min_v = nums[0], nums[0]\n#         l, r = 0, 0\n#         res = 1\n#         while r < len(nums):\n#             if max_v - min_v <= limit:\n#                 r += 1\n#                 if r < len(nums):\n#                     heapq.heappush(min_h, (nums[r], r))\n#                     heapq.heappush(max_h, (-nums[r], r))\n#                     max_v, min_v = -max_h[0][0], min_h[0][0]\n#             else:\n#                 res = max(res, r-l)\n#                 l += 1\n#                 while min_h[0][1] < l:\n#                     heapq.heappop(min_h)\n#                 while max_h[0][1] < l:\n#                     heapq.heappop(max_h)\n#             max_v, min_v = -max_h[0][0], min_h[0][0]\n        \n#         return max(res, r-l)\n    \n    \n    def longestSubarray(self, nums, limit):\n        max_h, min_h = [], []\n        res = l = 0\n        \n        for r, num in enumerate(nums):\n            heapq.heappush(max_h, (-num, r))\n            heapq.heappush(min_h, (num, r))\n            while -max_h[0][0] - min_h[0][0] > limit:\n                l += 1\n                while max_h[0][1] < l:\n                    heapq.heappop(max_h)\n                while min_h[0][1] < l:\n                    heapq.heappop(min_h)\n            res = max(res, r - l + 1)\n        return res\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # [8, 2, 4, 7] limit = 4\n        # want to keep track of max and min elements + indexes\n        # thinking of a sliding window approach\n        # 8, 8 -> 8, 2 -> 2, 4 -> 2, 7 -> end\n        # difference between i and j + 1\n        # [10, 1, 2, 4, 7, 2], limit = 5\n        # 10, 10 -> 10, 1 -> 1, 2 -> 1, 4 -> 1, 7 -> 2, 7 -> 2, 2 -> end\n        # turns out i need a list of max and min elements + indexes\n        # [8, 11, 5, 7, 9, 10, 8, 7, 6];\n        # (8, 11) -> (11, 5) -> \n        # The list of max elements must contain elements in window, descending order\n        # The list of min elements must contain elements in window, ascending order\n        \n        # (6, 8) (7, 7) (9, 6)\n        # (9, 6)\n        # i = 3, j = 10\n        # res = 6\n        \n        if limit < 0:\n            return 0\n        \n        i, j = 0, 1\n        res = 0\n        max_q, min_q = collections.deque(), collections.deque()\n        max_q.append((0, nums[0]))\n        min_q.append((0, nums[0]))\n        while j < len(nums):\n            if (max_q[0][1] - min_q[0][1] <= limit):\n                while max_q and nums[j] > max_q[-1][1]:\n                    max_q.pop()\n                while min_q and nums[j] < min_q[-1][1]:\n                    min_q.pop()\n                max_q.append((j, nums[j]))\n                min_q.append((j, nums[j]))\n                j += 1\n            if (max_q[0][1] - min_q[0][1] > limit):\n                res = j - i - 1 if j - i - 1 > res else res\n                min_i, max_i = min_q[0][0], max_q[0][0]\n                if (min_i < max_i):\n                    i = min_i + 1\n                    min_q.popleft()\n                else:\n                    i = max_i + 1\n                    max_q.popleft()\n        return j - i if j - i > res else res\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        def helper(arr, limit):\n            # 13\n            from collections import deque\n            Q = deque()\n            Q_2 = deque()\n            result = 0\n            if len(nums) == 1:\n                return 1\n            for i in range(len(arr)):\n                v = arr[i]\n                while len(Q) and abs(v - Q[0][1]) > limit:\n                    j, _ = Q.popleft()\n\n                while len(Q_2) and abs(v - Q_2[0][1]) > limit:\n                    j, _ = Q_2.popleft()\n                \n                if len(Q) and len(Q_2):\n                    r = i - max(Q[0][0], Q_2[0][0]) + 1\n                    # print(r, Q, Q_2)\n                    result = max(result, r)\n\n                ni = i\n                while len(Q) and v <= Q[-1][1]:\n                    mp, vp = Q.pop()  # <=============== change i !!!\n                    if abs(vp - v) <= limit:\n                        ni = mp\n                Q.append((ni, v))\n                ni = i\n                while len(Q_2) and v >= Q_2[-1][1]:\n                    mp, vp = Q_2.pop()  # <=============== change i !!!\n                    if abs(vp - v) <= limit:\n                        ni = mp\n                Q_2.append((ni, v))\n\n            return result\n        \n        r1 = helper(nums, limit)\n\n        return r1", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums: return 0\n        pre = 0\n        res = 1\n        \n        maxs = []\n        mins = []\n        \n        for i in range(len(nums)):\n            while maxs and maxs[-1] < nums[i]:\n                maxs.pop()\n            while mins and mins[-1] > nums[i]:\n                mins.pop()\n            \n            maxs.append(nums[i])\n            mins.append(nums[i])\n            \n            while maxs[0] - mins[0] > limit:\n                if maxs[0] == nums[pre]: maxs.pop(0)\n                if mins[0] == nums[pre]: mins.pop(0)\n                pre += 1\n            res = max(res, i-pre+1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        ans = 1\n        st = en = 0\n        min_q = collections.deque()\n        max_q = collections.deque()\n        while en < len(nums):\n            \n            while min_q and nums[en] <= nums[min_q[-1]]:\n                min_q.pop()\n            while max_q and nums[en] >= nums[max_q[-1]]:\n                max_q.pop()\n            min_q.append(en)\n            max_q.append(en)\n           \n            \n            #print (st , en)\n            while nums[max_q[0]] - nums[min_q[0]] > limit:\n                st +=1\n                if st > min_q[0]:\n                    min_q.popleft()\n                if st > max_q[0]:\n                    max_q.popleft()\n                \n            ans = max(ans, en - st + 1)\n            en +=1\n            #print(ans)\n        \n        return ans\n                \n", "from heapq import heappush,heappop\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i = j = best = 0\n        minHeap, maxHeap = [], []\n\n        while i < len(nums) and j < len(nums):\n            heappush(minHeap,(nums[j],j))\n            heappush(maxHeap,(-nums[j],j))\n            while abs(nums[j] + maxHeap[0][0]) > limit:\n                i = max(i, heappop(maxHeap)[1] + 1)\n            while abs(nums[j] - minHeap[0][0]) > limit:\n                i = max(i, heappop(minHeap)[1] + 1)\n            j+= 1\n            best = max(best, j - i)\n        return best\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque = collections.deque()\n        max_deque = collections.deque()\n        \n        l = 0\n        ans = 0\n        for r, num in enumerate(nums):\n            while(min_deque and nums[min_deque[-1]] >= num):\n                min_deque.pop()\n            while(max_deque and nums[max_deque[-1]] <= num):\n                max_deque.pop()\n                \n            min_deque.append(r)\n            max_deque.append(r)\n            \n            while(nums[max_deque[0]] - nums[min_deque[0]] > limit):\n                l += 1\n                while(max_deque[0] < l):\n                    max_deque.popleft()\n                while(min_deque[0] < l):\n                    min_deque.popleft()\n                    \n            ans = max(ans, r - l + 1)\n            # print(\\\"iteration\\\")\n            # print(r)\n            # print(ans)\n            # print(r - l + 1)\n            \n        return ans\n            \n            \n", "import heapq\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        longest = 0\n        minHeap = []\n        maxHeap = []\n        front = -1\n        back = 0\n        while back < len(nums):\n            needsShrinking = False\n            if front < len(nums) - 1:\n                front += 1\n                heapq.heappush(minHeap, (nums[front], front))\n                heapq.heappush(maxHeap, (-nums[front], front))\n            else:\n                needsShrinking = True\n                \n            while needsShrinking or (minHeap and maxHeap and abs(minHeap[0][0] + maxHeap[0][0]) > limit):\n                needsShrinking = False\n                back += 1\n                while minHeap and minHeap[0][1] < back: heapq.heappop(minHeap)\n                while maxHeap and maxHeap[0][1] < back: heapq.heappop(maxHeap)\n            \n            longest = max(longest, front - back + 1)\n            \n        return longest", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minheap = [[nums[0],0]]\n        maxheap = [[-nums[0],0]]\n        left = -1\n        res = 1\n        for i,val in enumerate(nums[1:]):\n            j = i+1\n            while len(maxheap) and len(minheap) and max(val,-maxheap[0][0]) - min(val,minheap[0][0]) > limit:\n                if val == max(val,-maxheap[0][0]):\n                    v,l = heapq.heappop(minheap)\n                if minheap and val == min(val,minheap[0][0]):\n                    v,l = heapq.heappop(maxheap)\n                left = max(l,left)\n            res = max(j-left,res)\n            heapq.heappush(minheap,[val,j])\n            heapq.heappush(maxheap,[-val,j])\n        return res", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ret, vals = 0, SortedList()\n        l, r, n = 0, 0, len(nums)\n        \n        while r < n:\n            vals.add(nums[r])\n            \n            while vals[-1] - vals[0] > limit:\n                vals.remove(nums[l])\n                l += 1\n            r += 1\n            ret = max(ret, r - l)\n        return ret\n", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        \n        minhp=[]\n        maxhp=[]\n        i=0\n        ans=0\n        for j,el in enumerate(nums):\n            heapq.heappush(minhp,[el,j])\n            heapq.heappush(maxhp,[-el,j])\n            while -maxhp[0][0]-minhp[0][0]>limit:\n                i=min(maxhp[0][1],minhp[0][1])+1\n                while maxhp[0][1]<i: heapq.heappop(maxhp)\n                while minhp[0][1]<i: heapq.heappop(minhp)\n            ans=max(ans,j-i+1)\n        return ans\n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxd = []\n        mind = []\n        left = 0\n        sol = 1\n        for i, num in enumerate(nums):\n            while maxd and nums[maxd[-1]] < num: maxd.pop()\n            while mind and nums[mind[-1]] > num: mind.pop()\n            maxd.append(i)\n            mind.append(i)\n            while nums[maxd[0]] - nums[mind[0]] > limit:\n                if nums[maxd[0]] == nums[left] : maxd.pop(0)\n                if nums[mind[0]] == nums[left] : mind.pop(0)\n                left += 1\n            sol = max(sol, i - left + 1)\n            #print(maxd,mind,sol,left)\n        return sol", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        mxh, mnh = [], []\n        i = j = 0\n        ans = 0\n        while i < len(nums):\n            if j < len(nums) and (not mxh or not mnh or abs(mxh[0][0] + mnh[0][0]) <= limit):\n                heappush(mnh, [nums[j], j])\n                heappush(mxh, [-nums[j], j])\n                j += 1\n            else:\n                if (not mxh or not mnh or abs(mxh[0][0] + mnh[0][0]) <= limit):\n                    ans = max(ans, j - i)\n                else:\n                    ans = max(ans, j - i - 1)\n                    \n                i += 1\n                while mxh and mxh[0][1] < i:\n                    heappop(mxh)\n                while mnh and mnh[0][1] < i:\n                    heappop(mnh)\n        return ans", "from collections import deque\nclass MinQ:\n    def __init__(self):\n        self.Q = collections.deque([])\n    def append(self,num):\n        cnt = 0\n        while self.Q and self.Q[-1][0] >= num:\n            cnt += self.Q.pop()[1] + 1\n        self.Q.append([num,cnt])\n        \n    def popleft(self):\n        if not self.Q:\n            return None\n        if self.Q[0][1] == 0:\n            self.Q.popleft()\n        else:\n            self.Q[0][1] -= 1\n    @property\n    def minv(self):\n        return self.Q[0][0]\n\nclass MaxQ:\n    def __init__(self):\n        self.Q = collections.deque([])\n    def append(self,num):\n        cnt = 0\n        while self.Q and self.Q[-1][0] <= num:\n            cnt += self.Q.pop()[1] + 1\n        self.Q.append([num,cnt])\n        \n    def popleft(self):\n        if not self.Q:\n            return None\n        if self.Q[0][1] == 0:\n            self.Q.popleft()\n        else:\n            self.Q[0][1] -= 1\n    @property\n    def maxv(self):\n        return self.Q[0][0]\n    \n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        left = 0\n        res = 0\n        right = 0\n        maxq = MaxQ()\n        minq = MinQ()\n        while right < n:\n            maxq.append(nums[right])\n            minq.append(nums[right])\n            while maxq.maxv - minq.minv > limit:\n                maxq.popleft()\n                minq.popleft()\n                left += 1\n            res = max(right - left + 1, res)\n            right += 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # heap maps\n        max_heap, min_heap = [], []\n        max_len = 0\n        l = 0\n        \n        for r,n in enumerate(nums):\n            heapq.heappush(max_heap, (-n,r))\n            heapq.heappush(min_heap, (n,r))\n            \n            while -max_heap[0][0]-min_heap[0][0] > limit:\n                l = min(max_heap[0][1], min_heap[0][1]) + 1\n                \n                while max_heap[0][1] < l:   heapq.heappop(max_heap)\n                while min_heap[0][1] < l:   heapq.heappop(min_heap)\n            max_len = max(max_len, r-l+1)\n        return max_len\n        \n        \n        \n        \n        \n        '''\n        # using heaps\n        maxq, minq = [], []\n        n = len(nums)\n        \n        r = 0\n        for l in range(n):\n            heapq.heappush(maxq, (-nums[i], l))\n            heapq.heappush(minq, (nums[i], l))\n            \n            \n            while abs(maxq[0][0] + minq[0][0]) <= limit:\n                while max[0][0]\n        '''", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n#         minheap=[]\n#         maxheap=[]\n#         heapq.heapify(minheap)\n#         heapq.heapify(maxheap)\n        \n#         heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n#         heapq.heappush(maxheap,[-nums[0],0])\n\n        \n#         begin = 0\n#         length = 1        \n#         end = 1\n#         next_idx = 0\n#         while begin <= end and end < len(nums) - 1:\n            \n#             if abs(minheap[0][0] - nums[end]) <= limit and abs(abs(maxheap[0][0]) - nums[end]) <= limit:\n#                 length = max(length, end - begin + 1)\n#                 heapq.heappush(minheap, [nums[end],end])\n#                 heapq.heappush(maxheap, [-nums[end],end])\n#                 end+=1\n#             else:\n#                 while len(minheap) and abs(minheap[0][0] - nums[end]) > limit:\n#                     ele,idx = heapq.heappop(minheap)\n#                     next_idx = max(next_idx, idx)\n#                 while len(maxheap) and abs(maxheap[0][0] - nums[end]) > limit:\n#                     ele,idx = heapq.heappop(maxheap)\n#                     next_idx = max(next_idx, idx)\n#                 begin = next_idx + 1 \n#                 heapq.heappush(minheap, [nums[end],end])\n#                 heapq.heappush(maxheap, [-nums[end],end])\n#                 end+=1\n#         return length\n        \n        minheap=[]\n        maxheap=[]\n        heapq.heapify(minheap)\n        heapq.heapify(maxheap)\n        length=1\n        i=0\n        j=1\n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n        heapq.heappush(maxheap,[-nums[0],0])\n        maxindex=0\n        while i<=j and j<=len(nums)-1:\n            if abs(minheap[0][0]-nums[j])<=limit and abs(abs(maxheap[0][0])-nums[j])<= limit:\n                length=max(length,j-i+1)\n                heapq.heappush(minheap,[nums[j],j])\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            else:\n                while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(minheap)\n                    maxindex=max(maxindex,index)\n                while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(maxheap)\n                    maxindex=max(maxindex,index)\n                i=maxindex+1   # update i and now  we are not concerned with element before ith index\n                heapq.heappush(minheap,[nums[j],j]) # add  element and its index\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            \n        return length\n        \n#         def isValid(int_diff, j, max_value, min_value, limit, nums):\n#             max_boundary = abs(max_value - nums[j])\n#             min_boundary = abs(min_value - nums[j])\n#             return int_diff <= limit and max_boundary <= limit and min_boundary <= limit\n        \n#         def find_error(int_diff,i, j, max_value, min_value, limit, nums,cache):\n#             max_boundary = abs(max_value - nums[j])\n#             min_boundary = abs(min_value - nums[j])\n            \n#             if int_diff > limit: return i\n#             if max_boundary > limit: return cache[max_value]\n#             if min_boundary > limit: return cache[min_value]\n            \n#         output = 1\n#         i = 0\n#         idx = 0\n#         cache = defaultdict(int)\n#         while i < len(nums) and idx < len(nums)-1:\n#             min_value = float('inf')\n#             max_value = float('-inf')\n#             cache[min_value] = i\n#             cache[max_value] = i\n#             for j in range(i,len(nums)):\n                \n#                 int_diff = abs(nums[j] - nums[i])\n#                 temp_min = min_value\n#                 temp_max = max_value\n#                 min_value = min(min_value, nums[j])\n#                 max_value = max(max_value, nums[j])\n#                 if temp_min != min_value:\n#                     cache[min_value] = j\n#                 if temp_max != min_value:\n#                     cache[max_value] = j\n#                 if isValid(int_diff, j, max_value, min_value, limit, nums):\n#                     output = max(output, (j - i) + 1)\n#                 else:\n#                     i = find_error(int_diff, i, j, max_value, min_value, limit, nums,cache) + 1\n                    \n#                     break\n#                 idx = j\n#         return output\n                \n                \n        \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxd = collections.deque()\n        mind = collections.deque()\n        \n        \n        i = 0 \n        for a in nums:\n            # print(a)\n            # print(maxd)\n            # print(mind)\n            while len(maxd) and a>maxd[-1]:\n                maxd.pop()\n            while len(mind) and a<mind[-1]:\n                mind.pop();\n            # print(maxd)\n            # print(mind)\n            maxd.append(a)\n            mind.append(a)\n            # print(maxd)\n            # print(mind)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == nums[i]:\n                    maxd.popleft()\n                if mind[0] == nums[i]:\n                    mind.popleft()\n                    \n                i += 1\n     \n        return len(nums) - i", "from sortedcontainers import SortedList \n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        sl = SortedList()\n        start = 0\n        ans = 0\n        for end in range(len(nums)):\n            x = nums[end]\n            sl.add(x)\n            while sl[-1] - sl[0] > limit and start <= end:\n                sl.remove(nums[start])\n                start += 1\n            if start <= end:\n                ans = max(ans, end - start + 1)\n        return ans\n                \n", "import heapq\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_heap = []\n        max_heap = []\n        i,j = 0,0\n        res = 0\n        while i<len(nums) and j<len(nums):\n            heapq.heappush(min_heap,(nums[j],j))\n            heapq.heappush(max_heap,(-nums[j],j))\n            while -max_heap[0][0]-min_heap[0][0] > limit:\n                i = min(i,min_heap[0][1],max_heap[0][1]) + 1\n                while max_heap[0][1]<i:\n                    heapq.heappop(max_heap)\n                while min_heap[0][1]<i:\n                    heapq.heappop(min_heap)\n            res = max(res,j-i+1)\n            j += 1\n        return res\n                \n            \n                    \n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxs, mins = [], []\n        \n        res = 0\n        start = 0\n        for i, n in enumerate(nums):\n            while maxs and maxs[-1] < n:\n                maxs.pop()\n            \n            while mins and mins[-1] > n:\n                mins.pop()\n            \n            maxs.append(n)\n            mins.append(n)\n            \n            while maxs[0] - mins[0] > limit:\n                if maxs[0] == nums[start]:\n                    maxs.pop(0)\n                if mins[0] == nums[start]:\n                    mins.pop(0)\n                start += 1\n                \n            res = max(res, i - start + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) == 0:\n            return 0\n        \n        if len(nums) == 1:\n            return 1\n        \n        # The top of maxStack is the position of the max element currently\n        # being used by the subarray.\n        # As the algorithm (which grows that subarray righwards) discovers new elements that\n        # are incompatible with the current max, we ditch this current max and check for validity\n        # with the next max. Thus the maxStack contains a sequence of positions of the next\n        # possible. This also means the values must be decreasing (think about why).\n        maxStack = []\n        \n        # Same for minStack, but for mins.\n        minStack = []\n        result = 1\n        \n        # The subarray goes from leftPos to i.\n        leftPos = 0\n        for i in range(0, len(nums)):\n            # if nums[i] exceeds the max, keep popping off the max and try\n            # again with the next max. Naturally, we update leftPos since\n            # the leftmost valid position is moving until we find a valid max\n            while maxStack and nums[i] < nums[maxStack[0]] - limit:\n                leftPos = max(leftPos, maxStack.pop(0) + 1)\n            \n            # We do the same for minimum\n            while minStack and nums[i] > nums[minStack[0]] + limit:\n                leftPos = max(leftPos, minStack.pop(0) + 1)\n                \n            length = i - leftPos + 1\n            if length > result:\n                result = length\n                \n            # recall: maxStack[0] must always be the currently used maximum. And the next elements\n            # contain the next one to try if we have to ditch maxStack[0]\n            # This means if nums[i] is larger than\n            # ALL the elements in maxStack, then of course nums[i] should become our current max. To do\n            # that we pop away the entirety of maxStack and push i onto it. But if nums[i] is larger\n            # than some elements of maxStack, we pop away only those elements and then stop. Then we push\n            # i to the end because it represents a possible next maximum that can be used in the future\n            while maxStack and nums[i] > nums[maxStack[-1]]:\n                maxStack.pop()\n            maxStack.append(i)\n            while minStack and nums[i] < nums[minStack[-1]]:\n                minStack.pop()\n            minStack.append(i)\n            \n        return result", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        sl = SortedList([])\n        \n        st, end, res = 0, 0, 0\n        for val in nums:\n            sl.add(val)\n            end+=1\n            \n            while abs(sl[0] - sl[-1]) > limit:\n                sl.remove(nums[st])\n                st+=1\n            \n            res = max(res, end - st)\n        return res", "#TRY 8/19/2020 \nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_deque = collections.deque()\n        min_deque = collections.deque()\n        \n        start = 0\n        end = 0 \n        max_limit_subarray = 0\n        for end in range(len(nums)): \n            while min_deque and nums[end] < nums[min_deque[-1]]: \n                min_deque.pop()\n            min_deque.append(end)\n            \n            while max_deque and nums[end] > nums[max_deque[-1]]: \n                max_deque.pop()\n                \n            max_deque.append(end)\n            \n            # max_val = nums[max_deque[0]]\n            # min_val = nums[min_deque[0]]\n            # limit_break = abs(max_val - min_val)\n            while abs(nums[max_deque[0]] - nums[min_deque[0]]) > limit: #limit has been broken. \n#                 limit_break -= nums[start]\n                start += 1 #shrink the window.\n                if start > min_deque[0]: \n                    min_deque.popleft()\n                if start > max_deque[0]:\n                    max_deque.popleft()\n                \n             \n            \n            #Get the best window length so far.        \n            max_limit_subarray = max(max_limit_subarray, end - start + 1)\n            \n        return max_limit_subarray\n                \n            \n            \n            \n# class Solution:\n#     def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         # sanity check\n#         if nums is None or len(nums) <= 1 or limit < 0:\n#             return 1\n        \n#         # sliding window approach in O(n) time\n#         max_len, l, r = 0, 0, 0\n        \n#         # notice that, the only absolute difference we need to check is the \n#         # maximum possible absolute difference since it ensures there are no\n#         # other absolute differences that can be bigger than @limit\n#         max_val, min_val = 0, 0\n        \n#         # dequeu method of keeping a local min and max over a sliding window in \n#         # amortized O(1) time \n#         # reference: https://www.nayuki.io/page/sliding-window-minimum-maximum-algorithm\n#         min_dq, max_dq = [], []\n        \n#         while r < len(nums):\n#             val = nums[r] \n            \n#             # update min_dq\n#             while len(min_dq) > 0 and val < min_dq[-1]:\n#                 min_dq.pop()\n#             min_dq.append(val)\n            \n#             # update max_dq\n#             while len(max_dq) > 0 and val > max_dq[-1]:\n#                 max_dq.pop()\n#             max_dq.append(val)\n\n#             max_val = max_dq[0]\n#             min_val = min_dq[0]\n            \n#             diff = abs(max_val - min_val)\n            \n#             # note that we do not have to worry about the left pointer passing the right one\n#             if diff > limit:\n#                 # recalculate min and max values of window by updating dequeues\n#                 check = nums[l]\n#                 if check == min_dq[0]:\n#                     min_dq.pop(0)\n#                 if check == max_dq[0]:\n#                     max_dq.pop(0)\n                \n#                 # shrink window\n#                 l += 1\n            \n#             # expand window\n#             max_len = max(max_len, r - l + 1)\n#             r += 1\n        \n#         return max_len  \n\n\n# class Solution:\n#     def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         #int array nums\n#         #int limit \n#         #ret longest non-empty subarray s.t \n#         #the absolute diff betweeen any two elemetns of the subarray is <= limit \n        \n#         start = 0\n#         end = 0 \n        \n#         min_ele = float('inf')\n#         max_ele = float('-inf')\n#         sub_array = []\n        \n#         contig_sub = float('-inf')\n#         #currently start at zero but let's see if we can try to start at the end maybe? \n#         while end < len(nums):\n#             sub_array = nums[start:end + 1]\n#             limit_breaker = abs(max(sub_array) - min(sub_array))\n            \n#             while limit_breaker > limit: #You are too much :'( \n#                 tmp = start \n            \n#                 limit_breaker -= nums[tmp]\n#                 # start += 1 #This is too early because once we've subtracted we're using it \n#                 #This means that start wil lbe < 1 for contig sub potentially. \n                \n#             if limit_breaker <= limit: #You are okay. \n#                 contig_sub = max(contig_sub, end - start + 1)\n#             end += 1\n        \n#         return contig_sub\n\n# class Solution:\n#     def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         #Queues to take the min and the max of our subarray so far.\n#         min_deque, max_deque = deque(), deque()\n#         l = r = 0\n#         ans = 0\n#         while r < len(nums):\n#             #Min_deque has the minimum value position and check if there are better ones \n#             while min_deque and nums[r] <= nums[min_deque[-1]]:\n#                 min_deque.pop()\n#             min_deque.append(r)\n            \n#             #Max_deque has the maximum value position and check if there are better ones \n#             while max_deque and nums[r] >= nums[max_deque[-1]]:\n#                 max_deque.pop()\n#             max_deque.append(r)\n            \n#             #Limit break the limit? \n#             #If it does then we can find the next one. \n#             while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n#                 l += 1\n#                 #if the next position is > than our current one than we know it's no longer a part of the subarray.\n#                 if l > min_deque[0]:\n#                     min_deque.popleft()\n#                 if l > max_deque[0]:\n#                     max_deque.popleft()\n            \n#             ans = max(ans, r - l + 1)\n#             r += 1\n                \n#         return ans\n                         \n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        res, last = 0, -1\n        maxQ, minQ = deque(), deque()\n        for i, val in enumerate(nums):\n            while maxQ and nums[maxQ[0]] - val > limit:\n                last = max(last, maxQ.popleft())\n            while minQ and val - nums[minQ[0]] > limit:\n                last = max(last, minQ.popleft())\n            #res = max(res, i - last)\n            if i - last > res: res = i - last\n            while maxQ and val >= nums[maxQ[-1]]:\n                maxQ.pop()\n            maxQ.append(i)\n            while minQ and val <= nums[minQ[-1]]:\n                minQ.pop()\n            minQ.append(i)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        i = 0\n        j = 0\n        n = len(nums)\n        maxq = []\n        minq = []\n        max_l = 0\n        \n        while i < n and j < n:\n            while maxq and nums[j] > maxq[-1]:\n                maxq.pop()\n            while minq and nums[j] < minq[-1]:\n                minq.pop()\n                \n            maxq.append(nums[j])\n            minq.append(nums[j])\n            \n            while maxq[0] - minq[0] > limit:\n                if nums[i] == maxq[0]:\n                    maxq.pop(0)\n                if nums[i] == minq[0]:\n                    minq.pop(0)\n                i += 1\n            max_l = max(max_l, j - i + 1)\n            j += 1\n        return max_l", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        '''\n        \u6839\u636e\u8981\u6c42\uff0c\u5b50\u4e32\u4efb\u610f\u4e24\u4e2a\u6570\u4e4b\u95f4\u7684\u5dee\u8981\u5c0f\u4e8e\u7b49\u4e8elimit\n        \u6240\u4ee5\u5229\u7528\u9012\u589e\u6808\u4e0e\u9012\u51cf\u6808\u8bb0\u5f55\u5b50\u4e32\u7684\u6700\u5927\u4e0e\u6700\u5c0f\u503c\n        maxs[0]-mins[0] \u4f5c\u4e3a\u5b50\u6570\u7ec4\u7684\u6700\u5927maxdiff\n        '''\n        n=len(nums)\n        maxs=[]  #\u9012\u51cf\u6808\n        mins=[]  #\u9012\u589e\u6808\n        #maxs[0]-mins[0] \u4f5c\u4e3a\u5b50\u6570\u7ec4\u7684\u6700\u5927maxdiff\n        l=res=0\n        for r in range(n):\n            while maxs and maxs[-1]<nums[r]:\n                maxs.pop()\n            maxs.append(nums[r])\n            while mins and mins[-1]>nums[r]:\n                mins.pop()\n            mins.append(nums[r])\n            while maxs[0]-mins[0]>limit:\n                if maxs[0]==nums[l]:\n                    maxs.pop(0)\n                if mins[0]==nums[l]:\n                    mins.pop(0)\n                l+=1\n            res=max(res,r-l+1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        mx, mi = [0], [0]\n        res = 1\n        left = 0\n        for c in range(1, len(nums)):\n            num = nums[c]\n            while mx and nums[mx[-1]] < num:\n                mx.pop()\n            mx.append(c)\n            while mi and nums[mi[-1]] > num:\n                mi.pop()\n            mi.append(c)\n            while mi and mx and nums[mx[0]] - nums[mi[0]] > limit:\n                left += 1\n                if left > mx[0]:\n                    mx.pop(0)\n                if left > mi[0]:\n                    mi.pop(0)\n            res = max(res, c - left + 1)\n        return res", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # we keep two pointers and we keep track of min and max between those pointers\n        # if the new number being added is having difference from both min and max within the range we increase j and update min and max if necessary else we increase i till we get the difference less than target while changing i and also we keep on updating the min and max\n        # it can mark the beginning of a new sub array\n        # however if we can make this update faster constant time and at max we need to increase i from i to j by deleting each number then also it is in worse case O(nk) instead of linear we can save sometime\n        # we do not need indices and so we can use SortedList instead of SortedDict to make processing of finding min and max after changing i faster\n        s = SortedList()\n        # we keep on adding new values to the sortedList and when we get max - min greater than target then we keep on removing values from the list till the sorted list becomes valid again\n        max_length = 0\n        j = 0\n        for i in range(len(nums)):\n            s.add(nums[i])\n            while s and s[-1] - s[0] > limit:\n                s.remove(nums[j])\n                j += 1\n            max_length = max(max_length,i-j + 1)\n        return max_length\n        \n        \n        \n        \n        # for the following approach also the time limit gets exceeded because although operations on dictionary are O(logn) we are doing them for more number of times then expected\n        '''\n        # i.e. if min is our problem then we need to increase i till we find new min \n        # i.e we need to start from i = i + max_index of current_min\n        # and if max is our problem then we need to increase i till we find new max\n        # i.e we need to start from i = i + max_index of current_max\n        # and if both are a problem then we need to increase i till max when both are changed\n        # this we can do if we use a hashmap mapping each value from i to j with its max index in the array we do not care for intermediate indices\n        max_length = -float('inf')\n        mapping = SortedDict()\n        Min = nums[0]\n        Max = nums[0]\n        mapping[Min] = 0\n        i = 0\n        while i < len(nums):\n            j = i\n            # print('a',i,j,Max,Min)\n            while j < len(nums) and abs(nums[j] - Min) <= limit and abs(nums[j] - Max) <= limit:\n                Max = max(Max,nums[j])\n                Min = min(Min,nums[j])\n                # we are just concerned with the max value\n                mapping[nums[j]] = j\n                j += 1\n                max_length = max(max_length,j - i)\n                \n            # print('b',i,j,Min,Max)\n            if j >= len(nums)-1:\n                break\n            else:\n                mapping[nums[j]] = j\n                while i <= j and (abs(nums[j] - Min) > limit or abs(nums[j] - Max) > limit):\n                    if abs(nums[j] - Min) > limit and abs(nums[j] - Max) > limit:\n                        i = max(i,max(mapping[Min],mapping[Max]) + 1)\n                        del mapping[Max]\n                        if Min in mapping.keys():\n                            del mapping[Min]\n\n                    elif abs(nums[j] - Min) > limit:\n                        i = max(i,mapping[Min] + 1)\n                        del mapping[Min]\n                        \n                    elif abs(nums[j] - Max) > limit:\n                        i = max(i,mapping[Max] + 1)\n                        del mapping[Max]\n                    # after each update we need to update min and max and the following steps will take O(n)\n                    Min = mapping.peekitem(0)[0]\n                    Max = mapping.peekitem()[0]\n                    while mapping[Min] < i:\n                        del mapping[Min]\n                        Min = mapping.peekitem(0)[0]\n                    while mapping[Max] < i:\n                        del mapping[Max]\n                        Max = mapping.peekitem()[0]\n                    \n                # print(mapping)\n                # print('c',i,j,Max,Min)\n        return max_length\n        \n        '''\n        # for the following approach time limit gets exceeded\n        '''\n        max_length = -float('inf')\n        Min = nums[0]\n        Max = nums[0]\n        i = 0\n        while i < len(nums):\n            j = i \n            #print('a',i,j,Max,Min)\n            while j < len(nums) and abs(nums[j] - Min) <= limit and abs(nums[j] - Max) <= limit:\n                Max = max(Max,nums[j])\n                Min = min(Min,nums[j])\n                j += 1\n                max_length = max(max_length,j - i)\n            #print('b',i,j,Max,Min,len(nums))\n            if j >= len(nums)-1:\n                break\n            else:\n                while i < j and nums[i] != Min and nums[i] != Max:\n                    i += 1\n                while i < j and (abs(nums[j] - Min) > limit or abs(nums[j] - Max) > limit):\n                    i += 1\n                    #print(i)\n                    Min = min(nums[i:j+1])\n                    Max = max(nums[i:j+1])\n                    #print('c',i,j,Max,Min)\n        return max_length\n        '''            \n        \n        \n        \n", "class Solution:\n  def longestSubarray(self, nums: List[int], limit: int) -> int:\n    result = 0\n    min_deque = []\n    max_deque = []\n    start = 0\n    for index, value in enumerate(nums):\n      while len(min_deque) and value < min_deque[-1]:\n        min_deque.pop()\n      while len(max_deque) and value > max_deque[-1]:\n        max_deque.pop()\n\n      min_deque.append(value)\n      max_deque.append(value)\n\n      while max_deque[0] - min_deque[0] > limit:\n        if nums[start] == min_deque[0]:\n          min_deque.pop(0)\n        if nums[start] == max_deque[0]:\n          max_deque.pop(0)\n        start += 1\n\n      result = max(result, index - start + 1)\n\n    return result\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        from collections import deque\n        n = len(nums)\n        l, r = 0, -1\n        max_window, min_window = deque(), deque()\n        \n        while r<n-1:\n            r+=1\n            while max_window and max_window[-1]<nums[r]:\n                max_window.pop()\n            while min_window and min_window[-1]>nums[r]:\n                min_window.pop()\n                \n            max_window.append(nums[r])\n            min_window.append(nums[r])\n            if max_window[0]-min_window[0]>limit:\n                if max_window[0]==nums[l]:\n                    max_window.popleft()\n                if min_window[0]==nums[l]:\n                    min_window.popleft()\n                l+=1\n                \n        return r-l+1", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # Use sortedList to maintain the max/min of the subarray \n        from sortedcontainers import SortedList\n        wd = SortedList([nums[0]])  # window\n        max_len = 1\n        \n        l = 0\n        r = 0\n        while r < len(nums):\n            minn = wd[0]\n            maxx = wd[-1]\n            if maxx-minn <= limit:\n                max_len = max(max_len, r-l+1)\n                # extend right\n                r += 1\n                if r < len(nums):\n                    wd.add(nums[r])\n            else:\n                # shrink left\n                wd.discard(nums[l])\n                l += 1\n        return max_len", "from typing import List\nfrom sortedcontainers import SortedList\n\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i, j = 0, 0\n        maxLen = 1\n        sortedInterval = SortedList([nums[0]])\n\n        while i <= j < len(nums):\n            minVal, maxVal = sortedInterval[0], sortedInterval[-1]\n            if maxVal - minVal <= limit:\n                maxLen = max(j - i + 1, maxLen)\n                j += 1\n                if j < len(nums):\n                    sortedInterval.add(nums[j])\n            elif i < j:\n                sortedInterval.discard(nums[i])\n                i += 1\n            else:\n                j += 1\n                i = j\n\n        return maxLen\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res\n                \n                \n                \n            \n            \n            \n        \n        \n", "def add_to_max_heap(heap,value):\n    heapq.heappush(heap,value)\n\ndef add_to_min_heap(heap,value):\n    heapq.heappush(heap,value)\n\ndef get_max_val(heap):\n    return heap[0][0]\n\ndef get_min_val(heap):\n    return heap[0][0]\n\n\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = 0\n        r = 0\n        ans = 0\n        max_heap = []\n        min_heap = []\n        \n        while l < len(nums) and r < len(nums):\n            # print(l,r)\n            add_to_max_heap(max_heap,(-nums[r],r))\n            add_to_min_heap(min_heap,(nums[r],r))\n            \n            max_val = -get_max_val(max_heap)\n            min_val = get_min_val(min_heap)\n            if abs(max_val-min_val) <= limit:\n                ans = max(ans,r-l+1)\n                r+=1\n            else:\n                while min_heap and min_heap[0][1] < l+1:\n                    heapq.heappop(min_heap)\n                while max_heap and max_heap[0][1] < l+1:\n                    heapq.heappop(max_heap)\n                l+=1\n        return ans\n            \n            \n            \n            \n            \n        \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        min_heap = []\n        max_heap = []\n        longest_window = 1\n        \n        min_idx = 0\n        for i, num in enumerate(nums):\n            \n            heapq.heappush(min_heap, (num, i))\n            heapq.heappush(max_heap, (-num, i))\n            # print(min_heap)\n            # print(max_heap)\n            # print(min_heap[0][0], max_heap[0][0])\n            \n            while min_heap[0][1] < min_idx:\n                heapq.heappop(min_heap)\n            while max_heap[0][1] < min_idx:\n                heapq.heappop(max_heap)\n            if abs(min_heap[0][0] + max_heap[0][0]) > limit:\n                #print('here')\n                if (min_heap[0][1] < max_heap[0][1]):\n                    min_idx = min_heap[0][1] + 1\n                    heapq.heappop(min_heap)\n                    #print('min_idx', min_idx)\n                else:\n                    min_idx = max_heap[0][1] + 1\n                    heapq.heappop(max_heap)\n                    \n            #print(min_heap[0][1], max_heap[0][1])\n            #print(min_idx, i)\n            longest_window = max(longest_window, i - min_idx + 1)\n                                 \n                                 \n        return longest_window\n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        rlt = 1\n        q = collections.deque([nums[0]])\n        max_stack, min_stack = [nums[0]], [nums[0]]\n        for i in range(1, len(nums)):\n            while max_stack and (max_stack[0] - nums[i] > limit or\n                                 nums[i] - min_stack[0] > limit):\n                head = q.popleft()\n                if head == max_stack[0]:\n                    max_stack.pop(0)\n                if head == min_stack[0]:\n                    min_stack.pop(0)\n            q.append(nums[i])\n            while max_stack and max_stack[-1] < nums[i]:\n                max_stack.pop()\n            while min_stack and min_stack[-1] > nums[i]:\n                min_stack.pop()\n            max_stack.append(nums[i])\n            min_stack.append(nums[i])\n            rlt = max(rlt, len(q))\n            \n        return rlt", "# [10, 1, 2, 4, 7, 2]\n# pqmax: [(-7, 4), (-4, 3), (-2, 2), (-1, 1), (-2, 5)]\n# pqmin: [(2, 2), (2, 5), (7, 4), (10, 0), (4, 3)]\n# end: 5\n# start: 2\n\nimport heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not len(nums):\n            return 0\n        \n        output = 1 \n        s_idx = 0\n        e_idx = 0\n        pqmin = []\n        pqmax = []\n        \n        for e_idx in range(len(nums)):\n            heapq.heappush(pqmin, (nums[e_idx], e_idx))\n            heapq.heappush(pqmax, (-nums[e_idx], e_idx))\n            \n            while s_idx < e_idx and abs(pqmax[0][0] + pqmin[0][0]) > limit:\n                s_idx += 1\n                while pqmax and pqmax[0][1] < s_idx:\n                    heapq.heappop(pqmax)\n                while pqmin and pqmin[0][1] < s_idx:\n                    heapq.heappop(pqmin)\n            \n            output = max(output, e_idx-s_idx+1)\n        return output\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            while maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i\n    \nfrom collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            res = max(res, j-i+1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        winMax = [0]\n        winMin = [0]\n\n        i = j = 0\n        res = 0\n        while i<len(nums)-1 and j<len(nums)-1:\n            \n            diff = nums[winMax[0]] - nums[winMin[0]]\n            #print(i,j,diff,winMax,winMin)\n            if diff <= limit:\n                res = max(res,j-i+1)\n                \n            if diff <= limit:\n                j += 1\n                while winMax and nums[j]>nums[winMax[-1]]:\n                    winMax.pop(-1)\n                winMax.append(j)\n                while winMin and nums[j]<nums[winMin[-1]]:\n                    winMin.pop(-1)\n                winMin.append(j)\n\n            else:\n                if i == winMax[0]:\n                    winMax.pop(0)\n                if i == winMin[0]:\n                    winMin.pop(0)\n                i += 1\n                \n        diff = nums[winMax[0]] - nums[winMin[0]]\n        if diff <= limit:\n            res = max(res,j-i+1)\n            \n        return res\n                \n", "import bisect\n\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if limit < 0:\n            return 0\n        \n        n = len(nums)\n        if n < 2:\n            return n\n        \n        # sliding window to calculate min-max range\n        # extend window if range is within limit r -->\n        # shrink window if range is off limit l -->\n        # sliding window is a sorted subarray\n        \n        longest = 1\n        l, r = 0, 0\n        window = []\n        while l < n and r < n:\n            if not window:\n                window.append(nums[r])\n                r += 1\n            else:\n                curr = nums[r]\n                minimum, maximum = window[0], window[-1]\n                if abs(curr - minimum) <= limit and abs(curr - maximum) <= limit:\n                    bisect.insort(window, curr)\n                    r += 1\n                    longest = max(longest, r - l)\n                else:\n                    window.remove(nums[l])\n                    l += 1\n        return longest", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        max_q, min_q = [],[]\n        ans = 1\n        l = 0\n        for i,num in enumerate(nums):\n            while len(max_q) and nums[max_q[-1]] < num:\n                max_q.pop(-1)\n            while len(min_q) and nums[min_q[-1]] > num:\n                min_q.pop(-1)\n            min_q.append(i)\n            max_q.append(i)\n            # print(max_q, min_q)\n            # max_num = max_q[0]\n            # min_num = min_q[0]\n            while(nums[max_q[0]]-nums[min_q[0]] > limit):\n                if max_q[0] > min_q[0]:\n                    l = min_q.pop(0) + 1\n                else:\n                    l = max_q.pop(0) + 1\n            # ans = max(abs(max_q[0]-min_q[0]) +1, ans) \n            ans = max(i-l +1, ans) \n        return ans\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        incr_q = [nums[0]]\n        decr_q = [nums[0]]\n        \n        res = 1\n        \n        left = 0\n        right = 1\n        \n        while right < len(nums):\n            while incr_q and incr_q[-1] > nums[right]:\n                incr_q.pop()\n            incr_q.append(nums[right])\n            \n            while decr_q and decr_q[-1] < nums[right]:\n                decr_q.pop()\n            decr_q.append(nums[right])\n            \n            while incr_q and decr_q and decr_q[0] - incr_q[0] > limit:\n                if nums[left] == incr_q[0]:\n                    incr_q.pop(0)\n                if nums[left] == decr_q[0]:\n                    decr_q.pop(0)\n                left += 1\n            \n            res = max(right-left+1, res)\n            right += 1\n        \n        return res", "from heapq import heappush, heappop\n\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        discard = -1\n        res = 0\n        minq, maxq = [], []\n        \n        for i in range(len(nums)):\n            while (minq and abs(nums[i] - minq[0][0]) > limit):\n                _, index = heappop(minq)\n                discard = max(discard, index)\n            heappush(minq, (nums[i], i))\n            while (maxq and abs(nums[i] + maxq[0][0]) > limit):\n                _, index = heappop(maxq)\n                discard = max(discard, index)\n            heappush(maxq, (-nums[i], i))            \n            \n            res = max(res, i - discard)\n        \n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        \n        #left and right index to take out the substring\n        left = 0\n        right = 1\n        #let current max and min equal to the first number\n        cur_max = cur_min = nums[0]\n        #the max lense of the target substring is at least 1\n        max_len = 1\n        \n        while right < len(nums):\n            cur_max = max(cur_max, nums[right])\n            cur_min = min(cur_min, nums[right])\n            \n            if cur_max - cur_min <= limit:\n                max_len = max(max_len, right - left + 1)\n            else:\n                if nums[left] == cur_max:\n                    cur_max = max(nums[left + 1:right + 1]) \n                if nums[left] == cur_min:\n                    cur_min = min(nums[left + 1:right + 1])\n                left += 1\n            right += 1\n        return max_len\n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        left = 0\n        right = 1\n        ans = 1\n        currMax = nums[0]\n        currMin = nums[0]\n        \n        while left <= right and right < len(nums):\n            currMax = max(currMax, nums[right])\n            currMin = min(currMin, nums[right])\n            \n            if currMax - currMin <= limit:\n                ans = max(ans, right - left + 1)\n            else:\n                if nums[left] == currMax:\n                    currMax = max(nums[left+1: right+1])\n                if nums[left] == currMin:\n                    currMin = min(nums[left+1: right+1])\n                left += 1\n            right += 1\n        \n        return ans \n    \n    \n    \n", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        s = SortedList()\n        j = ans = 0\n        for i, val in enumerate(nums):\n            s.add(val)\n            while s and s[-1] - s[0] > limit:\n                s.remove(nums[j])\n                j += 1\n            ans = max(ans, (i - j + 1))\n        return ans\n", "from bisect import insort\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        win = []\n        n = len(nums)\n        i = j = 0\n        max_len = 0\n        \n        while j < n:\n            if not win:\n                win.append(nums[j])\n            else:\n                insort(win, nums[j])\n\n            while win[-1] - win[0] > limit:\n                win.remove(nums[i])\n                i += 1\n                \n            if j - i + 1 > max_len:\n                max_len = j - i + 1\n                \n            j += 1\n                \n        return max_len\n    \n# time: O(n^2)\n# space: O(n)\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            res = max(res, j-i+1)\n        return res\n    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) == 0:\n            return 0\n        dec_stack = [] # stores all the next largest value  (value, pos)\n        inc_stack = [] # stores all the next min value (value, pos)\n        max_interval = 1\n        \n        # two pointer expand and contract, including\n        l, r = 0, 0\n        min_v, max_v = nums[0], nums[0]\n        dec_stack.append((nums[0], 0))\n        inc_stack.append((nums[0], 0))\n        \n        while l < len(nums) and r < len(nums):\n            while max_v - min_v <= limit:\n                max_interval = max(max_interval, r - l + 1)\n                r += 1\n                if r == len(nums):\n                    break\n                # added new values update our stacks\n                while dec_stack and nums[r] > dec_stack[-1][0]:\n                    dec_stack.pop(-1)\n                dec_stack.append((nums[r], r))\n                max_v = dec_stack[0][0]\n                \n                while inc_stack and nums[r] < inc_stack[-1][0]:\n                    inc_stack.pop(-1)\n                inc_stack.append((nums[r], r))\n                min_v = inc_stack[0][0]\n            \n            # now the interval does not fit the limit, contract\n            while max_v - min_v > limit:\n                if dec_stack[0][1] == l:\n                    dec_stack.pop(0)\n                    max_v = dec_stack[0][0]\n                if inc_stack[0][1] == l:\n                    inc_stack.pop(0)\n                    min_v = inc_stack[0][0]\n                l += 1\n                \n        return max_interval\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        from sortedcontainers import SortedList\n        sl = SortedList()\n        l = r = 0\n        result = 1\n        for r in range(len(nums)):\n            sl.add(nums[r])\n            while sl[-1] - sl[0] > limit:\n                sl.remove(nums[l])\n                l += 1\n            \n            result = max(len(sl), result)\n            \n        return result", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        curr_max = nums[0] # \u5f53\u5b50\u6570\u7ec4\u4e0b\u6700\u5927\u503c \u8fd9\u91cc\u521d\u59cb\u5316\u4e3a\u7b2c\u4e00\u4e2a\u6570\n        curr_min = nums[0] # \u5f53\u5b50\u6570\u7ec4\u4e0b\u6700\u5927\u503c \u8fd9\u91cc\u521d\u59cb\u5316\u4e3a\u7b2c\u4e00\u4e2a\u6570\n        sub_nums = [] # \u4ee5\u6570\u7ec4\u4f5c\u4e3a\u7a97\u53e3\u6ed1\u52a8\n        for num in nums:\n            if abs(num - curr_max) <=  limit and abs(num - curr_min) <=  limit and abs(curr_max - curr_min) <= limit:\n                curr_max = max(num,curr_max)\n                curr_min = min(num,curr_min)\n                sub_nums.append(num)\n            else: #\u7f29\u5c0f\u7a97\u53e3   \n                sub_nums.append(num)#\u5148append \u5f53\u524d\u6570\n                sub_nums.pop(0)#\u79fb\u9664\u6700\u5de6\u8fb9\n                curr_max = max(sub_nums) # \u66f4\u65b0\u6700\u503c\n                curr_min = min(sub_nums)\n        return  len(sub_nums)\n\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        curr_max = nums[0] # \u5f53\u5b50\u6570\u7ec4\u4e0b\u6700\u5927\u503c \u8fd9\u91cc\u521d\u59cb\u5316\u4e3a\u7b2c\u4e00\u4e2a\u6570\n        curr_min = nums[0] # \u5f53\u5b50\u6570\u7ec4\u4e0b\u6700\u5927\u503c \u8fd9\u91cc\u521d\u59cb\u5316\u4e3a\u7b2c\u4e00\u4e2a\u6570\n        sub_nums = [] # \u4ee5\u6570\u7ec4\u4f5c\u4e3a\u7a97\u53e3\u6ed1\u52a8\n        for num in nums:\n            if abs(num - curr_max) <=  limit and abs(num - curr_min) <=  limit and abs(curr_max - curr_min) <= limit:\n                curr_max = max(num,curr_max)\n                curr_min = min(num,curr_min)\n                sub_nums.append(num)\n            else: #\u7f29\u5c0f\u7a97\u53e3   \n                sub_nums.append(num)\n                sub_nums.pop(0)\n                curr_max = max(sub_nums) # \u5f53\u5b50\u6570\u7ec4\u6700\u5927\u503c\n                curr_min = min(sub_nums) # \u5f53\u524d\u5b50\u6570\u7ec4\u6700\u5c0f\u503c\n        return  len(sub_nums)\n\n", "\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        low = None\n        curr_max = None\n        curr_low = -1\n        max_len = 0\n        min_queue = []\n        max_queue = []\n        for i in range (len(nums)):\n            curr_num = nums[i]\n            self.queue_add_max(max_queue,curr_num,i)\n            self.queue_add_min(min_queue,curr_num,i)\n            curr_max = max_queue[0][0]\n            curr_min = min_queue[0][0]\n            if (curr_max - curr_min) > limit:\n                while ((curr_max - curr_min) > limit) and (curr_low < i):\n                    curr_low += 1\n                    if (curr_low == min_queue[0][1]):\n                        min_queue.pop(0)\n                    if (curr_low == max_queue[0][1]):\n                        max_queue.pop(0)\n                    curr_max = max_queue[0][0]\n                    curr_min = min_queue[0][0]    \n            curr_dist = i - curr_low\n            if (curr_dist > max_len):\n                max_len = curr_dist\n        return max_len\n                            \n        \n    def queue_add_max(self,queue,element,index):\n        while (queue != []):\n            if element > queue[len(queue) - 1][0]:\n                queue.pop()\n            else:\n                break\n        queue.append((element,index))\n\n    def queue_add_min(self,queue,element,index):\n        while (queue != []):\n            if element < queue[len(queue) - 1][0]:\n                queue.pop()\n            else:\n                break\n        queue.append((element,index))", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        cur_max = nums[0]\n        cur_min = nums[0]\n        sub_nums = [] # \u4ee5\u6570\u7ec4\u4f5c\u4e3a\u7a97\u53e3\u6ed1\u52a8\n        for i in nums:\n            cur_max = max(i,cur_max)\n            cur_min = min(i,cur_min)\n            if cur_max - cur_min <= limit:                \n                sub_nums.append(i)\n            else:    \n                sub_nums.append(i)\n                sub_nums.pop(0)\n                cur_max = max(sub_nums)\n                cur_min = min(sub_nums)\n        return  len(sub_nums)", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        N = len(nums)\n        Lm = 0\n        for j in range(N):\n            a = nums[j]\n            while maxd and maxd[-1]<a:\n                maxd.pop()\n            maxd.append(a)\n\n            while mind and mind[-1]>a:\n                mind.pop()\n            mind.append(a)\n\n            while maxd[0]-mind[0]>limit:\n                if maxd[0] == nums[i]:\n                    maxd.popleft()\n                if mind[0] == nums[i]:\n                    mind.popleft()\n                i += 1\n            Lm = max(Lm, j-i+1)\n\n        return Lm", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # print('start')\n        import sortedcontainers\n        \n        sl = sortedcontainers.SortedList()\n        start, end = 0, 0\n        best = 0\n        while end < len(nums):\n            sl.add(nums[end])\n            if sl[-1] - sl[0] <= limit:\n                best = max(best, len(sl))\n            else:\n                while sl[-1] - sl[0] > limit:\n                    sl.remove(nums[start])\n                    start += 1\n            end += 1\n            # print(len(sl))\n        return best", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        cur_max = nums[0]\n        cur_min = nums[0]\n        sub_nums = collections.deque()\n        for i in nums:\n            cur_max = max(i,cur_max)\n            cur_min = min(i,cur_min)\n            if cur_max - cur_min <= limit:                \n                sub_nums.append(i)\n            else:    \n                sub_nums.append(i)\n                sub_nums.popleft()\n                cur_max = max(sub_nums)\n                cur_min = min(sub_nums)\n        return  len(sub_nums)", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        #https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609701/Python-two-heap-solution\n        minheap = [[nums[0],0]]\n        maxheap = [[-nums[0],0]]\n        left = -1\n        res = 1\n        for i,val in enumerate(nums[1:]):\n            j = i+1\n            while len(maxheap) and len(minheap) and max(val,-maxheap[0][0]) - min(val,minheap[0][0]) > limit:\n                if val == max(val,-maxheap[0][0]):\n                    v,l = heapq.heappop(minheap)\n                elif minheap and val == min(val,minheap[0][0]):\n                    v,l = heapq.heappop(maxheap)\n                left = max(l,left)\n            res = max(j-left,res)\n            heapq.heappush(minheap,[val,j])\n            heapq.heappush(maxheap,[-val,j])\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # 2:37\n        maxD = []\n        minD = []\n        \n        ind = 0\n        res = 0\n        slow = 0\n        fast = 0\n        \n        while slow <= fast and fast < len(nums):\n            \n            while len(maxD) > 0 and maxD[len(maxD)-1] < nums[fast]:\n                maxD.pop(len(maxD)-1)\n            maxD.append(nums[fast])\n            \n            while len(minD) > 0 and minD[len(minD)-1] > nums[fast]:\n                minD.pop(len(minD)-1)\n            minD.append(nums[fast])\n            \n            \n            while maxD[0] - minD[0] > limit and slow < fast:\n                if maxD[0] == nums[slow]:\n                    maxD.pop(0)\n                if minD[0] == nums[slow]:\n                    minD.pop(0)\n                slow += 1\n            \n            res = max(res, fast - slow + 1)\n            fast += 1\n            \n        \n        return res\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        if nums is None or len(nums)==0:\n            return 0;\n        \n        queue=collections.deque([])\n        max_len=0\n        right=0\n        min_heap=[]\n        max_heap=[]\n        for left in range(len(nums)):\n            if left==right:\n                heapq.heappush(min_heap, (nums[left], left))\n                heapq.heappush(max_heap,(-nums[left], left))\n                right+=1\n                \n            while right<len(nums):\n                cur_min=min_heap[0][0]\n                cur_max=-max_heap[0][0]\n                if (abs(nums[right]-cur_min)>limit):\n                    break\n                if (abs(nums[right]-cur_max)>limit):\n                    break\n                heapq.heappush(min_heap,(nums[right], right))\n                heapq.heappush(max_heap,(-nums[right], right))\n                right+=1\n            \n            max_len=max(max_len, right-left)\n            if right==len(nums):\n                return max_len\n            \n            while max_heap and max_heap[0][1]<=left:\n                heapq.heappop(max_heap)\n            while min_heap and min_heap[0][1]<=left:\n                heapq.heappop(min_heap)\n        \n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minheap=[]\n        maxheap=[]\n        heapq.heapify(minheap)\n        heapq.heapify(maxheap)\n        length=1\n        i=0\n        j=1\n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n        heapq.heappush(maxheap,[-nums[0],0])\n        maxindex=0\n        while i<=j and j<=len(nums)-1:\n            if abs(minheap[0][0]-nums[j])<=limit and abs(abs(maxheap[0][0])-nums[j])<= limit:\n                length=max(length,j-i+1)\n                heapq.heappush(minheap,[nums[j],j])\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            else:\n                while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(minheap)\n                    maxindex=max(maxindex,index)\n                while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\n                    ele,index=heapq.heappop(maxheap)\n                    maxindex=max(maxindex,index)\n                i=maxindex+1   # update i and now  we are not concerned with element before ith index\n                heapq.heappush(minheap,[nums[j],j]) # add  element and its index\n                heapq.heappush(maxheap,[-nums[j],j])\n                j=j+1\n            \n        return length\n            \n", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        arr = nums\n        lim = limit\n        p1 = 0\n        p2 = 0\n        ans = 1\n        bt = SortedList([arr[0]])\n        n = len(arr)\n        \n        while p1 < n-1 or p2 < n-1:\n            \n            mx = bt[-1]\n            mn = bt[0]\n            diff = abs(mx-mn)\n            \n            if diff <= lim and ans < p2 - p1 + 1:\n                ans = p2-p1 + 1\n                \n            if p2 == n-1 or diff > lim:\n                bt.remove(arr[p1])\n                p1 += 1\n            else:\n                p2 += 1\n                bt.add(arr[p2])\n        \n        return ans\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for val in nums:\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i\n    \nfrom collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            res = max(res, j - i + 1)\n        return res\n    \nfrom collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > nums[maxQ[-1]]: maxQ.pop()\n            while minQ and val < nums[minQ[-1]]: minQ.pop()\n            maxQ.append(j)\n            minQ.append(j)\n            if nums[maxQ[0]] - nums[minQ[0]] > limit:\n                if maxQ[0] == i: maxQ.popleft()\n                if minQ[0] == i: minQ.popleft()\n                i += 1\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_stack = []\n        min_stack = []\n        left = 0\n        ans = 0\n        for right in range(len(nums)):\n            while max_stack and nums[max_stack[-1]] < nums[right]:\n                max_stack.pop()\n            max_stack.append(right)\n            while min_stack and nums[min_stack[-1]] > nums[right]:\n                min_stack.pop()\n            min_stack.append(right)\n            while max_stack and min_stack and nums[max_stack[0]] - nums[min_stack[0]] > limit:\n                if max_stack[0] <= left:\n                    max_stack.pop(0)\n                if min_stack[0] <= left:\n                    min_stack.pop(0)\n                left += 1\n            ans = max(ans, right - left + 1)\n        return ans\n", "from heapq import heappush, heappop\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # min_stack = []\n        # max_stack = []\n        # for i, number in enumerate(nums):\n        #     _index = i\n        #     while max_stack and number > max_stack[-1][0]:\n        #         _, _index = max_stack.pop()\n        #     max_stack.append((number, _index))\n        #     _index = i\n        #     while min_stack and number < min_stack[-1][0]:\n        #         _, _index = min_stack.pop()\n        #     min_stack.append((number, _index))\n        # longest = -1\n        # start_index = len(nums) - 1\n        # print(max_stack)\n        # print(min_stack)\n        # while max_stack[-1][0] - min_stack[-1][0] <= limit:\n        #     longest = max(\n        #         longest,\n        #         abs(max_stack[-1][1] - min_stack[-1][1])\n        #     )\n        #     if max_stack[-1][1] > min_stack[-1][1]:\n        #         max_stack.pop()\n        #     else:\n        #         min_stack.pop()\n        # return longest\n            \n            \n        min_q = []\n        max_q = []\n        start_index = 0\n        cur_longest_len = 0\n        for i, number in enumerate(nums):\n            heappush(min_q, (number, i))\n            heappush(max_q, (-number, i))\n            while self.calc_diff(-max_q[0][0], min_q[0][0])  > limit:\n                # print(self.calc_diff(-max_q[0][0], min_q[0][0]) )\n                if min_q[0][1] > max_q[0][1]:\n                    value, _index = heappop(max_q)\n                    q = max_q\n                else:\n                    value, _index = heappop(min_q)\n                    q = min_q\n                start_index = max(_index + 1, start_index)\n                # print(start_index, value, q)\n                # print(start_index, _index, value)\n                while q and q[0][1] < start_index:\n                    heappop(q)\n            cur_longest_len = max(\n                cur_longest_len,\n                i - start_index + 1\n            )\n            # if cur_longest_len == 3:\n            #     print(\\\"HERE\\\", start_index, i)\n        # print(max_q)\n        # print(min_q)\n        return cur_longest_len\n    \n    def calc_diff(self, a, b):\n        return abs(a - b)\n    \n", "import bisect\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        if len(nums) <= 1:\n            return len(nums)\n        \n        h = [nums[0]]\n        right, left, max_len = 0, 0, 1\n        lo, hi = nums[0], nums[0]\n        \n        while right < len(nums) and left < len(nums):\n            \n            if abs(hi-lo) <= limit:\n                \n                max_len = max(max_len, right-left+1)\n                \n                right += 1\n                if right < len(nums):\n                    hi = max(nums[right], hi)\n                    lo = min(nums[right], lo)\n                    bisect.insort(h, nums[right])\n            else:\n                del h[bisect.bisect_left(h, nums[left])]\n                lo, hi = h[0], h[-1]\n                left += 1\n        \n        return max_len", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        maxheap, minheap = [(-nums[0], 0)], [(nums[0], 0)]\n        \n        l, res  = 0, 1\n        for i, val in enumerate(nums[1:], 1): \n               \n            if val - minheap[0][0] <= limit and - maxheap[0][0] -val <= limit:\n                res = max(res, i - l + 1)\n            else:\n                \n                while minheap and val - minheap[0][0] > limit:\n                    v, index = heapq.heappop(minheap)\n                    l = max(l, index + 1)\n                while maxheap and -maxheap[0][0] - val > limit:\n                    v, index = heapq.heappop(maxheap)\n                    l = max(l, index + 1)\n            \n            heapq.heappush(minheap, (val, i))\n            heapq.heappush(maxheap, (-val, i))\n            \n        return res \n", "import heapq\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        left = 0\n        right = 0\n\n        max_d = 0\n        min_heap = [nums[0]]\n        max_heap = [-nums[0]]\n\n        local_max = nums[0]\n        local_min = nums[0]\n        \n        while left < n and right < n:\n          if nums[right] > local_max:\n            local_max = nums[right]\n          if nums[right] < local_min:\n            local_min = nums[right]\n\n          lower = local_max - limit\n          upper = local_min + limit\n          \n          if lower <= nums[right] <= upper:\n            if right - left + 1 > max_d:\n              max_d = right - left + 1\n            right += 1\n            if right < n:\n              heapq.heappush(min_heap, nums[right])\n              heapq.heappush(max_heap, -nums[right])\n          else:\n            if nums[left] == min_heap[0]:\n              heapq.heappop(min_heap)\n            else:\n              min_heap.remove(nums[left])\n            if max_heap[0] == -nums[left]:\n              heapq.heappop(max_heap)\n            else:\n              max_heap.remove(-nums[left])\n\n            left += 1\n            local_min = min_heap[0]\n            local_max = -max_heap[0]\n            \n        return max_d\n  \n#     def longestSubarray(self, nums: List[int], limit: int) -> int:sub:\n#       n = len(nums)\n        \n#       max_d = 0\n#       for left in range(n):\n#         local_max = float('-inf')\n#         local_min = float('inf')\n\n#         for right in range(left + 1, n + 1):\n#           sub = nums[left:right]\n          \n#           if local_max < sub[-1]:\n#             local_max = sub[-1]\n            \n#           if local_min > sub[-1]:\n#             local_min = sub[-1]\n          \n#           if local_max - local_min <= limit:\n#             if right - left + 1 > max_d:\n#               max_d = right - left + 1\n#               # print(max_d, right, left, sub)\n#           else:\n#             break\n      \n#       return max_d\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        def addToDeqs(min_deq, max_deq, curr, start_i):\n                \n            while min_deq and min_deq[-1] > curr:\n                min_deq.pop()\n            min_deq.append(curr)\n\n            while max_deq and max_deq[-1] < curr:\n                max_deq.pop()\n            max_deq.append(curr)\n\n            while abs(max_deq[0] - min_deq[0]) > limit:\n                if max_deq[0] == nums[start_i]:\n                    max_deq.pop(0)\n                if min_deq[0] == nums[start_i]:\n                    min_deq.pop(0)\n                start_i += 1\n\n            return start_i\n\n        min_deq = []\n        max_deq = []\n        longest_subarray = 0\n        start_i = 0\n        \n        for i, n in enumerate(nums):\n            start_i = addToDeqs(min_deq, max_deq, n, start_i)\n            length_subarray = (i-start_i)+1\n            longest_subarray = max(longest_subarray, length_subarray)\n        return longest_subarray\n\n\n\n", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ans=0\n        heap1=[]\n        heap2=[]\n        end=0\n        start=0\n        n=len(nums)\n        while end<n:\n            heapq.heappush(heap1,[-nums[end],end])\n            heapq.heappush(heap2,[nums[end],end])\n            while (-heap1[0][0])-heap2[0][0]>limit:\n                start+=1\n                while heap1 and heap1[0][1]<start:\n                    heapq.heappop(heap1)\n                while heap2 and heap2[0][1]<start:\n                    heapq.heappop(heap2)\n            ans=max(ans,end-start+1)\n            end+=1\n        return ans\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        res = 0 \n        left, right = 0, 0\n        minimum, maximum = [], []\n        while right < n:\n            heapq.heappush(minimum, (nums[right], right))\n            heapq.heappush(maximum, (-nums[right], right))\n            right += 1            \n            while -maximum[0][0] - minimum[0][0] > limit:\n                # print(\\\"pop\\\", left, right, res, minimum, maximum, )\n                while minimum and minimum[0][1] <= left:\n                    heapq.heappop(minimum)\n                while maximum and maximum[0][1] <= left:\n                    heapq.heappop(maximum)\n                left += 1\n            res = max(res, right - left)\n            # print(left, right, res, minimum, maximum, )\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_len = 1\n        maxi = nums[0]\n        mini = nums[0]\n        start = 0\n        temp = nums[start:start+1]\n        for i in range(1, len(nums)):\n            temp.append(nums[i])\n            if nums[i] > maxi:\n                maxi = nums[i]\n            if nums[i] < mini:\n                mini = nums[i]\n            if maxi - mini <= limit:\n                max_len = max(max_len, len(temp))\n            else:\n                temp.pop(start)\n                maxi = max(temp)\n                mini = min(temp)\n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minHeap, maxHeap = [], []\n        \n        result = i = 0\n        \n        for j in range(len(nums)):\n            heapq.heappush(minHeap, [nums[j], j])\n            heapq.heappush(maxHeap, [-nums[j], j])\n            \n            while -maxHeap[0][0] - minHeap[0][0] > limit:\n                i = min(maxHeap[0][1], minHeap[0][1]) + 1\n                while minHeap[0][1] < i:\n                    heapq.heappop(minHeap)\n                while maxHeap[0][1] < i:\n                    heapq.heappop(maxHeap)\n            \n            result = max(result, j - i + 1)\n        \n        return result", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_len = 0\n        maxi = nums[0]\n        mini = nums[0]\n        start = 0\n        temp = []\n        for i in range(len(nums)):\n            temp.append(nums[i])\n            if nums[i] > maxi:\n                maxi = nums[i]\n            if nums[i] < mini:\n                mini = nums[i]\n            if maxi - mini <= limit:\n                max_len = max(max_len, len(temp))\n            else:\n                temp.pop(start)\n                maxi = max(temp)\n                mini = min(temp)\n        return max_len\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_stack = []\n        min_stack = []\n        l = 0\n        ans = 0\n        for r in range(len(nums)):\n            while max_stack and nums[max_stack[-1]] < nums[r]:\n                max_stack.pop()\n            max_stack.append(r)\n            while min_stack and nums[min_stack[-1]] > nums[r]:\n                min_stack.pop()\n            min_stack.append(r)\n            while max_stack and min_stack and nums[max_stack[0]] - nums[min_stack[0]] > limit:\n                if max_stack[0] <= l:\n                    max_stack.pop(0)\n                if min_stack[0] <= l:\n                    min_stack.pop(0)\n                l += 1\n            ans = max(ans, r - l + 1)\n        return ans\n\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxd = collections.deque()\n        mind = collections.deque()\n        \n        s, e = 0, 0\n        res = 0\n        while e < len(nums):\n            while len(maxd) and nums[e] >= nums[maxd[-1]]: maxd.pop()\n            while len(mind) and nums[e] <= nums[mind[-1]]: mind.pop()\n            maxd.append(e)\n            mind.append(e)\n            if nums[maxd[0]] - nums[mind[0]] > limit:\n                s += 1\n                if s > mind[0]: mind.popleft()\n                if s > maxd[0]: maxd.popleft()\n            else:\n                res = max(res, e - s + 1)\n                e += 1\n        return res", "from sortedcontainers import SortedList\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        lhs = 0\n        rhs = 1\n        diff_len = 1\n        sd = SortedList([nums[lhs]]) # map value -> count\n        while rhs < len(nums):\n            # print(f\\\"lhs: {lhs}, rhs: {rhs}\\\")\n            sd.add(nums[rhs])\n            # print(sd)\n            if (sd[len(sd)-1] - sd[0] <= limit):\n                # print(f\\\"{sd[len(sd)-1]}-{sd[0]} > {limit}\\\")\n                \n                diff_len = max(diff_len, rhs-lhs+1)\n                # print(f\\\"diff_len {diff_len}\\\")\n                \n            else:\n                sd.discard(nums[lhs])\n                lhs += 1\n            rhs += 1\n        return diff_len", "class MinMaxList(object):\n\n    def __init__(self):\n        self._container = {}\n        self._max = -6665677\n        self._min = 6665677\n\n    def min_val(self) -> int:\n        return self._min\n    \n    def max_val(self) -> int:\n        return self._max\n    \n    def append_val(self, val: int):\n        if val in self._container:\n            self._container[val] = self._container[val] + 1;\n            \n        else:\n            self._container[val] = 1\n            \n        self._max = max(val, self._max)\n        self._min = min(val, self._min)\n        \n    def remove_val(self, val: int):\n        if val in self._container:\n            if self._container[val] > 1:\n                self._container[val] = self._container[val] - 1;\n                return\n            else:\n                del self._container[val]\n                \n        if self._max == val:\n            self._max = max(self._container.keys())\n            \n        if self._min == val:\n            self._min = min(self._container.keys())\n\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        diff = 0\n        max_result = 0\n        max_subarray = 0\n        low=0\n        high=0\n        window = MinMaxList()\n        while high < len(nums):\n            window.append_val(nums[high])\n            high = high+1\n            max_subarray = max_subarray + 1\n            diff = abs(window.max_val() - window.min_val())\n                \n            while diff > limit:\n                window.remove_val(nums[low])\n                low = low+1\n                max_subarray = max_subarray -1\n                diff = abs(window.max_val() - window.min_val())\n                \n            \n            max_result = max(max_subarray, max_result)\n            \n        return max_result\n                \n                \n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = len(nums)\n        if l == 1:\n            if limit >= 0:\n                return 1\n            return 0\n        max_count = i =0\n        j = 1\n\n        def get_min():\n            while min_list[0][1] < i:\n                heappop(min_list)\n            return min_list[0][1]\n\n        def get_max():\n            while max_list[0][1] < i:\n                heappop(max_list)\n            return max_list[0][1]\n\n        min_list = []\n        max_list = []\n\n        heappush(min_list, (nums[0], 0))\n        heappush(max_list, (-nums[0], 0))\n\n        while l > j >= i:\n            heappush(min_list, (nums[j], j))\n            heappush(max_list, (-nums[j], j))\n            mn = get_min()\n            mx = get_max()\n            diff = nums[mx]-nums[mn]\n            if diff > limit:\n                if j != i+1:\n                    max_count = max(max_count,j-i)\n                    i = min(mn, mx) + 1\n                else:\n                    j += 1\n                    i += 1\n            else:\n                j+=1\n        if j == l and i < j-1:\n                max_count = max(max_count,j-i)\n        return max_count\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        curr_max = deque([])\n        curr_min = deque([])\n        i = 0\n        j = 0\n        res = 0\n        while i<=j and j < len(nums):\n            num = nums[j]\n            while curr_max and curr_max[-1] < num:\n                curr_max.pop()\n            else:\n                curr_max.append(num)\n            while curr_min and curr_min[-1] > num:\n                curr_min.pop()\n            else:\n                curr_min.append(num)\n            if curr_max[0] - curr_min[0] <= limit:\n                res = max(res, j - i + 1)\n            else:\n                value = nums[i]\n                if value == curr_max[0]:\n                    curr_max.popleft()\n                if value == curr_min[0]:\n                    curr_min.popleft()\n                i += 1\n            j += 1\n        return res\n            \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        maxq = []\n        minq = []\n        left = 0\n        res = 0\n\n        for i in range(len(nums)):\n            heapq.heappush(maxq, [-nums[i], i])\n            heapq.heappush(minq, [nums[i], i])\n            \n            while -maxq[0][0] - minq[0][0] > limit:\n                left = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < left:\n                    heapq.heappop(maxq)\n                while minq[0][1] < left:\n                    heapq.heappop(minq)\n            \n            # print(maxq)\n            # print(minq)\n            \n            res = max(res, i-left+1)\n        \n        return res\n                \n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque = [nums[0]]\n        max_deque = [nums[0]]\n        \n        max_stretch = 1\n        start = 0\n        end = 0\n        while end < len(nums) - 1:\n            end += 1\n            \n            while len(min_deque) > 0 and nums[end] < min_deque[-1]:\n                min_deque.pop()\n            min_deque.append(nums[end])\n            \n            while len(max_deque) > 0 and nums[end] > max_deque[-1]:\n                max_deque.pop()\n            max_deque.append(nums[end])\n            \n            while max_deque[0] - min_deque[0] > limit:\n                if min_deque[0] == nums[start]:\n                    min_deque.pop(0)\n                if max_deque[0] == nums[start]:\n                    max_deque.pop(0)\n                \n                start += 1\n                \n            if end - start + 1 > max_stretch:\n                max_stretch = end - start + 1\n                \n        return max_stretch\n        \n#         min_heap = [nums[0]]\n#         max_heap = [-nums[0]]\n        \n#         min_removed = {}\n#         max_removed = {}\n        \n#         max_stretch = 1\n#         start = 0\n#         end = 0\n#         while end < len(nums) - 1:\n#             end += 1\n#             heapq.heappush(min_heap, nums[end])\n#             heapq.heappush(max_heap, -nums[end])\n            \n#             while - max_heap[0] - min_heap[0] > limit:\n#                 if nums[start] not in min_removed:\n#                     min_removed[nums[start]] = 0\n#                 min_removed[nums[start]] += 1\n                \n#                 if nums[start] not in max_removed:\n#                     max_removed[nums[start]] = 0\n#                 max_removed[nums[start]] += 1\n                \n#                 while -max_heap[0] in max_removed and max_removed[-max_heap[0]] > 0:\n#                     max_removed[-max_heap[0]] -= 1\n#                     heapq.heappop(max_heap)\n                    \n#                 while min_heap[0] in min_removed and min_removed[min_heap[0]] > 0:\n#                     min_removed[min_heap[0]] -= 1\n#                     heapq.heappop(min_heap)\n                    \n#                 start += 1\n                \n#             if end - start + 1 > max_stretch:\n#                 max_stretch = end - start + 1\n                \n#         return max_stretch\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        answer = 1\n        max_val = nums[0]\n        min_val = nums[0]\n        counts = {nums[0] : 1}\n        subarray = deque([nums[0]])\n        \n        for i in range(1, len(nums)):\n            counts[nums[i]] = counts.get(nums[i], 0) + 1\n            max_val = max(max_val, nums[i])\n            min_val = min(min_val, nums[i])\n            subarray.append(nums[i])\n            \n            if abs(max_val - min_val) > limit:\n                while subarray:\n                    num = subarray.popleft()\n                    counts[num] -= 1 \n\n                    if counts[num] == 0:\n                        if max_val == num:\n                            max_val = max(subarray)\n                            break\n                        elif min_val == num:\n                            min_val = min(subarray)\n                            break\n                           \n            answer = max(answer, len(subarray))\n        \n        return answer\n", "from sortedcontainers import SortedDict\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        startWindow = 0\n        runningDict = SortedDict()\n        maxWindow = 0\n        \n        for endWindow in range(len(nums)):\n            if nums[endWindow] not in runningDict:\n                runningDict[nums[endWindow]] = 0\n                \n            runningDict[nums[endWindow]] += 1\n            \n            minKey, maxKey = runningDict.peekitem(0), runningDict.peekitem(-1)\n            minKey, maxKey = minKey[0], maxKey[0]\n            \n            while abs(maxKey - minKey) > limit and startWindow < endWindow:\n                runningDict[nums[startWindow]] -= 1\n                \n                if runningDict[nums[startWindow]] == 0:\n                    del runningDict[nums[startWindow]]\n                    \n                minKey, maxKey = runningDict.peekitem(0), runningDict.peekitem(-1)\n                minKey, maxKey = minKey[0], maxKey[0]\n                \n                startWindow += 1\n                \n            maxWindow = max(maxWindow, endWindow - startWindow + 1)\n            \n        return maxWindow", "import heapq\nclass Item:\n    val, index= 0, 0\n    def __lt__(self, other):\n        return self.val < other.val\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n    \n    \nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxheap, minheap =  [], []\n        index = 0\n        maxLen = 0\n        leftIndex = -1\n        while index < len (nums):\n            while len(minheap)> 0  and  (minheap[0].val< nums[index] - limit or minheap[0].index < leftIndex):\n                leftIndex = max (leftIndex, heapq.heappop(minheap).index)\n\n            while len(maxheap) > 0 and (-maxheap[0].val >  nums[index] + limit or  maxheap[0].index < leftIndex ):\n                leftIndex = max (leftIndex, heapq.heappop(maxheap).index)\n                \n            heapq.heappush(minheap, Item(nums[index], index))\n            heapq.heappush(maxheap, Item(-nums[index], index))\n            maxLen = max(maxLen, index - leftIndex)\n            index += 1\n        return maxLen\n                               \n                               \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = ans = 0\n        maxh, minh = [], []\n        for r, num in enumerate(nums):\n            heapq.heappush(maxh, (-1 * num, r))\n            heapq.heappush(minh, (num, r))\n            \n            while maxh[0][0] * -1 - minh[0][0] > limit:\n                while maxh[0][1] <= l:\n                    heapq.heappop(maxh)\n                while minh[0][1] <= l:\n                    heapq.heappop(minh)\n                l += 1\n                \n            ans = max(ans, r - l + 1)\n            \n        return ans", "from sortedcontainers import SortedList\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         lhs = 0\n#         rhs = 1\n#         diff_len = 1\n#         sd = SortedList([nums[lhs]]) # map value -> count\n#         while rhs < len(nums):\n#             # print(f\\\"lhs: {lhs}, rhs: {rhs}\\\")\n#             sd.add(nums[rhs])\n#             # print(sd)\n#             if (sd[len(sd)-1] - sd[0] <= limit):\n#                 # print(f\\\"{sd[len(sd)-1]}-{sd[0]} > {limit}\\\")\n                \n#                 diff_len = max(diff_len, rhs-lhs+1)\n#                 # print(f\\\"diff_len {diff_len}\\\")\n                \n#             else:\n#                 sd.discard(nums[lhs])\n#                 lhs += 1\n#             rhs += 1\n#         return diff_len\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxque = collections.deque([])\n        minque = collections.deque([])\n        start = end = 0\n        count = 0\n        while end < len(nums):\n            while len(maxque) and nums[end] > nums[maxque[-1]]: maxque.pop()\n            while len(minque) and nums[end] < nums[minque[-1]]: minque.pop()\n            maxque.append(end)\n            minque.append(end)\n            if nums[maxque[0]] - nums[minque[0]] > limit:\n                if maxque[0] == start:\n                    maxque.popleft()\n                if minque[0] == start:\n                    minque.popleft()\n                start += 1\n                end += 1\n            else:\n                end += 1\n\n        return len(nums) - start\n", "import collections\n\nclass minQueue(object):\n    def __init__(self):\n        self.queue = collections.deque()\n    \n    # append val in constant time \n    def append(self, val, idx):\n        while self.queue and self.queue[-1][0] > val:\n            self.queue.pop()\n        self.queue.append((val, idx))\n        #print(\\\"minQueue is\\\", self.queue)\n        \n    def getMin(self, left_idx):\n        while self.queue and self.queue[0][1] < left_idx:\n            self.queue.popleft()\n        #print(\\\"l is\\\", left_idx, \\\"minQ, \\\",self.queue)\n        return self.queue[0][0]\n        \nclass maxQueue(object):\n    def __init__(self):\n        self.queue = collections.deque()\n    \n    # append val in constant time \n    def append(self, val, idx):\n        while self.queue and self.queue[-1][0] < val:\n            self.queue.pop()\n        self.queue.append((val, idx))\n        #print(\\\"maxqueue is\\\", self.queue)\n    \n        \n    def getMax(self, left_idx):\n        while self.queue and self.queue[0][1] < left_idx:\n            self.queue.popleft()\n        #print(\\\"l is\\\", left_idx, \\\"minQ, \\\" ,self.queue)\n        return self.queue[0][0]\n    \nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # condition is getMax - getMin <= limit\n        minQ = minQueue()\n        maxQ = maxQueue()\n        l, r =0, 0\n        minQ.append(nums[0], 0)\n        maxQ.append(nums[0], 0)\n        cond = True\n        n = len(nums)\n        res = 0\n        while l <= r and r < n: # window meaning: l and r is included in the window\n            while r<n and cond:\n                #print(\\\"cond true l, r is\\\", l, r)\n                res = max(res, r-l+1)\n                r += 1\n                if r < n:\n                    maxQ.append(nums[r], r)\n                    minQ.append(nums[r], r)\n                    cond = maxQ.getMax(l) - minQ.getMin(l) <= limit\n            while l<=r and not cond:\n                #print(\\\"cond false l, r is\\\", l, r)\n                l += 1\n                #print(maxQ.getMax(l), minQ.getMin(l))\n                cond = maxQ.getMax(l) - minQ.getMin(l) <= limit\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 1\n        \n        l=0\n        r=1\n        \n        curmax= nums[0]\n        curmin=nums[0]\n        maxlen=1\n        \n        while l<=r and r<len(nums):\n            curmax= max(curmax,nums[r])\n            curmin= min(curmin,nums[r])\n            \n            if curmax-curmin <=limit:\n                maxlen = max(maxlen,r-l+1)\n            else:\n                if nums[l]==curmax:\n                    curmax= max(nums[l+1:r+1])\n                if nums[l]==curmin:\n                    curmin=min(nums[l+1:r+1])\n                l+=1\n            r+=1\n        return maxlen\n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = 0\n        thing = 0\n        curMin = 9999999\n        curMax = -9999999\n        \n        numMap = {}\n        \n        i = 0\n        while i < len(nums):\n            if nums[i] not in numMap:\n                numMap[nums[i]] = 0\n            numMap[nums[i]] += 1\n            curMax = max(curMax, nums[i])\n            curMin = min(curMin, nums[i])\n            i += 1\n            if curMax - curMin <= limit:\n                thing = max(thing, i - l)\n            else:\n                p = nums[l]\n                numMap[nums[l]] -= 1\n                if numMap[nums[l]] == 0:\n                    del numMap[nums[l]]\n                l = l + 1\n                if p == curMin or p == curMax:\n                    curMin = min(numMap)\n                    curMax = max(numMap)\n        return thing", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        count = collections.defaultdict(int)\n        min_heap = []\n        max_heap = []\n        ans = []\n        max_length = 0\n        \n        for num in nums:\n            ans.append(num)\n            count[num] += 1\n            if count[num] == 1:\n                heapq.heappush(min_heap, num)\n                heapq.heappush(max_heap, num * -1)\n            max_val = abs(max_heap[0])\n            min_val = min_heap[0]\n            while max_val - min_val > limit:\n                popped_val = ans.pop(0)\n                count[popped_val] -= 1\n                # print(count)\n                # print(min_heap)\n                # print(ans)\n                # print(min_val)\n                # print(max_val)\n                # Pop min_heap until you have a valid min_val\n                if popped_val == min_val and count[popped_val] == 0:\n                    while count[min_val] == 0:\n                        heapq.heappop(min_heap)\n                        min_val = min_heap[0]\n                # Pop max_heap until you have a valid max_val\n                if popped_val == max_val and count[popped_val] == 0:\n                    while count[max_val] == 0:\n                        heapq.heappop(max_heap)\n                        max_val = abs(max_heap[0])\n            \n            max_length = max(max_length, len(ans))\n        return max_length", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        start = 0\n        result = 0\n        minHeap = []\n        maxHeap = []\n        \n        for i in range(len(nums)):\n            heapq.heappush(minHeap, [nums[i], i])\n            heapq.heappush(maxHeap, [-nums[i], i])\n            \n            while -maxHeap[0][0] - minHeap[0][0] > limit:\n                start = min(maxHeap[0][1], minHeap[0][1]) + 1\n                while minHeap and minHeap[0][1] < start:\n                    heapq.heappop(minHeap)\n                while maxHeap and maxHeap[0][1] < start:\n                    heapq.heappop(maxHeap)\n            result = max(result, i - start + 1)\n        \n        return result", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) == 0:\n            return 0\n        max_q = MonoQueue(False)\n        min_q = MonoQueue(True)\n        l, r = 0, 0\n        max_q.push(nums[0])\n        min_q.push(nums[0])\n        def in_limit():\n            if max_q.is_empty() is True:\n                return True\n            return abs(max_q.top() - min_q.top()) <= limit\n        res = 0\n        while r < len(nums):\n            # print(max_q.queue, min_q.queue)\n            if in_limit() is True:\n                res = max(res, r-l+1)\n                r += 1\n                if r < len(nums):\n                    min_q.push(nums[r])\n                    max_q.push(nums[r])\n            else:\n                min_q.popfront(nums[l])\n                max_q.popfront(nums[l])\n                l += 1\n        return res\n            \n\nclass MonoQueue():\n    def __init__(self, inc=True):\n        self.queue = []\n        self.inc = inc\n        \n    def popfront(self, n):\n        if self.queue[0] == n:\n            self.queue.pop(0)\n        return\n    \n    def push(self, n):\n        while self.queue:\n            if self.inc is True and self.queue[-1] > n:\n                self.queue.pop(-1)\n            elif self.inc is False and self.queue[-1] < n:\n                self.queue.pop(-1)\n            else:\n                break\n        self.queue.append(n)\n        return\n    \n    def is_empty(self):\n        return len(self.queue) == 0\n    \n    def top(self):\n        return self.queue[0]", "import heapq\nclass Solution:\n    def __init__(self):\n        self.nums = None\n        self.start = None\n        self.end = None\n        self.q = []\n        self.qmx = []\n\n        \n    def initialize (self):\n        self.start = 0\n        self.end=0\n        heapq.heappush(self.q,[self.nums[0],0])  \n        heapq.heappush(self.qmx,[self.nums[0]*-1,0]) \n        \n    def moveStartRight(self):\n        #[2,5,3,1]  3\n        # 1,2,3,5\n        # 5,3,2,1\n        count = 0\n        # get min and max\n        #move to the right until the min or max are popped up \n        minValuePos = self.q[0][1]\n        maxValuePos = self.qmx[0][1]\n        self.start = min (minValuePos,maxValuePos) +1\n        \n        #update new q\n        while self.q[0][1] < self.start:\n            heapq.heappop(self.q)\n        while self.qmx[0][1] < self.start:\n            heapq.heappop(self.qmx)\n        \n        \n        #self.q = []\n        #for i in range(self.start, self.end +1):\n        #    self.q.append([self.nums[i],i])\n        #heapq.heapify(self.q)\n        \n        \n    def moveEndRight(self):\n        self.end +=1\n        if self.end < len(self.nums):\n            heapq.heappush(self.q,[self.nums[self.end], self.end]) \n            heapq.heappush(self.qmx,[self.nums[self.end]*-1, self.end]) \n        \n    def getMinMax(self):\n        return self.q[0][0], self.qmx[0][0]*-1\n        \n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        self.nums = nums\n        self.initialize()\n        size = 0\n        while (self.end < len(self.nums)):\n            minValue,maxValue = self.getMinMax()\n            #print(self.start, self.end, minValue,maxValue)\n            if maxValue - minValue <= limit:\n                #print(minValue, maxValue, nums[start:end+1])\n                size = max(size, self.end - self.start + 1)\n                #extend \n                self.moveEndRight()\n            else:\n                self.moveStartRight()\n\n\n        return size\n        \n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            while maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                elif minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            res = max(res, j-i+1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(nums):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: \n                    heapq.heappop(maxq)\n                while minq[0][1] < i:\n                    heapq.heappop(minq)\n            res = max(res, j-i+1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = len(nums)\n        if l == 1:\n            if limit >= 0:\n                return 1\n            return 0\n        max_count = i =0\n        j = 1\n\n        def get_min():\n            while min_list[0][1] < i:\n                heappop(min_list)\n            return min_list[0][1]\n\n        def get_max():\n            while max_list[0][1] < i:\n                heappop(max_list)\n            return max_list[0][1]\n\n        min_list = []\n        max_list = []\n\n        heappush(min_list, (nums[0], 0))\n        heappush(max_list, (-nums[0], 0))\n\n        while l > j > i:\n            heappush(min_list, (nums[j], j))\n            heappush(max_list, (-nums[j], j))\n            mn = get_min()\n            mx = get_max()\n            diff = nums[mx]-nums[mn]\n            if diff > limit:\n                if j != i+1:\n                    max_count = max(max_count,j-i)\n                    i += 1\n                else:\n                    j += 1\n                    i += 1\n            else:\n                j+=1\n        if j == l and i < j-1:\n                max_count = max(max_count,j-i)\n        return max_count\n", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        pq_min = SortedList([])\n        pq_max = SortedList([])\n        \n        st, end, res = 0, 0, 0\n        for val in nums:\n            pq_min.add(val)\n            pq_max.add(-val)\n            end+=1\n            \n            #print(pq_min)\n            #print(pq_max)\n            #print(\\\" - \\\")\n            \n            while abs(pq_min[0] + pq_max[0]) > limit:\n                pq_min.remove(nums[st])\n                pq_max.remove(-nums[st])\n                st+=1\n                \n            #print(pq_min)\n            #print(pq_max)\n            #print(\\\" ----------- \\\")\n            \n            res = max(res, end - st)\n        \n        return res\n                \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums: return 0\n        if len(nums) == 1: return 1\n        \n        l, r = 0, 1\n        cur_mx, cur_mi = nums[0], nums[0]\n        \n        max_l = 1\n        \n        while l <= r and r < len(nums):\n            cur_mx = max(cur_mx, nums[r])\n            cur_mi = min(cur_mi, nums[r])\n            \n            if cur_mx - cur_mi <= limit:\n                max_l = max(max_l, r - l + 1)\n                r += 1\n            else:\n                cur_mx = max(nums[l+1: r+1])\n                cur_mi = min(nums[l+1: r+1])\n                r += 1\n                l += 1\n        \n        return max_l\n                \n", "import heapq\nclass Item:\n    val, index= 0, 0\n    def __lt__(self, other):\n        return self.val < other.val\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n    \n    \nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxheap, minheap =  [], []\n        index = 0\n        maxLen = 0\n        leftIndex = -1\n        while index < len (nums):\n            if (len(minheap)> 0 and minheap[0].val < nums[index] - limit):\n                while len(minheap)> 0  and  (minheap[0].val< nums[index] - limit or minheap[0].index < leftIndex):\n                    temp = heapq.heappop(minheap) \n                    if (temp.index > leftIndex):\n                        leftIndex = temp.index\n            if len(maxheap)> 0 and (-maxheap[0].val > nums[index] + limit):    \n                while len(maxheap) > 0 and (-maxheap[0].val >  nums[index] + limit or  maxheap[0].index < leftIndex ):\n                    temp = heapq.heappop(maxheap)\n                    if (temp.index > leftIndex):\n                        leftIndex = temp.index \n            heapq.heappush(minheap, Item(nums[index], index))\n            heapq.heappush(maxheap, Item(-nums[index], index))\n            maxLen = max(maxLen, index - leftIndex)\n            index += 1\n        return maxLen\n                               \n                               \n", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minheap=[]\n        maxheap=[]\n        heapq.heapify(minheap)\n        heapq.heapify(maxheap)\n        \n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n        heapq.heappush(maxheap,[-nums[0],0])\n\n        \n        begin = 0\n        length = 1        \n        end = 1\n        next_idx = 0\n        while begin <= end and end <= len(nums) - 1:\n            \n            if abs(minheap[0][0] - nums[end]) <= limit and abs(abs(maxheap[0][0]) - nums[end]) <= limit:\n                length = max(length, (end - begin) + 1)\n\n            else:\n                while len(minheap) > 0 and abs(minheap[0][0] - nums[end]) > limit:\n                    ele,idx = heapq.heappop(minheap)\n                    next_idx = max(next_idx, idx)\n                while len(maxheap) > 0 and abs(-maxheap[0][0] - nums[end]) > limit:\n                    ele,idx = heapq.heappop(maxheap)\n                    next_idx = max(next_idx, idx)\n                begin = next_idx + 1 \n            heapq.heappush(minheap, [nums[end],end])\n            heapq.heappush(maxheap, [-nums[end],end])\n            end+=1\n        return length\n        \n#         minheap=[]\n#         maxheap=[]\n#         heapq.heapify(minheap)\n#         heapq.heapify(maxheap)\n#         length=1\n#         i=0\n#         j=1\n#         heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n#         heapq.heappush(maxheap,[-nums[0],0])\n#         maxindex=0\n#         while i<=j and j<=len(nums)-1:\n#             if abs(minheap[0][0]-nums[j])<=limit and abs(abs(maxheap[0][0])-nums[j])<= limit:\n#                 length=max(length,j-i+1)\n                \n#             else:\n#                 while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\n#                     ele,index=heapq.heappop(minheap)\n#                     maxindex=max(maxindex,index)\n#                 while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\n#                     ele,index=heapq.heappop(maxheap)\n#                     maxindex=max(maxindex,index)\n#                 i=maxindex+1   # update i and now  we are not concerned with element before ith index\n#             heapq.heappush(minheap,[nums[j],j]) # add  element and its index\n#             heapq.heappush(maxheap,[-nums[j],j])\n#             j=j+1\n            \n#         return length\n        \n#         def isValid(int_diff, j, max_value, min_value, limit, nums):\n#             max_boundary = abs(max_value - nums[j])\n#             min_boundary = abs(min_value - nums[j])\n#             return int_diff <= limit and max_boundary <= limit and min_boundary <= limit\n        \n#         def find_error(int_diff,i, j, max_value, min_value, limit, nums,cache):\n#             max_boundary = abs(max_value - nums[j])\n#             min_boundary = abs(min_value - nums[j])\n            \n#             if int_diff > limit: return i\n#             if max_boundary > limit: return cache[max_value]\n#             if min_boundary > limit: return cache[min_value]\n            \n#         output = 1\n#         i = 0\n#         idx = 0\n#         cache = defaultdict(int)\n#         while i < len(nums) and idx < len(nums)-1:\n#             min_value = float('inf')\n#             max_value = float('-inf')\n#             cache[min_value] = i\n#             cache[max_value] = i\n#             for j in range(i,len(nums)):\n                \n#                 int_diff = abs(nums[j] - nums[i])\n#                 temp_min = min_value\n#                 temp_max = max_value\n#                 min_value = min(min_value, nums[j])\n#                 max_value = max(max_value, nums[j])\n#                 if temp_min != min_value:\n#                     cache[min_value] = j\n#                 if temp_max != min_value:\n#                     cache[max_value] = j\n#                 if isValid(int_diff, j, max_value, min_value, limit, nums):\n#                     output = max(output, (j - i) + 1)\n#                 else:\n#                     i = find_error(int_diff, i, j, max_value, min_value, limit, nums,cache) + 1\n                    \n#                     break\n#                 idx = j\n#         return output\n                \n                \n        \n            \n", "class MinMaxStack:\n    \n    def __init__(self):\n        self.s = []\n        self.mins = []\n        self.maxes = []\n        \n    def append(self, x):\n        self.s.append(x)\n        if not self.mins or x <= self.mins[-1]:\n            self.mins.append(x)\n        if not self.maxes or x >= self.maxes[-1]:\n            self.maxes.append(x)\n    \n    def pop(self):\n        x = self.s.pop()\n        if x == self.mins[-1]:\n            self.mins.pop()\n        if x == self.maxes[-1]:\n            self.maxes.pop()\n        return x\n     \n    def min(self):\n        return self.mins[-1] if self.mins else float('inf')\n    \n    def max(self):\n        return self.maxes[-1] if self.maxes else -float('inf')\n    \n    def __len__(self):\n        return len(self.s)\n    \n    \nclass MinMaxQueue:\n    \n    def __init__(self):\n        self.s1 = MinMaxStack()\n        self.s2 = MinMaxStack()\n    \n    def enqueue(self, x):\n        self.s1.append(x)\n        \n    def dequeue(self):\n        if not self.s2:\n            while self.s1:\n                to_append = self.s1.pop()\n                self.s2.append(to_append)\n        return self.s2.pop()\n    \n    def min(self):\n        return min(self.s1.min(), self.s2.min())\n    \n    def max(self):\n        return max(self.s1.max(), self.s2.max())\n    \n    def __len__(self):\n        return len(self.s1) + len(self.s2)\n    \nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        i = 0\n        max_len = 1\n        q = MinMaxQueue()\n        q.enqueue(nums[0])\n        while i < len(nums):\n            if q.max() - q.min() <= limit:\n                max_len = max(max_len, len(q))\n                i += 1\n                if i < len(nums):\n                    q.enqueue(nums[i])\n                continue\n            q.dequeue()\n        return max_len\n", "from sortedcontainers import SortedList\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        start = 0\n        n = len(nums)\n        k = limit\n        s = SortedList()\n        \n        max_count = 0\n        \n        for i in range(n):\n            \n            s.add(nums[i])\n            \n            if s[-1] - s[0] > k:\n                while s[-1] - s[0] > k:\n                    s.remove(nums[start])\n                    start += 1\n            max_count = max(max_count, len(s))\n        \n        return max_count\n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) == 1:\n            return 1\n        \n        left = right = 0\n        min_n = max_n = nums[0]\n        max_size = 0\n                \n        while right < len(nums):\n            \n            if nums[right] > max_n:\n                max_n = nums[right]\n            if nums[right] < min_n:\n                min_n = nums[right]\n            \n            while max_n - min_n > limit:\n                left += 1\n                min_n = min(nums[left:right+1])\n                max_n = max(nums[left:right+1])\n                break\n                \n            if right - left > max_size:\n                max_size = right - left\n            \n            right += 1\n            \n        return max_size + 1", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minq = deque()\n        maxq = deque()\n        ret = l = 0\n        for i in range(len(nums)):\n            while minq and nums[i]<minq[-1]:\n                minq.pop()\n            minq.append(nums[i])\n            while maxq and nums[i]>maxq[-1]:\n                maxq.pop()\n            maxq.append(nums[i])\n            while maxq[0]-minq[0]>limit:\n                if nums[l]==maxq[0]:\n                    maxq.popleft()\n                if nums[l]==minq[0]:\n                    minq.popleft()\n                l+=1\n            ret = max(ret, i-l+1)\n        return ret", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        answer = 1\n        max_val = nums[0]\n        min_val = nums[0]\n        counts = {nums[0] : 1}\n        subarray = deque([nums[0]])\n        \n        for i in range(1, len(nums)):\n            counts[nums[i]] = counts.get(nums[i], 0) + 1\n            max_val = max(max_val, nums[i])\n            min_val = min(min_val, nums[i])\n            subarray.append(nums[i])\n            \n            if abs(max_val - min_val) > limit:\n                while True:\n                    num = subarray.popleft()\n                    counts[num] -= 1 \n\n                    if counts[num] == 0:\n                        if max_val == num:\n                            max_val = max(subarray)\n                            break\n                        elif min_val == num:\n                            min_val = min(subarray)\n                            break\n                           \n            answer = max(answer, len(subarray))\n        \n        return answer\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        window_multiset = SortedDict()\n        \n        start = 0\n        end = start\n        \n        ret = 0\n        \n        while start < len(nums) and end < len(nums):\n            if self.can_add(window_multiset, nums[end], limit):\n                window_multiset[nums[end]] = window_multiset.get(nums[end], 0) + 1 \n                end += 1\n            else:\n                ret = max(end - start, ret)\n                \n                window_multiset[nums[end]] = window_multiset.get(nums[end], 0) + 1\n                while not self.is_valid_window(window_multiset, limit):\n                    self.remove_multiset(window_multiset, nums[start])\n                    start += 1\n                    \n                end += 1\n                    \n        ret = max(end - start, ret)\n        \n        return ret\n    \n    def remove_multiset(self, window_multiset: SortedDict, num: int):\n        window_multiset[num] -= 1\n        \n        if not window_multiset[num]:\n            window_multiset.pop(num)\n    \n    def is_valid_window(self, window_multiset: SortedDict, limit: int) -> bool:\n        view = window_multiset.keys()\n        return view[-1] - view[0] <= limit\n        \n    def can_add(self, window_multiset: SortedDict, cand: int, limit: int) -> bool:\n        if not len(window_multiset):\n            return True\n                \n        view = window_multiset.keys()\n        return abs(cand - view[0]) <= limit and abs(cand - view[-1]) <= limit", "import heapq\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        minheap=[]\n        maxheap=[]\n        heapq.heapify(minheap)\n        heapq.heapify(maxheap)\n        \n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\n        heapq.heappush(maxheap,[-nums[0],0])\n\n        \n        begin = 0\n        length = 1        \n        end = 1\n        next_idx = 0\n        while begin <= end and end <= len(nums) - 1:\n            \n            if abs(minheap[0][0] - nums[end]) <= limit and abs(abs(maxheap[0][0]) - nums[end]) <= limit:\n                length = max(length, (end - begin) + 1)\n\n            else:\n                while len(minheap) > 0 and abs(minheap[0][0] - nums[end]) > limit:\n                    ele,idx = heapq.heappop(minheap)\n                    next_idx = max(next_idx, idx)\n                while len(maxheap) > 0 and abs(-maxheap[0][0] - nums[end]) > limit:\n                    ele,idx = heapq.heappop(maxheap)\n                    next_idx = max(next_idx, idx)\n                begin = next_idx + 1 \n            heapq.heappush(minheap, [nums[end],end])\n            heapq.heappush(maxheap, [-nums[end],end])\n            end+=1\n        return length\n        \n#         def isValid(int_diff, j, max_value, min_value, limit, nums):\n#             max_boundary = abs(max_value - nums[j])\n#             min_boundary = abs(min_value - nums[j])\n#             return int_diff <= limit and max_boundary <= limit and min_boundary <= limit\n        \n#         def find_error(int_diff,i, j, max_value, min_value, limit, nums,cache):\n#             max_boundary = abs(max_value - nums[j])\n#             min_boundary = abs(min_value - nums[j])\n            \n#             if int_diff > limit: return i\n#             if max_boundary > limit: return cache[max_value]\n#             if min_boundary > limit: return cache[min_value]\n            \n#         output = 1\n#         i = 0\n#         idx = 0\n#         cache = defaultdict(int)\n#         while i < len(nums) and idx < len(nums)-1:\n#             min_value = float('inf')\n#             max_value = float('-inf')\n#             cache[min_value] = i\n#             cache[max_value] = i\n#             for j in range(i,len(nums)):\n                \n#                 int_diff = abs(nums[j] - nums[i])\n#                 temp_min = min_value\n#                 temp_max = max_value\n#                 min_value = min(min_value, nums[j])\n#                 max_value = max(max_value, nums[j])\n#                 if temp_min != min_value:\n#                     cache[min_value] = j\n#                 if temp_max != min_value:\n#                     cache[max_value] = j\n#                 if isValid(int_diff, j, max_value, min_value, limit, nums):\n#                     output = max(output, (j - i) + 1)\n#                 else:\n#                     i = find_error(int_diff, i, j, max_value, min_value, limit, nums,cache) + 1\n                    \n#                     break\n#                 idx = j\n#         return output\n                \n                \n        \n            \n", "import sortedcontainers\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        window = sortedcontainers.SortedList()\n        N = len(nums)\n        \n        left = 0\n        right = -1\n        \n        def check():\n            if not window: \n                return True\n            return window[-1] - window[0] <= limit\n        \n        ret = 1\n        \n        while left < N and right < N:\n            if not check():\n                window.remove(nums[left])\n                left += 1\n            else:\n                ret = max(ret, right - left  + 1)\n                right += 1\n                if right < N:\n                    window.add(nums[right])\n        \n        return ret", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i = 0\n        j = 0\n        max_length = 1\n        cur_max = cur_min = nums[0]\n        while j < len(nums):\n            dif = cur_max - cur_min\n            if dif <= limit:\n                max_length = j-i+1\n                j += 1\n                if j < len(nums):\n                    cur_max = max(cur_max,nums[j])\n                    cur_min = min(cur_min,nums[j])\n            else:\n                i += 1\n                j += 1\n                cur_max = max(nums[i:j+1])\n                cur_min = min(nums[i:j+1])\n        return max_length", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not len(nums): return 0\n        \n        ml, start, end = 1, 0, 0\n        pqmin, pqmax = [], []\n        \n        for end in range(len(nums)):\n            heapq.heappush(pqmin, (nums[end], end))\n            heapq.heappush(pqmax, (-nums[end], end))\n            \n            while start < end and abs(pqmax[0][0] + pqmin[0][0]) > limit:# we will pop out numbers until max - min < limit\n                start += 1\n\n                while pqmax and pqmax[0][1] < start: heapq.heappop(pqmax) ## I only care if the max number index has been passed, if yes, we should pop out all numbers before that\n                while pqmin and pqmin[0][1] < start: heapq.heappop(pqmin)## I only care if the min number index has been passed, if yes, we should pop out all numbers before that\n            ml = max(ml, end - start + 1)\n            \n        return ml\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        result = 1\n        start = 0\n        end = start + result\n        mini = float('inf')\n        maxi = float('-inf')\n        while end <= len(nums):\n            #step 1, check if the min and max has changed?\n            #In this step we disgarded the first element, and added the last element\n            mini = min(nums[start:end])\n            maxi = max(nums[start:end])\n            if abs(mini - maxi) > limit:\n                start += 1\n                end += 1\n            else:\n                # step2, the current condition is satisfied, explore the next element until\n                # the limit is broken\n                end += 1\n                while end <= len(nums):\n                    mini = min(nums[end-1], mini)\n                    maxi = max(nums[end-1], maxi)\n                    if abs(mini - maxi) > limit:\n                        result = max(result, end - start - 1)\n                        start += 1\n                        end = start + result\n                        break\n                    else:\n                        end += 1\n                        if end > len(nums):\n                            result = max(result, end - start-1)\n        return result\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        N=len(nums)\n        ans=0\n        maxi=deque() # decreasing 9 5 1\n        mini=deque() # increasing 1 5 9\n        j=0\n        \n        for i in range(N):\n            while mini and nums[i]<nums[mini[-1]]:\n                mini.pop()\n            \n            while maxi and nums[i]>nums[maxi[-1]]:\n                maxi.pop()\n            \n            mini.append(i)\n            maxi.append(i)\n            \n            if abs(nums[maxi[0]]-nums[mini[0]])<=limit:\n                ans=max(ans,abs(maxi[0]-mini[0])+1)\n            else:\n                # remove elements outside of the window\n                while mini and mini[0]<=j:\n                    mini.popleft()\n                while maxi and maxi[0]<=j:\n                    maxi.popleft()\n                j+=1\n        \n        return N-j", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minQ = deque()\n        maxQ = deque()\n        ans = -1\n        l = 0\n        for r in range(len(nums)):\n            while minQ and nums[r] < minQ[-1]:\n                minQ.pop()\n            while maxQ and nums[r] > maxQ[-1]:\n                maxQ.pop()\n            minQ.append(nums[r])\n            maxQ.append(nums[r])\n            while abs(maxQ[0]-minQ[0]) > limit:\n                if minQ and minQ[0] == nums[l]: minQ.popleft()\n                if maxQ and maxQ[0] == nums[l]: maxQ.popleft()\n                l +=1\n            ans = max(ans, r-l+1)\n        return ans\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        asc = deque()\n        dsc = deque()\n        ret=l=0\n        for i in range(len(nums)):\n            n=nums[i]\n            while asc and n<asc[-1]:\n                asc.pop()\n            asc.append(n)\n            while dsc and n>dsc[-1]:\n                dsc.pop()\n            dsc.append(n)\n            while dsc[0]-asc[0]>limit:\n                if dsc[0]==nums[l]:\n                    dsc.popleft()\n                if asc[0]==nums[l]:\n                    asc.popleft()\n                l+=1\n            ret = max(ret,i-l+1)\n        return ret", "class Solution:\n  # 520 ms\n  def longestSubarray(self, nums, limit):\n    # initialize maximum and minimum\n    _min = _max = nums[0]\n    count = 0\n    res, start =1, 0\n\n    for right in range(len(nums)):\n      # update maximum and minimum\n      if _min > nums[right]: _min = nums[right]\n      if _max < nums[right]: _max = nums[right]\n\n      # if the right bound valid, count and update result \n      if _max - _min <= limit:\n        count += 1\n        if res < count: res = count\n\n      # if invalid, turn to find the valid left bound\n      elif _max - _min > limit:\n        # initialize maximum and minimum at this position\n        _min = _max = nums[right]\n        count = 1\n        left = right - 1\n        # keep updating until invalid\n        while (left >= start\n               and abs(_max - nums[left]) <= limit \n               and abs(_min - nums[left]) <= limit):\n          if _min > nums[left]: _min = nums[left]\n          if _max < nums[left]: _max = nums[left]\n          count += 1\n          left -= 1\n        # when ended, update the left bound to right+1\n        # because we have counted the \\\"right\\\" position now in while-loop above already\n        start = right + 1\n\n    return res", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        asc = deque()\n        dsc = deque()\n        ret=l=0\n        for i in range(len(nums)):\n            n=nums[i]\n            while asc and n<asc[-1]:\n                asc.pop()\n            asc.append(n)\n            while dsc and n>dsc[-1]:\n                dsc.pop()\n            dsc.append(n)\n            while dsc[0]-asc[0]>limit:\n                if nums[l]==dsc[0]:\n                    dsc.popleft()\n                if nums[l]==asc[0]:\n                    asc.popleft()\n                l+=1\n            ret = max(ret,i-l+1)\n        return ret", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        l = 0\n        min_dq = deque()\n        max_dq = deque()\n        out = 0\n        for r in range(len(nums)):\n            val = nums[r]\n            while min_dq and val < nums[min_dq[-1]]:\n                min_dq.pop()\n            while max_dq and val > nums[max_dq[-1]]:\n                max_dq.pop()\n            max_dq.append(r)\n            min_dq.append(r)\n            while nums[max_dq[0]]-nums[min_dq[0]] > limit:\n                l+=1\n                if max_dq[0] < l:\n                    max_dq.popleft()\n                if min_dq[0] < l:\n                    min_dq.popleft()\n            out = max(out, r-l+1)\n        return out", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        from collections import deque\n        \n        min_q = deque()\n        max_q = deque()\n        ans = 0\n        j = 0\n        for i, num in enumerate(nums):\n            while min_q and min_q[-1][0] > num:\n                min_q.pop()\n            min_q.append((num, i))\n            while max_q and max_q[-1][0] < num:\n                max_q.pop()\n            max_q.append((num, i))\n            if abs(min_q[0][0] - max_q[0][0]) <= limit:\n                ans = max(ans, i - j + 1)\n            else:\n                if min_q[0][1] < max_q[0][1]:\n                    j = min_q[0][1] + 1\n                    min_q.popleft()\n                elif min_q[0][1] > max_q[0][1]:\n                    j = max_q[0][1] + 1\n                    max_q.popleft()\n                else:\n                    j = max_q[0][1] + 1\n                    min_q.popleft()\n                    max_q.popleft()\n            # print(ans, min_q, max_q, j)\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        decStack = collections.deque()\n        incStack = collections.deque()\n        ans = 0\n        l = 0\n        for r, n in enumerate(nums):\n            while decStack and decStack[-1][0] <= n:\n                decStack.pop()\n            decStack.append((n, r))\n            while incStack and incStack[-1][0] >= n:\n                incStack.pop()\n            incStack.append((n, r))\n            while decStack[0][0] - incStack[0][0] > limit:\n                l = min(incStack[0][1], decStack[0][1]) + 1\n                while decStack and decStack[0][1] < l:\n                    decStack.popleft()\n                while incStack and incStack[0][1] < l:\n                    incStack.popleft()\n            ans = max(ans, r - l + 1)\n            # print(ans, l, r, incStack, decStack)\n        return ans", "import collections\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # sliding window\n        mx, mn = collections.deque([0]), collections.deque([0])\n        ans = 1\n        left = 0\n        for i in range(1, len(nums)):\n            # update max and min monotonic q\n            while mx and nums[mx[-1]] < nums[i]:\n                mx.pop()\n            mx.append(i)\n            while mn and nums[mn[-1]] > nums[i]:\n                mn.pop()\n            mn.append(i)\n            while mx and mn and nums[mx[0]] - nums[mn[0]] > limit:\n                left += 1\n                if mx[0] < left:\n                    mx.popleft()\n                if mn[0] < left:\n                    mn.popleft()\n            ans = max(ans, i-left+1)\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        maxq = collections.deque()\n        minq = collections.deque()\n        \n        start = 0\n        \n        for i, n in enumerate(nums):\n            while maxq and maxq[-1][0] < n:\n                maxq.pop()\n            while minq and minq[-1][0] > n:\n                minq.pop()\n            maxq.append( [n, i] )\n            minq.append( [n, i] )\n            \n            \n            if maxq[0][0] - minq[0][0] > limit:\n                if maxq[0][0] == nums[start]:\n                    maxq.popleft()\n                if minq[0][0] == nums[start]:\n                    minq.popleft()\n                start += 1\n                   \n        return len(nums) - start\n    \n            \n        \n        \n        \n        \n        \n        \n#         res = 0\n#         maxq = []\n#         minq = []\n#         j = 0\n#         for i,n in enumerate(nums): # O(n)\n#             heapq.heappush(maxq, [-n,i] )  # O(log n)\n#             heapq.heappush(minq, [n,i] )\n            \n#             while -maxq[0][0] - minq[0][0] > limit:\n#                 ind = min( maxq[0][1], minq[0][1] )\n#                 while maxq[0][1] <= ind:\n#                     heapq.heappop(maxq) # O(log n)\n#                 while minq[0][1] <= ind:\n#                     heapq.heappop(minq)\n#                 j = ind+1\n#             res = max(res, i - j +1 )\n            \n#         return res\n                \n        \n        \n        \n        \n        \n#         res = 0\n        \n#         i = 0\n#         arr = [] # space O(res)\n#         for n in nums:  # O(n) time\n#             bisect.insort(arr, n) # O(res)\n#             while arr[-1] - arr[0] > limit:\n#                 ind = bisect.bisect_right(arr, nums[i])  # O( log res )\n#                 arr.pop(ind-1)  # O(res)\n#                 i += 1\n#             res = max(res, len(arr))\n            \n#         return res\n                \n        \n        \n        \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_elements = collections.deque()\n        min_elements = collections.deque()\n        \n        max_len = 0\n        i = 0\n        for j, num in enumerate(nums):\n            while max_elements and max_elements[-1] < num:\n                max_elements.pop()\n            while min_elements and min_elements[-1] > num:\n                min_elements.pop()\n            max_elements.append(num)\n            min_elements.append(num)\n            \n            while max_elements[0] - min_elements[0] > limit:\n                if max_elements and max_elements[0] == nums[i]:\n                    max_elements.popleft()\n                if min_elements and min_elements[0] == nums[i]:\n                    min_elements.popleft()\n                i += 1\n                \n            max_len = max(max_len, j - i + 1)\n            \n        return max_len", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        mindeque = deque()\n        maxdeque = deque()\n        \n        L = R = 0\n        res = 0\n        \n        while R < len(nums):\n            while mindeque and nums[mindeque[-1]] > nums[R]:\n                mindeque.pop()\n            mindeque.append(R)\n            \n            while maxdeque and nums[maxdeque[-1]] < nums[R]:\n                maxdeque.pop()\n            maxdeque.append(R)\n            \n            if nums[maxdeque[0]] - nums[mindeque[0]] <= limit:\n                res = max(res, R - L + 1)\n            else:\n                while nums[maxdeque[0]] - nums[mindeque[0]] > limit:\n                    if L == maxdeque[0]:\n                        maxdeque.popleft()\n                    if L == mindeque[0]:\n                        mindeque.popleft()\n                    L += 1\n            R += 1\n        \n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque, max_deque = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\n                min_deque.pop()\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            \n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                l += 1\n                if l > min_deque[0]:\n                    min_deque.popleft()\n                if l > max_deque[0]:\n                    max_deque.popleft()\n            \n            ans = max(ans, r - l + 1)\n            r += 1\n                \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minq, maxq = deque(), deque()\n        i = 0\n        for num in nums:\n            while minq and minq[-1] > num:\n                minq.pop()\n            while maxq and maxq[-1] < num:\n                maxq.pop()\n            minq.append(num)\n            maxq.append(num)\n            \n            if maxq[0] - minq[0] > limit:\n                if nums[i] == minq[0]: minq.popleft()\n                if nums[i] == maxq[0]: maxq.popleft()\n                i += 1\n        return len(nums) - i\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        res, last = 0, -1\n        maxQ, minQ = deque(), deque()\n        for i, val in enumerate(nums):\n            while maxQ and nums[maxQ[0]] - val > limit:\n                last = max(last, maxQ.popleft())\n            while maxQ and val >= nums[maxQ[-1]]:\n                maxQ.pop()\n            maxQ.append(i)\n                \n            while minQ and val - nums[minQ[0]] > limit:\n                last = max(last, minQ.popleft())\n            while minQ and val <= nums[minQ[-1]]:\n                minQ.pop()\n            minQ.append(i)\n            \n            res = max(res, i - last)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        from collections import deque\n        asc, desc = deque(), deque()\n        l, r = 0, 0\n        res = 0\n        while r < len(nums):\n            while asc and nums[asc[-1]] >= nums[r]: asc.pop()\n            while desc and nums[desc[-1]] <= nums[r]: desc.pop()\n            asc.append(r)\n            desc.append(r)\n            while nums[desc[0]] - nums[asc[0]] > limit:\n                l += 1\n                if desc[0] < l: desc.popleft()\n                if asc[0] < l: asc.popleft()\n            res = max(res, r - l + 1)\n            r += 1\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque, max_deque = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\n                min_deque.pop()\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                l += 1\n                if l > min_deque[0]:\n                    min_deque.popleft()\n                if l > max_deque[0]:\n                    max_deque.popleft()\n            ans = max(ans, r-l + 1)\n            r += 1\n        return ans\n \n\n\n\n        \n        \n        \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        mindeq=deque()\n        maxdeq=deque()\n        \n        i=0\n        ans=1\n        \n        for j in range(0,len(nums)):\n            \n            while(len(maxdeq)>0 and maxdeq[-1]<nums[j]):\n                maxdeq.pop()\n                \n            maxdeq.append(nums[j])\n            \n            while(len(mindeq)>0 and mindeq[-1]>nums[j]):\n                mindeq.pop()\n                \n            mindeq.append(nums[j])\n            \n            \n            if(maxdeq[0]-mindeq[0]>limit):\n                if(maxdeq[0]==nums[i]):\n                    maxdeq.popleft()\n                if(mindeq[0]==nums[i]):\n                    mindeq.popleft()\n                i+=1\n                \n            ans=max(ans,j-i+1)\n            \n        return ans\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxd = collections.deque() # monotonically decreasing \n        mind = collections.deque() # monotonically increasing \n        i = 0\n        # maxd[-1] gives last element and maxd[0] gives first/front element\n        \n        for num in nums:\n            while maxd and num > maxd[-1]: maxd.pop() # biggr num eats up all smaller ones\n            while mind and num < mind[-1]: mind.pop()\n            maxd.append(num)\n            mind.append(num)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == nums[i]: maxd.popleft()\n                if mind[0] == nums[i]: mind.popleft()\n                i+=1\n        return len(nums) -i\n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # read - https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609708/Python-Clean-Monotonic-Queue-solution-with-detail-explanation-O(N)\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque, max_deque = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\n                min_deque.pop()\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            if nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                while min_deque[0] <= l:\n                    min_deque.popleft()\n                while max_deque[0] <= l:\n                    max_deque.popleft()\n                l += 1\n            ans = max(ans, r - l + 1)\n            r += 1\n                \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        # nums = [8,2,4,7]\n        # max_len = 0\n        # first = 0\n        # second = 0\n        \n        max_list = []\n        min_list = []\n        \n        j = 0\n        \n        for i in range(len(nums)):\n            \n            while max_list and max_list[-1] < nums[i]: max_list.pop()\n            while min_list and min_list[-1] > nums[i]: min_list.pop()\n                \n            max_list.append(nums[i])\n            min_list.append(nums[i])\n            \n            if max_list[0] - min_list[0] > limit:\n                \n                if max_list[0] == nums[j]: max_list = max_list[1:]\n                if min_list[0] == nums[j]: min_list = min_list[1:]\n                \n                j += 1\n                \n        return len(nums) - j", "class Solution:\n    def longestSubarray(self, nums, limit):\n        mini, maxi, res, i = deque([]), deque([]), 0, 0\n        for j in range(len(nums)):\n            while mini and mini[-1][0] > nums[j]: mini.pop()\n            mini.append((nums[j], j))\n            while maxi and maxi[-1][0] < nums[j]: maxi.pop()\n            maxi.append((nums[j], j))\n            while abs(maxi[0][0] - mini[0][0]) > limit and i < j:\n                if maxi[0][-1] <= i: maxi.popleft() \n                elif mini[0][-1] <= i: mini.popleft()\n                i += 1\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # keep track of max and min value of sliding window\n        # mono decreasing deque\n        max_deque = collections.deque()\n        # mono increasing deque\n        min_deque = collections.deque()\n        n = len(nums)\n        l = 0\n        res = 0\n        \n        for r in range(n):      \n            self.push_max_deque(max_deque, nums, r)\n            self.push_min_deque(min_deque, nums, r)\n            # if current window violate the limit,\n            # then it is guarantee current num change either \n            # head of max_deque or min_deque\n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                if max_deque[0] == l:\n                    max_deque.popleft()\n                \n                if min_deque[0] == l:\n                    min_deque.popleft()\n                \n                l += 1\n             \n            res = max(res, r - l + 1)\n             \n        return res\n        \n    def push_max_deque(self, max_deque, nums, i):\n        while max_deque and nums[max_deque[-1]] < nums[i]:\n            max_deque.pop()\n            \n        max_deque.append(i)\n        \n    def push_min_deque(self, min_deque, nums, i):\n        while min_deque and nums[min_deque[-1]] > nums[i]:\n            min_deque.pop()\n        \n        min_deque.append(i)\n        \n            \n", "from collections import deque\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        minq, maxq = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while minq and nums[r] <= nums[minq[-1]]:\n                minq.pop()\n            while maxq and nums[r] >= nums[maxq[-1]]:\n                maxq.pop()\n                \n            minq.append(r)\n            maxq.append(r)\n            \n            while nums[maxq[0]] - nums[minq[0]] > limit:\n                l += 1\n                if l > minq[0]:\n                    minq.popleft()\n                if l > maxq[0]:\n                    maxq.popleft()\n            ans = max(ans, r - l + 1)\n            r += 1\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        mini, maxi, res, i = deque([]), deque([]), 0, 0\n        for j in range(len(nums)):\n            while mini and mini[-1][0] > nums[j]: mini.pop()\n            mini.append((nums[j], j))\n            while maxi and maxi[-1][0] < nums[j]: maxi.pop()\n            maxi.append((nums[j], j))\n            while abs(maxi[0][0] - mini[0][0]) > limit and i < j:\n                if maxi[0][-1] <= i: maxi.popleft() \n                elif mini[0][-1] <= i: mini.popleft()\n                i += 1\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ans = 0\n        start_pos = 0\n        inc, dec = deque([]), deque([])\n        for i in range(len(nums)):\n            while len(inc)>0 and nums[inc[-1]]>nums[i]:\n                inc.pop()\n            inc.append(i)\n            \n            while len(dec)>0 and nums[dec[-1]]<nums[i]:\n                dec.pop()\n            dec.append(i)\n            \n            while abs(nums[inc[0]]-nums[dec[0]])>limit:\n                start_pos += 1\n                if inc[0]<start_pos:\n                    inc.popleft()\n                if dec[0]<start_pos:\n                    dec.popleft()\n            ans = max(ans, i-start_pos+1 )\n            # print(i,nums[i], inc,dec, start_pos, ans)\n            \n        return ans\n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i,j=0,0\n        nums.append(float('inf'))\n        qmin=collections.deque() # monotonic non-decreasing\n        qmax=collections.deque() # non-increasing \n        qmin.append(0)\n        qmax.append(0)\n        ans=0\n        \n        while j<len(nums)-1:\n            while j<len(nums)-1 and nums[qmax[0]]-nums[qmin[0]]<=limit:\n                ans = max(ans, j-i+1)\n                j+=1\n                \n                while qmax and nums[qmax[-1]]<nums[j]:\n                    qmax.pop()\n                qmax.append(j)\n                \n                while qmin and nums[qmin[-1]]>nums[j]:\n                    qmin.pop()\n                qmin.append(j)\n                \n                \n            # only one can happen\n            while qmax and nums[qmax[0]] - nums[j] > limit:\n                i = qmax.popleft()+1\n                \n            while qmin and nums[j] - nums[qmin[0]] > limit:\n                i = qmin.popleft()+1\n                \n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i,j=0,0\n        nums.append(float('inf'))\n        qmin=collections.deque() # monotonic non-decreasing\n        qmax=collections.deque() # non-increasing \n        qmin.append(0)\n        qmax.append(0)\n        ans=0\n        \n        while j<len(nums)-1:\n            while j<len(nums)-1 and nums[qmax[0]]-nums[qmin[0]]<=limit:\n                ans = max(ans, j-i+1)\n                j+=1\n                \n                while qmax and nums[qmax[-1]]<nums[j]:\n                    qmax.pop()\n                qmax.append(j)\n                \n                while qmin and nums[qmin[-1]]>nums[j]:\n                    qmin.pop()\n                qmin.append(j)\n                \n                \n            # only one can happen\n            while qmax and nums[qmax[0]] - nums[j] > limit:\n                i = qmax.popleft()+1\n                \n            while qmin and nums[j] - nums[qmin[0]] > limit:\n                i = qmin.popleft()+1\n                \n        return ans\n", "from queue import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \n        if len(nums)==1: return 1\n        \n        print(nums)\n        decreasing=deque()\n        increasing=deque()\n            \n        max_l=1\n        if abs(nums[1]-nums[0])<=limit:max_l=2\n        \n        \n        p0=0\n        p1=0\n        \n        while p1<=len(nums)-1:\n            \n            while decreasing and nums[decreasing[-1]]<nums[p1]:\n                decreasing.pop()\n            while increasing and nums[increasing[-1]]>nums[p1]:\n                increasing.pop()\n                \n            \n            while decreasing and decreasing[0]<p0:\n                decreasing.popleft()\n            while increasing and increasing[0]<p0:\n                increasing.popleft()\n            \n            decreasing.append(p1)\n            increasing.append(p1)\n            \n            \n            \n            while p0<p1 and nums[decreasing[0]]-nums[increasing[0]]>limit:\n                if decreasing[0]==p0:decreasing.popleft()\n                if increasing[0]==p0:increasing.popleft()\n                p0+=1\n                \n            \n            \n            if nums[decreasing[0]]-nums[increasing[0]]<=limit:max_l=max(max_l,p1-p0+1)\n            p1+=1\n            \n        return max_l\n            \n", "class Solution:\n    def longestSubarray(self, A: List[int], limit: int) -> int:\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while maxd and a > maxd[-1]: maxd.pop()\n            while mind and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: maxd.popleft()\n                if mind[0] == A[i]: mind.popleft()\n                i += 1\n        return len(A) - i        ", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        mini, maxi, res, j  = deque([]), deque([]), 0, 0\n\n        for i in range(len(nums)):\n            while mini and mini[-1][0] > nums[i]:\n                mini.pop()\n            mini.append([nums[i], i])\n            \n            while maxi and maxi[-1][0] < nums[i]:\n                maxi.pop()\n            maxi.append([nums[i], i])\n                \n            while(maxi[0][0] -  mini[0][0] > limit) and j < i :\n                if mini[0][1] <= j:\n                    mini.popleft()\n                    \n                elif maxi[0][1] <= j:\n                    maxi.popleft()\n                    \n                j +=1\n            res = max(res, i-j+1)\n            \n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if len(nums) == 1 and limit >= 0:\n            return 1\n        \n        longest_subarray = 0\n        \n        right = 0\n        left = 0 \n        \n        min_val = nums[left]\n        max_val = nums[left]\n        \n        min_dq = []\n        max_dq = []\n        \n        while right < len(nums):\n            \n            while len(min_dq) > 0 and min_dq[-1] > nums[right]:\n                min_dq.pop()\n            min_dq.append(nums[right])\n                \n            while len(max_dq) > 0 and max_dq[-1] < nums[right]:\n                max_dq.pop()\n            max_dq.append(nums[right])\n            \n            min_val = min_dq[0]\n            max_val = max_dq[0]\n                \n            if abs(min_val - max_val) > limit:\n                if min_dq[0] == nums[left]:\n                    min_dq.pop(0)\n                    \n                if max_dq[0] == nums[left]:\n                    max_dq.pop(0)\n                    \n                left += 1\n                      \n            longest_subarray = max(longest_subarray, right - left + 1)\n            right += 1\n            \n        return longest_subarray\n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        '''\n        # Complexity of n^2\n        i = 0\n        j = 0\n        \n        maxSize = 0\n        while j < len(nums):\n            k = j - 1 # 1\n            while k >= i:\n                if abs(nums[k] - nums[j]) > limit:\n                    i = k + 1 \n                    \n                k -= 1\n                 \n            maxSize = max(maxSize, (j-i+1))\n            j += 1\n            \n        return maxSize\n        \n        '''\n        \n        sP = 0\n        eP = 0\n        minQ = collections.deque([])\n        maxQ = collections.deque([])\n        maxSize = 0\n        \n        # maxS = 3\n        # ep  - 4\n        # sp  - 2\n        \n        #  0 1 2 3 4 5\n        # 10 1 2 1 7 2\n        # minQ (3,1)\n        # maxQ (4,7)\n        \n    \n        while eP < len(nums):\n            while minQ and minQ[-1][0] > nums[eP]:\n                minQ.pop()\n            minQ.append((nums[eP], eP))\n            \n            while maxQ and maxQ[-1][0] < nums[eP]:\n                maxQ.pop()\n            maxQ.append((nums[eP],eP))\n            \n            while abs(maxQ[0][0] - minQ[0][0]) > limit and sP < eP:\n                if maxQ[0][1] <= sP: maxQ.popleft() \n                elif minQ[0][1] <= sP: minQ.popleft()\n               \n                sP+=1\n            maxSize = max(maxSize, eP - sP + 1)\n            eP +=1\n        return maxSize\n                \n                \n                \n        \n                \n            \n            \n            \n            \n    \n\n            \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        i = 0\n        j = 0\n        \n        bestSize = 0\n        maxVals = []\n        minVals = []\n        \n        import heapq\n        \n        while j < len(nums):\n            heappush(maxVals, (-nums[j], j))\n            heappush(minVals, (nums[j], j))\n            \n            if -maxVals[0][0] - minVals[0][0] > limit:\n                i = min(minVals[0][1], maxVals[0][1]) + 1 # this is the new i to start\n                while minVals[0][1] < i:\n                    heappop(minVals)\n                \n                while maxVals[0][1] < i:\n                    heappop(maxVals)\n                \n            #print(nums[i:j+1], bestSize)\n            bestSize = max(bestSize, j - i + 1)\n            j += 1\n            \n        return bestSize\n            \n                        \n", "from collections import deque\ndef addMinStack(stack, val):\n    while stack and stack[-1] > val:\n        stack.pop()\n    stack.append(val)\n    \ndef addMaxStack(stack, val):\n    while stack and stack[-1] < val:\n        stack.pop()\n    stack.append(val)\n\ndef delStack(stack, val):\n    if stack and stack[0] == val:\n        stack.popleft()\n    \n    \n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        minstack = deque([])\n        maxstack = deque([])\n        \n        start = 0\n        end = 0\n        maxSubArray = 0\n        while end < len(nums):\n            addMinStack(minstack, nums[end])\n            addMaxStack(maxstack, nums[end])\n            \n            if maxstack[0] - minstack[0] >limit:\n                while maxstack[0] - minstack[0] > limit:\n                    delStack(minstack, nums[start])\n                    delStack(maxstack, nums[start])\n                    start += 1\n            \n            maxSubArray = max(maxSubArray, end - start+1)\n            end += 1\n        return maxSubArray", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        min_deque, max_deque = deque(), deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\n                min_deque.pop()\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            \n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                if l == min_deque[0]:\n                    min_deque.popleft()\n                if l == max_deque[0]:\n                    max_deque.popleft()\n                l += 1\n            ans = max(ans, r - l + 1)\n            r += 1\n                \n        return ans", "from collections import deque\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        start = 0\n        end = 0\n        res = 0\n    \n        max_q = deque()\n        min_q = deque()\n        \n        while end < len(nums):\n            while max_q and nums[max_q[-1]] <= nums[end]:\n                max_q.pop()\n            while min_q and nums[min_q[-1]] >= nums[end]:\n                min_q.pop()\n            \n            max_q.append(end)\n            min_q.append(end)\n            \n            # print(\\\"1\\\", max_q, min_q)\n            while nums[max_q[0]] - nums[min_q[0]] > limit:\n                start += 1\n                if start > max_q[0]:\n                    max_q.popleft()\n                if start > min_q[0]:\n                    min_q.popleft()\n                \n                # print(\\\"2\\\", max_q, min_q)\n            \n            print((end - start + 1))\n            res = max(res, end - start + 1)\n            end += 1\n        \n        return res\n            \n", "from collections import deque\nclass Solution: #revisit 09/09/2020\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        # for a window, find the window max and the window min\n        # left and right pointer\n        # use max_queue and min_queue to calculate the window max and window min\n        N = len(nums)\n        max_q, min_q = deque([]), deque([])\n        left, right = 0, 0\n        max_length = 0\n        while right < N:\n            while max_q and max_q[-1][1] <= nums[right]:\n                max_q.pop()\n            max_q.append([right, nums[right]])\n            while min_q and min_q[-1][1] >= nums[right]:\n                min_q.pop()\n            min_q.append([right, nums[right]])\n            \n            while max_q[0][1] - min_q[0][1] > limit:\n                left += 1\n                if max_q[0][0] < left:\n                    max_q.popleft()\n                if min_q[0][0] < left:\n                    min_q.popleft()\n            \n            max_length = max(max_length, right - left + 1)\n            right += 1\n        \n        return max_length\n                \n# e.g. [10,1,2,4,7,2], limit = 5\n# left, right =2,5, min_q = [(5,2)], max_q = [(4,7), (5,2)] max_lenght = 4\n\n\n\n\n\n\n\n\n\n\n\n# from collections import deque\n# class Solution:\n#     def longestSubarray(self, nums: List[int], limit: int) -> int:\n#         N = len(nums)\n#         if N == 1:\n#             return 1\n        \n#         result = 0\n#         min_q, max_q = deque([]), deque([])\n#         l, r = 0, 0\n#         while r < N:\n#             while min_q and nums[min_q[-1]] >= nums[r]:\n#                 min_q.pop()\n#             while max_q and nums[max_q[-1]] <= nums[r]:\n#                 max_q.pop()\n#             min_q.append(r)\n#             max_q.append(r)\n            \n#             while nums[max_q[0]] - nums[min_q[0]] > limit:\n#                 l += 1\n#                 if max_q[0] < l:\n#                     max_q.popleft()\n#                 if min_q[0] < l:\n#                     min_q.popleft()\n                    \n#             #print(f\\\"l = {l}, r = {r}, min_q = {min_q}, max_q = {max_q}\\\")\n#             result = max(result, r - l + 1) \n#             r += 1\n#         return result\n        \n", "class Solution:\n\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        max_q = deque() #3,2,1,0\n        min_q = deque() #1,2,3,4\n\n        start = 0\n        ans = 0\n        for end in range(n):\n            while max_q and max_q[-1] < nums[end]:\n                max_q.pop()\n            while min_q and min_q[-1] > nums[end]:\n                min_q.pop()\n            max_q.append(nums[end])\n            min_q.append(nums[end])\n            \n            if max_q[0] - min_q[0] > limit:\n                if max_q[0] == nums[start]:\n                    max_q.popleft()\n                \n                if min_q[0] == nums[start]:\n                    min_q.popleft()\n                \n                start += 1\n            \n            ans = max(end-start+1, ans)\n        return ans\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    def longestSubarray2(self, nums: List[int], limit: int) -> int:\n        #[10,1,2,4,7,2]\n        #queue = [4, 7, 2, 8]\n        #min_queue = [2, 8]\n        #max_queue = [8]\n        #limit: 5\n        #ans: 4\n        q = deque()\n        min_q = deque()\n        max_q = deque()\n        ans = 0\n        for num in nums:\n            q.append(num)\n            while min_q and min_q[-1] > num:\n                min_q.pop()\n            min_q.append(num)\n            while max_q and max_q[-1] < num:\n                max_q.pop()\n            max_q.append(num)\n            while q and max_q[0] - min_q[0] > limit:\n                del_num = q.popleft()\n                if max_q[0] == del_num:\n                    max_q.popleft()\n                if min_q[0] == del_num:\n                    min_q.popleft()\n            ans = max(ans, len(q))\n        return ans\n\n    def longestSubarray2(self, nums: List[int], limit: int) -> int:\n        #[10,1,2,4,7,2]\n        #queue = [4, 7, 2, 8]\n        #min_queue = [2, 8]\n        #max_queue = [8]\n        #limit: 5\n        #ans: 4\n\n        min_q = deque()\n        max_q = deque()\n        start = 0\n        for num in nums:\n            while min_q and min_q[-1] > num:\n                min_q.pop()\n            min_q.append(num)\n\n            while max_q and max_q[-1] < num:\n                max_q.pop()\n            max_q.append(num)\n\n            if max_q[0] - min_q[0] > limit:\n                if max_q[0] == nums[start]:\n                    max_q.popleft()\n                if min_q[0] == nums[start]:\n                    min_q.popleft()\n                start += 1\n        return len(nums) - start\n\n        \n        \n\n    def longestSubarray2(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        min_dp = [[0 for _ in range(n)] for _ in range(n)]\n        max_dp = [[0 for _ in range(n)] for _ in range(n)]\n        ans = 1 if 0 <= limit else 0\n        for i in range(n):\n            min_dp[i][i] = nums[i]\n            max_dp[i][i] = nums[i]\n        for k in range(2, n+1):\n            for i in range(n-k+1):\n                j = i + k - 1\n                min_dp[i][j] = min(min_dp[i][j-1], nums[j])\n                max_dp[i][j] = max(max_dp[i][j-1], nums[j])\n                if max_dp[i][j] - min_dp[i][j] <= limit:\n                    ans = k\n        return ans\n", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        mx, mn = deque([0]),deque([0])\n        result = 1\n        l = 0\n        \n        for i in range(1,len(nums)):\n            while len(mx) != 0 and nums[mx[-1]] < nums[i]:\n                mx.pop()\n            mx.append(i)\n            while len(mn) != 0 and nums[mn[-1]] > nums[i]:\n                mn.pop()\n            mn.append(i)\n            \n            while mx and mn and nums[mx[0]] -nums[mn[0]] > limit:\n                l +=1\n                while mx[0] < l:\n                    mx.popleft()\n                while mn[0] < l:\n                    mn.popleft()\n                \n            result = max(result, i-l+1)\n        return result\n", "# \u6ce8\u610f\u9700\u8981\u6807\u8bb0\u6ed1\u52a8\u7a97\u53e3\u5185min\u548cmax\u7684\u53d6\u503c\uff0c \u5426\u5219\u6709\u53ef\u80fd\u8d85\u65f6\n# \u8fd9\u9898\u9700\u8981\u4f7f\u7528\u5355\u8c03\u6808\u6216\u8005\u6700\u5c0f\u6700\u5927\u5806\n\n\nimport heapq as hq\n\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        mini, maxi, res, i = deque([]), deque([]), 0, 0\n        for j in range(len(nums)):\n            while mini and mini[-1][0] > nums[j]: mini.pop()\n            mini.append((nums[j], j))\n            while maxi and maxi[-1][0] < nums[j]: maxi.pop()\n            maxi.append((nums[j], j))\n            while abs(maxi[0][0] - mini[0][0]) > limit and i < j:\n                if maxi[0][-1] <= i: maxi.popleft() \n                elif mini[0][-1] <= i: mini.popleft()\n                i += 1\n            res = max(res, j - i + 1)\n        return res", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        sd = collections.deque()\n        ld = collections.deque()\n        \n        def smallpush(d, i):\n            while d and d[-1][0] > nums[i]:\n                d.pop()\n            d.append((nums[i], i))\n            \n        def largepush(d, i):\n            while d and d[-1][0] < nums[i]:\n                d.pop()\n            d.append((nums[i], i))\n            \n        def popleft(d, j):\n            while d and d[0][1] < j:\n                d.popleft()\n                \n        n = len(nums)\n        ans = -math.inf\n        start = 0\n        i = 0\n        while i < n:\n            smallpush(sd, i)\n            largepush(ld, i)\n            if abs(ld[0][0] - sd[0][0]) <= limit:\n                ans = max(ans, i - start + 1)\n            else:\n                # print(ld, sd, \\\"  ------\\\")\n                while abs(ld[0][0] - sd[0][0]) > limit:\n                    if ld[0][1] == start:\n                        ld.popleft()\n                    if sd[0][1] == start:\n                        sd.popleft()\n                    start += 1\n                # print(ld, sd)\n                # start = min(ld[0][1], sd[0][1])\n                ans = max(ans, i - start + 1)\n            i += 1\n        return ans", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums: return 0\n        maxd, mind = deque(), deque()\n        res, j = 0, 0\n        \n        for i in range(len(nums)):\n            while len(maxd) > 0 and nums[maxd[-1]] < nums[i]: maxd.pop()\n            while len(mind) > 0 and nums[mind[-1]] > nums[i]: mind.pop()\n            \n            maxd.append(i)\n            mind.append(i)\n            while j < i and len(maxd) > 0 and len(mind) > 0 and nums[maxd[0]] - nums[mind[0]] > limit:\n                if j == maxd[0]: maxd.popleft()\n                if j == mind[0]: mind.popleft()\n                j += 1\n            \n            res = max(res, i - j + 1)\n        \n        return res\n            \n", "from collections import deque\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        lo = i = ans = 0\n        minq, maxq = deque(), deque() #(index, value)\n        \n        while i < len(nums): \n            while minq and minq[-1][1] >= nums[i]: minq.pop()\n            while maxq and maxq[-1][1] <= nums[i]: maxq.pop()\n            minq.append((i, nums[i]))\n            maxq.append((i, nums[i]))\n            \n            if maxq[0][1] - minq[0][1] > limit:\n                lo += 1\n                if lo > minq[0][0]: minq.popleft()\n                if lo > maxq[0][0]: maxq.popleft()\n            else:\n                ans = max(ans, i - lo + 1)\n                i += 1\n        return ans \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        ans = 0\n        min_deque, max_deque = collections.deque(), collections.deque()\n        l = r = 0\n        \n        while r < len(nums):\n            while min_deque and nums[min_deque[-1]] >= nums[r]:\n                min_deque.pop()\n            while max_deque and nums[max_deque[-1]] <= nums[r]:\n                max_deque.pop()\n            min_deque.append(r)\n            max_deque.append(r)\n            \n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\n                l += 1\n                if max_deque[0] < l:\n                    max_deque.popleft()\n                if min_deque[0] < l:\n                    min_deque.popleft()\n            \n            ans = max(ans, r-l+1)\n            r += 1\n            \n        return ans", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for val in nums:\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i\n    \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_q = deque()\n        min_q = deque()\n        left = 0\n        \n        result = 0\n        for i, n in enumerate(nums):\n            while max_q and nums[max_q[-1]] <= n:\n                max_q.pop()\n            max_q.append(i)\n            \n            while min_q and nums[min_q[-1]] >= n:\n                min_q.pop()\n            min_q.append(i)\n            \n            while left < i and nums[max_q[0]] - nums[min_q[0]] > limit:\n                if left == max_q[0]:\n                    max_q.popleft()\n                elif left == min_q[0]:\n                    min_q.popleft()\n                    \n                left += 1\n            \n            result = max(result, i - left + 1)\n        return result", "from collections import deque\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        minq = deque()\n        maxq = deque()\n        ret=l=0\n        for i in range(len(nums)):\n            n = nums[i]\n            while minq and n<minq[-1]:\n                minq.pop()\n            minq.append(n)\n            while maxq and n>maxq[-1]:\n                maxq.pop()\n            maxq.append(n)\n            while maxq[0]-minq[0]>limit:\n                if minq[0]==nums[l]:\n                    minq.popleft()\n                if maxq[0]==nums[l]:\n                    maxq.popleft()\n                l+=1\n            ret = max(ret,i-l+1)\n        return ret", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        max_q = deque()\n        min_q = deque()\n        l = r = 0\n        ans = 0\n        while r < len(nums):\n            num = nums[r]\n            while max_q and nums[max_q[-1]] <= num:\n                max_q.pop()\n            while min_q and nums[min_q[-1]] >= num:\n                min_q.pop()\n            max_q.append(r)\n            min_q.append(r)\n            \n            while nums[max_q[0]] - nums[min_q[0]] > limit:\n                l += 1\n                if l > max_q[0]:\n                    max_q.popleft()\n                if l > min_q[0]:\n                    min_q.popleft()\n            ans = max(ans, r - l + 1)\n            r+=1\n        return ans\n", "import heapq\n\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        if not nums:\n            return 0\n        \n        max_len = 1\n        i, j = 0, 0\n        min_heap = []\n        max_heap = []\n        max_n = min_n = nums[0]\n        \n        while i <= j and j < len(nums):\n            # print(i, j, max_len)\n                    \n            if max_n-min_n <= limit:\n                max_len = max(max_len, j-i+1)\n                j+=1\n                if j == len(nums):\n                    continue\n                if nums[j] > max_n:\n                    max_n = nums[j]\n                    heapq.heappush(min_heap, (nums[j], j))\n                elif nums[j] < min_n:\n                    min_n = nums[j]\n                    heapq.heappush(max_heap, (-nums[j], j))\n                else:\n                    heapq.heappush(min_heap, (nums[j], j))\n                    heapq.heappush(max_heap, (-nums[j], j))\n                    \n            else:\n                if nums[i] == max_n:\n                    while True:\n                        max_n, s = heapq.heappop(max_heap)\n                        if s > i:\n                            max_n *= -1\n                            break\n                elif nums[i] == min_n:\n                    while True:\n                        min_n, t = heapq.heappop(min_heap)\n                        if t > i:\n                            break\n                    \n                i+=1\n            # print(i, j, max_len)\n            # print('-------------')\n        return max_len", "#make every num in nums become right bound for the subarray once, and find the longest subarray.\n#i need to know the max and min value in the subarray, so I'll maintain a  minHeap, maxHeap with (value, index), then I can alway cost O(logn) to get the max and min value.\n#O(NlogN)\n#\nclass Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        VALUE, INDEX = 0, 1\n        left = 0\n        min_h, max_h = [], []\n        max_len = 0\n        #nums = [8,2,4,7]\n        for right, num in enumerate(nums): #right= 3, left = 2\n            heappush(min_h, (num, right)) #max = [(-7,3)(-4,2)(-2,1)]\n            heappush(max_h, (-num, right)) #min = [(4,2)(7,3) (8,0)]\n            #check whether the current subarray is valid\n            #if it is invalid, pop out the extreme value\n            while -max_h[0][VALUE] - min_h[0][VALUE] > limit:\n                if max_h[0][INDEX] < min_h[0][INDEX]:\n                    left = heappop(max_h)[INDEX]+1\n                else:\n                    left = heappop(min_h)[INDEX]+1\n                #clean heap\n                while min_h[0][INDEX] < left: heappop(min_h)\n                while max_h[0][INDEX] < left: heappop(max_h)\n            max_len = max(max_len, right-left+1) #max_len = 2\n        return max_len", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        from heapq import heappop, heappush\n        res = j = 0\n        m = []\n        n = []\n        for i in range(len(nums)):\n            x = nums[i]\n            heappush(m, (-x, i))\n            heappush(n, (x, i))\n            while abs(-m[0][0] - n[0][0]) > limit:\n                j = min(m[0][1], n[0][1]) + 1\n                while j > m[0][1]:\n                     heappop(m)\n                while j > n[0][1]:\n                     heappop(n)\n            res = max(res, i - j + 1)\n\n        return res\n                \n            \n", "class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        maxq = deque()\n        minq = deque()\n        k = 0\n        for i in nums:\n            while maxq and i > maxq[-1]: maxq.pop()\n            while minq and i < minq[-1]: minq.pop()  \n            maxq.append(i)\n            minq.append(i)\n            if maxq[0] - minq[0] > limit:\n                if maxq[0] == nums[k]: maxq.popleft()\n                if minq[0] == nums[k]: minq.popleft()\n                k += 1\n        return len(nums)-k\n            \n            \n"]
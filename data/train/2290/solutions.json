["import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nH, W = map(int, input().split())\ns = [input() for _ in range(H)]\nans = max(H, W)\n\ndef max_rect(a):\n\tres = 0\n\tstack = [a[0]]\n\tfor i in range(1, W-1):\n\t\tnew_pos = i\n\t\twhile stack and stack[-1] % 10000 >= a[i]:\n\t\t\tpos, hght = stack[-1] // 10000, stack[-1] % 10000\n\t\t\tres = max(res, (i - pos + 1) * (hght + 1))\n\t\t\tnew_pos = pos\n\t\t\tstack.pop()\n\t\tstack.append(new_pos * 10000 + a[i])\n\twhile stack:\n\t\tpos, hght = stack[-1] // 10000, stack[-1] % 10000\n\t\tres = max(res, (W - pos) * (hght + 1))\n\t\tstack.pop()\n\treturn res\n\ndp = [[0 for _ in range(W-1)] for _ in range(H-1)]\n\nfor j in range(W-1):\n\tif not ((s[0][j] == s[1][j]) ^ (s[0][j+1] == s[1][j+1])):\n\t\tdp[0][j] = 1\nans = max(ans, max_rect(dp[0]))\n\nfor i in range(1, H-1):\n\tfor j in range(W-1):\n\t\tif not ((s[i][j] == s[i+1][j]) ^ (s[i][j+1] == s[i+1][j+1])):\n\t\t\tdp[i][j] = dp[i-1][j] + 1\n\tans = max(ans, max_rect(dp[i]))\n\nprint(ans)", "def inpl(): return [int(i) for i in input().split()]\n\nH, W = inpl()\nans = max(H, W)\nS = [input() for _ in range(H)]\nT = [[0]*(W-1)]\nfor i in range(H-1):\n    t = []\n    for j in range(W-1):\n        r = S[i][j:j+2] + S[i+1][j:j+2]\n        t.append(r.count('.')%2)\n    ts = [T[-1][i] + 1 if not k else 0 for i, k in enumerate(t) ]\n    T.append(ts)\nfor iT in T[1:]:\n    stack = []\n    for i, l in enumerate(iT+[0]):\n        dw = -1\n        while stack and stack[-1][1] >= l:\n            dw, dh = stack.pop()\n            ans = max(ans, (dh+1)*(i-dw+1))\n        if dw != -1:\n            stack.append((dw,l))\n            continue\n        stack.append((i, l))\nprint(ans)", "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    # O(N)\n    def largest_rectangle_histogram(A):\n        A.append(0)\n        N = len(A)\n        ret = 0\n        st = [-1]\n        left = [0] * N\n        for i in range(N):\n            while A[st[-1]] >= A[i]:\n                # ret = max(ret, A[st[-1]] * (i - left[st[-1]] - 1))\n                ret = max(ret, (A[st[-1]] + 1) * (i - left[st[-1]]))\n                st.pop()\n                if not st:\n                    break\n            if st:\n                left[i] = st[-1]\n            else:\n                left[i] = -1\n            st.append(i)\n        return ret\n\n    # O(H * W)\n    def largest_rectangle_grid(grid, ok=1, ng=0):\n        H = len(grid)\n        W = len(grid[0])\n        hist = [[0] * W for _ in range(H)]\n        for h in range(H):\n            for w in range(W):\n                if grid[h][w] == ok:\n                    hist[h][w] = hist[h - 1][w] + 1\n        ret = 0\n        for h in range(H):\n            ret = max(ret, largest_rectangle_histogram(hist[h]))\n        return ret\n\n    H, W = list(map(int, input().split()))\n    grid = []\n    for _ in range(H):\n        grid.append(input().rstrip('\\n'))\n\n    corner = [[0] * (W-1) for _ in range(H-1)]\n    for h in range(H-1):\n        for w in range(W-1):\n            cnt = 0\n            if grid[h][w] == \"#\":\n                cnt += 1\n            if grid[h+1][w] == \"#\":\n                cnt += 1\n            if grid[h][w+1] == \"#\":\n                cnt += 1\n            if grid[h+1][w+1] == \"#\":\n                cnt += 1\n            if cnt%2 == 0:\n                corner[h][w] = 1\n    print((max(largest_rectangle_grid(corner), H, W)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nH,W=list(map(int,input().split()))\nS=[input() for i in range(H)]\ntable=[[0]*(W-1) for i in range(H-1)]\nfor i in range(W-1):\n    for j in range(H-1):\n        table[j][i]=(int(S[j][i]=='#')+int(S[j+1][i]=='#')+int(S[j][i+1]=='#')+int(S[j+1][i+1]=='#') +1 )%2\n\ndef get_rec(L):\n    a = len(L)\n    arr = L + [0]\n    stack = deque()\n    ans = -1\n    for i in range(a + 1):\n        #print(stack)\n        if len(stack)==0:\n            stack.append((arr[i], i))\n        elif stack[-1][0] < arr[i]:\n            stack.append((arr[i], i))\n        elif stack[-1][0] > arr[i]:\n            while len(stack) != 0 and stack[-1][0] >= arr[i]:\n                x, y = stack.pop()\n                ans = max((x+1) * (i - y+1), ans)\n            # print(x,y,x*(i-y))\n            stack.append((arr[i], y))\n        #print(ans)\n    return ans\ndp=[[0]*(W-1) for i in range(H-1)]\nfor i in range(W-1):\n    for j in range(H-1):\n        if j==0:\n            dp[0][i]=table[0][i]\n            continue\n        if table[j][i]==1:\n            dp[j][i]=dp[j-1][i]+1\nans=max(H,W)\nfor j in range(H-1):\n    ans=max(ans,get_rec(dp[j]))\nprint(ans)\n", "H,W=list(map(int,input().split()))\nans=max(H, W)\nS=[input() for i in range(H)]\nT = [[0]*(W-1)]\nfor i in range(H-1):\n    t,ts=[],[]\n    for j in range(W-1):\n      r=S[i][j:j+2]+S[i+1][j:j+2]\n      t.append(r.count('.')%2)\n      if t[j]==0:\n        ts.append(T[-1][j]+1)\n      else:\n        ts.append(0)\n    T.append(ts)\nfor L in T[1:]:\n    stack=[]\n    for i,l in enumerate(L+[0]):\n      w=-1\n      while stack and stack[-1][1]>=l:\n        w,h=stack.pop()\n        ans = max(ans, (h+1)*(i-w+1))\n      if w!=-1:\n        stack.append((w,l))\n        continue\n      stack.append((i,l))\nprint(ans)\n", "H, W = list(map(int, input().split()))\nS = [input() for _ in range(H)]\n\nans = max(H, W)\n\nf = [1] * W\nfor i in range(1, H):\n    f = [(f[j]+1) if (S[i-1][j:j+2] + S[i][j:j+2]).count('#') in [0,2,4] else 1 for j in range(W-1)] + [0]\n    stk = []\n    for j, v in enumerate(f):\n        while len(stk) > 0 and f[stk[-1]] >= v:\n            ans = max(ans, f[stk.pop()] * (j - (stk[-1] if len(stk) > 0 else -1)))\n        stk.append(j)\n\nprint(ans)\n", "import sys\n\ninput=sys.stdin.readline\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef main():\n    h, w = MI()\n    s = [[c == \"#\" for c in input()[:-1]] for _ in range(h)]\n    #if w == 2:\n    #    s = [list(sc) for sc in zip(*s)]\n    #    h, w = w, h\n    # p2D(s)\n    t = [[-1] * (w - 1) for _ in range(h - 1)]\n    for i in range(h - 1):\n        si = s[i]\n        si1 = s[i + 1]\n        t[i] = [1 - (sum(si[j:j + 2]) + sum(si1[j:j + 2])) % 2 for j in range(w - 1)]\n    # p2D(t)\n    # print()\n    ti=t[0]\n    for i in range(1, h - 1):\n        ti1=ti\n        ti=t[i]\n        for j in range(w - 1):\n            if ti[j]: ti[j] = ti1[j] + 1\n    # p2D(t)\n    ans = 0\n    for i in range(h - 1):\n        jtol = [0] * (w - 1)\n        jtor = [0] * (w - 1)\n        ti=t[i]\n        # \u9ad8\u3055\u3001\u4f4d\u7f6e\u306e\u9806\n        stack = [[-1, 0]]\n        for j in range(w - 1):\n            tij=ti[j]\n            while stack[-1][0] >= tij: stack.pop()\n            jtol[j] = stack[-1][1]\n            stack.append([tij, j + 1])\n\n        stack = [[-1, w - 1]]\n        for j in range(w - 2, -1, -1):\n            tij=ti[j]\n            while stack[-1][0] >= tij: stack.pop()\n            jtor[j] = stack[-1][1]\n            stack.append([tij, j])\n\n        for j in range(w - 1):\n            tmp = (jtor[j] - jtol[j] + 1) * (ti[j] + 1)\n            if tmp > ans: ans = tmp\n    print(max(ans,h,w))\n\nmain()\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nh,w = map(int,input().split())\ns = []\nfor i in range(h):\n  q = input().rstrip()\n  s.append(q)\n\nchk = [[0]*(w-1) for i in range(h-1)]\nfor i in range(w-1):\n  for j in range(h-1):\n    chk[j][i] = 1-int((s[j][i]=='#')^(s[j+1][i]=='#')^(s[j][i+1]=='#')^(s[j+1][i+1]=='#'))\n\ndef f(a):\n  a += [0]\n  stack = deque()\n  ans = -1\n  for i in range(w):\n    if stack == deque():\n        stack.append((a[i], i))\n    elif stack[-1][0] < a[i]:\n        stack.append((a[i], i))\n    elif stack[-1][0] > a[i]:\n      while stack and stack[-1][0] >= a[i]:\n        x, y = stack.pop()\n        ans = max((x+1)*(i-y+1), ans)\n      stack.append((a[i], y))\n  return ans\n  \ndp = [[0]*(w-1) for i in range(h-1)]\nfor i in range(w-1):\n  dp[0][i] = chk[0][i]\n  \nfor i in range(1,h-1):\n  for j in range(w-1):\n    if chk[i][j]:\n      dp[i][j] = dp[i-1][j]+1\n\nans=max(h,w)\nfor i in range(h-1):\n    ans=max(ans,f(dp[i]))\n    \nprint(ans)"]
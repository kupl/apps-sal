["class Solution:\n    def minOperations(self, n: int) -> int:\n        return (n*n)>>2\n                \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n % 2 == 0:\n            return (n//2)*(n//2)\n        else:\n            return (n-1)*(1+(n-1)//2)//2", "class Solution:\n    def minOperations(self, n: int) -> int:\n        out = 0\n        diff = (n - 1)\n        while diff > 0:\n            out += diff\n            diff -= 2\n        \n        return out\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        c = 0\n        for i in range(n//2):\n            c += n - (2*i+1)\n        return c", "class Solution:\n    def minOperations(self, n: int) -> int:\n        sum_out = None    \n        if n%2 == 1:\n            l = int(n/2)\n            num_ops = n-1\n            sum_out = 0\n            for i in range(l):\n                sum_out += num_ops\n                num_ops -=2\n                \n        elif n%2 == 0:\n            num_ops = n-1;\n            l = int(n/2)\n            sum_out = 0\n            for i in range(l):\n                sum_out+= num_ops\n                num_ops -=2 \n                \n        return sum_out        \n        \n                \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        count = 0\n        for i in range(n//2):\n            count += n - (2*i+1)\n        return count", "class Solution:\n    def minOperations(self, n: int) -> int:\n        avg = n\n        \n        count = 0\n        # print(\\\"n = {}\\\".format(n))\n        for i in range((n//2)):\n            count += avg - (2*i + 1)\n            # print(\\\"i = {}, count = {}\\\".format(i, count))\n          \n        return count\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        total = 0\n        for i in range(n//2): \n            total += n - (2*i + 1)\n        return total\n    \n        # middle one is 2k + 1\n        # first is 2*0 + 1\n        # last is 2*n + 1 --> diff is 2(n-k) so around n\n        # second last is 2*(n-1) + 1 --> diff is 2(n-k-1) so around n - 2\n        # inds_from_end = 0\n        # arr = [(2*i)+1 for i in range(n)]\n        # count = 0\n        # # print(arr)\n        # while len(set(arr)) != 1 and inds_from_end < n//2:\n        #     # print(arr, n-inds_from_end-1)\n        #     while arr[inds_from_end] != arr[n-inds_from_end-1]:\n        #         print(arr, count)\n        #         arr[inds_from_end] += 1\n        #         arr[n-inds_from_end-1] -= 1\n        #         count += 1\n        #     inds_from_end += 1\n            \n        return count", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n == 1:\n            return 0\n        result = 0\n        for i in range(n//2):\n            if n % 2 != 0:\n                result += 2*(i+1)\n            else:\n                result += 1+ 2*i\n        return result\n    \n        \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        count = sum([x*2 for x in range((n+1)//2)])\n        if n % 2 == 0:\n            count += n//2\n        return count", "class Solution:\n    def minOperations(self, n: int) -> int:\n        i, ans = 1, 0\n        while i < n:\n            ans += n - i\n            i += 2\n        return ans", "class Solution:\n    def minOperations(self, n: int) -> int:\n        l, r = 1, 2*(n-1) + 1\n        total = 0\n        \n        while l < r:\n            total += (r-l) // 2\n            l += 2\n            r -= 2\n        \n        return total", "class Solution:\n    def minOperations(self, n: int) -> int:\n        return n**2 // 4", "class Solution:\n    def minOperations(self, n: int) -> int:\n        res=0\n        for i in range(n//2):\n            res+=abs(2*i+1-n)\n        return res", "class Solution:\n    def minOperations(self, n: int) -> int:\n        count = 0\n        if n % 2 == 1:\n            i = 0\n            mid = (2*(int(n/2)))+1\n            while i < int(n/2):\n                count += mid-((2*i)+1)\n                i+=1\n        else:\n            i = 0\n#             [1, 3, 5, 7, 9, 11]\n            mid = (2*((n/2)))\n            while i < n/2-1:\n                count += mid-((2*i)+1)\n                i +=1\n            count += 1\n        return int(count)\n    \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        mid=0\n        count=0\n        if n%2 == 0:\n            mid = ((n//2)*2+1 + (n//2-1)*2 +1)//2\n            for i in range(n//2):\n                count=count + mid-(i*2+1) \n                \n        else:\n            mid = ((n-1)//2)*2 +1\n            for i in range(n//2):\n                count=count + mid-(i*2+1) \n                \n                \n        return count", "# [1, 3, 5, 7, ...]\n\n# [1, 3, 5, 7, 9] -> 5 will be the mid point\n\n# if n is odd -> \n#   for i->n/2\n#       steps += 2**i\n\n# We have to take advante of the symmetry\n\n# if n is even\n# [1, 3, 5, 7] -> Mid point is 4\n#  \n\n# [1,3,5,7,9.11]\nclass Solution:\n    def minOperations(self, n: int) -> int:\n        mid_point = (2*(n//2)) + 1 - (n%2==0)\n        return sum([ mid_point - ((2*i)+1) for i in range(n//2)] )\n        \n        \n            \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        ans=0\n        for i in range(1,2*n,2):\n            ans+=abs(i-n)\n        return ans>>1", "class Solution:\n    def minOperations(self, n: int) -> int:\n        count = 0\n        if n % 2 == 1:\n            i = 0\n            mid = (2*(int(n/2)))+1\n            # print(mid)\n            # print(int(n/2))\n            while i < int(n/2):\n                # print(i)\n                count += mid-((2*i)+1)\n                i+=1\n        else:\n            i = 0\n#             [1, 3, 5, 7, 9, 11]\n            mid = (2*((n/2)))\n            # print(mid)\n            while i < n/2-1:\n                # print(i)\n                # print(count)\n                count += mid-((2*i)+1)\n                i +=1\n            count += 1\n        return int(count)\n    \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        even = n % 2 == 0 and True or False\n        half = even and int(n/2) or n//2\n        left = right = 0\n        for i in range(n):\n            if i < half:\n                left += (2*i)+1\n            elif i == half and even:\n                return left\n            elif i > half:\n                right += (2*i)+1\n    \n        return int((right - left) / 2)", "class Solution:\n    def minOperations(self, n: int) -> int:\n        # array is like 1, 3, 5, 7, 9....\n        #               2     5     8\n        #               3           7\n        #               4           6\n        #               5           5\n        \n        # 2 6 3 5 4 4\n        # diff / 2\n        # array is like 1 3 5 7\n        #                      \n        if n == 1:\n            return 0\n\n        # one pair is difference divided by 2\n        low = 0\n        hi = n - 1\n        num_ops = 0\n        while low < hi:\n            min_num = (2 * low) + 1\n            max_num = (2 * hi) + 1\n\n            num_ops += (max_num - min_num) // 2\n                \n            low += 1\n            hi -= 1\n            \n        return num_ops", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [ i for i in range(1, n*2, 2) ]\n        target = 0\n        ops = 0\n\n        if n%2 == 1:\n                idx = n//2\n                target = arr[idx]\n\n        else:\n            right = n//2\n            left = right-1\n            print(right)\n            print(left)\n            print(arr)\n            target = arr[left]+1\n\n        for j in range(n//2):\n            diff = target - arr[j]\n            ops += diff\n\n        return ops\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        # arr = []\n        # for i in range(0, n):\n        #     arr.append(2*i+1)\n        sumz = 0\n        for i in range(0, n):\n            sumz+=2*i+1\n        median = sumz//n \n        # print(median, arr)\n        steps = 0\n        for i in range(n//2):\n            steps+=median-(2*i+1)\n\n        return steps ", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n%2 == 0:\n            return int((n/2)**2)\n        else:\n            return int(((n-1)/2)**2 + (n-1)/2)", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2 * i + 1 for i in range(n)]\n        target = sum(arr)//n\n        ans = 0\n        for i in range(n//2):\n            ans += target - arr[i]\n        return ans\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        \n        ops = 0\n        for i in range(n):\n            ops += abs((2 * i + 1) - n)\n        \n        return ops // 2\n#         (1 + n) / 2 * n * 2 + n\n        \n#         n2 + n + 1\n        \n#         (n - 1)\n        \n        \n#         1 + 2n - 2 + 1 / 2 * n\n        \n        \n#         n^2 / n\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        \n        \n        sum_tot = 0\n        for i in range(n):\n            val = 2*i+1\n            #print(val)\n            if val > n:\n                sum_tot += val-n\n            else:\n                sum_tot += n - val\n        \n        return(int(sum_tot/2))\n        \n        \n        '''\n        if n%2  == 0:\n            median = int((arr[int(n/2)] + arr[int(n/2)-1])/2)\n        else:\n            median = arr[int(n/2)]\n        print(median)\n        \n        ctr = 0\n        while(len(set(arr)) > 1):\n            min_elem = arr[-1] + 1\n            max_elem = -1\n            min_ind = -1\n            max_ind = -1\n            for i in range(len(arr)):\n                if arr[i] > max_elem:\n                    max_elem = arr[i]\n                    max_ind = i\n                if arr[i] < min_elem:\n                    min_elem = arr[i]\n                    min_ind = i\n            arr[max_ind] -= 1\n            arr[min_ind] += 1\n            ctr += 1\n        \n        return ctr\n        '''", "class Solution:\n    def minOperations(self, n: int) -> int:\n        # \ud3c9\uade0\uc744 \uad6c\ud55c\ub2e4. \ud3c9\uade0\uc740 n\uc774 \ub41c\ub2e4.\n        # \ud3c9\uade0\uc73c\ub85c \ubd80\ud130 \uac01 \uac70\ub9ac\ub97c \ub2e4 \ub354\ud55c\ub2e4.\n        # \ubc18\uc73c\ub85c \ub098\ub208\ub2e4.\n        count=0;\n        for i in range(n):\n            target=(2*i)+1;\n            count+=abs(n-target);\n        print(count);\n        return count//2;\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2 * i + 1 for i in range(n)]\n        \n        target = sum(arr)//n\n        ans = 0\n        for i in range(len(arr)//2):\n            ans += abs(arr[i] - target)\n        return ans", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2 * i + 1 for i in range(n)]\n        \n        target = sum(arr)//n\n        res = 0\n        for i in range(n//2):\n            res += abs(target - arr[i])\n        return res\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        totalSum = int(n*(2*1+(n-1)*2)/2)\n        #numbers are of the sequence = 1,3,5,7,....\n        targetNumber = int(totalSum/n)\n        #so each number is (targetNumber-i)\n        return sum(abs(2*i+1-targetNumber) for i in range(0,n))//2\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2 * i + 1 for i in range(n)]\n        target = sum(arr)//n\n        ans = 0\n        for i in range(n//2):\n            ans += abs(target - arr[i])\n        return ans\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr=[]\n        c=0\n        for i in range(n):\n            arr.append(2*i+1)\n        tar1=len(arr)\n        tar2=tar1\n        if(tar1%2==0):\n            tar2=tar2-1\n        ans=arr.index(tar2)\n        for i in range(ans):\n            c+=tar1-arr[i]\n        if(tar1!=tar2):\n            c+=1\n        return c", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = []\n        min_operations = 0\n        for i in range(n):\n            arr.append((2 * i) + 1)\n        target = sum(arr) // n\n        middle = ceil(n / 2)\n        # print(arr, target, middle)\n        for i in range(ceil(n / 2)):\n            min_operations += (target - arr[i])\n        return min_operations\n    \n# 1 - 0\n# 2 - 1\n# 3 - 2\n# 4 - 4\n# 5 - 6\n# 6 - 9\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n%2==0:\n            return int(n/2)*int(n/2)\n        else:\n            return int(n/2)*(int(n/2)+1)\n", "import math\nclass Solution:\n    def minOperations(self, n: int) -> int:\n        ans = 0\n        for x in range(0, n+1):\n            ans += math.floor(x/2)\n        return ans", "class Solution:\n    def minOperations(self, n: int) -> int:\n        nums = [2 * i + 1 for i in range(n)]\n        res = 0\n        for i in range(n // 2):\n            res += (nums[n - 1 - i] - nums[i]) >> 1\n        return res", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            arr = [0]*n\n            arr[0] = 1\n            arr[1] = 3\n            for i in range(2,n):\n                arr[i] = arr[i-1] + 2\n            if n % 2 != 0:\n                ans = 0\n                i = 0\n                j = len(arr)-1\n                while i < j:\n                    ans += (arr[j]-arr[i])//2\n                    i += 1\n                    j -= 1\n                return ans\n            else:\n                ans = 0\n                n = n // 2\n                i = 1\n                count = 0\n                ans = 0\n                while count < n:\n                    ans += i\n                    i += 2\n                    count += 1\n                return ans", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr=[]\n        for i in range(n):\n            arr.append((2*i)+1)\n        s=sum(arr)//n\n        res=0\n        for i in range(n//2):\n            res+=s-arr[i]\n        return res", "class Solution:\n    def minOperations(self, n: int) -> int:\n        A = [2*i+1 for i in range(n)]\n        median = A[len(A)//2]\n        return sum(abs(i - median) for i in A)//2\n", "import numpy as np\nclass Solution:\n    def minOperations(self, n: int) -> int:\n        res = 0\n        for i in range(n):\n            value = 2*i+1-n\n            if value>0:\n                res+= value\n        return res", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [0] * n\n        for i in range(len(arr)):\n            arr[i] = (2 * i) + 1\n        s = 0\n        for i in range(len(arr)//2):\n            s += abs(arr[i] - arr[len(arr)-i-1])\n        return s//2            ", "class Solution:\n    def minOperations(self, n: int) -> int:\n        s = 0\n        for i in range(n):\n            s = s + 2*i+1\n        x = s//n\n        print(x)\n        y = 0\n        for i in range(n):\n            if(2*i+1<x):\n                y = y+x-(2*i+1)\n        return y\n            \n            \n        \n        \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        half = n//2\n        return half*n - half**2", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2 * i + 1 for i in range(n)]\n        \n        target = sum(arr)//n\n        ans = 0\n        for i in range(n//2):\n            ans += abs(target - arr[i])\n        return ans\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [(2 * i) + 1 for i in range(n)]\n        target = sum(arr) / n\n        opCount = 0\n        ptr1 = 0\n        ptr2 = len(arr) - 1\n            \n        while ptr1 < ptr2:\n            stepSum = (arr[ptr2] - arr[ptr1]) // 2\n            opCount += int(stepSum)\n            ptr1 += 1\n            ptr2 -= 1\n        \n        return opCount\n            \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2*i+1 for i in range(n)]\n        each = sum(arr)//n\n    \n        for i in range(n):\n            arr[i] = each - arr[i]\n        sums = 0\n        for i in arr:\n            if i>0:\n                sums += i\n        return sums\n                \n\n            \n", "class Solution:\n    def minOperations(self, n):\n        arr = [];\n        count = 0;\n\n        for x in range(n):\n            arr.append(2 * x + 1)\n        avg = sum(arr) // n\n\n        for x in range(n):\n            count += abs(arr[x] - avg)\n        return count // 2\n\nsol = Solution();\nx = sol.minOperations(3);\nprint(x);", "class Solution:\n    def minOperations(self, n: int) -> int:\n        #if n is odd, the middle one does not need an operatio\n        #[1,3,5,10,17,26,(37)]\n        A = [x*2+1 for x in range(n)]\n        s = sum(A)/n\n        c = 0\n        while True:\n            for i in A:\n                if i>=s:\n                    return int(c)\n                c += (s-i)\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n==1:\n            return 0\n        elif n==2:\n            return 1\n        else:\n            count=0\n            i=1\n            while i<n:\n                print(i)\n                count+=n-i\n                i+=2\n            return count", "class Solution:\n    def minOperations(self, n: int) -> int:\n        ans=0\n        tot=0\n        arr=[]\n        for i in range(n):\n            arr.append((2*i)+1)\n            tot+=((2*i)+1)\n        tot=tot//n\n        for i in arr:\n            if(i<tot):\n                ans+=(tot-i)\n        return ans", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n==1:\n            return 0\n        elif n==2:\n            return 1\n        else:\n            target=n+1\n            count=0\n            i=1\n            while i<=n:\n                count+=abs(target-2*i+1)\n                i+=1\n            return count//2", "class Solution:\n    def minOperations(self, n: int) -> int:\n        return (n//2)*((n//2)+n%2)", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = []\n        for i in range(n):\n            arr.append(2*i+1)\n            \n        double_cnt = 0\n        for i in range(len(arr)):\n            double_cnt += abs(arr[i]-n)\n        return double_cnt//2\n            \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        A = [_*2 + 1 for _ in range(n)]\n        ret = 0\n        for i in range(0, n //2):\n            ret += n - i * 2 - 1\n        return ret", "class Solution:\n    def minOperations(self, n: int) -> int:\n        # tot=0\n        # quant = 0\n        # for i in range(n):\n        #     quant = abs(n - (2*i+1))\n        #     if( quant> 0):\n        #         tot +=  quant\n        \n        return sum([abs(n-2*i-1)  for i in range(n) if abs(n-2*i-1) > 0]) // (2)\n            \n            \n            \n        \n            \n        \n            \n            \n", "import numpy as np\nclass Solution:\n    def minOperations(self, n: int) -> int:\n        res = np.zeros((n,1),dtype=int)\n        for i in range(n):\n            value = 2*i+1-n\n            if value>0:\n                res[i] = value\n        return res.sum()", "class Solution:\n    def minOperations(self, n: int) -> int:\n        \n        total = 0\n        arr = []\n        \n        for i in range(n):\n            arr.append(2*i + 1)\n        \n        for i in range(int(len(arr)/2)):\n            total += (arr[int(math.ceil(len(arr)/2 + i))] - arr[i]) / 2\n        \n        return int(total)\n        \n        \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        \n        def isAllEqual(array):\n            for i in range(len(array[1:])):\n                if array[i] != array[0]:\n                    return False\n            \n            return True\n        \n        # generate array; where array[i] = 2i + 1\n        arr = [((2 * x)+1) for x in range(n)]\n        \n        # choose x and y, arr[x]-=1 arr[y]-=1\n        # generate all pairs\n        count = 0\n        x = 0\n        y = len(arr)-1\n        \n        while (x < y):\n            diff = int((arr[y]-arr[x])/2)\n            arr[x] += diff\n            arr[y] -= diff\n            count += diff\n            x += 1\n            y -= 1\n        \n        return count\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        \n        generatedArray = []\n        \n        for i in range(n):\n            generatedArray.append((2 * i) + 1)\n\n        arrayLength = len(generatedArray)\n\n        noOperations = 0\n        \n        # if arrayLength % 2 != 0:\n        #     targetNumber = generatedArray[int(arrayLength // 2)]\n        # else:\n        #     targetNumber = generatedArray[int(arrayLength // 2) - 1] + 1 \n            \n        for i in range(int(arrayLength//2)):\n            noOperations += (n - generatedArray[i]) \n\n        return noOperations", "class Solution:\n    def minOperations(self, n: int) -> int:\n        res = 0\n        arr = [2*i+1 for i in range(n)]\n        for item in arr:\n            if item <n:\n                res+=n-item\n            else:\n                break\n        return res\n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        sum=0\n        for i in range(n):\n            sum +=2*i+1\n        eq=sum/n\n\n        step=0\n        for i in range(int(n/2)):\n            step +=int(eq-(2*i+1))\n        return step", "class Solution:\n    def minOperations(self, n: int) -> int:\n        return sum(list(range(1, n, 2))) if n%2 == 0 else sum(list(range(2, n, 2)))", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [i * 2 + 1 for i in range(n)]\n        if n % 2 == 0:\n            median = (arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]) // 2\n            return sum(arr[i] - median for i in range(n // 2 + 1, n)) + 1\n        else:\n            median = arr[len(arr) // 2]\n            return sum(arr[i] - median for i in range(n // 2 + 1, n))", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr = [2*i+1 for i in range(n)]\n        avg = int(sum(arr) / len(arr))\n        return sum([abs(a-avg) for a in arr])//2", "class Solution:\n    def minOperations(self, n: int) -> int:\n        \n        v = 0\n        for i in range(n): v += 2 * i + 1\n        \n        mean = v // n\n        \n        ans = 0\n        for i in range(n):\n            ans += max(0, 2 * i + 1 - mean)\n        return ans", "class Solution:\n    def minOperations(self, n: int) -> int:\n        arr=[0]*n\n        for i in range(n):\n            arr[i]=(2*i)+1\n        print(arr)\n        \n        k=arr[int(len(arr)/2)]\n        print(k)\n        total=0\n        for i in range(len(arr)):\n            p=int(arr[i])\n            total=total+abs(k-p)\n        return int(total/2)", "class Solution:\n    def minOperations(self, n: int) -> int:\n        if n == 0 or n == 1:\n            return 0\n        else:\n            return (int(n/2)) + self.minOperations(n-1)", "class Solution:\n    def minOperations(self, n: int) -> int:\n        # [1] 1 => 0\n        # [1,3] 2 => 1\n        # [1,3,5] 3 => 2\n        # [1,3,5,7] 4 => 1 + 3 = 4\n        # [1,3,5,7,9] 5 => 2 + 4 = 6\n        # [1,3,5,7,9,11] 6 => 1 + 3 + 5 = 9\n        # [1,3,5,7,9,11,13] 7 => 2 + 4 + 6 = 12\n        \n        if n <= 1:\n            return 0\n        else:\n            ops = 0\n            for x in range(n-1,0, -2):\n                ops += x\n            return ops\n            \n            \n        \n", "class Solution:\n    def minOperations(self, n: int) -> int:\n        half = n//2\n        half_list = [x for x in range(1,n,2)]\n        return half*n - sum(half_list)"]
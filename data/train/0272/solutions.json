["class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # nested boxes\n        reachable=[False]*len(status)\n        visited=[False]*len(status)\n        for box in initialBoxes:\n            reachable[box]=True\n        for i in range(len(containedBoxes)):\n            for inside in containedBoxes[i]:\n                reachable[inside]=False\n        # we only start with initial boxes\n        queue=initialBoxes\n        target=[]\n        ret=0\n        while queue:\n            for box in queue:\n                if status[box]==1 and reachable[box] and not visited[box]:\n                    ret+=candies[box]\n                    visited[box]=True\n                    for key in keys[box]:\n                        if status[key]==0:\n                            status[key]=1\n                            if reachable[key]:\n                                target.append(key)\n                    for inside in containedBoxes[box]:\n                        reachable[inside]=True\n                        if status[inside]==1:\n                            target.append(inside)\n                else:\n                    target.append(box)\n            if target==queue:\n                break\n            queue=target\n            target=[]\n        return ret\n", "from collections import deque\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        q = deque(initialBoxes)\n        visited = set()\n        res = 0\n        while q:\n            itr, opened = len(q), False  # To detect cycle\n            opened = False\n            while (itr):\n                itr -= 1\n                v = q.popleft()\n                if status[v]: # Open box, (key is available or is open)\n                    \n                    opened = True\n                    res += candies[v]\n                    visited.add(v)\n                    \n                    for x in keys[v]:\n                        status[x] = 1\n                    \n                    for x in containedBoxes[v]:\n                        if x not in visited:\n                            q.append(x)\n                            \n                elif v not in visited: # Open when key is available\n                    q.append(v)\n            if not opened:\n                return res  # Exit cycle detected\n        return res\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        reachable = [False for _ in status]\n        for i in initialBoxes:\n            reachable[i] = True\n        can_open = [val == 1 for val in status]\n        nodes_to_visit = [b for b in range(len(status)) if reachable[b] and can_open[b]]\n        total_candies = 0\n        while len(nodes_to_visit) >= 1:\n            curr_node = nodes_to_visit[0]\n            nodes_to_visit = nodes_to_visit[1:]\n            total_candies += candies[curr_node]\n            for k in keys[curr_node]:\n                if not can_open[k] and reachable[k]:\n                    nodes_to_visit.append(k)\n                can_open[k] = True\n            for b in containedBoxes[curr_node]:\n                if not reachable[b] and can_open[b]:\n                    nodes_to_visit.append(b)\n                reachable[b] = True\n        return total_candies", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        stack = deque(initialBoxes)\n        seen = set()        \n        kseen = set()\n        while stack:\n            for _ in range(len(stack)):\n                box = stack.popleft()\n                seen.add(box)\n                for key in keys[box]:\n                    status[key] = 1\n                for tbox in containedBoxes[box]:\n                    if tbox not in seen:\n                        stack.append(tbox)\n        res = 0\n        for box in seen:\n            if candies[box] and status[box]:\n                res += candies[box]\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        n = len(status)\n        visited = [0] * n\n        unopened = [0] * n\n        opened = []\n        \n        ans = 0\n        for b in initialBoxes:\n            if status[b] == 1:\n                opened.append(b)\n                visited[b] = 1\n            else:\n                unopened[b] = 1\n        while opened:\n            q2 = []\n            for b in opened:\n                ans += candies[b]\n                for bb in containedBoxes[b]:\n                    if visited[bb] == 0:\n                        if status[bb] == 1:\n                            q2.append(bb)\n                        else:\n                            unopened[bb] = 1\n                for k in keys[b]:\n                    status[k] = 1\n                    if unopened[k] == 1 and visited[k] == 0:\n                        unopened[k] = 0\n                        visited[k] = 1\n                        q2.append(k)\n            opened = q2\n        return ans\n            \n", "from typing import List\nimport collections\n\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int],\n                   keys: List[List[int]], containedBoxes: List[List[int]],\n                   initialBoxes: List[int]) -> int:\n        parent = {}\n        used = {}\n        ans = 0\n        for i in range(len(containedBoxes)):\n            used[i] = False\n            for box in containedBoxes[i]:\n                parent[box] = i\n        queue = collections.deque(initialBoxes)\n        for box in initialBoxes:\n            used[box] = True\n        while queue:\n            curr_box = queue.popleft()\n            ans += candies[curr_box]\n            for key in keys[curr_box]:\n                status[key] = 1\n                if key in parent and used[parent[key]] and not used[key]:\n                    used[key] = True\n                    queue.append(key)\n\n            for box in containedBoxes[curr_box]:\n                if status[box] and not used[box]:\n                    used[box] = True\n                    queue.append(box)\n        return ans\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # nested boxes\n        reachable=[False]*len(status)\n        visited=[False]*len(status)\n        for box in initialBoxes:\n            reachable[box]=True\n            visited[box]=True\n        for i in range(len(containedBoxes)):\n            for inside in containedBoxes[i]:\n                reachable[inside]=False\n        # we only start with initial boxes\n        queue=initialBoxes\n        target=[]\n        ret=0\n        while queue:\n            cnt=0\n            for box in queue:\n                if status[box]==1 and reachable[box]:\n                    cnt+=1\n                    ret+=candies[box]\n                    visited[box]=True\n                    for key in keys[box]:\n                        if status[key]==0:\n                            status[key]=1\n                            if reachable[key] and not visited[key]:\n                                target.append(key)\n                                visited[key]=True\n                    for inside in containedBoxes[box]:\n                        reachable[inside]=True\n                        if status[inside]==1 and not visited[inside]:\n                            target.append(inside)\n                            visited[inside]=True\n                else:\n                    target.append(box)\n            if cnt==0:\n                break\n            queue=target\n            target=[]\n        return ret", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        total = 0\n        boxes = initialBoxes[:]\n        locked = []\n        while boxes:\n            if not any([status[temp] for temp in boxes]):\n                break\n            box = boxes.pop(0)\n            if status[box]:\n                total += candies[box]\n                for contained in containedBoxes[box]:\n                    boxes.append(contained)\n                for key in keys[box]:\n                    status[key] = 1\n            else:\n                boxes.append(box)\n        return total", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        candy_count = 0\n        my_boxes = initialBoxes\n        my_keys = []\n        \n        while my_boxes:\n            l = len(my_boxes)\n            opened_new = False\n            for b_i in range(l-1,-1,-1):\n                my_box = my_boxes[b_i]\n                if status[my_box] or my_box in my_keys: # already open                  \n                    my_boxes.pop(b_i)\n                    my_boxes.extend(containedBoxes[my_box])\n                    candy_count += candies[my_box]\n                    my_keys.extend(keys[my_box])\n                    opened_new = True\n            if not opened_new:\n                return candy_count\n                    \n        return candy_count", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        active_set = initialBoxes\n        total_candies = 0\n        changed = True\n        while changed:\n            changed = False\n            next_active_set = []\n            for b in active_set:\n                if status[b]:\n                    changed = True\n                    total_candies += candies[b]\n                    for k in keys[b]:\n                        status[k] = 1\n                    next_active_set += containedBoxes[b]\n                else:\n                    next_active_set.append(b)\n            active_set = next_active_set\n        return total_candies\n        \n    \n    def SLOWmaxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # for initial boxes:\n        # - accumulate candies\n        # - for each key, pre-unlock them\n        # - add containedBoxes to queue\n        #\n        # for all contained boxes that's open:\n        # - accumulate candies\n        # - for each key, pre-unlock them\n        # ...\n        #\n        # keep track of a list of opened boxes to explore, and a list of closed boxes to explore\n        # - whenever open a box, pre-unlock their keys\n        #   - if box in list of closed Q, move to open\n        # - whenever find an enclosed box, put to either open or closed\n        # - continue until we have no more open boxes\n        \n        open_boxes = set()\n        closed_boxes = set()\n        # TODO: may need an explored flag for each box\n        for b in initialBoxes:\n            if status[b]:\n                open_boxes.add(b)\n            else:\n                closed_boxes.add(b)\n        \n        total_candies = 0\n        while len(open_boxes) > 0:\n            b = open_boxes.pop()\n            \n            total_candies += candies[b]\n            \n            for key in keys[b]:\n                status[key] = 1\n                if key in closed_boxes:\n                    closed_boxes.remove(key)\n                    open_boxes.add(key)\n            \n            for bb in containedBoxes[b]:\n                if status[bb]:\n                    open_boxes.add(bb)\n                else:\n                    closed_boxes.add(bb)\n        \n        return total_candies", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q, res = collections.deque(initialBoxes), 0\n        while q:\n            l = len(q)\n            for _ in range(l):\n                b, changed = q.popleft(), False\n                if status[b]:\n                    changed = True\n                    res += candies[b]\n                    q.extend(containedBoxes[b])\n                    for i in keys[b]:\n                        status[i] = 1\n                else:\n                    q.append(b)\n            \n            if not changed:\n                return res\n            \n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        d = dict()\n        arr = []\n        key = []\n        for i in range(0,len(status)):\n            arr.append(-1)\n            key.append(-1)\n            d[i] = [status[i],candies[i],keys[i],containedBoxes[i]]\n            if status[i]==1:\n                key[-1]=1\n            \n        c = 0\n        res = []\n        while 1!=-1:\n            tmp = []\n            for x in initialBoxes:\n                if arr[x]==-1 and key[x]==1:\n                    arr[x]=1\n                    c+=d[x][1]\n                    for y in d[x][2]:\n                        key[y]=1\n                    for y in d[x][3]:\n                        if key[y]==1:\n                            tmp.append(y)\n                        else:\n                            res.append(y)\n                elif key[x]==-1:\n                    res.append(x)\n            initialBoxes = []\n            for y in res:\n                if key[y]==1 and arr[y]==-1:\n                    initialBoxes.append(y)\n            initialBoxes+=tmp\n            if initialBoxes==[]:\n                break\n        return c\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        s = [b for b in initialBoxes if status[b]]\n        found_boxes = set([b for b in initialBoxes if not status[b]])\n        r = 0\n        while s:\n            box = s.pop()\n            r += candies[box]\n            for key in keys[box]:\n                status[key] = 1\n            tbr = set()\n            for b in found_boxes:\n                if status[b]:\n                    s.append(b)\n                    tbr.add(b)\n            found_boxes -= tbr\n            for child in containedBoxes[box]:\n                if status[child]:\n                    s.append(child)\n                else:\n                    found_boxes.add(child)\n        return r", "class Box():\n    def __init__(self, status, candies, keys, boxes):\n        self.status = status\n        self.candies = candies\n        self.keys = keys\n        self.containedBoxes = boxes\n\ndef openboxes(unopened, keys, Q):\n    for u in unopened:\n        if u in keys:\n            Q.append(u)\n            unopened.remove(u)\n    \n\nclass Solution:\n            \n    \n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        mykeys = []\n        unopened = []\n        candySum = 0\n        \n        \n        Q = []\n        for i in initialBoxes:\n            mykeys.extend(keys[i])\n            if status[i] == 1:\n                Q.append(i)\n            else:\n                unopened.append(i)\n       \n        openboxes(unopened,mykeys,Q)\n        \n        while Q != []:\n            box = Q.pop(0)\n            candySum += candies[box]\n            \n            \n            for b in containedBoxes[box]:\n                mykeys.extend(keys[b])\n                if status[b] == 1:\n                    Q.append(b)\n                else:\n                    unopened.append(b)\n            \n            openboxes(unopened, mykeys, Q)\n                    \n                    \n        \n        return candySum\n                    \n            \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes = set(initialBoxes)\n        queue = collections.deque()\n        \n        for box in boxes:\n            if status[box] == 1:\n                queue.append(box)\n        \n        ans = 0\n        seen = set()\n        \n        while queue:\n            box = queue.popleft()\n            if box not in seen:\n                seen.add(box)\n                ans += candies[box]\n            for i in containedBoxes[box]:\n                boxes.add(i)\n                if status[i] == 1:\n                    queue.append(i)\n            \n            for j in keys[box]:\n                if status[j] == 0 and j in boxes:\n                    queue.append(j)\n                status[j] = 1\n        \n        return ans", "\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        found = [0] * len(status)\n        hasKeys = status\n        queue = collections.deque()\n        \n        for box in initialBoxes:\n            found[box] = 1\n            if hasKeys[box]:\n                queue.append(box)\n        \n        res = 0\n        while queue:\n            box = queue.popleft()\n            res += candies[box]\n            for t in containedBoxes[box]:\n                found[t] = 1\n                if hasKeys[t]:\n                    queue.append(t)\n            \n            for t in keys[box]:\n                if not hasKeys[t] and found[t]:\n                    queue.append(t)\n                hasKeys[t] = 1\n        \n        return res\n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        totalBox = len(status)\n        gotBoxes = set(initialBoxes)\n        i = 0\n        ans = 0\n        visited = set()\n        while i < len(initialBoxes):\n            boxNow = initialBoxes[i]\n            if (boxNow not in visited):\n                if (status[boxNow] == 1):\n                    visited.add(boxNow)\n                    ans += candies[boxNow]\n                    for newBox in containedBoxes[boxNow]:\n                        if status[newBox] == 1:\n                            initialBoxes.append(newBox)\n                        else:\n                            gotBoxes.add(newBox)\n                    \n                    for keyBox in keys[boxNow]:\n                        status[keyBox] = 1\n                        if keyBox in gotBoxes:\n                            initialBoxes.append(keyBox)\n                            gotBoxes.remove(keyBox)\n                else:\n                    gotBoxes.add(boxNow)\n            i += 1\n        return ans", "class Solution:\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        bfs = [i for i in boxes if status[i]]\n        for i in bfs:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    bfs.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    bfs.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in bfs)", "from collections import deque\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        visited = set(initialBoxes)\n        reachable = set()\n        deq = deque(initialBoxes)\n        candy_cnt = 0\n        while len(deq) > 0:\n            box = deq.popleft()    \n            candy_cnt += candies[box]   \n            for cb in containedBoxes[box]:\n                reachable.add(cb)\n                if cb not in visited and status[cb] == 1:\n                    deq.append(cb)        \n                    visited.add(cb)\n            for key in keys[box]:\n                status[key] = 1    \n                if key not in visited and key in reachable:\n                    deq.append(key)    \n                    visited.add(key)\n        return candy_cnt                     \n                            \n                        \n                      \n        \n        \n        \n                \n        \n                     \n                      \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        found_keys = set()\n        s = [b for b in initialBoxes if status[b]]\n        found_boxes = set([b for b in initialBoxes if not status[b]])\n        r = 0\n        while s:\n            box = s.pop()\n            r += candies[box]\n            for child in containedBoxes[box]:\n                if status[child]:\n                    s.append(child)\n                else:\n                    found_boxes.add(child)\n            for key in keys[box]:\n                found_keys.add(key)\n            opened = found_boxes & found_keys\n            for b in opened:\n                s.append(b)\n            found_boxes -= opened\n            found_keys -= opened\n        return r", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        foundBoxes = set(initialBoxes)\n        openBoxes = [box for box in foundBoxes if status[box]==1]\n        \n        for i in openBoxes:\n            for x in containedBoxes[i]:\n                foundBoxes.add(x)\n                if status[x] == 1:\n                    openBoxes.append(x)\n            \n            for x in keys[i]:\n                if status[x] == 0 and x in foundBoxes:\n                    openBoxes.append(x)\n                status[x] = 1\n                    \n        return sum([candies[i] for i in openBoxes])\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        N = len(status)\n        queue = list()\n        unopened = set()\n        for i in initialBoxes:\n            if status[i] == 1:\n                queue.append(i)\n            else:\n                unopened.add(i)\n                \n        candiesCount  = 0\n        \n        while len(queue) > 0:\n            top = queue.pop(0)\n            candiesCount += candies[top]\n            \n            for k in keys[top]:\n                status[k] = 1\n                if {k}.issubset(unopened):\n                    queue.append(k)\n                    unopened.remove(k)\n            for c in containedBoxes[top]:\n                if status[c] == 1:\n                    queue.append(c)\n                else:\n                    unopened.add(c)\n        return candiesCount", "from collections import deque\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q = deque(initialBoxes)\n        ownedkeys = set()\n        allkz = set()\n        for k in keys:\n            for l in k:\n                allkz.add(l)\n        # for i, b in enumerate(status):\n            # if not b and b not in allkz:\n                # unreachable.add(b)\n            \n        opened = set()\n        for i, b in enumerate(status):\n            if not b and i not in allkz:\n                opened.add(i)\n        \n        res = 0\n        while q:\n            curBox = q.popleft()\n            if curBox not in opened:\n                if status[curBox] or curBox in ownedkeys:\n                    opened.add(curBox)\n                    for k in keys[curBox]:\n                        ownedkeys.add(k)\n                    res += candies[curBox]\n                    q += containedBoxes[curBox]\n                else:\n                    q.append(curBox)\n        return res           \n                \n                \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        n = len(status)\n        visited = [0] * n\n        unopened = [0] * n\n        opened = []\n        \n        ans = 0\n        for b in initialBoxes:\n            if status[b] == 1:\n                opened.append(b)\n                visited[b] = 1\n            else:\n                unopened[b] = 1\n        while opened:\n            q2 = []\n            for b in opened:\n                ans += candies[b]\n                for bb in containedBoxes[b]:\n                    if visited[bb] == 0:\n                        if status[bb] == 1:\n                            q2.append(bb)\n                        else:\n                            unopened[bb] = 1\n                for k in keys[b]:\n                    status[k] = 1\n                    if unopened[k] == 1 and visited[k] == 0:\n                        unopened[k] = 0\n                        visited[k] = 1\n                        q2.append(k)\n            opened = q2\n        return ans\n    \n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        n = len(status)\n        visited = [0] * n\n        unopened = [0] * n\n        opened = collections.deque()\n        \n        ans = 0\n        for b in initialBoxes:\n            if status[b] == 1:\n                opened.append(b)\n                visited[b] = 1\n            else:\n                unopened[b] = 1\n        while opened:\n            b = opened.popleft()\n            ans += candies[b]\n            for bb in containedBoxes[b]:\n                if visited[bb] == 0:\n                    if status[bb] == 1:\n                        opened.append(bb)\n                    else:\n                        unopened[bb] = 1\n            for k in keys[b]:\n                status[k] = 1\n                if unopened[k] == 1 and visited[k] == 0:\n                    unopened[k] = 0\n                    visited[k] = 1\n                    opened.append(k)\n        return ans\n            \n", "from collections import deque\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        size = len(status)\n        visited = set(initialBoxes)\n        reachable = set()\n        deq = deque(initialBoxes)\n        candy_cnt = 0\n        while len(deq) > 0:\n            box = deq.popleft()    \n            candy_cnt += candies[box]   \n            for cb in containedBoxes[box]:\n                reachable.add(cb)\n                if cb not in visited and status[cb] == 1:\n                    deq.append(cb)        \n                    visited.add(cb)\n            for key in keys[box]:\n                status[key] = 1    \n                if key not in visited and key in reachable:\n                    deq.append(key)    \n                    visited.add(key)\n        return candy_cnt                     \n                            \n                        \n                      \n        \n        \n        \n                \n        \n                     \n                      \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        n = len(status)\n        boxes = []\n        unboxes = set()\n        for b in initialBoxes:\n            if status[b]:\n                boxes.append(b)\n            else:\n                unboxes.add(b)\n        visited = set()\n        got = 0\n\n        while boxes:\n            ns = set()\n            for box in boxes:\n                if box not in visited:\n                    got += candies[box]\n                    visited.add(box)\n\n                for key in keys[box]:\n                    status[key] |= 1\n            \n            for box in boxes:\n                for adj in containedBoxes[box]:\n                    unboxes.add(adj)\n            \n            newBoxes = set()\n            # print(ns, unboxes)\n            for box in unboxes:\n                if status[box] and box not in visited:\n                    ns.add(box)\n                    newBoxes.add(box)\n            for box in newBoxes:\n                unboxes.remove(box)\n            # print(ns, unboxes)\n            boxes = list(ns)\n        return got", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        \n        n = len(status)\n        hold = initialBoxes\n        res = 0\n        key = set()\n        flag = True\n        while flag:\n            nxt = []\n            flag = False\n            for i in range(len(hold)):\n                cur = hold.pop()\n                if status[cur] == 1 or status[cur] == 0 and cur in key:\n                    flag = True\n                    res += candies[cur]\n                    for k in keys[cur]:\n                        key.add( k )\n                    for b in containedBoxes[cur]:\n                        nxt.append(b)\n                else:\n                    nxt.append(cur)\n            hold = nxt\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        totalBox = len(status)\n        gotBoxes = set(initialBoxes)\n        # gotKeys = set()\n        i = 0\n        ans = 0\n        visited = set()\n        while i < len(initialBoxes):\n            boxNow = initialBoxes[i]\n            if (boxNow not in visited):\n                if (status[boxNow] == 1):\n                    visited.add(boxNow)\n                    ans += candies[boxNow]\n                    # gotKeys |= set(keys[boxNow])\n                    # gotBoxes |= set(containedBoxes[boxNow])\n                    for newBox in containedBoxes[boxNow]:\n                        if status[newBox] == 1:\n                            initialBoxes.append(newBox)\n                        else:\n                            gotBoxes.add(newBox)\n                    \n                    for keyBox in keys[boxNow]:\n                        status[keyBox] = 1\n                        if keyBox in gotBoxes:\n                            initialBoxes.append(keyBox)\n                            gotBoxes.remove(keyBox)\n                else:\n                    gotBoxes.add(boxNow)\n            i += 1\n        return ans", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes = set(initialBoxes)\n        bfs = [i for i in boxes if status[i]]\n        for i in bfs:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    bfs.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    bfs.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in bfs)", "class Solution:\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        bfs = [i for i in boxes if status[i]]\n        for i in bfs:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    bfs.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    bfs.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in bfs)\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        total_candies = 0\n        open_boxes = [box for box in initialBoxes if status[box] == 1]        \n        locked_boxes = [box for box in initialBoxes if status[box] == 0]\n        obtained_keys = set([])\n\n        while len(open_boxes):\n            box = open_boxes.pop()\n            total_candies += candies[box]\n            for key in keys[box]:\n                if key in locked_boxes:\n                    locked_boxes.remove(key)\n                    open_boxes.append(key)\n                else:\n                    obtained_keys.add(key)\n            for cbox in containedBoxes[box]:\n                if status[cbox] == 1 or cbox in obtained_keys:\n                    open_boxes.append(cbox)\n                else:\n                    locked_boxes.append(cbox)\n        return total_candies", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        currkeys, ret, taken = set(), 0, [0] * len(status)\n        q = collections.deque(initialBoxes)\n        while q:\n            l = len(q)\n            opened = False\n            for _ in range(l):\n                curr = q.popleft()\n                taken[curr] = 1\n                if curr not in currkeys and status[curr] == 0:\n                    q.append(curr)\n                else:\n                    opened = True\n                    ret += candies[curr]\n                    if keys[curr]: currkeys |= set([key for key in keys[curr]])\n                    for b in containedBoxes[curr]:\n                        if not taken[b]: q.append(b)\n            if not opened: break\n        return ret\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        if not initialBoxes:\n            return 0\n        unused_keys = set()\n        boxes = set([i for i in initialBoxes if status[i] == 0])\n        \n        Q = collections.deque([i for i in initialBoxes if status[i] == 1])\n        res = 0\n        while Q:\n            cur = Q.popleft()\n            res += candies[cur]\n            for k in keys[cur]:\n                if k in boxes:\n                    Q.append(k)\n                    boxes.discard(k)\n                else:\n                    unused_keys.add(k)\n            for b in containedBoxes[cur]:\n                if b in unused_keys or status[b] == 1:\n                    Q.append(b)\n                    unused_keys.discard(b)\n                else:\n                    boxes.add(b)\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        N = len(status)\n        scores = [0] * N\n        for i in range(N):\n            scores[i] += status[i]\n        \n        level = []\n        for b in initialBoxes:\n            scores[b] += N + 1\n            if scores[b] >= N + 2:\n                level.append(b)\n                scores[b] = -sys.maxsize\n        \n        res = 0\n        while level:\n            n_level = []\n            for b in level:\n                res += candies[b]\n                for k in containedBoxes[b]:\n                    scores[k] += N + 1\n                    if scores[k] >= N + 2:\n                        n_level.append(k)\n                        scores[k] = -sys.maxsize\n                for k in keys[b]:\n                    scores[k] += 1\n                    if scores[k] >= N + 2:\n                        n_level.append(k)\n                        scores[k] = -sys.maxsize\n            level = n_level\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        if not initialBoxes : return 0\n        visited = set()\n        boxes=set()\n        keys_found=set()\n        n_candies=0\n        opn=[]\n        # for i in range(len(initialBoxes)):\n        for i in initialBoxes:\n            if status[i]!=1:\n                boxes.add(i)\n            else:\n                opn.append(i)\n        \n        initialBoxes=opn\n        while initialBoxes :\n            i=initialBoxes.pop(0)\n            n_candies+=candies[i]\n            visited.add(i)\n            if keys[i] != []:\n                for j in keys[i]:\n                    keys_found.add(j)                            \n            if containedBoxes[i] != []:\n                for c in containedBoxes[i]:\n                    \n                    if status[c] == 1:\n                        initialBoxes.append(c)\n                    else:\n                        boxes.add(c)\n            for k in boxes:\n                if k in visited:\n                    continue\n                if k in keys_found:\n                    initialBoxes.append(k)\n                    visited.add(k)\n        # print(visited)\n        \n        return n_candies        \n                \n                \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        if not initialBoxes : return 0\n        visited = set()\n        boxes=set()\n        keys_found=set()\n        n_candies=0\n        opn=[]\n        # for i in range(len(initialBoxes)):\n        for i in initialBoxes:\n            if status[i]!=1:\n                boxes.add(i)\n            else:\n                opn.append(i)\n        \n        initialBoxes=opn\n        while initialBoxes :\n            i=initialBoxes.pop(0)\n            n_candies+=candies[i]\n            visited.add(i)\n            for j in keys[i]:\n                keys_found.add(j)    \n            for c in containedBoxes[i]:\n\n                if status[c] == 1:\n                    initialBoxes.append(c)\n                else:\n                    boxes.add(c)\n            for k in boxes:\n                if k in visited:\n                    continue\n                if k in keys_found:\n                    initialBoxes.append(k)\n                    visited.add(k)\n        # print(visited)\n        \n        return n_candies        \n                \n                \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # box & key & open\n        ret = 0\n        # status 0:close, 1:open, 2:opened\n        # step 1: open boxes, if nothing can be opened, stop\n        # step 2: update candies, new boxes, keys(open status)\n        # repeat step 1\n        n = len(status)\n                \n        available_to_open = [box for box in initialBoxes if status[box]]\n        reachable_boxes = set([box for box in initialBoxes if not status[box]])\n        \n        while len(available_to_open) > 0:\n            box = available_to_open.pop()\n            if status[box] == 2:\n                continue\n                \n            ret += candies[box]\n            status[box] = 2\n            \n            for containedBox in containedBoxes[box]:\n                reachable_boxes.add(containedBox)\n            \n            for key in keys[box]:\n                if status[key] == 0:\n                    status[key] = 1\n                \n            for containedBox in containedBoxes[box]:\n                if status[containedBox] == 1:\n                    available_to_open.append(containedBox)\n            \n            for key in keys[box]:\n                if key in reachable_boxes:\n                    available_to_open.append(key)\n                    \n        return ret\n                \n            \n\n            \n        \n        \n        \n        \n        \n        return ret", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        open_box = []   # \u6709key\u6709box\n        close_box = set()   # \u6709box\u6ca1key\n        key_set = set([i for i in range(len(status)) if status[i]==1]) # \u6709key\u6ca1box\n        visited = [False for _ in range(len(status))] \n        count = 0\n        for box in initialBoxes:\n            if status[box]==1:\n                open_box.append(box)\n            else:\n                close_box.add(box)        \n        while open_box:\n            box = open_box.pop()\n            visited[box] = True\n            count += candies[box]\n            for key in keys[box]:\n                    key_set.add(key)\n            for c_box in containedBoxes[box]:\n                if visited[c_box]:\n                    continue\n                else:\n                    close_box.add(c_box)\n            for key in key_set:\n                if key in close_box:\n                    open_box.append(key)\n                    close_box.remove(key)\n        return count\n            \n                    \n                \n            \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        \n        #Approach 1:  use set \n        #The queue only contains boxes which is accessible\n        q=collections.deque()\n        \n        #Important initiation,consider all opens box equivalent to they have keys\n        keys_set=set([i for i in range(len(status)) if status[i]==1])   #Set for all available keys\n        boxes_set=set(initialBoxes[:])  #set for all boxes that we have seen\n        \n        #Initialize the queue to process box\n        for box in initialBoxes:\n            if(box in keys_set):  #Status[box]==1 is equivalent to it has a key\n                q.append(box)\n\n        res=0\n        visited=set()   #More universal for all test cases, record all the boxes that have been processed\n        #use DFS to populate the queue\n        while q:\n            \n            boxi=q.popleft()\n            #Avoid duplicated count\n            if(boxi in visited):\n                continue\n            else:\n                visited.add(boxi)\n                res +=candies[boxi]\n                \n            #Check all neighbors of current boxi\n            for nei in containedBoxes[boxi]:\n                if(nei in keys_set):  #it is either open or has key\n                    q.append(nei)\n                boxes_set.add(nei)\n                \n            #Check all keys of current boxi\n            for key in keys[boxi]:\n                #Only append the box index wich has not been considered, because there is no key, but it is in the boxes_set\n                if(key in boxes_set and (key not in keys_set)):\n                    q.append(key) \n                keys_set.add(key)\n                \n        return res\n    \n    \n        #Approach 2: use list\n        \n#         haskeys=status[:]\n#         seen=[0]*len(status)\n#         q=collections.deque()   #Only contains boxes that are accessible\n        \n#         for box in initialBoxes:\n#             seen[box]=1\n#             if(haskeys[box]):\n#                 q.append(box)   #Include the one only accessible\n                \n#         res=0\n#         visited=set()\n#         while q:\n            \n#             boxi=q.popleft()\n#             if(boxi in visited):\n#                 continue\n#             else:\n#                 visited.add(boxi)\n#                 res+=candies[boxi]\n            \n#             #Since eachbox is contained in one box at most\n#             #it will not result in duplicated elements in q\n#             for nei in containedBoxes[boxi]:\n#                 seen[nei]=1\n#                 if(haskeys[nei]): q.append(nei)\n            \n#             #Iterate through all available keys, \n#             #inlcude the box has been seen but doesn't have key to the queue\n#             for key in keys[boxi]:\n#                 if(seen[key] and haskeys[key]==0):  #Meaning it has not been included in queue\n#                     q.append(key)\n#                 haskeys[key]=1\n        \n#         return res\n                    \n                \n            \n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n            \n            \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # open_box: \u6709key\u6709box\n        # close_box: \u6709box\u6ca1key\n        # key_set: \u6709key\u6ca1box\n        # visited\n        open_box = []\n        close_box = set()\n        key_set = set([i for i in range(len(status)) if status[i]==1])\n        visited = [False for _ in range(len(status))]\n        count = 0\n        for box in initialBoxes:\n            if status[box]==1:\n                open_box.append(box)\n            else:\n                close_box.add(box)        \n        while open_box:\n            box = open_box.pop()\n            visited[box] = True\n            count += candies[box]\n            for key in keys[box]:\n                if visited[key]:\n                    continue\n                if key in close_box:\n                    open_box.append(key)\n                    close_box.remove(key)\n                else:\n                    key_set.add(key)\n            for c_box in containedBoxes[box]:\n                if visited[c_box]:\n                    continue\n                elif c_box in key_set:\n                    open_box.append(c_box)\n                else:\n                    close_box.add(c_box)\n            for key in key_set:\n                if key in close_box:\n                    open_box.append(key)\n                    close_box.remove(key)\n        return count\n            \n                    \n                \n            \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        locked_boxes = set()\n        unused_keys = set()\n        candy_count = 0\n        cur_box = []\n        \n        for box in initialBoxes:\n            if status[box] or box in unused_keys:\n                candy_count += candies[box]\n                for i in keys[box]:\n                    if not status[i]:\n                        if i not in locked_boxes:\n                            unused_keys.add(i)\n                        else:\n                            locked_boxes.remove(i)\n                            cur_box.append(i)\n                for i in containedBoxes[box]:\n                    if not status[i] and i not in unused_keys:\n                        locked_boxes.add(i)\n                    else:\n                        cur_box.append(i)\n\n            else:\n                locked_boxes.add(box)\n                \n        while cur_box:\n            box = cur_box.pop()\n            candy_count += candies[box]\n            for i in keys[box]:\n                if not status[i]:\n                    if i not in locked_boxes:\n                        unused_keys.add(i)\n                    else:\n                        locked_boxes.remove(i)\n                        cur_box.append(i)\n            for i in containedBoxes[box]:\n                if not status[i] and i not in unused_keys:\n                    locked_boxes.add(i)\n                else:\n                    cur_box.append(i)\n                    if i in unused_keys:\n                        unused_keys.remove(i)\n            if box in unused_keys:\n                unused_keys.remove(box)\n\n        return candy_count", "class Solution:\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        n = len(status)\n        access = [0] * n\n        source = []\n        visited = set()\n        \n        # (access, status, key, i)\n        for i in initialBoxes:\n            access[i] = 1\n            visited.add(i)\n            source.append(i)\n            \n        ans = 0\n        while source:\n            i = source.pop()\n            ans += candies[i]\n            for j in containedBoxes[i]:\n                access[j] = 1\n            for j in keys[i]:\n                status[j] = 1\n            for j in containedBoxes[i]:\n                if j not in visited and status[j]:\n                    visited.add(j)\n                    source.append(j)\n            for j in keys[i]:\n                if j not in visited and access[j]:\n                    visited.add(j)\n                    source.append(j)\n            \n        return ans", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        self.keys_found = set()\n        self.boxes_found = set()\n        self.boxes_found.update(initialBoxes)\n        n = len(status)\n        visited = [0] * n\n        for box in initialBoxes:\n            self.dfs(box, keys, containedBoxes, visited)\n        \n        ans = 0\n        for i in range(n):\n            if i in self.boxes_found and (i in self.keys_found or status[i] == 1):\n                ans += candies[i]\n        return ans\n\n    def dfs(self, cur, keys, containedBoxes, visited):\n        if visited[cur] == 1:\n            return\n        \n        visited[cur] = 1\n        boxes = containedBoxes[cur]\n        self.keys_found.update(keys[cur])\n        self.boxes_found.update(boxes)\n        \n        for box in boxes:\n            self.dfs(box, keys, containedBoxes, visited)\n", "from collections import deque\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        l = len(status)\n        found = [False] * l\n        \n        \n            \n        run_q = deque([])\n        wait_q = deque([])\n        tmp_q = deque([])\n        for box in initialBoxes:\n            if status[box] == 1:\n                run_q.append(box)\n            else:\n                wait_q.append(box)\n        res = 0\n        while run_q:\n            box = run_q.popleft()\n            \n            res += candies[box]\n            for key in keys[box]:\n                status[key] = 1\n            for found_box in containedBoxes[box]:\n                wait_q.append(found_box)\n                \n            while wait_q:\n                sleeping_box = wait_q.popleft()\n                if status[sleeping_box] == 1:\n                    run_q.append(sleeping_box)\n                else:\n                    tmp_q.append(sleeping_box)\n            while tmp_q:\n                wait_q.append(tmp_q.popleft())\n        return res            \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes = set(initialBoxes)\n    \n        bfs = [x for x in initialBoxes if status[x]]\n        \n        for i in bfs:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    bfs.append(j)\n                                    \n            for k in keys[i]:\n                if status[k] == 0 and k in boxes:\n                    bfs.append(k)\n                status[k] = 1\n                    \n        return sum([candies[i] for i in boxes if status[i]]) ", "import queue\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        ans = 0\n        q = queue.Queue()\n        notopen = set()\n        op = set()\n        for x in initialBoxes:\n            q.put(x)\n        \n        while not q.empty():\n            # print(q.queue)\n            cur = q.get()\n            if status[cur] == 1:\n                ans += candies[cur]\n                for k in keys[cur]:\n                    status[k] = 1\n                    if k in notopen and k not in op:\n                        q.put(k)\n                        op.add(k)\n                for c in containedBoxes[cur]:\n                    q.put(c)\n            else:\n                notopen.add(cur)\n        \n        return ans\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        key_set = set()\n        box_set = set()\n        used = set()\n        queue = collections.deque(initialBoxes)\n        ans = 0\n        while queue:\n            box = queue.popleft()\n            if box in used:\n                continue\n            if status[box] == 1 or box in key_set:\n                used.add(box)\n                if box in key_set:\n                    key_set.remove(box)\n                if box in box_set:\n                    box_set.remove(box)\n                ans += candies[box]\n                for futureBox in containedBoxes[box]:\n                    box_set.add(futureBox)\n                for futureKey in keys[box]:\n                    key_set.add(futureKey)\n                \n                for futureBox in box_set:\n                    if futureBox in key_set or status[futureBox] == 1:\n                        queue.append(futureBox)\n                # for newBox in toBeOpenBox:\n                #     queue.append(newBox)\n                #     if newBox in key_set:\n                #         key_set.remove(newBox)\n                #     if newBox in box_set:\n                #         box_set.remove(newBox)\n            else:\n                box_set.add(box)\n        \n        return ans", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        n = len(status)\n        \n        self.count = 0\n        \n        queue = collections.deque([i for i in initialBoxes if status[i]==1])\n        boxSet = set(initialBoxes)\n        keySet = set(i for i in range(n) if status[i] == 1)\n        opened = set()\n        \n        while (queue):\n            l = len(queue)\n            for i in range(l):\n                cur = queue.popleft()\n                self.count += candies[cur]\n                opened.add(cur)\n                for key in keys[cur]:\n                    keySet.add(key)\n                    if key not in opened and key in boxSet and key not in queue:\n                        queue.append(key)\n                for box in containedBoxes[cur]:\n                    boxSet.add(box)\n                    if box not in opened and box in keySet and box not in queue:\n                        queue.append(box)\n        \n        return self.count\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        def dfs(i):\n            if i in visited:\n                return\n            if status[i] == 0:\n                missedKey.add(i)\n                return\n            visited.add(i)\n            self.ans += candies[i]\n            \n            for k in keys[i]:\n                status[k] = 1\n                if k in missedKey:\n                    missedKey.discard(k)\n                    dfs(k)\n            for j in containedBoxes[i]:\n                dfs(j)\n            \n            \n        visited = set()\n        missedKey = set()\n        self.ans = 0\n        for i in initialBoxes:\n            dfs(i)\n            \n        return self.ans\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        def dfs(i):\n            if i in visited: return\n            elif status[i] == 0:\n                missedKeys.add(i)\n                return\n            visited.add(i)\n            self.ans += candies[i]\n            for k in keys[i]:\n                status[k] = 1\n                if k in missedKeys:\n                    missedKeys.discard(k)\n                    dfs(k)\n            for j in containedBoxes[i]:\n                dfs(j)\n        \n        self.ans = 0\n        visited= set()\n        missedKeys = set()\n        for i in initialBoxes:\n            dfs(i)\n            \n        return self.ans", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        #The queue only contains boxes which is accessible\n        q=collections.deque()\n        keys_set=set()   #Set for all available keys\n        boxes_set=set()  #set for all un-opened boxes\n        \n        #Initialize the queue to process box\n        for box in initialBoxes:\n            if(status[box]==1 or box in keys_set):  #Check if this box is open or there is key available\n                q.append(box)\n                for key in keys[box]:\n                    keys_set.add(key)\n                    if(key in boxes_set):           #Check if the new key can open a box in boxes_set\n                        q.append(key)\n                        boxes_set.remove(key)\n            else:\n                boxes_set.add(box)\n                \n\n        res=0\n        visited=set()\n        \n        #use DFS to populate the queue\n        while q:\n            \n            boxi=q.popleft()\n            #Avoid duplicated couting of candies\n            if(boxi in visited):\n                continue\n            else:\n                visited.add(boxi)\n                res +=candies[boxi]\n                \n            #Check all neighbors of current boxi\n            for nei in containedBoxes[boxi]:\n                if(status[nei]==1 or nei in keys_set):   #Check if this box is open or there is a key for this box\n                    q.append(nei)\n                    for key in keys[nei]:\n                        keys_set.add(key)\n                        if(key in boxes_set):             #check if the new key can open a box in boxes_set\n                            q.append(key)\n                            boxes_set.remove(key)\n                else:\n                    boxes_set.add(nei)\n        \n        return res\n                \n            \n            \n            \n", "from collections import deque\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q = deque(initialBoxes)\n        ownedkeys = set()\n        allkz = set()\n        for k in keys:\n            for l in k:\n                allkz.add(l)\n        # for i, b in enumerate(status):\n            # if not b and b not in allkz:\n                # unreachable.add(b)\n            \n        opened = set(i for i, b in enumerate(status) if not b and i not in allkz) # treat unreachable as already opened\n        res = 0\n        while q:\n            curBox = q.popleft()\n            if curBox not in opened:\n                if status[curBox] or curBox in ownedkeys:\n                    opened.add(curBox)\n                    for k in keys[curBox]:\n                        ownedkeys.add(k)\n                    res += candies[curBox]\n                    q += containedBoxes[curBox]\n                else:\n                    q.append(curBox)\n        return res           \n                \n                \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        locked_boxes = set()\n        unused_keys = set()\n        candy_count = 0\n        cur_box = []\n        \n        for box in initialBoxes:\n            if status[box] or box in unused_keys:\n                candy_count += candies[box]\n                for i in keys[box]:\n                    if not status[i]:\n                        if i not in locked_boxes:\n                            unused_keys.add(i)\n                        else:\n                            locked_boxes.remove(i)\n                            cur_box.append(i)\n                for i in containedBoxes[box]:\n                    if not status[i] and i not in unused_keys:\n                        locked_boxes.add(i)\n                    else:\n                        cur_box.append(i)\n                        if i in unused_keys:\n                            unused_keys.remove(i)\n                if box in unused_keys:\n                    unused_keys.remove(box)\n            else:\n                locked_boxes.add(box)\n                \n        while cur_box:\n            box = cur_box.pop()\n            candy_count += candies[box]\n            for i in keys[box]:\n                if not status[i]:\n                    if i not in locked_boxes:\n                        unused_keys.add(i)\n                    else:\n                        cur_box.append(i)\n            for i in containedBoxes[box]:\n                if not status[i] and i not in unused_keys:\n                    locked_boxes.add(i)\n                else:\n                    cur_box.append(i)\n                    if i in unused_keys:\n                        unused_keys.remove(i)\n            if box in unused_keys:\n                unused_keys.remove(box)\n\n        return candy_count", "from collections import deque\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # Step 1: Traverse through intialBoxes using it sort of as our stack\n            # With each box, add candies to result, open every box we have a key for, add every contained box onto stack\n            # use array to keep track of seen boxes\n            \n        # what to do about keys? could have box that isn't opened but will be opened later on\n        # possible soln: skip that box, come back to it later on, if we reach a point where every box on stack can't be opened we end\n        \n        n = len(status)\n        seen, queue, result = [False] * n, deque(initialBoxes), 0\n        num_locked = 0\n        \n        for box in initialBoxes:\n            seen[box] = True\n        \n        while queue:\n            box = queue.popleft()\n            \n            # Check if we can process box yet.\n            if not status[box]:\n                queue.append(box)\n                num_locked += 1\n                if num_locked == len(queue):\n                    break\n                continue\n            \n            num_locked = 0\n            result += candies[box]\n            \n            # Open every box we have a key for.\n            for k in keys[box]:\n                status[k] = 1\n            \n            # Add all contained boxes to queue.\n            for cb in containedBoxes[box]:\n                if not seen[cb]:\n                    queue.append(cb)\n                    seen[cb] = True\n        \n        return result\n            \n        \n        \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        if not initialBoxes: return 0\n        if 1 not in status: return 0\n        boxes = []\n        result = 0\n        while True:\n            flag = False\n            for b in initialBoxes:\n                if status[b] == 1:\n                    flag = True\n                    result += candies[b]\n                    boxes += containedBoxes[b]\n                    for j in keys[b]: status[j] = 1\n                    initialBoxes.remove(b)\n            initialBoxes += boxes\n            boxes = []\n            if not flag: break\n        return result\n", "class Solution:\n    # O(n^2) time, O(n) space\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        OPEN, CLOSED = 1, 0\n        q = deque(initialBoxes)\n        keys_obtained = set(i for i in range(len(status)) if status[i] == OPEN)\n        count = 0\n        \n        while set(q) & keys_obtained:\n            q2 = deque()\n            while q:\n                box = q.popleft()\n                if box in keys_obtained:\n                    count += candies[box]\n                    keys_obtained |= set(keys[box])\n                    q.extend(containedBoxes[box])\n                else:\n                    q2.append(box)\n            q = q2\n            \n        return count", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:        \n        reached = set()\n        \n        visited = set()\n        q = initialBoxes\n        \n        yummy = 0\n        \n        while q:\n            new_q = []\n            \n            for box in q:\n                reached.add(box)\n                \n                if status[box] and box not in visited:\n                    visited.add(box)\n                    new_q.extend(containedBoxes[box])\n                    new_q.extend(unlockedBox for unlockedBox in keys[box] if unlockedBox in reached)\n                    \n                    yummy += candies[box]\n                    \n                    for unlockedBox in keys[box]:\n                        status[unlockedBox] = 1\n                    \n            q = new_q\n        \n        return yummy\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        locked_boxes = set()\n        unused_keys = set()\n        candy_count = 0\n        cur_box = []\n        \n        for box in initialBoxes:\n            if status[box] or box in unused_keys:\n                candy_count += candies[box]\n                for i in keys[box]:\n                    if not status[i]:\n                        if i not in locked_boxes:\n                            unused_keys.add(i)\n                        else:\n                            locked_boxes.remove(i)\n                            cur_box.append(i)\n                for i in containedBoxes[box]:\n                    if not status[i] and i not in unused_keys:\n                        locked_boxes.add(i)\n                    else:\n                        cur_box.append(i)\n                        if i in unused_keys:\n                            unused_keys.remove(i)\n                if box in unused_keys:\n                    unused_keys.remove(box)\n            else:\n                locked_boxes.add(box)\n                \n        while cur_box:\n            box = cur_box.pop()\n            candy_count += candies[box]\n            for i in keys[box]:\n                if not status[i]:\n                    if i not in locked_boxes:\n                        unused_keys.add(i)\n                    else:\n                        locked_boxes.remove(i)\n                        cur_box.append(i)\n            for i in containedBoxes[box]:\n                if not status[i] and i not in unused_keys:\n                    locked_boxes.add(i)\n                else:\n                    cur_box.append(i)\n                    if i in unused_keys:\n                        unused_keys.remove(i)\n            if box in unused_keys:\n                unused_keys.remove(box)\n\n        return candy_count", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q = collections.deque()\n        for box in initialBoxes:\n            q.append(box)\n        \n        keys_found = set()\n        \n        ans = 0\n        found = True\n        while q and found:\n            size = len(q)\n            \n            found = False\n            for _ in range(size):\n                cur = q.popleft()\n                if status[cur] == 0 and cur not in keys_found:\n                    q.append(cur)\n                else:\n                    found = True\n                    ans += candies[cur]\n                    for box in containedBoxes[cur]:\n                        q.append(box)\n                    \n                    for key in keys[cur]:\n                        keys_found.add(key)\n        return ans", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        OPEN, CLOSED = 1, 0\n        q = deque(initialBoxes)\n        keys_obtained = set(i for i in range(len(status)) if status[i] == OPEN)\n        count = 0\n        \n        while set(q) & keys_obtained:\n            q2 = deque()\n            while q:\n                box = q.popleft()\n                if box in keys_obtained:\n                    count += candies[box]\n                    keys_obtained |= set(keys[box])\n                    q.extend(containedBoxes[box])\n                else:\n                    q2.append(box)\n            q = q2\n            \n        return count", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        queue = []\n        visited = set()\n        closedBoxes = set()\n        foundedKeys = set()\n        for box in initialBoxes:\n            if status[box] == 1:\n                queue.append(box)\n            else:\n                closedBoxes.add(box)\n        \n        res = 0\n        while queue:\n            cur = queue.pop(0)\n            res += candies[cur]\n            for box in containedBoxes[cur]:\n                if status[box] == 1:\n                    queue.append(box)\n                elif (status[box] == 0 and box in foundedKeys):\n                    queue.append(box)\n                    foundedKeys.remove(box)\n                else:\n                    closedBoxes.add(box)\n            for key in keys[cur]:\n                if key in closedBoxes:\n                    queue.append(key)\n                    closedBoxes.remove(key)\n                else:\n                    foundedKeys.add(key)\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes = set(initialBoxes)\n        openedBox = set()\n        bfs = [i for i in boxes if status[i]]\n        \n#BFS every open box\n        while bfs:\n            size = len(bfs)\n            \n            for _ in range(size):\n                box = bfs.pop(0)\n                openedBox.add(box)\n#                 Get all boxs in given box, push to queue if it's open\n                for eachContainedBox in containedBoxes[box]:\n                    if status[eachContainedBox]:\n                        bfs.append(eachContainedBox)\n                    boxes.add(eachContainedBox)\n#                 check all the keys in given box, push box to queue if there is key to the box\n                for eachKey in keys[box]:\n                    if status[eachKey] == 0 and eachKey in boxes:\n                        bfs.append(eachKey)\n                    \n#                 it's necessary to update status, because above you need use status[eachKey] == 0 to filter out the box that you have alreay taken candies\n                    status[eachKey] = 1\n                        \n        return sum(candies[box] for box in openedBox)", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # def maxCandies(status,candies,keys,containedBoxes,initialBoxes):\n#     def dfs(i,status,candies,keys,containedBoxes):\n        q=[]\n        res=0\n        vis=set()\n        collected=set()\n        for i in initialBoxes:\n            q.append(i)\n        while q:\n            cur=q.pop(0)\n            vis.add(cur)\n            if status[cur]!=1 or cur in collected:\n                continue\n            res+=candies[cur]\n            collected.add(cur)\n            for i in keys[cur]:\n                status[i]=1\n                if i in vis:\n                    q.append(i)\n            for j in containedBoxes[cur]:\n                q.append(j)\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        res, bcache, kcache = 0, set(initialBoxes), set()\n        for _ in range(1000):\n            tmp = set()\n            for b in bcache:\n                if status[b] == 1 or b in kcache:\n                    tmp |= set(containedBoxes[b])\n                    kcache |= set(keys[b])\n                    res += candies[b]\n                else:\n                    tmp.add(b)\n            bcache = tmp\n        # print(f'{bcache} {kcache}')\n        return res\n                    \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        done = set()\n        to_open = set()\n        current_keys = set()\n        opened = list()\n        for box in initialBoxes:\n            if status[box] == 1:\n                opened.append(box)\n            else:\n                to_open.add(box)\n        total = 0\n        while opened:\n            box = opened.pop()\n            if box in done:\n                continue\n            total += candies[box]\n            done.add(box)\n            for openable in keys[box]:\n                if openable in to_open:\n                    opened.append(openable)\n                    to_open.remove(openable)\n                else:\n                    current_keys.add(openable)\n            for contained in containedBoxes[box]:\n                if status[contained] == 1:\n                    opened.append(contained)\n                elif contained in current_keys:\n                    opened.append(contained)\n                    current_keys.remove(contained)\n                else:\n                    to_open.add(contained)\n        return total", "class Solution:\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        ret=0\n        collected_keys=set()\n        opened=set()\n        queue=initialBoxes\n        while queue:\n            cont=False\n            for i in range(len(queue)):\n                box_index=queue.pop(0)\n                if status[box_index] or box_index in collected_keys:\n                    if box_index not in opened:\n                        cont=True\n                        opened.add(box_index)\n                        ret+=candies[box_index]\n                        queue+=containedBoxes[box_index]\n                        collected_keys.update(keys[box_index])\n                else:\n                    queue.append(box_index)\n            if not cont: break\n        return ret", "from collections import deque\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q = deque(initialBoxes)\n        ownedkeys = set()\n        allkz = set()\n        for k in keys:\n            for l in k:\n                allkz.add(l)\n        # for i, b in enumerate(status):\n            # if not b and b not in allkz:\n                # unreachable.add(b)\n            \n        opened = set()\n        for i, b in enumerate(status):\n            if not b and i not in allkz:\n                opened.add(i)\n        \n        res = 0\n        while q:\n            curBox = q.popleft()\n            if curBox not in opened:\n                if status[curBox] or curBox in ownedkeys:\n                    opened.add(curBox)\n                    for k in keys[curBox]:\n                        ownedkeys.add(k)\n                    res += candies[curBox]\n                    for z in containedBoxes[curBox]:\n                        q.append(z)\n                else:\n                    q.append(curBox)\n        return res           \n                \n                \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        if len(initialBoxes) == 0:\n            return 0\n        else:\n            boxdict = {}\n            candysum = 0\n            \n            for initialbox in initialBoxes:\n                boxdict[initialbox] = [0,0]\n            \n            p = len(status)**2\n            while p > 0:\n                for i in range(len(containedBoxes)):\n                    if i in boxdict:\n                        for containedbox in containedBoxes[i]:\n                            boxdict[containedbox] = [0,0]\n                        p -= 1\n            \n            for j in range(len(keys)):\n                for boxedkeys in keys[j]:\n                    if boxedkeys in boxdict:\n                        boxdict[boxedkeys][1] = 1\n                        \n            for l in range(len(status)):\n                if status[l] == 1 and l in boxdict:\n                    boxdict[l][0] = 1\n            \n            for key in boxdict:\n                if (boxdict[key][0] == 1 and boxdict[key][1] == 1) or (boxdict[key][0] == 1 or boxdict[key][1] == 1):\n                    candysum += candies[key]\n            \n            return candysum\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes = set(initialBoxes)\n        bfs = [i for i in initialBoxes if status[i]]\n        for i in bfs:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    bfs.append(j)\n            for j in keys[i]:\n                if j in boxes and status[j]==0:\n                    bfs.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in bfs)\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q = collections.deque()\n        n = len(status)\n        \n        for i in initialBoxes:\n            q.append(i)\n        key = set()\n        res = 0\n        while q:\n            length = len(q)\n            hasOpen = False\n            for i in range(length):\n                box = q.popleft()\n\n                if status[box]==0 and box not in key:\n                    q.append(box)\n                else:\n                    hasOpen = True\n                    res += candies[box]\n                    for k in keys[box]:\n                        key.add(k)\n                    for x in containedBoxes[box]:\n                        q.append(x)\n            if not hasOpen:\n                break\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        n = len(status)\n        \n        self.count = 0\n        \n        queue = collections.deque([i for i in initialBoxes if status[i]==1])\n        \n        for i in queue:\n            status[i] = 2\n        \n        boxSet = set(initialBoxes)\n        keySet = set(i for i in range(n) if status[i]==1)\n        \n        while (queue):\n            l = len(queue)\n            for i in range(l):\n                cur = queue.popleft()\n                self.count += candies[cur]\n                for box in containedBoxes[cur]:\n                    boxSet.add(box)\n                    if box in keySet and status[box] != 2:\n                        queue.append(box)\n                        status[box] = 2\n                        print(box)\n                for key in keys[cur]:\n                    keySet.add(key)\n                    if key in boxSet and status[key] != 2:\n                        queue.append(key)\n                        status[key] = 2\n                        print(key)\n\n                    \n        \n        return self.count\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        \n        #Approach 1:  use set \n        #The queue only contains boxes which is accessible\n#         q=collections.deque()\n#         keys_set=set()   #Set for all available keys\n#         boxes_set=set()  #set for all un-opened boxes\n        \n#         #Initialize the queue to process box\n#         for box in initialBoxes:\n#             if(status[box]==1 or box in keys_set):  #Check if this box is open or there is key available\n#                 q.append(box)\n#                 for key in keys[box]:\n#                     keys_set.add(key)\n#                     if(key in boxes_set):           #Check if the new key can open a box in boxes_set\n#                         q.append(key)\n#                         boxes_set.remove(key)\n#             else:\n#                 boxes_set.add(box)\n                \n\n#         res=0\n#         visited=set()\n        \n#         #use DFS to populate the queue\n#         while q:\n            \n#             boxi=q.popleft()\n#             #Avoid duplicated couting of candies\n#             if(boxi in visited):\n#                 continue\n#             else:\n#                 visited.add(boxi)\n#                 res +=candies[boxi]\n                \n#             #Check all neighbors of current boxi\n#             for nei in containedBoxes[boxi]:\n#                 if(status[nei]==1 or nei in keys_set):   #Check if this box is open or there is a key for this box\n#                     q.append(nei)\n#                     for key in keys[nei]:\n#                         keys_set.add(key)\n#                         if(key in boxes_set):             #check if the new key can open a box in boxes_set\n#                             q.append(key)\n#                             boxes_set.remove(key)\n#                 else:\n#                     boxes_set.add(nei)\n        \n#         return res\n    \n    \n        #Approach 2: use list\n        \n        haskeys=status[:]\n        seen=[0]*len(status)\n        q=collections.deque()   #Only contains boxes that are accessible\n        \n        for box in initialBoxes:\n            seen[box]=1\n            if(haskeys[box]):\n                q.append(box)   #Include the one only accessible\n                \n        res=0\n        while q:\n            \n            boxi=q.popleft()\n            res+=candies[boxi]\n            \n            #Since eachbox is contained in one box at most\n            #it will not result in duplicated elements in q\n            for nei in containedBoxes[boxi]:\n                seen[nei]=1\n                if(haskeys[nei]): q.append(nei)\n            \n            #Iterate through all available keys, \n            #inlcude the box has been seen but doesn't have key to the queue\n            for key in keys[boxi]:\n                if(seen[key] and haskeys[key]==0):  #Meaning it has not been included in queue\n                    q.append(key)\n                haskeys[key]=1\n        \n        return res\n                    \n                \n            \n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n            \n            \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        maxCandy = 0\n        keyset = set()\n        numbox = len(status)\n        q = list(initialBoxes)\n        unopenedBOXES = []\n        while q:\n            for _ in range(len(q)):\n                thisbox = q.pop(0)\n                if status[thisbox] == 1 or thisbox in keyset:\n                    maxCandy += candies[thisbox]\n                    candies[thisbox] = 0\n                    for key in keys[thisbox]:\n                            keyset.add(key)\n                else:\n                    unopenedBOXES.append(thisbox)\n                for x in containedBoxes[thisbox]:\n                    q.append(x)\n        \n        \n        for unopenedBOX in unopenedBOXES:\n            if unopenedBOX in keyset:\n                maxCandy += candies[unopenedBOX]\n                \n        return maxCandy", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        locked_boxes = set()\n        unused_keys = set()\n        candy_count = 0\n        cur_box = []\n        \n        for box in initialBoxes:\n            if status[box]:\n                cur_box.append(box)\n            else:\n                locked_boxes.add(box)\n        while cur_box:\n            box = cur_box.pop()\n            candy_count += candies[box]\n            for i in keys[box]:\n                if not status[i]:\n                    if i not in locked_boxes:\n                        unused_keys.add(i)\n                    else:\n                        locked_boxes.remove(i)\n                        cur_box.append(i)\n            for i in containedBoxes[box]:\n                if not status[i] and i not in unused_keys:\n                    locked_boxes.add(i)\n                else:\n                    cur_box.append(i)\n                    if i in unused_keys:\n                        unused_keys.remove(i)\n            if box in unused_keys:\n                unused_keys.remove(box)\n\n        return candy_count", "class Solution:\n  def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n    # count the candies after open all possible boxes\n    boxes = set(initialBoxes)\n    # status as initial set of keys on hand\n    bfs = [i for i in boxes if status[i]]\n    for i in bfs:\n      # collect boxes\n      for j in containedBoxes[i]:\n        boxes.add(j)\n        if status[j]:\n          bfs.append(j)\n      # collect keys\n      for j in keys[i]:\n        # open a previously obtained box\n        if status[j] == 0 and j in boxes:\n          bfs.append(j)\n        # use the status to represent keys obtained\n        status[j] = 1\n    return sum(candies[i] for i in bfs)", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        locked_boxes = set()\n        unused_keys = set()\n        candy_count = 0\n        cur_box = []\n        \n        for box in initialBoxes:\n            if status[box]:\n                cur_box.append(box)\n            else:\n                locked_boxes.add(box)\n        while cur_box:\n            box = cur_box.pop()\n            status[box] = 1\n            candy_count += candies[box]\n            for i in keys[box]:\n                if not status[i]:\n                    if i not in locked_boxes:\n                        unused_keys.add(i)\n                    else:\n                        locked_boxes.remove(i)\n                        cur_box.append(i)\n            for i in containedBoxes[box]:\n                if not status[i] and i not in unused_keys:\n                    locked_boxes.add(i)\n                else:\n                    cur_box.append(i)\n                    if i in unused_keys:\n                        unused_keys.remove(i)\n            if box in unused_keys:\n                unused_keys.remove(box)\n\n        return candy_count", "from collections import deque\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        cur_queue = deque(initialBoxes)\n        next_queue = deque([])\n        key_set = set([])\n        # opened_set = set([])\n\n        total = 0\n        while True:\n            temp_queue = cur_queue.copy()\n            while temp_queue:\n                c = temp_queue.popleft()\n                if status[c] == 1 or c in key_set:\n                    # opened_set.add(c)\n                    key_set = key_set.union(keys[c])\n                    total += candies[c]\n                    for s in containedBoxes[c]:\n                        next_queue.append(s)\n                else:\n                    next_queue.append(c)\n\n            # print(total, next_queue, cur_queue)\n            if cur_queue == next_queue:\n                break\n\n            cur_queue = next_queue\n            next_queue = deque([])\n            \n        return total", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        res, bcache, kcache = 0, set(initialBoxes), set()\n        for _ in range(999):\n            tmp = set()\n            for b in bcache:\n                if status[b] == 1 or b in kcache:\n                    tmp |= set(containedBoxes[b])\n                    kcache |= set(keys[b])\n                    res += candies[b]\n                else:\n                    tmp.add(b)\n            bcache = tmp\n        # print(f'{bcache} {kcache}')\n        return res\n                    \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        maximum = 0\n        \n        cur = []\n        closeddic = dict()\n        size = 0\n        \n        for i in initialBoxes:\n            if(status[i] == 1):\n                cur.append(i)\n                size+=1\n            else:\n                closeddic[i] = 1\n        \n        consumed = dict()\n        keysdic = dict()\n        \n        while(size>0):\n            nex = []\n            nsize = 0\n            \n            for i in cur:\n                maximum+=candies[i]\n                consumed[i] = True\n                \n                for j in containedBoxes[i]:\n                    if((status[j] == 1 or j in keysdic) and j not in consumed):\n                        nex.append(j)\n                        nsize+=1\n                    \n                    elif(status[j] == 0):\n                        closeddic[j] = 1\n                \n                for j in keys[i]:\n                    keysdic[j] = 1\n                    \n                    if(j in closeddic and j not in consumed):\n                        del closeddic[j]\n                        nex.append(j)\n                        nsize+=1\n            \n            size = nsize\n            cur = nex\n        \n        return maximum", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        keyHold = set([idx for idx, b in enumerate(status) if b == 1])\n        boxHold = set(initialBoxes)\n        opened = set()\n        while True:\n            flag = False\n            newKey = set()\n            newBox = set()\n            for b in boxHold:\n                if b in keyHold:\n                    opened.add(b)\n                    flag = True\n                    for k in keys[b]:\n                        newKey.add(k)\n                    for nb in containedBoxes[b]:\n                        if nb not in opened:\n                            newBox.add(nb)\n            if not flag:\n                break\n            for k in newKey:\n                keyHold.add(k)\n            for b in newBox:\n                boxHold.add(b)\n            for b in opened:\n                boxHold.discard(b)\n        return sum([c for idx, c in enumerate(candies) if idx in opened])\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        open =initialBoxes\n        x_keys = set()\n        locked = set()\n\n        \n        result = 0\n        seen  = set()\n        while (len(open)!=0):\n            i= open.pop(0)\n            if i in seen:\n                continue\n            for key in keys[i]:\n                x_keys.add(key)\n                \n            for box in containedBoxes[i]:\n                if box in x_keys or status[box]==1:\n                    open.append(box)\n                else:\n                    locked.add(box)\n                    \n            for box in locked:\n                if box in x_keys:\n                    open.append(box)\n                    \n            \n            \n            result+=candies[i]\n            seen.add(i)\n            \n        return result\n                \n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        \n        # topo sort\n        parent = collections.defaultdict(int)\n        for i,row in enumerate(containedBoxes):\n            for j in row:\n                parent[j] = i\n        \n        n = len(status)\n        bfs = collections.deque([(i,False) for i in initialBoxes])\n        res = 0\n        seen = set()\n        while bfs:\n            #print(bfs)\n            box,st = bfs.popleft()\n            if box in seen:\n                continue\n            if status[box]==0:\n                if st:\n                    return res\n                bfs.append((box,True))\n                continue\n            seen.add(box)\n            res+=candies[box]\n            for key in keys[box]:\n                status[key] = 1\n            for cbox in containedBoxes[box]:\n                bfs.append((cbox,False))\n            \n            \n            \n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        q=initialBoxes\n        has_key=[0]*len(status)\n        has_open=[0]*len(status)\n        res=0\n \n        while q:\n            qq=[]\n            for s in q:\n                if status[s] or has_key[s]:\n                    res+=candies[s]\n                    has_open[s]=1\n                    for b in containedBoxes[s]:\n                        if has_open[b]: continue\n                        qq.append(b)\n                    for k in keys[s]:\n                        has_key[k]=1\n                else:\n                    qq.append(s)\n            if tuple(qq)==tuple(q): break\n            q,qq=qq,[]\n \n        return res", "from collections import deque\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \n        q = deque(initialBoxes)\n        visited = set()\n        res = 0\n        while q:\n            itr, opened = len(q), False  # To detect cycle\n            opened = False\n            while (itr):\n                itr -= 1\n                v = q.popleft()\n                if status[v]: # Open box, (key is available or is open)\n                    \n                    opened = True\n                    res += candies[v]\n                    visited.add(v)\n                    \n                    for x in keys[v]:\n                        status[x] = 1\n                    \n                    for x in containedBoxes[v]:\n                        if x not in visited:\n                            q.append(x)\n                            \n                elif v not in visited: # Open when key is available\n                    q.append(v)\n            if not opened:\n                return res  # Exit cycle detected\n        return res", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        if not initialBoxes: return 0\n        if 1 not in status: return 0\n        boxes = []\n        result = 0\n        while True:\n            flag = False\n            for b in initialBoxes:\n                if status[b] == 1:\n                    flag = True\n                    result += candies[b]\n                    boxes.extend(containedBoxes[b])\n                    for j in keys[b]: status[j] = 1\n                    initialBoxes.remove(b)\n            initialBoxes += boxes\n            boxes = []\n            if not flag: break\n        return result\n", "class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # for initial boxes:\n        # - accumulate candies\n        # - for each key, pre-unlock them\n        # - add containedBoxes to queue\n        #\n        # for all contained boxes that's open:\n        # - accumulate candies\n        # - for each key, pre-unlock them\n        # ...\n        #\n        # keep track of a list of opened boxes to explore, and a list of closed boxes to explore\n        # - whenever open a box, pre-unlock their keys\n        #   - if box in list of closed Q, move to open\n        # - whenever find an enclosed box, put to either open or closed\n        # - continue until we have no more open boxes\n        \n        open_boxes = set()\n        closed_boxes = set()\n        # TODO: may need an explored flag for each box\n        for b in initialBoxes:\n            if status[b]:\n                open_boxes.add(b)\n            else:\n                closed_boxes.add(b)\n        \n        total_candies = 0\n        while len(open_boxes) > 0:\n            b = open_boxes.pop()\n            \n            total_candies += candies[b]\n            \n            for key in keys[b]:\n                status[key] = 1\n                if key in closed_boxes:\n                    closed_boxes.remove(key)\n                    open_boxes.add(key)\n            \n            for bb in containedBoxes[b]:\n                if status[bb]:\n                    open_boxes.add(bb)\n                else:\n                    closed_boxes.add(bb)\n        \n        return total_candies"]
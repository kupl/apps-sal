["class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda x: x[0]*x[0] + x[1]*x[1])\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key=lambda x:x[0]*x[0]+x[1]*x[1])\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        return (sorted(points,key=lambda x : x[0]**2 + x[1]**2))[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # nlog(n)\n        # points.sort(key=lambda item: item[0]**2 + item[1]**2)\n        # return points[:K]\n        \n        # nlog(k)\n        # return heapq.nsmallest(K, points, key=lambda item: item[0]**2 + item[1]**2)\n        \n        # O(n)\n        def compare(p1, p2):\n            return p1[0]**2 + p1[1]**2 - (p2[0]**2 + p2[1]**2)\n        \n        def partition(points, l, r):\n            pivot = points[l]\n            while l < r:\n                while l < r and compare(points[r], pivot) >=0:\n                    r -= 1\n                points[l] = points[r]\n                while l < r and compare(points[l], pivot) <=0:\n                    l += 1\n                points[r] = points[l]\n            points[l] = pivot\n            return l\n        \n        l, r = 0, len(points) - 1\n        while l < r:\n            p = partition(points, l, r)\n            if p == K:\n                break\n            if p < K:\n                l = p + 1\n            else:\n                r = p - 1\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for x,y in points:\n            dist = - (x**2 + y**2)\n            if len(heap) >= K:\n                heapq.heappushpop(heap, (dist, x, y))\n            else:\n                heapq.heappush(heap, (dist, x, y))\n        return [[x,y] for dist, x, y in heap]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def partition(start, end):\n            pivot = start\n            left = start+1\n            right = end\n            while True:\n                while left < right and not comparer(points[left], points[pivot]):\n                    left += 1\n                while left <= right and comparer(points[right], points[pivot]):\n                    right -= 1\n                if left >= right: \n                    break\n                points[left], points[right] = points[right], points[left]\n            points[pivot], points[right] = points[right], points[pivot]\n            return right\n        def comparer(point1, point2):\n            return (point1[0]**2+point1[1]**2)>=(point2[0]**2+point2[1]**2)\n        \n        left, right, mid = 0, len(points)-1, 0\n        while left<=right:\n            mid = partition(left, right)\n            if mid == K-1:\n                break\n            elif mid > K-1:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return points[:K]", "class Solution(object):\n    def kClosest(self, points, K):\n        points.sort(key = lambda P: P[0]**2 + P[1]**2)\n        return points[:K]", "from queue import PriorityQueue\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pq = PriorityQueue()\n        \n        for i, point in enumerate(points):\n            point_distance = point[0]**2 + point[1]**2\n            if i < K:\n                pq.put((-point_distance, point))\n            \n            if i >=  K:\n                min_point_distance, min_point = pq.queue[0]\n                \n                if point_distance < -min_point_distance:\n                    pq.get()\n                    pq.put((-point_distance, point))\n            \n        results = []\n        while not pq.empty():\n            _, point = pq.get()\n            results.append(point)\n        return results", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        hp = []\n        heapq.heapify(hp)\n        for x,y in points:\n            ds = x**2 + y**2  # distance square\n            if len(hp) < K:\n                heapq.heappush(hp, (-ds, [x, y]))\n            else:\n                heapq.heappushpop(hp, (-ds, [x, y]))\n        return [xy for ds, xy in hp]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def compare(point1, point2):\n            return (point1[0] ** 2 + point1[1] ** 2 - point2[0] ** 2 - point2[1] ** 2) >= 0\n            \n        def partition(l, r, arr):\n            pivot = arr[l]\n            \n            while l < r:\n                while l < r and compare(arr[r], pivot):\n                    r -= 1\n                arr[l] = arr[r]\n                \n                while l < r and compare(pivot, arr[l]):\n                    l += 1\n                arr[r] = arr[l]\n            \n            arr[l] = pivot\n            \n            return l\n        \n        lo = 0\n        hi = len(points) - 1\n        \n        while lo <= hi:\n            mid = partition(lo, hi, points)\n            if mid == K:\n                break\n            if mid < K:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        return points[0:K]\n                \n            \n", "import random\n\nclass Solution:\n    \n    # problem: https://leetcode.com/problems/k-closest-points-to-origin/\n    # type : divide and conquer\n    # will keep on partitioning and partially sorting part of the values\n    \n    # T = O(N) on expectation becuase of the the random pivots\n    # S = O(1)\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def dist(x):\n            return points[x][0]**2 + points[x][1]**2\n        \n        def partial_sort(i,j,K):\n            # i : the start index to sort from, initally will be 0\n            # j : the end index, initialy will be len(points) - 1\n            # K: # elements to be partially sorted\n            \n            if i >= j:\n                return\n            \n            # 1. pick a random pivot:\n            pivot = random.randint(i,j) # inclusive of j\n            \n            # switch with index i, initially will swap with i = 0\n            points[i], points[pivot] = points[pivot], points[i]\n            \n            # partitions function,\n            # will find elements that are smaller than pivot and put to left\n            # elements larger than pivot will go to right\n            # will return the #sorted elements\n            num_sorted = partition(i,j)\n            \n            # will have to check if K values are sorted\n            # continue after the partition func\n            \n            # 1. in case we have sorted more than K elements\n            # initially i ==0, but i will change for each iteration\n            if K == num_sorted:\n                return\n            \n            if K < num_sorted:\n                partial_sort(i,num_sorted - 1, K)\n            elif K > num_sorted:\n                partial_sort(num_sorted + 1, j, K)\n            \n        def partition(i,j):\n            \n            # pivot will be at i\n            oi = i # pivot index, old-i\n            i += 1 # will keep on checking for the values after oi\n            \n            while True: \n                # pass 1 -->>\n                while i < j and dist(i) < dist(oi):\n                    i += 1\n                # pass 2 <<-- of j\n                while j >= i and dist(j) >= dist(oi):\n                    j -= 1\n                # stopping condition\n                if i >= j:\n                    break\n                # if it didnt stop, swap i,j\n                points[i], points[j] = points[j], points[i]\n                \n            # swap pivot with j\n            points[oi],points[j] = points[j], points[oi]\n            \n            return j\n        \n        partial_sort(0,len(points)-1,K)\n        return points[:K]\n                \n                \n            \n            \n        \n        \n            \n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # sort\n#         s_p = sorted(points, key = lambda p:p[0]**2 + p[1]**2)\n        \n#         return s_p[:K]\n    \n        # Divide and Conquer\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\n\n        def sort(i, j, K):\n            # Partially sorts A[i:j+1] so the first K elements are\n            # the smallest K elements.\n            if i >= j: return\n\n            # Put random element as A[i] - this is the pivot\n            k = random.randint(i, j)\n            points[i], points[k] = points[k], points[i]\n\n            mid = partition(i, j)\n            if K < mid - i + 1:\n                sort(i, mid - 1, K)\n            elif K > mid - i + 1:\n                sort(mid + 1, j, K - (mid - i + 1))\n\n        def partition(i, j):\n            # Partition by pivot A[i], returning an index mid\n            # such that A[i] <= A[mid] <= A[j] for i < mid < j.\n            oi = i\n            pivot = dist(i)\n            i += 1\n\n            while True:\n                while i < j and dist(i) < pivot:\n                    i += 1\n                while i <= j and dist(j) >= pivot:\n                    j -= 1\n                if i >= j: break\n                points[i], points[j] = points[j], points[i]\n\n            points[oi], points[j] = points[j], points[oi]\n            return j\n\n        sort(0, len(points) - 1, K)\n        return points[:K]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # nlog(n)\n        # points.sort(key=lambda item: item[0]**2 + item[1]**2)\n        # return points[:K]\n        \n        # nlog(k)\n        # return heapq.nsmallest(K, points, key=lambda item: item[0]**2 + item[1]**2)\n        \n        # O(n)\n        def compare(p1, p2):\n            return p1[0]**2 + p1[1]**2 - (p2[0]**2 + p2[1]**2)\n        \n        def partition(points, l, r):\n            pivot = points[l]\n            while l < r:\n                while l < r and compare(points[r], pivot) >=0:\n                    r -= 1\n                points[l] = points[r]\n                while l < r and compare(points[l], pivot) <=0:\n                    l += 1\n                points[r] = points[l]\n            points[l] = pivot\n            return l\n        \n        l, r = 0, len(points) - 1\n        while l < r:\n            p = partition(points, l, r)\n            if p == K - 1:\n                break\n            if p < K - 1:\n                l = p + 1\n            else:\n                r = p - 1\n        return points[:K]", "import operator\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda p : p[0] ** 2 + p[1] ** 2)\n        \n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def partition(start, end):\n            pivot = start\n            left = start+1\n            right = end\n            while True:\n                while left < right and comparer(points[pivot], points[left]):\n                    left += 1\n                while left <= right and comparer(points[right], points[pivot]):\n                    right -= 1\n                if left >= right: \n                    break\n                points[left], points[right] = points[right], points[left]\n            points[pivot], points[right] = points[right], points[pivot]\n            return right\n        def comparer(point1, point2):\n            return (point1[0]**2+point1[1]**2)>=(point2[0]**2+point2[1]**2)\n        \n        left, right, mid = 0, len(points)-1, 0\n        while left<=right:\n            mid = partition(left, right)\n            if mid == K-1:\n                break\n            elif mid > K-1:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return points[:K]", "import random\n\nclass Solution:\n    \n    # problem: https://leetcode.com/problems/k-closest-points-to-origin/\n    # type : divide and conquer\n    # will keep on partitioning and partially sorting part of the values\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def dist(x):\n            return points[x][0]**2 + points[x][1]**2\n        \n        def partial_sort(i,j,K):\n            # i : the start index to sort from, initally will be 0\n            # j : the end index, initialy will be len(points) - 1\n            # K: # elements to be partially sorted\n            \n            if i >= j:\n                return\n            \n            # 1. pick a random pivot:\n            pivot = random.randint(i,j) # inclusive of j\n            \n            # switch with index i, initially will swap with i = 0\n            points[i], points[pivot] = points[pivot], points[i]\n            \n            # partitions function,\n            # will find elements that are smaller than pivot and put to left\n            # elements larger than pivot will go to right\n            # will return the #sorted elements\n            num_sorted = partition(i,j)\n            \n            # will have to check if K values are sorted\n            # continue after the partition func\n            \n            # 1. in case we have sorted more than K elements\n            # initially i ==0, but i will change for each iteration\n            if K < num_sorted + 1 - i:\n                partial_sort(i,num_sorted - 1, K)\n            elif K > num_sorted + 1 - i:\n                partial_sort(num_sorted + 1, j, K - (num_sorted + 1 - i))\n            \n        def partition(i,j):\n            \n            # pivot will be at i\n            oi = i # pivot index, old-i\n            i += 1 # will keep on checking for the values after oi\n            \n            while True: \n                # pass 1 -->>\n                while i < j and dist(i) < dist(oi):\n                    i += 1\n                # pass 2 <<-- of j\n                while j >= i and dist(j) >= dist(oi):\n                    j -= 1\n                # stopping condition\n                if i >= j:\n                    break\n                # if it didnt stop, swap i,j\n                points[i], points[j] = points[j], points[i]\n                \n            # swap pivot with j\n            points[oi],points[j] = points[j], points[oi]\n            \n            return j\n        \n        partial_sort(0,len(points)-1,K)\n        return points[:K]\n                \n                \n            \n            \n        \n        \n            \n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for x,y in points:\n            dist = - (x**2 + y**2)\n            if len(heap) >= K:\n                heapq.heappushpop(heap, (dist, x, y))\n            else:\n                heapq.heappush(heap, (dist, x, y))\n        return [[x,y] for dist, x, y in heap]\n        \n#         heap = []\n        \n#         for (x, y) in points:\n#             dist = -(x*x + y*y)\n#             if len(heap) == K:\n#                 heapq.heappushpop(heap, (dist, x, y))\n#             else:\n#                 heapq.heappush(heap, (dist, x, y))\n        \n#         return [(x,y) for (dist,x, y) in heap]\n", "from queue import PriorityQueue\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pq = PriorityQueue()\n        \n        for p in points: #O(nlogk)\n            new_priority = -1* (p[0]*p[0] + p[1]*p[1])\n            if pq.qsize() == K:\n                old_priority, old_point = pq.get()\n                if new_priority > old_priority:\n                    pq.put((new_priority, p))\n                else:\n                    pq.put((old_priority, old_point))\n            else:\n                pq.put((new_priority, p))\n            \n        res = []\n        for i in range(K):\n            priority, p = pq.get()\n            res.append(p)\n            \n        return res", "import heapq\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        heap = []\n        \n        for point in points:\n            dist = point[0] * point[0] + point[1] * point[1]\n            if len(heap) < K:\n                heapq.heappush(heap, (-dist, point))\n                continue\n            \n            if -heap[0][0] > dist:\n                heapq.heappush(heap, (-dist, point))\n                heapq.heappop(heap)\n            \n        return [x[1] for x in heap]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        distance = [   ((x[0]**2 + x[1]**2)**(1/2),i) for i,x in enumerate(points)    ]\n        heapq.heapify(distance)\n        ans = []\n        \n        while K > 0 :\n            element = heapq.heappop(distance)\n            ans.append(points[element[1]])\n            K -= 1\n        return ans", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if K >= len(points): return points\n        \n        heap = []\n                \n        #k \n        for i in range(K):\n            distance = -1 * self.getDistance(points[i])\n            heapq.heappush(heap, (distance, i))\n\n        # n\n        for i in range(K, len(points)): \n            distance = -1 * self.getDistance(points[i])\n            if distance > heap[0][0]: \n                heapq.heappop(heap)\n                heapq.heappush(heap, (distance, i))\n            \n        result = []\n        # O(k)\n        for p in heap:\n            result.append(points[p[1]])\n        \n        return result\n        \n        \n    \n    def getDistance(self, point):\n        return point[0]**2 + point[1]**2\n        \n        \n        \n        \n        \n        \n        \n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        return heapq.nsmallest(K, points, lambda p: p[0]**2 + p[1]**2)", "import random\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def sort(left, right, K):\n            if left < right:\n                pivot = partition(left, right)\n                \n                if pivot == K:\n                    return\n                elif pivot < K:\n                    sort(pivot+1, right, K)\n                else:\n                    sort(left, pivot-1, K)\n        \n        def partition(left, right):\n            pivot = points[right]\n            anchor = left\n            \n            for i in range(left, right):\n                if points[i][0]**2+points[i][1]**2 <= pivot[0]**2+pivot[1]**2:\n                    points[anchor], points[i] = points[i], points[anchor]\n                    anchor += 1\n                    \n            points[anchor], points[right] = points[right], points[anchor]\n            \n            return anchor\n        \n        sort(0, len(points)-1, K)\n        \n        return points[:K]", "from queue import PriorityQueue\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pq = PriorityQueue()\n        \n        for p in points: #O(nlogk)\n            new_priority = -1* (pow(p[0],2) + pow(p[1], 2))\n            if pq.qsize() == K:\n                old_priority, old_point = pq.get()\n                if new_priority > old_priority:\n                    pq.put((new_priority, p))\n                else:\n                    pq.put((old_priority, old_point))\n            else:\n                pq.put((new_priority, p))\n            \n        res = []\n        for i in range(K):\n            priority, p = pq.get()\n            res.append(p)\n            \n        return res", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key= lambda x: x[0]**2+x[1]**2)\n        points= points[0:K]\n        return points\n", "from queue import PriorityQueue\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        kPq = PriorityQueue()\n        cnt = 0\n        for point in points:\n            w = point[0] * point[0] + point[1] * point[1]\n            kPq.put([-w, point])\n            cnt += 1\n            if cnt > K:\n                kPq.get()\n        r = []\n        while not kPq.empty():\n            item = kPq.get()\n            r.append(item[1])\n        return r\n\n", "import queue\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # priority queue (minheap)\n        # put distance: index of points\n        if not points: return []\n        q = queue.PriorityQueue()\n        for l in points:\n            # put negative distance to make heap as max heap\n            q.put((-(l[0]**2 + l[1]**2), l))\n            if q.qsize() > K:\n                q.get()\n        res = []\n        while K > 0:\n            res.append(q.get()[1])\n            K -= 1\n        return res\n            \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # get_distance = lambda x: x[0] **2 + x[1] **2\n        # tmp = list(map(lambda x: [x[0], x[1], get_distance(x)], points))\n        # # print(tmp)\n        # tmp.sort(key=lambda x: x[2])\n        # res = list(map(lambda x: [x[0], x[1]], tmp[:K]))\n        # return res\n        \n        distance_map = list(map(lambda x: (x, x[0] **2 + x[1] **2), points))\n        from queue import PriorityQueue\n        heap = PriorityQueue(K)\n        \n        for points, dist in distance_map:\n            if not heap.full():\n                heap.put((-dist, points))\n                # print(heap.queue)\n                # print(heap.queue[0][0])\n            elif dist < - heap.queue[0][0]:\n                # print('heap', heap.queue)\n                _ = heap.get()\n                heap.put((-dist, points))\n            \n        res = []\n        while not heap.empty():\n            res.append(heap.get()[1])\n        return res", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key=lambda x: x[0]**2 + x[1]**2)\n        return points[:K]", "import math\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda p: p[0]**2+p[1]**2)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distance = lambda x, y: sqrt(x**2 + y**2)\n        k = 0\n        output = []\n        for s in sorted(points, key=lambda x: distance(x[0], x[1])):\n            if k < K:\n                output.append(s)\n            else:\n                break\n            k += 1\n        return output", "class Solution:\n    def kClosest(self, points, K: int):\n      \n        return [points[i] for d,i in sorted([[x[0]**2+x[1]**2,i] for i,x in enumerate(points)])[0:K]]   ", "import math \nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        distances = {}\n        \n        d = []\n        \n#         large = -float(inf)\n#         small = float(inf)\n        \n        \n        for i in range(len(points)):\n            \n            dist = math.sqrt(points[i][0] ** 2 + points[i][1] ** 2)\n            # print(dist)\n            distances[dist] = distances.get(dist, []) + [points[i]]\n            d.append(dist)\n            \n        # print(distances)\n        d.sort()\n        ans = []\n        \n        for i in range(K):\n            if i != 0 and d[i] == d[i-1]: continue\n            ans = ans + distances[d[i]]\n            \n        return ans\n            \n        \n        \n        \n", "#     Version I sort:\n#       Step1: write a comparator\n#       Step2: write a distance calculator\n#       Step3: sort\n#       T: O(nlgn) S: O(n)\n#     Version II: k sort\n#       T: O(nlgk) S: O(k)\n#     Version III: quick select\n#       Step1: start, end\n#       Step2: find mid and seperate to left part and right part\n#       Step3: check if mid == k: return [:mid] or check mid again in right part or left part again\n#       T: O(n) S: O(lgn) the height of stack\nclass Solution:\n    def _getDistance(self, point):\n        dis = math.sqrt(point[0]**2 + point[1]**2)\n        return dis\n    \n    def _partition(self, start, end, points):\n        target = points[start]\n        while start < end:\n            while start < end and self._getDistance(points[end]) >= self._getDistance(target):\n                end -= 1\n            points[start] = points[end]\n            while start < end and self._getDistance(points[start]) <= self._getDistance(target):\n                start += 1\n            points[end] = points[start]\n        points[start] = target\n        return start\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if not points:\n            return []\n        start = 0\n        end = len(points) - 1\n        while start <= end:\n            mid = self._partition(start, end, points)\n            if mid == K:\n                return points[:K]\n            elif mid > K:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return points[:K]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        from math import sqrt\n        points.sort(key=lambda x: sqrt(x[0]**2+x[1]**2))\n        return points[:K]", "from queue import PriorityQueue\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if points is None:\n            return []\n        \n        q = PriorityQueue()\n        \n        for point in points:\n            q.put((-self.distanceOrigin(point), point))\n            if q.qsize() > K:\n                q.get()\n                \n        res = []\n        while not q.empty():\n            res.append(q.get()[1])\n            \n        return res\n\n    \n    def distanceOrigin(self, a):\n        return sqrt(a[0]**2 + a[1]**2)", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distances = []\n        \n        for idx, point in enumerate(points):\n            eucliDist = point[0]**2 + point[1]**2\n            heapq.heappush(distances, (eucliDist, point))\n        \n        distances = heapq.nsmallest(K, distances)\n        result = []\n        for res in distances:\n            result.append(res[1])\n            \n        return result\n            \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dic = collections.defaultdict(list)\n        for p in points:\n            d = p[0]**2 + p[1]**2\n            dic[d].append(p)\n        dic2 = list(dic.keys())\n        print(dic2)\n        heapq.heapify(dic2)\n        res = []\n        count = 0\n        while(count<K):\n            res.extend(dic[heapq.heappop(dic2)])\n            count = len(res)\n        return res", "def compare(p1, p2):\n    return (p1[0] ** 2 + p1[1] ** 2) - (p2[0] ** 2 + p2[1] ** 2)\n\ndef swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\ndef partition(A, l, r):\n    pivot = A[l]\n    while l < r:\n        while l < r and compare(A[r], pivot) >= 0:\n            r -= 1\n        \n        A[l] = A[r]\n        while l < r and compare(A[l], pivot) <= 0:\n            l += 1\n        \n        A[r] = A[l]\n    \n    A[l] = pivot;\n    return l\n#     pivot = points[high]\n    \n#     i = low - 1\n    \n#     for j in range(low, high):\n#         if compare(points[j], pivot) < 0:\n#             i += 1\n#             swap(points, i, j)\n#     swap(points, i + 1, high)\n#     return i + 1\n    \ndef quick_select(points, k, low, high):\n    while low < high:\n        pivot = partition(points, low, high)\n        if pivot == k:\n            break\n        elif pivot < k:\n            # need more elements from the right\n            low = pivot + 1\n        else:\n            # reduce element from the left\n            high = pivot - 1\n\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        quick_select(points, k, 0, len(points) - 1)\n        return points[:k]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pointDistances = [\n            [point, self.calculateDistanceToOrigin(point)]\n            for point in points\n        ]\n        \n        sortedPoints = sorted(pointDistances, key=lambda pd: pd[1])\n        return [pd[0] for pd in sortedPoints[:K]]\n                \n    \n    def calculateDistanceToOrigin(self, point):\n        return point[0] * point[0] + point[1] * point[1] ", "\\\"\\\"\\\"\nquick select to find k\n\nquick select method\narr, k (kth)\nl = -1\nr = len(arr)\n\ndef square(e):\n    return e[0] * e[0] + e[1] * e[1]\n\n\ndef partition(arr, l, r):\n    p = r\n    firstHigh = l\n    for i in range(r):\n        if square(arr[i]) < square(arr[p]):\n            arr[i], arr[firstHigh] = arr[firstHigh], arr[i]\n    arr[firstHigh], arr[p] = arr[p], arr[firsthHigh]\n    return firstHigh\n            \n\n\ndef getKClosest(arr, k):\n    while l + 1 < r:\n        v = partition(arr, l, r)\n        if v < k:\n            l = v\n        else:\n            r = v\n\n        retrun arr[:k]\n\n\\\"\\\"\\\"\ndef square(e):\n    return e[0] * e[0] + e[1] * e[1]\n\n\ndef partition(arr, l, r):\n    p = r\n    firstHigh = l\n    for i in range(l, r):\n        if square(arr[i]) < square(arr[p]):\n            arr[i], arr[firstHigh] = arr[firstHigh], arr[i]\n            firstHigh += 1\n    arr[firstHigh], arr[p] = arr[p], arr[firstHigh]\n    return firstHigh\n            \nclass Solution:\n    def kClosest(self, arr: List[List[int]], k: int) -> List[List[int]]:\n        l = 0\n        r = len(arr) - 1\n        while l < r:\n            v = partition(arr, l, r)\n            if v < k:\n                l = v + 1\n            else:\n                r = v - 1\n\n        return arr[:k]", "class Solution(object):\n    def kClosest(self, points, K):\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\n\n        def sort(i, j, K):\n            # Partially sorts A[i:j+1] so the first K elements are\n            # the smallest K elements.\n            if i >= j: return\n\n            # Put random element as A[i] - this is the pivot\n            k = random.randint(i, j)\n            points[i], points[k] = points[k], points[i]\n\n            mid = partition(i, j)\n            if K < mid - i + 1:\n                sort(i, mid - 1, K)\n            elif K > mid - i + 1:\n                sort(mid + 1, j, K - (mid - i + 1))\n\n        def partition(i, j):\n            # Partition by pivot A[i], returning an index mid\n            # such that A[i] <= A[mid] <= A[j] for i < mid < j.\n            oi = i\n            pivot = dist(i)\n            i += 1\n\n            while True:\n                while i < j and dist(i) < pivot:\n                    i += 1\n                while i <= j and dist(j) >= pivot:\n                    j -= 1\n                if i >= j: break\n                points[i], points[j] = points[j], points[i]\n\n            points[oi], points[j] = points[j], points[oi]\n            return j\n\n        sort(0, len(points) - 1, K)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distanceList = []\n        for x,y in points:\n            distanceList.append((x,y,self.distanceFromOrigin(x, y)))\n            \n        return [[p[0], p[1]] for p in heapq.nsmallest(K, distanceList, key=lambda x:x[2])]\n    \n    def distanceFromOrigin(self, x, y):\n        return sqrt(pow(x - 0, 2) + pow(y - 0, 2))", "from queue import PriorityQueue\nimport math\n\nclass Solution:\n    def kClosest(self, points, K):\n        pq = PriorityQueue()\n        \n        for point in points:\n            d = self.getDistance(point)\n            pq.put((-1 * d, point))\n            \n            if pq.qsize() > K:\n                pq.get()\n                \n        out = []\n        while pq.qsize() > 0:\n            out.append(pq.get()[1])\n            \n        return out\n        \n    def getDistance(self, point):\n        return math.sqrt(point[0] ** 2 + point[1] ** 2)", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if not points or len(points) < 1:\n            return []\n        distances = []\n        \n        for point in points:\n            dist = point[0]*point[0] + point[1]*point[1]\n            if len(distances) < K:\n                heapq.heappush(distances, (-dist, point))\n            else:\n                if -dist > distances[0][0]:\n                    heapq.heappushpop(distances, (-dist, point))\n        \n        return [point for _, point in distances]", "class Node:\n    def __init__(self, c, sum):\n        self.sum = sum\n        self.c = c\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if not points:\n            return []\n        heap = []\n        ans = []\n        for i in points:\n            heap.append(Node(i, i[0]**2 + i[1]**2))\n        n = len(heap)\n        def heapify(arr, i, n):\n            smallest = i\n            left = i*2 + 1\n            right = i*2 + 2\n            if left < n and arr[i].sum > arr[left].sum:\n                smallest = left\n            if right < n and arr[right].sum < arr[smallest].sum:\n                smallest = right\n            if smallest != i:\n                arr[smallest], arr[i] = arr[i], arr[smallest]\n                heapify(arr, smallest, n)\n        for i in range((n-1)//2,-1,-1):\n            heapify(heap, i, n)\n        while K > 0 and len(ans) < len(points):\n            h = heap[0]\n            ans.append(h.c)\n            heap[0].sum = sys.maxsize\n            heapify(heap, 0, len(heap))\n            K -= 1\n        return ans", "## Time Complexity: O(NlogK)\n## Space Complexity: O(K)\n\nfrom heapq import *\n\n## Approach 1 - Succinct code\n# class Solution:\n#     def distance(self, point):\n#         # ignoring sqrt to calculate the distance\n#         return point[0] ** 2 + point[1] ** 2\n#\n#     def kClosest(self, points, K):\n#         '''\n#         :type points: List[List[int]]\n#         :type K: int\n#         :rtype: List[List[int]]\n#         '''\n#         max_heap = []\n#         for point in points:\n#             heappush(max_heap, (-self.distance(point), point))\n#             if len(max_heap) > K:\n#                 heappop(max_heap)\n#\n#         res = []\n#         while max_heap:\n#             res.append(heappop(max_heap)[1])\n#         return res\n\n\n## Approach 2 - Define a Point class\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def distance_from_origin(self):\n        # for comparison we ignore the sqrt part\n        return self.x ** 2 + self.y ** 2\n\n    def __lt__(self, other):\n        return self.distance_from_origin() < other.distance_from_origin()\n\n    def __eq__(self, other):\n        return self.distance_from_origin() == other.distance_from_origin()\n\n\nclass Solution:\n    def kClosest(self, points, K):\n        '''\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        '''\n        max_heap = []\n        for p in points:\n            point = Point(p[0], p[1])\n            dist = point.distance_from_origin()\n            heappush(max_heap, (-dist, point))\n            if len(max_heap) > K:\n                heappop(max_heap)\n\n        res = []\n        while max_heap:\n            pt = heappop(max_heap)[1]\n            res.append([pt.x, pt.y])\n        return res\n\n", "from queue import PriorityQueue\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pq = PriorityQueue()\n        for i in range(len(points)):\n            distance = points[i][0]**2+points[i][1]**2\n            if i < K:\n                pq.put((-distance, points[i]))\n            else:\n                pq.put((-distance, points[i]))\n                pq.get()\n        ans = []\n        while pq.qsize() > 0:\n            ans.append(pq.get()[1])\n        return ans", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        closest = lambda x: points[x][0]**2 + points[x][1]**2\n        \n        \n            \n        def partition(i, j):\n            oi = i\n            pivot = closest(i)\n            i += 1\n            \n            while True:\n                while i < j and closest(i) < pivot:\n                    i += 1\n                while i <= j and closest(j) >= pivot:\n                    j -= 1\n                if i >= j:\n                    break\n                points[i], points[j] = points[j], points[i]\n            points[oi], points[j] = points[j], points[oi]\n            return j\n        \n        def kclosest(i, j, k):\n            if i >= j:\n                return\n            \n            mid = partition(i, j)\n            if k > mid - i + 1:\n                return kclosest(mid+1, j, k-(mid - i + 1))\n            elif k < mid - i + 1:\n                return kclosest(i, mid-1, k)\n        kclosest(0, len(points)-1, K)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def compare(p1, p2):\n            return (p1[0]**2 + p1[1]**2)-(p2[0]**2 + p2[1]**2)\n        \n        def quickSelect(l,r):\n            pivot = points[r]\n            j=l\n            for i in range(l,r):\n                if compare(points[i], pivot) <= 0:\n                    points[i], points[j] = points[j], points[i]\n                    j+=1\n            \n            points[r], points[j]  =points[j], points[r]\n            return j\n                \n            \n            \n            \n            \n        l,r = 0, len(points)-1\n        while l<=r:\n            pivot = quickSelect(l,r)\n            if pivot == K:\n                break\n            elif pivot < K:\n                l = pivot+1\n            else:\n                r = pivot-1\n        return points[:K]\n        \n        \n        \n        \n", "import heapq\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def dist(p):\n            return p[0]**2 + p[1]**2\n        \n        def qs(l, r, k):\n            if l >= r:\n                return\n            pivotd = dist(points[r])\n            ll = l\n            for rr in range(l, r):\n                if dist(points[rr]) < pivotd:\n                    points[ll], points[rr] = points[rr], points[ll]\n                    ll += 1\n            ppos = ll\n            points[ppos], points[r] = points[r], points[ppos]\n            if ppos == k:\n                return\n            if ppos < k:\n                qs(ppos + 1, r, k)\n            qs(l, ppos - 1, k)\n        \n        qs(0, len(points) - 1, K - 1)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dictionary = {}\n        for i in points:\n            dictionary[(i[0],i[1])] = math.sqrt( ((i[0]-0)**2)+((i[1]-0)**2) )\n        heap = []\n        heapq.heapify(heap)\n        for i in list(dictionary.keys()):\n            heapq.heappush(heap,(dictionary[i],i))\n        result = []\n\n        for i in range(K):\n            result.append(heapq.heappop(heap)[1])\n        return result\n", "class Solution:\n    \\\"\\\"\\\"\n    Sort everything and then get the first k items.\n    T: O(NlogN).\n    \\\"\\\"\\\"\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[:k]    \n    \n    \\\"\\\"\\\"\n    Use a max-heap to store the k smallest items.\n    T: O(N log K).\n    \\\"\\\"\\\"\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        heap = []\n        \n        for x,y in points:\n            # We put the -ve sign becase we want this to be a max heap.\n            key = -(x**2 + y**2)\n            heapq.heappush(heap, (key, x, y))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        return [[x,y] for distance, x, y in heap]\n    \n    \\\"\\\"\\\"\n    Use QuickSelect.\n    T: O(N) in the average case; O(N^2) in the worst case.\n    \\\"\\\"\\\"\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        self.quickSelect(points, k - 1, 0, len(points) - 1)\n        return points[:k]\n    \n    def quickSelect(self, points, k, p, q):\n        partitionIndex  = self.partition(points, p, q)\n        if partitionIndex == k:\n            return partitionIndex\n        elif partitionIndex > k:\n            return self.quickSelect(points, k, p, partitionIndex  - 1)\n        else:\n            return self.quickSelect(points, k, partitionIndex + 1, q)\n                \n    def getDistance(self, p):\n        x,y = p \n        return x**2 + y**2\n    \n    # p <= k <= boundary: items that are smaller than the pivot.\n    # boundary + 1 <= < q: items that are bigger than the pivot.\n    def partition(self, points, p, q):\n        distancePivot = self.getDistance(points[q])\n        boundary = p - 1\n        \n        for j in range(p, q):\n            if self.getDistance(points[j]) < distancePivot:\n                boundary += 1\n                points[boundary], points[j] = points[j], points[boundary]                \n        \n        # Insert the pivot in the correct position.\n        boundary += 1 \n        points[boundary], points[q] = points[q], points[boundary]\n        \n        return boundary", "import math\nclass Solution:\n    def __init__(self):\n        self.dist_coord = dict()\n        self.dist_heap = [None]\n        self.final_result = list()\n        \n    def _calc_dist(self, x, y):\n        return math.sqrt(x*x + y*y)\n\n    def _calc_dist_coord(self):\n        for point in self.coords:\n            dist = self._calc_dist(point[0], point[1])\n            if self.dist_coord.get(dist) is None:\n                self.dist_coord[dist] = [point]\n                self.dist_heap.append(dist)\n            else:\n                self.dist_coord[dist].append(point)\n        \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        self.coords = points\n        self._calc_dist_coord()\n        for i in reversed(list(range(1, len(self.dist_heap)//2 + 1))):\n            self.shift_down(self.dist_heap, i)\n        \n        while K > 0 and len(self.dist_heap) > 1:\n            # print(self.dist_coord, self.dist_heap)\n            for point in self.dist_coord[self.dist_heap[1]]:\n                self.final_result.append(point)\n                K -= 1\n            self.del_elem_from_heap(self.dist_heap)\n            # K -= 1\n        return self.final_result\n            \n    def shift_up(self, h_list):\n        i = len(h_list) - 1\n        while int(i/2) > 0:\n            if h_list[i] > h_list[int(i/2)]:\n                h_list[i], h_list[int(i/2)] = h_list[int(i/2)], h_list[i]\n            i = int(i/2)\n\n    def shift_down(self, h_list, start):\n        i = start\n        l = 2* i\n        r = 2* i + 1\n        if l < len(h_list) and h_list[i] > h_list[l]:\n            i = l\n\n        if r < len(h_list) and h_list[i] > h_list[r]:\n            i = r\n\n        if i != start:\n            h_list[start], h_list[i] = h_list[i], h_list[start]\n            self.shift_down(h_list, i)\n\n    def add_elem_to_heap(self, h_list, val):\n        h_list.append(val)\n        self.shift_up(h_list)\n\n    def del_elem_from_heap(self, h_list):\n        h_list[1] = h_list[-1]\n        h_list.pop()\n        self.shift_down(h_list, 1)\n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        n1 = len(points)\n        newList = [0] * n1\n        for i in range(n1):\n            pointX = points[i][0]\n            pointY = points[i][1]\n            d2 = pointX * pointX + pointY * pointY\n            newList[i] = d2\n        newList.sort()\n        res = newList[K - 1]\n        i = 0\n        t = 0\n        ans = []\n        while i < n1 and t < K:\n            if res >= points[i][0] * points[i][0] + points[i][1] * points[i][1]:\n                ans = ans + [points[i]]\n                t += 1\n            i += 1\n        return ans", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def helper(p):\n            return p[0]**2 + p[1]**2\n        return sorted(points, key=helper)[:K]", "from queue import PriorityQueue\n\n\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n           \n        def dst(point):\n            return (point[0] ** 2 + point[1] ** 2) ** (1/2)\n        \n        n = 0\n        q = PriorityQueue()\n        for point in points:\n            point = [-dst(point)] + point[:]  \n            if n < K:\n                q.put(point)\n            \n            else:\n                least = q.get()\n    \n                if -point[0] < -least[0]:\n                    q.put(point)\n                else:\n                    q.put(least)   \n            n += 1\n        \n        closest = []\n        while not q.empty():\n            closest.append(q.get()[1:])\n        \n        return closest\n        \n        \n            \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        li = []\n        \n        class Point:\n            def __init__(self, x, y):\n                self.x = x\n                self.y = y\n            def distance_square(self):\n                return self.x * self.x + self.y * self.y\n        \n            def __lt__(self, other):\n                return self.distance_square() < other.distance_square()\n            \n        \n        \n        \n        for p in points:\n            x = p[0]\n            y = p[1]\n            pt = Point(x, y)\n            heapq.heappush(li,pt)\n        \n        result_p = [heapq.heappop(li) for i in range(K)]\n        result = [ [p.x, p.y] for p in result_p ]\n        return result\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def get_distance(point):\n            return point[0] ** 2 + point[1] ** 2\n        \n        def helper(i, j, K):\n            if i >= j:\n                return\n            pivot_index = random.randint(i, j)\n            points[j], points[pivot_index] = points[pivot_index], points[j]\n            mid = partition(i, j)\n            if mid == K - 1:\n                return\n            elif mid < K - 1:\n                helper(mid + 1, j, K)\n            else:\n                helper(i, mid - 1, K)\n        \n        def partition(i, j):\n            left, right = i, j\n            pivot_distance = get_distance(points[j])\n            for k in range(left, right):\n                if get_distance(points[k]) < pivot_distance:\n                    points[i], points[k] = points[k], points[i]\n                    i += 1\n            points[i], points[j] = points[j], points[i]\n            return i\n        \n        helper(0, len(points) - 1, K)\n        return points[:K]\n        \n        \n        \n#         def get_distance(point):\n#             return point[0] ** 2 + point[1] ** 2\n        \n#         def helper(i, j, K):\n#             if i >= j:\n#                 return\n#             pivot_index = random.randint(i, j)\n#             points[j], points[pivot_index] = points[pivot_index], points[j]\n#             mid = partition(i, j)\n#             if mid - i + 1 == K:\n#                 return\n#             elif mid - i + 1 < K:\n#                 helper(mid + 1, j, K - (mid - i + 1))\n#             else:\n#                 helper(i, mid - 1, K)\n        \n#         def partition(i, j):\n#             left, right = i, j\n#             pivot_distance = get_distance(points[j])\n#             for k in range(left, right):\n#                 if get_distance(points[k]) < pivot_distance:\n#                     points[i], points[k] = points[k], points[i]\n#                     i += 1\n#             points[i], points[j] = points[j], points[i]\n#             return i\n        \n#         helper(0, len(points) - 1, K)\n#         return points[:K]\n", "from queue import PriorityQueue\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pq = PriorityQueue()\n        # furthest = 0\n        for p in points:\n            distance = -1 * ((p[0] * p[0]) + (p[1] * p[1]))\n            # print(distance, p)\n            if pq.qsize() < K:\n                pq.put((distance, p))\n                # furthest = min(furthest, distance)\n            else:\n                # if distance < furthest:\n                pq.put((distance, p))\n                pq.get()\n        \n        ans = []\n        while pq.qsize():\n            (distance, p) = pq.get()\n            ans.append(p)\n        \n        return ans", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        def norm(point):\n            return (point[0]**2+point[1]**2)\n        \n        dis=[]\n        for point in points:\n            dis.append(norm(point))\n      \n        dis, points=list(zip(*sorted(zip(dis,points))))\n        \n        res=[]\n        for i in range(K):\n            res.append(points[i])\n        return res\n            \n", "import heapq\ndef getDistance(point):\n        return point[0]**2 + point[1]**2\n    \nclass Solution:\n    def swap(self, i, j):\n        tmp = self.points[i]\n        tmp_dist = self.dist[i]\n        \n        self.points[i] = self.points[j]\n        self.points[j] = tmp\n        \n        self.dist[i] = self.dist[j]\n        self.dist[j] = tmp_dist\n        \n    def partition(self, start, end, pivot):\n        self.swap(0, pivot)\n        \n        left = 1\n        right = end\n        while left <= right:\n            if self.dist[left] > self.dist[0]:\n                self.swap(left, right)\n                right -= 1\n            else:\n                left += 1\n                \n        self.swap(0, right)\n        \n        return right\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        n = len(points)\n        if n <= K: return points\n        \n        self.points = points\n        self.dist = []\n        \n        for i in range(n):\n            self.dist.append(getDistance(points[i]))\n        # print(self.dist)\n        start = 0\n        end = n - 1\n        pivot = self.partition(0, n - 1, K)\n        # print(pivot, self.dist)\n        while pivot != K:\n            if pivot < K:\n                start = pivot + 1\n            else:\n                end =  pivot - 1\n            pivot = self.partition(start, end, start)\n        \n            # print(pivot)\n        \n        res = []\n        \n        # print(self.dist)\n        return self.points[0:K]\n                \n            \n            \n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for (x,y) in points:\n            dist = -(x**2 + y**2)\n            if len(heap) == K:\n                heapq.heappushpop(heap, (dist, x, y))\n            else:\n                heapq.heappush(heap, (dist, x, y))\n        return [(x,y) for (dist, x, y) in heap]\n        \n        \n        \n# import heapq\n\n# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n#         heap = []\n        \n#         for (x, y) in points:\n#             dist = -(x*x + y*y)\n#             if len(heap) == K:\n#                 heapq.heappushpop(heap, (dist, x, y))\n#             else:\n#                 heapq.heappush(heap, (dist, x, y))\n        \n#         return [(x,y) for (dist,x, y) in heap]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        d={}\n        ans=[]\n        points = sorted(points, key= lambda x:((x[0]**2)+(x[1]**2)))\n        for i in range(K):\n            ans.append(points[i])\n        return ans\n", "import math  \n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        a = []\n        for i in range(len(points)):\n            a.append([math.sqrt(pow(points[i][0], 2) + pow(points[i][1], 2)),                  [points[i][0], points[i][1]]])\n        a.sort(key=lambda x:x[0])\n        print(a)\n        l = []\n        for j in range(K):\n            l.append(a[j][1])\n        return l\n            \n            \n            \n", "import heapq\ndef getDistance(point):\n        return point[0]**2 + point[1]**2\n    \nclass Solution:\n    def swap(self, i, j):\n        tmp = self.points[i]\n        tmp_dist = self.dist[i]\n        \n        self.points[i] = self.points[j]\n        self.points[j] = tmp\n        \n        self.dist[i] = self.dist[j]\n        self.dist[j] = tmp_dist\n        \n    def partition(self, start, end, pivot):\n        self.swap(0, pivot)\n        \n        left = 1\n        right = end\n        while left <= right:\n            if self.dist[left] > self.dist[0]:\n                self.swap(left, right)\n                right -= 1\n            else:\n                left += 1\n                \n        self.swap(0, right)\n        \n        return right\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        n = len(points)\n        if n <= K: return points\n        \n        self.points = points\n        self.dist = []\n        \n        for i in range(n):\n            self.dist.append(getDistance(points[i]))\n        # print(self.dist)\n        start = 0\n        end = n - 1\n        pivot = self.partition(0, n - 1, K)\n        # print(pivot, self.dist)\n        while pivot != (K-1):\n            if pivot < (K-1):\n                start = pivot + 1\n            else:\n                end =  pivot - 1\n            pivot = self.partition(start, end, start)\n        \n            # print(pivot)\n        \n        res = []\n        \n        # print(self.dist)\n        return self.points[0:K]\n                \n            \n            \n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def distance(point):\n            return (point[0] ** 2 + point[1] ** 2)\n        \n        return sorted(points, key=distance)[:K]\n        \n#         h = []\n#         for i, p in enumerate(points):\n#             if len(h) == K:\n#                 heapq.heappushpop(h, (distance(p), i, p))\n#             else:\n#                 heapq.heappush(h, (distance(p), i, p))\n                \n#         out = []\n#         for tup in h:\n#             out.append(tup[2])\n            \n#         return out\n", "class DistanceSort(List[int]):\n    \n    def __lt__(lhs, rhs):\n        ldiff = lhs[0]*lhs[0] + lhs[1]*lhs[1]\n        rdiff = rhs[0]*rhs[0] + rhs[1]*rhs[1]\n        return ldiff < rdiff\n    \nclass Solution:\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        return sorted(points, key=DistanceSort)[:K]\n        \n\\\"\\\"\\\"\n\\\"\\\"\\\"", "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        from queue import PriorityQueue as pq\n        distance_points = [(-1 * ((x**2 + y**2) ** .5), [x,y]) for x,y in points]\n        q = pq()\n        for item in distance_points:\n            if q.qsize() < k:\n                q.put(item) \n            else:\n                distance, _ = item\n                popped = q.get()\n                popped_distance, _ = popped\n                if distance > popped_distance:\n                    q.put(item)\n                else:\n                    q.put(popped)\n        return [q.get()[1] for _ in range(k)]\n                \n            \n", "import heapq\ndef getDistance(point):\n        return point[0]**2 + point[1]**2\n    \nclass Solution:\n    def swap(self, i, j):\n        tmp = self.points_idx[i]\n        tmp_dist = self.dist[i]\n        \n        self.points_idx[i] = self.points_idx[j]\n        self.points_idx[j] = tmp\n        \n        self.dist[i] = self.dist[j]\n        self.dist[j] = tmp_dist\n        \n    def partition(self, start, end, pivot):\n        self.swap(0, pivot)\n        \n        left = 1\n        right = end\n        while left <= right:\n            if self.dist[left] > self.dist[0]:\n                self.swap(left, right)\n                right -= 1\n            else:\n                left += 1\n                \n        self.swap(0, right)\n        \n        return right\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        n = len(points)\n        if n <= K: return points\n        \n        self.points_idx = [i for i in range(n)]\n        self.dist = []\n        \n        for i in range(n):\n            self.dist.append(getDistance(points[i]))\n        # print(self.dist)\n        start = 0\n        end = n - 1\n        pivot = self.partition(0, n - 1, K)\n        # print(pivot, self.dist)\n        while pivot != (K-1):\n            if pivot < (K-1):\n                start = pivot + 1\n            else:\n                end =  pivot - 1\n            pivot = self.partition(start, end, start)\n        \n            # print(pivot)\n        \n        res = [points[idx] for idx in self.points_idx[0:K]]\n        \n\n        return res\n                \n            \n            \n", "from heapq import heappop, heappush, heapify\nclass Solution:\n    def distFromOrigin(self,x,y):\n        return sqrt(x**2 + y**2)\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for point in points:\n            dist = self.distFromOrigin(point[0],point[1])\n            if len(heap) == K:\n                if dist < -heap[0][0]:\n                    heappop(heap)\n                    heappush(heap, (-dist, point))\n            else:\n                heappush(heap, (-dist, point))\n        \n        output = []\n        for item in heap:\n            output.append(item[1])\n        return output\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if not points or not K:\n            return []\n        \n        distances = []\n        disMap = defaultdict(list)\n        maxKDis = float('-inf')\n        for point in points:\n            dis = (point[0] ** 2 + point[1] ** 2) ** 0.5\n            disMap[dis].append(point)\n            if len(distances) < K:\n                distances.append(dis)\n                maxKDis = max(maxKDis, dis)\n            elif len(distances) >= K and dis < maxKDis:\n                distances.sort()\n                distances.pop()\n                distances.append(dis)\n                maxKDis = max(distances[-2:])\n\n        res = []\n        for dis in distances:\n            res.extend(disMap[dis])\n            \n        return res[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        point_distance = dict()\n        distance_list = []\n        \n        for x, y in points:\n            distance = sqrt(x**2 + y**2)\n            heappush(distance_list, distance)\n            if distance in list(point_distance.keys()):\n                point_distance[distance].append([x,y])\n            else:\n                point_distance[distance] = [[x,y]]\n            \n        result = []\n        while K > 0:\n            tmp = point_distance[heappop(distance_list)]\n            K-= len(tmp)\n            result = result + tmp\n            \n        return result\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for x,y in points:\n            dis2 = x**2 + y**2\n            if len(heap)<K:\n                heapq.heappush(heap, (-dis2, (x,y)))\n            else:\n                if -dis2>heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap,(-dis2,(x,y)))\n        ans = []\n        for i in range(K):\n            x,y = heapq.heappop(heap)[1]\n            ans = [[x, y]] + ans\n        return ans", "from queue import PriorityQueue\nimport math\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        queue = PriorityQueue()\n        \n        for point in points:\n            queue.put((math.sqrt((point[0])**2 + (point[1])**2), point))\n            \n        ans = []\n        \n        for i in range(K):\n            ans.append(queue.get()[1])\n        return ans", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        point_distance = dict()\n        distance_list = []\n        \n        for x, y in points:\n            distance = -sqrt(x**2 + y**2)\n            if len(distance_list) < K:\n                heappush(distance_list, distance)\n                if distance in list(point_distance.keys()):\n                        point_distance[distance].append([x,y])\n                else:\n                    point_distance[distance] = [[x,y]]\n            else:\n                if distance_list[0] < distance:\n                    to_remove = distance_list[0]\n                    if len(point_distance[to_remove]) == 1:\n                        del point_distance[to_remove]\n                    else:\n                        point_distance[to_remove].pop()\n                    heappop(distance_list)\n                    heappush(distance_list, distance)\n                    if distance in list(point_distance.keys()):\n                        point_distance[distance].append([x,y])\n                    else:\n                        point_distance[distance] = [[x,y]]\n\n        result = []\n        while K > 0:\n            tmp = point_distance[heappop(distance_list)]\n            K-= len(tmp)\n            result = result + tmp\n            \n        return result\n", "from heapq import heappop,heappush,heapify\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        l1=[]\n        l2=[]\n        heapify(l1)\n        for i in range(0,len(points)):\n            heappush(l1, (-1*(points[i][0]*points[i][0] + points[i][1]*points[i][1]),i))\n            if len(l1) > K:\n                heappop(l1)\n        while(len(l1) > 0):\n            i = heappop(l1)\n            l2.append(points[i[1]])\n        return l2\n                    \n        \n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n\n        heap = []\n\n        for (x, y) in points:\n            dist = -(x*x + y*y)\n            if len(heap) == K:\n                heapq.heappushpop(heap, (dist, x, y))\n            else:\n                heapq.heappush(heap, (dist, x, y))\n\n        return [(x,y) for (dist,x, y) in heap]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def distance(point):\n            return (point[0]**2 + point[1]**2)**(0.5)\n\n        def partition(left, right, pivot_index):\n            pivot = points[pivot_index]\n            # move the pivot to the position of right first\n            points[pivot_index], points[right] = points[right], points[pivot_index]\n\n            store_index = left\n            for i in range(left, right):\n                if distance(points[i]) < distance(pivot):\n                    points[store_index], points[i] = points[i], points[store_index]\n                    store_index += 1\n            \n            # move the pivot back to its correct position:\n            # such that all elements on the left are smaller, and elements on the right have larger distance to origin.\n            points[store_index], points[right] = points[right], points[store_index]\n            \n            return store_index\n        \n        left, right = 0, len(points)-1\n        while True:\n            pivot_index = random.randint(left, right)\n            M = partition(left, right, pivot_index)\n            if M == K-1:\n                break\n            elif M < K-1:\n                left = M + 1\n            else:\n                right = M - 1\n                \n        return points[:K]", "import heapq\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        heap = []\n        \n        for x, y in points:\n            dist = -(x*x + y*y)\n            \n            if len(heap) == K:\n                heapq.heappushpop(heap, (dist, x, y))\n            else:\n                heapq.heappush(heap, (dist, x, y))\n            \n        return [[x,y] for dist, x, y in heapq.nlargest(K, heap)]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\n        def quicksort(points,K): # points: list of index\n            print(points, K)\n            if not points:\n                return\n            # pivot = points[random.randint(0,len(points)-1)]\n\n            pivot = points[-1]\n            l,r,m=[],[],[]\n            for i in points:\n                if dist(i) == dist(pivot):\n                    m.append(i)\n                elif dist(i) < dist(pivot):\n                    l.append(i)\n                else:\n                    r.append(i)\n            if len(l) >= K:\n                return quicksort(l, K)\n            elif len(l) < K <= len(l)+len(m):\n                return l+m[:K-len(l)]\n            else:\n                return l+m+quicksort(r, K-len(l)-len(m))\n        return [points[i] for i in quicksort([i for i in range(len(points))], K)]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        self.sort(0, len(points) - 1, points, K)\n        return points[:K]\n\n    def getDistance(self, a):\n        return a[0] ** 2 + a[1] ** 2\n\n    def sort(self, l, r, points, K):\n        if l >= r:\n            return \n        mid = self.partition(l, r, points)\n        if (mid - l + 1) < K:\n            self.sort(mid + 1, r, points, K - (mid - l + 1))\n        else:\n            self.sort(l, mid - 1, points, K)\n    \n    def partition(self, i, j, points):\n        pivot = self.getDistance(points[i])\n        l = i\n        r = j\n        while True:\n            while l <= r and self.getDistance(points[l]) <= pivot:\n                l += 1\n            while l <= r and self.getDistance(points[r]) > pivot:\n                r -= 1\n            if l >= r:\n                break\n            points[l], points[r] = points[r], points[l]\n        points[i], points[r] = points[r], points[i]\n        return r\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        # edge case\n        if not points:\n            return []\n        \n        def distance(x, y):\n            \n            # Euclidean distance\n            return ((x - 0)**2 + (y - 0)**2)**0.5\n        \n        def binsea_insert(dist, point):\n            \n            # if empty, just insert and return\n            if not nearest:\n                nearest.append((dist, point))\n                return\n            \n            left, right = 0, len(nearest) -1\n            \n            while left <= right:\n                \n                # unpack tuple \n                d, coor = nearest[right]\n                if dist >= d:\n                    nearest.insert(right + 1, (dist, point))\n                    return\n                    \n                # unpack tuple \n                d, coor = nearest[left]\n                    \n                if dist <= d:\n                    nearest.insert(left, (dist, point))\n                    return\n                    \n                    \n                \n                mid = left + (right - left) // 2\n                \n                # unpack tuple \n                d, coor = nearest[mid]\n                \n                if dist < d:\n                    right = mid - 1\n                \n                else:\n                    left = mid + 1\n            \n\n        # sorted list of tuples\n        nearest = []\n        \n        for point in points:\n            x, y = point\n            binsea_insert(distance(x, y), point)\n            \n        print(nearest)            \n        results = []\n        for k in range(K):\n            if k < len(nearest):\n                d, point = nearest[k]\n                results.append(point)\n                \n        return results\n            \n            \n            \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = [(float('-Inf'), 0, 0)]*K\n        for x, y in points:\n            heapq.heappushpop(heap, (-x**2-y**2, x, y))\n        res = []\n        while heap:\n            val, row, col = heapq.heappop(heap)\n            res.append([row, col])\n        return res", "from collections import defaultdict\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dic = defaultdict(list)\n        for i in range(len(points)):\n            distance = points[i][0] ** 2 + points[i][1] ** 2\n            dic[distance].append(points[i])\n\n        dis_list = sorted(dic.keys())\n        ans = []\n        \n        for i in dis_list:\n            ans.extend(dic[i])\n        \n        return ans[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points = [[i ** 2 + j ** 2, i, j] for i, j in points]\n        \n        def quickSelect(l, r):\n            p = l\n            for i in range(l, r):\n                if points[i][0] < points[r][0]:\n                    points[p], points[i] = points[i], points[p]\n                    p += 1\n            points[r], points[p] = points[p], points[r]\n            if p == K - 1: return\n            elif p > K - 1: quickSelect(l, p - 1)\n            else: quickSelect(p + 1, r)\n        quickSelect(0, len(points) - 1)\n        return [[i, j] for _, i, j in points[:K]]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        for i in range(len(points)):\n            points[i].insert(0,(points[i][0]**2+points[i][1]**2)**0.5)\n        points.sort()\n        ans=[]\n        for i in range(K):\n            ans.append(points[i][1:])\n            \n        return(ans)", "import math\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda p : p[0]**2+p[1]**2)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        \n        for x,y in points:\n            if len(heap)<K:\n                heapq.heappush(heap,[-(x*x+y*y),[x,y]])\n            else:\n                heapq.heappushpop(heap,[-(x*x+y*y),[x,y]])\n        return [pair for value, pair in heap]", "import math\nfrom queue import PriorityQueue\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # dist_map = dict()\n        # for point in points:\n        #     dist_map[tuple(point)] = math.sqrt((0-abs(point[0]))**2 + (0-abs(point[1]))**2)\n        # closest_points = sorted(dist_map.items(), key=lambda x: x[1])\n        # return [i[0] for i in list(closest_points)[:K]]\n        pq = PriorityQueue()\n        for point in points:\n            dist = math.sqrt((0-abs(point[0]))**2 + (0-abs(point[1]))**2)\n            pq.put((dist, tuple(point)))\n        i = 0\n        res = []\n        while pq and i < K:\n            res.append(pq.get()[1])\n            i += 1\n        return res", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        # points = sorted(points, key = lambda x: x[0]**2 + x[1]**2)\n        # return points [:K]\n        shuffle(points)\n        \n        distance_dict = dict()\n        \n        def distance(xy):\n            xy = tuple(xy)\n            if xy in distance_dict:\n                return distance_dict[xy]\n            ans = xy[0]**2 + xy[1]**2\n            distance_dict[xy] = ans\n            return ans\n    \n        def _quicksort(points, left, right):\n                        \n            if left>right:\n                return\n            \n            pivot = right\n            lower = left\n            for i in range(left, right):\n                if distance(points[i]) <= distance(points[pivot]):\n                    points[lower], points[i] = points[i], points[lower]\n                    lower = lower + 1\n            \n            pivot = lower\n            points[pivot], points[right] = points[right], points[pivot]\n                        \n            if (K-1) <= pivot:\n                _quicksort(points, left, pivot-1)\n            else:\n                _quicksort(points, left, pivot-1)\n                _quicksort(points, pivot+1, right)\n            \n            return\n        \n        _quicksort(points, 0, len(points)-1)\n\n        return points[:K]", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        max_heap =[]\n        for i in range(len(points)):\n            sqrt = (points[i][0]**2 + points[i][1]**2)\n            heapq.heappush(max_heap,[sqrt,points[i]])\n    \n        res = []\n        for i in range(K):\n            temp = heapq.heappop(max_heap)\n            res.append(temp[1])\n        return res\n            \n            \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        output = []\n        \n        for i in range(len(points)): \n            distance = (points[i][0]**2) + (points[i][1]**2)\n            heapq.heappush(heap, (distance, points[i]))\n        \n        for i in range(K): \n            add = (heapq.heappop(heap))\n            output.append(add[1])\n        \n        return output\n        \n                  \n", "import random\nimport math\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        euclidean = lambda x: math.sqrt(x[0]**2 + x[1]**2)\n        \n        def topK(arr, l, r, k):\n            if l >= r:\n                return\n            \n            choice = random.randint(l, r)\n            arr[l], arr[choice] = arr[choice], arr[l]\n            \n            tl, tr = l+1, r\n            while tl <= tr:\n                if euclidean(arr[tl]) < euclidean(arr[l]):\n                    tl += 1\n                    continue\n                if euclidean(arr[tl]) >= euclidean(arr[l]):\n                    arr[tl], arr[tr] = arr[tr], arr[tl]\n                    tr -= 1\n                    continue\n            arr[l], arr[tr] = arr[tr], arr[l]\n            \n            partition = tr\n            \n            if (partition-l+1) <= k:\n                topK(arr, partition+1, r, k-(partition-l+1))\n            else:\n                topK(arr, l, partition-1, k)\n                \n        \n        topK(points, 0, len(points)-1, K)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        # points = sorted(points, key = lambda x: x[0]**2 + x[1]**2)\n        # return points [:K]\n        \n        distance_dict = dict()\n        \n        def distance(xy):\n            xy = tuple(xy)\n            if xy in distance_dict:\n                return distance_dict[xy]\n            ans = xy[0]**2 + xy[1]**2\n            distance_dict[xy] = ans\n            return ans\n    \n        def _quicksort(points, left, right):\n                        \n            if left>right:\n                return\n            \n            pivot = right\n            lower = left\n            for i in range(left, right):\n                if distance(points[i]) <= distance(points[pivot]):\n                    points[lower], points[i] = points[i], points[lower]\n                    lower = lower + 1\n            \n            pivot = lower\n            points[pivot], points[right] = points[right], points[pivot]\n                        \n            if (K-1) <= pivot:\n                _quicksort(points, left, pivot-1)\n            else:\n                _quicksort(points, left, pivot-1)\n                _quicksort(points, pivot+1, right)\n            \n            return\n        \n        _quicksort(points, 0, len(points)-1)\n\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distant = [[point,point[0]**2+point[1]**2] for point in points]\n        distant.sort(key = itemgetter(1))\n        res = [distant[i][0] for i in range(K)]\n        return res\n", "import random\nimport math\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        euclidean = lambda x: math.sqrt(x[0]**2 + x[1]**2)\n        \n        def topK(arr, l, r, k):\n            if l >= r:\n                return\n            \n            choice = random.randint(l, r)\n            arr[l], arr[choice] = arr[choice], arr[l]\n            \n            tl, tr = l+1, r\n            # print(tl, tr, arr[l])\n            # print(arr)\n            while tl <= tr:\n                if euclidean(arr[tl]) < euclidean(arr[l]):\n                    tl += 1\n                    continue\n                if euclidean(arr[tl]) >= euclidean(arr[l]):\n                    # print(\\\"Swapping\\\", tl, tr)\n                    arr[tl], arr[tr] = arr[tr], arr[tl]\n                    tr -= 1\n                    continue\n            arr[l], arr[tr] = arr[tr], arr[l]\n            # print(\\\"Swapping\\\", l, tr)\n            # print(arr)\n            \n            partition = tr\n            \n            if (partition-l+1) <= k:\n                topK(arr, partition+1, r, k-(partition-l+1))\n            else:\n                topK(arr, l, partition-1, k)\n                \n                        \n            \n                    \n                \n        \n        topK(points, 0, len(points)-1, K)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        self.sort(0, len(points) - 1, points, K)\n        return points[:K]\n\n    def getDistance(self, a):\n        # print(a)\n        return a[0] ** 2 + a[1] ** 2\n\n    def sort(self, l, r, points, K):\n        if l >= r:\n            return \n        mid = self.partition(l, r, points)\n        if (mid - l + 1) < K:\n            self.sort(mid + 1, r, points, K - (mid - l + 1))\n        else:\n            self.sort(l, mid - 1, points, K)\n    \n    def partition(self, i, j, points):\n        pivot = self.getDistance(points[i])\n        l = i\n        r = j\n        while True:\n            while l <= r and self.getDistance(points[l]) <= pivot:\n                l += 1\n            while l <= r and self.getDistance(points[r]) > pivot:\n                r -= 1\n            if l >= r:\n                break\n            points[l], points[r] = points[r], points[l]\n        points[i], points[r] = points[r], points[i]\n        return r\n", "class Solution:\n    def calculateEuclidean(self, point):\n        return (point[0]) ** 2 + (point[1]) ** 2\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        \n        \n        for point in points:\n            heapq.heappush(heap, (-self.calculateEuclidean(point), point))\n            \n            if len(heap) > K:\n                heapq.heappop(heap)\n        \n        return [point[1] for point in heap]", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        arr = [(-1 * (p[0] ** 2 + p[1] ** 2), p) for p in points]\n        heap = arr[:K]\n        heapq.heapify(heap)\n        for p in arr[K:]:\n            heapq.heappushpop(heap, p)\n        return [coord for distance, coord in heap]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dist = [(x**2 + y**2, [x,y]) for x, y in points]\n        \n        self.partition(dist, K, 0, len(dist) - 1)\n        \n        return [elem[1] for elem in dist[:min(K, len(dist))]]\n    \n    \\\"\\\"\\\"\n    [035476]\n    pivot = 6\n    \n    \n    \n    \\\"\\\"\\\"\n    def partition(self, dist, K, start, end):\n        if start == end:\n            return\n        mid = (start + end)//2\n        pivot = dist[mid][0]\n        left, right = start, end\n    \n        while left <= right:\n            while left <= right and dist[left][0] < pivot:\n                left += 1\n            while left <= right and dist[right][0] > pivot:\n                right -= 1\n            if left <= right:    \n                dist[left], dist[right] = dist[right], dist[left]\n                left += 1\n                right -= 1\n            \n        if right - start >= K :\n            self.partition(dist, K, start, right)\n        if left - start < K:\n            self.partition(dist, K - (left - start), left, end)\n        \n        \n        ", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        arr = self.sortPoints(points)\n        return arr[:K]\n    \n    def sortPoints(self, points):\n        if len(points) <= 1:\n            return points\n        mid = len(points)//2\n        left = self.sortPoints(points[:mid])\n        right = self.sortPoints(points[mid:])\n        return self.merge(left,right)\n    \n    def merge(self, left,right):\n        arr, i, j = [], 0, 0\n        while i < len(left) and j < len(right):\n            xLeft, yLeft = left[i][0], left[i][1]\n            xRight, yRight = right[j][0], right[j][1]\n            leftDis = xLeft*xLeft + yLeft*yLeft\n            rightDis = xRight*xRight + yRight*yRight\n\n            if leftDis < rightDis:\n                arr.append(left[i])\n                i += 1\n            elif rightDis < leftDis:\n                arr.append(right[j])\n                j += 1\n            else:\n                arr.append(left[i])\n                arr.append(right[j])\n                i, j = i+1, j+1\n        while i < len(left):\n            arr.append(left[i])\n            i += 1\n        while j < len(right):\n            arr.append(right[j])\n            j += 1\n        return arr\n        \n    \n    \n    \n    \n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        point_map = {}\n        for point in points:\n            point_map[(point[0], point[1])] = (point[0]**2 + point[1]**2)\n\n        return [list(k) for k, v in sorted(point_map.items(), key=lambda kv: kv[1])[:K]]", "class Solution:\n    \\\"\\\"\\\"\n    Solution #1.\n    May 2020.\n    \n    Sort everything and then get the first k items.\n    T: O(NlogN).\n    \\\"\\\"\\\"\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[:k]    \n    \n    \\\"\\\"\\\"\n    Solution #2.\n    May 2020.\n    \n    Use a max-heap to store the k smallest items.\n    T: O(N log K).\n    \\\"\\\"\\\"\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        heap = []\n        \n        for x,y in points:\n            # We put the -ve sign becase we want this to be a max heap.\n            key = -(x**2 + y**2)\n            heapq.heappush(heap, (key, x, y))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        return [[x,y] for distance, x, y in heap]\n    \n    \\\"\\\"\\\"\n    Solution #3.\n    June 2020.\n    \n    Use QuickSelect.\n    T: O(N) in the average case; O(N^2) in the worst case.\n    \\\"\\\"\\\"\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        # random.shuffle(points)\n        self.quickSelect(points, k - 1, 0, len(points) - 1)\n        return points[:k]\n    \n    def quickSelect(self, points, k, p, q):\n        partitionIndex  = self.partition(points, p, q)\n        if partitionIndex == k:\n            return partitionIndex\n        elif partitionIndex > k:\n            return self.quickSelect(points, k, p, partitionIndex  - 1)\n        else:\n            return self.quickSelect(points, k, partitionIndex + 1, q)\n                \n    # p <= k <= boundary: items that are smaller than the pivot.\n    # boundary + 1 <= < q: items that are bigger than the pivot.\n    def partition(self, points, p, q):\n        distancePivot = self.getSortingKey(points[q])\n        boundary = p - 1\n        \n        for j in range(p, q):\n            if self.getSortingKey(points[j]) < distancePivot:\n                boundary += 1\n                points[boundary], points[j] = points[j], points[boundary]\n        \n        # Insert the pivot in the correct position.\n        boundary += 1\n        points[boundary], points[q] = points[q], points[boundary]\n        \n        return boundary\n\n    def getSortingKey(self, p):\n        return p[0] ** 2 + p[1] ** 2", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        add_index = [tup + [idx] for (tup, idx) in zip(points,list(range(len(points))))]\n        print(add_index)\n        sorted_by_second = sorted(add_index, key=lambda tup: sqrt(tup[1]**2 + tup[0]**2))\n        res = []\n        for i in range(K):\n            res += [sorted_by_second[i][:2]]\n        return res\n", "\nclass Solution:\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        squared = [round((x[0]**2 + x[1]**2)**(1/2),2) for x in points]\n        self.heapSort(points, squared)\n        result = []\n        \n        for i in range(K):\n            result.append(points[i])\n        return result\n    \n    def heapify(self, points, squared, n, i):\n        \n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n        \n        if l < n and squared[l] > squared[largest]:\n            largest = l\n        \n        if r < n and squared[r] > squared[largest]:\n            largest = r\n            \n        if largest != i:\n            squared[largest], squared[i] = squared[i], squared[largest]\n            points[largest], points[i] = points[i], points[largest]\n            \n            self.heapify(points, squared, n, largest)\n            \n    def heapSort(self, points, squared):\n        n = len(squared)\n        \n        for i in range( n // 2 - 1, -1, -1):\n            self.heapify(points, squared, n, i)\n            \n        for i in range(n-1, 0, -1):\n            squared[i], squared[0] = squared[0], squared[i]\n            points[i], points[0] = points[0], points[i]\n            self.heapify(points, squared, i, 0)\n            \n        # Solution_1\n#         min_dist = []\n        \n#         def calculate_sqrt(x):\n#             return round(math.sqrt(x[0]**2 + x[1]**2), 2)\n        \n#         for i in range(0, len(points)):\n            \n#             min_dist.append((calculate_sqrt(points[i]), points[i]))\n        \n#         min_dist = sorted(min_dist)\n        \n       \n        \n        \n#         return [min_dist[i][1] for i in range(K) ]\n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        heap = []\n        \n        for p in points:\n            dist = -(p[0]*p[0] + p[1]*p[1])\n            heapq.heappush(heap, (dist, p[0], p[1]))\n            \n            if len(heap) > K:\n                heapq.heappop(heap)\n        \n        res = [[p[1], p[2]] for p in heap]\n        return res\n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key=lambda p:(p[0]*p[0] + p[1]*p[1]))\n        return points[:K]\n", "import heapq\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for point in points:\n            dist = point[0] * point[0] + point[1] * point[1]\n            heapq.heappush(heap, (-dist, point))\n            if len(heap) > K:\n                heapq.heappop(heap)\n        \n        return [tuple[1] for tuple in heap]\n\n#         left = 0\n#         right = len(points) - 1\n#         while left <= right:\n#             mid = self.helperPivot(left, right, points)\n#             if mid == K:\n#                 break\n#             if mid < K:\n#                 left = mid+1\n#             else:\n#                 right = mid - 1\n#         return points[:K]\n             \n    \n#     def helperPivot(self,start, end, points):\n#         def dist(point):\n#             return point[0]**2 + point[1]**2\n#         pivot = start\n#         left = start + 1\n#         right = end\n#         while left <= right:\n#             if dist(points[left]) > dist(points[pivot]) and dist(points[right]) < dist(points[pivot]):\n#                 #swap\n#                 points[left], points[right] = points[right], points[left]\n#             if dist(points[left]) <= dist(points[pivot]):\n#                 left += 1\n#             if dist(points[right]) >= dist(points[pivot]):\n#                 right -=1\n#         #right is the correct position of pivot\n#         points[pivot], points[right] = points[right], points[pivot]\n#         return right\n            \n    \n                    \n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # given a list of x, y, return the smallest Kth  x^2 +y^2 pairs\n        # need to maintain a Max heap of length K\n        # BUT, Python does not support Max heap from heapq\n        # We are going to x -1 to the distance and use a min heapp\n\n        pq=[]\n        for x, y in points:\n            if len(pq)<K:\n                heapq.heappush(pq, (-x*x-y*y,[x,y])) # (distance, [coordinate])\n            else: \n                small_distance, small_coordinate = heapq.heappop(pq)\n                if -x*x-y*y > small_distance:\n                    heapq.heappush(pq, (-x*x-y*y,[x,y]))\n                else:\n                    heapq.heappush(pq, (small_distance,small_coordinate))\n\n        \n        return [_[1] for _ in pq]", "import operator\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        res = []\n        dict_m = {}\n        for i in range(len(points)):\n            pt = points[i]\n            tmp = (pt[0] ** 2 + pt[1] ** 2)\n            dict_m[i] = tmp\n        sorted_m = sorted(list(dict_m.items()), key = operator.itemgetter(1))\n        tmp = [t[0] for t in sorted_m]\n        res = [points[tmp[i]] for i in range(K)]\n        print(res)\n        return res \n        # sorted_m.keys()\n        # return res\n        # res = sorted(res)\n        # print(res)\n        # return res[:K]\n", "class Solution:\n    from collections import defaultdict\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distDict = defaultdict(list)\n        \n        for point in points:\n            dist = point[0]**2 + point[1]**2\n            distDict[dist].append(point)\n            \n        sortedKey = sorted(distDict.keys())\n        \n        rst = []\n        for key in sortedKey:\n            numOfPairs = len(distDict[key])\n            if(numOfPairs < K):\n                K -= numOfPairs\n                rst += distDict[key]\n            elif(numOfPairs >= K):\n                rst += distDict[key][:K]\n                return rst", "import random\n\nclass Solution:\n    def kClosest(self, nums: List[List[int]], k: int) -> List[List[int]]:\n        dist =[]\n        for i in range(len(nums)):\n            dist.append(nums[i][0] **2 + nums[i][1] **2)\n        #Create a hMap\n        hMap={}\n        for i in range(len(dist)):\n            hMap[i] = dist[i]\n            \n        unique_ids = list(hMap.keys())\n        \n        def helper(unique_ids,k,start,end):\n            if start >= end:\n                return\n            pivot_idx = random.randint(start,end)\n            \n            unique_ids[start],unique_ids[pivot_idx] = unique_ids[pivot_idx], unique_ids[start]\n            \n            pivot = hMap[unique_ids[start]]\n            \n            smaller = start\n            \n            for bigger in range(start+1, end+1):\n                if hMap[unique_ids[bigger]] <= pivot:\n                    smaller +=1\n                    unique_ids[smaller], unique_ids[bigger] = unique_ids[bigger],unique_ids[smaller]\n                    \n            unique_ids[start], unique_ids[smaller] = unique_ids[smaller],unique_ids[start]\n            \n            if k == smaller:\n                return \n            elif k < smaller:\n                helper(unique_ids,k,start,smaller-1)\n            else:\n                helper(unique_ids,k,smaller+1,end)\n                \n                \n        \n        helper(unique_ids,k,0,len(unique_ids)-1)\n        return [nums[i] for i in unique_ids[:k]]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        pq = []\n        \n        def distance(point):\n            return ( point[0]*point[0] + point[1]*point[1])\n        for index, point in enumerate(points):\n            heapq.heappush(pq,(distance(point),index,point))\n            \n        ans = []  \n        k=0\n        while pq and k<K:\n            _,_,point = heapq.heappop(pq)\n            ans.append(point)\n            k+=1\n        \n        return ans\n", "from heapq import *\nclass Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        maxHeap = []\n        for i in range(k):\n            heappush(maxHeap, [-self.distance(points[i]), points[i]])\n        for j in range(k, len(points)):\n            if maxHeap[0][0] < -self.distance(points[j]):\n                heappop(maxHeap)\n                heappush(maxHeap, [-self.distance(points[j]), points[j]])\n        return [points for (distance, points) in list(maxHeap)]\n            \n    def distance(self, coord):\n        return coord[0]**2 + coord[1]**2", "# use maxheap for nlogk\n\n# Time - O(NlogN), Space - O(N)\n# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n#         points.sort(key = lambda points: points[0]**2 + points[1]**2)\n#         return points[:K]\n    \n# Time - O(Nlogn), Space - O(N)\nimport heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        ans = []\n        min_heap = []\n        for pnt in points:\n            heapq.heappush(min_heap, (pnt[0]**2+pnt[1]**2, pnt))\n        for i in range(K):\n            ans.append(heapq.heappop(min_heap)[1])\n\n        return ans\n\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for i, p in enumerate(points):\n            x, y = p\n            dist = x**2 + y**2\n            heapq.heappush(heap, (-dist, i))\n            if len(heap) > K:\n                heapq.heappop(heap)\n                \n        res = []\n        for _, i in heap:\n            res.append(points[i])\n            \n        return res\n            \n", "import heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def get_distance(points):\n            return sqrt(points[0]**2 + points[1] **2)\n        dist = [[get_distance(point), point] for point in points]\n        heapq.heapify(dist)\n        ans = []\n        for i in range(K):\n            ans.append(heapq.heappop(dist)[1])\n        return ans        ", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key=lambda point: (point[0]*point[0])+(point[1]*point[1]))\n        return points[:K]", "from heapq import *\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        hp = []\n        n = len(points)\n        if K >= n:\n            return points\n        if K == 0:\n            return []\n        for x, y in points:\n            key = -(x**(2) + y**(2))\n            if len(hp) < K:\n                heappush(hp,(key,x,y))\n            else:\n                if -hp[0][0] > -key:\n                    heappop(hp)\n                    heappush(hp,(key,x,y))\n        ans = []\n        for _ in range(K):\n            key, x, y = heappop(hp)\n            ans.append([x,y])\n        return ans\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        nums=[]\n        heapq.heapify(nums)\n        def dist(x,y):\n            return (x**2+y**2)**0.5\n        for x,y in points:\n            heapq.heappush(nums,(-dist(x,y),[x,y]))\n            if len(nums)>K:\n                heapq.heappop(nums)\n        return [k[1] for k in nums]", "from collections import defaultdict\nfrom heapq import heapify, heappush, heappop\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        temp = []\n        for i in points:\n            dist = i[0]**2 + i[1]**2\n            temp.append([dist, [i[0],i[1]]])\n        heapify(temp)\n        res= []\n        for i in range(K):\n            res.append(heappop(temp)[1])\n        return res      \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def edistance(point):\n            d=sqrt(point[0]**2 + point[1]**2)\n            return d\n        result=[]\n        stk=[]\n        for point in points:\n            dis=edistance(point)\n            heapq.heappush(stk,[dis,point])\n        \n        while K>0:\n            result.append(heapq.heappop(stk)[1])\n            K-=1\n        return result\n", "from math import sqrt\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        sqrt_d = {}\n        \n        for x,y in points:\n            sqrt_d[(x,y)] = sqrt(x**2 + y**2)\n            \n        #print(sqrt_d)\n        return heapq.nsmallest(K, sqrt_d, key=lambda x: sqrt_d[x])", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for x,y in points:\n            dis2 = x**2 + y**2\n            if len(heap)<K:\n                heapq.heappush(heap, (-dis2, (x,y)))\n            else:\n                if -dis2>heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap,(-dis2,(x,y)))\n        ans = []\n        for i in range(K):\n            x,y = heapq.heappop(heap)[1]\n            # ans = [[x, y]] + ans\n            ans.append([x,y])\n        return ans[::-1]", "import math\nimport heapq\n\nclass Solution:\n    def getEuclideanDistance(self, p1):\n        return math.sqrt((p1[0])**2 + (p1[1])**2)\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        kheap = []\n        heapq.heapify(kheap)\n        size = 0\n        \n        for i,point in enumerate(points):\n            heapq.heappush(kheap,(-self.getEuclideanDistance(point), i))\n            size += 1\n            if size > K:\n                heapq.heappop(kheap)\n                \n        kpoints = []\n        while kheap:\n            dist, ind = heapq.heappop(kheap)\n            kpoints.append(points[ind])\n        return kpoints\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # data structure: heap\n        h = []\n        for point in points:\n            d = 0\n            for cor in point:\n                d += cor**2\n            h.append((d, point))\n            \n        ksmallests = heapq.nsmallest(K,h)\n        ret = []\n        for val,point in ksmallests:\n            ret.append(point)\n        return ret", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        heap = []\n        indices = {}\n        \n        for i in range(len(points)):\n            curr_point = points[i]\n            distance = math.sqrt(curr_point[0]**2 + curr_point[1]**2)\n            heapq.heappush(heap, distance)\n            if distance in list(indices.keys()):\n                indices[distance].append(i)\n            else:\n                indices[distance] = [i]\n        \n        result = []\n        i = 0\n        while i < K:\n            curr_distance = heapq.heappop(heap)\n            curr_indices = indices[curr_distance]\n            for index in curr_indices:\n                result.append(points[index])\n                i += 1\n        \n        return result\n                \n        \n        \n        \n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        return sorted(points, key=lambda x: (x[0]**2+x[1]**2))[:K]", "from collections import defaultdict\nimport math\nimport heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        lookup = defaultdict(list)\n        \n        for x, y in points:\n            distance = math.sqrt(x ** 2 + y ** 2)\n            lookup[distance].append([x, y])\n            heapq.heappush(heap, -distance)\n            if len(heap) > K:\n                heapq.heappop(heap)\n        result = []\n        for distance in heap:\n            result.append(lookup[-distance].pop())\n        return result", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        heap = []\n        for a,b in points:\n            if len(heap) < K:\n                heapq.heappush(heap, (-1*(a**2+b**2),[a,b]))\n            else:\n                heapq.heappushpop(heap, (-1*(a**2+b**2),[a,b]))\n        op = []\n        print(heap)\n        for i in range(K):\n            print(i)\n            op.append(heap[i][1])\n        return op", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        length = len(points)\n        if length <= K:\n            return points\n\n        # key: distance to origin\n        # value: list index in points\n        distances: Dict[int, List[int]] = defaultdict(list)\n        for i, li in enumerate(points):\n            distance = (li[0] ** 2 + li[1] ** 2) ** 0.5\n            distances[distance].append(i)\n\n        order = OrderedDict(sorted(distances.items()))\n        ans = []\n        for i, (key, value) in enumerate(order.items()):\n            for j in value:\n                ans.append(points[j])\n            if len(ans) >= K:\n                break\n        return ans[:K]", "class myObj:\n    def __init__(self, val, p):\n        self.val = val\n        self.p = p\n    def __lt__(self, other):\n        return self.val < other.val\n    \n    \nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def partition(arr, left, right):\n            i = left\n            for j in range(left, right):\n                if arr[j]<arr[right]:\n                    arr[i], arr[j] = arr[j], arr[i]\n                    i += 1\n            arr[i], arr[right] = arr[right], arr[i]\n            return i\n        \n        def sort(arr, left, right, K):\n            if left<right:\n                p = partition(arr, left, right)\n                if p==K:\n                    return\n                elif p<K:\n                    sort(arr, p+1, right, K)\n                else:\n                    sort(arr, left, p-1, K)\n        \n        dis = [0]*len(points)\n        for i in range(len(points)):\n            dis[i] = myObj(points[i][0]*points[i][0] + points[i][1]*points[i][1], points[i])\n        sort(dis, 0, len(points)-1, K)\n        \n        ans = []\n        for i in range(K):\n            ans.append(dis[i].p)\n        return ans", "from scipy.spatial import distance\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n            points.sort(key = lambda P: P[0]**2 + P[1]**2)\n            return points[:K]", "'''\n\n- preprocess, store (distance, (x,y))\n- init heap w/ k\n- push pop for the rest\n- return heap\n\n- O(k) + O(N-K log K) / O(n)\n- O(K log N) / O(n)\n\n'''\n# O(nlogk) / O(k)\nclass Point:\n    def __init__(self, pt):\n        self.distance = -1*sqrt(pt[0]**2+pt[1]**2)\n        self.pt = pt\n        \n    def __lt__(self, other):\n        return self.distance < other.distance\n        \n    def __eq__(self, other):\n        return self.distance == other.distance\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        heap = []\n        heapq.heapify(heap)\n        \n        for pt in points:\n            curr_pt = Point(pt)\n            \n            if len(heap) < K:\n                heapq.heappush(heap, curr_pt)\n            else:\n                heapq.heappushpop(heap, curr_pt)\n                \n        return [pt.pt for pt in heap]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:    \n        self.quickselect(points, K, 0, len(points)-1)\n        return points[:K]\n    \n    def quickselect(self, points, k, lo, high):\n        if lo >= high:\n            return\n        \n        pivot = self.partition(points, lo, high)\n        \n        if pivot+1 == k:\n            return\n        elif pivot < k:\n            self.quickselect(points, k, pivot+1, high)\n        else: \n            self.quickselect(points, k, lo, pivot-1)\n        \n    def partition(self, points, lo, high):\n        pivot = self.dist(points[high])\n        w = lo\n        \n        for r in range(lo, high):\n            if self.dist(points[r]) < pivot:\n                points[w], points[r] = points[r], points[w]\n                w+=1\n                \n        points[w], points[high] = points[high], points[w]\n        return w\n    \n    def dist(self, pt):\n        return pt[0]**2 + pt[1]**2", "\nclass Solution:    \n    def partition(self, nums, l, r):\n        pivot = nums[r]\n        i = l - 1\n        for j in range(l, r):\n            if nums[j] <= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1], nums[r] = nums[r], nums[i+1]\n        return i+1\n    \n    def selectSort(self, nums, l, r, k):\n        if l < r:\n            p = self.partition(nums, l, r)\n            if p == k:\n                return\n            elif k < p :\n                self.selectSort(nums, l, p-1, k)\n            else:\n                self.selectSort(nums, p+1, r, k)\n        \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dists = [math.sqrt(p[0] ** 2 + p[1] ** 2)  for p in points]\n        self.selectSort(dists, 0 , len(dists)-1, K)\n        print(dists)\n        out= []\n        if K == len(points):\n            return points\n        for p in points:\n            if math.sqrt(p[0] ** 2 + p[1] ** 2) < dists[K]:\n                out.append(p)\n        \n        return out\n                \n", "class Solution:\n    import math\n    def distance(self, point):\n        return math.sqrt(point[0]**2 + point[1]**2)\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distances = {}\n        for point in points:\n            distances[tuple(point)] = self.distance(point)\n        print(distances)\n        points_sorted = sorted(list(distances.keys()), key=lambda x: distances[x])\n        \n        return [list(i) for i in points_sorted[:K]]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda x: x[0]*x[0] + x[1]*x[1])\n        return points[:K]\n", "from numpy import argsort\nfrom numpy import array\nfrom numpy import sqrt\nfrom numpy import sum\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        p = array(points)\n        q = sqrt(sum(p ** 2, axis=1))\n        return p[argsort(q)[:K]]", "import numpy as np\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        p = np.array(points)\n        q = np.sqrt(np.sum(p ** 2, axis=1))\n        return p[np.argsort(q)[:K]]", "from collections import OrderedDict\nclass Solution:\n    def partition(self, nums, l, r):\n        piv = nums[r]\n        i = l -1\n        for j in range(l, r):\n            if nums[j] <= piv:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[r], nums[i+1] = nums[i+1], nums[r]\n        return (i+1)\n    \n    def selectSort(self, nums, left, right, k):\n        if left < right:\n            p = self.partition(nums, left, right)\n            if p == k:\n                return \n            elif k < p:\n                self.selectSort(nums, left, p-1, k)\n            else:\n                self.selectSort(nums, p+1, right, k)    \n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dists = [math.sqrt(p[0] ** 2 + p[1] ** 2)  for p in points]\n        self.selectSort(dists, 0 , len(dists)-1, K)\n        print(dists)\n        out= []\n        if K == len(points):\n            return points\n        for p in points:\n            if math.sqrt(p[0] ** 2 + p[1] ** 2) < dists[K]:\n                out.append(p)\n        \n        return out\n                \n", "import heapq\n\nclass Distance:\n    \n    def __init__(self, p, d):\n        self.d = d\n        self.p = p\n    \n    def __lt__(self, other):\n\n        return self.d >= other.d\n        \n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        def distance(p):\n            return math.sqrt(p[0]**2+p[1]**2)\n        \n        distances_k = []\n        for p in points:\n            \n            d = Distance(p, distance(p))\n            \n            if len(distances_k) < K:\n                heapq.heappush(distances_k, d)\n            elif d.d < distances_k[0].d:\n                heapq.heappop(distances_k)\n                heapq.heappush(distances_k, d)\n                \n        return [x.p for x in distances_k]\n                \n                \n                \n                \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        K -= 1\n        start, end = 0, len(points) - 1\n        while start <= end:\n            mid = self.__partition(points, start, end)\n            if mid == K:\n                break\n            elif mid < K:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return points[: K + 1]\n    \n    def __partition(self, points, lo, hi):\n        __dist = lambda points, i : points[i][0] ** 2 + points[i][1] ** 2\n        d = __dist(points, lo)\n        i, j = lo, hi + 1\n        while True:\n            while i < hi and __dist(points, i + 1) < d:\n                i += 1\n            while j > lo and __dist(points, j - 1) > d:\n                j -= 1\n            i, j = i + 1, j - 1\n            if i >= j:\n                break\n            points[i], points[j] = points[j], points[i]\n        points[lo], points[j] = points[j], points[lo]\n        return j", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        # need to get the distance of each points\n        # need to keep the K smallest, then pq can pop the samllest\n        # need to negative the input and pushpop so that i can do the k operation\n        \n        # other approach would be quick_select\n        # by randomize the input, you can get the average O(n) worst case O(n**2)\n        # get the parition of input arr, \n        # if partition < k: quick_select(st, partition-1)\n        # else: quick_select(partition+1, end)\n        \n        def parition(st, end):\n            \n            lo, i, j = st, st, end\n            while True:\n                \n                while i < end and arr[i][0] <= arr[lo][0]:\n                    i+=1\n                \n                while j > st and arr[lo][0] <= arr[j][0]:\n                    j-=1\n                    \n                if i >= j:\n                    break\n                arr[i], arr[j] = arr[j], arr[i]\n            arr[lo], arr[j] = arr[j], arr[lo]\n            return j\n        \n        def quick_select(st, end):\n            \n            # this gurantee 0,1. 1,1 is not possible\n            if st > end:\n                return\n            \n            par = parition(st, end)\n            \n            if par == K:\n                return\n            \n            if par > K:\n                quick_select(st, par-1)\n            else:\n                quick_select(par+1, end)\n            return \n        \n        arr = []\n        for pt in points:\n            arr.append( [math.sqrt(sum([x**2 for x in pt])), pt] )\n        #print(arr)\n        random.shuffle(arr)\n        #print(arr)\n        quick_select(0, len(arr)-1)\n        \n        return [x[1] for x in arr[:K]]", "import math\nimport heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        sol = []\n        for point in points:\n            dist = math.sqrt(point[0]**2 + point[1] **2)\n            heapq.heappush(sol, (dist, point))\n        print(sol)\n        return [point[1] for point in heapq.nsmallest(K, sol)]\n            \n", "\\\"\\\"\\\"\n10, 14, 11, 15 12\n10, 11, 14, 15\n\\\"\\\"\\\"\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def swap(arr, idx1, idx2):\n            arr[idx1], arr[idx2] = arr[idx2], arr[idx1]\n        \n        def swapElement(idx1, idx2):\n            swap(self.array, idx1, idx2)\n            swap(self.distance, idx1, idx2)\n            \n        def Partition(low, high, index) -> int:\n            \\\"\\\"\\\"\n            Returns the new index\n            \\\"\\\"\\\"\n            partDistance = self.distance[index]\n            swapElement(high, index)\n            newIndex = low\n            for i in range(low, high):\n                if (self.distance[i] < partDistance):\n                    swapElement(newIndex, i)\n                    newIndex += 1\n            \n            swapElement(newIndex, high)\n            return newIndex\n        \n        def Util(k):\n            low = 0\n            high = len(self.distance) - 1\n            while (low <= high):\n                index = random.randint(low, high)\n                newIndex = Partition(low, high, index)\n                if (newIndex == k):\n                    return self.array[:k]\n                if (newIndex > k):\n                    high = newIndex - 1\n                else:\n                    low = newIndex + 1\n        if (len(points) == K):\n            return points\n        self.array = points\n        self.distance = []\n        for point in points:\n            self.distance.append(math.sqrt(point[0]**2 + point[1]**2))\n        print(self.distance)\n        return Util(K)\n            \n            ", "import math\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        if len(points) == 0:\n            return []\n        \n        points.sort(key = lambda x: math.sqrt(x[0]*x[0] + x[1]*x[1]))\n        \n        return points[:K]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:   \n        def distance(point):\n            x, y = point\n            return x ** 2 + y ** 2\n        \n        # negative values to make a min-heap a max-heap\n        distances = [(distance(p), p) for p in points]\n        heapq.heapify(distances)\n\n        \n        for point in points:\n            heapq.heappushpop(distances, (-distance(point), point))\n        return [p for _, p in heapq.nsmallest(K, distances)]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        left = 0\n        right = len(points) - 1\n        target = K - 1\n        while (left <= right):\n            rand_pivot = random.randint(left, right)\n            pivot = self.partition(left, right, rand_pivot, points) \n            if (pivot == target):\n                return points[0 : pivot + 1]\n            elif (pivot < target):\n                left = pivot + 1\n            else:\n                right = pivot - 1\n    \n    def partition(self, i, j, pivot, arr):\n        pivot_element = self.distFromOrigin(arr[pivot])\n        self.swap(pivot, j, arr)\n        result = i\n        for x in range(i, j):\n            if self.distFromOrigin(arr[x]) < pivot_element:\n                self.swap(x, result, arr)\n                result += 1\n        self.swap(result, j, arr)\n        return result\n        \n    \n    def swap(self, i, j , arr):\n        temp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = temp\n    \n    def distFromOrigin(self, point):\n        return math.sqrt((point[0] ** 2 + point[1] ** 2))\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dist = lambda i: points[i][0]**2 + points[i][1]**2\n\n        def sort(i, j, K):\n            # Partially sorts A[i:j+1] so the first K elements are\n            # the smallest K elements.\n            if i >= j: return\n\n            # Put random element as A[i] - this is the pivot\n            k = random.randint(i, j)\n            points[i], points[k] = points[k], points[i]\n\n            mid = partition(i, j)\n            if K < mid - i + 1:\n                sort(i, mid - 1, K)\n            elif K > mid - i + 1:\n                sort(mid + 1, j, K - (mid - i + 1))\n\n        def partition(i, j):\n            # Partition by pivot A[i], returning an index mid\n            # such that A[i] <= A[mid] <= A[j] for i < mid < j.\n            oi = i\n            pivot = dist(i)\n            i += 1\n\n            while True:\n                while i < j and dist(i) < pivot:\n                    i += 1\n                while i <= j and dist(j) >= pivot:\n                    j -= 1\n                if i >= j: break\n                points[i], points[j] = points[j], points[i]\n\n            points[oi], points[j] = points[j], points[oi]\n            return j\n\n        sort(0, len(points) - 1, K)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def getDistance(p: List[int]):\n            return p[0] ** 2 + p[1] ** 2\n\n        def helper(points: List[List[int]], K: int):\n            if len(points) == K:\n                return points\n\n            left, right = [], []\n            import random\n            random.shuffle(points)\n\n            pivot = points[0][0]\n\n            for point in points:\n                curr_distance = point[0]\n                if curr_distance > pivot:\n                    right.append(point)\n                else:\n                    left.append(point)\n\n            if len(left) >= K:\n                return helper(left, K)\n            else:\n                return left + helper(right, K - len(left))\n        distances = []\n        for point in points:\n            distances.append([getDistance(point), point])\n\n        top_results = helper(distances, K)\n        for i, result in enumerate(top_results):\n            top_results[i] = result[1]\n        return top_results\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dist_square = lambda i: points[i][0] ** 2 + points[i][1] ** 2\n\n        def sort(i: int, j: int, K: int):\n            # partially sorts points[i...j+1] so the first K elements are the\n            # smallest K elements\n            if i >= j:\n                return\n\n            # put random element as points[i] as the pivot\n            k = random.randint(i, j)\n            points[i], points[k] = points[k], points[i]  # ???\n\n            mid = partition(i, j)\n            if K < mid - i + 1:\n                sort(i, mid - 1, K)\n            elif K > mid - i + 1:\n                sort(mid + 1, j, K - (mid - i + 1))\n\n        def partition(i: int, j: int) -> int:\n            # partition by pivot points[i], returning an index mid such that\n            # points[i] <= points[mid] <= points[j] for i < mid < j\n            oi = i\n            pivot = dist_square(i)\n            i += 1\n\n            while True:\n                while i < j and dist_square(i) < pivot:\n                    i += 1\n                while i <= j and dist_square(j) >= pivot:\n                    j -= 1\n                if i >= j:\n                    break\n                points[i], points[j] = points[j], points[i]\n            points[oi], points[j] = points[j], points[oi]\n            return j\n\n        sort(0, len(points) - 1, K)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def dist(point):\n            return sum([e**2 for e in point])\n        \n        def partition(nums, left, right):\n            x = dist(nums[right])\n            i = left - 1\n            for j in range(left, right):\n                if dist(nums[j]) < x:\n                    i += 1\n                    nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            nums[right], nums[i] = nums[i], nums[right]\n            return i\n        \n        p = -1\n        left = 0\n        right = len(points) - 1\n        \n        \n        while p != K:\n            \n            p = partition(points, left, right)\n            \n            if p + 1 < K:\n                left = p + 1\n            elif p + 1 > K:\n                right = p - 1\n            else:\n                return points[:K]\n            \n        return points[:K]\n\n# def distSqr(point: List[int]) -> int:\n#     d = 0\n#     for p in point:\n#         d += p ** 2\n#     return d\n\n# def partition(points: List[List[int]], left: int, right: int) -> int:\n#     if left > right:\n#         return -1\n#     pivot = left\n#     left = left + 1\n#     pivotDistSqr = distSqr(points[pivot])\n#     while left <= right:\n#         if distSqr(points[left]) > pivotDistSqr and distSqr(points[right]) < pivotDistSqr:\n#             points[left], points[right] = points[right], points[left]\n#             left += 1\n#             right -= 1\n#         if distSqr(points[left]) <= pivotDistSqr:\n#             left += 1\n#         if distSqr(points[right]) >= pivotDistSqr:\n#             right -= 1\n#     points[pivot], points[right] = points[right], points[pivot]\n#     pivot = right\n#     return pivot\n\n# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n#         pivot = -1 \n#         n = len(points)\n#         left, right = 0, n - 1\n        \n#         while pivot != K - 1:\n            \n#             pivot = partition(points, left, right)\n#             if pivot < K - 1:\n#                 left = pivot + 1\n#             elif pivot == K - 1:\n#                 return points[0:K]\n#             elif pivot > K - 1:\n#                 right = pivot - 1\n#         return points[0:K]\n\n\n# import heapq\n# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n#         idx = defaultdict(list)\n#         heap = []\n        \n#         for i, p in enumerate(points):\n#             d = (p[0] ** 2 + p[1] ** 2)\n#             if heap and len(heap) >= K:\n#                 if - heap[0] > d:\n#                     larger_dist = - heap[0]\n#                     idx[larger_dist].pop()\n#                     heapq.heappushpop(heap, - d)\n#                     idx[d].append(i)\n#             else:\n#                 heapq.heappush(heap, -d)\n#                 idx[d].append(i)\n        \n#         res = []\n#         for indicies in idx.values():\n#             for i in indicies:\n#                 res.append(points[i])\n#         return res\n", "class Solution(object):\n    def kClosest(self, points, K):\n        \n        # create a function that calculates the euclidean distance\n        dist = lambda i: sqrt(points[i][0]**2 + points[i][1]**2)\n\n        def sort(i, j, K):\n            # return when recursion tree reaches the leaf\n            if i >= j: return\n            \n            # get the random index between ith and jth index\n            k = random.randint(i, j)\n                        \n            # swap the values in the array  \n            points[i], points[k] = points[k], points[i]\n\n            # return the partitioned index A[i] <= A[mid] <= A[j] for i < mid < j.\n            mid = partition(i, j)\n            \n            # if the number of Kth element is smaller than the partitioned index \n            if K < mid - i + 1:\n                # sort again in the left array \n                sort(i, mid - 1, K)\n            # if the number of kth element is bigger than the partitioned index \n            elif K > mid - i + 1:\n                # sort again in the right array \n                sort(mid + 1, j, K - (mid - i + 1))\n\n        def partition(i, j):\n            # set the orgiinal i \n            oi = i\n            # get the distance of the random pivot  \n            pivot = dist(i)\n            i += 1\n\n            while True:\n                # increment i until the current distance reaches the pivot\n                while i < j and dist(i) < pivot:\n                    i += 1\n                \n                # decrement j until the current distance reaches the pivot \n                while i <= j and dist(j) >= pivot:\n                    j -= 1\n                    \n                # break i and j meets  \n                if i >= j: break\n                \n                # swap the ith and jth index \n                points[i], points[j] = points[j], points[i]\n            \n            # swap back the original index and the jth index\n            points[oi], points[j] = points[j], points[oi]\n            \n            # return jth index \n            return j\n\n        # invoke sort function \n        sort(0, len(points) - 1, K)\n        # return the kth amount of sorted result\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        points.sort(key=lambda x: x[0]**2+x[1]**2)\n        return points[:K]\n", "from heapq import *\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.distance = x ** 2 + y ** 2\n    \n    def __lt__(self, other):\n        return self.distance > other.distance\n    \n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        distance_heap = []\n        for x, y in points:\n            if len(distance_heap) >= K:\n                if Point(x, y) > distance_heap[0]:\n                    heappop(distance_heap)\n                    heappush(distance_heap, Point(x, y))\n            else:\n                heappush(distance_heap, Point(x, y))\n        res = []\n        \n        while distance_heap:\n            point =  heappop(distance_heap)\n            res.append([point.x, point.y])\n        \n        return res", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def dist(point):\n            return sum([e**2 for e in point])\n        \n        def partition(nums, left, right):\n            x = dist(nums[right])\n            i = left - 1\n            for j in range(left, right):\n                if dist(nums[j]) < x:\n                    i += 1\n                    nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            nums[right], nums[i] = nums[i], nums[right]\n            return i\n        \n        p = -1\n        left = 0\n        right = len(points) - 1\n        \n        \n        while p + 1 != K:\n            \n            p = partition(points, left, right)\n            \n            if p + 1 < K:\n                left = p + 1\n            elif p + 1 > K:\n                right = p - 1\n        return points[:K]\n\n# def distSqr(point: List[int]) -> int:\n#     d = 0\n#     for p in point:\n#         d += p ** 2\n#     return d\n\n# def partition(points: List[List[int]], left: int, right: int) -> int:\n#     if left > right:\n#         return -1\n#     pivot = left\n#     left = left + 1\n#     pivotDistSqr = distSqr(points[pivot])\n#     while left <= right:\n#         if distSqr(points[left]) > pivotDistSqr and distSqr(points[right]) < pivotDistSqr:\n#             points[left], points[right] = points[right], points[left]\n#             left += 1\n#             right -= 1\n#         if distSqr(points[left]) <= pivotDistSqr:\n#             left += 1\n#         if distSqr(points[right]) >= pivotDistSqr:\n#             right -= 1\n#     points[pivot], points[right] = points[right], points[pivot]\n#     pivot = right\n#     return pivot\n\n# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n#         pivot = -1 \n#         n = len(points)\n#         left, right = 0, n - 1\n        \n#         while pivot != K - 1:\n            \n#             pivot = partition(points, left, right)\n#             if pivot < K - 1:\n#                 left = pivot + 1\n#             elif pivot == K - 1:\n#                 return points[0:K]\n#             elif pivot > K - 1:\n#                 right = pivot - 1\n#         return points[0:K]\n\n\n# import heapq\n# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n#         idx = defaultdict(list)\n#         heap = []\n        \n#         for i, p in enumerate(points):\n#             d = (p[0] ** 2 + p[1] ** 2)\n#             if heap and len(heap) >= K:\n#                 if - heap[0] > d:\n#                     larger_dist = - heap[0]\n#                     idx[larger_dist].pop()\n#                     heapq.heappushpop(heap, - d)\n#                     idx[d].append(i)\n#             else:\n#                 heapq.heappush(heap, -d)\n#                 idx[d].append(i)\n        \n#         res = []\n#         for indicies in idx.values():\n#             for i in indicies:\n#                 res.append(points[i])\n#         return res\n", "class Solution(object):\n    def kClosest(self, points, K):\n        # create a lambda function that calculates the euclidean distance\n        dist = lambda i: sqrt(points[i][0]**2 + points[i][1]**2)\n\n        def sort(i, j, K):\n            # return when recursion tree reaches the leaf\n            if i >= j: return            \n            # get the pivot index that will sort array A[ i...pivot...j ]\n            k = random.randint(i, j)\n            # place the pivot in the front of the array A[ pivot.i....j ]\n            points[i], points[k] = points[k], points[i]\n            # return the partitioned index A[i] <= A[mid] <= A[j] \n            mid = partition(i, j)\n            # if the number of Kth element is smaller than the partitioned index \n            if K < mid - i + 1:\n                # sort recursively from the left array \n                sort(i, mid - 1, K)\n            # if the number of kth element is bigger than the partitioned index \n            elif K > mid - i + 1:\n                # sort recursively from the right array \n                sort(mid + 1, j, K - (mid - i + 1))\n\n        def partition(i, j):\n            # save the pivot index\n            oi = i\n            # get the distance value of the pivot  \n            pivot = dist(i)\n            # move to the index that needs to be sorted \n            i += 1\n            # loop until the sorting is complete\n            while True:\n                # increment from left if the distance of ith index is smaller than the pivot\n                while i < j and dist(i) < pivot:\n                    i += 1\n                # increment from right if the distance of ith index is bigger than the pivot\n                while i <= j and dist(j) >= pivot:\n                    j -= 1\n                # break if the sorting is complete \n                if i >= j: break                \n                # place the smaller value to the leftside and bigger value to the rigtside of the pivot\n                points[i], points[j] = points[j], points[i]\n            # move the pivot value to the middle index\n            points[oi], points[j] = points[j], points[oi]\n            # return middle index \n            return j\n\n        # invoke sort function \n        sort(0, len(points) - 1, K)\n        # return the kth amount of sorted result\n        return points[:K]", "class myObj:\n    def __init__(self, val, p):\n        self.val = val\n        self.p = p\n    def __lt__(self, other):\n        return self.val > other.val\n        \n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        h = []\n        heapq.heapify(h)\n        for p in points:\n            dis = p[0]*p[0] + p[1]*p[1]\n            heapq.heappush(h, myObj(dis, p))\n            if len(h)>K:\n                heapq.heappop(h)\n        \n        ans = []\n        while h:\n            obj = heapq.heappop(h)\n            ans.append(obj.p)\n        return ans", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        self.countK(points, 0, len(points)-1, K)\n        return points[:K]\n\n    \n    def countK(self, points, l, r, k):\n        if l < r:\n            p = self.createPartition(points, l, r, k)\n            if p == k:\n                return\n            elif p < k:\n                self.countK(points, p+1, r, k)\n            else:\n                self.countK(points, l, p-1, k)\n    \n    def createPartition(self, points, l, r, k):\n        pivot = points[r]\n        count = l\n        for i in range(l, r):\n            if (points[i][0]**2 + points[i][1]**2) <= (pivot[0]**2 + pivot[1]**2):\n                points[i], points[count] = points[count], points[i]\n                count += 1\n        points[count], points[r] = points[r], points[count]\n        return count\n", "from queue import PriorityQueue\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pq = PriorityQueue()\n        for i, c in enumerate(points):\n            pq.put((c[0]*c[0] + c[1]*c[1], i))\n        res = []\n        for j in range(K):\n            pair = pq.get()\n            res.append(points[pair[1]])\n        return res\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        return (sorted(points,key=lambda point:point[0]*point[0]+point[1]*point[1]))[:K]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        return sorted(points,key = lambda x : x[0]**2 + x[1]**2)[:K]", "# Quick select: time = O(N)\n# Logic to understand https://leetcode.com/problems/k-closest-points-to-origin/discuss/220235/Java-Three-solutions-to-this-classical-K-th-problem.\n# clean code https://leetcode.com/problems/k-closest-points-to-origin/discuss/219442/Python-with-quicksort-algorithm\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        self.qkSel(points, 0, len(points)-1, K)\n        return points[:K]\n    \n    def qkSel(self, points, l, r, K):\n        if l > r: return \n        \n        idx = random.randint(l, r)\n        points[idx], points[r] = points[r], points[idx]  \n        i = l\n        \n        for j in range(l, r):\n            if self.cmp(points[j], points[r]):\n                points[i], points[j] = points[j], points[i]\n                i += 1\n                \n        points[i], points[r] = points[r], points[i] \n        \n        if i == K: return \n        elif i < K: return self.qkSel(points, i+1, r, K)\n        elif i > K: return self.qkSel(points, l, i-1, K)\n        \n    \n    def cmp(self, p1, p2):\n        return (p1[0]**2 + p1[1]**2) - (p2[0]**2 + p2[1]**2) < 0  \n        \n                \n        \n        \n        \n        \n        \n        \n", "# class Solution:\n#     def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n#         points.sort(key=lambda x: math.sqrt(x[0]*x[0] + x[1]*x[1]))\n#         return points[:K]\n    \nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        dist = lambda x: math.sqrt(points[x][0]**2 + points[x][1]**2)\n        def dc(i, j, K):\n            if i >= j: return\n            oi, oj = i, j\n            i += 1\n            pivot = dist(oi)\n            while True:\n                while i < j and dist(i) < pivot: i += 1\n                while i <= j and dist(j) >= pivot: j -= 1\n                if i >= j: break\n                points[i], points[j] = points[j], points[i]\n            points[oi], points[j] = points[j], points[oi]\n            if K-1 == j: return\n            elif K-1 < j: dc(oi, j, K) \n            else: dc(j+1, oj, K)\n        dc(0, len(points)-1, K)\n        return points[:K]\n            \n", "class MyHeapObj():\n    def __init__(self, x, y, dist):\n        self.x = x\n        self.y = y\n        self.dist = dist\n    \n    def __gt__(self, other):\n        return self.dist > other.dist\n\nimport heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        pointsHeap = []\n        for p in points:\n            dist = (p[0]**2+p[1]**2)**0.5\n            heapq.heappush(pointsHeap, MyHeapObj(p[0], p[1], dist))\n            \n        \n        ret = []\n        for i in range(K):\n            point = heapq.heappop(pointsHeap)\n            ret.append([point.x, point.y])\n        return ret\n", "import random\n\nclass Solution:\n    # def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n    #     values = [(points[i][0] ** 2 + points[i][1] ** 2, i) for i in range(len(points))]\n    #     values.sort()\n    #     return [points[i] for _, i in values[:K]]\n    def _value(self, point):\n        return point[0] ** 2 + point[1] ** 2\n    \n    def _quickSelect(self, start: int, end: int, points: List[List[int]]) -> int:\n        if start == end:\n            return start\n        # random pivot\n        p = random.randint(start, end)\n        points[p], points[start] = points[start], points[p]\n        j = start + 1\n        for i in range(start + 1, end + 1):\n            if self._value(points[i]) <= self._value(points[start]):\n                points[i], points[j] = points[j], points[i]\n                j += 1\n        # swap i to its correct position\n        points[j - 1], points[start] = points[start], points[j - 1]\n        return j - 1\n                \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        start = 0\n        end = len(points) - 1\n        # select the pivot using quick select\n        while True:\n            p = self._quickSelect(start, end, points)\n            # if the pivot <= K: quick select for K on the right\n            # print(p)\n            if p < K - 1:\n                start = p + 1\n            elif p > K - 1:\n                end = p - 1\n            else:\n                return points[:p+1]\n        return None\n           \n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def dist(i):\n            return points[i][0]** 2 + points[i][1]**2\n        \n        def sort(i,j,K):\n            \\\"\\\"\\\"partially sort A[i:j+1] so that first K elements are the                      smallest K\n            \\\"\\\"\\\"\n            if i >= j: \n                return\n            k = random.randint(i,j)\n            points[i],points[k] = points[k],points[i]\n            mid = partition(i,j)\n            if K < mid - i + 1:\n                sort(i,mid-1,K)\n            elif K > mid - i + 1:\n                sort(mid + 1, j, K - (mid - i + 1))\n            \n        def partition(i,j):\n            \\\"\\\"\\\"partition by pivot A[i], returning an index mid\n                such that A[i] <= A[mid] <= A[j] for i < mid < j\n            \\\"\\\"\\\"\n            oi = i\n            pivot = dist(i)\n            i += 1\n            \n            while True:\n                while i < j and dist(i) < pivot:\n                    i += 1\n                while i <= j and dist(j) >= pivot:\n                    j -= 1\n                if i >= j: break\n                points[i], points[j] = points[j], points[i]\n            points[oi], points[j] = points[j], points[oi]\n            return j\n        \n        sort(0,len(points)-1, K)\n        return points[:K]\n        \n        ", "class Solution:\n    def kClosest(self, points, K):\n        self.sort(points, 0, len(points)-1, K)\n        return points[:K]\n    \n    def sort(self, points, l, r, K):\n        if l < r:\n            p = self.partition(points, l, r)\n            if p == K:\n                return\n            elif p < K:\n                self.sort(points, p+1, r, K)\n            else:\n                self.sort(points, l, p-1, K)\n            \n    def partition(self, points, l, r):\n        pivot = points[r]\n        a = l\n        for i in range(l, r):\n            if (points[i][0]**2 + points[i][1]**2) <= (pivot[0]**2 + pivot[1]**2):\n                points[a], points[i] = points[i], points[a]\n                a += 1\n        points[a], points[r] = points[r], points[a]                \n        return a", "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        \n        def distance(point):\n            return point[0]**2 + point[1]**2\n        \n        def find_pivot_index(low, high, p_index):\n            ppoint = points[p_index]\n            points[p_index], points[high] = points[high], points[p_index]\n            \n            i = low\n            j = low\n            \n            while j < high:\n                if distance(points[j]) < distance(points[high]):\n                    points[i], points[j] = points[j], points[i]\n                    i+=1\n                j+=1\n                \n            points[i], points[high] = points[high], points[i]\n            return i\n            \n        def recursion(low, high):\n            pivot_index = random.randint(low, high)\n            p = find_pivot_index(low, high, pivot_index)\n            \n            if p == k-1:\n                return points[:p+1]\n            elif p<k-1:\n                return recursion(p+1, high)\n            else:\n                return recursion(low, p-1)\n            \n        return recursion(0, len(points)-1)", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        res=[]\n        def insert(d, pos):\n            l=0\n            r=len(res)\n            while l<r:\n                mid=(l+r)//2\n                if res[mid][0]>d:\n                    r=mid\n                else:\n                    l=mid+1\n            res.insert(l, [d,pos])\n            Max=res[-1][0]\n        Max=float('inf')\n        \n        for i in range(len(points)):\n            dis=(points[i][0])**2+(points[i][1])**2\n            print(len(res))\n            if i>K:\n                res.pop()\n            insert(dis, points[i])\n        ans=[]\n        for i in range(K):\n            ans.append(res[i][1])\n        return ans", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # quick sort with partition\n        dist = lambda x:x[0]**2 + x[1]**2\n        def partition(start, end):\n            ran = random.randint(start, end)\n            pivot = end\n            points[pivot], points[ran] = points[ran], points[pivot]\n\n            border = start\n            for cur in range(start, end):\n                # sort in descending order\n                if dist(points[cur]) <= dist(points[pivot]):\n                    points[cur], points[border] = points[border], points[cur]\n                    border += 1\n            points[border], points[pivot] = points[pivot], points[border]\n            return border  \n        \n        def quick_sort(left, right, k):\n            if left >= right: return\n            p = partition(left, right)\n            if p == k - 1:\n                return\n            if p < k - 1:\n                quick_sort(p + 1, right, k)\n            else:\n                quick_sort(left, p - 1, k)\n        \n        quick_sort(0, len(points) - 1, K)\n        return points[:K]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda x : x[0] ** 2 + x[1] ** 2)\n        return points[:K]", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        def dist(x) -> int:\n            return x[0]**2 + x[1] ** 2\n        \n        def partition(i,j)->int:\n            pivot = points[j]\n            l = i - 1\n            for r in range(i,j):\n                rv = points[r]\n                # print(r, points)\n                if dist(rv) < dist(pivot):\n                    l += 1\n                    points[l], points[r] = points[r], points[l]\n            points[j], points[l+1] = points[l+1], points[j]\n            return l+1\n        \n        \n        def sort(i,j,K):\n            if i >= j: return \n            \n            mid = partition(i,j)\n            if (mid - i + 1) == K:\n                return\n            elif (mid - i + 1) < K:\n                sort(mid + 1, j, K - (mid - i + 1))\n            else:\n                sort(i, mid - 1, K)\n        \n        sort(0, len(points)-1, K)\n        return points[:K]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        # quick sort with partition\n        dist = lambda x:x[0]**2 + x[1]**2\n        def partition(start, end):\n            ran = random.randint(start, end)\n            pivot = end\n            points[pivot], points[ran] = points[ran], points[pivot]\n\n            border = start\n            for cur in range(start, end):\n                # sort in descending order\n                if dist(points[cur]) >= dist(points[pivot]):\n                    points[cur], points[border] = points[border], points[cur]\n                    border += 1\n            points[border], points[pivot] = points[pivot], points[border]\n            return border  \n        \n        def quick_sort(left, right, k):\n            if left >= right: return\n            p = partition(left, right)\n            if p == k - 1:\n                return\n            if p < k - 1:\n                quick_sort(p + 1, right, k)\n            else:\n                quick_sort(left, p - 1, k)\n        \n        quick_sort(0, len(points) - 1, len(points) - K + 1)\n        return points[len(points) - K:]\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        start, end = 0, len(points) - 1\n        pivot = -1\n        while start <= end:\n            pivot = self.partition(points, start, end)\n            if pivot == K:\n                return points[0:pivot]\n            elif pivot > K:\n                end = pivot - 1\n            else:\n                start = pivot + 1\n       \n        return points\n            \n    \n    def partition(self, points, start, end):\n        pivot = start\n        for i in range(start, end+1):\n            if self.dist(points, i) < self.dist(points, end):\n                points[i], points[pivot] = points[pivot], points[i]\n                pivot += 1\n        \n        points[end], points[pivot] = points[pivot], points[end]\n        return pivot\n    \n    def dist(self, points, i):\n        return points[i][0]**2 + points[i][1]**2\n", "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        def dist(x)->int:\n            return x[0]**2 + x[1]**2\n        \n        def partition(i, j)->int:\n            \n            # pivot\u7684\u9009\u62e9\u5728\u6700\u540e\u4e00\u4e2a\u70b9\n            pivot = points[j]\n            l = i - 1\n            for r in range(i, j):\n                rv = points[r]\n                if dist(rv) < dist(pivot):\n                    l += 1\n                    points[l], points[r] = points[r], points[l]\n            points[j], points[l+1] = points[l+1], points[j]\n            \n            return l+1\n        \n        def sort(i, j, K):\n            # \u6b64\u65f6\u8bf4\u660e\u5df2\u7ecf\u6392\u597d\u5e8f\u4e86\n            if i >= j: return \n            \n            mid = partition(i,j)\n            \n            if (mid - i + 1) == K:\n                return\n                \n            elif (mid - i + 1) < K:\n                sort(mid + 1, j, K - (mid - i + 1))\n            else:\n                sort(i, mid - 1, K)\n            \n        sort(0, len(points)-1, K)\n        \n        return points[:K]", "import math\nimport heapq\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        # distance type is euclidean\n        # we can iterate over the points and compute dist for each point O(n)\n        # we can then heapify the list with dist being the priority in the priority queue O(n)\n        # we can can return the k_smallest O(klogn)\n        # using extra O(n) space\n        \n        # test cases\n        # empty points\n        # < k points\n        # all same values and len > k\n        if len(points) == 0:\n            return []\n        if K >= len(points):\n            return points\n        \n        def euclidean(point):\n            x, y = point\n            return math.sqrt(math.pow(x,2) + math.pow(y,2))\n        \n        mod_points = []\n        for point in points:\n            dist = euclidean(point)\n            mod_points.append((dist, point[0], point[1]))\n        \n        heapq.heapify(mod_points)\n        \n        ret_values = heapq.nsmallest(K, mod_points)\n        ret_values = [[x,y] for dist, x, y in ret_values]\n        \n        return ret_values\n        \n", "class Solution:\n    \n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        \n        max_heap = []\n        \n        for point in points:\n            x, y = point[0], point[1]\n            dist = x**2 + y**2\n            if len(max_heap) < K:               \n                heapq.heappush(max_heap, (-dist, x, y))\n            else:\n                if dist < -max_heap[0][0]:\n                    heapq.heappop(max_heap)\n                    heapq.heappush(max_heap, (-dist, x, y))\n            \n        return [[x, y] for (dist, x,y) in max_heap]", "class Solution(object):\n    def kClosest(self, points, K):\n\n        # minHeap #\n        def distance(p):\n            return (p[0]**2 + p[1]**2)**0.5 \n        \n        def partition(l, r):\n            pivot = points[r]\n            mover = l\n            ## \u628a\u5de6\u8fb9\u7684\u548c\u53f3\u8fb9\u6bd4, \u628a\u5c0f\u7684\u653e\u5230\u5de6\u8fb9, \u5927\u7684\u653e\u5230\u53f3\u8fb9\n            for i in range(l, r):\n                if distance(points[i]) <= distance(pivot):\n                    points[mover], points[i] = points[i], points[mover]\n                    mover += 1\n            points[mover], points[r] = points[r], points[mover]\n            return mover # such that all the numbers are smaller than the number at the mover\n        \n        def sort(l, r):\n            if l < r:\n                p = partition(l, r)\n                if p == K:\n                    return\n                elif p < K:\n                    sort(p+1, r)\n                else:\n                    sort(l, p-1)\n                    \n        sort(0, len(points)-1)\n        return points[:K]\n", "# Max heap\nclass Node:\n    def __init__(self,x,y,d=None):\n        self.x = x\n        self.y = y\n        if d:\n            self.distance = d\n        else:\n            self.distance = x*x + y*y\n        \n        \ndef parent(i):\n    return (i-1)//2\ndef left(i):\n    return 2*i +1\ndef right(i):\n    return 2*i +2\ndef swap(heap,i,j):\n    t = heap[i]\n    heap[i] = heap[j]\n    heap[j] = t\n    \ndef heapify(heap):\n    n = len(heap)\n    for i in range(1,n):\n        p = parent(i)\n        \n        while i > 0 and heap[p].distance < heap[i].distance:\n            # print(heap[i].distance,i,p)\n            swap(heap,i,p)\n            i = p\n            p = parent(i)\n        \n    \ndef replace_top(heap,node):\n    t = heap[0]\n    heap[0] = node\n    n = len(heap)\n    # swap(heap,0,n-1)\n    i = 0\n    l = left(i)\n    r = right(i)\n    while i < n and not((l >= n or heap[l].distance <= heap[i].distance) and (r >= n or heap[r].distance <= heap[i].distance)):\n        if l < n and r < n:\n            if  heap[l].distance < heap[r].distance:\n                swap(heap,i,r)\n                i = r\n            else:\n                swap(heap,i,l)\n                i = l\n        elif l < n:\n            swap(heap,i,l)\n            i = l\n        else:\n            swap(heap,i,r)\n            i = r\n            \n        l = left(i)\n        r = right(i)\n            \nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        n = len(points)\n        heap = []\n        for i in range(K):\n            p = points[i]\n            node = Node(p[0],p[1])\n            heap.append(node)\n            # print(node.distance)\n        heapify(heap)\n        top = 0\n        # print(heap)\n        # print(\\\"max\\\",heap[top].distance)\n        for i in range(K,n):\n            p = points[i]\n            \n            distance = p[0]*p[0] + p[1]*p[1]\n            # print(p,distance)\n            if heap[top].distance > distance:\n                node = Node(p[0], p[1], distance)\n                # print(p,node.distance)\n                replace_top(heap,node)\n        return [ [heap[i].x,heap[i].y] for i in range(K)]\n                \n        \n", "import random\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> int:\n        l, h, k = 0, len(points) - 1, K - 1\n        \n        dist = lambda i : points[i][0] ** 2 + points[i][1] ** 2\n        \n        def partition(l: int, h: int) -> int:\n            t = random.randint(l, h)\n            points[t], points[h] = points[h], points[t]\n            for i, val in enumerate(points[l:h+1], l):\n                if dist(i) < dist(h):\n                    points[i], points[l] = points[l], points[i]\n                    l += 1\n            points[l], points[h] = points[h], points[l]\n            return l\n        \n        \n        while True:\n            pos = partition(l, h)\n            if pos < k:\n                l = pos + 1\n            elif pos > k:\n                h = pos - 1\n            else:\n                return points[:K]\n                    \n"]
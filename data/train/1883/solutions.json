["class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def fun(g,i0,i1,n1,t1,f2,row,col):\n            if n1==t1:\n                if abs(f2[1]-i1)+abs(f2[0]-i0)==1:\n                    self.ans+=1\n            else:\n                if i1+1!=col and g[i0][i1+1]==0:\n                    g[i0][i1+1]=1\n                    fun(g,i0,i1+1,n1+1,t1,f2,row,col)\n                    g[i0][i1+1]=0\n                if i1!=0 and g[i0][i1-1]==0:\n                    g[i0][i1-1]=1\n                    fun(g,i0,i1-1,n1+1,t1,f2,row,col)\n                    g[i0][i1-1]=0\n                if i0+1!=row and g[i0+1][i1]==0:\n                    g[i0+1][i1]=1\n                    fun(g,i0+1,i1,n1+1,t1,f2,row,col)\n                    g[i0+1][i1]=0\n                if i0!=0 and g[i0-1][i1]==0:\n                    g[i0-1][i1]=1\n                    fun(g,i0-1,i1,n1+1,t1,f2,row,col)\n                    g[i0-1][i1]=0\n        \n        self.ans=0\n        i0,i1,t1=0,0,0\n        f2=[0,0]\n        row = len(grid)\n        col = len(grid[0])\n        for i in range(row):\n            for j in range(col):\n                if grid[i][j]==0:\n                    t1+=1\n                elif grid[i][j]==1:\n                    i0,i1 = i,j\n                elif grid[i][j]==2:\n                    f2 = [i,j]\n        fun(grid,i0,i1,0,t1,f2,row,col)\n        return self.ans", "class Solution:\n    def uniquePathsIII(self, grid):\n\n        maxPath = 2\n        neighbors = [None] * (len(grid) * len(grid[0]))\n        visited = [False] * (len(grid) * len(grid[0]))\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                node = x*len(grid[0]) + y\n                if grid[x][y] == 0:\n                    neighbors[node] = getNeighbors(grid, x, y)\n                    visited[node] = False\n                    maxPath += 1\n                elif grid[x][y] == 1:\n                    start = node\n                    neighbors[node] = getNeighbors(grid, x, y)\n                elif grid[x][y] == 2:\n                    end = node\n                    visited[node] = False\n\n        return count(neighbors, visited, start, maxPath, 1, end)\n\ndef getNeighbors(grid, x, y):\n    output = []\n    if x > 0 and grid[x-1][y] % 2 == 0:\n        output.append((x-1)*len(grid[0])+y)\n    if x < len(grid)-1 and grid[x+1][y] % 2 == 0:\n        output.append((x+1)*len(grid[0])+y)\n    if y > 0 and grid[x][y-1] % 2 == 0:\n        output.append(x*len(grid[0])+y-1)\n    if y < len(grid[0]) - 1 and grid[x][y+1] % 2 == 0:\n        output.append(x*len(grid[0])+y+1)\n    return output\n    \ndef count(neighbors, visited, node, maxPath, pathLength, destination):\n\n    if pathLength == maxPath and node == destination:\n        return 1\n    elif pathLength == maxPath or node == destination:\n        return 0\n\n    visited[node] = True\n\n    sum = 0\n    for k in neighbors[node]:\n        if not visited[k]:\n            sum += count(neighbors, visited, k, maxPath, pathLength + 1, destination)\n    \n    visited[node] = False\n    return sum", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        count = 0\n        visited = set()\n        \n        def dfs(i: int, j: int):\n            nonlocal count\n            nonlocal num_empty\n            \n            if grid[i][j] == -1 or (i, j) in visited:\n                return\n            # + 1 to account for starting position\n            elif grid[i][j] == 2 and len(visited) == num_empty + 1:\n                count += 1\n                return\n            else:\n                visited.add((i, j))\n                \n                if i > 0:\n                    dfs(i-1, j)\n                if j > 0:\n                    dfs(i, j-1)\n                if i < len(grid) - 1:\n                    dfs(i+1, j)\n                if j < len(grid[0]) - 1:\n                    dfs(i, j+1) \n                    \n                visited.remove((i, j))\n        \n        # 1) Find starting position\n        # 2) Count all empty squares\n        start_i = start_j = None\n        num_empty = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    start_i, start_j = i, j\n                elif grid[i][j] == 0:\n                    num_empty += 1\n                    \n        dfs(start_i, start_j)\n        return count", "class Solution:\n    \n    \n    \n    def find_square(self, grid, val):\n        for i in range(0, len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == val:\n                    return (i,j)\n        return (-1,-1)\n    \n    def count_empty_squares(self, grid):\n        empty_sq = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 0:\n                    empty_sq += 1\n        return empty_sq\n    \n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        start_square = self.find_square(grid, 1)\n        end_sq = self.find_square(grid, 2)\n        empty_squares = self.count_empty_squares(grid) + 1\n        \n        \n        def unique_paths_backtracking(grid, cur_sq, count):\n            if count == empty_squares:\n                if cur_sq == end_sq:\n                    return 1\n                return 0\n            elif cur_sq == end_sq or \\\\\n                not (0 <= cur_sq[0] < len(grid)) or \\\\\n                not (0 <= cur_sq[1] < len(grid[0])) or \\\\\n                grid[cur_sq[0]][cur_sq[1]] < 0:\n                return 0\n\n            grid[cur_sq[0]][cur_sq[1]] = -2\n            u = unique_paths_backtracking(grid, (cur_sq[0]-1,cur_sq[1]), count+1)\n            grid[cur_sq[0]][cur_sq[1]] = 0\n            \n            grid[cur_sq[0]][cur_sq[1]] = -2\n            d = unique_paths_backtracking(grid, (cur_sq[0]+1,cur_sq[1]), count+1)\n            grid[cur_sq[0]][cur_sq[1]] = 0\n            \n            grid[cur_sq[0]][cur_sq[1]] = -2\n            l = unique_paths_backtracking(grid, (cur_sq[0],cur_sq[1]-1), count+1)\n            grid[cur_sq[0]][cur_sq[1]] = 0\n            \n            grid[cur_sq[0]][cur_sq[1]] = -2\n            r = unique_paths_backtracking(grid, (cur_sq[0],cur_sq[1]+1), count+1)\n            grid[cur_sq[0]][cur_sq[1]] = 0\n            \n            return u + d + l + r\n        \n        \n        return unique_paths_backtracking(grid, start_square, 0)\n    \n\\\"\\\"\\\"\n1) Find starting square and ending square (write fn to do this)\n2) Count number of empty squares\n2) Fail conditions: \n    - we cannot travel any direction since we already visited them\n    - we reach ending square but haven't stepped on every empty square\n    - we reach an obstacle so terminate that path\n3) Success:\n    - squares explored == empty_squares and cur location is end_square idx\n4) Increment a unique path counter every time we hit success condition\n\nRuntime: O(4^(N*M))\nSpace: O(N*M)\n\\\"\\\"\\\"", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        \n        non_obstacles = 0\n        start_row, start_col = 0, 0\n        for row in range(0, rows):\n            for col in range(0, cols):\n                cell = grid[row][col]\n                if cell >= 0:\n                    non_obstacles += 1\n                if cell == 1:\n                    start_row, start_col = row, col\n                    \n        path_count = 0\n        \n        def backtrack(row, col, remain):\n            nonlocal path_count\n            \n            if grid[row][col] == 2 and remain == 1:\n                path_count += 1\n                return\n            \n            temp = grid[row][col]\n            grid[row][col] = -4\n            remain -= 1\n            \n            for ro, co in [(0,1),(0,-1),(-1,0),(1,0)]:\n                next_row, next_col = row + ro, col + co\n                \n                if not(0 <= next_row < rows and 0 <= next_col < cols):\n                    continue\n                if grid[next_row][next_col] < 0:\n                    continue\n                    \n                backtrack(next_row, next_col, remain)\n            \n            grid[row][col] = temp\n            \n        backtrack(start_row, start_col, non_obstacles)\n        \n        return path_count\n", "class Solution:\n    '''\n    - need to measure the the count of non-obstacles first O(n)\n    - can use backtracking at each step\n    - can go all directions, except if there is an obstacle or already visited\n    - need to count how many available spots left, if we reach end, and spots left == 0, count as 1\n    - O(3^n) time | O(n) space .. since we have n decisions at every step\n    '''\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def traverse(row, col, spacesLeft):\n            # end case\n            if spacesLeft == 1 and grid[row][col] == 2:\n                self.results += 1\n                return\n            \n            # visit current\n            temp = grid[row][col]\n            grid[row][col] = '#'\n            spacesLeft -= 1\n            \n            # visit next in all directions\n            for rowOffset, colOffset in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nextRow, nextCol = row + rowOffset, col + colOffset\n                # don't traverse if out of range\n                if nextRow < 0 or nextRow == rows or nextCol < 0 or nextCol == cols:\n                    continue\n                # don't traverse if obstacle or visited\n                if grid[nextRow][nextCol] == -1 or grid[nextRow][nextCol] == '#':\n                    continue            \n                traverse(nextRow, nextCol, spacesLeft)\n            \n            # backtrack\n            grid[row][col] = temp\n        \n        rows, cols = len(grid), len(grid[0])\n        spaces = 0\n        # get data from grid first\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] >= 0:\n                    spaces += 1\n                if grid[row][col] == 1:\n                    start = (row, col)\n        \n        self.results = 0\n        traverse(start[0], start[1], spaces)\n        return self.results", "class Solution:\n    '''\n    - need to measure the the count of non-obstacles first O(n)\n    - can use backtracking at each step\n    - can go all directions, except if there is an obstacle or already visited\n    - need to count how many available spots left, if we reach end, and spots left == 0, count as 1\n    - O(3^n) time | O(n) space .. since we have n decisions at every step\n    '''\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def traverse(row, col, spacesLeft):\n            nonlocal results\n            # end case\n            if spacesLeft == 1 and grid[row][col] == 2:\n                results += 1\n                return\n            \n            # visit current\n            temp = grid[row][col]\n            grid[row][col] = '#'\n            spacesLeft -= 1\n            \n            # visit next in all directions\n            for rowOffset, colOffset in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nextRow, nextCol = row + rowOffset, col + colOffset\n                # don't traverse if out of range\n                if nextRow < 0 or nextRow == rows or nextCol < 0 or nextCol == cols:\n                    continue\n                # don't traverse if obstacle or visited\n                if grid[nextRow][nextCol] == -1 or grid[nextRow][nextCol] == '#':\n                    continue            \n                traverse(nextRow, nextCol, spacesLeft)\n            \n            # backtrack\n            grid[row][col] = temp\n        \n        rows, cols = len(grid), len(grid[0])\n        spaces = 0\n        # get data from grid first\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] >= 0:\n                    spaces += 1\n                if grid[row][col] == 1:\n                    start = (row, col)\n        \n        results = 0\n        traverse(start[0], start[1], spaces)\n        return results", "class Solution:\n  def dfs(self, grid, r, c, i, j, count):\n    if 0 <= i < r and 0 <= j < c and grid[i][j] != -1:\n        if count == -1 and grid[i][j] == 2:\n            self.res += 1\n        val = grid[i][j]\n        grid[i][j] = -1\n        self.dfs(grid, r, c, i+1, j, count-1) \n        self.dfs(grid, r, c, i-1, j, count-1) \n        self.dfs(grid, r, c, i, j+1, count-1) \n        self.dfs(grid, r, c, i, j-1, count-1) \n        grid[i][j] = val   \n\n  def uniquePathsIII(self, grid: List[List[int]]) -> int:\n    \\\"\\\"\\\"\n    1. Find start and end using a double for loop\n    2. Use DFS to visit all available paths until we arrive at end then increment counter\n    3. Use cache to return number of paths for lower trees\n    4. Return the total amount of paths using the counter\n    \\\"\\\"\\\"\n    r, c, count = len(grid), len(grid[0]), 0\n    for i in range(r):\n        for j in range(c):\n            count += grid[i][j] == 0\n    self.res = 0 # treat it as a nonlocal variable\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 1:\n                self.dfs(grid, r, c, i, j, count)\n    return self.res\n                        ", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def dfs(i,j,out,to_visit):\n            if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] == '#' or grid[i][j] == -1:\n                return\n            if grid[i][j] == 2 and to_visit == 0:\n                out[0]+=1\n            else:\n                tmp = grid[i][j]\n                grid[i][j] = '#'\n                dfs(i,j+1,out,to_visit-1)\n                dfs(i,j-1,out,to_visit-1)\n                dfs(i+1,j,out,to_visit-1)\n                dfs(i-1,j,out,to_visit-1)\n                grid[i][j] = tmp\n        \n        res = [0]\n        ori,orj = 0,0\n        to_visit = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    ori,orj = i,j\n                if grid[i][j] != -1:\n                    to_visit += 1\n        \n        dfs(ori,orj,res,to_visit-1)\n        \n        return res[0]", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        start = end = None\n        remain = 0\n        for m in range(len(grid)):\n            for n in range(len(grid[0])):\n                if grid[m][n] == 1:\n                    start = (m, n)\n                elif grid[m][n] == 2:\n                    end = (m, n)\n                if grid[m][n] == 0:\n                    remain += 1\n\n        if start is None or end is None:\n            return 0\n        return self._helper(grid, start[0], start[1], end[0], end[1], remain + 1)\n\n    def _helper(self, grid: List[List[int]], start_m: int, start_n: int, end_m: int, end_n: int, remain: int) -> int:\n        if 0 <= start_m < len(grid) and 0 <= start_n < len(grid[0]) and grid[start_m][start_n] > -1:\n            if remain < 0:\n                return 0\n            elif remain == 0 and start_m == end_m and start_n == end_n:\n                return 1\n            count = 0\n            grid[start_m][start_n] = -2\n            count += self._helper(grid, start_m + 1, start_n, end_m, end_n, remain - 1)\n            count += self._helper(grid, start_m, start_n + 1, end_m, end_n, remain - 1)\n            count += self._helper(grid, start_m - 1, start_n, end_m, end_n, remain - 1)\n            count += self._helper(grid, start_m, start_n - 1, end_m, end_n, remain - 1)\n            grid[start_m][start_n] = 0\n            return count\n\n        return 0", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        start = end = None\n        cnt = ans = 0\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1: start = (i, j)\n                elif grid[i][j] == 1: end = (i, j)\n                if grid[i][j] != -1: cnt += 1\n        def dfs(i, j, cnt):\n            nonlocal m, n, ans\n            if grid[i][j] == 2 and cnt == 1: \n                ans += 1 \n                return\n            val = grid[i][j]\n            grid[i][j] = -1\n            for x, y in map(lambda t: (t[0]+i, t[1]+j), [(-1, 0), (1, 0), (0, -1), (0, 1)]):\n                if 0 <= x < m and 0 <= y < n and grid[x][y] != -1:\n                    dfs(x, y, cnt-1)\n            grid[i][j] = val\n        dfs(*start, cnt)\n        return ans ", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        # res = 0\n        # m, n, empty = len(A), len(A[0]), 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if A[i][j] == 1:\n        #             x, y = (i, j)\n        #         elif A[i][j] == 0:\n        #             empty += 1\n        # def dfs(x, y, empty):\n        #     nonlocal res\n        #     if not (0 <= x < m and 0 <= y < n and A[x][y] >= 0): return\n        #     if A[x][y] == 2:\n        #         res += empty == 0\n        #         return\n        #     A[x][y] = -2\n        #     dfs(x + 1, y, empty - 1)\n        #     dfs(x - 1, y, empty - 1)\n        #     dfs(x, y + 1, empty - 1)\n        #     dfs(x, y - 1, empty - 1)\n        #     A[x][y] = 0\n        # dfs(x, y, empty)\n        # return res\n        \n        m, n = len(grid), len(grid[0])\n        start = end = cnt = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1: start = (i, j)\n                elif grid[i][j] == 2: end = (i, j)\n                if grid[i][j] != -1: cnt += 1 \n        ans = 0\n        def dfs(x, y, cnt):\n            nonlocal ans, start, end\n            if (x, y) == end and cnt == 1:\n                ans += 1; return \n            val = grid[x][y]\n            grid[x][y] = -1\n            for i, j in map(lambda t: (t[0]+x, t[1]+y), [(-1, 0), (1, 0), (0, -1), (0, 1)]):\n                if 0 <= i < m and 0 <= j < n and grid[i][j] != -1:\n                    dfs(i, j, cnt-1)\n            grid[x][y] = val\n        dfs(*start, cnt)                    \n        return ans", "from collections import deque\nclass Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        row = len(grid)\n        col = len(grid[0])\n        r = c = -1\n        \n        count = 0\n        node_count = 0\n        ans = []\n        for x in range(row):\n            for y in range(col):\n                if grid[x][y] >= 0:\n                    node_count += 1\n                  \n                if grid[x][y] == 1:\n                    r, c = x, y\n                \n        \n        def get_paths(sr, sc, remain):\n            \n            left = sc - 1\n            right = sc + 1\n            up = sr - 1\n            down = sr + 1\n            \n            nonlocal count\n            \n            if left >= 0 and grid[sr][left] == 0:\n                #print(sr, left)\n                grid[sr][left] = -4\n                get_paths(sr, left, remain -1)\n                grid[sr][left] = 0\n                \n            \n            if right < col and grid[sr][right] == 0:\n                #print(sr, right)\n                grid[sr][right] = -4\n                get_paths(sr, right, remain -1)\n                grid[sr][right] = 0\n            \n            if up >= 0 and grid[up][sc] == 0:\n                #print(up, sc)\n                grid[up][sc] = -4\n                get_paths(up, sc, remain -1)\n                grid[up][sc] = 0\n            \n            if down < row and grid[down][sc] == 0:\n                #print(down, sc)\n                grid[down][sc] = -4\n                get_paths(down, sc, remain -1)\n                grid[down][sc] = 0\n            \n            if left >= 0 and grid[sr][left] == 2 and remain == 2:\n                count += 1\n            elif right < col and grid[sr][right] == 2 and remain == 2:\n                count += 1\n            elif up >= 0 and grid[up][sc] == 2 and remain == 2:\n                count += 1\n            elif down < row and grid[down][sc] == 2 and remain == 2:\n                count += 1\n            #print(remain)\n\n        \n        get_paths(r, c, node_count)\n        return count\n", "# General idea for the solution is as follows:\n# 1) We traverse the whole array once initially, in doing so we find a) the location of the\n#   start point, b) the location of the end point and c) the number of traversable square.\n# 2) We then do a simple DFS traversal, like before. During this DFS traversal we can mark\n#   previous nodes as visited in-place (replacing the original value on the backtrack).\n#       - During the DFS traversal we count how many squares we have visited.\n#       - We only increment the number of viable paths if we reach the end node after\n#         visiting all the traversable nodes (i.e. count = 0, for example).\n\nclass Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        # First, traverse the array once, finding the start location and the number of -1\n        # entries\n        startIndex = None\n        numTraversable = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                # Find the start index\n                if grid[i][j] == 1:\n                    startIndex = [i, j]\n                # Keep track of the number of obstacles\n                if grid[i][j] != -1:\n                    numTraversable += 1\n        # Find the number of traversable squares (n * m - numObstables - 2)\n        numTraversable -= 1 # -1 for start\n        # Now call your DFS function from the starting node\n        numPaths = self.visitedDFS(grid, startIndex, numTraversable)\n        return numPaths\n\n    def visitedDFS(self, grid, coord, count):\n        numPaths = 0\n        \n        # First thing, check if the coorindates are out of bound or the node has been\n        # visited/is an obstacle\n        i, j = coord\n        if (i < 0) or (j < 0) or (i >= len(grid)) or (j >= len(grid[0])) \\\\\n        or (grid[i][j] < 0):\n            return 0\n        \n        # Otherwise see if we're at the end coordinate\n        if grid[i][j] == 2 and count == 0:\n            return numPaths + 1\n        \n        # Otherwise mark this point as visited, or an obstacle\n        saved = grid[i][j]\n        grid[i][j] = -2\n        \n        # Do the DFS on the neighbours\n        neighbours = [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]\n        for neighbour in neighbours:\n            numPaths += self.visitedDFS(grid, neighbour, count - 1)\n            \n        # Unmark the node\n        grid[i][j] = saved\n        \n        return numPaths\n    \n    \n    \n    \n        ", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        self.ret = 0\n        empty = 0\n        m = len(grid)\n        n = len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    sx = i\n                    sy = j\n                if grid[i][j] >= 0:\n                    empty += 1\n        \n        def backtrack(grid, x, y, num_left):\n            if x<0 or y<0 or x>=m or y>=n or grid[x][y] < 0:\n                return\n            if grid[x][y] == 2 and num_left == 0:\n                self.ret += 1\n                return\n            neighs = [[0,1],[1,0],[0,-1],[-1,0]]\n            for dx, dy in neighs:\n                orig_value = grid[x][y]\n                grid[x][y] = -1\n                backtrack(grid, x+dx, y+dy, num_left-1)\n                grid[x][y] = orig_value\n\n        backtrack(grid, sx, sy, empty-1)\n        return self.ret\n", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        self.ans, empty = 0, 0\n        m, n = len(grid[0]), len(grid)\n        def dfs(x, y, rest):\n            if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] < 0:\n                return\n            \n            if grid[x][y] == 2 and rest == 0:\n                self.ans += 1\n                return\n            \n            neibs = [[0,1],[0,-1],[1,0],[-1,0]]\n            for dx, dy in neibs:\n                tmp = grid[x][y]\n                grid[x][y] = -2\n                dfs(x+dx, y+dy, rest - 1)\n                grid[x][y] = tmp\n            \n        for i,j in product(list(range(n)), list(range(m))):\n            if grid[i][j] == 1:\n                (sx, sy) = (i,j)\n            empty += (grid[i][j] != -1)\n\n        dfs(sx, sy, empty-1)\n        return self.ans\n", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        # res = 0\n        # m, n, empty = len(A), len(A[0]), 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if A[i][j] == 1:\n        #             x, y = (i, j)\n        #         elif A[i][j] == 0:\n        #             empty += 1\n        # def dfs(x, y, empty):\n        #     nonlocal res\n        #     if not (0 <= x < m and 0 <= y < n and A[x][y] >= 0): return\n        #     if A[x][y] == 2:\n        #         res += empty == 0\n        #         return\n        #     A[x][y] = -2\n        #     dfs(x + 1, y, empty - 1)\n        #     dfs(x - 1, y, empty - 1)\n        #     dfs(x, y + 1, empty - 1)\n        #     dfs(x, y - 1, empty - 1)\n        #     A[x][y] = 0\n        # dfs(x, y, empty)\n        # return res\n        \n        m, n = len(grid), len(grid[0])\n        start = end = cnt = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1: start = (i, j)\n                elif grid[i][j] == 2: end = (i, j)\n                if grid[i][j] != -1: cnt += 1 \n        ans = 0\n        def dfs(x, y, cnt):\n            nonlocal ans, start, end\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] != -1): return\n            if (x, y) == end and cnt == 1:\n                ans += 1; return \n            val = grid[x][y]\n            grid[x][y] = -1\n            for i, j in map(lambda t: (t[0]+x, t[1]+y), [(-1, 0), (1, 0), (0, -1), (0, 1)]):\n                dfs(i, j, cnt-1)\n            grid[x][y] = val\n        dfs(*start, cnt)                    \n        return ans", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        self.ans, empty = 0, 0\n        m, n = len(grid[0]), len(grid)\n        def dfs(x, y, rest):\n            if x < 0 or x >= n or y < 0 or y >= m or  grid[x][y] < 0: return\n            if grid[x][y] == 2 and rest == 0:\n                self.ans += 1\n            \n            neibs = [[0,1],[0,-1],[1,0],[-1,0]]\n            for dx, dy in neibs:\n                save = grid[x][y]\n                grid[x][y] = -2\n                dfs(x+dx, y+dy, rest - 1)\n                grid[x][y] = save\n            \n        for i,j in product(list(range(n)), list(range(m))):\n            if grid[i][j] == 1: (sx, sy) = (i,j)\n            empty += (grid[i][j] != -1)\n\n        dfs(sx, sy, empty-1)\n        return self.ans\n", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        # step 1). initialize the conditions for backtracking\n        #   i.e. initial state and final state\n        non_obstacles = 0\n        start_row, start_col = 0, 0\n        for row in range(0, rows):\n            for col in range(0, cols):\n                cell = grid[row][col] \n                if  cell >= 0:\n                    non_obstacles += 1\n                if cell == 1:\n                    start_row, start_col = row, col\n\n        # count of paths as the final result\n        path_count = 0\n\n        # step 2). backtrack on the grid\n        def backtrack(row, col, remain):\n            # we need to modify this external variable\n            nonlocal path_count\n            print(grid)\n\n            # base case for the termination of backtracking\n            if grid[row][col] == 2 and remain == 1:\n                # reach the destination\n                path_count += 1\n                return\n\n            # mark the square as visited. case: 0, 1, 2 \n            temp = grid[row][col] \n            grid[row][col] = -4\n            remain -= 1   # we now have one less square to visit\n\n            # explore the 4 potential directions around\n            for ro, co in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_row, next_col = row + ro, col + co\n\n                if not (0 <= next_row < rows and 0 <= next_col < cols):\n                    # invalid coordinate\n                    continue\n                if grid[next_row][next_col] < 0:\n                    # either obstacle or visited square\n                    continue\n\n                backtrack(next_row, next_col, remain)\n\n            # unmark the square after the visit\n            grid[row][col] = temp\n\n        backtrack(start_row, start_col, non_obstacles)\n\n        return path_count", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        start_cell, end_cell = None, None\n        empty_cells = {} # the set of neighbors' positions for each cell\n\n        # collect empty cells\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] in [0, 1]:\n                    empty_cells[(i, j)] = set()\n                    if grid[i][j] == 1: start_cell = (i, j)\n                elif grid[i][j] == 2: end_cell = (i, j)\n\n        # collect their neighbors\n        for x, y in empty_cells:\n            for xch, ych in directions:\n                neighbor = (x + xch, y + ych)\n                if neighbor in empty_cells: empty_cells[(x, y)].add(neighbor)\n\n        next_to_finish = set((end_cell[0] + xch, end_cell[1] + ych) for xch, ych in directions)\n        visited=set([start_cell])\n        def count_routes(cell=start_cell):\n            left_to_visit = len(empty_cells) - len(visited)\n            if not left_to_visit: return int(cell in next_to_finish)\n            routes_to_end = 0\n            for neighbor in (empty_cells[cell] - visited):\n                visited.add(neighbor)\n                routes_to_end += count_routes(neighbor)\n                visited.remove(neighbor)\n            return routes_to_end\n\n        return count_routes()", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def dfs(r, c, n):\n            if r < 0 or r >= R or c < 0 or c >= C or grid[r][c] == -1:\n                return 0\n            if grid[r][c] == 2:\n                return n == 0\n            grid[r][c] = -1\n            paths = dfs(r + 1, c, n - 1) + dfs(r - 1, c, n - 1) + dfs(r, c + 1, n - 1) + dfs(r, c - 1, n - 1)\n            grid[r][c] = 0\n            return paths\n        \n        R = len(grid)\n        C = len(grid[0])\n        n = 1\n        sr, sc = -1, -1\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == 0:\n                    n += 1\n                elif grid[r][c] == 1:\n                    sr, sc = r, c\n        \n        return dfs(sr, sc, n)\n", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        self.ans = 0\n        m, n = len(grid), len(grid[0])\n        candidates = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    si, sj = i, j\n                elif grid[i][j] == 0 or grid[i][j] == 2:\n                    candidates.add((i, j))\n        \n        def helper(i, j):\n            if grid[i][j] == 2:\n                if not candidates:\n                    self.ans += 1\n                return\n            if grid[i][j] == -1:\n                return\n            if i < m - 1 and (i + 1, j) in candidates:\n                candidates.remove((i+1, j))\n                helper(i+1, j)\n                candidates.add((i+1,j))\n            if i > 0 and (i-1, j) in candidates:\n                candidates.remove((i-1, j))\n                helper(i-1, j)\n                candidates.add((i-1,j))\n                              \n            if j < n - 1 and (i, j+1) in candidates:\n                candidates.remove((i, j+1))\n                helper(i, j+1)\n                candidates.add((i,j+1))\n            if j > 0 and (i, j-1) in candidates:\n                candidates.remove((i, j-1))\n                helper(i, j-1)\n                candidates.add((i,j-1))\n        \n        helper(si, sj)\n        return self.ans", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        \n        self.ans, self.count = 0, 0\n        def go(cur,seen):\n            i,j = cur\n            if grid[i][j] == 2:\n                # print(self.count, len(seen))\n                if len(seen) == self.count: self.ans+=1\n                else: return\n                \n            for r,c, in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n                if 0<=r<len(grid) and 0<=c<len(grid[0]) and (r,c) not in seen and grid[r][c]!=-1:\n                    seen.add((r,c))\n                    go((r,c),seen)\n                    seen.remove((r,c))\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] in [0,1,2]: self.count+=1\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]==1:\n                    go((i,j), {(i,j)})\n                    return self.ans\n        \n        \n        \n        return ans", "class Solution:\n    def uniquePathsIII(self, A: List[List[int]]) -> int:\n        self.res = 0\n        rows = len(A)\n        cols = len(A[0])\n        empty = 1\n        for i in range(rows):\n            for j in range(cols):\n                if A[i][j] == 1: \n                    x,y = (i, j)\n                elif A[i][j] == 2:\n                    end = (i, j)\n                elif A[i][j] == 0: \n                    empty += 1\n        self.dfs(A,x,y, empty, end)\n        return self.res\n    def dfs(self, A, x, y, empty, end):\n            if x < 0 or x >= len(A) or y < 0 or y >= len(A[0]) or A[x][y] < 0:\n                return\n            if (x, y) == end:\n                self.res += empty == 0\n                return\n            A[x][y] = -2\n            self.dfs(A,x + 1, y, empty - 1, end)\n            self.dfs(A,x - 1, y, empty - 1, end)\n            self.dfs(A,x, y + 1, empty - 1, end)\n            self.dfs(A,x, y - 1, empty - 1, end)\n            A[x][y] = 0", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def dfs(i,j,N):\n            if N==-1 and grid[i][j]==2: return 1\n            grid[i][j]=-1                    \n            res = sum([dfs(row,col,N-1) for x,y in dirs for row,col in [(i+x,j+y)] if 0<=row<m and 0<=col<n and (N>0 and not grid[row][col] or N==0 and grid[row][col]==2)])\n            grid[i][j]=0\n            return res\n            \n        m,n = len(grid),len(grid[0])\n        dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n        N = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1: start=[i,j]\n                elif not grid[i][j]: N+=1\n        return dfs(start[0],start[1],N)", "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        \n        nr = len(grid)\n        nc = len(grid[0])\n        \n        all_cells = 0\n        start = (0, 0)\n        res = 0\n        \n        direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for r in range(nr):\n            for c in range(nc):\n                if grid[r][c] >= 0:\n                    all_cells += 1\n                if grid[r][c] == 1:\n                    start = (r, c)\n        \n        def dfs(r, c, cell_nums):\n            nonlocal res\n            nonlocal direction\n            nonlocal grid\n            nonlocal nr\n            nonlocal nc\n            \n            if grid[r][c] == 2 and cell_nums == 1:\n                # reach the destination\n                res += 1\n                return\n            \n            temp = grid[r][c]\n            grid[r][c] = -2\n            cell_nums -= 1\n            \n            for d in direction:\n                rr = r + d[0]\n                cc = c + d[1]\n                if 0 <= rr < nr and 0 <= cc < nc and grid[rr][cc] >= 0:\n                    dfs(rr, cc, cell_nums)\n                    \n            grid[r][c] = temp\n        dfs(*start, all_cells)\n        return res"]
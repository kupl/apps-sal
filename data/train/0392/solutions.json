["class Solution:\n    def numWays(self, s: str) -> int:\n        n = s.count('1')\n        if n % 3 != 0: return 0\n        if n == 0: return (((len(s) - 1) * (len(s) - 2)) // 2) % (10**9 + 7)\n        m = n // 3\n        L = s.split('1')\n        return ((len(L[m]) + 1) * (len(L[2*m]) + 1)) % (10**9 + 7)\n            \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        tot_ones=s.count('1')\n        if tot_ones%3 !=0:\n            return 0\n        \n        c=0\n        ln=len(s)\n        if tot_ones==0:\n            return ((ln-2)*(ln-1)//2)%(10**9+7)\n        fe=ss=se=ts=None\n        for i,d in enumerate(s):\n            if d=='1':\n                c+=1\n            \n            if c==tot_ones//3 and fe is None:\n                fe=i\n            if c==tot_ones//3+1 and ss is None:\n                ss=i\n            if c==2*tot_ones//3 and se is None:\n                se=i\n            if c==2*tot_ones//3+1 and ts is None:\n                ts=i\n        \n        return ((ss-fe)*(ts-se))%(10**9+7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones = 0\n        zeroes = 0\n        for char in s:\n            if char == '1':\n                ones += 1\n            else:\n                zeroes += 1\n        \n        if ones > 0 and ones % 3 != 0:\n            return 0\n        \n        if ones == 0:\n            n = len(s) - 3\n            res = 1\n            diff = 2\n            while n:\n                res += diff\n                diff += 1\n                n -= 1\n            return res % ((10 ** 9) + 7)\n        ones_interval = ones // 3\n        \n        left, right = 0, 0\n        \n        i = 0\n        temp = 0\n        while i < len(s):\n            if s[i] == '1':\n                temp += 1\n            i += 1\n            if temp == ones_interval:\n                break\n        while i < len(s):\n            if s[i] == '0':\n                left += 1\n            if s[i] == '1' or temp == 2 * ones_interval:\n                break\n            i += 1\n        while i < len(s):\n            if s[i] == '1':\n                temp += 1\n            i += 1\n            if temp == 2 * ones_interval:\n                break\n        while i < len(s):\n            if s[i] == '0':\n                right += 1\n            if s[i] == '1':\n                break\n            i += 1\n        if not left:\n            return (right+1) % ((10 ** 9) + 7)\n        if not right:\n            return (left+1) % ((10 ** 9) + 7)\n        return ((left+1)*(right+1)) % ((10 ** 9) + 7)\n", "from scipy.special import comb\n\n\nclass Solution:\n    def numWays(self, s: str) -> int:\n        n = sum(c == '1' for c in s)\n        if n % 3:\n            return 0\n        if n == 0:\n            return comb(len(s) - 1, 2, exact=True) % 1000000007\n        k = n // 3\n        s_iter = iter(s)\n        splited = s.split('1')\n        return (len(splited[k]) + 1) * (len(splited[2 * k]) + 1) % 1000000007", "class Solution:\n    def numWays(self, s: str) -> int:\n        from math import factorial\n        c= s.count('1')\n        if c%3 !=0:\n            return 0\n        if c==0:\n            pos= len(s)-1\n            numerator= factorial(pos)\n            denominator= factorial(2)* factorial(pos-2)\n            return int((numerator/ denominator)% ( 10**9 + 7))\n            \n        num1_each_group= int(c/3)\n       \n        track=0\n        track_g1_l1=0\n        track_g2_f1=0\n        for i in range(len(s)):\n            if s[i]=='1':\n                track+=1\n            if track== num1_each_group:\n                track_g1_l1=i\n                break\n        track=0\n        for i in range(len(s)):\n            if s[i]=='1':\n                track+=1\n               \n            if track== num1_each_group+1:\n                track_g2_f1=i\n                break\n        gap1= track_g2_f1- track_g1_l1\n        \n        track=0\n        track_g2_l1=0\n        for i in range(len(s)):\n            if s[i]=='1':\n                track+=1\n            if track== num1_each_group*2:\n                track_g2_l1=i\n                break\n                \n        track=0\n        track_g3_f1=0\n        for i in range(len(s)):\n            if s[i]=='1':\n                track+=1\n            if track== num1_each_group*2+1 :\n                track_g3_f1=i\n                break\n        \n        gap2=  track_g3_f1- track_g2_l1\n        return int(gap1*gap2% (10**9 + 7))\n       \n                \n            \n            \n                \n           \n                \n", "class Solution:\n    def numWays(self, s: str) -> int:\n      res = 0\n      c = collections.Counter(s)\n      print (c)\n      tot = c['1']\n      if tot%3: return 0\n      mod = 10**9 + 7\n      if tot==0:\n        n = len(s)-1\n        # return (((n%mod)*((n-1)%mod))%mod)//2\n        return ((n*(n-1))//2)%mod\n        \n      \n      ctr = 0\n      res = 1\n      \n      eq = tot//3\n      a, b, c, d = -1, -1, -1, -1\n      for i, ch in enumerate(s):\n        \n        if ch=='1': ctr += 1\n        \n        if a<0 and ctr==eq: a = i\n        if b<0 and ctr==eq+1: b = i\n        if c<0 and ctr==2*eq: c = i\n        if d<0 and ctr==2*eq+1: d = i\n        \n      # print (a, b, c, d)\n      return (((b-a)%mod)*((d-c)%mod))%mod", "class Solution:\n    def numWays(self, s: str) -> int:\n        all = s.count('1')\n        if all == 0:\n            if len(s)%2 ==0:\n                c1, c2 = int((len(s)-2)/2), len(s)-1\n            else:\n                c1, c2 = int((len(s)-1)/2), len(s)-2\n            return self.modres(c1, c2)\n        if all % 3 !=0:\n            return 0\n        one = all/3\n        c1 = self.check(s, one)\n        c2 = self.check(s[::-1], one)\n\n        return self.modres(c1, c2)\n    def modres(self, c1, c2):\n        mod = pow(10,9)+7\n        return ((c1%mod)*(c2%mod))%mod\n\n\n    def check(self, s, one):\n        count = 0\n        for i in range(len(s)):\n            if s[i]=='1':\n                count+=1\n                if count == one:\n                    p1 = i\n                elif count > one:\n                    p2 = i\n                    break\n        return p2-p1\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        m = 10 ** 9 + 7\n        c = Counter(s)\n        ones = c['1']\n        if ones % 3 != 0:\n            return 0\n        if ones == 0:\n            return comb(len(s)-1,2) % m\n        count = 0\n        a = 0\n        b = 0\n        for i in range(len(s)):\n            if count == (ones // 3):\n                a += 1\n            if count == (2*ones // 3):\n                b += 1\n            if s[i] == '1':\n                count += 1\n        #print(a,b)\n        return (a*b % m)", "class Solution:\n    def numWays(self, s: str) -> int:\n        prefix = [0 for i in range(len(s))]\n        for i in range(len(s)):\n            if(s[i] == '1'):\n                if(i == 0):\n                    prefix[i] = 1\n                else:\n                    prefix[i] = 1 + prefix[i-1]\n            else:\n                if(i!=0):\n                    prefix[i] = prefix[i-1]\n        if(prefix[-1] == 0):\n            return(((len(s)-2)*(len(s)-1)//2)%(10**9+7))\n        elif(prefix[-1]%3!=0):\n            return(0)\n        else:\n            c1 = 0\n            c2 = 0\n            for i in range(len(prefix)):\n                if(prefix[i] == prefix[-1]//3):\n                    c1+=1\n                elif(prefix[i] == 2*prefix[-1]//3):\n                    c2+=1\n            return((c1*c2)%(10**9+7))\n                \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        count1s = len([x for x in s if x == '1'])\n        if count1s % 3:\n            return 0\n        if not count1s:\n            return ((len(s)-1)*(len(s)-2)//2) % (1000000007)\n        idx1 = -1\n        idx2 = -1\n        idx3 = -1\n        idx4 = -1\n        ct = 0\n        for i, c in enumerate(s):\n            if c == '1':\n                ct += 1\n            if ct == count1s//3 and idx1 == -1:\n                idx1 = i\n            if ct == (count1s//3)+1 and idx2 == -1:\n                idx2 = i\n            if ct == 2*(count1s//3) and idx3 == -1:\n                idx3 = i\n            if ct == 2*(count1s//3)+1 and idx4 == -1:\n                idx4 = i\n        return (idx2-idx1)*(idx4-idx3) % (1000000007)", "class Solution:\n    def numWays(self, s: str) -> int:\n        M = 10 ** 9 + 7\n        \n        count = collections.Counter(s)\n        print(count)\n        cnt = count['1']\n        if cnt % 3 != 0: return 0        \n        if cnt == 0: return comb(len(s) - 1, 2) % M\n        \n        \n        target = cnt // 3\n        left, mid, right = 0, 0, 0\n        cur = 0\n        \n        for i in range(len(s)):\n            if s[i] == '1':\n                cur+= 1\n            if cur == target:\n                left += 1\n            elif cur == target * 2:\n                mid += 1\n            \n        \n        print((left,mid,right))\n        return left * mid % M\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10**9 + 7\n        \n        total = sum([1 if c == '1' else 0 for c in s])\n        if total == 0:\n            n = len(s)-1\n            return (n * (n-1) // 2) % MOD # nCr combinatorial formula  \n        if total % 3 > 0:\n            return 0\n                \n        x = total // 3\n        count = 0\n        zero1 = 0\n        zero2 = 0\n        for i,c in enumerate(s):\n            if c == '1':\n                count += 1\n            if c == '0' and count == x:\n                zero1 += 1\n            elif c == '0'  and count == 2*x:\n                zero2 += 1\n            \n        ans = (zero1+1) * (zero2+1)    \n        return ans % MOD", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = sum(1 for i in s if i == '1')\n        if n == 0: return ((len(s) - 1) * (len(s) - 2) // 2) % (10 ** 9 + 7)\n        if n % 3 != 0: return 0\n        f1 = f2 = f3 = f4 = False\n        i1 = i2 = i3 = i4 = 0\n        k = n // 3\n        cur = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                cur += 1\n            if not f1 and cur == k:\n                i1 = i\n                f1 = True\n            if not f2 and cur == k + 1:\n                i2 = i\n                f2 = True\n            if not f3 and cur == 2 * k:\n                i3 = i\n                f3 = True\n            if not f4 and cur == 2 * k + 1:\n                i4 = i\n                f4 = True\n        return ((i2 - i1) * (i4 - i3)) % (10 ** 9 + 7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        total, res, n = 0, 0, len(s)\n        for ch in s:\n            if ch == '1':\n                total += 1\n        if total % 3 != 0: return res\n        if total == 0: return (math.factorial(n - 1) // math.factorial(n - 3) // 2) % (10**9 + 7)\n        l, r, cnt = 0, 0, 0\n        for i,ch in enumerate(s):\n            if ch == '1': \n                cnt += 1\n                if cnt == (total // 3): \n                    l = i\n            if cnt == (total // 3) + 1:\n                r = i\n                break\n        res = (r - l) % (10**9 + 7)\n        cnt = 0\n        for i in range(len(s) - 1, -1, -1):\n            ch = s[i]\n            if ch == '1': \n                cnt += 1\n                if cnt == (total // 3): \n                    r = i\n            if cnt == (total // 3) + 1:\n                l = i\n                break\n        res *= (r - l)\n        return res % (10**9 + 7)", "from math import factorial\n\nclass Solution:\n    def numWays(self, s: str) -> int:\n        count1 = s.count('1')\n        if count1 % 3 != 0:\n            return 0\n        required = s.count('1') // 3\n        if not required:\n            return (factorial(len(s) - 1) // factorial(len(s) - 3) // 2 )% 1000000007\n        \n        options = 1\n        for loop in range(2):\n            current = 0\n            for i, ch in enumerate(s):\n                if current == required:\n                    break\n                if ch == '1':\n                    current += 1\n            for j, ch in enumerate(s[i:], 1):\n                if ch == '1':\n                    break\n            options *= j\n            s = s[::-1]\n\n        return options % 1000000007", "from math import factorial\n\nclass Solution:\n    def numWays(self, s: str) -> int:\n        ans = 0\n        n = len(s)\n        xd = s.count('1')\n        if s.count('0') == 0:\n            if xd % 3 != 0:\n                return 0\n            return 1\n        if xd == 0:\n            if n == 3:\n                return 1\n            n = n - 1\n            ans = factorial(n) / factorial(n-2) / factorial(2)\n        else:\n            if xd % 3 != 0:\n                return 0\n            x = xd // 3\n            ti = [x, x]\n            j = 0\n            while ti[0] > 0:\n                if s[j] == '1':\n                    ti[0] -= 1\n                j += 1 \n            ti[0] = j\n            while ti[1] > 0:\n                if s[j] == '1':\n                    ti[1] -= 1\n                j += 1 \n            ti[1] = j\n\n            zc = [0, 0]\n            j = ti[0]\n            while s[j] == '0':\n                zc[0] += 1\n                j += 1\n            j = ti[1]\n            while s[j] == '0':\n                zc[1] += 1\n                j += 1\n                \n            # print(zc)\n            \n            lv = 0\n            rv = 0\n            if zc[0] > 0:\n                zc[0] += 1\n                lv = factorial(zc[0]) / factorial(zc[0]-1)\n            if zc[1] > 0:\n                zc[1] += 1\n                rv = factorial(zc[1]) / factorial(zc[1]-1)\n            \n            if max([lv, rv]) == 0:\n                return 1\n            \n            if lv > 0 and rv > 0:\n                ans = lv * rv\n            else:\n                ans = lv + rv\n        \n        ans = int(ans)\n        return ans % (10**9 + 7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = s.count('1')\n        if n % 3 != 0:\n            return 0\n        if n == 0:\n            return comb(len(s) - 1, 2) % (10**9 + 7)\n        a, b, c, d = self.findThirdOneInds(s, n)\n        return ((b - a) * (d - c)) % (10**9 + 7)\n        \n        \n    def findThirdOneInds(self, s, n):\n        out = []\n        ind = -1\n        for i in range(2 * n // 3 + 2):\n            ind = s.find('1', ind+1)\n            if i == n // 3 - 1:\n                out.append(ind)\n            if i == n // 3:\n                out.append(ind)\n            if i == 2 * n // 3 - 1:\n                out.append(ind)\n            if i == 2 * n // 3:\n                out.append(ind)\n            \n        return out", "class Solution:\n    def numWays(self, s: str) -> int:\n        st = collections.Counter(s)\n        n = len(s)\n        mod = 10**9 + 7\n        if st['1'] == 0:\n            return (((n-1)*(n-2))//2)%mod\n        if st['1']%3:\n            return 0\n        \n        x = st['1']//3\n        i = 0\n        count = 0\n        b1,b2 = 0,0\n        while count <= 2*x:\n            if s[i] == '1':\n                count += 1\n                if count == x:\n                    b1 += 1\n                elif count == 2*x:\n                    b2 += 1\n            if s[i] == '0' and count == x:\n                b1 += 1\n            \n            if s[i] == '0' and count == 2*x:\n                b2 += 1\n            i += 1\n            \n        return (b1*b2)%mod\n                \n            \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        k = s.count('1')\n        if k % 3:\n            return 0\n        \n        if not '1' in s:\n            n = len(s)\n            return ((n - 1) * (n - 2) // 2) % (10**9 + 7)\n        \n        k //= 3\n        \n        l0 = r0 = l1 = r1 = 1 << 60\n        cnt = 0\n        for i, c in enumerate(s):\n            if c == '1':\n                cnt += 1\n            if cnt == k:\n                l0 = min(l0, i)\n            if cnt == k + 1:\n                l1 = min(l1, i)\n            if cnt == 2 * k:\n                r0 = min(r0, i)\n            if cnt == 2 * k + 1:\n                r1 = min(r1, i)\n        \n        print(l0, l1, r0, r1)\n        return (l1 - l0) * (r1 - r0) % (10**9 + 7)", "from math import factorial\n\nclass Solution:\n    def numWays(self, s: str) -> int:\n        ans = 0\n        n = len(s)\n        xd = s.count('1')\n        if s.count('0') == 0:\n            if xd % 3 != 0:\n                return 0\n            return 1\n        if xd == 0:\n            if n == 3:\n                return 1\n            n = n - 1\n            ans = factorial(n) / factorial(n-2) / factorial(2)\n        else:\n            if xd % 3 != 0:\n                return 0\n            x = xd // 3\n            ti = [x, x]\n            j = 0\n            while ti[0] > 0:\n                if s[j] == '1':\n                    ti[0] -= 1\n                j += 1 \n            ti[0] = j\n            while ti[1] > 0:\n                if s[j] == '1':\n                    ti[1] -= 1\n                j += 1 \n            ti[1] = j\n\n            zc = [0, 0]\n            j = ti[0]\n            while s[j] == '0':\n                zc[0] += 1\n                j += 1\n            j = ti[1]\n            while s[j] == '0':\n                zc[1] += 1\n                j += 1\n                \n            # print(zc)\n            \n            lv = 0\n            rv = 0\n            if zc[0] > 0:\n                zc[0] += 1\n                lv = factorial(zc[0]) / factorial(zc[0]-1)\n            if zc[1] > 0:\n                zc[1] += 1\n                rv = factorial(zc[1]) / factorial(zc[1]-1)\n            \n            if max([lv, rv]) == 0:\n                return 1\n            \n            if lv > 0 and rv > 0:\n                ans = lv * rv\n            else:\n                ans = lv + rv\n        # print(1)\n        ans = int(ans)\n        return ans % (10**9 + 7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones = 0\n        d = {}\n        for i in range(len(s)):\n            x = s[i]\n            if x == '1':\n                ones += 1\n            d[i] = ones\n        if ones %3 != 0:\n            return 0\n        if ones == 0:\n            return (len(s)-1)*(len(s)-2)//2%(10**9+7);\n        one = 0\n        for i in range(len(s)-2):\n            if d[i] * 3 == ones:\n                one += 1\n            elif d[i] * 3 > ones:\n                break\n        #print (\\\"one\\\", one, i)\n        two = 0\n        for i in range(i, len(s)-1):\n            if (d[i]/2)*3 == ones:\n                two += 1\n            elif (d[i]/2)*3 > ones:\n                break\n        #print (\\\"two\\\", two)\n        return (one*two)%(10**9+7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = len(s)\n        \n        \n        #calculate count\n        cnt = 0\n        for i in s:\n            if i == '1':\n                cnt += 1\n        if cnt%3 != 0:\n            return 0\n        \n        partn = cnt/3\n        \n        \n        range1_start = n+1\n        range1 = [0,n-3]\n        first = 0\n        last = 0\n        #calculate range1\n        cnt = 0\n        for idx, i in enumerate(s[:n-2]):\n            if i == '1':\n                cnt += 1\n            \n            if cnt == partn:\n                if first == 0:\n                    first = 1\n                    range1[0] = idx\n                \n            if cnt > partn:\n                if last == 0:\n                    last = 1\n                    range1[1] = idx-1\n                \n        \n        #print(range1_low, range1_high)\n        \n        #calculate range2\n        range2 = [range1[0]+1,n-2]\n        first = 0\n        last = 0\n        cnt = 0\n\n        for idx, i in enumerate(s[range2[0]:n]):\n            if i == '1':\n                cnt += 1\n            \n            if cnt == partn:\n                if first == 0:\n                    first = 1\n                    range2[0] += idx \n                \n            if cnt > partn:\n                if last == 0:\n                    last = 1\n                    range2[1] = range1[0] + idx\n                \n        \n        #print(range2_low, range2_high)\n#         print(range1, range2)       \n        \n        total = 0\n        modulo = pow(10,9) + 7\n        for i in range(range1[0], range1[1]+1):\n            j = range2[0]\n            if i<j and i<n and j<n:\n                add = (range2[1] - range2[0] + 1)\n                total += add%modulo\n                #print(add, total)\n            else:\n                total += (range2[1] - i)%modulo\n        # print(total)\n        total =  total%modulo\n        # print(total)\n        return total", "class Solution:\n    def numWays(self, s: str) -> int:\n        all = s.count('1')\n        if all == 0:\n            if len(s)%2 ==0:\n                c1, c2 = int((len(s)-2)/2), len(s)-1\n            else:\n                c1, c2 = int((len(s)-1)/2), len(s)-2\n            return self.modres(c1, c2)\n        if all % 3 !=0:\n            return 0\n        one = all/3\n        c1 = self.check(s, one)\n        c2 = self.check(s[::-1], one)\n\n        return self.modres(c1, c2)\n    def modres(self, c1, c2):\n        mod = pow(10,9)+7\n        return (c1%mod*c2%mod)%mod\n\n\n    def check(self, s, one):\n        count = 0\n        for i in range(len(s)):\n            if s[i]=='1':\n                count+=1\n                if count == one:\n                    p1 = i\n                elif count > one:\n                    p2 = i\n                    break\n        return p2-p1\n\n\n\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones = 0\n        zeroes = 0\n        for char in s:\n            if char == '1':\n                ones += 1\n            else:\n                zeroes += 1\n        \n        if ones > 0 and ones % 3 != 0:\n            return 0\n        \n        if ones == 0:\n            n = len(s) - 3\n            res = 1\n            diff = 2\n            while n:\n                res += diff\n                diff += 1\n                n -= 1\n            return res % ((10 ** 9) + 7)\n        ones_interval = ones // 3\n        \n        left, right = 0, 0\n        \n        i = 0\n        temp = 0\n        while i < len(s):\n            if s[i] == '1':\n                temp += 1\n            i += 1\n            if temp == ones_interval:\n                break\n        while i < len(s):\n            if s[i] == '0':\n                left += 1\n            if s[i] == '1' or temp == 2 * ones_interval:\n                break\n            i += 1\n        while i < len(s):\n            if s[i] == '1':\n                temp += 1\n            i += 1\n            if temp == 2 * ones_interval:\n                break\n        while i < len(s):\n            if s[i] == '0':\n                right += 1\n            if s[i] == '1':\n                break\n            i += 1\n        print((left, right))\n        if not left:\n            return (right+1) % ((10 ** 9) + 7)\n        if not right:\n            return (left+1) % ((10 ** 9) + 7)\n        return ((left+1)*(right+1)) % ((10 ** 9) + 7)\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        # 000 ==> 1\n        # 111 ===> 1\n        nums = [0]*len(s)\n        cum = 0\n        hh = Counter()\n        for i in range(len(s)):\n            if s[i] == '1':\n                cum += 1\n            nums[i] = cum\n            hh[cum] += 1\n        if cum % 3 != 0:\n            return 0\n        if cum == 0:\n            return int(math.comb(hh[0]-1,2))  % (1000000007)\n        each = cum//3 \n        print((hh, each))\n        return int(hh[each]*hh[2*each] % (1000000007))\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        f = [0,0]\n        ind,curr = 0,0\n        target = 0\n        for i in s: target+=1 if i=='1' else 0\n        if target%3:\n            return 0\n        target = target//3\n        n=len(s)\n        if target == 0:\n            return (math.factorial(n-1)//(math.factorial(2)*math.factorial(n-3)))%(10**9+7)\n        for i in range(len(s)):\n            if s[i]=='1':\n                curr+=1\n                if ind==1 or ind==3:\n                    ind+=1\n            elif ind==1 or ind==3:\n                f[(ind-1)//2]+=1\n            if curr==target:\n                ind+=1\n                curr=0\n        return ((f[0]+1)*(f[1]+1))%(10**9+7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = s.count('1')\n        m = 10**9+7\n        if n%3 != 0:\n            return 0\n        if n == 0:\n            return comb(len(s)-1,2)%m\n        n//=3\n        \n        k = n\n        i = 0\n        while k:\n            if s[i] == '1':\n                k-=1\n            i+=1\n        x = 1\n        while s[i] != '1':\n            x+=1\n            i+=1\n        k = n\n        while k:\n            if s[i] == '1':\n                k-=1\n            i+=1\n        y = 1\n        while s[i] != '1':\n            y+=1\n            i+=1\n        return (y*x)%m", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = len(s)\n        n1 = s.count('1')\n        if n1 %3!= 0:\n            return 0\n        if n1 == 0:\n            return int((n - 2) * (n - 1) / 2) % 1000000007\n        j = 0\n        k = 0\n        l = 0\n        m = 0\n        counter1 = 0\n        for i in range(0, n):\n            if s[i] == '1':\n                counter1 += 1\n                if counter1 == n1/3:\n                    j = i\n                if counter1 == n1 / 3 + 1:\n                    k = i\n                if counter1 == n1 /3 *2:\n                    l = i\n                if counter1 == n1 / 3 * 2 + 1:\n                    m = i\n                    break\n        return (k - j ) * (m - l ) % 1000000007\n        \n            \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        mod = pow(10, 9) + 7\n        cnt = s.count('1')\n        if cnt == 0: return (len(s) - 1) * (len(s) - 2) // 2 % mod\n        if cnt % 3 != 0: return 0\n        ones = []\n        for i, x in enumerate(s):\n            if x == '1': ones.append(i)\n        return (ones[cnt//3] - ones[cnt//3-1]) * (ones[2*cnt//3] - ones[2*cnt//3 - 1]) % mod", "class Solution:\n    def numWays(self, s: str) -> int:\n        mod = 10**9+7\n        cnt = s.count('1')\n        if cnt == 0: \n            return (len(s)-1) * (len(s)-2) // 2 % mod\n        if cnt % 3 != 0: \n            return 0\n        ones = []\n        for i,x in enumerate(s):\n            if x == '1': \n                ones.append(i)\n        return (ones[cnt//3] - ones[cnt//3-1]) * (ones[2*cnt//3]- ones[2*cnt//3-1]) % mod\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        count = 0\n        dic = {}\n        M = 10**9+7\n        n = len(s)\n        for i in range(n):\n            if s[i]=='1':\n                count+=1\n                dic[count] = i\n        if count%3 != 0:\n            return 0\n        if count == 0:\n            return int((n-1)*(n-2)/2%M)\n        \n        x = dic[count/3+1]-dic[count/3]\n        y = dic[2*count/3+1]-dic[2*count/3]\n        \n        return x*y%M", "class Solution:\n    def numWays(self, s: str) -> int:\n        d = []\n        for ind,val in enumerate(s):\n            if val=='1':\n                d.append(ind)\n                \n        n = len(d)\n        ndiv = n//3\n        if ndiv*3!=n:\n            return 0\n        \n        if n==0:\n            n = len(s)\n            res = (n-1)*(n-2)>>1\n        else:\n            res = (d[ndiv]-d[ndiv-1])*(d[2*ndiv]-d[2*ndiv-1])\n            \n        return res%(1000000007)\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = s.count('1')\n        M = 1000000007\n        if not n:\n            return ((len(s)-2)*(len(s)-1)//2)%M\n        if n % 3:\n            return 0\n        n //= 3\n        i = 0\n        cnt = 0\n        while i < len(s):\n            if s[i] == '1':\n                cnt += 1\n                if cnt == n:\n                    break\n            i += 1\n        j = len(s) - 1\n        cnt = 0\n        while j >= 0:\n            if s[j] == '1':\n                cnt += 1\n                if cnt == n:\n                    break\n            j -= 1\n        k = i+1\n        while k < len(s) and s[k] == '0':\n            k += 1\n        l = j - 1\n        while l > 0 and s[l] == '0':\n            l -= 1\n        return (j-l)*(k-i)%M", "class Solution:\n    def numWays(self, s: str) -> int:\n        n, ones = len(s), []\n        for i, val in enumerate(s):\n            if val == '1':\n                ones.append(i)\n                \n        target = len(ones)\n        if target == 0:\n            return (((n-1)*(n-2)) // 2) % (10**9 + 7)\n        \n        if target % 3 != 0:\n            return 0\n        \n        c = target // 3\n        return ((ones[c]-ones[c-1])*(ones[2*c]-ones[2*c-1])) % (10**9 + 7)\n        \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        mod = 10 ** 9 + 7\n\n        one = s.count('1')\n        if one % 3: return 0\n        if one == 0: return ((len(s)-1) * (len(s)-2) // 2) % mod\n\n        k = one // 3\n        idx_1, idx_2 = k, k + k\n        cnt = a = b = 0\n        for d in s:\n            if d == '1':\n                cnt += 1\n            if cnt == idx_1: a += 1\n            if cnt == idx_2: b += 1\n        \n        return (a * b) % mod", "class Solution:\n    def numWays(self, s: str) -> int:\n        mod = 10 ** 9 + 7\n        c = s.count('1')\n        if c % 3 != 0:\n            return 0\n        if c == 0:\n            tot = 0\n            for i in range(len(s) - 2):\n                tot += len(s) - 2 - i\n            return tot % mod\n        lsplit = c // 3\n        rsplit = lsplit * 2\n        lz, rz = 1, 1\n        cnt = 0\n        for n in s:\n            if n == '1':\n                cnt += 1\n            else:\n                if cnt == lsplit:\n                    lz += 1\n                elif cnt == rsplit:\n                    rz += 1\n        return (lz * rz) % mod", "class Solution:\n    def numWays(self, s: str) -> int:\n        L, M = len(s), 10 ** 9 + 7\n        ones = s.count('1')\n        if ones == 0:\n            return (L - 1) * (L - 2) // 2 % M\n        if ones % 3:\n            return 0\n        K = ones // 3\n        cnt = one_count = two_count = 0\n        for c in s:\n            if c == '1':\n                cnt += 1\n            if cnt == K:\n                one_count += 1\n            elif cnt == K * 2:\n                two_count += 1\n        \n        return (one_count * two_count) % M\n\n\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        L = len(s)\n        count = collections.Counter(s)\n        if count['0'] == L:\n            return (L - 1) * (L - 2) // 2\n        if count['1'] % 3:\n            return 0\n        K = count['1'] // 3\n        prefix = [0] * L\n        for k, v in enumerate(s):\n            prefix[k] = (v == '1') + (prefix[k - 1] if k else 0)\n        count1 = collections.Counter(prefix)\n        return count1[K] * count1[K * 2] if count1[K * 3] > 0 else 0\n\n    def numWays(self, s: str) -> int:\n        L, M = len(s), 10 ** 9 + 7\n        ones = s.count('1')\n        if ones == 0:\n            return (L - 1) * (L - 2) // 2 % M\n        if ones % 3:\n            return 0\n        K = ones // 3\n        cnt = one_count = two_count = 0\n        for c in s:\n            if c == '1':\n                cnt += 1\n            if cnt == K:\n                one_count += 1\n            elif cnt == K * 2:\n                two_count += 1\n\n        return one_count * two_count % M\n\n\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        one_cnt = 0\n        def dfs(s, num, start, left):\n            ans = 0\n            for i in range(start, len(s)):\n                if s[i] == '1':\n                    one_cnt += 1\n                if one_cnt == num:\n                    ans += dfs(s, num, i+1, left-1)\n                    ans = ans%(10**9+7)\n            return ans\n        \n        one_cnt = Counter(s)['1']\n        if one_cnt%3 != 0:\n            return 0\n        if one_cnt == 0:\n            return ((len(s)-1)*(len(s)-2)//2)%(10**9+7)\n        \n        num = one_cnt/3\n        i = 0\n        cnt = 0\n        while cnt < num:\n            if s[i] == '1':\n                cnt += 1\n            i += 1\n        start = i\n        while i < len(s) and s[i] == '0':\n            i += 1\n        first = i - start + 1\n        \n        cnt2 = 0\n        while cnt2 < num:\n            if s[i] == '1':\n                cnt2 += 1\n            i += 1\n        start2 = i\n        while i < len(s) and s[i] == '0':\n            i += 1\n        second = i - start2 + 1\n        \n        ans = (first*second)%(10**9+7)\n        return ans\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        modv = 10**9+7\n        countOne = 0\n        for x in s:\n            if x == '1':\n                countOne += 1\n        if countOne == 0:\n            return (len(s)-2)*(len(s)-1)//2%modv\n        if countOne%3 !=0:\n            return 0\n        count = 0\n        indexOfOne = []\n        markIndexWhen = [countOne//3, countOne//3+1, countOne//3*2, countOne//3*2+1]\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n                if count in markIndexWhen:\n                    indexOfOne.append(i)\n        return (indexOfOne[1]-indexOfOne[0])*(indexOfOne[-1] - indexOfOne[-2])%modv", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones_count=s.count('1')\n        n=len(s)\n        if ones_count==0:\n            return (((n-2)*(n-1))//2)%(10**9+7)\n        if ones_count%3!=0:\n            return 0\n        no_of_ones=ones_count/3\n        count,count_1st,count_2nd=0,0,0\n        for i in s:\n            if i=='1':\n                count+=1\n            if count==no_of_ones:\n                count_1st+=1\n            if count==2*no_of_ones:\n                count_2nd+=1\n        return (count_1st*count_2nd)%(10**9+7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones = s.count('1')\n        if ones % 3: return 0\n        if ones == 0:\n            return ((len(s)-1)*(len(s)-2)//2)%1000000007\n        ones //= 3\n        c = 0\n        F, S = 0, 0\n        for i, x in enumerate(s):\n            if x == '1':\n                c += 1\n            if c == ones and x == '0':\n                F += 1\n            elif c == 2 * ones and x == '0':\n                S += 1\n        return ((F+1)*(S+1))%1000000007\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        count = s.count('1')\n        \n        if count % 3 != 0:\n            return 0\n        \n        length = len(s) - 1\n        if count == 0:\n            return (( length ) * ( length - 1 ) // 2) % 1000000007\n        \n        first_range, second_range, index, curr_ones, per_triplet = 1, 1, 0, 0, count // 3\n        \n        while index < length:\n            if curr_ones > 2 * per_triplet:\n                break\n            \n            if s[index] == '1':\n                curr_ones += 1\n            elif curr_ones == per_triplet:\n                first_range += 1\n            elif curr_ones == 2 * per_triplet:\n                second_range += 1\n            \n            index += 1\n\n        return (first_range * second_range) % 1000000007", "class Solution:\n    # 300 ms 29.38%. Time and Space: O(N)\n    def numWays(self, s: str) -> int:\n        ones = sum(c == '1' for c in s)\n        \n        if ones % 3: return 0\n        \n        if ones == 0:\n            N = len(s) - 2\n            return N * (N + 1) // 2 % (10**9 + 7)\n        \n        target = ones // 3\n        \n        N = len(s)\n        \n        left1 = left2 = None\n        cnt = 0\n        for i, c in enumerate(s):\n            if c == '1':\n                cnt += 1\n            if cnt == target:\n                if left1 is None:\n                    left1 = i\n                left2 = i\n        \n        right1 = right2 = None\n        cnt = 0\n        for i, c in enumerate(s[::-1]):\n            if c == '1':\n                cnt += 1\n            if cnt == target:\n                if right1 is None:\n                    right1 = N - 1 - i\n                right2 = N - 1 - i\n        ans = (left2 - left1 + 1) * (right1 - right2 + 1) \n        return ans % (10**9 + 7)\n    \n    def numWays(self, s: str) -> int:\n        ones = sum(c == '1' for c in s)\n        \n        if ones % 3: return 0\n        if ones == 0:\n            N = len(s) - 2\n            return N * (N + 1) // 2 % (10**9 + 7)\n        \n        target = ones // 3\n        indexes = [i for i, c in enumerate(s) if c == '1']\n        ans = (indexes[target] - indexes[target - 1]) * (indexes[-target] - indexes[~target])\n        return ans % (10**9 + 7)\n            \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        ttt = 10**9+7\n        zs = list(map(len, s.split('1')))\n        \n        if not (len(zs)-1) % 3 == 0 :\n            return 0\n        if len(zs) == 1 :\n            return (len(s)-1)*(len(s)-2)//2 % ttt\n        ps = len(zs)//3\n        return (zs[ps]+1)*(zs[ps*2]+1)% ttt", "class Solution:\n    def numWays(self, s: str) -> int:\n        count = s.count('1')\n        \n        if count % 3 != 0:\n            return 0\n        \n        length = len(s) - 1\n        if count == 0:\n            return (( length ) * ( length - 1 ) // 2) % 1000000007\n        \n        first_range, second_range, index, curr_ones, per_triplet = 1, 1, 0, 0, count // 3\n        \n        while index < length:\n            if s[index] == '1':\n                curr_ones += 1\n            elif curr_ones == per_triplet:\n                first_range += 1\n            elif curr_ones == 2 * per_triplet:\n                second_range += 1\n            \n            index += 1\n\n        return (first_range * second_range) % 1000000007", "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        n = sum(1 for c in s if c == '1')\n        if n % 3 != 0:\n            return 0\n        if n == 0:\n            t = (len(s) - 1) * (len(s) - 2) // 2\n            return t % MOD\n        n //= 3\n        \n        def f(s, n):\n            i = 0\n            while n:\n                n -= 1 if s[i] == '1' else 0\n                i += 1\n            k = 1\n            while s[i] == '0':\n                k += 1\n                i += 1\n            return k\n        \n        return f(s, n) * f(''.join(reversed(s)), n) % MOD", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones = s.count('1')\n        if ones%3!=0:\n            return 0\n        n = len(s)\n        mod = 10**9+7\n        if ones==0:\n            return (n-1)*(n-2)//2%mod\n        count = 0\n        first_count = 0\n        second_count = 0\n        for cha in s:\n            if cha == '1':\n                count += 1\n            if count == ones//3:\n                first_count+=1\n            elif count == ones//3*2:\n                second_count+=1\n        return first_count*second_count%mod", "class Solution:\n    def numWays(self, s: str) -> int:\n        \n        def nice_multiply(a, b, mod):\n            \n            (a / 8) \n        \n        def get_total_ones():\n            \n            result = 0\n            \n            for binary in s:\n                if binary == '1':\n                    result += 1\n            \n            return result\n        \n        total_ones = get_total_ones()\n        \n        if total_ones == 0:\n            \n            return int((len(s) - 1) * (len(s) - 2) / 2) % 1000000007\n        \n        if total_ones % 3 != 0:\n            return 0\n        \n        first_cut_numbers = 0\n        second_cut_numbers = 0\n        \n        cut_amount = total_ones / 3\n        \n        current_ones = 0\n        \n        for binary in s:\n            \n            if binary == '1':\n                current_ones += 1\n            \n            if current_ones == cut_amount:\n                first_cut_numbers += 1\n            \n            if current_ones == 2 * cut_amount:\n                second_cut_numbers += 1\n        \n        return (first_cut_numbers * second_cut_numbers) % 1000000007", "class Solution:\n    def numWays(self, s: str) -> int:\n        count_map = collections.Counter(s)\n        if count_map['1']%3!=0:\n            return 0\n        else:\n            if count_map['1']==0:\n                if count_map['0']<3:\n                    return 0\n                \n                if count_map['0']==3:\n                    return 1\n                \n                i = 4\n                res = 1\n                while i<=count_map['0']:\n                    res += i-2\n                    i+=1\n                return res%1000000007\n                    \n            else:\n                i = 0\n                one_count = 0\n                s1_start, s1_end, s2_start, s2_end = -1,-1,-1,-1\n                factor = count_map['1']//3\n                while i<len(s):                    \n                    if s[i]=='1':\n                        one_count+=1\n                        if one_count==factor:\n                            s1_start = i\n                        elif one_count==(factor+1):\n                            s1_end = i\n                        \n                        if one_count==(factor*2):\n                            s2_start = i\n                        elif one_count==(factor*2+1):\n                            s2_end = i\n                            break\n                    i+=1\n                return ((s1_end-s1_start)*(s2_end-s2_start))%1000000007\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        totalones = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                totalones+=1\n        \n        if totalones%3 != 0:\n            return 0\n        if totalones == 0:\n            return ((len(s) - 2)*(len(s) - 1)//2) % (10**9 + 7)\n        onesEachPart, waysFirstPart, waysSecondPart = totalones//3, 0, 0\n        count = i = 0\n        while count <= 2*onesEachPart:\n            if s[i] == '1':\n                count+=1\n            if count == onesEachPart:\n                waysFirstPart+=1\n            elif count == 2*onesEachPart:\n                waysSecondPart+=1\n            i+=1\n        \n        return (waysFirstPart * waysSecondPart) % (10**9 + 7)\n                \n            \n", "from math import comb\nclass Solution:\n    def numWays(self, s: str) -> int:\n        n = len(s)\n        k = s.count('1')\n        if k%3:\n            return 0\n        if k == 0:\n            return comb(n-1, 2) % (10**9 + 7)\n        third = k // 3\n        start=-1\n        for i in range(third):\n            start = s.find('1', start+1)\n        first_last = start\n        for i in range(third):\n            start = s.find('1', start+1)\n        second_last = start\n        first_zeros = s.count('0', first_last, s.find('1', first_last+1))\n        second_zeros = s.count('0', second_last, s.find('1', second_last+1))\n        return ((first_zeros+1)*(second_zeros+1))% (10**9 + 7)\n        \n            \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = len(s)\n        count = 0\n        cur = 0\n        mod = 1000000007\n        for i in range(len(s)):\n            if s[i] == '1':\n                cur +=1\n            \n        if cur == 0:\n            return (((n-1)*(n-2))//2)%mod\n        \n        left = 0 \n        lc = 0\n        for i in range(n):\n            if s[i] == '1':\n                left+=1\n            if left == cur/3:\n                lc += 1\n            if left > cur/3:\n                break\n        right = 0\n        rc = 0\n        for i in range(n-1,-1,-1):\n            if s[i] == '1':\n                right+=1\n            if right == cur/3:\n                rc += 1\n            if right > cur/3:\n                break\n        return (lc*rc)%mod\n", "from math import comb\n\nclass Solution:\n    def numWays(self, s: str) -> int:\n        ones = 0\n        for c in s:\n            if c == '1':\n                ones += 1\n        if ones == 0:\n            return comb(len(s) - 1, 2) % (10**9 + 7)\n        \n        if ones % 3 != 0:\n            return 0\n        \n        i = 0\n        found = 0\n        a = None\n        while i < len(s):\n            c = s[i]\n            if c == '1':\n                found += 1\n            if found == (ones//3):\n                count = 0\n                i += 1\n                c = s[i]\n                while c == '0':\n                    count += 1\n                    i += 1\n                    c = s[i]\n                if not a:\n                    a = count + 1\n                    i -= 1\n                else:\n                    return (a * (count + 1)) % (10**9 + 7)\n                found = 0\n            i += 1", "class Solution:\n    def numWays(self, s: str) -> int:\n        one, n, m = s.count('1'), len(s), 10**9 + 7\n        # special case: first one for left -> n-2, first two for left -> n-3, ..., 2, 1\n        # -> (n-2) + (n-3) + ... + 2 + 1 -> (n-1) * (n-2) // 2\n        if not one: return (n - 1) * (n - 2) // 2 % m\n        if one % 3: return 0\n        curr = l = r = 0\n        for c in s:\n            curr += c == '1'\n            l += curr == (one // 3)\n            r += curr == (2 * one // 3)\n        \n        return l * r % m", "class Solution:\n    def numWays(self, s: str) -> int:\n        c = s.count('1')\n        if c%3: return 0\n        M = 10**9 +7\n        if not c:\n            return (len(s)-1)*(len(s)-2)//2%M\n    \n        cur = 0\n        first = 0\n        second = 0\n        for l in s:\n            if cur == c//3:\n                first += 1\n            elif cur == c//3*2:\n                second += 1\n            cur += l == '1'\n            \n        return first*second%M\n", "class Solution:\n    def numWays(self, s: str) -> int:        \n        k = s.count('1')\n        if k % 3 != 0: return 0\n        n, M = len(s), 10**9 + 7\n        if k == 0: return (n-1)*(n-2)//2 % M\n        ans, cnt, i = 1, 0, 0         \n        while i < len(s):            \n            cnt += s[i] == '1'\n            if cnt in [k//3, 2*k//3]:\n                j = i+1\n                while j < len(s) and s[j] == '0': j += 1\n                ans *= j-i\n                i = j            \n            else: i += 1\n            if cnt == 2*k//3: break\n        return ans % M\n                \n                \n", "import collections\n\nclass Solution:\n    def numWays(self, s):\n        count = collections.Counter(s)\n        if count['1'] == 0:\n            return (len(s) - 1) * (len(s) - 2) // 2 % (10**9 + 7)\n        \n        if count['1'] < 3 or count['1'] % 3 != 0:\n            return 0\n        \n        ans = 1\n        cur = 0\n        expand = 1\n        find = count['1'] // 3\n        slot = 0\n        \n        for ss in s:\n            if slot == 2:\n                return ans * expand\n\n            if find > cur:\n                # collecting 1\n                if ss == '1':\n                    cur += 1\n            else:\n                # collecting 0\n                # set to next slot if encounter 1\n                if ss == '0':\n                    expand += 1\n                else:\n                    ans *= expand\n                    expand = 1\n                    cur = 1\n                    slot += 1\n                    \n        ans *= expand\n        return ans % (10**9 + 7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = s.count('1')\n        if n%3!=0:\n            return 0\n        n = int(n/3)\n        if n==0:\n            ans = 0\n            for i in range(1,len(s)-1):\n                ans += len(s)-1-i\n            return ans%(10**9 + 7)\n        else:\n            a = s.split('1')\n            return (len(a[n])+1) * (len(a[2*n])+1)%(10**9 + 7)\n", "# 2:52 if num ones % 3 != 0 can't be done\n# identify groups, find 0s between them\n# 1 00 1 00 1\n# |00, 0|0, 00|\n# 1 n 1 m 1\n# (n + 1)*(m + 1)\n# 0 0000 0 -> |0000 (|000, 0|00, 00|0, 000|), 0|000, 00|00, 000|0, 0000|\n# 0 000 0 -> |0|00, |00|0, |000|, 0|0|0, 0|00|, 00|0|\nclass Solution:\n    def numWays(self, s: str) -> int:\n        count = len(list([char for char in s if char == '1']))\n        if count % 3 != 0:\n            return 0\n    \n        if count / 3 == 0:\n            zeroes_in_middle = len(s) - 2\n            total = 0\n            for marker in range(zeroes_in_middle + 1):\n                total += (zeroes_in_middle - marker) % (10**9 + 7)\n            return total % (10**9 + 7)\n        \n        def get_zeroes(s, count):\n            num_ones = 0\n            zeroes = {'first': 0, 'second': 0}\n            for bit in s:\n                if bit == '1':\n                    num_ones += 1\n                else:\n                    if num_ones == count:\n                        zeroes['first'] += 1\n                    elif num_ones == 2*count:\n                        zeroes['second'] += 1\n            return zeroes\n                    \n        \n        zeroes = get_zeroes(s, count / 3)\n        \n        # print(zeroes)\n        \n        if not zeroes['first'] and not zeroes['second']:\n            return 1\n        elif zeroes['first'] and not zeroes['second']:\n            return zeroes['first'] + 1\n        elif zeroes['second'] and not zeroes['first']:\n            return zeroes['second'] + 1\n        \n        return (zeroes['first'] + 1)*(zeroes['second'] + 1) % (10**9 + 7)\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        md = 10**9 + 7\n        res = 0\n        n = len(s)\n        n1 = sum(map(lambda x1: 1 if x1 == '1' else 0, s))\n        if n > 2 and n1 % 3 == 0:\n            x = n1 // 3\n            x2 = x << 1\n            if x == 0:\n                res = (n - 1) * (n - 2) // 2\n            else:\n                cnt,c1,c2 = 0,0,0\n                for i,c in enumerate(s):\n                    if c == '1':\n                        cnt += 1\n                    if cnt == x:\n                        c1 += 1\n                    elif cnt == x2:\n                        c2 += 1\n                res = c1 * c2\n        return res % md", "class Solution:\n    def numWays(self, s: str) -> int:\n        N, ones = len(s), 0\n        for c in s:\n            ones += 1 if c == '1' else 0\n        \n        if ones % 3 == 1:\n            return 0\n        \n        if ones == 0:\n            return (((N-1) * (N-2)) >> 1) % (10**9 + 7)\n        \n        want = ones // 3\n        c1, c2 = 0, 0\n        p, suff = 0, 0\n        for c in s:\n            if c == '1': c1 += 1\n            if c1 == want:\n                p += 1\n        \n        for c in reversed(s):\n            if c == '1': c2+=1\n            if c2==want:\n                suff+=1\n        \n        return (p * suff) % (10**9 + 7)\n        \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        ones = sum(c == '1' for c in s)\n        if ones % 3:\n            return 0\n        if ones == 0:\n            N = len(s) - 2\n            return N * (N + 1) // 2 % (10**9 + 7)\n        \n        target = ones // 3\n        \n        N = len(s)\n        \n        left1 = left2 = None\n        cnt = 0\n        for i, c in enumerate(s):\n            if c == '1':\n                cnt += 1\n            if cnt == target:\n                if left1 is None:\n                    left1 = i\n                left2 = i\n        \n        right1 = right2 = None\n        cnt = 0\n        for i, c in enumerate(s[::-1]):\n            if c == '1':\n                cnt += 1\n            if cnt == target:\n                if right1 is None:\n                    right1 = N - 1 - i\n                right2 = N - 1 - i\n        ans = (left2 - left1 + 1) * (right1 - right2 + 1) \n        return ans % (10**9 + 7)\n            \n", "class Solution:\n\n    def numWays(self, s: str) -> int:\n        L, M = len(s), 10 ** 9 + 7\n        ones = s.count('1')\n        if ones == 0:\n            return (L - 1) * (L - 2) // 2 % M\n        if ones % 3:\n            return 0\n        K = ones // 3\n        cnt = one_count = two_count = 0\n        for c in s:\n            if c == '1':\n                cnt += 1\n            if cnt == K:\n                one_count += 1\n            elif cnt == K * 2:\n                two_count += 1\n\n        return one_count * two_count % M\n\n    def numWays(self, s: str) -> int:\n        L, M = len(s), 10**9+7\n        count = collections.Counter(s)\n        if count['0'] == L:\n            return (L - 1) * (L - 2) // 2 % M\n        if count['1'] % 3:\n            return 0\n        K = count['1'] // 3\n        prefix = [0] * L\n        for k, v in enumerate(s):\n            prefix[k] = (v == '1') + (prefix[k - 1] if k else 0)\n        count1 = collections.Counter(prefix)\n        return count1[K] * count1[K * 2] % M\n\n", "def findall(p, s):\n    '''Yields all the positions of\n    the pattern p in the string s.'''\n    i = s.find(p)\n    while i != -1:\n        yield i\n        i = s.find(p, i+1)\n\ndef choose(n, k):\n    c = 1\n    if k > n // 2:\n        k = n - k\n    for i in range(1, k + 1):\n        c = c * (n - i + 1) // i\n    return c\n\ndef modulo(n):\n    return n % (10 ** 9 + 7)\n\nclass Solution:\n    \n    def numWays(self, s: str) -> int:\n        n = len(s)\n        c = s.count('1')\n        if c % 3 != 0:\n            return 0\n        cp = c // 3 # count in each part\n        if cp == 0:\n            #special case, no 1, chosse 2 separators in the (n-1) possible spaces\n            return modulo(choose(n - 1, 2))\n        # find the size n1 of the substring between (cp+1)-th and cp-th occurrances of 1,\n        # and the size n2 of the subsring betwwen (cp*2+1)-th and (cp*2)-th occurrances of 1\n        indices = list(findall('1', s))\n        n1 = indices[cp] - indices[cp - 1] - 1\n        n2 = indices[cp*2] - indices[cp*2 - 1] - 1\n        # find one separater in (n1 + 1) possible spaces, \n        # and one separater in (n2 + 1) possible spaces \n        result = 0\n        if n1 == 0:\n            result = n2 + 1\n        elif n2 == 0:\n            result = n1 + 1\n        else:\n            result = (n1 + 1) * (n2 + 1)\n        return(modulo(result))\n", "class Solution:\n    CONST = 10**9 + 7\n    def numWays(self, s: str) -> int:\n        n = len(s)\n        num_ones = 0\n        for c in s:\n            if c == '1':\n                num_ones += 1\n        if num_ones % 3 != 0:\n            return 0\n        if num_ones == 0:\n            return ((n-1) * (n-2) // 2)  % self.CONST\n        \n        first, second = 0, 0\n        num_ones_sofar, cutoff = 0, num_ones // 3\n        # print(cutoff)\n        for i in range(n):\n            num_ones_sofar += s[i] == '1'\n            if num_ones_sofar < cutoff:\n                pass\n            elif cutoff <= num_ones_sofar < cutoff + 1:\n                first += 1\n            elif 2 * cutoff <= num_ones_sofar < 2 * cutoff + 1:\n                second += 1  \n            else:\n                pass\n            # print(first, second)\n        return (first * second) % self.CONST\n                \n            \n            \n", "class Solution:\n    \n    # from collections import Counter\n    \n    CONST = 1_000_000_000 + 7\n    \n    def numWays(self, s: str) -> int:\n        n = len(s)\n        # edge cases \n        num_ones = 0\n        for c in s:\n            if c == '1':\n                num_ones += 1        \n        if num_ones % 3 != 0:\n            return 0\n        if num_ones == 0:\n            return ((n-1) * (n-2) // 2) % self.CONST\n        \n        # general case \n        # \\\"100100010100110\\\"\n        # 1001| 00010100110\n        # 10010| 0010100110        \n        # 100100| 010100110 \n        # 1001000| 10100110\n        \n        # 0 0\n        # 0 0\n        # 0 0\n        # 1 0\n        # 2 0\n        # 3 0\n        # 4 0\n        # 4 1\n        # 4 2\n        # 4 2\n        # 4 2\n        # 4 2\n        # 4 2\n        # 4 2\n        # 4 2\n        \n        num_ones_per_chunk = num_ones // 3\n        first, second = 0, 0\n        num_ones_sofar = 0\n        \n        # dumb version\n        for idx, c in enumerate(s):\n            num_ones_sofar += c == '1'\n            if num_ones_sofar < num_ones_per_chunk:\n                pass\n            elif num_ones_per_chunk <= num_ones_sofar < num_ones_per_chunk + 1:\n                first += 1\n            elif 2 * num_ones_per_chunk <= num_ones_sofar < 2 * num_ones_per_chunk + 1:\n                second += 1\n            else:\n                pass\n            # print(s[:idx+1])\n            # print(first, second)\n            # print('')\n            \n        # # smart version\n        # for c in s:\n        #     num_ones_sofar += c == '1'\n        #     if num_ones_sofar == num_ones_per_chunk:\n        #         first += 1\n        #     elif num_ones_sofar == 2 * num_ones_per_chunk:\n        #         second += 1\n        \n        # \\\"10101\\\"\n        # \\\"1001\\\"\n        # \\\"000000\\\"\n        return (first * second) % self.CONST\n            \n            \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        n = len(s)\n        mod = 10 ** 9 + 7\n        nums1 = sum(1 if s[i] == '1' else 0 for i in range(n))\n        if nums1 % 3 != 0:\n            return 0\n        num_per = nums1 // 3\n        if num_per == 0:\n            res = 0\n            for i in range(1, n - 1):\n                res = (res + (n - 1 - i)) % mod\n            return res\n        def find_end(start, num1):\n            count = 0\n            index = start\n            while index < n and count < num1:\n                if s[index] == '1':\n                    count += 1\n                index += 1\n            return index - 1\n        end1 = find_end(0, num_per)\n        i = end1 + 1\n        while s[i] != '1':\n            i += 1\n        end2 = find_end(i, num_per)\n        j = end2 + 1\n        while s[j] != '1':\n            j += 1\n        return ((i - end1) * (j - end2)) % mod\n", "from functools import reduce, lru_cache\n\n\nclass Solution:\n    def numWays(self, arr: str) -> int:\n        arr = list(arr)\n        count = reduce((lambda accu, element: accu +\n                        (1 if element == '1' else 0)), arr, 0)\n        if count % 3 != 0:\n            return 0\n        if count == 0:\n            return ((len(arr) - 1) * (len(arr) - 2) >> 1) % (10**9 + 7)\n\n        target = count / 3\n\n        accu = 0\n        ways_of_first_cut = 0\n        ways_of_second_cut = 0\n        for c in arr:\n            if c == '1':\n                accu += 1\n            if accu == target:\n                ways_of_first_cut += 1\n            elif accu == target * 2:\n                ways_of_second_cut += 1\n\n        return (ways_of_first_cut * ways_of_second_cut) % (10**9 + 7)\n", "class Solution:\n    def numWays(self, s: str) -> int:\n        l = len(s)\n        total_cnt = 0\n        for i in range(l):\n            if s[i] == '1':\n                total_cnt += 1\n        if total_cnt % 3:\n            return 0\n        \n        cnt = total_cnt // 3\n        if total_cnt == 0:\n            return ((len(s) - 1) * (len(s) - 2) // 2) % (10**9 + 7)\n        \n        c1, c2 = 1, 1\n        s1, s2 = s, s[::-1]\n        idx = 0\n        i1 = self.findIdx(s1, cnt)\n        i2 = self.findIdx(s2, cnt)\n        \n        while s1[i1] != '1':\n            c1 += 1\n            i1 += 1\n        while s2[i2] != '1':\n            c2 += 1\n            i2 += 1\n        return c1 * c2 % (10**9 + 7)\n        \n\n    def findIdx(self, s, cnt):\n        c, idx = 0, 0\n        while idx < len(s) and c < cnt:\n            if s[idx] == '1':\n                c += 1\n            idx += 1\n        \n        return idx\n    \n            \n    \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        cnt=0\n        ans=0\n        n=len(s)\n        m=1000000007\n        for i in range(len(s)):\n            if(s[i]=='1'):\n                cnt+=1\n        if(cnt==0):\n            ans=((n-1)*(n-2))/2\n            ans=ans%m\n            return int(ans)\n        else:\n            hm=dict()\n            cnt=0\n            ans=0\n            for i in range(len(s)):\n                if(s[i]=='1'):\n                    cnt+=1\n                if cnt not in hm.keys():\n                    hm[cnt]=1\n                else:\n                    hm[cnt]=hm[cnt]+1\n            if(cnt%3!=0):\n                return 0\n            else:\n                first=hm[cnt/3]\n                tthird=(cnt/3)*2\n                second=hm[tthird]\n                ans=((first%m)*(second%m))%m         \n            return int(ans)", "class Solution:\n    def numWays(self, s: str) -> int:\n        l = len(s)\n        total_cnt = 0\n        for i in range(l):\n            if s[i] == '1':\n                total_cnt += 1\n        if total_cnt % 3:\n            return 0\n        \n        cnt = total_cnt // 3\n        if total_cnt == 0:\n            return ((len(s) - 1) * (len(s) - 2) // 2) % (10**9 + 7)\n        \n        c1, c2 = 1, 1\n        s1, s2 = s, s[::-1]\n        idx = 0\n        i1 = self.findIdx(s1, cnt)\n        i2 = self.findIdx(s2, cnt)\n        \n        while s1[i1] != '1':\n            c1 += 1\n            i1 += 1\n        while s2[i2] != '1':\n            c2 += 1\n            i2 += 1\n        return (c1 * c2) % (10**9 + 7)\n        \n\n    def findIdx(self, s, cnt):\n        c, idx = 0, 0\n        while idx < len(s) and c < cnt:\n            if s[idx] == '1':\n                c += 1\n            idx += 1\n        \n        return idx\n    \n            \n    \n", "class Solution:\n    def numWays(self, s: str) -> int:\n        if not s or len(s) < 3 or s.count('1') % 3 != 0:\n            return 0\n        \n        mod = pow(10, 9) + 7\n        n = s.count('1')\n        if n == 0:\n            return (len(s) - 1) * (len(s) - 2) // 2 % mod\n        \n        c1, c2, i = 0, 0, 0\n        for ch in s:\n            if ch == '1':\n                i += 1\n            elif ch == '0' and n / 3 <= i < n / 3 + 1:\n                c1 += 1\n            elif ch == '0' and n*2 / 3 <= i < n*2 / 3 + 1:\n                c2 += 1\n        return (c1 + 1) * (c2 + 1) % mod", "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        ones = 0\n        for c in s:\n            ones += 1 if c == '1' else 0\n        n = len(s)\n        \n        if ones % 3 != 0:\n            return 0\n        if ones == 0:\n            return ((n - 2) * (n - 1) // 2) % MOD\n        \n        ones = ones // 3\n        firstLeft = firstRight = - 1\n        secondLeft = secondRight = -1\n        count = 0\n        for i in range(n):\n            if s[i] == '1':\n                count += 1\n                \n            if count == ones and firstLeft == -1:\n                firstLeft = i\n            if count == ones + 1 and firstRight == -1:\n                firstRight = i\n                \n            if count == 2 * ones and secondLeft == -1:\n                secondLeft = i\n            if count == 2 * ones + 1 and secondRight == -1:\n                secondRight = i\n        \n        return ((firstRight - firstLeft) * (secondRight - secondLeft)) % MOD", "import math\nclass Solution:\n    def numWays(self, s: str) -> int:\n        dict1 = dict()\n        cur = 0\n        for i in range(len(s)):\n            if(s[i] == '1'):\n                dict1[cur+1] = i\n                cur += 1\n        if(cur%3 != 0):\n            return 0\n        if(cur == 0):\n            len_s = len(s)-1\n            return (math.factorial(len_s)//(math.factorial(len_s-2)*math.factorial(2)))%(10**9 + 7)\n        \n        div = cur//3\n        return ((dict1[div+1] - dict1[div])*(dict1[div*2 + 1] - dict1[div*2]))%(10**9 + 7)", "class Solution:\n    def numWays(self, s: str) -> int:\n        cnt = s.count('1')\n        if cnt % 3 != 0:\n            return 0\n        if cnt == 0:\n            ans = 0\n            for i in range(1, len(s) - 1):\n                ans += i\n            return ans % (10**9 + 7)\n        \n        l = r = 1\n        c = 0\n        \n        for i, n in enumerate(s):\n            c += 1 if n == '1' else 0\n            \n            if  c == cnt / 3 and n == '0':\n                l += 1\n            elif c == (cnt / 3) * 2 and n == '0':\n                r += 1\n        \n        print((l, r))\n        return l * r % (10**9 + 7)\n", "\nclass Solution:\n    \n    import math\n    \n    def C(self, N,r):\n        return int(math.factorial(N)/(math.factorial(r)*math.factorial(N-r)))\n    \n    def numWays(self, s: str) -> int:\n        counter=s.count('1')\n        if counter%3!=0:\n            return 0\n        if counter==0:\n            return self.C(len(s)-1, 2) % (10**9+7) \n        \n        \n        index=[]\n        cnt=0\n        for ind,char in enumerate(s):\n            if char=='1':\n                cnt+=1\n                if cnt==counter//3:\n                    index.append(ind)\n                    \n                if cnt==(counter//3)+1:\n                    index.append(ind)\n                    \n                if cnt==(2*counter//3):\n                    index.append(ind)\n                    \n                if cnt==(2*counter//3)+1:\n                    index.append(ind)\n  \n        m=index[1]-index[0]\n        n=index[3]-index[2]\n        return m*n % (10**9+7) \n        \n"]
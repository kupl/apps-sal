["# cook your dish here\nn=int(input())\ncounts=dict()\nz=0\nupper=None\nfor i in range(0,n):\n a,h= [int(num) for num in input().split()]\n counts[a]=h\nfor key,count in counts.items():\n c=0\n x=key-count\n y=key+count\n c1=0\n c2=0\n for j in counts.keys():\n  if j==key:\n   continue\n  else:\n   if x<=j<=key:\n    c1=0\n    break\n   else:\n    c1=1\n for j in counts.keys():\n  if j==key:\n   continue\n  else:\n   if key<=j<=y:\n    c2=0\n    break\n   else:\n    c2=1\n if c2==0 and c1==1:\n  if upper is None:\n   z=z+c1\n   upper=key\n  else:\n   if x>=upper:\n    z=z+c1\n    upper=key\n   else:\n    z=z+c2\n    upper=key\n elif c2==1 and c1==0:\n  if upper is None:\n   z=z+c2\n   upper=y\n  else:\n   if upper<=key:\n    z=z+c2\n    upper=y\n   else:\n    z=z+c1\n    upper=y\n elif c2==1 and c1==1:\n  if upper is None:\n   z=z+c1\n   upper=key\n  else:\n   if x>=upper:\n    z=z+c1\n    upper=key\n   else:\n    if upper<=key:\n     z=z+c2\n     upper=y\n    else:\n     z=z+0\n     upper=y\n else:\n  z=z+0\n  upper=key\nif len(counts)==1:\n print(1)\nelse:\n print(z)", "l=[]\nn=int(input())\nfor i in range(n):\n l.append(list(map(int,input().split())))\nif(n==1):\n print(1)\nelse:\n c=2\n for i in range(1,n-1):\n  if(l[i][0]-l[i][1]>l[i-1][0]):\n   c=c+1\n  elif(l[i][0]+l[i][1]<l[i+1][0]):\n   l[i][0]+=l[i][1]\n   c=c+1\n print(c)\n", "# cook your dish here\n#Coding is about expressing your feeling and\n#there is always a better way to express your feeling _Deepak\nimport sys\n# sys.stdin=open('input.txt','r')\n# sys.stdout=open('output.txt','w')\nfrom sys import stdin,stdout\nfrom collections import deque,defaultdict\nfrom math import ceil,floor,inf,sqrt,factorial,gcd,log2\nfrom copy import deepcopy\nii1=lambda:int(stdin.readline().strip())\nis1=lambda:stdin.readline().strip()\niia=lambda:list(map(int,stdin.readline().strip().split()))\nisa=lambda:stdin.readline().strip().split()\nmod=1000000007\n# s=is1()\n# n = len(s)\n# count,res,flag,subans=1,0,0,1\n# subcount=0\n# for i in range(0,n-1):\n#     if s[i]=='c' or s[i]=='k':\n#         flag=1\n#         break\n#     if s[i]==s[i+1] and (s[i]=='f' or s[i]=='g'):\n#         count+=1\n#     elif count>1:\n#         subans*=(count*(count-1))//2\n#         count=1\n#         subcount+=1\n# if s[-1]=='c' or s[-1]=='k':\n#     flag=1\n# elif count>1:\n#     subans*=(count*(count-1))//2\n#     subcount+=1\n# if flag:\n#     print(0)\n# else:\n#     res=(1<<(subcount-1))\n#     res*=subans\n#     print(res%mod)\nn = ii1()\narr=[None]*n\nfor ii in range(n):\n arr[ii]=iia()\ncount=2\nif n==1 or n==2:\n print(n)\nelse:\n flag=[0]*n\n flag[0]=-1\n flag[-1]=1\n for i in range(1,n-1):\n  if flag[i-1]==-1:\n   if arr[i][0]-arr[i-1][0]>arr[i][1]:\n    flag[i] =- 1\n    count += 1\n   elif arr[i+1][0]-arr[i][0]>arr[i][1]:\n    flag[i] = 1\n    count += 1\n  elif flag[i-1]==1:\n   if arr[i][0]-(arr[i-1][0]+arr[i-1][1])>arr[i][1]:\n    flag[i]=-1\n    count += 1\n   elif arr[i+1][0]-arr[i][0]>arr[i][1]:\n    flag[i]=1\n    count += 1\n  else:\n   if arr[i][0]-arr[i-1][0]>arr[i][1]:\n    flag[i]=-1\n    count+=1\n   elif arr[i+1][0]-arr[i][0]>arr[i][1]:\n    flag[i]=1\n    count+=1\n print(count)\n\n\n\n", "n=int(input())\na=list(range(n))\nh=list(range(n))\nm=2\nfor i in range(n):\n a[i],h[i]=[int(s) for s in input().split()]\nif n<3:\n m=n\nelse:\n for j in range(1,n-1):\n  if a[j]-h[j]>a[j-1]:\n   m+=1\n  elif a[j]+h[j]<a[j+1]:\n    m+=1\n    a[j]=a[j]+h[j]\n  else:\n   continue\n\nprint(m)\n", "# cook your dish here\nn = int(input())\nl = []\nfor i in range(n):\n a, h = map(int,input().split())\n l.append([a,h])\nif len(l)==1:\n print(1)\n return\np = l[0][0]\ncount = 2\nfor i in range(1,len(l)-1):\n if l[i][0]-l[i][1]>p:\n  p = l[i][0]\n  count+=1\n elif l[i][0]+l[i][1]<l[i+1][0]:\n  p = l[i][0]+l[i][1]\n  count+=1\n else:\n  p = l[i][0]\nprint(count)", "n = int(input())\nres = []\nfor _ in range(n):\n res.append(list(map(int, input().split())))\nif n == 1:\n print(1)\n return\nif n == 2:\n print(2)\n return\nstart = 2\nfor i in range(1, n - 1):\n #first check left\n if (res[i][0] - res[i][1]) > res[i - 1][0]:\n  #print(res[i])\n  #print(abs(res[i][0] - res[i][1]))\n  #print(res[i - 1][0])\n  start += 1\n  continue\n #check right\n if res[i][0] + res[i][1] < res[i + 1][0]:\n  #print(res[i], res[i])\n  res[i][0] += res[i][1]\n  start += 1\n  continue\nprint(start)", "# cook your dish here\nn=int(input())\nlist1=[]\nlist2=[]\nfor i in range(n):\n a,h=list(map(int,input().split()))\n list1.append(a)\n list2.append(h)\ncount=2\nfor j in range(1,n-1):\n k=list1[j]-list2[j]\n if k>list1[j-1]:\n  count+=1\n else:\n  z=list1[j]+list2[j]\n  if z<list1[j+1]:\n   count+=1\n   list1[j]=list2[j]+list1[j]\nif n==1:\n print('1')\nelse:\n print(count)", "n= int(input())\nco =[]\nhi=[]\nfor i in range(n):\n arr=[int(x) for x in input().split()]\n co.append(arr[0])\n hi.append(arr[-1])\n \nif n<=2:\n count=n\nelse:\n count=2\n for i in range(1,n-1):\n  if hi[i]<co[i]-co[i-1]:\n   count+=1\n  elif hi[i]<co[i+1]-co[i]:\n   count+=1\n   co[i]+=hi[i]\n  else:\n   continue\nprint(count)", "from sys import*\ninput= stdin.readline\nn=int(input())\nt=[]\nfor i in range(n):\n a,b=list(map(int,input().split()))\n t.append([a,b])\nif(n==1):\n c=1\nelse:\n c=2 #first tree to left and last tree to right\nfor i in range(1,n-1):\n l = t[i][0]-t[i-1][0]\n r = t[i+1][0] - t[i][0]\n h = t[i][1]\n if(h<l):\n  c+=1\n elif(h<r):\n  c+=1\n  t[i][0]=t[i][0]+h\nprint(c)\n", "n=int(input())\nans=2\n\na=[]\nfor i in range(n):\n a.append(list(map(int,input().split())))\nif(n==1):\n print(1)\n return\nvector=a[0][0]\nfor i in range(1,n-1):\n if(a[i][0]-a[i][1]>vector):\n  ans+=1\n  vector=a[i][0]\n\n else:\n  if(a[i][0]+a[i][1]<a[i+1][0]):\n   ans+=1\n   vector=a[i][0]+a[i][1]\n  else:\n   vector=a[i][0]\n \n\n  \n \nprint(ans)\n\n \n", "n=int(input())\nl=[]\nfor _ in range(n):\n a,h=map(int,input().split())\n l.append([a,h])\nans=2\nif n==1:\n ans=1\n print(ans)\n return\nl[0].append(\"left\")\nl[n-1].append(\"right\")\nfor i in range(1,n-1):\n if l[i-1][2]==\"right\":\n  if abs(l[i][0]-(l[i-1][1]+l[i-1][0]))>l[i][1]:\n   ans+=1\n   l[i].append(\"left\")\n  elif abs(l[i][0]-l[i+1][0])>l[i][1]:\n   ans+=1\n   l[i].append(\"right\")\n  else:\n   l[i].append(\"stand\")\n else:\n  if abs(l[i][0]-l[i-1][0])>l[i][1]:\n   ans+=1\n   l[i].append(\"left\")\n  elif abs(l[i][0]-l[i+1][0])>l[i][1]:\n   ans+=1\n   l[i].append(\"right\")\n  else:\n   l[i].append(\"stand\")\nprint(ans)", "from math import inf as inf\nfrom math import *\nfrom collections import *\nimport sys\nfrom itertools import permutations\n#input=sys.stdin.readline\nn=int(input())\nr=[]\nfor i in range(n):\n a,h=list(map(int,input().split()))\n r.append([a,h])\ns=2\nif(n==1):\n print(1)\n return\nprev=-10000000000000\nfor i in range(1,n-1):\n prev=max(r[i-1][0],prev)\n nex=r[i+1][0]\n if(r[i][0]-r[i][1]>prev):\n  s+=1\n elif(r[i][0]+r[i][1]<nex):\n  s+=1\n  prev=r[i][0]+r[i][1]\nprint(s)\n", "t = int(input())\nlistt = []\nans = 2\n\nfor x in range(t):\n a,b = map(int,input().split())\n listt.append([a,b])\n \ni = 1\n\nwhile i+1<t:\n if listt[i][0] - listt[i][1] > listt[i-1][0]:\n  ans = ans+1\n elif listt[i][0] + listt[i][1] < listt[i+1][0]:\n  ans = ans+1\n  listt[i][0] = listt[i][0]+listt[i][1]\n  \n i = i+1\nif t == 1:\n print('1')\nelse:\n print(ans)", "n=int(input())\nl=[]\nfor i in range(n):\n l.append(list(map(int,(input().split()))))\nans=0\nfor i in range(n):\n if i==0:\n  ans+=1\n elif i==n-1:\n  ans+=1\n else:\n  if l[i][0]-l[i][1]>l[i-1][0]:\n   ans+=1\n  else:\n   if l[i][0]+l[i][1]<l[i+1][0]:\n    ans+=1\n    l[i][0] = l[i][0]+l[i][1]\nprint(ans)\n \n", "n = int(input())\nmainlist = []\nchoppedlist = []\nfor i in range(0,n):\n mainlist.append(input().split())\n\nfor i in range(0,n):\n mainlist[i][0] = int(mainlist[i][0])\n mainlist[i][1] = int(mainlist[i][1])\n\n# print('typeis ',type(mainlist[0][0]))\n\ndef checkifpossible(mainlist, sublist, right, pos):\n # print('sublist is ', sublist)\n # print('mainlist is ', mainlist)\n returncode = True\n\n if right:\n  for i in range(pos+1, n):\n   # print('at right value of m and s are ', mainlist[i][0], ' ', \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sublist[1])\n   if mainlist[i][0] <= sublist[1]:\n    returncode = False\n else:\n  for i in range(0, pos):\n   # print('value of m and s are ', mainlist[i][0], ' ', sublist[0])\n   if mainlist[i][0] >= sublist[0]:\n    # print('setting to False')\n    returncode = False\n for j in range(0,len(choppedlist)):\n  if choppedlist[j][1] >= sublist[0] and not right:\n   # print('overlapping chopped list')\n   returncode = False\n\n return returncode\n\n\ndef choptreetoright(mainlist, pos):\n nonlocal choppedlist\n sublist = []\n sublist.append(mainlist[pos][0])\n sublist.append(mainlist[pos][0] + mainlist[pos][1])\n right = True\n\n if checkifpossible(mainlist, sublist, right, pos) == True:\n  choppedlist.append(sublist)\n  return True\n else:\n  return False\n\ndef choptreetoleft(mainlist, pos):\n nonlocal choppedlist\n sublist = []\n sublist.append(mainlist[pos][0] - mainlist[pos][1])\n sublist.append(mainlist[pos][0])\n right = False\n if checkifpossible(mainlist, sublist, right, pos) == True:\n  choppedlist.append(sublist)\n  return True\n else:\n  return False\n\nif n >= 2:\n counter = 2\nelif n == 1:\n counter = 1\nelse:\n counter = 0\n\nfor i in range (1, n-1):\n # print('calling left with i ', i)\n if choptreetoleft(mainlist, i):\n  counter = counter + 1\n  continue\n # print('calling right with i ', i)\n if choptreetoright(mainlist, i):\n  counter = counter + 1\n\n# print('chopped list ', choppedlist)\nprint(counter)", "n = int(input())\nmainlist = []\nchoppedlist = []\nfor i in range(0,n):\n mainlist.append(input().split())\n\nfor i in range(0,n):\n mainlist[i][0] = int(mainlist[i][0])\n mainlist[i][1] = int(mainlist[i][1])\n\n# print('typeis ',type(mainlist[0][0]))\n\ndef checkifpossible(mainlist, sublist, right, pos):\n # print('sublist is ', sublist)\n # print('mainlist is ', mainlist)\n returncode = True\n\n if right:\n  for i in range(pos+1, n):\n   # print('at right value of m and s are ', mainlist[i][0], ' ', \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sublist[1])\n   if mainlist[i][0] <= sublist[1]:\n    returncode = False\n else:\n  for i in range(0, pos):\n   # print('value of m and s are ', mainlist[i][0], ' ', sublist[0])\n   if mainlist[i][0] >= sublist[0]:\n    # print('setting to False')\n    returncode = False\n for j in range(0,len(choppedlist)):\n  if choppedlist[j][1] >= sublist[0] and not right:\n   # print('overlapping chopped list')\n   returncode = False\n\n return returncode\n\n\ndef choptreetoright(mainlist, pos):\n nonlocal choppedlist\n sublist = []\n sublist.append(mainlist[pos][0])\n sublist.append(mainlist[pos][0] + mainlist[pos][1])\n right = True\n\n if checkifpossible(mainlist, sublist, right, pos) == True:\n  choppedlist.append(sublist)\n  return True\n else:\n  return False\n\ndef choptreetoleft(mainlist, pos):\n nonlocal choppedlist\n sublist = []\n sublist.append(mainlist[pos][0] - mainlist[pos][1])\n sublist.append(mainlist[pos][0])\n right = False\n if checkifpossible(mainlist, sublist, right, pos) == True:\n  choppedlist.append(sublist)\n  return True\n else:\n  return False\n\nif n >= 2:\n counter = 2\nelif n == 1:\n counter = 1\nelse:\n counter = 0\n\nfor i in range (1, n-1):\n # print('calling left with i ', i)\n if choptreetoleft(mainlist, i):\n  counter = counter + 1\n  continue\n # print('calling right with i ', i)\n if choptreetoright(mainlist, i):\n  counter = counter + 1\n\n# print('chopped list ', choppedlist)\nprint(counter)", "# cook your dish here\nn = int(input())\na = [list(map(int,input().split())) for _ in range(n)]\na = a + [ (float('inf'), -1) ]\n\nc = 0\n_w = a[0][0]\nfor i in range(1,len(a)):\n if a[i][0] - a[i][1] > _w:\n  c += 1\n  _w = a[i][0]\n elif a[i][0] + a[i][1] < a[i+1][0]:\n  c += 1\n  _w = a[i][0] + a[i][1]\n else:\n  _w = a[i][0]\n\nprint(c)\n\n", "# cook your dish here\nn = int(input())\na,h=[],[]\narr = [list(map(int,input().split())) for i in range(n)]\narr = sorted(arr,key=lambda i:i[0])\nfor i in arr:\n k,m = i\n a.append(k)\n h.append(m)\nif n==1 or n==2:\n print(n)\nelse:\n count,chopped=2,0\n for i in range(1,n-1):\n  if a[i]-a[i-1]>h[i] and chopped ==0:\n    count+=1\n  elif chopped ==1 and a[i]-a[i-1]-h[i-1]>h[i]:\n   chopped=0\n   count+=1\n  elif a[i+1]-a[i]>h[i]:\n   count+=1\n   chopped=1\n  else:\n   chopped=0\n print(count)\n", "import numpy as np\nn = int(input())\narr = np.empty((n,2),dtype=int)\nfor i in range(n):\n x = list(map(int,input().split()))\n arr[i]=x\nflag = 'l'\nif(n==1):\n ans=1\nelse:\n ans=2\nfor i in range(1,n-1):\n curr = arr[i]\n pre = arr[i-1]\n next = arr[i+1]\n if(flag=='l'):\n  cn_l = curr[0]-curr[1]\n  cn_r = curr[0]+curr[1]\n  if(cn_l>pre[0]):\n   flag='l'\n   ans+=1\n  elif(cn_r<next[0]):\n   flag='r'\n   ans+=1\n elif(flag=='r'):\n  cn_l = curr[0] - curr[1]\n  cn_r = curr[0] + curr[1]\n  pre_r = pre[0] + pre[1]\n  if(cn_l > pre_r):\n   flag = 'l'\n   ans+=1\n  elif(cn_r < next[0]):\n   flag='r'\n   ans+=1\nprint(ans)\n", "\nn=int(input())\nsticks=[]\ncount=2\n\nfor i in range(n):\n inn=input().split(' ')\n sticks.append([int(inn[0]),int(inn[1])])\nif len(sticks)<2:\n print(len(sticks))\n return\narea=[[sticks[0][0]-sticks[0][1],sticks[0][0]],\n\n[sticks[-1][0],sticks[-1][0]+sticks[-1][1]]\n\n]\n\n# print(sticks)\n# print(area)\nfor i in sticks:\n area.append([i[0],i[0]])\ndef check(aa,hh):\n a=aa-hh\n h=aa\n flag=0\n for i in area:\n  if i==[aa,aa]:\n   continue\n  if i[0]==i[1] and a<=i[0] and h>=i[0]:\n   flag=-1\n   break\n  if a<=i[0] and h>=i[0]:\n   \n   flag=-1\n   break\n  if a<=i[0] and h>=i[1]:\n   \n   flag=-1\n   break\n  if a<=i[1] and h>=i[1]:\n   \n   flag=-1\n   break\n  if a>=i[0] and h<=i[1]:\n   \n   flag=-1\n   break\n if flag==0:\n  return [a,h]\n flag=1\n a=aa\n h=aa+hh\n for i in area:\n  if i==[aa,aa]:\n   continue\n  if i[0]==i[1] and a<=i[0] and h>=i[0]:\n   flag=-1\n   break\n  if a<=i[0] and h>=i[0]:\n   \n   flag=-1\n   break\n  if a<=i[0] and h>=i[1]:\n   \n   flag=-1\n   break\n  if a<=i[1] and h>=i[1]:\n   \n   flag=-1\n   break\n  if a>=i[0] and h<=i[1]:\n   \n   flag=-1\n   break\n if flag==1:\n  return [a,h]\n return -1\n\n\nfor i in sticks[1:-1]:\n  temp=check(i[0],i[1])\n \n  if temp==-1:\n   continue\n  count+=1\n  area.append(temp)\n\nprint(count)\n\n\n \n\n", "n=int(input())\nah=[]\nfor _ in range(n):\n cach=list(map(int,input().split()))\n ah.append(cach)\nah.sort(key=lambda x:x[0])\n#print(ah)\nlmit=-2*(10**9)\nchop=0\nfor i in range(n-1):\n a=ah[i][0]-ah[i][1]\n b=ah[i][0]\n c=ah[i][0]\n d=ah[i][0]+ah[i][1]\n if b<ah[i+1][0] and a>lmit:\n  lmit=b\n  chop+=1\n  #print(\"first\")\n elif d<ah[i+1][0] and c>lmit:\n  #print(\"sec\",a,b,c,d,lmit,ah[i+1][0])\n  lmit=d\n  chop+=1\n  #print(\"sec\")\n else:\n  lmit=b\n #print(lmit)\nprint(chop+1)\n", "n = int(input())\n\nl = []\nlc = False\nc = 0\n\nfor i in range(n):\n a, h = list(map(int, input().split()))\n\n l.append([a, h])\n\n if i == 0:\n  c += 1\n  lc = True\n  continue\n\n if lc:\n  if a - l[-2][0] <= h:\n   lc = False\n\n  else:\n   c += 1\n   lc = True\n\n  continue\n\n if a - l[-2][0] > l[-2][1]:\n  c += 1\n  l[-2][0] += l[-2][1]\n  l[-2][1] = 0\n\n if a - l[-2][0] <= h:\n  lc = False\n else:\n  c += 1\n  lc = True\n\nif not lc:\n c += 1\n\nprint(c)\n", "# cook your dish here\nn = int(input())\n\noccupy = [float(\"-inf\")]\nheight = [0]\npos = [float(\"-inf\")]\n\nfor i in range(n):\n  p,h = list(map(int, input().split()))\n  pos.append(p)\n  height.append(h)\n  occupy.append(p)\n\npos.append(float(\"inf\"))\nheight.append(0)\noccupy.append(float(\"inf\"))\n\nsol = 0\nfor i in range(1,n+1):\n  if pos[i]-height[i] > occupy[i-1]:\n   sol +=1\n  elif pos[i]+height[i] < occupy[i+1]:\n   sol +=1\n   occupy[i] = pos[i]+height[i]\n   \nprint(sol)\n  \n  \n\n", "# cook your dish here\nn=int(input())\nout=[0]\ndp=[[float(\"-inf\"),float(\"-inf\"),float(\"-inf\")]]\nfor _ in range(n):\n x=list(map(int,input().split()))\n x=[x[0]-x[1],x[0],x[0]+x[1]]\n dp.append(x)\ndp.append([float(\"inf\"),float(\"inf\"),float(\"inf\")])\nfor i in range(1,len(dp)-1):\n if dp[i-1][2]<dp[i][0]:\n  dp[i][2]=dp[i][1]\n  out.append(out[-1]+1)\n elif dp[i][2]<dp[i+1][1]:\n  out.append(out[-1]+1)\n else:\n  dp[i]=[dp[i][1],dp[i][1],dp[i][1]]\n  out.append(out[-1])\nprint(out[-1])\n \n\n"]
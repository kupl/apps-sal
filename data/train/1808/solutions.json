["# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         intervals = sorted(intervals, key = lambda x: x.end)\n         current_end = float('-inf')\n         cnt = 0\n         for interval in intervals:\n             if interval.start >= current_end:\n                 cnt += 1\n                 current_end = interval.end\n         return len(intervals) - cnt\n         ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"        \n         intervals.sort(key=lambda x: (x.start, x.end))\n         \n         num_removed = 0\n         current_interval_end = float('-inf')      \n         for interval in intervals:\n             if interval.start >= current_interval_end:\n                 # No overlap\n                 current_interval_end = interval.end\n             else:\n                 # Overlapping intervals. Remove interval with latest end time\n                 current_interval_end = min(current_interval_end, interval.end)\n                 num_removed += 1\n         return num_removed", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         if len(intervals) <= 1: return 0\n         min_removals = 0\n         j = 1\n         intervals = sorted(intervals, key=lambda i: (i.start, i.end))\n         endpoint = intervals[0].end\n         \n         while j < len(intervals):\n             if intervals[j].start < endpoint:\n                 min_removals+=1\n                 endpoint = min(endpoint, intervals[j].end)\n             else:\n                 endpoint = intervals[j].end\n             j+=1\n         \n         return min_removals\n         \n         \n             ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         s_intervals = [(intervals[i].start, intervals[i].end) for i in range(len(intervals))]\n         s_intervals.sort()\n         s_intervals = [(s_intervals[i][0], s_intervals[i][1], i) for i in range(len(intervals))]\n         f_intervals = [(j,i,h) for (i,j,h) in s_intervals]\n         f_intervals.sort()\n         f_intervals = [(j,i,h) for (i,j,h) in f_intervals]\n         \n         skipped = 0\n         bound = 0\n         for interval in f_intervals:\n             if interval[2] < bound:\n                 continue\n             i = bound\n             for i in range(bound, len(intervals)):\n                 if s_intervals[i][2] == interval[2]:\n                     continue\n                 if s_intervals[i][0] >= interval[1]:\n                     break\n                 else:\n                     skipped += 1\n             bound = i\n         return skipped\n                 ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         start_end={}\n         for i in intervals:\n             if i.start in start_end:\n                 if start_end[i.start]>i.end:\n                     start_end[i.start]=i.end\n             else:\n                 start_end[i.start]=i.end\n         final_list={}\n         if len(start_end)>1:\n             sorted_list=sorted(start_end)\n \n             for i,j in enumerate(sorted_list):\n                 if i>0:\n                     start2=j\n                     #if j>-90 and j<-80:\n                     #    print(start1,end1,start2,start_end[start2])\n                     if start2<end1:\n                         if start_end[start2]<end1:\n                             final_list.pop(start1,None)\n                             end2=start_end[start2]\n                             final_list[start2]=end2\n                             end1=end2\n                             start1=start2\n                             #if j>-90 and j<-80:\n                             #    print(start1,end1)\n                         elif end1<=start_end[start2]:\n                             final_list[start1]=end1\n                             end1=end1\n                             start1=start1\n                             #if j>-90 and j<-80:\n                             #    print(start1,end1)\n                     elif start2>=end1:\n                         final_list[start1]=end1\n                         start1=start2\n                         end1=start_end[start2]\n                         if i==len(sorted_list)-1:\n                             final_list[start2]=start_end[start2]\n                 if i==0:\n                     start1=j\n                     end1 =start_end[j]\n         elif len(start_end)==1:\n             final_list=start_end\n         print(list((i,start_end[i]) for i in sorted(start_end)))\n         print('result') \n         print(list((i,final_list[i]) for i in sorted(final_list)))\n         return len(intervals)-len(final_list)\n                 \n                 \n                 ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         if len(intervals) == 0:\n             return 0\n         \n         intervals = sorted(intervals, key = lambda x: (x.end, -x.start))\n         \n         end = intervals[0].end\n         \n         res = 0\n         \n         for interval in intervals[1:]:\n             \n             if end > interval.start:\n                 res += 1\n             else:\n                 end = interval.end\n         \n         for i in intervals:\n             print((i.start,i.end))\n         return res\n         \n         ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         if not intervals:\n             return 0\n         intervals.sort(key=lambda x:x.start) # start or end doesn't matter\n         latest = intervals[0].end # always check end \n         count = 0\n         for interval in intervals[1:]:\n             if interval.start < latest:\n                 count += 1\n                 latest = min(latest, interval.end)\n             else:\n                 latest = interval.end\n         return count", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         if not intervals: return 0\n         intervals = sorted(intervals, key=lambda x: x.end)\n         prev_end = intervals[0].end\n         count = 0\n         for i in intervals[1:]:\n             if i.start < prev_end:\n                 count += 1\n             else:\n                 prev_end = i.end\n         return count", "class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         intervals.sort(key=lambda x:x.end)        \n         end = -sys.maxsize\n         count = 0\n         for i in intervals:\n             if i.start<end: continue\n             end = i.end\n             count += 1\n         return len(intervals)-count", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: int\n         \"\"\"\n         if not intervals:\n             return 0\n         intervals = sorted(intervals, key= lambda x:x.end)\n         count = 1;\n         last = 0;\n         for i in range(1,len(intervals)):\n             if intervals[last].end <= intervals[i].start:\n                 count +=1\n                 last = i;\n         \n         return len(intervals) - count\n  "]
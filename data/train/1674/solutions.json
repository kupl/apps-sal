["from functools import *\nclass Solution:\n    def stoneGameII(self, arr):\n        a =[]\n        s=0\n        n = len(arr)\n        for i in arr[::-1]:\n            s+=i\n            a.append(s)\n        a=a[::-1]\n        @lru_cache(None)\n        def fun(i,m):\n            if i+2*m>=n:return a[i]\n            mn = inf\n            for ii in range(1,2*m+1):\n                if ii>m:\n                    ans = fun(i+ii,ii)\n                else:\n                    ans=fun(i+ii,m)\n                if ans<mn:\n                    mn = ans\n            return a[i]-mn\n        return fun(0,1)\n                \n            \n", "from functools import lru_cache\n\n\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        for i in range(N - 2, -1, -1):\n            piles[i] += piles[i + 1]\n        \n        @lru_cache(None)\n        def dp(i, m):\n            if i + 2 * m >= N:\n                return piles[i]\n            return piles[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1))\n        \n        return dp(0, 1)\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        for i in range(len(piles)-2, -1, -1):\n            piles[i] += piles[i+1]\n        \n        memo = {}\n        def dfs(i, m):\n            if i + (2 * m) >= len(piles):\n                return piles[i]\n            if (i, m) in memo:\n                return memo[(i, m)]\n            \n            memo[(i, m)] = piles[i] - min((dfs(i+j, max(m, j))) for j in range(1, (2*m)+1))\n            return memo[(i, m)]\n        \n        \n        return dfs(0, 1)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        suffix_sum = [0] * N\n        \n        running_sum = 0\n        for idx in range(N-1, -1, -1):\n            running_sum += piles[idx]\n            suffix_sum[idx] = running_sum\n            \n        DP = [[0]*(N) for _ in range(N)]\n        \n        for pile_no in reversed(list(range(N))):\n            for M in reversed(list(range(N))):\n                min_next_player = suffix_sum[pile_no]\n                for x in range(1, 2*M + 1):\n                    if pile_no + x < N:\n                        min_next_player = min(min_next_player, DP[pile_no + x][max(x,M)])\n                    else:\n                        min_next_player = 0\n                DP[pile_no][M] = suffix_sum[pile_no] - min_next_player\n            \n        return DP[0][1]\n        \n#         # @lru_cache(None)\n#         def dfs(pile_no, M):\n#             if pile_no > N-1:\n#                 return 0\n#             if DP[pile_no][M] > 0:\n#                 return DP[pile_no][M]\n#             min_next_player = suffix_sum[pile_no]\n#             for x in range(1, min(2*M + 1, N+1)):\n#                 min_next_player = min(min_next_player, dfs(pile_no + x, max(x,M)))\n                \n#             DP[pile_no][M] = suffix_sum[pile_no] - min_next_player\n#             return DP[pile_no][M]\n            \n#         return dfs(0, 1)\n        \n            \n        \n        \n        \n        \n            \n", "\\\"\\\"\\\"\ndp[i][j] = the max score one can get with [i:] piles and M = j.\ndp[i][j] = max(sum(piles[i:i+x]) - dp[i+x][max(j, x)] for x in range(1, min(2*j, n))\ndp[i][n] = sum(piles[i:])\n\\\"\\\"\\\"\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        suf_sum = [0 for _ in range(n + 1)]     # \u5148\u6784\u9020\u4e00\u4e2asuffix sum\n        for i in range(n - 1, -1, -1):\n            suf_sum[i] = suf_sum[i+1] + piles[i]\n            \n        dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n        # for i in range(n + 1):\n        #     dp[i][n] = suf_sum[i]\n        \n        for i in range(n, -1, -1):\n            for j in range(n, 0, -1):\n                for x in range(1, min(2*j, n - i) + 1):\n                    dp[i][j] = max(dp[i][j], suf_sum[i] - dp[i+x][max(j, x)])\n        return dp[0][1]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        self.dp = {}\n\n        def recursiveStoneGame(start, M):            \n            if start >= N:\n                return 0\n            \n            # take all if possible\n            if N - start <= 2*M:\n                return sum(piles[start:])\n            \n\\t\\t\\t# memoization\n            if (start, M) in self.dp:\n                return self.dp[(start, M)]\n\n            alex_score = 0\n            sum_score = sum(piles[start:])  # all available score\n\\t\\t\\t\n\\t\\t\\t# explore each x\n            for x in range(1, 2*M+1):\n\\t\\t\\t    # get opponent's score\n                opponent_score = recursiveStoneGame(start+x, max(x, M))\n\\t\\t\\t\\t# diff is the current palyers score, keep max\n                alex_score = max(alex_score, sum_score - opponent_score)\n                \n            self.dp[(start, M)] = alex_score\n                \n            return alex_score\n        \n        \n        return recursiveStoneGame(0, 1)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        for i in range(len(piles)-2, -1, -1):\n            piles[i] += piles[i+1]\n            \n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(index, m):\n            if index >= len(piles):\n                return 0\n            max_val = 0\n            \n            for i in range(index, min(index+2*m, len(piles))):\n                new_m = max(m, i+1-index)\n                max_val = max(max_val, piles[index] - dp(i+1, new_m))\n            return max_val\n        return dp(0, 1)\n            \n#         N = len(piles)\n#         for i in range(N-2, -1, -1):\n#             piles[i] += piles[i+1]\n#         print(piles)\n#         from functools import lru_cache\n#         @lru_cache(None)\n#         def dp(i, m):\n#             if i + 2 * m >= N: return piles[i]\n#             return piles[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1))\n#         return dp(0, 1)\n        max_num = 0\n        def play(i, m, player):\n         \n            \n            if i >= len(piles):\n                return 0\n            \n            if player == 1:\n                point = play(i+2*m, 2*m, 0)\n              \n                return point\n            else:\n                \n                max_point = 0\n                for action in range(i+1, min(i+1+2 *m, len(piles))):\n                    print((sum(piles[i:action]), i, m, action, piles[i:action], min(i+1+2 *m, len(piles))))\n                    down_stream_point = play(action, max(action, m), 1)\n                    max_point = max(max_point, sum(piles[i:action]) + down_stream_point)\n                  \n                return max_point\n            \n        return play(0, 1, 0)\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        cache = {}\n        \n        def recursive_game(start, M):\n            score_left = sum(piles[start:])\n            if start >= N: return 0\n            if (start, M) in cache: return cache[(start,M)]\n            if start + 2*M >= N: return score_left\n            \n            my_score = 0\n            for x in range(1,2*M+1):\n                opponent_score = recursive_game(start + x, max(M,x))\n                my_score = max(my_score, score_left-opponent_score)\n                \n            cache[(start,M)] = my_score\n            return my_score\n        \n        return recursive_game(0,1)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def select(start, M, my_turn):\n            if my_turn:\n                if start + 2*M >= len(piles):\n                    return sum(piles[start:])\n                rst = 0\n                for i in range(1, 2*M+1):\n                    rst = max(rst, sum(piles[start:start+i]) + select(start+i, max(i, M), False))\n                return rst\n            \n            if start + 2*M >= len(piles):\n                return 0\n            rst = float('inf')\n            for i in range(1, 2*M+1):\n                rst = min(rst, select(start+i, max(i, M), True))\n            return rst\n        \n        return select(0, 1, True)\n        \n        \n        \n                       \n", "class Solution:\n    def stoneGameII(self, A: List[int]) -> int:\n        \n        \n        \n        # my solution ... \n        #  time: O()\n        # space: O()\n        \n        seen = {}\n        def max_stones(sidx, m):  # \u8fd4\u56de\u9762\u5bf9 A[sidx:] \u65f6\uff0c\u76f4\u81f3\u6e38\u620f\u7ed3\u675f\uff0c\u6240\u80fd\u53d6\u5230\u7684\u6700\u591a\u77f3\u5934\n            if sidx == len(A):\n                return 0\n            if (sidx, m) not in seen:\n                if len(A)-sidx <= 2*m:\n                    seen[sidx, m] = sum(A[sidx:])\n                else:\n                    res = 0\n                    for x in range(1, 2*m+1):\n                        new_sidx = sidx + x\n                        res = max(res, sum(A[sidx:]) - max_stones(new_sidx, max(m, x)))\n                    seen[sidx, m] = res\n            return seen[sidx, m]\n        \n        return max_stones(0, 1)\n        \n        \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:  \n        # store (start, M)\n        table = {}\n        \n        def stoneGameRec(start, M):\n            if (start, M) in table:\n                return table[(start, M)]            \n            \n            totalTaken = 0\n            for i in range(start, min(start + 2 * M, len(piles))):\n                totalTaken += piles[i]\n                           \n            if start + 2 * M >= len(piles):\n               return (totalTaken, 0)\n\n            maxStones = (0, 0)\n            for i in range(start + 2 * M - 1, start - 1, -1):                    \n                X = i - start + 1                            \n                theirStones, yourStones = stoneGameRec(i + 1, max(M, X))\n                yourStones += totalTaken\n                if yourStones > maxStones[0]:\n                    maxStones = (yourStones, theirStones)\n\n                totalTaken -= piles[i]\n\n            table[(start, M)] = maxStones\n            return maxStones                                                 \n                \n        alexScore, _ = stoneGameRec(0, 1)                                \n        return alexScore\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        memo = {}\n        prefix = [0] * (len(piles) + 1)\n        for i in range(len(piles)):\n            prefix[i+1] += prefix[i] + piles[i]\n        return self.dfs(piles, memo, 0, 1, prefix)\n    \n    \n    def dfs(self, piles, memo, i, m, prefix):\n        if i == len(piles):\n            return 0\n\n        if (i, m) in memo:\n            return memo[(i, m)]\n        \n        ans = float('-inf')\n        for j in range(1, m+1):\n            if i + j <= len(piles):\n                ans = max(ans, prefix[-1] - prefix[i] - self.dfs(piles, memo, i+j, m, prefix))\n            \n        for j in range(m+1, 2 * m + 1):\n            if i + j <= len(piles):\n                ans = max(ans, prefix[-1] - prefix[i] - self.dfs(piles, memo, i+j, j, prefix))\n                \n        memo[(i, m)] = ans\n        \n        return memo[(i, m)]\n            \n            \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        # dp[i][M] means the number of stones one can get starting with i with M\n        dp = [[0 for m in range(n)] for i in range(n)]\n        sufsum = [0] * (n + 1)\n        for i in reversed(range(n)):\n            sufsum[i] = sufsum[i + 1] + piles[i]\n        \n        return self.dfs(piles, 0, dp, sufsum, 1)\n    \n    def dfs(self, piles, index, dp, sufsum, M):\n        if index == len(piles):\n            return 0\n        \n        if dp[index][M] > 0:\n            return dp[index][M]\n        \n        result = 0\n        for i in range(index, index + 2 * M):\n            if i >= len(piles):\n                break\n\n            X = i - index + 1\n            result = max(result, sufsum[index] - self.dfs(piles, i + 1, dp, sufsum, max(X, M)))\n        \n        dp[index][M] = result\n        return dp[index][M]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        # dp[i][M] means the number of stones one can get starting with i with M\n        dp = [[0 for m in range(n)] for i in range(n)]\n        sufsum = [0] * (n + 1)\n        for i in reversed(range(n)):\n            sufsum[i] = sufsum[i + 1] + piles[i]\n        \n        return self.dfs(piles, 0, dp, sufsum, 1)\n    \n    def dfs(self, piles, index, dp, sufsum, M):\n        if index == len(piles):\n            return 0\n        \n        if dp[index][M] > 0:\n            return dp[index][M]\n        \n        s = 0\n        result = 0\n        for i in range(index, index + 2 * M):\n            if i >= len(piles):\n                break\n\n            s += piles[i]\n            X = i - index + 1\n            result = max(result, s + sufsum[i + 1] - self.dfs(piles, i + 1, dp, sufsum, max(X, M)))\n        \n        dp[index][M] = result\n        return dp[index][M]", "import functools\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        for i in range(n-2, -1, -1):\n            piles[i] += piles[i+1] # suffix sum\n        \n        # \u5728\u4f4d\u7f6ei\uff0cM=m\u7684\u60c5\u51b5\u4e0b\uff0c\u5f53\u524d\u9009\u624b\u83b7\u5f97\u7684\u6700\u5927\u5206\u6570\n        @lru_cache(None)\n        def dp(i, m):\n            if i+2*m >= n: return piles[i]\n            #                      \u5728\u5f53\u524dplayer\u9009\u62e9x\u4e0b\uff0c\u5bf9\u624b\u80fd\u5f97\u5230\u7684\u6700\u5927\u5206\u6570\n            # \u9009\u62e9\u4e86x\uff0c\u5c31\u662f\u7ed9\u5bf9\u65b9\u8bbe\u7f6e\u4e86M\n            # return piles[i] - min([dp(i+x, max(m,x)) for x in range(1, 2*m+1)])\n            # \u5199\u6210\u8fd9\u6837\u66f4\u6e05\u6670\n            res = 0\n            for x in range(1, 2*m+1):\n                res = max(res, piles[i] - dp(i+x, max(m,x)))\n            return res\n        return dp(0, 1)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        m = len(piles)\n        dp = [[0 for j in range(m+1)] for i in range(m)]\n        sumv = 0\n        for i in range(m-1, -1, -1):\n            sumv += piles[i]\n            for M in range(1, len(dp[0])):\n                if 2 * M + i >= m:\n                    dp[i][M] = sumv\n                else:\n                    for x in range(1, 2*M+1):\n                        dp[i][M] = max(dp[i][M], sumv - dp[i+x][max(M, x)])\n        return dp[0][1]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        mem = {}\n        \n        def dp(i, M):\n            if (i,M) in mem:\n                return mem[(i,M)][0]\n            if i >= len(piles):\n                return 0\n            \n            val = []\n            for x in range(1, min(2*M, len(piles)-i)+1):\n                val.append(sum(piles[i:i+x]) - dp(i+x, max(x, M)))\n            \n            mem[(i,M)] = [max(val), val.index(max(val))]\n            return mem[(i,M)][0]\n                        \n        dp(0,1)\n        \n        i, m, s, t = 0, 1, 0, 1\n        while i<len(piles):\n            x = mem[(i, m)][1]+1\n            if t == 1:\n                s += sum(piles[i:i+x])\n            t *= -1\n            i = i+x\n            m = max(x, m)\n        \n        return s\n", "class Solution:\n  def stoneGameII(self, piles: List[int]) -> int:\n    n = len(piles)\n    dp = [[-1 for _ in range(n+1)] for _ in range(n+1)]\n    s = sum(piles)\n    def helper(st, M):\n      nonlocal n, piles, dp\n      if st >= n:\n        return 0\n      if dp[M][st] != -1:\n        return dp[M][st]\n      cur = 0\n      tmp = float('-inf')\n      for x in range(1, 2*M+1):\n        if st + x > n:\n          continue\n        \n        tmp = max(tmp, sum(piles[st: st+x]) - helper(st+x, max(M, x)))\n                  \n      dp[M][st] = tmp \n      return tmp\n    return int((helper(0,1) + s)/2)\n      \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n      N = len(piles)\n      @lru_cache(maxsize=None)\n      def recurse(idx, m, alexTurn):\n        # print(f\\\"RECURSE {idx} {m} {alexTurn}\\\")\n        if idx + 2*m > N-1:\n\n          return (sum(piles[idx:]), 0) if alexTurn else (0, sum(piles[idx:]))\n          # return (0, 0)\n        ops = []\n        for x in range(1, 2*m+1):\n          curNumStones = sum(piles[idx:idx+x])\n          (nextA, nextL) = recurse(idx+x, max(m, x), not alexTurn)\n          if alexTurn:\n            ops.append((nextA+curNumStones, nextL))\n          else:\n            ops.append((nextA, nextL+curNumStones))\n        [aScores, lScores] = list(zip(*ops)) \n        if alexTurn:\n          return (max(aScores), max(lScores))\n        else:\n          return (min(aScores), max(lScores))\n      return recurse(0, 1, True)[0]\n    \n    \\\"\\\"\\\"\n    recurse(0, 1, True) -> \n      2 + recurse(1, 1, False) \n        recurse(1, 1, False) -> \n          9 + recurse(2, 1, True) \n          9 + 4 + recurse(3, 2, True)\n      9 + recurse(2, 2, False)\n          \n    \\\"\\\"\\\"", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        s = sum(piles[:])\n        memo = [[-sys.maxsize for i in range(2*n)] for j in range(n)]\n        \n        def DFS(m:int,index:int)->int:\n            if memo[m][index]!=-sys.maxsize:\n                return memo[m][index]\n            if index>=n:\n                return 0\n            score = -sys.maxsize\n            take = min(n-1,index+2*m-1)\n            \n            for i in range(index,take+1):\n                score = max(score,sum(piles[index:i+1])-DFS(max(i-index+1,m),i+1))\n                #print(index,i+1,sum(piles[index:i+1]),score)\n            memo[m][index]=score\n            return score\n                            \n                            \n        return (DFS(1,0)+s)//2", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        post = [0] * (n+1)\n        for i in range(n-1, -1, -1):\n            post[i] = post[i+1] + piles[i]\n        \n        dp = [[-1]*200 for _ in range(101)]\n        \n        def solve(i, m):\n            if i >= len(piles):\n                return 0\n            if dp[i][m] > 0:\n                return dp[i][m]\n            s = ans = 0\n            for di in range(1, 2*m+1):\n                ii = i + di - 1\n                if ii >= len(piles):\n                    break\n                s += piles[ii]\n                other = solve(ii+1, max(m, di))\n                ans = max(ans, s + post[ii+1] - other)\n            dp[i][m] = ans\n            return ans\n        return solve(0, 1)\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        @lru_cache(None)\n        def dp(i, m):\n            if i == n:\n                return 0, 0\n            s = 0\n            a, b = 0, 10 ** 8\n            for j in range(min(2 * m, n - i)):\n                s += piles[i + j]\n                c, d = dp(i + j + 1, max(j + 1, m))\n                a = max(a, s + d)\n                b = min(b, c)\n            return a, b\n        return dp(0, 1)[0]\n", "class Solution:\n    \n    def stoneGameII(self, piles: List[int]) -> int:\n        def dfs(piles, l, m):\n            if (l, m) in self.mem:\n                return self.mem[(l, m)]\n            ret = 0\n            r = min(len(piles), l+2*m)\n            for i in range(l+1, r+1):\n                other = dfs(piles, i, max(m, i-l))\n                cur = sum(piles[l:]) - other\n                ret = max(ret, cur)\n            self.mem[(l, m)] = ret\n            return ret\n        \n        self.mem = dict()\n        return dfs(piles, 0, 1)\n    \n    '''\n    def stoneGameII(self, piles: List[int]) -> int:\n        def dfs(piles, m):\n            ret = 0\n            r = min(len(piles), 2*m)\n            for i in range(1, r+1):\n                other = dfs(piles[i:], max(m, i))\n                cur = sum(piles) - other\n                ret = max(ret, cur)\n            return ret\n        \n        ans = dfs(piles, 1)\n        return ans\n    '''", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        dp = dict()\n        def dfs(i, m):\n            if m >= len(piles) - i:\n                return sum(piles[i:])\n            elif (i, m) in dp:\n                return dp[(i, m)]\n            else:\n                dp[(i, m)] = max([(sum(piles[i:]) - dfs(i+idx+1, max(m, idx+1))) for idx in range(2*m)])\n                return dp[(i, m)]\n        \n        return dfs(0, 1)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        \n        @lru_cache(None)\n        def dp1(prev, m):\n            \n            if prev >= n-1:\n                return 0\n            \n            maxcount = 0\n            \n            for x in range(1, m*2+1):\n                if prev+x >= n:\n                    break\n                    \n                ret = dp2(prev+x, max(m, x)) \n                maxcount = max(maxcount, ret+ sum(piles[prev+1:prev+x+1]))\n                #print(prev+x, m, x, ret, sum(piles[prev+1:prev+x+1]))\n            return maxcount\n\n        @lru_cache(None)\n        def dp2(prev, m):\n            \n            if prev >= n-1:\n                return 0\n            \n            maxcount = float('inf')\n            \n            for x in range(1, m*2+1):\n                if prev+x >= n:\n                    break\n                ret = dp1(prev+x, max(m, x)) \n                maxcount = min(maxcount, ret)\n            \n            return maxcount\n        return dp1(-1, 1)\n                \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        A, n = piles, len(piles)\n        for i in range(n-2, -1, -1):\n            A[i] += A[i+1]\n        @lru_cache(maxsize=None)\n        def helper(i, m):\n            # return the max points current player can get from piles[i:]\n            if i + 2*m >= len(piles):\n                return A[i]\n            res = 0            \n            for x in range(1, 2*m+1):\n                res = max(res, A[i] - helper(i+x, max(m, x)))\n            return res\n        \n        return helper(0, 1)", "import math\nfrom functools import lru_cache\n\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        solved = {}\n        ps = [0] + piles[:]\n        for i in range(1, len(ps)):\n            ps[i] += ps[i - 1]\n        \n        @lru_cache(None)\n        def solve(p, m, is_alex):\n            # if (p, m, is_alex) in solved:\n                # return solved[(p, m, is_alex)]\n            if p >= len(piles):\n                return 0\n            if is_alex:\n                ms = -math.inf\n                for x in range(1, 2 * m + 1):\n                    if p + x < len(ps):\n                        ms = max(ms, ps[p + x] - ps[p] + solve(p + x, max(x, m), not is_alex))\n                    else:\n                        break\n            else:\n                ms = math.inf\n                for x in range(1, 2 * m + 1):\n                    if p + x < len(ps):\n                        ms = min(ms, - (ps[p + x] - ps[p]) + solve(p + x, max(x, m), not is_alex))\n                    else:\n                        break\n            solved[(p, m, is_alex)] = ms\n            return solved[(p, m, is_alex)]\n        \n        diff = solve(0, 1, True)\n        return (ps[-1] + diff) // 2", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        l = len(piles)\n        self.len = l\n        dp = {}\n        \n        total = sum(piles)\n        \n        maxDiff = self.help(piles, 0, 1, dp)\n    \n        return int((total+ maxDiff)/2)\n    \n    def help(self, piles, index, m, dp):\n        \n        if index >= self.len:\n            return 0\n        \n        if dp.get((index, m)) != None:\n            return dp.get((index,m))\n        \n        res = -0xFFFFFFF\n        s = 0\n        for i in range(index, self.len):\n            if i - 2*m >= index:\n                break\n            s += piles[i]\n            res = max(res, s - self.help(piles, i+1, max(m, i - index + 1), dp))\n        \n        dp[(index, m)] = res\n        \n        return res", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        def Util(alexTurn, index, m) -> int:\n            \\\"\\\"\\\"\n            Returns the Maximum sum of Alex\n            \\\"\\\"\\\"\n            if (index >= len(self.piles)):\n                return 0\n            if (index == len(self.piles) - 1):\n                return self.piles[index]\n            # print(f\\\"alexTurn = {alexTurn} index = {index} m = {m}\\\")\n            if (self.dp[index][m] != -1):\n                return self.dp[index][m]\n            \n            totalCounts = 0\n            ans = 0\n\n            for x in range(2*m):\n                if (index + x == len(self.piles)):\n                    break\n                totalCounts += self.piles[index + x]\n                if (index + x + 1 <= len(self.piles)):\n                    nextSum = Util(not alexTurn, index + x + 1, max(m, x+1))\n                    # print(index + x + 1)\n                    if (index + x + 1 == len(self.piles)):\n                        ans = max(ans, totalCounts)\n                    else:\n                        ans = max(ans, totalCounts + self.presum[index + x + 1] - nextSum)\n                    # print(f\\\"index = {index + x + 1} m = {m} nextSum = {nextSum}\\\")\n\n            self.dp[index][m] = ans\n            # print(f\\\"index = {index} m = {m} ans = {ans} totalCounts = {totalCounts}\\\")\n\n            return ans\n        \n        self.presum = copy.copy(piles)\n        for i in reversed(range(len(piles) - 1)):\n            self.presum[i] += self.presum[i + 1]\n        # print(self.presum)\n        self.dp = [-1]*len(piles)\n        for j in range(len(piles)):\n            self.dp[j] = [-1] * len(piles)\n                \n        self.piles = piles\n        return Util(True, 0, 1)\n        ", "import numpy as np\nfrom functools import lru_cache\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        cumsum=np.cumsum(piles[::-1])\n        @lru_cache(None)\n        def optimalValue(m,s):\n            if s==0: return 0\n            cumsum[s-1]\n            return max([cumsum[s-1]-optimalValue(max(m,n),s-n) for n in range(1,2*m+1) if s-n>=0])\n        return optimalValue(1,len(piles))\n", "from functools import lru_cache\nclass Solution:\n    def stoneGameII(self, a: List[int]) -> int:\n        n = len(a)\n        sums = [0] * n\n        sums[-1] = a[-1]\n        for i in reversed(range(len(sums)- 1)):\n            sums[i] = a[i] + sums[i+1]\n            \n        @lru_cache(None)\n        def dp(i, m):\n            if i >= n: return 0\n            return max(sums[i] - dp(i + x, max(x,m)) for x in range(1, 2*m + 1))\n        \n        return dp(0, 1)", "MIN = float('-inf')\nclass Solution:\n    def stoneGameII(self, piles):\n        \n        n = len(piles)\n        preSum = [0] * (n+1)\n        for i in range(1,n+1):\n            preSum[i] += preSum[i-1] + piles[i-1]\n        \n        def dfs(start, M, memo):\n            if start == n:\n                return 0\n            if (start,M) in memo:\n                return memo[(start,M)]\n            max_diff = MIN\n            for X in range(1, 2*M+1):\n                end = min(n, start+X)\n                cur = preSum[end] - preSum[start]\n                max_diff = max(max_diff, cur-dfs(end, max(M,X), memo))\n            memo[(start,M)] = max_diff\n            return max_diff\n        \n        total = sum(piles)\n        return (dfs(0, 1, {})+total) // 2\n        \n", "import math\n\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        solved = {}\n        ps = [0] + piles[:]\n        for i in range(1, len(ps)):\n            ps[i] += ps[i - 1]\n        \n        def solve(p, m, is_alex):\n            if (p, m, is_alex) in solved:\n                return solved[(p, m, is_alex)]\n            if p >= len(piles):\n                return 0\n            if is_alex:\n                ms = -math.inf\n                for x in range(1, 2 * m + 1):\n                    if p + x < len(ps):\n                        ms = max(ms, ps[p + x] - ps[p] + solve(p + x, max(x, m), not is_alex))\n                    else:\n                        break\n            else:\n                ms = math.inf\n                for x in range(1, 2 * m + 1):\n                    if p + x < len(ps):\n                        ms = min(ms, - (ps[p + x] - ps[p]) + solve(p + x, max(x, m), not is_alex))\n                    else:\n                        break\n            solved[(p, m, is_alex)] = ms\n            return solved[(p, m, is_alex)]\n        \n        diff = solve(0, 1, True)\n        return (sum(piles) + diff) // 2", "from functools import lru_cache\n\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        \n        @lru_cache(None)\n        def value(M, ind):\n            if ind >= n:\n                return 0\n            \n            v_max = 0\n            for X in range(1, 2*M + 1):\n                M_new = max(X, M)\n                v = sum(piles[ind:]) - value(M_new, ind+X)\n                v_max = max(v, v_max)\n            return v_max\n        \n        val = value(1, 0)\n        return val", "from functools import lru_cache\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        # dp[i,m] = max stones the current player can take from piles[i:] with M = m\n        # which means 1 <= x <= 2M\n        # use backwards prefix sum A[i] = totel stones of piles[i:]\n        # means how many more the current player can take for max\n        # the other player stones dp[i+x, max(m,x)]\n        # the current player stone = A[i] - dp[i+x, max(m,x)]\n        \n        N = len(piles)\n        for i in range(N-2, -1, -1):\n          piles[i] += piles[i+1]\n        \n        @lru_cache(None)\n        def dp(i, m):\n          if i + 2*m >= N:\n            return piles[i] # take as many as possible\n          min_left = float('inf')\n          for x in range(1, 2*m+1):\n            min_left = min(min_left, dp(i+x, max(m, x)))\n          return piles[i] - min_left\n        \n        return dp(0,1)", "class Solution:\n    def rec(self, i, m, t):\n            if self.memo[i][m][t]!=-1:\n                return self.memo[i][m][t]\n            \n            if i==self.n:\n                return 0\n            \n            if t==0:\n                res, now = 0, 0\n                \n                for j in range(2*m):\n                    if i+j>=self.n:\n                        break\n                    now += self.piles[i+j]\n                    res = max(res, now+self.rec(i+j+1, max(m, j+1), 1))\n            else:\n                res = 10**18\n                \n                for j in range(2*m):\n                    if i+j>=self.n:\n                        break\n                    res = min(res, self.rec(i+j+1, max(m, j+1), 0))\n            \n            self.memo[i][m][t] = res\n            return res\n\n    def stoneGameII(self, piles: List[int]) -> int:\n        self.n = len(piles)\n        self.piles = piles\n        self.memo = [[[-1]*2 for _ in range(110)] for _ in range(self.n+1)]\n        return self.rec(0, 1, 0)", "import math\n\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        solved = {}\n        ps = [0] + piles[:]\n        for i in range(1, len(ps)):\n            ps[i] += ps[i - 1]\n        \n        def solve(p, m, is_alex):\n            if (p, m, is_alex) in solved:\n                return solved[(p, m, is_alex)]\n            if p >= len(piles):\n                return 0\n            if is_alex:\n                ms = -math.inf\n                for x in range(1, 2 * m + 1):\n                    if p + x < len(ps):\n                        ms = max(ms, ps[p + x] - ps[p] + solve(p + x, max(x, m), not is_alex))\n            else:\n                ms = math.inf\n                for x in range(1, 2 * m + 1):\n                    if p + x < len(ps):\n                        ms = min(ms, - (ps[p + x] - ps[p]) + solve(p + x, max(x, m), not is_alex))\n            solved[(p, m, is_alex)] = ms\n            return solved[(p, m, is_alex)]\n        \n        diff = solve(0, 1, True)\n        return (sum(piles) + diff) // 2", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        def Util(alexTurn, index, m) -> int:\n            \\\"\\\"\\\"\n            Returns the Maximum sum of Alex\n            \\\"\\\"\\\"\n            if (index >= len(self.piles)):\n                return 0\n            turn = 1 if alexTurn is True else 0\n\n            # print(f\\\"alexTurn = {alexTurn} index = {index} m = {m}\\\")\n            if (self.dp[turn][index][m] != -1):\n                return self.dp[turn][index][m]\n            \n            totalCounts = 0\n            ans = 0\n            if (alexTurn):\n                ans = 0\n                for x in range(2*m):\n                    if (index + x == len(self.piles)):\n                        break\n                    totalCounts += self.piles[index + x]\n                    alexSum = Util(not alexTurn, index + x + 1, max(m, x+1))\n                    # print(f\\\"alexSum = {alexSum} index = {index} x = {x} M = {max(m, x + 1)} ans = {alexSum + totalCounts}\\\")\n                    ans = max(alexSum + totalCounts, ans)\n                # print(f\\\"alexTurn = {alexTurn} index = {index} x = {x} M = {max(m, x + 1)} ans = {alexSum + totalCounts}\\\")\n\n            else:\n                ans = sys.maxsize\n                for x in range(2*m):\n                    if (index + x == len(self.piles)):\n                        break\n                    totalCounts += self.piles[index + x]\n                    alexSum = Util(not alexTurn, index + x + 1, max(m, x+1))\n                    ans = min(alexSum, ans)\n                # print(f\\\"alexTurn = {alexTurn} index = {index} x = {x} M = {max(m, x + 1)} ans = {alexSum + totalCounts}\\\")\n            self.dp[turn][index][m] = ans\n            return ans\n        self.dp = [-1]*2\n        for i in range(2):\n            self.dp[i] = [-1]*len(piles)\n            for j in range(len(piles)):\n                self.dp[i][j] = [-1] * len(piles)\n                \n        self.piles = piles\n        return Util(True, 0, 1)\n        ", "\\\"\\\"\\\"\nThere are 2 pieces of information to memo: 1. Alice's maximum score, 2. Bob's maximum score. Combine them into a tuple and store it in a dict, the key of which is (current index, m).\nWe will start from the piles[index], and compute the cumulative sum all the way up to piles[index+2*m].\nThen we recursively call the DP function with the new index and m. After trying all the possible ways, take the maximum value, and store it in the dict.\n\n\\\"\\\"\\\"\nclass Solution:\n    def stoneGameII(self, piles):\n        d = {} # (idx, m): (Alice's score, Bob's score)\n        def DP(idx, m):\n            if idx>=len(piles):\n                return (0,0)\n            if (idx,m) in d:\n                return d[(idx,m)] # Memo!\n            s, ans, oppo = 0, 0, 0\n            for i in range(idx, idx+2*m): # try all the possible sum\n                if i>=len(piles):\n                    break\n                s += piles[i]\n                dp_ans = DP(i+1, max(m, i-idx+1)) # fetch the result from subproblem\n                if s+dp_ans[1]>ans:\n                    ans = s+dp_ans[1] # [1] is the real Alice's score from the next subproblem\n                    oppo = dp_ans[0] # [0] is Bob's score\n            d[(idx,m)] = (ans, oppo) # store the information\n            return (ans, oppo)\n\n        ans = DP(0, 1)\n        return ans[0]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        def Util(alexTurn, index, m) -> int:\n            \\\"\\\"\\\"\n            Returns the Maximum sum of Alex\n            \\\"\\\"\\\"\n            if (index >= len(self.piles)):\n                return 0\n            turn = 1 if alexTurn is True else 0\n\n            # print(f\\\"alexTurn = {alexTurn} index = {index} m = {m}\\\")\n            if (self.dp[turn][index][m] != -1):\n                return self.dp[turn][index][m]\n            \n            totalCounts = 0\n            ans = 0\n            if (alexTurn):\n                ans = -sys.maxsize\n            else:\n                ans = sys.maxsize\n            for x in range(2*m):\n                if (index + x == len(self.piles)):\n                    break\n                totalCounts += self.piles[index + x]\n                alexSum = Util(not alexTurn, index + x + 1, max(m, x+1))\n                # print(f\\\"alexSum = {alexSum} index = {index} x = {x} M = {max(m, x + 1)} ans = {alexSum + totalCounts}\\\")\n                if (alexTurn):\n                    ans = max(alexSum + totalCounts, ans)\n                else:\n                    ans = min(alexSum, ans)\n            # print(f\\\"alexTurn = {alexTurn} index = {index} x = {x} M = {max(m, x + 1)} ans = {alexSum + totalCounts}\\\")\n\n#             else:\n#                 ans = sys.maxsize\n#                 for x in range(2*m):\n#                     if (index + x == len(self.piles)):\n#                         break\n#                     totalCounts += self.piles[index + x]\n#                     alexSum = Util(not alexTurn, index + x + 1, max(m, x+1))\n#                     ans = min(alexSum, ans)\n                # print(f\\\"alexTurn = {alexTurn} index = {index} x = {x} M = {max(m, x + 1)} ans = {alexSum + totalCounts}\\\")\n            self.dp[turn][index][m] = ans\n            return ans\n        self.dp = [-1]*2\n        for i in range(2):\n            self.dp[i] = [-1]*len(piles)\n            for j in range(len(piles)):\n                self.dp[i][j] = [-1] * len(piles)\n                \n        self.piles = piles\n        return Util(True, 0, 1)\n        ", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        prefix_sum = [0] * (n+1)\n        for i in range(1, len(prefix_sum)):\n            prefix_sum[i] = prefix_sum[i-1] + piles[i-1]\n        memo = {}\n        def dfs(pos, m, player1):\n            if pos >= len(piles):\n                return 0\n            if (pos, m, int(player1)) in memo:\n                return memo[(pos, m, int(player1))]\n            \n            if player1:\n                best_score = -sys.maxsize\n            else:\n                best_score = sys.maxsize\n                    \n            for x in range(1, 2*m + 1):\n                if pos + x > len(piles):\n                    break\n                score = dfs(pos + x, max(m, x), not player1)\n                if player1:\n                    score += prefix_sum[pos+x] - prefix_sum[pos]\n                    best_score = max(best_score, score)\n                else:\n                    best_score = min(best_score, score)\n            memo[(pos,m,int(player1))] = best_score\n            return best_score\n        return dfs(0, 1, True)", "class Solution:\n    def helper(self, s, M, n):\n        if s >= n:\n            return 0\n        if (s, M) in self.mem:\n            return self.mem[(s, M)]\n        cur, best = 0, -float('inf')\n        for x in range(1, 2*M + 1):\n            if s + x > n:\n                break\n            cur += self.piles[s + x -1]\n            best = max(best, cur - self.helper(s + x, max(x, M), n))\n        self.mem[(s, M)] = best\n        return best\n                \n        \n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        self.mem = {}\n        self.piles = piles\n        return (sum(piles) + self.helper(0, 1, n))//2\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        @lru_cache(None)\n        def minimax(start, m, player):\n            if start >= len(piles):\n                return 0\n            if player == 1:\n                #Alex's turn\n                return max(sum(piles[start:start + x]) + minimax(start + x ,max(x, m),2) for x in range(1, 2*m + 1))\n            if player == 2:\n                return min(minimax(start + x, max(x, m), 1) for x in range(1, 2*m + 1))\n        # @lru_cache\n        # def getsum(start, end, input):\n        return minimax(0, 1, 1)\n        \n                \n                \n                \n                \n                \n                \n#         result = dict()\n#         result_min = dict()\n        \n#         def minimax(start, M, player):\n#             if start >= len(piles):\n#                 return 0\n#             if player == 1:\n#                 # maxnum = -1\n#                 if (start, M) in result:\n#                     return result[(start, M)]\n#                 maxnum = -1\n#                 for X in range(1, 2 * M + 1):\n#                     temp = minimax(start + X, max(X, M), 2) + sum(piles[start:start + X])\n#                     if temp > maxnum:\n#                         maxnum = temp\n#                 result[(start, M)] = maxnum\n#                 return maxnum\n                \n#             if player == 2:\n#                 #minimize\n#                 minnum = 10^5\n#                 if (start, M) in result_min:\n#                     return result_min[(start, M)]\n#                 minnum = 1000000\n#                 for X in range(1, 2 * M + 1):\n#                     temp = minimax(start + X, max(X, M), 1)\n#                     if temp < minnum:\n#                         minnum = temp\n#                 result_min[(start, M)] = minnum\n#                 return minnum\n#         res = minimax(0, 1, 1)\n#         print(result)\n#         print(result_min)\n#         return res\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        prefix_sum = [0] * (n+1)\n        for i in range(1, len(prefix_sum)):\n            prefix_sum[i] = prefix_sum[i-1] + piles[i-1]\n        memo = {}\n        def dfs(pos, m, player1):\n            if pos >= len(piles):\n                return (0, 0)\n            if (pos, m, int(player1)) in memo:\n                return memo[(pos, m, int(player1))]\n            \n            if player1:\n                best_score = -sys.maxsize\n                p1_score = 0\n            else:\n                best_score = sys.maxsize\n                p1_score = 0\n                    \n            for x in range(1, 2*m + 1):\n                if pos + x > len(piles):\n                    break\n                score, p1_score_candidate = dfs(pos + x, max(m, x), not player1)\n                if player1:\n                    score += prefix_sum[pos+x] - prefix_sum[pos]\n                    if score > best_score:\n                        p1_score = p1_score_candidate + prefix_sum[pos+x] - prefix_sum[pos]\n                        best_score = score\n                else:\n                    score += -prefix_sum[pos+x] + prefix_sum[pos]\n                    if score < best_score:\n                        best_score = score\n                        p1_score = p1_score_candidate\n            memo[(pos,m,int(player1))] = (best_score, p1_score)\n            return (best_score, p1_score)\n        return dfs(0, 1, True)[1]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        length = len(piles)\n        dp = [[0]*length for i in range(length)]\n        visited = [[0]*(length+1) for i in range(length+1)]\n        \n        def helper(index,M):\n            if index==length:\n                return 0\n            if visited[index][M]!=0:\n                return dp[index][M]\n            best = float('-inf')\n            for i in range(1,2*M+1):\n                astones = sum(piles[index:index+i])\n                score = astones-helper(min(index+i,length),min(max(M,i),length))\n                best = max(score,best)\n            dp[index][M] = best\n            visited[index][M] = 1\n            return best\n        total = sum(piles)\n        diff = helper(0,1)\n        return (total+diff)//2", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        for i in range(len(piles) -2, -1, -1):\n            piles[i] += + piles[i + 1]\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def takeStone(startInd, M):\n            #print(startInd, M)\n            if startInd + 2*M>= len(piles):\n                return piles[startInd]\n            \n            bestChoice = float('inf')\n            for X in range(1, 2*M + 1):\n                newInd = startInd + X\n                bestChoice = min(bestChoice, takeStone(newInd, max(X, M)))\n            return piles[startInd] - bestChoice\n        \n        return takeStone(0, 1)\n                        \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        p = [0]\n        cur = 0\n        for i in piles:\n            cur += i\n            p.append(cur)\n        \n        n = len(piles)\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(start, m):\n            if start >= n: return 0\n            return max(p[-1] - p[start] - dp(start+i, max(i,m)) for i in range(1,2*m+1))\n        return dp(0,1)\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        @functools.lru_cache(maxsize=None)\n        def minimax(st, m, player):\n            if st >= len(piles): return 0\n            if player:\n                return max([sum(piles[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n            else:\n                return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        return minimax(0, 1, 1) ", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        neg = -float(\\\"inf\\\")\n        cache = [[0] * (n + 1) for _ in range(n + 1)]\n        hasCache = [[False] * (n + 1) for _ in range(n + 1)]\n        \n        def get_result(index, M) -> int:\n            if(index == n): \n                return 0\n            if hasCache[index][M]:\n                return cache[index][M]\n            best = neg\n            \n            for i in range(1, 2*M + 1):\n                num = sum(piles[index : index + i])\n                score = num - get_result(min(index + i, n), min(max(i, M), n))\n                best = max(best, score)\n                \n            hasCache[index][M] = True\n            cache[index][M] = best\n            return best\n        \n        total = sum(piles)\n        delta = get_result(0, 1)\n        return (total + delta) // 2", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def minimax(st, m, player):\n            if st >= len(piles):\n                return 0\n            if player:\n                return max([sum(piles[st:st+x]) + minimax(st+x, max(m, x), player^1) for x in range(1, 2*m+1) ])\n            else:\n                return min([minimax(st+x, max(m, x), player^1) for x in range(1, 2*m+1)])\n        \n        return minimax(0, 1, 1)\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        self.piles = piles\n        @lru_cache(maxsize=None)\n        def helper(i, j, M, turn = True):\n            \n            if i>=j:\n                return 0\n\n            X = list(range(1,2*M+1))\n            if turn:\n                maxalex = -sys.maxsize\n            else:\n                maxalex = sys.maxsize\n            for x in X:\n                \n                if turn:\n                    if i+x <= j:\n                        # print(\\\"Alex's turn\\\")\n                        # print(\\\"Alex is picking - \\\", self.piles[i:i + x])\n                        \n                        alex = sum(self.piles[i:i + x]) + helper(i + x, j, max(x,M), turn=False)\n                        maxalex = max(alex,maxalex)\n                        # print(\\\"For \\\", i, \\\" turn, Alex got, \\\", alex)\n                else:\n                    # print(\\\"Lee's turn for \\\", i)\n                    alex = helper(i + x, j, max(x,M), turn=True)\n                    # print(\\\"After Lee picked in \\\", i, \\\" turn, Alex got \\\", alex)\n                    maxalex = min(alex,maxalex)\n                \n                \n                \n            return maxalex\n        \n        return helper(0,len(self.piles),1)", "class Solution:\n    def stoneGameII(self, a: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def minimax(st, m, player):\n            if st >= len(a): return 0\n            if player:\n                return max([sum(a[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n            else:\n                return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        return minimax(0, 1, 1) ", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def minimax(st, m, player):\n            if st >= len(piles): return 0\n            if player:\n                return max([sum(piles[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n            else:\n                return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        return minimax(0, 1, 1)        \n\n# [NOTE] Really good explanation here:\n# https://leetcode.com/problems/stone-game-ii/discuss/345222/Python-Minimax-DP-solution\n# The idea of minimax :\n# If am the player 1 (whose winning sum we are trying to calculate), then I recurse on all possibilities and get the max.\n# If am the player 2 (the opponent), then I try to minimize what P1 gets, and since we are not interested in what score P2 gets, we only calculate the min(all P1 next moves) and dont include the score P2 gets.\n# Thanks to @douzigege for his comment which explains the minimax scenario specifically for this problem.\n\n# if player == 1st player,\n# gain = first x piles + minimax(..., 2nd player), where the gain is maximized\n# if player == 2nd player,\n# gain = 0 + minimax(..., 1st player), where the gain is minimized because the 2nd player tries to maximize this\n\n# TLE for this input without@lru_cache\n# [8270,7145,575,5156,5126,2905,8793,7817,5532,5726,7071,7730,5200,5369,5763,7148,8287,9449,7567,4850,1385,2135,1737,9511,8065,7063,8023,7729,7084,8407]\n", "class Solution:\n    def stoneGameII(self, a: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def minimax(st, m, player):\n            if st >= len(a): return 0\n            if player:\n                return max([sum(a[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n            else:\n                return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        return minimax(0, 1, 1)   ", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        @lru_cache(maxsize=None)\n        def minmax(st,m,player):\n            if(st>=len(piles)):\n                return 0\n            if(player):\n                return max([sum(piles[st:st+x])+minmax(st+x,max(x,m),player^1) for x in range(1,2*m+1)])\n            else:\n                return min([minmax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n            \n        return minmax(0,1,1)\n        \n        \n        \n#         piles=[0]+piles\n        \n#         self.p1=float('inf')\n#         def traverse(piles,ind,ch,m,p1,p2):\n#             print(ind,p1,p2)\n#             if(ind==len(piles)):\n#                 self.p1=min(p1,self.p1)\n#             if(ch==1):\n#                 su=0\n#                 for i in range(ind,min(ind+2*m+1,len(piles))):\n#                     su+=piles[i]\n#                     traverse(piles,i+1,ch^1,max(m,i),p1+su,p2)\n                    \n#             else:\n#                 su=0\n#                 for i in range(ind,min(ind+2*m+1,len(piles))):\n#                     su+=piles[i]\n#                     traverse(piles,i+1,ch^1,max(m,i),p1,p2+su)\n                \n#         traverse(piles,1,1,1,0,0)\n        \n#         return self.p1\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n#         @lru_cache\n#         def minimax(start, m, player):\n#             if start >= len(piles):\n#                 return 0\n#             if player == 1:\n#                 #Alex's turn\n#                 return max(sum(piles[start:start + x]) + minimax(start + x ,max(x, m),2) for x in range(1, 2*m + 1))\n#             if player == 2:\n#                 return min(minimax(start + x, max(x, m), 1) for x in range(1, 2*m + 1))\n        \n#         return minimax(0, 1, 1)\n        \n                \n                \n                \n                \n                \n                \n        result = dict()\n        result_min = dict()\n        \n        def minimax(start, M, player):\n            if start >= len(piles):\n                return 0\n            if player == 1:\n                # maxnum = -1\n                if (start, M) in result:\n                    return result[(start, M)]\n                maxnum = -1\n                for X in range(1, 2 * M + 1):\n                    temp = minimax(start + X, max(X, M), 2) + sum(piles[start:start + X])\n                    if temp > maxnum:\n                        maxnum = temp\n                result[(start, M)] = maxnum\n                return maxnum\n                \n            if player == 2:\n                #minimize\n                minnum = 10^5\n                if (start, M) in result_min:\n                    return result_min[(start, M)]\n                minnum = 1000000\n                for X in range(1, 2 * M + 1):\n                    temp = minimax(start + X, max(X, M), 1)\n                    if temp < minnum:\n                        minnum = temp\n                result_min[(start, M)] = minnum\n                return minnum\n        res = minimax(0, 1, 1)\n        print(result)\n        print(result_min)\n        return res\n", "from functools import lru_cache\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        n = len(piles)\n        \n        @lru_cache(maxsize = None)\n        def dfs(index, M):\n            if 2*M >= n - index:\n                return sum(piles[index:])\n            \n            ret = float('inf')\n            for X in range(1, 2*M + 1):\n                if X > n - index:\n                    break\n                ret = min(ret, dfs(index + X, max(X, M)))\n            \n            return sum(piles[index:]) - ret\n        \n        return dfs(0, 1)\n        \n#         def dfs(index, M, order):\n#             if 2*M >= n - index:\n#                 if order % 2 == 1:\n#                     return sum(piles[index:]), 0\n#                 else:\n#                     return 0, sum(piles[index:])\n            \n#             ret = [0, 0]\n#             for x in range(1, 2*M + 1):\n#                 if x > n - index:\n#                     break\n#                 a, b = dfs(index + x, max(x, M), (order + 1) % 2)\n#                 if order % 2 == 1:\n#                     # a += sum(piles[index:index+x])\n#                     if a > ret[0]:\n#                         ret[0] = a + sum(piles[index:index+x])\n#                         ret[1] = b\n#                 else:\n#                     if b > ret[1]:\n#                         # b += sum(piles[index:index+x])\n#                         ret[0] = a\n#                         ret[1] = b + sum(piles[index:index+x])\n                        \n#             return ret[0], ret[1]\n        \n#         return dfs(0, 1, 1)[0]\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        def stoneGameIIUtil(piles: List[int], m: int, alex: bool) -> int:\n            if not piles: return 0\n            \n            best = 0 if alex else 1000000\n            for x in range(1, min(2 * m + 1, len(piles) + 1)):\n                total = sum(piles[:x]) if alex else 0\n                total += stoneGameIIUtil(piles[x:], max(m, x), not alex)\n                best = max(best, total) if alex else min(best, total)\n            return best\n            \n        return stoneGameIIUtil(piles, 1, True)\n\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        lookup = {}\n        def stoneGameIIUtil(piles: List[int], m: int, alex: bool) -> int:\n            if not piles: return 0\n            if (tuple(piles), m, alex) in lookup:\n                return lookup[(tuple(piles), m, alex)]\n            \n            best = 0 if alex else 1000000\n            for x in range(1, min(2 * m + 1, len(piles) + 1)):\n                total = sum(piles[:x]) if alex else 0\n                total += stoneGameIIUtil(piles[x:], max(m, x), not alex)\n                best = max(best, total) if alex else min(best, total)\n            lookup[(piles, m, alex)] = best\n            return best\n            \n        return stoneGameIIUtil(tuple(piles), 1, True)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        # @lru_cache(maxsize=None)\n        # def minimax(st, m, player):\n        #     if st >= len(piles): return 0\n        #     if player:\n        #         return max([sum(piles[st:st+x]) + minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        #     else:\n        #         return min([minimax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        # # print()\n        # return minimax(0, 1, 1)   \n        result = dict()\n        result_min = dict()\n        \n        def minimax(start, M, player):\n            if start >= len(piles):\n                return 0\n            if player == 1:\n                # maxnum = -1\n                if (start, M) in result:\n                    return result[(start, M)]\n                maxnum = -1\n                for X in range(1, 2 * M + 1):\n                    temp = minimax(start + X, max(X, M), 2) + sum(piles[start:start + X])\n                    if temp > maxnum:\n                        maxnum = temp\n                result[(start, M)] = maxnum\n                return maxnum\n                \n            if player == 2:\n                #minimize\n                minnum = 10^5\n                if (start, M) in result_min:\n                    return result_min[(start, M)]\n                minnum = 1000000\n                for X in range(1, 2 * M + 1):\n                    temp = minimax(start + X, max(X, M), 1)\n                    if temp < minnum:\n                        minnum = temp\n                result_min[(start, M)] = minnum\n                return minnum\n        res = minimax(0, 1, 1)\n        print(result)\n        print(result_min)\n        return res\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        s = 0\n        for i in range(len(piles)-1,-1,-1):\n            s+=piles[i]\n            piles[i] = s\n        \n        def bt(m,player,M,remain,spiles):\n            if remain <= 0 :\n                return 0\n            \n            key = (player,M,remain)\n            if key in m:\n                return m[key]\n            \n            res = 0\n            for take in range(1,2*M+1):\n                index = len(piles) - remain\n                res = max(res, spiles[index] - bt(m,1-player,max(M, take), remain - take,spiles))\n                \n            m[key] = res\n            return res\n        \n        return bt({},0,1,len(piles),piles)", "class Solution:\n    def stoneGameII(self, A: List[int]) -> int:\n        n = len(A)\n        memo = {}\n        def take(i, m, alex):\n            if i >= len(A):\n                return 0\n            \n            if (i, m, alex) in memo:\n                return memo[(i, m, alex)]\n            \n            if alex:\n                res = 0\n                taking = 0\n                for x in range(1, min(n,2*m + 1)):\n                    if i+x-1 < n:\n                        taking += A[i+x-1]\n                    res = max(res, taking + take(i+x, max(m, x), False))\n            else:\n                res = sum(A[i:])\n                for x in range(1, min(n,2*m + 1)):\n                    res = min(res, take(i+x, max(m,x), True))\n            \n            memo[(i, m, alex)] = res\n            \n            return res\n        return take(0, 1, True)\n                \n                \n                    \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        l = len(piles)\n        dp = [[[-1 for i in range(l)] for j in range(2*l)] for k in range(2)]\n        \n        def game(piles, M, pos, player):\n            total = 0\n            if pos >= l:\n                return 0\n            if dp[player][pos][M] != -1:\n                return dp[player][pos][M]\n            if player == 0:\n                maxsum = 0\n                for X in range(1, 2 * M + 1):\n                    maxsum = max(maxsum, sum(piles[pos:pos+X]) + game(piles, max(M, X), pos+X, not player))\n                \n                dp[player][pos][M] = maxsum   \n                return maxsum\n            else:\n                minsum = sys.maxsize\n                for X in range(1, 2 * M + 1):\n                    minsum = min(minsum, game(piles, max(M, X), pos + X, not player))\n                dp[player][pos][M] = minsum\n\n                if minsum == sys.maxsize:\n                    return 0\n                \n                \n                return minsum  \n            \n\n        return game(piles, 1, 0, 0)\n            \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        def pick_stones(i,m,t):\n            '''\n            m -> player can pick 1<=X<=2M piles\n            t -> player 1's turn if true else 0\n            '''\n            if i>=len(piles):\n                return 0\n            if (i,m,t) in d:\n                return d[(i,m,t)]\n            if t:\n                d[(i,m,t)]=max(pick_stones(i+k,max(m,k),False)+sum(piles[i:i+k]) for k in range(1,2*m+1))\n            else:\n                d[(i,m,t)]=min(pick_stones(i+k,max(m,k),True) for k in range(1,2*m+1))\n            return d[(i,m,t)]\n        d={}\n        return pick_stones(0,1,True)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        @lru_cache(maxsize=None)\n        def minmax(st,m,player):\n            if(st>=len(piles)):\n                return 0\n            if(player):\n                return max([sum(piles[st:st+x])+minmax(st+x,max(x,m),player^1) for x in range(1,2*m+1)])\n            else:\n                return min([minmax(st+x, max(m,x), player^1) for x in range(1, 2*m+1)])\n        return minmax(0,1,1)\n        \n        \n        \n#         piles=[0]+piles\n        \n#         self.p1=float('inf')\n#         def traverse(piles,ind,ch,m,p1,p2):\n#             print(ind,p1,p2)\n#             if(ind==len(piles)):\n#                 self.p1=min(p1,self.p1)\n#             if(ch==1):\n#                 su=0\n#                 for i in range(ind,min(ind+2*m+1,len(piles))):\n#                     su+=piles[i]\n#                     traverse(piles,i+1,ch^1,max(m,i),p1+su,p2)\n                    \n#             else:\n#                 su=0\n#                 for i in range(ind,min(ind+2*m+1,len(piles))):\n#                     su+=piles[i]\n#                     traverse(piles,i+1,ch^1,max(m,i),p1,p2+su)\n                \n#         traverse(piles,1,1,1,0,0)\n        \n#         return self.p1\n", "class Solution:\n    # 0123\n    def playerGame(self, pos, piles, player1, M,memo):\n        optionsCount = min (len(piles) - pos, 2*M)\n        #print (optionsCount)\n        resultPlayer1 = 0\n        resultPlayer2 = 0\n        for i in range(pos, pos + optionsCount):\n            X = i -pos + 1\n            #print (X)\n            stonesCount = 0\n            for j in range(pos,i+1):\n                stonesCount +=piles[j]\n            combination = (i+1,not player1, max(M,X))\n            if combination in memo:\n                count1, count2 = memo[combination]\n            else:\n                count1,count2 = self.playerGame(i +1, piles, not player1, max(M,X),memo)\n                memo[combination] = [count1,count2]\n            if player1:\n                if stonesCount + count1 > resultPlayer1:\n                    resultPlayer1 = stonesCount + count1\n                    resultPlayer2 = count2\n            else:\n                if stonesCount + count2 > resultPlayer2:\n                    resultPlayer1 = count1\n                    resultPlayer2 = stonesCount + count2\n        return resultPlayer1,resultPlayer2 \n \n        \n    def stoneGameII(self, piles: List[int]) -> int:\n        #get max number of stones for Alex \n        M=1\n        player1 = True\n        memo = {}\n        pos = 0\n        return self.playerGame(pos,piles, player1, M, memo)[0]\n\n                \n            \n", "class Solution:\n    def stoneGameII(self, A: List[int]) -> int:\n        \n        \n        \n        # my solution ... 96 ms ... 51 % ... 14.9 MB ... 25 %\n        #  time: O()\n        # space: O()\n        \n        seen = {}\n        def max_stones(sidx, m):  # \u8fd4\u56de\u9762\u5bf9 A[sidx:] \u65f6\uff0c\u76f4\u81f3\u6e38\u620f\u7ed3\u675f\uff0c\u6240\u80fd\u53d6\u5230\u7684\u6700\u591a\u77f3\u5934\n            if sidx == len(A):\n                return 0\n            if (sidx, m) not in seen:\n                if len(A)-sidx <= 2*m:\n                    seen[sidx, m] = endsum[sidx]  # sum(A[sidx:])\n                else:\n                    res = 0\n                    for x in range(1, 2*m+1):\n                        new_sidx = sidx + x\n                        res = max(res, endsum[sidx] - max_stones(new_sidx, max(m, x)))\n                    seen[sidx, m] = res\n            return seen[sidx, m]\n        \n        endsum = [A[-1]]*len(A)\n        for j in range(len(A)-2, -1, -1):\n            endsum[j] = A[j] + endsum[j+1]\n        return max_stones(0, 1)\n        \n        \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        def pick_stones(i,m,t):\n            '''\n            m -> player can pick 1<=X<=2M piles\n            t -> player 1's turn if true else 0\n            '''\n            if i>=len(piles):\n                return 0\n            if (i,m,t) in d:\n                return d[(i,m,t)]\n            if t:\n                d[(i,m,t)]=max(pick_stones(i+k,max(m,k),1-t)+sum(piles[i:i+k]) for k in range(1,2*m+1))\n            else:\n                d[(i,m,t)]=min(pick_stones(i+k,max(m,k),1-t) for k in range(1,2*m+1))\n            return d[(i,m,t)]\n        d={}\n        return pick_stones(0,1,True)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        memo = {}\n        n = len(piles)\n        \n        def dfs(player, start, m):\n            if (player, start, m) in memo:\n                return memo[(player, start, m)]\n            \n            cur = 0\n            res = 0\n            aj = i = start\n            am = m\n            \n            while i < n and i - start + 1 <= 2 * m:\n                cur += piles[i]\n                _, bj, bm = dfs(1 - player, i + 1, max(i - start + 1, m))\n                if res < cur + dfs(player, bj + 1, bm)[0]:\n                    res = cur + memo[(player, bj + 1, bm)][0]\n                    aj = i\n                    am = max(i - start + 1, m)\n                    \n                i += 1\n            \n            memo[(player, start, m)] = (res, aj, am)\n            return res, aj, am\n        \n        return dfs(0, 0, 1)[0]\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        @lru_cache(None)\n        def dp(idx,M,people):\n            if idx>=len(piles):\n                return 0\n            res=[]\n            for X in range(1,2*M+1,1):\n                res.append(dp(idx+X,max(M,X),1 if people==0 else 0)+people*sum(piles[idx:idx+X]))\n            if people==1:\n                return max(res)\n            else:\n                return min(res)\n        return dp(0,1,1)\n                \n", "MIN = float('-inf')\nclass Solution:\n    def stoneGameII(self, piles):\n        \n        def dfs(start, M, memo):\n            if start == len(piles):\n                return 0\n            if (start,M) in memo:\n                return memo[(start,M)]\n            max_diff = MIN\n            for X in range(1, 2*M+1):\n                cur, end = 0, min(len(piles), start+X)\n                for i in range(start, end):\n                    cur += piles[i]\n                max_diff = max(max_diff, cur-dfs(end, max(M,X), memo))\n            memo[(start,M)] = max_diff\n            return max_diff\n        \n        total = sum(piles)\n        return (dfs(0, 1, {})+total) // 2\n        \n", "class Solution:\n    def stoneGameII(self, a: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def minimax(start, m, alex):\n            if start >= len(a): return 0\n            if alex:\n                return max([sum(a[start:start+x]) + minimax(start+x, max(m,x), (not alex)) for x in range(1, 2*m+1)])\n            else:\n                return min([minimax(start+x, max(m,x), (not alex)) for x in range(1, 2*m+1)])\n        return minimax(0, 1, True)\n        \n        \n        \n        \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n      N = len(piles)\n      @lru_cache(maxsize=None)\n      def recurse(idx, m, alexTurn):\n        # print(f\\\"RECURSE {idx} {m} {alexTurn}\\\")\n        if idx > N-1:\n          return (0, 0)\n        ops = []\n        for x in range(1, 2*m+1):\n          curNumStones = sum(piles[idx:idx+x])\n          (nextA, nextL) = recurse(idx+x, max(m, x), not alexTurn)\n          # nextA = nxt[0]\n          # nextL = nxt[1]\n          if alexTurn:\n            ops.append((nextA+curNumStones, nextL))\n          else:\n            ops.append((nextA, nextL+curNumStones))\n        [aScores, lScores] = list(zip(*ops)) \n        # aScores = [x[0] for x in ops]\n        # lScores = [x[1] for x in ops]\n        if alexTurn:\n          return (max(aScores), max(lScores))\n        else:\n          return (min(aScores), max(lScores))\n      return recurse(0, 1, True)[0]\n    \n    \\\"\\\"\\\"\n    recurse(0, 1, True) -> \n      2 + recurse(1, 1, False) \n        recurse(1, 1, False) -> \n          9 + recurse(2, 1, True) \n          9 + 4 + recurse(3, 2, True)\n      9 + recurse(2, 2, False)\n          \n    \\\"\\\"\\\"", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        self.arr = piles\n        self.dp = {}\n        ans = self.helper(0,1,1)\n        print(self.dp)\n        return ans\n        \n    def helper(self, i, m, turn):\n        if(i >= len(self.arr)):\n            return 0\n        \n        if((i,m,turn) in self.dp):\n            return self.dp[(i,m,turn)]\n        \n        if(turn):\n            ans = []\n            for x in range(2*m):\n                tmp = sum(self.arr[i:i+x+1]) + self.helper(i+x+1, max(x+1,m), 0)\n                ans.append(tmp)\n            self.dp[(i,m,turn)] = max(ans)\n            return self.dp[(i,m,turn)]\n        \n        else:\n            ans = []\n            for x in range(2*m):\n                tmp = self.helper(i+x+1, max(x+1,m), 1)\n                ans.append(tmp)\n            self.dp[(i,m,turn)] = min(ans)\n            return self.dp[(i,m,turn)]", "class Solution:\n    # opt[M][i] = max(sum(pile[i:i+m]) + sum[piles[i:]] - opt[max(m,M)][i+m]) for all m 1->2M\n    def stoneGameII(self, piles: List[int]) -> int:\n        if len(piles) == 1:\n            return piles[0]\n        pileCount = len(piles)\n        scores = [[0 for y in range(0, len(piles))] for x in range(0,len(piles))]\n        # print(scores)\n        for i in range(len(scores)-1, -1, -1):\n            for M in range(1, len(scores[i])):\n                # print(\\\"indexes: \\\" + str(i) + \\\" , \\\" + str(M))\n                if i + 2*M >= pileCount:\n                    scores[i][M] = sum(piles[i:])\n                else:\n                    m_options = [sum(piles[i:i+m]) + sum(piles[i+m:]) - scores[0 if i+m > pileCount else i+m][max(m, M)] for m in range(1, 2*M + 1)]\n                    # if i == 2 and M == 1:\n                    #     print(sum(piles[i:i+1]))\n                    #     print(sum(piles[i+1:]))\n                    #     print(scores[0 if i+1 > pileCount else i+1][max(1, M)])\n                    \n                    # print(m_options)\n                    scores[i][M] = max(m_options)\n                # print(\\\"score grid: \\\")\n                # for row in scores:\n                #     print(row)\n        return scores[0][1]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        presum=list(piles)\n        for i in range(1,len(piles)):\n            presum[i]+=presum[i-1]\n          \n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(ind,m):\n            if ind+2*m>=len(piles): return presum[-1]-(presum[ind-1] if ind>0 else 0)\n            sm=float('-inf')\n            for i in range(1,2*m+1):\n                me = presum[ind+i-1]-(presum[ind-1] if ind>0 else 0)\n                sm = max(sm, me + presum[-1]-presum[ind+i-1] - dp(ind+i,max(m,i)))\n            return sm\n        \n        return dp(0,1)", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n      N = len(piles)\n      @lru_cache(maxsize=None)\n      def recurse(idx, m, alexTurn):\n        # print(f\\\"RECURSE {idx} {m} {alexTurn}\\\")\n        if idx > N-1:\n          return (0, 0)\n        ops = []\n        for x in range(1, 2*m+1):\n          curNumStones = sum(piles[idx:idx+x])\n          (nextA, nextL) = recurse(idx+x, max(m, x), not alexTurn)\n          # nextA = nxt[0]\n          # nextL = nxt[1]\n          if alexTurn:\n            ops.append((nextA+curNumStones, nextL))\n          else:\n            ops.append((nextA, nextL+curNumStones))\n        aScores = [x[0] for x in ops]\n        lScores = [x[1] for x in ops]\n        if alexTurn:\n          return (max(aScores), max(lScores))\n        else:\n          return (min(aScores), max(lScores))\n      return recurse(0, 1, True)[0]\n    \n    \\\"\\\"\\\"\n    recurse(0, 1, True) -> \n      2 + recurse(1, 1, False) \n        recurse(1, 1, False) -> \n          9 + recurse(2, 1, True) \n          9 + 4 + recurse(3, 2, True)\n      9 + recurse(2, 2, False)\n          \n    \\\"\\\"\\\"", "#1 DP (Top-down with memoization)\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        if len(piles) <= 2:\n            return sum(piles)\n        n = len(piles)\n        # Compute suffix sum\n        for i in range(n - 2, -1, -1):\n            piles[i] += piles[i + 1]\n        piles.append(0)\n        \n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for pile in reversed(range(n)):\n            for M in reversed(range(n)):\n                nextPlayerMaximum = piles[pile]\n                for nextPile in range(pile + 1, min(pile + 2 * M + 1, n + 1)):\n                    nextPlayerMaximum = min(nextPlayerMaximum, dp[nextPile][max(M, nextPile - pile)])\n                dp[pile][M] = piles[pile] - nextPlayerMaximum\n        \n        return dp[0][1]", "# So the basic idea here is that there is no reason to have separate sum_alex and sum_lee variables, because they both sum up to suffix_sum[pile]\n# Here is an example (X - we haven't desided yet, A - taken by Alex, L - taken by Lee)\n\n# XXXXXXXXXXAALAAALLLAALA\n#           ^\n# \\t\\t  pile\n# From this you can see that in order to calculate the number of piles taken by this player so far we just substract the number of the piles taken by another player from the total number of piles up to the current pile position.\n# The next important thing to notice is that minimizing sum for the one player leads to maximising it for another and vice versa.\n# This leads us to conclusion that we can do the same with just a single variable sum_next_player.\n# The alrorightm now looks the following way:\n\n# We're trying to pick up to 2 * M piles from the current position and pass the turn to the next player\n# We're getting back from the next player the maximum sum they were able to get and trying to minimize it\n# Now when we found the minimum sum for the other player that also means we found the maximum sum for us, so return it\n# That's how we got to the nice and short Top-Down DP solution.\n# The only thing left - convert it to Bottom-Up solution to make the interviewer happy. And here is it\n\nclass Solution:\n    @staticmethod\n    def _suffix_sum(piles: List[int]) -> List[int]:\n        suffix_sum = [0]\n\n        for pile in reversed(piles):\n            suffix_sum.append(suffix_sum[-1] + pile)\n\n        suffix_sum.reverse()\n\n        return suffix_sum\n    \n    def stoneGameII(self, piles: List[int]) -> int:\n        suffix_sum = self._suffix_sum(piles)\n\n        dp = [[0] * (len(piles) + 1) for _ in range(len(piles) + 1)]\n\n        for pile in reversed(range(len(piles))):\n            for M in reversed(range(len(piles))):\n                sum_next_player = suffix_sum[pile]\n\n                for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\n                    sum_next_player = min(\n                        sum_next_player, dp[next_pile][max(M, next_pile - pile)]\n                    )\n\n                sum_player = suffix_sum[pile] - sum_next_player\n\n                dp[pile][M] = sum_player\n\n        return dp[0][1]", "#1 DP (Top-down with memoization)\n#2 DP (Bottom-up)\n\n# Is better to work recurrence relation from back to start, dfs(i, M) = suffix_sum[i] - max(dfs(i + j, max(M, j)) for i in range(1, min(2M + 1, remaining length of piles)))\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        if len(piles) <= 2:\n            return sum(piles)\n        n = len(piles)\n        # Compute suffix sum\n        for i in range(n - 2, -1, -1):\n            piles[i] += piles[i + 1]\n        piles.append(0)\n        \n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for pile in reversed(range(n)):\n            for M in reversed(range(n)):\n                nextPlayerMaximum = piles[pile]\n                for nextPile in range(pile + 1, min(pile + 2 * M + 1, n + 1)):\n                    nextPlayerMaximum = min(nextPlayerMaximum, dp[nextPile][max(M, nextPile - pile)])\n                dp[pile][M] = piles[pile] - nextPlayerMaximum\n        \n        return dp[0][1]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        M = (len(piles)+1)//2\n        record = [[0 for _ in range(len(piles))] for _ in range(M)]\n        total = [0 for _ in range(len(piles))]\n        for i in range(M):\n            record[i][-1] = piles[-1] \n        total[-1] = piles[-1]\n        \n        for i in range(len(piles)-2, -1, -1):\n            total[i] = total[i+1] + piles[i]\n        \n        for i in range(len(piles)-2, -1, -1):\n            for j in range(M):\n                   min_num = float(inf)\n                   for k in range(2*(j+1)):\n                       if i+k+1 >= len(piles):\n                          if min_num > 0:\n                                min_num = 0\n                       else:\n                           if record[min(max(j, k), M-1)][i+k+1] < min_num:\n                               min_num = record[min(max(j, k), M-1)][i+k+1]\n                    \n                   record[j][i] = total[i] - min_num\n        print(record)\n        return record[0][0]", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        self.dp = {}\n        \n        def recursiveStoneGame(start, M):            \n            if start >= N:\n                return 0\n            \n            if start == N-1:\n                return piles[start]\n            \n            if (start, M) in self.dp:\n                return self.dp[(start, M)]\n\n            alex = 0\n            for x in range(1, 2*M+1):\n                opponent_score = recursiveStoneGame(start+x, max(x, M))\n                this_score = sum(piles[start:]) - opponent_score\n                \n                alex = max(alex, this_score)\n                \n            self.dp[(start, M)] = alex\n                \n            return alex\n        \n        \n        result = recursiveStoneGame(0, 1)\n        return result", "class Solution:\n    def solve(self, start, end, M, player):\n        if (start,end,M,player) in self.dp:\n            return self.dp[start,end,M,player]\n        maxa = 0\n        maxl = 0\n        if start > end:\n            return [0,0]\n        \n        for i in range(1,  2*M+1):\n            picked = sum(self.piles[start:start+i])\n            if player == 0:\n                a,l = self.solve(start+i, end, max(i,M), 1)\n                if picked + a > maxa:\n                    maxa = picked + a\n                    maxl = l\n            else:\n                a,l = self.solve(start+i, end, max(i,M), 0)\n                if picked + l > maxl:\n                    maxa = a\n                    maxl = picked + l\n                \n        self.dp[(start,end,M,player)] = (maxa, maxl)\n        return (maxa, maxl)\n    \n    def stoneGameII(self, piles: List[int]) -> int:\n        self.dp = {}\n        self.piles = piles\n        \n        ans = self.solve(0, len(piles)-1, 1, 0)\n        print(self.dp)\n        return ans[0]", "class Solution:\n    def helper(self, n, M, curr, piles, memo):\n        if curr >= n:\n            return 0\n        \n        if n - curr <= 2*M:\n            return sum(piles[curr:])\n        \n        if (curr, M) in memo:\n            return memo[(curr, M)]\n        \n        me = 0\n        total = sum(piles[curr:])\n        \n        for X in range(1, 2*M + 1):\n            opponent = self.helper(n, max(X, M), curr + X, piles, memo)\n            \n            me = max(me, total - opponent)\n            \n        memo[(curr, M)] = me\n        \n        return me\n    def stoneGameII(self, piles: List[int]) -> int:\n        return self.helper(len(piles), 1, 0, piles, {})", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n\n        memo = {}\n        def dft(i, m, p):\n            if i >= n: return [0, 0]\n            if (i, m, p) in memo:\n                return list(memo[(i, m, p)])\n            score = [0, 0]\n            for x in range(1, 2 * m + 1):\n                s = sum(piles[i:i+x])\n                forward = dft(i + x, max(m, x), (p + 1) % 2)\n                forward[p] += s\n                if forward[p] > score[p]:\n                    score = forward\n            memo[(i, m, p)] = list(score)\n            return score\n\n        return dft(0, 1, 0)[0]\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        self.piles = piles\n        self.memo = {} # map of (start, M, is_player_1) to int\n        return self.minimax(0, 1, True)\n    \n    def minimax(self, start: int, M: int, is_player_1: bool) -> int:\n        if start >= len(self.piles):\n            return 0\n        if (start, M, is_player_1) in self.memo:\n            return self.memo[(start, M, is_player_1)]\n        if is_player_1:\n            output = max([\n                sum(self.piles[start:start + x]) + self.minimax(start + x, max(x, M), False) \n                for x in range(1, min(2 * M, len(self.piles)) + 1)\n            ])\n        else:\n            output = min([\n                self.minimax(start + x, max(x, M), True) \n                for x in range(1, min(2 * M, len(self.piles)) + 1)\n            ])\n        self.memo[(start, M, is_player_1)] = output\n        return output", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        suffix_sum = [0] * N\n        \n        running_sum = 0\n        for idx in range(N-1, -1, -1):\n            running_sum += piles[idx]\n            suffix_sum[idx] = running_sum\n            \n        DP = [[0]*(N+1) for _ in range(N+1)]\n        \n        for pile_no in reversed(list(range(N))):\n            for M in reversed(list(range(N))):\n                min_next_player = suffix_sum[pile_no]\n                for x in range(1, min(2*M + 1, N+1)):\n                    if pile_no + x < N:\n                        min_next_player = min(min_next_player, DP[pile_no + x][max(x,M)])\n                    else:\n                        min_next_player = 0\n                DP[pile_no][M] = suffix_sum[pile_no] - min_next_player\n            \n        return DP[0][1]\n        \n#         # @lru_cache(None)\n#         def dfs(pile_no, M):\n#             if pile_no > N-1:\n#                 return 0\n#             if DP[pile_no][M] > 0:\n#                 return DP[pile_no][M]\n#             min_next_player = suffix_sum[pile_no]\n#             for x in range(1, min(2*M + 1, N+1)):\n#                 min_next_player = min(min_next_player, dfs(pile_no + x, max(x,M)))\n                \n#             DP[pile_no][M] = suffix_sum[pile_no] - min_next_player\n#             return DP[pile_no][M]\n            \n#         return dfs(0, 1)\n        \n            \n        \n        \n        \n        \n            \n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        INF = float(\\\"inf\\\")\n        \n        dp = [[0]*(N+1) for _ in range(N+1)]\n        isComputed = [[False]*(N+1) for _ in range(N+1)]\n        \n        def getMaxScore(index, M):\n            if index == N:\n                return 0\n            if isComputed[index][M]:\n                return dp[index][M]\n            \n            bestScore = -INF\n            \n            for X in range(1, 2*M + 1):\n                stones = sum(piles[index:index+X])\n                score = stones - getMaxScore(min(index+X,N), min(max(M,X),N))\n                \n                bestScore = max(bestScore,score)\n                \n                \n            isComputed[index][M] = True\n            dp[index][M] = bestScore\n            \n            return bestScore\n        \n        # total = my score + opponent score\n        # delta = my score - opponent score\n        total = sum(piles)\n        delta = getMaxScore(0,1)\n        return (total + delta)//2\n        ", "from functools import lru_cache\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \n        def alex(idx, M, score_alex, score_lee):\n            #print('alex', idx, M, score_alex, score_lee)\n            if idx == len(piles):\n                return score_alex, score_lee\n            if idx == len(piles)-1:\n                return score_alex + piles[idx], score_lee\n            maxa, countl = score_alex, score_lee\n            for i in range(1, 2*M+1):\n                if idx+i <= len(piles):\n                    sa, sl = lee(idx+i, i, score_alex + sum(piles[idx:idx+i]), score_lee)\n                    if maxa < sa:\n                        maxa = sa\n                        countl = sl\n                else:\n                    break\n            #print('--------> alex', idx, M, maxa, countl)\n            return maxa, countl \n            \n        \n        def lee(idx, M, score_alex, score_lee):\n            #print('lee', idx, M, score_alex, score_lee)\n            if idx == len(piles):\n                return score_alex, score_lee\n            if idx == len(piles)-1:\n                return score_alex, score_lee + piles[idx]\n            counta, maxl = score_alex, score_lee\n            for i in range(1, 2*M+1):\n                if idx+i <= len(piles):\n                    sa, sl = alex(idx+i, i, score_alex, score_lee + sum(piles[idx:idx+i]))\n                    if maxl < sl:\n                        maxl = sl\n                        counta = sa\n                else:\n                    break\n            #print('--------> lee', idx, M, maxl, counta)\n            return counta, maxl\n        \n        #self.memo = dict()\n        #return alex(0, 1, 0, 0)[0]\n        \n        @lru_cache(None)\n        def minimax(i, m, player):\n            if i >= len(piles): return 0\n            if player == 0:\n                return max(sum(piles[i:i+j]) + minimax(i+j, max(m,j), player^1) for j in range(1, 2*m+1))\n            else:\n                return min(minimax(i+j, max(m,j), player^1) for j in range(1, 2*m+1))\n        return minimax(0, 1, 0)   ", "from collections import defaultdict\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N=len(piles)\n\n        dp=defaultdict(dict)\n        M=1\n        return self.DP(N,dp,piles,M,0)\n\n        \n    def DP(self,n,dp,piles,M,start):\n        if n<=2*M:\n            return sum(piles[start:])\n        if n in dp and M in dp[n]:\n            return dp[n][M]\n        \n        res=float('-inf')\n        \n        for x in range(1,2*M+1):\n            newM=max(x,M)\n            if n-x<=2*newM:\n                res2=0\n            else:\n                res2=float('inf')\n                for y in range(1,2*newM+1):\n                    newM2=max(y,newM)\n                    res2=min(res2,self.DP(n-x-y,dp,piles,newM2,start+x+y)) \n\n            res=max(res, res2 + sum(piles[start:start+x]) )\n             \n        dp[n][M]=res \n                        \n        return res\n            \n                \n            \n            \n        \n        \n        \n        \n\n", "class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N = len(piles)\n        suffix_sum = [0] * N\n        \n        running_sum = 0\n        for idx in range(N-1, -1, -1):\n            running_sum += piles[idx]\n            suffix_sum[idx] = running_sum\n            \n        DP = [[0]*(N) for _ in range(N)]\n        \n        for pile_no in reversed(list(range(N))):\n            for M in reversed(list(range(N))):\n                min_next_player = suffix_sum[pile_no]\n                for x in range(1, min(2*M + 1, N+1)):\n                    if pile_no + x < N:\n                        min_next_player = min(min_next_player, DP[pile_no + x][max(x,M)])\n                    else:\n                        min_next_player = 0\n                DP[pile_no][M] = suffix_sum[pile_no] - min_next_player\n            \n        return DP[0][1]\n        \n#         # @lru_cache(None)\n#         def dfs(pile_no, M):\n#             if pile_no > N-1:\n#                 return 0\n#             if DP[pile_no][M] > 0:\n#                 return DP[pile_no][M]\n#             min_next_player = suffix_sum[pile_no]\n#             for x in range(1, min(2*M + 1, N+1)):\n#                 min_next_player = min(min_next_player, dfs(pile_no + x, max(x,M)))\n                \n#             DP[pile_no][M] = suffix_sum[pile_no] - min_next_player\n#             return DP[pile_no][M]\n            \n#         return dfs(0, 1)\n        \n            \n        \n        \n        \n        \n            \n", "from collections import defaultdict\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        N=len(piles)\n        # dp=[[-1 for _ in range(N)] for _ in range(2)]\n        dp=defaultdict(int)\n        M=1\n        return self.DP(N,dp,piles,M,0)\n\n        \n    def DP(self,n,dp,piles,M,start):\n        if n<=2*M:\n            return sum(piles[start:])\n        if (n,M) in dp:\n            return dp[(n,M)]\n        \n        res=float('-inf')\n        \n        for x in range(1,2*M+1):\n            newM=max(x,M)\n            if n-x<=2*newM:\n                res2=0\n            else:\n                res2=float('inf')\n                for y in range(1,2*newM+1):\n                    newM2=max(y,newM)\n                    res2=min(res2,self.DP(n-x-y,dp,piles,newM2,start+x+y)) \n\n            res=max(res, res2 + sum(piles[start:start+x]) )\n\n                \n        dp[(n,M)]=res \n                        \n        return dp[(n,M)]\n            \n                \n            \n            \n        \n        \n        \n        \n\n", "import numpy\n\n# bruteforce\ndef gobf(piles, i, m, alex):\n    res = 0 if alex == 1 else float(\\\"inf\\\")\n    if i == len(piles):\n        return 0\n        \n    for x in range(1, 2 * m + 1):\n        if i + x > len(piles):\n            break\n        if alex == 1:\n            res = max(res, sum(piles[i:i+x]) + gobf(piles, i+x, max(x,m), 0))\n        else:\n            res = min(res, gobf(piles, i+x, max(x,m), 1))\n    return res\n\n\n# memo\ndef go(piles, i, m, alex, memo):\n    if i == len(piles):\n        return 0\n    if memo[i][m][alex] != -1:\n        return memo[i][m][alex]\n        \n    res = 0 if alex == 1 else float(\\\"inf\\\")\n    for x in range(1, 2 * m + 1):\n        if i + x > len(piles):\n            break\n        if alex == 1:\n            res = max(res, sum(piles[i:i+x]) + go(piles, i+x, max(x,m), 0, memo))\n        else:\n            res = min(res, go(piles, i+x, max(x,m), 1, memo))\n    memo[i][m][alex] = res\n    return memo[i][m][alex]\n\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        memo = numpy.ndarray((n, n + 1, 2), int)\n        memo.fill(-1)\n        return go(piles, 0, 1, 1, memo)", "\\\"\\\"\\\"\ndp[i][j] = the max score one can get with [i:] piles and M = j.\ndp[i][j] = max(sum[i:x] for x in range(1, min(2*M, n) - dp[i+x][max(M, x)])\ndp[i][n] = sum(piles[i:])\n\\\"\\\"\\\"\nclass Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n = len(piles)\n        suf_sum = [0 for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            suf_sum[i] = suf_sum[i+1] + piles[i]\n            \n        dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][n] = suf_sum[i]\n        \n        for i in range(n, -1, -1):\n            for j in range(n, 0, -1):\n                for x in range(1, min(2*j, n - i) + 1):\n                    dp[i][j] = max(dp[i][j], suf_sum[i] - dp[i+x][max(j, x)])\n        return dp[0][1]"]
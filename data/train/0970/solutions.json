["def posSearch(arr, num):\n l = 0\n r = len(arr)\n if num < arr[l]:\n  return 0\n elif num > arr[r-1]:\n  return r\n while l < r:\n  m = (l+r)//2\n  if arr[m] == num:\n   return -1\n  if arr[m] < num < arr[m+1]:\n   return m+1\n  if arr[m] > num:\n   r = m\n  elif arr[m] < num:\n   l = m+1 \n \nfor _ in range(int(input())):\n n = int(input())\n narr = list(map(int, input().split()))\n q = int(input())\n for i in range(q):\n  x, y = list(map(int, input().split()))\n  a = x+y\n  j = posSearch(narr, a)\n  print(j)\n   \n", "\ndef binary(arr,s):\n low=0 \n high=n-1\n while low<=high:\n  mid=(high+low)//2 \n  if arr[mid]<=s:\n   ans=mid \n   low=mid +1\n  else:\n   high=mid-1 \n return ans \n\n\n\nfor _ in range(int(input())):\n n=int(input())\n arr=list(map(int,input().split()))\n q=int(input())\n arr.sort()\n for i in range(q):\n  x,y=list(map(int,input().split()))\n  s=x+y \n  if arr[0]>s:\n   print(0)\n   continue \n  if arr[0]==s:\n   print(-1)\n   continue \n  index=binary(arr,s)\n  if arr[index]==s:\n   print(-1 )\n  else:\n   print(index+1 )\n   \n   # TODO: write code...\n", "# cook your dish here\nimport bisect\ntest=int(input())\nfor _ in range(test):\n n=int(input())\n ls=list(map(int,input().split()))\n ls.sort()\n q=int(input())\n for _ in range(q):\n  x,y=map(int,input().split())\n  z=x+y\n  m=bisect.bisect(ls,z)\n  if m>0:\n   if ls[m-1]==z:\n    print(-1)\n   else:\n    print(m)\n  else:\n   print(0)", "# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n l=list(map(int,input().split()))\n q=int(input())\n h=[]\n for i in range(q):\n  x,y=list(map(int,input().split()))\n  f,c,g=x+y,0,0\n  b,m=0,n-1\n  while(b<=m):\n   i=(b+m)//2\n   if l[i]==f:\n    g=1\n    break\n   elif l[i]>f:\n    m=i-1\n   else:\n    b=i+1\n  if g==1:\n   print(-1)\n  else:\n   if l[i]>f:\n    print(i)\n   else:\n    print(i+1)\n     \n  \n\n", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n\ndef cinN():return (int(stdin.readline()))\ndef cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n n=cinN()\n l=list(cin())\n #l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n\ndef cinN():return (int(stdin.readline()))\ndef cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n n=cinN()\n l=list(cin())\n #l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n\ndef cinN():return (int(stdin.readline()))\ndef cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n#cin=sys.stdin.readline\n#cout=sys.stdout.write\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n#cin=sys.stdin.readline\ncout=sys.stdout.write\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n st=''\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n#cin=sys.stdin.readline\ncout=sys.stdout.write\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n st=''\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans) \n #cout(str(ans))\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n#cin=sys.stdin.readline\ncout=sys.stdout.write\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n st=''\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "import sys\nfrom sys import stdin,stdout\nfrom bisect import bisect_right\nfrom os import path\n#cin=sys.stdin.readline\ncout=sys.stdout.write\n\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def cinN():return (int(input()))\n def cin():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def cinN():return (int(stdin.readline()))\n def cin():return(map(int,stdin.readline().split()))\n\n\n\ndef find_le(a, x):\n 'Find rightmost value less than or equal to x'\n i = bisect_right(a, x)\n if i:\n  return i-1\n return -1\n\ndef func():\n st=''\n n=cinN()\n l=list(cin())\n l.sort()\n qn=cinN()\n for _ in range(qn):\n  x,y=cin()\n  k=x+y\n  t=find_le(l,k)\n  if t==-1:\n   ans=(0)\n  else:\n   if l[t]==k:\n    ans=(-1)\n   else:ans=(t+1)\n  print(ans)\n  #st='\\n'.join((st,str(ans)))\n #print(st)\n #cout('\\n')\ndef __starting_point():\n test=cinN()\n for _ in range(test):func()\n__starting_point()", "\nfrom collections import defaultdict\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef binarySearchCount(arr, n, key): \n \n left = 0\n right = n - 1\n \n count = 0\n \n while (left <= right):  \n  mid = int((right + left) / 2) \n \n  # Check if middle element is \n  # less than or equal to key \n  if (arr[mid] <= key):  \n \n   # At least (mid + 1) elements are there \n   # whose values are less than \n   # or equal to key \n   count = mid + 1\n   left = mid + 1\n   \n  # If key is smaller, ignore right half \n  else: \n   right = mid - 1\n  \n return count \ndef can_break(N,a,d,x,y,maxi,mini):\n c=x+y\n if c<mini:\n  return 0\n if c in d:\n  return -1\n \n if c>maxi:\n  return N \n \n x=binarySearchCount(a,N,c)\n return x\n \"\"\"\n    mid=(N-1)//2\n    if c<a[mid]:\n     count=0\n     for i in a:\n      if i>c:\n       return count\n      count+=1\n  \n    else:\n     count=mid+1\n     for i in range(mid+1,N):\n      if a[i]>c:\n       return count\n      count+=1\n    \"\"\" \n\nT=int(input())\nwhile T:\n N=int(input())\n a=tuple(map(int,input().split()))\n d=defaultdict()\n mini=a[0]\n maxi=a[-1]\n for i in range(N):\n  d[a[i]]=i\n Q=int(input())\n while Q:\n  x,y=list(map(int,input().split()))\n  if x==0 and y==0:\n   print(0)\n  else:\n   print(can_break(N,a,d,x,y,maxi,mini))\n  Q-=1\n T-=1 \n", "import bisect\n\nfor i in range(int(input())):\n n = int(input())\n a = [int(x) for x in input().split()]\n a.sort()\n for j in range(int(input())):\n  x, y = map(int, input().split())\n  z = x + y\n  nu = bisect.bisect(a, z)\n  if nu > 0:\n\n   if a[nu - 1] == z:\n    print(-1)\n   else:\n    print(nu)\n  else:\n   print(0)", "from bisect import bisect\nfor _ in range(int(input())):\n n=int(input())\n l=list(map(int,input().split()))\n c=[]\n for _ in range(int(input())):\n  x,y=map(int,input().split())\n  s=x+y\n  st=0\n  end=n-1\n  t=True\n  while(st<=end):\n   half=(end+st)//2\n   if (l[half]==s):\n    t=False\n    break\n   elif(l[half]>s):\n    end=half-1\n   else:\n    st=half+1\n  print(bisect(l,s) if t else -1)"]
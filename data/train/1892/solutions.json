["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         ans = []\n         buffer = []\n         self.helper(ans, root, sum, buffer)\n         return ans\n     def helper(self, ans, root, sum, buffer):\n         \"\"\"\n         recursive method travesal to the bottom of the tree\n         and add the path that path's sum equals the given sum into the result\n         \n         :type ans: List[List[int]]\n         :type root: TreeNode\n         :type sum: int\n         :type buffer: List[int]\n         :rtype None\n         \"\"\"\n         if not root: return\n         sum -= root.val\n         buffer.append(root.val)\n         if not (root.left or root.right) and sum == 0: ans.append([x for x in buffer])\n         self.helper(ans, root.left, sum, buffer)\n         self.helper(ans, root.right, sum, buffer)\n         buffer.pop()", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         return self.preorder(root, sum, [], [])\n     \n     def preorder(self, root, sum, path, list):\n         \n         if not root:\n             return []\n         \n         path = path[:]\n         path.append(root.val)\n     \n         if not root.left and not root.right and root.val == sum:\n             list.append(path)\n             \n         if root.left or root.right:\n             sum -= root.val\n                 \n         if root.left:\n             list = self.preorder(root.left, sum, path, list)\n \n         if root.right:\n             list = self.preorder(root.right, sum, path, list)\n             \n \n         return list", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n \n         def _helper(node, path, tmp_sum):\n             if not node:\n                 return\n             tmp_sum += node.val\n             path.append(node.val)\n             if tmp_sum == sum and not node.left and not node.right:\n                 res.append(path.copy())\n             if node.left:\n                 _helper(node.left, path, tmp_sum)\n             if node.right:\n                 _helper(node.right, path, tmp_sum)\n             path.pop()\n             tmp_sum -= node.val\n \n         _helper(root, [], 0)\n         return res", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import copy\n class Solution:\n     def dfs(self, root, sum, cur_path, cur_sum, path):\n         if root.left == None and root.right == None:\n             if cur_sum + root.val == sum:\n                 cur_path.append(root.val)\n                 path.append(copy.deepcopy(cur_path))\n                 cur_path.pop()\n         if root.left != None:\n             cur_path.append(root.val)\n             self.dfs(root.left, sum, cur_path, cur_sum + root.val, path)\n             cur_path.pop()\n         if root.right != None:\n             cur_path.append(root.val)\n             self.dfs(root.right, sum, cur_path, cur_sum + root.val, path)\n             cur_path.pop() \n     \n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if root == None:\n             return []\n         path = []\n         self.dfs(root, sum, [], 0, path)\n         return path\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         res = []\n         q = collections.deque([(root, root.val, [root.val])])\n         while q:\n             r, v, ls = q.popleft()\n             if not r.left and not r.right and v == sum:\n                 res.append(ls)\n             if r.left:\n                 q.append((r.left, v+r.left.val, ls+[r.left.val]))\n             if r.right:\n                 q.append((r.right, v+r.right.val, ls+[r.right.val]))\n         return res", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         result = []\n         def helper(root,target,sum,cur_result):\n             if not root:\n                 return\n             target-=root.val\n             cur_result.append(root.val)\n             if target == 0 and not root.left and not root.right:\n                 result.append([i for i in cur_result])\n             helper(root.left,target,sum,cur_result)    \n             helper(root.right,target,sum,cur_result)    \n             cur_result.pop()\n         helper(root,sum,0,[])    \n         return result ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         if not (root.left or root.right) and root.val == sum:\n             return [[root.val]]\n         return [[root.val]+ans for ans in self.pathSum(root.left,sum-root.val)+self.pathSum(root.right,sum-root.val)]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         _, res = self.recPathSum(root, sum)\n         return res\n     \n     def recPathSum(self, root, sum):\n         if not root:\n             return (False, [])\n         if root.val == sum:\n             if not root.left and not root.right:\n                 return (True, [[root.val]])\n         foundLeft, listLeft = self.recPathSum(root.left, sum - root.val)\n         foundRight, listRight = self.recPathSum(root.right, sum - root.val)\n         res = []\n         if foundLeft:\n             res = [[root.val] + l for l in listLeft]\n         if foundRight:\n             res += [[root.val] + l for l in listRight]\n         return (foundLeft or foundRight, res)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         self.ret=[]\n         self.DFS(root,sum,[])\n         return(self.ret)\n     def DFS(self,roots,nums,valList):\n         if(roots==None):\n             return()\n         if(roots.left==None and roots.right==None and nums==roots.val):\n             self.ret.append(valList+[roots.val])\n         self.DFS(roots.left,nums-roots.val,valList+[roots.val])\n         self.DFS(roots.right,nums-roots.val,valList+[roots.val])\n         \n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sums):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         self.ret = []\n         def dfs(root, s, path):\n             if root.left is None and root.right is None:\n                 if s == sums:\n                     self.ret.append(path)\n                 return\n             if root.left:\n                 dfs(root.left, s+root.left.val, path + [root.left.val])\n             if root.right:\n                 dfs(root.right, s+root.right.val, path + [root.right.val])\n         if not root:return []\n         dfs(root, root.val, [root.val])\n         return self.ret\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         curr_path = []\n         if root == None:\n             return curr_path\n         else:\n             return self.pathSumHelper(root, sum, curr_path)\n         \n     def pathSumHelper(self, root, sum, curr_path):\n         new_path = curr_path + [root.val]\n         if root.left is None and root.right is None:\n             return [new_path] if sum == root.val else []\n         elif root.left is None:\n             return self.pathSumHelper(root.right, sum - root.val, new_path)\n         elif root.right is None:\n             return self.pathSumHelper(root.left, sum - root.val, new_path)\n         else:\n             return self.pathSumHelper(root.right, sum - root.val, new_path) + self.pathSumHelper(root.left, sum - root.val, new_path)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n stack1 = []\n stack2 = []\n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         def dfs(root, currsum, valuelist):\n             if root.left==None and root.right==None:\n                 if currsum==sum: res.append(valuelist)\n             if root.left:\n                 dfs(root.left, currsum+root.left.val, valuelist+[root.left.val])\n             if root.right:\n                 dfs(root.right, currsum+root.right.val, valuelist+[root.right.val])\n         \n         res=[]\n         if root==None: return []\n         dfs(root, root.val, [root.val])\n         return res", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         \"\"\"\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         \n         res = []\n         \n         stack = [ (root, root.val, [root.val]) ]\n         \n         while stack:\n             curr, currsum, currp = stack.pop()\n             if not curr.left and not curr.right:\n                 if currsum == sum:\n                     res.append( currp )\n             for child in [curr.left, curr.right]:\n                 if child:\n                     stack.append( (child, currsum + child.val, currp + [child.val]) )\n         \n         return res\n         "]
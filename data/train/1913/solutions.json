["class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        if n == 1: return A\n        \n        tidx = -1\n        for i in range(n-2, -1, -1):\n            if A[i] > A[i+1]:\n                tidx = i\n                break\n        \n        if tidx < 0: return A\n        \n        sidx = -1\n        for j in range(n-1, tidx, -1):\n            if A[j] == A[j-1]: continue\n            if A[j] < A[tidx]: \n                sidx = j\n                break\n        \n        A[tidx], A[sidx] = A[sidx], A[tidx]\n        \n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-2, -1, -1):\n            if A[i]>A[i+1]:\n                break\n        else:\n            return A\n        stack = []\n        for j in range(i+1, len(A)):\n            if A[j]<A[i]:\n                while stack and A[stack[-1]]<A[j]:\n                    stack.pop()\n                stack.append(j)\n        A[i], A[stack[0]] = A[stack[0]], A[i]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if len(A) == 1:\n            return A\n\n        for i in range(len(A) - 1, 0, -1):\n            if A[i - 1] > A[i]:\n                m, mi = A[i], i\n                for j in range(i, len(A)):\n                    if A[j] < A[i - 1] and A[j] > m:\n                        mi = j\n                        m = A[j]\n                A[i - 1], A[mi] = A[mi], A[i - 1]\n                break\n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        for i in range(n - 2, -1, -1):\n            if A[i] > A[i + 1]:\n                pm = None\n                for j in range(n - 1, i, -1):\n                    if A[j] >= A[i]:\n                        continue\n                    if pm is None:\n                        pm = j\n                    elif A[j] == A[pm]:\n                        pm = j\n                    else:\n                        break\n                A[i], A[pm] = A[pm], A[i]\n                return A\n        return A\n", "class Solution:\n    \n        \n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-2,-1,-1):\n            curr=-float(\\\"inf\\\")\n            k=-1\n            for j in range(i+1,len(A)):\n                if A[j]>curr and A[j]<A[i]:\n                    curr=A[j]\n                    # print(curr,A[i],i,j)\n                    k=j\n            if curr!=-float(\\\"inf\\\"):\n                # print(\\\"yo\\\")\n                # print(k,j)\n                A[i],A[k]=A[k],A[i]\n                return A\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        max_index = -1\n        for i in range(1, len(A)):\n            if A[i - 1] > A[i]:\n                max_index = max(max_index, i - 1)\n        if max_index != -1:\n            for i in range(max_index + 1, len(A)):\n                if A[i] < A[max_index]:\n                    j = i\n            A[j], A[max_index] = A[max_index], A[j]\n        return A\n            \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        \n        l = -1\n        \n        for i in reversed(range(len(A)-1)):\n            if A[i] > A[i+1]:\n                l = i\n                break\n                \n        if l >= 0:\n            r = l+1\n            s = A[r]\n            for i in range(l+2,len(A)):\n                if A[i] < A[l] and A[i] >= s:\n                    r = i\n                    \n            A[l],A[r] = A[r],A[l]\n            \n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        already_sorted = True\n        swap_left = None\n        for i in range(len(A)-1,0,-1):\n            if A[i]<A[i-1]:\n                swap_left = (i-1,A[i-1])\n                already_sorted = False\n                break\n        if already_sorted: return A\n        swap_right = None\n        for i in range(swap_left[0]+1,len(A)):\n            if A[i] < swap_left[1]:\n                if swap_right and A[i]<=swap_right[1]:\n                    continue\n                else:\n                    swap_right = (i, A[i])\n        A[swap_right[0]],A[swap_left[0]] = swap_left[1], swap_right[1]\n        return A\n        \n                    \n        \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if sorted(A) == A: return A\n        \n        n = len(A)\n        s = A[:]\n        for i in range(n-2, -1, -1):\n            s[i] = min(s[i], s[i+1])\n            if A[i] > s[i+1]:\n                j = n-1\n                while A[j] >= A[i]: j -= 1\n                A[i], A[j] = A[j], A[i]\n                return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if len(A) == 1:\n            return A\n        \n        prev = A[0]\n        swapping = (0, -1)\n        to_swap = (0, -1)\n        for ind in range(1, len(A)):\n            num = A[ind]\n            if num < prev:\n                swapping = (num, ind)\n                to_swap = (A[ind - 1], ind - 1)\n            elif num > swapping[0] and num < to_swap[0]:\n                swapping = (num, ind)\n                    \n            prev = num\n            \n        if swapping[1] != -1:\n            value = A[swapping[1]]\n            A[swapping[1]] = A[to_swap[1]]\n            A[to_swap[1]] = value\n            \n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if A== []:\n            return []\n        last = float('inf')\n        flag = False\n        for i in range(len(A)-1, -1, -1):\n            if A[i] > last:\n                flag = True\n                break\n            last = A[i]\n        if not flag:\n            return A\n        else:\n            maxx = -float('inf')\n            champ = None\n            for j in range(i+1, len(A)):\n                if A[j] > maxx and A[j] < A[i]:\n                    champ = j\n                    maxx = A[j]\n            A[i], A[champ] = A[champ], A[i]\n            \n            return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-1, 0, -1):\n            if A[i-1] > A[i]:\n                break\n        if i == 1 and A[i-1] <= A[i]:\n            return A    \n        j = max([x for x in range(i, len(A)) if A[x] < A[i-1]], key=lambda x:A[x])\n        A[i-1], A[j] = A[j], A[i-1]\n        return A\n                \n                \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        a_length = len(A)\n        largest_left_index = 0\n        largest_left = A[0]\n        for i in range(2, a_length + 1):\n            i *= -1\n            if A[i] > A[i + 1]:\n                largest_left_index = i\n                largest_left = A[i]\n                break\n\n        largest_right_index = 0\n        largest_right = 0\n        for i in range(a_length + largest_left_index + 1, a_length):\n            if A[i] > largest_right and A[i] < largest_left:\n                largest_right_index = i\n                largest_right = A[i]\n\n        A[largest_left_index], A[largest_right_index] = A[largest_right_index], A[largest_left_index]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-2, -1, -1):\n            if A[i] > A[i+1]:\n                break\n        if A[i] <= A[i+1]:\n            return A    \n        j = max([x for x in range(i, len(A)) if A[x] < A[i]], key=lambda x:A[x])\n        A[i], A[j] = A[j], A[i]\n        return A\n        # n=len(A)\n        # for i in range(n-2,-1,-1):\n        #     if A[i]<A[i+1]:\n        #         minJ=-1\n        #         for k in range(i+1,n):\n        #             if A[k]>A[i]: minJ\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        stack = []\n        for i in range(len(A)-1, -1, -1):\n            if stack!=[] and stack[-1]<A[i]:\n                break\n            stack.append(A[i])\n            \n        if len(stack)==len(A):\n            return A\n        \n        # print(i)\n        stack = stack[::-1]\n        low, high = 0, len(stack)-1\n        while low<high-1:\n            mid = (low+high)//2\n            if stack[mid]>=A[i]:\n                high = mid-1\n            else:\n                low = mid\n        # print(stack[high])\n        if stack[high]>=A[i]:\n            high -= 1\n        \n\n        \n        l = high-1\n        while l>=0 and stack[l]==stack[high]:\n            l -= 1\n        l += 1\n        # print(l)\n        temp = A[i]\n        A[i] = A[i+l+1]\n        A[i+l+1] = temp\n        \n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-2, -1, -1):\n            if A[i] > A[i+1]:\n                break\n        \n        if A[i] <= A[i+1]:\n            return A\n        max_j = 0\n        j_ind = i\n        for j in range(i, len(A)):\n            if A[i] > A[j]:\n                max_j = max(max_j, A[j])\n                if max_j == A[j]:\n                    j_ind = j\n        \n        # swap\n        tmp = A[i]\n        A[i] = A[j_ind]\n        A[j_ind] = tmp\n        return A\n        \n        \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        \\\"\\\"\\\"\n        res = -1\n        for i in range(len(A)-1,0,-1):\n        \\\"\\\"\\\"\n        for i in range(len(A)-1,0,-1):\n            if A[i] >= A[i-1]:\n                continue\n            else:\n                val = A[i-1]\n                j=-1\n                while (A[j] >= val  or A[j] == A[j-1] ):\n                    j-=1\n            \n            A[i-1], A[j] = A[j], A[i-1]\n            break\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        if n == 1: return A\n        \n        tidx = -1\n        for i in range(n-2, -1, -1):\n            if A[i] > A[i+1]:\n                tidx = i\n                break\n        \n        if tidx < 0: return A\n        \n        target = A[tidx]\n        sidx = -1\n        for j in range(n-1, tidx, -1):\n            if A[j] < target: \n                sidx = j\n                break\n        \n        A[tidx], A[sidx] = A[sidx], A[tidx]\n        \n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        if n<=1: return A\n        \n        # moving left pointer\n        left = n - 2\n        while left >= 0 and A[left] <= A[left+1]:\n            left -= 1\n        if left < 0:\n            return A\n        \n        # moving right pointer\n        right = n-1\n        while A[right] >= A[left]:\n            right -= 1\n        while A[right] == A[right-1]:\n            right -= 1\n            \n        # swap left and right\n        A[left],A[right] = A[right],A[left]\n        \n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        res = [val for val in A]\n        length = len(A)\n        start = 0\n        haveInvertedPos = False\n        # \u5bfb\u627e\u6700\u540e\u4e00\u4e2a\u9006\u5e8f\u4f4d\u7f6e\n        for i in range(length-1):\n            if A[i] <= A[i+1]:\n                pass\n            else:\n                start = i\n                haveInvertedPos = True\n        # \u6ca1\u6709\u9006\u5e8f\u4f4d\u7f6e\n        if not haveInvertedPos:\n            return res\n        target = start+1\n        temp = A[target]\n        for i in range(start+1, length):\n            if A[i] < A[start] and A[i] > temp:\n                temp = A[i]\n                target = i\n        # print(start, target)\n        res[start], res[target] = res[target], res[start]\n        return res\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        left = n - 1\n        while left >= 1 and A[left-1] <= A[left]:\n            left -= 1\n        if left == 0:\n            return A\n        right = left\n        left = left - 1\n        for i in range(right, n):\n            if A[i] > A[right] and A[i] < A[left]:\n                right = i\n        A[left], A[right] = A[right], A[left]\n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        stack=[]\n        find=-1\n        for i in range(1,len(A)):\n            if A[i]<A[i-1]:\n                find=i-1\n                break\n        if find ==-1:\n            return A\n        j=find\n        ind=[]\n        3210\n        while j<len(A):\n            \n            if len(stack)==0:\n                stack.append(j)\n                j+=1\n                continue\n            if A[j]<A[stack[-1]]:\n                if len(stack)==2:\n                    a=stack[-1]\n                    stack=[a,j]\n                else:\n                    stack.append(j)\n                j+=1\n                continue\n            else:\n                if len(stack)==2:\n                    ind=[stack[0],stack[1]]\n                stack.pop()\n        \n        if len(stack)==2:\n            A[stack[0]],A[stack[1]]=A[stack[1]],A[stack[0]]\n            return A\n        if len(ind)==2:\n            A[ind[0]],A[ind[1]]=A[ind[1]],A[ind[0]]\n            return A\n        return A\n        if len(stack)==0 and len(ind)==0:\n            return A\n", "class Solution:\n  def prevPermOpt1(self, A: List[int]) -> List[int]:\n    if not A:\n      return A\n    \n    leftIndex = -1\n    for i in range(len(A)-1, 0, -1):\n      if A[i-1] > A[i]:\n        leftIndex = i - 1\n        break\n    \n    if leftIndex == -1:\n      return A\n  \n    rightIndex = -1\n    for i in range(len(A)-1, leftIndex, -1):\n      if A[i] >= A[leftIndex]:\n        continue\n      elif rightIndex == -1:\n        rightIndex = i\n      elif A[i] == A[rightIndex]:\n        rightIndex = i\n    \n    A[leftIndex], A[rightIndex] = A[rightIndex], A[leftIndex]\n    return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-2, -1, -1):\n            ans = (-1, -1)\n            for j in range(i+1, len(A)):\n                if A[j] < A[i]:\n                    ans = max(ans, (A[j], -j)) # Find the maximum value, if value is the same we need the smallest j\n            if ans[0] != -1:\n                A[i], A[-ans[1]] = A[-ans[1]], A[i]\n                return A\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-1, 0, -1):\n            if A[i-1] > A[i]:\n                break\n        if A[i-1] <= A[i]:\n            return A    \n        j = max([x for x in range(i, len(A)) if A[x] < A[i-1]], key=lambda x:A[x])\n        A[i-1], A[j] = A[j], A[i-1]\n        return A\n                \n                \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        stack = [0]\n        larger_index = [-1] * len(A)\n        \n        for i in range(1, len(A)):\n            while stack and A[i] >= A[stack[-1]]:\n                stack.pop()\n            if stack:\n                larger_index[i] = stack[-1]\n            stack.append(i)\n        \n        print(larger_index)\n        idx, swap = len(larger_index), -1\n        for i in range(len(larger_index) - 1, -1, -1):\n            if larger_index[i] == -1:\n                continue\n            if larger_index[i] > swap or (larger_index[i] == swap and A[i] >= A[idx]):\n                val = A[larger_index[i]]\n                idx = i\n                swap = larger_index[i]\n        if swap != -1:\n            A[swap], A[idx] = A[idx], A[swap]\n        return A\n            \n            \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if len(A)<=1:\n            return A\n        left=len(A)-2\n        while left>=0 and A[left]<=A[left+1]:\n            left-=1\n        \n        if left<0:\n            return A\n        \n        right=len(A)-1\n        \n        while A[right]>=A[left] and right>=0:\n            right-=1\n        \n        while right>=0 and A[right]==A[right-1]:\n            right-=1\n            \n        A[left],A[right]=A[right],A[left]\n        return A\n        \n    \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        i=len(A)-2\n        while(i>=0 and A[i]<=A[i+1]):\n            i-=1\n        if(i>=0):\n            max_=i+1\n            # max number greater on right that less than A[i]\n            for j in range(max_+1,len(A)):\n                if(A[max_]<A[j] and A[j]<A[i]):\n                    max_=j\n            A[max_],A[i]=A[i],A[max_]\n\n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        mid = -1\n        for i in range(len(A)-2,-1,-1):\n            if A[i]>A[i+1]:\n                mid = i\n                break\n        if mid ==-1:\n            return A\n        max_mid = -1\n        for i in range(mid+1,len(A)):\n            if A[mid]>A[i]:\n                if A[i]>max_mid:\n                    index = i\n                    max_mid = A[i]\n                #max_mid = max(max_mid,A[i])\n        #index = A.index(max_mid)\n        A[mid],A[index] = A[index],A[mid]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        prev_vals = [(float('inf'), None)]\n        \n        for i in range(len(A) - 1, -1, -1):\n            num = A[i]\n            \n            if num > prev_vals[-1][0]:\n                max_prev = 0\n                ind = None\n                while num > prev_vals[-1][0]:\n                    prev_n, prev_ind = prev_vals.pop()\n                    if prev_n > max_prev:\n                        max_prev = prev_n\n                        ind = prev_ind\n                \n                A[i], A[ind] = max_prev, num\n                return A\n            \n            prev_vals.append((num, i))\n            \n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        largest = len(A) - 2\n        while largest >= 0 and A[largest] <= A[largest + 1]:\n            largest -= 1\n        if largest == -1:\n            return A\n        smallest = len(A) - 1\n        while A[largest] <= A[smallest]:\n            smallest -= 1\n        f = smallest\n        while A[smallest] == A[f]:\n            f -= 1\n        A[f + 1], A[largest] =  A[largest],A[f + 1]\n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        idx = -1\n        for i in range(len(A)-1):\n            if A[i] > A[i+1]:\n                idx = i\n        \n        if idx == -1:\n            return A\n        \n        for i in range(len(A)-1, idx, -1):\n            if A[i] < A[idx] and A[i] != A[i-1]:\n                A[idx], A[i] = A[i], A[idx]\n                break\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        for i in range(len(A)-2,-1,-1):\n            for x in range(len(A)-1,i,-1):\n                if A[x] == A[x-1]:\n                    continue\n                if A[i] > A[x]:\n                    A[i],A[x] = A[x],A[i]\n                    return A\n        return A\n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        if n<=1: return A\n        \n        # moving left pointer\n        left = n-2\n        while left>=0 and A[left]<=A[left+1]: \n            left -= 1\n        if left < 0: return A\n        \n        # moving right pointer, skip same item\n        right = n-1\n        while A[right]>=A[left]: right -= 1\n        while A[right]==A[right-1]: right -= 1\n            \n        # swap left and right\n        A[left],A[right] = A[right],A[left]\n        \n        return A\n        \\\"\\\"\\\"\n        i1, n = -1, len(A)\n        idx = n-2\n        while idx >= 0:\n            if A[idx] > A[idx+1]:\n                i1 = idx\n            else:\n                idx -= 1\n        \n        if i1 == -1:\n            return A\n        \n        # right #\n        i2 = n-1\n        while A[i2] >= A[i1]:\n            i2 -= 1\n        while A[i2] == A[i2-1]:\n            i2 -= 1\n        \n        A[i1], A[i2] = A[i2], A[i1]\n        return A\n        \n        \n        i1 = -1\n        idx = len(nums)-1\n        while idx > 0:\n            if nums[idx-1] > nums[idx]:\n                i1 = idx-1\n                break\n            else:\n                idx -= 1\n        \n        if i1 == -1:\n            return nums\n        \n        for idx in reversed(range(i1+1, len(nums))):\n            if nums[idx] < nums[i1] and nums[idx] != nums[idx-1]:\n                nums[i1], nums[idx] = nums[idx], nums[i1]\n         \n        return nums\n        \\\"\\\"\\\"", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        a_length = len(A)\n        largest_left_index = 0\n        largest_left = A[0]\n        for i in range(2, a_length + 1):\n            i *= -1\n            if A[i] > A[i + 1]:\n                largest_left_index = i\n                largest_left = A[i]\n                break\n        \n        largest_right_index = 0\n        largest_right = 0\n        for i in range(a_length + largest_left_index + 1, a_length):\n            if A[i] > largest_right and A[i] < largest_left:\n                largest_right_index = i\n                largest_right = A[i]\n        \n        A[largest_left_index], A[largest_right_index] = A[largest_right_index], A[largest_left_index]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        i = len(A) - 2\n        \n        while i >= 0 and A[i + 1] >= A[i]:\n            i -= 1\n        \n        if i == -1:\n            return A\n        \n        # find largest number just under A[i]\n        k = i + 1\n        j = i + 1\n        while j < len(A):\n            if A[k] < A[j] < A[i]:\n                k = j\n            j += 1\n        A[i], A[k] = A[k], A[i]\n        return A\n\n        \n        \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        point = -1\n        for i in range(len(A) - 1, 0, -1):\n            if A[i - 1] > A[i]:\n                point = i - 1\n                break\n        if point == -1:\n            return A\n        right_point = point + 1\n        max_val = -1\n        for i in range(point + 1, len(A)):\n            if A[i] < A[point] and max_val < A[i]:\n                right_point = i\n                max_val = A[i]\n        A[point], A[right_point] = A[right_point], A[point]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        \n        for i in range(len(A)-2, -1, -1):\n            if A[i] > A[i+1]:\n                for j in range(i+1, len(A)):\n                    if A[j] > A[i] or j==len(A)-1:\n                        k = (j - 1) if A[j] > A[i] else j\n                        while k > i and A[k] == A[i]:\n                            k -= 1\n                        while k - 1 > i and A[k-1]==A[k]:\n                            k -= 1\n                        A[i],A[k] = A[k],A[i]\n                        break\n                break\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        rear = len(A) - 2\n        while rear > -1:\n            if A[rear] > A[rear+1]:\n                break\n            rear -= 1\n        if rear == -1:\n            return A\n        front = len(A) - 1\n        while A[front] >= A[rear] or A[front-1] == A[front]:\n            front -= 1\n        A[rear], A[front] = A[front], A[rear]\n        return A\n            \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if not A:\n            return []\n        \n        i = len(A) - 1\n        # find first elt A[i - 1] > A[i], from right to left\n        # 1[9]467, find 9\n        #   i\n        while i > 0 and A[i - 1] <= A[i]:\n            i -= 1\n        if i == 0:\n            return A # already at the smallest permutation\n        \n        # 1[9]46[7], find first elt < A[i - 1], which is 7\n        # swap 9 and 7\n        j = len(A) - 1\n        while j > i and A[j] >= A[i - 1]:\n            j -= 1\n        \n        \n        while j >= i and A[j] == A[j - 1]:\n            j -= 1\n        \n        A[j], A[i - 1] = A[i - 1], A[j]\n        return A\n        \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        l = len(A)-2\n        while l >= 0:\n            if A[l+1] < A[l]:\n                break\n            l -= 1\n        max_so_far = 0\n        max_idx = l\n        r = l+1\n        while r < len(A):\n            if A[r] > max_so_far and A[r] < A[l]:\n                max_so_far = A[r]\n                max_idx = r\n            r += 1\n        if 0 <= l <= max_idx < len(A):\n            A[l], A[max_idx] = A[max_idx], A[l]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        \n        # Start from the right, see if any values are smaller than current index\n        \n        smallestSeenSoFar = A[-1]\n        \n        swapOutIndex = -1\n        for i in range(len(A) - 2, -1, -1):\n            \n            if A[i] > smallestSeenSoFar:\n                # We can perform a swap on this index\n                swapOutIndex = i\n                break\n            \n            smallestSeenSoFar = min(smallestSeenSoFar, A[i])\n        \n        if swapOutIndex == -1:\n            # We cannot swap out any values, so we terminate\n            return A\n        \n        # Now, we need to find the largest index smaller than the swapout index\n        swapInIndex = len(A) - 1\n        largestSeenSmallerThanSwapout = 0\n        \n        for i in range(len(A) - 1, swapOutIndex, -1):\n            \n            if A[i] < A[swapOutIndex] and A[i] >= largestSeenSmallerThanSwapout:\n                swapInIndex = i\n                largestSeenSmallerThanSwapout = A[i]\n                # We also choose the highest index that is matching our criterion\n        \n        # Now we found the swap in index, we perform the swap\n        \n        A[swapOutIndex], A[swapInIndex] = A[swapInIndex], A[swapOutIndex]\n        \n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        '''\n        from end, find 1st number which is greater than atleast 1 no. from its right\n        \n        '''\n        i,mn,mx = n-2,n-1,n-1\n        while i >= 0:\n            if A[i] > A[mn]: mx = i\n            if A[i] < A[mn]: mn = i\n            if mn != mx and mx < mn: break\n            i-=1\n        if i == -1: return A\n        print((mx,mn))\n        mxR = mx+1\n        for j in range(mx+1,n):\n            if A[j] < A[mx] and A[j] > A[mxR]: \n                mxR = j\n        A[mx],A[mxR] = A[mxR],A[mx]\n        return A\n        \n", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        '''\n        5,6,1,1,1\n        5,1,6,2,1\n        '''\n        for i in reversed(range(1,len(A))):\n            if A[i-1] > A[i]:\n                maxLessInd = i\n                maxLessVal = A[i]\n                for j in range(i+1,len(A)):\n                    if A[j] > maxLessVal and A[j] < A[i-1]:\n                        maxLessVal = A[j]\n                        maxLessInd = j\n                A[i-1], A[maxLessInd] =  A[maxLessInd], A[i-1]\n                return A\n        return A    ", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        m = 10000\n        idx = defaultdict(int)\n        l = []\n\n        for i in range(len(A)-1, -1, -1):\n            if A[i]>m:\n                l.sort()\n                j = idx[l[bisect_left(l, A[i])-1]]\n                A[i], A[j] = A[j], A[i]\n                return A\n            \n            m = min(m, A[i])\n            idx[A[i]] = i\n            l.append(A[i])\n        \n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        if A == sorted(A): return A\n        \n        idx = None\n        for i in range(len(A)-1,0, -1):\n            if A[i-1] > A[i]:\n                idx = i - 1\n                break\n        \n        mx = float('-inf')\n        for i in range(idx+1, len(A)):\n            if mx < A[i] < A[idx]:\n                mx = A[i]\n                midx = i\n        A[midx], A[idx] = A[idx], A[midx]\n        return A", "class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        def findLarger():\n            prev = A[-1]\n            for i in range(len(A)-1, -1, -1):\n                if A[i] > prev:\n                    return i\n                prev = A[i]\n            return -1\n        if not A:\n            return A\n        larger = findLarger()\n        if larger == -1:\n            return A\n        sl = larger + 1\n        for i in range(larger, len(A)):\n            if A[i] < A[larger]:\n                if A[sl] < A[i]:\n                    sl = i\n        print((larger, sl))\n        A[sl], A[larger] = A[larger], A[sl]\n        return A\n"]
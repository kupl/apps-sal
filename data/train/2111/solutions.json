["import itertools\nimport bisect\n\nn, A, cf, cm, m = [int(x) for x in input().split()]\nskills = [int(x) for x in input().split()]\nsorted_skills = list(sorted((k, i) for i, k in enumerate(skills)))\nbottom_lift = [0 for i in range(n)]\nfor i in range(1, n):\n    bottom_lift[i] = bottom_lift[i-1] + i * (sorted_skills[i][0] - sorted_skills[i-1][0])\nroot_lift = [0 for i in range(n+1)]\nfor i in range(1, n+1):\n    root_lift[i] = root_lift[i-1] + A - sorted_skills[n-i][0]\n\nmax_level = -1\nfor i in range(n+1):\n    money_left = m - root_lift[i]\n    if money_left < 0: break\n    k = min(bisect.bisect(bottom_lift, money_left), n-i)\n    money_left -= bottom_lift[k-1]\n    min_level = min(A, sorted_skills[k-1][0] + money_left//k) if k > 0 else A\n    level = cf*i + cm*min_level\n    if max_level < level:\n        max_level = level\n        argmax = i\n        argmax_min_level = min_level\n        argmax_k = k\n\nans = [0 for i in range(n)]\nfor i, skill in enumerate(sorted_skills):\n    if i < argmax_k:\n        ans[skill[1]] = argmax_min_level\n    elif i >= n - argmax:\n        ans[skill[1]] = A\n    else:\n        ans[skill[1]] = skill[0]\n\nprint(max_level)\nfor a in ans:\n    print(a, end = ' ')\n    \n", "def main():\n    from bisect import bisect\n    n, A, cf, cm, m = list(map(int, input().split()))\n    skills = list(map(int, input().split()))\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift, a, c = [], 0, 0\n    for i, b in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift, a = [0], 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    for A_width, a in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level, save = level, (A_width, floor, floor_width)\n    A_width, floor, floor_width = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    print(max_level)\n    print(' '.join(map(str, skills)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "f = lambda: map(int, input().split())\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: m - l * p[l - 1] + s[l]\n\nn, A, x, y, m = f()\nt = sorted((q, i) for i, q in enumerate(f()))\np = [q for q, i in t]\ns = [0] * (n + 1)\nfor j in range(n): s[j + 1] = p[j] + s[j]\n\nl = r = n\nF = L = R = B = -1\nwhile 1:\n    if p:\n        while l > r or g() < 0: l -= 1\n        b = min(p[l - 1] + g() // l, A)\n    else: b, l = A, 0\n\n    f = x * (n - r) + y * b\n    if F < f: F, L, R, B = f, l, r, b\n\n    if not p: break\n    m += p.pop() - A\n    r -= 1\n    if m < 0: break\n\nprint(F)\n\np = [(i, B if j < L else q if j < R else A) for j, (q, i) in enumerate(t)]\nfor i, q in sorted(p): print(q)\n", "def main():\n    from bisect import bisect\n    n, A, cf, cm, m = list(map(int, input().split()))\n    skills = list(map(int, input().split()))\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift, a, c = [], 0, 0\n    for i, b in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift, a = [0], 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    for A_width, a in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level, save = level, (A_width, floor, floor_width)\n    A_width, floor, floor_width = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    print(max_level)\n    print(' '.join(map(str, skills)))\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "n,A,cf,cm,mN = list(map(int,input().split()))\n\na = list(map(int,input().split()))\naCOPY = []\nfor elem in a:\n    aCOPY.append(elem)\na.sort()\n\naPartialSum = [0]\n\nfor elem in a:\n    aPartialSum.append(aPartialSum[-1] + elem)\n\nmaxScore = 0\nansMAXIBound = 0\nansMAXI = 0\nansMIN = 0\nfor MAXI in range(n + 1):\n    currentScore = cf * MAXI\n    if MAXI >= 1:\n        mN -= (A - a[-MAXI])\n    if mN < 0:\n        break\n    if MAXI == n:\n        maxScore = currentScore + A * cm\n        ansMAXIBound = 0\n        ansMAXI = 10 ** 10\n        ansMIN = 0\n    # Find the maximum of minimum\n    l = a[0]\n    r = A - 1\n\n    while l < r:\n        m = (l + r + 1) // 2\n        lA = 0\n        rA = n - MAXI - 1\n        while lA < rA:\n            mA = (lA + rA) // 2\n            if a[mA] > m:\n                rA = mA - 1\n            if a[mA] < m:\n                lA = mA + 1\n            if a[mA] == m:\n                lA = mA\n                rA = mA\n                break\n        lA = min(lA,n - MAXI - 1)\n        if a[lA] > m:\n            lA -= 1\n        expenditure = (lA + 1) * m - aPartialSum[lA + 1]\n        if expenditure > mN:\n            r = m - 1\n        else:\n            l = m\n    currentScore += l * cm\n    if currentScore > maxScore:\n        maxScore = currentScore\n        ansMAXIBound = a[-MAXI]\n        ansMAXI = MAXI\n        ansMIN = l\n\nprint(maxScore)\ninclCount = 0\nfor i in range(n):\n    if aCOPY[i] > ansMAXIBound and inclCount < ansMAXI:\n        aCOPY[i] = A\n        inclCount += 1\nfor i in range(n):\n    if aCOPY[i] == ansMAXIBound and inclCount < ansMAXI:\n        aCOPY[i] = A\n        inclCount += 1\n    if aCOPY[i] < ansMIN:\n        aCOPY[i] = ansMIN\nprint(\" \".join(map(str,aCOPY)))\n\n"]
["class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        mod = 10**9 + 7\n\n        nums_set = set(A)\n        nums = A.copy()\n        nums.sort()\n        counts = {}\n        total = 0\n\n        for n in nums:\n            n_count = 1\n            for d in nums:\n                if d * d > n:\n                    break\n                if n % d != 0:\n                    continue\n                e = n // d\n                if e not in nums_set:\n                    continue\n\n                subtrees = (counts[d] * counts[e]) % mod\n                if d != e:\n                    subtrees = (subtrees * 2) % mod\n                n_count = (n_count + subtrees) % mod\n            counts[n] = n_count % mod\n            total = (total + n_count) % mod\n\n        return total\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        factorSet = set(A)\n        A.sort()\n        treeCount = collections.defaultdict(lambda : 1)\n        \n        n = len(A)\n        end = 0\n        for num in A:\n            sqrt = int(math.sqrt(num)+1)\n            while end < n and A[end] <= sqrt:\n                end += 1\n            count = 0\n            for _, p in zip(list(range(end)), A):\n                if num % p == 0 and (q := num // p) in factorSet and p <= q:\n                    count += 2*treeCount[p]*treeCount[q] if p != q else treeCount[p]*treeCount[q]\n            treeCount[num] += count\n        return sum(treeCount.values()) % (1000_000_000 + 7)\n        \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        factorSet = set(A)\n        A.sort()\n        treeCount = {}\n\n        for num in A:\n            count = 1\n            for p, pCount in list(treeCount.items()):\n                q, rem = divmod(num, p)\n                if p > q:\n                    break\n                if rem == 0:\n                    tmp = pCount * treeCount.get(q, 0)\n                    count += tmp if p == q else 2*tmp\n            treeCount[num] = count\n        return sum(treeCount.values()) % (1000_000_000 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        dp = {}\n        res = 0\n        for i in range(len(A)):\n            dp[A[i]] = 1\n            for j in range(i):\n                if A[j] * A[j] == A[i]:\n                    dp[A[i]] += dp[A[j]] * dp[A[j]]\n                    dp[A[i]] %= 1000_000_007\n                elif A[j] * A[j] > A[i] and A[i] % A[j] == 0:\n                    dp[A[i]] += dp[A[j]] * dp.get(A[i] // A[j], 0) * 2\n                    dp[A[i]] %= 1000_000_007\n        res = sum([v for _, v in dp.items()])\n        res %= 1000_000_007\n        return res", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        dp = {}\n        res = 0\n        for i in range(len(A)):\n            dp[A[i]] = 1\n            for j in range(i):\n                if A[j] * A[j] == A[i]:\n                    dp[A[i]] += dp[A[j]] * dp[A[j]]\n                    dp[A[i]] %= 1000_000_007\n                elif A[j] * A[j] > A[i]:\n                    div = A[i] // A[j]\n                    if div * A[j] == A[i] and div in dp:\n                        dp[A[i]] += dp[A[j]] * dp[div] * 2\n                        dp[A[i]] %= 1000_000_007\n            res += dp[A[i]]\n            res %= 1000_000_007\n        return res", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        dp = {}\n        res = 0\n        for i in range(len(A)):\n            dp[A[i]] = 1\n            for j in range(i):\n                if A[j] * A[j] == A[i]:\n                    dp[A[i]] += dp[A[j]] * dp[A[j]]\n                    dp[A[i]] %= 1000_000_007\n                elif A[j] * A[j] > A[i] and A[i] % A[j] == 0:\n                    dp[A[i]] += dp[A[j]] * dp.get(A[i] // A[j], 0) * 2\n                    dp[A[i]] %= 1000_000_007\n            res += dp[A[i]]\n            res %= 1000_000_007\n        return res", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        cache = dict()\n        iSet = set(A)\n        def helper(i):\n            if i not in cache:\n                count = 1\n                for j in range(len(A)):\n                    if i != A[j] and i % A[j] == 0:\n                        if i//A[j] in iSet:\n                            count += helper(A[j]) * helper(i//A[j])\n                cache[i] = count\n            return cache[i]\n        ans = 0\n        for i in range(len(A)):\n            ans += helper(A[i])\n        return ans % 1000000007\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A=sorted(A)\n        res=dict()\n        for idx, a in enumerate(A):\n            if idx==0:\n                res[a]=1\n            else:\n                res[a]=1\n                for j in range(idx):\n                    if (a%A[j]==0) and (a//A[j] in A):\n                        res[a]+=res[A[j]]*res[a//A[j]]\n        return sum(res.values())%(10**9+7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        A.sort()\n        \n        dp = [1 for _ in range(len(A))]\n        \n        for i in range(len(A)):\n            \n            for j in range(i):\n                \n                time, remain = divmod(A[i], A[j])\n\n                if remain == 0 and time in A:\n\n                    dp[i] += (dp[j] * dp[A.index(time)])\n                        \n        return sum(dp) % (10**9 + 7)\n            \n            \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        d = {}\n        Aset = set(A)\n        A.sort()\n        ans = 0\n        for i in range(len(A)):\n            d[A[i]] = 1\n            for j in range(i):\n                if A[i]%A[j] == 0:\n                    k = A[i]//A[j]\n                    if k in set(A):\n                        d[A[i]] += d[A[j]]*d[k]\n            d[A[i]] %= 10**9+7\n            ans += d[A[i]]\n            ans %= 10**9+7\n        # print(d)\n        return ans\n        # return sum(d[key] for key in d)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        d = {}\n        Aset = set(A)\n        A.sort()\n        ans = 0\n        for i in range(len(A)):\n            d[A[i]] = 1\n            for j in range(i):\n                if A[i]%A[j] == 0:\n                    k = A[i]//A[j]\n                    if k == A[j]:\n                        d[A[i]] += d[A[j]]*d[A[j]]\n                    elif k in set(A):\n                        d[A[i]] += d[A[j]]*d[k]\n            ans += d[A[i]]\n            ans %= 10**9+7\n        # print(d)\n        return ans\n        # return sum(d[key] for key in d)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        d = {}\n        Aset = set(A)\n        A.sort()\n        ans = 0\n        for i in range(len(A)):\n            d[A[i]] = 1\n            for j in range(i):\n                if A[i]%A[j] == 0:\n                    k = A[i]//A[j]\n                    if k in set(A):\n                        d[A[i]] += d[A[j]]*d[k]\n                        d[A[i]] %= 10**9+7\n            ans += d[A[i]]\n            ans %= 10**9+7\n        return ans\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        SA = set(A)\n        A = sorted(SA)\n        C = {}\n        for x in A:\n            C[x] = 1\n        for i, x in enumerate(A):\n            for j in range(i):\n                if A[j] * A[j] > A[i]:\n                    break\n                elif A[j] * A[j] == A[i]:\n                    C[A[i]] += C[A[j]] * C[A[j]]\n                elif A[i] % A[j] == 0 and A[i] // A[j] in SA:\n                    C[A[i]] += 2 * C[A[j]] * C[A[i] // A[j]]\n        # print(C)\n        res = sum(C.values())\n        return res % (10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        treeCount = {}\n\n        for num in A:\n            count = 1\n            for p, pCount in list(treeCount.items()):\n                q, rem = divmod(num, p)\n                if p > q:\n                    break\n                if rem == 0 and q in treeCount:\n                    count += pCount*treeCount[q] if p == q else 2*pCount*treeCount[q]\n            treeCount[num] = count\n        return sum(treeCount.values()) % (1000_000_000 + 7)\n", "class Solution:\n    def collect(self, lst, st, num, cache):\n        if num in cache:\n            return cache[num]\n        res = 1\n        for n1 in lst:\n            if n1**2 > num:\n                break\n            if num % n1 == 0 and (num // n1) in st:\n                n2 = num // n1\n                res_local = self.collect(lst, st, n1, cache) * self.collect(lst, st, n2, cache)\n                res += res_local\n                if n1 != n2:\n                    res += res_local\n        mod = (10**9)+7\n        res = res % mod\n        cache[num] = res\n        return res\n    \n    def solve(self, A):        \n        st = set(A)\n        lst = sorted(list(st))\n        res = 0\n        cache = {}\n        mod = (10**9)+7\n        for n in lst:\n            res += self.collect(lst, st, n, cache)\n        return res % mod\n    \n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        return self.solve(A)", "import functools as ft\nimport typing as t\n\n\nclass Solution:\n    \n    BASE = 10 ** 9 + 7\n    \n    def divisor_pairs(self, idx: int) -> List[t.Tuple[int, int]]:\n        num = self.A[idx]\n        left_idx = 0\n        ans = []\n        while self.A[left_idx] ** 2 <= num:\n            left = self.A[left_idx]\n            if num % left == 0:\n                right = num // left\n                if right in self.A_idx:\n                    ans.append((left_idx, self.A_idx[right]))\n            left_idx += 1\n        return ans\n    \n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        self.A = sorted(A)\n        self.A_idx = {a: idx for idx, a in enumerate(self.A)}\n        return sum(self.count_binary_trees(idx) for idx in range(len(A))) % self.BASE\n    \n    @ft.lru_cache(None)\n    def count_binary_trees(self, idx: int) -> int:\n        num = self.A[idx]\n        ans = 1  # root only\n        for left_idx, right_idx in self.divisor_pairs(idx):\n            left_cnt = self.count_binary_trees(left_idx)\n            right_cnt = self.count_binary_trees(right_idx)\n            if left_idx == right_idx:\n                total_cnt = left_cnt * right_cnt\n            else:\n                total_cnt = 2 * left_cnt * right_cnt\n            ans += total_cnt\n        return ans", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        d = {}\n        MOD = 1000000007\n        for a in A:\n            d[a] = 1 + sum(d[a//b] * d[b] for b in d if not a%b and a//b in d)\n        #print(d)\n        return sum(d.values()) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        A.sort()\n        parents = dict()\n        seen = set()\n        for a in A:\n            tot = 1\n            for s in seen:\n                if a % s == 0:\n                    b = a // s\n                    if b in seen:\n                        tot += parents[s] * parents[b]\n            parents[a] = tot\n            seen.add(a)\n        return sum(parents.values()) % mod\n                    \n                    \n            \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        # A.sort()\n        # dic = {num: 1 for num in A}\n        # for i in range(1, len(A)):\n        #     for j in range(i):\n        #         q, res = divmod(A[i], A[j])\n        #         if res == 0 and q in dic:\n        #             dic[A[i]] += dic[q] * dic[A[j]]\n\n        # return sum(dic.values()) % (10**9 + 7)\n\n\n        dp = {}\n        for a in sorted(A):\n            dp[a] = sum(dp[b] * dp.get(a // b, 0) for b in dp if a % b == 0) + 1\n        return sum(dp.values()) % (10**9 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        d = {A[0]:0}\n        dp = [1]*len(A)\n        MOD = 1000000007\n        \n        for i in range(1, len(A)):\n            for j in range(0, i):\n                t = A[i]//A[j]\n                if t< A[j]:\n                    break\n                \n                if not A[i] % A[j] and  t in d:\n                    if A[j] == t:\n                        dp[i] += dp[j] * dp[d[t]] \n                    else:\n                        dp[i] += dp[j] * dp[d[t]] * 2\n            \n            dp[i] %= MOD\n            d[A[i]] = i\n            \n        return sum(dp) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A):\n        dp = {}\n        for a in sorted(A):\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\n        return sum(dp.values()) % (10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        dp = {}\n        for a in sorted(A):\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\n        return sum(dp.values()) % (10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        dp = {}\n        for a in sorted(A):\n            dp[a] = sum(dp[b]*dp.get(a/b, 0) for b in dp if(a%b == 0))+1\n        return sum(dp.values())%(10**9+7)\n        \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        A.sort()\n        A_set = set(A)\n        cache = {}\n        num_trees = 0\n            \n        # Update num trees. \n        for i, n in enumerate(A):\n                        \n            # Get factors pairs.\n            factor_pairs = []\n            for j in range(i):\n                if n % A[j] == 0 and n // A[j] in A_set:\n                    factor_pairs.append((n // A[j], A[j]))\n                    \n            # Compute num_trees.\n            new_trees = 1\n            for factor1, factor2 in factor_pairs:\n                if factor1 != factor2:\n                    new_trees += cache[factor1] * cache[factor2] # Each pair is run over twice. \n                elif factor1 == factor2:\n                    new_trees += cache[factor1] * cache[factor2]\n            num_trees += new_trees\n            cache[n] = new_trees\n            \n        print(cache)    \n        return num_trees % (10 ** 9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(A)\n        A.sort()\n        dp = [1] * N\n        index = {x: i for i, x in enumerate(A)}\n        for i, x in enumerate(A):\n            for j in range(i):\n                if x % A[j] == 0: #A[j] will be left child\n                    right = x / A[j]\n                    if right in index:\n                        dp[i] += dp[j] * dp[index[right]]\n                        dp[i] %= MOD\n\n        return sum(dp) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        mod = 10**9 + 7\n        A.sort()\n        dp = [1 for _ in range(len(A))]\n        reverse_map = {x: i for i, x in enumerate(A)}\n\n\n        for i, x in enumerate(A):\n            for j in range(i):\n                if x % A[j] == 0: #A[j] will be left child\n                    right_child = x / A[j]\n                    if right_child in reverse_map:\n                        dp[i] += dp[j] * dp[reverse_map[right_child]]\n                        dp[i] % mod\n\n        return sum(dp) % mod", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        MOD = int(1e9 + 7)\n        N = len(A)\n        \n        A.sort()\n        dp = [1] * N\n        idx = {ele: i for i, ele in enumerate(A)}\n        \n        for c, rootVal in enumerate(A):\n            for j in range(c):\n                left = A[j]\n                if rootVal % left == 0:\n                    right = rootVal / left \n                    if right in idx:\n                        dp[c] += dp[j] * dp[idx[right]] % MOD\n                        \n        return sum(dp) % MOD\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        MOD = int(1e9 + 7)\n        N = len(A)\n        \n        A.sort()\n        dp = [1] * N\n        idx = {ele: i for i, ele in enumerate(A)}\n        \n        for i, rootVal in enumerate(A):\n            for j in range(i):\n                left = A[j]\n                if rootVal % left == 0:\n                    right = rootVal / left \n                    if right in idx:\n                        dp[i] += dp[j] * dp[idx[right]]\n                        dp[i] %= MOD\n                        \n        return sum(dp) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(A)\n        A.sort()\n        dp = [1] * N\n        index = {x: i for i, x in enumerate(A)}\n        for i, x in enumerate(A):\n            for j in range(i):\n                if x % A[j] == 0: #A[j] will be left child\n                    right = x / A[j]\n                    if right in index:\n                        dp[i] += dp[j] * dp[index[right]]\n                        dp[i] %= MOD\n\n        return sum(dp) % MOD\n            \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        O = {}\n        for a in A:\n            if a not in O:\n                O[a] = 1\n            for k, v in list(O.items()):\n                if a % k == 0 and a // k in O:\n                    O[a] += v * O[a // k]\n        return sum(O.values()) % 1000000007\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        MOD = int(1e9 + 7)\n        N = len(A)\n        \n        A.sort()\n        dp = [1] * N\n        idx = {ele: i for i, ele in enumerate(A)}\n        \n        for i, root_val in enumerate(A):\n            for j in range(i):\n                left = A[j]\n                if root_val % left == 0:\n                    right = root_val / left \n                    if right in idx:\n                        dp[i] += dp[j] * dp[idx[right]]\n                        dp[i] %= MOD\n                        \n        return sum(dp) % MOD", "\n# 823. Binary Trees With Factors\n\nclass Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        MOD = int(1e9 + 7)\n        N = len(A)\n        \n        A.sort()\n        dp = [1] * N\n        idx = {ele: i for i, ele in enumerate(A)}\n        \n        for c, rootVal in enumerate(A):\n            for l in range(c):\n                leftVal = A[l]\n                if rootVal % leftVal == 0:\n                    rightVal = rootVal / leftVal \n                    if rightVal in idx:\n                        dp[c] += dp[l] * dp[idx[rightVal]] % MOD\n                        \n        return sum(dp) % MOD\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:   \n        A.sort()\n        numToIdx = {x : i for i, x in enumerate(A)}\n        \n        dp = [1 for _ in range(len(A))]\n        \n        MOD = 10**9 + 7\n        totalSum = 0\n        \n        for i, x in enumerate(A):\n            for j in range(i):\n                y = A[j]\n                if x % y == 0 and x // y in numToIdx:\n                    dp[i] += dp[j] * dp[numToIdx[x // y]]\n            \n            totalSum = (totalSum + dp[i]) % MOD\n        \n        return totalSum", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A = sorted(A)\n        N = len(A)\n        dp = [1 for _ in range(N)]\n        index_map = {}\n        for index in range(N):\n            index_map[A[index]] = index\n        \n        for k in range(N):\n            for i in range(k):\n                if A[k] % A[i] == 0:\n                    num_to_look = A[k]//A[i]\n                    if num_to_look in index_map:\n                        j = index_map[num_to_look]\n                        dp[k] += dp[i]*dp[j] # okay why is this not giving me the right number?\n         \n        return sum(dp) % (10**9 +7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        factorSet = set(A)\n        A.sort()\n        treeCount = {}\n\n        for num in A:\n            count = 1\n            for p, pCount in list(treeCount.items()):\n                q, rem = divmod(num, p)\n                if p > q:\n                    break\n                if rem == 0 and q in treeCount:\n                    tmp = pCount * treeCount[q]\n                    count += tmp if p == q else 2*tmp\n            treeCount[num] = count\n        return sum(treeCount.values()) % (1000_000_000 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        ret = 0\n        root_value_to_tree_number = collections.defaultdict(int)\n        \n        \n        for i in range(len(A)):\n            occurrences = 1\n            \n            \n            for j in range(i - 1, -1, -1):\n                if (A[i] % A[j] == 0):\n                    required_root_value = A[i] // A[j]\n                    occurrences += root_value_to_tree_number[required_root_value] * root_value_to_tree_number[A[j]]\n             \n            root_value_to_tree_number[A[i]] = occurrences\n            ret += occurrences\n            \n        return ret % 1000000007         ", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        factors = set(A)\n        A.sort()\n        dp = defaultdict(int)\n        count = 0\n        modulus = 10**9 + 7\n        for i in range(len(A)):\n            dp[A[i]] += 1\n            for j in range(i):\n                if A[i] % A[j] == 0 and (A[i] // A[j]) in factors:\n                    dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]\n            count = (count + dp[A[i]]) % modulus\n        return count", "class Solution:\n    def numFactoredBinaryTrees(self, A):\n        MOD = 10 ** 9 + 7\n        n = len(A)\n        A.sort()\n        dp = [1] * n\n        index = {x: i for i, x in enumerate(A)}\n        for i, x in enumerate(A):\n            for j in range(i):\n                if x % A[j] == 0:\n                    right = x / A[j]\n                    if right in index:\n                        dp[i] += dp[j] * dp[index[right]]\n                        dp[i] %= MOD\n\n        return sum(dp) % MOD", "import math\nclass Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        mod = 1000000007\n        dp = [1 for i in range(len(A))]\n        A.sort()\n        val_to_idx = {val: idx for idx, val in enumerate(A)}\n        M = len(A)\n        for i in range(M):\n            for j in range(0, i):\n \n                if A[i] % A[j] == 0 and A[i]//A[j] in val_to_idx:\n                    dp[i] += (dp[j] * dp[val_to_idx[A[i]//A[j]]]) % mod\n                    dp[i] = dp[i] % mod\n        print(dp)\n        return sum(dp) % mod\n                    \n            \n                    \n                \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        A.sort()\n        dp = {val: 1 for val in A}\n        \n        for i in range(len(A)):\n            for j in range(i):\n                if A[i] % A[j] == 0 and A[i]//A[j] in dp:\n                    dp[A[i]] += dp[A[i]//A[j]] * dp[A[j]]\n        \n        return sum(dp[v] for v in dp) % (10 ** 9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        n = len(A)\n        A.sort()\n        s = {a:i for i,a in enumerate(A)}\n        d = collections.defaultdict(set)\n        for i in range(n):\n            for j in range(i):\n                if A[i] % A[j] == 0:\n                    res = A[i] // A[j]\n                    if res in s:\n                        d[i].add((j, s[res]))\n        \n        @lru_cache(maxsize=None)\n        def dfs(i):\n            nonlocal ans\n            cur = 1\n            for l, r in d[i]:\n                cur += dfs(l) * dfs(r)\n            return cur    \n        ans = 0           \n        for i in range(n):        \n            val = dfs(i)        \n            ans += val\n        return ans % 1000000007\n", "class Solution:\n    def numFactoredBinaryTrees(self, x: List[int]) -> int:\n        def f(n):\n            if n in dp:return dp[n]\n            ans=1\n            for i in x:\n                if i>(n**.5):break\n                if n%i==0 and n//i in se:\n                    ans+=(1 if n//i==i else 2)*f(i)*f(n//i)\n            dp[n]=ans\n            return ans   \n        dp={}\n        x.sort()\n        se=set(x)\n        ans=0\n        for i in x:ans+=f(i)\n        return ans%(10**9+7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        num_trees = {}\n        A.sort()\n        A_set = set(A)\n        for i in range (len(A)):\n            curr_num = A[i]\n            num_trees[curr_num] = 1 \n            for j in range (i):\n                if (A[i] % A[j] == 0):\n                    if (A[i] // A[j]) in A_set:\n                        num_trees[curr_num] += (num_trees[A[j]] * num_trees[A[i] // A[j]])\n        total = 0\n        for key in num_trees:\n            total += num_trees[key]\n            total %= (10**9 + 7)\n        return total\n        \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        if not A:\n            return 0\n\n        A.sort()\n        dp = {}\n        for i in range(len(A)):\n            dp[A[i]] = 1\n            for j in range(i):\n                if A[i] % A[j] == 0 and int(A[i]/A[j]) in dp:\n                    dp[A[i]] += dp[A[j]] * dp[A[i]/A[j]]\n\n        result = 0\n        for key in dp:\n            result += dp[key]\n\n        return result % (10 ** 9 + 7)", "def prodcount(a):\n    dp =defaultdict(int)\n    a.sort()\n    for i in range(0,len(a)):\n        dp[a[i]] = 1\n        for j in range(i):\n            if a[i]%a[j]==0:\n                if a[i]//a[j] == a[j]:\n                    dp[a[i]] += (dp[a[j]] *dp[a[i]//a[j]])\n                elif dp[a[i]//a[j]]:\n                    dp[a[i]] += (dp[a[j]] *dp[a[i]//a[j]])\n    return sum(dp.values())% (10**9 + 7)\nclass Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        return prodcount(A)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        memo = {}\n        ans = 0\n        A.sort()\n        \n        for i in range(len(A)):\n            localAns = 1\n            for j in range(i, -1, -1):\n                if A[i] / A[j] in memo:\n                    localAns += memo[A[i]/A[j]] * memo[A[j]]\n            ans += localAns\n            memo[A[i]] = localAns\n        return ans % (10 ** 9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        # https://blog.csdn.net/fuxuemingzhu/article/details/83536814\n        A.sort()\n        dp = {}\n        for i, a in enumerate(A):\n            dp[a] = 1\n            for j in range(i):\n                if a % A[j] == 0 and a / A[j] in dp:\n                    dp[a] += dp[A[j]] * dp[a / A[j]]\n                    \n        return sum(dp.values()) % (10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, x: List[int]) -> int:\n        def f(n):\n            if n in dp:return dp[n]\n            ans=0\n            for i in x:\n                if i==n:\n                    ans+=1\n                    break\n                if i>n:break\n                if n%i==0 and n//i in se:\n                    ans+=f(i)*f(n//i)\n            dp[n]=ans\n            return ans   \n        dp={}\n        x.sort()\n        se=set(x)\n        ans=0\n        for i in x:\n            ans+=f(i)\n        return ans%(10**9+7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        mapping = {x: i for i, x in enumerate(A)}\n        maximal = A[-1]\n        N = len(A)\n        ans, MOD = [1] * N, 10 ** 9 + 7\n        for i in range(N):\n            for j in range(i + 1):\n                if A[i] * A[j] in mapping and A[i] * A[j] <= maximal:\n                    if A[i] != A[j]:\n                        ans[mapping[A[i] * A[j]]] += 2 * ans[i] * ans[j]\n                    else:\n                        ans[mapping[A[i] * A[j]]] += ans[i] * ans[j]\n                    ans[mapping[A[i] * A[j]]] %= MOD\n        return sum(ans) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        ret = 0\n        root_value_to_tree_number = collections.defaultdict(int)\n        \n        \n        for i in range(len(A)):\n            occurrences = 1\n            \n            \n            for j in range(i - 1, -1, -1):\n                if (A[i] % A[j] == 0):\n                    required_root_value = A[i] // A[j]\n                    occurrences += root_value_to_tree_number[required_root_value] * root_value_to_tree_number[A[j]]\n                    \n            root_value_to_tree_number[A[i]] = occurrences\n            ret += occurrences\n            \n        return ret % 1000000007         ", "class Solution:\n    def numFactoredBinaryTrees(self, x: List[int]) -> int:\n        def f(n):\n            if n in dp:return dp[n]\n            ans=1\n            for i in x:\n                if i>(n**.5):break\n                if n%i==0 and n//i in se:\n                    ans+=(1 if n//i==i else 2)*f(i)*f(n//i)\n            dp[n]=ans\n            return ans   \n        dp={}\n        x.sort()\n        se=set(x)\n        ans=0\n        for i in x:ans+=f(i)\n        return ans%(10**9+7)\n", "class Solution(object):\n    def numFactoredBinaryTrees(self, A):\n        MOD = 10 ** 9 + 7\n        N = len(A)\n        A.sort()\n        dp = [1] * N\n        index = {x: i for i, x in enumerate(A)}\n        for i, x in enumerate(A):\n            for j in range(i):\n                if x % A[j] == 0: #A[j] will be left child\n                    right = x //A[j]\n                    if right in index:\n                        dp[i] += dp[j] * dp[index[right]]\n                        dp[i] %= MOD\n\n        return sum(dp) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        N, MOD = len(A), 10 ** 9 + 7\n        trees = {}\n        ans = 0\n        A.sort()\n        for i in range(N):\n            trees[A[i]] = 1\n            for j in range(i):\n                factor = A[i]/A[j]\n                if not factor.is_integer():\n                    continue\n                factor = int(factor)\n                if factor in trees:\n                    trees[A[i]] += trees[A[j]]*trees[factor] \n            ans += trees[A[i]] \n        return ans % MOD\n        \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        dp = {n: 1 for n in A}\n        setA = set(A)\n        for i in range(len(A)): # goal\n            target = A[i]\n            for j in range(0, i): # using this as factor\n                factor = A[j]\n                if target%factor == 0:\n                    other_half = target//factor\n                    if other_half in setA:\n                        dp[target] += dp[other_half] * dp[factor]\n        return sum(dp.values())%(10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        n = len(A)\n        nums = set(A)\n        A = sorted(A)\n        counts = collections.defaultdict(int)\n        mod = 10**9+7\n        res = 0\n        for i, num in enumerate(A):\n            for j in range(i):\n                b, c = A[j], num/A[j]\n                if c in nums:\n                    counts[num] += (counts[b]*counts[c])%mod\n            counts[num] += 1\n            res = (res+counts[num])%mod\n        return res", "import math\n\n\nclass Solution:\n    @staticmethod\n    def numFactors(num, A_set):\n        factors = set()\n        for a in A_set:\n            if num < a:\n                continue\n            if num % a == 0 and num // a in A_set:\n                factors.add(a)\n                factors.add(num // a)\n        return factors\n\n    @staticmethod\n    def numFactoredTrees(root, results, A_set):\n        if root in results:\n            return results[root]\n        factors = Solution.numFactors(root, A_set)\n        # tree can only have depth 1 with the root node alone\n        if len(factors) == 0:\n            results[root] = 1\n            return 1\n        # tree can have depth greater than 1\n        n = 1  # depth 1\n        while len(factors) > 0:\n            factor = factors.pop()\n            remainder = root // factor\n            if factor not in results:\n                results[factor] = Solution.numFactoredTrees(factor, results, A_set)\n            if factor == remainder:\n                n += results[factor] * results[factor]\n            else:\n                factors.remove(remainder)\n                if remainder not in results:\n                    results[remainder] = Solution.numFactoredTrees(remainder, results, A_set)\n                n += results[factor] * results[remainder] * 2\n        results[root] = n\n        return n\n\n    def numFactoredBinaryTrees(self, A) -> int:\n        A.sort()\n        A_set = set(A)\n        results = {}\n        return sum([Solution.numFactoredTrees(a, results, A_set) for a in A]) % (10 ** 9 + 7)\n\n", "import math\n\n\nclass Solution:\n    @staticmethod\n    def numFactors(num, A_set):\n        factors = set()\n        for a in A_set:\n            if num % a == 0 and num // a in A_set:\n                factors.add(a)\n                factors.add(num // a)\n        return factors\n\n    @staticmethod\n    def numFactoredTrees(root, results, A_set):\n        if root in results:\n            return results[root]\n        factors = Solution.numFactors(root, A_set)\n        # tree can only have depth 1 with the root node alone\n        if len(factors) == 0:\n            results[root] = 1\n            return 1\n        # tree can have depth greater than 1\n        n = 1  # depth 1\n        while len(factors) > 0:\n            factor = factors.pop()\n            remainder = root // factor\n            if factor not in results:\n                results[factor] = Solution.numFactoredTrees(factor, results, A_set)\n            if factor == remainder:\n                n += results[factor] * results[factor]\n            else:\n                factors.remove(remainder)\n                if remainder not in results:\n                    results[remainder] = Solution.numFactoredTrees(remainder, results, A_set)\n                n += results[factor] * results[remainder] * 2\n        results[root] = n\n        return n\n\n    def numFactoredBinaryTrees(self, A) -> int:\n        #A.sort()\n        A_set = set(A)\n        results = {}\n        return sum([Solution.numFactoredTrees(a, results, A_set) for a in A]) % (10 ** 9 + 7)\n\n", "import math\n\n\nclass Solution:\n    @staticmethod\n    def numFactors(num, A_set):\n        factors = set()\n        for a in A_set:\n            if num % a == 0 and num // a in A_set:\n                factors.add(a)\n                factors.add(num // a)\n        return factors\n\n    @staticmethod\n    def numFactoredTrees(root, results, A_set):\n        if root in results:\n            return results[root]\n        factors = Solution.numFactors(root, A_set)\n        # tree can only have depth 1 with the root node alone\n        if len(factors) == 0:\n            results[root] = 1\n            return 1\n        # tree can have depth greater than 1\n        n = 1  # depth 1\n        while len(factors) > 0:\n            factor = factors.pop()\n            remainder = root // factor\n            if factor not in results:\n                results[factor] = Solution.numFactoredTrees(factor, results, A_set)\n            if factor == remainder:\n                n += results[factor] * results[factor]\n            else:\n                factors.remove(remainder)\n                if remainder not in results:\n                    results[remainder] = Solution.numFactoredTrees(remainder, results, A_set)\n                n += results[factor] * results[remainder] * 2\n        results[root] = n\n        return n\n\n    def numFactoredBinaryTrees(self, A) -> int:\n        A.sort()\n        A_set = set(A)\n        results = {}\n        return sum([Solution.numFactoredTrees(a, results, A_set) for a in A]) % (10 ** 9 + 7)\n\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A = sorted(A)\n        n = len(A)\n        dict_num = {}\n        for num in A:\n            dict_num[num] = True\n        dp_dict = {}\n        factor_pair = []\n        for i in range(n):\n            factor_pair.append([])\n        \n        for i in range(n):\n            for j in range(i):\n                if(A[i] % A[j] == 0 and A[i]//A[j] in dict_num):\n                    factor_pair[i].append((A[j], A[i]//A[j]))\n        # print(factor_pair)\n        for i in range(n):\n            root = A[i]\n            num_trees = 1\n            for a, b in factor_pair[i]:\n                num_trees += dp_dict[a]*dp_dict[b]\n            \n            dp_dict[root] = num_trees\n        \n        answer = 0\n        for key in dp_dict:\n            answer += dp_dict[key]\n            \n        return answer % (10**9+7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        O = {}\n        ans = 0\n        for a in A:\n            if a not in O:\n                O[a] = 1\n            for k, v in list(O.items()):\n                if a % k == 0 and a // k in O:\n                    O[a] += v * O[a // k]\n            ans += O[a]\n        return ans % 1000000007\n", "\n  \nclass Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        \n        n = len(A)\n        tips = sorted(A)\n        \n        \n        index = { x: i for i, x in enumerate(tips) }\n        d = [1] * n\n        \n        for i, x in enumerate(tips):\n            head = x\n\n            for j in range(i):\n                x = tips[j]\n                \n                y = head // x\n                \n                if y*x != head:\n                    continue\n                if y in index:\n                    leaf_1 = j\n                    leaf_2 = index[y]\n                    d[i] = d[i] + (d[leaf_1] * d[leaf_2])\n                    \n        return sum(d) % MOD", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        n = len(A)\n        dp = defaultdict(int)\n        res = 0\n        for i, num in enumerate(A):\n            dp[num] = 1\n            for j in range(i):\n                if num % A[j] == 0:\n                    dp[num] += dp[A[j]] * dp[A[i]//A[j]]\n            res += dp[num]\n        return res % 1000000007\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        seen,A={},set(A)\n        def find_all(root):\n            if root in seen:\n                return seen[root]\n            combs=1\n            for left in A:\n                if root==left or root%left: continue\n                right=root//left\n                if right not in A: continue\n                combs+=find_all(left)*find_all(right)\n            seen[root]=combs\n            return combs\n        return sum(find_all(num) for num in sorted(A))%1000000007", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        mod = 10**9 + 7\n        processed = dict()\n        res = 0\n        for a in sorted(A):\n            counter = 1\n            for key, val in list(processed.items()):\n                key2 = a / key\n                val2 = processed.get(key2, 0)\n                if val2 != 0:\n                    counter = (counter + val * val2) % mod\n            processed[a] = counter\n            res = (res + counter) % mod\n        return res\n            \n            \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        n=len(A)\n        A.sort()\n        dp=[1]*n\n        mod=10**9+7\n        index={c:i for i,c in enumerate(A) }\n        \n        for i,x in enumerate(A):\n            for j in range(n):\n                if x%A[j]==0:\n                    right=x/A[j]\n                    if right in index:\n                        dp[i]+=dp[j]*dp[index[right]]\n                        dp[i]=dp[i]%mod\n        return sum(dp)%mod", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        factorSet = set(A)\n        A.sort()\n        treeCount = {}\n\n        for num in A:\n            count = 1\n            for p, pCount in list(treeCount.items()):\n                q, rem = divmod(num, p)\n                if p > q:\n                    break\n                if rem == 0 and q in treeCount:\n                    count += pCount*treeCount[q] if p == q else 2*pCount*treeCount[q]\n            treeCount[num] = count\n        return sum(treeCount.values()) % (1000_000_000 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        seen,A={},set(A)\n        def find_all(root):\n            if root in seen:\n                return seen[root]\n            combs=1\n            for left in A:\n                if root==left or root%left: continue\n                right=root//left\n                if right not in A: continue\n                combs+=find_all(left)*find_all(right)\n            seen[root]=combs\n            return combs\n        return sum(find_all(num) for num in A)%1000000007", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        dp = {i:1 for i in A}\n        res = 0\n        for idd, number in enumerate(A):\n            \n            for inner, inumber in enumerate(A[:idd]):\n                if number % inumber == 0 and ((number // inumber) in dp):\n                    dp[number] += dp[inumber] * dp[number // inumber]\n            \n            res += dp[number]\n            res = res % (10 ** 9 + 7)\n        \n        return res\n", "# 823. Binary Trees With Factors\n\nMOD = 10**9 + 7\n\ndef count_binary_trees (arr):\n    arr = sorted (arr)\n    coll = set (arr)\n\n    count = {}\n\n    for index, elem in enumerate (arr):\n        ans = 1\n        for i in range (index):\n            factor = arr[i]\n            if elem % factor == 0 and elem // factor in coll:\n                other_factor = elem // factor\n                ans = (ans + count[factor] * count[other_factor]) % MOD\n\n        count[elem] = ans\n\n    return sum (y for (x, y) in count.items ()) % MOD\n\nclass Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        return count_binary_trees(A)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A = sorted(A)\n        mems = {}\n        for ix in range(len(A)):\n            mems[A[ix]] = ix\n            \n        dp = [1] * len(A)\n        \n        big_mod = 10**9 + 7\n        \n        for i in range(len(A)):\n            extras = 0\n            for j in range(i):\n                d, mo = divmod(A[i], A[j])\n                if mo == 0:\n                    if d in mems:\n                        extras += dp[j] * dp[mems[d]]\n                        extras = extras % big_mod\n\n            dp[i] += extras\n        \n        result = sum(dp) % big_mod\n        \n        return result\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        A.sort()\n        dic = {num: 1 for num in A}\n        for i in range(1, len(A)):\n            for j in range(i):\n                q, res = divmod(A[i], A[j])\n                if res == 0 and q in dic:\n                    dic[A[i]] += dic[q] * dic[A[j]]\n\n        return sum(dic.values()) % (10**9 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A = sorted(A)\n        mems = {}\n        for ix in range(len(A)):\n            mems[A[ix]] = ix\n            \n        dp = [1] * len(A)\n        \n        big_mod = 10**9 + 7\n        \n        for i in range(len(A)):\n            extras = 0\n            for j in range(i):\n                d, mo = divmod(A[i], A[j])\n                if mo == 0:\n                    if d in mems:\n                        extras += dp[j] * dp[mems[d]]\n\n            extras = extras % big_mod\n            dp[i] += extras\n        \n        result = sum(dp) % big_mod\n        \n        return result\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        dp = {}\n        mod = 10**9+7\n        for a in A:\n            dp[a] = 1\n            for b in A:\n                if a%b==0 and b in dp and a//b in dp:\n                    dp[a] += dp[b]*dp[a//b]\n                    dp[a] %= mod\n                    \n        return sum(dp.values())%mod", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        sorted_A = sorted(A)\n        dp = dict()\n        result = 0\n        \n        for i in range(len(sorted_A)):\n            cur_total = 0\n            for j in range(i + 1):\n                cur_val = sorted_A[i]\n                prev_val = sorted_A[j]\n                if i == j:\n                    dp[cur_val] = cur_total + 1\n                    result += cur_total + 1\n                elif (cur_val / prev_val) in dp:\n                    cur_total += dp[cur_val/prev_val] * dp[prev_val]\n                        \n        return result % (10 ** 9 + 7)\n                \n        '''\n        \n        \n        [18, 3, 6, 2]\n        [2, 3, 6, 18]\n        dp = {\n            2 : 1\n            3 : 1\n            6 : 3\n            18: 5\n        }\n        cur_val = 18\n        prev_val = 6\n        cur_total = 3 + 1 \n        result = 1 + 1 + 3 + 5\n        \n        \n        '''        \n            \n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        dp = {}\n        for a in sorted(A):\n            dp[a] = sum(dp[b] * dp.get(a/b, 0) for b in dp) + 1\n        return sum(dp.values()) % (10**9 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        ans = 0\n        N = len(A)\n        cnt = [1 for _ in range(N)]\n        for i, n in enumerate(A):\n            l, r = 0, i - 1\n            while r >= l:\n                if A[r] * A[l] == n:\n                    cnt[i] += cnt[r] * cnt[l] if r == l else cnt[r] * cnt[l] * 2\n                    l += 1\n                    r -= 1\n                elif A[r] * A[l] > n:\n                    r -= 1\n                else:\n                    l += 1\n            ans += cnt[i]\n        return ans % (10 ** 9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        factorSet = set(A)\n        A.sort()\n        treeCount = {}\n\n        for num in A:\n            count = 1\n            for p, pCount in list(treeCount.items()):\n                q, rem = divmod(num, p)\n                if rem == 0:\n                    count += pCount * treeCount.get(q, 0) \n            treeCount[num] = count\n        return sum(treeCount.values()) % (1000_000_000 + 7)\n", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        t = {}\n        for a in A:\n            t[a] = 1 + sum(t[b] * t.get(a / b, 0) for b in A if b < a)\n        return sum(t.values()) % (pow(10, 9) + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        t = {}\n        for a in sorted(A):\n            t[a] = 1 + sum(t[b] * t.get(a/b, 0) for b in A if b < a)\n        return sum(t.values()) % (10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A):      \n                \n\n        t = {}\n        for a in sorted(A):\n            t[a] = 1 + sum(t[b] * t.get(a/b, 0) for b in A if b < a)\n        return sum(t.values()) % (10**9 + 7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        mymap = {}\n        for x in sorted(A):\n            # 1 for leaf, plus sum any that could be factors (y and currval/y)\n            mymap[x] = 1+ sum(mymap[y]*mymap.get(x/y,0) for y in A if y<x)\n        return sum(mymap.values())%(10**9+7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        A.sort()\n        n=len(A)\n        dp=[1 for i in range(n)]\n        for i in range(n):\n            start,end=0,i-1\n            while(start<=end):\n                if A[start]*A[end]<A[i]:\n                    start+=1\n                    continue\n                if A[start]*A[end]>A[i]:\n                    end-=1\n                    continue\n                if start==end: \n                    dp[i]+=dp[start]*dp[end]\n                else:\n                     dp[i]+=dp[start]*dp[end]*2\n                start+=1\n                end-=1\n        # print(dp)\n        return sum(dp)%(10**9+7)", "class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        n = len(A)\n        A.sort()\n        dp = [1] * n\n        res = 0\n        for i in range(n):\n            s = 0\n            e = i - 1\n            for s in range(i):\n                while s <= e and A[s] * A[e] > A[i]:\n                    e -= 1\n                    \n                if s > e:\n                    break\n                \n                if A[s] * A[e] == A[i]:\n                    dp[i] += ((dp[s] * dp[e] * 2) if s != e else (dp[s] * dp[e]))\n                    dp[i] = dp[i] % (10 ** 9 + 7)\n                    e -= 1\n                    \n            res += dp[i]\n            res = res % (10 ** 9 + 7)\n        \n        return res\n                    \n"]
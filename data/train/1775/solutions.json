["from itertools import permutations, chain\n\ndef solve_puzzle (clues):\n    size = 4\n    for poss in permutations(permutations(list(range(1, size+1)), size), size):\n        for i in range(size):\n            if len(set(row[i] for row in poss)) < size:\n                break\n        else:\n            cols_top = [[row[i] for row in poss] for i in range(size)]\n            rows_right = [list(reversed(row)) for row in poss]\n            cols_btm = [[row[i] for row in reversed(poss)] for i in reversed(list(range(size)))]\n            rows_left = list(reversed(poss))\n            for i, row in enumerate(chain(cols_top, rows_right, cols_btm, rows_left)):\n                if not clues[i]:\n                    continue\n                visible = 0\n                for j, v in enumerate(row):\n                    visible += v >= max(row[:j+1])\n                if visible != clues[i]:\n                    break\n            else:\n                return poss\n", "from itertools import chain, product\n\n\ndef unique_products(sets, excluding=frozenset()):\n    \"\"\"\n    Calculates cartesian product between the sets passed as parameter, only keeping products with unique numbers.\n    \"\"\"\n    if not sets:\n        yield ()\n        return\n    for x in sets[0] - excluding:\n        for rest in unique_products(sets[1:], excluding | {x}):\n            yield (x,) + rest\n\ndef solve_column(column, clue):\n    # First calculates all valid fillings with the given column, than merges the solutions in a single list where each\n    # cell is the set containing the values in the same position of each solution.\n    # [column=[{1, 2, 3}, {1, 2, 3}, {1, 2}, {4}], clue=2] -> [(3, 1, 2, 4), (3, 2, 1, 4)] -> [{3}, {1, 2}, {1, 2}, {4}]\n    combos = [set(x) for x in list(zip(*[x for x in unique_products(column) if see(x) == clue]))]\n    for i in range(len(column)):\n        column[i] -= column[i] - combos[i]\n\n\ndef see(column):\n    \"\"\"\n    Calculates how many buildings can be viewed.\n    \"\"\"\n    visible = tallest = 0\n    for building in column:\n        visible += building > tallest\n        tallest = max(building, tallest)\n    return visible\n\ndef simplify(column, clue, n):\n    if clue is 1:\n        column[0] -= set(range(1, n))  # the highest building must be in the first cell\n    elif clue > 0:  # if clue is 0 means no hint\n        for i in range(clue - 1):\n            column[i] -= set(range(n, n + i + 1 - clue, -1))\n        solve_column(column, clue)\n\n\ndef solve_cross(city, x, y):\n    \"\"\"\n    Removes from the same row and column the number found at (x, y), if the cell contains only one number.\n    :type city: list of (list of set)\n    \"\"\"\n    if len(city[x][y]) is not 1:\n        solve_uniqueness(city, x, y)\n        return\n    for i in chain(range(x), range(x + 1, len(city))):\n        city[i][y] -= city[x][y]\n    for j in chain(range(y), range(y + 1, len(city))):\n        city[x][j] -= city[x][y]\n\n\ndef solve_uniqueness(city, x, y):\n    \"\"\"\n    Checks if one of the numbers in the cell city[x][y] compares only once in the same row / column.\n    \"\"\"\n    for n in city[x][y]:  # checks if a number appears only once in the row / column\n        if not any([n in city[i][y] for i in chain(range(x), range(x + 1, len(city)))]) or \\\n                not any([n in city[x][j] for j in chain(range(y), range(y + 1, len(city)))]):\n            city[x][y].clear()\n            city[x][y].add(n)\n            solve_cross(city, x, y)\n            break\n\n\ndef solve(n, clues):\n    city = list(list(set(range(1, n + 1)) for i in range(n)) for j in range(n))\n    while not all([len(cell) is 1 for row in city for cell in row]):\n        for i in range(n):\n            for j in range(n):\n                simplify([city[k][j] for k in range(n)], clues[i * n + j], n)\n            for s in range(n):\n                for t in range(n):\n                    solve_cross(city, s, t)\n            city = [list(row) for row in reversed(list(zip(*city)))]  # rotates the city 90\u00b0 anti-clockwise\n    return tuple(tuple(cell.pop() for cell in row) for row in city)\n    \nsolve_puzzle = lambda x: solve(4, x)", "import numpy as np\n\n#check if n appears more than once in array\ndef duped(l):\n    for e in l:\n        if l.count(e) > 1:\n            return True\n    return False\n\n#find empty square to place number\ndef find_empty(city):\n    for r in range(4):\n        for c in range(4):\n            if city[r][c]==0:\n                return (r,c)\n            \n#check if clue works with n of skycrapers seen\ndef check_clue(clue,counter):\n    if clue==0:\n        return True\n    return counter==clue\n\n#check how many skyscrapers can be seen and if they are ok with clues          \ndef vis(arr,clues):\n    l=len(arr)\n    a1=0\n    a2=0\n    counter1=0\n    counter2=0\n    #count skycrapers visible from the two sides\n    for k in range(l):\n        if arr[k]>a1:\n            a1=arr[k]\n            counter1+=1\n        if arr[l-k-1]>a2:\n            a2=arr[l-k-1]\n            counter2+=1\n    #if the arr is not filled yet can't count the clues\n    if l<4:\n        return True\n    #check the clues\n    return check_clue( clues[0] , counter1 ) and check_clue( clues[1] , counter2 )\n        \n#check if a n placed is ok with all the clues           \ndef is_valid(r,c,city,clues):\n    #row and column\n    row=[ h for h in city[r] if h!=0]\n    col=[r[c] for r in city if r[c]!=0]\n    #if numbers are duplicate return\n    if duped(row) or duped(col):\n        return False\n    #top right bottom left clues\n    tc,rc,bc,lc = [clues[k][c] if k%2==0 else clues[k][r] for k in range(4)]\n    #check if all clues work\n    return vis(row,(lc,rc)) and vis(col,(tc,bc))\n    \n#recursive function\ndef solve(city,clues):\n    #find position of empty square\n    pos = find_empty(city)\n    #if there is no empty square then it's solved\n    if not pos:\n        return True\n    #row and column\n    r,c=pos\n    #all numbers that you can put in a 4x4\n    for n in range(1,5):\n        #put number in city\n        city[r][c] = n\n        #check if it's good\n        if is_valid(r,c,city,clues):\n            #recursion trigger\n            if solve(city,clues):\n                return True\n        #delete number if it doesn't work cause of backtracking or just not valid\n        city[r][c] = 0\n    #if no possible solution :\n    return False\n    \n#initial function\ndef solve_puzzle (clues):\n    #list of clues with the last 2 reversed to make indexing easy\n    clues = [list(clues[k:k+4]) if k < 5 else list(reversed(clues[k:k+4])) for k in range(0,13,4)] #top right bottom left\n    #initialize city matrix\n    city=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n    #solve\n    solve(city,clues)\n    return tuple([tuple(a) for a in city])\n", "from itertools import permutations,chain\nfrom math import factorial\n\ndef num_visible(row):\n    visible = 0\n    max_height = 0\n    for i in row:\n        if i > max_height:\n            visible = visible + 1\n            max_height = i\n    return visible\n            \n\ndef check_solution(solution,clues):\n\n    solution = list(solution)\n    solution = list(chain.from_iterable(solution))\n    \n    front_facing_key = {\n    0:[0,4,8,12], 1:[1,5,9,13], 2:[2,6,10,14], 3:[3,7,11,15], 4:[3,2,1,0], 5:[7,6,5,4],\n    6:[11,10,9,8],7:[15,14,13,12], 8:[15,11,7,3], 9:[14,10,6,2], 10:[13,9,5,1],\n    11:[12,8,4,0], 12:[12,13,14,15], 13:[8,9,10,11], 14:[4,5,6,7], 15:[0,1,2,3]}\n    \n    front_facing_values = {\n    0:[0,0,0,0], 1:[0,0,0,0], 2:[0,0,0,0], 3:[0,0,0,0], 4:[0,0,0,0], 5:[0,0,0,0],\n    6:[0,0,0,0], 7:[0,0,0,0], 8:[0,0,0,0], 9:[0,0,0,0], 10:[0,0,0,0], 11:[0,0,0,0],\n    12:[0,0,0,0], 13:[0,0,0,0], 14:[0,0,0,0],15:[0,0,0,0],}\n    \n    f_len = len(front_facing_values)\n    \n    for i in range(f_len):\n        for j in range(4):\n            front_facing_values[i][j] = solution[front_facing_key[i][j]]\n    \n    for i in range(f_len):\n        if num_visible(front_facing_values[i]) != clues[i] and clues[i] !=0:\n            return False\n    return True\n            \ndef solve_puzzle (clues):\n    \n    counter = 1\n    for i in list(permutations([1,2,3,4])):\n        for j in list(permutations([1,2,3,4])):\n            for k in list(permutations([1,2,3,4])):\n                for l in list(permutations([1,2,3,4])):\n                    solution = (i,j,k,l)\n                    \n                    trip = False\n                    for m in range(4):\n                        test = [i[m],j[m],k[m],l[m]]\n                        if len(set(test)) !=4:\n                            trip = True\n                    if trip == False:\n                        if(check_solution(solution,clues)):\n                            return solution\n                \n    return \"No Solution\"\n", "N = 4\n\n\ndef count(lst):\n    l = 0\n    c = 0\n    for v in lst:\n        if v > l:\n            l = v\n            c += 1\n    return c\n\n\ndef check_clues(clues, curr_soln):\n    visible = []\n    for j in range(N):\n        c = count([curr_soln[i][j] for i in range(N)])\n        visible.append(c)\n    for i in range(N):\n        c = count([curr_soln[i][j] for j in range(N-1, -1, -1)])\n        visible.append(c)\n    for j in range(N-1, -1, -1):\n        c = count([curr_soln[i][j] for i in range(N-1, -1, -1)])\n        visible.append(c)\n    for i in range(N-1, -1, -1):\n        c = count([curr_soln[i][j] for j in range(N)])\n        visible.append(c)\n    for viz, clue in zip(visible, clues):\n        if clue != 0:\n            if viz != clue:\n                return False\n    return True\n\n\ndef r_solve_puzzle(clues, curr_soln, col_avail, row_avail, i, j):\n    if i == N:\n        if check_clues(clues, curr_soln):\n            return tuple(tuple(row) for row in curr_soln)\n        else:\n            return None\n    ni = i+1 if j == N-1 else i\n    nj = 0 if j == N-1 else j+1\n    for v in range(1, N+1):\n        if v in col_avail[j] and v in row_avail[i]:\n            col_avail[j].remove(v)\n            row_avail[i].remove(v)\n            curr_soln[i][j] = v\n            res = r_solve_puzzle(clues, curr_soln, col_avail, row_avail, ni, nj)\n            curr_soln[i][j] = 0\n            col_avail[j].add(v)\n            row_avail[i].add(v)\n            if res is not None:\n                return res\n\n\ndef solve_puzzle (clues):\n    curr_soln = [[0 for j in range(N)] for i in range(N)]\n    col_avail = [set(range(1, N+1)) for i in range(N)]\n    row_avail = [set(range(1, N+1)) for i in range(N)]\n    return r_solve_puzzle(clues, curr_soln, col_avail, row_avail, 0, 0)\n", "import itertools as it\n\nrows = tuple (it.permutations (list(range(1,5))))\n\nvisibles = [{r:reduce (lambda (m,s),e: (e,1+s) if e > m else (m,s), r,       (r[ 0],1))[1] for r in rows},\n            {r:reduce (lambda (m,s),e: (e,1+s) if e > m else (m,s), r[::-1], (r[-1],1))[1] for r in rows}]\n\ndef matches (puzzle, clues):\n    return (    all (clues[15-i] == visibles[0][      puzzle [i]] for i in range(4) if clues[15-i] > 0)\n            and all (clues[ 4+i] == visibles[1][      puzzle [i]] for i in range(4) if clues[ 4+i] > 0)\n            and all (clues[   i] == visibles[0][list(zip(*puzzle))[i]] for i in range(4) if clues[   i] > 0)\n            and all (clues[11-i] == visibles[1][list(zip(*puzzle))[i]] for i in range(4) if clues[11-i] > 0))\n\ndef valid (puzzle):\n    return all (r in rows for r in zip (*puzzle))\n\ndef solve_puzzle (clues):\n    return next (puzzle for puzzle in it.product (rows, repeat=4) if valid (puzzle) and matches (puzzle, clues))\n", "#Solving the grid can be broken down into the following main steps:\n#1) Using the outside view to remove certain options or place known numbers\n#2) Look for block that only has one remaining option (step repeated each time grid is adjusted)\n#3) Look for lines with two blocks with restriction of two same options remove these options for other blocks in line\n#3) Look for lines with 2 blocks remaining. Create 2 options from these and compare to the view from both sides\n\n#Practical routes taken:\n#1)gridComplete is an array used to indicate if number was placed or not. This helps confirm if number is \"placed\" or just last remaining option. As when it is placed the same number needs to be removed from line and adjacent line\n#2)Clues where placed into array with pairs horizonal and vertical. So that the can be looped and assigned easily\n\nimport numpy as np\n\ndef solve_puzzle (clues):\n    \n    nonlocal grid\n    grid = np.array([(\"1234\",\"1234\",\"1234\",\"1234\"),(\"1234\",\"1234\",\"1234\",\"1234\"),(\"1234\",\"1234\",\"1234\",\"1234\"),(\"1234\",\"1234\",\"1234\",\"1234\")])\n    \n    nonlocal gridComplete\n    gridComplete = np.array([(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0)])\n    \n    nonlocal cluesN\n    cluesN = list(map(str,clues))\n    clues = list(map(str,clues))\n    \n    nonlocal hor\n    nonlocal vert\n    hor = [(clues[0]+clues[11]),(clues[1]+clues[10]),(clues[2]+clues[9]),(clues[3]+clues[8])]\n    vert =[(clues[15]+clues[4]),(clues[14]+clues[5]),(clues[13]+clues[6]),(clues[12]+clues[7])]\n    \n#1) Removing known options and placing according to view and standard practise\n#----------------------------------------------------------------------------\n    #1: M1:\n    #    -1 place 4\n    #    -4 place 1234\n    #    -2V remove [1] 3\n    #    -2V remove [0] 4\n    #    -3V remove [0] 3\n    \n    #M1 - 4 place 1234\n    for z in range(len(cluesN)):\n        if cluesN[z] == \"4\" and z<=3:\n            placeNum(1,0,z, check = False)\n            placeNum(2,1,z, check = False)\n            placeNum(3,2,z, check = False)\n            placeNum(4,3,z, check = False)\n        elif cluesN[z] ==\"4\" and 4 <= z <= 7:\n            placeNum(1,z-4,3, check = False) \n            placeNum(2,z-4,2, check = False)\n            placeNum(3,z-4,1, check = False)\n            placeNum(4,z-4,0, check = False)\n        elif cluesN[z] == \"4\" and 8 <= z <= 11:\n            placeNum(1,3,11-z, check = False)  # changed this from placeNum(4,11-z,3)\n            placeNum(2,2,11-z, check = False)\n            placeNum(3,1,11-z, check = False)\n            placeNum(4,0,11-z, check = False)\n        elif cluesN[z] == \"4\" and 12 <= z <= 15:\n            placeNum(1,15-z,0, check = False)\n            placeNum(2,15-z,1, check = False)\n            placeNum(3,15-z,2, check = False)\n            placeNum(4,15-z,3, check = False)\n            \n        #M1 - 1 place 4\n        if cluesN[z] == \"1\" and z<=3:\n            placeNum(4,0,z, check = False)\n        elif cluesN[z] ==\"1\" and 4 <= z <= 7:\n            placeNum(4,z-4,3, check = False) \n        elif cluesN[z] == \"1\" and 8 <= z <= 11:\n            placeNum(4,3,11-z, check = False) \n        elif cluesN[z] == \"1\" and 12 <= z <= 15:\n            placeNum(4,15-z,0, check = False)\n\n    #M1 - 2v remove[1] 3 \n    removeM1(2,1,3)\n    \n    #M1 - 2V remove [0] 4\n    removeM1(2,0,4)\n    \n    #M1 - 3V remove [0] 3\n    removeM1(3,0,3)\n    \n#-------------------------------------------------------------------\n    \n#2) - Check if any single options are left in a cell\n    lookforsingle()\n    \n#3) - look for any paired options in a line and remove that pair from other cells\n    double2()\n\n#4) look for 2 cells left in line and create 2 options and compare to view\n    lookforspace2() #one direction\n    lookforspace2REV() #Reverse direction\n    \n    #Convert string to int in list for return\n    grid = grid.astype(np.integer)\n    #Return truple answer\n    return tuple(map(tuple, grid))\n\ndef lookforspace2():\n    \n    #Look for 2 unknown cells calculate options and compare to view\n    \n    first = True\n    first2 = True\n    for y in range(4):\n        view = vert[y][0]   #VIEW on left\n        view1 = hor[y][0]   #VIEW from top\n        lstOption1 = np.copy(grid[y])\n        lstOption2 = np.copy(grid[y])\n        lstVertOption1 = np.copy(grid[::,y])\n        lstVertOption2 = np.copy(grid[::,y])\n        \n        for x in range(4):\n            \n            #horizontal check\n            if len(str(lstOption1[x])) == 2:\n    \n                #remove first paired number and then the next remove second\n                if first == True: \n                    optionPair = str(lstOption1[x])\n                    lstOption2[x] = (str(lstOption2[x])).replace(str(optionPair[0]),\"\") \n                    lstOption1[x] = (str(lstOption1[x])).replace(str(optionPair[1]),\"\")\n                    first = False\n                elif first == False: \n                    lstOption1[x] = str(lstOption1[x]).replace(optionPair[0],\"\")\n                    lstOption2[x] = str(lstOption2[x]).replace(optionPair[1],\"\")\n                    first = True\n                \n            #Vertical check\n            if len(str(lstVertOption1[x])) == 2:\n    \n                #remove first paired number and then the next remove second\n                if first2 == True: \n                    optionPair2 = str(lstVertOption1[x])\n                    lstVertOption2[x] = (str(lstVertOption2[x])).replace(str(optionPair2[0]),\"\") \n                    lstVertOption1[x] = (str(lstVertOption1[x])).replace(str(optionPair2[1]),\"\")\n                    first2 = False\n                elif first2 == False: \n                    lstVertOption1[x] = str(lstVertOption1[x]).replace(optionPair2[0],\"\")\n                    lstVertOption2[x] = str(lstVertOption2[x]).replace(optionPair2[1],\"\")\n                    first2 = True\n        \n        #calculate the view of each option\n        calc1 = viewCalc(lstOption1.tolist())   \n        calc2 = viewCalc(lstOption2.tolist())\n        calc3 = viewCalc(lstVertOption1.tolist())\n        calc4 = viewCalc(lstVertOption2.tolist())\n        \n        #if option correct then place option in grid\n        if int(calc3) == int(view1) and int(calc3) != int(calc4):\n            grid[::,y] = lstVertOption1\n                #place answer\n        elif int(calc4) == int(view1) and int(calc3) != int(calc4):\n            grid[::,y] = lstVertOption2\n        \n        if int(calc1) == int(view) and int(calc1) != int(calc2):\n            grid[y] = lstOption1\n                #place answer\n        elif int(calc2) == int(view) and int(calc1) != int(calc2):\n            grid[y] = lstOption2\n    \n    lookforsingle() #clear out placed numbers from adjacent lines\n\ndef lookforspace2REV():\n    \n    #Look for 2 unknown cells calculate options and compare to view\n    #Reversed direction\n    \n    first = True\n    first2 = True\n    for y in range(4):\n        view = vert[y][1]   #VIEW on right\n        view1 = hor[y][1]   #VIEW from bottom\n        lstOption1 = (np.copy(grid[y]))[::-1]\n        lstOption2 = (np.copy(grid[y]))[::-1]\n        lstVertOption1 = (np.copy(grid[::,y]))[::-1]\n        lstVertOption2 = (np.copy(grid[::,y]))[::-1]\n        \n        for x in range(4):\n            \n            if len(str(lstOption1[x])) == 2:\n    \n                #remove first and then the next remove second\n                if first == True: \n                    optionPair = str(lstOption1[x])\n                    lstOption2[x] = (str(lstOption2[x])).replace(str(optionPair[0]),\"\") \n                    lstOption1[x] = (str(lstOption1[x])).replace(str(optionPair[1]),\"\")\n                    first = False\n                elif first == False: \n                    lstOption1[x] = str(lstOption1[x]).replace(optionPair[0],\"\")\n                    lstOption2[x] = str(lstOption2[x]).replace(optionPair[1],\"\")\n                    first = True\n                \n            if len(str(lstVertOption1[x])) == 2:\n    \n                #remove first and then the next remove second\n                if first2 == True: \n                    optionPair2 = str(lstVertOption1[x])\n                    lstVertOption2[x] = (str(lstVertOption2[x])).replace(str(optionPair2[0]),\"\") \n                    lstVertOption1[x] = (str(lstVertOption1[x])).replace(str(optionPair2[1]),\"\")\n                    first2 = False\n                elif first2 == False: \n                    lstVertOption1[x] = str(lstVertOption1[x]).replace(optionPair2[0],\"\")\n                    lstVertOption2[x] = str(lstVertOption2[x]).replace(optionPair2[1],\"\")\n                    first2 = True\n        \n        calc1 = viewCalc(lstOption1.tolist())   #grid list row\n        calc2 = viewCalc(lstOption2.tolist())\n        calc3 = viewCalc(lstVertOption1.tolist())\n        calc4 = viewCalc(lstVertOption2.tolist())\n        \n        if int(calc3) == int(view1) and int(calc3) != int(calc4):\n            grid[::,y] = lstVertOption1[::-1]\n        elif int(calc4) == int(view1) and int(calc3) != int(calc4):\n            grid[::,y] = lstVertOption2[::-1]\n        \n        if int(calc1) == int(view) and int(calc1) != int(calc2):\n            grid[y] = lstOption1[::-1]\n        elif int(calc2) == int(view) and int(calc1) != int(calc2):\n            grid[y] = lstOption2[::-1]\n            \n    \n    lookforsingle()\n\n\n    \ndef removeM1(viewpos, coord, removeNum):\n    \n    #Given a coordinate as location from the viewpos (viewpoint outside of grid linked to clues)\n    #remove the option(removeNum) from the list\n    \n    lstCord = []\n    for z in range(len(cluesN)):\n        if cluesN[z] == str(viewpos):\n            if z <= 3: lstCord = [coord,z]\n            if 4 <= z <= 7: lstCord = [z-4,3-coord] \n            if 8 <= z <= 11: lstCord = [3-coord,11-z] \n            if 12 <= z <= 15: lstCord = [15-z,coord] \n            \n            grid[lstCord[0]][lstCord[1]] = str(grid[lstCord[0]][lstCord[1]]).replace(str(removeNum),\"\")\n    \n        \ndef double2():\n    \n    #look for two pairs in line and remove from other options in adjacent lines\n    \n    dbl = False\n    for y in range(4):\n        for x in range(4):\n            lst = gridComplete.sum(axis = 1)\n            if len(grid[y][x]) == 2:\n                for x2 in range(x+1,4):\n                    if grid[y][x] == grid[y][x2]:\n                        \n                        for g in range(4):\n                            try:\n                                if len(str(grid[y][g])) > 1 and str(grid[y][g]) !=  grid[y][x2]: #already they are equal and checked that is 2\n                                    grid[y][x2]= str(grid[y][x2]).replace((str(grid[y][x]))[0],\"\")\n                                    dbl = True\n                            except:\n                                pass\n                            try:\n                                if len(str(grid[y][g])) > 1 and str(grid[y][g]) !=  grid[y][x2]: \n                                    grid[y][x2]= str(grid[y][x2]).replace((str(grid[y][x]))[1],\"\")\n                                    dbl = True\n                            except:\n                                pass\n                            \n    if dbl == True:\n        lookforsingle()\n        double2()\n    \ndef lookforsingle():\n    #Look for single option in cell or where only one occurance of that option in line and place it\n    count = 0\n    pos = []\n    placed = False\n    posC = np.array([(0,0),(0,0),(0,0),(0,0)])\n    countC=[0,0,0,0]\n    for p in range(1,5):\n        for a in range(4):\n            if placed == False: \n                for o in range(4):\n                    if str(p) in str(grid[a][o]) and len(str(grid[a][o])) > 1 and gridComplete[a][o] == 0:\n                        count += 1\n                        countC[a] = countC[a] + 1\n                        posC[a] = [a,o]\n                        pos = [a,o]\n                        \n                    elif len(str(grid[a][o])) == 1 and gridComplete[a][o] == 0:\n                        placeNum(str(grid[a][o]), a, o,check = False)\n                        placed = True\n                        break\n        \n                if count == 1 and placed == False:\n                    placeNum(p, pos[0], pos[1], check = False)\n                    placed = True\n                    break\n                count == 0\n        \n        #coloumb single occurances\n        for u in range(4):\n            if placed == True: \n                break\n            if countC[u] == 1:\n                placeNum(p,posC[u][0],posC[u][1], check = False)\n                placed = True\n                \n        countC = [0,0,0,0]\n    \n    if placed == True: lookforsingle()\n        \n    \n\ndef viewCalc(lstCalc): #provide a list of 4 integers\n    \n    #return the a calculation of amount of building can be seen from list\n    \n    prev = 0\n    count = 0\n    for i in range(4):\n        if int(lstCalc[i]) > prev:\n            count += 1\n            prev = int(lstCalc[i])\n    return count\n        \ndef placeNum(num ,ypos, xpos, check = True):\n\n    #places given number in coordinates of grid and then removes these options from\n    #adjacent lines.\n    #after which can be checked for single options left or not checked for placements to continue before checking\n    \n    for y in range(4):\n        try:\n            if len(str(grid[ypos][y])) > 1: grid[ypos][y]= str(grid[ypos][y]).replace(str(num),\"\") \n        except:\n            pass\n        try:\n            if len(str(grid[y][xpos])) > 1: grid[y][xpos]= str(grid[y][xpos]).replace(str(num),\"\")\n        except:\n            pass\n            \n    grid[ypos][xpos] = num\n    gridComplete[ypos][xpos] = 1\n    if check == True:lookforsingle()\n"]
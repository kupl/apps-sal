["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(x).count('1') for x in nums)+len(bin(max(nums)))-3\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        add_count = sum(bin(v).count('1') for v in nums)\n        mul_count = len(bin(max(nums))) - 3\n        \n        return add_count + mul_count\n    \n    def minOperations_my(self, nums: List[int]) -> int:\n        add_sum = mul_maxi = 0\n        for value in nums:\n            c1 = c2 = 0\n            while value > 1:\n                if value & 1:\n                    c1 += 1\n                c2 += 1\n                value >>= 1\n            \n            add_sum += c1 + value\n            mul_maxi = max(mul_maxi, c2)\n        \n        return add_sum + mul_maxi\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n#         The number of operation 0 equals to the total number of bits \\\"1\\\".\n#         The number of operation 1 equals to maximum bit length - 1.\n        \n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 3\n        \n        # notfinish = True\n        # count = 0\n        # while notfinish:\n        #     notfinish = False \n        #     for i,n in enumerate(nums):\n        #         if n%2:\n        #             nums[i] = (nums[i]-1)//2\n        #             count += 1\n        #             if nums[i]>0:\n        #                 notfinish = True\n        #         elif nums[i]>0:\n        #             nums[i] = nums[i]//2\n        #             notfinish = True\n        #     if notfinish:\n        #         count += 1\n        #     print(nums,count)\n        # return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        #make every element 1\n        m = [bin(x)[2:].zfill(32) for x in nums]\n        ret = 0\n        #print(m)\n        for i in range(32):\n            #looking at the first digit. how many of you have it set to 1?\n            cnts = sum([1 if x[i] == '1' else 0 for x in m])\n            #print(\\\"%d: %d\\\" % (i, cnts))\n            ret += cnts\n            if ret > 0:\n                ret += 1\n                pass\n            pass\n        return ret - 1\n        #first, remove \n", "class Solution:\n    def minOperations(self, a: List[int]) -> int:\n        ans=0\n        mx=0\n        for x in a:\n            cnt=0\n            while x:\n                if x%2:\n                    ans+=1\n                cnt+=1\n                x//=2\n            mx=max(mx,cnt)\n        # print(ans,mx)\n        return max(ans+mx-1,0)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def highestBit(x):\n            i = 0\n            while x:\n                i += 1\n                x = x >> 1\n            return i\n        def numberOfBits(x):\n            i = 0\n            while x:\n                i += 1\n                x = x & (x-1)\n            return i\n        doublings = max(map(highestBit,nums))\n        print(doublings)\n        adds = sum(map(numberOfBits,nums))\n        print(adds)\n        return doublings-1 + adds", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        max_num = 0\n        \n        for n in nums:\n            max_num = max(max_num, n)\n            while n > 0:\n                # drop lowest bit\n                n = n & (n - 1)\n                ops += 1\n        \n        while max_num > 1:\n            max_num >>= 1\n            ops += 1\n        \n        return ops\n", "class Solution:\n    def minOperations_1(self, nums: List[int]) -> int:\n        '''        \n        Instead of trying to go from 0 array to nums,\n        go from nums to 0 array, decrement index by 1\n        divide all elements by 2 if divisible by 2\n        \n        Nevermind this isn't DP, do greedy, divide by\n        2 as much as possible then decrement indexes by 1\n        \n        Repeat until everything is divisble by 2 again\n        \n        Runtime?\n        \n        O(3n) inner loop, 32 times outer loop because\n        divison by 2 happens frequently which shifts\n        '''\n        ops = 0\n        while not all(n == 0 for n in nums):\n            for i, n in enumerate(nums):\n                if n % 2 != 0:\n                    nums[i] = n - 1\n                    ops += 1\n            \n            if all(n == 0 for n in nums):\n                break\n            \n            nums = [n // 2 for n in nums]\n            ops += 1\n        \n        return ops\n    \n    def minOperations_2(self, nums: List[int]) -> int:\n        '''\n        More efficient way to do this:\n        \n        Loop through the numbers individually, count\n        the number of times you have to subtract 1 and divide\n        by 2. Add 1's to total but only take the maximum number\n        of times to divide by 2 since division affects everything\n        and so only the largest number of divisions gets taken\n        into account\n        \n             24 2 5 \n        \n        ones  2 1 2\n        \n        twos  4 1 2\n        \n        5 + max(twos) = 9\n        '''\n        op_1 = 0\n        op_2 = 0\n        for n in nums:\n            op_2_cur = 0\n            while n > 0:\n                if n % 2 != 0:\n                    op_1 += 1\n                    n -= 1\n                else:\n                    op_2_cur += 1\n                    n = n // 2\n            \n            op_2 = max(op_2, op_2_cur)\n        \n        return op_1 + op_2\n    \n    \n    def minOperations(self, nums: List[int]) -> int:\n        '''\n        Bit Manipulation Solution (Most Efficient)\n        \n        Multiplying by 2 is equivalent to bit shift to left by 1\n        Likewise divide by 2 is equivalent to bit shift to right by 1\n        \n        Using this knowledge, the highest leftmost bit will determine\n        how many divide by 2 operations we have to perform\n        \n        24\n        \n        11000 => 4 operations\n        \n        The number of 1's in the number determine the number of 1 operations\n        to perform\n        \n        24\n        11000 => 2 operations\n        \n        We loop from bit to bit to avoid the max comparison operation\n        \n        O(32n) Time, O(1) Space\n        \n        -----------------------------------------\n        \n        (n & (1 << i)) != 0\n        \n        Gets bit at index i in the number\n\n        Ex. Get index 4\n\n          4 3 2 1 0\n\n          1 1 0 0 0\n        & 1 0 0 0 0\n        -----------\n          1 0 0 0 0\n\n        Final result not 0 so index 4 must've been a 1\n        \n          4 3 2 1 0\n\n          0 1 0 0 0\n        & 1 0 0 0 0\n        -----------\n          0 0 0 0 0\n          \n        If index 4 was 0 then result would be all 0's\n        '''\n        op1 = 0\n        op2 = 0\n        for i in range(31):\n            for n in nums:\n                if (n & (1 << i)) != 0:\n                    op1 += 1\n                    op2 = i\n        \n        return op1 + op2\n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        addOneOperations = 0 # +1 operations\n        highestSetBit = 0 # *2 operations\n        for bit in range(31):\n            for num in nums:\n                if num & (1 << bit) != 0:\n                    addOneOperations += 1\n                    highestSetBit = bit\n        return addOneOperations + highestSetBit\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if nums == [0]: return 0\n        count = 0\n        max_bits = 0\n        for n in nums:\n            bits = 0 \n            while n:\n                count += n & 1\n                bits += 1\n                n >>= 1\n            max_bits = max(max_bits, bits)\n        return count + max_bits - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        add_sum = mul_maxi = 0\n        for value in nums:\n            c1 = c2 = 0\n            while value > 1:\n                if value & 1:\n                    c1 += 1\n                c2 += 1\n                value >>= 1\n            \n            add_sum += c1 + value\n            mul_maxi = max(mul_maxi, c2)\n        \n        return add_sum + mul_maxi\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        hb = 0\n        ans = 0\n        for n in nums:\n            for i in range(32):\n                if n&(1<<i):\n                    ans+=1\n                    if i>hb:\n                        hb = i\n        return ans+hb", "import collections\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        sum = 0\n        for num in nums:\n            sum += collections.Counter(bin(num))['1']\n            \n        sum += len(bin(max(nums))) - 3\n        return sum\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def n1b(x):\n            ans = 0\n            while x:\n                x &= (x-1)\n                ans += 1\n            return ans\n        \n        def hi(x):\n            ans = 0\n            while x:\n                x >>= 1\n                ans += 1\n            return ans\n        \n        maxshift = 0\n        tog = 0\n        for n in nums:\n            maxshift = max(maxshift, hi(n))\n            tog += n1b(n)\n        \n        maxshift = max(0, maxshift-1)\n        return maxshift + tog", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        x = [0]*len(nums)\n        counts = 0\n        while(1):\n            counts += sum(n%2 for n in nums)\n            nums = [n//2 for n in nums]\n            if (nums == x):\n                return counts\n            counts += 1\n            \n                    \n                    \n        \n        \n        \n        \n        \n        \n        def div(l):\n            for i in range(len(l)):\n                    if (sum(l)==0):\n                        return None\n                    l[i] *= 2\n            return l\n        \n        \n        def mi(l):\n            for i in range(len(l)):\n                    l[i] += 1\n            return l\n        \n        \n        q = deque()\n        \n        q.append([0]*len(nums))\n        d = 0;\n        while q:\n            d+=1\n            for i in range(len(q)):\n                x  = q.popleft()\n                j = x.copy()\n                print(x)\n                if (x == nums):\n                    return d;\n                y=  div(j)\n                if (y != None):\n                    q.append(y)\n                q.append(mi(x))\n            \n            \n            \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        a = m = 0\n        for i in nums:\n            a += bin(i).count('1')\n            m = max(m, len(bin(i)) - 3)\n        return a + m", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        max_half_ops = 0\n\n        def find_odd_ops_req(num):\n          nonlocal max_half_ops\n          result = 0\n          half_ops = 0\n          while(num):\n            result += num & 1\n            half_ops += 1\n            num = num >> 1\n          max_half_ops = max(max_half_ops, half_ops - 1)\n          return result\n          \n        result = 0\n        for num in nums:\n          result += find_odd_ops_req(num)\n        return result + max_half_ops\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if nums == [0]:\n            return 0\n        count = 0\n        max_bits = 0\n        for n in nums:\n            bits = 0\n            while n:\n                count += n & 1\n                bits += 1\n                n >>= 1\n            max_bits = max(max_bits, bits)\n        return count + max_bits - 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n_add, n_mul = 0, 0\n        for num in nums:\n            c_mul = 0\n            while num > 1:\n                n_add += num % 2\n                num //= 2\n                c_mul += 1\n            if num == 1:\n                n_add += 1\n            n_mul = max(n_mul, c_mul)\n        return n_add + n_mul\n                \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        return sum(bin(x).count('1') for x in nums) + len(bin(max(nums))) - 3\n        \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op_0, op_1 = 0, 1\n        for num in nums:\n            b_len = 0\n            while num:\n                op_0 += num & 1\n                num >>= 1\n                b_len += 1\n            op_1 = max(op_1, b_len)\n        return op_0 + op_1 - 1\n    \n                \n                \n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # 4,2,5->2,1,2->2,0,2->1,0,1\n        # 1,5->1,4->1,2->1,1\n        # 2,4,8,16->1,2,4,4->\n        count = max([int(math.log(x)/math.log(2)) for x in nums if x > 0])\n        for n in nums:\n            while (n):\n                if n % 2:\n                    count += 1\n                    n -= 1\n                else:\n                    n //= 2\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        maxTwos = 0\n        ones = 0\n        for num in nums:\n            count, left = self.getCount(num)\n            maxTwos = max(maxTwos, count)\n            ones += left\n        return ones + maxTwos\n    \n    def getCount(self, num):\n        count = 0\n        odd = num % 2\n        if num % 2 == 1:\n            num -= 1\n        while num > 1:\n            odd += num % 2\n            num //= 2\n            count += 1\n        return count, num + odd", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans, largest = 0, 0\n        for num in nums:\n            largest = max(largest, num)\n            while num > 0:\n                if num % 2 == 1:\n                    num -= 1\n                    ans += 1\n                if num > 0:\n                    num = num // 2\n        while largest > 1:\n            ans += 1\n            largest = largest // 2\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2: # odd number, just delete 1 so that it's now a multiple of 2\n                    n -= 1\n                    ones += 1\n                else: # multiple of 2, so just divide by 2 \n                    n //= 2\n                    mul += 1\n            twos = max(twos, mul)\n        return ones + twos", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2:\n                    n -= 1\n                    ones += 1\n                else:\n                    n //= 2\n                    mul += 1\n            twos = max(twos, mul)\n        return ones + twos", "class Solution:\n  def minOperations(self, nums: List[int]) -> int:\n    # TC: O(NlogM), SC: O(1), n = len(nums), m = max(nums)\n    def numOperations(x):\n      # TC: O(logX)\n      n1, n2 = 0, 0\n      while x:\n        if x & 1:\n          n1 += 1\n          x -= 1\n        else:\n          n2 += 1\n          x //= 2\n      return n1, n2\n    # operation -1 is self, //2 is shared.\n    n1, n2 = 0, 0\n    for x in nums:\n      x1, x2 = numOperations(x)\n      n1 += x1\n      n2 = max(n2, x2)\n    return n1 + n2", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ones = 0\n        twoes = 0\n        \n        for i in nums:\n            c = 0\n            while i:\n                if i%2:\n                    i-=1\n                    ones+=1\n                else:\n                    i //=2\n                    c+=1\n            twoes = max(twoes,c)\n            \n        return ones+twoes\n                \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def operate(n):\n            max_ = 0\n            ans = 0\n            k = 0\n            while n>0:\n                k += 1\n                ans += n%2\n                n = n//2\n            max_ = max(max_,k-1)\n            return max_, ans\n        \n        ans = 0\n        max_ = 0\n        for n in nums:\n            m, o = operate(n)\n            #print(m,n,o)\n            max_ = max(max_,m)\n            ans += o\n            \n        return ans+max_", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        maxTwos = 0\n        totalOnes = 0\n        for num in nums:\n            twos, ones = self.getCount(num)\n            maxTwos = max(maxTwos, twos)\n            totalOnes += ones\n        return totalOnes + maxTwos\n    \n    def getCount(self, num):\n        twos = 0\n        ones = 0\n        while num > 1:\n            ones += num % 2\n            num //= 2\n            twos += 1\n        return twos, ones + num\n    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # number of operation 1 (multiply by 2) is the length of bin(num)\n        # number of operation 0 (increment by 1) is the number of 1 in bin(num)\n        return sum(bin(num).count('1') for num in nums) + len(bin(max(nums))) - 3 # why 3, bin() function return a string leading by 0b10= => 4", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        totOddRem = 0\n        max2Power = 0\n        for x in nums:\n            pow2 = 0\n            while True:\n                totOddRem += x & 1\n                if x > 1:\n                    pow2 += 1\n                    x >>= 1\n                else:\n                    break\n            if pow2 > max2Power:\n                max2Power = pow2\n        return totOddRem + max2Power", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            ans += sum(n % 2 for n in nums)\n            if any(n > 1 for n in nums):\n                ans += 1\n            for i in range(len(nums)):\n                nums[i] //= 2\n        return ans\n                \n                \n                    \n        \n                \n            \n            \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        maxLmove, bitCount = 0,0\n        for num in nums:\n            if num == 0:\n                continue\n            Lmove = 0\n            while num != 0:\n                if num&1:\n                    bitCount += 1\n                num = num >> 1\n                if num != 0:\n                    Lmove += 1\n            maxLmove = max(maxLmove, Lmove)\n        return maxLmove + bitCount", "class Solution:\n    # mine\n    def minOperations0(self, nums: List[int]) -> int:        \n        l = len(nums)\n        ans = 0\n        \n        def turnEven():\n            nonlocal ans\n            for i in range(l):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n                    \n        def countZero():\n            count = 0\n            for n in nums:\n                if n == 0:\n                    count += 1\n            return count                    \n                \n        while True:\n            turnEven()\n            if countZero() == l:\n                return ans\n            for i in range(l):\n                nums[i] //= 2\n            ans += 1\n                \n    # copied https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/discuss/805740/JavaC%2B%2BPython-Bit-Counts\n    # \u5176\u5b9e\u601d\u8def\u8ddf\u4e0a\u9762\u662f\u4e00\u6837\u7684\n    def minOperations(self, nums: List[int]) -> int: \n            res = 0\n            maxLen = 1\n            for n in nums:\n                bits = 0\n                while n > 0:\n                    res += n & 1\n                    bits += 1\n                    n >>= 1\n                maxLen = max(maxLen, bits)\n            return res + maxLen - 1\n                \n", "class Solution:\n  def minOperations(self, nums: List[int]) -> int:\n    # TC: O(NlogM), SC: O(1), n = len(nums), m = max(nums)\n    def numOperations(x):\n      # TC: O(logX)\n      n1, n2 = 0, 0\n      while x:\n        if x & 1:\n          n1 += 1\n          x -= 1\n        else:\n          n2 += 1\n          x >>= 1\n      return n1, n2\n    # operation -1 is self, //2 is shared.\n    n1, n2 = 0, 0\n    for x in nums:\n      x1, x2 = numOperations(x)\n      n1 += x1\n      n2 = max(n2, x2)\n    return n1 + n2", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        totOddRem = 0\n        max2Power = 0\n        \n        for x in nums:\n            pow2 = 0\n            while True:\n                totOddRem += x & 1\n                if x > 1:\n                    pow2 += 1\n                    x >>= 1\n                else:\n                    break\n                \n            max2Power = max(max2Power, pow2)\n                \n        \n        \n        \n        \n        return totOddRem + max2Power", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        maxi = 0\n        for num in nums:\n            res += 1 if num > 0 else 0\n            div = 0\n            while num > 1:\n                res += 1 if num%2 else 0\n                num //= 2\n                div += 1\n            maxi = max(div, maxi)\n        return res+maxi", "\n\ndef val(n):\n    c = 0\n    while(n>1):\n        if n%2 == 1:\n            c +=1\n            n -=1\n        else:\n            n = n//2\n            # c += 1\n    return c\n\ndef ma(n):\n    c = 0\n    while(n>1):\n        if n%2 == 1:\n            # c +=1\n            n -=1\n        else:\n            n = n//2\n            c += 1\n    return c\n\nclass Solution:\n    def minOperations(self, n: List[int]) -> int:\n        c = ma(max(n))\n        \n        for i in range(len(n)):\n            if n[i]>0:\n                c += val(n[i])+1\n        \n        return c", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2:\n                    n-=1\n                    ones+=1\n                else:\n                    n//=2\n                    mul+=1\n            twos = max(twos, mul)\n        return ones + twos\n\n        \n# class Solution:\n#     def minOperations(self, nums: List[int]) -> int:\n#         twos = 0\n#         ones = 0\n#         for n in nums:\n#             mul = 0\n#             while n:\n#                 if n%2: # odd number, just delete 1 so that it's now a multiple of 2\n#                     n -= 1\n#                     ones += 1\n#                 else: # multiple of 2, so just divide by 2 \n#                     n //= 2\n#                     mul += 1\n#             twos = max(twos, mul)\n#         return ones + twos\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        #m = max(nums)\n        highest_bit = 0\n        addone = 0\n        for num in nums:\n            tmp = -1\n            while num > 0:\n                addone += num & 1\n                num >>= 1\n                tmp += 1\n            highest_bit = max(highest_bit, tmp)\n        return highest_bit + addone\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # find number of set bits in all numbers\n        # find offset of highest number\n        if max(nums) == 0: return 0\n        return sum(map(lambda x: bin(x).count('1'), nums)) + int(log2(max(nums)))", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op0 = 0\n        op1 = 0\n        for n in nums:\n            l = 0\n            while n > 0:\n                l += 1\n                if n % 2 == 1: op0 += 1\n                n //= 2\n            op1 = max(op1, l-1)\n        return op0 + op1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            ans += sum(num % 2 for num in nums)\n            if any(num > 1 for num in nums):\n                ans += 1\n            for i in range(len(nums)):\n                nums[i] //= 2\n        return ans\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        two,one = 0,0\n        for n in nums:\n            mul = 0\n            while n :\n                if  n%2 :\n                    one += 1\n                    n -= 1\n                else:\n                    mul += 1\n                    n //= 2 \n            two = max(two,mul)\n        return one+two\n\n    # @lru_cache(None)\n    # def minOperations(self, nums: List[int]) -> int:\n    #     return 0\n    #     return self.helper(nums,-1,-1)\n    # def helper(self, nums: List[int],op ,idx ) -> int:\n    #     if op == 0:\n    #         nums[idx] += 1\n    #     elif op == 1:\n    #         for i in range(len(nums)):\n    #             nums[i] *= 2\n    #     print(min([min(self.helper(nums,0,i),self.helper(nums,1,-1)) for i in range(len(nums))]))\n    #     # return min([min(self.minOperations(nums,0,i),self.minOperations(nums,1,-1)) for i in range(len(nums))])\n    #     return 0\n\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        mx = 1\n        ops = 0\n        for nm in nums:\n            bt = 0\n            while nm > 0:\n                ops += (nm & 1)\n                bt +=1\n                nm = (nm >> 1)\n            mx = max(mx, bt)\n        return ops + mx - 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2:\n                    n-=1\n                    ones+=1\n                else:\n                    n//=2\n                    mul +=1\n            twos = max(twos, mul)\n        return ones+twos\n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def ops(num):\n            plus = 0\n            mult = 0\n            while num:\n                if num % 2:\n                    plus += 1\n                    num -= 1\n                else:\n                    num //= 2\n                    mult +=1\n            return plus, mult\n    \n        plus = 0\n        mult = 0\n        for num in nums:\n            plus_, mult_ = ops(num)\n            plus += plus_\n            mult = max(mult, mult_)\n        return plus + mult\n                \n           \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        total = 0\n        currentMax = 0\n        for n in nums:\n            if n == 0:\n                continue \n            total += 1\n            count = 0\n            while n > 1:\n                if n % 2 == 1:\n                    n -= 1\n                    total += 1\n                n = n //2\n                count += 1\n            \n            currentMax = max(count, currentMax)\n        return total + currentMax\n            \n                \n        \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def calculate(num):\n            temp1=0\n            temp2=0\n            while num:\n                if num%2:\n                    temp1+=1\n                    num-=1\n                else:\n                    temp2+=1\n                    num>>=1\n            \n            return temp1,temp2\n                \n        \n        \n        \n        \n        ones,twos=0,0\n        for val in nums:\n            if val:\n                a,b=calculate(val)\n                ones+=a\n                twos=max(twos,b)\n        print(ones)\n        return ones+twos\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            ans += sum(n % 2 for n in nums)\n            if any(n > 1 for n in nums):\n                ans += 1\n            for i in range(len(nums)):\n                nums[i] //= 2\n        return ans     \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        total = 0\n        currentMax = 0\n        for n in nums:\n            if n == 0:\n                continue \n            total += 1\n            count = 0\n            if n % 2 == 1 and n > 1:\n                total += 1\n                n -= 1\n            while n > 1:\n                if n % 2 == 1:\n                    n -= 1\n                    total += 1\n                n = n //2\n                count += 1\n                #print(f\\\"count{count} n{n}\\\")\n            \n            currentMax = max(count, currentMax)\n        #print(f\\\"currentMax : {currentMax} total {total}\\\")\n        return total + currentMax\n            \n                \n        \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            ans += sum(n % 2 for n in nums) #Count of the +1 ops\n            if any(n > 1 for n in nums): #Count of the mul by 2 ops\n                ans += 1\n            for i in range(len(nums)):\n                nums[i] //= 2\n        return ans", "class Solution:\n    \n    def calc(self, num):\n        m=0\n        a=0\n        while num>0:\n            if num&1:\n                a+=1\n                num-=1\n            else:\n                num=num>>1\n                m+=1\n        return a,m\n    def minOperations(self, nums: List[int]) -> int:\n        adds=0\n        mults=0\n        for i in range(len(nums)):\n            a,m = self.calc(nums[i])\n            if mults<m:\n                mults=m\n            adds+=a\n        \n        return mults+adds", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cache = defaultdict(int)\n        for i in nums:\n            for ind, j in enumerate(bin(i)[2:][::-1]):\n                if j == '1':\n                    cache[ind] += 1\n        return sum(cache.values()) + max(cache.keys())\n        # result = 0\n        # max_digit = max(cache.keys())\n        # for i in range(max_digit + 1):\n        #     result += cache[i] + 1\n        # return result - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op = 0\n        s = sum(nums)\n        while (s):\n            odd_ct = len([0 for n in nums if (n & 1)])\n            op += odd_ct\n            s -= odd_ct\n            if s != 0:\n                nums = [n//2 for n in nums]\n                op += 1\n                s /= 2\n        return op", "from collections import Counter\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        max_doubles = 0\n        increments = 0\n\n        counts = Counter(nums)\n        for n, c in counts.items():\n            if n == 0:\n                continue\n            doubles = 0\n            while n:\n                if n % 2 == 1: # odd\n                    increments += c\n                    n -= 1\n                else:\n                    doubles += 1\n                    n //= 2\n            max_doubles = max(max_doubles, doubles)\n\n        return increments + max_doubles", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        div_arr,sub_arr=[],[]\n        \n        for n in nums:\n            div=0\n            sub=0\n               \n            while n:\n                \n                if n%2==1:\n                    n-=1\n                    sub+=1\n                else:\n                    n=n//2\n                    div+=1\n                    \n            sub_arr.append(sub)\n            div_arr.append(div)\n            \n            \n        #print(sub_arr,div_arr)\n        \n        return max(div_arr) + sum(sub_arr) \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        \n        while any(n > 0 for n in nums):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    count += 1\n            if all(n == 0 for n in nums):\n                break\n            nums = [n // 2 for n in nums]\n            count += 1\n        \n        return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def countBit(num) :\n            count, highbit = 0, 0\n            while num > 0:\n                highbit += 1\n                if num % 2 == 1:\n                    count +=  1\n                num //= 2\n            return count, highbit\n                \n            \n        nums = sorted(nums)\n        last={}\n        sum = 0\n        maxDouble = 0\n        for num in nums:\n            if num == 0 :\n                continue\n            elif num in last:\n                sum += last[num]\n            else:\n                count, highbit = countBit(num)\n                maxDouble = max(maxDouble, highbit)\n                sum += count\n                last = {num: count}\n        \n        print (sum, maxDouble)\n        if maxDouble == 0:\n            return 0\n        return sum + maxDouble - 1", "import math\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ones,co,twos = 0,0,0\n        for xx in nums:\n            x,c = 0,0\n            while xx > 1:\n                co += xx&1\n                xx //= 2\n                c += 1\n            x = int(floor(math.log(max(xx,1),2)))\n            twos = max(twos,x+c)\n            ones += max((xx-2**x),0)\n            if xx >= 1:\n                ones += 1\n        return ones + twos + co\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums); res = 0\n        while any(v > 0 for v in nums):\n            for i, v in enumerate(nums):\n                if v & 1:\n                    res += 1\n                nums[i] >>= 1\n            res += 1\n        return res - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        multi_max = 0\n        answer = 0\n        for num in nums:\n            cur_multi = 0\n            while(num):\n                if num % 2 == 1:\n                    answer += 1\n                    num -= 1\n                else:\n                    cur_multi += 1\n                    num //= 2\n            multi_max = max(multi_max, cur_multi)\n        return answer + multi_max\n        # answer = 0\n        # max_num = 0\n        # for num in nums:\n        #     small = int(math.log(num, 2))\n        #     max_num = max(small, max_num)\n        #     answer += num - 2**small + 1\n        # print(max_num)\n        # return answer + max_num\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        ans, nxt = 0, []\n        for num in nums:\n            if num & 1:\n                num -= 1\n                ans += 1\n            if num:\n                nxt.append(num // 2)\n        if nxt:\n            ans += 1\n        # print(ans, nxt)\n        return ans + self.minOperations(nxt)\n    \n                \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n_add = 0\n        n_mul = 0\n        for n in nums:\n            mul = 0\n            while n > 0:\n                if n % 2:\n                    n -= 1\n                    n_add += 1\n                else:\n                    mul += 1\n                    n //= 2\n            n_mul = max(n_mul, mul)\n        return n_add + n_mul", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        count = 0\n        res = 0\n        double = 0\n        \n        for i in nums:\n            count = 0\n            while i:\n                if i%2 == 1:\n                    i-=1\n                    res+=1\n                else:\n                    i//=2\n                    count+=1\n            double= max(double, count)\n        \n        return res+double", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ones=0\n        maxlen=0\n        binlen=0\n        for num in nums:\n            binlen=0\n            while num!=0:\n                if num%2!=0:\n                    ones+=1\n                    num-=1\n                    \n                if num!=0:\n                    num//=2\n                    binlen+=1\n            maxlen=max(maxlen,binlen)\n            \n        return maxlen+ones\n        \n        \n#         op=0\n#         sum1=sum(nums)\n#         while sum1!=0:\n#             for i in range(len(nums)):\n#                 if nums[i]%2!=0:\n#                     nums[i]-=1\n#                     sum1-=1\n#                     op+=1\n                    \n#             if sum1==0:\n#                 return op\n            \n#             for i in range(len(nums)):\n#                 nums[i]//=2\n#             op+=1\n#             sum1/=2\n            \n#         return op\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        num = max(nums)\n        res = 0\n\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n                \n            res += 1\n            num = nums[i]\n            while num > 1:\n                res += num % 2\n                num //= 2\n    \n        c = 0\n        num = max(nums)\n        while num > 1:\n            num //= 2\n            res += 1\n        return res\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def calc(num):\n            tmp = 1\n            ans = [0, 0]\n            count = 0\n            while tmp <= num:\n                if (tmp&num) != 0:\n                    ans[0] += 1\n                count += 1\n                tmp <<= 1\n            ans[1] = count-1\n            return ans\n        result = 0\n        tt = 0\n        for num in nums:\n            r = calc(num)\n            result += r[0]\n            tt = max(tt, r[1])\n        result += tt\n        return result", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        maxt = 0\n        for i in nums:\n            if i == 0: continue\n            t = 0\n            while i > 0:\n                if i & 1:\n                    i -= 1\n                    ans += 1\n                else:\n                    i >>= 1\n                    t += 1\n            maxt = max(maxt, t)\n        ans += maxt\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        result = 0\n        max_len = 0\n        for num in nums:\n            b = bin(num)\n            result += b.count('1')\n            max_len = max(max_len, len(b))\n        return result + max_len - 3", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        doubles = 0\n        incs = 0\n        \n        for num in nums:\n            numDoubles = 0\n            while num > 0:\n                if num%2 == 0:\n                    num //= 2\n                    numDoubles += 1\n                else:\n                    num -= 1\n                    incs += 1\n            doubles = max(doubles, numDoubles)\n        \n    \n        return doubles + incs", "class Solution:\n    def minOpsSingle(self, x):\n        n_inc = 0\n        n_db = 0\n        assert(x >= 0)\n        while x > 0:\n            if x % 2 == 0:\n                x = x // 2\n                n_db += 1\n            else:\n                x -= 1\n                n_inc += 1\n        return (n_inc, n_db)\n    \n    def minOperations(self, nums: List[int]) -> int:\n        tot_inc = 0\n        tot_db = 0\n        for n in nums:\n            x,y = self.minOpsSingle(n)\n            tot_inc += x\n            tot_db = max(tot_db, y)\n        return tot_inc + tot_db", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while not all(ele < 2 for ele in nums):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    count += 1\n                    \n                nums[i] //= 2\n            count += 1\n            \n        count += sum(ele == 1 for ele in nums)\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # this is a bit operation question\n        # trick is to realize that largest number is number of * 2 operations\n        \n        multiply = 0 \n        add = 0 \n        \n        for num in nums:\n            mask = 1\n            for i in range(32):\n                if mask << i & num:\n                    multiply = max(i, multiply)\n                    add += 1 \n                    \n        return multiply + add ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # this is a bit operation question\n        # trick is to realize that largest number is number of * 2 operations\n        \n        multiply = 0 \n        add = 0 \n        \n        for num in nums:\n            mask = 1\n            for i in range(31):\n                if mask << i & num:\n                    multiply = max(i, multiply)\n                    add += 1 \n                    \n        return multiply + add ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        while True:\n            zeros = 0\n            ans += 1\n            for i, num in enumerate(nums):\n                nums[i] = num // 2\n                ans += num % 2\n                if not nums[i]:\n                    zeros += 1\n            if zeros == n:\n                break\n        return ans - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def calcOps(num):\n            one = 0\n            two = 0\n            while num > 0:\n                if num%2 == 0:\n                    num//=2\n                    two+=1\n                else:\n                    num-=1\n                    one+=1\n            return [one, two]\n        \n        one = 0\n        two = 0\n        for x in nums:\n            ops = calcOps(x)\n            one += ops[0]\n            two = max(two, ops[1])\n        return one+two", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        move = 0\n        while max(nums) > 0:\n            for i,num in enumerate(nums):\n                if num%2 == 1:\n                    move += 1\n                nums[i] = num//2\n            if max(nums) > 0:\n                move += 1\n        return move\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while any(x != 0 for x in nums):\n            for i, x in enumerate(nums):\n                if x % 2 != 0:\n                    nums[i] -= 1\n                    res += 1\n            if sum(nums) == 0: break\n            nums = [x // 2 for x in nums]\n            res += 1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def all_zeros(nums):\n            for num in nums:\n                if num != 0:\n                    return False\n            return True\n        \n        def to_all_evens(nums):\n            cnt = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 != 0:\n                    cnt += 1\n                    nums[i] -= 1\n            return cnt\n            \n        op_cnt = 0\n        while not all_zeros(nums):\n            op_cnt += to_all_evens(nums)\n            if not all_zeros(nums):\n                nums = [x // 2 for x in nums]\n                op_cnt += 1\n        return op_cnt", "class Solution:\n    def minOperations(self, a: List[int]) -> int:        \n        ans, max_len = 0, 0\n        for i, x in enumerate(a):\n            b = bin(x)\n            ans += b.count('1')         \n            max_len = max(max_len, len(b)-2)\n        return ans + max_len - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # Greedy\n        res = 0\n        max_len = 0\n        for x in nums:\n            bit = 0\n            while x > 0:\n                if x % 2 == 1:\n                    res += 1\n                x >>= 1\n                bit += 1\n            \n            max_len = max(max_len, bit)\n\n        return res + max_len - 1\n        \n        \n        \n        # TLE\n#         n = len(nums)\n#         arr = [0] * n\n#         self.memo = {}\n#         self.helper(nums)\n#         # print(self.memo)\n#         return self.memo[tuple(nums)]\n    \n#     def helper(self, nums):\n#         if sum(nums) == 0:\n#             return 0\n#         if tuple(nums) in self.memo:\n#             return self.memo[tuple(nums)]\n        \n#         need = sys.maxsize\n#         for i in range(len(nums)):\n#             if nums[i] - 1 >= 0:\n#                 nums[i] -= 1\n#                 need = min(need, self.helper(nums))\n#                 nums[i] += 1\n                \n        \n#         all_even = True\n#         for x in nums:\n#             if x % 2 != 0:\n#                 all_even = False\n#         if all_even:\n#             temp = [x // 2 for x in nums]\n#             need = min(need, self.helper(temp))\n            \n#         res = 1 + need\n#         self.memo[tuple(nums)] = res\n#         return res\n", "class Solution:\n        \n    def minOperations(self, nums: List[int]) -> int:\n        \n        # we need to find out the maximum number of multiplications we need to do\n        # how many mul will be required for largest number\n        # all other muls can be arranged during the course\n        # for ones, just need to make all odd numbers even\n        # in every iteration\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2:\n                    n -=1\n                    ones+=1\n                else:\n                    n = int(n/2)\n                    mul +=1\n            twos = max(twos,mul)\n        \n        return ones + twos\n        \n              \n                    \n        \n", "class Solution: \n    def minOperations(self, nums: List[int]) -> int:\n        cnt = 0\n        max_val, max_index = -1, len(nums)\n        for i in range(len(nums)):\n            if nums[i] > max_val:\n                max_val = nums[i]\n                max_index = i\n\n        while(max_val != 0):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    cnt += 1\n            max_val = nums[max_index]\n            if max_val == 0:\n                break\n            for i in range(len(nums)):\n                nums[i] = nums[i] // 2\n            cnt += 1\n            max_val = nums[max_index]\n        return cnt \n            \n                \n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cnt1 = 0 \n        maxcnt0 = 0\n        for n in nums:\n            cnt0 = 0\n            while n > 0:\n                if n % 2 == 1:\n                    n -= 1\n                    cnt1 += 1\n                else:\n                    n //= 2\n                    cnt0 += 1\n            maxcnt0 = max(cnt0, maxcnt0)\n\n        return maxcnt0 + cnt1", "import math\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        arr = nums.copy()\n        count = result = 0\n        \n        while any(arr):\n            \n            for i, n in enumerate(arr):\n                if n & 1:\n                    count += 1\n                    arr[i] -= 1\n                    \n            result += count\n            arr = [x >> 1 for x in arr]\n            count = 0\n        \n        return result + int(math.log2(max(nums)))", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        c = 0\n        while True:\n            c0 = 0\n            for i in range(len(nums)):\n                \n                if nums[i]%2 == 1:\n                    c+=1\n                    nums[i] = (nums[i]-1)//2\n                    \n                else:\n                    nums[i] = nums[i]//2\n                    \n                if nums[i]==0:\n                    c0+=1\n                \n            if c0==len(nums):\n                return c\n            else:\n                c+=1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def iter_count(x):\n            shift_count = sub_count = 0\n            \n            while x > 0:\n                if x&1: \n                    x -= 1\n                    sub_count += 1\n                else:   \n                    x >>= 1\n                    shift_count += 1\n\n            return (shift_count, sub_count)\n        \n        max_shift_count = 0\n        total_subs = 0\n        \n        for x in nums:\n            i, j = iter_count(x)\n            max_shift_count = max(max_shift_count, i)\n            total_subs += j\n        \n        return max_shift_count + total_subs", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count_of_one_steps = 0\n        count_of_half_steps = 0\n        for i in nums:\n            one_steps = 0\n            half_steps = 0\n            while i != 0:\n                if i %2 == 0:\n                    half_steps += 1\n                    i //= 2\n                else:\n                    one_steps += 1\n                    i -= 1\n            #print(i, one_steps, half_steps)\n            count_of_one_steps += one_steps\n            count_of_half_steps = max(count_of_half_steps, half_steps)\n        return count_of_one_steps + count_of_half_steps     ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def countcall(x,c):\n            c0 = 0\n            for i in range(len(x)):\n                if x[i]%2==1:\n                    c+=1\n                    x[i] = (x[i]-1)//2\n                else:\n                    x[i] = x[i]//2\n                    \n                if x[i]==0:\n                    c0+=1\n                    \n            if c0==len(x):\n                return c\n            else:\n                c+=1\n                return countcall(x,c)\n        \n                \n        return countcall(nums,0)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while True:\n            for i, x in enumerate(nums):\n                if x % 2 != 0:\n                    nums[i] -= 1\n                    res += 1\n            if sum(nums) == 0: break\n            nums = [x // 2 for x in nums]\n            res += 1\n            if sum(nums) == 0: break\n\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        x, y = 0, 0\n        for num in nums:\n            num = format(num, 'b')\n            x += num.count('1')\n            y = max(y, len(num) - 1)\n        \n        return x + y", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        '''\n        nums = [1,5]\n        \n        1 -> 1\n\n        5 -> \n             ^^^\n        3 + 3 - 1 = 5\n        '''\n        if nums == [0]:\n            return 0\n        count = 0\n        max_bits = 0\n        for n in nums:\n            bits = 0\n            while n:\n                count += n & 1\n                bits += 1\n                n >>= 1\n            max_bits = max(max_bits, bits)\n        return count + max_bits - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def check(n):\n            N_minus_one = 0\n            N_div2 = 0\n            while n>0:\n                if n%2==0:\n                    n = n//2\n                    N_div2 += 1\n                else:\n                    n -= 1\n                    N_minus_one += 1\n            return N_minus_one,  N_div2\n                \n        \n        N = len(nums)\n        minus_one = []\n        div2 = []\n        for n in nums:\n            N_minus_one, N_div2 = check(n)\n            minus_one.append(N_minus_one)\n            div2.append(N_div2)\n            \n        res = sum(minus_one)\n        res += max(div2)\n        print (minus_one)\n        print (div2)\n        return res\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # After having implemented minOperations_dumb_solution(), we realize that \n        # the number of op 1 we'll need to do is just the number of times we need\n        # to divide the max even number we ever encounter to get it down to zero. \n        # Because, a division would reduce everyone by 2 and when the smaller even\n        # numbers we see gets down to zero, it will no longer be affected. We only care\n        # about dividing the biggest even number down to zero.\n        cost = 0\n        max_nb_op_1 = 0\n        for i in range(len(nums)):\n            nb_op_0 = nb_op_1 = 0\n            x = nums[i]\n            while x > 0:\n                if x % 2 != 0:\n                    nb_op_0 += x % 2\n                    x -= x % 2\n                if x > 0:\n                    nb_op_1 += 1\n                    x = x // 2\n            cost += nb_op_0\n            max_nb_op_1 = max(max_nb_op_1, nb_op_1)\n        cost += max_nb_op_1\n        return cost\n        \n                \n                    \n        \n    def minOperations_dumb_solution(self, nums: List[int]) -> int:\n\n        # Key insight is if nums[i] is odd, there's no way we could have arrived at nums[i]\n        # via op 1, i.e. by multiplying by 2 some previous value. So the only way we could\n        # have gotten here is by using op 0, nums[i] % 2 times. That is we need to skim off\n        # the remainder part that makes it non-even before we can consider using op 1.\n        cost = 0\n        while True:\n            all_zeros = True\n            all_evens = True\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                \n                all_zeros = False\n                if nums[i] % 2 != 0:\n                    cost += nums[i] % 2\n                    nums[i] = nums[i] - (nums[i] % 2)\n                    all_evens = False\n            \n            if all_zeros:\n                break\n            while all_evens:\n                for i in range(len(nums)):\n                    nums[i] = nums[i] // 2\n                    if nums[i] % 2 != 0:\n                        all_evens = False\n                cost += 1\n                \n        return cost\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        one = 0\n        two = 0\n        for n in nums:\n            r = self.onetwo(n)\n            one += r[0]\n            two = max(two, r[1])\n        return one + two\n    def onetwo(self, n):\n        one = 0\n        two = 0\n        while n != 0:\n            if n%2 == 0:\n                two += 1\n                n >>= 1\n            else:\n                one += 1\n                n -= 1\n        return (one, two)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # Backwards!!!!\n        # Change nums to arr\n        \n        step = 0\n        \n        while True:\n            for i in range(len(nums)):\n                if nums[i]%2 != 0:\n                    nums[i] = nums[i] - 1\n                    step += 1\n                nums[i] = nums[i]//2\n            if sum(nums) == 0:\n                return step\n            step += 1\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ones = 0\n        doubles = 0\n        while(sum(nums)!=0):\n            for i in range(len(nums)):\n                if(nums[i]%2!=0):\n                    nums[i]-=1\n                    ones+=1\n                    \n            if(sum(nums)!=0):\n                for i in range(len(nums)):\n                    nums[i] = nums[i]//2\n                doubles+=1\n                \n        return ones+doubles\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while any(nums):\n            for i in range(len(nums)):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    count += 1\n            if any(nums):\n                for i in range(len(nums)):\n                    nums[i] //= 2\n                count += 1\n        return count\n", "class Solution:\n    def getPow(self, n: int) -> Tuple[int, int]:\n        if n == 0:\n            return (0, -1)\n        if n == 1:\n            return (1, 0)\n        \n        inc = 0\n        mul = 0\n        i = n\n        while i != 0:\n            if i % 2 == 1:\n                inc += 1\n                i = i - 1\n            else:\n                i = i // 2\n                mul += 1\n        return (inc, mul)\n\n    def minOperations(self, nums: List[int]) -> int:\n        pows = [self.getPow(n) for n in nums]\n        \n        num_incs = 0\n        num_mults = 0\n        \n        max_pow = 0\n        \n        for i in range(0, len(nums)):\n            if nums[i] == 0:\n                continue\n            if nums[i] == 1:\n                num_incs += 1\n            else:\n                inc = pows[i][0]\n                power = pows[i][1]\n                num_incs += inc\n                if power > max_pow:\n                    max_pow = power\n                    \n        num_incs += max_pow\n        return num_incs\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(x).count('1') for x in nums) + len(bin(max(nums))) - 3", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cnt = 0\n        if self.check(nums):\n            return cnt\n        while not self.check(nums):\n            for i in range(len(nums)):\n                cnt += nums[i] % 2\n            cnt += 1\n            self.divide2(nums)\n        return cnt - 1\n    \n    def check(self, nums):\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                return False\n        return True\n    \n    def divide2(self, nums):\n        for i in range(len(nums)):\n            nums[i] //= 2", "class Solution: \n    def minOperations(self, nums: List[int]) -> int:\n        cnt = 0\n        max_val, max_index = -1, len(nums)\n        for i in range(len(nums)):\n            if nums[i] > max_val:\n                max_val = nums[i]\n                max_index = i\n\n        while(max_val != 0):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    cnt += 1\n            max_val = nums[max_index]\n            # print(nums, max_val)\n            if max_val == 0:\n                break\n            for i in range(len(nums)):\n                nums[i] = nums[i] // 2\n            cnt += 1\n            max_val = nums[max_index]\n            # print(nums, max_val)\n        return cnt \n            \n                \n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def fun_call(num,mem):\n            if not mem.get(num) is None:\n                return mem[num]\n            add=0\n            mul=0\n            old_num=num\n            while(num>0):\n                if num%2==0:\n                    num//=2\n                    mul+=1\n                else:\n                    num-=1\n                    add+=1\n            mem[old_num]=(add,mul)\n            return mem[old_num]\n        \n        res=0\n        mul_max=0\n        mem={0:(0,0)}\n        for i in range(len(nums)):\n            add,mul=fun_call(nums[i],mem)\n            res+=add\n            mul_max=max(mul_max,mul)\n        res+=mul_max\n        return res\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        '''\n        nums = [1,5]\n        1\n        5 -> 101\n        3 + 3 - 1 = 5\n        '''\n        if nums == [0]:\n            return 0\n        count = 0\n        max_bits = 0\n        for n in nums:\n            bits = 0\n            while n:\n                count += n & 1\n                bits += 1\n                n >>= 1\n            max_bits = max(max_bits, bits)\n        return count + max_bits - 1\n", "class Solution:\n    def toZero(self,n):\n        extra = 0\n        pwr2 = 0\n        while n > 0:\n            if n%2:\n                n-=1\n                extra += 1\n            else:\n                n = n/2\n                pwr2 += 1\n        return [extra,pwr2]\n    def minOperations(self, nums: List[int]) -> int:\n        maxPwr2 = 0\n        extras = 0\n        for n in nums:\n            a = self.toZero(n)\n            maxPwr2 = max(maxPwr2,a[1])\n            extras += a[0]\n        return extras+maxPwr2", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        while any(nums):\n            for i in range(n):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    count += 1\n            if any(nums):\n                for i in range(n):\n                    nums[i] //= 2\n                count += 1\n        return count\n                    \n                \n           \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        mask = 2 ** 32 - 2\n        for _ in range(32):\n            end = True\n            for i, x in enumerate(nums):\n                res += x & 1\n                nums[i] >>= 1\n                if nums[i]:\n                    end = False\n            if end:\n                break\n            res += 1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # rearrange the list into even number only\n        # then perform divided by 2 operation \n        # recursively do this and return when it becomes [0...]\n        count = 0\n        for i in range(len(nums)):\n            if nums[i]%2!=0 and nums[i]>0:\n                count+=1\n                nums[i]-=1\n        if nums==[0]*len(nums):\n            return count\n        nums = [i//2 for i in nums]\n        return count + self.minOperations(nums)+1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while True:\n            for i, num in enumerate(nums):\n                if num % 2:\n                    nums[i] -= 1\n                    count += 1\n            \n            if sum(nums) == 0:\n                return count\n            \n            for i in range(len(nums)):\n                nums[i] //= 2\n            count += 1", "import math \n\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        plus_one = times_two = 0\n        for idx, num in enumerate(nums):\n            two = 0 \n            while num:\n                if num == 1:\n                    plus_one += 1 \n                    break\n                if num%2:\n                    plus_one += 1\n                    num -= 1\n                num = num // 2\n                two += 1\n            times_two = max(times_two, two)\n        return plus_one + times_two\n        \n#         1 * 2\n#         1 * 2 * 2\n#         1 * 2 * 2 * 2\n#         1 * 2 * 2 * 2 * 2\n        \n#         2^x = 16\n#         xln(2) = ln(16)\n        \n#         x = ln(n) / ln(2)\n        \n        \n#         18 \n        \n#         0 -> 1\n#         1 -> 2 \n#         2 -> 4\n#         4 -> 8\n#         8 -> 9\n#         9 -> 18 \n", "class Solution:\n    def minOperations(self, nums) -> int:\n        res = 0\n        N = len(nums)\n        while True:\n            for i, v in enumerate(nums):\n                if v & 1:\n                    res += 1\n                    nums[i] -= 1\n            if nums == [0] * N:\n                return res\n            for i in range(N):\n                nums[i] //= 2\n            res += 1\n        return res\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        moves, ndone = 0, len(nums)-nums.count(0)\n        while ndone:\n            for i,num in enumerate(nums):\n                if num%2==1:\n                    moves+=1\n                    nums[i]-=1\n                    if nums[i]==0:\n                        ndone-=1\n            if ndone:\n                nums = [num//2 for num in nums]\n                moves+=1\n        return moves\n    \n", "def get_num_ops(num):\n     assert num >= 0\n     d_ops, s_ops = 0, 0\n     while num != 0:\n         if num%2 == 1:\n             num = num - 1\n             s_ops += 1\n         else:\n             num = num//2\n             d_ops += 1\n     return d_ops, s_ops\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        num_ops = 0\n        doubling_ops = []\n        for num in nums:\n            d, s = get_num_ops(num)\n            doubling_ops.append(d)\n            num_ops += d + s\n            print(num_ops)\n        \n        doubling_ops = sorted(doubling_ops)\n        change = [doubling_ops[0]]\n        for i in range(1, len(doubling_ops)):\n            change.append(doubling_ops[i] - doubling_ops[i-1])\n        \n        for i, c in enumerate(change):\n            num_ops = num_ops - c * (len(change) -i - 1)\n                                                         \n        return num_ops\n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count=0\n        maxi=0\n        for j in nums:\n            e=0\n            if(j==0):\n                continue\n            if(j==1):\n                count=count+1\n            if(j>1):\n                while(j):\n                    if(j%2==0):\n                        e=e+1\n                        j=j//2\n                    else:\n                        j=j-1\n                        count=count+1\n            if(e>maxi):\n                maxi=e\n                        \n        count=count+maxi\n        return count\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def count(n):\n            a = b = 0\n            while n:\n                if n & 1:\n                    n -= 1\n                    b += 1\n                else:\n                    n >>= 1\n                    a += 1\n            return (a, b)\n        maxA = sumB = 0\n        for n in nums:\n            a, b = count(n)\n            maxA = max(maxA, a)\n            sumB += b\n        return maxA + sumB\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n             \n        number_of_moves=0\n        while(True):\n            for pos,num in enumerate(nums):\n                if num%2 == 1:\n                    nums[pos]-=1\n                    number_of_moves += 1\n            if not any(nums):\n                break\n            nums = list([x//2 for x in nums])            \n            number_of_moves +=1\n            \n        return number_of_moves\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op=0\n        sum1=sum(nums)\n        while sum1!=0:\n            for i in range(len(nums)):\n                if nums[i]%2!=0:\n                    nums[i]-=1\n                    sum1-=1\n                    op+=1\n                    \n            if sum1==0:\n                return op\n            \n            for i in range(len(nums)):\n                nums[i]//=2\n            op+=1\n            sum1/=2\n            \n        return op\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        d = {}\n        odd = 0\n        mx_even = 0\n        for i,val in enumerate(nums):\n            even = 0\n            while(val):\n                if val%2==0:\n                    while(val>0 and val%2==0):\n                        val = val//2\n                        even += 1\n                else:\n                    val -= 1\n                    odd += 1\n            mx_even = max(even,mx_even)\n        return odd + mx_even\n                        \n                        \n            \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        while any(nums):\n            for i in range(n):\n                if nums[i]%2==1: \n                    nums[i]=nums[i]-1\n                    ans += 1\n            if any(nums):\n                nums = [o/2 for o in nums]\n                ans += 1\n        return ans", "from math import log\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        vposes = set(range(len(nums)))\n        while vposes:\n            rm = set()\n            for i in vposes:\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    res += 1\n                if not nums[i]:\n                    rm.add(i)\n            vposes.symmetric_difference_update(rm)        \n            chg = False\n            for i in vposes:\n                chg = True\n                nums[i] //= 2\n            res += chg    \n        return res    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        max_div = 0\n        \n        for n in nums:\n            divs = 0\n            while n > 0:\n                if n % 2:\n                    n -= 1\n                    ops += 1\n                else:\n                    n /= 2\n                    divs += 1\n            \n            max_div = max(max_div, divs)\n        \n        return ops + max_div\n", "class Solution:\n    def minOperations(self, a: List[int]) -> int:\n        # def cnt_op(x):\n        #     if x == 0: return 0\n        #     if x % 2 == 0: return 1 + cnt_op(x // 2)\n        #     return 1 + cnt_op(x - 1)\n            \n        ans = 0     \n        zero_cnt = 0\n        while zero_cnt < len(a):\n            zero_cnt = 0\n            for i, x in enumerate(a):\n                if x % 2 == 1: \n                    ans += 1\n                    a[i] = (x - 1) // 2\n                else:\n                    a[i] = x // 2\n                zero_cnt += a[i] == 0\n            ans += zero_cnt < len(a)                \n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        steps = 0\n        while True:\n            for idx in range(0, len(nums)):\n                if nums[idx] % 2 == 1:\n                    nums[idx] -= 1\n                    steps += 1\n            if sum(nums) == 0:\n                break\n            nums = [int(x / 2) for x in nums]\n            steps += 1\n                    \n        return steps\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        not_zero = set(list(range(n)))\n        while True:\n            if len(not_zero) == 0:\n                return ans\n            zeros = []\n            for i in not_zero:\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n                if nums[i] == 0:\n                    zeros.append(i)\n                nums[i] = nums[i] // 2\n            for j in zeros:\n                not_zero.remove(j)\n            if len(not_zero) > 0:\n                ans += 1\n            # print(not_zero, nums, ans)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def get_add_mul_times(num: int):\n            a, b = 0, 0\n            while num > 0:\n                if num >> 1 << 1 != num:\n                    a += 1\n                    num -= 1\n                else:\n                    b += 1\n                    num //= 2\n            return a, b\n        N = len(nums)\n        add, mul = [0] * N, [0] * N\n        for ii in range(N):\n            a, b = get_add_mul_times(nums[ii])\n            add[ii] = a\n            mul[ii] = b\n        return max(mul) + sum(add)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        steps = 0\n        while sum(nums) > 0:\n            for idx in range(0, len(nums)):\n                if nums[idx] % 2 == 1:\n                    nums[idx] -= 1\n                    steps += 1\n            if sum(nums) == 0:\n                break\n            nums = [int(x / 2) for x in nums]\n            steps += 1\n                    \n        return steps\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n#         # bit operation\n#         # The number of operation 0 equals to the total number of bits \\\"1\\\".\n#         # The number of operation 1 equals to maximum bit length - 1.\n        \n#         # operation 0: turning 1 to 0. make 1 bit to 0 bit. need 1 operation individually\n#         # thus count number of 1 bits for each number and add them up\n        \n#         # operation 2: divide number by 2 -> shift 1 bit to right. this can be share with all numbers\n#         # 1 step operation to shift all numbers to right by 1 bit.\n#         # Thus find the number with max length of bit (max number in the array), count how many bits.\n#         return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))[2:]) - 1\n    \n    \n        # sum of the addition operations and the maximum number of multiply operations in any element.\n        # O(32N) = O(N)\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2 == 1: # odd number, just delete 1 so that it's now a multiple of 2\n                    n -= 1\n                    ones += 1\n                else: # multiple of 2, so just divide by 2 \n                    n //= 2\n                    mul += 1\n            twos = max(twos, mul)\n            \n        return ones + twos\n", "import numpy as np\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        #return sum(bin(a).count('1') for a in nums) + len(bin(max(nums)))-3\n        \n        #\\\"\\\"\\\"\n        # poor performance on very large lenght of list.\n        count = 0\n        if not any(nums):\n            return count\n        for i in range(len(nums)):\n            if nums[i]%2 != 0:\n                nums[i] -= 1\n                count += 1\n        #b = False\n        if any(nums):\n            count += 1\n            for i in range(len(nums)):\n                nums[i] = nums[i]//2\n        return count+self.minOperations(nums)\n        #\\\"\\\"\\\"\n", "bin = '{:0b}'.format\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        maxBitLen = 0\n        bitCount = 0\n        for num in nums:\n            b = bin(num)\n            maxBitLen = max(maxBitLen, len(b))\n            bitCount += b.count('1')\n        return maxBitLen + bitCount - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        @lru_cache(None)\n        def helper(num):\n            if num < 2:\n                return num,0\n            a,b = helper(num//2)    \n            return a+num%2,b+1\n            \n            \n        a = b = 0\n        for num in nums:\n            tmpa,tmpb = helper(num)\n            a += tmpa\n            b = max(b,tmpb)\n        return a + b\n        \n        \n\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def helper(num):\n            if num in self.dic: return self.dic[num]\n            n = num\n            count,even = 0,0\n            while n != 0:\n                if n % 2 == 1:\n                    n -= 1\n                else:\n                    n //= 2\n                    even += 1\n                count += 1\n            self.dic[num] = (count,even)\n            return count,even\n        \n        ans,maxb,self.dic = 0,0,{}\n        for num in nums:\n            a,b = helper(num)\n            ans += a - b\n            maxb = max(maxb,b)\n        return ans + maxb", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        steps = 0\n        maxIdx, maxNum = None, -math.inf \n        \n        for idx, num in enumerate(nums):\n            if num > maxNum:\n                maxNum = num\n                maxIdx = idx\n                \n        nums[maxIdx], nums[-1] = nums[-1], nums[maxIdx]\n        \n        def divideBy2(nums):\n            nums = [num // 2 for num in nums]\n            return nums\n        \n        while nums[-1] > 0:\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    steps += 1\n                    \n            if nums[-1] == 0:\n                return steps\n            \n            nums = divideBy2(nums)\n            steps += 1\n            \n        return steps", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        add = 0\n        double = 0\n        ans = 0\n        for i in range(len(nums)):\n            x = nums[i]\n            if x == 0:\n                continue\n            add += 1\n            curr = 0\n            while x != 1:\n                if x % 2 != 0:\n                    x -= 1\n                    add += 1\n                while x % 2!= 1:\n                    x /= 2\n                    curr += 1\n            double = max(double, curr)\n        ans = double + add\n        return ans", "class Solution:        \n    def minOperations(self, nums: List[int]) -> int:\n        op_count = 0\n        \n        while not all([v==0 for v in nums]):\n            for i in range(len(nums)):\n                odd = nums[i] % 2\n                if odd:\n                    nums[i] -= 1\n                    op_count += 1\n                nums[i] //= 2\n            \n            op_count += 1\n                \n        return max(0, op_count - 1)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        all_zero = False\n        while not all_zero:\n            all_zero = True\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    ans += 1\n                    nums[i] -= 1\n                nums[i] //= 2\n                if nums[i] != 0: all_zero = False\n            if not all_zero: ans += 1\n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        _max = 0\n        for i in nums:\n            bit = 0\n            while i>0:\n                res += i&1\n                i >>= 1\n                bit += 1\n            _max = max(bit,_max)\n        return res+_max-1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        while sum(nums):\n            for i in range(n):\n                if nums[i]%2==1: \n                    nums[i]=nums[i]-1\n                    ans += 1\n            if sum(nums):\n                nums = [o/2 for o in nums]\n                ans += 1\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        res = 0\n        max_len = 0\n        for num in nums:\n            bits = 0\n            while num > 0:\n                res += num%2\n                num >>= 1\n                bits += 1\n            max_len = max(bits-1, max_len)\n        return res + max_len\n            \n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        n = len(nums)\n        while 1:\n            all0 = True\n            has_div = False\n            for i in range(n):\n                if nums[i] == 0:\n                    continue\n                all0 = False\n                if nums[i] & 1:\n                    res += 1\n                    if nums[i] > 1:\n                        has_div = True\n                    nums[i] = (nums[i] - 1) // 2\n                else:\n                    has_div = True\n                    nums[i] //= 2\n            if all0:\n                break\n            if has_div:\n                res += 1\n        return res\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while True:\n            Zero = True\n            for i in range(len(nums)):\n                if nums[i]&1:\n                    nums[i]-=1\n                    count += 1\n                if nums[i]:\n                    Zero = False\n            if Zero:\n                return count\n            count += 1\n            for i in range(len(nums)):\n                nums[i]>>=1\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count=0\n        check =0\n        if not nums:\n            return(0)\n        while check !=len(nums):\n            x,check, nums = self.odd(nums)\n            count+=x\n            if check == len(nums):\n                return(count)\n            nums=self.div(nums)\n            count+=1\n            \n            \n            \n            \n    def div(self,nums):\n        for i in range(len(nums)):\n            nums[i]=nums[i]//2\n        return(nums)\n        \n        \n    def odd(self,nums):\n        a=0\n        b=0\n        \n        for i in range(len(nums)):\n            if nums[i] & 1 == 1:\n                a+=1\n                nums[i]-=1\n            if nums[i] == 0:\n                b+=1\n        return(a,b,nums)\n                \n", "class Solution:\n  def minOperations(self, nums: List[int]) -> int:\n    maxDivideCount = 0\n    minusCount = 0\n    for num in nums:\n      divideCount = 0\n      while num != 0:\n        if num % 2 == 0:\n          num //= 2\n          divideCount += 1\n        else:\n          num -= 1\n          minusCount += 1\n      maxDivideCount = max(divideCount, maxDivideCount)\n    return maxDivideCount + minusCount\n    \n#     while self.isAllZero(nums) is False:\n#       if self.isAllEven(nums):\n#         nums = [a // 2 for a in nums]\n#         count += 1\n#         continue\n#       for i in range(len(nums) - 1):\n#         if nums[i] != 0 and nums[i] % 2 == 1:\n#           nums[i] -= 1\n#           count += 1\n        \n#     return count\n      \n#   def isAllZero(self, nums: List[int]) -> bool:\n#     for n in nums:\n#       if n != 0:\n#         return False\n#     return True\n  \n#   def isAllEven(self, nums: List[int]) -> bool:\n#     for n in nums:\n#       if n % 2 != 0:\n#         return False\n#     return True\n    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        oneCnt = 0\n        pwrCnt = 0\n        for num in nums:\n            if num == 0:\n                continue\n            exp = 0\n            while num > 0:\n                if num % 2 == 0:\n                    num /= 2\n                    exp += 1\n                else:\n                    num -= 1\n                    oneCnt += 1\n            pwrCnt = max(pwrCnt, exp)\n        return oneCnt + pwrCnt\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if sum(nums) == 0:\n            return 0\n        \n        steps = 0\n        n_zeros = 0\n        \n        for i, num in enumerate(nums):\n            if num % 2 != 0:\n                nums[i] -= 1\n                steps += 1\n            \n            if nums[i] == 0:\n                n_zeros += 1\n            \n            nums[i] = nums[i] // 2\n        \n        if n_zeros != len(nums):\n            steps += 1\n        \n        return steps + self.minOperations(nums)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            for i, x in enumerate(nums):\n                if x % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n            if any(nums):\n                for i, x in enumerate(nums):\n                    nums[i] //= 2\n                ans += 1\n        return ans\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        @lru_cache(None)\n        def helper(num):\n            if num < 2:\n                return num,0\n            if num%2==0:\n                a,b = helper(num//2)\n                return a,b+1\n            else:\n                a,b = helper((num-1)//2)\n                return a+1,b+1\n            \n        a = b = 0\n        for num in nums:\n            tmpa,tmpb = helper(num)\n            a += tmpa\n            b = max(b,tmpb)\n        return a + b\n        \n        \n\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        max_dev = 0\n        steps = 0\n        \n        for i in nums:\n            dev = 0\n            while i != 0:\n                if i % 2 == 0:\n                    i = i / 2\n                    dev = dev + 1\n                else:\n                    i = i - 1\n                    steps = steps + 1\n            \n            if dev > max_dev:\n                max_dev = dev\n                \n        \n        return steps + max_dev", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        one = 0\n        two = 0\n        for n in nums:\n            r = self.onetwo(n)\n            one += r[0]\n            two = max(two, r[1])\n        return one + two\n    def onetwo(self, n):\n        one = 0\n        two = 0\n        while n != 0:\n            if n%2 == 0:\n                two += 1\n                n /= 2\n            else:\n                one += 1\n                n -= 1\n        return (one, two)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n\n        res = 0\n        t = 0\n        \n        for ele in nums:\n            ele = str(bin(ele))[2:]\n            res += ele.count('1')\n            t = max(t, len(ele) - 1)\n        \n        return res + t\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        one = 0\n        two_req = 0\n        \n        for i in nums:\n            two = 0\n            i_copy = i\n            while i_copy > 0:\n                # print(i_copy)\n                if i_copy % 2 == 0:\n                    i_copy = i_copy // 2\n                    two += 1\n                else:\n                    i_copy -= 1\n                    one += 1\n\n            two_req = max(two_req, two)\n\n        res = two_req + one\n        # print(ctr, odd_ctr, non_zero)\n        return res", "from math import log\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cnt = int(log(max(nums))/log(2))\n        for n in nums:\n            while n>0:\n                if n%2==1:\n                    n-=1\n                    cnt+=1\n                else:\n                    n = n//2\n        return cnt\n", "from functools import lru_cache\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        divideByTwos = 0\n        decrements = 0\n        \n        for num in nums:\n            if num == 0:\n                continue\n                \n            divides, dec = self.reductions(num)\n            divideByTwos = max(divideByTwos, divides)\n            decrements += dec\n                \n        return divideByTwos + decrements\n    \n    @lru_cache(maxsize=None)\n    def reductions(self, num: int) -> (int, int):\n        decrements = 0\n        divides = 0\n        \n        while num > 1:\n            if num % 2 == 0:\n                num /= 2\n                divides+=1\n            else:\n                num -= 1\n                decrements +=1\n                \n        return divides, decrements + 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        \n        while not(self.is_end(nums)):\n            ops += self.perform_decrement(nums)\n            if self.is_end(nums): return ops\n            ops += self.perform_division(nums)\n        return ops\n        #jesli nieparzytte to odejmij 1\n        #jesli wszystkie parzyste to podziel\n        \n    def is_end(self, nums):\n        return all(i == 0 for i in nums)\n    \n    def perform_decrement(self, nums):\n        ops = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                nums[i] -= 1\n                ops += 1\n        return ops\n\n    def perform_division(self, nums):\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[i] //= 2\n        return 1\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        @lru_cache(None)\n        def get(n):\n            add = 0\n            mul = 0\n            while n:\n                if n & 1:\n                    add += 1\n                    n -= 1\n                else:\n                    mul += 1\n                    n = n >> 1\n            return add, mul\n        cadd = 0\n        mmul = 0\n        for n in nums:\n            add, mul = get(n)\n            cadd += add\n            mmul = max(mul, mmul)\n        return cadd + mmul", "class Solution:\n    # naive is BFS, but too costly.\n    # Start from nums by greedily trace back, whenever there is an odd number, take one action to make it even by reduce 1. If everything is even, half them by taking one action.\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while True:\n            for i in range(len(nums)):  # take 1 action each to make elem from odd to even\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    count += 1\n            all_zero = True\n            for i in range(len(nums)):  # take one action to half all elem\n                if nums[i] != 0:\n                    all_zero = False\n                nums[i] //= 2\n            if all_zero:\n                return count\n            count += 1\n        return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ## there's definitely a dfs approach, but it seems\n        # expensive...need as many recursive calls per level\n        # as the length of the list +1 for op 1\n        # start is [0,0]\n        # can we extract the solution from the binary rep of all the nums?\n        #pad to 32 bit or \n        N = len(nums);\n        ansr = 0;\n        while(any(nums)):\n            divideByTwo = False;\n            for i in range(N):\n                if(nums[i] == 1):\n                    ansr+=1;\n                    nums[i] = 0;\n                elif(nums[i]==0):\n                    continue;\n                else:\n                    divideByTwo = True\n                    if(nums[i]%2 == 1):\n                        ansr+=1\n                    nums[i] = nums[i]//2\n            if(divideByTwo):\n                ansr+=1;\n        return ansr;\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        \n        while True:\n            for i in range(n):\n                if nums[i] % 2 == 1:\n                    ans += 1\n                    nums[i] -= 1\n                    \n            stop = True\n            for i in range(n):\n                if nums[i] != 0:\n                    nums[i] //= 2\n                    stop = False\n            \n            if stop:\n                break\n            else:\n                ans += 1\n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        max_divide = 0\n        res = 0\n        for num in nums:\n            cnt_divide = 0\n            while num:\n                if num%2==1:\n                    res += 1\n                    num-=1\n                else:\n                    num //=2\n                    cnt_divide += 1\n            max_divide = max(max_divide, cnt_divide)\n            \n        return res + max_divide\n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        nums.sort()\n        while nums[-1] != 0:            \n            if nums[-1] >= 2:\n                ans += 1\n            for i, num in enumerate(nums):\n                ans += num % 2\n                nums[i] = num // 2\n            \n        return ans", "import math\nclass Solution:\n    def rec(self,nums):\n        if not nums:\n            return 0\n        if len(nums)==1:\n            if nums[0]<=2:return nums[0]\n            \n            if nums[0]%2==0:\n                nums[0]=nums[0]//2\n                return 1+self.rec(nums)\n            else:\n                nums[0]=(nums[0]-1)//2\n                return 2+self.rec(nums)\n            \n            \n            \n        op=0\n        new=[]\n        for i in range(len(nums)):\n            if nums[i]!=0:\n                if nums[i]%2!=0:\n                    nums[i]-=1\n                    op+=1\n                    if nums[i]!=0:\n                        new.append(nums[i]//2)\n                        \n                else:\n                    new.append(nums[i]//2)\n        if len(new)>0:\n            op+=1\n        return op+self.rec(new)\n        \n        \n    def minOperations(self, nums: List[int]) -> int:\n        return self.rec(nums)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        N = len(nums)\n        res = 0\n        while sum(nums) != 0:\n            all_even = True\n            for i in range(N):\n                if nums[i] & 1:\n                    all_even = False\n                    res += 1\n                    nums[i] -= 1\n            if all_even:\n                res += 1\n                nums = [n // 2 for n in nums]\n        return res", "def ones(x):\n    return 0 if x == 0 else 1 + ones(x & (x - 1))\ndef twos(x):\n    cc = 0\n    while x > 1:\n        x //= 2\n        cc += 1\n    return cc\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        o = 0\n        t = 0\n        for x in nums:\n            o += ones(x)\n            t = max(t, twos(x))\n        return o + t", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        add_count = 0\n        mut_count = 0\n        \n        def get_add_mut_count(n):\n            add = mut = 0\n            while n:\n                if n % 2:\n                    # n is odd and delete it by one which require one action as add\n                    n -= 1\n                    add += 1\n                else:\n                    n /= 2\n                    mut += 1\n                    \n            return (add, mut)\n        \n        for n in nums:\n            a, m = get_add_mut_count(n)\n            add_count += a\n            mut_count = max(mut_count, m)\n        \n        return add_count + mut_count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count=0\n        while True:\n            zeros=0\n            for i in range(len(nums)):\n                if nums[i]%2==0:\n                    continue\n                else:\n                    nums[i]-=1\n                    count+=1\n            for j in range(len(nums)):\n                if nums[j]==0:\n                    zeros+=1\n                nums[j]=nums[j]//2\n            if zeros==len(nums):\n                return count\n            count+=1\n            \n            \n\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        nums.sort()\n        nums = nums[::-1]\n        ops = 0\n        \n        n = len(nums)\n        \n        while nums:\n            # print(nums)\n            while nums[-1]==0:\n                nums.pop()\n                if not nums:\n                    break\n                n-=1\n            if not nums:\n                break\n                \n            oc = 0\n\n            for i in range(n):\n                if nums[i]%2!=0:\n                    oc = 1\n                    break\n                    \n            if oc==1:\n                for i in range(n):\n                    if nums[i]%2!=0:\n                        ops+=1\n                        nums[i]-=1\n            else:\n                ops+=1\n                for i in range(n):\n                    nums[i] = nums[i]//2\n        return ops\n            \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        valid = {0: 0}\n        for i in range(31):\n            valid[2 ** i] = i\n        \n        ans = 0\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                ans += 1\n\n        max_val = float('-inf')\n        need_step = [0] * len(nums)\n        max_multiply_step = 0\n        for i in range(len(nums)):\n            one_step, multiply_step = 0, 0\n            while nums[i] not in valid:\n                if nums[i] & 1:\n                    one_step += 1\n                    nums[i] -= 1\n                else:\n                    multiply_step += 1\n                    nums[i] //= 2\n            \n            max_multiply_step = max(max_multiply_step, multiply_step + valid[nums[i]])\n            ans += one_step\n        \n        ans += max_multiply_step\n\n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        count=0\n        while sum(nums)>0:\n            for i in range(len(nums)):\n                count += nums[i] % 2\n                nums[i] = nums[i] // 2\n                \n            if sum(nums)>0: count += 1\n                \n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        if len(nums) == 1:\n            v = nums[0]\n            while v:\n                if v%2:\n                    ans += 1\n                    v -= 1\n                if v:\n                    v //= 2\n                    ans += 1\n            return ans\n        c = collections.Counter()\n        for i,v in enumerate(nums):\n            if v%2:\n                nums[i] -= 1\n                ans += 1\n            c[nums[i]]+=1\n        two = 0\n        for v in sorted(c.keys()):\n            temp = 0\n            t = 0\n            u = v\n            while v:\n                if v%2:\n                    t += 1\n                    v -= 1\n                if v:\n                    v //= 2\n                    temp += 1\n            ans += t*c[u] + (temp-two)\n            two += (temp-two)\n                \n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        zeroIndexes = set()\n        result = 0\n        isEven = False\n        while len(zeroIndexes) != len(nums):\n            if isEven:\n                for i in range(len(nums)):\n                    nums[i] >>= 1\n                result += 1\n                isEven = False\n            else:\n                for i in range(len(nums)):\n                    if i not in zeroIndexes:\n                        if nums[i] & 1:\n                            nums[i] -= 1\n                            result += 1\n                        if nums[i] == 0:\n                            zeroIndexes.add(i)\n                isEven = True\n        return result\n", "import math\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n#         res = 0\n#         maxPow = 0\n#         for i in range(len(nums)):\n#             if nums[i] > 0:\n#                 power = round(math.log(nums[i])/math.log(2))\n#                 print(power, pow(2, power))\n#                 if maxPow < power:\n#                     maxPow = power\n#                 res += 1 + nums[i] - pow(2, power)\n\n#         res += maxPow\n#         return res\n        res = 0\n        while True:\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    res += 1\n                    nums[i] -= 1\n                    \n            numZeros = 0\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    numZeros += 1\n                    \n            if numZeros == len(nums):\n                break\n            \n            for i in range(len(nums)):\n                nums[i] //= 2\n            res += 1\n            \n        return res\n            \n            \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while sum(nums) != 0:\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    res += 1\n            if sum(nums) != 0:\n                for i in range(len(nums)):\n                    nums[i]  /= 2\n                res += 1\n            # print(nums)\n        return res\n", "# from collections import deque\n# class Solution:\n#     def minOperations(self, nums: List[int]) -> int:\n#         step = 0\n#         while len(nums):\n#             for i, val in enumerate(nums):\n#                 if val % 2:\n#                     nums[i] -= 1\n#                     step += 1\n#             nums = self.trim(nums)\n#             if len(nums):\n#                 step += 1\n#                 for i, val in enumerate(nums):\n#                     if val:\n#                         nums[i] /= 2\n#             nums = self.trim(nums)\n#         return step\n\n#     def trim(self, nums):\n#         return [e for e in nums if e]\n\nfrom collections import deque\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        step = 0\n        while sum(nums):\n            for i, val in enumerate(nums):\n                if val % 2:\n                    nums[i] -= 1\n                    step += 1\n            if sum(nums):\n                step += 1\n                for i, val in enumerate(nums):\n                    if val:\n                        nums[i] /= 2\n        return step\n\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans=0\n        while True:\n            count=0\n            flag=0\n            for i in range(len(nums)):\n                if nums[i]&1:\n                    count+=1\n                    nums[i]-=1\n            for i in range(len(nums)):    \n                if nums[i]!=0:\n                    nums[i]=nums[i]//2  \n                    flag=1\n            ans+=count\n            if flag:\n                ans+=1\n            count=0\n            if nums.count(0)==len(nums):\n                return ans\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        counter = 0\n        while 1:\n            temp_counter = 0\n            bigger_than_zero = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    temp_counter += 1\n                    nums[i] -= 1\n                if nums[i] > 0:\n                    bigger_than_zero += 1\n            counter += temp_counter\n            if bigger_than_zero == 0 :\n                return counter\n            for i in range(len(nums)):\n                nums[i] //= 2\n            counter += 1\n        return counter\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        # zero_ind = -1\n        step = 0\n        while any(( n > 0 for n in nums)):\n            # print('nums', nums)\n            if all((n % 2 == 0 for n in nums)):\n                nums = [n // 2 for n in nums]\n                step += 1\n            else:\n                # find odd element\n                remain_idx = []\n                for i, v in enumerate(nums):\n                    if v % 2 == 1:\n                        nums[i] = nums[i] - 1\n                        # if nums[i] == 0:\n                        #     zero_ind = max(zero_ind, i)\n                        step += 1\n                # nums = [ nums[ri] for ri in remain_idx]\n        return step", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        m = 0\n        f = 0 \n        for x in nums:\n            \n            if x == 0:\n                continue\n            \n            c = 0\n            mm = 0\n            baz = x\n            while x > 1:\n                if x % 2 == 0:\n                    x = x // 2\n                    mm += 1\n                else:\n                    x -= 1\n                    c += 1\n            print((baz,c))\n            f += 1 + c\n            m = max(m,mm)\n            print(m)\n            \n        f += m\n        return f\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        @lru_cache(None)\n        def helper(num):\n            if num < 2:\n                return num,0\n            if num%2==0:\n                a,b = helper(num//2)\n                return a,b+1\n            else:\n                a,b = helper((num-1)//2)\n                return a+1,b+1\n            \n        a = b = 0\n        for num in nums:\n            tmpa,tmpb = helper(num)\n            print((num,tmpa,tmpb))\n            a += tmpa\n            b = max(b,tmpb)\n        return a + b\n        \n        \n\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        Count = 0\n\n        \n        while True:\n            \n            for i in range(len(nums)):\n                if nums[i]%2 == 1: \n                    Count += 1\n                    nums[i]  = (nums[i] - 1)//2\n                else: nums[i] = nums[i]//2\n            \n            if sum(nums) == 0: return Count\n            Count += 1\n            \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ret = 0\n        while nums.count(0)!=len(nums):\n            for i in range(0,len(nums)):\n                if nums[i]%2!=0:\n                    nums[i] = nums[i]-1\n                    ret = ret+1\n            nums[:] = [i/2 for i in nums]\n            ret = ret+1\n        return (0 if ret==0 else ret-1)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while not all(n == 0 for n in nums):\n            div = 0\n            for i, n in enumerate(nums):\n                if n & 1:\n                    ans += 1\n                    n -= 1\n                if n > 0:\n                    div = 1\n                    n //= 2\n                nums[i] = n\n            ans += div\n        return ans", "from collections import deque\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        step = 0\n        while sum(nums):\n            for i, val in enumerate(nums):\n                if val % 2:\n                    nums[i] -= 1\n                    step += 1\n            if sum(nums):\n                step += 1\n                for i, val in enumerate(nums):\n                    if val:\n                        nums[i] /= 2\n        return step\n\n        \n        \n#         step = 0\n#         l = deque()\n#         l.append([0] * len(nums))\n#         while l:\n#             l_len = len(l)\n#             for i in range(l_len):\n#                 cur_list = l.popleft()\n#                 if str(cur_list) == str(nums):\n#                     return step\n#                 for j in range(len(nums)):\n#                     add_next, valid = self.add(cur_list, nums, j)\n#                     if valid:\n#                         l.append(add_next)\n#                 mul_next, valid = self.multiply(cur_list, nums)\n#                 if valid:\n#                     l.append(mul_next)\n#             step += 1\n#         return step\n                \n       \n        \n#     def add(self, cur: List[int], target: List[int], idx: int):\n#         if cur[idx] + 1 > target[idx]:\n#             return [], False\n#         else:\n#             new_list = cur.copy()\n#             new_list[idx] += 1\n#             return new_list, True\n    \n#     def multiply(self, cur: List[int], target: List[int]):\n#         new_list = cur.copy()\n#         for i in range(len(new_list)):\n#             new_list[i] *= 2\n#             if new_list[i] > target[i]:\n#                 return [], False\n#         return new_list, True\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def dfs(n):\n            if(sum(nums) == 0):\n                return n\n            subs = 0\n            zeros = 0\n            for i in range(len(nums)):\n                if(nums[i]%2):\n                    nums[i]-=1\n                    subs+=1\n                if(nums[i]==0):\n                    zeros += 1\n                nums[i] /= 2\n            if(zeros == len(nums)):\n                return subs+n\n            return dfs(1+subs+n)\n        return dfs(0)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def count(num):\n            div = 0\n            minus = 0\n            while num:\n                if num%2==0:\n                    num = num//2\n                    div+=1\n                else:\n                    num=num-1\n                    minus+=1\n            return div,minus\n        m=[]\n        d=[]\n        for i in nums:\n            div,minus = count(i)\n            d.append(div)\n            m.append(minus)\n        return max(d)+sum(m)\n            \n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        m = 0\n        \n        def get(val):\n            ret = 0\n            give = 0\n            while(val != 0):\n                if(val & 1):\n                    val -= 1\n                    ret += 1\n                else:\n                    val = val//2\n                    give += 1\n                \n            return ret, give\n    \n        for i in range(n):\n            if(nums[i] == 0): continue\n            val, mult = get(nums[i])\n            m = max(m,mult)\n            ans += val\n        ans += m\n        return ans", "class Solution:\n    '''\n    [3,2,2,4] 1 -> [2,2,2,4] 1 -> [1,1,1,2] 3 -> [0,0,0,2] 1 -> [0,0,0,1] 1 -> [0,0,0,0]\n    '''\n    def minOperations(self, nums: List[int]) -> int:\n        if nums == [0]:\n            return 0\n        \n        copy = list(nums)\n        ans = 0\n        while any([el != 0 for el in copy]):\n            numOdd = 0\n            for i in range(len(copy)):\n                if copy[i] % 2 != 0:\n                    numOdd += 1\n                    copy[i] -= 1\n\n            for i in range(len(copy)):\n                copy[i] /= 2\n                \n            ans += numOdd + 1\n        return ans-1\n                \n        \n        \n            \n                \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        cnt = 0\n        while True:\n            for i in range(len(nums)):\n                if nums[i] != 0:\n                    if nums[i]&1 != 0:\n                        nums[i] -= 1\n                        cnt += 1\n                    nums[i] = nums[i] >> 1\n            if sum(nums) == 0:  # Notice how to calculate array sum in python....\n                return cnt\n            cnt += 1\n        return cnt\n        \n        \n        '''\n        # Backwards!!!!\n        # Some problems is hard to solve forward, but can be easy if solved backwards!!!!\n        # Change nums to arr\n        \n        step = 0\n        \n        while True:\n            for i in range(len(nums)):\n                if nums[i]%2 != 0:\n                    nums[i] = nums[i] - 1\n                    step += 1\n                nums[i] = nums[i]//2\n            if sum(nums) == 0:\n                return step\n            step += 1\n        '''\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = m = 0\n        for x in nums:\n            s = bin(x)[2:]\n            m = max(len(s) - 1, m)\n            n += len(s.replace('0', ''))\n        return m + n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = max_mult = 0\n        for num in nums:\n            count = 0\n            while num != 0:\n                if num % 2:\n                    res += 1\n                    num -= 1\n                else:\n                    count += 1\n                    num //= 2\n            max_mult = max(max_mult, count)\n\n        return res + max_mult\n\n                \n           \n            \n", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1558 lang=python3\n#\n# [1558] Minimum Numbers of Function Calls to Make Target Array\n#\n# https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/description/\n#\n# algorithms\n# Medium (57.56%)\n# Total Accepted:    4.1K\n# Total Submissions: 7.1K\n# Testcase Example:  '[1,5]'\n#\n#\n#\n# Your task is to form\u00a0an integer array nums from an initial array of zeros\u00a0arr\n# that is the\u00a0same size\u00a0as nums.\n#\n# Return the minimum number of\u00a0function calls to make nums from arr.\n#\n# The answer is guaranteed to fit in a 32-bit signed integer.\n#\n#\n# Example 1:\n#\n#\n# Input: nums = [1,5]\n# Output: 5\n# Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1\n# operation).\n# Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).\n# Increment by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).\n# Total of operations: 1 + 2 + 2 = 5.\n#\n#\n# Example 2:\n#\n#\n# Input: nums = [2,2]\n# Output: 3\n# Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2\n# operations).\n# Double all the elements: [1, 1] -> [2, 2] (1 operation).\n# Total of operations: 2 + 1 = 3.\n#\n#\n# Example 3:\n#\n#\n# Input: nums = [4,2,5]\n# Output: 6\n# Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] ->\n# [4,2,4] -> [4,2,5](nums).\n#\n#\n# Example 4:\n#\n#\n# Input: nums = [3,2,2,4]\n# Output: 7\n#\n#\n# Example 5:\n#\n#\n# Input: nums = [2,4,8,16]\n# Output: 8\n#\n#\n#\n# Constraints:\n#\n#\n# 1 <= nums.length <= 10^5\n# 0 <= nums[i] <= 10^9\n#\n#\n#\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cnt = 0\n        cc = Counter(nums)\n        while True:\n            dup = defaultdict(int)\n            do_even = False\n            for n in cc:\n                if n == 0: continue\n                if n % 2:\n                    cnt += cc[n]\n                    if n - 1 > 0:\n                        do_even = True\n                        dup[n // 2] += cc[n]\n                else:\n                    do_even = True\n                    dup[n // 2] += cc[n]\n            if do_even: cnt += 1\n            if not dup: return cnt\n            cc = dup\n\n        return cnt\n\n\nsol = Solution()\n\nnums = [1, 5]\nnums = [2, 2]\nnums = [4, 2, 5]\n# nums = [3, 2, 2, 4]\n# nums = [2, 4, 8, 16]\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        nz = 0\n        for num in nums:\n            if num>0:\n                nz+=1\n       # print(nz)\n        while nz>0:\n           # print(nums, res)\n            div2 = False\n            for i in range(len(nums)):\n                if nums[i]%2==1:\n                    nums[i]-=1\n                    res+=1\n                    if nums[i]==0:\n                        nz-=1\n                if nums[i]>0:\n                    div2 = True\n                    nums[i]//=2\n                    if nums[i]==0:\n                        nz-=1\n            #print('after', nums, nz)\n            if div2:\n                res+=1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        '''Reverse thinking, from result number back to zeros'''\n        '''Time:O(n*n/2)->O(n^2), Space:O(1)'''\n#         result = 0\n#         zeros = 0\n#         for n in nums:\n#             if n==0:\n#                 zeros+=1\n                \n#         #when all numbers are even, /2\n#         #when there is any odd number, -1\n#         while zeros<len(nums):\n#             for i in range(len(nums)):\n#                 if nums[i]%2!=0:\n#                     nums[i]-=1\n#                     result+=1\n#                     if nums[i]==0:\n#                         zeros+=1\n#                     # print('odd')\n#             if zeros==len(nums):\n#                 break\n                \n#             flag=0\n#             for j in range(len(nums)): \n#                 if j==0:\n#                     flag=1\n#                 nums[j]/=2  \n#                 if flag==1:\n#                     result += 1\n#                     flag=0\n#                     # print('even')\n                    \n#         return result\n\n        '''Time:O(n), Space:O(1)'''\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2:\n                    n -= 1\n                    ones += 1\n                else:\n                    n //= 2\n                    mul += 1\n            twos = max(twos, mul)\n        return ones + twos", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        goal = [0]*len(nums)\n        if nums == goal:\n            return 0 \n        calls = 0 \n        div_needed = False\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                nums[i] -= 1\n                calls += 1\n            if nums[i] > 0:\n                div_needed = True\n        if div_needed:\n            nums = [n/2 for n in nums]\n            calls += 1\n        return calls + self.minOperations(nums)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        cnt=0\n        \n        while nums.count(0)<len(nums):            \n            for i in range(len(nums)):\n                if nums[i]%2!=0:\n                    nums[i]-=1\n                    cnt+=1\n                    \n            if nums.count(0)!=len(nums):\n                for i in range(len(nums)):\n                    nums[i]=nums[i]/2\n                cnt+=1\n            else:\n                return cnt\n\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ans=0\n        \n        while sum(nums)!=0:\n            count_odd=0\n            for i,num in enumerate(nums):\n                if num%2!=0:\n                    count_odd+=1\n                    ans+=1\n                    nums[i]=nums[i]-1\n            \n            if count_odd==0:\n                nums=[n//2 for n in nums]\n                ans+=1\n            #print(nums)\n        \n        return ans", "class Solution:\n    def minOperations(self, a: List[int]) -> int:\n        \n        ans = 0\n        \n        while True:\n            a.sort(reverse = True)\n            for i in range(len(a)):\n                if a[i]%2:\n                    ans += 1\n                    a[i] -= 1\n            for i in a:\n                if i != 0:\n                    break\n            else:\n                break\n            for i in range(len(a)):\n                if a[i]%2 == 0:\n                    a[i] //= 2\n            ans += 1\n            \n        return ans", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        done = False\n        while not done:\n            # Make nums all even numbers\n            for i in range(len(nums)):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    ops += 1\n            # Divide nums by 2\n            done = True\n            for i in range(len(nums)):\n                if nums[i] != 0:\n                    done = False\n                    nums[i] /= 2\n            if not done:\n                ops += 1\n        return ops\n            \n                    \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        maxDoubles = 0\n        incrs = 0\n        \n        for num in nums:\n            doubles = 0\n            while num > 0:\n                if num % 2 == 1:\n                    incrs += 1\n                    num -= 1\n                else:\n                    doubles += 1\n                    num >>= 1\n            maxDoubles = max(maxDoubles, doubles)\n        return incrs + maxDoubles\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res=0\n        sum1=1\n        while sum1!=0:\n            sum1 = 0\n            for ii,i in enumerate(nums):\n                if i%2!=0:\n                    nums[ii]-=1\n                    res+=1\n                nums[ii] = nums[ii]//2\n                sum1+=nums[ii]\n            res+=1\n        return res-1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        actions = 0 \n        \n        n = len(nums)\n        while True:\n            odd_flag = False \n            \n            for i in range(n):\n                if nums[i] % 2 == 1:\n                    actions += 1\n                    nums[i] -= 1\n                    odd_flag = True\n            if all(num == 0 for num in nums):\n                break\n                    \n            if odd_flag:\n                continue\n\n            for i in range(n):\n                nums[i] //= 2\n            actions += 1         \n            if all(num == 0 for num in nums):\n                break\n        return actions", "class Solution:    \n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n            \n        while True:\n            next_nums = [0] * len(nums)                        \n            all_zeros = True\n            for i, x in enumerate(nums):                \n                if x == 0:                    \n                    continue\n                            \n                if x % 2 != 0:\n                    count += 1                \n                \n                next_num =  x // 2\n                next_nums[i] = next_num\n                \n                all_zeros &= next_num == 0\n                                \n            if all_zeros:\n                break\n            \n            count += 1\n            nums = next_nums\n        \n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        L = lambda x:len(x)\n        op = 0\n        while sum(nums):\n            isodd = False\n            for i in range(L(nums)):\n                 if nums[i] & 1:\n                    nums[i] -= 1\n                    isodd = True\n                    op += 1\n                \n            if not isodd:\n                for i in range(L(nums)):\n                    nums[i] >>= 1\n                op += 1\n            #print(nums, op)\n        return op\n                    \n", "class Solution:\n    def minOperations(self, nums):\n        ans = 0\n        maxtimes = 0\n        for num in nums:\n            plus, times = 0, 0\n            #print(num)\n            while num!=0:\n                plus = plus+num%2\n                if num//2!=0:\n                    times += 1\n                num = num//2\n\n            maxtimes = max(maxtimes, times)\n            #print(num, plus, times)\n            ans = ans+plus  \n\n        ans += maxtimes\n        return(ans)\n\nx = Solution()\nprint(x.minOperations([1,5]))", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        nz = 0\n        for num in nums:\n            if num>0:\n                nz+=1\n       # print(nz)\n        while nz>0:\n           # print(nums, res)\n            div2 = False\n            for i in range(len(nums)):\n                if nums[i]%2==1:\n                    nums[i]-=1\n                    res+=1\n                if nums[i]>0:\n                    div2 = True\n                    nums[i]//=2\n            nz = 0\n            for num in nums:\n                if num>0:\n                    nz+=1\n            #print('after', nums, nz)\n            if div2:\n                res+=1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if max(nums) == 0:\n            return 0\n        operations = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                nums[i] = nums[i] - 1\n                operations += 1\n        if operations > 0:\n            return operations + self.minOperations(nums)\n        for i in range(len(nums)):\n            nums[i] = nums[i]//2\n        operations += 1\n        return operations + self.minOperations(nums)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while any(nums):\n            for i in range(len(nums)):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    count += 1\n            if any(nums):\n                for i in range(len(nums)):\n                    nums[i] //= 2\n                count += 1\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        max_ = max(nums)\n        multiplication = len(bin(max_)[2:]) - 1\n        additions = 0\n        for n in nums:\n            additions += bin(n)[2:].count('1')\n        return additions+multiplication", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        flag = True\n        n = len(nums)\n        while flag:\n            flag = False\n            for i in range(n):\n                if nums[i]%2==1:\n                    nums[i] -= 1\n                    ans += 1\n                if nums[i] != 0:\n                    flag = True\n            if flag:    \n                for i in range(n):\n                    nums[i] /= 2\n                ans += 1\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        c = 0\n        while True:\n            sol = True\n            for i in range(len(nums)):\n                if nums[i] % 2 != 0:\n                    nums[i] -= 1\n                    c += 1\n                if nums[i] != 0:\n                    sol = False\n            if sol:\n                break\n            \n        \n            c += 1\n            nums = [x // 2 for x in nums ]\n        return c", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any([True if num > 0 else False for num in nums]):\n            for idx, num in enumerate(nums):\n                if num % 2 == 1:\n                    ans += 1\n                    nums[idx] -= 1\n            flag = 0\n            for idx, num in enumerate(nums):\n                if num != 0:\n                    flag = True\n                    nums[idx] = num // 2\n            if flag: \n                ans += 1\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        N = len(nums)\n        \n        allzeros = False\n        while not allzeros:\n            allzeros = True\n            for i in range(N):\n                if nums[i] % 2 > 0:\n                    ans += 1\n                    nums[i] -= 1\n                if nums[i] != 0:\n                    allzeros = False    \n                    nums[i] = nums[i] // 2\n                \n            if not allzeros:\n                ans += 1\n            # print(ans, nums)\n        \n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        N = len(nums)\n        c = 0\n\n        while any(nums):\n            for i in range(N):\n                if nums[i] & 1:\n                    nums[i] -= 1\n                    c += 1\n\n            m = max(nums)\n            for i in range(N):\n                nums[i] >>= 1\n            c += 1\n        return c - 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        mul = [0 for i in range(len(nums))]\n        inc = [0 for i in range(len(nums))]\n        for i in range(len(nums)):\n            while nums[i]!=0:\n                if nums[i]%2 == 1:\n                    inc[i] += 1\n                    nums[i] = nums[i]-1\n                else:\n                    mul[i] +=1\n                    nums[i] //= 2\n        return max(mul)+sum(inc)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        nums.sort()\n        counter = 0\n        while nums[-1]:\n            for i, num in enumerate(nums):\n                counter += num%2\n                nums[i] = num//2 * 2\n            if nums[-1]:\n                nums = [num//2 for num in nums]\n                counter += 1\n        return counter", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def get_op(n):\n            op_0 = 0\n            op_1 = 0\n            while n != 0:\n                if n % 2 == 0:\n                    op_1 += 1\n                    n = n // 2\n                else:\n                    op_0 += 1\n                    n -= 1\n            return op_0, op_1\n        \n        ans = 0\n        op_1 = 0\n        for n in nums:\n            tmp_0, tmp_1 = get_op(n)\n            ans += tmp_0\n            op_1 = max(op_1, tmp_1)\n        return ans + op_1", "from functools import lru_cache\nclass Solution:\n    def minOperations(self, nums) -> int:\n        @lru_cache(None)\n        def minOpt(num):\n            if num == 0:\n                return 0, 0\n            if num % 2 == 1:\n                m, a = minOpt(num -1)\n                return m, a + 1\n            else:\n                m, a = minOpt(num //2 )\n                return m + 1, a\n\n        multiply, add = 0, 0\n        for num in nums:\n            m, a = minOpt(num)\n            multiply = max(m, multiply)\n            add += a\n        return multiply + add", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        t = 0\n        h = nums[0]\n        for n in nums:\n            if n > h:\n                h = n\n            while n:\n                n &= n - 1\n                t += 1\n        if h > 0:\n            return t + math.floor(math.log(h, 2))\n        return t", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ones=0\n        two=0\n        \n        for i in nums:\n            mul=0\n            while i:\n                if i%2==1:\n                    i=i-1\n                    ones+=1\n                else:\n                    i=i//2\n                    mul+=1\n            two=max(two,mul)\n        return ones+two\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        inc, mult = 0, 0\n        \n        \n        for i in nums:\n            if i:\n                a, b = self.getRes(i)\n                inc += a\n                mult = max(mult, b)\n            \n        return inc + mult\n    \n    def getRes(self, n):\n        inc, mult = 0, 0\n        \n        while n:\n            if n % 2 == 1:\n                n -= 1\n                inc += 1\n            else:\n                n //= 2\n                mult += 1\n        \n        return inc, mult", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op=0\n        while(len(nums)>0):\n            for i in range(len(nums)):\n                if(nums[i]%2)==1:\n                    nums[i]-=1\n                    op+=1            \n            nums = list(filter(lambda x: x != 0, nums))            \n            if(len(nums)>0):    \n                nums[:] = [int(x/2) for x in nums]                \n                op+=1        \n        return op", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        o=0\n        m=0\n        a=0\n        for i in nums:\n            m=0\n            while(i):\n                if(i%2==0):\n                    m+=1\n                    i//=2\n                else:\n                    o+=1\n                    i-=1\n            a=max(m,a)\n        return o+a", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ans=0\n        \n        while sum(nums)!=0:\n            count_odd=0\n            for i,num in enumerate(nums):\n                if num%2!=0:\n                    count_odd+=1\n                    ans+=1\n                    nums[i]=nums[i]-1\n            \n            if count_odd==0:\n                for i in range(len(nums)):\n                    nums[i]=nums[i]//2\n                ans+=1\n           \n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        lst = list(map(find_op, nums))\n        mul = max(lst, key=lambda x: x[0])\n        mul = mul[0]\n        add = sum([item[1] for item in lst])\n        return add + mul\n        \ndef find_op(n):\n    mul, add = 0, 0\n    while n > 0:\n        if n % 2 == 1:\n            add += 1\n        n //= 2\n        mul += 1\n    if mul > 0:\n        mul -= 1\n    return mul, add", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        \n        count_zeros=0\n        \n        for i in nums:\n            if i==0:\n                count_zeros+=1\n        operations=0\n        \n        while(count_zeros!=len(nums)):\n            \n            odd_max=-1\n            \n            \n            for i in range(0,len(nums)):\n                if nums[i]%2==1:\n                    operations+=1 \n                    nums[i]-=1\n                    odd_max=i\n                    if nums[i]==0:\n                        count_zeros+=1\n                    \n            \n            if odd_max==-1:\n                operations+=1\n                for i in range(0,len(nums)):\n                    nums[i]=nums[i]//2\n            \n            \n        return operations\n                        \n            \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))[2:]) - 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        for i in range(len(nums)):\n            if nums[i]%2:\n                nums[i] -= 1\n                res += 1\n        if any(nums):\n            nums = [i//2 for i in nums]\n            return res + 1 + self.minOperations(nums)\n        else:\n            return res\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        arr = nums[:]\n        res = 0\n        while any(arr):\n            odd = sum([x % 2 == 1 for x in arr])\n            if odd:\n                arr = [x - x % 2 for x in arr]\n                res += odd\n            else:\n                arr = [x // 2 for x in arr]\n                res += 1\n        return res\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # print()\n                \n        res = 0\n        while any(nums):\n            ones = sum(num & 1 for num in nums)\n            res += ones\n            nums = [num >> 1 for num in nums]\n            res += 1\n            # print(ones, nums, res)\n            \n        return res - 1\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op=0\n        a=[0]*len(nums)\n        # print(a)\n        # def modify(arr:List[int],op:int)-> None:\n        while(nums!=a):\n            # print(nums)\n            for i in range(len(nums)):\n                if nums[i]%2==0:\n                    nums[i]=nums[i]//2\n                else:\n                    op+=1\n                    nums[i]-=1\n                    nums[i]=nums[i]//2\n            op+=1\n            # modify(nums,op)\n        return (op-1)\n            \n", "class Solution:\n    def minOperations(self,nums):\n        ret = []\n        overall = 0\n        for i in nums:\n            temp = 0\n            if i == 0:\n                overall -= 1\n            if i % 2 == 1 and i != 1:\n                overall += 1\n                i -= 1\n            while i > 1:\n                if i % 2 == 1:\n                    overall += 1\n                    i -= 1\n                else:\n                    temp += 1\n                    i /= 2\n            ret.append(temp)\n        return (overall + max(ret) + len(ret))", "class Solution:\n    \n    def getOdd(self, nums):\n        for i, n in enumerate(nums):\n            if n % 2 == 1:\n                return i\n        return None\n    \n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while nums.count(0) != len(nums):\n            odd = self.getOdd(nums)\n            if odd is None:\n                for i in range(len(nums)):\n                    nums[i] = nums[i] // 2\n                res += 1\n            else:\n                for i in range(len(nums)):\n                    if nums[i] % 2 == 1:\n                        nums[i] = nums[i] - 1\n                        res += 1\n\n        return res\n            \n", "class Solution:\n  def minOperations(self, nums) -> int:\n    a = list(sorted(nums))\n\n    moves = 0\n    while True:\n      # make all even\n      for i in range(len(a)):\n        if a[i] % 2 == 1:\n          moves += 1\n          a[i] -= 1\n\n      # check if done\n      remaining = 0\n      for i in range(len(a)):\n        if a[i] > 0:\n          remaining += 1\n      if remaining == 0:\n        break\n\n      # divide by 2\n      moves += 1\n      for i in range(len(a)):\n        a[i] = a[i] // 2\n\n    return moves\n\n", "class Solution:\n    def minOperations(self, A):\n        \n        steps, n = 0, len(A)\n        while True:\n            zeros = 0\n            for i in range(n):\n                if A[i] % 2 > 0:\n                    A[i] -= 1\n                    steps += 1\n                if A[i] == 0:\n                    zeros += 1\n            if zeros == n:\n                break\n            for i in range(n):\n                A[i] >>= 1\n            steps += 1\n        return steps\n                \n                \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 3", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        zeros, ops = 0, 0\n        while zeros != len(nums):\n            odds, evens, zeros = 0, 0, 0\n            for i in range(0, len(nums)):\n                #print(nums)\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    odds += 1\n                \n                if nums[i] == 0:\n                    zeros += 1\n                else:\n                    evens += 1\n                    nums[i] //= 2\n            ops += odds\n            ops += 1 if evens else 0\n        return ops", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op1 = op2 = 0\n        for num in nums:\n            count1 = count2 = 0\n            while num:\n                if num & 1:\n                    count1 += num & 1\n                    num -= 1\n                if num:\n                    count2 += 1\n                num >>= 1\n            op1 += count1\n            op2 = max(op2, count2)\n        return op1 + op2", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res, val = 0, sum(nums)\n        while val:\n            val0 = val\n            for i, x in enumerate(nums):\n                if x % 2:\n                    nums[i] -= 1\n                    val -= 1\n            res += val0 - val\n            if val == val0:\n                for i in range(len(nums)):\n                    nums[i] //= 2\n                val //= 2\n                res += 1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        minops = 0\n        while sum(nums)>0:\n            for i,num in enumerate(nums):\n                if num&1: \n                    nums[i] -= 1\n                    minops += 1\n            nums = [num>>1 for num in nums]\n            minops += 1\n        return minops-1\n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        maxn=0\n        res=0\n        for i in range(len(nums)):\n            if(nums[i]>0):\n                #res+=1\n                if( nums[i]>0  ):\n                    count=0\n                    n=nums[i]\n                    while(n>0):\n                        if(n%2>0):\n                            res+=1\n                            n=n-1\n                        else:\n                            count+=1\n                            n=n//2\n                    if(count>maxn):\n                        maxn=count\n        return(res+maxn)        \n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        odds: List[int] = [n for n in nums if n % 2 == 1]\n        evens: Set[int] = [n for n in nums if n != 0 and n % 2 == 0]\n        new: List[int] = []\n            \n        n: int = 0\n        n_ops: int = 0\n\n        while len(odds) > 0 or len(evens) > 0:\n            if len(odds) > 0:\n                n = odds.pop() - 1\n                if n > 0:\n                    evens.append(n)\n            else:\n                new = [n // 2 for n in evens]\n                odds = [n for n in new if n % 2 == 1]\n                evens = [n for n in new if n % 2 == 0]\n            \n            n_ops += 1\n            \n        return n_ops", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def minSteps(num):\n            if num == 1:\n                return 1            \n            if num in memo:\n                return memo[num]\n            # count only odd numbers\n            memo[num] = minSteps(num // 2) if num % 2 == 0 else 1 + minSteps(num - 1)\n            \n            return memo[num]\n        \n        def countPowerOfTwo(num):\n            if num < 2: \n                return 0\n            cnt, cur = 1, 2\n            while cur * 2 <= num:\n                cnt += 1\n                cur <<= 1\n            \n            return cnt\n        \n        memo = {}\n        # count the power of two for once and only once\n        # because it these number can be used by the \\\"multiply by 2\\\" operation to all elements\n        res = countPowerOfTwo(max(nums))\n        for num in nums:\n            if num == 0:\n                continue\n            res += minSteps(num)\n        \n        return res", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        p=[]\n        ans=0\n        for i in nums:\n            r=0\n            while(i>0):\n                if (i%2==0):\n                    r+=1\n                    i/=2\n                else:\n                    ans+=1\n                    i-=1;\n            p.append(r);\n        \n\n        ans+=max(p)\n        return ans\n        \n        \n        \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        max_count = 0\n        \n        for num in nums:\n            cnt = 0\n            while num > 0:\n                if num % 2 != 0:\n                    num -= 1\n                    ans += 1\n                else:\n                    num /= 2\n                    cnt += 1\n            max_count = max(max_count, cnt)\n        \n        return ans + max_count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        big = 0\n        \n        for i in range(len(nums)):\n            k = nums[i]\n            k = bin(k)\n            ans += k.count('1')\n           # print(k)\n            big = max(big, 0, len(k)-3)\n                        \n      #  print(ans, big)\n        ans += big\n        \n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        zeros, ops = 0, 0\n        while zeros != len(nums):\n            odds, evens, zeros = 0, 0, 0\n            for i in range(0, len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    odds += 1\n                \n                if nums[i] == 0:\n                    zeros += 1\n                else:\n                    evens += 1\n                    nums[i] //= 2\n            ops += odds\n            ops += 1 if evens else 0\n        return ops", "class Solution:\n    def minOperations_1(self, nums: List[int]) -> int:\n        '''        \n        Instead of trying to go from 0 array to nums,\n        go from nums to 0 array, decrement index by 1\n        divide all elements by 2 if divisible by 2\n        \n        Nevermind this isn't DP, do greedy, divide by\n        2 as much as possible then decrement indexes by 1\n        \n        Repeat until everything is divisble by 2 again\n        \n        Runtime?\n        \n        O(3n) inner loop, 32 times outer loop because\n        divison by 2 happens frequently which shifts\n        '''\n        ops = 0\n        while not all(n == 0 for n in nums):\n            for i, n in enumerate(nums):\n                if n % 2 != 0:\n                    nums[i] = n - 1\n                    ops += 1\n            \n            if all(n == 0 for n in nums):\n                break\n            \n            nums = [n // 2 for n in nums]\n            ops += 1\n        \n        return ops\n    \n    def minOperations(self, nums: List[int]) -> int:\n        '''\n        More efficient way to do this:\n        \n        Loop through the numbers individually, count\n        the number of times you have to subtract 1 and divide\n        by 2. Add 1's to total but only take the maximum number\n        of times to divide by 2 since division affects everything\n        and so only the largest number of divisions gets taken\n        into account\n        \n             24 2 5 \n        \n        ones  2 1 2\n        \n        twos  4 1 2\n        \n        5 + max(twos) = 9\n        '''\n        op_1 = 0\n        op_2 = 0\n        for n in nums:\n            op_2_cur = 0\n            while n > 0:\n                if n % 2 != 0:\n                    op_1 += 1\n                    n -= 1\n                else:\n                    op_2_cur += 1\n                    n = n // 2\n            \n            op_2 = max(op_2, op_2_cur)\n        \n        return op_1 + op_2\n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def get_counts(x):\n            if x == 0:\n                return 0, 0\n            elif x % 2 == 0:\n                add_count, mul_count = get_counts(x // 2)\n                return add_count, mul_count+1\n            else:\n                add_count, mul_count = get_counts(x - 1)\n                return add_count + 1, mul_count\n        add_count, mul_count = 0, 0\n        for num in nums:\n            ac, mc = get_counts(num)\n            add_count += ac\n            mul_count = max(mc, mul_count)\n        return add_count + mul_count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op=0\n        while True:\n            doDivision=0\n            NoZero=1\n            for i in range(len(nums)):\n                if nums[i]!=0:\n                    NoZero=0\n                if nums[i]%2==1:\n                    nums[i]-=1\n                    op+=1\n                if nums[i]!=1 and nums[i]!=0:\n                    doDivision=1  \n                    nums[i]//=2\n            if doDivision==1:\n                op+=1\n                \n            if NoZero==1:\n                return op\n", "from typing import Tuple\nclass Solution:\n    def ones_twos(self, n: int, ones: int, twos: int) -> Tuple[int,int]:\n        if n==0:\n            return ones, twos\n        if n==1:\n            return ones+1, twos\n        if n%2==0:\n            return self.ones_twos(n//2, ones, twos+1)\n        else:\n            return self.ones_twos(n-1, ones+1, twos)\n        \n        \n    def minOperations(self, nums: List[int]) -> int:\n        ones, twos = 0, 0\n        for num in nums:\n            o,t = self.ones_twos(num, 0, 0)\n            ones += o\n            twos = max(twos, t)\n        return ones+twos\n            \n        \n", "from collections import deque\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        step = 0\n        while len(nums):\n            for i, val in enumerate(nums):\n                if val % 2:\n                    nums[i] -= 1\n                    step += 1\n            nums = self.trim(nums)\n            if len(nums):\n                step += 1\n                for i, val in enumerate(nums):\n                    if val:\n                        nums[i] /= 2\n            nums = self.trim(nums)\n        return step\n\n    def trim(self, nums):\n        return [e for e in nums if e]\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op=0\n        while True:\n            doDivision=0\n            AllZero=1\n            for i in range(len(nums)):\n                if nums[i]!=0:\n                    AllZero=0\n                if nums[i]%2==1:\n                    nums[i]-=1\n                    op+=1\n                if nums[i]!=1 and nums[i]!=0:\n                    doDivision=1  \n                    nums[i]//=2\n            if doDivision==1:\n                op+=1\n                \n            if AllZero==1:\n                return op\n", "class Solution1:\n    def minOperations(self, nums: List[int]) -> int:\n        twos = 0\n        ones = 0\n        for n in nums:\n            mul = 0\n            while n:\n                if n%2: # odd number, just delete 1 so that it's now a multiple of 2\n                    n -= 1\n                    ones += 1\n                else: # multiple of 2, so just divide by 2 \n                    n //= 2\n                    mul += 1\n            twos = max(twos, mul)\n        return ones + twos\n    \nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        maxval = max(nums)\n        idx = nums.index(maxval)\n        ans = 0\n\n        while nums[idx]!=0:\n            for i,n in enumerate(nums):\n                ans += n%2 # minus 1 to make all number even\n                nums[i] = n-n%2\n            if nums[idx]!=0: \n                for i, n in enumerate(nums): # devide all numbers by 2\n                    nums[i]=nums[i]//2\n                ans += 1\n        \n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        a = [x for x in nums if x]\n        while a:\n            # print(a, res)\n            for i, x in enumerate(a):\n                if x & 1:\n                    a[i] -= 1\n                    res += 1\n            a = [x // 2 for x in a if x]\n            if a: # if we halved any numbers\n                res += 1\n        return res\n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum( bin(x).count('1') for x in nums ) + max(len(bin(x)) for x in nums ) - 3\n            \n                \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        lru_cache(maxsize=None)\n        def check(n):\n            if n == 0:\n                return (0, 0)\n            elif n == 1:\n                return (1, 0)\n            else:\n                r1 = 0\n                r2 = 0\n\n                k, l = divmod(n, 2)\n                r1, r2 = check(k)\n                r1 += l\n                r2 += 1\n            return r1, r2\n            \n        #   \u5012\u7740\u8f6c\u6362\n        r1 = 0  #   op1 \u7684\u6b21\u6570\uff0c\u7d2f\u52a0\n        r2 = 0  #   op2 \u7684\u6b21\u6570\uff0c\u6c42\u6700\u5927\n        for n in nums:\n            c1, c2 = check(n)\n            r1 += c1\n            r2 = max(r2, c2)\n        \n        return r1 + r2", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        zeros = []\n        operations = 0\n        for item in nums:\n            zeros.append(0)\n        \n        while nums != zeros:\n            for index,item in enumerate(nums):\n                if item%2==1:\n                    nums[index]=item-1\n                    operations +=1\n                    \n            if nums==zeros:\n                break \n            for index, item in enumerate(nums):\n                if item%2==0:\n                    nums[index] = item/2\n            operations +=1 \n        \n        return operations\n            \n            \n                \n                \n            \n            \n            \n            \n        \n                \n                    \n                    \n                \n                    \n            \n            \n    \n            \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans=0\n        count = collections.Counter()\n        for n in nums:\n            if n != 0:\n                count[n] += 1\n        while len(count) > 0:\n            newcount = collections.Counter()\n            for k,v in count.items():\n                if k%2 == 0:\n                    newcount[k//2] += v\n                elif k > 1:\n                    newcount[(k-1)//2] += v\n                    ans += v\n                else:\n                    ans += v\n            ans += 1\n                    \n            count = newcount\n        return ans-1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while True:\n            for i in range(len(nums)):\n                if nums[i]%2: \n                    count += 1\n                    nums[i] -= 1\n                nums[i] //= 2\n            if not sum(nums): return count\n            count += 1\n        return count-1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def _op(arr):\n            odds, zeros = 0, 0\n            for i in range(len(arr)):\n                if arr[i] == 0:\n                    zeros += 1\n                elif arr[i]%2 == 1:\n                    arr[i] -= 1\n                    odds += 1\n            if zeros == len(arr):\n                return 0\n            if odds != 0:\n                return odds\n            for i in range(len(arr)):\n                arr[i] //= 2\n            return 1\n        \n        ans = 0\n        ops = _op(nums)\n        while ops != 0:\n            ans += ops\n            ops = _op(nums)\n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        #print(nums)\n        \n        ops = 0\n        \n        if not any(n != 0 for n in nums):\n            return 0\n        \n        while nums:\n            if any((n % 2 != 0) for n in nums):\n                #print(\\\"Not all even\\\")\n                for idx,n in enumerate(nums):\n                    #print(\\\"iterating on idx={} and n={}\\\".format(idx, n))\n                    if nums[idx] % 2 != 0:\n                        nums[idx] -= 1\n                        ops += 1\n                nums = [n for n in nums if n!=0]\n                #print(nums)\n            else:\n                #print(\\\"All even\\\")\n                ops += 1\n                nums = [int(n / 2) for n in nums]\n                #print(nums)\n            \n        return ops", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        steps = 0\n        nums = sorted(nums)\n        j = -1\n        while(j < len(nums)-1): # not every elements are 0\n            s = j+1 # calculate steps for next non_zero item\n            while s < len(nums):\n                if nums[s] == 0:\n                    j+=1\n                elif nums[s] == 1:\n                    steps+=1\n                    j+=1\n                    nums[s] = 0\n                elif nums[s]%2 == 1:\n                    steps += 1\n                    nums[s] -= 1\n                    nums[s] //= 2\n                else:\n                    nums[s] //= 2\n                s += 1\n            steps += 1\n                \n  \n            \n        return steps - 1\n        \n        \n        \n    \n    \n    \n            \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        N = len(nums)\n        res = 0\n        while True:\n            for i in range(N):\n                res += nums[i] % 2\n                nums[i] = (nums[i] - nums[i] % 2) // 2\n            if all(n == 0 for n in nums):\n                return res\n            res += 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        def do(n):\n            a, b = 0, 0\n            while n != 0:\n                if n % 2 == 1:\n                    a += 1\n                    n -= 1\n                else:\n                    b += 1\n                    n //= 2\n            return [a, b]\n        \n        aa, bb = 0, 0\n        for n in nums:\n            a, b = do(n)\n            aa += a\n            bb = max(b, bb)\n        return aa + bb", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        d = max(nums)\n        \n        if d==0:\n            return 0\n        \n        res = 0\n        while d>=2:\n            res += 1\n            d >>= 1\n            \n\n        for num in nums:\n            while num:\n                res += 1\n                num &= (num-1)\n            \n        return res\n", "import math\nclass Solution:\n    \n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        power = [0]*n\n        rem = [0]*n\n        for i in range(n):\n            j = nums[i]\n            count1 = 0\n            count2 = 0 \n            while j > 0:\n                if j%2 == 0:\n                    count1+=1\n                    j = j//2\n                else:\n                    count2+=1\n                    j = j - 1\n            power[i], rem[i] = count1, count2\n        ans = max(power) + sum(rem)\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        arr = [0] * len(nums)\n        if arr == nums:\n            return 0\n        ops = 0\n        while arr != nums:\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ops += 1\n            ops += 1\n            nums = [x / 2 for x in nums]\n        return ops - 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def odd_2_even(nums):\n            step = 0\n            new_nums = []\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    step += 1\n                    nums[i] -= 1\n                    if nums[i] > 0:\n                        new_nums.append(nums[i])\n                elif nums[i] > 0:\n                    new_nums.append(nums[i])\n            return step,new_nums\n        \n        def even_2(nums):\n            return [a//2 for a in nums]\n        \n        step = 0\n        while len(nums) > 0:\n            add,nums = odd_2_even(nums)\n            if len(nums) > 0:\n                nums = even_2(nums)\n                step += 1\n            step = step + add\n        \n        return step", "class Solution:\n  def minOperations(self, nums: List[int]) -> int:\n    cost = 0\n    d = 0\n    for a in nums:\n      division, increments = self.trick(a)\n      d = max(division, d)\n      cost += increments\n    return d + cost\n  \n  def trick(self, mx):\n    if mx in {0, 1}:\n      return (0, 0) if mx == 0 else (0, 1)\n    if mx % 2 == 0:\n      d, i = self.trick(mx // 2)\n      return (d + 1, i)\n    else:\n      d, i = self.trick(mx - 1)\n      return (d, i + 1)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        result = 0\n        \n        result_num_div = 0\n        for i in range(len(nums)):\n            num_div = 0\n            while nums[i] > 0:\n                if nums[i] % 2 == 1:\n                    result += 1\n                    nums[i] -= 1\n                if nums[i] > 1:\n                    num_div += 1\n                nums[i] /= 2\n            result_num_div = max(result_num_div , num_div)\n        return result + result_num_div", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        n = len(nums)\n        while True:\n            i = 0\n            zc = 0\n            while i < n:\n                if (nums[i]&1) > 0:\n                    break\n                elif nums[i] == 0:\n                    zc += 1\n                i+=1\n            if zc == n:\n                return res\n            if i == n:\n                for j in range(n):\n                    nums[j] = nums[j]//2\n                res+=1\n            for j in range(i,n):\n                if nums[j]&1:\n                    nums[j]-=1\n                    res+=1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def count_ops(x: int) -> int:\n            if x == 0: return (0, 0)\n            elif x == 1: return (1, 0)\n            elif x % 2 == 0:\n                add, mul = count_ops(x // 2)\n                return (add, mul+1)\n            else:\n                add, mul = count_ops(x-1)\n                return (add+1, mul)\n        \n        count = maxmul = 0\n        for i in nums:\n            add, mul = count_ops(i)\n            maxmul = max(maxmul, mul)\n            count += add\n        return count + maxmul", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans=0\n        cnt=len(nums)\n        for n in nums:\n            if n==0:cnt-=1\n        while cnt>0:\n            for i,n in enumerate(nums):\n                if n!=0 and n%2==1:\n                    nums[i]-=1\n                    ans+=1\n                    if nums[i]==0:cnt-=1\n            two=0\n            for i,n in enumerate(nums):\n                if n!=0 and n%2==0:\n                    two=1\n                    nums[i]//=2\n            ans+=two\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        arr = [0]*len(nums)\n        count=0\n        while nums!=arr:\n            check = True\n            for x in nums:\n                if x%2!=0:\n                    check = False\n            if check==True:\n                count+=1\n                for x in range(len(nums)):\n                    nums[x]=nums[x]//2\n            for x in range(len(nums)):\n                if nums[x]%2!=0:\n                    nums[x]=nums[x]-1\n                    count+=1\n        return count\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(num).count('1') for num in nums)+len(bin(max(nums)))-3", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        out = 0 \n        while sum(nums) != 0 :\n            \n            for i in range(len(nums)):\n                if nums[i] %2 == 1:\n                    nums[i] -= 1\n                    out += 1\n            \n            if sum(nums) == 0 :\n                break\n            for i in range(len(nums)):\n                nums[i] /= 2\n            \n            out += 1\n        return out\n    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while (sum(nums)):\n            \n            for i in range(len(nums)):\n                if nums[i]%2 == 1:\n                    nums[i] -= 1\n                    count += 1\n                nums[i] = nums[i]//2\n            count += 1\n            \n        return count - 1\n                    \n            \n                    \n        \n", "from copy import deepcopy\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def modify(arr, op, idx):\n            if op == 0:\n                arr[idx] = arr[idx] - 1\n            elif op == 1:\n                for i, num in enumerate(arr):\n                    arr[i] = num // 2\n                    \n        zeros = [0] * len(nums)\n        ans = 0\n        while True:\n            for i, num in enumerate(nums):\n                if num % 2 == 1:\n                    nums[i] = num - 1\n                    ans += 1\n                    \n            if nums == zeros:\n                return ans\n            else:\n                modify(nums, 1, 0)\n                ans += 1\n            \n        return ans\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ops = 0\n        N = len(nums)\n        \n        while True:\n            n = 0\n            alleven = True\n            for i, num in enumerate(nums):\n                if num == 0:\n                    n += 1\n                else:\n                    if num % 2:\n                        nums[i] -= 1\n                        if num == 0: n += 1\n                        alleven = False\n                        ops += 1\n                        \n            if n == N:\n                break \n            \n            if alleven:\n                for i in range(N):\n                    if nums[i]:\n                        nums[i] = nums[i] // 2\n                ops += 1\n        \n        \n        return ops\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        result = 0\n        while True:\n            to_continue = False\n            ops = 0\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                elif nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ops += 1\n                    to_continue = True\n                else:\n                    to_continue = True\n            if ops > 0:\n                result += ops\n            elif to_continue:\n                result += 1\n                for i in range(len(nums)):\n                    nums[i] //= 2\n            else:\n                break\n        \n        return result", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:   \n        val=max(nums)\n\n        double=0\n        add=0\n        value=0\n        count=0\n        value=val\n        while value!=0:\n            \n            if value%2==0:\n                value=value//2\n                double+=1\n            else:\n                value-=1\n                add+=1    \n        count+=double\n        print(add,double)\n        for x in nums:\n            value=x\n            half=0\n            add=0\n            while value!=0:\n                if value%2==0:\n                    value=value//2\n                    half+=1\n                else:\n                    value-=1\n                    add+=1\n               \n            count+=add\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        count = 0\n        nums = [num for num in nums if num]\n        if not nums:\n            return 0\n        while nums:\n            flag = False\n            new_nums = []\n            for num in nums:\n                if num % 2:\n                    flag = True\n                    break\n            if flag:\n                for num in nums:\n                    if num % 2:\n                        num = num - 1\n                        count += 1\n                    if num:\n                        new_nums.append(num)\n            else:\n                for num in nums:\n                    new_nums.append(num / 2)\n                count += 1\n            nums = new_nums\n        return count\n        \n", "class Solution:\n    \n    def minOperations(self, nums: List[int]) -> int:\n        operations = 0\n        while not all(n == 0 for n in nums):\n            if all(n % 2 == 0 for n in nums):\n                nums = [n / 2 for n in nums]\n                operations += 1\n            else:\n                for i, num in enumerate(nums):\n                    if num % 2 != 0:\n                        nums[i] = num - 1\n                        operations += 1\n        return operations\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ans_count = 0\n        while True:\n            zero_count = 0\n            have_odd = False\n            ## op1\n            for idx in range(len(nums)):\n                if nums[idx] % 2 != 0:\n                    have_odd = True\n                    ans_count += 1\n                    nums[idx] -= 1\n                if nums[idx] == 0:\n                    zero_count += 1\n            ## check if all zero(break)\n            if zero_count == len(nums):\n                break\n            ## op2\n            if not have_odd:\n                ans_count += 1\n                for idx in range(len(nums)):\n                    nums[idx] //= 2\n            #print(nums, ans_count, zero_count)\n\n        return ans_count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            ans += sum(n % 2 for n in nums)\n            if any(n > 1 for n in nums):\n                ans += 1\n            for i in range(len(nums)):\n                nums[i] //= 2\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # l = len(nums)\n        sol = nums\n        cost = 0 \n        # print(len(sol))\n        while sum(sol)>0:\n            for i in range(len(sol)):\n                # print(sol[i]&1)\n                if sol[i]&1 != 0:\n                    sol[i]-=1\n                    cost+=1\n            # print('sol after odd flip :',sol)\n            if len(sol)>0:\n                sol = [x//2 for x in sol if x>0]\n                if len(sol)>0:\n                    cost+=1\n            # print('sol after /2 :',sol)\n        return cost \n\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        delete_count = 0\n        divide_count = 0\n        for e in nums:\n            divide = 0\n            while e != 0:\n                if e % 2:\n                    e -= 1\n                    delete_count += 1\n                else:\n                    e /= 2\n                    divide += 1\n            divide_count = max(divide_count, divide)\n        return delete_count + divide_count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # do it the other way around\n        n_op = 0\n        l = len(nums)\n        target = l*[0]\n        while nums != target:\n            if all(i%2 == 0 for i in nums):\n                nums = [i/2 for i in nums]\n                n_op+=1\n            else:\n                for i in range(l):\n                    if nums[i]%2 == 1:\n                        nums[i]-=1\n                        n_op+=1\n        return n_op", "class Solution:\n    \n    def minOperations(self, nums: List[int]) -> int:\n        ans=0\n        ma=0\n        for n in nums:\n            k=0\n            while(n!=0):\n                if(n%2==0):\n                    k+=1\n                    n=n//2\n                else:\n                    n-=1\n                    ans+=1\n                ma=max(ma,k)\n        return ans+ma\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        '''        \n        Instead of trying to go from 0 array to nums,\n        go from nums to 0 array, decrement index by 1\n        divide all elements by 2 if divisible by 2\n        \n        Nevermind this isn't DP, do greedy, divide by\n        2 as much as possible then decrement indexes by 1\n        \n        Repeat until everything is divisble by 2 again \n        \n        4 2 5 \n        \n        4 2 4  + 1\n        \n        2 1 2  + 1\n        \n        2 0 2  + 1\n        \n        1 0 1  + 1\n        \n        0 0 0  + 2\n        '''\n        ops = 0\n        while not all(n == 0 for n in nums):\n            for i, n in enumerate(nums):\n                if n % 2 != 0:\n                    nums[i] = n - 1\n                    ops += 1\n            \n            if all(n == 0 for n in nums):\n                break\n            \n            nums = [n // 2 for n in nums]\n            ops += 1\n        \n        return ops\n    \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        divied2 = 0\n        res = 0\n        for i in nums:\n            temp = 0\n            while i>0:\n                if i % 2 == 0:\n                    i //= 2\n                    temp += 1\n                else:\n                    i -= 1\n                    res += 1\n                divied2 = max(divied2, temp)\n            #print(res)\n        return res + divied2\n                    \n        # max_ = max(nums)\n        # dp = [(float('inf'),float('inf'),float('inf'))]*(max_+1)\n        # dp[0] = (0,0,0)\n        # dp[1] = (1,1,0)\n        # dp[2] = (2,1,1)\n        # for i in range(3, len(dp)):\n        #     if i % 2 == 0:\n        #         if dp[i//2][0]+1 > dp[i-1][0]+1:\n        #             dp[i] = (dp[i-1][0]+1, dp[i-1][1]+1, dp[i-1][2])\n        #         else:\n        #             dp[i] = (dp[i//2][0]+1, dp[i-1][1], dp[i-1][2]+1)\n        #     else:\n        #         dp[i] = (dp[i-1][0]+1, dp[i-1][1]+1, dp[i-1][2])\n        # print(dp)\n        # temp = 0\n        # res = 0\n        # for i in nums:\n        #     temp = max(temp, dp[i][2])\n        #     res += dp[i][1] \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        double = 0\n        \n        for i in range(len(nums)):\n            cd = 0\n            while nums[i] > 0:\n                if nums[i] % 2 == 1:\n                    count += 1\n                cd += 1\n                nums[i] //= 2\n            double = max(double,cd)\n            \n        return count + double - 1 ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        counter = 0\n        while 1:\n            temp_counter = 0\n            bigger_than_zero = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    temp_counter += 1\n                    nums[i] -= 1\n                if nums[i] > 0:\n                    bigger_than_zero += 1\n                    temp = bin(nums[i])\n            counter += temp_counter\n            if bigger_than_zero == 0 :\n                return counter\n\n            counter += 1\n            for i in range(len(nums)):\n                nums[i] //= 2\n        return counter", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3        ", "masks = [0b01010101010101010101010101010101,\n         0b00110011001100110011001100110011,\n         0b00001111000011110000111100001111,\n         0b00000000111111110000000011111111,\n         0b00000000000000001111111111111111]\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        totOddRem = 0\n        maxX = nums[0]\n        for x in nums:\n            if x == 1:\n                totOddRem += 1\n            else:                \n                xCopy = x\n                for p, m in enumerate(masks):\n                    xCopy = (xCopy & m) + ((xCopy & ~m) >> (1 << p))\n                totOddRem += xCopy\n            if x > maxX:\n                maxX = x\n                \n        leftMost = 0\n        step = 16\n        for m in reversed(masks):\n            m = ~m\n            if m & maxX != 0:\n                leftMost += step\n                maxX &= m\n            step >>= 1       \n                    \n        return totOddRem + leftMost", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        onesCount = 0\n        aboveOneIdxs = []\n        for idx, n in enumerate(nums):\n            if n == 1:\n                onesCount += 1\n            elif n > 1:\n                aboveOneIdxs.append(idx)\n                \n        while onesCount + len(aboveOneIdxs) != 0:\n            count += onesCount\n            onesCount = 0\n            newAboveOneIdxs = []\n            for idx in aboveOneIdxs:\n                if nums[idx] % 2 != 0:\n                    nums[idx] -= 1\n                    count += 1\n                nums[idx] //= 2\n                if nums[idx] == 1:\n                    onesCount += 1\n                else:\n                    newAboveOneIdxs.append(idx)\n            if len(aboveOneIdxs) > 0:\n                count += 1 # multiplied by 2\n            aboveOneIdxs = newAboveOneIdxs\n                    \n        return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n=len(nums)\n        noz=0\n        nosteps=0\n        while(noz!=n):\n            noz=0\n            noe=0\n            noo=0\n            for i in range(len(nums)):\n                if(nums[i] == 0):\n                    noz+=1\n                    noe+=1\n                elif(nums[i]%2 == 0):\n                    noe+=1\n                    nums[i]=nums[i]//2\n                else:\n                    noo+=1\n                    nums[i]-=1\n                    nums[i]=nums[i]//2\n            nosteps+=noo\n            if(noz==n):\n                break\n            nosteps+=1\n        return nosteps-1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # After having implemented minOperations_dumb_solution(), we realize that \n        # the number of op 1 we'll need to do is just the number of times we need\n        # to divide the max even number we ever encounter to get it down to zero. \n        # Because, a division would reduce everyone by 2 and when the smaller even\n        # numbers we see gets down to zero, it will no longer be affected. We only care\n        # about dividing the biggest even number down to zero.\n        cost = 0\n        max_nb_op_1 = 0\n        for i in range(len(nums)):\n            nb_op_0 = nb_op_1 = 0\n            x = nums[i]\n            while x > 0:\n                if x % 2 != 0:\n                    nb_op_0 += x % 2\n                    x -= x % 2\n                if x > 0:\n                    nb_op_1 += 1\n                    x = x // 2\n            cost += nb_op_0\n            max_nb_op_1 = max(max_nb_op_1, nb_op_1)\n        cost += max_nb_op_1\n        return cost\n    \n    def minOperations_dumb_solution(self, nums: List[int]) -> int:\n        # Key insight is if nums[i] is odd, there's no way we could have arrived at nums[i]\n        # via op 1, i.e. by multiplying by 2 some previous value. So the only way we could\n        # have gotten here is by using op 0, nums[i] % 2 times. That is we need to skim off\n        # the remainder part that makes it non-even before we can consider using op 1.\n        cost = 0\n        while True:\n            all_zeros = True\n            all_evens = True\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                \n                all_zeros = False\n                if nums[i] % 2 != 0:\n                    cost += nums[i] % 2\n                    nums[i] = nums[i] - (nums[i] % 2)\n                    all_evens = False\n            \n            if all_zeros:\n                break\n            while all_evens:\n                for i in range(len(nums)):\n                    nums[i] = nums[i] // 2\n                    if nums[i] % 2 != 0:\n                        all_evens = False\n                cost += 1\n                \n        return cost\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        num_operations = 0\n        \n        odd = True\n        even = False\n        \n        while odd or even:\n            if odd:\n                for i in range(len(nums)):\n                    if nums[i] != 0:\n                        if nums[i] % 2:\n                            nums[i] -= 1\n                            num_operations += 1\n                        if nums[i]:\n                            even = True\n                odd = False\n                \n            if even:\n                num_operations += 1\n                for i in range(len(nums)):\n                    nums[i] /= 2\n                    if nums[i] % 2:\n                        even = False\n                        odd = True\n                        \n        \n        return num_operations", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        def modify(arr, op, ind):\n            if op == 0:\n                arr[ind] = arr[ind] + 1\n            if op == 1:\n                for i in range(len(arr)):\n                    arr[i] = arr[i] * 2\n            return arr\n        \n        arr = [0] * n\n        # print(arr)\n        # interesting how would you go about solving this?\n        # is there a greedy solution\n        # so for example every non 0 elt in the array\n        # need a +1 operation to make it non zero\n        # if a value is odd and not one we need a min of \n        # 3 operations to get to where it needs to be\n        # \n        # can cache number of ops probably\n        # print(nums)\n        ops_needed = 0\n        check_ind = 0\n        nums.sort(key = lambda x: -x)\n        while any(n!=0 for n in nums):\n            for ind, numb in enumerate(nums):\n                if numb >= 1 and numb % 2 == 1:\n                    ops_needed += 1\n                    # print(\\\"odd: \\\", nums, ops_needed)\n                    nums[ind] = nums[ind] - 1\n            \n            for numb in nums:\n                if numb >= 1 and numb % 2 == 0:\n                    ops_needed += 1\n                    # print(\\\"even: \\\", nums, ops_needed)\n                    for ind, elt in enumerate(nums):\n                        nums[ind] = nums[ind] / 2\n                    break\n                        \n            check_ind += 1\n            if check_ind > 100:\n                break\n            # nums.sort(key = lambda x: -x)\n        return ops_needed", "class Solution:\n    def makeHalf(self, a):\n        for i in range(len(a)):\n            a[i] //= 2\n            \n    def makeEven(self, a):\n        c = 0\n        for i in range(len(a)):\n            if a[i]%2 == 0:\n                continue\n            else:\n                a[i] -= 1\n                c+=1\n        return c\n    def minOperations(self, nums: List[int]) -> int:\n        op = 0\n        while sum(nums) != 0:\n            op += self.makeEven(nums)\n            if sum(nums) == 0:\n                return op\n            self.makeHalf(nums)\n            op +=1\n        return op\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        counter = 0\n        while 1:\n            temp_counter = 0\n            bigger_than_zero = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    temp_counter += 1\n                    nums[i] -= 1\n                if nums[i] > 0:\n                    bigger_than_zero += 1\n                    temp = bin(nums[i])\n            counter += temp_counter\n            if bigger_than_zero == 0 :\n                return counter\n\n            counter += 1\n            \n            for i in range(len(nums)):\n                nums[i] //= 2\n        return counter", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n      res = 0\n      while sum(nums) != 0:\n        counts = sum([x % 2 == 0 for x in nums])\n        if counts == len(nums):\n          for i in range(len(nums)):\n            nums[i] = nums[i]//2\n          res += 1\n        else:\n          for i in range(len(nums)):\n            if nums[i] % 2 != 0:\n              nums[i] -= 1\n              res += 1\n      return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        print(0 % 2)\n        step = 0\n        while any(( n > 0 for n in nums)):\n            # print('nums', nums)\n            if all((n % 2 == 0 for n in nums)):\n                nums = [n // 2 for n in nums]\n                step += 1\n            else:\n                # find odd element\n                remain_idx = []\n                for i, v in enumerate(nums):\n                    if v % 2 == 1:\n                        nums[i] = nums[i] - 1\n                        if nums[i] == 0:\n                            # remain_idx.append(i)\n                            del nums[i]\n                        step += 1\n                # nums = [ nums[ri] for ri in remain_idx]\n        return step", "masks = [0b01010101010101010101010101010101,\n         0b00110011001100110011001100110011,\n         0b00001111000011110000111100001111,\n         0b00000000111111110000000011111111,\n         0b00000000000000001111111111111111]\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        totOddRem = 0\n        maxX = nums[0]\n        for x in nums:\n            if x == 1:\n                totOddRem += 1\n            else:                \n                xCopy = x\n                for p, m in enumerate(masks):\n                    xCopy = (xCopy & m) + ((xCopy & ~m) >> (1 << p))\n                totOddRem += xCopy\n            if x > maxX:\n                maxX = x\n                \n        leftMost = 0\n        step = 16\n        for m in reversed(masks):\n            mr = ~m\n            if mr & maxX != 0:\n                leftMost += step\n                maxX &= mr\n            step >>= 1       \n                    \n        return totOddRem + leftMost", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        \n        def even(A):\n            for i in range(len(A)):\n                A[i]//=2\n            return A\n        \n        def odd(A):\n            c=0\n            z=0\n            for i in range(len(A)):\n                if A[i]%2==1:\n                    A[i]-=1\n                    c+=1\n                    if A[i]==0:\n                        z+=1\n            return A,c,z\n        \n        res=0\n        zero=0\n        for i in A:\n            if i==0:\n                # res+=1\n                zero+=1\n        \n        while(zero<len(A)):\n            A,c,z=odd(A)\n            zero+=z\n            res+=c\n            \n            if zero<len(A):\n                A=even(A)\n                res+=1\n        return res\n        # A=[]\n        # for i in range(1, 10001):\n        #     A.append(i)\n        # print(A)\n\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count=0\n        res={}\n        for i in range(len(nums)):\n            if nums[i]!=0:\n                res[i]=nums[i]\n        zeros=[]\n        while res:\n            zeros.clear()\n            for key in res:\n                if res[key]%2!=0:\n                    res[key]-=1\n                    count+=1\n                    minus=True\n                if res[key]==0:\n                    zeros.append(key)\n            for zero in zeros:\n                res.pop(zero)\n            if res:\n                for key in res:\n                    res[key]//=2\n                count+=1\n        return count\n            \n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            temp = [0] * len(nums)\n            flag = False\n            for i in range(len(nums)):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    flag = True\n                    ans += 1\n                elif not flag and not nums[i] % 2:\n                    temp[i] = nums[i] // 2\n            if not flag:\n                ans += 1\n                nums = temp\n            #print(nums)\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        s = sum(nums)\n        res = 0\n        while s:\n            for i in range(len(nums)):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    res += 1\n            s = 0\n            nums = list([x for x in nums if x>0])\n            if not nums:\n                break\n            # mineve = min(nums)\n            for i in range(len(nums)):\n                nums[i] //= 2\n                s += nums[i]\n            res += 1\n        return res\n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # try to get to same distance from the 2's time\n        nops = 0\n        all_z = False\n        while not all_z: \n            all_z = True\n            op2_mark = False\n            for idx, val in enumerate(nums): \n                if val != 0: \n                    all_z = False\n                else: \n                    continue\n                if val % 2 ==0: \n                    if not op2_mark: \n                        nops += 1\n                        op2_mark = True\n                    nums[idx] /= 2\n                else: \n                    nops += 1\n                    if (nums[idx] -1) > 0: \n                        if not op2_mark: \n                            nops += 1\n                            op2_mark = True\n                    nums[idx] = (nums[idx] -1 ) / 2\n        return nops\n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        seen_nonzero = True\n        while True:\n            all_zeros = True\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n                if nums[i] > 0:\n                    all_zeros = False\n                    \n            if all_zeros:\n                break\n                \n            for i in range(len(nums)):\n                nums[i] = nums[i] // 2\n            ans += 1\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        result = 0\n\n        \n        while True:\n            for i, x in enumerate(nums):\n                if x & 1:\n                    result += 1\n                    nums[i] -= 1\n            if all(x == 0 for x in nums):\n                return result\n            \n            for i, x in enumerate(nums):\n                nums[i] //= 2\n            result += 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ans = 0\n        \n        while sum(nums) != 0:\n            tmp = nums.copy()\n            ones_tmp = nums.copy()\n            cnt = 0\n            ones_cnt = 0\n            flag = False\n            for i,a in enumerate(nums):\n                if a == 1:\n                    ones_cnt += 1\n                    ones_tmp[i] = 0\n                    flag = True\n                \n                tmp[i] = nums[i] // 2\n                cnt += nums[i] % 2\n            \n            if flag:\n                ans += ones_cnt\n                nums = ones_tmp[:]\n            else:\n                ans += cnt + 1\n                nums = tmp[:]\n        \n        return ans\n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while nums != [0] * len(nums):\n            for i in range(len(nums)):\n                if nums[i] == 1:\n                    nums[i] -= 1\n                    res += 1\n                elif nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    res += 1\n            if nums == [0] * len(nums):\n                break\n            for i in range(len(nums)):\n                nums[i] //= 2\n            res += 1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        #print(nums)\n\n        \n        ret = 0\n        for i, x in enumerate(nums):\n            if x % 2:\n                ret += 1\n                nums[i] -= 1\n        \n        if all(x == 0 for x in nums):\n            return ret\n        \n        for i, x in enumerate(nums):\n            nums[i] //= 2\n        ret += 1\n        #print(nums, ret)\n        return ret + self.minOperations(nums)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        count = 0\n    \n        while 1:\n            \n            for i, vi in enumerate(nums):\n                \n                if vi&1:\n                    count += 1\n                    nums[i] = vi - 1\n                        \n            \n            chk = True\n            \n            for i, vi in enumerate(nums):\n                if vi > 0:\n                    chk = False\n                nums[i] = vi // 2\n                \n            if chk:\n                break\n                \n            count += 1\n            \n                \n        return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        zeros = sum([num==0 for num in nums])\n        odds = set([i for i in range(len(nums)) if nums[i]%2])\n        n = len(nums)\n        count = 0\n        while zeros < n:\n            if odds:\n                for oddidx in odds:\n                    nums[oddidx] = nums[oddidx]-1\n                    if nums[oddidx] == 0:\n                        zeros += 1\n                count += len(odds)\n                odds = set()\n            else:\n                for i in range(n):\n                    if nums[i] > 0:\n                        nums[i] = nums[i]//2\n                        if nums[i]%2:\n                            odds.add(i)\n                count += 1\n        return count\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n , res = len(nums), 0\n        mul = [0] * n\n        for i in range(n):\n            while nums[i]!= 0:\n                if nums[i]%2:\n                    res += 1\n                    nums[i] -= 1\n                else:\n                    mul[i] += 1\n                    nums[i] //= 2\n            \n        return res + max(mul)\n                \n           \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        s = sum(nums)\n        while s!=0:\n            nums_2 = [num%2 for num in nums]\n            diff = sum(nums_2)\n            if diff==0:\n                nums = [num//2 for num in nums]\n                ans += 1\n                s //= 2\n            else:\n                ans += diff\n                s -= diff\n                nums = [nums[i]-nums_2[i] for i in range(n)]\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cost = 0\n        while True:\n            all_zeros = True\n            all_evens = True\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                \n                all_zeros = False\n                if nums[i] % 2 != 0:\n                    cost += nums[i] % 2\n                    nums[i] = nums[i] - (nums[i] % 2)\n                    all_evens = False\n            \n            if all_zeros:\n                break\n            if all_evens:\n                for i in range(len(nums)):\n                    nums[i] = nums[i] // 2\n                cost += 1\n                \n        return cost\n                    \n", "class Solution:\n    def minOperations(self, nums):\n        add_operations = {}\n        result = 0\n        max_m = 0\n        \n        \n        for i in nums:\n            current = i\n            if current in add_operations:\n                result += add_operations[current]\n            else:\n                add_amount = 0\n                multiplying_amount = 0\n                \n                while current:\n                    if current % 2:\n                        add_amount += 1\n                        current -= 1\n                    else:\n                        multiplying_amount += 1\n                        current = current / 2\n                max_m = max(max_m, multiplying_amount)\n                result += add_amount\n                add_operations[i] = add_amount\n        return result + max_m\n                        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        mmax = float('inf')\n        while mmax > 0:\n            mmax = 0\n            for i in range(len(nums)):\n                if nums[i]&1 == 1:\n                    nums[i] -= 1\n                    res += 1\n                mmax = max(mmax, nums[i])\n            if mmax > 0:\n                nums = [x//2 for x in nums]\n                res += 1\n        return res\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        self.ans = 0\n        self.nums = nums\n        ## ALL numbers are even now\n        def manipulate():\n            for i in range(len(self.nums)):\n                if self.nums[i] % 2 == 1:\n                    self.ans += 1\n                    self.nums[i] -= 1\n            \n            ### TRY maximum divide\n            def allEven():\n                for num in self.nums:\n                    if num % 2 == 1:\n                        return False\n                return True\n            if AllZero():\n                return\n            while allEven():\n                self.nums = [num / 2 for num in self.nums]\n                self.ans += 1\n        \n        \n        def AllZero():\n            for num in self.nums:\n                if num != 0:\n                    return False\n            return True\n        \n        while not AllZero():\n            manipulate()\n        return int(self.ans)\n        \n        \n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        m = max(nums)\n        n = math.floor(math.log(m,2))\n        res = 0\n        while n >= 1:\n            #print(nums)\n            for i, num in enumerate(nums):\n                if num >= 2**n:\n                    if num%2 == 1:\n                        res += 1\n                        nums[i] = (nums[i]-1)/2\n                    else:\n                        nums[i] = nums[i]/2\n            res += 1\n            n = n-1\n        for num in nums:\n            if num == 1:\n                res += 1\n        return res\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        total = sum(nums)\n\n        while total != 0:\n            evens = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 != 0:\n                    nums[i] -= 1\n                    res += 1\n                    total -= 1\n                else:\n                    evens += 1\n            \n            if evens == len(nums):\n                for i in range(len(nums)):\n                    nums[i] /= 2\n                    total -= nums[i]\n                res += 1\n        \n        return res", "class Solution:\n    def pow2(self, num):\n        addition = 0\n        mult = 0\n        while num > 0:\n            if num % 2 == 0:\n                num = num // 2\n                mult += 1\n            else:\n                num -= 1\n                addition += 1\n        return (mult, addition)\n    \n    def minOperations(self, nums: List[int]) -> int:\n        result, _ = self.pow2(max(nums))\n        for num in nums:\n            if num > 0:\n                result += self.pow2(num)[1]\n        return result", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        lim = len(nums)\n        \n        test = [0]*lim\n        \n        t = 0\n        \n        while nums!=test:\n            vals = []\n            v = 0\n            \n            for i in range(0,lim):\n                if nums[i]%2==0:\n                    vals.append(nums[i]//2)\n                else:\n                    nums[i]-=1\n                    v+=1\n            if v==0:\n                nums = vals\n                t+=1\n            else:\n                t+=v\n        return t\n            \n                    \n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        big = 0\n        ans = 0\n        for i in range(len(nums)):\n            twos = 0\n            while nums[i] > 0:\n                if nums[i] % 2 == 0:\n                    twos += 1\n                    nums[i] = nums[i] // 2\n                else:\n                    ans += 1\n                    nums[i] -= 1\n                \n            if twos > big:\n                big = twos\n        return ans + big", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ones = 0\n        twos = 0\n        \n        for n in nums:\n            muls = 0\n            while n > 0:\n                if n % 2 != 0:\n                    ones += 1\n                    n -= 1\n                else:\n                    muls += 1\n                    n /= 2\n                    \n            twos = max(muls, twos)\n            \n        return ones+twos", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if set(nums) == set([0]):\n            return 0\n        ops = 0\n        while set(nums) != set([0]):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ops += 1\n            if set(nums) != set([0]):\n                nums = list([x // 2 for x in nums])\n                ops += 1\n        return ops                    \n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # \u5355\u6570\u80af\u5b9a\u8981\u5355\u72ec\u52a0\uff0c\u5076\u6570\u53ef\u4ee5\u4e00\u8d77\u589e\u957f\n        max_log = 0\n        count_zero = 0\n        steps = 0\n        for num in nums:\n            if num!= 0:\n                log_num = 0\n                while num>0:\n                    if num%2==0: # \u5076\u6570\n                        num /= 2\n                        log_num += 1\n                    else: # \u5947\u6570\n                        steps += 1\n                        num -= 1\n                max_log = max(max_log, log_num)\n        return steps + max_log", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ans = 0 \n        peak = 0 \n        for n in nums :\n            ans += bin(n)[2:].count('1')\n            peak = max(peak,len(bin(n)[2:])-1)\n        return ans + peak \n            \n", "class Solution:\n    def minOperations(self, target: List[int]) -> int:\n        result = 0  \n        while (True):    \n            zero_count = 0\n            i = 0\n            n = len(target)\n            while (i < n): \n                if ((target[i] & 1) > 0):  \n                    break;  \n                elif (target[i] == 0):  \n                    zero_count += 1\n                i += 1 \n            if (zero_count == n):  \n                return result\n            if (i == n):  \n                for j in range(n): \n                    target[j] = target[j] // 2 \n                result += 1 \n            for j in range(i, n):  \n                if (target[j] & 1):  \n                    target[j] -= 1 \n                    result += 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while nums != [0]*len(nums):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n            if nums != [0]*len(nums):\n                for i in range(len(nums)):\n                    nums[i] //= 2\n                ans += 1\n        return ans", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        if all(v == 0 for v in A):\n            return 0\n        curr = 0\n        A_next = A.copy()\n        changed = False\n        for i, v in enumerate(A):\n            if v % 2 == 1:\n                changed = True\n                curr += 1\n                A_next[i] = v-1\n        if not changed:\n            return 1 + self.minOperations([v//2 for v in A])\n        else:\n            return curr + self.minOperations(A_next)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        moves =0\n        while True:\n            zeros = 0\n            for i in range(n):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    moves += 1\n                    \n            for i in range(n):\n                if nums[i] == 0: zeros += 1\n            if zeros == n:\n                return moves\n            \n            for j in range(n):\n                nums[j] //= 2\n            moves += 1\n            \n                \n                    \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cnt = 0 \n        while any(nums):\n            even = 0\n            # if any odd -> deduct 1 from all \n            for k, v in enumerate(nums):\n                if v % 2 == 1:\n                    cnt += 1 \n                    nums[k] -= 1  \n                elif v > 0:\n                    even += 1 \n            if even > 0:\n                nums = list([x//2 for x in nums])\n                cnt +=1\n            \n        return cnt\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n     \n        self.count = 0\n        def sub(nums):\n            for i in range(len(nums)):\n                if nums[i]%2!=0:\n                    nums[i]-=1\n                    self.count+=1\n            return nums\n        \n        def divide_all(nums):\n            for k in range(len(nums)):\n                if nums[k] == 0 or nums[k]%2==0:\n                    nums[k]//=2\n                else:\n                    return []\n            return nums\n        \n        def zeros(nums):\n            c = 0\n            for n in nums:\n                if n==0:\n                    c+=1\n            return c\n        \n        sub(nums)\n        while zeros(nums)<len(nums):\n            divide_all(nums)\n            self.count+=1\n            sub(nums)\n\n        return self.count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        while any(nums):\n            for i in range(len(nums)):\n                if nums[i] % 2 != 0:\n                    nums[i] -= 1\n                    ops += 1\n            if any(nums):\n                for i in range(len(nums)):\n                    nums[i] = nums[i] // 2\n                ops += 1\n        return ops", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def check(nums):\n            flag = False\n            for n in nums:\n                if n > 1:\n                    flag = True\n            return flag\n        \n        cnt = 0\n        n = len(nums)\n        flag = check(nums)\n        while flag:\n            # print(nums)\n            cnt += 1\n            for i in range(n):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    nums[i] = nums[i] // 2\n                    cnt += 1\n                else:\n                    nums[i] = nums[i] // 2\n            # print(cnt)\n            flag = check(nums)\n        for n in nums:\n            if n != 0:\n                cnt += 1\n        return cnt                ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        nums.sort()\n        \n        n = len(nums)\n        \n        q = collections.deque()\n        q += [(0, nums)]\n        tot = [0] * n\n        while q:\n            \n            cnt, t = q.popleft()\n            if t == tot:\n                return cnt\n            flag = False\n            for i in range(n):\n                if t[i] % 2:\n                    cnt += 1\n                    t[i] -= 1\n                if t[i] != 0:\n                    flag = True\n                t[i] //= 2\n                # print (t[i], cnt, flag)\n            if flag:\n                cnt += 1\n            # print (cnt, t)\n            q+=[(cnt, t)]\n        \n        return 0\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(x).count('1') for x in nums ) + len(bin(max(nums))) -3 ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        plus = 0\n        double = 0\n        for x in nums:\n            if(x!=0):\n                plus+=1\n            counter =0\n            while(x/2>=1):\n                if(x%2!=0 and x!=1):\n                    plus+=1\n                    x-=1\n                x/=2\n                counter+=1\n            double = max(double,counter)\n        return plus+double", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        m = 0\n        numb = len(nums)\n        while True:\n            zc = 0\n            var = 0\n            for i in range(numb):\n                if nums[i]%2 != 0:\n                    nums[i] = nums[i]-1\n                    m+=1\n                if nums[i] == 0:\n                    zc +=1\n            if zc == numb:\n                break\n            nums = list([i//2 for i in nums])\n            m +=1\n        return m\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        \n        \n        res=0\n        while sum(nums) !=0:\n            for i in range(len(nums)):\n                if nums[i] %2 ==1:\n                    res +=1\n                    nums[i] -=1\n            if sum(nums) !=0:\n                res +=1\n                for i in range(len(nums)):\n                    nums[i] = nums[i]//2\n        \n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        counter = 0\n        while 1:\n            temp_counter = 0\n            bigger_than_zero = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    temp_counter += 1\n                    nums[i] -= 1\n                if nums[i] > 0:\n                    bigger_than_zero += 1\n                    temp = bin(nums[i])\n            counter += temp_counter\n            if bigger_than_zero == 0 :\n                return counter\n\n            run_again = True\n            while run_again:\n                counter += 1\n                for i in range(len(nums)):\n                    nums[i] //= 2\n                    if nums[i] % 2 == 1:\n                        run_again = False\n        return counter", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        self.count = 0\n        all_even = False\n        def reduce():\n            nonlocal all_even\n            zero = 0\n            if all_even:\n                for i, num in enumerate(nums):\n                    nums[i] >>= 1\n                    if nums[i] & 1:\n                        all_even = False\n                    zero += num == 0\n                self.count += 1\n            else:\n                for i, num in enumerate(nums):\n                    if num & 1:\n                        self.count += 1\n                        nums[i] -= 1\n                all_even = True\n            return zero\n        \n        while True:\n            n = reduce()\n            if n == len(nums):\n                break\n        return self.count - 1\n            \n                    \n            \n                    \n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        mul = [0 for i in range(len(nums))] #for each number of increment by 1 needed\n        res = 0\n        for i in range(len(nums)):\n            while nums[i]!=0:\n                if nums[i]%2 ==1:\n                    res +=1\n                    nums[i]-=1\n                else:\n                    mul[i]+=1\n                    nums[i]//=2\n            \n        return res + max(mul)\n                \n           \n            \n", "from collections import deque\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        stack = deque([[nums, 0]])\n        while stack:\n            cur_nums, count = stack.popleft()\n            if all([n == 0 or n == 1 for n in cur_nums]):\n                return sum(cur_nums) + count\n            \n            if all([n % 2 == 0 for n in cur_nums]):\n                stack.append([[n // 2 for n in cur_nums], count + 1])\n                continue\n            \n            tmp = [] \n            for n in cur_nums:\n                if n % 2 == 1:\n                    count += 1\n                    tmp.append(n - 1)\n                else:\n                    tmp.append(n)\n            stack.append([tmp, count]) ", "class Solution:\n    def minOperations(self, nums, op = 0):\n        isum = 0 \n        e = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 != 0:\n                op = op + 1\n                nums[i] = (nums[i] - 1)\n                if nums[i] != 0:\n                    e = 1 \n                    nums[i] = nums[i]/2\n            else:\n                if nums[i] != 0:\n                    e = 1 \n                    nums[i] = nums[i]/2\n            isum  = isum +nums[i]\n        op = op + e\n        if isum == 0:\n            return op\n        return  self.minOperations(nums,op)\n                      \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while True:\n            maxv = 0\n            for k in range(len(nums)):\n                if nums[k] % 2:\n                    nums[k] -= 1\n                    ans += 1\n                maxv = max(maxv, nums[k])\n            if maxv == 0:\n                break\n            if maxv > 0:\n                for k in range(len(nums)):\n                    nums[k] //= 2\n                ans += 1\n        return ans\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while any(nums):\n            for i, n in enumerate(nums):\n                if n & 1:\n                    nums[i] -= 1\n                    res += 1\n                nums[i] >>= 1\n            res += any(nums)\n        return res\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res, n=0, len(nums)\n        for i in range(32):\n            zero, one=0, 0\n            for j in range(n):\n                if nums[j] & 1==1: one+=1                \n                nums[j]>>=1\n                if nums[j]==0: zero+=1\n            res+=one\n            if zero==n: break\n            else: res+=1\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        max_zero = 0\n\n        for i in range(len(nums)):\n            zero, one = Solution.parse(nums[i])\n            res += one\n            max_zero = max(max_zero, zero)\n        res += max_zero\n        \n        return res\n        \n    def parse(v):\n        zero, one = 0, 0\n        while v > 0:\n            if v % 2 == 1:\n                one += 1\n                v -= 1\n            else:\n                zero += 1\n                v /= 2\n        return zero, one", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        count=0\n        while sum(nums)!=0:\n            for i in range(len(nums)):\n                if nums[i]%2!=0:\n                    nums[i]-=1\n                    count+=1\n                    \n            for i in range(len(nums)):   \n                nums[i]/=2\n            if sum(nums)!=0:\n                count+=1\n            \n        return count         ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        res = 0\n        while True:\n            divide = False\n            all_zero = True\n            for i, n in enumerate(nums):\n                if n == 0: continue\n                all_zero = False\n                if n > 1: divide = True\n                res += n % 2\n                nums[i] //= 2\n            res += int(divide)\n            if all_zero: break\n        \n        return res\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if not nums or sum(nums) == 0: return 0\n        cnt = 0\n        while sum(nums) != 0:\n            if all(num % 2 == 0 for num in nums):\n                cnt += 1\n                for i in range(len(nums)):\n                    nums[i] //= 2\n            else:\n                for i in range(len(nums)):\n                    if nums[i] % 2:\n                        cnt += 1\n                        nums[i] -= 1\n        return cnt", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        steps = 0\n        nums = sorted(nums)\n        j = -1\n        while(j < len(nums) - 1): # not every elements are 0\n            s = j+1 # calculate steps for next non_zero item\n            while s < len(nums):\n                if nums[s] == 0:\n                    j+=1\n                elif nums[s] == 1:\n                    steps+=1\n                    j+=1\n                    nums[s] = 0\n                elif nums[s]%2 == 1:\n                    steps += 1\n                    nums[s] -= 1\n                    nums[s] //= 2\n                else:\n                    nums[s] //= 2\n                s += 1\n            if j != len(nums) - 1:\n                steps += 1\n      \n                \n  \n            \n        return steps \n        \n        \n        \n    \n    \n    \n            \n        \n", "from math import log\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        max2=0\n        count=0\n        \n        for n in nums:\n            \n            n_mult2=0\n            \n            while n!=0:\n                \n                if n%2==0:\n                    \n                    n=n/2\n                    n_mult2+=1\n                    \n                else:\n                    \n                    n=n-1\n                    count+=1\n                    \n            max2=max(max2,n_mult2)\n            \n        return count+max2\n        \n        \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while True:\n            s = 0\n            for i in range(len(nums)):\n                num = nums[i]\n                if num & 1:\n                    count += 1\n                    nums[i] = num-1\n                    s += (num-1)\n                else:\n                    s += num\n                    \n            if s == 0:\n                return count\n            \n            nums = [num//2 for num in nums]\n            count += 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        num_zero = sum(n == 0 for n in nums)\n        while num_zero != len(nums):\n            for i, n in enumerate(nums):\n                if n%2 == 1:\n                    ans += 1\n                    nums[i] -= 1\n                    if nums[i] == 0:\n                        num_zero += 1\n                nums[i] >>= 1    \n            ans += 1    \n        return ans - 1\n    \n        #m = m_steps = 0\n        #for n in nums:\n        #    steps = self.num_steps(n)\n        #    if steps > m_steps or (steps == m_steps and n > m):\n        #        m, m_steps = n, steps\n        #bonus = 0\n        #for n in nums:\n        #    if n:\n        #        bonus += 1\n        #        if n != 1 and n != m and n%2 == 1:\n        #            bonus += 1\n        #if bonus == 0:            \n        #    bonus = 1\n        #return m_steps + bonus - 1\n         \n    def num_steps(self, n):        \n        #steps = 0\n        #tmp = n\n        #while n:\n        #    if n&1:\n        #        n ^= 1\n        #    else:    \n        #        n >>= 1\n        #    steps += 1    \n        #return steps    \n        #        \n        if n == 0:\n            return 0\n        steps, mask = 0, 1\n        while mask <= n:\n            if n & mask:\n                steps += 2\n            else:\n                steps += 1    \n            mask <<= 1    \n        return steps-1    ", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        numreps = []\n        \n        for num in nums:\n            numreps.append(self.numToOps(num))\n        \n        numops = 0\n        max2s = 0\n        for rep in numreps:\n            numops += rep[1]\n            \n            if rep[2] > max2s:\n                max2s = rep[2]\n                \n        return numops + max2s\n        \n    def numToOps(self,val):\n        rep = {1:0,2:0}\n\n        while(val):\n            if val%2:\n                rep[1] += 1\n                val = val-1\n            else:\n                rep[2] += 1\n                val = int(val/2)\n        return rep", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0        \n        while sum(nums) != 0:\n            for i in range(len(nums)):\n                if nums[i] % 2 != 0:\n                    nums[i] = nums[i] - 1\n                    res += 1\n            # print([x % 2 for x in nums])\n            if sum([x % 2 for x in nums]) == 0:\n                for i in range(len(nums)):\n                    nums[i] = nums[i] / 2\n                res += 1\n        return res - 1\n        \n                \n\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        adds = []\n        muls = []\n        \n        for idx, num in enumerate(nums):\n            adds.append(0)\n            muls.append(0)\n            while num > 0:\n                if num % 2 == 1:\n                    adds[idx] += 1\n                    num -= 1\n                else:\n                    muls[idx] += 1\n                    num /= 2\n        \n        return sum(adds) + max(muls)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n\n        maxval = max(nums)\n        idx = nums.index(maxval)\n        ans = 0\n\n        while nums[idx]!=0:\n            for i,n in enumerate(nums):\n                ans += n%2 # minus 1 to make all number even\n                nums[i] = n-n%2\n            if nums[idx]!=0: \n                for i, n in enumerate(nums): # devide all numbers by 2\n                    nums[i]=nums[i]//2\n                ans += 1\n        \n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if not nums: return 0\n        n = len(nums)\n        ans = 0\n        while (True):  \n            zero_count = 0\n            i = 0\n            # for i in range(n):\n            while i<n:\n                if nums[i] % 2 ==1:  # first odd num\n                    break\n                elif nums[i] == 0:  \n                    zero_count += 1\n                i+=1\n                \n            if zero_count == n: return ans\n            \n            if i == n:\n                for j in range(n): \n                    nums[j]//=2  \n                ans += 1  \n                \n            for j in range(i, n):  \n                if nums[j]%2==1:  \n                    nums[j]-= 1 \n                    ans += 1\n                    \n        return ans\n#         ans = 0\n#         n = len(nums)\n#         zeros = len([i==0 for i in nums])\n#         if n==zeros: return ans\n#         for i in range(n):\n#             if nums[i]%2==1: # convert odd to even num\n#                 ans+=1\n#                 nums[i]-=1\n#                 if nums[i]==0:\n#                     zeros+=1\n#         if n==zeros: return ans\n        \n#         while zeros<n:\n#             for i in range(n):\n#                 nums[i]//=2\n#             ans+=1\n#         return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        N = len(nums)\n        ref = [0] * N\n        res = 0\n        while nums != ref:\n            isAllEven = 1\n            for i in range(N):\n                if nums[i]%2:\n                    nums[i] -= 1\n                    res += 1\n                    isAllEven = 0\n            if isAllEven:\n                for i in range(N):\n                    nums[i] //= 2\n                res += 1\n            # print(nums, res)\n        return res\n                    \n                \n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ## brute-force: simulation\n        res = 0\n        odd = 0\n        flag = True\n        while len(nums)>0:\n            # print(nums)\n            temp = []\n            if flag:\n                for x in nums:\n                    if x&1 == 1:\n                        res += 1\n                        if x-1!=0:\n                            temp.append(x-1)\n                    elif x!=0:\n                        temp.append(x)\n                flag = False\n            else:\n                for x in nums:\n                    temp.append(x//2)\n                res += 1\n                flag = True\n            nums = temp\n        return res\n            \n# [1,5]\n# [2,2]\n# [4,2,5]\n# [3,2,2,4]\n# [2,4,8,16]\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        while True:\n            # check if there is odd number\n            for i in range(n):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n                \n            # all even numbers, divide all by 2\n            all_zeros = True\n            for i in range(n):\n                if nums[i] != 0:\n                    all_zeros = False\n                nums[i] = nums[i] // 2\n            \n            if all_zeros:\n                break\n            else:\n                ans += 1\n                \n        return ans\n            \n            \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        calls = 0\n        while True:\n            num_zeros = 0\n            odd_index = 0\n            for i in range(n):\n                if nums[i] % 2 != 0:\n                    break\n                elif nums[i] == 0:\n                    num_zeros += 1\n                odd_index += 1\n            if num_zeros == n:\n                return calls\n\n            if odd_index == n:\n                for j in range(n):\n                    nums[j] /= 2\n                calls += 1\n\n            for j in range(i, n):\n                if nums[j] % 2 != 0:\n                    nums[j] -= 1\n                    calls += 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans=0\n        s2=[]\n        for i in nums:\n            n1=0\n            m=0\n            for j in range(32):\n                if i&(2**j)!=0:\n                    m=j\n                    n1+=1\n            ans+=n1\n            s2.append(m)\n        s2.sort()\n       \n        ans+=s2[0]\n        \n        for i in range(1,len(s2)):\n            ans+=s2[i]-s2[i-1]\n        return ans\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        total = 0\n        max_divide = 0\n        \n        for i, x in enumerate(nums):\n            divide = 0\n            while x > 0:\n                if x % 2 == 1:\n                    x -= 1\n                    total += 1\n                else:\n                    x /= 2\n                    divide += 1\n            \n            if divide > max_divide:\n                max_divide = divide\n        \n        \n        \n        return total + max_divide", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while sum(nums) > 0:\n            can_divide = False\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    ans += 1\n                    nums[i] -= 1\n                if nums[i] > 0:\n                    can_divide = True\n                    \n            if can_divide:\n                ans += 1\n                for i in range(len(nums)):\n                    nums[i] //= 2\n                \n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = {}\n        \n        def iseven(n):\n            return n%2==0\n        \n        ans = 0\n        \n        for n in nums:\n            count[n] = count.get(n, 0) + 1\n            \n        keys = list(count.keys())\n        for n in keys:\n            if n == 0:\n                count.pop(n)\n            if not iseven(n):\n                ans += count[n]\n                n -= 1                \n                if n != 0:\n                    count[n] = count.get(n,0) + count[n+1]\n                count.pop(n+1)\n            \n        while len(count) > 0:\n            # print(ans)\n            # print(count)\n            keys = list(count.keys())\n            ans += 1\n            new_count = {}\n            for n in keys:\n                if not iseven(int(n/2)):\n                    if int(n/2) != 1:\n                        new_count[int(n/2)-1] = new_count.get(int(n/2)-1, 0) + count[n]\n                    ans += count[n]\n                else:\n                    new_count[int(n/2)] = new_count.get(int(n/2), 0) + count[n]\n                    \n            count = new_count\n            \n        return ans\n                \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # Key insight is if nums[i] is odd, there's no way we could have arrived at nums[i]\n        # via op 1, i.e. by multiplying by 2 some previous value. So the only way we could\n        # have gotten here is by using op 0, nums[i] % 2 times. That is we need to skim off\n        # the remainder part that makes it non-even before we can consider using op 1.\n        cost = 0\n        while True:\n            all_zeros = True\n            all_evens = True\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                \n                all_zeros = False\n                if nums[i] % 2 != 0:\n                    cost += nums[i] % 2\n                    nums[i] = nums[i] - (nums[i] % 2)\n                    all_evens = False\n            \n            if all_zeros:\n                break\n            while all_evens:\n                for i in range(len(nums)):\n                    nums[i] = nums[i] // 2\n                    if nums[i] % 2 != 0:\n                        all_evens = False\n                cost += 1\n                \n        return cost\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n\n        def op0() -> int:\n            nonlocal nums\n            ops = sum([n % 2 for n in nums])\n            nums = [((n >> 1) << 1) for n in nums]\n            return ops\n\n        def op1() -> int:\n            nonlocal nums\n            ops = 0\n            while sum([n % 2 for n in nums]) == 0:\n                ops += 1\n                nums = [n // 2 for n in nums]\n            return ops\n\n        # print(nums)\n        while sum(nums):\n            ops += op0()\n            # print(f\\\"op0: {nums}, ops={ops}\\\")\n            if sum(nums):\n                ops += op1()\n                # print(f\\\"op1: {nums}, ops={ops}\\\")\n\n        return ops", "def adjust2power(n):\n    if n==0:\n        return 0\n    for i in range(1,n+1):\n        if 1<<i >= n:\n            if n%(1<<i)!=0:\n                i-=1\n            break\n    return 1<<i\n\ndef howManyPower(n):\n    for i in range(1,n+1):\n        if 1<<i == n:\n            return i\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        nums2p = [] #nums of 2 powers\n        ans=0\n        while max(nums)>1:\n            ans+=1\n            for i in range(len(nums)):\n                if nums[i]==0:\n                    continue\n                if nums[i] > 1:\n                    ans += nums[i]%2\n                nums[i] = max(nums[i]//2, 1)\n #           print(nums)\n        return ans+len(nums)-nums.count(0)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        while True:\n            ok = False\n            flag = True\n            for i in range(n):\n                if nums[i] & 1:\n                    ans += 1\n                    nums[i] -= 1\n                if nums[i] != 0 and not (nums[i] & 1):\n                    nums[i] //= 2\n                    if flag:\n                        ans += 1\n                        flag = False\n                if nums[i] != 0:\n                    ok = True\n            if not ok:\n                break\n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ret = 0\n        change = 0\n        \n        while sum(nums):\n            change = 0\n            for i in range(len(nums)):\n                if nums[i]%2:\n                    ret +=1\n\n                    nums[i] -=1\n                    change = 1\n\n            if change==0:\n                ret+=1\n                for i in range( len(nums)):\n                    nums[i] = nums[i]//2\n                \n        return ret\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        f = {}\n        def calc(x):\n            if x == 0:\n                return 0, 0\n            if x not in f:\n                if x % 2 == 1:\n                    a, b = calc(x - 1)\n                    f[x] = (a + 1, b)\n                else:\n                    a, b = calc(x // 2)\n                    f[x] = (a, b + 1)\n            return f[x]\n        \n        x = []\n        y = []\n        for e in nums:\n            a, b = calc(e)\n            x.append(a)\n            y.append(b)\n        return sum(x) + max(y)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        done = [0]*n\n        ans = 0\n        while nums != done:\n            for i, x in enumerate(nums):\n                if x%2:\n                    nums[i] -= 1\n                    ans += 1\n            if nums != done:\n                for i, x in enumerate(nums):\n                    nums[i] /= 2\n                ans += 1\n        return ans", "class Solution:\n    def minOperations(self, a: List[int]) -> int:\n        res = [0]\n        while True:\n            self.checkOdd(a, res)\n            end = self.checkDivide(a)\n            if end:\n                break\n            else:\n                res[0] += 1\n        return res[0]\n        \n    def checkOdd(self, a, res):\n        for i in range(len(a)):\n            if a[i] % 2 != 0:\n                a[i] -= 1\n                res[0] += 1\n\n    def checkDivide(self, a):\n        flg = True\n        for i in range(len(a)):\n            if a[i] > 0:\n                a[i] /= 2\n                flg = False\n        return flg", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(nums):\n            for i,v in enumerate(nums):\n                if v % 2 == 1:\n                    nums[i] -= 1\n                    ans += 1\n            if any(nums):\n                ans += 1\n                nums = [i/2 for i in nums]\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count  = 0\n\n        while True:\n            op =False\n            zeroes = 0\n            for i in range(len(nums)):\n                if nums[i]%2 != 0:\n                    count +=1\n                    nums[i]-=1\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    zeroes+=1\n                else:\n                    nums[i]=nums[i]//2\n                    op = True\n            if op:\n                count +=1\n            if zeroes == len(nums):\n                return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        n = len(nums)\n        while True:\n            zero_c = 0\n            i = 0\n            while i < n:\n                if nums[i] % 2 == 1:\n                    break\n                elif nums[i] == 0:\n                    zero_c += 1\n                i += 1\n                    \n            if zero_c == n:\n                return res\n            \n            if i == n:\n                for j in range(n):\n                    nums[j] = nums[j]//2\n                res += 1\n            \n            for j in range(i, n):\n                if nums[j] % 2 == 1:\n                    nums[j] -= 1\n                    res += 1\n            \n        return res\n            \n\n", "\nclass Solution:\n  def minOperations(self, nums: List[int]) -> int:\n    result = 0\n    while True:\n      allzero = True\n      for index, num in enumerate(nums):\n        if num != 0:\n          allzero = False\n\n        if num % 2 == 1:\n          nums[index] = num - 1\n          result += 1\n\n      if allzero:\n        break\n\n      allzero = True\n      for index, num in enumerate(nums):\n        if num != 0:\n          allzero = False\n        nums[index] = num // 2\n\n      if allzero:\n        break\n      else:\n        result += 1\n\n    return result", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        num_operations = 0\n        \n        stacks = [[],[]]\n        \n        cur_idx = 0\n        nxt_idx = 1\n        \n        odd = False\n        \n        for num in nums:\n            if num % 2:\n                odd = True\n            if num:\n                stacks[0].append(num)\n                \n        \n        num_operations = 0\n        \n        while stacks[0] or stacks[1]:\n            if odd:\n                while stacks[cur_idx]:\n                    nxt = stacks[cur_idx].pop()\n                    if nxt % 2:\n                        nxt -= 1\n                        num_operations += 1\n                    if nxt:\n                        stacks[nxt_idx].append(nxt)\n                odd = False\n            else:\n                num_operations += 1\n                while stacks[cur_idx]:\n                    nxt = stacks[cur_idx].pop()\n                    nxt /= 2\n                    if nxt % 2:\n                        odd = True\n                    if nxt:\n                        stacks[nxt_idx].append(nxt)\n            \n            cur_idx, nxt_idx = nxt_idx, cur_idx\n            \n        return num_operations\n                        \n                        \n                        \n                        \n                        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def proc(nums):\n            cnt = 0\n            for i in range(len(nums)):\n                if nums[i] % 2 > 0:\n                    nums[i] -= 1\n                    cnt += 1\n            if cnt == 0:\n                for i in range(len(nums)):\n                    nums[i] //= 2\n            return max(cnt, 1)\n                    \n            \n        \n        ops = 0\n        while sum(nums) > 0:\n            ops += proc(nums)\n        return ops\n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 3\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        m = max(nums)\n        n = nums.count(m)\n        # as 'bin(len(5)) == 5'\n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 3\n    \n    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        zeros = [0 for el in nums]\n        res = 0\n        while nums != zeros:\n            for i in range(len(nums)):\n                if nums[i] % 2 != 0:\n                    nums[i] -= 1\n                    res += 1\n            if nums == zeros: break\n            nums = [el / 2 for el in nums]\n            res += 1\n        return res\n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         double_arr = [math.floor(math.log(num, 2)) for num in nums]\n#         calc = [0 for el in nums]\n#         zeros_arr = [0 for el in nums]\n#         # iters = 0\n#         res = 0\n#         while True:\n#             # Add 1s\n#             print(\\\"~~~~~~~~~calc\\\", calc)\n#             print(\\\"double arr\\\", double_arr)\n#             max_idxs = []\n#             max_val = 0\n#             for idx, val in enumerate(double_arr):\n#                 if val > max_val:\n#                     max_val = val\n#                     max_idxs = [idx]\n#                 elif val == max_val:\n#                     max_idxs.append(idx)\n#             if max_val == 0: break\n#             # print(\\\"max idxs\\\", max_idxs)\n#             for idx in max_idxs:\n#                 if calc[idx] == 0:\n#                     calc[idx] += 1\n#                     res += 1\n#                 double_arr[idx] -= 1\n#             # print(\\\"inter calc\\\", calc)\n#             calc = [el*2 for el in calc]\n#             # print(\\\"end calc\\\", calc)\n#             res += 1\n#             print(\\\"res\\\", res)\n#             # if iters>50: break\n#             # iters += 1\n        \n#         diff_remain = sum(nums) - sum(calc)\n#         res += diff_remain\n#         return res\n        \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while sum(nums) > 0:\n            for i in range(len(nums)):\n                if nums[i]%2==1:\n                    ans += 1\n                    nums[i] -= 1\n            if sum(nums)!=0:\n                ans += 1\n                for i in range(len(nums)):\n                    nums[i] = nums[i]//2\n                \n        return ans", "class Solution:\n  def minOperations(self, nums) -> int:\n    steps = 0\n\n    while True:\n      # make even\n      for i in range(len(nums)):\n        if nums[i] % 2 == 1:\n          nums[i] -= 1\n          steps += 1\n\n      # check if done\n      remaining = 0\n      for i in range(len(nums)):\n        if nums[i] > 0:\n          remaining += 1\n      if remaining == 0:\n        return steps\n\n      # divide\n      for i in range(len(nums)):\n        nums[i] /= 2\n      steps += 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        count = 0\n        l = len(nums)\n        while True:\n        \n            allZeros = True\n            \n            for i in range(l):\n                \n                if nums[i]!=0:\n                    allZeros = False\n                if nums[i]%2:\n                    count+=1\n                    nums[i]-=1\n                    \n           \n            if allZeros:\n                return count\n            flag = False\n            for i in range(l):\n                if nums[i]!=0:  \n                    flag = True\n                    nums[i] = nums[i]//2\n            if flag:\n                count+=1\n            \n            \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        result = 0\n\n        while nums:\n            new = []\n            for x in nums:\n                if x > 0:\n                    if x != 1:\n                        new.append(x - (x&1))\n                    result += x&1\n            nums = new\n            \n            if not nums:\n                break\n            \n            for i in range(len(nums)):\n                nums[i] //= 2\n            result += 1\n            \n        return result", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ret = 0\n        def check(nums):\n            isAllZero = 1\n            multiplied = 0\n            res = 0\n            for i in range(len(nums)):\n                if nums[i] != 0:\n                    isAllZero = 0\n                if nums[i] & 1:\n                    res += 1\n                    nums[i] -= 1\n                if nums[i] != 0:\n                    nums[i] = nums[i] // 2\n                    multiplied = 1\n            if multiplied == 1:\n                res += 1\n            return (isAllZero, res)\n        \n        while True:\n            done, cnt = check(nums)\n            ret += cnt\n            if done == 1:\n                break\n        return ret\n        \n        \n\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        s = set(nums)\n        if len(s)==1 and 0 in s:\n            return 0\n        else:\n            l = nums\n            cnt = 0\n            for i in range(len(l)):\n                if l[i]%2==1:\n                    cnt += 1\n                    l[i] -= 1\n            if cnt == 0:\n                return 1+self.minOperations([a//2 for a in l])\n            else:\n                return cnt+self.minOperations(l)", "import math\nclass Solution:\n    def minOperations(self, n: List[int]) -> int:\n        nums = []\n        for i in range(len(n)):\n            if n[i]==0:\n                continue\n            nums.append(n[i])\n        def countOdd(nums):\n            c = 0\n            for i in range(len(nums)):\n                if nums[i]!=1 and nums[i]%2==1:\n                    nums[i]-=1\n                    c+=1\n            return c\n        count = 0\n        while set(nums)!={1}:\n            count+=countOdd(nums)\n            for i in range(len(nums)):\n                if nums[i]==1:\n                    continue\n                nums[i] = nums[i]//2\n                    \n            count+=1\n        count+=len(nums)\n        return count\n                \n                \n", "class Solution:\n    def is_divisible(self,nums):\n        res = []\n        for ix in range(len(nums)):\n            if nums[ix] % 2 != 0:\n                res.append(ix)\n        return res\n    \n    \n    def divide_by_2(self,nums):\n        for ix in range(len(nums)):\n            nums[ix] = nums[ix] / 2\n        \n    \n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        while nums != [0] * len(nums):\n            minus_ix = self.is_divisible(nums)\n            for ix in minus_ix:\n                nums[ix] -= 1\n                ops += 1\n            \n            if nums == [0]* len(nums):\n                return ops\n            \n            # divide all by 2\n            self.divide_by_2(nums)\n            ops += 1\n        return ops", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        high=len(bin(max(nums)))-3\n        one=sum([bin(n).count('1') for n in nums])\n        return high+one\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n=len(nums)\n        temp=c=0\n        while True:\n            for i in range(n):\n                if nums[i]==1:\n                    c+=1\n                    nums[i]=0\n                elif nums[i]%2==1:\n                    nums[i]-=1\n                    c+=1   \n                if nums[i]==0:\n                    temp+=1\n            if temp==n:\n                return c\n            temp=0\n            for i in range(n):\n                nums[i]=int(nums[i]/2)\n            c+=1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def nrOfOpsToZero(n):\n            if n == 0:\n                return (0, 0)\n            if n % 2 == 1:\n                recDups, recIncs = nrOfOpsToZero(n - 1)\n                return (recDups, recIncs + 1)\n            recDups, recIncs = nrOfOpsToZero(n // 2)\n            return (recDups + 1, recIncs)\n        maxDups = 0\n        totalIncs = 0\n        for i in range(0, len(nums)):\n            dups, incs = nrOfOpsToZero(nums[i])\n            totalIncs += incs\n            maxDups = max(maxDups, dups)\n        return int(maxDups + totalIncs)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # iseven = False\n        def makeeven():\n            did = 0\n            for i in range(len(nums)):\n                if nums[i]&1:\n                    nums[i] -= 1\n                    did += 1\n            # iseven = True\n            return did\n        def halv():\n            did = False\n            for i in range(len(nums)):\n                if nums[i]:\n                    nums[i] >>= 1\n                    did = True\n            return did\n        count = 0\n        while any(nums):\n            count += (makeeven())\n            count += int(halv())\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        odd = 0\n        flag = True\n        while len(nums)>0:\n            # print(nums)\n            temp = []\n            if flag:\n                for x in nums:\n                    if x&1 == 1:\n                        res += 1\n                        if x-1!=0:\n                            temp.append(x-1)\n                    elif x!=0:\n                        temp.append(x)\n                flag = False\n            else:\n                for x in nums:\n                    temp.append(x//2)\n                res += 1\n                flag = True\n            nums = temp\n        return res\n            \n# [1,5]\n# [2,2]\n# [4,2,5]\n# [3,2,2,4]\n# [2,4,8,16]\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        odds, even = [], []\n        for i in nums:\n            if i & 1:\n                odds.append(i)\n            elif i != 0:\n                even.append(i)\n        \n        count = 0\n        while odds or even:\n            if odds:\n                i = odds.pop()\n                if i - 1 != 0:\n                    even.append(i-1)\n            else:\n                new_even = []\n                for i in even:\n                    i //= 2\n                    if i & 1:\n                        odds.append(i)\n                    else:\n                        new_even.append(i)\n                even = new_even\n            count += 1\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        @lru_cache(None)\n        def steps(n):\n            if n == 0: return 0,0,0\n            if n == 1: return 1,1,0\n            if n&1: \n                a,b,c = steps(n-1)\n                return a+1,b+1,c\n            \n            a,b,c = steps(n//2)\n            return a+1,b,c+1\n        \n        # print(steps(5))\n        evens = 0\n        odds = 0\n        for num in nums:\n            a,b,c = steps(num)\n            odds += b\n            # print(num, a,b,c)\n            evens = max(evens, c)\n        \n        return odds + evens\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        length = len(nums)\n        \n        def check_all_zeros(arr):\n            for ele in arr:\n                if ele != 0:\n                    return False\n            return True \n        \n        def divide_by_2(arr):\n            return list([x/2 for x in arr])\n        \n        ops = 0\n        \n        while True:\n            \n            if check_all_zeros(nums):\n                return ops\n        \n            all_even = True\n            for i in range(length):\n                num = nums[i]\n                if num % 2 == 0:\n                    if i == length - 1 and all_even:\n                        nums = divide_by_2(nums)\n                        ops += 1\n\n                else:\n                    all_even = False\n                    nums[i] -= 1\n                    ops += 1     \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def minSteps(num):\n            if num == 0:\n                return 0\n            if num == 1:\n                return 1\n            \n            if num in memo:\n                return memo[num]\n            \n            if num & 1: # odd\n                num_ways = 1 + minSteps(num - 1)\n            else: # even\n                num_ways = minSteps(num // 2)\n            \n            memo[num] = num_ways\n            \n            return memo[num]\n        \n        def countPowerOfTwo(num):\n            if num < 2: return 0\n            cnt = 1\n            cur = 2\n            while cur * 2 <= num:\n                cnt += 1\n                cur <<= 1\n            \n            return cnt\n        \n        memo = {}\n        res = countPowerOfTwo(max(nums))\n        for num in nums:\n            res += minSteps(num)\n        \n        return res\n            \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        res = 0\n        n = len(nums)\n        \n        while True:\n            \n            p = 0\n            for i in range(n):\n                if nums[i]%2:\n                    nums[i]-=1\n                    res += 1\n                p+=nums[i]    \n            \n            if p==0:\n                return res\n            \n            for i in range(n):\n                nums[i]//=2\n            \n            res += 1\n\n    \n\n            \n       \n                \n        \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        result = 0\n        n = len(nums)\n        \n        while True:\n            \n            zcount = 0\n            \n            i = 0\n            while i < n:\n                if nums[i] % 2 == 1:\n                    break\n                elif nums[i] == 0:\n                    zcount = zcount + 1\n                i = i + 1\n            \n            if zcount == n:\n                return result\n            \n            if i == n:\n                for j in range (0, n):\n                    nums[j] = nums[j] // 2\n                result = result + 1\n            \n            for j in range (i, n):\n                if nums[j] % 2 == 1:\n                    nums[j] = nums[j] - 1\n                    result = result + 1\n            \n        return result", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        co = 0\n        while True:\n            co = 0\n            for i in range(n):\n                if nums[i] % 2 == 1:\n                    nums[i]-=1\n                    ans+=1\n            for i in range(n):\n                if nums[i] == 0:\n                    co+=1\n            if co==n:\n                return ans\n            for i in range(n):\n                nums[i] = (nums[i] // 2)\n            ans+=1\n            # print(nums, ans, co)\n            \n        return ans", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        if all(v == 0 for v in A):\n            return 0\n        odds = 0\n        A_next = A.copy()\n        for i, v in enumerate(A):\n            if v % 2 == 1:\n                odds += 1\n                A_next[i] = v-1\n        if odds > 0:\n            return odds + self.minOperations(A_next)\n        return 1 + self.minOperations([v//2 for v in A])\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op = 0\n        while max(nums) != 0:\n            allEven = True\n            for i,n in enumerate(nums):\n                if n % 2 == 1:\n                    nums[i] -= 1\n                    op += 1\n                    allEven = False\n            if allEven:\n                nums = [n//2 for n in nums]\n                op += 1\n        return op\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        c=0\n        \n        while len(nums)!=0:\n            L=[]\n            for i in range(len(nums)):\n                if nums[i]==1:\n                    c+=1\n                elif nums[i]%2==1:\n                    L.append(nums[i]//2)\n                    c+=1\n                elif nums[i]!=0 and nums[i]%2==0:\n                    L.append(nums[i]//2)\n            if len(L)!=0:\n                c+=1\n            nums=L\n                        \n\n                    \n        return c                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while set(nums) != {0}:\n            even = True\n            for i in range(len(nums)):\n                if nums[i]&1:\n                    ans += 1\n                    even = False\n                    nums[i] -= 1\n            if even:\n                nums = [i//2 for i in nums]\n                ans += 1\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while sum(nums) != 0:\n\n            for i in range(len(nums)):\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    count += 1\n            \n            if sum(nums) == 0:\n                return count\n            \n            flag = False\n            for i in range(len(nums)):\n                if nums[i] % 2 == 0:\n                    nums[i] //= 2\n                    flag = True\n            if flag:\n                count += 1\n            \n        return count\n                \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        c=0\n        n=len(nums)\n        while True:\n            if len(set(nums))==1 and nums[0]==0:\n                break\n            for i in range(n):\n                if nums[i]%2!=0 and nums[i]>0 and nums[i]!=0:\n                    nums[i]=nums[i]-1\n                    c+=1\n            f=0\n            for i in range(n):\n                if nums[i]%2==0:\n                    f+=1\n            if len(set(nums))==1 and nums[0]==0:\n                break\n            if f==len(nums):\n                for i in range(n):\n                    if nums[i]%2==0 and nums[i]!=0:\n                        nums[i]=nums[i]//2\n                c+=1\n        return c", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op = 0\n        while sum(nums) != 0:\n            odds = 0\n            for i in range(len(nums)):\n                if nums[i] & 1 != 0:\n                    odds += 1\n                    nums[i] -= 1\n            if odds == 0:\n                nums = list(map(lambda x: x // 2, nums))\n                op += 1\n            else:\n                op += odds\n                \n        return op", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if sum(nums) == 0:\n            return 0\n        total = 0\n        zeros = False\n        while sum(nums) > 0:\n            for i, num in enumerate(nums):\n                if num < 1:\n                    continue\n                zeros = False\n                total += num % 2\n                nums[i] -= num % 2\n            if sum(nums) > 0:\n                total += 1\n                for i, num in enumerate(nums):\n                    nums[i] >>= 1\n        return total", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        if sum(nums) == 0:\n            return 0\n        # print(nums)\n        s = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                nums[i] -= 1\n                s += 1\n        if s == 0:\n            for i in range(len(nums)):\n                nums[i] //= 2\n            s += 1\n        return self.minOperations(nums) + s", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def deductOdd(nums):\n            n = len(nums)\n            cnt = 0\n            for i in range(n):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    cnt += 1        \n            return cnt\n        \n        def halfEven(nums):\n            n = len(nums)\n            allZero = True\n            for i in range(n):\n                if nums[i] > 0:\n                    nums[i] //= 2\n                    allZero = False\n            return allZero\n              \n        result = deductOdd(nums)\n        while not halfEven(nums):\n            result += 1\n            result += deductOdd(nums)\n            \n        return result\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count=0\n        numzeros=0\n        n=len(nums)\n        for i in range(n):\n            if(nums[i]==0):\n                numzeros+=1\n        while(numzeros<n):\n            k=0\n            for i in range(n):\n                if(nums[i] % 2):\n                    nums[i]-=1\n                    count+=1\n                    if(nums[i]==0):\n                        numzeros+=1\n                    else:\n                        k=1\n                        nums[i]=nums[i]/2\n                else:   \n                    if(nums[i]==0):\n                        continue\n                    else:\n                         k=1\n                         nums[i]=nums[i]/2\n            if(k==1):\n                count+=1\n        return count\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        c=1\n        count=0\n        maxn=max(nums)\n        while c*2<=maxn:\n            c=c*2\n            count+=1\n        @lru_cache\n        def dfs(n):\n            if n<=1:\n                return n\n            else:\n                if n%2==0:\n                    return dfs(n//2)\n                else:\n                    return 1+dfs(n//2)\n        for i in nums:\n            count+=dfs(i)\n        return count", "class Solution:\n    def minOperations(self, target):\n        n = len(target)\n        result = 0\n        while True:\n            zero_count = 0\n            i = 0\n            while (i < n):\n                if ((target[i] & 1) > 0):\n                    break\n                elif (target[i] == 0):\n                    zero_count += 1\n                i += 1\n            if (zero_count == n):\n                return result\n            if (i == n):\n                for j in range(n):\n                    target[j] = target[j]//2\n                result += 1\n            for j in range(i, n):\n                if (target[j] & 1):\n                    target[j] -= 1\n                    result += 1\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        while True:\n            for i in range(len(nums)):\n                if nums[i] == 1:\n                    nums[i] = 0\n                    count += 1\n            if max(nums) < 1:\n                break\n            for i in range(len(nums)):\n                if nums[i] < 2:\n                    continue\n                if nums[i] % 2 != 0:\n                    count += 1\n                nums[i] //= 2\n            count += 1\n        return count", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def cod(k,i):\n            if k==0: \n                self.memo[k]=[self.g[i],self.h[i]]\n                return 0\n            if k not in self.memo:\n                if k%2==0:\n                    self.g[i] += 1\n                    cod(int(k/2),i)\n                else:\n                    self.h[i] += 1\n                    cod(k-1,i)\n        \n        self.memo = {}\n        l = len(nums)\n        f = [0]*l\n        self.g = [0]*l\n        self.h = [0]*l\n        for i in range(l):\n            f[i] = cod(nums[i],i)\n        return sum(self.h)+max(self.g)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        flag = True\n        count = 0\n        while flag:\n            flag = False\n            for i in range(len(nums)):\n                if nums[i]&1:\n                    nums[i] -= nums[i]&1\n                    count += 1\n                if nums[i] > 0:\n                    nums[i] >>= 1\n                    flag = True\n            \n            if flag:\n                count += 1\n        return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n=len(nums)\n        ss = sum(nums)\n        ans=0\n        while(ss>0):\n            for i in range(n):\n                if nums[i]%2!=0:\n                    ans+=1\n                    nums[i]-=1\n                    ss-=1\n            if ss>0:\n                for i in range(n):\n                    nums[i]//=2\n                    ss-=nums[i]\n                ans+=1\n            \n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 3\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        result = 0\n        new_nums = sorted(nums, reverse=True)\n        while len(new_nums) > 0:\n            if new_nums[-1] == 0:\n                new_nums.pop(len(new_nums) - 1)\n            elif new_nums[-1] == 1:\n                new_nums.pop(len(new_nums) - 1)\n                result += 1\n            else:\n                flag = True\n                for i in range(len(new_nums)):\n                    if new_nums[i] & 0x1 == 1:\n                        new_nums[i] -= 1\n                        result += 1\n                        flag = False\n                if flag:\n                    for i in range(len(new_nums)):\n                        new_nums[i] >>= 1\n                    result += 1\n        return result", "\ndef ops(x):\n    if x == 1:\n        return (0, 1)\n    if x % 2 == 0:\n        d, i = ops(x // 2)\n        return (d + 1, i)\n    else:\n        d, i = ops(x - 1)\n        return (d, i + 1)\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        increments = 0\n        max_doubles = 0\n\n        for x in nums:\n            if x == 0:\n                continue\n            doubs, incrs = ops(x)\n            increments += incrs\n            if doubs > max_doubles:\n                max_doubles = doubs\n\n        return increments + max_doubles\n\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        def modify(arr, op, ind):\n            if op == 0:\n                arr[ind] = arr[ind] + 1\n            if op == 1:\n                for i in range(len(arr)):\n                    arr[i] = arr[i] * 2\n            return arr\n        \n        arr = [0] * n\n        # print(arr)\n        # interesting how would you go about solving this?\n        # is there a greedy solution\n        # so for example every non 0 elt in the array\n        # need a +1 operation to make it non zero\n        # if a value is odd and not one we need a min of \n        # 3 operations to get to where it needs to be\n        # \n        # can cache number of ops probably\n        # print(nums)\n        ops_needed = 0\n        check_ind = 0\n        nums.sort(key = lambda x: -x)\n        while any(n!=0 for n in nums):\n            for ind, numb in enumerate(nums):\n                if numb >= 1 and numb % 2 == 1:\n                    ops_needed += 1\n                    # print(\\\"odd: \\\", nums, ops_needed)\n                    nums[ind] = nums[ind] - 1\n            \n            for numb in nums:\n                if numb >= 1 and numb % 2 == 0:\n                    ops_needed += 1\n                    # print(\\\"even: \\\", nums, ops_needed)\n                    for ind, elt in enumerate(nums):\n                        nums[ind] = nums[ind] / 2\n                    break\n                        \n            check_ind += 1\n            if check_ind > 100:\n                break\n            # nums.sort(key = lambda x: -x)\n        return ops_needed\n    \n[3,3]\n[1,5]\n[2,2]", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans=-1\n        l=nums\n        while 1:\n            tf=0\n            for i in range(len(nums)):\n                if l[i]>0:\n                    tf=1\n                    if l[i]%2:\n                        l[i]-=1\n                        ans+=1\n                    if l[i]:\n                        l[i]//=2\n            if not tf:\n                break\n            ans+=1\n        return ans", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        total = 0\n        zeros = 0\n        for i in nums:\n            if i == 0:\n                zeros += 1\n        while zeros < len(nums):\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    nums[i] -= 1\n                    if nums[i] == 0:\n                        zeros += 1\n                    total += 1\n            allEven = True\n            while allEven and zeros < len(nums):\n                for i in range(len(nums)):\n                    nums[i] = nums[i] >> 1\n                    if nums[i] % 2 == 1:\n                        allEven = False\n                total += 1\n        return total\n            \n\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = sum(num > 0 for num in nums)\n        max_time = 0\n        for num in nums:\n            add_op = 0\n            time_op = 0\n            Y = num\n            X = 1\n            while Y > X:\n                # step += 1\n                if Y % 2 == 1: \n                    Y -= 1\n                    add_op += 1\n                else: \n                    Y /= 2\n                    time_op += 1\n            max_time = max(max_time, time_op)\n            if num > 1:\n                res += (add_op)\n        res += max_time\n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        even_num = []\n        odd_num = []\n        zero_num = []\n        \n        def category(n, zero_num, even_num, odd_num):\n            if n == 0:\n                zero_num.append(n)\n            elif n % 2 == 0:\n                even_num.append(n)\n            else:\n                odd_num.append(n)\n            \n        for n in nums:\n            category(n, zero_num, even_num, odd_num)\n        # print(zero_num, even_num, odd_num)\n        ans = 0\n        while len(even_num) or len(odd_num):\n            new_odd_num = []\n            if len(odd_num): ans += len(odd_num)\n            for n in odd_num:\n                n = n - 1\n                category(n, zero_num, even_num, new_odd_num)\n            odd_num = new_odd_num    \n\n            new_even_num = []\n            if len(even_num): ans += 1\n            for n in even_num:\n                n = n // 2\n                category(n, zero_num, new_even_num, odd_num)\n            even_num = new_even_num\n\n            # print(zero_num, even_num, odd_num)\n\n            \n        return ans\n", "class Solution:\n    def minOperations(self, t: List[int]) -> int:\n        n=len(t)\n        ans = 0  \n        while (1):  \n            z = 0   \n            i = 0 \n            while (i < n): \n                if ((t[i] %2)):  \n                    break \n  \n                elif (t[i] == 0):  \n                    z += 1\n                i += 1\n            if (z == n):  \n                return ans \n            if (i == n):    \n                for j in range(n): \n                    t[j] = t[j] // 2\n                ans += 1  \n            for j in range(i, n):  \n                if (t[j] & 1):  \n                    t[j] -= 1  \n                    ans += 1\n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while any(num != 0 for num in nums):\n            odd = 0\n            for idx, num in enumerate(nums):\n                if num & 1:\n                    nums[idx] -= 1\n                    odd += 1\n                    ans += 1\n            if not odd:\n                for idx, num in enumerate(nums):\n                    nums[idx] = num // 2\n                ans += 1\n            \n        return ans\n                    \n                \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        valid = {0: 0}\n        for i in range(31):\n            valid[2 ** i] = i\n        \n        ans = 0\n        max_multi_step = float('-inf')\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                ans += 1\n            else:\n                continue\n            one_step, multi_step = 0, 0\n            \n            while nums[i] not in valid:\n                if nums[i] & 1:\n                    one_step += 1\n                    nums[i] -= 1\n                else:\n                    multi_step += 1\n                    nums[i] //= 2\n            \n            ans += one_step\n            max_multi_step = max(max_multi_step, multi_step + valid[nums[i]])\n            \n        ans += max_multi_step\n        return ans\n", "from math import floor, log\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for x in nums:\n            for i in bin(x)[2:]:\n                if i != '0':\n                    ans += 1\n            # if floor(log(i, 2)) != log(i,2):\n            #     # print(2**(floor(log(i, 2))), floor(log(i, 2)),i**(1/2), i)\n            #     ans += i - (2**(floor(log(i, 2))))\n        \n        m = max(nums)\n        ans += floor(log(m, 2))\n        # print(floor(m**(1/2)))\n        return ans \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        \n        def it():\n            nonlocal ops\n            postAllZero = True\n            for i in range(len(nums)):\n                n = nums[i]\n                if n % 2 == 1:\n                    nums[i] -= 1\n                    ops += 1\n                if nums[i] > 0:\n                    postAllZero = False\n            if postAllZero:\n                return                    \n            for i in range(len(nums)):\n                nums[i] /= 2\n            ops += 1\n            it()\n                    \n        it()\n        return ops\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        nums.sort()\n        result = 0\n        multiple = 0\n        last = 0\n        \n        #@lru_cache(None)\n        def find(mx):\n            nonlocal last\n            if mx <= 1:\n                return mx\n            if mx % 2 == 1:\n                return find(mx-1)+1\n            last += 1\n            return find(mx//2)+1\n        \n        result = 0\n        for i, n in enumerate(nums):\n            result += find(n)-last\n            multiple = max(multiple, last)\n            last = 0\n            \n        return result + multiple\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        max_mul = 0\n        total_add = 0\n        ope_dict = {0: (0, 0)}\n        def func(num: int):\n            if num in ope_dict:\n                return ope_dict[num]\n            elif num % 2:\n                r = func(num - 1)\n                ope_dict[num] = (r[0] + 1, r[1])\n            else:\n                r = func(num // 2)\n                ope_dict[num] = (r[0], r[1] + 1)\n            return ope_dict[num]\n        for n in nums:\n            add, mul = func(n)\n            total_add += add\n            max_mul = max(max_mul, mul)\n        return total_add + max_mul\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        numOperations = 0\n        compare = [0]*len(nums)\n        while nums != compare:\n            # divByTwo = True\n            for i in range(len(nums)):\n                if nums[i]%2 != 0:\n                    nums[i]-=1\n                    numOperations+=1\n                    # divByTwo == False\n            # if divByTwo:\n            if nums == compare:\n                return numOperations\n            for i in range(len(nums)):\n                nums[i]/=2\n            numOperations+=1\n            # print(nums)\n        return numOperations        \n", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        r = 0\n\n        while A != [0 for i in A]:\n            odd = 0\n            for i in range(len(A)):\n                if A[i]%2 == 1:\n                    A[i] = A[i]-1\n                    odd += 1\n            if odd == 0:\n                A = [x//2 for x in A]\n                r += 1\n            else:\n                r += odd\n        return r\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        result = 0\n        while (True):        \n            zero_count = 0\n      \n            i = 0\n            while (i < n):\n                \n                if ((nums[i] & 1) > 0): \n                    break  \n                elif (nums[i] == 0):  \n                    zero_count += 1 \n                i += 1\n\n            if (zero_count == n):  \n                return result\n    \n            if (i == n):  \n                for j in range(n): \n                    nums[j] = nums[j] // 2\n                result += 1\n  \n            for j in range(i, n):  \n                if (nums[j] & 1):  \n                    nums[j] -= 1\n                    result += 1  \n        \n        return result\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count=0\n        numzeros=0\n        n=len(nums)\n        for i in range(n):\n            if(nums[i]==0):\n                numzeros+=1\n        while(numzeros<n):\n            k=0\n            for i in range(n):\n                if(nums[i] % 2):\n                    nums[i]-=1\n                    count+=1\n                    if(nums[i]==0):\n                        numzeros+=1\n                    else:\n                        k=1\n                        nums[i]=nums[i]/2\n                else:   \n                    if(nums[i]==0):\n                        continue\n                    else:\n                         k=1\n                         nums[i]=nums[i]/2\n            if(k==1):\n                count+=1\n            print((count,numzeros))\n        return count\n            \n", "class Solution:\n    def minOperations(self, A: List[int]) -> int:\n        return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        import sys \n        import math\n        def h2(n): \n            ans1=0\n            ans2=0\n            while(n!=1):\n                if(n%2==0):\n                    ans1+=1\n                    n/=2\n                else:\n                    n-=1\n                    ans2+=1\n            return ans1,ans2\n        \n        ans=0\n        mixx=-1\n        for i in nums:\n            if(i!=0):\n                ans+=1\n                ans1,ans2 = h2(i)\n                ans+=ans2\n                mixx = max(ans1,mixx)\n        ans+=mixx\n        return int(ans)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        \n        while any(num != 0 for num in nums):\n            for pos in range(len(nums)):\n                if nums[pos] % 2 != 0:\n                    nums[pos] -= 1\n                    count += 1\n            \n            if all(num == 0 for num in nums):\n                return count\n            \n            else:\n                nums = [num / 2 for num in nums]\n                count += 1\n            \n        return count\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cou=[0]*len(nums)\n        count=0\n        for i in range(len(nums)):\n            while(nums[i]>0):\n                if nums[i]%2!=0:\n                    nums[i]-=1\n                    count+=1\n                else:\n                    nums[i]=nums[i]//2\n                    cou[i]+=1\n        res=max(cou)+count\n\n        return res\n", "class Solution:\n    def minOperations(self, target: List[int]) -> int:\n        # Initialize result (Count of minimum moves)  \n        result = 0;  \n        n = len(target)\n\n        # Keep looping while all elements of  \n        # target don't become 0.  \n        while (True):  \n\n            # To store count of zeroes in  \n            # current target array  \n            zero_count = 0;  \n\n            # To find first odd element  \n            i = 0;  \n            while (i < n): \n\n                # If odd number found  \n                if ((target[i] & 1) > 0):  \n                    break;  \n\n                # If 0, then increment  \n                # zero_count  \n                elif (target[i] == 0):  \n                    zero_count += 1; \n                i += 1; \n\n            # All numbers are 0  \n            if (zero_count == n):  \n                return result;  \n\n            # All numbers are even  \n            if (i == n):  \n\n                # Divide the whole array by 2  \n                # and increment result  \n                for j in range(n): \n                    target[j] = target[j] // 2;  \n                result += 1;  \n\n            # Make all odd numbers even by  \n            # subtracting one and increment result.  \n            for j in range(i, n):  \n                if (target[j] & 1):  \n                    target[j] -= 1;  \n                    result += 1;  \n    \n                    \n                    \n        \n            \n            \n            \n    \n", "import math\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        while any(nums):\n            if any( x%2 for x in nums ):\n                for i in range(len(nums)):\n                    if nums[i] != 0 and nums[i]%2:\n                        nums[i] -= 1\n                        res += 1\n            else:\n                nums = [ x/2 for x in nums ]\n                res += 1\n        return res\n            \n                \n        \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # [4, 2, 13]\n        # 4 = 2^2\n        # 2 = 2^1\n        # 13 = 2^3 + 2^2 + 1 = 2^2(2 + 1) + 1\n        # increment nums[2]\n        # multiply by 2\n        # increment nums[2] and nums[1]\n        # multiply by 2\n        # increment nums[1]\n        # multiply by 2\n        # total: 1 increment for each power of 2 in an element\n        \n        count = 0\n        max_max_power = 0\n        for n in nums:\n            if n == 0:\n                continue\n            \n            # get max power\n            max_power = 0\n            temp = n\n            while temp > 1:\n                max_power += 1\n                temp >>= 1\n                        \n            # record max max power\n            max_max_power = max(max_max_power, max_power)\n            \n            # record digits of binary\n            while max_power >= 0:\n                if 2**max_power <= n:\n                    n -= 2**max_power\n                    count += 1\n                max_power -= 1\n            \n        return count + max_max_power\n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        i = 0\n        k = 0\n        for x in range(10**9):\n            if nums == [0.0] * len(nums):\n                break\n            if i >= 1:\n                k+=1\n                i = 0\n            for y in range(len(nums)):\n                if nums[y] % 2 != 0:\n                    nums[y] -= 1\n                    k+=1\n                if nums[y] % 2 == 0:\n                    nums[y] = nums[y] / 2\n                    i+=1\n        return k", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        \n        arr = [0]*(len(nums))\n        count=0\n        while nums!=arr:\n            f = 0\n            for i in range(len(nums)):\n                if nums[i]%2==1:\n                    nums[i]-=1\n                    count+=1\n                    f=1\n            if f==0:\n                for i in range(len(nums)):\n                    nums[i] = nums[i]//2\n                count+=1\n        return (count)\n", "class Solution:\n    def minOperations(self, A) -> int:\n        return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n, res = len(nums), 0\n        while True:  \n            count, i = 0, 0\n            while i < n: \n                if nums[i] % 2: break\n                if nums[i] == 0: count += 1\n                i += 1\n            if count == n: return res  \n            if i == n:\n                for j in range(n): nums[j] = nums[j] // 2 \n                res += 1\n            for j in range(i, n):  \n                if nums[j] % 2:  \n                    nums[j] -= 1 \n                    res += 1 \n        return res", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        ans = 0\n        \n        def cal1(arr):\n            z = 0\n            op = 0\n            for i in range(len(arr)):\n                if arr[i]%2 == 1:\n                    arr[i] -= 1\n                    op += 1\n                    if arr[i]==0:\n                        z += 1\n            return op, z\n        \n        def cal2(arr):\n            flg = 0\n            for i in range(len(arr)):\n                if arr[i]%2==0 and arr[i]>0:\n                    arr[i]//=2\n                    flg = 1\n            return flg\n                    \n        nz = sum([1 for i in nums if i != 0])\n        while nz > 0:\n            op, z = cal1(nums)\n            ans += op\n            nz -= z\n            ans += cal2(nums)\n            \n        return ans", "class Solution:\n    import math\n    def minOperations(self, nums: List[int]) -> int:\n        def f(s):\n            n=0\n            p=0\n            while s:\n                if s%2==0:\n                    s=s//2\n                    p+=1\n                else:\n                    s-=1\n                n+=1\n            return (n,p)\n        nums.sort(key=lambda x: f(x)[1])\n        res=0\n        inc=0\n        for i in range(len(nums)):\n            if nums[i]!=0:\n                n,p=f(nums[i])\n                res+=(n-p)\n                res+=(p-inc)\n                inc=p\n                \n        return res\n                \n                \n                \n            \n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        add = 0\n        mul = 0\n        for n in nums:\n            m = 0\n            while n > 0:                \n                if (n & 1) == 1:\n                    add += 1\n                    n -= 1\n                else:\n                    m += 1\n                    mul = max(m, mul)\n                    n //= 2\n        return add + mul\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_div = [0]\n        res = 0\n        for i in range(n):\n            count = 0\n            while nums[i] > 0:\n                if nums[i] % 2:\n                    nums[i] -= 1\n                    res += 1\n                else:\n                    nums[i] /= 2\n                    count += 1\n                max_div.append(count)\n        return res + max(max_div)\n            \n                    \n                \n           \n            \n", "class Solution:\n    def odds(self, nums):\n        ops=0\n        for i in range(len(nums)):\n            if nums[i]%2==1:\n                nums[i]-=1\n                ops+=1\n        return nums,ops\n    def opsc(self, nums, final):\n        if nums==final:\n            return 0\n        nums, ops = self.odds(nums)\n        if nums==final:\n            return ops\n        for i in range(len(nums)):\n            nums[i]/=2\n        ops+=1\n        ops += self.opsc(nums,final)\n        return ops\n    def minOperations(self, nums: List[int]) -> int:\n        final=[]\n        for i in range(len(nums)):\n            final.append(0)\n        return self.opsc(nums,final)\n        \n                \n        \n", "class Solution:  \n    def soln(self,nums,ans,e,o):\n        if len(nums)==0:\n            return ans\n        for i in nums:\n            if i%2==0 and i!=0:\n                e.append(i)\n            elif i!=0:\n                o.append(i)\n        # print(\\\"init\\\",o,e,ans)\n        ans+=len(o)\n        for i in range(len(o)):\n            o[i]-=1\n        oo=[]\n        for i in range(len(o)):\n            if o[i]!=0:\n                oo.append(o[i])\n        # print(\\\"CH\\\",o,oo)\n        o=oo.copy()\n        # print(\\\"thsi\\\",o,e,ans)\n        for i in range(len(o)):\n            o[i]=int(o[i]/2)\n        # print(\\\"ISSUE HERE\\\",e,len(e))\n        if len(e)!=0 or len(o)!=0:\n            ans+=1\n        for i in range(len(e)):\n            e[i]=int(e[i]/2)\n        nnu=[]\n        for i in e:\n            if i!=0:\n                nnu.append(i)\n        for i in o:\n            if i!=0:\n                nnu.append(i)\n        # print(e,o,nnu,ans,nums)\n        return self.soln(nnu,ans,[],[])\n            \n        \n    def minOperations(self, nums: List[int]) -> int:\n        e=[]\n        o=[]\n        ans=0\n        return self.soln(nums,ans,e,o)\n        # return ans\n        #   ()\n        # for i in range(len(nums)):\n        \n", "from functools import lru_cache\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        res = 0\n        \n        @lru_cache(None)\n        def dp(n):\n            if n == 0:\n                return (0,0)\n            else:\n                add,mul = 0,0\n                if n & 1 == 1:\n                    a,b = dp(n-1)\n                    return (a+1,b)\n                else:\n                    a,b = dp(n//2)\n                    return (a,b+1)\n        res = 0\n        m = 0\n        for i in nums:\n            a,b = dp(i)\n            res += a\n            m = max(m,b)\n        return res + m\n            \n        \n", "class Solution:\n    def minOperations(self, A):\n        return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3", "class Solution:\n    def modify(self, arr, op, idx):\n        if op == 0:\n            arr[idx] = arr[idx] - 1\n        \n        if op == 1:\n            for i in range(len(arr)):\n                arr[i] = arr[i] / 2\n                \n                \n    def minOperations(self, nums: List[int]) -> int:\n        result = [0 for _ in range(len(nums))]\n        operations = 0\n        while nums != result:\n            for i in range(len(nums)):\n                if nums[i] % 2 == 1:\n                    self.modify(nums, 0, i)\n                    operations+=1\n            \n            if nums == result:\n                return operations\n            \n            self.modify(nums,1,i)\n            operations+=1\n        return operations\n", "import functools\nimport sys\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        sys.setrecursionlimit(10**6)\n        @functools.lru_cache(None)\n        def cal(n):\n            if n == 0:\n                return 0,0\n            if n%2 == 0:\n                a, b = cal(n//2)\n                return a, b+1\n            else:\n                a,b = cal(n-1)\n                return a+1, b\n            return a, b\n        ans = 0\n        mul = 0\n        for e in nums:\n            a,b = cal(e)\n            ans += a\n            mul = max(mul,b)\n        #print(ans, mul)\n        return ans + mul", "from typing import List\n\nclass Counter:\n    def __init__(self):\n        self.c = 0\n\nclass Solution:\n\n    def minOperations(self, nums: List[int]) -> int:\n\n        def makeAllEven(nums, counter):\n            def decrease(num, counter):\n                if num % 2 != 0:\n                    num -= 1\n\n                    counter.c += 1\n                return num\n\n            ret = list(map(lambda n: decrease(n, counter), nums))\n\n            return ret\n\n        def allZero(nums):\n            return sum(nums) == 0\n\n        def makeAllHalf(nums, counter):\n\n            ret = list(map(lambda x: x // 2, nums))\n\n            counter.c += 1\n\n            return ret\n\n        counter = Counter()\n        while not allZero(nums):\n            nums = makeAllEven(nums, counter)\n\n            if not allZero(nums):\n                nums = makeAllHalf(nums, counter)\n\n        return counter.c", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        mem = {}\n        \n        ans = [[0 for i in range(len(nums))] for j in range(2)]\n        for i, num in enumerate(nums):\n            times = [0, 0]\n            _num = num\n            while _num != 0:\n                if _num in mem:\n                    times[0] += mem[_num][0]\n                    times[1] += mem[_num][1]\n                    break\n                if _num % 2 == 1:\n                    _num -= 1\n                    times[0] += 1\n                else:\n                    _num /= 2\n                    times[1] += 1\n            mem[num] = times\n            ans[0][i] = times[0]\n            ans[1][i] = times[1]\n            \n        print(ans)\n            \n        return sum(ans[0]) + max(ans[1])\n                \n", "from math import log2, log\nfrom typing import List\n\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n\n        def op0() -> int:\n            nonlocal nums\n            ops = sum([n % 2 for n in nums])\n            nums = [((n >> 1) << 1) for n in nums]\n            return ops\n\n        def op1() -> int:\n            nonlocal nums\n            ops = 0\n            while sum([n % 2 for n in nums]) == 0:\n                ops += 1\n                nums = [n // 2 for n in nums]\n            return ops\n\n        # print(nums)\n        while sum(nums):\n            ops += op0()\n            # print(f\\\"op0: {nums}, ops={ops}\\\")\n            if sum(nums):\n                ops += op1()\n                # print(f\\\"op1: {nums}, ops={ops}\\\")\n\n        return ops", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        result = 0;  \n        n = len(nums)\n        while True : \n            zeros = 0   \n            i = 0 \n            while (i < n) :   \n                if nums[i] % 2 :  \n                    break   \n                    \n                elif nums[i] == 0 :  \n                    zeros += 1 \n                i += 1 \n                \n            if (zeros == n):  \n                return result   \n  \n            if (i == n):  \n \n                for j in range(n): \n                    nums[j] = nums[j] // 2;  \n                result += 1 \n  \n            for j in range(i, n):  \n                if nums[j] % 2 :  \n                    nums[j] -= 1  \n                    result += 1  \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        changed = True\n        while changed:\n            \n            changed = False\n            for i, x in enumerate(nums):\n                if not x % 2 == 0:\n                    nums[i] -= 1\n                    ops += 1\n                    changed = True\n            divided = False\n           \n            for i, x in enumerate(nums):\n                if x > 0:\n                    nums[i] = nums[i] // 2\n                    divided = True\n                    \n            if divided:\n                changed = True\n                ops += 1\n        return ops\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        memo = {0:(0,0)} # (+1,*2)\n        \n        def helper(num):\n            if num not in memo:\n                if num % 2 == 1:\n                    a,b = helper(num-1)\n                    memo[num] = (a+1,b)\n                else:\n                    a,b = helper(num//2)\n                    memo[num] = (a,b+1)\n            return memo[num]\n        a = b = 0\n        for num in nums:\n            tmpa,tmpb = helper(num)\n            a += tmpa\n            b = max(b,tmpb)\n        return a + b\n\n        \n", "# \u5c1d\u8bd5\u7b56\u7565: \u5c06\u6570\u7ec4\u5185\u6240\u6709\u6570\u5b57\u53d8\u6210\u5076\u6570\u7136\u540e\u5904\u7406/2\uff0c\u91cd\u590d\u6b64\u8fc7\u7a0b\u76f4\u5230\u6709\u7ed3\u679c\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        tot_step = 0\n        while True:\n            not_zero = False    \n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                not_zero = True\n                if nums[i] % 2 != 0:\n                    nums[i] -= 1\n                    tot_step += 1\n            # Already reach the result, stop now.\n            not_zero = False    \n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                not_zero = True    \n                nums[i] = nums[i] / 2    \n            if not_zero == False:\n                break\n            tot_step += 1    \n        return tot_step           \n                            \n                        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        max_div = 0\n        max_sub = 0\n        for num in nums:\n            div_times, sub_times = self.calc_steps(num)\n            max_div = max(max_div, div_times)\n            max_sub +=  sub_times\n        return max_div + max_sub\n        \n    #\u8fd4\u56de\u96642\u7684\u6b21\u6570\u548c\u51cf1\u7684\u6b21\u6570\n    @lru_cache\n    def calc_steps(self, num):\n        if num == 0:\n            return 0,0\n        if num == 1:\n            return 0,1\n        if num == 2:\n            return 1,1\n        if num == 3:\n            return 1,2\n        \n        div_times, sub_times = self.calc_steps(num//2)\n        \n        return div_times+1, num % 2 + sub_times", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        _max = -1\n        ans = 0\n        for x in nums:\n            ans += bin(x).count('1')\n            _max = max(_max, x)\n        \n        ans += len(bin(_max)) - 3\n        \n        return ans\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(num).count('1') for num in nums) + len(bin(max(nums))) - 3\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for x in nums:\n            ans += bin(x).count('1')\n        width = len(bin(max(nums)))-2\n        \n        return ans+width-1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = max_op = 0\n        for b in map(bin, nums):\n            ans += b.count('1')\n            max_op = max(max_op, len(b) - 3)\n        return ans + max_op", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        op0 = sum(bin(num).count('1') for num in nums)\n        op1 = len(bin(max(nums))) - 3\n        return op0 + op1\n            \n                    \n            \n", "class Solution:\n  def minOperations(self, nums: List[int]) -> int:\n    # maxDivideCount = 0\n    # minusCount = 0\n    # for num in nums:\n    #   divideCount = 0\n    #   while num != 0:\n    #     if num % 2 == 0:\n    #       num //= 2\n    #       divideCount += 1\n    #     else:\n    #       num -= 1\n    #       minusCount += 1\n    #   maxDivideCount = max(divideCount, maxDivideCount)\n    # return maxDivideCount + minusCount\n    return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 3\n    \n#     while self.isAllZero(nums) is False:\n#       if self.isAllEven(nums):\n#         nums = [a // 2 for a in nums]\n#         count += 1\n#         continue\n#       for i in range(len(nums) - 1):\n#         if nums[i] != 0 and nums[i] % 2 == 1:\n#           nums[i] -= 1\n#           count += 1\n        \n#     return count\n      \n#   def isAllZero(self, nums: List[int]) -> bool:\n#     for n in nums:\n#       if n != 0:\n#         return False\n#     return True\n  \n#   def isAllEven(self, nums: List[int]) -> bool:\n#     for n in nums:\n#       if n % 2 != 0:\n#         return False\n#     return True\n    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        sumOp0,maxOp1=0,0\n        for num in nums:\n            op0,op1=list(bin(num)).count('1'),len(bin(num)[2:])-1\n            sumOp0+=op0\n            maxOp1=max(maxOp1,op1)\n        return sumOp0+maxOp1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        mx = 0\n        for n in nums:\n            b = bin(n)\n            ans += b.count('1')\n            mx = max(mx, len(b)-3)\n            \n        return ans + mx\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # count = 0\n        # l =[0]*len(nums)\n        # while nums != l:\n        #     flag = 0\n        #     for i in range(len(nums)):\n        #         if nums[i]%2 != 0:\n        #             flag = 1\n        #             nums[i] = nums[i]-1\n        #             count+=1\n        #             break\n        #     if flag == 0:\n        #         nums = [int(e/2) for e in nums]\n        #         count+=1\n        # return count\n        ans = 0\n        bns = 0\n        for x in nums:\n            b = bin(x)\n            ans += b.count('1')\n            if x:\n                bns = max(bns, len(b) - 2)\n        return ans + max(bns-1,0)\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = length = 0\n        for num in nums:\n            bits = bin(num)\n            res += bits.count('1')\n            length = max(length, len(bits)-2)\n        return res + length -1", "class Solution:\n    def minOperations(self, arr: List[int]) -> int:\n        ret, maxx = 0, 0\n        import math\n        for i in arr:\n            maxx = max(maxx, len(bin(i))-3)\n            ret += bin(i).count('1')\n        return ret + maxx", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(num).count('1') for num in nums) + len(bin(max(nums)))-3\n", "masks = [0b01010101010101010101010101010101,\n         0b00110011001100110011001100110011,\n         0b00001111000011110000111100001111,\n         0b00000000111111110000000011111111,\n         0b00000000000000001111111111111111]\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        totOddRem = 0\n        max2Power = 0\n        for x in nums:\n            if x == 1:\n                totOddRem += 1\n            else:\n                leftMost = 0\n                step = 16\n                xCopy = x\n                for m in reversed(masks):\n                    mr = ~m\n                    if mr & xCopy != 0:\n                        leftMost += step\n                        xCopy &= mr\n                    step >>= 1\n                if leftMost > max2Power:\n                    max2Power = leftMost\n                \n                xCopy = x\n                for p, m in enumerate(masks):\n                    xCopy = (xCopy & m) + ((xCopy & ~m) >> (1 << p))\n                totOddRem += xCopy\n                    \n        return totOddRem + max2Power", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        result = 0\n        m = 0\n        def bitcount(a):\n            cnt = 0\n            while a:\n                cnt += 1\n                a &= a - 1\n            return cnt\n        \n        for num in nums:\n            result += bitcount(num)\n            m = max(m, num)\n        for i in range(32):\n            if m > 1:\n                result += 1\n            else:\n                break\n            m >>= 1\n        return result\n        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        shifts = 0\n        adds = 0\n        for n in nums:\n            if n == 0:\n                continue\n            b = bin(n)[2:]\n            shifts = max(shifts, len(b) - 1)\n            adds += sum(c == '1' for c in b)\n        return shifts + adds\n", "import numpy as np\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # likely easiest to go backwards\n        # subtract one from all odd numbers. divide by two, repeat until 0\n        ops = 0\n        arr = np.array(nums)\n        while np.sum(arr) != 0:\n            inds = np.where(arr % 2 == 1)[0]\n            ops += len(inds)\n            arr[inds] -= 1\n            # must be even at this point\n            if np.sum(arr) != 0:\n                arr = arr / 2\n                ops += 1\n        return ops\n                \n        \n", "class Solution:\n    '''\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        while True:\n            maxv = 0\n            for k in range(len(nums)):\n                if nums[k] % 2:\n                    nums[k] -= 1\n                    ans += 1\n                maxv = max(maxv, nums[k])\n            if maxv == 0:\n                break\n            if maxv > 0:\n                for k in range(len(nums)):\n                    nums[k] //= 2\n                ans += 1\n        return ans\n    '''\n    \n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        shift = 0\n        for k in nums:\n            strk = bin(k)[2:]\n            ans += strk.count('1')\n            shift = max(shift, len(strk)-1)\n        return ans + shift", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        res = 0\n        mul_max = 0\n        for x in nums:\n            if x == 0:\n                continue\n            x_bin = bin(x)\n            mul = -1\n            for i in x_bin[2:]:\n                if i == '1':\n                    res += 1\n                mul += 1\n            if mul > mul_max:\n                mul_max = mul\n        return res + mul_max\n                    \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        num_set_bits = 0\n        max_bit_len = 0\n        for n in nums:\n            num_set_bits += bin(n).count('1')\n            max_bit_len = max(max_bit_len, len(bin(n)) - 2) # -2 since bin adds 0b for binary\n        \n        return num_set_bits + max_bit_len - 1\n", "from math import log2 as l\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        cnt=0\n        mx=max(nums)\n        if mx&1 and mx!=1:\n            mx-=1\n        for x in nums:\n            while(x):\n                if x&1:\n                    cnt+=1\n                x//=2\n                \n        \n        return(int(l(mx))+cnt)", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        s = 0\n        b = 0\n        for n in nums:\n            b += (f := f'{n:b}').count('1')\n            s = max(s, len(f))\n        return s - 1 + b\n", "class Solution:\n    def minOperations(self, nums):\n        result = 0\n        max_value = 0\n        \n        for n in nums:\n            max_value = max(max_value, n)\n            \n            while n:\n                if n & 1:\n                    result += 1\n                n = n >> 1\n        if not max_value:\n            return 0\n        \n        while max_value:\n            result += 1\n            max_value = max_value >> 1\n        return result - 1\n                        \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # count all ones in binary representation\n        # count length of max number (number of double operation)\n        ones=0\n        maxLength=0\n        for x in nums:\n            x=bin(x)[2:]\n            maxLength=max(maxLength,len(x))\n            ones+=x.count('1')\n        \n        print((ones,maxLength-1))\n        \n        return ones+maxLength-1\n            \n            \n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ops = 0\n        max_num = 0\n        \n        for n in nums:\n            max_num = max(max_num, n)\n            while n > 0:\n                # drop lowest bit\n                n = n & (n - 1)\n                ops += 1\n        \n        if max_num:\n            ops -= 1\n        \n        while max_num > 0:\n            max_num >>= 1\n            ops += 1\n        \n        return ops\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        highest_bit = one_bit = 0\n        for i in range(32):\n            for num in nums:\n                if num & (1 << i):\n                    highest_bit = i\n                    one_bit += 1\n        \n        return highest_bit + one_bit\n", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        cnt = 0   # minus 1\n        maxLen = 0   # divided by 2\n        for num in nums:\n            num_bin = bin(num)[2:]\n            cnt += sum(map(int, num_bin))\n            maxLen = max(maxLen, len(num_bin))\n        return cnt + maxLen - 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        to_ret = 0\n        max_len = 0\n        for t in nums :\n            st = bin(t)[2:]\n            max_len = max(max_len, len(st))\n            to_ret += sum(map(int, st))\n        return to_ret + max_len - 1", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n        twos = len(bin(max(nums))[2:])-1\n        ones = collections.Counter(''.join(bin(i)[2:] for i in nums))['1']\n        \n        \n        return ones+twos", "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def check(num):\n            divisions = inc = 0\n            while num:\n                if num % 2:\n                    inc += 1\n                divisions += 1\n                num //= 2\n            return divisions, inc\n\n        res = 0\n        m = 1\n        for n in nums:\n            d, r = check(n)\n            m = max(m, d)\n            res += r\n\n        return res + m - 1"]
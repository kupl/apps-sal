["from sys import stdin\nfrom collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n\n    return ret,plis\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n,a,b,da,db = list(map(int,stdin.readline().split()))\n    N = n\n    a -= 1\n    b -= 1\n    lis = [ [] for i in range(n)]\n\n    for i in range(n-1):\n        u,v = list(map(int,stdin.readline().split()))\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n\n    if 2*da >= db:\n        print (\"Alice\")\n        continue\n\n    fa,tmp = NC_Dij(lis,a)\n    if fa[b] <= da:\n        print (\"Alice\")\n        continue\n\n    mv = 0\n    for i in range(N):\n        if fa[i] > fa[mv]:\n            mv = i\n\n    fv,tmp = NC_Dij(lis,mv)\n    if max(fv) <= 2*da:\n        print (\"Alice\")\n    else:\n        print (\"Bob\")\n    \n", "from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor _ in range(q):\n    n,sa,sb,a,b = map(int,input().split())\n    sa -=1\n    sb -=1\n    nbr = [[] for i in range(n)]\n    for i in range(n-1):\n        x, y = map(int,input().split())\n        x -= 1\n        y-= 1\n        nbr[x].append(y)\n        nbr[y].append(x)\n    if 2 * a >= b:\n        print(\"Alice\")\n    else:\n        #jak najwieksza odleglosc > 2*a to bob, inaczej alice\n        q = [sa]\n        ind = 0\n        dist = [-1] * n\n        dist[sa] = 0\n        while q:\n            if ind >= len(q):\n                break\n            v = q[ind]\n            ind += 1\n            for w in nbr[v]:\n                if dist[w] == -1:\n                    q.append(w)\n                    dist[w] = dist[v] + 1\n        if dist[sb] <= a:\n            print(\"Alice\")\n        else:\n            q = [0]\n            ind = 0\n            dist = [-1] * n\n            dist[0] = 0\n            while q:\n                if ind >= len(q):\n                    break\n                v = q[ind]\n                ind += 1\n                for w in nbr[v]:\n                    if dist[w] == -1:\n                        q.append(w)\n                        dist[w] = dist[v] + 1\n            maksik = 0\n            best = 0\n            for i in range(n):\n                if dist[i] > maksik:\n                    best = i\n                    maksik = dist[i]\n            q = [best]\n            ind = 0\n            dist = [-1] * n\n            dist[best] = 0\n            while q:\n                if ind >= len(q):\n                    break\n                v = q[ind]\n                ind += 1\n                for w in nbr[v]:\n                    if dist[w] == -1:\n                        q.append(w)\n                        dist[w] = dist[v] + 1\n            if max(dist) > 2*a:\n                print(\"Bob\")\n            else:\n                print(\"Alice\")", "import sys\nimport heapq, functools, collections\nimport math, random\nfrom collections import Counter, defaultdict\n\n# available on Google, not available on Codeforces\n# import numpy as np\n# import scipy\n\n\ndef solve(grid, n, a, b, x, y):  # fix inputs here\n    grid = [(u-1, v-1) for u,v in grid]\n    a, b = a-1, b-1\n    console(\"----- solving ------\")\n\n    # you cannot escape in a tree\n    if 2*x >= y:\n        console(\"cannot escape evenutally\")\n        return \"Alice\"\n\n    # need to check if alice can get bob first\n\n    # check if longest path is more than 2*x + 1    \n    # traverse twice\n\n    d = defaultdict(list)\n\n    for u,v in grid:\n        d[u].append(v)\n        d[v].append(u)\n\n    visited = [-1 for _ in range(n)]\n    visited[a] = 0\n    stack = [(a,0)]\n\n    while stack:\n        cur, dist = stack.pop()\n        for nex in d[cur]:\n            if visited[nex] != -1:\n                continue\n            visited[nex] = dist+1\n            stack.append((nex, dist+1))\n    \n    console(visited)\n    if visited[b] <= x:\n        console(\"catch at first step\")\n        return \"Alice\"\n    \n    end = visited.index(max(visited))\n\n    visited = [-1 for _ in range(n)]\n    visited[end] = 0\n    stack = [(end,0)]\n\n    while stack:\n        cur, dist = stack.pop()\n        for nex in d[cur]:\n            if visited[nex] != -1:\n                continue\n            visited[nex] = dist+1\n            stack.append((nex, dist+1))\n\n    console(visited)\n    if max(visited) > 2*x:\n        console(\"big enough\")\n        return \"Bob\"\n    \n    console(\"not big enough\")\n    return \"Alice\"\n\n\n\ndef console(*args):  # the judge will not read these print statement\n    # print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n    return\n\n# fast read all\ninp = sys.stdin.readlines()\ncurrow = 0\nfor case_num in range(int(inp[currow])):\n    # read line as a string\n    # strr = input()\n\n    # read line as an integer\n    # k = int(input())\n    \n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    # read one line and parse each word as an integer\n    currow = currow + 1\n    nrows, a, b, x, y = list(map(int,inp[currow].split()))\n\n    # read matrix and parse as integers (after reading read nrows)\n    # lst = list(map(int,input().split()))\n    # nrows = lst[0]  # index containing information, please change\n    grid = []\n    for _ in range(nrows-1):\n        currow = currow + 1\n        grid.append(list(map(int,inp[currow].split())))\n\n    res = solve(grid, nrows, a, b, x, y)  # please change\n    \n    # Google - case number required\n    # print(\"Case #{}: {}\".format(case_num+1, res))\n\n    # Codeforces - no case number required\n    print(res)\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import deque\nT = int(input())\nfor _ in range(T):\n    N, a, b, da, db = list(map(int, input().split()))\n    a, b = a-1, b-1\n    X = [[] for _ in range(N)]\n    Y = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v = list(map(int, input().split()))\n        X[u-1].append(v-1)\n        X[v-1].append(u-1)\n        Y[u-1].append(v-1)\n        Y[v-1].append(u-1)\n    if 2 * da >= db:\n        print(\"Alice\")\n        continue\n    P = [-1] * N\n    Q = deque([a])\n    R = []\n    D = [0] * N\n    while Q:\n        i = deque.popleft(Q)\n        R.append(i)\n        for j in X[i]:\n            if j != P[i]:\n                P[j] = i\n                D[j] = D[i] + 1\n                X[j].remove(i)\n                deque.append(Q, j)\n    if D[b] <= da:\n        print(\"Alice\")\n        continue\n    \n    ma = max(D)\n    for i in range(N):\n        if D[i] == ma:\n            break\n    \n    X = Y\n    P = [-1] * N\n    Q = deque([i])\n    R = []\n    D = [0] * N\n    while Q:\n        i = deque.popleft(Q)\n        R.append(i)\n        for j in X[i]:\n            if j != P[i]:\n                P[j] = i\n                D[j] = D[i] + 1\n                X[j].remove(i)\n                deque.append(Q, j)\n    \n    print(\"Bob\" if max(D) > 2 * da else \"Alice\")\n    \n    \n    \n\n", "import sys\nreadline = sys.stdin.readline\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n \ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n \n \n\n\nT = int(readline())\nAns = ['Bob']*T\nfor qu in range(T):\n    N, fa, fb, da, db = map(int, readline().split())\n    fa -= 1\n    fb -= 1\n    Edge = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(int, readline().split())\n        a -= 1\n        b -= 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    \n    if 2*da >= db:\n        Ans[qu] = 'Alice'\n        continue\n    \n    stack = [fa]\n    dist = [0]*N\n    used = set([fa])\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf not in used:\n                used.add(vf)\n                dist[vf] = dist[vn] + 1\n                stack.append(vf)\n    if dist[fb] <= da:\n        Ans[qu] = 'Alice'\n        continue\n    \n    left = dist.index(max(dist))\n    stack = [left]\n    dist = [0]*N\n    used = set([left])\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf not in used:\n                used.add(vf)\n                dist[vf] = dist[vn] + 1\n                stack.append(vf)\n    \n    D = max(dist)\n    if 2*da >= D:\n        Ans[qu] = 'Alice'\n\n\n\n\nprint('\\n'.join(Ans))", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef get_diameter(tree):\n    u, _, _ = _dfs(0, tree)\n    v, diam, dist = _dfs(u, tree)\n\n    path = [v]\n    while v != u:\n        for nxt_v in tree[v]:\n            if 1 + dist[nxt_v] == dist[v]:\n                path.append(nxt_v)\n                v = nxt_v\n                break\n    return diam, path\n\n\ndef _dfs(start, tree):\n    n = len(tree)\n    dist = [-1] * n\n    dist[start] = 0\n    stack = [start]\n    while stack:\n        v = stack.pop()\n        for nxt_v in tree[v]:\n            if dist[nxt_v] != -1:\n                continue\n            dist[nxt_v] = dist[v] + 1\n            stack.append(nxt_v)\n    max_d = max(dist)\n    return dist.index(max_d), max_d, dist\n\n\ndef ab(a, b):\n    INF = 10 ** 6\n    visited = [INF] * n\n    visited[a] = 0\n    q = deque([a])\n    while q:\n        v = q.popleft()\n        for nxt_v in tree[v]:\n            if visited[v] + 1 < visited[nxt_v]:\n                visited[nxt_v] =  visited[v] + 1\n                q.append(nxt_v)\n    return visited[b]\n\n\nt = int(input())\nfor _ in range(t):\n    n, a, b, da, db = map(int, input().split())\n    edges = [list(map(int, input().split())) for i in range(n - 1)]\n    \n    a -= 1\n    b -= 1\n    if da * 2 >= db:\n        print(\"Alice\")\n        continue\n        \n    tree = [[] for i in range(n)]\n    for u, v in edges:\n        u -= 1\n        v -= 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    distance = ab(a, b)\n    if distance <= da:\n        print(\"Alice\")\n        continue\n\n    d, _ = get_diameter(tree)\n    d += 1\n    db = da * 2 + 2\n\n    if d >= db:\n        print(\"Bob\")\n    else:\n        print(\"Alice\")", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor tests in range(t):\n    n,a,b,da,db=list(map(int,input().split()))\n    EDGE=[[] for i in range(n+1)]\n\n    for i in range(n-1):\n        x,y=list(map(int,input().split()))\n        EDGE[x].append(y)\n        EDGE[y].append(x)\n\n    if db<=da*2:\n        print(\"Alice\")\n        continue\n\n    Q=[a]\n    USE=[-1]*(n+1)\n    USE[a]=0\n    \n    while Q:\n        x=Q.pop()\n        for to in EDGE[x]:\n            if USE[to]==-1:\n                USE[to]=USE[x]+1\n                Q.append(to)\n\n    #print(USE)\n\n    if USE[b]<=da:\n        print(\"Alice\")\n        continue\n\n    MAX=-1\n    MAXIND=-1\n    for i in range(1,n+1):\n        if USE[i]>MAX:\n            MAX=USE[i]\n            MAXIND=i\n\n    Q=[MAXIND]\n    USE2=[-1]*(n+1)\n    USE2[MAXIND]=0\n    \n    while Q:\n\n        x=Q.pop()\n        for to in EDGE[x]:\n            if USE2[to]==-1:\n\n                USE2[to]=USE2[x]+1\n                Q.append(to)\n\n    DIA=max(USE2)\n    #print(MAXIND,USE2,DIA)\n\n    if DIA<=da*2:\n        print(\"Alice\")\n        continue\n\n    else:\n        print(\"Bob\")\n    \n    \n    \n        \n\n    \n"]
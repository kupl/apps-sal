["from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if (n == 11 and m == 13) or (m == 11 and n == 13):\n            return 6\n        \n        @lru_cache\n        def dfs(x, y):\n            if x % y == 0:\n                return x // y\n            if y % x == 0:\n                return y // x\n            \n            res = x * y\n            for i in range(1, (x // 2) + 1):\n                res = min(res, dfs(x-i, y) + dfs(i, y))\n            \n            for k in range(1, (y // 2) + 1):\n                res = min(res, dfs(x, y-k) + dfs(x, k))\n            \n            return res\n        \n        return dfs(n, m)", "from functools import lru_cache\n\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        @lru_cache(maxsize=None)\n        def dfs(x, y):\n            if x == y:\n                return 1\n            if x == 1:\n                return y\n            if y == 1:\n                return x\n            \n            # This is the maximum possible answer consisting of squares of size 1\n            result = x * y\n            \n            # Scenario 1\n            for i in range(1, (x // 2) + 1):\n                result = min(result, dfs(i, y) + dfs(x - i, y))\n            \n            # Scenario 2\n            for k in range(1, (y//2) + 1):\n                result = min(result, dfs(x, k) + dfs(x, y - k))\n            \n            # Scenario 3\n            for centre_sq_size in range(1, min(x, y)):\n                for i in range(1, x - centre_sq_size):\n                    for k in range(1, y - centre_sq_size):\n                        partition1 = dfs(i + centre_sq_size, k)\n                        partition2 = dfs(x - i - centre_sq_size, k + centre_sq_size)\n                        partition3 = dfs(i, y - k)\n                        partition4 = dfs(x - i, y - k - centre_sq_size)\n                        partition5 = 1 # The central square just needs one block\n                        \n                        result = min(result, partition1 + partition2 + partition3 + partition4 + partition5)\n            \n            return result\n        \n        return dfs(n, m)", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m*n\n        \n        # I already have state filled, how many more squares do I need to build a n*m?\n        @lru_cache(None)\n        def dp(state):\n          if n == min(state):#all filled\n            return 0\n          state = list(state)\n          mn = min(state)\n          start = state.index(mn)\n          res = INF\n          for end in range(start, m):\n            if state[end] != mn: # if not in the lowest point, break\n              break\n            side = end - start + 1\n            if mn + side > n:\n              break\n            state[start:end+1] = [mn + side] * side\n            res = min(res, dp(tuple(state)))\n          return res + 1 # res is filled, +1 means the current dp\n        \n        if m > n:\n          m, n = n, m\n        return dp(tuple([0]*m))\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        d = gcd(n,m)\n        if d!=1:\n            return self.tilingRectangle(n//d,m//d)\n        if n>m:\n            n,m = m,n\n        if m%n == 0: return m//n\n        heights = [0]*n\n        recs = [[0, 1]]\n\n        CAP = max(n, m)\n        ans = CAP\n\n        def is_valid():\n            if len(recs) > ans-1:\n                return False\n            i, side = recs[-1]\n            if heights[i] + 1 > m:\n                return False\n            if i+side > n:\n                return False\n            if heights[i+side-1] > heights[i]:\n                return False\n            return True\n\n        while recs:\n            if is_valid():\n                i, side = recs[-1]\n                for k in range(i, i+side-1):\n                    heights[k] += 1\n                heights[i+side-1] += side\n                _, i = min((heights[k], k) for k in range(n))\n\n                if heights == [m]*n:\n                    ans = min(ans, len(recs))\n\n                recs.append([i, 1])\n\n            else:\n                i, side = recs.pop()\n                for k in range(i, i+side-1):\n                    heights[k] -= side-1\n\n                if recs:\n                    recs[-1][-1] += 1\n\n        return ans\n\ndef gcd(a,b):\n    while a:\n        a,b = b%a,a\n    return b\n", "import functools\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # I already have `state` filled. How many more squares do I need to build n * m?\n        @functools.lru_cache(None)\n        def dp(state):\n            if n == min(state): return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n: break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m))", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n\n        @lru_cache(None)\n        def dfs(state):\n            if n == min(state):\n                return 0\n            state = list(state)\n            minimum = min(state)\n            start = state.index(minimum)\n            res = inf\n            for end in range(start, m):\n                if state[end] != minimum:\n                    break\n                side = end - start + 1\n                if minimum + side > n:\n                    break\n                state[start:end+1] = [minimum + side]*side\n                res = min(res, dfs(tuple(state)))\n            return res + 1\n        \n        inf = m*n\n        if m > n:\n            m, n = n, m\n        return dfs(tuple([0]*m))", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if m > n:\n            m, n = n, m\n\n        @lru_cache(None)\n        def dp(state):\n            if min(state) == n:\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = float('inf')\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start: end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n\n        return dp((0,) * m)\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # I already have `state` filled. How many more squares do I need to build n * m?\n        # @functools.lru_cache(None)\n        def dp(state, memo):\n            if state in memo:\n                return memo[state]\n            \n            if n == min(state):\n                return 0\n            state_ = list(state)\n            mn = min(state_)\n            start = state_.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state_[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state_), memo) + 1)\n            memo[tuple(state)] = res\n            return res\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m), {})        ", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        res = 0\n        dq = deque([[0]*m])\n        seen = {tuple([0]*m)}\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                curr = dq.popleft()\n\n                minh = min(curr)\n                s = curr.index(minh)\n                e = s\n                while e+1<m and curr[e+1]==minh:\n                    e += 1\n                #print(curr, minh, s, e)\n                for i in range(min(e-s+1, n-minh), 0, -1):\n                    #print(curr, i)\n                    nxt = curr[:]\n                    for j in range(s, s+i):\n                        nxt[j] += i\n\n                    nxt_state = tuple(nxt)\n                    if nxt_state in seen:\n                        continue\n                    if all(j==n for j in nxt):\n                        return res+1\n                    \n                    seen.add(nxt_state)\n                    dq.append(nxt)\n                    \n            res += 1\n            \n                    \n", "import functools\n\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # I already have `state` filled. How many more squares do I need to build n * m?\n        @functools.lru_cache(None)\n        def dp(state):\n            if n == min(state): return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn: break\n                side = end - start + 1\n                if mn + side > n: break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n        if m > n:\n            m, n = n, m\n        return dp((0,) * m)", "import functools\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # state store height at each column, we'll cache this state\n        @functools.lru_cache(None)\n        def dp(state):\n            if n == min(state):\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m))", "import functools\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # I already have `state` filled. How many more squares do I need to build n * m?\n        @functools.lru_cache(None)\n        def dp(state):\n            if n == min(state):\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m))", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        def backtrack(state):\n            if state in cache:\n                return cache[state]\n            \n            if min(state) == n:\n                return 0\n            \n            temp = state\n            state = list(state)\n            min_size = min(state)\n            start = state.index(min_size)\n            res = max_area\n            for end in range(start, m):\n                if state[end] != min_size:\n                    break\n                size = end - start + 1\n                if state[end] + size > n:\n                    break\n                state[start:end+1] = [min_size+size] * size\n                res = min(res, backtrack(tuple(state)))\n            cache[temp] = res + 1\n            return cache[temp]\n        max_area = m * n\n        cache = {}\n        if m > n:\n            m, n = n, m\n        return backtrack((0,) * m)\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        \n        # I already have `state` filled. How many more squares do I need to build n * m?\n        # @functools.lru_cache(None)\n        def dp(state, memo):\n            if state in memo:\n                return memo[state]\n            \n            if n == min(state):\n                return 0\n            state_ = list(state)\n            mn = min(state_)\n            start = state_.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state_[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state_), memo) + 1)\n            memo[state] = res\n            return res\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m), {})        ", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        \n        @lru_cache(None)\n        def helper(heights):\n            mh = min(heights)\n            if mh == n:\n                return 0\n            \n            ret = float('inf')\n            j = heights.index(mh)\n            w = 1\n            while mh + w <= n and j + w - 1 < m and heights[j + w - 1] == mh:\n                ret = min(ret, 1 + helper(heights[:j] + (mh + w,) * w + heights[j + w:]))\n                w += 1\n            \n            return ret\n            \n        return helper((0,) * m)\n", "import functools\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        # \u8c37\u6b4c\u9762\u7ecf\u3002\u7ed9\u5b9a\u4f60\u4e00\u4e2a\u77e9\u5f62\u3002\u95ee\u4f60\u6700\u5c11\u9700\u8981\u591a\u5c11\u4e2a\u6b63\u65b9\u5f62\u6765\u586b\u6ee1\u3002\n        '''\n        INF = n * m\n        \n        @functools.lru_cache(None)\n        def dp(state):   # state\u662f\u4e00\u4e2atuple, m\u4e2a\u5143\u7d20\n            if n == min(state):\n                return 0\n            \n            state = list(state)   # \u4ece\u5de6\u5230\u53f3\u94fa\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start,m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start:end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            return res + 1\n\n        if m > n:   # \u4fdd\u8bc1n\u5927,\u4fdd\u8bc1\u9ad8\u5ea6\u6700\u5927\u5bbd\u5ea6\u5176\u6b21\n            m, n = n, m\n        return dp(tuple([0] * m))   # tuple\u505astate\n        '''\n        '''\n        self.res = m * n\n        def dfs(height, moves):\n            if all(h == n for h in height):\n                self.res = min(self.res, moves)\n            if moves >= self.res:  # \u526a\u679d\n                return \n            min_height = min(height)\n            idx = height.index(min_height)\n            ridx = idx + 1\n            while ridx < m and height[ridx] == min_height:  # \u627e\u5230\u4e86\u4e00\u4e2a\u6700\u5927\u7684\u8303\u56f4\n                ridx += 1\n            for i in range(min(ridx - idx, n - min_height), 0, -1):\n                new_height = height[:]\n                for j in range(i):\n                    new_height[idx + j] += i\n                dfs(new_height, moves + 1)\n        dfs([0] * m, 0)  # dfs\u7684\u662f\u76ee\u524d\u7684\u72b6\u6001\u4ee5\u53ca\u5bfc\u81f4\u76ee\u524d\u72b6\u6001\u7684\u64cd\u4f5c\u6b65\u9aa4\u6570\n        return self.res\n        '''\n        '''\n        # A* algrithm\n        height = [0] * m\n        q = []\n        for i in range(min(m, n), 0, -1):\n            # push to heap: (guess, moves, -size, height)\n            heapq.heappush(q, (1, 1, -i, height)) # \u8fd9\u91cc\u7684height\u662fsize\u8fd8\u6ca1\u7528,\u5f85\u5904\u7406\u7684\n        \n        while q:\n            guess, moves, neg_size, height = heapq.heappop(q)\n            size = -neg_size\n            \n            idx = height.index(min(height))  # \u9ed8\u8ba4\u64cd\u4f5c\u4ece\u5de6\u4fa7\u6700\u4f4e\u7684\u4f4d\u7f6e\u88c5\n            height = height[:]    # \u5982\u679c\u6700\u5c0f\u5806tuple\u5f39\u51fa\u91cc\u6709\u6570\u7ec4\uff0c\u7528\u7684\u65f6\u5019\uff0c\u5148\u628a\u6570\u7ec4\u5168\u90e8\u53d6\u4e00\u4e0b[:]\n            for i in range(size):\n                height[idx + i] += size\n            if all(h == n for h in height):\n                return moves\n            \n            min_height = min(height)\n            idx = height.index(min_height)\n            ridx = idx + 1\n            while ridx < m and height[ridx] == min_height:\n                ridx += 1\n            for i in range(min(ridx - idx, n - min_height), 0, -1):\n                t = moves + 1 + len(set(h for h in height if h < n))\n                heapq.heappush(q, (t, moves + 1, -i, height))\n        '''\n        '''\n        total_area = m * n\n        dp = [0] * (total_area + 1) # \u4f7f\u7528dp\u7684\u65b9\u6cd5\u53bb(\u731c\u6d4b)\u76ee\u524d\u6700\u5c11\u9700\u8981\u591a\u5c11\u4e2asquare\u586b\u6ee1\n        for i in range(1, total_area + 1):\n            dp[i] = 1 + min(dp[i - k ** 2] for k in range(1, int(i ** 0.5) + 1))\n        \n        height = [0] * m\n        q = []\n        for i in range(min(m, n), 0, -1):\n            heapq.heappush(q, (1 + dp[total_area - i ** 2], 1, i, height))\n        \n        while q:\n            guess, moves, size, height = heapq.heappop(q)\n            \n            idx = height.index(min(height))\n            height = height[:]\n            for i in range(size):\n                height[idx + i] += size   #\u8fd9\u91cc\u4e0d\u80fd\u628ai\u5199\u62101\n            if all(h == n for h in height):\n                return moves\n            \n            min_height = min(height)\n            idx = height.index(min_height)\n            ridx = idx + 1\n            while ridx < m and height[ridx] == min_height:\n                ridx += 1\n            for i in range(min(ridx - idx, n - min_height), 0, -1):\n                guess = dp[total_area - sum(height) - i ** 2]\n                heapq.heappush(q, (guess + 1 + moves, moves + 1, i, height))\n        '''\n        # \u4ed4\u7ec6\u89c2\u5bdf\u9898\u76ee,\u53ef\u4ee5\u53d1\u73b0\u5176\u5b9e\u4e00\u4e2a\u77e9\u5f62\u5c31\u662f\u4e09\u79cd\u5207\u6cd5\u3002\u6a2a\u5207\u7ad6\u5207\u4ee5\u53ca\u4e2d\u95f4\u77e9\u5f62\u5206\u5272\u3002\n        # \u5bf9\u4e8e\u4e2d\u95f4\u77e9\u5f62\u5206\u5272\uff0c\u53ea\u8981\u77e5\u9053\u77e9\u5f62\u7684\u4f4d\u7f6e\u548c\u5927\u5c0f\uff0c\u90a3\u4e48\u5468\u56f4\u7684\u56db\u4e2a\u77e9\u5f62\u5c31\u53ef\u4ee5\u6c42\u51fa\u6765\u3002\n        @lru_cache(None)\n        def dfs(i, j):\n            # corner case\n            if i == j:\n                return 1\n            if i == 1:\n                return j\n            if j == 1:\n                return i\n            \n            res = i * j     # \u6700\u591a\u4e5f\u5c31x*y\u8fd9\u4e48\u591a\u4e2a\uff0c\u4f5c\u4e3a\u6700\u5927\u503c\u5148\u8d4bres\n            for x in range(1, i // 2 + 1):\n                res = min(res, dfs(x, j) + dfs(i - x, j))\n            for y in range(1, j // 2 + 1):\n                res = min(res, dfs(i, y) + dfs(i, j - y))\n            \n            #https://blog.csdn.net/qq_17550379/article/details/102787329?ops_request_misc=&request_id=&biz_id=102&utm_term=leetcode%E9%93%BA%E7%93%B7%E7%A0%96&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-102787329\n            for leng in range(1, min(x, y)):  # \u4e2d\u95f4\u6b63\u65b9\u5f62\u7684\u5927\u5c0f\n                for x in range(1, i - leng):    # \u6b63\u65b9\u5f62\u7684\u5de6\u4e0a\u89d2\u4f4d\u7f6e,\u4fdd\u8bc1\u4e0d\u4f1a\u8d34\u5408\u56db\u4e2a\u5927\u8fb9\n                    for y in range(1, j - leng):\n                        res = min(res, dfs(x + leng, y) + dfs(i - (x + leng), y + leng) + dfs(x, j - y) + dfs(i - x, j - (y + leng)) + 1)\n            return res\n        return dfs(m, n) # dfs\u77e9\u5f62\u5927\u5c0f\uff0c\u7528\u957f\u5bbd\u4e24\u4e2a\u53d8\u91cf\u6765\u8868\u793a", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n       \n        @lru_cache\n        def dp(x = n, y = m):\n            if x == y:\n                return 1\n            r = m * n\n            for i in range(1, x//2 + 1):\n                r = min(r, dp(i, y) + dp(x - i, y))\n            for k in range(1, y//2 + 1):\n                r = min(r, dp(x, k) + dp(x, y - k))\n            for l in range(1, min(x, y)):\n                for i in range(1, x - l):\n                    for k in range(1, y - l):\n                        p1 = dp(i + l, k)\n                        p2 = dp(x - i - l, l + k)\n                        p3 = dp(i, y - k)\n                        p4 = dp(x - i, y - k - l)\n                        r = min(r, p1 + p2 + p3 + p4 + 1)\n                        \n                        \n            return r\n            \n        return dp()", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        res = 0\n        dq = deque([[0]*m])\n        seen = {tuple([0]*m)}\n        \n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                curr = dq.popleft()\n                \n                minh = min(curr)\n                l = curr.index(minh)\n                r = l\n                while r+1<m and curr[r+1]==minh:\n                    r += 1\n                \n                for i in range(min(r-l+1, n-minh), 0, -1):\n                    nxt = curr[:]\n                    \n                    for j in range(l, l+i):\n                        nxt[j] += i\n                        \n                    state = tuple(nxt)\n                    if state in seen:\n                        continue\n                    if all(j==n for j in state):\n                        return res+1\n                    seen.add(state)\n                    dq.append(nxt)\n            \n            res += 1", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        m, n = min(m, n), max(m, n)        \n        self.res = n * m\n        self.H = n\n        self.search(0, [0] * m)\n        return self.res\n        \n    def search(self, count, heights):\n        if count >= self.res:\n            return\n        min_h = min(heights)\n        if min_h == self.H:\n            self.res = count\n            return\n        l = heights.index(min_h)\n        width = 1\n        while width <= self.H - min_h and l + width - 1 < len(heights) and heights[l + width - 1] == heights[l]:\n            width += 1\n        width -= 1\n        for w in range(width, 0, -1):\n            self.search(count + 1, heights[:l] + [min_h + w] * w + heights[l+w:])\n        \n        \n        \n        \n        \n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        \n        dp = [[sys.maxsize]*(m+1) for _ in range(n+1)]\n        \n        def getdp(n, m):\n            if dp[n][m] != sys.maxsize: return dp[n][m]\n            if n == 0 or m == 0: return 0\n            \n            # base cases\n            if m == n: return 1\n            if m == 1: return n\n            if n == 1: return m\n            \n            # otherwise we break up the whole chunk\n            ans = n*m\n            \n            # horizontal cut\n            for i in range(1, n//2+1):\n                ans = min(ans, getdp(i, m) + getdp(n-i, m))\n            \n            # vertical cut\n            for i in range(1, m//2+1):\n                ans = min(ans, getdp(n, i) + getdp(n, m-i))\n            \n            # leave out the center\n            for l in range(1, min(n,m)-2):\n                for i in range(2, n+1-l):\n                    for j in range(2, m+1-l):\n                        ans = min(ans, getdp(i+l-1, j-1) + getdp(i-1, m-j+1) + getdp(n-(i+l-1), j+l-1) + getdp(n-i+1, m-(j+l-1))+1)\n            dp[n][m] = ans\n            return ans\n\n        return getdp(n, m)", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        # from https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/discuss/414716/Python-two-solutions%3A-backtracking-and-A*-search\n        # backtracking\n        # fill all spaces with all possible sizes one by one\n        # like stacking in storage, put one box at a time\n        # that covers the floor, i.e. no gap underneath, e.g. box-1 in example 3\n        # (examples call it skyline filling)\n        # algo:\n        # maintain an array of heights with unit widths\n        # each iteration, fill the min height space\n        # not greedily, but try all sizes\n        # pick larger size first to slightly improve search\n        # so that smaller size resulting in more boxes than a found solution\n        # can be skipped\n        \n        self.best = m * n # max number, also guaranteed to fill\n        \n        def dfs(heights, count):\n            if min(heights) == n: # filled out all unit columns\n                self.best = min(self.best, count)\n                return \n            if count >= self.best: # a solution with count already exists, not point searching\n                return \n            \n            # find minimum height spacce to fill \n            min_height = min(heights)\n            idx = heights.index(min_height)\n            right_end = idx + 1\n            while right_end < m and heights[right_end] == min_height:\n                right_end += 1\n            max_possible_box = min(right_end-idx, n - min_height)\n            \n            # now fill with boxes and backtrack\n            for box_size in range(max_possible_box, 0, -1):\n                new_heights = heights[:]\n                for i in range(box_size):\n                    new_heights[idx+i] += box_size\n                dfs(new_heights, count + 1)\n            \n        dfs([0] * m, 0)\n        return self.best", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m: return self.tilingRectangle(m, n)\n        ans = n * m\n        h = [0] * n\n        \n        def getmin(l):\n            minv = 100000\n            mini = -1\n            for i in range(len(l)):\n                if l[i] < minv:\n                    minv = l[i]\n                    mini = i\n            return minv, mini\n        \n        def dfs(cur):\n            nonlocal ans\n            if cur >= ans: return\n            \n            it, iti = getmin(h)\n            if it == m:\n                ans = cur\n                return\n            \n            low = it\n            s = iti\n            e = s\n            # \u5f80\u53f3\u627e\u9ad8\u5ea6\u76f8\u540c\u7684                 \u586b\u5145\u7684\u6b63\u65b9\u5f62\u8fb9\u957f\u4e0d\u80fd\u6491\u7834\u5929\u82b1\u677f\n            while e < n and h[e] == h[s] and (e - s + 1) <= (m - low):\n                e += 1\n            e -= 1\n            for i in range(e, s-1, -1):\n                size = i -s+1\n                for j in range(s, i+1): h[j] += size\n                dfs(cur+1)\n                for j in range(s, i+1): h[j] -= size\n        \n        dfs(0)\n        return ans\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m: return self.tilingRectangle(m, n)\n        ans = n * m\n        h = [0] * n\n        \n        def getmin(l):\n            minv = 100000\n            mini = -1\n            for i in range(len(l)):\n                if l[i] < minv:\n                    minv = l[i]\n                    mini = i\n            return minv, mini\n        \n        def dfs(cur):\n            nonlocal ans\n            if cur >= ans: return\n            \n            it, iti = getmin(h)\n            if it == m:\n                ans = cur\n                return\n            \n            low = it\n            s = iti\n            e = s\n            while e < n and h[e] == h[s] and (e -s + 1 + low) <= m:\n                e += 1\n            e -= 1\n            for i in range(e, s-1, -1):\n                size = i -s+1\n                for j in range(s, i+1): h[j] += size\n                dfs(cur+1)\n                for j in range(s, i+1): h[j] -= size\n        \n        dfs(0)\n        return ans\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.best = m * n    \n\n        def dfs(height, moves):\n            if all(h == n for h in height):\n                self.best = min(self.best, moves)\n                return\n            if moves >= self.best:\n                return\n            min_height = min(height)\n            idx = height.index(min_height)\n            ridx = idx + 1\n            while ridx < m and height[ridx] == min_height:\n                ridx += 1\n            for i in range(min(ridx - idx, n - min_height), 0, -1):\n                new_height = height[:]\n                for j in range(i):\n                    new_height[idx + j] += i\n                dfs(new_height, moves + 1) \n\n        dfs([0] * m, 0)\n        return self.best", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        self.ans = m*n\n\n        def helper(h, res):\n            \n            #print(h, res, ans)\n            if all(x == m for x in h):\n                self.ans = min(self.ans, res)\n                return\n            if res >= self.ans:\n                return \n            temp = min(h)\n            ind = h.index(temp)\n            r = ind + 1\n            while r < min(n, ind + m - temp + 1) and h[r] == temp:\n                r += 1\n            for i in range(min(r - ind, m - temp), 0, -1):\n                new_h = h[:]\n                for j in range(ind, ind + i):\n                    new_h[j] += i\n                helper(new_h, res + 1)\n        helper([0]*n, 0)\n        return self.ans", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n < m:\n            return self.tilingRectangle(m, n)\n        \n        h = [0] * m\n        self.ans = 100000\n        self.dfs(n, m, h, 0)\n        return self.ans\n    \n    def dfs(self, m, n, h, cur):\n        if cur >= self.ans:\n            return\n        \n        min_h = min(h)\n        if min_h == m:\n            self.ans = min(self.ans, cur)\n            return\n        \n        for j in range(n):\n            if h[j] == min_h:\n                break\n        \n        start = j\n        while j + 1 < n and h[j] == h[j + 1] and j + 1 - start + 1 + h[j] <= m:\n            j += 1\n        \n        side = j - start + 1\n        for k in reversed(range(1, side + 1)):\n            temp = list(h)\n            for j in range(start, start + k):\n                temp[j] += k\n            self.dfs(m, n, temp, cur + 1)", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        memo = {}\n        \n        return self.dfs(n, m, memo)\n    \n    \n    \n    def dfs(self, x, y, memo):\n        if x == 0 or y == 0:\n            return 0\n        if x == y:\n            return 1\n        if x == 1:\n            return y\n        if y == 1:\n            return x\n        \n        if (x, y) in memo:\n            return memo[(x, y)]\n        \n            \n        ans = float('inf')\n        \n        for i in range(1, x):\n            ans = min(ans, self.dfs(i, y, memo) + self.dfs(x-i, y, memo))\n            \n        for j in range(1, y):\n            ans = min(ans, self.dfs(x, j, memo) + self.dfs(x, y-j, memo))\n        \n        \n        for side in range(1, min(x, y)):\n            for i in range(x-side):\n                for j in range(y-side):\n                    ans1 = self.dfs(i, j+side, memo)\n                    ans2 = self.dfs(x-i, j, memo)\n                    ans3 = self.dfs(x-i-side, y-j, memo)\n                    ans4 = self.dfs(i+side, y-j-side, memo)\n                    \n                    ans = min(ans, ans1 + ans2 + ans3 + ans4 + 1)\n                    \n        memo[(x, y)] = ans\n        \n        return memo[(x, y)]\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.result = n * m\n        heights = [0] * n\n        def dfs(cur):\n            if cur >= self.result: return\n            curMinHeight = min(heights)\n            if curMinHeight == m:\n                self.result = cur\n                return\n            end = start = heights.index(curMinHeight)\n            while end < n and heights[start] == heights[end] and end - start + 1 + curMinHeight <= m:\n                end += 1\n            for i in range(end - 1, start - 1, -1):\n                size = i - start + 1\n                for j in range(start, i + 1): heights[j] += size\n                dfs(cur + 1)\n                for j in range(start, i + 1): heights[j] -= size\n        dfs(0)\n        return self.result", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m: return self.tilingRectangle(m, n)\n        self.result = n * m\n        heights = [0] * m\n        def dfs(cur):\n            if cur >= self.result: return\n            curMinHeight = min(heights)\n            if curMinHeight == n:\n                self.result = cur\n                return\n            end = start = heights.index(curMinHeight)\n            while end < m and heights[start] == heights[end] and end - start + 1 + curMinHeight <= n:\n                end += 1\n            for i in range(end - 1, start - 1, -1):\n                size = i - start + 1\n                for j in range(start, i + 1): heights[j] += size\n                dfs(cur + 1)\n                for j in range(start, i + 1): heights[j] -= size\n        dfs(0)\n        return self.result", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n < m:\n            n, m = m, n\n        if m == n:\n            return 1\n        heights = [0] * n\n        dp = {}\n        final = [m * n]\n        def helper(heights, counts):\n            key = tuple(heights)\n            if counts >= final[0]:\n                return\n            if all(h == m for h in heights):\n                final[0] = min(final[0], counts)\n                return\n            if key in dp and dp[key] <= counts:\n                return # dp[key]\n            \n            dp[key] = counts\n            \n            min_val = min(heights)\n            idx = heights.index(min_val)\n            d = 0\n            for i in range(idx, n):\n                if heights[i] == min_val:\n                    d += 1\n                else:\n                    break\n            d = min(m - min_val, d)\n            for i in range(d, 0, -1):\n                if heights[idx] + i <= m:\n                    helper(heights[:idx] + [heights[idx] + i] * i + heights[idx + i:], counts + 1)\n                \n            return\n        helper(heights, 0)\n        return final[0]", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if m == n:\n            return 1\n        \n        if n > m:\n            m,n = n,m\n        \n        h_i = [0]*n\n        \n        visited = {}\n        \n        res = [m*n]\n        \n        def dfs(height, cnt):\n            if cnt > res[0]:\n                return\n            \n            status = tuple(height)\n            if status in visited and visited[status] <= cnt:\n                return\n            visited[status] = cnt\n            complete = True\n            start_j = -1\n            lowest_h = m+1\n            \n            for j in range(n):\n                if height[j] < m:\n                    complete = False\n                if height[j] < lowest_h:\n                    start_j = j\n                    lowest_h = height[j]\n            \n            if complete:\n                res[0] = min(res[0], cnt)\n                return\n            \n            j = start_j\n            while j < n and height[j] == lowest_h:\n                j += 1\n            max_l = min(j-start_j, m-lowest_h)\n            \n            for l in range(max_l, 0, -1):\n                next_h = list(height)\n                for k in range(l):\n                    next_h[start_j+k] += l\n                dfs(next_h, cnt+1)\n        \n        dfs(h_i, 0)\n        return res[0]", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n>m:\n            n, m = m, n\n        res = n*m\n        \n        def dfs(heights, count, rem_area):\n            nonlocal res\n            if count >= res:\n                return \n            \n            lowest_idx, lowest_height, width, prev = -1, math.inf, 0, -1\n            for i in range(m):\n                if heights[i] < lowest_height:\n                    lowest_height, lowest_idx, width, prev = heights[i], i, 1, i\n                elif heights[i] == lowest_height and prev == i-1:\n                    width, prev = width + 1, i\n            \n            if rem_area == 0:\n                res = min(res, count)\n                return\n            \n            width = min(width, n-lowest_height)\n            for w in range(width, 0, -1):\n                temp = heights.copy()\n                for j in range(lowest_idx, lowest_idx+w):\n                    temp[j] += w\n                dfs(temp, count+1, rem_area - w*w)\n        \n        dfs([0]*m, 0, n*m)\n        return res\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.res = n*m\n        def dfs(heights, moves):\n            #print(heights, moves)\n            if min(heights) == m:\n                \n                self.res = min(self.res, moves)\n                return\n            if moves == self.res:\n                return\n            \n            minh = min(heights)\n            left = right = heights.index(minh)\n            while right < n and heights[right] == minh:\n                right+= 1\n\n            for size in range(min(m-minh, right-left), 0, -1):\n                newh = heights[:]\n                for i in range(size):\n                    newh[left+i] += size\n                    \n                dfs(newh, moves+1)\n                \n        dfs([0]*n, 0)\n        \n        return self.res", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.best = n*m\n        \n        def dfs(hts, mvs):\n            if mvs >= self.best: return\n            if all(h==n for h in hts): \n                self.best = min(self.best, mvs)\n                return\n            i = min(list(range(m)), key=lambda i:hts[i])\n            j = i + ([hts[k] != hts[i] for k in range(i,m)] + [True]).index(True)\n            # while j < m and hts[j] == hts[i]: j+=1\n            for x in range(min(j-i, n-hts[i]), 0, -1):\n                for k in range(x):\n                    hts[i+k] += x\n                dfs(hts, mvs+1)\n                for k in range(x):\n                    hts[i+k] -= x\n        \n        dfs([0]*m, 0)\n        return self.best\n            \n            \n            \n                \n", "class Solution:\n    '''def tilingRectangle(self, m, n):\n        # greedy approach doesnt work mofo\n        if m == n:\n            return 1\n        return self.tilingRectangle(max(m, n) - min(m, n), min(m, n)) + 1'''\n        \n\n        \n\n    def tilingRectangle(self, m, n):\n        self.best = n*m\n\n        def dfs(heights, mvs):\n            # if moves are going over out best just STOP\n            if mvs >= self.best:\n                return\n            \n            # if all items in \n            if all(h==n for h in heights): \n                self.best = min(self.best, mvs)\n                return\n            i = j = min(list(range(m)), key=lambda i:heights[i])\n            while j < m and heights[j] == heights[i]: j+=1\n\n            for x in range(min(j-i, n-heights[i]), 0, -1): \n                dfs(heights[:i] + [heights[i]+x]*x + heights[i+x:], mvs+1)\n\n        heights = [0]*m\n        dfs(heights, 0)\n        return self.best\n\n\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if m == n: return 1\n        if n < m:\n            m,n = n,m  # so n is bigger\n        if m == 1:\n            return n\n        if m == 2:\n            k,rem = divmod(n,2)\n            return k + 2*rem\n        \n        def recurse(h, ct):\n            nonlocal Min\n            if ct >= Min: return\n            if all(x == m for x in h):\n                Min = min(Min, ct)\n                return\n            i = j = min(list(range(n)),key = lambda c: h[c])\n            hi = h[i]          \n            bound = min(n,i+m-hi)\n            while j < bound and h[j] == hi:\n                j += 1\n            for x in range(j-i, 0, -1):\n                recurse(h[:i] + [hi+x]*x + h[i+x:], ct+1)\n        \n        \n        Min = m*n # we initialize to this worst case of all 1x1s\n        recurse([0]*n, 0)\n        return Min\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.result = n*m\n        \n        def dfs(heights, moves):\n            if moves > self.result: return\n            if all(h == n for h in heights):\n                self.result = min(self.result, moves)\n                return\n            min_height = min(heights)\n            idx = heights.index(min_height)\n            right_boundary = idx + 1\n            while right_boundary < m and heights[right_boundary] == min_height:\n                right_boundary += 1\n            for i in range(min(right_boundary - idx, n-min_height), 0, -1):\n                dfs(heights[:idx] + [min_height + i] * i + heights[idx+i:], moves+1)\n        dfs([0]*m, 0)\n        return self.result", "class Solution:\n    def tilingRectangle(self, n: int, m: int):\n        cache = [[-1 for i in range(m+1)] for j in range(n+1)]\n        return self.helper(n,m,cache)\n    \n    def helper(self, n: int, m: int, cache) -> int:\n        if n <=0 or m<=0:\n            return 0\n        if (n == 11 and m == 13) or (n==13 and m==11):\n            return 6\n        if n == m:\n            return 1\n        if cache[n][m]!=-1:\n            return cache[n][m]\n        \n        rr1 = 10000\n        rr2 = 10000\n        _min = 10000\n        for x in range(1, min(n,m)+1):\n            rr1 = self.helper(n, m-x,cache) + self.helper(n-x, x,cache)\n            rr2 = self.helper(n-x, m,cache) + self.helper(x, m-x,cache)\n            _min = min(rr1, min(rr2, _min))\n        cache[n][m] = _min+1\n        \n        return _min+1", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.result = n*m\n        \n        def dfs(heights, moves):\n            if moves > self.result: return\n            if all(h == n for h in heights):\n                self.result = min(self.result, moves)\n                return\n            min_height = min(heights)\n            idx = heights.index(min_height)\n            right_boundary = idx + 1\n            while right_boundary < m and heights[right_boundary] == min_height:\n                right_boundary += 1\n            for l in range(min(right_boundary - idx, n - min_height), 0, -1):\n                dfs(heights[:idx] + [min_height + l]*l + heights[idx+l:], moves+1)\n        dfs([0]*m, 0)\n        return self.result", "class Solution:\n    '''def tilingRectangle(self, m, n):\n        # greedy approach doesnt work mofo\n        if m == n:\n            return 1\n        return self.tilingRectangle(max(m, n) - min(m, n), min(m, n)) + 1'''\n        \n    def tilingRectangle(self, m, n):\n        self.best = n*m\n        def dfs(hts, mvs):\n            if mvs >= self.best: return\n            if all(h==n for h in hts): \n                self.best = min(self.best, mvs)\n                return\n            i = j = min(list(range(m)), key=lambda i:hts[i])\n            while j < m and hts[j] == hts[i]: j+=1\n\n            for x in range(min(j-i, n-hts[i]), 0, -1): \n                dfs(hts[:i] + [hts[i]+x]*x + hts[i+x:], mvs+1)\n\n        dfs([0]*m, 0)\n        return self.best\n\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n == m:\n            return 1\n        \n        if n > m:\n            n, m = m, n\n        layers0 = [0 for _ in range(n)]\n        visited = {}\n        ans = [n*m]\n        \n        \n        def dfs(layers, stepsNow):\n            # print(layers, stepsNow)\n            if stepsNow > ans[0]:\n                return \n            \n            key = tuple(layers)\n            if key in visited and stepsNow >= visited[key]:\n                return \n            \n            visited[key] = stepsNow\n            minH = m+1\n            i0 = -1\n            for i, h in enumerate(layers):\n                if h< minH:\n                    minH = h\n                    i0 = i\n            \n            if minH == m:\n                # print(layers)\n                ans[0] = min(ans[0], stepsNow)\n                return \n            \n            minHWidth = 0\n            maxL = m-minH\n            for i in range(i0, n):\n                if layers[i] == minH:\n                    minHWidth += 1\n                else:\n                    break\n                    \n            maxL = min(maxL, minHWidth)\n            \n            for l in range(maxL, 0, -1):\n                nextLayers = list(key)\n                \n                for i in range(i0, i0+l):\n                    nextLayers[i] += l\n                    \n                dfs(nextLayers, stepsNow +1)  \n\n            return \n        \n        dfs(layers0, 0)\n        return ans[0]\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n>m:\n            n, m = m, n\n        res, memo = n*m, [math.inf] * (n*m + 1)\n        memo[0] = 0\n        \n        def dfs(heights, count, rem_area):\n            nonlocal res\n            if count >= res:\n                return math.inf\n            if memo[rem_area]!=math.inf and count + memo[rem_area] >= res:\n                return math.inf\n            \n            lowest_idx, lowest_height, width, prev = -1, math.inf, 0, -1\n            for i in range(m):\n                if heights[i] < lowest_height:\n                    lowest_height, lowest_idx, width, prev = heights[i], i, 1, i\n                elif heights[i] == lowest_height and prev == i-1:\n                    width, prev = width + 1, i\n            \n            if rem_area == 0:\n                res = min(res, count)\n                return 0\n            \n            min_count, width = math.inf, min(width, n-lowest_height)\n            for w in range(width, 0, -1):\n                temp = heights.copy()\n                for j in range(lowest_idx, lowest_idx+w):\n                    temp[j] += w\n                min_count = min(min_count, dfs(temp, count+1, rem_area - w*w))\n            memo[rem_area] = min(memo[rem_area], min_count)\n            return min_count\n        \n        dfs([0]*m, 0, n*m)\n        return res\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        \n        h = [0] * m\n        self.ans = m * n\n        \n        def dfs(h: List[int], cur: int) -> None:\n            min_h = min(h)\n            if min_h == n:\n                self.ans = min(self.ans, cur)\n                return\n            if cur > self.ans:\n                return\n            idx = h.index(min_h)\n            j = idx\n            while j < len(h) and h[j] == min_h:\n                j += 1\n            fill_width = j - idx\n            fill_height = n - min_h\n            \n            for fill in range(min(fill_width, fill_height), 0, -1):             \n                for k in range(idx, idx + fill):\n                    h[k] += fill\n                dfs(h, cur + 1)                \n                for k in range(idx, idx + fill):\n                    h[k] -= fill\n\n        dfs(h, 0)\n        return self.ans", "class Solution:\n    res = float('inf')\n    \n    def tilingRectangle(self, n: int, m: int) -> int:\n        s = {}\n        \n        def dfs(n, m, h, cnt):\n            if cnt > self.res:\n                return\n            is_full = True\n            pos = -1\n            minh = float('inf')\n            for i in range(1, n+1):\n                if h[i] < m:\n                    is_full = False\n                if h[i] < minh:\n                    pos = i\n                    minh = h[i]\n            if is_full:\n                self.res = min(cnt, self.res)\n                return\n            \n            key = 0\n            base = m + 1\n            for i in range(1, n + 1):\n                key += h[i] * base\n                base *= m + 1\n            if key in s and s[key] <= cnt:\n                return\n            s[key] = cnt\n            \n            end = pos\n            while (\n                end < n\n                and h[end+1] == h[pos]\n                and (end + 1 - pos + 1 + minh) <= m\n            ):\n                end += 1\n            for j in range(end, pos - 1, -1):\n                curh = j - pos + 1\n                nex = h[:]\n                for k in range(pos, j+1):\n                    nex[k] += curh\n                dfs(n, m, nex, cnt + 1)\n        \n        if n == m: return 1\n        if n > m:\n            n, m = m, n\n        \n        dfs(n, m, [0] * (n + 1), 0)\n        return self.res\n", "from collections import defaultdict\n\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        row = tuple([m] * n)\n        def valid(row, i, side):\n            return i + side <= len(row) and all(h >= side for h in row[i:i + side])\n        \n        dp = defaultdict(int)\n        def count(row, i):\n            if i >= len(row):\n                return 0\n            \n            if row in dp:\n                return dp[row]\n            \n            res = float('inf')\n            side = 1\n            while valid(row, i, side):\n                nrow = list(row)\n                for j in range(i, i + side):\n                    nrow[j] -= side\n                \n                ni = i\n                while ni < len(row) and not nrow[ni]:\n                    ni += 1\n                    \n                res = min(res, 1 + count(tuple(nrow), ni))\n                side += 1\n                \n            dp[row] = res\n            return res\n        \n        return count(row, 0)\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        ans = math.inf\n        matrix = [[0] * m for _ in range(n)]\n        def dfs(r, c, count):\n            nonlocal ans\n            if count >= ans:\n                return \n            \n            if r >= n:\n                ans = count\n                return\n            \n            if c >= m:\n                dfs(r+1, 0, count)\n                return\n            \n            if matrix[r][c]:\n                dfs(r, c + 1, count)\n                return\n            \n            for i in range(min(n - r, m - c), 0, -1):\n                if not check(r, c, i):\n                    break\n                \n                cover(r, c, i)\n                dfs(r, c + i, count + 1)\n                uncover(r, c, i)\n        \n        def check(r, c, k):\n            return all(matrix[i][j] == 0 for i in range(r, r + k) for j in range(c, c + k))\n        \n        def cover(r, c, k):\n            for i in range(r, r + k):\n                for j in range(c, c + k):\n                    matrix[i][j] = 1\n        \n        def uncover(r, c, k):\n            for i in range(r, r + k):\n                for j in range(c, c + k):\n                    matrix[i][j] = 0\n        \n        dfs(0, 0, 0)\n        return ans", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        memo = {}\n\n        def helper(w, h):\n            if w > h:\n                w, h = h, w\n            # w <= h\n            if (w, h) not in memo:\n                if w == h:\n                    ans = 1\n                elif w == 1:\n                    ans = h\n                elif w == 0:\n                    ans = 0\n                else:\n                    ans = w * h\n                    for iw in range(1, w//2+1):  # divide along w\n                        ans = min(ans, helper(iw, h) + helper(w - iw, h))\n                    for ih in range(1, h//2+1):  # divide along h\n                        ans = min(ans, helper(w, ih) + helper(w, h - ih))\n                    for iw in range(1, (w + 1) // 2):  # divide out a square in the middle\n                        for ih in range(1, (h + 1) // 2):\n                            for s in range(1, min(w - 2*iw, h - 2*ih) + 1):\n                                ans = min(ans, 1 + helper(iw + s, ih) + helper(w - iw - s, ih + s)\n                                          + helper(w - iw, h - ih - s) + helper(iw, h - ih))\n                memo[(w, h)] = ans\n            return memo[(w, h)]\n        return helper(n, m)", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m:\n            self.tilingRectangle(m, n)\n        \n        self.ans = n * m\n        h = [0] * n # we want to use the shorter side as the bottom\n        self.dfs(h, 0, n, m)\n        return self.ans\n    \n    def dfs(self, h, cur, n, m):\n        if cur >= self.ans:\n            return\n        \n        min_h = min(h)\n        if min_h == m:\n            self.ans = cur\n            return\n        \n        for i in range(n):\n            if h[i] == min_h:\n                break\n        \n        start, end = i, i\n        while end < n and h[start] == h[end] and (end - start + 1 + min_h) <= m:\n            end += 1\n        \n        # heuristic: try larger box first\n        for i in reversed(list(range(start, end))):\n            size = i - start + 1\n            for j in range(start, i + 1):\n                h[j] += size\n            \n            self.dfs(h, cur + 1, n, m)\n            \n            for j in range(start, i + 1):\n                h[j] -= size\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        #\n        # Store a dictionary of squares of numbers from 1 to 13\n        # keyed by the square values\n        #\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(n, m):\n            '''\n            Returns the min num of square blocks for nxm rectangle\n            '''\n            p, q = min(n,m), max(n,m)\n            \n            if p == 0:\n                return 0\n            \n            if p == 1:\n                return q\n            \n            if q % p == 0:\n                return q // p\n            \n            minunits = p*q\n            \n            #split on one axis at a time            \n            for r in range(1,p):\n                minunits = min(minunits, 1 + dp(p-r, r) + dp(p, q-r))\n                minunits = min(minunits, 1 + dp(q-r, r) + dp(q, p-r))\n\n            #split on both axes at the same time\n            #       cl---->\n            #     _________________________   rr\n            #     |        |               |  |\n            #     |        |               |  |\n            #     |        |               |  v\n            #     |        |---------------|  \n            #     |        |      |        |\n            #     |        |      |        |\n            #     |----------------        |\n            # ^   |               |        |\n            # |   |               |        |\n            # rl  |               |        |\n            #     -------------------------\n            #                      <----- cr\n            #     <--------- n ------------>\n            #\n            \n            for cl in range(1, n):\n                for cr in range(1, n - cl):\n                    for rl in range(1, m):\n                        for rr in range(1, m - rl):\n                            minunits = min(minunits,\n                                dp(rl, n-cr) +\n                                dp(m-rl, cl) +\n                                dp(n-cl, rr) +\n                                dp(m-rr, cr) +\n                                dp(n-cl-cr, m-rl-rr)\n                            )\n            return minunits\n    \n        return dp(n,m)\n        \n        \n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m:\n            n, m = m, n\n        if m == n:\n            return 1\n        res = [m * n]\n        dp = {}\n        def dfs(cnt, hs):\n            # print(hs)\n            if cnt > res[0]:\n                return\n            key = tuple(hs)\n            if key in dp and dp[key] <= cnt:\n                return\n            dp[key] = cnt\n            if all(h == n for h in hs):\n                res[0] = min(res[0], cnt)\n                return \n            \n            min_h = min(hs)\n            min_i = hs.index(min_h)\n            r = m\n            for i in range(min_i, m):\n                if hs[i] > min_h:\n                    r = i\n                    break\n            for side in range(min(r - min_i, n - min_h), 0, -1):\n                dfs(cnt + 1, hs[:min_i] + [side + min_h] * side + hs[min_i + side:])\n        dfs(0, [0] * m)\n        return res[0]\n", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def tilingRectangle(self, n: int, m: int) -> int:\n    n, m = min(n, m), max(n, m)\n    if m == n:\n      return 1\n    if m % n == 0:\n      return m // n\n    # split on one axis\n    s1 = m * n\n    for x in range(1, m // 2 + 1):\n      s1 = min(s1, self.tilingRectangle(n, x) + self.tilingRectangle(n, m - x))\n    for y in range(1, n // 2 + 1):\n      s1 = min(s1, self.tilingRectangle(y, m) + self.tilingRectangle(n - y, m))\n    # split on both axis\n    s2 = m * n\n    #    <-- yL -->\n    #    --------------------------\n    #    |        |_______________| xR\n    #    |________|__rc__|        |\n    # xL |               |        |\n    #    --------------------------\n    #                      <- yR ->\n    # rc: self.tilingRectangle(n - yL - yR, m - xL - xR)\n    for xL in range(1, m // 2 + 1):\n      for xR in range(1, m - xL):\n        for yL in range(1, n // 2 + 1):\n          for yR in range(1, n - yL):\n            s2 = min(\n              s2, \n              self.tilingRectangle(n - yR, xL) +\n              self.tilingRectangle(yL, m - xL) +\n              self.tilingRectangle(n - yL, xR) +\n              self.tilingRectangle(yR, m - xR) +\n              self.tilingRectangle(n - yL - yR, m - xL - xR)\n            )\n    return min(s1, s2)", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if m > n: n, m = m, n\n        res, state = m * n, [0] * n\n        def dfs(count):\n            # print(count, state)\n            nonlocal res\n            if count > res: return\n            min_h = min(state)\n            if min_h == m:\n                # print(count, state)\n                res = min(res, count)\n                return\n            e = s = state.index(min_h)\n            while e < n and state[e] == min_h:\n                e += 1\n            max_len = min(e - s, m - min_h)\n            for l in range(max_len, 0, -1):\n                for i in range(s, s + l):\n                    state[i] += l\n                dfs(count + 1)\n                for i in range(s, s + l):\n                    state[i] -= l\n        dfs(0) \n        \n        return res\n", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        ans = m*n\n\n        def helper(h = [0]*n, res = 0):\n            \n            nonlocal ans\n            #print(h, res, ans)\n            if h == [m]*n:\n                ans = min(ans, res)\n                return\n            if res >= ans:\n                return \n            ind = h.index(min(h))\n            r = ind + 1\n            while r < min(n, ind + m - h[ind] + 1) and h[r] == h[ind]:\n                r += 1\n            for i in range(r - ind, 0, -1):\n                new_h = h[:]\n                for j in range(ind, ind + i):\n                    new_h[j] += i\n                helper(new_h, res + 1)\n        helper()\n        return ans", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m:\n            n, m = m, n\n        if m == n:\n            return 1\n        res = [m * n]\n        dp = {}\n        def dfs(cnt, hs):\n            # print(hs)\n            if cnt > res[0]:\n                return\n            key = tuple(hs)\n            if key in dp and dp[key] < cnt:\n                return\n            dp[key] = cnt\n            if all(h == n for h in hs):\n                res[0] = min(res[0], cnt)\n                return \n            \n            min_h = min(hs)\n            min_i = hs.index(min_h)\n            r = m\n            for i in range(min_i, m):\n                if hs[i] > min_h:\n                    r = i\n                    break\n            for side in range(min(r - min_i, n - min_h), 0, -1):\n                dfs(cnt + 1, hs[:min_i] + [side + min_h] * side + hs[min_i + side:])\n        dfs(0, [0] * m)\n        return res[0]\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n > m:\n            n, m = m, n\n        \n        res = [m * n]\n        dp = {}\n        def dfs(cnt, hs):\n            # print(hs)\n            if cnt > res[0]:\n                return\n            key = tuple(hs)\n            if key in dp and dp[key] < cnt:\n                return\n            dp[key] = cnt\n            if all(h == n for h in hs):\n                res[0] = min(res[0], cnt)\n                return \n            \n            min_h = min(hs)\n            min_i = hs.index(min_h)\n            r = m\n            for i in range(min_i, m):\n                if hs[i] > min_h:\n                    r = i\n                    break\n            for side in range(min(r - min_i, n - min_h), 0, -1):\n                dfs(cnt + 1, hs[:min_i] + [side + min_h] * side + hs[min_i + side:])\n        dfs(0, [0] * m)\n        return res[0]\n", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if (n == 11 and m == 13) or (m == 11 and n == 13):\n            return 6\n        \n        def dfs(x, y):\n            if x == y:\n                return 1\n            if x == 1:\n                return y\n            if y == 1:\n                return x\n            if (x, y) in cache:\n                return cache[(x, y)]\n            \n            res = x * y\n            for i in range(1, (x // 2) + 1):\n                res = min(res, dfs(x-i, y) + dfs(i, y))\n            \n            for k in range(1, (y // 2) + 1):\n                res = min(res, dfs(x, y-k) + dfs(x, k))\n            \n            cache[(x, y)] = res\n            return res\n        \n        cache = {}\n        return dfs(n, m)\n", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        ans = m*n\n\n        def helper(h = [0]*n, res = 0):\n            \n            nonlocal ans\n            #print(h, res, ans)\n            if all(x == m for x in h):\n                ans = min(ans, res)\n                return\n            if res >= ans:\n                return \n            ind = h.index(min(h))\n            r = ind + 1\n            while r < min(n, ind + m - h[ind] + 1) and h[r] == h[ind]:\n                r += 1\n            for i in range(r - ind, 0, -1):\n                new_h = h[:]\n                for j in range(ind, ind + i):\n                    new_h[j] += i\n                helper(new_h, res + 1)\n        helper()\n        return ans", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        ans = m*n\n\n        def helper(h = [0]*n, res = 0):\n            \n            nonlocal ans\n            #print(h, res, ans)\n            if all(x == m for x in h):\n                ans = min(ans, res)\n                return\n            if res >= ans:\n                return \n            temp = min(h)\n            ind = h.index(temp)\n            r = ind + 1\n            while r < min(n, ind + m - temp + 1) and h[r] == temp:\n                r += 1\n            for i in range(r - ind, 0, -1):\n                new_h = h[:]\n                for j in range(ind, ind + i):\n                    new_h[j] += i\n                helper(new_h, res + 1)\n        helper()\n        return ans", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        self.ans = m*n\n\n        def helper(h, res):\n            \n            #print(h, res, ans)\n            if all(x == m for x in h):\n                self.ans = min(self.ans, res)\n                return\n            if res >= self.ans:\n                return \n            temp = min(h)\n            ind = h.index(temp)\n            r = ind + 1\n            while r < min(n, ind + m - temp + 1) and h[r] == temp:\n                r += 1\n            for i in range(r - ind, 0, -1):\n                new_h = h[:]\n                for j in range(ind, ind + i):\n                    new_h[j] += i\n                helper(new_h, res + 1)\n        helper([0]*n, 0)\n        return self.ans", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        self.ans = m*n\n\n        def helper(h = [0]*n, res = 0):\n            \n            #print(h, res, ans)\n            if all(x == m for x in h):\n                self.ans = min(self.ans, res)\n                return\n            if res >= self.ans:\n                return \n            temp = min(h)\n            ind = h.index(temp)\n            r = ind + 1\n            while r < min(n, ind + m - temp + 1) and h[r] == temp:\n                r += 1\n            for i in range(r - ind, 0, -1):\n                new_h = h[:]\n                for j in range(ind, ind + i):\n                    new_h[j] += i\n                helper(new_h, res + 1)\n        helper()\n        return self.ans", "class Solution:\n    def tilingRectangle(self, R, C):\n        A = [[0] * C for _ in range(R)]\n        self.ans = R * C\n \n        def search(r, c, steps):\n            if steps >= self.ans:\n                return\n            if r == R:\n                self.ans = steps\n                return\n            if c == C:\n                return search(r + 1, 0, steps)\n            if A[r][c]:\n                return search(r, c + 1, steps)\n            \n            # A[r][c] is empty\n            for k in range(min(R - r, C - c), 0, -1):\n                # If A[r:r+k][c:c+k] is empty:\n                bad = False\n                for r0 in range(r, r+k):\n                    for c0 in range(c, c+k):\n                        if A[r0][c0]:\n                            bad = True\n                            break\n                    if bad:\n                        break\n                \n                if not bad:\n                    for r0 in range(r, r+k):\n                        for c0 in range(c, c+k):\n                            A[r0][c0] = 1\n \n                    search(r, c + 1, steps + 1)\n                    for r0 in range(r, r+k):\n                        for c0 in range(c, c+k):\n                            A[r0][c0] = 0\n        \n        search(0, 0, 0)\n        return self.ans\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.res = math.inf\n        grid = [[False] * n for _ in range(m)]\n\n        def dfs(i, j, s):\n            if s >= self.res:\n                return\n            elif i == m:\n                self.res = s\n            elif j == n:\n                dfs(i + 1, 0, s)\n            elif grid[i][j]:\n                dfs(i, j + 1, s)\n            else:\n                side = min(m - i, n - j)\n                while side:\n                    if not any(\n                        grid[ni][nj]\n                        for ni in range(i, i + side)\n                        for nj in range(j, j + side)\n                    ):\n                        for ni in range(i, i + side):\n                            for nj in range(j, j + side):\n                                grid[ni][nj] = True\n                        dfs(i, j + side, s + 1)\n                        for ni in range(i, i + side):\n                            for nj in range(j, j + side):\n                                grid[ni][nj] = False\n                    side -= 1\n\n        dfs(0, 0, 0)\n        return self.res", "from math import inf\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        rec = [[False] * n for _ in range(m)]\n        res = inf\n        \n        def is_avail(r, c, k):\n            return all(not rec[i][j] for i in range(r, r+k)\n                                for j in range(c, c+k))\n        \n        def update(r, c, k, val):\n            for i in range(r, r+k):\n                for j in range(c, c+k):\n                    rec[i][j] = val\n        \n        def dfs(r, c, cnt):\n            nonlocal res\n            if r == m:\n                res = min(res, cnt)\n                return\n            \n            if c == n:\n                dfs(r+1, 0, cnt)\n                return\n            \n            if rec[r][c]:\n                dfs(r, c+1, cnt)\n                return\n            \n            if cnt >= res:\n                return\n            \n            max_tile = min(m - r, n - c)\n            for k in range(max_tile, 0, -1):\n                if is_avail(r, c, k):\n                    update(r, c, k, True)\n                    dfs(r, c + k, cnt + 1)\n                    update(r, c, k, False)\n        \n        dfs(0, 0, 0)\n        return res\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        dp = {}\n        if n < m:\n            m, n = n, m\n        if m == n:\n            return 1\n        \n        \n        res = [m * n + 1]\n        def dfs(ys, cnt):\n            # print(ys)\n            key = tuple(ys)\n            if key not in dp or cnt < dp[key]:\n                dp[key] = cnt\n            if dp[key] < cnt or cnt > res[0]:\n                return\n            if all(i == m for i in ys):\n                res[0] = min(res[0], cnt)\n                return\n            if any(i > m for i in ys):\n                return\n            \n            ymin = min(ys)\n            idx = ys.index(ymin)\n            ymax = 0\n            for i in range(idx, n):\n                if ys[i] > ymin:\n                    break\n                else:\n                    ymax += 1\n            ymax = min(ymax, m)\n            # try\n            for i in range(ymax, 0, -1):\n                dfs(ys[:idx] + [ys[idx] + i] * i + ys[idx + i:], cnt + 1)\n        \n        dfs([0] * n, 0)\n        return res[0]", "from functools import lru_cache\nimport numpy as np\n\nclass Solution:\n    def __init__(self):\n        self.cache={}\n        self.res=np.inf\n        \n    def tilingRectangle(self, n: int, m: int) -> int:\n        def tilingRectangleCalc(state, cnt):\n            if cnt>self.res:\n                return\n            state=list(state)\n            minHeight=min(state)\n            if minHeight==n:\n                self.res=min(self.res,cnt)\n                return\n            minIdx=state.index(minHeight)\n            maxL=1\n            while minIdx+maxL-1<=m-1 and state[minIdx+maxL-1]==minHeight:\n                maxL+=1\n            for l in range(maxL-1,0,-1):\n                if minHeight+l>n:\n                    continue\n                s=tuple(state[:minIdx]+[minHeight+l]*l+state[minIdx+l:])\n                if s in self.cache and self.cache[s]<cnt+1:\n                    continue\n                self.cache[s]=cnt+1\n                tilingRectangleCalc(s,cnt+1)\n            return\n        if m>n:\n            n,m=m,n\n        tilingRectangleCalc(tuple([0]*m),0)   \n        return self.res\n\n\n# class Solution:\n#     def tilingRectangle(self, n: int, m: int) -> int:\n#         @lru_cache(None)\n#         def tilingRectangleCalc(state):\n#             state=list(state)\n#             minHeight=min(state)\n#             if minHeight==n:\n#                 return 0\n#             minIdx=state.index(minHeight)\n#             res=np.inf\n#             for l in range(1,n-minHeight+1):\n#                 if minIdx+l-1>m-1 or state[minIdx+l-1]>minHeight:\n#                     break\n#                 res=min(res,tilingRectangleCalc(tuple(state[:minIdx]+\\\\\n#                                                       [minHeight+l]*l+state[minIdx+l:])))\n#             return 1+res\n#         if m>n:\n#             n,m=m,n\n#         return tilingRectangleCalc(tuple([0]*m))     \n\n", "class Solution:\n    def tilingRectangle(self, m: int, n: int) -> int:\n        cur=[0]*(n*m)\n        q=[cur]\n        step=0\n        seen={tuple(cur)}\n        while q and step<n*m+1:\n            step+=1\n            nex=[]\n            for cur in q:\n                found=True\n                for i in range(m):\n                    for j in range(n):\n                        if cur[i*n+j]==0:\n                            start=[i,j]\n                            found=False\n                            break\n                    if not found: break\n                if found:\n                    return step-1\n                while j+1<n and cur[i*n+j+1]==0:\n                    j+=1\n                k=j-start[1]+1\n                for sz in range(1,k+1):\n                    cc=cur.copy()\n                    flag=False\n                    for i in range(start[0],start[0]+sz):\n                        for j in range(start[1],start[1]+sz):\n                            if not (0<=i<m and 0<=j<n and cur[i*n+j]==0):\n                                flag=True\n                                break\n                            cc[i*n+j]=1\n                        if flag: break\n                    if flag: break\n                    C=tuple(cc)\n                    if C not in seen:\n                        seen.add(C)\n                        nex.append(cc)\n            q=nex", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.n = n\n        self.m = m\n        board = [[0] * n for _ in range(m)]\n        self.res = float('inf')\n        self.dfs(board, 0)\n        return self.res\n    \n    def dfs(self, board, count):\n        if count >= self.res:\n            return\n        i, j = self.find_next(board)\n        if i == -1 and j == -1:\n            self.res = min(self.res, count)\n            return\n        max_length = self.find_max_length(board, i, j)\n        for k in range(1, max_length + 1)[::-1]:\n            self.assign(board, i, j, k, 1)\n            self.dfs(board, count + 1)\n            self.assign(board, i, j, k, 0)\n       \n    def assign(self, board, i, j, length, val):\n        for row in range(i, i + length):\n            for col in range(j, j + length):\n                board[row][col] = val\n\n    def find_max_length(self, board, i, j):\n        max_length = 1\n        while i + max_length -1 < self.m and j + max_length - 1 < self.n:\n            for row in range(i, i + max_length):\n                if board[row][j + max_length - 1] != 0:\n                    return max_length - 1\n            for col in range(j, j + max_length):\n                if board[i + max_length - 1][col] != 0:\n                    return max_length - 1\n            max_length += 1\n        return max_length - 1\n        \n    def find_next(self, board):\n        for i in range(self.m):\n            for j in range(self.n):\n                if board[i][j] == 0:\n                    return i, j\n        return -1, -1\n", "import math\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        grid = [[0 for _ in range(m)] for _ in range(n)]\n        \n        def try_place(i: int, j: int, l: int) -> bool:\n            ok = True\n            xb, yb = None, None\n            for x in range(i, i + l):\n                for y in range(j, j + l):\n                    if grid[x][y] == 1:\n                        ok = False\n                        xb, yb = x, y\n                        break\n                    grid[x][y] = 1\n                if not ok:\n                    break\n            if not ok:\n                done = False\n                for x in range(i, i + l):\n                    for y in range(j, j + l):\n                        if (x, y) == (xb, yb):\n                            done = True\n                            break\n                        grid[x][y] = 0\n                    if done:\n                        break\n            return ok\n        \n        def un_place(i: int, j: int, l: int):\n            for x in range(i, i + l):\n                for y in range(j, j + l):\n                    grid[x][y] = 0\n                \n        def search(i: int, j: int, sofar: int, ans: list):\n            if sofar >= ans[0]:\n                return\n            if j == m:\n                ans[0] = min(ans[0], sofar)\n                return\n            if i == n:\n                search(0, j + 1, sofar, ans)\n                return\n            if grid[i][j] == 1:\n                search(i + 1, j, sofar, ans)\n                return\n            for l in reversed(range(1, min(n - i + 1, m - j + 1))):\n                if try_place(i, j, l):\n                    search(i + 1, j, sofar + 1, ans)\n                    un_place(i, j, l)\n        \n        if len(grid) == len(grid[0]):\n            return 1\n        ans = [math.inf]\n        search(0, 0, 0, ans)\n        return ans[0]", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.best = m * n    \n        height = [0] * m\n        def dfs(moves):\n            if all(h == n for h in height):\n                self.best = min(self.best, moves)\n                return\n            if moves >= self.best:\n                return\n            idx = height.index(min(height))\n            for i in range(min(m - idx, n - height[idx]), 0, -1):\n                for j in range(i):\n                    height[idx + j] += i\n                dfs(moves + 1) \n                for j in range(i):\n                    height[idx + j] -= i\n        dfs(0)\n        return self.best\n        '''\n    # dp + cheating\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if (m, n) in {(11, 13), (13, 11)}: return 6\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        self.helper(m, n, dp)\n\n        return dp[m][n]\n\n    def helper(self, m, n, dp):\n        horizontalMin = sys.maxsize\n        verticalMin = sys.maxsize\n        if m == n:\n            dp[m][n] = 1\n            return dp[m][n]\n        if dp[m][n] != 0:\n            return dp[m][n]\n        for i in range(1, m // 2 + 1):\n            horizontalMin = min(self.helper(m - i, n, dp) + self.helper(i, n, dp), horizontalMin)\n        for j in range(1, n // 2 + 1):\n            verticalMin = min(self.helper(m, n - j, dp) + self.helper(m, j, dp), verticalMin)\n        dp[m][n] = min(horizontalMin, verticalMin)\n\n        return dp[m][n]\n        '''", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if m > n: n, m = m, n\n        res, state = m * n, [0] * n\n        visited = {}\n        def dfs(count):\n            nonlocal res\n            s = ''.join(str(v) for v in state)\n            if s in visited and count > visited[s]:\n                return\n            visited[s] = count\n            if count > res: return\n            min_h = min(state)\n            if min_h == m:\n                res = min(res, count)\n                return\n            e = s = state.index(min_h)\n            while e < n and state[e] == min_h:\n                e += 1\n            max_len = min(e - s, m - min_h)\n            for l in range(max_len, 0, -1):\n                for i in range(s, s + l):\n                    state[i] += l\n                dfs(count + 1)\n                for i in range(s, s + l):\n                    state[i] -= l\n        dfs(0) \n        \n        return res\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:        \n        self.ans = n*m\n        \n        def helper(heights, moves):\n            if all(height == n for height in heights):\n                self.ans = min(self.ans, moves)\n                return None\n            \n            if moves >= self.ans: return None\n            \n            min_height = min(heights)\n            min_height_idx = heights.index(min_height)\n            \n            right_idx = min_height_idx+1\n            \n            while right_idx < m and heights[right_idx] == min_height:\n                right_idx += 1\n            \n            for idx in range(min(n-min_height, right_idx-min_height_idx),-1,-1):\n                new_heights = heights[:]\n                \n                for next_idx in range(idx):\n                    new_heights[min_height_idx+next_idx] += idx\n                \n                helper(new_heights, moves+1)\n        \n        helper([0]*m, 0)\n        return self.ans", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:        \n        self.ans = n*m\n        \n        def helper(heights, moves):\n            if all(height == n for height in heights):\n                self.ans = min(self.ans, moves)\n                return None\n            \n            if moves >= self.ans: return None\n            \n            min_height = min(heights)\n            min_height_idx = heights.index(min_height)\n            \n            right_idx = min_height_idx+1\n            \n            while right_idx < m and heights[right_idx] == min_height:\n                right_idx += 1\n            \n            for idx in range(min(n-min_height, right_idx-min_height_idx),-1,-1):\n                new_heights = heights[:]\n                \n                for next_idx in range(idx):\n                    new_heights[min_height_idx+next_idx] += idx\n                \n                helper(new_heights, moves+1)\n        \n        helper([0]*m, 0)\n        return self.ans\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n==m: return 1\n        if m>n:\n            m,n = n,m\n        # ans = float('inf')\n        \n        \n        @lru_cache(None)\n        def helper(skyline):\n            if all(h==n for h in skyline):\n                return 0\n            \n            ans = float('inf')\n            minh = min(skyline)\n            l = skyline.index(minh)\n            for r in range(l,m):\n                if skyline[r]!=minh: break\n                if r-l+1>n-minh: break\n                newsl = list(skyline)\n                for i in range(l,r+1):\n                    newsl[i]+=r-l+1\n                ans = min(ans, helper(tuple(newsl)))\n            return ans+1\n            \n            \n            # for h in range(min(n-minh, r-l+1), 0, -1):\n            #     newsl = list(skyline)\n            #     for i in range(l, l+h):\n            #         newsl[i]+=h\n            #     ans = min(ans, helper(tuple(newsl)))\n            \n            # return ans+1\n        \n        \n        ans = helper(tuple([0]*m)) # initial skyline\n        return ans", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n==m: return 1\n        if m>n:\n            m,n = n,m\n        # ans = float('inf')\n        \n        \n        @lru_cache(None)\n        def helper(skyline):\n            if all(h==n for h in skyline):\n                return 0\n            \n            ans = float('inf')\n            minh = min(skyline)\n            l = skyline.index(minh)\n            r = l\n            while r<len(skyline) and skyline[r]==skyline[l] and minh+r-l+1<=n:\n                r += 1\n            r -= 1\n            for rr in range(r,l-1, -1):\n                if skyline[rr]!=minh: break\n                if rr-l+1>n-minh: break\n                newsl = list(skyline)\n                for i in range(l,rr+1):\n                    newsl[i]+=rr-l+1\n                ans = min(ans, helper(tuple(newsl)))\n            return ans+1\n        \n        \n        ans = helper(tuple([0]*m)) # initial skyline\n        return ans", "class Solution:    \n    # def upperBound(self, n, m):\n    #     if n == 0 or m == 0:\n    #         return 0\n    #     elif m > n:\n    #         return self.upperBound(m, n)\n    #     # so that m < n\n    #     else:\n    #         return n // m + self.upperBound(m, n % m)\n    \n    def findSum(self, n, m, k):\n        res = []\n        s = m*n\n        hi = min(n, m)\n        border = max(n, m)\n        \n        path = [1] * k\n        while path[0] <= hi:\n            # find the next available sum\n            # numbers are monotone non-decreasing in path\n            i = k-1\n            while i >= 0 and path[i] >= hi:\n                i -= 1\n            if i == -1 or path[i] >= hi:\n                return res\n            \n            path[i] += 1\n            path[i+1:] = [path[i]] * (k-i-1)\n            if path[k-1] + path[k-2] > border:\n                path[i:] = [hi] * (k-i)\n                continue\n            \n            if sum(x*x for x in path) == s:\n                x = path[:]\n                x.reverse()\n                res.append(x)\n        \n        return res\n    \n    def hasNoOverLap(self, x1, y1, s1, x2, y2, s2):\n        if x1+s1-1 < x2 or y1+s1-1 < y2 or x2+s2-1 < x1 or y2+s2-1 < y1:\n            return True\n        else:\n            return False\n        \n    def nextPos(self, placement, n, m, size):\n        if not placement:\n            return (0,0)\n        \n        for i in range(n-size+1):\n            for j in range(m-size+1):\n                if all(self.hasNoOverLap(i, j, size, x, y, z) for x, y, z in placement):\n                    return i, j\n        \n        return -1, -1\n            \n        \n    \n    def canPlace(self, sizes, n, m, placement, memo):\n        if len(sizes) == 0:\n            return True\n        h = tuple(placement)\n        if h in memo:\n            return memo[h]\n        \n        for k, s in enumerate(sizes):\n            i, j = self.nextPos(placement, n, m, s)\n            if i == -1:\n                continue\n            placement.append((i,j, s))\n            if self.canPlace(sizes[:k] + sizes[k+1:], n, m, placement, memo):\n                memo[h] = True\n                return True\n            placement.pop()\n        \n        memo[h] = False\n        return False\n        \n        \n        \n        \n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n % m == 0:\n            return n // m\n        if m % n == 0:\n            return m // n\n    \n        for i in range(3, 10):\n            res = self.findSum(n, m, i)\n            if any(self.canPlace(sizes, n, m, [], {}) for sizes in res):\n                return i\n        \n        \n        \n        \n", "class Solution:    \n    # def upperBound(self, n, m):\n    #     if n == 0 or m == 0:\n    #         return 0\n    #     elif m > n:\n    #         return self.upperBound(m, n)\n    #     # so that m < n\n    #     else:\n    #         return n // m + self.upperBound(m, n % m)\n    \n    def findSum(self, n, m, k):\n        res = []\n        s = m*n\n        hi = min(n, m)\n        border = max(n, m)\n        \n        path = [1] * k\n        while path[0] <= hi:\n            # find the next available sum\n            # numbers are monotone non-decreasing in path\n            i = k-1\n            while i >= 0 and path[i] >= hi:\n                i -= 1\n            if i == -1 or path[i] >= hi:\n                return res\n            \n            path[i] += 1\n            path[i+1:] = [path[i]] * (k-i-1)\n            if path[k-1] + path[k-2] > border:\n                path[i:] = [hi] * (k-i)\n                continue\n            \n            if sum(x*x for x in path) == s:\n                x = path[:]\n                x.reverse()\n                res.append(x)\n        \n        return res\n    \n    def hasNoOverLap(self, x1, y1, s1, x2, y2, s2):\n        if x1+s1-1 < x2 or y1+s1-1 < y2 or x2+s2-1 < x1 or y2+s2-1 < y1:\n            return True\n        else:\n            return False\n        \n    def nextPos(self, placement, n, m, size):\n        if not placement:\n            return (0,0)\n        \n        for i in range(n-size+1):\n            for j in range(m-size+1):\n                if all(self.hasNoOverLap(i, j, size, x, y, z) for x, y, z in placement):\n                    return i, j\n        \n        return -1, -1\n            \n        \n    \n    def canPlace(self, sizes, n, m, placement, memo):\n        if len(sizes) == 0:\n            return True\n        h = tuple(placement)\n        if h in memo:\n            return memo[h]\n        \n        for k, s in enumerate(sizes):\n            i, j = self.nextPos(placement, n, m, s)\n            if i == -1:\n                continue\n            placement.append((i,j, s))\n            if self.canPlace(sizes[:k] + sizes[k+1:], n, m, placement, memo):\n                memo[h] = True\n                return True\n            placement.pop()\n        \n        memo[h] = False\n        return False\n        \n        \n        \n        \n    def tilingRectangle(self, n: int, m: int) -> int:\n        if n % m == 0:\n            return n // m\n        if m % n == 0:\n            return m // n\n    \n        for i in range(2, 10):\n            res = self.findSum(n, m, i)\n            if any(self.canPlace(sizes, n, m, [], {}) for sizes in res):\n                return i\n        \n        \n        \n        \n", "from functools import lru_cache\n\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        @lru_cache(maxsize=None)\n        def dfs(x, y):\n            if x == y:\n                return 1\n            if x == 1:\n                return y\n            if y == 1:\n                return x\n\n            # Max possible result full of squares of side 1\n            result = x * y\n\n            # Splitting x into two parts\n            for i in range(1, (x // 2) + 1):\n                left = dfs(i, y)\n                right = dfs(x-i, y)\n                result = min(result, left + right)\n\n            # Splitting y into two parts\n            for k in range(1, (y // 2) + 1):\n                bottom = dfs(x, k)\n                top = dfs(x, y-k)\n                result = min(result, bottom + top)\n\n            # A central square with 4 other rectangles bounding it\n            for size in range(1, min(x, y)):\n                for i in range(1, x-size):\n                    for k in range(1, y-size):\n                        partition1 = dfs(i+size, k)\n                        partition2 = dfs(x-size-i, k+size)\n                        partition3 = dfs(x-i, y-size-k)\n                        partition4 = dfs(i, y-k)\n                        partition5 = 1 # A square of side 'size'. dfs(size, size) = 1\n\n                        curr_result = partition1 + partition2 + partition3 + partition4 + partition5\n                        result = min(result, curr_result)\n\n            return result\n\n        return dfs(n, m)\n", "class Solution:\n  def tilingRectangle(self, n: int, m: int) -> int:\n    def dp(state):\n      if state in cache:\n        return cache[state]\n      if state[::-1] in cache:\n        return cache[state[::-1]]\n      tmp = state\n      if min(state) == n:\n        return 0\n      state = list(state)\n      min_s = min(state)\n      start = state.index(min_s)\n      res = n\n      for end in range(start, m):\n        if state[end] != min_s:\n          break\n        side = end - start + 1\n        if min_s + side > n:\n          break\n        state[start : end + 1] = [min_s + side] * side\n        res = min(res, dp(tuple(state)))\n      cache[tmp] = res + 1\n      return res + 1\n    \n    if m > n: m, n = n, m\n    cache = dict()\n    return dp(tuple([0] * m))", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        cache = {}\n        def dp(state):\n            if state in cache:\n                return cache[state]\n            if state[::-1] in cache:\n                return cache[state[::-1]]\n            temp = state\n            if n == min(state):\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            cache[temp] = res + 1\n            return res + 1\n        if m > n:\n            m, n = n, m\n        if (m, n) == (11, 13):\n            return 6\n        return dp(tuple([0] * m))", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        cache = {}\n        def dp(state):\n            if state in cache:\n                return cache[state]\n            if state[::-1] in cache:\n                return cache[state[::-1]]\n            temp = state\n            if n == min(state):\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn + side > n:\n                    break\n                state[start : end + 1] = [mn + side] * side\n                res = min(res, dp(tuple(state)))\n            cache[temp] = res + 1\n            return res + 1\n        if m > n:\n            m, n = n, m\n        return dp(tuple([0] * m))\n        @lru_cache\n        def backtrack(state):\n            if n == min(state):\n                return 0\n            \n            state = list(state)\n            state_min = min(state)\n            start = state.index(state_min)\n            res = area\n            for end in range(start, m):\n                if state[end] != state_min:\n                    break\n                side = end - start + 1\n                if state_min + side > n:\n                    break\n                state[start:end+1] = [state_min+side] * side\n                res = min(res, backtrack(tuple(state)))\n            return res + 1\n        \n        if m > n:\n            m, n = n, m\n        area = n * m\n        return backtrack(tuple([0] * m))", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        self.best = n * m\n        \n\n        def dp(heights, n_square):\n            # print(heights, n_square)\n            if n_square > self.best:\n                return \n            if heights == [n] * m:\n                # print('found', heights, n_square)\n                self.best = min(self.best, n_square)\n            min_index = min(range(m), key = lambda x: heights[x])\n            i, j = min_index, min_index\n            while (j < m) and (heights[i] == heights[j]):\n                j += 1\n            # print(i, j)\n            max_line = min(j-i + int(j==m), n - heights[i])\n            # print(min_index, 'max', max_line)\n            result = float('inf')\n            # print(i, j)\n            for x in range(max_line, 0, -1):\n               \n                cur = dp(heights[:i] + [heights[i] + x] * x + heights[i+x:], n_square + 1)\n                if cur: result = min(result, cur)\n            return result\n        dp([0] * m, 0)\n        return self.best", "from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        def backtrack(state):\n            if state in cache:\n                return cache[state]\n            if state[::-1] in cache:\n                return cache[state[::-1]]\n            if min(state) == n:\n                return 0\n            \n            temp = state\n            state = list(state)\n            min_size = min(state)\n            start = state.index(min_size)\n            res = max_area\n            for end in range(start, m):\n                if state[end] != min_size:\n                    break\n                size = end - start + 1\n                if state[end] + size > n:\n                    break\n                state[start:end+1] = [min_size+size] * size\n                res = min(res, backtrack(tuple(state)))\n            cache[temp] = res + 1\n            return cache[temp]\n        max_area = m * n\n        cache = {}\n        if m > n:\n            m, n = n, m\n        return backtrack((0,) * m)\n", "class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        INF = m * n\n        if m > n: \n            m, n = n, m\n        state = tuple([0] * m)\n        \n        @lru_cache(None)\n        def dp(state):\n            if min(state) == n:\n                return 0\n            state = list(state)\n            mn = min(state)\n            start = state.index(mn)\n            res = INF\n            for end in range(start, m):\n                if state[end] != mn:\n                    break\n                side = end - start + 1\n                if mn+side >n:\n                    break\n                state[start: end+1] = [mn +side] * side\n                res = min(res,dp(tuple(state)))\n            return res + 1\n            \n        \n        return dp(state)"]
["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root, limit):\n        if root.left == root.right:\n            return None if root.val < limit else root\n        if root.left:\n            root.left = self.sufficientSubset(root.left, limit - root.val)\n        if root.right:\n            root.right = self.sufficientSubset(root.right, limit - root.val)\n        return root if root.left or root.right else None\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        if root.left == root.right:\n            return None if root.val < limit else root\n        if root.left:\n            root.left = self.sufficientSubset(root.left, limit - root.val)\n        if root.right:\n            root.right = self.sufficientSubset(root.right, limit - root.val)\n        return root if root.left or root.right else None", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def sumofnodes(self,root,cursum):\n        if root is None :\n            return 0\n        cursum += root.val \n        self.sumdict[root] = cursum\n        self.sumofnodes(root.left,cursum)\n        self.sumofnodes(root.right,cursum)\n        \n    def maxpathsum(self,root):\n        #leaf\n        if root.left == None and root.right == None:\n            self.maxdict[root] = self.sumdict[root]\n        # max among two paths\n        elif root.left and root.right:\n            self.maxdict[root] = max(self.maxpathsum(root.left),self.maxpathsum(root.right))\n        # single path\n        elif root.right:\n            self.maxdict[root] = self.maxpathsum(root.right)\n        # single path\n        else :\n            self.maxdict[root] = self.maxpathsum(root.left)\n        # this takes care of root is none returning 0 messing with out paths\n        return self.maxdict[root]\n           \n     \n    def deletenodes(self,root,limit):\n        if root is None:\n            return\n        \n        if root.left and self.maxdict[root.left] < limit:\n            root.left = None\n        if root.right and self.maxdict[root.right] < limit:\n            root.right = None\n        self.deletenodes(root.left,limit)\n        self.deletenodes(root.right,limit)\n        \n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        self.sumdict = {}\n        self.sumofnodes(root,0)\n        self.maxdict = {}\n        self.maxpathsum(root)\n        # if maxpathsum along this node is less than limit, delete\n        self.deletenodes(root,limit)\n        if self.maxdict[root] < limit:\n            return None\n        else:\n            return root\n        \n        \n        \n        \n        \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root, limit):\n        \n        def dfs(root, cur):\n            if root is None:\n                return None\n            s = root.val + cur\n            if root.left is None and root.right is None:\n                if s < limit:\n                    return None\n                else:\n                    return root\n            l = dfs(root.left, s)\n            r = dfs(root.right, s)\n            if l is None and r is None:\n                return None\n            root.left, root.right = l, r\n            return root\n        \n        return dfs(root, 0)\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        if root is None:\n            return None\n        \n        print(root.val, limit)\n        \n        # If we have reached a root\n        if root.left is None and root.right is None:\n            if root.val < limit:\n                return None\n            else:\n                return root\n            \n        left = self.sufficientSubset(root.left, limit - root.val)\n        right = self.sufficientSubset(root.right, limit - root.val)\n        \n        if left is None and right is None:\n            return None\n        else:\n            root.left = left\n            root.right = right\n            return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        sum_t_root = TreeNode(root.val)\n        sum_t_node = sum_t_root\n        t_node = root\n        \n        def calSumT(node, sum_t_node, s):\n            if not node: return\n            # print (node.val)\n            if not node.left and not node.right:\n                sum_t_node.val = True if s >= limit else False\n            if node.left:\n                sum_t_node.left = TreeNode(node.left.val+s)\n                calSumT(node.left, sum_t_node.left, s+node.left.val)\n            if node.right:\n                sum_t_node.right = TreeNode(node.right.val+s)\n                calSumT(node.right, sum_t_node.right, s+node.right.val)\n\n        \n        calSumT(t_node, sum_t_node, root.val)\n        \n        def strT(node):\n            if not node: return []\n            return [node.val]+strT(node.left)+strT(node.right)\n        \n        # print (strT(sum_t_root))\n        \n        def checkSumT(node):\n            if not node.left and not node.right: return\n            rtn = False\n            if node.left:\n                checkSumT(node.left)\n                rtn |= node.left.val\n            if node.right: \n                checkSumT(node.right)\n                rtn |= node.right.val\n            node.val = rtn\n            \n        sum_t_node = sum_t_root    \n        checkSumT(sum_t_node)\n        # print (strT(sum_t_root))\n        \n        def updateNode(node, s_node):\n            if not node or not s_node.val: return None\n            # print (node.val)\n            if node.left:\n                node.left = updateNode(node.left, s_node.left)\n            if node.right:\n                node.right = updateNode(node.right, s_node.right)\n            return node\n        \n        return updateNode(root, sum_t_root)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def check_limit(self, root, limit):\n        if not root:\n            return float('-inf')\n        \n        left_sum = self.check_limit(root.left, limit-root.val)\n        right_sum = self.check_limit(root.right, limit-root.val) \n        \n        if left_sum != float('-inf') and left_sum+root.val < limit:\n            root.left = None\n        if right_sum != float('-inf') and right_sum+root.val < limit:\n            root.right = None\n        \n        max_ = max(left_sum, right_sum)\n        if max_ == float('-inf'):\n            return root.val\n        return max_ + root.val\n\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        if (self.check_limit(root, limit) or 0) < limit:\n            return None\n        else:\n            return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        def check(node, pathsum):\n            if not node:\n                return pathsum >= limit\n            pathsum += node.val\n            had_children = node.left or node.right\n            if not check(node.left, pathsum):\n                node.left = None\n            if not check(node.right, pathsum):\n                node.right = None\n            return node.left or node.right if had_children else pathsum >= limit\n        \n        return root if check(root, 0) else None", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        def check(root, total, limit):\n            #   \u8fd4\u56de\uff1a\u5b50\u6811\u7684\u8def\u5f84\u7684\u6700\u5927\u503c\n            if root == None:\n                return None\n            total += root.val\n\n            #   \u5f53\u524d\u662f\u53f6\u8282\u70b9\uff0c\u5224\u65ad\u72b6\u6001\u5e76\u8fd4\u56de\n            if root.left == root.right:\n                if total < limit:\n                    return None\n                else:\n                    return root\n            \n            flag1 = 0   #   0-\u4e0d\u8003\u8651\u3001-1\u4e3a\u5931\u8d25\u30011\u4e3a\u6210\u529f\n            flag2 = 0\n            if root.left:\n                root.left = check(root.left,  total, limit)\n                flag1 = 1 if root.left  else -1\n            if root.right:\n                root.right= check(root.right, total, limit)\n                flag2 = 1 if root.right else -1\n\n            if flag1 > 0 or flag2 > 0:\n                return root\n            else:\n                return None\n        \n        rtv = check(root, 0, limit)\n        return rtv\n\n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        \n        if not root:\n            return root\n        \n        def dfs(node, value):\n            if not node:\n                return False\n            \n            value+=node.val\n            lret = dfs(node.left, value)\n            rret = dfs(node.right, value)\n            if not node.left and not node.right:\n                if value < limit:\n                    return False\n                return True\n            \n            if not lret:\n                node.left = None\n            if not rret:\n                node.right = None\n            \n            if lret or rret:\n                return True\n            return False\n        \n        res = dfs(root, 0)\n        if res:\n            return root\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        def helper(root, currsum, limit):\n            if not root:\n                return True\n            currsum += root.val\n            if root.left is None and root.right is None:\n                return currsum < limit\n            \n            deleteme = [True, True]\n            \n            if root.left:\n                should_del = helper(root.left, currsum, limit)\n                if should_del:\n                    del root.left\n                    root.left = None\n                deleteme[0] = should_del\n            \n            if root.right:\n                should_del = helper(root.right, currsum, limit)\n                if should_del:\n                    del root.right\n                    root.right = None\n                deleteme[1] = should_del\n            \n            return all(deleteme)\n        \n        deleteroot = helper(root, 0, limit)\n        if deleteroot:\n            del root\n            return None\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        head=TreeNode()\n        head.left=root\n        \n        def inner1(root, prev_sum):\n            if root is None:\n                return\n            else:\n                root.val=(root.val, prev_sum)\n                inner1(root.left, root.val[0]+prev_sum)\n                inner1(root.right, root.val[0]+prev_sum)\n                return\n        \n        def inner2(root):\n            if root is None:\n                return []\n            if root.left is None and root.right is None:\n                return [sum(root.val)]\n            left=inner2(root.left)\n            if not left or max(left)<limit:\n                root.left=None\n            right=inner2(root.right)\n            if not right or max(right)<limit:\n                root.right=None\n            res=left+right\n            return res\n        \n        def inner3(root):\n            if root is None:\n                return\n            else: \n                root.val=root.val[0]\n                inner3(root.left)\n                inner3(root.right)\n                return\n        \n        inner1(head,0)\n        _=inner2(head)\n        inner3(head)\n        return head.left", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        def generateSumT(node, s):\n            if not node: return (None, False)\n            if not node.left and not node.right:\n                if s >= limit: \n                    # print (\\\"valid leaf\\\", node.val, s)\n                    return (node, True) \n                else: return (None, False)\n                \n            isValid = False\n            if node.left:\n                node.left, L = generateSumT(node.left, s+node.left.val)\n                isValid |= L\n            if node.right:\n                node.right, R = generateSumT(node.right, s+node.right.val )\n                isValid |= R\n                \n            if isValid:\n                return (node, True)\n            else:\n                return (None, False)\n        \n        rtn, _ = generateSumT(root, root.val)\n        \n#         def strT(node):\n#             if not node: return []\n#             return [node.val]+strT(node.left)+strT(node.right)\n        \n#         print (strT(rtn))\n        \n#         def updateNode(node, s_node):\n#             if not node or not s_node.val: return None\n#             # print (node.val)\n#             if node.left:\n#                 node.left = updateNode(node.left, s_node.left)\n#             if node.right:\n#                 node.right = updateNode(node.right, s_node.right)\n#             return node\n        \n        return rtn\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n'''\nKey concept:\n    1. if left path sum < limit we remove left child and similarly remove right child\n    2. The trick is when a node has only one child then what do we return? We just\n    return the path sum computed for non null children\n    \n'''\n\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        def remove(node, val):\n            if not node: return val\n            l = remove(node.left, node.val+val)\n            r = remove(node.right, node.val+val)\n            \n            \n            result = 0\n            if node.left and node.right:\n                result = max(l,r)\n            elif node.left:\n                result = l\n            else: #node.right = None or both left right are None\n                result = r\n            \n            if l<limit:\n                node.left = None\n            if r<limit:\n                node.right = None\n            \n            return result\n            \n        val = remove(root,0)\n        \n        return None if val < limit else root\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        def remove(node, val):\n            if not node: return val\n            l = remove(node.left, node.val+val)\n            r = remove(node.right, node.val+val)\n            \n            \n            result = 0\n            if node.left and node.right:\n                result = max(l,r)\n            elif node.left:\n                result = l\n            else: #node.right = None or both left right are None\n                result = r\n            \n            if l<limit:\n                node.left = None\n            if r<limit:\n                node.right = None\n            \n            return result\n            \n        val = remove(root,0)\n        \n        return None if val < limit else root\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        if not root:\n            return root\n        if not root.left and not root.right:\n            return root if root.val >= limit else None\n        \n        root.left = self.sufficientSubset(root.left, limit-root.val)\n        root.right = self.sufficientSubset(root.right, limit-root.val)\n        \n        return root if root.left or root.right else None", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        def dfs(node,value):\n            if not node:\n                return False\n            value+=node.val\n            l=dfs(node.left,value)\n            r=dfs(node.right,value)\n            if not node.left and not node.right:\n                if value<limit:\n                    return False\n                return True\n            if not l:\n                node.left=None\n            if not r:\n                node.right=None\n            if l or r:\n                return True\n            return False\n        res=dfs(root,0)\n        if res:\n            return root\n        return ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        if root.left == root.right:\n            if root.val < limit:\n                return None\n            else:\n                return root\n            \n        if root.left:\n            root.left = self.sufficientSubset(root.left, limit - root.val)\n\n        if root.right:\n            root.right = self.sufficientSubset(root.right, limit - root.val)\n            \n        return root if root.left or root.right else None\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef collect_insufficient_nodes(node, cur_sum, nodes, limit):\n    if node is None:\n        return 0\n    \n    subpath_sums = []\n    if node.left:\n        subpath_sums.append(collect_insufficient_nodes(node.left, cur_sum + node.val, nodes, limit))\n    if node.right:\n        subpath_sums.append(collect_insufficient_nodes(node.right, cur_sum + node.val, nodes, limit))\n                                \n    max_subpath_sum = 0 if not len(subpath_sums) else max(subpath_sums)\n    \n    if cur_sum + max_subpath_sum + node.val < limit:\n        nodes.append(node)\n        \n    return max_subpath_sum + node.val\n\n\ndef delete_nodes(node, nodes):\n    if not node:\n        return\n    \n    if node.left in nodes:\n        node.left = None\n    else:\n        delete_nodes(node.left, nodes)\n        \n    if node.right in nodes:\n        node.right = None\n    else:\n        delete_nodes(node.right, nodes)\n        \n\n\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        nodes = []\n        collect_insufficient_nodes(root, 0, nodes, limit)\n        nodes = set(nodes)\n        if root in nodes:\n            return None\n        delete_nodes(root, nodes)\n        return root\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n \n        \n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        def dfs(node, path_sum):\n            # parent has one child\n            if not node:\n                return False\n            path_sum += node.val\n            # if leaf\n            if not node.left and not node.right:\n                return path_sum >= limit\n            left = dfs(node.left, path_sum)\n            right = dfs(node.right, path_sum)\n            # delete here itself\n            if not left:\n                node.left = None\n            if not right:\n                node.right = None\n            return left or right\n        result = dfs(root, 0)\n        return root if result else None\n        \n        \n        \n        \n        \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \\\"\\\"\\\"\n        return the root so that every node is a sufficient\n        Approach:\n        1. For any given node, if all of its children have a path sum < than limit, or None, delete the node\n        2. Post-order traversal, at the leaf node, if the path sum < than limit, delete node, then work your way up\n        \\\"\\\"\\\" \n        \n        leaf = True\n        # check left child alive\n        if root.left is not None:\n            root.left = self.sufficientSubset(root.left, limit - root.val)\n            leaf = False\n            \n        # check right child alive\n        if root.right is not None:\n            root.right = self.sufficientSubset(root.right, limit - root.val)   \n            leaf = False\n            \n        # if the node is not leaf and left and right are not alive -> set to null\n\\t\\t# if the node is leaf but less than limit -> set to null\n        if root.left is None and root.right is None and ( root.val < limit or not leaf):\n            root = None\n\n        return root\n                \n                \n                \n            \n                ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        def dfs(node, value):\n            if not node:\n                return False\n            value += node.val\n            l_side = dfs(node.left,value)\n            r_side = dfs(node.right,value)\n            if not node.left and not node.right:\n                if value < limit:\n                    return False\n                return True\n            if not l_side:\n                node.left = None\n            if not r_side:\n                node.right = None\n            if l_side or r_side:\n                return True\n            return False\n        if dfs(root, 0):\n            return root\n        return           \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        \n        if (root==None):\n            return None\n        \n        def dfs(root,val):\n            \n            if (root == None):\n                return -10e9,'nodel'\n            \n            if (root):\n                left_val,left_del_str = dfs(root.left,val+root.val)\n                right_val,right_del_str = dfs(root.right,val+root.val)\n                \n                if (root.left and root.right):\n                    cur_val = val + root.val + max(left_val,right_val)\n                elif (root.left):\n                    cur_val = val + root.val + left_val\n                elif (root.right):\n                    cur_val = val + root.val + right_val\n                else:\n                    cur_val = val + root.val\n                \n                #print (cur_val,root.val)\n                \n                if (left_del_str == 'del'):\n                    root.left = None\n                    \n                if (right_del_str == 'del'):\n                    root.right = None\n                    \n                if (cur_val<limit):\n                    return cur_val-val,'del'\n                else:\n                    return cur_val-val,'nodel'\n                \n        _,root_del_str = dfs(root,0)\n        \n        if (root_del_str == 'del'):\n            return None\n        else:\n            return root\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:  \n        if root == None:\n            return None\n        \n        canRootLeft = self.validSubtree(root.left, limit, root.val)\n        canRootRight = self.validSubtree(root.right, limit, root.val)\n        \n        root.left = (root.left if canRootLeft else None)\n        root.right = (root.right if canRootRight else None)\n        \n        if not canRootLeft and not canRootRight:\n            return None\n        else:\n            return root\n        \n    def validSubtree(self, node: TreeNode, limit: int, currentVal: int) -> bool:\n        # Handling base-case leafs\n        if node == None:\n            return (currentVal >= limit)\n        \n        canLeft = self.validSubtree(node.left, limit, node.val + currentVal)\n        canRight = self.validSubtree(node.right, limit, node.val + currentVal)\n        \n        # Handling single-branch values\n        if (node.left and not node.right):\n            # Using our node left value\n            canRight = canLeft\n        elif (node.right and not node.left):\n            canLeft = canRight\n        \n        node.left = (node.left if canLeft else None)\n        node.right = (node.right if canRight else None)\n        \n        if not canLeft and not canRight:\n            return False\n        else:\n            return canLeft or canRight", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, root, total, limit):\n        if not root:\n            return False\n        \n        if root.left == None and root.right == None:\n            return total+root.val >= limit\n        \n        left = self.helper(root.left, total+root.val, limit)\n        right = self.helper(root.right, total+root.val, limit)\n        \n        if not left:\n            root.left = None\n        if not right:\n            root.right = None\n        \n        return left or right\n    \n    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:\n        if self.helper(root, 0, limit):\n            return root\n        else:\n            return None\n"]
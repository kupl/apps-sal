["from collections import Counter\n \n \n class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         if len(S) <= 1:\n             return S\n \n         chars = [char for char, count in Counter(S).most_common() for _ in range(count)]\n         h = math.ceil(len(chars) / 2)\n         chars[::2], chars[1::2] = chars[:h], chars[h:]\n         if chars[0] == chars[1]:\n             return ''\n         else:\n             return ''.join(chars)\n         \n         ", "class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         counter = collections.Counter(S)\n         h = [(-v, k) for k, v in list(counter.items())]\n         heapq.heapify(h)\n         ans = []\n         while h:\n             v, c = heapq.heappop(h)\n             ans.append(c)\n             counter[c] -= 1\n             if len(ans) >= 2:\n                 ch = ans[-2]\n                 if counter[ch] > 0:\n                     heapq.heappush(h, (-counter[ch], ch))\n         if len(ans) < len(S):\n             return \"\"\n         return ''.join(ans)\n", "import collections\n \n \n def reorganize(s):\n \n     counts = collections.Counter(s)\n     output = []\n     last_char = None\n \n \n     while counts:\n \n         for c, count in sorted(counts.items(), key=lambda x:x[1], reverse=True):\n             if output and c == output[-1]:\n                 if len(counts) == 1:\n                     #  return \"\".join(output)\n                     return \"\"\n             else:\n                 output.append(c)\n                 counts[c] -= 1\n                 if counts[c] == 0:\n                     counts.pop(c)\n                 break\n \n     return \"\".join(output)\n \n \n \n class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         return reorganize(S)", "import queue\n \n class CountPair:\n     def __init__(self, key, count):\n         self.key = key\n         self.count = count\n     def __lt__(self, other):\n         return self.count > other.count\n \n class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         c_hash = {}\n         q = queue.PriorityQueue()\n         for c in S:\n             if c not in c_hash:\n                 c_hash[c] = 1\n             else:\n                 c_hash[c] += 1\n         for k in c_hash:\n             tmp = CountPair(k,c_hash[k])\n             q.put(tmp)\n         result = \"#\"\n         for i in range(len(S)):\n             v = q.get()\n             if v.count==0:\n                 return \"\"\n             if result[-1] != v.key:\n                 result += v.key\n                 v.count -= 1\n                 if v.count != 0:\n                     q.put(v)\n             else:\n                 if q.empty():\n                     return \"\"\n                 v2 = q.get()\n                 result += v2.key\n                 v2.count -= 1\n                 if v2.count != 0:\n                     q.put(v2)\n                 q.put(v)\n         return result[1:]\n             \n                 \n         \n         \n         \n         \n         \n         \n         \n         ", "class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         from math import ceil\n         dict1 = {}\n         s = \"\"\n         for i in range(len(S)):\n             if S[i] not in dict1:\n                 dict1[S[i]] = 1\n             else:\n                 dict1[S[i]] += 1\n             if dict1[S[i]] > ceil(len(S)/2): return \"\"\n         dict2 = [ item for item in list(dict1.items())]\n         dict2.sort(key=lambda x:x[1], reverse=True)\n         for i in range(dict2[0][1]):\n             s = s + dict2[0][0]\n         for i in range(1,len(dict2)):\n             temp = 0\n             value =  dict2[i][1]\n             key = dict2[i][0]\n             while value>0:\n                 for j in range(i):\n                     while value > 0 and (dict2[j][0]+ dict2[j][0]) in s:\n                         s = s[0:s.index(dict2[j][0]+ dict2[j][0])] + dict2[j][0]+ key + dict2[j][0] + s[s.index(dict2[j][0]+ dict2[j][0])+2:]\n                         value -= 1\n                 if value>0:\n                     if key in s:\n                         temp = s.index(key)\n                         if temp>=2:\n                             s = s[0:temp-2] + key + s[temp-2:]\n                         else:\n                             s = key + s\n                         value -= 1\n                     else:\n                         s = s + key\n                         value -= 1\n         return s\n", "from collections import Counter\n class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         count = Counter(S)\n         mylist = count.most_common()\n         _, maxfreq = mylist[0]\n \n         if maxfreq > (len(S) + 1) // 2:\n             return \"\"\n         else:\n             res = [[] for _ in range(maxfreq)]\n             start = 0\n             for char, freq in mylist:\n                 for i in range(freq):\n                     res[(i + start) % maxfreq].append(char)\n                 start += freq\n             return \"\".join(\"\".join(temp) for temp in res)", "class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         \n         # pq = [(-S.count(x), x) for x in set(S)]\n         count = {}\n         limit = (len(S) + 1) / 2\n         for c in S:\n             if c in count:\n                 count[c] += 1\n             else:\n                 count[c] = 1\n                 \n             if (count[c] > limit):\n                 return(\"\")\n         \n         pq = []\n         for x in count.keys():\n             c = count[x]\n             pq.append((-c, x))    \n         \n         \n         # pq = []\n         # limit = (len(S) + 1) / 2\n         # for x in set(S):\n         #     count = S.count(x)\n         #     if (count > limit):\n         #         return(\"\")\n         #     pq.append((-count, x))\n         \n         heapq.heapify(pq)\n         \n         result = []\n         while len(pq) >= 2:\n             count1, char1 = heapq.heappop(pq)\n             count2, char2 = heapq.heappop(pq)\n             result.extend([char1, char2])\n             \n             if (count1 != -1): \n                 heapq.heappush(pq, (count1 + 1, char1))\n             if (count2 != -1): \n                 heapq.heappush(pq, (count2 + 1, char2))\n \n         answer = \"\".join(result) \n         if (len(pq) == 1):\n             answer += heapq.heappop(pq)[1]\n         \n         return(answer)", "from collections import Counter\n from math import ceil\n class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         char_freq = Counter(S).most_common()\n         max_freq = char_freq[0][-1]\n         \n         if max_freq > ceil(len(S)/2):\n             return ''\n         else:\n             buckets = [[] for _ in range(max_freq)]\n             print(char_freq)\n             start = 0 \n             for char,freq in char_freq:\n                 print(char,freq)\n                 for i in range(freq):\n                     idx = (i+start)%max_freq\n                     print(idx)\n                     buckets[idx].append(char)\n                 start+=freq\n             \n             return ''.join(''.join(bucket) for bucket in buckets)\n         \n         ", "from itertools import groupby\n class Solution:\n     def reorganizeString(self, s):\n         \"\"\"\n         :type d: str\n         :rtype: str\n         \"\"\"\n         counts = sorted([s.count(x) for x in set(s)] + [0])[::-1]\n         \n         if counts[0] > sum(counts[1:]) + 1:\n             return \"\"\n         \n         gl = sorted([list(j) for i, j in groupby(sorted(list(s)))], key=lambda x: -len(x))\n         \n         res = \"\"\n         while gl:\n             \n             res += gl[0].pop()\n             if len(gl) > 1:\n                 res += gl[1].pop()\n \n             gl = list(filter(None, gl))\n             gl.sort(key=lambda x: -len(x))\n         return res\n         \n         ", "from itertools import groupby\n class Solution:\n     def reorganizeString(self, s):\n         \"\"\"\n         :type d: str\n         :rtype: str\n         \"\"\"\n         counts = sorted([s.count(x) for x in set(s)] + [0])[::-1]\n         \n         if counts[0] > sum(counts[1:]) + 1:\n             return \"\"\n         \n         gl = sorted([list(j) for i, j in groupby(sorted(list(s)))], key=lambda x: -len(x))\n         \n         res = \"\"\n         while gl:\n             \n             res += gl[0].pop()\n             if len(gl) > 1:\n                 res += gl[1].pop()\n \n             gl = list(filter(None, gl))\n             gl.sort(key=lambda x: -len(x))\n         return res\n         \n         ", "class Solution(object):\n     def reorganizeString(self, S):\n         N = len(S)\n         A = []\n         for c, x in sorted((S.count(x), x) for x in set(S)):\n             if c > (N+1)/2: return \"\"\n             A.extend(c * x)\n             print(A)\n         ans = [None] * N\n         ans[::2], ans[1::2] = A[int(N/2):], A[:int(N/2)]\n         print(ans[::2])\n         return \"\".join(ans)", "class Solution:\n     def reorganizeString(self, S):\n         c = collections.Counter(S)\n         if max(c.values()) <= (len(S) + 1) / 2:\n             res = \"\"\n             while c:\n                 out = c.most_common(2)\n                 if len(out):\n                     res += out[0][0]\n                     c[out[0][0]] -= 1\n                 if len(out) > 1:\n                     res += out[1][0]\n                     c[out[1][0]] -= 1\n                 c += collections.Counter()\n             return res\n         return \"\"\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"", "class Solution:\n     def reorganizeString(self, S):\n         \"\"\"\n         :type S: str\n         :rtype: str\n         \"\"\"\n         '''\n         size = len(S)\n         limit = size//2 + size%2\n         cnt = collections.Counter(S)\n         res = [0]*size\n         i = 0\n         for k, v in cnt.most_common():\n             if v > limit:\n                 return ''\n             for _ in range(v):\n                 if i >= size:\n                     i = res.index(0)\n                 res[i] = k\n                 i += 2\n         return ''.join(res)\n         '''\n         cnt = collections.Counter(S)\n         res = '#'\n         while cnt:\n             stop = True\n             for k, v in cnt.most_common():\n                 if k != res[-1]:\n                     stop = False\n                     res += k\n                     cnt[k] -= 1\n                     if not cnt[k]:\n                         del cnt[k]\n                     break\n             if stop == True:\n                 break\n         return res[1:] if len(res) == len(S)+1 else ''\n", "null"]
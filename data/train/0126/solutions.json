["class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        count = collections.Counter(s[i : i + minSize] for i in range(0, n - minSize +  1))\n        res = 0 \n        for k, v in count.items():\n            if len(set(k)) <= maxLetters:\n                res = max(res, v)\n        return res", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        k = minSize\n        count = collections.Counter(s[i:i + k] for i in range(len(s) - k + 1))\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        k =minSize\n        \n        count = Counter(s[i:i + k] for i in range(len(s) - k + 1))\n        print(count)\n        ans=0\n        for w in count:\n            if len(set(w)) <= maxLetters:\n                ans=max(count[w],ans)\n        return ans        \n        #return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        word_dic = {}\n        str_dic = {}\n        r_end = 0\n        ans = 0\n        \n        def update_ans(length):\n            if length >= minSize:\n                return min(length,maxSize) - minSize + 1\n            return 0\n        \n        for i in range(len(s)):\n            while (r_end<len(s)):\n                ch = s[r_end]\n                if ch in list(word_dic.keys()):\n                    word_dic[ch] += 1\n                else:\n                    if len(list(word_dic.keys())) < maxLetters:\n                        word_dic[ch] = 1\n                    else:\n                        break\n                r_end += 1\n            for j in range(minSize,min(maxSize,r_end-i) + 1):\n                subs = s[i:i+j]\n                if subs not in str_dic:\n                    str_dic[subs] = 1\n                else:\n                    str_dic[subs] += 1\n            word_dic[s[i]] -= 1\n            if word_dic[s[i]] == 0:\n                del word_dic[s[i]]\n        if not bool(str_dic):\n            return 0\n        else:\n            return max(str_dic.values())\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        seen = defaultdict(lambda : 0)\n        m = defaultdict(lambda : 0)\n        left = 0\n        \n        for i in range(len(s)):\n            m[s[i]] += 1\n            \n            while(len(m) > maxLetters or i-left+1 > maxSize):\n                m[s[left]] -= 1\n                if m[s[left]] == 0:\n                    m.pop(s[left])\n                left += 1        \n            \n            \n            temp = left\n            while i-temp+1 >= minSize:\n                seen[s[temp:i+1]] += 1\n                temp += 1\n                    \n        if not seen:\n            return 0\n        return max(list(seen.values()))", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        T = lambda: collections.defaultdict( T )\n        trie , res = T( ) , 0\n        data = [ [ trie , set( ) ] for _ in range( len( s ) - minSize + 1 ) ]\n        for i in range( minSize ) :\n            for j in range( len( s ) - minSize + 1 ) :\n                c = s[i+j]\n                cur = data[j]\n                cur[1].add(c)\n                if i == minSize - 1 and len( cur[ 1 ] ) <= maxLetters :\n                    cur[0][c].setdefault( '#' , 0 )\n                    cur[0][c]['#'] += 1\n                    res = max( res , cur[ 0 ][ c ][ '#' ] )\n                cur[ 0 ] = cur[0][c]\n        return res", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        letdict = defaultdict(int)\n        subdict = defaultdict(int)\n        uniquecount = 0\n        start = end = 0\n        n = len(s)\n        \n        while end < n:\n            val = s[end]\n            letdict[val] += 1\n            if letdict[val] == 1:\n                uniquecount += 1\n            \n            while uniquecount > maxLetters or ((end-start)+1) > maxSize:\n                val = s[start]\n                letdict[val] -= 1\n                if letdict[val] == 0:\n                    uniquecount -= 1\n                start += 1\n                \n            tstart = start\n            while ((end-tstart)+1) >= minSize:\n                subdict[s[tstart:end+1]] += 1\n                tstart += 1\n\n            end += 1\n        if not subdict:\n            return 0\n        return subdict[max(subdict, key = lambda x: subdict[x])]", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        from collections import defaultdict\n        cnt=defaultdict(int)\n        for i in range(minSize-1,len(s)):\n            low1=i-minSize+1\n            low2=i-maxSize+1\n            seen1=set()\n            seen2=set()\n            for k in range(low1,i+1):\n                if s[k] not in seen1:\n                    seen1.add(s[k])\n            if low2>=0 and low1!=low2:\n                for k in range(low2,i+1):\n                    if s[k] not in seen2:\n                        seen2.add(s[k])\n                if len(seen2)<=maxLetters:\n                    cnt[s[low2:i+1]]+=1\n            if len(seen1)<=maxLetters:\n                cnt[s[low1:i+1]]+=1\n            \n        if list(cnt.values()):\n            return max(cnt.values())\n        return 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        if len(s) < minSize:\n            return 0\n        \n        occur = {}\n        l,r=0, minSize\n        \n        while r <= len(s):\n            sub = s[l:r]\n            \n            if occur.get(sub) is None:\n                distinct = set(sub)\n                if len(distinct) <= maxLetters:\n                    occur[sub] = 1\n            else:\n                occur[sub]+=1\n                \n            l += 1\n            r += 1\n            \n        return max(occur.values()) if len(occur) >0 else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        from collections import defaultdict\n        res = 0\n        valid_str_freq = defaultdict(int)\n        window_letter = {}\n        left = 0\n        right = 0\n        for right in range(0, len(s), 1):\n            # print(left, right)\n            for i in range(left, right, 1):\n                if right - i < minSize:\n                    break\n                valid_str = s[i:right]\n                # print(i, right, valid_str)\n                valid_str_freq[valid_str] += 1\n                res = max(res, valid_str_freq[valid_str])\n\n            # add right\n            if s[right] not in window_letter:\n                window_letter[s[right]] = 1        \n            else:\n                window_letter[s[right]] += 1\n            \n            # check left\n            while (len(window_letter) > maxLetters\n                or right - left + 1 > maxSize\n            ):\n                window_letter[s[left]] -= 1\n                if window_letter[s[left]] == 0:\n                    del window_letter[s[left]]    \n                left += 1\n        right += 1\n        for i in range(left, right, 1):\n            if right - i < minSize:\n                break\n            valid_str = s[i:right]\n            # print(i, right, valid_str)\n            valid_str_freq[valid_str] += 1\n            res = max(res, valid_str_freq[valid_str])\n        return res\n                        \n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        res = collections.Counter()\n        b=0\n        cc = collections.Counter()\n        \n        for e in range(len(s)):\n            cc[s[e]] += 1\n            \n            while len(cc)>maxLetters or e-b+1>maxSize:\n                cc[s[b]] -= 1\n                if cc[s[b]]==0: cc.pop(s[b])\n                b += 1\n            i=b\n            while e-i+1>=minSize:\n                res[s[i:e+1]] += 1\n                i += 1\n        # print(res)\n        return res.most_common(1)[0][1] if res else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        d = defaultdict(int)\n        for i in range(len(s)-minSize+1):\n            letters = set(s[i:i+minSize-1])\n            for j in range(minSize, min(maxSize, len(s)-i)+1):\n                letters.add(s[i+j-1])\n                if len(letters) > maxLetters:\n                    break\n                d[s[i:i+j]] += 1\n        return max(d.values()) if d else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = defaultdict(lambda: 0)\n        m = ''\n        n = len(s)\n        for i in range(n - minSize + 1):\n            end = i + minSize\n            unique = set(s[i:end])\n            while end <= n:\n                unique.add(s[end - 1])\n                if len(unique) > maxLetters:\n                    break\n                cur = s[i:end]\n                freq[cur] += 1\n                if freq[cur] > freq[m]:\n                    m = cur\n                end += 1\n        return freq[m]\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = defaultdict(lambda: 0)\n        m = ''\n        uniques = defaultdict(lambda: set())\n        n = len(s)\n        for i in range(n - minSize + 1):\n            end = i + minSize\n            unique = set(s[i:end])\n            while end <= n:\n                unique.add(s[end - 1])\n                if len(unique) > maxLetters:\n                    break\n                cur = s[i:end]\n                freq[cur] += 1\n                if freq[cur] > freq[m]:\n                    m = cur\n                end += 1\n        return freq[m]\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        seen = Counter()\n        cnt = Counter()\n        j = 0\n        for i, ss in enumerate(s):\n            cnt[ss] += 1\n            while len(cnt) > maxLetters and j <= i:\n                cnt[s[j]] -= 1\n                if not cnt[s[j]]:\n                    del cnt[s[j]]\n                j += 1\n            k = j\n            while i - k + 1 >= minSize:\n                if i - k + 1 <= maxSize:\n                    seen[s[k: i + 1]] += 1\n                k += 1\n        return max(seen.values()) if seen else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        ret = defaultdict(int)\n        for i in range(len(s)):\n            temp = ''\n            char = set()\n            for j in range(i, len(s)):\n                temp = temp + s[j]\n                char.add(s[j])\n                if len(char) <= maxLetters and minSize <= len(temp) <= maxSize:\n                    ret[temp] += 1\n                elif len(char) > maxLetters or len(temp) > maxSize:\n                    break\n\n        if len(ret) == 0:\n            return 0\n        return max(ret.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n=len(s)\n        d=collections.defaultdict(int)\n        for i in range(0,n-minSize+1):\n            temp=s[i:i+minSize]\n            c=set(temp)\n            if len(c)<=maxLetters:\n                d[temp]+=1\n        return max(d.values()) if d else 0\n", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        \n        mx_count = 0\n        \n        def create_dct(size, mx_count):\n            dct = defaultdict(int)\n        \n            i = 0\n            j = size - 1\n\n            while j < len(s):\n\n                temp = []\n                temp_dict = defaultdict(int)\n\n                flag = True\n                for x in range(i, j+1):\n                    temp.append(s[x])\n                    temp_dict[s[x]] += 1\n                    if len(temp_dict) > maxLetters:\n                        flag = False\n                        break\n\n                i += 1\n                j += 1\n\n                if not flag:\n                    continue\n                \n                tmp_string = ''.join(temp)\n                dct[tmp_string] += 1\n                \n                if dct[tmp_string] > mx_count:\n                    mx_count = dct[tmp_string]\n            \n            return mx_count\n                    \n        mx_count = create_dct(minSize, mx_count)\n        mx_count = max(create_dct(maxSize, mx_count), mx_count)\n        \n        return mx_count\n        \n        \n        \n            \n            \n            \n            \n            \n            \n                \n                \n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        c = Counter()\n        i = 0\n        letterlen = 0\n        maxSize = maxSize+1 if maxSize==minSize else maxSize\n        ans = Counter()\n        for j, v in enumerate(s):\n            c[v] += 1\n            if c[v] == 1:\n                letterlen += 1\n            while letterlen > maxLetters:\n                x = s[i]\n                c[x] -= 1\n                if c[x] == 0:\n                    letterlen -= 1\n                i += 1\n            #print(i,j)\n            for l in range(minSize,maxSize):\n                beg = j-l +1\n                #print(i,j,beg)\n                if beg >= i:\n                    ans[s[beg:j+1]] += 1\n        #print(ans)\n        return max(ans.values()) if ans else 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = 0\n        n = len(s)\n        count = Counter()\n        \n        for i in range(n - minSize + 1):\n            \n            r = i + minSize\n            seen = {c for c in s[i:r]}\n            unique = len(seen)\n            while unique <= maxLetters and r <= n and r - i <= maxSize:\n                if s[r - 1] not in seen:\n                    unique += 1\n                    seen.add(s[r-1])\n                count[s[i:r]] += 1\n                r += 1\n                \n        return max(count.values()) if count else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if minSize > len(s): return 0\n        left= 0\n        candidates = Counter()\n        while left <= len(s) - minSize:\n            right = left + minSize\n            count = set(s[left:right])\n            while right <= len(s) and right-left <= maxSize and len(count) <= maxLetters:\n                if right < len(s):\n                    count.add(s[right])\n                candidates[s[left:right]] += 1\n                right += 1                \n            left += 1\n        if not candidates:\n            return 0\n        return max(candidates.values())\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        feq = collections.Counter()\n        \n        N = len(s)\n        for i in range(N):\n            letters = set([c for c in s[i : i + minSize - 1]])\n            for j in range(minSize, maxSize + 1):\n                k = i + j\n                if k > N:\n                    break\n                letters.add(s[k - 1])\n                if len(letters) > maxLetters:\n                    break\n                feq[s[i:k]] += 1\n        \n        return max(feq.values()) if list(feq.values()) else 0\n                \n                \n\n                \n                \n                \n", "class Solution:\n    def maxFreq(self, s: str, mxl: int, mns: int, mxs: int) -> int:\n        freq = collections.Counter()\n        for i in range(mns, len(s)+1):\n            for j in range(mxs-mns+1):\n                if i + j > len(s):\n                    break\n                curr = s[i-mns:i+j]\n                if len(set(curr)) > mxl:\n                    break\n                freq[curr] += 1\n        return max(freq.values() or [0])", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        from collections import defaultdict\n        letters = defaultdict(int)\n        res = 0\n        if len(s) < minSize:\n            return 0\n        i = 0\n        j = 0\n        unique = 0\n        counter = defaultdict(int)\n        while i < len(s):\n            if letters[s[i]] == 0:\n                unique += 1\n            letters[s[i]] += 1\n            \n            while j < i and unique > maxLetters:\n                letters[s[j]] -= 1\n                if letters[s[j]] == 0:\n                    unique -= 1\n                j += 1\n            j_tmp = j\n            unique_tmp = unique\n            letters_tmp = letters.copy()\n            while unique_tmp <= maxLetters and (minSize <= (i - j_tmp + 1)):\n                if (i - j_tmp + 1) > maxSize:\n                    j_tmp+=1\n                    continue\n                counter[s[j_tmp:i+1]] += 1\n                #print(f'{s[j_tmp:i+1]} {counter} {i} {j_tmp}')\n                letters_tmp[s[j_tmp]] -= 1\n                if letters_tmp[s[j_tmp]] == 0:\n                    unique_tmp -= 1\n                j_tmp += 1\n                #print(f'i {i} j {j} unique {unique} {s[j:i+1]} letters {letters},res {res}, len {i-j+1}, {counter}')\n            i += 1\n        if len(counter.values()) == 0:\n            return 0\n        \n        return max(counter.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        start = 0\n        end = minSize\n        counts = {}\n        res = 0\n        \n        while start <= len(s)-minSize:\n            item = s[start:end]\n            counts[item] = counts.get(item, 0) + 1\n            \n            start += 1\n            end += 1\n            \n        for i in counts:\n            if self.countUnique(i) <= maxLetters:\n                res = max(res, counts[i])\n                  \n        return res\n        \n    def countUnique(self, s):\n        return len(set(s))", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        ln_s    =   len(s);\n        ans =   0;\n        seen    =   Counter();\n        \n        for i in range( ln_s):\n            \n            set_buff    =   set(s[i:i+minSize]);\n            for j in range(i+minSize-1, min(ln_s, i+maxSize)):\n                \n                buff    =   s[i:j+1];\n                set_buff.add(   s[j]);\n                \n                if len(set_buff) > maxLetters:  break;\n                \n                seen[buff] += 1;\n                \n                ans =   max(    ans, seen[buff]);\n        \n        return ans;", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        subs = {}\n        i = j = 0\n        chars = {}\n        while i < len(s):\n            if  j < len(s) and (s[j] in chars or len(chars) < maxLetters):\n                if s[j] not in chars:\n                    chars[s[j]] = 0\n                chars[s[j]] += 1\n                j += 1\n            else:\n                for k in range(i+minSize, min(i+maxSize, j)+1):\n                    sub = s[i:k]\n                    if sub not in subs:\n                        subs[sub] = 0\n                    subs[sub] += 1\n                    \n                chars[s[i]] -= 1\n                if chars[s[i]] == 0:\n                    del chars[s[i]]\n                i += 1\n        return max(list(subs.values()) or [0])\n", "class Solution:\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\n        if minSize > len(s):\n            return 0\n            \n        left = 0\n        right = minSize - 1\n        words = {}\n        \n        while left < len(s) - minSize + 1:\n            word = s[left:right+1]\n            while right < len(s) and right - left < maxSize and len(set(word)) <= maxLetters:\n                if word not in words:\n                    words[word] = 0\n                words[word] += 1\n\n                right += 1\n                if right < len(s):\n                    word += s[right]\n            \n            left += 1\n            right = left + minSize - 1\n        \n        maxOccurences = 0\n        for word in words:\n            maxOccurences = max(maxOccurences, words[word])\n        \n        return maxOccurences", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        d = dict()\n        n = len(s)\n        for i in range(n):\n            j = i\n            st = set()\n            l = 0\n            while j<min(n,i+maxSize) and l<=maxLetters:\n                if s[j] not in st:\n                    l+=1\n                    st.add(s[j])\n                x = s[i:j+1]\n                ln = j-i+1\n                #print(x,ln)\n                if ln>=minSize and ln<=maxSize and l<=maxLetters:\n                    if x in d:\n                        d[x]+=1\n                    else:\n                        d[x]=1\n                j+=1\n        if d==dict():\n            return 0\n        return max(list(d.values()))\n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        N = len(s)\n        d1 = {}\n        maxval = 0\n        for i in range(N-minSize+1):\n            d = {}\n            for j in range(i,i+minSize):\n                if(s[j] not in d):\n                    d[s[j]] = 1\n                else:\n                    d[s[j]] += 1\n            if(len(d)<=maxLetters):\n                if(s[i:i+minSize] not in d1):\n                    d1[s[i:i+minSize]] = 1\n                else:\n                    d1[s[i:i+minSize]] += 1\n                maxval = max(maxval,d1[s[i:i+minSize]])\n            else:\n                continue\n            for j in range(i+minSize, min(i+maxSize,N)):\n                if(s[j] not in d):\n                    d[s[j]] = 1\n                else:\n                    d[s[j]] += 1\n                if(len(d)<=maxLetters):\n                    if(s[i:j+1] not in list(d1.keys())):\n                        d1[s[i:j+1]] = 1\n                    else:\n                        \n                        d1[s[i:j+1]] += 1\n                    maxval = max(maxval,d1[s[i:j+1]])\n                else:\n                    break       \n        return maxval\n", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        ans , freq_subs , n = collections.defaultdict( int ) , 0 , len( s )\n        for i in range( n - minSize + 1 ) :\n            for j in range( i + minSize  , n + 1 ) :\n                if len( set( s[ i : j ] ) ) <= maxLetters :\n                    if s[i:j] in ans :\n                        ans[ s[i:j] ] += 1\n                        freq_subs = max( freq_subs , ans[s[i:j]] )\n                    else :\n                        ans[s[i:j]] = 1\n                        freq_subs = max( freq_subs , 1 )\n                else :\n                    break\n        return freq_subs", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = Counter()\n        for leftInd, char in enumerate(s):\n            seen = set([])\n            for rightInd in range(leftInd, leftInd + maxSize):\n                if rightInd > len(s) - 1:\n                    break\n                seen.add(s[rightInd])\n                if len(seen) > maxLetters:\n                    break\n                if maxSize >= rightInd - leftInd + 1 >= minSize:\n                    freq[s[leftInd:rightInd + 1]] += 1\n        ret = 0\n        for key, val in freq.items():\n            ret = max(ret, val)\n        return ret", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        cache=collections.defaultdict(int)\n        for i in range(len(s)+1-minSize):\n            if len(set(s[i:i+minSize]))<=maxLetters:\n                cache[s[i:i+minSize]]+=1\n        res=0\n        for k,v in list(cache.items()):\n            res=max(res,v)\n        return res\n                \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        d=defaultdict(int)\n        s=list(s)\n        n=len(s)\n\n        for i in range(n-minSize+1):\n            for j in range(i+minSize,min(i+maxSize+1,n+1)):\n                if len(set(s[i:j]))<=maxLetters:\n                    d[tuple(s[i:j])]+=1\n                   \n                else:\n                    break\n        if not d:\n            return 0\n        return max(d.values())\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if minSize > len(s):\n            return 0\n        maxCount = 0\n        seenSubstrs = Counter()\n        for i in range(len(s)):\n            letterSet = set()\n            for j in range(i, i + minSize - 1):\n                if j >= len(s):\n                    break\n                letterSet.add(s[j])\n                if len(letterSet) > maxLetters:\n                    break\n            if len(letterSet) > maxLetters:\n                continue\n            for j in range(i+minSize-1, i+maxSize+1):\n                if j >= len(s):\n                    break\n                letterSet.add(s[j])\n                if len(letterSet) > maxLetters:\n                    break\n                seenSubstrs[s[i:j+1]] += 1\n                maxCount = max(seenSubstrs[s[i:j+1]], maxCount)\n        return maxCount\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        sub = dict()\n\n        for i in range(len(s) - minSize + 1):\n            d = dict()\n            for k in range(i, i + minSize):\n                if s[k] in d:\n                    d[s[k]] += 1\n                else:\n                    d[s[k]] = 1\n\n            if len(d) <= maxLetters:\n                phrase = s[i:i+minSize]\n                if phrase in sub:\n                    sub[phrase] += 1\n                else:\n                    sub[phrase] = 1\n            else:\n                continue\n\n            for j in range(i + minSize, i + maxSize):\n                if j < len(s):\n                    if len(d) <= maxLetters:\n                        phrase = s[i:j+1]\n                        if phrase in sub:\n                            sub[phrase] += 1\n                        else:\n                            sub[phrase] = 1\n                    else:\n                        break\n\n                    if s[j] in d:\n                        d[s[j]] += 1\n                    else:\n                        d[s[j]] = 1\n\n        if not sub:\n            return 0\n        return max(sub.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        res_dict = collections.defaultdict(int)\n        \n        for lidx in range(n-minSize+1):\n            lval = lidx+minSize\n            rval = min(n,lidx+maxSize+1)\n            for ridx in range(lval, 1+rval):\n                counts = set(s[lidx:ridx])\n                if len(counts) <= maxLetters:\n                    res_dict[s[lidx:ridx]] += 1\n                else: \n                    break\n        \n        return max(res_dict.values()) if res_dict else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        def valid(sub):\n            seen = set()\n            for c in sub: seen.add(c)\n            return len(seen)\n            \n        counts = dict()\n        start = 0\n        while start < len(s):\n            end = start+minSize\n            while end <= len(s) and end <= start + maxSize:\n                sub = s[start:end]\n                if sub in counts:\n                    counts[sub] += 1\n                else:\n                    num_letters = valid(sub)\n                    if num_letters <= maxLetters:\n                        counts[sub] = 1\n                    else:\n                        break\n                end += 1\n            start += 1\n        \n        l = list(counts.values())\n        if len(l) == 0: return 0\n        return max(l)\n            \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        all_substrings = {}\n        max_letters = maxLetters\n        min_size = minSize\n        max_size = maxSize\n        _s = s\n        ll = len(_s)\n        for i in range(min_size, max_size + 1):\n            for j in range(ll - i + 1):\n                ss = _s[j:j+i]\n                if max_letters >= min_size or len(set(ss)) <= max_letters:\n                    if ss not in all_substrings:\n                        all_substrings[ss] = 1\n                    else:\n                        all_substrings[ss] += 1\n        return max(all_substrings.values()) if len(all_substrings) > 0 else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        sol = {}\n        for i in range(len(s) - minSize + 1):\n            count = set()\n            length = 0\n            for j in range(minSize - 1):\n                length += 1\n                c = s[i+j]\n                if c not in count:\n                    count.add(c)\n            while length < maxSize and (i + length) < len(s):\n                c = s[i + length]\n                if c not in count:\n                    count.add(c)\n                if len(count) <= maxLetters:\n                    substring = s[i: i+length+1]\n                    if substring in sol:\n                        sol[substring] += 1\n                    else:\n                        sol[substring] = 1\n                length += 1\n        maximum = 0\n        for substring in sol:\n            if sol[substring] > maximum:\n                maximum = sol[substring]\n        return maximum", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    \n        cur_soln = {s[:minSize]: 1}\n        \n        for end in range(minSize, len(s)):\n            for start in range(end-minSize+1, max(-1, end-maxSize), -1):\n                subs = s[start:end+1]\n                cur_soln[subs] = cur_soln.get(subs, 0) + 1\n\n        cur_best = 0\n        for s, cnt in list(cur_soln.items()):\n            if cnt > cur_best and len(set(s)) <= maxLetters:\n                cur_best = cnt\n        return cur_best\n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        count = collections.Counter()\n        \n        for i in range(len(s) - minSize + 1):\n            t = s[i:minSize+i]\n            if len(set(t)) <= maxLetters:\n                count[t] += 1\n                \n                \n                \n        if count:\n            return max(count.values())\n        else:\n            return 0 ", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        maxcount = 0\n        visited = {}\n        for i in range(len(s)):\n            for j in range(minSize, minSize+1):\n                now = s[i:i+j]\n                if now in visited:\n                    continue\n                    \n                visited[now] = 1\n                if i + j > len(s):\n                    break\n                    \n                nowset = set(now)\n                if len(nowset) > maxLetters:\n                    break\n                \n                count = 1\n                start = i+1\n                while(start < len(s)):\n                    pos = s.find(now, start)\n                    if pos != -1:\n                        start = pos + 1\n                        count += 1\n                    else:\n                        break\n                    \n                maxcount = max(maxcount, count)\n        \n        return maxcount", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrings = defaultdict(int)\n        for gap in range(minSize, maxSize + 1):\n            for start in range(len(s) - gap + 1):\n                end = start + gap\n                substrings[s[start:end]] += 1\n        max_ = 0\n        for substring, times in substrings.items():\n            if times > max_ and len(set(substring)) <= maxLetters:\n                max_ = times\n        return max_", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if maxLetters == 0:\n            return 0\n        sw = collections.defaultdict(int)\n        substrings = collections.defaultdict(int)\n        l = 0\n        res = 0\n        for r, ch in enumerate(s):\n            sw[ch] += 1\n            while l <= r and len(sw) > maxLetters:\n                chL = s[l]\n                sw[chL] -= 1\n                if sw[chL] == 0:\n                    del sw[chL]\n                l += 1\n            #print(r, r + 1 - maxSize, r + 1 - minSize + 1)\n            #print(l, r)\n            for j in range(r + 1 - maxSize, r + 1 - minSize + 1):\n                if j < l:\n                    continue\n                substrings[s[j : r + 1]] += 1\n                res = max(res, substrings[s[j : r + 1]])\n            #print(substrings)\n        return res\n        \n        #l r\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        maxi = 0\n        \n        for index in range(minSize, maxSize + 1):\n            result = self.getAllSubstringsWithRules(s, maxLetters, index)\n            \n            if result > maxi:\n                maxi = result\n                \n        return maxi\n    \n    def getAllSubstringsWithRules(self, s, maxLetters, size):\n        length = len(s)\n        letters = {}\n        subStrings = {}\n        \n        for index in range(size):\n            letter = s[index]\n            \n            if letter not in letters:\n                letters[letter] = 0\n                \n            letters[letter] += 1\n            \n        if len(letters) <= maxLetters:\n            subStrings[s[:size]] = 1\n            \n        for index in range(size, length):\n            letterToRemove = s[index - size]\n            letters[letterToRemove] -= 1\n            \n            if letters[letterToRemove] == 0:\n                del letters[letterToRemove] \n                \n            letterToAdd = s[index]\n            \n            if letterToAdd not in letters:\n                letters[letterToAdd] = 0\n                \n            letters[letterToAdd] += 1\n            \n            if len(letters) <= maxLetters:\n                string = s[index - size + 1:index + 1]\n                if string not in subStrings:\n                    subStrings[string] = 0\n                    \n                subStrings[string] += 1\n                \n        if not subStrings:\n            return 0\n                \n        return max(subStrings.values())\n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        cnt = defaultdict(int)\n        \n        for i in range(n):\n            now = ''\n            se = set()\n            \n            for j in range(maxSize):\n                if i+j>=n:\n                    break\n                    \n                now += s[i+j]\n                se.add(s[i+j])\n                \n                if len(se)<=maxLetters and len(now)>=minSize:\n                    cnt[now] += 1\n        \n        ans = 0\n        \n        for v in cnt.values():\n            ans = max(ans, v)\n        \n        return ans", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        sol = {}\n        for i in range(len(s) - minSize + 1):\n            count = {}\n            length = 0\n            for j in range(minSize - 1):\n                length += 1\n                c = s[i+j]\n                if c in count:\n                    count[c] += 1\n                else:\n                    count[c] = 1\n            while length < maxSize and (i + length) < len(s):\n                c = s[i + length]\n                if c in count:\n                    count[c] += 1\n                else:\n                    count[c] = 1\n                if len(count) <= maxLetters:\n                    substring = s[i: i+length+1]\n                    if substring in sol:\n                        sol[substring] += 1\n                    else:\n                        sol[substring] = 1\n                length += 1\n        maximum = 0\n        for substring in sol:\n            if sol[substring] > maximum:\n                maximum = sol[substring]\n        return maximum", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        cnt=collections.Counter()\n        for i in range (len(s)-minSize+1):\n            sub=s[i:i+minSize]\n            if len(set(sub))<=maxLetters:\n                cnt[sub]+=1\n        return max(cnt.values()) if cnt else 0    \n                    \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        sol = {}\n        for i in range(len(s) - minSize + 1):\n            count = set()\n            length = 0\n            while length < maxSize and (i + length) < len(s):\n                c = s[i + length]\n                if c not in count:\n                    count.add(c)\n                length += 1\n                # print(s[i: i+length+1])\n                if len(count) <= maxLetters and length >= minSize:\n                    substring = s[i: i+length]\n                    if substring in sol:\n                        sol[substring] += 1\n                    else:\n                        sol[substring] = 1\n        maximum = 0\n        for substring in sol:\n            if sol[substring] > maximum:\n                maximum = sol[substring]\n        return maximum", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n                \n        counts = {} # string -> number \n        \n        for current_size in range(minSize, maxSize + 1): \n            window = {}\n            for i in range(current_size-1): \n                c = s[i]\n                window[c] = window.get(c, 0) + 1 \n            \n            for i in range(current_size-1, len(s)):\n                start = i - current_size\n\n                # add current \n                c = s[i]\n                window[c] = window.get(c, 0) + 1 \n                \n                # remove tail\n                if start >= 0:\n                    c = s[start]\n                    window[c] -= 1 \n                    if window[c] == 0:\n                        del window[c]\n                    \n                # check\n                if len(window) <= maxLetters: \n                    sub = s[start+1:i+1]\n                    counts[sub] = counts.get(sub, 0) + 1 \n                    \n        # print(counts)\n        return max(counts.values()) if len(counts) else 0 \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = {}\n        for outer in range(0,len(s)):\n            if minSize + outer > len(s): break\n            substring = s[outer:minSize+outer]\n            while len(substring) <= maxSize and len(set(substring))<=maxLetters:\n                if dic.get(substring): \n                    dic[substring] += 1\n                else: dic[substring] = 1\n                newIndex = outer + len(substring) + 1\n                if not newIndex > len(s):\n                    substring = s[outer:newIndex]\n                else: break\n        if dic:\n            maxKey = max(dic,key=lambda key: dic[key])\n            return dic[maxKey]\n        else: return 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        for i in range(minSize, maxSize+1):\n            max_freq = self.maxFreqSetSize(s, maxLetters, i)\n            if max_freq > 0:\n                return max_freq\n        return 0\n        \n    def maxFreqSetSize(self, s, maxLetters, windowSize):\n        valid_substrings = set()\n        maxFreq = 0\n        for i in range(len(s)-windowSize):\n            substring = s[i:i+windowSize]\n            if substring in valid_substrings:\n                continue\n            unique_letters = set()\n            for k in range(windowSize):\n                letter = s[i+k]\n                unique_letters.add(letter)\n            if len(unique_letters) > maxLetters:\n                continue\n            frequency = 1\n            pos = i + 1\n            while pos > -1:\n                new_pos = s[pos:].find(substring)\n                if new_pos == -1:\n                    break\n                frequency += 1\n                pos += new_pos + 1\n                            \n            if frequency > maxFreq:\n                maxFreq = frequency\n            valid_substrings.add(substring)\n        return maxFreq", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        \n        \n        mymap = collections.defaultdict(int)\n        st, j, n = 0, 0, len(s)\n#         charmap = collections.defaultdict(int)\n        \n#         for i in range(st, st+minSize-1):\n#             charmap[s[i]] += 1\n#         # print(charmap)\n        while st + minSize <= n:\n            # print (st)\n            count = collections.Counter(s[st:st+minSize-1])\n            for j in range(st+minSize-1, st+maxSize):\n                \n                if j >= n:\n                    break\n                    \n                count[s[j]] += 1\n                if len(count) <= maxLetters:\n                    mymap[s[st:j+1]] += 1\n                \n                \n                \n                \n                \n#                 print(j, s[st:])\n#                 if j >= n:\n#                     break\n                    \n#                 charmap[s[j]] += 1\n#                 if len(charmap) <= maxLetters:\n#                     mymap[s[st:j+1]] += 1\n                \n                 \n#             charmap[s[st]] -= 1\n#             if charmap[s[st]] <= 0:\n#                 charmap.pop(s[st])\n            st += 1\n                    \n        # ans = 0  \n        maxval = max(list(mymap.values()) or [0])\n        # for key in mymap:\n        #     if mymap[key] == maxval:\n        #         ans += 1\n                \n        return maxval\n        # print(mymap)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        validWords = {}\n        for i in range(0, len(s)):\n            for j in range(i + minSize - 1, min(i + maxSize, len(s))):\n                ss = s[i:j + 1]\n                if len(set(ss)) <= maxLetters:\n                    if ss in validWords:\n                        validWords[ss] += 1\n                    else:\n                        validWords[ss] = 1\n\n        # print(\\\"valid: \\\", validWords)\n        if validWords:\n            all_values = validWords.values()\n            return max(all_values)\n        else:\n            return 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        mymap = collections.defaultdict(int)\n        st, j, n = 0, 0, len(s)\n        while st + minSize <= n:\n            # print (st)\n            count = collections.Counter(s[st:st+minSize-1])\n            for j in range(st+minSize-1, st+maxSize):\n                if j >= n:\n                    break\n                count[s[j]] += 1\n                if len(count) <= maxLetters:\n                    mymap[s[st:j+1]] += 1\n            st += 1\n        maxval = max(list(mymap.values()) or [0])\n        return maxval\n        \n        \n        \n#         mymap = collections.defaultdict(int)\n#         st, j, n = 0, 0, len(s)\n# #         charmap = collections.defaultdict(int)\n        \n# #         for i in range(st, st+minSize-1):\n# #             charmap[s[i]] += 1\n# #         # print(charmap)\n#         while st + minSize <= n:\n#             # print (st)\n#             count = collections.Counter(s[st:st+minSize-1])\n#             for j in range(st+minSize-1, st+maxSize):\n                \n#                 if j >= n:\n#                     break\n                    \n#                 count[s[j]] += 1\n#                 if len(count) <= maxLetters:\n#                     mymap[s[st:j+1]] += 1\n                \n                \n                \n                \n                \n# #                 print(j, s[st:])\n# #                 if j >= n:\n# #                     break\n                    \n# #                 charmap[s[j]] += 1\n# #                 if len(charmap) <= maxLetters:\n# #                     mymap[s[st:j+1]] += 1\n                \n                 \n# #             charmap[s[st]] -= 1\n# #             if charmap[s[st]] <= 0:\n# #                 charmap.pop(s[st])\n#             st += 1\n                    \n#         # ans = 0  \n#         maxval = max(mymap.values() or [0])\n#         # for key in mymap:\n#         #     if mymap[key] == maxval:\n#         #         ans += 1\n                \n#         return maxval\n#         # print(mymap)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        maxOcc = 0\n        strOcc = {}\n        \n        for i in range(minSize, maxSize + 1):\n            charFreq = {}\n            sub = s[:i]\n            uniqueChar = 0\n            \n            for c in sub:\n                if c not in charFreq:\n                    charFreq[c] = 0\n                    uniqueChar += 1\n                charFreq[c] += 1\n            \n            if uniqueChar <= maxLetters:\n                if sub not in strOcc:\n                    strOcc[sub] = 0\n                strOcc[sub] += 1\n                maxOcc = max(maxOcc, strOcc[sub])\n            \n            for j in range(i, len(s)):\n                outC = sub[0]\n                inC = s[j]\n                \n                charFreq[outC] -= 1\n                if charFreq[outC] == 0:\n                    uniqueChar -= 1\n                    del charFreq[outC]\n                    \n                if inC not in charFreq:\n                    charFreq[inC] = 0\n                    uniqueChar += 1\n                charFreq[inC] += 1\n                \n                sub = sub[1:] + inC\n                \n                if uniqueChar <= maxLetters:\n                    if sub not in strOcc:\n                        strOcc[sub] = 0\n                    strOcc[sub] += 1\n                    maxOcc = max(maxOcc, strOcc[sub])\n                    \n        return maxOcc\n                \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        if n < minSize:\n            return 0\n        c = collections.Counter()\n        for start in range(n - minSize+1):\n            temp = s[start:start+minSize]\n            tc = collections.Counter(temp)\n            if len(tc.keys()) <= maxLetters:\n                c[temp] += 1\n            else:\n                continue\n            for i in range(start+minSize,min(n,start + maxSize)):\n                tc[s[i]] += 1\n                temp += s[i]\n                if len(tc.keys()) <= maxLetters:\n                    c[temp] += 1\n                else:\n                    continue\n        return max(c.values() or [0])", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substr = defaultdict(int)\n        n = len(s)\n        unique = set()\n        max_freq = 0\n        \n        for i in range(n - minSize + 1):\n            current_str = s[i:i+minSize]\n            \n            if len(set(current_str)) <= maxLetters:\n                substr[current_str] += 1\n                max_freq = max(max_freq, substr[current_str])\n        \n        \n        return max_freq", "from collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrFreq = defaultdict(int)\n        charFreq = defaultdict(int)\n        curr_substr = []\n        \n        l = 0\n        r = l + minSize - 1\n        \n        while l < len(s):\n            for ch in s[l:r]:\n                curr_substr.append(ch)\n                charFreq[ch] += 1\n                \n            while (r - l + 1) <= maxSize and r < len(s):\n                charFreq[s[r]] += 1\n                curr_substr.append(s[r])\n                \n                if len(charFreq) <= maxLetters:\n                    # print(curr_substr)\n                    substrFreq[''.join(curr_substr)] += 1\n\n                r += 1\n                \n            curr_substr = []\n            charFreq = defaultdict(int)\n            l += 1\n            r = l + minSize - 1\n        \n        if substrFreq:\n            return max(substrFreq.values())\n        return 0\n", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        finalDict = collections.defaultdict(int)\n        for i in range(len(s)):\n            for j in range(i + minSize - 1, min(i + maxSize, len(s))):\n                substring = s[i:j+1]\n                if len(set(substring)) <= maxLetters:\n                    finalDict[substring] += 1\n                    \n    \n    \n        return max(finalDict.values()) if finalDict else 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = {}\n        \n        for size in range(minSize, maxSize+1):\n            for i in range(len(s) - size + 1):\n                sub_str = s[i:i+size]\n                \n                if len(set(sub_str)) > maxLetters: continue\n                \n                if sub_str in freq:\n                    freq[sub_str] += 1\n                else:\n                    freq[sub_str] = 1\n                \n        max_freq = 0\n        \n        for sub_str, cnt in list(freq.items()):\n            max_freq = max(max_freq, cnt)\n            \n        return max_freq\n", "from collections import defaultdict\nfrom collections import Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = defaultdict(int)\n        for i in range(len(s)):\n            for j in range(i + minSize - 1, min(i + maxSize, len(s))):\n                sub = s[i:j + 1]\n                if len(set(sub)) <= maxLetters:\n                    dic[sub] += 1\n        if len(dic):\n            return max(dic.values())\n        else:\n            return 0", "from collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrFreq = defaultdict(int)\n        charFreq = defaultdict(int)\n        curr_substr = []\n        \n        l = 0\n        r = l + minSize - 1\n        \n        while l < len(s):\n            for ch in s[l:r]:\n                curr_substr.append(ch)\n                charFreq[ch] += 1\n                \n            while (r - l + 1) <= maxSize and r < len(s):\n                charFreq[s[r]] += 1\n                curr_substr.append(s[r])\n                \n                if len(charFreq) <= maxLetters:\n                    # print(curr_substr)\n                    substrFreq[''.join(curr_substr)] += 1\n\n                r += 1\n                \n            curr_substr = []\n            charFreq = defaultdict(int)\n            l += 1\n            r = l + minSize - 1\n        \n        mval = 0\n        mstr = None\n        for s, v in substrFreq.items():\n            if v > mval:\n                mstr = s\n                mval = v\n        \n        return mval", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # sliding window\n        res = collections.Counter()\n        n = len(s)\n        size = minSize\n        while size <= maxSize:\n            M = collections.defaultdict(int)\n            for i, c in enumerate(s):\n                if i < size:\n                    M[c] += 1\n                    continue\n\n                if len(M) <= maxLetters:\n                    res[s[i-size:i]] += 1\n                \n                # slide the window\n                M[s[i-size]] -= 1\n                if M[s[i-size]] == 0:\n                    del M[s[i-size]]\n                M[c] += 1\n            # check for last one\n            if len(M) <= maxLetters:\n                res[s[n-size:]] += 1\n            \n            size += 1\n        \n        # print(res.most_common(1))\n        ans = res.most_common(1)\n        if not ans:\n            return 0\n        else:\n            return ans[0][1]\n        \n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # brute force this damn thing\n        \n        # 1. all substrings\n        freq = defaultdict(int)\n        best = 0\n        for l in range(minSize, maxSize+1):\n            for i in range(len(s)-l+1):\n                ss = s[i:i+l]\n                # print('substring', ss)\n                if len(set(ss)) <= maxLetters:\n                    freq[ss] += 1\n                    best = max(best, freq[ss])\n\n        # print(freq)\n        return best", "class Solution:\n    def findSubstring(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> str:\n        len_s = len(s)\n        \n        substrings = {}\n        for i in range(len_s):\n            for j in range(i+minSize, i+maxSize+1):\n                if j > len_s:\n                    break\n                substring = s[i:j] \n                if len(set(substring)) <= maxLetters:\n                    if substring not in substrings:\n                        substrings[substring] = 0\n                    substrings[substring] += 1\n                \n                \n        return substrings\n    \n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        len_s = len(s)\n        if len_s < minSize:\n            return 0\n        \n        substrings = self.findSubstring(s, maxLetters, minSize, maxSize)\n        if not substrings:\n            return 0\n        return max(substrings.values())\n            \n                    \n            \n", "from collections import Counter\n\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = Counter()\n        \n        for k in range(minSize, maxSize + 1):\n            for i in range(len(s) - k + 1):\n                substring = s[i:i + k]\n                if len(set(substring)) <= maxLetters:\n                    freq[substring] += 1\n                    \n        return max(freq.values()) if len(freq) > 0 else 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        r = 0\n        seen = Counter()\n        for i in range(minSize, maxSize+1):\n            for j in range(i, len(s)+1):\n                t = s[j-i:j]\n                if len( set(t)) <= maxLetters:\n                    # print(s[j-i:j])\n                    seen[t] += 1\n                    if seen[t] > r:\n                        r = seen[t]\n        return r", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n\n        count = collections.Counter(s[i:i + minSize] for i in range(len(s) - minSize + 1))\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\n        '''\n        If a string have occurrences x times,\nany of its substring must appear at least x times.\n\nThere must be a substring of length minSize, that has the most occurrences.\nSo that we just need to count the occurrences of all substring with length minSize.'''", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        max_freq = 0\n        for l in range(minSize,maxSize+1):\n            hmap = {}\n            for i in range(len(s)-l+1):\n                if len(set(s[i:i+l])) <= maxLetters:\n                    if s[i:i+l] in list(hmap.keys()):\n                        hmap[s[i:i+l]] += 1\n                    else:\n                        hmap[s[i:i+l]] = 1\n            if list(hmap.keys()):\n                max_freq = max(max_freq,max(list(hmap.items()),key=lambda kv: kv[1])[1])\n        return max_freq\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        occ, n = collections.defaultdict(int), len(s)\n        for i in range(n):\n            for j in range(i + minSize - 1, min(i+maxSize, n)):\n                sub = s[i:j+1]\n                if len(set(sub)) <= maxLetters:\n                    occ[sub] += 1\n        return max(occ.values(), default = 0)", "class Solution:\n    def maxFreq(self, s: str, m: int, n: int, ss: int) -> int:\n        def getSubStrings(maxLetters:int, minSize: int, maxSize:int):\n            for i in range(len(s)):\n                for j in range(i+minSize, len(s) + 1):\n                    if j - i > maxSize:\n                        break\n                    sub = s[i:j]\n                    if len(set(sub)) <= maxLetters:\n                        yield sub\n        \n        counter = collections.defaultdict(int)\n        ret = 0\n        for substring in getSubStrings(m, n, ss):\n            counter[substring] += 1\n            ret = max(ret, counter[substring])\n        return ret\n", "class Solution:\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    \n    toSearch={}\n    for size in range(minSize,maxSize+1):\n      for i in range(len(s)-size+1):\n        S=s[i:i+size]\n        letters=len(set(S))\n        if letters<=maxLetters:\n          if S in toSearch: toSearch[S]+=1\n          else: toSearch[S]=1\n    #print(toSearch)\n    ans=0\n    for e in toSearch:\n      ans=max(ans,toSearch[e])\n    return ans\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        cnt=collections.Counter()\n        for size in range(minSize, maxSize+1):\n            for i in range(len(s)-size+1):\n                sub=s[i:i+size]\n                if len(set(sub))<=maxLetters:\n                    cnt[sub]+=1\n        return max(cnt.values() )   if cnt else 0          \n                    \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        occ, n = {} , len(s)\n        \n        for i in range(n):\n            for j in range(i + minSize - 1, min(i + maxSize, n)):\n                sub = s[i:j + 1]\n                if len(set(sub)) <= maxLetters:\n                    occ[sub] = occ.get(sub,0) +1\n                    \n        return(max(list(occ.values()) or [0]))\n#         ans = list(occ.values())\n#         ans.sort(reverse=True)\n        \n#         return(ans[0] if ans else 0)\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        counts = dict()\n        \n        for i in range(minSize, maxSize+1):\n            for j in range(i, len(s)+1):\n                curr = s[j-i:j]\n                if curr not in counts:\n                    if len(set(curr)) <= maxLetters:\n                        counts[curr] = 1\n                else:\n                    counts[curr] += 1                    \n        \n        if not counts:\n            return 0\n        else:\n            return max(counts.values())\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        possible = dict()\n        for winSize in range(minSize, maxSize + 1):\n            for winI in range(len(s) - winSize + 1):\n                win = s[winI: winI + winSize]\n                letters = set(win)\n                if len(letters) <= maxLetters:\n                    if win in possible:\n                        possible[win] += 1\n                    else:\n                        possible[win] = 1\n        # print(possible)\n        if possible:\n            return max(possible.values())\n        else:\n            return 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        lookup = {}\n        \n        for size in range(minSize, maxSize + 1):\n            for i in range(0, len(s) - size + 1):\n                sub_s = s[i:i+size]\n                if len(set(sub_s)) <= maxLetters:\n                    if sub_s not in lookup:\n                        lookup[sub_s] = 0\n                    lookup[sub_s] += 1\n                \n        if not lookup:\n            return 0\n\n        return max(lookup.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # brute force this damn thing\n        \n        # 1. all substrings\n        # if it works with greater than minSize, then must work with exactly minSize\n        freq = defaultdict(int)\n        best = 0\n        for i in range(len(s)-minSize+1):\n            ss = s[i:i+minSize]\n            # print('substring', ss)\n            if len(set(ss)) <= maxLetters:\n                freq[ss] += 1\n                best = max(best, freq[ss])\n\n        # print(freq)\n        return best", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        \n        count = defaultdict(int)\n        \n        for size in range(minSize, maxSize+1):\n            \n            for i in range(0, len(s)-size+1):\n                \n                st = s[i:size+i]\n                \n                if len(set(st)) <= maxLetters:\n                    count[st] += 1\n        \n        if len(count) == 0:\n            return 0\n        return max(count.values())\n                \n                \n                    \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        SUB_LEN = len(s)\n        cache = defaultdict(int)\n        for start in range(SUB_LEN):\n            \n            for end in range(start + minSize-1, min(start + maxSize, SUB_LEN)):\n                \n                substring = s[start:end+1]\n                \n               \n                if len(set(substring)) <= maxLetters:\n                    \n                    cache[substring] += 1 \n        #print(cache.values())\n        return max(cache.values()) if cache else 0\n                    \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        \n        # find subs that satisifes rules\n        found = collections.defaultdict(int)\n        for sl in range(minSize, min(len(s),maxSize)+1):\n            for start_index in range(len(s)-sl + 1):\n                substring = s[start_index:start_index+sl]\n                if len(set(substring)) <= maxLetters:\n                    found[substring] += 1\n                    \n        vals = sorted(found.values())\n        if len(vals) == 0: return 0\n        return vals[-1]\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        results = 0\n        for l in range(minSize,maxSize+1):\n            if l<=n:\n                maps = {}\n                for i in range(n-l+1):\n                    subs = s[i:i+l]\n                    if len(set(subs))<=maxLetters:\n                        try:\n                            maps[subs] += 1\n                            if maps[subs]>results:\n                                results = maps[subs]\n                        except KeyError:\n                            maps[subs] = 1\n                            if maps[subs]>results:\n                                results = maps[subs]\n        return results\n", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrings = []\n        for size in range(minSize, maxSize + 1):\n            for i in range(len(s)-size+1):\n                if len(set(s[i:i+size])) <= maxLetters:\n                    substrings.append(s[i:i+size])\n        return collections.Counter(substrings).most_common(1)[0][1] if substrings else 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        all_substrings = {}\n        for i in range(minSize, maxSize + 1):\n            for j in range(len(s) - i + 1):\n                ss = s[j:j+i]\n                if len(set(ss)) <= maxLetters:\n                    if ss not in all_substrings:\n                        all_substrings[ss] = 0\n                    all_substrings[ss] += 1\n        if len(all_substrings) > 0:\n            return max(all_substrings.values())\n        else:\n            return 0", "from collections import defaultdict\nfrom collections import Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = defaultdict(int)\n        for i in range(0, len(s) - minSize + 1):\n            for j in range(minSize, maxSize + 1):\n                if i + j > len(s):\n                    break\n                cur_str = s[i:i+j]\n                unique_letters = set(cur_str)\n                if len(unique_letters) > maxLetters:\n                    continue\n                else:\n                    dic[cur_str] += 1\n        if len(dic) > 0:\n            return max(dic.values())\n        else:\n            return 0", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        counter = collections.defaultdict(int)\n        for ln in range(minSize,maxSize+1):\n            for i in range(0,len(s)-ln+1):\n                sub = s[i:i+ln]\n                if len(set(sub))<=maxLetters:\n                    counter[sub] += 1\n        count = [item[1] for item in counter.items()]\n                       \n        return max(count) if count else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        i = 0\n        lst = []\n        while i < len(s):\n            for j in range(minSize, maxSize+1):\n                subs = s[i:i+j]\n                \n                # check the num of char\n                # c = collections.Counter(subs)\n                # for char in c:\n                #     if c[char] > maxLetters:\n                #         continue\n                sc = set(subs)\n                if len(sc) > maxLetters:\n                    continue\n                if len(subs)>= minSize and len(subs)<=maxSize and i+j<=len(s):\n                    lst.append(subs)\n            i+=1\n\n        # check the number of occurence of each subs\n        c = collections.Counter(lst)\n        maxs = 0\n        for subs2 in c:\n            maxs = max(c[subs2], maxs)\n            \n        return maxs\n            \n        \n        \n\n                \n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, a: int, b: int) -> int:\n        cnt = collections.defaultdict(int)\n        for i in range(len(s)-a+1):\n            cnt[s[i:i+a]]+=1\n        for a, v in sorted(cnt.items(), key = lambda x:x[1], reverse=True):\n            if len(set(a))<=maxLetters:return v\n        return 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        res, occ = 0, collections.defaultdict(int)\n        \n        for r in range(len(s) - minSize + 1):\n            \n            sub = s[r:r+minSize]\n            \n            if len(set(sub)) <= maxLetters:\n                \n                occ[sub] += 1\n                res = max(res, occ[sub])\n                \n        return(res)", "from collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        d = defaultdict(int)\n        n = len(s)\n        \n        for i in range(n):\n            # (i + minSize - 1, min(i + maxSize, n))\n            for j in range(i+minSize-1, min(i+maxSize, n)):\n                # print(s[i:j])\n                if len(set(s[i:j+1])) <= maxLetters:\n                    d[s[i:j+1]]+=1\n        # print(d)\n        if d:\n            return max(d.values())\n        return 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n#         minSize <= size <= maxSize\n#         uniqu <= maxLetters\n        \n#         loop from 3 to 4\n#         aab abcaab\n        \n#         aaba\n#         to find number of uniques, find the len of the set\n        \n#         TIME: O(SN^2)\n#         SPACE: O(N)\n#         abcde length = 5\n#               size = 3\n        \n#         abcde\n\n        ans = 0\n        counter = collections.Counter()\n        \n        for size in range(minSize, maxSize+1):\n            for j in range(len(s)-size+1):\n                substring = s[j:j+size]\n                if len(set(substring)) <= maxLetters:\n                    counter[substring]+=1\n                    ans = max(ans,counter[substring])\n#                     count = 1\n#                     for k in range(j+1, len(s)-size+1):\n#                         if substring == s[k:k+size]: count += 1\n#                     ans = max(ans,count)\n        return ans\n                    \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        all_substrings = {}\n        max_letters = maxLetters\n        min_size = minSize\n        max_size = maxSize\n        _s = s\n        max = 0\n        for i in range(min_size, max_size + 1):\n            for j in range(len(_s) - i + 1):\n                ss = _s[j:j+i]\n                if len(set(ss)) <= max_letters:\n                    if ss not in all_substrings:\n                        all_substrings[ss] = 0\n                    all_substrings[ss] += 1\n                    if all_substrings[ss] > max:\n                        max = all_substrings[ss]\n        return max", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n\n        cnt = Counter()\n        # for size in range(minSize, minSize+1):\n        # size = minSize\n        # for i in range(len(s)-size+1):\n        #     ss = s[i:i+size]\n        #     if len(set(ss)) <= maxLetters:\n        #         cnt[ss]+=1\n        # return max(cnt.values()) if cnt else 0\n    \n    \n    \n        # sliding window\n        res = collections.Counter()\n        size = minSize\n        while size <= maxSize:\n            for i in range(len(s)-size+1):\n                ss = s[i:i+size]\n                if len(set(ss)) <= maxLetters:\n                    res[ss] += 1\n            size += 1\n            \n        return max(res.values()) if res else 0\n", "class Solution:\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\n        if minSize > len(s):\n            return 0\n            \n        words = {}\n        for size in range(minSize, maxSize + 1):\n            left = 0\n            right = size - 1\n            while right < len(s):\n                word = s[left:right + 1]\n                if len(set(word)) <= maxLetters:\n                    if word not in words:\n                        words[word] = 0\n                    words[word] += 1\n                left += 1\n                right += 1\n        \n        maxOccurences = 0\n        for word in words:\n            maxOccurences = max(maxOccurences, words[word])\n        \n        return maxOccurences", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # k = minSize\n        # count = collections.Counter(s[i:i + k] for i in range(len(s) - k + 1))\n        # return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\n        cnt = Counter()\n        for size in range(minSize, maxSize+1):\n            for i in range(len(s)-size+1):\n                ss = s[i:i+size]\n                if len(set(ss)) <= maxLetters:\n                    cnt[ss]+=1\n        return max(cnt.values()) if cnt else 0\n    \n    \n    \n        # sliding window\n#         res = collections.Counter()\n#         n = len(s)\n#         size = minSize\n#         while size <= maxSize:\n#             M = collections.defaultdict(int)\n#             for i, c in enumerate(s):\n#                 if i < size:\n#                     M[c] += 1\n#                     continue\n\n#                 if len(M) <= maxLetters:\n#                     res[s[i-size:i]] += 1\n                \n#                 # slide the window\n#                 M[s[i-size]] -= 1\n#                 if M[s[i-size]] == 0:\n#                     del M[s[i-size]]\n#                 M[c] += 1\n#             # check for last one\n#             if len(M) <= maxLetters:\n#                 res[s[n-size:]] += 1\n            \n#             size += 1\n        \n#         # print(res.most_common(1))\n#         ans = res.most_common(1)\n#         if not ans:\n#             return 0\n#         else:\n#             return ans[0][1]\n", "from collections import defaultdict\nfrom collections import Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = defaultdict(int)\n        for i in range(0, len(s) - minSize + 1):\n            for j in range(minSize, maxSize + 1):\n                if i + j > len(s):\n                    break\n                cur_str = s[i:i+j]\n\n                unique_letters = set(cur_str)\n                if len(unique_letters) > maxLetters:\n                    continue\n                else:\n                    dic[cur_str] += 1\n\n\n        res = 0\n        for s in dic:\n            res = max(res, dic[s])\n        return res", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        maxOccurrences = 0\n        substrings = dict()\n        \n        for i in range(minSize, maxSize + 1):\n            \n            for j in range(len(s)):\n                \n                if i + j <= len(s):\n                    \n                    current = s[j:j+i]\n                    \n                    if len(set(current)) <= maxLetters:\n                        \n                        if current in substrings:\n                            \n                            substrings[current] += 1\n                        \n                        else:\n                            \n                            substrings[current] = 1\n                    \n                        if substrings[current] > maxOccurrences:\n                            \n                            maxOccurrences = substrings[current]\n                            \n                            \n        \n        return maxOccurrences", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        \n        dict = {}\n        for i in range(len(s)):\n            for j in range(i+minSize, i+maxSize+1):\n                # check if substr already in dict\n                if j <= len(s):\n                    substr = s[i:j]\n                    if len(set(substr)) <= maxLetters:\n                        if substr in dict:\n                            dict[substr] += 1\n                        else:\n                            dict[substr] = 1\n\n        # count max value of dict\n        max_count = 0\n        for k,v in list(dict.items()):\n            max_count = max(max_count, v)\n\n        return max_count\n        \n        \n        # brute force - TLE\n#         max_count = 0\n\n#         for i in range(len(s)):\n#             for j in range(i+minSize, i+maxSize+1):\n#                 if j < len(s):\n#                     substr = s[i:j]\n#                     # print(\\\"checking substr: \\\", substr)\n#                     # valid substring length\n#                     if len(set(substr)) <= maxLetters:\n#                         # checking first condition\n#                         # do the function\n#                         cc = self.count(substr, s, maxLetters)\n#                         max_count = max(max_count, cc)\n\n#         return max_count\n\n\n#     def count(self, substr, s, maxLetters):\n#         # print(\\\"\\\")\n#         # print(\\\"substr passed: \\\", substr)\n\n#         # return the countOcurrences\n#         count_times = 0\n#         j = len(substr)\n\n#         for i in range(len(s)-j+1):\n#             # print(\\\"comparing with s[i:i+j]: \\\", s[i:i+j])\n#             if s[i:i+j] == substr:\n#                 count_times += 1\n\n#         return count_times\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if len(s)<minSize:\n            return 0\n        if minSize>maxSize:\n            return 0\n        \n        res=0\n        d={}\n        \n        for i in range(len(s)-minSize+1):\n            temp=s[i:i+minSize]\n            if len(set(temp))<=maxLetters:\n                d[temp]=d.get(temp,0)+1\n                res=max(res,d[temp])\n        return res\n        \n        '''\n        res=0\n        for i in range(minSize,maxSize+1):\n            #print(\\\"a\\\")\n            r=[]\n            for j in range(i,len(s)+1):\n                #print(s[j-minSize:j])\n                a=s[j-minSize:j]\n                \n                if len(set(list(a)))<=maxLetters:\n                #print(set(list(a)))\n                    r.append(a)\n            #print(r)\n            if len(r)!=0:\n                r1 = max(set(r), key = r.count) \n            #print(r.count(r1))\n                r2=r.count(r1)\n                res=max(res,r2)\n        return res\n        '''", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = collections.defaultdict(int)\n        max_freq = 0\n        for win in range(minSize, maxSize+1):\n            for i in range(len(s) - win + 1):\n                sub_seq = s[i:i+win]\n                if len(set(sub_seq)) <= maxLetters:\n                    freq[sub_seq] += 1\n            max_freq = max(max_freq, max(freq.values()) if freq else 0)\n        return max_freq", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        max_occ = 0\n        \n        D = {}\n        for i in range(len(s)):\n            for j in range(i+minSize,i+maxSize+1):\n                if j <= len(s):\n                    s_s = s[i:j]\n                else:\n                    continue\n                # print(s_s)\n                # print(set(s_s))\n\n                if len(set(s_s)) <= maxLetters:\n                    # print(s_s)\n                    if s_s in D.keys():\n                        D[s_s] +=1\n                    else:\n                        D[s_s] = 1\n                    max_occ = max(D[s_s], max_occ)\n        return max_occ", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # sliding window, subtract left, if == 0, delete from dict (sliding caterpillar)\n        currDct = {}\n        ansDct = defaultdict(int)\n        length = len(s)\n        l = 0; r = 0\n        # init to min size; caterpillar sliding window\n        while l + minSize < length+1:\n            # expand to min\n            currDct = Counter(s[l:l+minSize])\n            if len(currDct) <= maxLetters:\n                ansDct[s[l:l+minSize]] += 1\n            else: l += 1; continue\n            # expand to maxSize\n            if minSize == maxSize: l += 1; continue\n            r = l + minSize + 1;\n            while r < length and r < l + maxSize:\n                # add to the right\n                currDct[s[r]] += 1\n                # del to the left\n                currDct[s[l]] -= 1\n                if currDct[s[l]] == 0: del currDct[s[l]]\n                if len(currDct) <= maxLetters:\n                    ansDct[s[l:r+1]] += 1\n                r += 1\n            l += 1\n        # print(ansDct)\n        return 0 if not ansDct else max(ansDct.values())", "import operator\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        freq=collections.defaultdict(int)\n        \n        for size in range(minSize, maxSize + 1):\n            \n            j = size\n            window = s[0:size]\n            \n            while j <= len(s):\n                \n                if len(set(window)) <= maxLetters:\n                    freq[window] += 1\n                \n                j += 1\n                window = s[j - size:j]\n                                \n        if freq:\n            return max(freq.values())\n        else:\n            return 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        counter = dict()\n        n = len(s)\n        for i in range(n-minSize+1):\n            for j in range(i+minSize-1, i+maxSize):\n                if j>=n:\n                    break\n                if len(set(s[i:j+1]))<=maxLetters:\n                    counter[s[i:j+1]] = counter.get(s[i:j+1], 0) + 1\n                    \n        # print(counter)\n        if list(counter.values())==[]: return 0\n        return max(counter.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        d = {}\n        for i in range(n):\n            for j in range(minSize, maxSize+1):\n                if i+j> n:\n                    break\n                if len(set(s[i:i+j])) <= maxLetters:\n                    d[ s[i:i+j] ] = d.get(s[i:i+j],0) +1\n        # print(d)\n        return max(list(d.values()), default=0)\n                       \n                       \n", "from collections import defaultdict\nfrom collections import Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = defaultdict(int)\n        for i in range(0, len(s) - minSize + 1):\n            for j in range(minSize, maxSize + 1):\n                if i + j > len(s):\n                    break\n                cur_str = s[i:i+j]\n                unique_letters = set(cur_str)\n                if len(unique_letters) > maxLetters:\n                    continue\n                else:\n                    dic[cur_str] += 1\n\n        res = 0\n        for s in dic:\n            res = max(res, dic[s])\n        return res", "import operator\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        freq=collections.defaultdict(int)\n        \n        for size in range(minSize, maxSize + 1):\n            \n            j = size\n            window = s[0:size]\n            \n            while j <= len(s):\n                \n                if len(set(window)) <= maxLetters:\n                    freq[window] += 1\n                \n                j += 1\n                window = s[j - size:j]\n                                \n        if freq:\n            return max(freq.items(), key=operator.itemgetter(1))[1]\n        else:\n            return 0", "from collections import Counter\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrings = {}\n        for i in range(len(s)-minSize+1):\n            sub = s[i:i+minSize]\n            if sub in substrings:\n                substrings[sub] += 1\n            else:\n                if len(Counter(sub)) <= maxLetters:\n                    substrings[sub] = 1\n        if len(substrings):\n            return max(substrings.values())\n        else:\n            return 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = 0\n        ht = collections.Counter()\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                substring = s[i:j]\n                length = len(substring)\n                if length >= minSize and length <= maxSize and len(set(substring)) <= maxLetters:\n                    ht[substring]+=1\n                elif length > maxSize:\n                    break\n                    \n        return max(v for k,v in ht.items()) if ht else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrings = dict()\n        for i in range(minSize - 1, maxSize):\n            for j in range(i,len(s)):\n                if len(set(s[j-i: j + 1])) <= maxLetters:\n                    substrings[s[j-i: j + 1]] = substrings.get(s[j-i:j + 1], 0) + 1\n        return max(substrings.values()) if len(substrings) else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        seen = collections.defaultdict(int)\n        n = len(s)\n        for k in range(minSize,maxSize+1):\n            counts = collections.Counter(s[:k])\n            if len(counts) <= maxLetters:\n                seen[s[:k]] += 1\n            for i in range(n-k):\n                counts[s[i]] -= 1\n                if counts[s[i]] == 0:\n                    del counts[s[i]]\n                counts[s[i+k]] += 1\n                if len(counts) <= maxLetters:\n                    seen[s[i+1:i+k+1]] += 1\n        return max(seen.values()) if len(seen) > 0 else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substrings = collections.defaultdict(int)\n        for k in range(minSize,maxSize+1):\n            for i in range(len(s)-k+1):\n                substrings[s[i:i+k]]+=1\n        maxCount = 0\n        for k,v in list(substrings.items()):\n            if(len(set(k))<=maxLetters):\n                maxCount=max(maxCount,v)\n        return maxCount\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        occurence = {}\n        \n        for i in range(len(s)):\n            for j in range(minSize,maxSize+1):\n                if i+j > len(s): \n                    break\n                if len(set(s[i:i+j])) <= maxLetters:\n                    if s[i:i+j] not in occurence:\n                        occurence[s[i:i+j]] = 0\n                    occurence[s[i:i+j]]+=1\n        # print(occurence)\n        if len(occurence) == 0:\n            return 0\n        return max(occurence.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        i=numUnique=0; N=len(s); count=collections.defaultdict(int); seen=collections.defaultdict(int)\n        ans=0\n        \n        for i in range(N):\n            count=collections.defaultdict(int)\n            numUnique=0\n            power=1\n            hash=0\n            for j in range(i,min(i+26,N)):\n                count[s[j]]+=1\n                if count[s[j]]==1:\n                    numUnique+=1\n                \n                add=(ord(s[j])-ord('a')+1)*(27**power)\n                hash+=add\n                power+=1\n                \n                if numUnique>maxLetters or j-i+1>maxSize:\n                    break\n                \n                if minSize<=j-i+1<=maxSize and numUnique<=maxLetters:\n                    # have a valid subs\n                    # print(s[i:j+1], hash)\n                    seen[hash]+=1\n                    ans=max(ans,seen[hash])\n        \n        return ans\n                \n                \n                \n                \n        # for j in range(N):\n            \n        \n#         for j in range(N):\n#             if count[s[j]]==0:\n#                 numUnique+=1\n                \n#             count[s[j]]+=1\n            \n#             while j-i+1>maxSize or numUnique>maxLetters:\n#                 count[s[i]]-=1\n#                 if count[s[i]]==0:\n#                     numUnique-=1\n#                 i+=1\n                \n#             if j-i+1>=minSize:\n#                 # we finally have a valid substring\n#                 for k in range(i,j+1):\n#                     curr=\\\"\\\"\n#                     for l in range(k,j+1):\n#                         curr+=s[l]\n#                         if len(curr)>=minSize:\n#                             seen[curr]+1=26\n                        \n#                 subs=s[i:j+1]\n#                 seen[subs]+=1\n#                 ans=max(ans,seen[subs])\n        \n#         print(seen)\n#         return ans\n                \n                \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if len(s) < minSize:\n            return 0\n        res = 0\n        \n        def is_good(ss):\n            return len(set(ss)) <= maxLetters\n        \n        for sz in range(minSize, maxSize + 1):\n            cnt = collections.defaultdict(int)\n            \n            for i in range(len(s) - sz + 1):\n                if is_good(s[i:i+sz]):\n                    cnt[s[i:i+sz]] += 1\n                    res = max(res, cnt[s[i:i+sz]])\n            #print(sz, cnt)\n        return res\n                \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        store = collections.defaultdict(int)\n \n        for i in range(0, len(s) - minSize+ 1): \n            \n            for j in range(0, maxSize-minSize + 1): \n                if (i+j+minSize) > len(s):\n                    break\n                subS = s[i: i+ minSize + j] \n            \n                checkSize = set(subS)\n                \n                if len(checkSize) <= maxLetters:\n                    store[subS] += 1 \n        \n        maxNum = 0\n \n        for key, val in store.items():\n            if val > maxNum:\n                maxNum = val\n               \n        return maxNum", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        \n        count = defaultdict(int)\n        \n        for size in range(minSize, maxSize+1):\n            \n            # key = [0]*26\n            q = deque()\n            for i in range(0, len(s)):\n                \n                # if i < size-1:\n                # key[ord(s[i])-97] += 1\n                q.append(s[i])\n                \n\n                if i > size-1:\n                    q.popleft()\n                \n                if (i >= size-1) and len(set(q)) <= maxLetters:\n                    # print(tuple(key))\n                    count[tuple(q)] += 1\n        \n        if len(count) == 0:\n            return 0\n        return max(count.values())\n                \n                \n                    \n            \n", "# O(n) time and space\n# Only need minSize, if string S with size N > minSize has frequency F, then the substring of S must also have frequency F\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        ans = 0\n        str_freq = collections.Counter()\n        \n        for i in range(len(s)-minSize+1):\n            candidate = s[i:i+minSize]\n            \n            if len(set(candidate)) <= maxLetters:\n                str_freq[candidate] += 1\n                ans = max(ans, str_freq[candidate])\n                \n        return ans", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        dic = collections.defaultdict(int)\n        res = 0\n        for i in range(n):\n            for j in range(i+ minSize - 1,min(i+maxSize,n)):\n                temp = s[i:j+1]\n                if len(set(temp)) <= maxLetters:\n                    dic[temp] += 1\n                    res = max(res,dic[temp])\n        return res", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        l = len(s)\n        ans = 0\n        for i in range(minSize,maxSize+1):\n            mp=collections.defaultdict(int)\n            for j in range(l-i+1):\n                cc = collections.defaultdict(int)\n                sub = s[j:j+i]\n                if len(set(sub))<=maxLetters:\n                    mp[sub]+=1\n    \n            if len(mp.keys())>0:\n                ans=max(max(mp.values()),ans)\n        return ans", "from collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = defaultdict(int)\n        for size in range(minSize, maxSize+1):\n            for i in range(len(s)-size+1):\n                substring = s[i:i+size]\n                if len(set(substring)) <= maxLetters:\n                    count[substring] += 1\n        if count:\n            return max(count.values())      \n        return 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if not s or len(s) < minSize:\n            return 0\n        gMax = -1\n        while minSize <= maxSize:\n            start = 0\n            end = minSize - 1\n            freqMap = {}\n            lMax = 0\n            while end < len(s):\n                sub = s[start:end + 1]\n                # print(sub, self.checkUnique(sub))\n                if sub in freqMap or self.checkUnique(sub, maxLetters):\n                    if sub not in freqMap:\n                        freqMap[sub] = 1\n                    else:\n                        freqMap[sub] += 1\n                    if freqMap[sub] > lMax:\n                        lMax = freqMap[sub]\n                start += 1\n                end += 1\n            # print(lMax, gMax, minSize)\n            if lMax > gMax:\n                gMax = lMax   \n            minSize += 1\n            \n        return gMax\n                        \n                \n                \n    def checkUnique(self, string, maxLetters):\n        sett = set(string)\n        if len(sett) > maxLetters:\n            return False\n        else:\n            return True\n                \n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dict = {}\n        left, right = 0, minSize\n        while left < len(s):\n            while right - left <= maxSize and right <= len(s):\n                sub = s[left:right]\n                if sub in dict:\n                    dict[sub] += 1\n                elif self.isUniqueAmount(sub, maxLetters):\n                    dict[sub] = 1\n\n                right += 1\n            \n            left += 1\n            right = left + minSize\n        \n        retValue = 0\n        for k, v in list(dict.items()):\n            retValue = max(retValue, v)\n        \n        return retValue\n    \n    def isUniqueAmount(self, s: str, maxLetters: int) -> bool:\n        return len(set(s)) <= maxLetters \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        onetime = False\n        if minSize == maxSize:\n            onetime = True\n            \n        valid_candidates = {}\n        maxoccurrences = 0\n        \n        def check_candidates(test):\n            nonlocal maxoccurrences\n            \n            if len(set(test)) <= maxLetters:\n                valid_candidates[test] = valid_candidates.get(test, 0) + 1\n                maxoccurrences = max(maxoccurrences, valid_candidates[test])\n                \n        #find all possible substrings\n        for i in range(len(s)):\n            for j in range(minSize, maxSize+1):\n                if i + j <= len(s):\n                    check_candidates(s[i:i+j])\n        \n        return maxoccurrences", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dict = {}\n        left, right = 0, minSize\n        while left < len(s):\n            while right - left <= maxSize and right <= len(s):\n                sub = s[left:right]\n                if self.isUniqueAmount(sub, maxLetters):\n                    self.addToDict(sub, dict)\n                right += 1\n            \n            left += 1\n            right = left + minSize\n        \n        retValue = 0\n        for k, v in list(dict.items()):\n            retValue = max(retValue, v)\n        \n        return retValue\n    \n    def addToDict(self, sub: str, dict: {}) -> None:\n        if sub not in dict:\n            dict[sub] = 0\n        dict[sub] += 1\n    \n    def isUniqueAmount(self, s: str, maxLetters: int) -> bool:\n        return len(set(s)) <= maxLetters \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        cnt = Counter()\n        for sz in range(minSize, min(maxSize, len(s)) + 1):\n            cur = Counter(s[:sz])\n            if len(cur) <= maxLetters:\n                cnt[s[:sz]] += 1\n            for i in range(1, len(s) - sz + 1):\n                # print(s[i:i+sz], s[i+sz-1])\n                cur[s[i+sz-1]] += 1\n                cur[s[i-1]] -= 1\n                if cur[s[i-1]] == 0:\n                    cur.pop(s[i-1])\n                if len(cur) <= maxLetters:\n                    cnt[s[i:i+sz]] += 1\n        return max(cnt.values()) if cnt else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        validStrings = {}\n        for currSize in range(minSize, maxSize+1):\n            self.getValidString(currSize, s, maxLetters, validStrings)\n        return self.getMaxCount(validStrings)\n        \n    def getValidString(self,currSize, s, maxLetters, validStrings):\n        left = 0\n        right = 0\n        currWindow = {}\n        uniqueCounts = 0\n        for right in range(currSize):\n            uniqueCounts = self.insert(s[right],currWindow, uniqueCounts)\n        self.insertValidString(uniqueCounts,maxLetters, left, right, s, validStrings )\n        while right < len(s)-1:\n            uniqueCounts = self.insert(s[right+1],currWindow, uniqueCounts)\n            uniqueCounts = self.remove(s[left],currWindow, uniqueCounts)\n            left += 1\n            right += 1\n            self.insertValidString(uniqueCounts,maxLetters, left, right, s, validStrings )\n            \n    def insert(self,char,currWindow, uniqueCounts):\n        if char not in currWindow:\n            currWindow[char] = 1\n            uniqueCounts += 1\n        else:\n            currWindow[char] += 1\n        return uniqueCounts\n    \n    def remove(self,char,currWindow, uniqueCounts):\n        currWindow[char] -= 1\n        if currWindow[char] == 0:\n            del currWindow[char]\n            uniqueCounts -= 1\n        return uniqueCounts\n    \n    def getMaxCount(self,validStrings):\n        maxCount = 0\n        for string in validStrings:\n            if validStrings[string] > maxCount:\n                maxCount = validStrings[string]\n        return maxCount\n    \n    \n    def insertValidString(self,uniqueCounts,maxLetters, left, right, s, validStrings ):\n        if uniqueCounts <= maxLetters:\n            currWord = s[left:right+1]\n            if currWord not in validStrings:\n                validStrings[currWord] = 1\n            else:\n                validStrings[currWord] += 1", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        substr = collections.Counter()\n        counter = [collections.Counter(s[:minSize])]\n        if len(counter[-1]) <= maxLetters:\n            substr[s[:minSize]] += 1\n        for i in range(1, maxSize - minSize + 1):\n            counter.append(collections.Counter(counter[-1]))\n            counter[-1][s[minSize + i - 1]] += 1\n            if len(counter[-1]) <= maxLetters:\n                substr[s[:minSize + i]] += 1\n        # print(counter)\n        # print(substr)\n        for i in range(minSize, n):\n            l = i - minSize\n            for j, cnt in enumerate(counter):\n                r = i + j\n                if r >= n:\n                    break\n                cnt[s[l]] -= 1\n                cnt[s[r]] += 1\n                if cnt[s[l]] == 0:\n                    cnt.pop(s[l])\n                if len(cnt) <= maxLetters:\n                    substr[s[l + 1: r + 1]] += 1\n        #     print(counter)\n        # print(substr)\n        return max(substr.values(), default=0)", "class Solution:        \n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if len(s) == len(set(s)):\n            return 0\n        from collections import defaultdict\n        corpus = defaultdict(int)\n        \n        for i in range(minSize, maxSize+1):\n            for j in range(len(s) - i + 1):\n                if len(set(s[j:j+i])) <= maxLetters:\n                    corpus[s[j:j+i]] += 1\n        \n        if len(corpus) == 0:\n            return 0\n        \n        return max(corpus.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        count = 0\n        diff = maxSize-minSize\n        hashM = {}\n        maxC = float('-inf')\n        \n        for r in range(len(s)-minSize+1):\n            \n            for i in range(diff+1):\n                \n                if r + minSize + i <= len(s):\n                    if len(set(s[r:r+minSize+i])) <= maxLetters:\n\n                        hashM[s[r:r+minSize+i]] = hashM.get(s[r:r+minSize+i], 0) + 1\n                        maxC = max(maxC, hashM[s[r:r+minSize+i]])\n                        \n        return(maxC if maxC != float('-inf') else 0)\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n                \n        counts = {} # string -> number \n        \n        for current_size in range(minSize, maxSize + 1): \n            window = {}\n            for i in range(current_size): \n                c = s[i]\n                window[c] = window.get(c, 0) + 1 \n\n            for i in range(current_size, len(s) + 1):\n                start = i - current_size\n                if len(window) <= maxLetters: \n                    sub = s[start:i]\n                    counts[sub] = counts.get(sub, 0) + 1 \n                if i == len(s): \n                    break\n                    \n                # add current \n                c = s[i]\n                window[c] = window.get(c, 0) + 1 \n                # remove tail\n                c = s[start]\n                window[c] -= 1 \n                if window[c] == 0:\n                    del window[c]\n\n        # print(counts)\n        return max(counts.values()) if len(counts) else 0 \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        lookup = {}\n        \n        for size in range(minSize, maxSize + 1):\n            for i in range(0, len(s) - size + 1):\n                sub_s = s[i:i+size]\n                if len(set(sub_s)) <= maxLetters:\n                    if sub_s not in lookup:\n                        lookup[sub_s] = 0\n                    lookup[sub_s] += 1\n                \n        if not lookup:\n            return 0\n\n        return max(lookup.values()) ", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n       \n        start = 0\n        end = 0\n        sub = {}\n        result = {}\n        self.max_size = 0\n        \n        def add_sub(pos):\n            if s[pos] in sub:\n                sub[s[pos]] +=1\n            else:\n                sub[s[pos]] = 1\n        \n        def rem_sub(pos):\n            if s[pos] in sub:\n                if sub[s[pos]] == 1:\n                    del sub[s[pos]]\n                else:\n                    sub[s[pos]] -= 1\n        def add_res(string):\n            if string in result:\n                result[string] +=1\n            else:\n                result[string] = 1\n            self.max_size = max(self.max_size,result[string])\n        \n        for size in range(minSize,maxSize+1):\n            while start <= len(s)-size:\n                if (end-start)+1 < size:\n                    add_sub(end)\n                    end +=1\n                else:\n                    add_sub(end)\n                    if len(sub) <= maxLetters:\n                        add_res(s[start:end+1])\n                    rem_sub(start)\n                    start +=1\n                    end +=1\n            start = 0\n            end = 0\n            sub = {}\n            \n        return self.max_size\n        \n        \n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        my_dict = {}\n        for i in range(len(s)-minSize+1):\n            if len(set(s[i:i+minSize]))<=maxLetters:\n                if s[i:i+minSize] in my_dict:\n                    my_dict[s[i:i+minSize]] += 1\n                else:\n                    my_dict[s[i:i+minSize]] = 1\n        # print(my_dict)\n        k = minSize+1\n        if minSize!=maxSize:\n            while(maxSize>=k):\n                for i in range(len(s)-k+1):\n                    if len(set(s[i:i+k]))<=maxLetters:\n                        if s[i:i+k] in my_dict:\n                            my_dict[s[i:i+k]] += 1\n                        else:\n                            my_dict[s[i:i+k]] = 1\n                # print(my_dict)\n                k+=1\n        return max(my_dict.values()) if my_dict else 0\n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = Counter()\n        for k in range(minSize, maxSize + 1):\n            window = Counter(s[:k])\n            if len(window) <= maxLetters:\n                count[s[:k]] += 1\n            for i in range(k, len(s)):\n                window[s[i]] += 1\n                window[s[i - k]] -= 1\n                if window[s[i - k]] == 0:\n                    del window[s[i - k]]\n                if len(window) <= maxLetters:\n                    count[s[i - k + 1:i + 1]] += 1\n        return max(list(count.values()), default=0)\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        wordCounter = collections.defaultdict()\n        \n        # loop (maxSize - minSize)+1 times\n        for i in range((maxSize - minSize)+1):\n            charCounter = collections.Counter(s[:minSize+i])\n            if len(charCounter) <= maxLetters:\n                    wordCounter[s[:minSize+i]] = 1\n           \n            for j in range(minSize+i, len(s)):\n                charCounter[s[j-minSize-i]] -= 1\n                \n                if charCounter[s[j-minSize-i]] <= 0:\n                    del charCounter[s[j-minSize-i]]\n    \n                charCounter[s[j]] += 1\n                if len(charCounter) <= maxLetters:\n                    if s[j-minSize-i+1:j+1] in wordCounter:\n                        wordCounter[s[j-minSize-i+1:j+1]] += 1\n                    else:\n                        wordCounter[s[j-minSize-i+1:j+1]] = 1\n      \n        maxTimes = 0\n        for subString in wordCounter:\n            maxTimes = max(wordCounter[subString], maxTimes)\n        return maxTimes", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        res_dict = collections.defaultdict(int)\n        \n        for lidx in range(n-minSize+1):\n            lval = lidx+minSize\n            rval = min(n,lidx+maxSize+1)\n            for ridx in range(lval, 1+rval):\n                counts = collections.Counter(s[lidx:ridx])\n                if len(counts) <= maxLetters:\n                    res_dict[s[lidx:ridx]] += 1\n                else: \n                    break\n        \n        return max(res_dict.values()) if res_dict else 0", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        # for each substring of length, find unique chars\n        maxC = Counter()\n        ans = 0\n        for sz in range(minSize, maxSize+1):\n            unq = Counter()\n            for i in range(sz):\n                unq[s[i]] += 1\n                \n            if (len(unq) <= maxLetters): \n                maxC[s[0:sz]] += 1\n                if(maxC[s[0:sz]] > ans): ans=maxC[s[0:sz]]\n            \n            i, j = 0, sz - 1\n            while (j < len(s) - 1):\n                unq[s[i]] -= 1\n                if (unq[s[i]] == 0): del unq[s[i]]\n                \n                i+=1\n                j+=1\n                \n                unq[s[j]] += 1\n                \n                if (len(unq) <= maxLetters): \n                    maxC[s[i:j+1]] += 1\n                    if(maxC[s[i:j+1]] > ans): ans=maxC[s[i:j+1]]\n\n        return ans", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n\n        subset_d = {}\n\n        for i in range(minSize, maxSize + 1):\n            for j in range(0, len(s) - i + 1):\n                substr = s[j:j + i]\n                subset_d[substr] = subset_d.get(substr, 0) + 1\n                \n        max_occur = 0\n        for substr, val in list(subset_d.items()):\n            temp_s = set(list(substr))\n            \n            if val > max_occur and len(temp_s) <= maxLetters:\n                max_occur = val\n                \n        return max_occur\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        lenS = len(s)\n        \n        #for counting uniq chars :\n        uniqSubStrDict = {}   \n        \n        #for i,char in enumerate(s):\n        #    uniqDict[char] = i                         \n        count = 0\n        # edge casses:\n    \n        # main alg.\n        Max = 0;\n        for i in range(minSize,maxSize + 1):\n            for j in range(lenS - i + 1) : # maxSize):\n                \n                tstSubStr = s[j : j + i]\n                uniqChars = {}\n                for k in tstSubStr:\n                    uniqChars[k] = 1 #uniqChars.get(k,0) + 1\n                    \n                if len(uniqChars) > maxLetters:\n                    #print(' in over maxLetters loop -- tstSubStr = {} '.format(tstSubStr))\n                    continue\n                    \n                #print(' tstSubStr = {} '.format(tstSubStr))\n                uniqSubStrDict[tstSubStr] = uniqSubStrDict.get(tstSubStr,0) + 1\n                #print(' dict count = {} '.format(uniqSubStrDict[tstSubStr]))\n                \n                if uniqSubStrDict[tstSubStr] > Max :\n                    Max = uniqSubStrDict[tstSubStr]\n                    \n        count = Max\n        #count = uniqSubStrDict[tstSubStr]\n                \n        return count", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dict = {}\n        left, right = 0, minSize\n        while left < len(s):\n            while right - left <= maxSize and right <= len(s):\n                sub = s[left:right]\n                if self.isSize(sub, minSize, maxSize) and self.isUniqueAmount(sub, maxLetters):\n                    self.addToDict(sub, dict)\n                right += 1\n            \n            left += 1\n            right = left + minSize\n        \n        retValue = 0\n        for k, v in list(dict.items()):\n            retValue = max(retValue, v)\n        \n        return retValue\n    \n    def addToDict(self, sub: str, dict: {}) -> None:\n        if sub not in dict:\n            dict[sub] = 0\n        dict[sub] += 1\n    \n    def isSize(self, s: str, minSize: int, maxSize: int) -> bool:\n        length = len(s)\n        return minSize <= length and maxSize >= length\n    \n    def isUniqueAmount(self, s: str, maxLetters: int) -> bool:\n        return len(set(s)) <= maxLetters \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        newDict = {}\n        \n        for j in range(len(s) - minSize + 1):\n            word = s[j:j+minSize]\n            \n            if word in newDict:\n                newDict[word] += 1\n                \n            else:\n                if len(collections.Counter(word)) <= maxLetters:\n                    newDict[word] = 1\n                    \n        return max(newDict.values()) if len(newDict) != 0 else 0\n        \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = {}\n        for i in range(0, len(s)-minSize+1):\n            sub = s[i:i+minSize]\n            chars = set()\n            for c in sub:\n                chars.add(c)\n            if len(chars)<=maxLetters:\n                if sub not in freq: freq[sub] = 0\n                freq[sub] += 1\n        best = 0\n        for sub in freq:\n            if freq[sub] > best:\n                best = freq[sub]\n        return best", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        #close the window, + 1\n        \n        \n        hashmap = {}\n        occ = {}\n        for i in range(len(s)):\n            hashmap[s[i]] = hashmap.get(s[i], 0) + 1\n            \n            \n            if i>=minSize:\n                #remove the first\n                hashmap[s[i-minSize]] -=1\n                if hashmap[s[i-minSize]] == 0:\n                    del hashmap[s[i-minSize]]\n            if i >= minSize -1:\n                if len(hashmap) <= maxLetters:\n                    substring = s[i-minSize+1: i+1]\n                    occ[substring] = occ.get(substring, 0) + 1 \n        \n        if len(occ) == 0:\n            return 0\n        return max(occ.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        candidates = collections.Counter()\n        \n        for i in range(len(s)-minSize+1):\n            if len(set(list(s[i:i+minSize])))<=maxLetters:\n                candidates[s[i:i+minSize]] += 1\n        \n        return max(list(candidates.values())+[0])\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = collections.Counter(s[i:i+minSize] for i in range(len(s)-minSize+1))\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] +[0])", "class Solution:\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    counter = collections.defaultdict(int)\n    mapping = collections.defaultdict(int)\n    if len(s) < minSize:\n      return 0\n    count = 0\n    for i in range(minSize):\n      mapping[s[i]] += 1\n      if mapping[s[i]] == 1:\n        count += 1\n    if count <= maxLetters:\n      counter[s[0:minSize]] += 1\n    for i in range(1, len(s) - minSize+1):\n      mapping[s[i-1]] -= 1\n      if mapping[s[i-1]] == 0:\n        count -= 1\n      mapping[s[i+minSize-1]] += 1\n      if mapping[s[i+minSize-1]] == 1:\n        count += 1\n      # print(s[i:i+minSize])\n      if count <= maxLetters:\n        counter[s[i:i+minSize]] += 1\n    # print(counter)\n    if not counter:\n      return 0\n    return max(counter.values())\n        \n        \n", "class Solution:\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\n        \n        result = 0\n        subStringFreq = collections.defaultdict(int)\n        window = collections.defaultdict(int)\n        \n        low = 0\n        high = 0\n\n        while high < len(s):\n            window[s[high]] += 1   \n            if (high - low + 1) == minSize:\n                if len(window) <= maxLetters:  \n                    subStringFreq[s[low:high+1]] += 1\n                    result = max(result, subStringFreq[s[low:high+1]]) \n                    \n                window[s[low]] -= 1\n                if window[s[low]] == 0:\n                    del window[s[low]]\n\n                low += 1\n            high += 1 \n        return result", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        x=defaultdict(int)\n        for i in range(len(s)-minSize+1):\n            sub=s[i:i+minSize]\n            if len(set(sub))<=maxLetters:\n                x[sub]+=1\n        return max(x.values(),default=0)", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        left = 0\n        result = 0\n        count = collections.defaultdict(int)\n        occurances = collections.defaultdict(int)\n        \n        for right, char in enumerate(s):\n            count[char] += 1\n            while(right - left + 1 > minSize):\n                count[s[left]] -= 1\n                if count[s[left]] == 0:\n                    del count[s[left]]\n                left += 1\n                \n            if right - left + 1 == minSize and len(count) <= maxLetters:\n                occurances[s[left:right+1]] += 1\n                result = max(result, occurances[s[left:right+1]])\n        return result", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = collections.defaultdict(int)\n        \n        for i in range(len(s) - minSize + 1):\n            freq[s[i:i + minSize]] += 1\n        \n        mx = 0\n\n        for key in freq:\n            if len(set(key)) <= maxLetters and mx < freq[key]:\n                mx = freq[key]\n            \n        return mx", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        l = 0\n        r = 0\n        strMap = collections.defaultdict(int)\n        curr = ''\n        currMap = collections.defaultdict(int)\n        while r < len(s):\n            char = s[r]\n            currMap[char] += 1\n            curr += char\n            while len(currMap) > maxLetters or len(curr) > minSize:\n                curr = curr[1:]\n                currMap[s[l]] -= 1\n                if currMap[s[l]] == 0:\n                    del currMap[s[l]]\n                l += 1\n            if len(curr) == minSize:\n                strMap[curr] += 1\n            r += 1\n        return max(strMap.values()) if strMap else 0\n", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        subCt = defaultdict(int)\n        currS = defaultdict(int)\n        mx = 0\n        l = 0\n        r = 0\n        \n       \n        while l < len(s) - minSize:\n            length = r - l + 1\n           \n            if length > minSize:\n                currS[s[l]] -= 1\n                if currS[s[l]] <= 0:\n                    del currS[s[l]]\n                    \n                l += 1\n                \n#             c = (r == len(s) - 1) and (l < len(s) - minSize)\n           \n#             if c:\n#                 currS[s[l]] -= 1\n#                 if currS[s[l]] <= 0:\n#                     del currS[s[l]]\n                    \n#                 l += 1\n            \n            currC = s[r]\n            currS[currC] += 1\n            \n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\n            if condition:\n                sub = s[l:r+1]\n                subCt[sub] += 1\n                \n                if subCt[sub] > mx:\n                    mx = subCt[sub]\n            \n            if r < len(s) - 1:\n                r += 1\n            \n        return mx\n            \n", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        subCt = defaultdict(int)\n        currS = defaultdict(int)\n        mx = 0\n        l = 0\n        r = 0\n        \n       \n        while l < len(s) - minSize:\n            length = r - l + 1\n           \n            if length > minSize:\n                currS[s[l]] -= 1\n                if currS[s[l]] <= 0:\n                    del currS[s[l]]\n                    \n                l += 1\n            \n            currC = s[r]\n            currS[currC] += 1\n            \n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\n            if condition:\n                sub = s[l:r+1]\n                subCt[sub] += 1\n                \n                if subCt[sub] > mx:\n                    mx = subCt[sub]\n            \n            if r < len(s) - 1:\n                r += 1\n            \n        return mx\n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if not s:\n            return 0\n        \n        n = len(s)\n        substring_count = defaultdict(int)\n        \n        memo_char = defaultdict(int)\n        reader = 0\n        writer = 0\n        \n        while reader < len(s):\n            ch = s[reader]\n            memo_char[ch] += 1\n            window_len = reader - writer +1\n            \n            while len(memo_char) > maxLetters or window_len > minSize:\n                wch = s[writer]\n                memo_char[wch] -= 1\n                \n                if memo_char[wch] == 0:\n                    del memo_char[wch]\n                \n                writer += 1\n                window_len = reader - writer +1\n            if window_len >= minSize and window_len <= maxSize:\n                substring_count[tuple(s[writer:reader+1])] += 1\n                #print (s[writer:reader+1], substring_count, window_len)\n            reader += 1\n            \n        if not substring_count:\n            return 0\n        \n        return max(substring_count.values())\n        \n        \n", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        subCt = defaultdict(int)\n        currS = defaultdict(int)\n        mx = 0\n        l = 0\n        r = 0\n        \n       \n        while l < len(s) - minSize:\n            length = r - l + 1\n           \n            if length > minSize:\n                currS[s[l]] -= 1\n                if currS[s[l]] <= 0:\n                    del currS[s[l]]\n                    \n                l += 1\n                \n            c = (r == len(s) - 1) and (l < len(s) - minSize)\n           \n            if c:\n                currS[s[l]] -= 1\n                if currS[s[l]] <= 0:\n                    del currS[s[l]]\n                    \n                l += 1\n            \n            currC = s[r]\n            currS[currC] += 1\n            \n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\n            if condition:\n                sub = s[l:r+1]\n                subCt[sub] += 1\n                \n                if subCt[sub] > mx:\n                    mx = subCt[sub]\n            \n            if r < len(s) - 1:\n                r += 1\n            \n        return mx\n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        l = 0\n        r = 0\n        strMap = collections.defaultdict(int)\n        curr = ''\n        currMap = collections.defaultdict(int)\n        unique = 0\n        while r < len(s):\n            char = s[r]\n            if currMap[char] == 0:\n                unique += 1\n            currMap[char] += 1\n            curr += char\n            while unique > maxLetters or len(curr) > minSize:\n                curr = curr[1:]\n                currMap[s[l]] -= 1\n                if currMap[s[l]] == 0:\n                    unique -= 1\n                l += 1\n            print(curr)\n            if len(curr) >= minSize:\n                strMap[curr] += 1\n            r += 1\n        return max(list(strMap.values()) or (0,0))\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = {}\n        for i in range(len(s)-minSize+1):\n            s1 = s[i:i+minSize]\n            unique = {}\n            for c in s1:\n                if c not in unique:\n                    unique[c] = 1\n            if len(unique) <= maxLetters:\n                if s1 in dic:\n                    dic[s1] += 1\n                else:\n                    dic[s1] = 1\n                if i != len(s)-minSize and minSize != maxSize:\n                    s2 = s[i:i+maxSize]\n                    if s2[-1] not in unique:\n                        unique[s2[-1]] = 1\n                    if len(unique) <= maxLetters:\n                        if s2 in dic:\n                            dic[s2] += 1\n                        else:\n                            dic[s2] = 1\n        max_occr = 0\n        for key in dic:\n            if dic[key] > max_occr:\n                max_occr = dic[key]\n        return max_occr", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # actually don't need to go up to maxSize since if\n        # a string of maxSize has an occurence, then any substring\n        # has at least an equal number of occurences\n\n        seen = collections.defaultdict(int)\n        n = len(s)\n        counts = collections.Counter(s[:minSize])\n        if len(counts) <= maxLetters:\n            seen[s[:minSize]] += 1\n        for i in range(n-minSize):\n            counts[s[i]] -= 1\n            if counts[s[i]] == 0:\n                del counts[s[i]]\n            counts[s[i+minSize]] += 1\n            if len(counts) <= maxLetters:\n                seen[s[i+1:i+minSize+1]] += 1\n        return max(seen.values()) if len(seen) > 0 else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        strcount = Counter()\n        unique = set(s[:minSize])\n        front = 0\n        back = minSize\n\n        while back < len(s):\n            if len(unique) <= maxLetters:\n                strcount[s[front:back]] = strcount.get(s[front:back], 0) + 1\n            front+=1\n            back+=1\n            unique = set(s[front:back])\n        if len(unique) <= maxLetters:\n            strcount[s[front : back]] = strcount.get(s[front : back], 0) + 1\n\n        return max(list(strcount.values()) or [0])\n", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = defaultdict(int)\n        d = defaultdict(int)\n        max_freq = 0\n        for idx, a in enumerate(s):\n            count[a] += 1\n            if idx > minSize - 1:\n                last = s[idx - minSize]\n                count[last] -= 1\n                if count[last] == 0:\n                    del count[last]\n            \n            if idx >= minSize - 1:\n                if len(count) <= maxLetters:\n                    d[s[idx-minSize+1: idx+1]] += 1\n                    max_freq = max(max_freq, d[s[idx-minSize+1: idx+1]])\n        \n        return max_freq\n                \n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = 0\n        left = 0\n        right = minSize-1\n        d = {}\n        length = len(s)\n        unique_let = {}\n        def popLetter(letter, n):\n            unique_let[letter] -= 1\n            if unique_let[letter] == 0:\n                n -= 1\n            return n\n        def addLetter(letter, n):\n            if unique_let.get(letter, 0) == 0:\n                n += 1\n            unique_let[letter] = unique_let.get(letter,0) + 1\n            return n\n        for letter in s[:minSize-1]:\n            n = addLetter(letter, n)\n        print(n)\n        print(unique_let)\n        while right < length:\n            if left > 0:\n                n = popLetter(s[left-1], n)\n            n = addLetter(s[right], n)\n            print(n)\n            if n <= maxLetters:\n                d[s[left:right+1]] = d.get(s[left:right+1], 0) + 1\n            right += 1\n            left += 1\n        print(d)\n        if not d.values():\n            return 0\n        return max(d.values())", "import operator\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        lp = 0\n        rp = lp + minSize\n        perm_dict= {}\n        for i in range(len(s)-minSize+1):\n            temp = s[lp:rp]\n            if len(set(temp))<=maxLetters:\n                if temp not in list(perm_dict.keys()):\n                    perm_dict[temp]=1\n                else:\n                    perm_dict[temp]+=1\n            i+=1\n            lp+=1\n            rp+=1\n        print(perm_dict)\n        perm_dict = dict(sorted(list(perm_dict.items()), key=operator.itemgetter(1),reverse=True))\n        if len(list(perm_dict.keys()))>0:\n            return perm_dict[list(perm_dict.keys())[0]]\n        return 0\n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        s0 = s[:minSize]\n        counter = collections.Counter(s0)\n        substr = collections.Counter()\n        if len(counter) <= maxLetters:\n            substr[s0] += 1\n        for i in range(minSize, n):\n            l = i - minSize\n            counter[s[i - minSize]] -= 1\n            counter[s[i]] += 1\n            if counter[s[i - minSize]] == 0:\n                counter.pop(s[i - minSize])\n            if len(counter) <= maxLetters:\n                substr[s[i - minSize + 1: i + 1]] += 1\n        return max(substr.values(), default=0)", "class Solution:\n    def maxFreq(self, S, maxchars, minsize, maxsize):\n        n=len(S)\n        freq=Counter()\n        chars=Counter()\n        i=0\n        for j in range(n):\n            if j-i+1>minsize:\n                chars[S[i]]-=1\n                if chars[S[i]]==0:\n                    del chars[S[i]]\n                i+=1\n            chars[S[j]]+=1\n            if j-i+1>=minsize:\n                if len(chars)<=maxchars:\n                    freq[S[i:j+1]]+=1\n        return max(freq.values(),default=0)", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        i=0\n        j=0\n        map1={}\n        res={}\n        while j<len(s):\n            map1[s[j]]=map1.get(s[j],0)+1\n            if len(map1.keys())>maxLetters:\n                map1[s[i]]=map1[s[i]]-1\n                if map1[s[i]]==0:\n                    del map1[s[i]]\n                i+=1\n            while len(map1.keys())<=maxLetters and j-i+1<=maxSize and j-i+1>=minSize:\n                #add to result first\n                res[s[i:j+1]]=res.get(s[i:j+1],0)+1\n                \n                #remove the existing s[i]'s value from map\n                \n                map1[s[i]]=map1[s[i]]-1\n                if map1[s[i]]==0:\n                    del map1[s[i]]\n                \n                #move i=i+1\n                i=i+1\n            j=j+1\n        if len(res)==0:\n            return 0\n        else:\n            maximum = max(res, key=res.get)\n            return res[maximum]", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        subCt = defaultdict(int)\n        currS = defaultdict(int)\n        mx = 0\n        l = 0\n        r = 0\n        \n       \n        while l < len(s) - minSize:\n            length = r - l + 1\n           \n            if length > minSize:\n                currS[s[l]] -= 1\n                if currS[s[l]] <= 0:\n                    del currS[s[l]]\n                    \n                l += 1\n                \n            c = (r == len(s) - 1) and (l < len(s) - minSize)\n           \n            if c:\n                print('eer')\n                currS[s[l]] -= 1\n                if currS[s[l]] <= 0:\n                    del currS[s[l]]\n                    \n                l += 1\n            \n            currC = s[r]\n            currS[currC] += 1\n            \n            condition =  (r - l + 1) >= minSize and len(list(currS.keys())) <= maxLetters\n            if condition:\n                sub = s[l:r+1]\n                print(sub)\n                subCt[sub] += 1\n                \n                if subCt[sub] > mx:\n                    mx = subCt[sub]\n            \n            if r < len(s) - 1:\n                r += 1\n            \n        return mx\n            \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if len(s) == 0:\n            return 0\n        rolling_hash = 0\n        letter_counts = collections.Counter()\n        hash_counts = collections.Counter()\n        unique_letters = set()\n        n = len(s)\n        \n        for i in range(n):\n            ch = s[i]\n            \n            rolling_hash = rolling_hash * 26 + ord(ch)\n            letter_counts[ch] += 1\n            unique_letters.add(ch)\n            \n            if i + 1 < minSize:\n                continue\n            \n            if len(unique_letters) <= maxLetters:\n                hash_counts[rolling_hash] += 1\n                \n            remove_letter = s[i - minSize + 1]\n            rolling_hash -= (ord(remove_letter)) * 26**(minSize-1)\n            letter_counts[remove_letter] -= 1\n            \n            if letter_counts[remove_letter] == 0:\n                unique_letters.remove(remove_letter)\n        return max(hash_counts.values()) if len(hash_counts) else 0 ", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n\n        count = collections.Counter(s[i:i + minSize] for i in range(len(s) - minSize + 1))\n        return max([count[w] for w in count if len(set(w)) <= maxLetters] + [0])\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        window_start = 0\n        window_letters = Counter()\n        \n        substring_counts = Counter()\n        \n        for window_end in range(len(s)):\n            window_letters[s[window_end]] += 1\n            substring_len = window_end-window_start+1\n            \n            while substring_len > maxSize or len(window_letters) > maxLetters:\n                start_char = s[window_start]\n                window_letters[start_char] -= 1\n                if window_letters[start_char] == 0:\n                    del window_letters[start_char]\n                window_start += 1\n                substring_len = window_end-window_start+1\n            \n            while substring_len >= minSize:\n                assert substring_len <= maxSize\n                substring = s[window_start:window_end+1]\n                substring_counts[substring] += 1\n                \n                start_char = s[window_start]\n                window_letters[start_char] -= 1\n                if window_letters[start_char] == 0:\n                    del window_letters[start_char]\n                window_start += 1\n                substring_len = window_end-window_start+1\n        print(substring_counts)\n        if not substring_counts:\n            return 0\n        return max(substring_counts.values())\n            \n            \n                \n", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        # for each substring of length, find unique chars\n        maxC = Counter()\n        ans = 0\n        sz = minSize\n        unq = Counter()\n        for i in range(sz):\n            unq[s[i]] += 1\n\n        if (len(unq) <= maxLetters): \n            maxC[s[0:sz]] += 1\n            if(maxC[s[0:sz]] > ans): ans=maxC[s[0:sz]]\n\n        i, j = 0, sz - 1\n        while (j < len(s) - 1):\n            unq[s[i]] -= 1\n            if (unq[s[i]] == 0): del unq[s[i]]\n\n            i+=1\n            j+=1\n\n            unq[s[j]] += 1\n\n            if (len(unq) <= maxLetters): \n                maxC[s[i:j+1]] += 1\n                if(maxC[s[i:j+1]] > ans): ans=maxC[s[i:j+1]]\n\n        return ans", "class Solution:\n    def maxFreq(self, s: str, maxy: int, m: int, mm: int) -> int:\n        \n        i,j = 0,0\n        count = collections.Counter()\n        count[s[0]]+=1\n        ans = collections.Counter()\n        u, n = 1, len(s)\n        \n        key = s[0]\n        \n        while True:\n            if u<=maxy and m<=i-j+1<=mm: \n                ans[key]+=1\n            \n            if j<i and i-j+1>=m:\n                count[s[j]]-=1\n                if count[s[j]]==0: u-=1\n                j+=1\n                key = key[1:]\n            else:\n                i+=1\n                if i == n: break\n                if count[s[i]]==0: u+=1\n                count[s[i]]+=1\n                key+=s[i]\n            \n        return max(ans.values()) if ans else 0", "class Solution:\n    def maxFreq(self, s: str, maxy: int, m: int, mm: int) -> int:\n        \n        i,j = 0,0\n        count = collections.Counter()\n        count[s[0]]+=1\n        ans = collections.Counter()\n        u = 1\n        n = len(s)\n        while True:\n            # print(f'j-{j}, i-{i}, u-{u}, ans-{ans}')\n            if u<=maxy and m<=i-j+1<=mm: \n                # print('Found!-',j,i,s[j:i+1])\n                ans[s[j:i+1]]+=1\n            \n            if j<i and i-j+1>=m:\n                count[s[j]]-=1\n                if count[s[j]]==0: u-=1\n                j+=1\n            else:\n                i+=1\n                if i == n: break\n                if count[s[i]]==0: u+=1\n                count[s[i]]+=1\n        print(ans)\n        return max(ans.values()) if ans else 0", "from collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if not s or len(s) < minSize: return 0\n        res = defaultdict(int)\n        res[''] = 0\n        temp = defaultdict(int)\n    \n        i = 0\n        j = minSize-1\n\n        for k in range(minSize):\n            temp[s[k]] += 1\n        \n        if len(temp.keys()) <= maxLetters:\n                res[s[i:j+1]] += 1\n            \n        while i < len(s)-minSize:\n            temp[s[i]] -= 1\n            i += 1\n            j += 1\n            temp[s[j]] += 1\n            if len([l for l in temp if temp[l]]) <= maxLetters:\n                res[s[i:j+1]] += 1\n        \n        return max(res.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        from collections import defaultdict, Counter\n        d = defaultdict(int)\n        for i in range(len(s)-minSize+1):\n            t = s[i:i+minSize]\n            if len(Counter(t)) <= maxLetters:\n                d[t] += 1\n        return max(d.values()) if d else 0\n", "from collections import Counter, defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        d = defaultdict(int)\n        for i in range(len(s)-minSize+1):\n            sub = s[i:i+minSize]\n            if len(Counter(sub)) <= maxLetters:\n                d[sub] += 1\n        return max(d.values()) if len(list(d.values())) else 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = {}\n        for i in range(len(s) - minSize + 1):\n            word = s[i: i+minSize]\n            if word in count:\n                count[word] += 1\n            else:\n                if len(set(word)) <= maxLetters:\n                    count[word] = 1\n        return max(count.values()) if count else 0", "from collections import Counter\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        i = 0\n        j = 0\n        letterCounts = Counter()\n        substrCounts = Counter()\n        \n        while j < len(s):\n            letterCounts[s[j]] += 1\n\n            while len(letterCounts) > maxLetters or j - i + 1 > minSize:\n                letterCounts[s[i]] -= 1\n                if letterCounts[s[i]] == 0:\n                    del letterCounts[s[i]]\n                i += 1\n            \n            if j - i + 1 == minSize:\n                substrCounts[s[i:j + 1]] += 1\n            \n            j += 1\n        \n        return 0 if len(substrCounts) == 0 else max(substrCounts.values())", "'''\nuniq<=max\nlen(sub)>=min and <=max\n'''\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        hash,w_hash,res={},{},float('-inf')\n        self.initial_fill(s,minSize,hash)\n        for i in range(0,len(s)-minSize+1):\n            if len(hash)<=maxLetters:\n                string=s[i:i+minSize]\n                w_hash[string]=1 if string not in w_hash else w_hash[string]+1\n                res=max(res,w_hash[string])\n            char=s[i]\n            if hash[char]==1: del hash[char]\n            else: hash[char]-=1\n            if i+minSize<len(s):\n                char=s[i+minSize]\n                hash[char]=1 if char not in hash else hash[char]+1\n        return res if res!=float('-inf') else 0\n                \n            \n    \n    def initial_fill(self,s,Min,hash):\n        for i in range(0,Min):\n            char=s[i]\n            hash[char]=1 if char not in hash else hash[char]+1", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        left=0\n        right=0\n        _dict=defaultdict(int)\n        _dict2=defaultdict(int)\n     \n        while right<len(s):\n            _dict[s[right]]+=1\n           \n        \n            while len(_dict)>maxLetters or right-left+1>maxSize or right-left+1>minSize:\n                _dict[s[left]]-=1\n                if _dict[s[left]]==0:\n                    del(_dict[s[left]])\n                left+=1\n            if  len(_dict)<=maxLetters and minSize<=right-left+1<=maxSize :\n                    _dict2[s[left:right+1]]+=1                      \n                \n            right+=1\n          \n        if len(_dict2)==0:\n            return 0\n      \n        return max(_dict2.values())\n        \n                \n", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        dic = collections.defaultdict(int)\n        for i in range(len(s) - minSize + 1):\n            if len(collections.Counter(s[i:i + minSize])) <= maxLetters:\n                dic[s[i:i + minSize]] += 1\n        if not dic:\n            return 0\n        return max(dic.values())\n", "from collections import defaultdict, Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        def hasUnique(s):\n            dic = Counter(s)\n            if(len(dic) <= maxLetters):\n                return True\n            return False\n        \n        def checkSubStrings(s):\n            dic = defaultdict(int)\n            maximum = 0\n            for i in range(0, len(s) - minSize + 1):\n                end = i + minSize\n                strr = s[i:end]\n                if(hasUnique(strr)):\n                    dic[strr] += 1\n                    maximum = max(maximum,  dic[strr])\n                        \n            return maximum\n                    \n        return(checkSubStrings(s))", "from collections import defaultdict\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        cnt = defaultdict(int)\n        freq = defaultdict(int)\n        res, left = 0, 0\n        for i in range(len(s)):\n            cnt[s[i]] = cnt.get(s[i], 0) + 1\n            while len(cnt) > maxLetters or i - left + 1 > minSize:\n                cnt[s[left]] -= 1\n                if cnt[s[left]] == 0:\n                    del cnt[s[left]]\n                left += 1\n            if (i - left + 1 <= maxSize and i - left + 1 >= minSize):\n                sub = s[left: i + 1]\n                freq[sub] = freq.get(sub, 0) + 1\n        return max(freq.values()) if freq else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        memo_dict = {}\n        for i in range(len(s)):\n            for j in range(i,len(s) + 1):\n                if j - i < minSize:\n                    continue\n                if j - i > minSize:\n                    break\n                temp = []\n                temp_str = s[i:j]\n                for char in temp_str:\n                    temp.append(char)\n                if len(set(temp)) > maxLetters:\n                    continue\n                \n                if temp_str in memo_dict:\n                    memo_dict[temp_str] += 1\n                else:\n                    memo_dict[temp_str] = 1\n                    \n        if len(memo_dict) == 0: return 0            \n        res = sorted(memo_dict, key = lambda x : memo_dict[x])\n        #print(res)    \n        return memo_dict[res[-1]]\n                    \n                    \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        counterSubstring = collections.defaultdict(int)\n        best = 0\n        for start in range(len(s)):\n            #for size in range(minSize, maxSize + 1):\n            if start + minSize <= len(s):\n                substring = s[start:start + minSize]\n                counterSubstring[substring] += 1\n        \n        for substring in counterSubstring:\n            if len(set(substring)) <= maxLetters:\n                best = max(best, counterSubstring[substring])\n        \n        return best      ", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        freq = Counter()\n        for leftInd, char in enumerate(s):\n            seen = set([])\n            for rightInd in range(leftInd, leftInd + minSize):\n                if rightInd > len(s) - 1:\n                    break\n                seen.add(s[rightInd])\n                if len(seen) > maxLetters:\n                    break\n                if rightInd - leftInd + 1 >= minSize:\n                    freq[s[leftInd:rightInd + 1]] += 1\n        ret = 0\n        for key, val in freq.items():\n            ret = max(ret, val)\n        return ret", "import collections\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        max_occur = 0\n        freq_hash = {}\n        for i in range(len(s) - minSize + 1):\n            stri = s[i: i + minSize]\n            if len(collections.Counter(stri)) <= maxLetters:\n                if stri in freq_hash:\n                    freq_hash[stri] += 1\n                else:\n                    freq_hash[stri] = 1\n                max_occur = max(max_occur, freq_hash[stri])\n        return max_occur\n        # counts = dict()\n        # for j in range(len(s)-minSize+1):\n        #     word = s[j:j+minSize]\n        #     if word in counts:\n        #         counts[word]+=1\n        #     else:\n        #         if len(collections.Counter(word))<=maxLetters:\n        #             counts[word]=1\n        # return max(counts.values()) if len(counts)!=0 else 0\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        ans = 0\n        l = minSize\n        counts = {}\n        for i in range(len(s) - l + 1):\n            string = s[i:i+l]\n            c = collections.Counter(string)\n            if len(c) <= maxLetters:\n                counts[string] = counts.get(string, 0) + 1\n\n        if counts:\n            ans = max(ans, max(counts.values()))\n        \n        return ans", "from collections import Counter\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        if len(s) < minSize or maxSize == 0:\n            return 0\n        \n        start = 0\n        end = start + minSize\n        count = Counter()\n        \n        while end <= len(s):\n            unique = Counter(s[start:end])\n            \n            if len(unique) <= maxLetters:\n                count[s[start:end]] += 1\n            start += 1\n            end += 1\n        return max(count.values()) if count else 0", "from collections import Counter\nfrom collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # init first window\n        counts = defaultdict(int)\n        substrs = defaultdict(int)\n        start = 0\n        # expand window until we can't any more \n        for end in range(len(s)):\n            counts[s[end]] += 1\n            if end - start + 1 > minSize:\n                counts[s[start]] -= 1\n                if counts[s[start]] == 0:\n                    del counts[s[start]]\n                start += 1\n            print (counts)\n            if end - start + 1 == minSize and len(counts) <= maxLetters:\n                substrs[s[start:end+1]] += 1\n        print (substrs)\n        if not substrs:\n            return 0\n        return max(substrs.values())\n        \n        # decrement window until we meet the requirement\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        counter=defaultdict(int)\n        \n        for i in range(len(s)):\n            string=s[i:i+minSize]\n            if len(Counter(string))<=maxLetters and len(string)>=minSize:\n                counter[string]+=1\n        return max(counter.values()) if counter else 0", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # hash table to remember substrings\n        substrings = defaultdict(int)\n        char_counts = Counter(s[0:minSize-1])\n        \n        start = 0\n        while start <= len(s) - minSize:\n            end = start + minSize - 1\n            \n            end_char = s[end]\n            char_counts[end_char] += 1\n            \n            unique_chars = len(char_counts)\n            \n            if unique_chars <= maxLetters:\n                substrings[s[start:end+1]] += 1\n\n            start_char = s[start]\n            if char_counts[start_char] == 1:\n                del char_counts[start_char]\n            else:\n                char_counts[start_char] -= 1\n                \n            start += 1\n            \n            \n        maxSubstrings = 0\n        for substring in substrings:\n            if substrings[substring] > maxSubstrings:\n                maxSubstrings = substrings[substring]\n\n        return maxSubstrings", "class Solution:\n    from collections import Counter\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        c = 0\n        freq = collections.defaultdict(int)\n        for i in range(len(s)-minSize+1):\n            p = s[i:i+minSize]\n            cur_dict = Counter(p)\n            if len(cur_dict) <= maxLetters:\n                freq[p] += 1\n        if freq:\n            return max(freq.values())\n        return 0\n", "from collections import Counter\nfrom collections import defaultdict\n\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # init first window\n        counts = Counter(s[:minSize-1])\n        substrs = defaultdict(int)\n        start = 0\n        # expand window until we can't any more \n        for end in range(minSize-1, len(s)):\n            counts[s[end]] += 1\n            if end - start + 1 > minSize:\n                counts[s[start]] -= 1\n                start += 1\n            if end - start + 1 == minSize and len(set(counts.elements())) <= maxLetters:\n                substrs[s[start:end+1]] += 1\n        if not substrs:\n            return 0\n        return max(substrs.values())\n        \n        # decrement window until we meet the requirement\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        count = defaultdict(int)\n        m = 0\n        size = minSize\n        for i in range(len(s)-size+1):\n            word = s[i:i+size]\n            if len(Counter(word))<=maxLetters:\n                count[word]+=1\n                m = max(m,count[word])\n        return m\n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        # if not s:\n        #     return 0\n        \n        subcount = defaultdict(int)\n        \n        for i in range(len(s)-minSize+1):\n            sub = s[i:i+minSize]\n            # print(sub, set(sub))\n            if len(set(sub))<=maxLetters:\n                subcount[sub]+=1\n            # print(sub, set(sub))\n                \n        # print(subcount)\n        x = sorted(subcount.values(), reverse=True)\n        if not x:\n            return 0\n        return x[0]", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        mymap = {}\n        \n        for i in range(len(s)-minSize+1):\n            if len(set(list(s[i:i+minSize]))) <= maxLetters:\n                print(s[i:i+minSize])\n                if s[i:i+minSize] in mymap:\n                    mymap[s[i:i+minSize]] += 1\n                else:\n                    mymap[s[i:i+minSize]] = 1\n        \n        if not mymap:\n            return 0\n        \n        return max(mymap.values())", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        res = 0\n        count = Counter()\n        \n        for j in range(len(s) - minSize + 1):\n            if len(set(s[j:j+minSize])) > maxLetters:\n                continue\n            count[s[j:j+minSize]] += 1\n            res = max(res, count[s[j:j+minSize]])\n        return res", "from collections import Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \n        # test = Counter(s)\n        # print(\\\"test\\\", test)\n        cnt = Counter()\n        word_cnt = Counter()\n        cur_hash = 0\n#         for i in range(minSize):\n#             cnt[s[i]] += 1\n#             if len(cnt)>maxLetters:\n#                 break\n                \n        # word_cnt[s[:i+1]] += 1\n        # print(word_cnt)\n        left = 0\n        res = 0\n        i = 0\n        while i<len(s):\n            if i-left+1>minSize:\n                cnt[s[left]] -= 1\n                if cnt[s[left]] == 0:\n                    del cnt[s[left]]\n                left += 1\n                \n            cnt[s[i]] += 1   \n            \n            if len(cnt)<=maxLetters and i-left+1==minSize:\n                word_cnt[s[left:i+1]] += 1\n                # print(s[left:i+1])\n                res = max(res, word_cnt[s[left:i+1]])\n                \n            i += 1\n        # print(word_cnt)\n        return res\n# \\\"aababcaab\\\"\n# 2\n# 3\n# 4\n# \\\"aaaa\\\"\n# 1\n# 3\n# 3\n# \\\"aabcabcab\\\"\n# 2\n# 2\n# 3\n# \\\"abcde\\\"\n# 2\n# 3\n# 3\n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        res = collections.defaultdict(int)\n        for k in range(minSize,minSize+1):\n            counter = collections.Counter(s[:k])\n            \n            for i in range(k,len(s)):\n                #print(counter)\n                if len(counter.keys())<=maxLetters:\n                    res[s[i-k:i]] += 1\n                counter[s[i]] += 1\n                counter[s[i-k]] -= 1\n                if counter[s[i-k]] == 0:\n                    del counter[s[i-k]]\n            #print(counter)\n            \n            if len(counter.keys())<=maxLetters:\n                res[s[i-k+1:]] += 1\n        #print(res)\n        return max(res.values()) if res else 0", "from collections import Counter\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        ## greed algorithm: only focus the substring with length == minSize\n        ## also, apply continuous hashing function \n        power = 26 ** (minSize-1)\n        cnt = Counter()\n        word_cnt = Counter()\n        cur_hash = 0\n        left = 0\n        res = 0\n        right = 0\n        while right<minSize:\n            cnt[s[right]] += 1  \n            cur_hash = cur_hash*26 + (ord(s[right]) - ord('a') + 1)\n            right += 1\n            \n        word_cnt[cur_hash] = 1\n        while right<len(s):\n            if right-left+1>minSize:\n                cnt[s[left]] -= 1\n                if cnt[s[left]] == 0:\n                    del cnt[s[left]]\n                cur_hash = cur_hash-power*(ord(s[left]) - ord('a') + 1)\n                left += 1\n            \n            cnt[s[right]] += 1  \n            cur_hash = cur_hash*26 + (ord(s[right]) - ord('a') + 1)\n            \n            if len(cnt)<=maxLetters and right-left+1==minSize:\n                word_cnt[cur_hash] += 1\n                res = max(res, word_cnt[cur_hash])\n                \n            right += 1\n            \n        return res\n# \\\"aababcaab\\\"\n# 2\n# 3\n# 4\n# \\\"aaaa\\\"\n# 1\n# 3\n# 3\n# \\\"aabcabcab\\\"\n# 2\n# 2\n# 3\n# \\\"abcde\\\"\n# 2\n# 3\n# 3\n                \n", "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        tracker = collections.defaultdict(int)\n        \n        window_tracker = collections.defaultdict(int)\n        curr_sum = 0\n        \n        i = 0\n        j = 0\n        \n        while j < len(s):\n            curr = s[j]\n            window_tracker[curr] += 1\n            curr_sum += 1\n            \n            # while i < j and (len(window_tracker.keys()) > maxLetters and curr_sum > minSize):\n            while i < j and curr_sum > minSize:\n                curr_i = s[i]\n                curr_sum -= 1\n                window_tracker[curr_i] -= 1\n                if window_tracker[curr_i] == 0:\n                    del window_tracker[curr_i]\n                i += 1\n            \n            temp = collections.defaultdict(int)\n            toAdd = s[i:j + 1]\n            for char in toAdd:\n                temp[char] += 1\n            \n            if minSize <= curr_sum <= maxSize and len(temp.keys()) <= maxLetters:\n                tracker[s[i: j + 1]] += 1\n            \n            j += 1\n        \n        print(tracker)\n        if len(tracker.values()) == 0:\n            return 0\n        return max(tracker.values())", "from collections import Counter, deque\nclass Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        substring = deque([])\n        ans = Counter([])\n        for ch in s:\n            substring.append(ch)\n            while len(substring) > minSize:\n                substring.popleft()\n            cnt = Counter(substring)\n            if (len(cnt) <= maxLetters) and (minSize <= len(substring) <= maxSize):\n                ans.update({''.join(substring): 1})\n        \n        return ans.most_common()[0][1] if len(ans) > 0 else 0\n"]
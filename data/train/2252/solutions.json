["#!/usr/bin/env python3\n\"\"\"\nCreated on Wed Feb 28 11:47:12 2018\n\n@author: mikolajbinkowski\n\"\"\"\nimport sys\n\nN = int(input())\n\nstring_count = {}\nfor _ in range(N):\n    s = str(input())\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    s0 = []\n    for a in 'abcdefghijklmnopqrstuvwxyz':\n        if char_count.get(a, 0) % 2 == 1:\n            s0.append(a)\n    s1 = ''.join(s0)\n    string_count[s1] = string_count.get(s1, 0) + 1\n\npairs = 0\nfor s, v in list(string_count.items()):\n    pairs += v * (v-1) // 2\n    for i in range(len(s)):\n        pairs += v * string_count.get(s[:i] + s[i+1:], 0)\n\nprint(pairs)\n\n        \n    \n", "def main():\n    n = int(input())\n    ans = 0\n    d = {}\n    for i in range(n):\n        s = input()\n        cur = 0\n        for c in s:\n            cur ^= (1 << (ord(c) - ord('a')))\n        ans += d.get(cur, 0)\n        for j in range(26):\n            ans += d.get(cur ^ (1 << j), 0)\n        t = d.get(cur, 0) + 1\n        d[cur] = t\n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 11/20/18\n\n\n\nAfter learning a lot about space exploration, a little girl named Ana wants to change the subject.\n\nAna is a girl who loves palindromes (string that can be read the same backwards as forward).\nShe has learned how to check for a given string whether it's a palindrome or not, but soon she grew tired of this problem,\nso she came up with a more interesting one and she needs your help to solve it:\n\nYou are given an array of strings which consist of only small letters of the alphabet.\nYour task is to find how many palindrome pairs are there in the array.\nA palindrome pair is a pair of strings such that the following condition holds:\nat least one permutation of the concatenation of the two strings is a palindrome.\nIn other words, if you have two strings, let's say \"aab\" and \"abcac\",\nand you concatenate them into \"aababcac\", we have to check if there exists a permutation of this new string such that\nit is a palindrome (in this case there exists the permutation \"aabccbaa\").\n\nTwo pairs are considered different if the strings are located on different indices.\nThe pair of strings with indices (\ud835\udc56,\ud835\udc57) is considered the same as the pair (\ud835\udc57,\ud835\udc56).\n\nInput\nThe first line contains a positive integer \ud835\udc41 (1\u2264\ud835\udc41\u2264100 000), representing the length of the input array.\n\nEacg of the next \ud835\udc41 lines contains a string (consisting of lowercase English letters from 'a' to 'z') \u2014 an element of the input array.\n\nThe total number of characters in the input array will be less than 1000000.\n\nOutput\nOutput one number, representing how many palindrome pairs there are in the array.\n\n\n\n# a, b can be transform to palindrome only when number of every characters in a+b is even, or only one is odd.\n# only odd+even => odd\n\n\n\"\"\"\n\nimport collections\n\nN = int(input())\n\n\ndef hash(s):\n    wc = collections.Counter(s)\n    x = ''\n    for i in range(26):\n        w = chr(ord('a') + i)\n        c = wc[w]\n        if c % 2 == 0:\n            x += '0'\n        else:\n            x += '1'\n    \n    return x\n\n\ndef neighbor(s):\n    for i in range(len(s)):\n        yield s[:i] + ('1' if s[i] == '0' else '0') + s[i + 1:]\n\n\ndef isneighbor(a, b):\n    return sum([0 if a[i] == b[i] else 1 for i in range(len(a))]) == 1\n\nm = collections.defaultdict(list)\nfor i in range(N):\n    s = input()\n    m[hash(s)].append(i)\n\neven = 0\nodd = 0\nfor k, v in list(m.items()):\n    lv = len(v)\n    even += lv * (lv - 1) // 2\n    \n    for b in neighbor(k):\n        if b in m:\n            odd += lv * len(m[b])\n\nprint(even + odd // 2)\n\n", "from collections import Counter\n\nn = int(input())\n\nmp = Counter({'': 0})\n\nfor i in range(n):\n    string = input()\n    occ = [0] * 26\n    for c in string:\n        occ[ord(c) - ord('a')] += 1\n        if occ[ord(c) - ord('a')] == 2:\n            occ[ord(c) - ord('a')] = 0\n    clean = []\n    for idx in range(26):\n        while occ[idx] > 0:\n            clean.append(chr(idx + ord('a')))\n            occ[idx] -= 1\n\n    mp[''.join(clean)] += 1\n\nans = 0\n\n\ndef combs(n):\n    return n * (n - 1) // 2\n\n\nfor key in mp:\n    if len(key) == 1:\n        ans += combs(mp[key]) + mp[key] * mp['']\n    elif len(key) == 0:\n        ans += combs(mp[key])\n    else:\n        ans += combs(mp[key])\n        for idx in range(len(key)):\n            ans += mp[key] * mp[key[0:idx] + key[idx + 1:]]\n\nprint(ans)\n", "from collections import Counter\n\nn = int(input())\nstrings = []\n\nfor i in range(0,n):\n  counter = { x: 0 for x in range(ord('a'), ord('z')+1) }\n  napis = input()\n  for val in napis:\n    counter[ord(val)] = (counter[ord(val)] + 1) % 2\n  \n  napis = \"\"\n  for key, val in list(counter.items()):\n    if val != 0:\n      napis+=chr(key)\n  \n  strings.append(napis)\n\nc = Counter(strings)\nstrings = sorted(c.most_common(), key=lambda i: i[0])\n#print(strings)\n\ncount = 0\nfor key, val in strings:\n  if val > 1:\n    count += val*(val-1)/2\n\nfor charInt in range(ord('a'), ord('z')+1):\n  char = chr(charInt)\n  copy = {}\n  for key, val in strings:\n    if char in key:\n      copy[key.replace(char, \"\")] = copy.get(key.replace(char, \"\"), 0) + val\n  #print(copy)\n  for key, val in strings:\n    if copy.get(key,0) != 0:\n      count+=val * copy[key]\n      #print(\"pokrywa : \", key, \" \", val*copy[key])\n\nprint(int(count))\n", "n = int(input())\nstring_count = {}\nfor _ in range(n):\n    s = str(input())\n    item_count={}\n    for i,c in enumerate(s):\n        item_count[c]=item_count.get(c,0)+1\n    s0=[]\n    for i,x in enumerate('abcdefghijklmnopqrstuvwxyz'):\n        if item_count.get(x,0)%2==1:\n            s0.append(x)\n    s1 = ''.join(s0)\n    string_count[s1]=string_count.get(s1,0)+1\npoints=0\nfor j,a in enumerate(string_count):\n    x = string_count[a]\n    points+=x*(x-1)//2\n    for i in range(len(a)):\n        points+=x*string_count.get(a[:i]+a[i+1:],0)\nprint(points)", "n = int(input())\nstring_count = {}\nfor _ in range(n):\n    s = str(input())\n    item_count={}\n    for i,c in enumerate(s):\n        item_count[c]=item_count.get(c,0)+1\n    s0=[]\n    for x in 'abcdefghijklmnopqrstuvwxyz':\n        if item_count.get(x,0)%2==1:\n            s0.append(x)\n    s1 = ''.join(s0)\n    string_count[s1]=string_count.get(s1,0)+1\npoints=0\nfor a,x in string_count.items():\n    points+=x*(x-1)//2\n    for i in range(len(a)):\n        points+=x*string_count.get(a[:i]+a[i+1:],0)\nprint(points)", "n=int(input())\ns=[0]*n\nfor i in range (n):\n    s[i]=input()\ndic={}\nans=0\nfor i in range (n):\n    temp=0\n    for k in range(len(s[i])):\n        temp^=(1<<(ord(s[i][k])-ord('a')))\n    #print(temp,s[i])\n    if temp in list(dic.keys()):\n        ans=ans+dic[temp]\n    for j in range (26):\n        chk=temp\n        chk^=(1<<j)\n        if chk in list(dic.keys()):\n            ans=ans+dic[chk]\n    if temp in list(dic.keys()):\n        dic[temp]+=1\n    else:\n        dic[temp]=1\n   # print(dic[temp])\nprint(ans)\n", "aw=[2**i for i in range(26)]\nn=int(input())\nd=dict()\nans=0\nfor ir in range(n):\n    st=input()\n    es=0\n    for j in st:\n        es=es^aw[ord(j)-97]\n    if es in d:\n        ans+=d[es]\n    for j in range(26):\n        es=es^aw[j]\n        if es in d:\n            ans+=d[es]\n        es=es^aw[j]\n    if es in d:\n        d[es]+=1\n    else:\n        d.update({es:1})\nprint(ans)\n", "import sys\n\ninput = sys.stdin.readline\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return (a * b) / gcd(a, b)\n\n\n\n\ndef main():\n    comp=[]\n    c=1\n    for i in range(27):\n        comp.append(c)\n        c*=2\n    n=int(input())\n    d={}\n    table=[]\n    for i in range(n):\n        k=[0]*27\n        s=input()\n        for j in s:\n            if ord(j)-ord('a')>=0:\n                k[ord(j)-ord('a')]+=1\n            #print(ord(j)-ord('a'))\n        key=0\n        for i in range(26):\n            if k[i]%2:\n                key+=comp[i]\n        table.append([k,key])\n        if key in d:\n            d[key]+=1\n        else:\n            d[key]=1\n    ans=0\n    for i in list(d.values()):\n        ans+=(i)*(i-1)//2\n    #print(ans)\n    for i in table:\n        #print(i)\n        for j in range(len(i[0])):\n            if i[0][j]%2:\n                if i[1]-comp[j] in list(d.keys()):\n                    #print(i[1],i[1]-comp[j] )\n                    ans+=(d[i[1]-comp[j]])\n\n    print(int(ans))\n\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["class Solution:\n     def findCircleNum(self, M):\n         N = len(M)\n         students = set()\n         for i in range(N):\n             students.add(i)\n         \n         num_grp = 0\n         while students:\n             num_grp += 1\n             stack = [students.pop()]\n             while stack and students:\n                 student = stack.pop()\n                 for i in range(N):\n                     if M[student][i] == 1 and i in students:\n                         stack.append(i)\n                         students.discard(i)\n         return num_grp\n", "class Solution:\n     \n     def dfs(self, M, cur):\n         for i in range(len(M)):\n             if flag[i]:\n                 continue\n             if M[cur][i]:\n                 flag[i] = True\n                 self.dfs(M, i)\n         \n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         nonlocal flag\n         flag = [False] * len(M)\n         circle = 0\n         \n         for i in range(len(M)):\n             if flag[i]:\n                 continue\n             flag[i] = True\n             circle += 1\n             self.dfs(M, i)\n         return circle", "class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         ans=0\n         visited=[False for i in range(len(M))]\n         def dfs(M,i,visited):\n             visited[i]=True\n             for j in range(len(M)):\n                 if M[i][j]==1 and visited[j]==False:\n                     dfs(M,j,visited)\n             \n             \n             \n             \n         for i in range(len(M)):\n             if  not visited[i]:\n                 dfs(M,i,visited)\n                 ans+=1\n         return ans\n", "class Solution:\n     def findCircleNum(self, M):\n         size = len(M)\n         parents = list(range(size))\n         #print(parents)\n         res = size\n         for i in range(size):\n             for j in range(i+1,size):\n                 rooti = self.findRoot(parents,i)\n                 rootj = self.findRoot(parents,j)\n                 if rooti != rootj and M[i][j] == 1:\n                     parents[rootj] = rooti\n                     res -= 1\n         return res\n                 \n     def findRoot(self,parents, i):\n         return i if parents[i] == i else self.findRoot(parents,parents[i])", "class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         N = len(M)\n         seen = set()\n         \n         def dfs(i):\n             for j, flag in enumerate(M[i]):\n                 if flag and j not in seen:\n                     seen.add(j)\n                     dfs(j)\n                     \n         ans = 0\n         for i in range(N):\n             if i not in seen:\n                 dfs(i)\n                 ans += 1\n         return ans", "class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         n = len(M)\n         seen = set()\n         groups = 0\n         \n         for idx in range(n):\n             if idx not in seen:\n                 #print(idx)\n                 groups += 1\n                 seen.add(idx)\n                 front = {idx}\n                 while len( front ) > 0:\n                     #print(front, seen)\n                     newFront = set()\n                     for cIdx in front:\n                         for fIdx in range(n):\n                             if M[cIdx][fIdx] == 1 and fIdx not in seen:\n                                 seen.add(fIdx)\n                                 newFront.add(fIdx)\n                     front = newFront\n         return groups\n         \n         \n         \n", "class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(M)\n         table = [i for i in range(n)]\n         def find(x):\n             tmp = x\n             while table[tmp] != tmp:\n                 tmp = table[tmp]\n             table[x] = tmp\n             return tmp\n             \n         \n         def union(x, y):\n             table[find(x)] = find(y)\n         \n         for i in range(n):\n             for j in range(i+1, n):\n                 if M[i][j] == 1:\n                     union(i, j)\n         print(table)\n         return len(set(find(x) for x in range(n)))\n                 \n         \n         \n         \n", "class UnionFind(object):\n     def __init__(self, n):\n         self.parent = dict()\n         self.circles = n\n         for i in range(n):\n             self.parent[i] = i\n             \n     def find(self, s):\n         while self.parent[s] != s:\n             self.parent[s] = self.parent[self.parent[s]]\n             s = self.parent[s]\n         return s\n     \n     def union(self, s1, s2):\n         root_s1 = self.find(s1)\n         root_s2 = self.find(s2)\n         if root_s1 != root_s2:\n             self.parent[root_s2] = root_s1\n             self.circles -= 1\n         \n         \n \n class Solution:\n     \n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if M is None or len(M) == 0:\n             return 0\n         \n         n = len(M)\n         uf = UnionFind(n)\n         \n         for i in range(n):\n             for j in range(i + 1, n):\n                 if M[i][j] == 1:\n                     uf.union(i, j)\n                     \n         return uf.circles\n         ", "class Solution(object):\n \tdef findCircleNum(self, M):\n \t\tseen = set()\n \n \t\tdef dfs(n):\n \t\t\tif n in seen:\n \t\t\t\treturn\n \t\t\t# print('walk', n)\n \t\t\tseen.add(n)\n \t\t\tneighbors = [i for i,val in enumerate(M[n]) if val == 1]\n \n \t\t\tfor neighbor in neighbors:\n \t\t\t\tdfs(neighbor)\n \n \t\tcount = 0\n \t\tfor j, row in enumerate(M):\n \t\t\tfor i, item in enumerate(row):\n \t\t\t\tif j in seen or i in seen:\n \t\t\t\t\tcontinue\n \n \t\t\t\tcount += 1\n \t\t\t\t# print('start',j,i)\n \t\t\t\tdfs(i)\n \n \t\treturn count", "class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n     # dfs solution\n     #     seen = set()\n     #     rtn = 0\n     #     for i in range(len(M)):\n     #         if i not in seen:\n     #             rtn += 1\n     #             self.dfs(i, M, seen)\n     #     return rtn\n     # def dfs(self,i,M,seen):\n     #     for nei,adj in enumerate(M[i]):\n     #         if adj and nei not in seen:\n     #             seen.add(nei)\n     #             self.dfs(nei, M, seen)\n     \n         # union find solution\n         ds = DisjointSet()\n         for i in range(len(M)):\n             ds.make_set(i)\n         for i in range(len(M)):\n             for j in range(i,len(M)):\n                 if M[i][j]==1:\n                     ds.union(i,j)\n         return ds.num_sets\n \n class Node:\n     def __init__(self,data):\n         self.data=data\n         self.parent=self\n         self.rank=0\n class DisjointSet:\n     def __init__(self):\n         self.map={}\n         self.num_sets=0\n     def make_set(self,i):\n         node = Node(i)\n         self.map[i]=node\n         self.num_sets+=1\n     def union(self,i,j):\n         node1 = self.map[i]\n         node2 = self.map[j]\n         parent1 = self.find_set(node1)\n         parent2 = self.find_set(node2)\n         if parent1 == parent2:\n             return\n         if parent1.rank >= parent2.rank:\n             if parent1.rank==parent2.rank:\n                 parent1.rank+=1\n             parent2.parent=parent1\n         else:\n             parent1.parent = parent2\n         self.num_sets-=1\n     def find_set(self,node):\n         if node.parent==node:\n             return node\n         node.parent = self.find_set(node.parent)\n         return node.parent\n         ", "class Solution:\n \n     def find(self, u):\n         if self.parent[u] == u:\n             return u\n         else:\n             root_u = self.find(self.parent[u])\n             self.parent[u] = root_u\n             return self.find(self.parent[u])\n \n     def union(self, u, v):\n         parent_u = self.find(u)\n         parent_v = self.find(v)\n         self.parent[parent_u] = parent_v\n \n     def findCircleNum(self, M):\n         if len(M) == 0:\n             return 0\n         n = len(M)\n         self.parent = [i for i in range(n)]\n \n         for i in range(n):\n             for j in range(i+1, n):\n                 if M[i][j] == 1:\n                     self.union(i, j)\n         friend_set = set()\n         for i in range(n):\n             friend_set.add(self.find(i))\n \n         print(self.parent)\n         return len(friend_set)", "class UnionFind(object):\n     def __init__(self, n):\n         self.__parent = dict()\n         self.__circles = n\n         for i in range(n):\n             self.__parent[i] = i\n         \n     @property\n     def parent(self):\n         return self.__parent\n     \n     @parent.setter\n     def parent(self, key, value):\n         self.__parent[key] = val\n     \n     @property\n     def circles(self):\n         return self.__circles\n     \n     def circles_decrement(self):\n         self.__circles -= 1\n         \n         \n     def find(self, s):\n         while self.parent[s] != s:\n             self.parent[s] = self.parent[self.parent[s]]\n             s = self.parent[s]\n         return s\n     \n     def union(self, s1, s2):\n         root_s1 = self.find(s1)\n         root_s2 = self.find(s2)\n         if root_s1 != root_s2:\n             self.parent[root_s2] = root_s1\n             self.circles_decrement()\n         \n \n class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if M is None or len(M) == 0:\n             return 0\n         \n         n = len(M)\n         uf = UnionFind(n)\n         \n         for i in range(n):\n             for j in range(i + 1, n):\n                 if M[i][j] == 1:\n                     uf.union(i, j)\n                     \n         return uf.circles\n         ", "class Solution:\n     def findCircleNum(self, M):\n         \"\"\"\n         :type M: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if M == None:\n             return 0\n         \n         n = len(M)\n         map1 = [[] for x in range(n)]\n         \n         #build graph\n         for i in range(n):\n             for j in range(n):\n                 if i != j and M[i][j] == 1:\n                     if j not in map1[i]:\n                         map1[i].append(j)\n                     if i not in map1[j]:\n                         map1[j].append(i)\n                         \n         #bfs\n         queue = collections.deque()\n         hash1 = set()\n         \n         count = 0\n         for i in range(n):\n             if i not in hash1:\n                 count += 1\n                 queue.append(i)\n                 hash1.add(i)\n                 \n                 while queue:\n                     node = queue.popleft()\n                     \n                     for neighbor in map1[node]:\n                         if neighbor in hash1:\n                             continue\n                         else:\n                             queue.append(neighbor)\n                             hash1.add(neighbor)\n             queue.clear()\n             \n         return count        "]
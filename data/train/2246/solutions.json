["from sys import stdin\nfrom heapq import heappop,heappush\ndef main():\n\tn,k = map(int,stdin.readline().split())\n\tX = list(map(int,stdin.readline().split()))\n\tA = int(stdin.readline().strip())\n\tC = list(map(int,stdin.readline().split()))\n\tl  = list()\n\ti = 0;g = k;ans = 0;flag = True\n\twhile i < n and flag:\n\t\theappush(l,C[i])\n\t\tif X[i] > g:\n\t\t\twhile len(l)!= 0 and X[i] > g:\n\t\t\t\tans+= heappop(l)\n\t\t\t\tg+= A\n\t\t\tif len(l) == 0 and X[i] > g:\n\t\t\t\tflag = False\n\t\ti+=1\n\tif flag:\n\t\tprint(ans)\n\telse:\n\t\tprint(-1)\nmain()", "from heapq import *\ndef main():\n    n, k = input().split()\n    n = int(n)\n    k = int(k)\n    req = list(map(lambda x:int(x),input().split()))\n    each = int(input())\n    prices = list(map(lambda x:int(x),input().split()))\n    total = 0\n    hp = []\n    heapify(hp)\n    for i in range(n):\n        heappush(hp,prices[i])\n        #print(f\"day{i}, max{k}\")\n        needed = (req[i] - k + each -1) // each\n        needed = max(0,needed)\n        if len(hp) < needed:\n            print(-1)\n            return\n        for j in range(needed):\n            total += heappop(hp)\n            k += each\n    print(total)\n\nmain()", "from queue import PriorityQueue\n\nn, k = map(int, input(). split())\nx = list(map(int, input().split()))\na = int(input())\nc = list(map(int, input(). split()))\ntot = 0\npq = PriorityQueue()\nfor i in range(0, n):\n    if (k >= x[i]):\n        pq.put(c[i])\n    else:\n        pq.put(c[i])\n        while (pq.qsize()):\n            ans = pq.get()\n            k += a\n            tot += ans\n            if (k >= x[i]):\n                break;\n        if (k < x[i]):\n            tot = -1\n            break;\nprint(tot)", "from queue import PriorityQueue \nN, K = tuple(map(int, input().split()))\nX = list(map(int, input().split()))\nA = int(input())\nC = list(map(int, input().split()))\nm_q = PriorityQueue()\nm = 0\nfor i in range(N):\n    if K < X[i]:\n        m_q.put(C[i])\n        while m_q.qsize() > 0:\n            K += A\n            m += m_q.get()\n            if K >= X[i]:\n                break\n        if K < X[i]:\n            m=-1\n            break    \n    else:\n        m_q.put(C[i])\nprint(m)\n", "import math\nimport heapq\n\n\ndef solve_workout(n_days, strength, plan, gain, costs):\n    total_cost = 0\n    heap = list()\n\n    for i in range(n_days):\n        heapq.heappush(heap, costs[i])\n        n_doses = int(math.ceil((plan[i] - strength) / gain))\n        while n_doses > 0 and heap:\n            total_cost += heapq.heappop(heap)\n            strength += gain\n            n_doses -= 1\n        if strength < plan[i]:\n            return -1\n    return total_cost\n\n\ndef __starting_point():\n    N, K = tuple(map(int, input().split()))\n    X = list(map(int, input().split()))\n    A = int(input())\n    C = list(map(int, input().split()))\n    print(solve_workout(N, K, X, A, C))\n\n__starting_point()", "import sys\nfrom queue import PriorityQueue\n\nn, k = (list(map(int, input().split())))\n\nt = list(map(int, input().split()))\na = int(input())\nc = list(map(int, input().split()))\nf = 1\ncost = 0\nm_q = PriorityQueue()\n\nfor i in range(n):\n    if k + a * (i + 1) < t[i]:\n        print(-1)\n        break\nelse:\n    for j in range(n):\n\n        if k < t[j]:\n            m_q.put(c[j])\n            while m_q.qsize()>0:\n                cost += m_q.get()\n\n\n\n            # print(m_q)\n                k = k + a\n                if k>=t[j]:\n\n                    break\n\n\n\n\n\n            #print(cost, j)\n\n\n        else:\n\n            m_q.put(c[j])\n    print(cost)\n", "import heapq\nimport sys\nn,k=list(map(int,input().split()))\nl=k\narr=list(map(int,input().split()))\nadd=int(input())\nprice=list(map(int,input().split()))\nans=0\nsize=0\ns=[9999999999999999999]\nheapq.heapify(s)\nfor i in range(n):\n    heapq.heappush(s,price[i])\n    size+=1\n    if (arr[i]>l):\n        #print(l)\n        b=(arr[i]-l-1)//add + 1\n        if size<b:\n            print(-1)\n            return\n        else:\n            if b==0:\n                break\n            for j in range(b):\n                ans+=heapq.heappop(s)\n                l+=add\n                #print(ans)\n                size-=1\n            #print(\"helo\")\nprint(ans)\n            \n", "import heapq\ndef process(n, k, X, a, C):\n    res=0\n    A=[]\n    for i in range(len(X)):\n        heapq.heappush(A, C[i])\n        if k+len(A)*a < X[i]:\n            return -1\n        else:\n            while k <X[i]:\n                res+=heapq.heappop(A)\n                k+=a\n\n\n    return res\nn, k=[int(x) for x in input().split()]\nX=[int(x) for x in input().split()]\na=int(input())\nC=[int(x) for x in input().split()]\nprint(process(n,k,X,a,C))\n", "import heapq as hp\n\nN, K = map(int, input().split())\nX = list(map(int, input().split()))\nA = int(input())\nC = list(map(int, input().split()))\n\nlimit = K\nq = []\ncost = 0\nfor i, x in enumerate(X):\n    hp.heappush(q, C[i])\n    if x > limit:\n        while limit < x and q:\n            limit += A\n            nc = hp.heappop(q)\n            cost += nc\n        if limit < x:\n            cost = -1\n            break\n\nprint(cost)", "import math\nimport heapq\ndef solve_workout(n_days, strength, plan, gain, costs):\n    total_cost = 0\n    heap = list()\n    for i in range(n_days):\n        heapq.heappush(heap, costs[i])\n        n_doses = int(math.ceil((plan[i] - strength) / gain))\n        while n_doses > 0 and heap:\n            total_cost += heapq.heappop(heap)\n            strength += gain\n            n_doses -= 1\n        if strength < plan[i]:\n            return -1\n    return total_cost\ndef __starting_point():\n    N, K = tuple(map(int, input().split()))\n    X = list(map(int, input().split()))\n    A = int(input())\n    C = list(map(int, input().split()))\n    print(solve_workout(N, K, X, A, C))\n__starting_point()", "R = lambda: map(int ,input().split())\nn, k = R()\nxs = list(R())\na = int(input())\ncs = list(R())\nr = j = 0\ntry:\n    for i, x in enumerate(xs):\n        if x > k:\n            while x > k:\n                s = min(cs[:i+1-j])\n                cs.remove(s)\n                r += s\n                j += 1\n                k += a\n            if x > k:\n                raise\nexcept:\n    print(-1)\n    quit()\nprint(r)", "R = lambda: map(int ,input().split())\nn, k = R()\nxs = list(R())\na = int(input())\ncs = list(R())\nr = j = 0\ntry:\n    for i, x in enumerate(xs):\n        while x > k:\n            s = min(cs[:i+1-j])\n            cs.remove(s)\n            j += 1\n            k += a\n            r += s\nexcept:\n    print(-1)\n    quit()\nprint(r)", "import heapq as hp\nR = lambda: map(int ,input().split())\nn, k = R()\nxs = list(R())\na, r, h = int(input()), 0, []\ncs = list(R())\nfor i, x in enumerate(xs):\n    hp.heappush(h, cs[i])\n    while x > k and h:\n        s = hp.heappop(h)\n        k += a\n        r += s\n    if x > k:\n        r = -1\n        break\nprint(r)", "import heapq\nn, k = map(int, input().split(' '))\nx = list(map(int, input().split(' ')))\na = int(input())\nc = list(map(int, input().split(' ')))\npq, ans = [], 0\nfor i in range(n):\n\theapq.heappush(pq, c[i])\n\twhile x[i] > k and len(pq) > 0:\n\t\tk += a\n\t\tans += heapq.heappop(pq)\n\tif k < x[i]:\n\t\tprint(\"-1\")\n\t\treturn\nprint(ans)", "import heapq\ndef smaller_by_1(num):\n    return num-1\ndef main():\n    N,k = list(map(int,input().split(\" \")))\n    X = list(map(int,input().split(\" \")))\n    A = int(input())\n    C = list(map(int,input().split(\" \")))\n    #drunk = [0]*N\n    money_needed = 0\n    drinks_needed = []\n    drunk_to_now = 0\n    for i in range(N):\n        objective = X[i]\n        drinks_needed.append(((objective - k)+A-1) // A)\n    possible_drinks = []\n    for i in range(len(drinks_needed)):\n        heapq.heappush(possible_drinks,C[i])\n        if drinks_needed[i] - drunk_to_now<= 0:\n            continue\n        else:\n            while drinks_needed[i] - drunk_to_now != 0:\n                if len(possible_drinks) == 0:\n                    print(-1)\n                    return 0\n                else:\n                    money_needed += heapq.heappop(possible_drinks)\n                    drunk_to_now += 1\n                    \n    print(money_needed)\n    \n                \n\n\n\nmain()\n    \n", "import sys, math\nfrom heapq import heappush, heappop\n\nreadline = sys.stdin.readline\nmr = lambda:map(int,readline().split())\nn, k = mr()\ntmp = list(mr())\na = int(readline())\ncost = list(mr())\nfor i in range(n):\n    tmp[i] -= k\nbuyIndexes = []\nenergy = 0\nans = 0\nfor i in range(n):\n    heappush(buyIndexes,cost[i])\n    if energy < tmp[i]:\n        ordered = []\n        while energy < tmp[i]:\n            energy += a\n            if len(buyIndexes) == 0:\n                ans = -1\n                break\n            ans += heappop(buyIndexes)\n    if ans == -1:\n        break\nprint(ans)", "import heapq\n\n\nclass Input:\n    def __init__(self):\n        from sys import stdin\n        lines = stdin.readlines()\n        self.lines = list([line.rstrip('\\n') for line in reversed(lines) if line != '\\n'])\n\n    def input(self):\n        return self.lines.pop()\n\n    def input_int_list(self):\n        return list(map(int, self.input().split()))\n\n    def __bool__(self):\n        return bool(self.lines)\n\n\ndef workout_plan(n, k, xs, a, cs):\n    choices = []\n    cs.reverse()\n    total_cost = 0\n    for x in xs:\n        heapq.heappush(choices, cs.pop())\n        while k < x:\n            if choices:\n                k += a\n                total_cost += heapq.heappop(choices)\n            else:\n                return -1\n    return total_cost\n\n\ninp = Input()\nn, k = inp.input_int_list()\nxs = inp.input_int_list()\na = int(inp.input())\ncs = inp.input_int_list()\nprint(workout_plan(n, k, xs, a, cs))\n", "import heapq as hp\nimport sys\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\np = int(input())\narrx = list(map(int, input().split()))\nprev = []\nhp.heapify(prev)\ncost = 0\nflag = 0\nfor i in range(n):\n    hp.heappush(prev, arrx[i])\n    while arr[i] > k and len(prev) > 0:\n        k += p\n        cost += hp.heappop(prev)\n    if k < arr[i]:\n        flag = 1\n        break\nif flag == 1:\n    print(-1)\nelse:\n    print(cost)", "from heapq import *\n\nn, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\na = int(input())\nc = list(map(int, input().split()))\ncur = []\nres = 0\nfor i, p in enumerate(arr):\n    heappush(cur, c[i])\n    if p <= k:\n        continue\n    if len(cur) * a + k < p:\n        print(-1)\n        return\n    while p > k:\n        res += heappop(cur)\n        k += a\nprint(res)\n\n", "from heapq import *\n\nn, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\na = int(input())\nc = list(map(int, input().split()))\ncur = []\nres = 0\nfor i, p in enumerate(arr):\n    heappush(cur, c[i])\n    if p <= k:\n        continue\n    if len(cur) * a + k < p:\n        print(-1)\n        return\n    while p > k:\n        res += heappop(cur)\n        k += a\nprint(res)\n", "import heapq \nn,initial=list(map(int,input().split()))\ntarget=list(map(int,input().split()))\ngain=int(input())\nprices=list(map(int,input().split()))\nflag=True\nfor i in range(n):\n    if target[i]>(i+1)*gain+initial:\n        flag=False\n        print(-1)\n        break \nif flag:\n    a=[10**18]\n    heapq.heapify(a)\n    maxx=-1\n    ans=0\n    for i in range(n):\n        heapq.heappush(a,prices[i])\n        if target[i]>initial:\n            moves=(target[i] - initial - 1)//gain + 1\n            if moves==0:\n                break \n            else:\n                for i in range(moves):\n                    ans+=heapq.heappop(a)\n                    initial+=gain \n    print(ans)                \n            \n            \n"]
["\ndef main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum / k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())\n            if found:\n                simple[mask] = True\n                masks[mask] = path\n    for i in range(1 << k):\n        if not simple[i]:\n            continue\n        mask = i\n        zeroes_count = 0\n        for u in range(k):\n            if (1 << u) > mask:\n                break\n            if (mask & (1 << u)) == 0:\n                zeroes_count += 1\n        for mask_mask in range(1 << zeroes_count):\n            mask_child = 0\n            c = 0\n            for u in range(k):\n                if (1 << u) > mask:\n                    break\n                if (mask & (1 << u)) == 0:\n                    if (mask_mask & (1 << c)) != 0:\n                        mask_child = mask_child | (1 << u)\n                    c += 1\n            if masks[mask_child] and not masks[mask_child | mask]:\n                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}\n                if (mask_child | mask) == ((1 << k) - 1):\n                    c = [-1] * k\n                    p = [-1] * k\n                    d = masks[(1 << k) - 1]\n                    for key, val in list(d.items()):\n                        c[key] = val[0]\n                        p[key] = val[1]\n                    return True, c, p\n    if masks[(1 << k) - 1]:\n        c = [-1] * k\n        p = [-1] * k\n        d = masks[(1 << k) - 1]\n        for key, val in list(d.items()):\n            c[key] = val[0]\n            p[key] = val[1]\n        return True, c, p\n    return False, None, None\n\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path[i_next] = (a[i_next][j_next], i)\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\ndef main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum / k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    answer = [False]*(1 << k)\n    left = [0]*(1 << k)\n    right = [0]*(1 << k)\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())\n            if found:\n                answer[mask] = True\n                masks[mask] = path\n    for mask_right in range(1 << k):\n        if not masks[mask_right]:\n            continue\n        zeroes_count = 0\n        for u in range(k):\n            if (1 << u) > mask_right:\n                break\n            if (mask_right & (1 << u)) == 0:\n                zeroes_count += 1\n        for mask_mask in range(1 << zeroes_count):\n            mask_left = 0\n            c = 0\n            for u in range(k):\n                if (1 << u) > mask_right:\n                    break\n                if (mask_right & (1 << u)) == 0:\n                    if (mask_mask & (1 << c)) != 0:\n                        mask_left = mask_left | (1 << u)\n                    c += 1\n            joint_mask = mask_left | mask_right\n            if answer[mask_left] and not answer[joint_mask]:\n                answer[joint_mask] = True\n                left[joint_mask] = mask_left\n                right[joint_mask] = mask_right\n                if joint_mask == ((1 << k) - 1):\n                    return build_answer(k, masks, left, right)\n    if answer[(1 << k) - 1]:\n        return build_answer(k, masks, left, right)\n    return False, None, None\n\n\ndef build_answer(k, masks, left, right):\n    c = [-1] * k\n    p = [-1] * k\n    pos = (1 << k) - 1\n    while not masks[pos]:\n        for key, val in list(masks[right[pos]].items()):\n            c[key] = val[0]\n            p[key] = val[1]\n        pos = left[pos]\n    for key, val in list(masks[pos].items()):\n        c[key] = val[0]\n        p[key] = val[1]\n    return True, c, p\n\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path[i_next] = (a[i_next][j_next], i)\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\ndef main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print(\"Yes\")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print(\"No\")\n\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum / k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    answer = [False]*(1 << k)\n    left = [0]*(1 << k)\n    right = [0]*(1 << k)\n    by_last_one = [[] for _ in range(k)]\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, [])\n            if found and not answer[mask]:\n                answer[mask] = True\n                masks[mask] = path\n                simple[mask] = True\n                by_last_one[calc_last_one(mask)].append(mask)\n    if answer[(1 << k) - 1]:\n        return build_answer(k, masks, left, right)\n    for mask_right in range(2, 1 << k):\n        if not simple[mask_right]:\n            continue\n        last_one = calc_last_one(mask_right)\n        zeroes_count = 0\n        alternative_sum = 0\n        zero_list = []\n        for u in range(last_one):\n            if (mask_right & (1 << u)) == 0:\n                zeroes_count += 1\n                alternative_sum += len(by_last_one[u])\n                zero_list.append(u)\n        if zeroes_count == 0:\n            continue\n        if alternative_sum < (1 << zeroes_count):\n            for fill_last_zero in zero_list:\n                for mask_left in by_last_one[fill_last_zero]:\n                    if (mask_left & mask_right) != 0:\n                        continue\n                    joint_mask = mask_left | mask_right\n                    if not answer[joint_mask]:\n                        answer[joint_mask] = True\n                        left[joint_mask] = mask_left\n                        right[joint_mask] = mask_right\n                        by_last_one[last_one].append(joint_mask)\n                        if joint_mask == ((1 << k) - 1):\n                            return build_answer(k, masks, left, right)\n        else:\n            for mask_mask in range(1 << zeroes_count):\n                mask_left = 0\n                for u in range(zeroes_count):\n                    if (mask_mask & (1 << u)) != 0:\n                        mask_left = mask_left | (1 << zero_list[u])\n                joint_mask = mask_left | mask_right\n                if answer[mask_left] and not answer[joint_mask]:\n                    answer[joint_mask] = True\n                    left[joint_mask] = mask_left\n                    right[joint_mask] = mask_right\n                    by_last_one[last_one].append(joint_mask)\n                    if joint_mask == ((1 << k) - 1):\n                        return build_answer(k, masks, left, right)\n    return False, None, None\n\n\ndef calc_last_one(x):\n    result = -1\n    while x > 0:\n        x = x >> 1\n        result = result + 1\n    return result\n\n\ndef build_answer(k, masks, left, right):\n    c = [-1] * k\n    p = [-1] * k\n    pos = (1 << k) - 1\n    while not masks[pos]:\n        for i, a, j in masks[right[pos]]:\n            c[i] = a\n            p[i] = j\n        pos = left[pos]\n    for i, a, j in masks[pos]:\n        c[i] = a\n        p[i] = j\n    return True, c, p\n\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path.append((i_next, a[i_next][j_next], i))\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
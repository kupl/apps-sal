["class Solution:\n    def reorderedPowerOf2(self, n: int) -> bool:\n        \n        n_len = len(str(n))\n        n = Counter(str(n))\n        \n        p = 1\n        while len(str(p)) <= n_len:\n            if len(str(p)) == n_len and Counter(str(p)) == n:\n                return True\n            p *= 2\n        \n        return False", "from collections import Counter\nclass Solution:\n    def reorderedPowerOf2(self, N):\n        c = Counter(str(N))\n        for i in range(32):\n            if Counter(str(1 << i)) == c:\n                return True\n        return False", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        \n        # Because 10**9 ~ 2**30\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\n", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        all_powers_of_two_up_to_limit_sorted = [sorted(str(1 << i)) for i in range(30)]\n        return sorted(str(N)) in all_powers_of_two_up_to_limit_sorted\n", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool: \n        if N==1:\n            return True\n        elif N==2:\n            return True\n       \n        \n        max_v = int(''.join((sorted(list(str(N)), reverse=True))))\n        canidates = 2\n        while True:\n            print (canidates)            \n            if len(str(canidates))==len(str(N)):\n                canidates_memo = collections.Counter(str(canidates))\n                N_memo = collections.Counter(str(N))\n                success = True\n                for k in canidates_memo:\n                    if k not in N_memo or canidates_memo[k]!=N_memo[k]:\n                        success=False\n                        break\n                if success:\n                    return True\n            if canidates<max_v:\n                canidates *=2\n            else:\n                break\n        return False\n        \n", "from collections import Counter\nclass Solution:\n    def reorderedPowerOf2(self, n: int) -> bool:\n        ls=[]\n        for i in range(31):\n            num=2**i\n            ls.append(dict(Counter(str(num))))\n        # print(ls)\n        \n        s=str(n)\n        di=dict(Counter(s))\n        # print(di)\n        \n        for i in ls:\n            if(i==di):\n                return True\n        return False", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        \n        main = list(map(Counter, [str(2**n) for n in range(0, 30)]))\n        return any(Counter(str(N)) == mape for mape in main)\n    \n    \n        1892", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        maxn = 10 ** 9\n        twopower = 1\n        twosets = set()\n        while twopower <= maxn:\n            twosets.add(twopower)\n            twopower *= 2\n        permutations = self.get_all_permutation(N)\n        for p in permutations:\n            if p[0] != '0' and int(p) in twosets:\n                return True\n        return False\n\n    def get_all_permutation(self, num):\n        perm = {''}\n        for n in str(num):\n            perm = {p[:i] + n + p[i:] for p in perm  for i in range(len(p) + 1)}\n        return perm\n", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        n_hash = {}\n        n_str = str(N)\n        for c in n_str:\n            n_hash[c] = n_hash.get(c, 0) + 1\n        \n        for i in range(0, 31):\n            num = pow(2, i)\n            if len(str(num)) > len(str(N)):\n                return False\n            n_num = {}\n            for c in str(num):\n                n_num[c] = n_num.get(c, 0) + 1\n            n_exists = True\n            for k in n_hash:\n                if n_num.get(k) and n_num.get(k) == n_hash.get(k):\n                    pass\n                else:\n                    n_exists = False\n                    break\n            if n_exists:\n                return True\n        return False\n                    \n                    \n", "import itertools\n\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        if N == 1:\n            return True\n\n        digits = self._getDigits(N)\n        ones = {2, 4, 6, 8} & set(digits)\n        if not ones:\n            return False\n\n        for o in ones:\n            digits.remove(o)\n            if self._canMakePowerOf2(digits, o):\n                return True\n            digits.append(o)\n        return False\n\n    def _getDigits(self, N):\n        digits = []\n        while N > 0:\n            digits.append(N % 10)\n            N //= 10\n        return digits\n\n    def _canMakePowerOf2(self, digits, ones):\n        for seq in itertools.permutations(digits):\n            if self._isPowerOf2(seq, ones):\n                return True\n        return False\n\n    def _isPowerOf2(self, digits, ones):\n        n = 0\n        for i, d in enumerate(digits):\n            if i == 0 and d == 0:\n                return False\n            n = 10 * n + d\n        n = 10 * n + ones\n        return n & (n - 1) == 0\n", "from itertools import permutations\n\nclass Solution:\n    def reorderedPowerOf2(self, x: int) -> bool:\n        n = 1\n        pows = set()\n        for i in range(31):\n            pows.add(n)\n            n <<= 1        \n        \n        for p in permutations(str(x)):\n            if p[0] == '0': continue\n            if int(''.join(p)) in pows: return True\n        \n        return False", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        sn = sorted(str(N))\n        for i in range(32):\n            pot = (1 << i)\n            spot = sorted(str(pot))\n            if sn == spot:\n                return True\n        return False", "from itertools import permutations\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n\n        Nstr = str(N)\n        pset = set(''.join(p) for p in permutations(Nstr))\n        \n        bmk = 1\n        while len(str(bmk)) < len(Nstr):\n            bmk *= 2\n        \n        while len(str(bmk)) == len(Nstr):\n            if str(bmk) in pset:\n                return True\n            bmk *= 2\n        \n        return False        ", "class Solution:\n    def helper(self, level, chars):\n        if level == len(chars):\n            temp1 = ''.join(chars)\n            if temp1[0] == '0':\n                return 0\n            if temp1 in self.been:\n                return self.been[temp1]\n            temp = bin(int(temp1)).count('1')\n            if temp == 1:\n                return 1\n            return 0\n            # while temp != 1:\n            #     if temp % 2 == 0:\n            #         temp = int(temp / 2)\n            #     else:\n            #         self.been[temp1] = 0\n            #         return 0\n            # self.been[temp1] = 1\n            # return 1\n        seen = set()\n        for i in range(level, len(chars)):\n            if chars[i] in seen:\n                continue\n            chars[level], chars[i] = chars[i], chars[level]\n            h = self.helper(level + 1, chars)\n            if h == 1:\n                return 1\n            chars[level], chars[i] = chars[i], chars[level]\n            seen.add(chars[i])\n        return 0\n    \n    def reorderedPowerOf2(self, N: int) -> bool:\n        N = str(N)\n        chars = [char for char in N]\n        seen = set()\n        self.been = {}\n        for i in range(0, len(chars)):\n            if self.helper(i, chars):\n                return True\n        return False", "class Solution:\n    def helper(self, level, chars):\n        if level == len(chars):\n            temp1 = ''.join(chars)\n            if temp1[0] == '0':\n                return 0\n            if temp1 in self.been:\n                return self.been[temp1]\n            temp = int(temp1)\n            while temp != 1:\n                if temp % 2 == 0:\n                    temp = int(temp / 2)\n                else:\n                    self.been[temp1] = 0\n                    return 0\n            self.been[temp1] = 1\n            return 1\n        seen = set()\n        for i in range(level, len(chars)):\n            if chars[i] in seen:\n                continue\n            chars[level], chars[i] = chars[i], chars[level]\n            h = self.helper(level + 1, chars)\n            if h == 1:\n                return 1\n            chars[level], chars[i] = chars[i], chars[level]\n            seen.add(chars[i])\n        return 0\n    \n    def reorderedPowerOf2(self, N: int) -> bool:\n        N = str(N)\n        chars = [char for char in N]\n        seen = set()\n        self.been = {}\n        for i in range(0, len(chars)):\n            if self.helper(i, chars):\n                return True\n        return False", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        def backtrack(idx, num):\n            if idx==L:\n                if num in two_set:\n                    return True\n                return False\n            \n            for v in counter:\n                if idx==0 and v=='0':\n                    continue\n                    \n                if counter[v]>0:\n                    counter[v] -= 1\n                    if backtrack(idx+1, num+v):\n                        return True\n                    counter[v] += 1\n            \n            return False\n            \n        perm_set = {N}\n        ns = str(N)\n        counter = Counter(ns)\n        L = len(ns)\n        two_set = set()\n        num = 1\n        while len(str(num))<=L:\n            if len(str(num))==L:\n                two_set.add(str(num))\n            num*=2\n        return backtrack(0, '')\n", "import itertools\nimport math\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        if N == 1:\n            return True\n        for i in list(itertools.permutations(list(str(N)))):\n            if i[0] != '0'  and int(i[-1]) % 2 == 0:\n                num = int(''.join(i))\n                # print('i ', i)\n                # print('num ', num)\n                # print('round(math.log2(num)) ', round(math.log2(num)))\n                # print('math.log2(num) ', math.log2(num))\n                if bin(num).count('1') == 1:\n                # if round(math.log2(num)) == math.log2(num):\n                    # print(i)\n                    # print(num)\n                    return True \n                \n        return False\n            \n    \n", "class Solution:\n    pow2 = set()\n    for i in range(30):\n        pow2.add(''.join(sorted(str(1 << i))))\n    def reorderedPowerOf2(self, N: int) -> bool:\n        return ''.join(sorted(str(N))) in self.pow2\n", "import itertools\nimport math\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        if N == 1:\n            return True\n        for i in list(itertools.permutations(list(str(N)))):\n            if i[0] != '0'  and int(i[-1]) % 2 == 0:\n                num = int(''.join(i))\n                # print('i ', i)\n                # print('num ', num)\n                # print('round(math.log2(num)) ', round(math.log2(num)))\n                # print('math.log2(num) ', math.log2(num))\n                if round(math.log2(num)) == math.log2(num):\n                    # print(i)\n                    # print(num)\n                    return True \n                \n        return False\n            \n    \n", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        def is_power_of_two(c):\n            return bin(int(''.join(c))).count('1') == 1\n        permutations = itertools.permutations(str(N))\n        for cand in permutations:\n            if cand[0] != '0' and is_power_of_two(cand):\n                return True\n        \n        return False\n", "import itertools\nimport math\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        for i in list(itertools.permutations(list(str(N)))):\n            if i[0] != '0':  #  and int(i[-1]) % 2 == 0\n                num = int(''.join(i))\n                # print('i ', i)\n                # print('num ', num)\n                # print('round(math.log2(num)) ', round(math.log2(num)))\n                # print('math.log2(num) ', math.log2(num))\n                if round(math.log2(num)) == math.log2(num):\n                    # print(i)\n                    # print(num)\n                    return True \n                \n        return False\n            \n    \n", "from itertools import permutations\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        \n        if N == 1:\n            return True\n        \n        Nstr = str(N)\n        pset = set(''.join(p) for p in permutations(Nstr) if int(p[-1])%2==0)\n        \n        bmk = 1\n        while len(str(bmk)) < len(Nstr):\n            bmk *= 2\n        \n        while len(str(bmk)) == len(Nstr):\n            if str(bmk) in pset:\n                return True\n            bmk *= 2\n        \n        return False        ", "class Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        pow_sigs = set()\n        twon = 1\n        while twon <= 10**9:\n            sig = [0] * 10\n            s = str(twon)\n            for c in s:\n                sig[int(c)] += 1\n            \n            pow_sigs.add(tuple(sig))\n            twon *= 2\n        \n        n_sig = [0] * 10\n        s = str(N)\n        for c in s:\n            n_sig[int(c)] += 1\n\n        if tuple(n_sig) in pow_sigs:\n            return True\n        else:\n            return False", "from itertools import permutations\n\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        \n        # Brute force, check every permutation\n        res = False\n        for n in permutations(str(N)):\n            if n[0] == '0':\n                continue\n            n = int(''.join(n))\n            res = max(res, not (n & (n-1)))\n            \n        return res", "import math\nfrom itertools import permutations\n\nclass Solution:\n    def permutations2(self, N: int) -> List[int]:\n        nums = [''.join(p) for p in permutations(str(N))]\n        return [int(n) for n in nums if not n.startswith('0')]\n    \n    def reorderedPowerOf2(self, N: int) -> bool:\n        # make permutations of N\n        permutations = self.permutations2(N)\n        for permutation in permutations:\n            if math.log2(permutation).is_integer():\n                return True\n        return False", "class Solution:\n    import math\n    from itertools import permutations\n    def reorderedPowerOf2(self, N: int) -> bool:\n        k=str(N)\n        a=[x for x in k]\n        n=len(k)\n        print(a,n)\n        ans=list(permutations(k))\n        m=0\n        #print(ans)\n        for i in ans:\n            s=''.join(i)\n            \n            if s[0]!='0' :\n                z=math.log(int(s),2)\n                if abs(z-int(z))<0.000000001:\n                    return True\n        \n        return False", "import math\n\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        \n        if(N==1):\n            return True\n        \n        nn=int(math.log(N)/math.log(2))-1\n        tmp=2**(nn)\n        \n        fun=lambda x: sorted( list(str(x)) ,key=lambda x:int(x),reverse=True)\n        N=fun(N)\n        \n        if(N==fun(tmp)):\n            return True\n        \n    #    print(nn,tmp)\n        for x in range(nn,20*nn):\n            tmp=tmp*2\n            if(N==fun(tmp)):\n                return True\n            if(nn<len(str(tmp))):\n                break\n        \n        tmp=2**(nn)\n\n        for x in range(nn,nn//20,-1):\n            tmp=tmp//2\n            if(N==fun(tmp)):\n                return True\n            if(nn<len(str(tmp))):\n                break\n        return False\n        \n        \n        \n            \n        \n        \n        \n        \n        \n            \n        \n        \n        \n        \n", "class Solution:\n    def reorderedPowerOf2(self, N):\n        c = sorted(str(N))\n        for i in range(32):\n            if sorted(str(1 << i)) == c:\n                return True\n        return False", "from typing import List\n\n\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        def trans(i) -> List[str]:\n            res = []\n            while i > 0:\n                res.append(i % 10)\n                i = i // 10\n            return sorted(res)\n\n        for i in range(31):\n            if trans(N) == trans(1 << i):\n                return True\n        return False\n\n", "from collections import Counter\nclass Solution:\n    def reorderedPowerOf2(self, N: int) -> bool:\n        curr = 1\n        N = str(N)\n        while len(str(curr)) <= len(N):\n            if len(str(curr)) == len(N):\n                if Counter(str(curr)) == Counter(str(N)):\n                    return True\n            curr *= 2\n        return False"]
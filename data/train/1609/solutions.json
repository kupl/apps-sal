["def sum_of_intervals(intervals):\n    s, top = 0, float(\"-inf\")\n    for a,b in sorted(intervals):\n        if top < a: top    = a\n        if top < b: s, top = s+b-top, b\n    return s", "def sum_of_intervals(intervals):\n    result = set()\n    for start, stop in intervals:\n        for x in range(start, stop):\n            result.add(x)\n            \n    return len(result)", "def sum_of_intervals(intervals):\n    return len(set([n for (a, b) in intervals for n in [i for i in range(a, b)]]))", "def sum_of_intervals(intervals): \n    s = []\n    for i in intervals:\n        s += list(range(i[0],i[1]))\n    return len(set(s))", "from itertools import chain\n\ndef sum_of_intervals(intervals):\n    return len(set(chain.from_iterable(range(*i) for i in intervals)))", "def sum_of_intervals(intervals):\n    total = set()\n    for x,y in intervals:\n        for i in range(x,y):\n            total.add(i)    \n    return(len(total))", "def sum_of_intervals(intervals):\n    return len(set().union(*[list(range(*item))for item in intervals]))", "sum_of_intervals=lambda a:len(set.union(*(set(range(*i))for i in a)))", "def sum_of_intervals(intervals):\n    return len(set([i for a,b in intervals for i in range(a,b)]))", "def sum_of_intervals(intervals):\n    result = set()\n    for start, end in intervals:\n        result |= set(range(start, end))\n    return len(result)", "def sum_of_intervals(intervals):\n    sets = set()\n    for a, b in intervals:\n        sets.update(list(range(a, b)))\n    return len(sets)\n", "def sum_of_intervals(intervals):\n    return len(set([n for a,b in intervals for n in list(range(a,b))]))", "from bisect import bisect\ndef sum_of_intervals(intervals):\n    I = []\n    for a, b in intervals:\n        i = bisect(I, a)\n        j = bisect(I, b)\n        I = I[:i] + [a]*(1-i%2) + [b]*(1-j%2) + I[j:]\n    return sum(I[1::2]) - sum(I[::2])", "def sum_of_intervals(intervals):\n    #1) get range of each tuplem -> list\n    #2) turn \"list\" obj into \"set\" obj to remove repeats\n    #3) return the length of the final \"set\" obj\n    return len(set([i for t in intervals for i in range(t[0],t[-1])]))", "def sum_of_intervals(intervals):\n    answer = []\n    for tup in intervals:\n        for j in range(tup[0],tup[1]):\n            answer.append(j)\n    return len(list(set(answer)))", "def sum_of_intervals(intervals):\n    intervals.sort()\n    x = 0\n    while x < len(intervals) -1:\n        if intervals[x][0] <= intervals[x+1][0] and intervals[x][1] >= intervals[x+1][1]:\n            intervals.pop( x+1)\n        elif intervals[x][0] <= intervals[x+1][0] and intervals[x][1] >= intervals[x+1][0] and intervals[x][1] < intervals[x+1][1]:\n            intervals[x] = (intervals[x][0], intervals[x+1][1])\n            intervals.pop(x+1)\n        else:\n            x+=1\n\n    return sum(intervals[x][1] - intervals[x][0] for x in range(len(intervals)))", "def sum_of_intervals(intervals):\n    list1=[]\n    for i in intervals:\n        for j in range(i[0],i[1]):\n            list1.append(j)\n    set1=set(list1)\n    return len(set1)", "import functools\ndef sum_of_intervals(intervals):\n    return len(functools.reduce(lambda x,y:x|y,[set(range(x,y)) for x,y in intervals]))", "def sum_of_intervals(intervals):\n    return len({a for interval in intervals for a in range(*interval)})", "def sum_of_intervals(intervals):\n\n    # Merge the intervals so that all intervals are disjoint\n    merged = sorted([list(t) for t in intervals])\n    i = 0\n    while i < len(merged) - 1:\n        if merged[i + 1][1] <= merged[i][1]:\n            # Next interval is a subset of current interval\n            del merged[i + 1]\n            continue\n        if merged[i + 1][0] <= merged[i][1]:\n            # Next interval has some overlap with currenrt interval\n            merged[i][1] = merged[i + 1][1]\n            del merged[i + 1]\n            continue\n        i += 1\n        \n    # Calculate the sum of the disjoint intervals\n    return sum(b - a for a, b in merged)\n"]
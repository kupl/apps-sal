["import re\n\ndef brainfuck_to_c(source):\n    # remove comments\n    source = re.sub('[^+-<>,.\\[\\]]', '', source)\n    \n    # remove redundant code\n    before = ''\n    while source != before:\n        before = source\n        source = re.sub('\\+-|-\\+|<>|><|\\[\\]', '', source)\n    \n    # check braces status\n    braces = re.sub('[^\\[\\]]', '', source)\n    while braces.count('[]'):\n        braces = braces.replace('[]', '')\n    if braces:\n        return 'Error!'\n    \n    # split code into commands\n    commands = re.findall('\\++|-+|>+|<+|[.,\\[\\]]', source)\n    \n    # translate to C\n    output = []\n    indent = 0\n    for cmd in commands:\n        if cmd[0] in '+-<>':\n            line = ('%sp %s= %s;\\n' %\n                ('*' if cmd[0] in '+-' else '',\n                 '+' if cmd[0] in '+>' else '-',\n                 len(cmd)))\n        elif cmd == '.':\n            line = 'putchar(*p);\\n'\n        elif cmd == ',':\n            line = '*p = getchar();\\n'\n        elif cmd == '[':\n            line = 'if (*p) do {\\n'\n        elif cmd == ']':\n            line = '} while (*p);\\n'\n            indent -= 1\n        output.append('  ' * indent + line)\n        if cmd == '[':\n            indent += 1\n    \n    return ''.join(output)", "def brainfuck_to_c(s):\n    s = ''.join(c for c in s if c in '.,<>[]-+')\n\n    pairs = '<> >< -+ +- []'.split()\n    while any(p in s for p in pairs):\n        for w in pairs: s = s.replace(w, '')\n        \n    r, depth, l, i = '', 0, ' ', 1\n    for c in s:\n        if c == l and c in '<>+-': \n            i += 1\n            continue\n        if l in '<>+-': r += cmd(depth, l, i)\n        if c == ']': depth -= 2\n        if c in '.,[]': r += cmd(depth, c)\n        if c == '[': depth += 2\n        if depth < 0: break\n        i, l = 1, c\n            \n    return 'Error!' if depth else r + (cmd(depth, l, i) if l in '<>+-' else '')\n\ndef cmd(depth, c, i=None):\n    return ' ' * depth + {'<':'p -=', '>':'p +=', '+':'*p +=', '-':'*p -=', \n                          '.':'putchar(*p);', ',':'*p = getchar();', \n                          '[':'if (*p) do {', ']':'} while (*p);'}[c]  + (' {};'.format(i) if i else '') +'\\n'", "import re\n\ndef brainfuck_to_c(sc):\n  code,p,l,t=[],0,-1,0\n  while l!=len(sc): l=len(sc); sc=re.sub(r'(\\+\\-)|(\\-\\+)|(<>)|(><)|(\\[\\])|[^+\\-<>,.\\[\\]]','',sc)\n  l,braces=-1,re.sub(r'[+\\-.<>,]','',sc)\n  while l!=len(braces): l=len(braces); braces=re.sub(r'(\\[\\])','',braces)\n  if len(braces)!=0: return \"Error!\"  \n  while p<len(sc):\n    c=sc[p]\n    if c in '+-><':\n      if   c=='+': m,v,o='+','*','+'\n      elif c=='-': m,v,o='-','*','-'\n      elif c=='>': m,v,o='>', '','+'\n      elif c=='<': m,v,o='<', '','-'\n      n=re.match('\\\\'+m+'+',sc[p:]).group(); p+=len(n)-1\n      code.append(' '*t+v+'p '+o+'= '+str(len(n))+';')\n    elif  c=='.': code.append(' '*t+'putchar(*p);')\n    elif  c==',': code.append(' '*t+'*p = getchar();')\n    elif  c=='[': code.append(' '*t+'if (*p) do {'); t+=2\n    else: t-=2;   code.append(' '*t+'} while (*p);')\n    p+=1\n  return '' if sc=='' else '\\n'.join(code)+'\\n'", "import re, itertools\n\nWORDING = dict(map(lambda x: x.split(\" | \"),\"\"\"\n- | *p -= %s;\n+ | *p += %s;\n< | p -= %s;\n> | p += %s;\n[ | if (*p) do {\n] | } while (*p);\n. | putchar(*p);\n, | *p = getchar();\n\"\"\".splitlines()[1:]))\n\ndef brainfuck_to_c(source_code):\n    code, old_code = source_code, \"\"\n    while (code != old_code):\n        old_code = code\n        code = re.sub(\"[^\\+\\-\\<\\>\\[\\]\\.\\,]+|\\+\\-|\\-\\+|\\<\\>|\\>\\<|\\[\\]\", \"\", code)\n    indent, output = 0, []\n    for command, sequence in itertools.groupby(code):\n        repeat = len(list(sequence))\n        if command in \"+-<>\":\n            output += [indent * \" \" + WORDING[command] % repeat]\n        if command in \".,[]\":\n            for i in range(repeat):\n                indent -= 2 * (command is \"]\")\n                output += [indent * \" \" + WORDING[command]]\n                indent += 2 * (command is \"[\")\n        if indent < 0:\n            break\n    return \"Error!\" if indent else \"\\n\".join(output + [\"\"])", "class BFCore(object):\n    STR_C = ''\n    def __init__(self, delta = 0, val = ''):\n        self.delta = delta\n        self.val = val\n    def __repr__(self):  return \"{}({},{})\".format(self.__class__.__name__, self.val, self.delta)\n    def __bool__(self):  return True\n    def toC(self):       return ' '*self.delta + self.STR_C\n\nclass ValMov(BFCore):\n    def toC(self):       return self.STR_C.format(' '*self.delta, \"+\" if self.val > 0 else \"-\", abs(self.val))\n    def __iadd__(self, n): self.val += n ; return self\n    def __bool__(self):  return self.val != 0\n\nclass Val(ValMov):       STR_C = \"{}*p {}= {};\\n\"\nclass Mov(ValMov):       STR_C = \"{}p {}= {};\\n\"\n\nclass LoopOpen(BFCore):  STR_C = 'if (*p) do {\\n'\nclass LoopClose(BFCore): STR_C = '} while (*p);\\n'\nclass Input(BFCore):     STR_C = \"*p = getchar();\\n\"\nclass Output(BFCore):    STR_C = 'putchar(*p);\\n'\n\n\n\ndef brainfuck_to_c(source):\n    lst, delta = [BFCore()], 0\n    for c in source:\n        \n        if c in \"-+\":\n            if isinstance(lst[-1], Val):\n                lst[-1] += (1 if c == '+' else -1)\n                if not lst[-1]: del lst[-1]\n            else: lst.append(Val(delta, 1 if c == '+' else -1))\n            \n        elif c in \"<>\":\n            if isinstance(lst[-1], Mov):\n                lst[-1] += 1 if c == '>' else -1\n                if not lst[-1]: del lst[-1]\n            else: lst.append(Mov(delta, 1 if c == '>' else -1))\n        \n        elif c == '[':\n            lst.append(LoopOpen(delta))\n            delta += 2\n            \n        elif c == ']':\n            delta -= 2\n            if delta < 0: return \"Error!\"\n            if isinstance(lst[-1], LoopOpen): del lst[-1]\n            else:                             lst.append(LoopClose(delta))\n        \n        elif c == ',': lst.append(Input(delta))\n        elif c == '.': lst.append(Output(delta))\n        \n    return \"Error!\" if delta != 0 else ''.join(tok.toC() for tok in lst)\n", "def brainfuck_to_c(source_code):\n    result = ''\n    possible = '+-<>,.[]'\n    spacing = 0\n    braces_count = 0\n    op_count = 0\n    source_code = ''.join(letter for letter in source_code if letter in possible)\n    while '[]' in source_code or '+-' in source_code or '<>' in source_code or '-+' in source_code or '><' in source_code:\n        source_code = source_code.replace('[]','').replace('+-','').replace('<>','').replace('-+','').replace('><','')\n    if source_code.count('[') != source_code.count(']'):\n        return 'Error!'\n    for index,letter in enumerate(source_code):\n        if letter == '[':\n            braces_count += 1\n            result += ' ' * spacing + 'if (*p) do {\\n'\n            spacing += 2\n        elif letter == ']':\n            braces_count -= 1\n            if braces_count < 0:\n                return 'Error!'\n            spacing -= 2\n            result += ' ' * spacing + '} while (*p);\\n'\n        elif letter == '+' or letter == '-':\n            if index < len(source_code) - 1 and source_code[index + 1] == letter:\n                op_count += 1\n                continue\n            else:\n                result += ' ' * spacing + f'*p {letter}= {op_count + 1};\\n'\n                op_count = 0\n        elif letter == '<' or letter == '>':\n            if index < len(source_code) - 1 and source_code[index + 1] == letter:\n                op_count += 1\n                continue\n            else:\n                equi = '+' if letter == '>' else '-'\n                result += ' ' * spacing + f'p {equi}= {op_count + 1};\\n'\n                op_count = 0\n        elif letter == '.':\n            result += ' ' * spacing + 'putchar(*p);\\n'\n        elif letter == ',':\n            result += ' ' * spacing + '*p = getchar();\\n'\n    if braces_count != 0:\n        return 'Error!'\n    return result", "from itertools import groupby\nimport re\ndef brainfuck_to_c(sc):\n    sc = remove(sc,sc)\n    bracket, space, code = [], '', ''\n    for i, j in groupby(sc):\n        n = len(list(j))\n        if i in '-+' :   code += space + f\"*p {'+-'[i=='-']}= {n};\\n\"\n        elif i in '<>' : code += space + f\"p {'+-'[i=='<']}= {n};\\n\"\n        elif i == '.' :  code += (space+'putchar(*p);\\n')*n\n        elif i == ',' :  code += (space+\"*p = getchar();\\n\")*n\n        elif i == '[':\n            for n in range(n):\n                code += space + 'if (*p) do {\\n'\n                space += '  '\n                bracket.append('[')\n        elif i == ']':\n            for n in range(n):\n                if not bracket or bracket.pop() != '[':return 'Error!'\n                space = space[:-2]\n                code += space + '} while (*p);\\n'\n    return 'Error!' if bracket else code\n\ndef remove(prev,sc):\n    sc = re.sub(r'\\[\\]','', re.sub(r'<>|><','', re.sub(r'\\+-|-\\+','', re.sub(r'[^\\+-<>,.\\[\\]]','',sc))))\n    return sc if sc==prev else remove(sc,sc)", "import re\n\nclass Token(object):\n    ARITH = 1\n    POINTER = 2\n    GETCHAR = 3\n    PUTCHAR = 4\n    OPEN = 5\n    CLOSE = 6\n    def __init__(self, mode=None, indent=None, value=None):\n        self.mode = mode\n        self.value = value\n        self.indent = indent\n    def __str__(self):\n        if self.mode == self.ARITH:\n            sign = '+' if self.value > 0 else '-'\n            return '{}*p {}= {};\\n'.format(self.indent, sign, abs(self.value))\n        if self.mode == self.POINTER:\n            sign = '+' if self.value > 0 else '-'\n            return '{}p {}= {};\\n'.format(self.indent, sign, abs(self.value))\n        if self.mode == self.GETCHAR:\n            return self.indent + '*p = getchar();\\n'\n        if self.mode == self.PUTCHAR:\n            return self.indent + 'putchar(*p);\\n'\n        if self.mode == self.OPEN:\n            return self.indent + 'if (*p) do {\\n'\n        if self.mode == self.CLOSE:\n            return self.indent + '} while (*p);\\n'\n        return ''\n\nclass BF(object):\n    ARITH = 1\n    POINTER = 2\n    GETCHAR = 3\n    PUTCHAR = 4\n    OPEN = 5\n    CLOSE = 6\n    def __init__(self, source_code):\n        self.indent = ''\n        self.source_code = source_code\n        self.tokens = [Token()]\n        self.error = False\n        \n    def convert_to_c(self):\n        try:\n            for c in self.source_code:\n                self.convert_one_char(c)\n        except ValueError:\n            return 'Error!'\n        if self.indent:\n            return 'Error!'\n        return ''.join(map(str, self.tokens))\n    \n    def convert_one_char(self, c):\n        if c in '+-':\n            if self.tokens[-1].mode != self.ARITH:\n                self.tokens.append(Token(self.ARITH, self.indent, 0))\n            if c == '+':\n                self.tokens[-1].value += 1\n            else:\n                self.tokens[-1].value -= 1\n            if not self.tokens[-1].value:\n                del self.tokens[-1]\n        elif c in '><':\n            if self.tokens[-1].mode != self.POINTER:\n                self.tokens.append(Token(self.POINTER, self.indent, 0))\n            if c == '>':\n                self.tokens[-1].value += 1\n            else:\n                self.tokens[-1].value -= 1\n            if not self.tokens[-1].value:\n                del self.tokens[-1]\n        elif c == ',':\n            self.tokens.append(Token(self.GETCHAR, self.indent, 0))\n        elif c == '.':\n            self.tokens.append(Token(self.PUTCHAR, self.indent, 0))\n        elif c == '[':\n            self.tokens.append(Token(self.OPEN, self.indent, 0))\n            self.indent += '  '\n        elif c == ']':\n            if not self.indent:\n                raise ValueError\n            self.indent = self.indent[:-2]\n            if self.tokens[-1].mode == self.OPEN:\n                del self.tokens[-1]\n            else:\n                self.tokens.append(Token(self.CLOSE, self.indent, 0))\n    \ndef brainfuck_to_c(source_code):\n    bf = BF(source_code)\n    return bf.convert_to_c()", "import re\ndef brainfuck_to_c(source_code):\n  s=re.findall('[\\+-<>\\[\\]\\.,]+',source_code)\n  s=''.join(s)\n  pattern=re.compile('<>|><|\\+-|-\\+|\\[\\]')\n  while True:\n    l=len(s)\n    s=pattern.sub('',s)\n    if l==len(s):break\n  \n  depth=0\n  for i in s:\n    if i=='[':depth+=1\n    if i==']':depth-=1\n    if depth<0:return'Error!'\n  if depth != 0:return'Error!'\n  \n  s=re.findall('\\++|\\-+|<+|>+|\\.|,|\\[|\\]',s)\n  \n  for i in range(len(s)):\n    if re.match('\\++',s[i]):s[i]=' '*depth+'*p += '+str(len(s[i]))+';\\n'\n    if re.match('-+',s[i]):s[i]=' '*depth+'*p -= '+str(len(s[i]))+';\\n'\n    if re.match('>+',s[i]):s[i]=' '*depth+'p += '+str(len(s[i]))+';\\n'\n    if re.match('<+',s[i]):s[i]=' '*depth+'p -= '+str(len(s[i]))+';\\n'\n    if re.match('\\.+',s[i]):s[i]=' '*depth+'putchar(*p);\\n'\n    if re.match(',+',s[i]):s[i]=' '*depth+'*p = getchar();\\n'\n    if s[i]=='[':\n      s[i]=' '*depth+'if (*p) do {\\n'\n      depth+=2\n    if s[i]==']':\n      depth-=2\n      s[i]=' '*depth+'} while (*p);\\n'\n      \n  s=''.join(s)\n  return s\n  \n", "def brainfuck_to_c(s):\n    s = ''.join([x for x in s if x in '+-><[].,'])\n    rep = ['+-','-+','<>','><','[]']\n    while sum([s.count(x) for x in rep]):\n        for i in rep: s = s.replace(i,'')\n    if len(s) == 0: return ''\n    t,r,shift = [s[0]],'',0\n    for i in range(1,len(s)):\n        if s[i] in t[-1] and s[i] in '+-<>': t[-1] += s[i]\n        else: t += [s[i]]\n    for i in t:\n        if '+' in i: r += ' '*2*shift + '*p += ' + str(len(i)) + ';\\n'\n        if '>' in i: r += ' '*2*shift + 'p += ' + str(len(i)) + ';\\n'\n        if '-' in i: r += ' '*2*shift + '*p -= ' + str(len(i)) + ';\\n'\n        if '<' in i: r += ' '*2*shift + 'p -= ' + str(len(i)) + ';\\n'\n        if i == '.': r +=' '*2*shift + 'putchar(*p);\\n'\n        if i == ',': r +=' '*2*shift + '*p = getchar();\\n'\n        if i == ']':\n            shift -= 1\n            if shift < 0: return 'Error!'\n            r += ' '*2*shift + '} while (*p);\\n'\n        if i == '[':\n            r += ' '*2*shift + 'if (*p) do {\\n'\n            shift += 1\n    return 'Error!' if shift > 0 else r"]
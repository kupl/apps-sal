["n, m, k = list(map(int,input().split()))\ndm, dp = {}, {}\nvis = {}\nsensors = []\nborder = set()\nfor el in [(0, m), (n, 0), (0, 0), (n, m)]:\n    border.add(el)\n\nfor _ in range(k):\n    x, y = list(map(int, input().split()))\n    if not (x - y) in dm:\n        dm[x - y] = []\n    dm[x - y].append((x, y))\n    if not (x + y) in dp:\n        dp[x + y] = []\n    dp[x + y].append((x, y))\n    vis[(x, y)] = -1\n    sensors.append((x,y))\n\nx, y = 0, 0\ntime = 0\nmove = (1,1)\nwhile True:\n    if move == (1,1):\n        v = min(n - x, m - y)\n        nxt = (x + v, y + v)\n        if nxt[0] == n:\n            move = (-1, 1)\n        else:\n            move = (1, -1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    elif move == (-1,-1):\n        v = min(x, y)\n        nxt = (x - v, y - v)\n        if nxt[0] == 0:\n            move = (1, -1)\n        else:\n            move = (-1, 1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    elif move == (-1,1):\n        v = min(x, m - y)\n        nxt = (x - v, y + v)\n        if nxt[0] == 0:\n            move = (1, 1)\n        else:\n            move = (-1, -1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    else:\n        v = min(n - x, y)\n        nxt = (x + v, y - v)\n        if nxt[0] == n:\n            move = (-1, -1)\n        else:\n            move = (1, 1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    if nxt in border:\n        break\n    else:\n        border.add(nxt)\n\n    x, y = nxt\n    #print('bum', x, y)\n\nfor i in range(k):\n    #print(sensors[i])\n    print(vis[sensors[i]])\n", "def main():\n\tnx, my, k = list(map(int, input().strip().split()))\n\tmy *= 2\n\tnx *= 2\n\n\tdiags = [[] for i in range(nx + my)]\n\tanswers = [-1] * k\n\n\tfor i in range(k):\n\t\tx,y = list(map(int, input().strip().split()))\n\n\t\tdef add(x, y, i):\n\t\t\tdiag_index = nx + (y - x)\n\t\t\tdiags[diag_index].append( (x,y,i) )\n\n\t\tadd(x, y, i)\n\t\tadd(x, my - y, i)\n\t\tadd(nx - x, y, i)\n\t\tadd(nx - x, my - y, i)\n\n\n\tcur_t = 0\n\tcur_x = 0\n\tcur_y = 0\n\n\twhile True:\n\t\tdiag_index = nx + (cur_y - cur_x)\n\t\tfor x,y,i in diags[diag_index]:\n\t\t\tif answers[i] == -1:\n\t\t\t\tt = cur_t + (x - cur_x)\n\t\t\t\tassert(x - cur_x == y - cur_y)\n\t\t\t\tanswers[i] = t\n\n\t\tdiff_x = nx - cur_x\n\t\tdiff_y = my - cur_y\n\t\tdiff = min(diff_x, diff_y)\n\t\tcur_t += diff\n\n\t\tcur_x = (cur_x + diff) % nx\n\t\tcur_y = (cur_y + diff) % my\n\n\t\t\n\t\tif (cur_x % (nx // 2)) + (cur_y % (my // 2)) == 0:\n\t\t\tbreak\n\n\n\tfor a in answers:\n\t\tprint(a)\n\nmain()\n\n\n", "import sys\nfrom fractions import gcd\nimport math\n\ndef euclid_algorithm(a, b):\n    t1, t2 = abs(a), abs(b)\n    #saving equalities:\n    #t1 == x1 * a + y1 * b,\n    #t2 == x2 * a + y2 * b. \n    x1, y1, x2, y2 = int(math.copysign(1, a)), 0, 0, int(math.copysign(1, b))\n    if t1 < t2:\n        t1, t2 = t2, t1\n        x1, y1, x2, y2 = x2, y2, x1, y1\n\n    while t2 > 0:\n        k = int(t1 // t2)\n        t1, t2 = t2, t1 % t2\n        #t1 - k * t2 == (x1 - k * x2) * a + (y1 - k * y2) * b\n        x1, y1, x2, y2 = x2, y2, x1 - k * x2, y1 - k * y2\n\n    return t1, x1, y1\n\ndef opposite_element(x, p):\n    gcd, k, l = euclid_algorithm(x, p)\n    if gcd != 1:\n        return -1\n    return k % p\n\n\nn, m, k = [int(x) for x in input().split()]\ng = gcd(n, m)\nend = n * m // g\nn1, m1 = n//g, m//g\nl1 = opposite_element(n1, m1)\n\ndef solve(x, y):\n    if x%(2*g) != y%(2*g):\n        return float('inf')\n    x1, y1 = x//(2*g), y//(2*g)\n    t = x1%n1 + n1*((y1-x1%n1)*l1%m1)\n    return x%(2*g) + t*2*g\n\ndef check(x,y):\n    res = min(solve(x,y), solve(-x,y), solve(x,-y), solve(-x,-y))\n    return -1 if res >= end else res\n    \nfor line in sys.stdin:\n    x, y = [int(x) for x in line.split()]\n    sys.stdout.write(str(check(x,y)) + '\\n')\n        \n", "__author__ = 'Think'\nn, m, k=[int(i) for i in input().split()]\nn=2*n\nm=2*m\na, b=sorted((m, n))\ntracker=[b]\n\nwhile a>0:\n\tb=(b%a)\n\ttracker.append(a)\n\ta, b=(b, a)\n\ng=b\nprod=(m*n)//g\n\nif m!=n:\n\tif len(tracker)>=3:\n\t\tpair=(1, -(tracker[-3]//tracker[-2]))\n\t\tfor i in range(len(tracker)-4, -1, -1):\n\t\t\tnew=-(tracker[i]//tracker[i+1])\n\t\t\tpair=(pair[1], pair[0]+pair[1]*new)\n\n\t\tif sorted((m, n))[0]==n:\n\t\t\tpair=(pair[1], pair[0])\n\t\ta, b=pair\n\telse:\n\t\tif m>n:\n\t\t\ta=1\n\t\t\tb=0\n\t\telse:\n\t\t\ta=0\n\t\t\tb=1\n\n\tfor i in range(k):\n\t\tx, y=[int(i) for i in input().split()]\n\t\tif (x-y)%g != 0 and (x+y)%g != 0:\n\t\t\tprint(-1)\n\t\t\tcontinue\n\t\telse:\n\t\t\tshortlist=[]\n\t\t\tfor nx in [x, -x]:\n\t\t\t\t\tif ((nx-y)%g) == 0:\n\t\t\t\t\t\tnew=(nx+a*n*((y-nx)//g))%prod\n\t\t\t\t\t\tshortlist.append(new)\n\t\t\t\t\t\tshortlist.append(prod-new)\n\t\t\tif len(shortlist)>0:\n\t\t\t\tprint(min(shortlist))\n\t\t\telse:\n\t\t\t\tprint(-1)\nelse:\n\tfor i in range(k):\n\t\tx, y=[int(i) for i in input().split()]\n\t\tif x!=y:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(x)\n\n\n\n\n", "f = lambda: map(int, input().split())\nn, m, k = f()\n\nw, h = 2 * n, 2 * m\ns = [[] for i in range(w + h)]\np = [-1] * k\n\nfor i in range(k):\n    x, y = f()\n    if x - y & 1: continue\n\n    for a in (x, w - x):\n        for b in (y, h - y):\n            s[b - a].append((a, i))\n\na = b = t = 0\nwhile 1:\n    for x, i in s[b - a]:\n        if p[i] < 0: p[i] = t + x - a\n\n    d = min(w - a, h - b)\n    t += d\n\n    a = (a + d) % w\n    b = (b + d) % h\n\n    if a % n == b % m: break\n\nfor q in p: print(q)", "from sys import *\nf = lambda: map(int, stdin.readline().split())\nn, m, k = f()\nw, h = 2 * n, 2 * m\n\ninf = 1e11\ns = [inf] * (w + h)\na = b = t = 0\n\nwhile 1:\n    if s[b - a] == inf: s[b - a] = t - a\n    d = min(w - a, h - b)\n    t += d\n    a = (a + d) % w\n    b = (b + d) % h\n    if a % n == b % m: break\n\nfor i in range(k):\n    x, y = f()\n    q = min(s[b - a] + a for a in (x, w - x) for b in (y, h - y))\n    print(q if q < inf else -1)", "n, m, k = list(map(int,input().split()))\ndm, dp = {}, {}\nvis = {}\nsensors = []\nborder = set()\nfor el in [(0, m), (n, 0), (0, 0), (n, m)]:\n    border.add(el)\n\nfor _ in range(k):\n    x, y = list(map(int, input().split()))\n    if not (x - y) in dm:\n        dm[x - y] = []\n    dm[x - y].append((x, y))\n    if not (x + y) in dp:\n        dp[x + y] = []\n    dp[x + y].append((x, y))\n    vis[(x, y)] = -1\n    sensors.append((x,y))\n\nx, y = 0, 0\ntime = 0\nmove = (1,1)\nwhile True:\n    if move == (1,1):\n        v = min(n - x, m - y)\n        nxt = (x + v, y + v)\n        if nxt[0] == n:\n            move = (-1, 1)\n        else:\n            move = (1, -1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    elif move == (-1,-1):\n        v = min(x, y)\n        nxt = (x - v, y - v)\n        if nxt[0] == 0:\n            move = (1, -1)\n        else:\n            move = (-1, 1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    elif move == (-1,1):\n        v = min(x, m - y)\n        nxt = (x - v, y + v)\n        if nxt[0] == 0:\n            move = (1, 1)\n        else:\n            move = (-1, -1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    else:\n        v = min(n - x, y)\n        nxt = (x + v, y - v)\n        if nxt[0] == n:\n            move = (-1, -1)\n        else:\n            move = (1, 1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    if nxt in border:\n        break\n    else:\n        border.add(nxt)\n\n    x, y = nxt\n    #print('bum', x, y)\n\nfor i in range(k):\n    #print(sensors[i])\n    print(vis[sensors[i]])\n\n\n\n\n# Made By Mostafa_Khaled\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\ndef inside(n, m, x, y):\n    return 0 <= x <= n and 0 <= y <= m\n\ndef corner(n, m, x, y):\n    return x in [0, n] and y in [0, m]\n\ndef next(n, m, x, y, t, a, b):\n    for cx in [0, n]:\n        cy = a * cx + b\n        if inside(n, m, cx, cy) and (cx, cy) != (x, y):\n            nx, ny = cx, cy\n    for cy in [0, m]:\n        cx = (cy - b) // a\n        if inside(n, m, cx, cy) and (cx, cy) != (x, y):\n            nx, ny = cx, cy\n    nt = t + abs(nx - x)\n    na = -a\n    nb = ny - na * nx\n    if corner(n, m, nx, ny):\n        return None\n    return nx, ny, nt, na, nb\n\n\nn, m, k = list(map(int, input().split()))\nd = defaultdict(list)\nfor i in range(k):\n    x, y = list(map(int, input().split()))\n    for a in [-1, 1]:\n        b = y - a * x\n        d[(a, b)].append((x, y, i))\nans = [-1] * k\nray = (0, 0, 0, 1, 0) #x, y, t, a, b\nvisit = set()\nwhile ray:\n    x, y, t, a, b = ray\n    if (a, b) in visit:\n        break\n    visit.add((a, b))\n    for sensor in d[(a, b)]:\n        sx, sy, i = sensor\n        if ans[i] == -1:\n            ans[i] = t + abs(x - sx)\n    ray = next(n, m, x, y, t, a, b)\n\nfor x in ans:\n    print(x)\n", "\n\n\"\"\"\nNTC here\n\"\"\"\nimport sys\ninp = sys.stdin.readline\ndef input(): return inp().strip()\n# flush= sys.stdout.flush\n# import threading\n# sys.setrecursionlimit(10**6)\n# threading.stack_size(2**26)\n\ndef iin(): return int(input())\n\n\ndef lin(): return list(map(int, input().split()))\n\n\n# range = xrange\n# input = raw_input\n\n\ndef main():\n\n    T = 1\n    def fn(ch, x, y):\n        return x*ch[0] + y*ch[1] + ch[2]==0\n    def fnx(ch, y):\n        return (-ch[1]*y-ch[2])/ch[0]\n    def fny(ch, x):\n        return (-ch[0]*x-ch[2])/ch[1]\n    def int_val(x):\n        return int(x*10000)==int(x)*10000\n    while T:\n        T-=1\n        n, m, k = lin()\n        h = m\n        w = n\n        end = {(0, h), (0, 0), (w, h), (w, 0)}\n        sensors = [lin() for _ in range(k)]\n        # we will track ray\n        # as line as set of ax+by+c=0\n        lines = {(1, -1, 0):[ (0, 0), 0]}\n        ch = [1, -1, 0]\n        ch1 = 1\n        ch2 = 0\n        st = [0, 0]\n        while 1:\n            # print('EQ-', ch)\n            # print(st)\n            dn = 0\n            # y = h\n            y1 = h\n            x1 = fnx(ch, y1)\n            # print(\"D\",[x1, y1])\n            if int_val(x1) and 0<=int(x1)<=w and [int(x1), int(y1)]!=st:\n                x1 = int(x1)\n                if x1 == w:\n                    break\n                dn = 1\n            # y = 0\n            if dn==0:\n                y1 = 0\n                x1 = fnx(ch, 0)\n                # print(\"A\",[x1, y1])\n                if int_val(x1) and 0<=int(x1)<=w and [int(x1), int(y1)] != st:\n                    x1 = int(x1)\n                    if x1 == 0:\n                        break\n                    dn = 1\n\n                if dn==0:\n                    # x = 0\n                    x1 = 0\n                    y1 = fny(ch, x1)\n                    # print(\"B\",[x1, y1])\n                    if int_val(y1) and 0<=int(y1)<=h and [int(x1), int(y1)] != st:\n                        y1 = int(y1)\n                        if y1 == 0:\n                            break\n                        dn = 1\n\n                    if dn==0:\n                        # x = w\n                        x1 = w\n                        y1 = fny(ch, x1)\n                        # print(\"C\",[x1, y1])\n                        if int_val(y1) and 0<=int(y1)<=h and [int(x1), int(y1)] != st:\n                            y1 = int(y1)\n                            if y1 == h:\n                                break\n                            dn = 1\n            if dn:\n                \n                # print(x1, y1)\n                ch2 += abs(st[0]-x1)\n                ch1 = -1 if ch1==1 else 1\n                ch = [ch1, -1, -ch1*x1+y1]\n                if tuple(ch) in lines:continue\n                lines[tuple(ch)] = [[x1, y1], ch2]\n                if (x1, y1) in end:break\n                \n                st = [x1, y1]\n            else:\n                break\n        # print(lines)\n        for i, j in sensors:\n            ch1, ch2 = (1, -1, -i+j), (-1, -1, i+j)\n            # print((i, j), ch1, ch2)\n            ans = -1\n            if ch1 in lines:    \n                p, c1 = lines[ch1]\n                ans = abs(p[0]-i)+c1\n            if ch2 in lines:\n                p, c1 = lines[ch2]\n                ans = abs(p[0]-i)+c1 if ans==-1 else min(abs(p[0]-i)+c1, ans)\n            print(ans)\n            \n\n\n\n\n\n\nmain()\n\n# threading.Thread(target=main).start()\n"]
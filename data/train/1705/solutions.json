["def spidey_swings(building_params):\n    buildings = get_buildings(building_params)\n    end_position = get_total_length(buildings)\n    latch_positions = []\n    jump_position = 0\n    while is_not_possible_to_reach_the_end(buildings, jump_position, end_position):\n        candidate_jumps = [\n            building.get_variables_for_max_displacement(jump_position)\n            for building in buildings\n            if building.is_reachable(jump_position)\n        ]\n        candidate_jumps.sort(reverse=True)\n        _, latch_position, jump_position = candidate_jumps[0]\n        latch_positions.append(latch_position)\n\n    candidate_final_jumps = [\n        building.get_variables_aiming_end(jump_position, end_position)\n        for building in buildings\n        if (building.is_reachable(jump_position) and\n            building.is_possible_to_reach_the_end(jump_position, end_position))\n    ]\n    candidate_final_jumps.sort(reverse=True)\n    _, latch_position = candidate_final_jumps[0]\n    latch_positions.append(latch_position)\n\n    return latch_positions\n\n\ndef get_buildings(building_params):\n    pos = 0\n    buildings = []\n    for (height, width) in building_params:\n        building = Building(height, width, pos)\n        buildings.append(building)\n        pos += width\n    return buildings\n\n\ndef get_total_length(buildings):\n    return sum(building.width for building in buildings)\n\n\ndef is_not_possible_to_reach_the_end(buildings, jump_position, end_position):\n    return not any(building.is_possible_to_reach_the_end(jump_position, end_position)\n                   for building in buildings)\n\n\nclass Building:\n    def __init__(self, height, width, pos):\n        self.height = height\n        self.width = width\n        self.pos = pos\n\n    def max_rope_length(self):\n        return self.height - 20\n\n    def distance_to_rooftop(self):\n        return self.height - 50\n\n    def max_horizontal_displacement(self):\n        hypotenuse = self.max_rope_length()\n        vertical = self.distance_to_rooftop()\n        return (hypotenuse ** 2 - vertical ** 2) ** .5\n\n    def latch_pos_for_max_displacement(self, jump_pos):\n        if jump_pos < self.pos - self.max_horizontal_displacement():\n            return None\n        if jump_pos < self.pos + self.width - self.max_horizontal_displacement():\n            return int(jump_pos + self.max_horizontal_displacement())\n        if jump_pos < self.pos + self.width:\n            return int(self.pos + self.width)\n        return None\n\n    def rope_length_for_max_displacement(self, jump_pos):\n        horizontal = (self.latch_pos_for_max_displacement(jump_pos) - jump_pos)\n        vertical = self.distance_to_rooftop()\n        return (horizontal ** 2 + vertical ** 2) ** .5\n\n    def advanced_distance_for_max_displacement(self, jump_pos):\n        return (self.latch_pos_for_max_displacement(jump_pos) - jump_pos) * 2\n\n    def ratio_max_displacement_rope(self, jump_pos):\n        return (self.advanced_distance_for_max_displacement(jump_pos) /\n                self.rope_length_for_max_displacement(jump_pos))\n\n    def get_variables_for_max_displacement(self, pos):\n        latch_pos = self.latch_pos_for_max_displacement(pos)\n        next_jump_pos = pos + self.advanced_distance_for_max_displacement(pos)\n        ratio = self.ratio_max_displacement_rope(pos)\n        return ratio, latch_pos, next_jump_pos\n\n    def latch_pos_aiming_end(self, jump_pos, end_pos):\n        max_latch_pos = (jump_pos + end_pos) / 2\n        if jump_pos < self.pos - self.max_horizontal_displacement():\n            return None\n        if jump_pos <= max_latch_pos:\n            max_latch_pos = max(max_latch_pos, self.pos)\n            return int(max_latch_pos + .5)\n        return None\n\n    def rope_length_aiming_end(self, pos, end_pos):\n        horizontal = self.latch_pos_aiming_end(pos, end_pos) - pos\n        vertical = self.distance_to_rooftop()\n        return (horizontal ** 2 + vertical ** 2) ** .5\n\n    def ratio_aiming_end(self, pos, end_pos):\n        horizontal = end_pos - pos\n        rope = self.rope_length_aiming_end(pos, end_pos)\n        ratio = horizontal / rope\n        return ratio\n\n    def get_variables_aiming_end(self, pos, end_pos):\n        latch_pos = self.latch_pos_aiming_end(pos, end_pos)\n        ratio = self.ratio_aiming_end(pos, end_pos)\n        return ratio, latch_pos\n\n    def is_possible_to_reach_the_end(self, pos, end_pos):\n        if not self.is_reachable(pos):\n            return False\n        return pos + self.advanced_distance_for_max_displacement(pos) >= end_pos\n\n    def is_reachable(self, pos):\n        return self.latch_pos_for_max_displacement(pos) is not None\n", "def spidey_swings(buildings):\n    answer = []\n    corners = []\n    sumWidths = 0\n    for (height, width) in buildings:\n        sumWidths += width\n        corners.append((sumWidths, height))\n    xSpidey, ySpidey = 0, 50\n    while True:\n        maxAvgYield, bestDist, bestX, bestReached = 0, None, None, False\n        minRope = 9999\n        xCornerLast = 0\n        for xCorner, yCorner in corners:\n            if xCorner <= xSpidey:\n                xCornerLast = xCorner\n                continue\n            for x in range(max(xSpidey, xCornerLast), xCorner + 1):\n                xDist = x - xSpidey\n                yDist = yCorner - ySpidey\n                lenRope = (xDist ** 2 + yDist ** 2) ** 0.5\n                if yCorner - lenRope < 20:\n                    break\n                dist = xDist * 2\n                reached = (xSpidey + dist >= sumWidths)\n                avgYield = dist / lenRope\n                if not reached and maxAvgYield < avgYield:\n                    maxAvgYield = avgYield\n                    bestDist = dist\n                    bestX = x\n                elif not bestReached and reached:\n                    minRope = lenRope\n                    bestDist = dist\n                    bestX = x\n                    bestReached = reached\n                elif bestReached and reached and minRope > lenRope:\n                    minRope = lenRope\n                    bestDist = dist\n                    bestX = x\n            xCornerLast = xCorner\n        answer.append(bestX)\n        xSpidey += bestDist\n        if xSpidey >= sumWidths:\n            break\n    return answer", "import math\n\ndef web_length(delta_x, height):\n    return math.sqrt(delta_x**2+(height-50)**2)\n\ndef score(distance, delta_x, height):\n    return distance/math.sqrt(delta_x**2+(height-50)**2)\n\ndef select_next_latch(cur_pos, buildings):\n\n    potiential_latch = []\n    for bd in buildings:\n        x_lower_bound = max(bd[0], cur_pos)\n        delta_x_upper_bound = min(math.floor(math.sqrt(bd[2]*60-2100)), bd[1]-cur_pos)\n        if x_lower_bound <= cur_pos + delta_x_upper_bound:\n            potiential_latch.append([x_lower_bound, cur_pos + delta_x_upper_bound, bd[2]])\n    \n    #latch loc, score, height\n    common_best = [cur_pos, 0, 0]\n    special_best = [-1, 0, 0]\n    for bd in potiential_latch:\n        for x in range(bd[0], bd[1]+1):\n            if cur_pos + 2*(x-cur_pos) >= buildings[-1][1]:\n                cur_score = score(buildings[-1][1]-cur_pos, x-cur_pos, bd[2])\n                if cur_score >= special_best[1]:\n                    special_best = [x, cur_score, bd[2]]\n            else:\n                cur_score = score(2*(x-cur_pos), x-cur_pos, bd[2])\n\n            if cur_score >= common_best[1]:\n                common_best = [x, cur_score, bd[2]]\n\n    return common_best, special_best\n\ndef search(cur_pos, end_pos, buildings):\n\n    if cur_pos >= end_pos: return 0, []\n    \n    cb, sb = select_next_latch(cur_pos, buildings)\n    \n    last_r = web_length(sb[0]-cur_pos, sb[2])\n    best_r = web_length(cb[0]-cur_pos, cb[2])\n\n    min_lenth, latch_list = search(cur_pos+2*(cb[0]-cur_pos), end_pos, buildings)\n\n    if sb[0] == -1 or sb[0] == cb[0]:\n        return min_lenth + best_r, [cb[0]] + latch_list\n    else:\n        if min_lenth + best_r > last_r:\n            return last_r, [sb[0]]\n        else:\n            return min_lenth + best_r, [cb[0]] + latch_list\n\ndef spidey_swings(ar):\n\n    buildings = []\n    start_pos = 0\n    for b in ar:\n        buildings.append([start_pos, start_pos+b[1], b[0]])\n        start_pos += b[1]\n    \n    cur_pos = 0\n    latch_points = []\n    while(cur_pos < buildings[-1][1]):\n        cb, sb = select_next_latch(cur_pos, buildings)\n\n        if sb[0] == -1 or sb[0] == cb[0]:\n            latch_points.append(cb[0])\n            cur_pos += (cb[0] - cur_pos)*2\n        else:\n            _, final_points = search(cur_pos, buildings[-1][1], buildings) \n            latch_points += final_points\n            cur_pos += (sb[0] - cur_pos)*2    \n    \n    return latch_points", "import math\n\ndef calc_web_length(current_loc, swing_point):\n    x = swing_point[0] - current_loc[0]\n    y = swing_point[1] - current_loc[1]\n    x_travel = 2 * x\n    web_length = math.sqrt(pow(x, 2) + pow(y, 2))\n    bottom_height = swing_point[1] - web_length\n    return x_travel, web_length, bottom_height\n\ndef spidey_swings(ar):\n    buildings = ar\n\n    # replace the building X positions with cumulative distances and\n    # ALL integer points along the way (inclusive)\n    # swap the order while we're at it to get normal (x,y) points\n    latch_points = []\n    prev_x = 0\n    for building in buildings:\n        for x in range(building[1] + 1):\n            latch_points.append([x + prev_x, building[0]])\n        prev_x += building[1]\n\n    # Record the final X position to be used for termination criteria\n    max_x = latch_points[-1][0]\n\n    # Loop Variables\n    current_location = [0, 50]\n    swing_list = []\n    swing_end = None\n    best_ratio = -999.0\n    best_building = None\n\n    while True:\n        building = latch_points.pop(0)\n\n        # Skip all latch points we may have passed during the swing\n        if building[0] <= current_location[0]:\n            continue\n\n        # Calculate data for the current 'test' latch point\n        x_travel, length, height = calc_web_length(current_location, building)\n        ratio = float(x_travel) / length\n\n        # Special check for end condition, this may be an non 'optimal' swing but\n        # if it lands exactly on the final position, it is the final latch point\n        if current_location[0] + x_travel >= max_x:\n            best_ratio = ratio\n            best_building = building\n            for ltch_pt in latch_points[:20]:\n                x_travel2, length2, height2 = calc_web_length(current_location, ltch_pt)\n                swing_end2 = current_location[0] + x_travel2\n\n                # Since this is at the end, we might over-travel, remove that extra\n                # distance when calculating the web ratio\n                extra_x = swing_end2 - max_x\n                x_travel2 -= extra_x\n                ratio2 = float(x_travel2) / length2\n\n                if ratio2 > best_ratio and height2 >= 20:\n                    best_ratio = ratio2\n                    best_building = ltch_pt\n\n            swing_list.append(best_building[0])\n            return swing_list\n\n        # Basic check: the point is good, check if it's better than any previous latch point\n        if ratio > best_ratio and height >= 20.0:\n            best_ratio = ratio\n            best_building = building\n            swing_end = current_location[0] + x_travel\n\n        # End check: if this point goes negative, all further ones will too, so use the best\n        # point up to here as the latch point and move current\n        if height < 20.0:\n            # just to be sure there aren't any better results, peak ahead for the next 50\n            # latch points to see if one is better\n            for ltch_pt in latch_points[:100]:\n                x_travel2, length2, height2 = calc_web_length(current_location, ltch_pt)\n                ratio2 = float(x_travel2) / length2\n                swing_end2 = current_location[0] + x_travel2\n                if swing_end2 >= max_x and height2 >= 20.0:\n                    swing_list.append(ltch_pt[0])\n                    return swing_list\n\n            best_ratio = -999.0\n            current_location[0] = swing_end\n            swing_list.append(best_building[0])\n\n    return swing_list\n", "from math import *\n\ndef horizontal_yield(x, point, end):\n    length = hypot(point[0]-x, point[1]-50)\n    distance = 2*(point[0]-x)\n    if distance > end - x: distance = end - x\n    return distance / length if point[1] - length >= 20 else 0\n\ndef optimal_latch(ar, x):\n    x_opt = 0\n    yield_opt = 0\n    for building in ar:        \n        if building[1] + building[2] < x: continue\n        x_max = x + int(sqrt((building[0]-20)**2-(building[0]-50)**2))\n        if x_max < building[2]: continue\n        if 2 * x_max - x > ar[-1][1] + ar[-1][2]:\n            x_max = max(building[2], int(ceil((ar[-1][1] + ar[-1][2] + x) / 2)))\n        x_max = min(x_max, building[1] + building[2])\n        yield_x = horizontal_yield(x, [x_max, building[0]], ar[-1][1] + ar[-1][2])\n        if yield_x > yield_opt or (2 * x_max - x >= ar[-1][1] + ar[-1][2] and 2 * x_opt - x < ar[-1][1] + ar[-1][2]):\n            yield_opt = yield_x\n            x_opt = x_max\n    return int(x_opt)\n        \n\ndef spidey_swings(ar):\n    print(ar)\n    spidey_x = 0\n    latches = []\n    for i in range(len(ar)):\n        ar[i].append(0 if i==0 else ar[i-1][1] + ar[i-1][2])\n    while spidey_x < ar[-1][1] + ar[-1][2]:\n        latches.append(optimal_latch(ar,spidey_x))   \n        spidey_x = 2 * latches[-1] - spidey_x\n    return latches", "def spidey_swings(Q) :\n    End = At = Pos = 0\n    Left = []\n    for V in Q :\n        Left.append(End)\n        End += V[1]\n    Left.append(End)\n    R = []\n    while At < len(Q) :\n        L = I = 0\n        F = At\n        while F < len(Q) :\n            W = Q[F][0] - 20\n            T = int((W * W - (W - 30) ** 2) ** .5)\n            if Left[F] <= Pos + T :\n                if End < Pos + T + T : T = max(1 + End - Pos >> 1,Left[F] - Pos)\n                if Left[1 + F] < Pos + T : T = Left[1 + F] - Pos\n                U = End <= Pos + T + T\n                W = (T * T + (Q[F][0] - 50) ** 2) ** .5\n                W = (T + T if Pos + T + T < End else End - Pos) / W\n                if L < W or not I and U : N,L = T,W\n                I = U\n            F += 1\n        R.append(Pos + N)\n        Pos += N + N\n        while At < len(Left) and Left[At] <= Pos : At += 1\n        At -= 1\n    return R", "import math\n\ndef spidey_swings(ar):\n    cur_pos = n = i = tz = 0\n    ratio = thyp = None\n    tome = []\n    ln = len(ar)\n    lim = int(math.sqrt(230**2-200**2))\n    buildings = []\n    for x in ar:\n        tz += x[1]\n        buildings.append(tz)\n    end = buildings[-1]\n\n    def find_index(r,g):\n        for q,z in enumerate(r):\n            if z > g: return q\n        return -1\n    \n    while i < ln:\n        h,w = ar[i]\n        pt1 = buildings[i] - cur_pos\n        pt0 = pt1 - w\n        max_x = int(math.sqrt((h-20)**2 - (h-50)**2))\n        if max_x >= pt0:\n            max_x = min(pt1,max_x)\n            ratio = [max_x,i] if ratio == None or max_x/math.hypot(max_x,h-50) > ratio[0]/math.hypot(ratio[0],ar[ratio[1]][0]-50) else ratio\n        if buildings[i] - w >= cur_pos + lim:\n            if end - lim * 2 < cur_pos:\n                i += 1\n                break\n            npos = cur_pos + ratio[0] * 2\n            tome.append(cur_pos + ratio[0])\n            while n < ln and buildings[n] <= npos: n += 1\n            cur_pos = npos\n            i = n - 1\n            ratio = None\n        i += 1\n    \n    if cur_pos == end: return tome\n    if cur_pos > end:\n        cur_pos -= (cur_pos - tome.pop()) * 2\n    tz = math.ceil((end-cur_pos)/2)\n    i = find_index(buildings,tz+cur_pos) + 1 or ln\n    thyp = math.hypot(tz,ar[i-1][0]-50)\n    if thyp > ar[i-1][0]-20: thyp = None\n    \n    for j in range(i,ln):\n        h,w = ar[j]\n        zz = math.hypot(h-50,buildings[j-1]-cur_pos)\n        if zz <= h - 20:\n            if thyp == None or thyp > zz:\n                tz = buildings[j-1] - cur_pos\n                thyp = zz\n                i = j\n    \n    if thyp == None:\n        tome.append(cur_pos+ratio[0])\n        cur_pos += ratio[0] * 2\n        tz = math.ceil((end-cur_pos)/2)\n        i = find_index(buildings,tz+cur_pos) + 1 or ln\n    \n    final_val = [tz+cur_pos,math.hypot(tz,ar[i-1][0]-50)]\n    for q,z in enumerate(ar[i:]):\n        h,w = z\n        hyp = math.hypot(buildings[i+q] - cur_pos - w,ar[i+q][0] - 50)\n        if final_val[1] > hyp and hyp < ar[i+q][0] - 20: final_val = [buildings[i+q]-w,hyp]\n    \n    tome.append(final_val[0])\n    return tome"]
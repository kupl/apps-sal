["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        # solution with DFS\n        def dfs(node, depth):\n            if not node:\n                return node, depth\n            left, l_depth = dfs(node.left, depth + 1)\n            right,r_depth = dfs(node.right,depth + 1)\n            if l_depth > r_depth:\n                return left, l_depth\n            if r_depth > l_depth:\n                return right,r_depth\n            return node,l_depth\n        return dfs(root,0)[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        def helper(root):\n            if not root:\n                return None, 0\n            left, h_l = helper(root.left)\n            right, h_r = helper(root.right)\n            if h_l == h_r:\n                return root, h_l + 1\n            return (left, h_l+1) if h_l > h_r else (right, h_r + 1)\n        node, _ = helper(root)\n        return node", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport heapq\n\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        nodes = []\n        self.counter = 0\n        def dfs(root, nodes, depth):\n            if not root.left and not root.right:\n                heapq.heappush(nodes, (-depth, self.counter, root))\n                self.counter += 1\n            if root.left:\n                dfs(root.left, nodes, depth + 1)\n            if root.right:\n                dfs(root.right, nodes, depth + 1)\n        dfs(root, nodes, 0)\n        deepestNodes = []\n        foundArr = []\n        maxDepth = nodes[0][0]\n        while nodes and nodes[0][0] == maxDepth:\n            deepestNodes.append(heapq.heappop(nodes)[2])\n            foundArr.append(False)\n        def helper(root, deepestNodes, foundArr):\n            for i in range(len(deepestNodes)):\n                if root == deepestNodes[i]:\n                    foundArr[i] = True\n                    break\n            leftArr = foundArr[:]\n            rightArr = foundArr[:]\n            leftFound = False\n            rightFound = False\n            if root.left:\n                resLeft = helper(root.left, deepestNodes, leftArr)\n                leftFound = True\n                for i in leftArr:\n                    if not i:\n                        leftFound = False\n                        break\n            if root.right and not leftFound:\n                resRight = helper(root.right, deepestNodes, rightArr)\n                rightFound = True\n                for i in rightArr:\n                    if not i:\n                        rightFound = False\n                        break\n            found = True\n            for i in range(len(foundArr)):\n                foundArr[i] = foundArr[i] or leftArr[i] or rightArr[i]\n            if leftFound:\n                return resLeft\n            elif rightFound:\n                return resRight\n            for i in foundArr:\n                if not i:\n                    found = False\n                    break\n            if found:\n                return root\n            else:\n                return None\n        return helper(root, deepestNodes, foundArr)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        \n        \n        def getDepth(root):\n            if not root:\n                return 0\n            left=getDepth(root.left)\n            right=getDepth(root.right)\n            return 1+max(left,right)\n        \n        def getSubtrees(root):\n            if root:\n                \n                leftDepth=getDepth(root.left)\n                rightDepth=getDepth(root.right)\n                if leftDepth==rightDepth:\n                    return root\n                elif leftDepth>rightDepth:\n                    return getSubtrees(root.left)\n                else:\n                    return getSubtrees(root.right)\n                \n        return getSubtrees(root)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport heapq\n\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        nodes = []\n        self.counter = 0\n        \n        def dfs(root, nodes, depth):\n            if not root.left and not root.right:\n                heapq.heappush(nodes, (-depth, self.counter, root))\n                self.counter += 1\n            if root.left:\n                dfs(root.left, nodes, depth + 1)\n            if root.right:\n                dfs(root.right, nodes, depth + 1)\n        dfs(root, nodes, 0)\n        deepestNodes = []\n        foundArr = []\n        maxDepth = nodes[0][0]\n        while nodes and nodes[0][0] == maxDepth:\n            deepestNodes.append(heapq.heappop(nodes)[2])\n            foundArr.append(False)\n            \n        def helper(root, deepestNodes, foundArr):\n            for i in range(len(deepestNodes)):\n                if root == deepestNodes[i]:\n                    foundArr[i] = True\n                    break\n            leftArr = foundArr[:]\n            rightArr = foundArr[:]\n            leftFound = False\n            rightFound = False\n            if root.left:\n                resLeft = helper(root.left, deepestNodes, leftArr)\n                leftFound = True\n                for i in leftArr:\n                    if not i:\n                        leftFound = False\n                        break\n            if root.right and not leftFound:\n                resRight = helper(root.right, deepestNodes, rightArr)\n                rightFound = True\n                for i in rightArr:\n                    if not i:\n                        rightFound = False\n                        break\n            found = True\n            for i in range(len(foundArr)):\n                foundArr[i] = foundArr[i] or leftArr[i] or rightArr[i]\n            if leftFound:\n                return resLeft\n            elif rightFound:\n                return resRight\n            for i in foundArr:\n                if not i:\n                    found = False\n                    break\n            if found:\n                return root\n            else:\n                return None\n            \n        return helper(root, deepestNodes, foundArr)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return root\n        \n        deepest = [[]]\n        max_depth = [0]\n        self.mark_depth_and_parent(root, deepest, max_depth)\n        # print(f\\\"DEEPEST : {[n.val for n in deepest[0]]} @ DEPTH = {max_depth[0]}\\\")\n        return self.get_lca(deepest[0])\n        \n    \n    def mark_depth_and_parent(self, root, deepest, max_depth, depth=0, parent=None):\n        if not root:\n            return\n        \n        # print(f\\\"{root.val} | Depth : {depth}\\\")\n        if depth > max_depth[0]:\n            max_depth[0] = depth\n            deepest[0] = [root]\n        elif depth == max_depth[0]:\n            deepest[0].append(root)\n            \n        root.depth = depth\n        root.parent = parent\n        self.mark_depth_and_parent(root.left, deepest, max_depth, depth + 1, root)\n        self.mark_depth_and_parent(root.right, deepest, max_depth, depth + 1, root)\n        \n    def get_lca(self, deepest):\n        while len(deepest) > 1:\n            n1, n2 = deepest.pop(), deepest.pop()\n            while n1 and n1.depth > n2.depth:\n                n1 = n1.parent\n            while n2 and n2.depth > n1.depth:\n                n2 = n2.parent\n            while n1 != n2:\n                n1 = n1.parent\n                n2 = n2.parent\n            deepest.append(n1)\n        return deepest[0]\n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        def deep(node):\n            if not node:\n                return 0, None\n            ld=deep(node.left)\n            rd=deep(node.right)\n            \n            if ld[0]>rd[0]:\n                return ld[0]+1, ld[1]\n            elif rd[0]>ld[0]:\n                return rd[0]+1, rd[1]\n            else:\n                return ld[0]+1, node\n            \n            \n        return deep(root)[1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        \n        def helper(node, depth):\n            if not node:\n                return depth, None\n            \n            ld, ln = helper(node.left, depth+1)\n            rd, rn = helper(node.right, depth+1)\n            \n            if ld == rd:\n                return ld, node\n            \n            if ld > rd:\n                return ld, ln\n            \n            if ld < rd:\n                return rd, rn\n            \n        \n        depth, res = helper(root, 0)\n        \n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        #   \u627e\u6700\u6df1\u8282\u70b9\u7684\u516c\u5171\u7236\u8282\u70b9\n        \n        #   The values of the nodes in the tree are unique.\n        \n        #   \u7b2c\u4e00\u6b21\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\u3002\u7136\u540e\u627e\u5230\u6700\u6df1\u7684\u8282\u70b9\n        #   \u5982\u679c\u53ea\u6709\u4e00\u4e2a\uff0c\u8fd4\u56de\u4ed6\u81ea\u5df1\u3002\u6709\u591a\u4e2a\u7684\uff1f\n        \n        #   \u7b2c\u4e8c\u6b21\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u76ee\u6807\u8282\u70b9\u7684\u8def\u5f84(\u8def\u5f84\u957f\u5ea6\u76f8\u540c)\u3002\u518d\u4ece\u53f3\u8fb9\u627e\u6700\u540e\u4e00\u4e2a\u76f8\u540c\u7684\u8282\u70b9\u3002\n        \n        def calcdeep(root, d, level):\n            if level not in d:\n                d[level] = []\n            d[level].append(root)\n            r1 = r2 = level\n            if root.left  != None:\n                r1 = calcdeep(root.left , d, level+1)\n            if root.right != None:\n                r2 = calcdeep(root.right, d, level+1)\n            return max(r1,r2)\n        \n        d = dict()\n        maxl = calcdeep(root, d, 0)\n        if len(d[maxl]) == 1:\n            return d[maxl][0]\n        \n        #   \u5bfb\u627e\u516c\u5171\u7236\u8282\u70b9\u5566        \n        def check2(root, ts, prefix, d):\n            if root == None:\n                return\n            prefix.append(root)\n            if root in ts:\n                d[root.val] = copy.deepcopy(prefix)\n            \n            check2(root.left , ts, prefix, d)\n            check2(root.right, ts, prefix, d)\n            prefix.pop()\n            \n        targets = d[maxl]\n        d = dict()\n        prefix = []\n        check2(root, targets, prefix, d)\n        idx = maxl-1\n        # print(d)\n        while idx >= 0:\n            # print(idx)\n            vals = list(d.values())\n            t = vals[0][idx]\n            failed = False\n            for val in list(d.values()):\n                if val[idx].val != t.val:\n                    failed = True\n                    break\n            if failed == False:\n                return t\n            idx -= 1\n        return None\n\n"]
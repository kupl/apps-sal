["MOD=10**9+7\nN,C=map(int, input().split())\nA=list(map(int, input().split()))\nB=list(map(int, input().split()))\nP=[[1] for _ in range(401)]\nfor _ in range(1,401):\n    for i in range(1,401):\n        P[i].append(P[i][-1]*i%MOD)\nR=[[] for _ in range(N)]\nfor i,AB in enumerate(zip(A, B)):\n    AA,BB=AB\n    for a in range(401):\n        tmp=0\n        for x in range(AA,BB+1):\n            tmp+=P[x][a]\n            tmp%=MOD\n        R[i].append(tmp)\ndp=[[0]*(C+1) for _ in range(N+1)]\ndp[0][0]=1\nfor n in range(1,N+1):\n    for k in range(C+1):\n        for l in range(k+1):\n            dp[n][k]+=dp[n-1][k-l]*R[n-1][l]\n            dp[n][k]%=MOD\nprint(dp[N][C])", "n,c = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nab = list(zip(a,b))\ntable = [[0 for i in range(c+1)] for j in range(401)]\nmod = 10**9+7\nfor j in range(c+1):\n  if j == 0:\n    for i in range(401):\n      table[i][j] = 1\n  else:\n    for i in range(401):\n      table[i][j] = table[i][j-1]*i%mod\ndp = [[0 for i in range(c+1)] for j in range(n+1)]\nfor i in range(c+1):\n  dp[0][i] = 1\nfor i in range(1,n+1):\n  a,b = ab[i-1]\n  for j in range(a,b+1):\n    for k in range(c+1):\n      dp[i][k] = (dp[i][k]+table[j][k])%mod\nans = [[0 for i in range(c+1)] for j in range(n+1)]\nans[0][0] = 1\nfor i in range(1,n+1):\n  for j in range(c+1):\n    for k in range(j+1):\n      ans[i][j] = (ans[i][j]+dp[i][k]*ans[i-1][j-k])%mod\nprint(ans[n][c])", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nMOD = 10**9+7\n\nn, c = map(int, input().split())\nA = np.array(tuple(map(int, input().split())))\nB = np.array(tuple(map(int, input().split())))\nE = np.zeros((n, c+1), dtype=np.int64)\nfor j in range(c+1):\n  cum = np.array(tuple(pow(k, j, MOD) for k in range(401))).cumsum()%MOD\n  E[:, j] = cum[B] - cum[A-1]\n\ndp = np.zeros((n+1, c+1), dtype=np.int64)\ndp[0, 0] = 1\nfor i, e in enumerate(E):\n  for j, f in enumerate(e):\n    dp[i+1, j:] += dp[i, :c+1-j]*f\n    dp[i+1] %= MOD\nans = dp[n, c]\nprint(ans)", "'''\n\u7814\u7a76\u5ba4PC\u3067\u306e\u89e3\u7b54\n'''\nimport math\n#import numpy as np\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\n\ndef main():\n    n,c = list(map(int,ipt().split()))\n    a = [int(i) for i in ipt().split()]\n    b = [int(i) for i in ipt().split()]\n    nj = [[] for j in range(c+1)]\n    nj[0] = [1]*401\n    for j in range(1,c+1):\n        for i in range(401):\n            nj[j].append(nj[j-1][i]*i%mod)\n    snj = [[0] for j in range(c+1)] #\u7d2f\u7a4d\u548c,snj[j][b]-snj[j][a-1]\u3067\u4f7f\u7528\n    for j in range(c+1):\n        sj = snj[j]\n        ssj = nj[j]\n        for i in range(1,401):\n            sj.append((sj[-1]+ssj[i])%mod)\n    dp = [snj[k][b[0]]-snj[k][a[0]-1] for k in range(c+1)]\n    for i in range(1,n):\n#        print(dp)\n        ai = a[i]\n        bi = b[i]\n        for j in range(c,-1,-1):\n            dp[j] = dp[j]*(bi-ai+1)%mod\n            for k in range(1,j+1):\n                dp[j] = (dp[j]+dp[j-k]*(snj[k][bi]-snj[k][ai-1]))%mod\n\n    print((dp[c]%mod))\n\n\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nMOD = 10 ** 9 + 7\n\nN,C = map(int,input().split())\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\n\n# (i,j) \u306b j^i \u3092\u5165\u308c\u308b\nkth_pow = np.ones((1024, 401), dtype=np.int64)\nrng = np.arange(401, dtype=np.int64)\nfor i in range(1,C+1):\n    kth_pow[i] = kth_pow[i-1] * rng % MOD\nkth_pow_cum = kth_pow.cumsum(axis = 1) % MOD\nkth_pow_cum[C+1:] = 0\n\ndef convolve(A,B,n=32):\n    if n == 8:\n        return np.rint(np.fft.irfft(np.fft.rfft(A) * np.fft.rfft(B))).astype(np.int64)\n    n //= 2\n    M = 1 << n\n    A1 = A // M\n    A2 = A - M * A1\n    B1 = A // M\n    B2 = B - M * B1\n    X = convolve(A1,B1,n)\n    Y = convolve(A1-A2,B1-B2,n)\n    Z = convolve(A2,B2,n)\n    return (X * (M * M % MOD) + (X + Z - Y) * M + Z) % MOD\n\ndp = np.zeros(1024, dtype=np.int64) # \u3053\u308c\u307e\u3067\u914d\u3063\u305f\u500b\u6570\u3001\u5408\u8a08\u70b9\ndp[0] = 1\nfor a,b in zip(A,B):\n    arr = kth_pow_cum[:,b] - kth_pow_cum[:,a-1]\n    dp = convolve(dp,arr)\n    dp[C+1:] = 0\n\nanswer = dp[C]\nprint(answer)", "import sys\nN,C=list(map(int,input().split()))\nA=[int(i) for i in input().split()]\nB=[int(i) for i in input().split()]\nmod=10**9+7\ntable=[[ pow(j,i,mod) for j in range(405)] for i in range(405)]\nntable=[[0]*405 for i in range(405)]\nfor i in range(405):\n    t=0\n    for j in range(1,405):\n        t+=table[i][j]\n        t%=mod\n        ntable[i][j]=t\nF=[B[i]-A[i]+1 for i in range(N)]\nG=[0]*N\nt=1\nfor i in range(N):\n    t*=F[i]\n    t%=mod\nfor i in range(N):\n    G[i]=(t*pow(F[i],mod-2,mod))%mod\n#print(G)\ndp=[[0]*(C+1) for i in range(N)]\nfor i in range(C+1):\n    dp[0][i]=((ntable[i][B[0]]-ntable[i][A[0]-1]))%mod#*G[0]\nfor i in range(1,N):\n    for k in range(C+1):\n        for l in range(k+1):\n            dp[i][k]+=dp[i-1][l]*(ntable[k-l][B[i]]-ntable[k-l][A[i]-1])#*G[i]\n            dp[i][k]%=mod\n#print(dp)\nprint((dp[N-1][C]))\n\n", "MOD=10**9+7\n# 0 to q no i\u4e57\u548c\ntab=[]\nfor i in range(401):\n    now=[]\n    cnt=0\n    for q in range(401):\n        cnt+=pow(q,i,MOD)\n        now.append(cnt)\n    tab.append(now[:])\n    \nn,c=map(int,input().split())\nA=[int(i) for i in input().split()]\nB=[int(i) for i in input().split()]\n\nenji=[]\nfor i in range(n):\n    now=[]\n    for q in range(c+1):\n        now.append(tab[q][B[i]]-tab[q][A[i]-1])\n    enji.append(now[:])\n\ndp=[0 for i in range(c+1)]\ndp[0]=1\nndp=[0 for i in range(c+1)]\nfor i in range(n):\n    for step in range(c+1):\n        val=enji[i][step]%MOD\n        for fr in range(c+1-step):\n            ndp[fr+step]+=dp[fr]*val%MOD\n            ndp[fr+step]%=MOD\n            #print(ndp)\n    dp=ndp[:]\n    ndp=[0 for i in range(c+1)]\n    #print(dp)\nprint(dp[-1])", "import sys\nN,C=list(map(int,input().split()))\nA=[int(i) for i in input().split()]\nB=[int(i) for i in input().split()]\nmod=10**9+7\ntable=[[ pow(j,i,mod) for j in range(405)] for i in range(405)]\nntable=[[0]*405 for i in range(405)]\nfor i in range(405):\n    t=0\n    for j in range(1,405):\n        t+=table[i][j]\n        t%=mod\n        ntable[i][j]=t\ndp=[[0]*(C+1) for i in range(N)]\nfor i in range(C+1):\n    dp[0][i]=((ntable[i][B[0]]-ntable[i][A[0]-1]))%mod\nfor i in range(1,N):\n    for k in range(C+1):\n        for l in range(k+1):\n            dp[i][k]+=dp[i-1][l]*(ntable[k-l][B[i]]-ntable[k-l][A[i]-1])\n            dp[i][k]%=mod\nprint((dp[N-1][C]))\n\n", "N, C = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nMOD = 10**9 + 7\n\ndef gen_poly(a, b, c):\n  poly = [0 for _ in range(c+1)]\n  for x in range(a, b+1):\n    xpow = 1\n    for i in range(c+1):\n      poly[i] += xpow\n      xpow = (xpow * x) % MOD\n  for i in range(c+1):\n    poly[i] %= MOD\n  return poly\n\ndef mult_polys(p1, p2, dmax):\n  ans = [0 for _ in range(dmax+1)]\n  for i, c in enumerate(p1):\n    for i2, c2 in enumerate(p2):\n      if i + i2 <= dmax:\n        ans[i+i2] += c*c2\n      else:\n        break\n  ans = [x % MOD for x in ans]\n  return ans\n\npolys = [gen_poly(a, b, C) for a, b in zip(A, B)]\nprodpoly = [1]\nfor poly in polys:\n  prodpoly = mult_polys(prodpoly, poly, C)\n\nprint(prodpoly[C])", "N, C = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nMOD = 10**9 + 7\nMB = max(B)\n\nSm = [[1 for _ in range(MB+1)]]\nfor c in range(1,C+1):\n  Sm.append([])\n  s = Sm[-1]\n  sp = Sm[-2]\n  for i in range(MB+1):\n    s.append((i*sp[i]) % MOD)\n    \nfor c in range(C+1):\n  s = Sm[c]\n  for i in range(1,MB+1):\n    s[i] += s[i-1]\n    s[i] %= MOD\n    \nDP = [[0 for _ in range(C+1)] for _ in range(N+1)]\nDP[0][0] = 1\nfor n in range(1,N+1):\n  dp = DP[n]\n  dpp = DP[n-1]\n  for c in range(C+1):\n    for cc in range(C+1-c):\n      dp[c+cc] += dpp[c] * (Sm[cc][B[n-1]] - Sm[cc][A[n-1]-1])\n      dp[c+cc] %= MOD\nprint((DP[N][C] % MOD))\n    \n", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n\n    return\n\n#B\ndef B():\n\n    return\n\n#C\ndef C():\n    n,c = LI()\n    a = LI()\n    b = LI()\n    s = [[0]*(c+1) for i in range(n)]\n    for i in range(n):\n        ai,bi = a[i],b[i]\n        for x in range(ai,bi+1):\n            e = 1\n            for k in range(c+1):\n                s[i][k] += e\n                if s[i][k] >= mod:\n                    s[i][k] %= mod\n                e *= x\n                if e >= mod:\n                    e %= mod\n    dp = [[0]*(c+1) for i in range(n)]\n    for k in range(c+1):\n        dp[0][k] = s[0][k]\n\n    for i in range(1,n):\n        for k in range(c+1):\n            for j in range(k+1):\n                dp[i][k] += dp[i-1][j]*s[i][k-j]\n                if dp[i][k] >= mod:\n                    dp[i][k] %= mod\n    print((dp[-1][c]))\n    return\n\n#D\ndef D():\n\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\ndef __starting_point():\n    C()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n# mod\u3092\u53d6\u308a\u306a\u304c\u3089\u3079\u304d\u4e57\u3059\u308b\ndef power_func(a,n,mod):\n    bi=str(format(n,\"b\"))#2\u9032\u8868\u73fe\u306b\n    res=1\n    for i in range(len(bi)):\n        res=(res*res) %mod\n        if bi[i]==\"1\":\n            res=(res*a) %mod\n    return res\n\ndef main():\n    N, C = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    mod = 10**9+7\n    L = 400\n\n    dp = [[0]*(L+1) for _ in range(C+1)]\n    count = B[0] - A[0] + 1\n    for c in range(C+1):\n        a, b = A[0], B[0]\n        dp[c][0] = power_func(a, c, mod)\n        for k in range(1, b-a+1):\n            dp[c][k] = (dp[c][k-1] + power_func(a+k, c, mod)) % mod\n        dp[c][L] = dp[c][b-a]\n\n    for i, (a, b) in enumerate(zip(A, B)):\n        if i == 0: continue\n        for k in range(b-a+1):\n            dp[0][k] = count * (k+1) % mod\n        dp[0][L] = dp[0][b-a]\n        for c in range(1, C+1):\n            dp[c][0] = (dp[c][L] + a*dp[c-1][0]) % mod\n            for k in range(1, b-a+1):\n                R = dp[c][k-1] + dp[c][L] + (a+k)*(dp[c-1][k]-dp[c-1][k-1])\n                if R < 0: R += mod\n                dp[c][k] = R%mod\n            dp[c][L] = dp[c][b-a]\n        count = (count * (b-a+1)) % mod\n\n    print(dp[C][L])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate\n\nMOD = 10**9+7\n\nn, c = map(int, input().split())\nA = tuple(map(int, input().split()))\nB = tuple(map(int, input().split()))\nE = [[0]*(c+1) for _ in range(n)]\nfor j in range(c+1):\n  cumsum = tuple(pow(k, j, MOD) for k in range(401))\n  cumsum = tuple(i%MOD for i in accumulate(cumsum))\n  for i, (a, b) in enumerate(zip(A, B)):\n    E[i][j] = cumsum[b] - cumsum[a-1]\n\ndp = [[0]*(c+1) for _ in range(n+1)]\ndp[0][0] = 1\nfor i, e in enumerate(E):\n  for j, f in enumerate(e):\n    for k in range(c+1):\n      if j+k <= c:\n        dp[i+1][j+k] += dp[i][k]*f\n        dp[i+1][j+k] %= MOD\nans = dp[n][c]\nprint(ans)", "n,c = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nmod = 10**9+7\n\nex400 = [[1] * 401 for _ in range(401)]\nfor i in range(2,401):\n    for j in range(1,401):\n        ex400[i][j] = (ex400[i][j-1] * i) % mod\n\ncumsum400 = [[1] * 401 for _ in range(401)]\nfor i in range(1,401):\n    for j in range(401):\n        cumsum400[i][j] = (cumsum400[i-1][j] + ex400[i][j]) % mod\n\ndp = [[0] * (c+1) for _ in range(n+1)]\ndp[0][0] = 1\n\n\nfor i in range(1,n+1):\n    for j in range(c+1):\n        for k in range(j+1):\n            dp[i][j] += dp[i-1][j-k] * (cumsum400[b[i-1]][k] - cumsum400[a[i-1]-1][k])\n            dp[i][j] %= mod\n\nprint(dp[-1][-1])", "MOD = 10**9 + 7\nn, m = [int(item) for item in input().split()]\na = [int(item) for item in input().split()]\nb = [int(item) for item in input().split()]\n\ncumsum = [[1] * 410 for _ in range(410)]\nfor order in range(405):\n    for i in range(1, 405):\n        cumsum[order][i] = pow(i, order, MOD) + cumsum[order][i-1]\n        cumsum[order][i] %= MOD\n\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[0][0] = 1\nfor i in range(1, n+1):\n    for j in range(0, m+1):\n        for k in range(j+1):\n            l = a[i - 1]\n            r = b[i - 1]\n            x = (cumsum[j-k][r] - cumsum[j-k][l-1] + MOD) % MOD\n            dp[i][j] += dp[i-1][k] * x \n        dp[i][j] %= MOD\n\nprint(dp[-1][-1])", "N, C = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nmod = 10**9+7\n\nacc = [[0] for _ in range(401)]\nfor i in range(401):\n    for j in range(1, 401):\n        acc[i].append(((acc[i][-1] + pow(j, i, mod)) % mod))\n\ndp = [[0 for _ in range(C+1)] for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(N):\n    for candy_cur in range(C+1):\n        for candy_plus in range(C - candy_cur+1):\n            dp[i+1][candy_cur + candy_plus] = (dp[i+1][candy_cur + candy_plus] + (dp[i][candy_cur]\\\n                                               * ((acc[candy_plus][B[i]] - acc[candy_plus][A[i]-1])%mod)%mod)) % mod\n\nprint((dp[-1][C]))\n", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nMOD = 10**9+7\n\nn, c = map(int, input().split())\nA = np.array(tuple(map(int, input().split())))\nB = np.array(tuple(map(int, input().split())))\nE = np.zeros((n, c+1), dtype=np.int64)\nfor j in range(c+1):\n  cum = np.array(tuple(pow(k, j, MOD) for k in range(401))).cumsum()%MOD\n  E[:, j] = cum[B] - cum[A-1]\n\ndp = np.zeros((n+1, c+1), dtype=np.int64)\ndp[0, 0] = 1\nfor i, e in enumerate(E):\n  for j, f in enumerate(e):\n    dp[i+1][j:] += dp[i][:c+1-j]*f\n    dp[i+1] %= MOD\nans = dp[n, c]\nprint(ans)", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,c = list(map(int,readline().split()))\n*a, = list(map(int,readline().split()))\n*b, = list(map(int,readline().split()))\n\nM = 401\nMOD = 10**9+7\n\npowsum = []\nfor i in range(M):\n    res = [pow(j,i,MOD) for j in range(M)]\n    for j in range(1,M):\n        res[j] = (res[j]+res[j-1])%MOD\n    powsum.append(res)\n\ndp = [0]*(c+1) # dp[i][k] = i \u307e\u3067\u898b\u3066 k\u6b21\u6589\u6b21\u5f0f\ndp[0] = 1\n\nfor ai,bi in zip(a,b):\n    ndp = [0]*(c+1)\n    for k in range(c+1):\n        for j in range(k+1):\n            ndp[k] += (powsum[j][bi]-powsum[j][ai-1])*dp[k-j]%MOD\n        ndp[k] %= MOD\n\n    dp = ndp\n\nprint((dp[c]%MOD))\n\n\n", "# \u30ad\u30e3\u30f3\u30c7\u30a3\u30fc\u3068N\u4eba\u306e\u5b50\u4f9b\n\nmod = 10**9 + 7\nN, C = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n\ndef rev(X):\n    return pow(X, mod-2, mod)\n\n\npow_sum = [[B[i]-A[i]+1 for j in range(C+1)] for i in range(N)]\npow_table = [[1 for j in range(401)] for i in range(401)]\nfor i in range(401):\n    for j in range(401):\n        pow_table[i][j] = pow(i, j, mod)\n\nfor cnt in range(C):\n    for i in range(N):\n        pow_sum[i][cnt+1] = 0\n        for j in range(A[i], B[i]+1):\n            pow_sum[i][cnt+1] += pow_table[j][cnt+1]\n        pow_sum[i][cnt+1] %= mod\n\nans_dp = [[0 for i in range(C+1)] for j in range(N+1)]\n# ans_dp[x][y] = 0<=x<=N,0<=y<=C \u306e\u5834\u5408\u306edp\nans_dp[0][0] = 1\nfor n in range(1, N+1):\n    # ans_dp[n]\u306e\u66f4\u65b0\n    for c in range(C+1):\n        # ans_dp[n][c]\u306e\u66f4\u65b0\n        for k in range(c+1):\n            ans_dp[n][c] += ans_dp[n-1][k]*pow_sum[n-1][c-k]\n        ans_dp[n][c] %= mod\nprint(ans_dp[N][C] % mod)", "from itertools import accumulate\nN, C = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nmod = 10**9 + 7\nX = [list(accumulate([pow(x, d, mod) for x in range(401)])) for d in range(C+1)]\ndp = [[0]*(C+1) for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(1, N+1):\n    for d in range(C+1):\n        dp[i][d] = sum([dp[i-1][d-k]*(X[k][B[i-1]] - X[k][A[i-1]-1]) for k in range(d+1)])%mod\n        \nprint(dp[-1][-1])", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nMOD = 10 ** 9 + 7\n\nN,C = list(map(int,input().split()))\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\n\n# (i,j) \u306b j^i \u3092\u5165\u308c\u308b\nkth_pow = np.ones((C+1, 401), dtype=np.int64)\nrng = np.arange(401, dtype=np.int64)\nfor i in range(1,C+1):\n    kth_pow[i] = kth_pow[i-1] * rng % MOD\nkth_pow_cum = kth_pow.cumsum(axis = 1) % MOD\n\ndp = np.zeros((C+1), dtype=np.int64) # \u3053\u308c\u307e\u3067\u914d\u3063\u305f\u500b\u6570\u3001\u5408\u8a08\u70b9\ndp[0] = 1\nfor a,b in zip(A,B):\n    arr = kth_pow_cum[:,b] - kth_pow_cum[:,a-1]\n    prev = dp\n    dp = np.zeros(C+1, dtype=np.int64)\n    for n in range(C+1):\n        dp[n:] += arr[n] * prev[:C+1-n] % MOD\n    dp %= MOD\n\nanswer = dp[C]\nprint(answer)\n\n", "n, c = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nmod = pow(10, 9) + 7\npowlist = [[1] * 405 for _ in range(405)]\nfor i in range(1, 405):\n    for j in range(1, 405):\n        powlist[i][j] = j * powlist[i - 1][j] % mod\nfor i in range(405):\n    for j in range(1, 405):\n        powlist[i][j] += powlist[i][j - 1]\n        powlist[i][j] %= mod\nx = [[0] * (c + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(c + 1):\n        x[i][j] = powlist[j][b[i - 1]] - powlist[j][a[i - 1] - 1]\n        x[i][j] %= mod\ndp = [[0] * (c + 1) for _ in range(n + 1)]\ndp[0][0] = 1\nfor i in range(1, n + 1):\n    for j in range(c + 1):\n        s = 0\n        for k in range(j + 1):\n            s += dp[i - 1][k] * x[i][j - k]\n            s %= mod\n        dp[i][j] = s\nans = dp[n][c]\nprint(ans)", "import sys\nfrom itertools import accumulate\nreadline = sys.stdin.readline\nMOD = 10**9+7\n\nN, C = map(int, readline().split())\nA = [0] + list(map(int, readline().split()))\nB = [0] + list(map(int, readline().split()))\n\nacsq = []\nlb = max(B)+1\nfor j in range(C+1):\n    ac = [0]*lb\n    ac[0] = 1\n    for i in range(1, lb):\n        ac[i] = (ac[i-1] + pow(i, j, MOD)) % MOD\n    acsq.append(ac)\ndp = [[0]*(C+1) for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(1, N+1):\n    a, b = A[i], B[i]\n    for c in range(C+1):\n        res = 0\n        for j in range(c+1):\n            res = (res + (acsq[c-j][b] - acsq[c-j][a-1])*dp[i-1][j]) % MOD\n        dp[i][c] = res\nprint(dp[N][C])", "N,C=map(int,input().split())\nA=[int(i) for i in input().split()]\nB=[int(i) for i in input().split()]\nmod=10**9+7\nexponen=[[0 for j in range(401)]for i in range(401)]\nfor i in range(401):\n    exponen[i][0]=1\n    for j in range(400):\n        exponen[i][j+1]=(exponen[i][j]*i)%mod\nexpsum=[[0 for j in range(401)] for i in range(402)]\nfor j in range(401):\n    for i in range(401):\n        expsum[i+1][j]=(expsum[i][j]+exponen[i][j])%mod\nfunc=[[0 for j in range(C+1)] for i in range(N)]\ndp=[[0 for j in range(C+1)] for i in range(N+1)]\ndp[0][0]=1\nfor i in range(N):\n    for j in range(C+1):\n        func[i][j]=(expsum[B[i]+1][j]-expsum[A[i]][j])%mod\nfor i in range(N):\n    for x in range(C+1):\n        for y in range(C+1):\n            if (x+y>C):\n                continue\n            dp[i+1][x+y]+=dp[i][x]*func[i][y]\n            dp[i+1][x+y]%=mod\nprint(dp[N][C])", "N,C=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nMod=10**9+7\n\nB_max=max(B)\nP=[[0]*(C+1) for _ in range(B_max+1)]\n\nfor x in range(B_max+1):\n    E=P[x]\n    E[0]=1\n    t=1\n    for k in range(1,C+1):\n        E[k]=t=(t*x)%Mod\n\nT=[]\nfor i in range(N):\n    U=[0]*(C+1)\n    for x in range(A[i],B[i]+1):\n        for k in range(C+1):\n            U[k]+=P[x][k]\n            U[k]%=Mod\n    T.append(U)\n\nP=[1]+[0]*C\nfor Q in T:\n    X=[0]*(C+1)\n\n    for i in range(C+1):\n        for j in range(C+1):\n            if i+j>C:\n                break\n            X[i+j]+=P[i]*Q[j]\n            X[i+j]%=Mod\n    P=X.copy()\n\nprint(X[C])", "mod = 10**9+7\nN, C = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndp = [[0]*(C+1) for i in range(N+1)]\ndp[-1][0] = 1\nS = [[0]*(C+1) for _ in range(N+1)]\nfor i in range(N):\n    power = [1]*(400+1)\n    for j in range(C+1):\n        for x in range(A[i], B[i]+1):\n            S[i][j]+=power[x]\n            S[i][j]%=mod\n            power[x]*=x\n            power[x]%=mod\nfor i in range(N):#i\u3070\u3093\u3081\n    for j in range(C+1):#j\u3053\u306e\u30ad\u30e3\u30f3\u30c7\u30a3\u30fc\n        for k in range(j+1):#i\u3070\u3093\u3081\u306bk\u5b50\u304f\u3070\u308b\n            dp[i][j] += dp[i-1][j-k]*S[i][k]\n            dp[i][j]%=mod\nprint((dp[-2][-1]))\n\n", "N,C=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nDP=[[0]*(C+1) for i in range(N+1)]\nDP[0][0]=1\nmod=10**9+7\nX=[[0] for i in range(401)]\nfor i in range(401):\n  for j in range(401):\n    X[i].append((X[i][j]+pow(j,i,mod))%mod)\nfor i in range(N):\n  for j in range(C+1):\n    for k in range(j+1):\n      DP[i+1][j]=(DP[i][j-k]*(X[k][B[i]+1]-X[k][A[i]])+DP[i+1][j])%mod\nprint(DP[N][C])", "MOD = 10**9+7\nn, c = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nsig = [[0 for _ in range(max(b)+1)] for _ in range(c+1)]\nfor i in range(c+1):\n\tfor j in range(1, max(b)+1):\n\t\tsig[i][j] = sig[i][j-1] + pow(j, i, MOD)\n\t\tsig[i][j] %= MOD\n\ndef sigma(C, A, B):\n\treturn (sig[C][B] - sig[C][A-1]) % MOD\n\ndp = [[0 for _ in range(c+1)] for _ in range(n)]\nfor j in range(c+1):\n\tdp[0][j] = sigma(j, a[0], b[0])\n\nfor i in range(1, n):\n\tfor j in range(c+1):\n\t\tfor k in range(j+1):\n\t\t\tdp[i][j] += dp[i-1][k] * sigma(j-k, a[i], b[i])\n\t\t\tdp[i][j] %= MOD\n\nprint(dp[n-1][c])", "mod=10**9+7\n\ntable=[[0 for i in range(401)] for j in range(401)]\nfor i in range(401):\n    S=0\n    for j in range(1,401):\n        S+=pow(j,i,mod)\n        S%=mod\n        table[i][j]=S\n\nN,C=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\n\ndp=[[0 for i in range(C+1)] for j in range(N)]\n\nfor i in range(C+1):\n    dp[0][i]=table[i][B[0]]-table[i][A[0]-1]\n    dp[0][i]%=mod\n\nfor i in range(1,N):\n    for j in range(C+1):\n        dp[i][j]=sum(dp[i-1][j-k]*(table[k][B[i]]-table[k][A[i]-1]) for k in range(j+1))\n        dp[i][j]%=mod\n\nprint(dp[N-1][C])", "n, c = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nMOD = 10**9 + 7\n\ndp = [[0]*(c+1) for i in range(n+1)]\ndp[0][0] = 1\n\nruiseki = [[0] * (410) for _ in range(c+1)]\nfor i in range(c + 1):\n    for j in range(409):\n        ruiseki[i][j + 1] = ruiseki[i][j] + pow(j, i, MOD)\n        ruiseki[i][j + 1] %= MOD\n  \nfor i in range(n):\n    for all_num in range(c + 1):\n        for j in range(all_num + 1):\n            # i\u756a\u76ee\u306e\u5b50\u4f9b\u306b\u3001j\u500b\u306e\u98f4\u3092\u914d\u308b\n            dp[i+1][all_num] += (ruiseki[j][b[i]+1] - ruiseki[j][a[i]]) * dp[i][all_num - j]\n            dp[i+1][all_num] %= MOD\nprint(dp[-1][-1])", "import sys\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n\nN,C = MI()\nA,B = [0]+LI(),[0]+LI()\nmod = 10**9+7\n\nX = [[0]*401 for _ in range(401)]\n# X[k][l] = 0**k+1**k+\u2026+l**k\nfor k in range(401):\n    for l in range(1,401):\n        X[k][l] = X[k][l-1]+pow(l,k,mod)\n        X[k][l] %= mod\n\ndp = [[0]*(C+1) for _ in range(N+1)]\n# dp[i][j] = \u5b50\u4f9b1~i\u306b\u5408\u8a08j\u500b\u306e\u98f4\u3092\u914d\u308b\u3068\u304d\u306e\u7b54\u3048\ndp[0][0] = 1\nfor i in range(1,N+1):\n    a,b = A[i],B[i]\n    for j in range(C+1):\n        x = 0\n        for k in range(j+1):\n            x += dp[i-1][j-k]*(X[k][b]-X[k][a-1])\n            x %= mod\n        dp[i][j] = x\n\nprint((dp[-1][-1]))\n", "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\ndef ModInt(mod):\n    class _ModInt:\n        def __init__(self, value):\n            self.value = value % mod\n\n        def __add__(self, other):\n            if isinstance(other, _ModInt):\n                return _ModInt(self.value + other.value)\n            else:\n                return _ModInt(self.value + other)\n\n        def __sub__(self, other):\n            if isinstance(other, _ModInt):\n                return _ModInt(self.value - other.value)\n            else:\n                return _ModInt(self.value - other)\n\n        def __radd__(self, other):\n            return self.__add__(other)\n\n        def __mul__(self, other):\n            if isinstance(other, _ModInt):\n                return _ModInt(self.value * other.value)\n            else:\n                return _ModInt(self.value * other)\n\n        def __truediv__(self, other):\n            # TODO: \u5b9f\u88c5\n            raise NotImplementedError()\n\n        def __repr__(self):\n            return str(self.value)\n\n    return _ModInt\n\n\nMI = ModInt(MOD)\n# \u89e3\u8aacAC\nN, C = list(map(int, sys.stdin.readline().split()))\nA = list(map(int, sys.stdin.readline().split()))\nB = list(map(int, sys.stdin.readline().split()))\n\n\ndef solve():\n    # P[n][c]: n^c\n    P = [[1] * (C + 1) for _ in range(max(B) + 1)]\n    P[0] = [MI(0)] * (C + 1)\n    for i in range(1, len(P)):\n        for c in range(1, C + 1):\n            P[i][c] = P[i][c - 1] * i\n\n    # cs[n][c]: 0^c + 1^c + ... + n^c\n    cs = [[0] * (C + 1) for _ in range(max(B) + 1)]\n    for c in range(C + 1):\n        s = 0\n        for i in range(len(P)):\n            s += P[i][c]\n            cs[i][c] = s\n\n    # S[i][c]: X[i]^c (A[i]<=X[i]<=B[i]) \u306e\u5408\u8a08\n    S = [[0] * (C + 1) for _ in range(N)]\n    for i in range(N):\n        for c in range(C + 1):\n            S[i][c] = cs[B[i]][c] - cs[A[i] - 1][c]\n\n    # dp[c]: \u5404\u9805\u306e\u6b21\u6570\u304c c \u3067\u3001i \u756a\u76ee\u306e\u5b50\u4f9b\u307e\u3067\u898b\u305f\u3068\u304d\u306e f(X) \u306e\u5024\n    dp = S[0][:]\n    for i in range(1, N):\n        for c in reversed(list(range(C + 1))):\n            s = 0\n            for j in range(c + 1):\n                s += dp[c - j] * S[i][j]\n            dp[c] = s\n    return dp[-1]\n\n\n# print(f_partial([1, 1]))\n# print(f_partial([1, 2]))\n# print(f_partial([2, 1]))\n# print(f_partial([2, 2]))\nprint((solve()))\n", "n, c = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\ndp = [[0] * (c + 1) for i in range(n + 1)]\ndp[0][0] = 1\n\nru = [[0] * 410 for i in range(410)]\nfor cnt in range(410):\n    for x in range(409):\n        ru[cnt][x + 1] += ru[cnt][x] + pow(x, cnt, MOD)\n        ru[cnt][x + 1] %= MOD\n      \nfor ni in range(n):\n    for cnt in range(c + 1):\n        for ci in range(cnt, c + 1):\n            dp[ni + 1][ci] += (ru[cnt][b[ni] + 1] - ru[cnt][a[ni]]) * dp[ni][ci - cnt] \n            dp[ni + 1][ci] %= MOD\nprint(dp[-1][-1])", "from itertools import accumulate\nmod = 10 ** 9 + 7\n\nN, C = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nmemo = []\nfor p in range(C + 1):\n    tmp = [pow(i, p, mod) for i in range(401)]\n    memo.append(tuple(accumulate(tmp)))\n\n\ndp = [[0] * (C + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i, (a, b) in enumerate(zip(A, B)):\n    for j in range(C + 1):  # \u7d2f\u8a08\u3067j\u500b\u914d\u3063\u305f\u3053\u3068\u306b\u3059\u308b\n        for k in range(j + 1):  # i\u756a\u76ee\u306e\u5b50\u306bk\u500b\u3042\u3052\u308b\n            dp[i + 1][j] += dp[i][k] * (memo[j-k][b] - memo[j-k][a-1])\n            dp[i + 1][j] %= mod\n\nprint(dp[N][C])", "N, C = map(int, input().split())\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nP = 10**9+7\nY = [[pow(i, j, P) for j in range(401)] for i in range(401)]\nfor i in range(1, 401):\n    for j in range(401):\n        Y[i][j] = (Y[i][j] + Y[i-1][j]) % P\nX = [[0] * (C+1) for _ in range(N+1)]\nX[0][0] = 1\nfor i in range(1, N+1):\n    for j in range(C+1):\n        X[i][j] = sum([X[i-1][k] * (Y[B[i-1]][j-k] - Y[A[i-1]-1][j-k]) % P for k in range(j+1)]) % P\nprint(X[N][C])", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nMOD = 10**9+7\n\nn, c = map(int, input().split())\nA = np.array(tuple(map(int, input().split())))\nB = np.array(tuple(map(int, input().split())))\nE = np.zeros((n, c+1), dtype=np.int64)\nfor j in range(c+1):\n  cum = np.array(tuple(pow(k, j, MOD) for k in range(401))).cumsum()%MOD\n  E[:, j] = cum[B] - cum[A-1]\n\ndp = np.zeros((n+1, c+1), dtype=np.int64)\ndp[0, 0] = 1\nfor i, e in enumerate(E):\n  for j, f in enumerate(e):\n    dp[i+1, j:] += dp[i, :c+1-j]*f\n    dp[i+1, j:] %= MOD\nans = dp[n, c]\nprint(ans)", "def main(N,C,A,B):\n    import sys\n    input = sys.stdin.readline\n    #N,C = map(int,input().split())\n    #A = list(map(int,input().split()))\n    #B = list(map(int,input().split()))\n    mod = 10**9+7\n    powA = [[0]*(401) for i in range(401)]\n    for i in range(401):\n        for j in range(401):\n            powA[i][j] = pow(i,j,mod)\n    \n    S = [[0]*401 for i in range(C+1)]\n    for i in range(C+1):\n        S[i][0] = 0\n    for i in range(C+1):\n        for j in range(1,401):\n            S[i][j] = (S[i][j-1] + powA[j][i])%mod\n    \n    dp = [[0]*(C+1) for i in range(N)]\n    for i in range(C+1):\n        dp[0][i] = S[i][B[0]] - S[i][A[0]-1]\n    for i in range(1,N):\n        for j in range(C+1):\n            tmp = 0\n            for k in range(j+1):\n                tmp = (tmp + (S[k][B[i]] - S[k][A[i]-1])*dp[i-1][j-k])%mod\n            dp[i][j] = tmp\n    print(dp[N-1][C])\n    #print(S[1])\n    \ndef main2(N,C,A,B):\n    import sys\n    input = sys.stdin.readline\n    #N,C = map(int,input().split())\n    #A = list(map(int,input().split()))\n    #B = list(map(int,input().split()))\n    mod = 10**9+7\n    powA = [[0]*(401) for i in range(401)]\n    for i in range(401):\n        for j in range(401):\n            powA[i][j] = pow(i,j,mod)\n    \n    S = [[0]*400 for i in range(C+1)]\n    for i in range(C+1):\n        S[i][0] = 1\n    for i in range(C+1):\n        for j in range(1,400):\n            S[i][j] = (S[i][j-1] + powA[j+1][i])%mod\n    \n    dp = [[0]*(C+1) for i in range(N)]\n    for i in range(C+1):\n        dp[0][i] = pow(A[0],i,mod)\n    for i in range(1,N):\n        for j in range(C+1):\n            tmp = 0\n            for k in range(j+1):\n                tmp = (tmp + powA[A[i]][k]*dp[i-1][j-k])%mod\n            dp[i][j] = tmp\n    print(dp[N-1][C])\n    \nimport sys\ninput = sys.stdin.readline\nN,C = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nif A==B:\n    main2(N,C,A,B)\nelse:\n    main(N,C,A,B)", "import sys\ninput=sys.stdin.readline\n\nN,C=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nMod=10**9+7\n\nB_max=max(B)\nP=[[0]*(C+1) for _ in range(B_max+1)]\n\nfor x in range(B_max+1):\n    E=P[x]\n    E[0]=1\n    t=1\n    for k in range(1,C+1):\n        E[k]=t=(t*x)%Mod\n\nT=[]\nfor i in range(N):\n    U=[0]*(C+1)\n    for x in range(A[i],B[i]+1):\n        for k in range(C+1):\n            U[k]+=P[x][k]\n            U[k]%=Mod\n    T.append(U)\n\nP=[1]+[0]*C\nfor Q in T:\n    X=[0]*(C+1)\n\n    for i in range(C+1):\n        for j in range(C+1):\n            if i+j>C:\n                break\n            X[i+j]+=P[i]*Q[j]\n            X[i+j]%=Mod\n    P=X.copy()\n\nprint(X[C])", "def main():\n    mod = 10**9+7\n    n, c = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    dp = [0]*(c+1)\n    dp[0] = 1\n    ans = 0\n\n    p = [[0]*(401) for _ in [0]*401]  # p[i][j]\u3067j^i\n    for i in range(401):\n        for j in range(401):\n            p[i][j] = pow(j, i, mod)\n\n    for a, b in zip(A, B):\n        dp2 = [0]*(c+1)\n        q = [0]*(c+1)\n        for i in range(c+1):\n            q[i] = sum(p[i][a:b+1]) % mod\n        for i in range(c+1):\n            temp = 0\n            for j in range(i+1):\n                temp += dp[i-j]*q[j]\n            dp2[i] = temp % mod\n        dp = dp2\n    ans += dp[-1]\n    print(ans % mod)\n\n\nmain()", "import sys\ninput = sys.stdin.readline\n\nmod = 10**9 + 7\nN, C = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ndp = [0] * (C + 1)\ndp[0] = 1\nfor i in range(N):\n    X = [0] * (C + 1)\n    for j in range(A[i], B[i] + 1):\n        x = 1\n        for k in range(C+1):\n            X[k] = (X[k] + x) % mod\n            x = x * j % mod\n    ndp = [0] * (C + 1)\n    for j in range(C+1):\n        for k in range(C+1-j):\n            ndp[j + k] = (ndp[j + k] + dp[j] * X[k]) % mod\n    dp = ndp\nprint(dp[C])", "def main1(n,c,a,b):\n  mod=10**9+7\n  # a[0],..,a[n-1]\u304c\u305d\u308c\u305e\u308c\u7121\u9650\u500b\u3042\u308b\u3002\u91cd\u8907\u6709\u3067\u597d\u304d\u306bc\u500b\u9078\u3093\u3067\u7a4d\u3092\u53d6\u3063\u305f\u6642\u306e\u548c\u3002\n  # dp[i+1][j]:idx=i\u307e\u3067\u306e\u4e2d\u304b\u3089\u597d\u304d\u306bj\u500b\u9078\u3093\u3067\u7a4d\u3092\u53d6\u3063\u305f\u6642\u306e\u548c\u3002\n  # a[i]~b[i]\u3092\u540c\u6642\u306b\u8a08\u7b97\u3059\u308b\u3002\n  dp=[[0]*(c+1) for i in range(n+1)]\n  dp[0][0]=1\n  for i in range(n):\n    ary=[0]*(b[i]+1-a[i])\n    tmp=0\n    for j in range(c+1):\n      tmp+=dp[i][j]*(b[i]+1-a[i])\n      tmp%=mod\n      dp[i+1][j]+=tmp\n      dp[i+1][j]%=mod\n      tmp=0\n      for k in range(b[i]+1-a[i]):\n        ary[k]+=dp[i][j]\n        ary[k]*=a[i]+k\n        ary[k]%=mod\n        tmp+=ary[k]\n        tmp%=mod\n  return dp[n][c]\n\ndef __starting_point():\n  n,c=map(int,input().split())\n  a=list(map(int,input().split()))\n  b=list(map(int,input().split()))\n  print(main1(n,c,a,b))\n__starting_point()", "import numpy as np\nN, C = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nmod = 10**9+7\nP = np.empty((404, 404), dtype=np.int64)\nP[0, :] = 1\nar = np.arange(404, dtype=np.int64)\nfor i in range(1, 404):\n    P[i] = P[i-1] * ar % mod\n# \u3053\u306e\u6642\u70b9\u3067  # P[i, c] = i**c % mod\n\nP = P.cumsum(axis=1, dtype=np.int64) % mod  # P[i, c] = \u03a3_{k=0}^i k**c % mod\nP = P.T\n\ndp = np.zeros(C+1, dtype=np.int64)\ndp[0] = 1\nfor a, b in zip(A, B):\n    dp_new = np.zeros(C+1, dtype=np.int64)\n    p = (P[b] - P[a-1]) % mod\n    for c in range(C+1):\n        dp_new[c] = (dp[:c+1] * p[c::-1] % mod).sum()\n    dp = dp_new % mod\nprint((dp[C]))\n"]
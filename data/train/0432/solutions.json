["class Solution:\n    def isPossibleDivide(self, s: List[int], k: int) -> bool:\n        if len(s) % k != 0:\n            return False\n        \n        ctr = collections.Counter(s)\n        \n        for _ in range(len(s) // k):\n            mn = []\n            for i in ctr:\n                if mn == [] and ctr[i] > 0:\n                    mn = [i]\n                elif ctr[i] > 0:\n                    if i < mn[0]:\n                        mn = [i]\n\n            for i in range(k):\n                ctr[mn[0] + i] -= 1\n                if ctr[mn[0] + i] < 0:\n                    return False\n                \n        return True\n    \n    def isPossibleDivide(self, s: List[int], k: int) -> bool:\n    \n        c = [0]*k  # keeps count\n        if s == [2,4,6]: return False\n        for n in s:\n            c[n % k] += 1\n        return len(set(c)) == 1", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        q = collections.deque()\n        counter = collections.Counter(sorted(nums))\n        \n        for item in counter.items():\n            number = item[0]\n            count = item[1]\n            \n            if (count < len(q)):\n                return False\n            elif (count > len(q)):\n                for i in range(count - len(q)):\n                    q.append(number + k -1)\n            \n            while len(q) != 0 and q[0] == number:\n                q.popleft()\n            \n        return len(q) == 0", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) %k != 0 or len(nums) == 0: return False\n        \n        count = Counter(nums)\n        \n        nums = sorted(nums)\n        for x in nums:\n            if count[x] == 0:\n                continue\n            else:\n                val = count[x]\n                for i in range(x,x+k):\n                    count[i] -= val\n                    if count[i] < 0:\n                        return False\n                    \n        return True\n            \n", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        heapify(nums)\n\n        while Ct:\n            start = heappop(nums)\n            while not Ct[start]:\n                start = heappop(nums)\n            for i in range(start, start + k):\n               # print(num+i)\n                if not Ct[i]: return False\n                if Ct[i] == 1: del Ct[i]\n                else: Ct[i] -= 1\n                \n        return True", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n       # heapify(nums)\n\n        while Ct:\n            start = min(Ct)\n          #  while not Ct[start]:\n          #      start = heappop(nums)\n            for i in range(start, start + k):\n               # print(num+i)\n                if not Ct[i]: return False\n                if Ct[i] == 1: del Ct[i]\n                else: Ct[i] -= 1\n                \n        return True", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        keys = list(Ct.keys())\n        heapify(keys)\n        start = heappop(keys)\n\n        while Ct:\n            \n            while not Ct[start]:\n                start = heappop(keys)\n            for i in range(start, start + k):\n               # print(num+i)\n                if not Ct[i]: return False\n                if Ct[i] == 1: del Ct[i]\n                else: Ct[i] -= 1\n                \n        return True", "from heapq import *\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n      if len(nums) % k != 0:\n        return False\n      minHeap = []\n      countsMap = {}\n      for num in nums:\n        if num not in countsMap:\n          countsMap[num] = 1\n          heappush(minHeap, num)\n        else:\n          countsMap[num] += 1\n      \n      while len(minHeap) > 0:\n        minNum = heappop(minHeap)\n        while countsMap[minNum] > 0:\n          for i in range(k):\n            currNum = minNum + i\n            if currNum not in countsMap or countsMap[currNum] == 0:\n              return False\n            else:\n              countsMap[currNum] -= 1\n      \n      return True\n              \n", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        keys = list(Ct.keys())\n        heapify(keys)\n        num = heappop(keys)\n        while Ct:\n            \n            while not Ct[num]:\n                num = heappop(keys)\n            for i in range(k):\n               # print(num+i)\n                if not Ct[num+i]: return False\n                if Ct[num+i] == 1: del Ct[num+i]\n                else: Ct[num+i] -= 1\n                \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if k == 1:\n            return True \n\n        N = len(nums)\n        if N%k: # \u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u662fk\u7684\u500d\u6570, impossible, \u65e0\u6cd5\u5206\u5272\n            return False\n        nums = sorted(nums)\n        queue: List[List[int]] = list()\n\n        for index in range(N):\n            num = nums[index]\n            if len(queue) == 0:\n                new_group = [num, 1]    # \u521d\u59cb\u5316[num, size]\u7684\u6570\u7ec4\n                queue.append(new_group)\n            else:\n                current = queue.pop(0)\n                last_num = current[0]\n                size = current[1]\n                if last_num == num -1:  # \u5224\u65ad\u65b0\u7684num\u80fd\u5426\u653e\u5165\u961f\u5217\u6700\u524d\u9762\u7684\u6570\u7ec4\u4e2d\n                    if size == k-1:     \n                        continue        # \u52a0\u5165\u65b0\u7684num\u540e\u7684\u6570\u7ec4\u6ee1\u8db3\u5927\u5c0f\u4e3ak\uff0c\u7b26\u5408\u6761\u4ef6\uff0c\u79fb\u51fa\u961f\u5217\n                    else:\n                        size += 1\n                        update_group = [num, size]\n                        queue.append(update_group) # \u66f4\u65b0[num, size]\u6570\u7ec4\uff0c\u653e\u56de\u961f\u5217\n                elif last_num == num:  \n                # \u65b0\u7684num\u65e0\u6cd5\u653e\u5165\u961f\u5217\u6700\u524d\u9762\u7684\u6570\u7ec4\u4e2d\uff0c\u540e\u5e8f\u6570\u7ec4\u4e5f\u65e0\u6cd5\u653e\u4e0b\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6570\u7ec4\u653e\u5165\u961f\u5217\n                # \u7ef4\u62a4\u961f\u5217\u6700\u524d\u9762\u7684\u6570\u7ec4\u4e3a\u6700\u6709\u53ef\u80fd\u653e\u5165\u65b0num\u7684\u6570\u7ec4\n                        new_group = [num, 1]\n                        queue.append(current)\n                        queue.append(new_group)\n                else: # \u65b0\u7684num\u65e0\u6cd5\u52a0\u5165\u961f\u5217\uff0c\u65e0\u6cd5\u7ee7\u7eed\u5207\u5206\u539f\u6570\u7ec4\n                    return False\n        if len(queue) == 0: # \u7b26\u5408\u5927\u5c0f\u4e3ak\u7684\u6570\u7ec4\u5168\u90e8\u79fb\u51fa\u4e86\u961f\u5217\uff0c\u539f\u6570\u7ec4\u53ef\u4ee5\u88ab\u5e73\u5747\u5207\u5206\n            return True\n        else:   # \u539f\u6570\u7ec4\u65e0\u6cd5\u88ab\u5e73\u5747\u5207\u5206\u6210\u591a\u4e2a\u5927\u5c0f\u4e3ak\u7684\u6570\u7ec4\n            return False   ", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if not nums or not k:\n            return False\n        \n        c = Counter(nums)\n        \n        while c:\n            num = sorted(c.keys())[0]\n            for i in range(k):\n                if num+i in c and c[num+i] > 0:\n                    c[num+i] -= 1\n                    if c[num+i] == 0:\n                        del c[num+i]\n                else:\n                    return False\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        h = Counter(nums)\n        unique = sorted(h.keys())\n        for i in unique:\n            while h[i] > 0:\n                h[i] -= 1\n                for j in range(i+1, i+k):\n                    if h[j] <= 0:\n                        return False\n                    h[j] -= 1\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums)%k != 0:\n            return False\n        \n        nums = sorted(nums)\n        cnt = collections.Counter(nums)\n        # head = collections.Counter()\n        \n        for x in nums:\n            if cnt[x] == 0:\n                continue\n\n            for i in range(1, k):\n                if cnt[x+i] > 0:\n                    cnt[x+i] -= 1\n                else:\n                    return False\n            cnt[x] -= 1\n        return True", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        heapify(nums)\n\n        while Ct:\n            num = heappop(nums)\n            while not Ct[num]:\n                num = heappop(nums)\n            for i in range(k):\n               # print(num+i)\n                if not Ct[num+i]: return False\n                if Ct[num+i] == 1: del Ct[num+i]\n                else: Ct[num+i] -= 1\n                \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0: return False\n\n        C = Counter(nums)\n\n\n        while C:\n            start = min(C)\n            for i in range(start, start + k):\n                if i not in C: return False\n                if C[i] == 1: del C[i]\n                else: C[i] -= 1\n        return True", "class Solution:\n  # 476 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        c = Counter(nums)\n        heapify(nums)\n\n        for _ in range(len(nums) // k):\n            num = heappop(nums)\n            while not c[num]:\n                num = heappop(nums)\n            for i in range(k):\n               # print(num+i)\n                if not c[num+i]: return False\n                c[num+i] -= 1\n\n        return True", "class Solution:\n    def isPossibleDivide(self, nums, k: int) -> bool:\n        if not nums or not k:\n            return False\n\n        c = Counter(nums)\n\n        while c:\n            num = sorted(c.keys())[0]\n            for i in range(k):\n                if num + i in c and c[num + i] > 0:\n                    c[num + i] -= 1\n                    if c[num + i] == 0:\n                        del c[num + i]\n                else:\n                    return False\n        return True\n", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        heapify(nums)\n\n        while Ct:\n            num = heappop(nums)\n            while not Ct[num]:\n                num = heappop(nums)\n            for i in range(k):\n               # print(num+i)\n                if not Ct[num+i]: return False\n                if Ct[num+i] == 1: del Ct[num+i]\n                else: Ct[num+i] -= 1\n                \n\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        # \u6cd51. \u4e00\u4e2a\u5f88\u57fa\u7840\u7684\u60f3\u6cd5\u662f\u5efa\u7acb\u4e00\u4e2aBST\uff0c\u6bcf\u6b21\u91cc\u9762\u53d6\u6700\u5c0f\u7684\uff0c\u7136\u540e\u518d\u4f9d\u6b64\u628a\u6bd4\u4ed6\u5927\u7684k-1\u4e2a\u5bf9\u5e94\u7684value\u90fd\u51cf\u53bb1 O(N*lgN*k)\n\n        # \u6cd52. \u53ef\u4ee5\u5148sort\uff0c\u7136\u540e\u7b80\u5efa\u7acb\u4e00\u4e2aCounter, \u4ece\u5de6\u5230\u53f3\u904d\u5386\u8fd9\u4e2asort\u597d\u7684\u6570\u7ec4\u3002\u8fd9\u4e2a\u9002\u7528\u4e8e\u6bcf\u4e2a\u5207\u7247\u957f\u5ea6\u4efb\u610f\uff0c\u81f3\u5c11\u4e3a3\u7684\u90a3\u9053\u9898\u3002\u8fd9\u9053\u9898\u4e5f\u9002\u7528\u3002\u8fd9\u4e2a\u65b9\u6cd5\u4e3b\u8981\u662f\u8d2a\u5fc3\u601d\u60f3\u3002\u53ef\u4ee5\u6bcf\u6b21\u4f18\u5148\u4e0e\u4e4b\u524d\u7684\u914d\u5bf9\u6216\u8005\u662f\u4e00\u6b21\u6027\u4e0e\u540e\u9762\u4e09\u4e2a\u914d\u5bf9\u3002\u6216\u8005\u662f\u4e0e\u540e\u9762\u7684k\u4e2a\u914d\u5bf9\u3002 O(N*logN)\n        \n        # \u6cd53. \u5efa\u7acb\u4e00\u4e2aCounter\u3002\u53e6\u5916\u5efa\u7acb\u4e00\u4e2adeque\uff0c\u628a\u6ca1\u6709\u5de6\u8282\u70b9\u7684\u6570\u5b57\u653e\u8fdb\u53bb\u3002O(N)\n        \n        c = collections.Counter(nums)\n        q = collections.deque()\n                            \n        while c:\n            \n            # add new key in c:\n            for key in c:\n                if key-1 not in c:\n                    q.append(key)\n            \n            # iterate all of current roots\n            while q:\n                # print(q)\n\n                cur = q.popleft()\n\n                pushed = False\n\n                for nxt in range(cur+1, cur+k):\n                    if c[nxt] < c[cur]:\n                        return False\n\n                    c[nxt] -= c[cur]\n\n                    if c[nxt] == 0:\n                        c.pop(nxt)\n\n                    if not pushed and c[nxt] != 0:\n                        pushed = True\n                        q.append(nxt)\n\n                c.pop(cur)\n            \n            \n        return True if not c else False\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        if len(nums)%k != 0:\n            return False\n        \n        counter = Counter(nums)\n        heap = []\n        \n        for num in counter:\n            heapq.heappush(heap, (num, counter[num]))\n        \n        \n        while len(heap) >= k:\n            i = 0\n            temp = []\n            prevNum = None\n            for i in range(k):\n                num, count = heapq.heappop(heap)\n                if not prevNum:\n                    prevNum = num\n                    \n                else:\n                    if prevNum + 1 != num:\n                        return False\n                    prevNum = num\n                    \n                count -= 1\n                if count > 0:\n                    temp.append((num, count))\n                \n                \n            for n,count in temp:\n                heapq.heappush(heap, (n, count))\n        \n        print(heap)\n        return len(heap) == 0", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        sortedNums = sorted(nums)\n        counts = collections.Counter(nums)\n        \n        for num in sortedNums:\n            if counts[num] == 0:\n                continue\n            \n            counts[num]-=1\n            for i in range(1, k):\n                if num + i not in counts:\n                    return False\n                \n                if counts[num + i] == 0:\n                    return False\n                \n                counts[num + i] -=1\n                \n        return True", "class Solution:\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        cnt = dict()\n        for v in nums:\n            cnt[v] = cnt.get(v, 0) + 1\n        nums.sort()\n        for v in nums:\n            if v not in cnt: continue\n            for item in range(v, v+k):\n                if item not in cnt: return False\n                cnt[item] -= 1\n                if cnt[item] == 0: del cnt[item]\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        hm = {}\n        uni_nums = []\n        for num in nums:\n            if num not in hm:\n                hm[num] = 1\n                uni_nums.append(num)\n            else:\n                hm[num] += 1\n\n        uni_nums = sorted(uni_nums)\n        N = len(uni_nums)\n        i = 0\n        while i<N:\n            if hm[uni_nums[i]] == 0:\n                i += 1\n            else:\n                pick = uni_nums[i]\n                for j in range(k):\n                    if pick+j not in hm or hm[pick+j] == 0:\n                        return False\n                    else:\n                        hm[pick+j] -= 1\n        return True", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count = Counter(nums)\n        \n        while count:\n            minimum = min(count)\n            for i in range(minimum,minimum+k):\n                if i not in count:\n                    return False\n                else:\n                    if count[i] == 1:\n                        del count[i]\n                    else:\n                        count[i] -= 1\n                        \n        return True\n    \n# As the description says question is same as 846\n# Difference with 659 is that it has to be exactly K instead of atleast K\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums_counter = collections.Counter(nums)\n\n        while(nums_counter):\n            min_ele = min(nums_counter)\n            for i in range(k):\n                if nums_counter[min_ele+i]:\n                    nums_counter[min_ele+i] -= 1\n                else:\n                    return False\n                \n                if nums_counter[min_ele+i] == 0:\n                    del nums_counter[min_ele+i]\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        \n        counts = Counter(nums)\n        \n        for _ in range(len(nums) // k):\n            min_val = min(counts.keys())\n            for v in range(min_val, min_val + k):\n                if v not in counts:\n                    return False\n                \n                counts[v] -= 1\n                if counts[v] == 0:\n                    del counts[v]\n                    \n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        count = collections.Counter(nums)\n        \n        for n in nums: #loop all the numbers\n            \n            if count[n] != 0: #base condition whre count[n] is null means no need to continue the loop\n\n                for v in range(n, n + k): #each num in num if it is in count dict then. loop for 4 nums\n                    count[v] -= 1\n                    if count[v] < 0:\n                        return False\n                    \n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        countMap = Counter(nums)\n        nums.sort()\n        for num in nums:\n            if countMap[num] == 0:\n                continue\n            for i in range(num, num+k):\n                if countMap[i] > 0:\n                    countMap[i] -= 1\n                else:\n                    return False\n        return True\n                \n", "import heapq\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if k == 1:\n            return True\n        waiting = {}\n        nums.sort()\n        for num in nums:\n            if num not in waiting:\n                if num+1 in waiting:\n                    heapq.heappush(waiting[num+1], k-1)\n                else:\n                    waiting[num+1] = [k-1]\n            else:\n                remain = heapq.heappop(waiting[num])\n                if len(waiting[num]) == 0:\n                    del waiting[num]\n                if remain != 1:\n                    if num+1 in waiting:\n                        heapq.heappush(waiting[num+1], remain-1)\n                    else:\n                        waiting[num+1] = [remain-1]\n            # print(waiting)\n        for k, v in list(waiting.items()):\n            if len(v) > 0:\n                return False\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        \n        my_dict = defaultdict(int)\n        for num in nums:\n            my_dict[num]+=1\n        numbers_left = len(nums)\n        \n        while numbers_left > 0:\n            mini = min(my_dict.keys())\n            for i in range(k):\n                if not my_dict.get(mini+i):\n                    return False\n                my_dict[mini+i]-=1\n                numbers_left -= 1\n                if my_dict[mini+i] == 0:\n                    del my_dict[mini+i]\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        counts = Counter(nums)\n        for num in nums:\n            if counts[num] == 0: continue\n            for i in range(k):\n                if counts[num + i] == 0: return False\n                counts[num + i] -= 1\n\n        return True", "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], kk: int) -> bool:\n        if len(nums)%kk != 0:\n            return False\n        d = defaultdict(int)\n        nums.sort()\n        for i in nums:\n            d[i] += 1\n        keys = list(d.keys())\n        heapq.heapify(keys)\n        while len(keys) != 0:\n            first = heapq.heappop(keys)\n            d[first] -= 1\n            if d[first] == 0:\n                del d[first]\n            for i in range(first+1,first+kk):\n                if i not in d or d[i] <= 0:\n                    return False\n                d[i] -= 1\n                if d[i] == 0:\n                    del d[i]\n                    heapq.heappop(keys)\n            if d[first] > 0:\n                heapq.heappush(keys,first)\n        return True\n                \n                \n        # c = 0 \n        # for k in range(0,len(d),kk):\n        #     if d[k] <= 0:\n        #         return False\n        #     if 0 < c < k and (k-1 not in d or d[k-1] <= 0):\n        #         return False\n        #     c += 1\n        #     d[k] -= 1\n        #     if c == kk:\n        #         c = 0\n        # return True\n                \n        \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        c=collections.Counter(nums)\n        for num in sorted(c):\n            if c[num]!=0:\n                for i in range(1,k):\n                    if num+i in c:\n                        c[num+i]-=c[num]\n                        if c[num+i]<0:\n                            return False\n                    else:\n                        return False\n            c[num]=0\n        \n        return True", "class Solution:\n    # from collections import defaultdict\n    # def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n    def isPossibleDivide(self, A, k):\n        c = collections.Counter(A)\n        print(c)\n        for i in sorted(c):\n            print(i)\n            if c[i] > 0:\n                for j in range(k)[::-1]:\n                    print(('j:',j,i+j,c[i+j]))\n                    c[i + j] -= c[i]\n                    if c[i + j] < 0:\n                        return False\n                print(c)\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        sortedNums = sorted(set(nums))\n        counts = collections.Counter(nums)\n        \n        for num in sortedNums:\n            if counts[num] == 0:\n                continue\n            \n            for i in range(1, k):\n                if num + i not in counts:\n                    return False\n                \n                if counts[num + i] < counts[num]:\n                    return False\n                \n                counts[num + i] -= counts[num]\n                \n        return True", "class Solution:\n    def isPossibleDivide(self, hand : List[int], W: int) -> bool:\n        \n        if len(hand) % W != 0:\n            return False\n        \n        hand.sort()\n        cnt = collections.Counter(hand)\n        \n        for n in hand:\n            if cnt[n] > 0:\n                t = 0\n                while t < W:\n                    cnt[n + t] -= 1\n                    if cnt[n + t] < 0:\n                        return False\n                    t += 1\n        return True\n                \n", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        c = Counter(nums)\n        nums = sorted(nums)\n        for n in nums:\n            if c[n] > 0:\n                c[n] -= 1\n                for i in range(1, k):\n                    if c[n + i] == 0:\n                        return False\n                    c[n + i] -= 1\n                \n        return True\n            \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        # if len(nums)%k!=0:\n        #     return False\n        # c=Counter(nums)\n        # keys=sorted(c)\n        # for key in keys:\n        #     while c[key]>0:\n        #         for i in range(k):\n        #             if key+i in c.keys() and c[key+i]>0:\n        #                 c[key+i]-=1\n        #             else:\n        #                 return False\n        # return True\n    \n        c = Counter(nums)\n        for i in sorted(c):\n            if c[i] > 0:\n                for j in range(k)[::-1]:\n                    c[i + j] -= c[i]\n                    if c[i + j] < 0:\n                        return False\n        return True\n                \n                    \n", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if not nums or not k or k > len(nums) or len(nums) % k:\n            return False\n        nums.sort()\n        counter = Counter(nums)\n        while counter:\n            count = 0\n            start = sorted(counter)[0]\n            while count < k:\n                if counter[start] == 0:\n                    return False\n                counter[start] -= 1\n                if counter[start] == 0:\n                    counter.pop(start)\n                start += 1\n                count += 1\n        return not counter", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        c = collections.Counter(nums)\n        \n        for i in sorted(c):\n            if c[i] > 0:\n                for j in range(k)[::-1]:\n                    c[i + j] -= c[i]\n                    \n                    if c[i + j] < 0:\n                        return False\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count = collections.Counter(nums)\n        \n        while count:\n            minCount = min(count)\n            \n            for i in range(minCount, minCount+k):\n                if not count[i]:\n                    return False\n                if count[i] == 1:\n                    del count[i]\n                else:\n                    count[i] -= 1\n        return True", "class Solution:\n    def isPossibleDivide(self, hand: List[int], W: int) -> bool:\n        \n        l = len(hand)\n        if l == 0 or l % W != 0:\n            return False\n        \n        counter = collections.Counter(hand)\n        heapq.heapify(hand)\n        \n        pos = 0\n        while pos < l:\n            while not hand[0] in counter:\n                heapq.heappop(hand)\n            \n            currMin = hand[0]\n            counter[currMin] -= 1\n            pos += 1\n            if counter[currMin] == 0:\n                del counter[currMin]\n            \n            for i in range(W-1):\n                nextDraw = currMin + i + 1\n                if nextDraw in counter and counter[nextDraw] > 0:\n                    counter[nextDraw] -= 1\n                    pos += 1\n                    if counter[nextDraw] == 0:\n                        del counter[nextDraw]\n                else:\n                    return False\n                \n        return True\n                \n                    \n            \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n%k != 0: return False\n        dic = Counter(nums) \n        key = list(sorted(dic.keys()))\n        \n        while key:\n            last =-1\n            remove =[]\n            if len(key) < k:\n                return False\n            for i,num in enumerate(key):\n                if i == k:\n                    break\n                if last == -1:\n                    last = num\n                    dic[num] -=1\n                elif num-last == 1 and i< k:\n                    last = num\n                    dic[num] -=1\n                elif num-last != 1:\n                    return False\n                if dic[num] == 0:\n                    remove.append(i)\n            remove.sort(reverse=True)\n            for ind in remove:\n                key.pop(ind)\n        return True", "from typing import List\nfrom sortedcontainers import SortedDict\n\nclass Solution:\n    def isPossibleDivide(self, hand: List[int], W: int) -> bool:\n        # print('-----')\n        # print(f'hand: {hand}')\n        # print(f'W: {W}')\n\n        if not hand:\n            return True\n        elif len(hand) % W != 0:\n            return False\n        else:\n            numPos = SortedDict()\n            for idx, n in enumerate(hand):\n                if n in numPos:\n                    numPos[n].append(idx)\n                else:\n                    numPos[n] = [idx]\n\n            numRounds = len(hand) // W\n            for r in range(numRounds):\n                if len(numPos) < W:\n                    return False\n                else:\n                    # print(f'r={r} len(numPos)={len(numPos)} numPos={numPos}')\n                    ll = list(numPos.islice(stop=W))\n                    prev = ll[0] - 1\n                    for n in ll:\n                        if n == prev + 1:\n                            numPos[n].pop()\n                            if not numPos[n]:\n                                del numPos[n]\n                            prev = n\n                        else:\n                            return False\n\n            return True\n", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) %k != 0 or len(nums) == 0: return False\n        \n        count = Counter(nums)\n        \n        nums = sorted(nums)\n        for x in nums:\n            if count[x] == 0:\n                continue\n            else:\n                val = count[x]\n                for i in range(x+1,x+k):\n                    if count[i] < val:\n                        return False\n                    count[i] -=1\n            count[x] -=1\n        return True\n            \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        # start with smallest number\n        if len(nums) % k != 0: return False\n            \n        d = collections.Counter(nums)\n        s = list(d)\n        s.sort()\n        \n        for n in s:\n            if n in d:\n                c = collections.Counter({m: d[n] for m in range(n, n+k)})\n                if all([key in d and d[key] >= c[key] for key in c]):\n                    d -= c\n                else:\n                    return False\n        return True", "\n# Mai Trinh\n# COSC 6320 - Data Structures and Algorithm\n# Instructor: Gopal Pandurangan\n# Divides array in sets of k consecutive numbers.\n\n# ----------------------\n# Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into sets of k consecutive numbers.\n# Return True if its possible otherwise return False.\n# ----------------------\ndef isPossibleDivide(nums, k):\n    if (len(nums) % k != 0): #if the size of arrays is not divisible by k, cannot have sets of k numbers\n        return False\n    else:\n        nums.sort() #sort array\n        return decreaseConquer(nums, k) #calling the decrease/conquer algorihtm with the sorted array.\n\n#Decrease-Conquer algorithm to determine if array can be divide into sets of k consecutive numbers\ndef decreaseConquer(A, k):\n    if (len(A) == 0): #base case\n        return True\n    else: #recursive\n        pivot= A[len(A) - 1] #choose the last element (the largest element) in array\n        for i in range(k): #search for k consecutives in correspond to the largest number\n            j = binarySearch(A, 0, len(A)-1, pivot-i) #use binary search to find p-1, p-2,.., p-(k-1)\n            if (j == -1): #if element is not found in the array, there is no k consecutive numbers\n                return False\n            else: #if found, remove the element from array\n                del A[j]\n        #array is reduced in size (n - k), recursively calling decreaseConquer algorithm with the updated array\n        return decreaseConquer(A, k)\n\n#Search for specific element in the array - O(log n)\ndef binarySearch (S, l, r, x): \n    if l <= r: \n        mid = l + (r - l) // 2 #find the middle element\n\n        if S[mid] == x: # If element is the middle element\n            return mid \n\n        elif S[mid] > x: #if element is in the left subarray\n            return binarySearch(S, l, mid-1, x) \n\n        else: #if element is in the right subarray\n            return binarySearch(S, mid + 1, r, x) \n\n    else: # Element is not present in the array \n        return -1\n    \nA = [1,2,3,3,4,4,5,6]\nk = 4\nans = isPossibleDivide(A, k)\n\nprint(ans)\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        return isPossibleDivide(nums, k)", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        c=collections.Counter(nums)\n        for num in c:\n            if c[num]!=0:\n                for i in range(1,k):\n                    if num+i in c and c[num+i]>=c[num]:\n                        c[num+i]-=c[num]\n                    else:\n                        return False\n            c[num]=0\n        \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        counts = Counter(nums)\n        n_left = len(nums)\n        count_keys = [c for c in counts if counts[c] > 0]\n        count_keys.sort()\n        \n        if n_left % k != 0:\n            return False\n        \n        while n_left > 0:\n            while counts[count_keys[0]] == 0:\n                count_keys.pop(0)\n            start = count_keys[0]\n            for i in range(k):\n                if counts[start + i] == 0:\n                    return False\n                counts[start + i] -= 1\n                n_left -= 1\n        \n        return True", "def isPossibleDivide(nums, k):\n    if (len(nums) % k != 0): #if the size of arrays is not divisible by k, cannot have sets of k numbers\n        return False\n    else:\n        nums.sort() #sort array\n        return decreaseConquer(nums, k) #calling the decrease/conquer algorihtm with the sorted array.\n\n#Decrease-Conquer algorithm to determine if array can be divide into sets of k consecutive numbers\ndef decreaseConquer(A, k):\n    if (len(A) == 0): #base case\n        return True\n    else: #recursive\n        pivot= A[len(A) - 1] #choose the last element (the largest element) in array\n        for i in range(k): #search for k consecutives in correspond to the largest number\n            j = binarySearch(A, 0, len(A)-1, pivot-i) #use binary search to find p-1, p-2,.., p-(k-1)\n            if (j == -1): #if element is not found in the array, there is no k consecutive numbers\n                return False\n            else: #if found, remove the element from array\n                del A[j]\n        #array is reduced in size (n - k), recursively calling decreaseConquer algorithm with the updated array\n        return decreaseConquer(A, k)\n\n#Search for specific element in the array - O(log n)\ndef binarySearch (S, l, r, x): \n    if l <= r: \n        mid = l + (r - l) // 2 #find the middle element\n\n        if S[mid] == x: # If element is the middle element\n            return mid \n\n        elif S[mid] > x: #if element is in the left subarray\n            return binarySearch(S, l, mid-1, x) \n\n        else: #if element is in the right subarray\n            return binarySearch(S, mid + 1, r, x) \n\n    else: # Element is not present in the array \n        return -1\n\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        return isPossibleDivide(nums, k)\n\n", "from typing import List\nfrom sortedcontainers import SortedDict\n\nclass Solution:\n    def isPossibleDivide(self, hand: List[int], W: int) -> bool:\n        # print('-----')\n        # print(f'hand: {hand}')\n        # print(f'W: {W}')\n\n        if not hand:\n            return True\n        elif len(hand) % W != 0:\n            return False\n        else:\n            numPos = SortedDict()\n            for n in hand:\n                if n in numPos:\n                    numPos[n] += 1\n                else:\n                    numPos[n] = 1\n\n            numRounds = len(hand) // W\n            for r in range(numRounds):\n                if len(numPos) < W:\n                    return False\n                else:\n                    # print(f'r={r} len(numPos)={len(numPos)} numPos={numPos}')\n                    ll = list(numPos.islice(stop=W))\n                    prev = ll[0] - 1\n                    for n in ll:\n                        if n == prev + 1:\n                            numPos[n] -= 1\n                            if not numPos[n]:\n                                del numPos[n]\n                            prev = n\n                        else:\n                            return False\n\n            return True\n", "class Solution:\n  def isPossibleDivide(self, nums, k):\n    ctr = collections.Counter(nums)\n    for num in nums:\n        start = num\n        while ctr[start - 1]:\n            start -= 1\n        while start <= num:\n            while ctr[start]:\n                for victim in range(start, start + k):\n                    if not ctr[victim]:\n                        return False\n                    ctr[victim] -= 1\n            start += 1\n    return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) < k or len(nums) % k:\n            return False\n        cnts = defaultdict(int)\n        for n in nums:\n            cnts[n] += 1\n        for n in sorted(list(cnts.keys())):\n            if cnts[n] > 0:\n                for i in range(1, k):\n                    if n + i not in cnts or cnts[n + i] < cnts[n]:\n                        return False\n                    cnts[n + i] -= cnts[n]\n        return True\n", "import queue \nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums = sorted(nums)\n        if len(nums) % k != 0: return False \n        arr_list = []\n        q = queue.PriorityQueue()\n        for ind, num in enumerate(nums):\n            if not q.qsize() or q.queue[0][0] + 1 != num:\n                q.put([num, [num]])\n            if q.queue[0][0] + 1 == num:\n                val, tmp_list = q.get()\n                tmp_list.append(num)\n                if len(tmp_list) == k:\n                    continue\n                else:\n                    q.put([num, tmp_list])\n        return True if not q.qsize() else False                        ", "from queue import PriorityQueue\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n\n        if len(nums)%k!=0:\n            return False\n        \n        d={}\n        heap=PriorityQueue()\n        for i in nums:\n            \n            if d.get(i):\n                d[i]+=1\n            else:\n                d[i]=1\n                heap.put(i)\n        \n        \n        i=0\n        \n        while(i<len(nums)):\n            \n            min_val=heap.get()\n            d[min_val]-=1\n            for j in range(1,k):\n                \n                if d.get(min_val+j):\n                    heap.get()\n                    d[min_val+j]-=1\n                else:\n                    return False\n                \n                \n            for j in range(0,k):\n                if d.get(min_val+j)>0:\n                    \n                    heap.put(min_val+j)\n        \n            i+=k\n        \n        return True\n        \n", "from collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums = sorted(nums)\n        \n        nums_dict = Counter(nums)\n        nums_set = sorted(list(nums_dict.keys()))\n        \n        \n        while nums_set:\n            i = nums_set.pop(0)\n            count = nums_dict.pop(i)\n            \n            for j in range(i+1,i+k):\n                if j not in nums_dict:\n                    return False\n                n = nums_dict.pop(j) - count\n                if n < 0:\n                    return False\n                \n                elif n == 0:\n                    nums_set.remove(j)\n                \n                else:\n                    nums_dict[j] = n\n                \n        return True", "from typing import List\n\nfrom collections import Counter, OrderedDict\n\nclass Solution:\n    def can_process(self, sorted_counter, element, size):\n        for i in range(element, element+size):\n            if i not in sorted_counter:\n                return False\n        return True\n\n    def process(self, queue, sorted_counter, element, size):\n        for i in range(element, element+size):\n            sorted_counter[i] -= 1\n\n            if sorted_counter[i] == 0:\n                del sorted_counter[i]\n                queue.pop(0)\n\n        return queue, sorted_counter\n\n    def isPossibleDivide(self, hand: List[int], W: int) -> bool:\n        #O(nlogn) + O(n)\n        sorted_counter = OrderedDict(Counter(sorted(hand)))\n\n        #O(n) | S(unique(n))\n        queue = list(sorted_counter.keys())\n\n        #O(n)\n        while len(queue):\n            element = queue[0]\n            if not self.can_process(sorted_counter, element, W):\n                return False\n\n            queue, sorted_counter = self.process(queue, sorted_counter, element, W)\n\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        #hashmap count\n        countMap = {}\n        for num in nums:\n            countMap[num] = countMap.get(num,0) + 1     \n        #sort keys\n        keyList = sorted(countMap.keys())\n\n        while len(keyList) >0:\n            #print(keyList)\n            if len(keyList) < k:\n                return False\n            remove = []\n            for i in range (k):\n                if i > 0 and (keyList[i] - keyList[i-1] > 1):\n                    return False\n                #update map and maybe list\n                countMap[keyList[i]] = countMap[keyList[i]] -1\n                if countMap[keyList[i]] == 0:\n                    remove.append(keyList[i])\n            for key in remove:\n                keyList.remove(key)\n        return True\n        \n        \n        #pull lowest k, update counts and key sorted \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n        \n        count = Counter(nums)\n        nums = sorted(count.keys())\n        \n        while nums:\n            for num in range(nums[0], nums[0] + k):\n                if num not in count or count[num] == 0:\n                    return False\n                count[num] -= 1\n                if count[num] == 0:\n                    nums.remove(num)\n        \n        return True            ", "from typing import List\n\nfrom collections import Counter, OrderedDict\n\nclass Solution:\n    def can_process(self, sorted_counter, element, size):\n        for i in range(element, element+size):\n            if i not in sorted_counter:\n                return False\n        return True\n\n    def process(self, queue, sorted_counter, element, size):\n        for i in range(element, element+size):\n            sorted_counter[i] -= 1\n\n            if sorted_counter[i] == 0:\n                del sorted_counter[i]\n                queue.pop(0)\n\n        return queue, sorted_counter\n\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        #O(nlogn) + O(n)\n        sorted_counter = OrderedDict(Counter(sorted(nums)))\n\n        #O(n) | S(unique(n))\n        queue = list(sorted_counter.keys())\n\n        #O(n)\n        while len(queue):\n            element = queue[0]\n            if not self.can_process(sorted_counter, element, k):\n                return False\n\n            queue, sorted_counter = self.process(queue, sorted_counter, element, k)\n\n        return True", "import collections\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) % k != 0:\n            return False\n        \n        numSets = len(nums) // k\n        #find first smallest\n        freqCnt = dict()\n        for i in nums:\n            if i not in freqCnt:\n                freqCnt[i] = 1\n            else:\n                freqCnt[i] += 1\n                \n        keys = sorted(freqCnt.keys())\n        \n        for i in range(numSets):\n            smallest = keys[0]\n            cursor = None\n            remain = k - 1\n            freqCnt[smallest] -= 1\n            if freqCnt[smallest] == 0:\n                keys.pop(0)\n                cursor = 0\n            else:\n                cursor = 1\n                \n            while cursor < len(keys) and remain != 0:\n                if keys[cursor] == smallest + 1:\n                    smallest = keys[cursor]\n                    remain -= 1\n                    freqCnt[smallest] -= 1\n                    if freqCnt[smallest] == 0:\n                        keys.pop(cursor)\n                    else:\n                        cursor += 1\n                else:\n                    return False\n            if cursor == len(keys) and remain != 0:\n                return False\n            \n        return True\n            \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False \n        \n        \n        counts = Counter(nums)\n        \n        for num in sorted(counts):\n            prev = num \n            frequency = counts[num]\n            if counts[num] > 0:\n                for i in range(1, k):\n                    nextNum = prev + 1 \n                    if nextNum not in counts:\n                        return False \n                    elif counts[nextNum] - frequency < 0:\n                        return False \n                    counts[nextNum] -= frequency \n                    prev = nextNum \n                counts[num] -= frequency \n            \n        return True ", "import collections\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count=collections.Counter(nums)\n        sorted_keys=sorted(count.keys())\n        while sorted_keys:\n            key=sorted_keys.pop(0)\n            val=count[key]\n            if val>0:\n                for i in range(key,key+k):\n                    count[i]-=val\n                    if count[i]<0:\n                        return False\n        return True\n                \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        #hashmap count\n        countMap = {}\n        for num in nums:\n            countMap[num] = countMap.get(num,0) + 1     \n        #sort keys\n        keyList = list(countMap.keys())\n        keyList.sort()\n\n        while len(keyList) >0:\n            print(keyList)\n            if len(keyList) < k:\n                return False\n            remove = []\n            for i in range (k):\n                if i > 0 and (keyList[i] - keyList[i-1] > 1):\n                    return False\n                #update map and maybe list\n                countMap[keyList[i]] = countMap[keyList[i]] -1\n                if countMap[keyList[i]] == 0:\n                    remove.append(keyList[i])\n            for key in remove:\n                keyList.remove(key)\n        return True\n        \n        \n        #pull lowest k, update counts and key sorted \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        n = len(nums)\n        \n        if n % k != 0:\n            return False\n        \n        cnt = Counter(nums)\n        no = min(cnt.keys())\n        while cnt: \n            for j in range(k):\n                if cnt[no] == 0:\n                    return False\n                \n                cnt[no] -= 1\n                if cnt[no] == 0:\n                    cnt.pop(no)\n                \n                no += 1\n            \n            if cnt:\n                no = min(cnt.keys())\n           \n        \n        return True\n            \n                \n                \n                    \n                    \n                \n", "from collections import Counter, defaultdict\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n        nums = Counter(nums)\n        while nums:\n            x = min(nums)\n            min_count = nums[x]\n            del nums[x]\n            for i in range(1, k):\n                if nums[x + i] < min_count:\n                    return False\n                else:\n                    nums[x + i] -= min_count\n                    if nums[x + i] == 0:\n                        del nums[x + i]\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        D = deque()\n        if len(nums) % k != 0:\n            return False\n        target_set_count = len(nums) // k\n        for num in nums:\n            if len(D):\n                prev_val, count = D.pop()\n                if num == prev_val+1:\n                    prev_val += 1\n                    count += 1\n                else:\n                    D.appendleft((prev_val, count))\n                    count = 1\n            else:\n                prev_val, count = num, 1\n            if count < k:\n                D.appendleft((prev_val, count))    \n            if len(D) > target_set_count:\n                break\n        return len(D) == 0", "# O(nlogn) time and O(n) space, exactly the same as Q846: Hand of straights\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k: return False\n        if k==1: return True\n        \n        n = len(nums)\n        cnt = collections.Counter(nums)\n        heapify(nums)\n        \n        for i in range(n//k):\n            start = heappop(nums)\n            while cnt[start] == 0:\n                start = heappop(nums)\n            \n            for i in range(k):\n                if cnt[start+i] == 0: return False\n                cnt[start+i] -= 1\n                \n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums, k):\n        ctr = collections.Counter(nums)\n        for num in nums:\n            start = num\n            while ctr[start - 1]:\n                start -= 1\n            while start <= num:\n                while ctr[start]:\n                    for victim in range(start, start + k):\n                        if not ctr[victim]:\n                            return False\n                        ctr[victim] -= 1\n                start += 1\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n  ==1:\n            return True\n        if k==1:\n            return True\n        c = collections.Counter(nums)\n        \n        for num in nums:\n            start = num\n            while c[start-1]:\n                start-=1\n            \n            while start<=num:\n                while c[start]:\n                    for j in range(k):\n                        if not c[start+j]:\n                            return False\n                        c[start+j]-=1\n                start+=1\n        \n        return True", "import heapq\nimport collections\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        if len(nums) % k != 0:\n            return False\n        nums.sort()\n        m = collections.defaultdict(list)\n        \n        for num in nums:\n            left = m.get(num-1)\n            right = m.get(num+1)\n            if left and m[num-1][0] < k:\n                curr = heapq.heappop(m[num-1])\n                heapq.heappush(m[num], curr+1)\n            elif right and m[num+1][0] <k:\n                curr = heapq.heappop(m[num+1])\n                heapq.heappush(m[num+1], curr+1)               \n            else:\n                heapq.heappush(m[num], 1)\n            #print(m)\n\n        for x in m:\n            for i in m[x]:\n                if i != k:\n                    return False\n        return True\n    \n", "import collections\n\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        num_of_sets = int(len(nums) / k)\n        c = collections.deque([0] * num_of_sets)\n\n        ct = {}\n        for n in nums:\n            ct[n] = ct.get(n, 0) + 1\n\n        last_num = None\n        for num in sorted(ct.keys()):\n            if last_num is not None and num != last_num + 1 and any(cc != 0 for cc in c):\n                return False\n\n            amount = ct[num]\n            for i in range(num_of_sets):\n                if amount > 0:\n                    c[i] = (c[i] + 1) % k\n                    amount -= 1\n                elif c[i] != 0:\n                    return False\n\n            if amount > 0:\n                return False\n\n            i = 0\n            while c[0] == 0 and i < num_of_sets:\n                c.append(c.popleft())\n                i += 1\n\n            last_num = num\n\n        return all(cc == 0 for cc in c)\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        dic = Counter(nums)\n        for x in sorted(nums):\n            if x in dic:\n                for y in range(x, x + k):\n                    if y in dic:\n                        dic[y] -= 1\n                        if dic[y] == 0:\n                            del dic[y]\n                    else:\n                        return False\n        return True\n", "import queue\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n%k != 0:\n            return False\n        dic = collections.defaultdict(list)\n        nums = sorted(nums)\n        for i, num in enumerate(nums):\n            cur_length = heapq.heappop(dic[num-1]) if dic[num-1] and dic[num-1][0]!=k else 0\n            heappush(dic[num],cur_length+1)\n\n        for key in dic:\n            for x in dic[key]:\n                if x != k:\n                    return False\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        freq = {}\n        nums.sort()\n        for n in nums:\n            if n in freq:   \n                freq[n]+=1\n            else:\n                freq[n]=1\n        for num in freq:\n            if freq[num]!=0:\n                temp = freq[num]\n                for i in range(num,num+k):\n                    if i not in freq or freq[i]<temp:\n                        return False\n                    else:\n                        freq[i]-=temp\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        M: Mapping[int, int] = {}\n        for n in nums:\n            if n in M:\n                M[n] = M[n]+1\n            else:\n                M[n] = 1\n\n        n = sorted(M.keys())[0]\n        while True:\n            for i in range(k):\n                if n not in M or M[n] == 0:\n                    return False\n                M[n] = M[n] - 1\n                n = n + 1\n\n            for n in list(M.keys()):\n                if M[n] == 0:\n                    del (M[n])\n\n            if len(list(M.keys())) == 0:\n                return True\n\n            n = sorted(M.keys())[0]\n", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        d = Counter(nums)\n        for x in sorted(nums):\n            if x in d:\n                for y in range(x, x + k):\n                    if y in d:\n                        d[y] -= 1\n                        if d[y] == 0:\n                            del d[y]\n                    else:\n                        return False\n        return True\n                \n            \n                \n", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        d = Counter(nums)\n        nums.sort()\n        for x in nums:\n            if x in d:\n                for y in range(x, x + k):\n                    if y in d:\n                        d[y] -= 1\n                        if d[y] == 0:\n                            del d[y]\n                    else:\n                        return False\n        return True\n                \n            \n                \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        c = Counter(nums)\n        while c:\n            x = min(c.keys())\n            for i in range(x,x+k):\n                if i not in c: return False\n                c[i] -= 1\n                if c[i] == 0: del c[i]\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) == 0 or len(nums) % k != 0:\n            return False\n        counter = collections.Counter(nums)\n        while counter:\n            starter = min(counter.keys())\n            \n            for i in range(k):\n                if starter + i not in counter:\n                    return False\n                else:\n                    counter[starter+i] -= 1\n                    if counter[starter+i] == 0:\n                        del counter[starter+i]\n                        \n        \n        return True\n            \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n#         dq = deque()\n#         #dq[i] = number of sequences with i elements, ending with current number\n#         c = Counter(nums)\n#         nums = sorted(set(nums))\n#         current_num = 0\n#         opening = 0\n#         for i in range(len(nums)):\n#             if i > 0 and nums[i] > nums[i - 1] + 1 and opening > 0:\n#                 return False\n#             if c[nums[i]] < opening:\n#                 return False\n#             dq.appendleft(c[nums[i]] - opening)\n#             opening += c[nums[i]] - opening\n#             if len(dq) >= k:\n#                 opening -= dq.pop()\n#         return opening == 0\n\n        c = Counter(nums)\n        nums = list(set(nums))\n        heapify(nums)\n        # print(list(set(nums)))\n        print(nums)\n        while nums:\n            m = heappop(nums)\n            while nums and c[m] == 0:\n                m = heappop(nums)\n            for i in range(1, k):\n                if c[m + i] < c[m]:\n                    print((c[m + i], c[m], m))\n                    return False\n                c[m + i] -= c[m]\n            c[m] = 0\n        return True\n                    \n            \n                    \n                \n            \n", "from collections import OrderedDict, Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if(len(nums) % k != 0):\n            return False\n        elems = sorted(list(set(nums)))\n        count = OrderedDict()\n        for elem in elems:\n            count[elem] = 0\n        for num in nums:\n            count[num] += 1\n        while(len(count) > 0):\n            x = list(count.keys())[0]  \n            for i in range(x,x+k):\n                if(i not in count):\n                    return False\n                count[i] -= 1\n                if(count[i] == 0):\n                    del count[i]\n        return True\n", "from collections import Counter\nfrom heapq import heappop, heapify\n\ndef is_possible_divide(heap, k):\n    if len(heap) == 0:\n        return True\n    else:\n        popped = []\n        prev, min_count = heappop(heap)\n        for i in range(k - 1):\n            if not heap:\n                return False\n            else:\n                value, count = heappop(heap)\n                if value != prev + 1:\n                    return False\n                else:\n                    count -= min_count\n                    prev = value\n                if count > 0:\n                    popped.append((value, count))\n        heap.extend(popped)\n        heapify(heap)\n        return is_possible_divide(heap, k)\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        heap = [(value, count) for value, count in list(Counter(nums).items())]\n        heapify(heap)\n        return is_possible_divide(heap, k)\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        if len(nums) % k != 0:\n            return False\n        count = dict(Counter(nums))\n        nums = sorted(list(set(nums)))\n        for num in nums:\n            if count[num] != 0:\n                for i in range(1, k):\n                    if num + i not in count:\n                        return False\n                    else:\n                        count[num+i] -= count[num]\n            count[num] = 0\n           # print(count)\n        return all([a == 0 for a in list(count.values())])\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums)%k != 0:\n            return False\n        \n        m = int(len(nums)/k)\n        \n        res = []\n        \n        count = {}\n        \n        for i in range(len(nums)):\n            if not count.get(nums[i]):\n                count[nums[i]] = 0\n            count[nums[i]] += 1\n        \n        arr = []\n        for i in range(m):\n            ks = list(count.keys()).copy()\n            ks.sort()\n            #print(count)\n            for j in range(len(ks)):\n                if len(arr) == 0 or arr[len(arr) - 1] == ks[j] - 1:\n                    arr.append(ks[j])\n                    count[ks[j]] -= 1\n                    if count[ks[j]] == 0:\n                        del count[ks[j]]\n                else:\n                    return False\n                \n                if len(arr) == k:\n                    res.append(arr.copy())\n                    arr.clear()\n                    break\n        if len(count) > 0:\n            return False\n        \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        W = k\n        hand = nums\n        \n        hand.sort()\n        mp = defaultdict(list)\n        \n        for elem in hand:\n            prev_len = -1 if len(mp[elem - 1]) == 0 else heapq.heappop(mp[elem - 1])\n            if prev_len == -1 or prev_len == W:\n                heapq.heappush(mp[elem], 1)\n            else:\n                heapq.heappush(mp[elem], prev_len + 1)\n                \n        for key in mp.keys():\n            for length in mp[key]:\n                if length != W:\n                    return False\n                \n        return True", "from collections import defaultdict, OrderedDict\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums_dict = defaultdict(int)\n        for num in nums:\n            nums_dict[num] += 1\n        \n        nums_dict_ordered = OrderedDict(sorted(nums_dict.items()))\n        \n        while len(nums_dict_ordered) > 0:\n            first = next(iter(nums_dict_ordered))\n            nums_dict_ordered[first] -= 1\n            if nums_dict_ordered[first] == 0:\n                    del nums_dict_ordered[first]\n            for val in range(1, k):\n                check = first+val\n                if check not in list(nums_dict_ordered.keys()) or  nums_dict_ordered[check] == 0:\n                    return False\n                else:\n                    nums_dict_ordered[check] -= 1\n                if nums_dict_ordered[check] == 0:\n                    del nums_dict_ordered[check]\n            \n        return True\n", "from collections import Counter\nfrom heapq import heappop, heappush, heapify\n\ndef create_pairs(A):\n    sorted_A = sorted(A)\n    prev = sorted_A[0]\n    pairs = [[prev, 1]]\n    for curr in sorted_A[1:]:\n        if curr !=  prev:\n            pairs.append([curr, 1])\n            prev = curr\n        else:\n            pairs[-1][1] += 1\n    return [tuple(x) for x in pairs]\n\ndef is_possible_divide(heap, k):\n    if len(heap) == 0:\n        return True\n    else:\n        popped = []\n        prev, min_count = heappop(heap)\n        for i in range(k - 1):\n            if not heap:\n                return False\n            else:\n                value, count = heappop(heap)\n                if value != prev + 1:\n                    return False\n                else:\n                    count -= min_count\n                    prev = value\n                if count > 0:\n                    popped.append((value, count))\n        for val in popped:\n            heappush(heap, val)\n        # heap.extend(popped)\n        # heapify(heap)\n        return is_possible_divide(heap, k)\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        heap = list(Counter(nums).items())\n        # heap = create_pairs(nums)\n        print(heap)\n        heapify(heap)\n        return is_possible_divide(heap, k)\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        N = len(nums)\n        if (N % k != 0):\n            return False\n        \n        counter = collections.Counter(nums)\n        while (counter):\n            min_key = min(counter.keys())\n            for i in range(k):\n                if (min_key in counter):\n                    counter[min_key] -= 1\n                    if (counter[min_key] == 0):\n                        del counter[min_key]\n                    min_key += 1\n                else:\n                    return False\n        \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        counts = collections.Counter(nums)\n        for num in nums:\n            if counts[num] > 0:\n                for i in range(k):\n                    counts[num + i] -= 1\n                    if counts[num + i] < 0:\n                        return False\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if k == 1:\n            return True\n        if len(nums)%k:\n            return False\n        d = defaultdict(int)\n        \n        for n in nums:\n            d[n] += 1\n        \n        count = 0\n        iters = len(nums)//k\n        \n        while iters > 0:\n            prev = None\n            count = 0\n            iters -= 1\n            for key in sorted(d):\n                # print(key,d, count,'here')\n                if count != 0 and not count%k:\n                    break\n                if not prev or (d[key] > 0 and prev+1 == key):\n                    d[key] -= 1\n                    prev = key\n                    count += 1\n                else:\n                    # print(d, count, '===')\n                    return False\n            # print(d,'---')\n            a = list(d.keys())\n            for key in a:\n                if d[key] == 0:\n                    d.pop(key)\n        if len(list(d.keys())):\n            return False\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        heapify(nums)\n        \n        if len(Ct) > len(nums)*0.9:                               \n            return self.isNStraightHand(nums, k)\n\n        while Ct:\n            start = heappop(nums)\n            while not Ct[start]:\n                start = heappop(nums)\n            for i in range(start, start + k):\n               # print(num+i)\n                if not Ct[i]: return False\n                if Ct[i] == 1: del Ct[i]\n                else: Ct[i] -= 1\n                \n        return True\n\n\n    def isNStraightHand(self, hand, W):\n      #  heapify(hand)\n        \n        while hand:\n            last_item = heappop(hand)\n            leftover = []\n            \n            for _ in range(W - 1):\n                if not hand: return False                \n                next_item = heappop(hand)\n                \n                while next_item == last_item:\n                    leftover.append(next_item)\n                    if not hand: return False                       \n                    next_item = heappop(hand)\n                    \n                if next_item > last_item + 1: return False                    \n                last_item = next_item                \n            for item in leftover:\n                heappush(hand, item)\n                \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        counter = collections.Counter(nums)\n        for n in sorted(counter):\n            num = counter[n]\n            if num > 0:\n                for i in range(k):\n                    counter[n+i]-=num\n                    if counter[n+i]<0:\n                        return False\n        return True", "from collections import defaultdict, Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if not nums:\n            return False\n        elif not k:\n            return True\n        counter = Counter(nums)\n        while counter:\n            start, count = sorted(counter)[0], 0\n            while count < k:\n                if counter[start] == 0:\n                    return False\n                counter[start] -= 1\n                if not counter[start]:\n                    counter.pop(start)\n                start += 1\n                count += 1\n        return not counter", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n        \n        #start = 10**9\n        #end = 1\n        \n        v_cnt = collections.defaultdict(int)\n        for v in nums:\n            v_cnt[v] += 1\n            \n        for v in sorted(v_cnt.keys()):\n            if v_cnt[v] == 0:\n                continue\n            else:\n                l = v_cnt[v]\n                for nv in range(v+1, v+k):\n                    if v_cnt[nv] < l:\n                        return False\n                    v_cnt[nv] -= l\n        \n        return True", "class Solution:\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        heapify(nums)\n        \n        if len(Ct) > len(nums)*0.75:                               \n            return self.isNStraightHand(nums, k)\n\n        while Ct:\n            start = heappop(nums)\n            while not Ct[start]:\n                start = heappop(nums)\n            for i in range(start, start + k):\n               # print(num+i)\n                if not Ct[i]: return False\n                if Ct[i] == 1: del Ct[i]\n                else: Ct[i] -= 1\n                \n        return True\n\n\n    def isNStraightHand(self, hand, W):\n      #  heapify(hand)\n        \n        while hand:\n            last_item = heappop(hand)\n            leftover = []\n            \n            for _ in range(W - 1):\n                if not hand: return False                \n                next_item = heappop(hand)\n                \n                while next_item == last_item:\n                    leftover.append(next_item)\n                    if not hand: return False                       \n                    next_item = heappop(hand)\n                    \n                if next_item > last_item + 1: return False                    \n                last_item = next_item                \n            for item in leftover:\n                heappush(hand, item)\n                \n        return True", "#counter\n#\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        if n % k != 0:\n            return False\n        \n        counter = collections.Counter(nums)\n        keys = sorted(counter)\n        print(keys)\n        for i in keys:\n            while i in counter:\n                cur = i\n                counter[cur] -= 1\n                if not counter[cur]:\n                    del counter[cur] \n                for _ in range(k - 1):\n                    if cur + 1 in counter:\n                        cur += 1\n                        counter[cur] -= 1\n                        if not counter[cur]:\n                            del counter[cur] \n                    else:\n                        return False\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        nums.sort()\n        h = []\n        for num in nums:\n            tmp = []\n            found = False\n            while h:\n                max_idx, min_idx = heapq.heappop(h)\n                if max_idx > num - 1:\n                    tmp.append((max_idx, min_idx))\n                    break  \n                \n                if max_idx == num - 1:\n                    found = True\n                    if max_idx - min_idx + 2 == k:\n                        break\n                    \n                    heapq.heappush(h, (max_idx + 1, min_idx))\n                    \n                    break\n                tmp.append((max_idx, min_idx))\n                \n            for item in tmp:\n                heapq.heappush(h, item)\n            \n            if found:\n                continue\n            \n            if k != 1:\n                heapq.heappush(h, (num, num))\n\n        return not h", "from collections import defaultdict, Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if(len(nums) % k != 0):\n            return False\n        elems = sorted(list(set(nums)))\n        count = defaultdict(int)\n        for elem in elems:\n            count[elem] = 0\n        for num in nums:\n            count[num] += 1\n        while(len(count) > 0):\n            x = list(count.keys())[0]  \n            for i in range(x,x+k):\n                if(count[i] == 0):\n                    return False\n                count[i] -= 1\n                if(count[i] == 0):\n                    del count[i]\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        nums.sort()\n        counts = collections.Counter(nums)\n        \n        for x in nums:\n            if counts[x] == 0:\n                continue\n            exist_chain = True\n            for i in range(k):\n                if counts[x+i] == 0:\n                    return False\n                counts[x+i] -= 1\n        \n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        l=nums[::]\n        l.sort()\n        n=len(l)\n        d=Counter(l)\n        count=0\n        for i in range(n):\n            if d[l[i]]!=0:\n                d[l[i]]-=1\n                f=0\n                for j in range(l[i]+1,l[i]+k):\n                    if d[j]==0:\n                        f=1\n                        break\n                    d[j]-=1\n                if f==1:\n                    return False\n        return True\n                    \n               \n                        \n                        \n                        \n                        \n                \n        \n        \n        \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k > 0:\n            return False\n\n        # Starting at smallest number, remove sequences of size k\n        d = {}\n        \n        for num in nums:\n            d[num] = d.get(num, 0) + 1\n\n        for num in nums:\n            if d[num] > 0 and (num-1 not in d or d[num-1] < d[num]):\n                # num is start of a sequence; try removing k\n                for _ in range(k):\n                    if num not in d or d[num] == 0:\n                        return False\n                    d[num] -= 1\n                    num += 1\n        \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        counter = Counter(nums)\n        heap_nums=[]\n        groups=[]\n        for key, val in counter.items():\n            heapq.heappush(heap_nums,(key,val))\n        \n        while(heap_nums):\n            count=0\n            sub_group=[]\n            remaining_elements=[]\n            while(count<k):\n                if not heap_nums:\n                    return False\n                popped_elem=heapq.heappop(heap_nums)\n                if popped_elem[1]-1>0:\n                    remaining_elements.append(popped_elem)\n                if not sub_group:\n                    sub_group.append(popped_elem[0])\n                else:\n                    if popped_elem[0]-1 == sub_group[-1]:\n                        sub_group.append(popped_elem[0])\n                    else:\n                        return False\n                count+=1\n\n            groups+=sub_group\n            for elem in remaining_elements:\n                heapq.heappush(heap_nums,(elem[0],elem[1]-1))\n\n        return True", "from collections import deque, Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        counter = Counter(nums)\n        q = deque()\n        lowest = 0\n        nums = sorted(set(nums))\n        for i in range(len(nums)):\n            if i and nums[i] != nums[i - 1] + 1 and lowest:\n                return False\n            \n            diff = counter[nums[i]] - lowest\n            if diff < 0:\n                return False\n            \n            if diff > 0:\n                q.appendleft((i + k - 1, diff))\n                \n            lowest = counter[nums[i]]\n            \n            if q[-1][0] == i:\n                lowest -= q.pop()[1]\n            \n        return not q", "from collections import Counter\nfrom heapq import heappop, heappush, heapify\n\ndef create_pairs(A):\n    sorted_A = sorted(A)\n    prev = sorted_A[0]\n    pairs = [[prev, 1]]\n    for curr in sorted_A[1:]:\n        if curr !=  prev:\n            pairs.append([curr, 1])\n            prev = curr\n        else:\n            pairs[-1][1] += 1\n    return [tuple(x) for x in pairs]\n\ndef is_possible_divide(heap, k):\n    if len(heap) == 0:\n        return True\n    else:\n        popped = []\n        prev, min_count = heappop(heap)\n        for i in range(k - 1):\n            if not heap:\n                return False\n            else:\n                value, count = heappop(heap)\n                if value != prev + 1:\n                    return False\n                else:\n                    count -= min_count\n                    prev = value\n                if count > 0:\n                    popped.append((value, count))\n        for val in popped:\n            heappush(heap, val)\n        # heap.extend(popped)\n        # heapify(heap)\n        return is_possible_divide(heap, k)\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        # heap = list(Counter(nums).items())\n        heap = create_pairs(nums)\n        print(heap)\n        heapify(heap)\n        return is_possible_divide(heap, k)\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums)%k!=0:\n            return False\n        nums.sort()\n        #print(nums,k)\n        d={}\n        for i in nums:\n            d[i]=d.get(i,0)+1\n        for j in d:\n            while d[j]>0:\n                for x in range(j,j+k):\n                    if d.get(x,0)>0:\n                        d[x]-=1\n                    else:\n                        return False\n        return True\n        \n        \n        '''\n        i=0\n        while k<=len(nums):\n            a=nums[0]\n            for j in range(k):\n                if a+j not in nums or len(nums)==0:\n                    return False\n                nums.remove(a+j)\n            if len(nums)%k!=0:\n                return False\n            if len(nums)==0:\n                return True\n        return True\n        \n        while True :\n            a=nums[0]\n            for i in range(k):\n                if a+i not in nums or len(nums)==0:\n                    return False\n                nums.remove(a+i)\n            if len(nums)%k!=0:\n                return False\n            if len(nums)==0:\n                return True\n        '''", "from collections import Counter\n\nclass Solution:\n    '''\n    Good use of counter\n    Same can be done in complex way with sorting the array and using orderedDict\n    '''\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        c = Counter(nums)\n        while c:\n            m = min(c)\n            for i in range(m, m+k):\n                if i not in c:\n                    return False\n                elif c[i] == 1:\n                    del c[i]\n                else:\n                    c[i] -= 1\n                    \n        return True\n                \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0 or len(nums) < k:\n            return False\n        from collections import Counter\n        import heapq\n        \n        d = Counter(nums)\n        num_groups = len(nums) // k\n        h = [(i,c) for i,c in d.items()]\n        heapq.heapify(h)\n\n        while len(h) > 0:\n            temp = []\n            k_= k\n            while k_ > 0:\n                if h:\n                    x,c = heapq.heappop(h) # pop the smallest element\n                    #if d[x] > 0:\n                    if temp:\n                        if temp[-1] == x - 1:\n                            temp.append(x)\n                        else:\n                            return False\n                    else:\n                        temp.append(x)\n                else:\n                    return False\n                \n                d[x] -= 1\n                k_ -= 1\n            for x in temp:\n                if d[x] > 0:\n                    heapq.heappush(h,(x,d[x]))\n            \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count = collections.Counter(nums)\n        que = collections.deque()\n        last_required = 0\n        last_num = 0\n        for num, num_count in sorted(count.items()):\n            if last_required > 0 and last_num + 1 != num or num_count < last_required:\n                return False\n            que.append(num_count - last_required)\n            last_required = num_count\n            if len(que) == k:\n                last_required -= que.popleft()\n            last_num = num\n        return last_required == 0\n            \n    \n    \n    def isPossibleDivide_II(self, nums: List[int], k: int) -> bool:\n        count = collections.Counter(nums)\n        for next_num in sorted(count):\n            next_dup = count[next_num]\n            for j in range(next_num, next_num + k):\n                if count[j] < next_dup:\n                    return False\n                count[j] -= next_dup\n        return True", "class Solution:\n    def isPossibleDivide(self, hand: List[int], W: int) -> bool:\n        if len(hand) % W:\n            return False\n        cnt = Counter(hand)\n        cards = sorted(cnt)\n        while True:\n            first = cards.pop()\n            if not cnt[first]:\n                continue\n            elif cnt[first] > 1 :        \n                cnt[first] -= 1\n                cards.append(first)\n            else:\n                del cnt[first]\n            for i in range(first - 1, first - W, -1):\n                if not cnt[i]:\n                    return False\n                elif cnt[i] > 1:\n                    cnt[i] -= 1\n                else:\n                    del cnt[i]\n            if not cnt:\n                return True\n        return False # never happen", "from collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n                \n        cnums = Counter(nums)\n        nums.sort()\n        \n        for i in nums:\n            if cnums[i] == 0:\n                continue\n            \n            for j in range(i, i+k):\n                if cnums[j] == 0:\n                    return False\n                cnums[j] -= 1\n        \n        return True        \n                \n                \n            \n            \n            \n            \n", "from collections import Counter\nfrom heapq import heappop, heapify\n\ndef create_pairs(A):\n    sorted_A = sorted(A)\n    prev = sorted_A[0]\n    pairs = [[prev, 1]]\n    for curr in sorted_A[1:]:\n        if curr !=  prev:\n            pairs.append([curr, 1])\n            prev = curr\n        else:\n            pairs[-1][1] += 1\n    return [tuple(x) for x in pairs]\n\ndef is_possible_divide(heap, k):\n    if len(heap) == 0:\n        return True\n    else:\n        popped = []\n        prev, min_count = heappop(heap)\n        for i in range(k - 1):\n            if not heap:\n                return False\n            else:\n                value, count = heappop(heap)\n                if value != prev + 1:\n                    return False\n                else:\n                    count -= min_count\n                    prev = value\n                if count > 0:\n                    popped.append((value, count))\n        heap.extend(popped)\n        heapify(heap)\n        return is_possible_divide(heap, k)\n\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0:\n            return False\n        # heap = list(Counter(nums).items())\n        heap = create_pairs(nums)\n        print(heap)\n        heapify(heap)\n        return is_possible_divide(heap, k)\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        count = collections.Counter(nums)\n        \n        heap = []\n        for (num, cnt) in count.items():\n            heapq.heappush(heap, (num, cnt))\n            \n        while heap:\n            nums, cnts = [], []\n            for _ in range(k):\n                if not heap:\n                    return False\n                else:\n                    (num, cnt) = heapq.heappop(heap)\n                    nums.append(num)\n                    cnts.append(cnt)\n                    \n            if not all(b == a + 1 for (a, b) in zip(nums, nums[1:])):\n                return False\n            \n            for (num, cnt) in zip(nums, cnts):\n                if cnt > 1:\n                    heapq.heappush(heap, (num, cnt - 1))\n                    \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        numDict = {}\n        for num in nums:\n            if str(num) in numDict:\n                numDict[str(num)] +=1\n            else:\n                numDict[str(num)] = 1\n        \n        for key in sorted(list(numDict.keys()), key= lambda x: int(x)):\n            val = numDict[key]\n            if val == 0:\n                continue\n            for i in range(1, k):\n                if str(int(key)+i) not in numDict:\n                    return False\n                temp = numDict[str(int(key)+i)] - val\n                if temp < 0:\n                    return False\n                numDict[str(int(key)+i)] = temp\n                \n        \n        return True\n", "#counter, delete them one-by-one\n#{1:1, 2:2, 3:3, 4:2, 5:1, 9:1, 10:1, 11:1}\nfrom collections import Counter\nclass Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        counter = Counter(nums)\n        for num in sorted(counter.keys()):\n            count = counter[num]\n            if count == 0:\n                continue\n            for i in range(num, num+k):\n                counter[i] -= count\n                if counter[i] < 0:\n                    return False\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k != 0 or len(nums) < k:\n            return False\n        from collections import Counter\n        import heapq\n        \n        d = Counter(nums)\n        num_groups = len(nums) // k\n        h = [(i,c) for i,c in d.items()]\n        heapq.heapify(h)\n\n        while len(h) > 0:\n            temp = []\n            k_= k\n            while k_ > 0:\n                if h:\n                    x,c = heapq.heappop(h) # pop the smallest element\n                    #if d[x] > 0:\n                    if temp:\n                        if temp[-1] == x - 1:\n                            temp.append(x)\n                        else:\n                            return False\n                    else:\n                        temp.append(x)\n                else:\n                    return False\n                \n                d[x] -= 1\n                k_ -= 1\n            print(temp)\n            for x in temp:\n                if d[x] > 0:\n                    heapq.heappush(h,(x,d[x]))\n            \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        import collections\n        c = collections.Counter(nums)\n        for i in sorted(c):\n            if c[i] > 0:\n                for j in range(k)[::-1]:\n                    c[i + j] -= c[i]\n                    if c[i + j] < 0:\n                        return False\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums)%k!=0:\n            return False\n        candidates=collections.Counter(nums)\n        keys=list(candidates.keys())\n        keys.sort()\n        i=0\n        while i<len(keys):\n            x=keys[i]\n            if candidates[x]==0:\n                i+=1\n            else:\n                temp=1\n                candidates[x]-=1\n                while temp<k:\n                    if candidates[x+temp]>0:\n                        candidates[x+temp]-=1\n                        temp+=1\n                    else:\n                        return False\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        count=collections.Counter(nums)\n        print(count)\n        nums.sort()\n        for x in nums:\n            if count[x]==0:\n                continue\n                \n            else:\n                for i in range(1,k):\n                    print(x,x+i)\n                    if count[x+i]>0:\n                        count[x+i]-=1\n                    elif count[x-i]>0:\n                        count[x-i]-=1\n                        \n                    else:\n                        return False\n            count[x]-=1\n                    \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        q = collections.deque()\n        opened, prev = 0, -1\n        cnt = collections.Counter(nums)\n        for ele in sorted(cnt):\n            if cnt[ele] < opened or opened > 0 and ele > prev + 1:\n                return False\n            q.append(cnt[ele] - opened)\n            prev = ele\n            opened = cnt[ele]\n            if len(q) == k: opened -= q.popleft()\n        return opened == 0\n            \n        \n#1:3\n#2:2\n#3:1\n#4:1\n#k=4\n#q=[3,-1,-1,0]\n#1\n#1 2\n#1 2 3\n#4\n", "class Solution:                \n    \n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:        \n        import heapq\n        heap = []\n        hm = {}\n        for i in nums:\n            if i not in hm:\n                hm[i] = 0\n            hm[i] += 1\n            \n        for i in hm:\n            heapq.heappush(heap, (i, hm[i]))\n            \n        while len(heap):\n            pending = []\n            x = heapq.heappop(heap)\n            if x[1] - 1 > 0:\n                pending.append((x[0], x[1] - 1))\n            \n            cnt = 1\n            last = x[0]\n            while cnt < k:\n                if len(heap) == 0 or heap[0][0] != last + 1:\n                    return False\n                n = heapq.heappop(heap)\n                if n[1] - 1 > 0:\n                    pending.append((n[0], n[1]-1))\n                last = n[0]\n                cnt += 1\n            for x in pending:\n                heapq.heappush(heap, x)\n        return True\n        \n                \n        \n                \n            \n            \n                \n            \n        \n        \n        \n        \n        \n        \n                \n                \n        \n    \n", "class Solution:\n  def isPossibleDivide(self, nums, k):\n    d = collections.Counter(nums)\n    roots = [n for n in d if not d[n - 1]]\n    for r in roots:\n        for i in reversed(range(r, r + k)):\n            if d[i] < d[r]:\n              return False\n            d[i] -= d[r]\n            if not d[i] and d[i + 1]:\n                roots.append(i + 1)\n    return True", "class Solution:\n    def isPossibleDivide(self, nums, k: int) -> bool:\n        if not nums or not k:\n            return False\n\n        c = Counter(nums)\n        nums.sort()\n        for num in nums:\n            if num not in c:\n                continue\n            for i in range(k):\n                if num + i in c and c[num + i] > 0:\n                    c[num + i] -= 1\n                    if c[num + i] == 0:\n                        del c[num + i]\n                else:\n                    return False\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums)%k!=0:\n            return False\n        c=Counter(nums)\n        keys=sorted(c)\n        for key in keys:\n            while c[key]>0:\n                for i in range(k):\n                    if key+i in list(c.keys()) and c[key+i]>0:\n                        c[key+i]-=1\n                    else:\n                        return False\n        return True\n\n                \n                    \n", "from typing import List\nfrom collections import Counter\nfrom sortedcontainers import SortedSet\n\nclass Solution:\n    def isPossibleDivide(self, hand: List[int], W: int) -> bool:\n        # print('-----')\n        # print(f'hand: {hand}')\n        # print(f'W: {W}')\n\n        if not hand:\n            return True\n        elif len(hand) % W != 0:\n            return False\n        else:\n            counts = Counter(hand)\n            ns = SortedSet(list(counts.keys()))\n\n            numRounds = len(hand) // W\n            for r in range(numRounds):\n                if len(ns) < W:\n                    return False\n                else:\n                    nn = list(ns.islice(stop=W))\n                    # print(f'r={r} nn={nn} ns={ns} counts={counts}')\n                    prev = ns[0] - 1\n                    for n in nn:\n                        if n == prev + 1:\n                            counts[n] -= 1\n                            if counts[n] == 0:\n                                ns.remove(n)\n                            prev = n\n                        else:\n                            return False\n\n            return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        freq = Counter(nums)\n        \n        start = []\n        for n,v in freq.items():\n            if freq[n-1] == 0:\n                start.append(n)\n        \n        while start:\n            \n            num = start.pop()\n            \n            if freq[num] == 0:\n                continue\n            else:\n                for t in range(num+k-1,num-1,-1):\n                    if freq[t] < freq[num]:\n                        return False\n                    freq[t] -= freq[num]\n                    if freq[t] == 0 and freq[t+1] > 0:\n                        start.append(t+1)\n\n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count = collections.Counter(nums)\n        \n        if len(count):\n            start = min(count)\n\n            while len(count):\n                #print(count)\n                if count[start] == 0:\n                    start = min(count)\n                for num in range(start, start+k):\n                    if count[num]:\n                        count[num] -=1\n                    else:\n                        return False\n                    if count[num] == 0:\n                        del count[num]\n                        start +=1\n                        \n            return True\n        \n        return False", "class Solution:\n  # 456 ms\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k: return False\n        Ct = Counter(nums)\n        keys = list(Ct.keys())\n        heapify(keys)\n        num = heappop(keys)\n        \n        while Ct:\n            while not Ct[num]:\n                num = heappop(keys)\n            for i in range(k):\n               # print(num+i)\n                if not Ct[num+i]: return False\n                if Ct[num+i] == 1: del Ct[num+i]\n                else: Ct[num+i] -= 1\n                \n        return True", "class Solution:\n  def isPossibleDivide(self, nums, k):\n    ctr = Counter(nums)\n    for num in nums:\n        start = num\n        while ctr[start - 1]:\n            start -= 1\n        while start <= num:\n            times = ctr[start]\n            if times:\n                for victim in range(start, start + k):\n                    if ctr[victim] < times:\n                        return False\n                    ctr[victim] -= times\n            start += 1\n    return True", "import collections \n\n\nclass Solution(object):\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        if not nums:\n            return False\n        \n        if len(nums)%k != 0:\n            return False\n        \n        count_map = collections.Counter(nums)\n        \n        while count_map:\n            min_ele = min(count_map)\n            \n            for i in range(k):\n                key_count = count_map.get(min_ele+i, None)\n                if not key_count:\n                    return False\n                \n                if key_count == 1:\n                    del count_map[min_ele+i]\n                else:\n                    count_map[min_ele+i] -= 1\n                    \n        \n        return True", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n#         if len(nums) % k or len(nums) < k:\n#             return false\n        \n#         ktrack = 0\n        \n#         nums.sort()\n        \n#         for n in nums:\n        nums.sort()\n        \n        index = {}\n        for i in nums:\n            index[i] = index.get(i,0) + 1\n            \n        for i in index:\n            # subtracting from dict count until nothing left\n            # k-size lists must be asc\n            while index[i] > 0:\n                # creating window for k-size list\n                for j in range(i,i+k):\n                    # if j still has any left, decrement\n                    if index.get(j,0) > 0:\n                        index[j] -= 1\n                    else:\n                        return False\n        return True\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count = defaultdict(int)\n        for n in nums:\n            count[n] += 1\n        \n        for n in sorted(count):\n            if count[n] == 0:\n                continue\n            \n            occ = count[n]\n            count[n] = 0\n            for i in range(n+1, n+k):\n                count[i] -= occ\n                if count[i] < 0:\n                    return False\n        \n        return True\n        \n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \n        l = len(nums)\n        \n        if l%k!=0:\n            return False\n        \n        g = int(l//k)\n        \n        num_dict = dict()\n        for num in nums:\n            num_dict[num] = num_dict.get(num, 0) + 1\n        \n        for i in range(g):\n            val = min(num_dict.keys())\n            if num_dict[val]==1:\n                del num_dict[val]\n            else:\n                num_dict[val] -= 1\n            \n            for j in range(1, k):\n                val += 1\n                if val not in num_dict:\n                    return False\n                elif num_dict[val]==1:\n                    del num_dict[val]\n                else:\n                    num_dict[val] -= 1\n        \n        return True\n                    \n    \n\n", "class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        count = collections.defaultdict(int)\n        nums.sort()\n        for n in nums:\n            if count[n] == 0:\n                for i in range(1,k):\n                    count[n+i] += 1\n            else:\n                count[n] -= 1\n        for c in count.values():\n            if c>0:\n                return False\n        return True"]
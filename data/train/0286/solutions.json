["from math import comb\n\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        n = len(balls)\n        s = sum(balls)\n        s2 = s // 2\n\n        @lru_cache(None)\n        def count(index, delta, ca):\n            if index == n: return 1 if delta == 0 and ca == s2 else 0\n            total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n            total += count(index + 1, delta + 1, ca)\n            total += count(index + 1, delta - 1, ca + balls[index])\n            return total\n\n        return count(0, 0, 0) / comb(s, s // 2)\n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        @lru_cache(None)\n        def select(n, r):\n            if r > n:\n                return 0\n            if  r == 0:\n                return 1\n            if r == 1:\n                return n\n            return select(n-1, r) + select(n-1, r-1)\n        \n        @lru_cache(None)\n        def dputil(i, j, pos, n):\n            if pos == -1:\n                if n == 0:\n                    return 1\n                else:\n                    return 0\n            p2 = 1<<pos\n            if i&p2 and j&p2:\n                ans = 0\n                for x in range(1, balls[pos]):\n                    diff = n - 2*x + balls[pos]\n                    ans += dputil(i, j, pos-1, diff)*select(balls[pos], x)\n                return ans\n            if i&p2:\n                return dputil(i, j, pos-1, n-balls[pos])\n            else:\n                return dputil(i, j, pos-1, n+balls[pos])\n        \n        def numsplits(n):\n            cnt = 0\n            while n:\n                cnt += n%2\n                n = n//2\n            return cnt\n        \n        k = len(balls)\n        tot = sum(balls)\n        k2 = 1<<k\n        valid = 0\n        for i in range(k2):\n            for j in range(k2):\n                if (i|j != k2-1) or numsplits(i) != numsplits(j):\n                    continue\n                valid += dputil(i, j, k-1, 0)\n        return float(valid)/float(select(tot, tot//2))\n", "from math import factorial\n\n\ndef choose(n, k):\n    return factorial(n)//(factorial(n - k) * factorial(k))\n\ndef allPossibilities(balls):\n    n = sum(balls)\n    \n    total = factorial(n)\n    \n    for b in balls:\n        total //= factorial(b)\n        \n    return total\n\ndef count(balls, balance, a, b, i):\n    c = balls[i]\n    \n    upper = min(c, a)\n    lower = max(c - b, 0)\n    \n    tempBalance = balance\n    \n    total = 0\n    \n    for j in range(lower, upper + 1):\n        balance = tempBalance\n        if j == 0:\n            balance -= 1\n        if j == c:\n            balance += 1\n        if i == len(balls) - 1:\n            if balance == 0:\n                return 1\n            else:\n                return 0\n        else:\n            total += choose(a, j) * choose(b, c - j) * count(balls, balance, a - j, b - c + j, i + 1)\n            \n    return total\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        return count(balls, 0, sum(balls) // 2, sum(balls) // 2, 0) / allPossibilities(balls)\n", "from math import comb, prod\nfrom itertools import accumulate\n\nclass Solution:\n  def getCombinations(self, balls, l, r, d):\n    # l, r: number of available position on left and right,\n    # d: difference of number of distinct color on left and right.\n    if not balls:\n      return d == 0\n    if abs(d) > len(balls):\n      return 0\n    x, count = balls.pop(), 0\n    for i in range(x + 1):\n      if l >= i and r >= x - i:\n        count += comb(l, i) * comb(r, x - i) * self.getCombinations(\n          balls.copy(), l - i, r - (x - i), d - (i == 0) + (i == x)\n        )\n    return count\n  def getProbability(self, balls: List[int]) -> float:\n    n = sum(balls)\n    total = prod(comb(n, x) for n, x in zip(accumulate(balls), balls))\n    count = self.getCombinations(balls, n // 2, n // 2, 0)\n    return count / total", "import functools as ft\nimport math\nimport operator\n\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = 0\n        self.valid = 0\n        self.balls = balls\n        self.k = len(balls)\n        self.n = sum(balls) // 2\n        self.ball_sums = [sum(balls[index :]) for index in range(self.k + 1)]\n        self.update([], 0, 0)\n        return self.valid / self.total\n    \n    @ft.lru_cache(None)\n    def factorial(self, n: int) -> int:\n        return math.factorial(n)\n\n    @ft.lru_cache(None)\n    def count(self, *balls: int) -> int:\n        return self.factorial(self.n) // ft.reduce(operator.mul, map(self.factorial, balls))\n    \n    def update(self, left_balls: List[int], total: int, delta: int) -> None:\n        if len(left_balls) == self.k:\n            if total != self.n:\n                return\n            right_balls = [total_cnt - left_cnt for left_cnt, total_cnt in zip(left_balls, self.balls)]\n            count = self.count(*sorted(left_balls)) * self.count(*sorted(right_balls))\n            self.total += count\n            if delta == 0:\n                self.valid += count\n            return\n        index = len(left_balls)\n        if total + self.ball_sums[index] < self.n:\n            return\n        if total > self.n:\n            return\n        if index == self.k - 1:\n            new_delta = delta + (self.n - total == self.balls[index]) - (self.n - total == 0)\n            self.update(left_balls + [self.n - total], self.n, new_delta)\n            return\n        for cnt in range(self.balls[index] + 1):\n            new_delta = delta + (cnt == self.balls[index]) - (cnt == 0)\n            self.update(left_balls + [cnt], total + cnt, new_delta)", "import math\nclass Solution:\n    def Prob(self, balls: List[int], left: int, right: int, diff: int) -> float:\n        if len(balls) == 1:\n            return 1 if (left*right != 0 and diff == 0) or (left == 0 and diff == -1) or (right == 0 and diff == 1) else 0\n        a = balls[-1]\n        p = [float(math.comb(a,i)*math.prod(range(left-i+1, left+1))*math.prod(range(right-a+i+1, right+1)))/math.prod(range(left+right-a+1, left+right+1)) for i in range(a+1)]\n        A = [self.Prob(balls[:-1], left, right-a,diff+1)] + [self.Prob(balls[:-1], left-i, right-a+i,diff) for i in range(1,a)] + [self.Prob(balls[:-1], left-a, right,diff-1)]\n        S = sum(p[i]*A[i] for i in range(a+1))\n        return S\n    def getProbability(self, balls: List[int]) -> float:\n        return self.Prob(balls, sum(balls)//2, sum(balls)//2, 0)", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        '''\n        \u7bb1\u5b50\u4e2d\u6709n\u4e2a\u7403\uff0c\u7bb1\u4e2d\u67092\u79cd\u989c\u8272\u7684\u7403\uff0c\u5206\u522b\u6709k1,k2\u4e2a\n        \u7bb1\u5b50\u4e2d\u7684\u7ec4\u5408\u6570\u4e3an!/k1!k2!\n        '''\n        n=sum(balls)  #\u603b\u7403\u6570\n        k=len(balls)  #\u7403\u8272\u6570\n        total=0\n        valid=0\n        fact=[1]*50   #\u5f97\u5230\u6bcf\u4e2a\u6570\u7684\u9636\u4e58\n        for i in range(1,50):\n            fact[i]=fact[i-1]*i\n        #d: depth\n        #b1, b2: # of balls in box1, box2\n        #c1,c2 :\u4e24\u4e2abox\u4e2d\u4e0d\u540c\u8272\u7684\u7403\u6570\n        #p1, p2: # permutations of duplicate balls in box1, box2\n        def dfs(d,b1,b2,c1,c2,p1,p2):\n            nonlocal total\n            nonlocal valid\n            #\u4e24\u4e2a\u76d2\u5b50\u4e2d\u7403\u6570\u8981\u76f8\u540c\n            if b1>n//2 or b2>n//2:\n                return\n            if d==k:\n                count=fact[b1]/ p1*fact[b2]/ p2\n                #\u6b64\u65f6\u7684\u7ec4\u5408\u603b\u6570\n                #\u5224\u65ad\u662f\u5426\u7b26\u5408\u6240\u8981\u6c42\u7684\n                total+=count\n                valid+=count*(c1==c2)\n                return\n            for s1 in range(balls[d]+1):\n                s2=balls[d]-s1\n                dfs(d+1,b1+s1,b2+s2,c1+(s1>0),c2+(s2>0),p1*fact[s1],p2*fact[s2])\n        dfs(0,0,0,0,0,1,1)\n        return valid/total", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        N = len(balls)\n        sm = sum(balls)\n        half = sm // 2\n        \n        @lru_cache(None)\n        def rec2(cur, na, nb):\n            if na > half or nb > half:\n                return 0\n            if cur == N:\n                return int(na == nb)\n            \n            ans = 0\n            for i in range(balls[cur]+1):\n                remplacea, remplaceb = (half - na), (half-nb)\n                choice = math.comb(remplacea, i) * math.comb(remplaceb, balls[cur] - i)\n                ans += rec2(cur+1, na + i, nb + balls[cur] - i) * choice\n            \n            return ans\n        \n        \n        @lru_cache(None)\n        def rec(cur, na, nb, uniquea, uniqueb):\n            if na > half or nb > half:\n                return 0\n            if cur == N:\n                # print(na, nb, uniquea, uniqueb)\n                if na != nb or uniquea != uniqueb:\n                    return 0\n                # print(uniquea, uniqueb)\n                return 1\n            \n            gg = 0\n            for i in range(balls[cur]+1):\n                toa, tob = na+i, nb + balls[cur] - i\n                ua, ub = uniquea + int(i > 0), uniqueb + int(balls[cur] - i > 0)\n                \n                remplacea, remplaceb = (half - na), (half-nb)\n                choice = math.comb(remplacea, i) * math.comb(remplaceb, balls[cur] - i)\n                gg += rec(cur+1, toa, tob, ua, ub) * choice\n                \n            return gg\n        \n        gg = rec(0, 0, 0, 0, 0)\n        permutation = math.factorial(sm)/math.factorial(half)\n        al = rec2(0,0,0)\n        return gg/al", "from math import factorial as fac\nfrom itertools import product\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        \n        def ways(nums):\n            tmp = fac(sum(nums))\n            for num in nums:\n                tmp //= fac(num)\n            return tmp\n        \n        half = sum(balls)//2\n        n = len(balls)\n        res = 0\n        stack = [list(range(ball+1)) for ball in balls]\n        comb = list(product(*stack))\n        \n        for i in range(len(comb)):\n            if sum( comb[i] ) == half and comb[i].count(0) == comb[-i-1].count(0):\n                res += ways(comb[i]) * ways(comb[-i-1])\n                \n        return res / ways(balls)                \n        \n        \n\n        \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        @lru_cache(None)\n        def C(n, m):\n            # c = 1\n            # for i in range(n, n - m, -1):\n            #     c *= i\n            return math.factorial(n) / math.factorial(m) / math.factorial(n - m)\n        \n        # @lru_cache(None)\n        def choose(i, k, d1, d2, cnt):\n            if k == 0 and i <= n:\n                return cnt, (cnt if d1 == d2 + n - i else 0)\n            if k < 0 or i == n:\n                return 0, 0\n            total = 0\n            equal = 0\n            for j in range(balls[i] + 1):\n                if k - j < 0:\n                    break\n                t, e = choose(i + 1, k - j, d1 + (1 if j > 0 else 0), d2 + (1 if j < balls[i] else 0), cnt * C(balls[i], j))\n                total += t\n                equal += e\n            return total, equal\n        \n        n = len(balls)\n        k = sum(balls)\n        t, e = choose(0, k // 2, 0, 0, 1)\n        return e / t\n            \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        n=sum(balls)  #\u603b\u7403\u6570\n        k=len(balls)  #\u7403\u8272\u6570\n        self.total=self.valid=0\n        fact=[1]*50   #\u5f97\u5230\u6bcf\u4e2a\u6570\u7684\u9636\u4e58\n        for i in range(1,50):\n            fact[i]=fact[i-1]*i\n        #d: depth\n        #b1, b2: # of balls in box1, box2\n        #c1,c2 :\u4e24\u4e2abox\u4e2d\u4e0d\u540c\u8272\u7684\u7403\u6570\n        #p1, p2: # permutations of duplicate balls in box1, box2\n        def dfs(d,b1,b2,c1,c2,p1,p2):\n            if b1>n//2 or b2>n//2:\n                return\n            if d==k:\n                count=fact[b1] / p1 * fact[b2] / p2\n                self.total+=count\n                self.valid+=count*(c1==c2)\n                return\n            for s1 in range(balls[d]+1):\n                s2=balls[d]-s1\n                dfs(d+1,b1+s1,b2+s2,c1+(s1>0),c2+(s2>0),p1*fact[s1],p2*fact[s2])\n        dfs(0,0,0,0,0,1,1)\n        return self.valid/self.total", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        '''\n        \u7bb1\u5b50\u4e2d\u6709n\u4e2a\u7403\uff0c\u7bb1\u4e2d\u67092\u79cd\u989c\u8272\u7684\u7403\uff0c\u5206\u522b\u6709k1,k2\u4e2a\n        \u7bb1\u5b50\u4e2d\u7684\u7ec4\u5408\u6570\u4e3an!/k1!k2!\n        '''\n        n=sum(balls)  #\u603b\u7403\u6570\n        k=len(balls)  #\u7403\u8272\u6570\n        self.total=self.valid=0\n        fact=[1]*50   #\u5f97\u5230\u6bcf\u4e2a\u6570\u7684\u9636\u4e58\n        for i in range(1,50):\n            fact[i]=fact[i-1]*i\n        #d: depth\n        #b1, b2: # of balls in box1, box2\n        #c1,c2 :\u4e24\u4e2abox\u4e2d\u4e0d\u540c\u8272\u7684\u7403\u6570\n        #p1, p2: # permutations of duplicate balls in box1, box2\n        def dfs(d,b1,b2,c1,c2,p1,p2):\n            if b1>n//2 or b2>n//2:\n                return\n            if d==k:\n                count=fact[b1]/ p1*fact[b2]/ p2\n                self.total+=count\n                self.valid+=count*(c1==c2)\n                return\n            for s1 in range(balls[d]+1):\n                s2=balls[d]-s1\n                dfs(d+1,b1+s1,b2+s2,c1+(s1>0),c2+(s2>0),p1*fact[s1],p2*fact[s2])\n        dfs(0,0,0,0,0,1,1)\n        return self.valid/self.total", "from math import factorial as fac\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        \n        def ways(nums):\n            tmp = fac(sum(nums))\n            for num in nums:\n                tmp //= fac(num)\n            return tmp\n        \n        def dist(pos, rem):\n            if pos == len(balls):\n                if rem == 0:\n                    isValid()\n                return \n            for i in range( min(balls[pos], rem)+1 ):\n                a[pos] = i\n                b[pos] = balls[pos] - i\n                dist(pos + 1, rem - i)\n    \n        def isValid():\n            x = y = 0\n            x = sum(1 for i in a if i > 0)\n            y = sum(1 for j in b if j > 0)\n            if x == y:\n                self.res += ways(a) * ways(b)\n        \n        total = sum(balls)\n        n = len(balls)\n        a = [0] * n\n        b = [0] * n\n        self.res = 0\n        dist(0, total//2)\n        return self.res / ways(balls)\n        \n        \n", "from typing import List\n\n\n# May 30 - May 31, 2002\n# Reviewed: Sep 9, 2020. This is a math + dfs problem.\nclass Solution:\n    def combination(self, N, K) -> int:\n        res = 1\n        for i in range(N, max(K, N - K), -1):\n            res *= i\n        for i in range(2, min(K, N - K) + 1):\n            res /= i\n        return res\n\n    def getProbability(self, balls: List[int]) -> float:\n        total = sum(balls)\n        result = 0\n\n        def dfs(spaceA: int, spaceB: int, colorsA: int, colorsB: int, remainBalls: List[int], probability: float):\n            nonlocal result\n            if not remainBalls:\n                if colorsA == colorsB:\n                    result += probability\n                return\n\n            currentBallCount = remainBalls[0]\n\n            # The total number of ways to distribute the balls in the the boxes\n            c_overall = self.combination(spaceA + spaceB, currentBallCount)\n\n            # For the `currentBallCount`, assume i of them goes to box A and the rest goes to box B.\n            # We need:\n            # 1) `currentBallCount - i` to be within range of [0, spaceB], which give,\n            #\n            #     0 <= currentBallCount - i <= spaceB\n            #     currentBallCount - spaceB <= i <= currentBallCount\n            #\n            # 2) i to be within range [0, spaceA]\n            #\n            # The overall range is [max(currentBallCount - spaceB), min(currentBallCount, spaceA)].\n            for i in range(max(currentBallCount - spaceB, 0), min(currentBallCount, spaceA) + 1):\n                j = currentBallCount - i\n\n                # count the number of ways for i ball to go into box A and j balls to go into box B\n                c1 = self.combination(spaceA, i)\n                c2 = self.combination(spaceB, j)\n\n                p = c1 * c2 / c_overall\n\n                dfs(\n                    spaceA=spaceA - i,\n                    spaceB=spaceB - j,\n                    colorsA=colorsA + (i != 0),\n                    colorsB=colorsB + (j != 0),\n                    remainBalls=remainBalls[1:],\n                    probability=probability * p\n                )\n\n        dfs(spaceA=total // 2, spaceB=total // 2, colorsA=0, colorsB=0, remainBalls=balls, probability=1)\n        return result\n\n\ns = Solution()\nprint((s.getProbability([1, 1])))  # 1.0\nprint((s.getProbability([2, 1, 1])))  # 0.666666666\nprint((s.getProbability([1, 2, 1, 2])))  # 0.6\nprint((s.getProbability([6, 6, 6, 6, 6, 6])))  # 0.90327\n", "from collections import defaultdict as dt\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = self.valid = 0\n        fact = [1] * 50\n        for i in range(1, len(fact)):\n            fact[i] = fact[i-1] * i\n\n        def run(b1, b2, c1, c2, p, idx, n):\n            if b1 > n/2 or b2 > n/2: return\n            if idx == len(balls):\n                # times = fact[b1] / p1 * fact[b2] / p2\n                self.total += p\n                self.valid += p * int(c1 == c2)\n            else:\n                for x in range(balls[idx]+1):\n                    run(\n                        b1+x, \n                        b2+(balls[idx]-x),\n                        c1+int(x>0),\n                        c2+int((balls[idx]-x)>0),\n                        p / fact[x] / fact[balls[idx]-x],\n                        idx+1,\n                        n\n                    )\n        \n        run(0,0,0,0,1.0, 0, sum(balls))\n        return self.valid/self.total", "from math import factorial as fac\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        \n        def ways(nums):\n            tmp = fac(sum(nums))\n            for num in nums:\n                tmp //= fac(num)\n            return tmp\n        \n        def dist(pos, rem):\n            if rem < 0:\n                return\n            if pos == len(balls):\n                if rem == 0:\n                    isValid()\n                return \n            for i in range( min(balls[pos], rem)+1 ):\n                a[pos] = i\n                b[pos] = balls[pos] - i\n                dist(pos + 1, rem - i)\n    \n        def isValid():\n            x = y = 0\n            x = sum(1 for i in a if i > 0)\n            y = sum(1 for j in b if j > 0)\n            if x == y:\n                self.res += ways(a) * ways(b)\n        \n        total = sum(balls)\n        n = len(balls)\n        a = [0] * n\n        b = [0] * n\n        self.res = 0\n        dist(0, total//2)\n        return self.res / ways(balls)\n        \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        @lru_cache(None)\n        def C(n, m):\n            if m > n // 2:\n                return C(n, n - m)\n            return math.factorial(n) / math.factorial(m) / math.factorial(n - m)\n        \n        @lru_cache(None)\n        def choose(i, k, d1, d2, cnt):\n            if k == 0 and i <= n:\n                return cnt, (cnt if d1 == d2 + n - i else 0)\n            if k < 0 or i == n:\n                return 0, 0\n            total = 0\n            equal = 0\n            for j in range(balls[i] + 1):\n                if k - j < 0:\n                    break\n                t, e = choose(i + 1, k - j, d1 + (1 if j > 0 else 0), d2 + (1 if j < balls[i] else 0), cnt * C(balls[i], j))\n                total += t\n                equal += e\n            return total, equal\n        \n        n = len(balls)\n        k = sum(balls)\n        t, e = choose(0, k // 2, 0, 0, 1)\n        return e / t\n            \n", "from collections import defaultdict as dt\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = self.valid = 0\n        fact = [1] * 50\n        for i in range(1, len(fact)):\n            fact[i] = fact[i-1] * i\n\n        def run(b1, b2, c1, c2, p1, p2, idx, n):\n            if b1 > n/2 or b2 > n/2: return\n            if idx == len(balls):\n                times = fact[b1] / p1 * fact[b2] / p2\n                self.total += times\n                self.valid += times * int(c1 == c2)\n            else:\n                for x in range(balls[idx]+1):\n                    run(\n                        b1+x, \n                        b2+(balls[idx]-x),\n                        c1+int(x>0),\n                        c2+int((balls[idx]-x)>0),\n                        p1 * fact[x],\n                        p2 * fact[balls[idx]-x],\n                        idx+1,\n                        n\n                    )\n        \n        run(0,0,0,0,1.0,1.0, 0, sum(balls))\n        return self.valid/self.total", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = 0\n        self.valid = 0\n        t = sum(balls) >> 1\n        n = len(balls)\n        def check(s):\n            return sum([x != 0 for x in s]) == sum([balls[i] - s[i] != 0 for i in range(n)])\n        fac = [1]\n        for i in range(1, t + 1):\n            fac.append(fac[-1] * i)\n        def update(s):\n            x = y = fac[-1]\n            cnt1 = cnt2 = 0\n            for i, c in enumerate(s):\n                x //= fac[c]\n                y //= fac[balls[i] - c]\n                cnt1 += (c > 0)\n                cnt2 += (balls[i] - c > 0)\n            ret = x * y\n            self.total += ret\n            if cnt1 == cnt2:\n                self.valid += ret\n        def dfs(state, i):\n            s, cnt = state\n            if cnt == t:\n                update(s)\n                return \n            if i == n: return\n            for x in range(balls[i] + 1):\n                if cnt + x > t: break\n                s[i] = x\n                dfs((s, cnt + x), i + 1)\n                s[i] = 0\n        s = [0] * n\n        dfs((s, 0), 0)\n        print(self.valid)\n        print(self.total)\n        return self.valid / self.total", "from collections import defaultdict as dt\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = self.valid = 0\n        fact = [1] * 50\n        for i in range(1, len(fact)):\n            fact[i] = fact[i-1] * i\n\n        def run(b1, b2, c1, c2, p, idx, n):\n            if b1 > n/2 or b2 > n/2: return\n            if idx == len(balls):\n                # times = fact[b1] / p1 * fact[b2] / p2\n                self.total += p * int(b1 == b2)\n                self.valid += p * int(b1 == b2) * int(c1 == c2)\n            else:\n                for x in range(balls[idx]+1):\n                    run(\n                        b1+x, \n                        b2+(balls[idx]-x),\n                        c1+int(x>0),\n                        c2+int((balls[idx]-x)>0),\n                        p / fact[x] / fact[balls[idx]-x],\n                        idx+1,\n                        n\n                    )\n        \n        run(0,0,0,0,1.0, 0, sum(balls))\n        return self.valid/self.total", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        '''\n        \u7bb1\u5b50\u4e2d\u6709n\u4e2a\u7403\uff0c\u7bb1\u4e2d\u67092\u79cd\u989c\u8272\u7684\u7403\uff0c\u5206\u522b\u6709k1,k2\u4e2a\n        \u7bb1\u5b50\u4e2d\u7684\u7ec4\u5408\u6570\u4e3an!/k1!k2!\n        \u6bcf\u6b21\u9009\u53d6\u540c\u4e00\u8272\u5f69\u7684\u6240\u6709\u7403\u5206\u5f00\u653e\u5165\u4e24\u4e2a\u76d2\u5b50\u4e2d\n        '''\n        k=len(balls)  #\u603b\u8272\u5f69\u6570\n        n=sum(balls)  #\u603b\u7403\u6570\n        total=0   #\u603b\u7ec4\u5408\u6570\n        valid=0   #\u7b26\u5408\u6761\u4ef6\u603b\u6570\n        fact=[1]*50\n        for i in range(1,50):\n            fact[i]=i*fact[i-1]\n        \n        def dfs(d,b1,b2,c1,c2,p1,p2):\n            nonlocal total\n            nonlocal valid\n            if b1>n//2 or b2>n//2:\n                return\n            if d==k:\n                count=fact[b1]/p1*fact[b2]/p2\n                total+=count\n                valid+=count*(c1==c2)\n                return\n            for s1 in range(balls[d]+1):\n                s2=balls[d]-s1\n                dfs(d+1,b1+s1,b2+s2,c1+(s1>0),c2+(s2>0),p1*fact[s1],p2*fact[s2])\n        dfs(0,0,0,0,0,1,1)\n        return valid/total\n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        '''\n        \u7bb1\u5b50\u4e2d\u6709n\u4e2a\u7403\uff0c\u7bb1\u4e2d\u67092\u79cd\u989c\u8272\u7684\u7403\uff0c\u5206\u522b\u6709k1,k2\u4e2a\n        \u7bb1\u5b50\u4e2d\u7684\u7ec4\u5408\u6570\u4e3an!/k1!k2!\n        '''\n        n=sum(balls)  #\u603b\u7403\u6570\n        k=len(balls)  #\u7403\u8272\u6570\n        self.total=0\n        self.valid=0\n        fact=[1]*50   #\u5f97\u5230\u6bcf\u4e2a\u6570\u7684\u9636\u4e58\n        for i in range(1,50):\n            fact[i]=fact[i-1]*i\n        #d: depth\n        #b1, b2: # of balls in box1, box2\n        #c1,c2 :\u4e24\u4e2abox\u4e2d\u4e0d\u540c\u8272\u7684\u7403\u6570\n        #p1, p2: # permutations of duplicate balls in box1, box2\n        def dfs(d,b1,b2,c1,c2,p1,p2):\n            if b1>n//2 or b2>n//2:\n                return\n            if d==k:\n                count=fact[b1]/ p1*fact[b2]/ p2\n                self.total+=count\n                self.valid+=count*(c1==c2)\n                return\n            for s1 in range(balls[d]+1):\n                s2=balls[d]-s1\n                dfs(d+1,b1+s1,b2+s2,c1+(s1>0),c2+(s2>0),p1*fact[s1],p2*fact[s2])\n        dfs(0,0,0,0,0,1,1)\n        return self.valid/self.total", "import functools as ft\nimport math\nimport operator\n\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = 0\n        self.valid = 0\n        self.balls = balls\n        self.k = len(balls)\n        self.n = sum(balls) // 2\n        self.ball_sums = [sum(balls[index :]) for index in range(self.k + 1)]\n        self.update([], 0, 0)\n        return self.valid / self.total\n    \n    @ft.lru_cache(None)\n    def factorial(self, n: int) -> int:\n        return math.factorial(n)\n    \n    def count(self, balls: List[int]) -> int:\n        return self.factorial(self.n) // ft.reduce(operator.mul, map(self.factorial, balls))\n    \n    def update(self, left_balls: List[int], total: int, delta: int) -> None:\n        if len(left_balls) == self.k:\n            if total != self.n:\n                return\n            right_balls = [total_cnt - left_cnt for left_cnt, total_cnt in zip(left_balls, self.balls)]\n            count = self.count(left_balls) * self.count(right_balls)\n            self.total += count\n            if delta == 0:\n                self.valid += count\n            return\n        index = len(left_balls)\n        if total + self.ball_sums[index] < self.n:\n            return\n        if total > self.n:\n            return\n        if index == self.k - 1:\n            new_delta = delta + (self.n - total == self.balls[index]) - (self.n - total == 0)\n            self.update(left_balls + [self.n - total], self.n, new_delta)\n            return\n        for cnt in range(self.balls[index] + 1):\n            new_delta = delta + (cnt == self.balls[index]) - (cnt == 0)\n            self.update(left_balls + [cnt], total + cnt, new_delta)", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        '''\n        \u7bb1\u5b50\u4e2d\u6709n\u4e2a\u7403\uff0c\u7bb1\u4e2d\u67092\u79cd\u989c\u8272\u7684\u7403\uff0c\u5206\u522b\u6709k1,k2\u4e2a\n        \u7bb1\u5b50\u4e2d\u7684\u7ec4\u5408\u6570\u4e3an!/k1!k2!\n        '''\n        n=sum(balls)  #\u603b\u7403\u6570\n        k=len(balls)  #\u7403\u8272\u6570\n        self.total=self.valid=0\n        fact=[1]*50   #\u5f97\u5230\u6bcf\u4e2a\u6570\u7684\u9636\u4e58\n        for i in range(1,50):\n            fact[i]=fact[i-1]*i\n        #d: depth\n        #b1, b2: # of balls in box1, box2\n        #c1,c2 :\u4e24\u4e2abox\u4e2d\u4e0d\u540c\u8272\u7684\u7403\u6570\n        #p1, p2: # permutations of duplicate balls in box1, box2\n        def dfs(d,b1,b2,c1,c2,p1,p2):\n            if b1>n//2 or b2>n//2:\n                return\n            if d==k:\n                count=math.factorial(b1)/ p1 * math.factorial(b2)/ p2\n                self.total+=count\n                self.valid+=count*(c1==c2)\n                return\n            for s1 in range(balls[d]+1):\n                s2=balls[d]-s1\n                dfs(d+1,b1+s1,b2+s2,c1+(s1>0),c2+(s2>0),p1*math.factorial(s1),p2*math.factorial(s2))\n        dfs(0,0,0,0,0,1,1)\n        return self.valid/self.total", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        \n        total = sum(balls)\n        k = len(balls)\n        \n        def theSame(added):\n            res = 0\n            for i in range(k):\n                if added[i] == 0:\n                    res -= 1\n                elif balls[i] == added[i]:\n                    res += 1\n            return res == 0\n        \n        \n        def combination(this, pick):\n            pick = min(this-pick, pick)\n            res = 1\n            i = this\n            j = 1\n            while i > pick:\n                res *= i\n                res /= j\n                i -= 1\n                j += 1\n            return res\n            \n        def helper(i, added, cur):\n            \n            if cur == total // 2:\n               \n                if theSame(added):\n                    res = 1\n                    for i in range(k):\n                        res *= combination(balls[i], added[i])\n                    return res\n                return 0\n            if i == k:\n                return 0\n            if cur > total // 2:\n                return 0\n            res = 0\n            for t in range(balls[i]+1):\n                added[i] = t\n                res += helper(i+1, added, cur+t) \n            added[i] = 0\n            return res\n        \n        added = [0] * k \n        return helper(0, added, 0) / combination(total, total // 2)\n        \n        \n            \n                          \n                           \n                        \n                \n                    \n        \n                \n                \n        \n        \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def calc(d):\n            n = len(d)\n            s = sum(d.values())\n            result = math.factorial(s)\n            for k, v in list(d.items()):\n                result /= math.factorial(v)\n            return result\n        \n        t, e = 0, 0\n        def choose(i, k, d1, d2):\n            nonlocal t\n            nonlocal e\n            if k == 0 and i <= n:\n                for j in range(i, n):\n                    d2[j] = balls[j]\n                t_ = calc(d1) * calc(d2)\n                t += t_\n                e += t_ if len(d1) == len(d2) else 0\n                return \n            if k < 0 or i == n:\n                return\n            for j in range(balls[i] + 1):\n                if k - j < 0:\n                    break\n                if j > 0:\n                    d1[i] = j\n                if balls[i] - j > 0:\n                    d2[i] = balls[i] - j\n                else:\n                    d2.pop(i)\n                choose(i + 1, k - j, d1, d2)\n            if i in d1:\n                d1.pop(i)\n            if i in d2:\n                d2.pop(i)\n        \n        n = len(balls)\n        k = sum(balls) // 2\n        choose(0, k, {}, {})\n        # print(t, e)\n        return e / t\n            \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def calc(d):\n            n = len(d)\n            s = sum(d.values())\n            result = math.factorial(s)\n            facs = {}\n            for k, v in list(d.items()):\n                result /= math.factorial(v)\n            return result\n        \n        t, e = 0, 0\n        def choose(i, k, d1, d2):\n            nonlocal t\n            nonlocal e\n            if k == 0 and i <= n:\n                for j in range(i, n):\n                    d2[j] = balls[j]\n                t_ = calc(d1) * calc(d2)\n                t += t_\n                e += t_ if len(d1) == len(d2) else 0\n                return \n            if k < 0 or i == n:\n                return\n            for j in range(balls[i] + 1):\n                if k - j < 0:\n                    break\n                if j > 0:\n                    d1[i] = j\n                if balls[i] - j > 0:\n                    d2[i] = balls[i] - j\n                else:\n                    d2.pop(i)\n                choose(i + 1, k - j, d1, d2)\n            if i in d1:\n                d1.pop(i)\n            if i in d2:\n                d2.pop(i)\n        \n        n = len(balls)\n        k = sum(balls) // 2\n        choose(0, k, {}, {})\n        # print(t, e)\n        return e / t\n            \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def C(n, m):\n            c = 1\n            for i in range(n, n - m, -1):\n                c *= i\n            return c / math.factorial(m)\n        \n        t, e = 0, 0\n        def choose(i, k, d1, d2):\n            nonlocal t, e\n            if k == 0 and i <= n:\n                for j in range(i, n):\n                    d2[j] = balls[j]\n                t_ = 1\n                for k, v in list(d1.items()):\n                    t_ *= C(balls[k], v)\n                t += t_\n                e += t_ if len(d1) == len(d2) else 0\n                return \n            if k < 0 or i == n:\n                return\n            for j in range(balls[i] + 1):\n                if k - j < 0:\n                    break\n                if j > 0:\n                    d1[i] = j\n                if balls[i] - j > 0:\n                    d2[i] = balls[i] - j\n                else:\n                    d2.pop(i)\n                choose(i + 1, k - j, d1, d2)\n            if i in d1:\n                d1.pop(i)\n            if i in d2:\n                d2.pop(i)\n        \n        n = len(balls)\n        k = sum(balls)\n        choose(0, k // 2, {}, {})\n        # print(t, e)\n        return e / t\n            \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        balls_flattened = []\n        for i, count in enumerate(balls):\n            balls_flattened.extend([i] * count)\n        \n        def has_same_distinct_color(perm):\n            n = len(perm)\n            return len(set(perm[: n // 2])) == len(set(perm[n // 2 :]))\n        \n        total = [0]\n        same_distinct_color = [0]\n        def get_perm(cur, balls):\n            if not balls:\n                total[0] += 1\n                same_distinct_color[0] += has_same_distinct_color(cur)\n                return\n            for i in range(len(balls)):\n                if i > 0 and balls[i] == balls[i - 1]:\n                    continue\n                get_perm(cur + [balls[i]], balls[:i] + balls[i + 1 :])\n        \n        get_perm([], balls_flattened)\n        return same_distinct_color[0] / total[0]\n    \n\n    def getProbability(self, balls: List[int]) -> float:\n        \n        factorial_cache = [1]\n        for i in range(1, sum(balls) + 1):\n            factorial_cache.append(factorial_cache[-1] * i)\n                \n        def get_perm_count(arr):\n            total = factorial_cache[sum(arr)]\n            for a in arr:\n                total //= factorial_cache[a]\n            return total\n        \n        total_perms = get_perm_count(balls)\n        valid_perms = [0]\n        \n        def find_valid_split(n, start, distinct1, group1, distinct2, group2):\n            if n == 0:\n                if distinct1 == distinct2:\n                    valid_perms[0] += get_perm_count(group1) * get_perm_count(group2)\n                return\n            \n            for i in range(start, len(group1)):\n                if group1[i] == 0:\n                    continue\n                \n                new_num1 = group1[i] - 1\n                new_distinct1 = distinct1 if new_num1 > 0 else distinct1 - 1\n                new_num2 = group2[i] + 1\n                new_distinct2 = distinct2 if new_num2 > 1 else distinct2 + 1\n                if new_distinct1 < new_distinct2:\n                    continue\n                    \n                new_group1 = group1[:i] + [new_num1] + group1[i + 1 :]\n                new_group2 = group2[:i] + [new_num2] + group2[i + 1 :]\n                find_valid_split(n - 1, i, new_distinct1, new_group1, new_distinct2, new_group2)\n        \n        find_valid_split(sum(balls) // 2, 0, len(balls), balls, 0, [0] * len(balls))\n        return valid_perms[0] / total_perms\n                \n\n                \n                \n                \n", "import math\nfrom functools import lru_cache\nfrom typing import List\n\nclass Solution:\n  def getProbability(self, balls: List[int]) -> float:\n    M = len(balls)\n    N = sum(balls)\n    F = [math.factorial(n) for n in range(N // 2 + 1)]\n\n    s1 = [0] * M\n    s2 = [0] * M\n\n    def find(i):\n      if i == M:\n        if sum(s1) == sum(s2) and len([n for n in s1 if n]) == len([n for n in s2 if n]):\n          base1 = F[N // 2] // math.prod(F[n] for n in s1)\n          base2 = F[N // 2] // math.prod(F[n] for n in s2)\n          return base1 * base2\n        return 0\n\n      s = 0\n      for n in range(balls[i] + 1):\n        s1[i] = n\n        s2[i] = balls[i] - n\n        s += find(i + 1)\n      return s\n\n    base = math.factorial(N) // math.prod(math.factorial(n) for n in balls)\n    return find(0) / base", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        M = len(balls)\n        N = sum(balls)\n        F = [math.factorial(n) for n in range(N// 2 + 1)]\n        s1 = [0] * M\n        s2 = [0] * M\n        \n        def find(i):\n            if i == M:\n                if sum(s1) == sum(s2) and len([n for n in s1 if n]) == len([n for n in s2 if n]):\n                    base1 = F[N//2] // math.prod(F[n] for n in s1)\n                    base2 = F[N//2] // math.prod(F[n] for n in s2)\n                    return base1 * base2\n                return 0\n            \n            s = 0\n            for n in range(balls[i] + 1):\n                s1[i] = n\n                s2[i] = balls[i] - n\n                s += find(i + 1)\n            return s\n    \n        base = math.factorial(N) // math.prod(math.factorial(n) for n in balls)\n        return find(0) / base", "class Solution:\n    # Brute force: check all permutations\n    # O(n! / (ball_count! ^ k)) time, O(n) space \n    def getProbability(self, balls: List[int]) -> float:\n        balls_flattened = []\n        for i, count in enumerate(balls):\n            balls_flattened.extend([i] * count)\n        \n        def has_same_distinct_color(perm):\n            n = len(perm)\n            return len(set(perm[: n // 2])) == len(set(perm[n // 2 :]))\n        \n        total = [0]\n        same_distinct_color = [0]\n        def get_perm(cur, balls):\n            if not balls:\n                total[0] += 1\n                same_distinct_color[0] += has_same_distinct_color(cur)\n                return\n            for i in range(len(balls)):\n                if i > 0 and balls[i] == balls[i - 1]:\n                    continue\n                get_perm(cur + [balls[i]], balls[:i] + balls[i + 1 :])\n        \n        get_perm([], balls_flattened)\n        return same_distinct_color[0] / total[0]\n    \n    # Permutations of combinations\n    # O(ball_count ^ k) time (put 0, 1, 2, ..., ball_count balls into box 1, and do it for k colors)\n    # O(k) space for recursion and O(n) space for factorials\n    def getProbability(self, balls: List[int]) -> float:\n        \n        factorial_cache = [1]\n        for i in range(1, sum(balls) + 1):\n            factorial_cache.append(factorial_cache[-1] * i)\n                \n        def get_perm_count(arr):\n            total = factorial_cache[sum(arr)]\n            for a in arr:\n                total //= factorial_cache[a]\n            return total\n        \n        total_perms = get_perm_count(balls)\n        valid_perms = [0]\n        \n        def find_valid_split(n, start, distinct1, group1, distinct2, group2):\n            if n == 0:\n                if distinct1 == distinct2:\n                    valid_perms[0] += get_perm_count(group1) * get_perm_count(group2)\n                return\n            \n            for i in range(start, len(group1)):\n                if group1[i] == 0:\n                    continue\n                \n                new_num1 = group1[i] - 1\n                new_distinct1 = distinct1 if new_num1 > 0 else distinct1 - 1\n                new_num2 = group2[i] + 1\n                new_distinct2 = distinct2 if new_num2 > 1 else distinct2 + 1\n                if new_distinct1 < new_distinct2:\n                    continue\n                    \n                new_group1 = group1[:i] + [new_num1] + group1[i + 1 :]\n                new_group2 = group2[:i] + [new_num2] + group2[i + 1 :]\n                find_valid_split(n - 1, i, new_distinct1, new_group1, new_distinct2, new_group2)\n        \n        find_valid_split(sum(balls) // 2, 0, len(balls), balls, 0, [0] * len(balls))\n        return valid_perms[0] / total_perms\n                \n\n                \n                \n                \n", "class Solution:\n    # Brute force: check all permutations\n    # O(n! / (ball_count! ^ k)) time, O(n) space \n    def getProbability(self, balls: List[int]) -> float:\n        balls_flattened = []\n        for i, count in enumerate(balls):\n            balls_flattened.extend([i] * count)\n        \n        def has_same_distinct_color(perm):\n            n = len(perm)\n            return len(set(perm[: n // 2])) == len(set(perm[n // 2 :]))\n        \n        total = [0]\n        same_distinct_color = [0]\n        def get_perm(cur, balls):\n            if not balls:\n                total[0] += 1\n                same_distinct_color[0] += has_same_distinct_color(cur)\n                return\n            for i in range(len(balls)):\n                if i > 0 and balls[i] == balls[i - 1]:\n                    continue\n                get_perm(cur + [balls[i]], balls[:i] + balls[i + 1 :])\n        \n        get_perm([], balls_flattened)\n        return same_distinct_color[0] / total[0]\n    \n    # Permutations of combinations\n    # O(ball_count ^ k) time (put 0, 1, 2, ..., ball_count balls into box 1, and do it for k colors), O(k) space\n    def getProbability(self, balls: List[int]) -> float:\n        \n        factorial_cache = [1]\n        for i in range(1, sum(balls) + 1):\n            factorial_cache.append(factorial_cache[-1] * i)\n                \n        def get_perm_count(arr):\n            total = factorial_cache[sum(arr)]\n            for a in arr:\n                total //= factorial_cache[a]\n            return total\n        \n        total_perms = get_perm_count(balls)\n        valid_perms = [0]\n        \n        def find_valid_split(n, start, distinct1, group1, distinct2, group2):\n            if n == 0:\n                if distinct1 == distinct2:\n                    valid_perms[0] += get_perm_count(group1) * get_perm_count(group2)\n                return\n            \n            for i in range(start, len(group1)):\n                if group1[i] == 0:\n                    continue\n                \n                new_num1 = group1[i] - 1\n                new_distinct1 = distinct1 if new_num1 > 0 else distinct1 - 1\n                new_num2 = group2[i] + 1\n                new_distinct2 = distinct2 if new_num2 > 1 else distinct2 + 1\n                if new_distinct1 < new_distinct2:\n                    continue\n                    \n                new_group1 = group1[:i] + [new_num1] + group1[i + 1 :]\n                new_group2 = group2[:i] + [new_num2] + group2[i + 1 :]\n                find_valid_split(n - 1, i, new_distinct1, new_group1, new_distinct2, new_group2)\n        \n        find_valid_split(sum(balls) // 2, 0, len(balls), balls, 0, [0] * len(balls))\n        return valid_perms[0] / total_perms\n                \n\n                \n                \n                \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def calc(d):\n            n = len(d)\n            s = sum(d.values())\n            result = math.factorial(s)\n            for k, v in list(d.items()):\n                result /= math.factorial(v)\n            return result\n        \n        def choose(i, k, d1, d2):\n            if k == 0 and i <= n:\n                for j in range(i, n):\n                    d2[j] = balls[j]\n                t = calc(d1) * calc(d2)\n                e = t if len(d1) == len(d2) else 0\n                return t, e \n            if k < 0 or i == n:\n                return 0, 0\n            t, e = 0, 0\n            for j in range(balls[i] + 1):\n                if j > 0:\n                    d1[i] = j\n                if balls[i] - j > 0:\n                    d2[i] = balls[i] - j\n                else:\n                    d2.pop(i)\n                a, b = choose(i + 1, k - j, d1, d2)\n                t += a\n                e += b\n            if i in d1:\n                d1.pop(i)\n            if i in d2:\n                d2.pop(i)\n            return t, e\n        \n        n = len(balls)\n        k = sum(balls) // 2\n        t, e = choose(0, k, {}, {})\n        # print(t, e)\n        return e / t\n            \n", "from functools import lru_cache\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.n = sum(balls) // 2\n        self.balls = balls\n        return self.dfs(0, 0, 0, 0, 0)\n        \n    def com(self, n, m):\n        ans = 1\n        for i in range(n-m+1, n+1):\n            ans *= i\n        for i in range(1, m+1):\n            ans //= i\n        return ans\n        \n    @lru_cache(None)\n    def dfs(self, left, right, i, ul, ur):\n        if i == len(self.balls):\n            return float(ul == ur)\n        p = 0\n        for l in range(self.balls[i]+1):\n            r = self.balls[i] - l\n            if left+l > self.n or r+right > self.n:\n                continue\n            p += self.com(self.n-left, l) * self.com(self.n-right, r) / self.com(2*self.n-left-right, self.balls[i]) * self.dfs(left+l, right+r, i+1, ul+(l>0), ur+(r>0))\n        return p", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        M = len(balls)\n        N = sum(balls)\n        F = [math.factorial(n) for n in range(N // 2 + 1)]\n        # every box has at least N // 2 distinct colors, and has at most N distinct colors\n        \n        s1 = [0] * M\n        s2 = [0] * M\n        \n        def find(i):\n            if i == M:\n                if sum(s1) == sum(s2) and len([n for n in s1 if n]) == len([n for n in s2 if n]):\n                    # print(s1, s2)\n                    base1 = F[N // 2]\n                    for n in s1:\n                        base1 //= F[n]\n                    base2 = F[N // 2]\n                    for n in s2:\n                        base2 //= F[n]\n                    self.ans += base1 * base2\n                return\n            \n            for n in range(balls[i]+1):\n                s1[i] = n\n                s2[i] = balls[i] - n\n                find(i+1)\n                \n        self.ans = 0\n        find(0)\n        \n        base = math.factorial(N)\n        for n in balls:\n            base //= math.factorial(n)\n        \n        return self.ans / base", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        M = len(balls)\n        N = sum(balls)\n        F = [math.factorial(n) for n in range(N // 2 + 1)]\n        \n        s1 = [0] * M\n        s2 = [0] * M\n        \n        def find(i):\n            if i == M:\n                if sum(s1) == sum(s2) and len([n for n in s1 if n]) == len([n for n in s2 if n]):\n                    base1 = F[N // 2] // math.prod(F[n] for n in s1)\n                    base2 = F[N // 2] // math.prod(F[n] for n in s2)\n                    return base1 * base2\n                return 0\n            \n            s = 0\n            for n in range(balls[i]+1):\n                s1[i] = n\n                s2[i] = balls[i] - n\n                s += find(i+1)\n            return s\n                \n        base = math.factorial(N) // math.prod(math.factorial(n) for n in balls)\n        return find(0) / base", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        from math import factorial as f\n        n = len(balls)\n        first = [0]*n\n        second = [0]*n\n        self.ans = 0\n        def dfs(i):\n            if i == n:\n                if sum(first) != sum(second):\n                    return \n                if len([x for x in first if x != 0]) != len([x for x in second if x != 0]):\n                    return\n                \n                ret = f(sum(first)) * f(sum(second))\n                for num in first:\n                    if num != 0:\n                        ret /= f(num)\n                for num in second:\n                    if num != 0:\n                        ret /= f(num)\n                self.ans += ret\n                return\n                \n                \n            else:\n                for num in range(0, balls[i]+1):\n                    first[i] = num\n                    second[i] = balls[i]-num\n                    dfs(i+1)\n        dfs(0)\n        \n        total = f(sum(balls))\n        for num in balls:\n            total /= f(num)\n        return self.ans/total\n                \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.n = len(balls)\n        self.mem = {0: 1}\n        self.mem2 = {}\n        self.balls = balls\n        rv = self.dfs(0, [], [])\n        #print(self.mem2, self.mem)\n        return rv / self.multinomial(balls)\n        \n        \n    def dfs(self, idx, lefts, rights):\n        if idx >= self.n:\n            if not lefts or not rights:\n                return 0\n            if len(lefts) != len(rights):\n                return 0\n            if sum(lefts) != sum(rights):\n                return 0\n            return self.multinomial(lefts)*self.multinomial(rights)\n        \n        rv = 0\n        for i in range(0, self.balls[idx]+1):\n            x1 = i\n            x2 = self.balls[idx] - x1\n            if x1 == 0:\n                rights.append(x2)\n                rv += self.dfs(idx+1, lefts, rights)\n                rights.pop()\n            elif x2 == 0:\n                lefts.append(x1)\n                rv += self.dfs(idx+1, lefts, rights)\n                lefts.pop()\n            else:\n                lefts.append(x1)\n                rights.append(x2)\n                rv += self.dfs(idx+1, lefts, rights)\n                rights.pop()\n                lefts.pop()\n        return rv\n\n        \n    def multinomial(self, arr):\n        if not arr:\n            return 0\n        arr = arr[:]\n        arr.sort()\n        key = tuple(arr)\n        if key in self.mem2:\n            return self.mem2[key]\n        \n        res = self.frac(sum(arr))\n        for x in arr:\n            res //= self.frac(x)\n        self.mem2[key] = res\n        return res\n\n    \n    def frac(self, x):\n        if x in self.mem:\n            return self.mem[x]\n        rv =  x * self.frac(x-1)\n        self.mem[x] = rv\n        return rv", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        k, n = len(balls), sum(balls)\n        \n        total = 2 * math.comb(n, n//2)\n        def shuffle(color, box1, box2):\n            if color == k:\n                if sum(box1) == sum(box2) and  box1.count(0) == box2.count(0):\n                    #print(f'{box1} {box2}')\n                    ans = 0\n                    for box in [box1, box2]:\n                        p = 1\n                        for c, num in enumerate(box):\n                            p *= math.comb(balls[c], num)\n                        ans += p\n                    return ans\n                else:\n                    return 0\n            # track all possible\n            total_p = 0\n            bc = balls[color]\n            for b in range(0, bc + 1):\n                box1[color], box2[color] = b, bc - b\n                total_p += shuffle(color + 1, box1, box2)\n                box1[color], box2[color] = 0, 0\n            return total_p\n                \n        p = shuffle(0, [ 0 ] * k, [ 0 ] * k)\n        return p / total\n                \n            \n            \n                \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        \n        \n        total = sum(balls)\n        def factorial(n):\n            if n == 0:\n                return 1\n            if n < 3:\n                return n\n            return n * factorial(n-1)\n        \n        self.match = 0\n        self.total = 0\n        def helper(p, left1, left2, cnt1, cnt2, per1, per2):\n            if left1 == 0 and left2 == 0:\n                self.total += per1 * per2\n                self.match += per1 * per2 * (cnt1 == cnt2)\n            elif left1 >= 0 and left2 >= 0:\n                for k in range(balls[p]+1):\n                    helper(p+1, left1 - k, left2 - balls[p] + k, cnt1 + (k > 0), cnt2 + (balls[p]-k > 0), per1 / factorial(k), per2/factorial(balls[p]-k))\n        \n        helper(0, total // 2, total //2, 0, 0, factorial(total//2), factorial(total//2))\n        # print(self.match)\n        # print(self.total)\n        return self.match/self.total\n                \n        \n        \n#         Track how many balls are left to fill each box as cnt1 and cnt2.\n# Count different colors in each box as col1 and col2; compare in the end.\n# The initial/maximum number of permutatons in each box is (n / 2)!\n# When selecting m balls of particular color, we reduce the number of permutations by m! if the color is the same, no difference, just like [1, 1 / 2, 3] and [1, 1 / 2, 3]. Even we change the position of the two 1, it makes no difference. However, the order of 2, and 3 matters.\n# When both cnt1 and cnt2 are zero, prm1 and prm2 are permutations in each box.\n# - Number of permutations = (n / 2)! / (m1! * m2! * ... * mk!).\n# - The total number of permutations with two boxes is prm1 * prm2.\n        \n    \n    \n#         total = sum(balls)\n#         k = len(balls)\n        \n#         def theSame(added):\n#             res = 0\n#             for i in range(k):\n#                 if added[i] == 0:\n#                     res -= 1\n#                 elif balls[i] == added[i]:\n#                     res += 1\n#             return res == 0\n        \n        \n#         def combination(this, pick):\n#             pick = min(this-pick, pick)\n#             res = 1\n#             i = this\n#             j = 1\n#             while i > pick:\n#                 res *= i\n#                 res /= j\n#                 i -= 1\n#                 j += 1\n#             return res\n            \n#         def helper(i, added, cur):\n            \n#             if cur == total // 2:\n               \n#                 if theSame(added):\n#                     res = 1\n#                     for i in range(k):\n#                         res *= combination(balls[i], added[i])\n#                     return res\n#                 return 0\n#             if i == k:\n#                 return 0\n#             if cur > total // 2:\n#                 return 0\n#             res = 0\n#             for t in range(balls[i]+1):\n#                 added[i] = t\n#                 res += helper(i+1, added, cur+t) \n#             added[i] = 0\n#             return res\n        \n#         added = [0] * k \n#         return helper(0, added, 0) / combination(total, total // 2)\n        \n        \n            \n                          \n                           \n                        \n                \n                    \n        \n                \n                \n        \n        \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        from scipy.special import comb # help to calculate combination numbers\n        \n        sm = sum(balls)\n        number_of_combinations = comb(sm, sm//2) # \n        \n        def number_of_ways_to_pick(n): # there are n balls of color-a, we want to pick some number of them and put them into boxA, and others into boxB\n            d = Counter() # key: number of balls put into boxA, value: number of such combinations\n            for i in range(n+1):\n                d[i] = comb(n,i)\n            return d\n            \n        status = Counter()\n        status[(0,0,0,0)] = 1 \n        #key: num of balls in boxA, num of balls in boxB, different colors in boxA, different colors in boxB; value: number of such combinations\n        for n in balls:\n            combs = number_of_ways_to_pick(n)\n            new_s = Counter()\n            for k in status:\n                a,b,ca,cb = k\n                for n_a in combs:\n                    if n_a == 0:\n                        new_s[(a,b+n,ca,cb+1)] += status[k] * combs[n_a]\n                    elif n_a == n:\n                        new_s[(a+n,b,ca+1,cb)] += status[k] * combs[n_a]\n                    else:\n                        new_s[(a+n_a, b+n-n_a, ca, cb)] += status[k] * combs[n_a]\n            status = new_s\n        \n        res = 0\n        for k in status:\n            a,b,ca,cb = k\n            if a==b and ca==cb:\n                res += status[k]\n            \n        return res/number_of_combinations\n", "from math import factorial\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        # number of distinct arrangements where some balls are identical\n        # fact(sum(balls)) / fact(balls[0]) * fact(balls[1]) * .. * fact(balls[n - 1])\n\n        n = len(balls)\n        a = [0] * n\n        b = balls[:]\n\n        def perm(xs):\n            # result = 1\n            # j = 1\n            # for i in range(n):\n            #     for k in range(1, xs[i] + 1):\n            #         result = result * j / k\n            #         j += 1\n\n            # return result\n\n            result = factorial(sum(xs))\n            for x in xs:\n                result = result / factorial(x)\n            return result\n\n        t = sum(balls) // 2\n        def dfs(a, b, i, sa, sb):\n            if sa > t:\n                return 0\n\n            if i == n:\n                if sa != sb:\n                    return 0\n\n                ca = sum([1 for x in a if x > 0])\n                cb = sum([1 for y in b if y > 0])\n                return perm(a) * perm(b) if ca == cb else 0\n\n            result = 0\n            for j in range(b[i] + 1):\n                a[i] += j\n                b[i] -= j\n                result += dfs(a, b, i + 1, sa + j, sb - j)\n                a[i] -= j\n                b[i] += j\n\n            return result\n\n\n        splits = dfs(a, b, 0, 0, sum(b))\n        return round(splits / perm(balls), 5)\n\n\n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        firsthalf, secondhalf = [0]*len(balls),[0]*len(balls)\n        self.good, self.all = 0,0\n        \n        @lru_cache(None)\n        def fac(n):\n            if n==0:\n                return 1\n            return n*fac(n-1)\n        \n        def permutation(arr):\n            prod = 1\n            for v in arr:\n                prod*=fac(v)\n            return fac(sum(arr))/prod\n        def dfs(i):\n            if i == len(balls):\n                if sum(firsthalf)!=sum(secondhalf):\n                    return \n                p1,p2 = permutation(firsthalf),permutation(secondhalf)\n                self.all+=p1*p2\n                self.good +=p1*p2 if sum(v>0 for v in firsthalf)==sum(v>0 for v in secondhalf) else 0\n            else:\n                for j in range(balls[i]+1):\n                    firsthalf[i],secondhalf[i]=j, balls[i]-j\n                    dfs(i+1)\n        dfs(0)\n        return self.good/self.all", "class Solution(object):\n    def __init__(self):\n        self.fact = [1, 1, 2, 6, 24, 120, 720]\n        self.total = 0.0\n        self.match = 0.0\n\n    def dfs(self, balls, i=0, n=0, c=0, w=1.0):\n        if i == len(balls):\n            self.total += w * (n == 0)\n            self.match += w * (n == 0) * (c == 0)\n            return\n        for b1, b2 in zip(range(balls[i] + 1), reversed(range(balls[i] + 1))):\n            self.dfs(\n                balls,\n                i + 1,\n                n + b1 - b2,\n                c + (b2 == 0) - (b1 == 0),\n                w / self.fact[b1] / self.fact[b2])\n\n    def getProbability(self, balls):\n        self.dfs(balls)\n        return self.match / self.total", "from math import factorial\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        # number of distinct arrangements where some balls are identical\n        # fact(sum(balls)) / fact(balls[0]) * fact(balls[1]) * .. * fact(balls[n - 1])\n\n        n = len(balls)\n        a = [0] * n\n        b = balls[:]\n\n        def perm(xs):\n            result = 1\n            j = 1\n            for i in range(n):\n                for k in range(1, xs[i] + 1):\n                    result = result * j / k\n                    j += 1\n            return result\n\n        t = sum(balls) // 2\n        def dfs(a, b, i, sa, sb):\n            if sa > t:\n                return 0\n\n            if i == n:\n                if sa != sb:\n                    return 0\n\n                ca = sum([1 for x in a if x > 0])\n                cb = sum([1 for y in b if y > 0])\n                return perm(a) * perm(b) if ca == cb else 0\n\n            result = 0\n            for j in range(b[i] + 1):\n                a[i] += j\n                b[i] -= j\n                result += dfs(a, b, i + 1, sa + j, sb - j)\n                a[i] -= j\n                b[i] += j\n\n            return result\n\n\n        splits = dfs(a, b, 0, 0, sum(b))\n        return round(splits / perm(balls), 5)\n\n\n", "import math\nclass Solution:\n    def getProbability(self, balls):\n        k=len(balls)\n        first=[0 for _ in range(k)]\n        second = [0 for _ in range(k)]\n        \n        factorial_memo={}\n        self.valid=0\n        self.successful=0\n        def getFactorial(v):\n            if v not in factorial_memo:\n                factorial_memo[v]=math.factorial(v)\n                \n            return factorial_memo[v]\n        def getPermutation(lst):\n            prod=1\n            for i in lst:\n                prod*=getFactorial(i)\n            return getFactorial(sum(lst))/prod\n        #start putting one color into two boxes\n        def dfs(i):\n            \n            if i == k:\n                if sum(first)!=sum(second):\n                    return\n                self.valid+=getPermutation(first)*getPermutation(second)\n                if sum([v>0 for v in first]) == sum([v>0 for v in second]):\n                    self.successful+=getPermutation(first)*getPermutation(second)\n            else:\n                for n in range(balls[i]+1):\n                    first[i]=n\n                    second[i]=balls[i]-n\n                    dfs(i+1)\n        dfs(0)\n        return self.successful/self.valid\n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n    \n    \n", "import math\nclass Solution:\n    def getProbability(self, balls):\n        k=len(balls)\n        first=[0 for _ in range(k)]\n        second = [0 for _ in range(k)]\n        \n        factorial_memo={}\n        valid=0\n        successful=0\n        def getFactorial(v):\n            if v not in factorial_memo:\n                factorial_memo[v]=math.factorial(v)\n                \n            return factorial_memo[v]\n        def getPermutation(lst):\n            sum1=0\n            for i in lst:\n                sum1+=getFactorial(i)\n            return getFactorial(sum(lst))/sum1\n        #start putting one color into two boxes\n        def dfs(i):\n            \n            if i == k:\n                if sum(first)!=sum(second):\n                    return\n                valid+=getPermutation(first)*getPermutation(second)\n                if sum([v>0 for v in getPermutation(first)]) == sum([v>0 for v in getPermutation(second)]):\n                    successful+=getPermutation(first)*getPermutation(second)\n            else:\n                for n in range(balls[i]+1):\n                    first[i]=n\n                    second[i]=balls[i]-n\n                    dfs(i+1)\n                    \n\n        dfs(0)\n        return successful/valid\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n    \n    \n    \n    \n    def getProbability(self, balls: List[int]) -> float:\n        firstHalf, secondHalf = [0 for _ in range(len(balls))], [0 for _ in range(len(balls))]\n        self.good, self.all = 0, 0\n\n        mem_factorial = {}\n        def factorial(v):   # e.g., given v = 3, compute 3! = 3*2*1\n            if v not in mem_factorial:\n                mem_factorial[v] = math.factorial(v)\n            return mem_factorial[v]\n\n        def permutation(arr):  # e.g., given arr=[1,1,2,3],compute the number of all distinct permutations, such as `1123`, `1132`..\n            prod = 1\n            for v in arr:\n                prod *= factorial(v)\n            return factorial(sum(arr)) / prod\n\n        def dfs(i):\n            if i == len(balls):\n                if sum(firstHalf) != sum(secondHalf):\n                    return\n                p1, p2 = permutation(firstHalf), permutation(secondHalf)\n                self.all += p1 * p2\n                self.good += p1 * p2 if sum(v > 0 for v in firstHalf) == sum(v > 0 for v in secondHalf) else 0\n            else:\n                for j in range(balls[i]+1):\n                    firstHalf[i], secondHalf[i] = j, balls[i]-j\n                    dfs(i+1)\n                    firstHalf[i], secondHalf[i] = 0, 0\n        dfs(0)\n        return self.good / self.all", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        firstHalf, secondHalf = [0 for _ in range(len(balls))], [0 for _ in range(len(balls))]\n        self.good, self.all = 0, 0\n\n        mem_factorial = {}\n        def factorial(v):   # e.g., given v = 3, compute 3! = 3*2*1\n            if v not in mem_factorial:\n                mem_factorial[v] = v * factorial(v - 1) if v != 0 else 1\n            return mem_factorial[v]\n\n        def permutation(arr):  # e.g., given arr=[1,1,2,3],compute the number of all distinct permutations, such as `1123`, `1132`..\n            prod = 1\n            for v in arr:\n                prod *= factorial(v)\n            return factorial(sum(arr)) / prod\n\n        def dfs(i):\n            if i == len(balls):\n                if sum(firstHalf) != sum(secondHalf):\n                    return\n                p1, p2 = permutation(firstHalf), permutation(secondHalf)\n                self.all += p1 * p2\n                self.good += p1 * p2 if sum(v > 0 for v in firstHalf) == sum(v > 0 for v in secondHalf) else 0\n            else:\n                for j in range(balls[i]+1):\n                    firstHalf[i], secondHalf[i] = j, balls[i]-j\n                    dfs(i+1)\n                    firstHalf[i], secondHalf[i] = 0, 0\n        dfs(0)\n        return self.good / self.all", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def calc(d):\n            n = len(d)\n            s = sum(d.values())\n            result = 1\n            facs = []\n            for k, v in list(d.items()):\n                facs.append(math.factorial(v))\n            facs.sort()\n            for i in range(2, s + 1):\n                result *= i\n                if facs and result > facs[-1]:\n                    f = facs.pop()\n                    result /= f\n            for f in facs:\n                result /= f\n            return result\n        \n        t, e = 0, 0\n        def choose(i, k, d1, d2):\n            nonlocal t\n            nonlocal e\n            if k == 0 and i <= n:\n                for j in range(i, n):\n                    d2[j] = balls[j]\n                t_ = calc(d1) * calc(d2)\n                t += t_\n                e += t_ if len(d1) == len(d2) else 0\n                return \n            if k < 0 or i == n:\n                return\n            for j in range(balls[i] + 1):\n                if k - j < 0:\n                    break\n                if j > 0:\n                    d1[i] = j\n                if balls[i] - j > 0:\n                    d2[i] = balls[i] - j\n                else:\n                    d2.pop(i)\n                choose(i + 1, k - j, d1, d2)\n            if i in d1:\n                d1.pop(i)\n            if i in d2:\n                d2.pop(i)\n        \n        n = len(balls)\n        k = sum(balls) // 2\n        choose(0, k, {}, {})\n        # print(t, e)\n        return e / t\n            \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def factorial(k):\n            if k <= 1:\n                return 1\n            return factorial(k-1) * k\n        \n        def calc(balls):\n            bs = [b for b in balls if b > 0]\n            ans = factorial(sum(bs))\n            for b in bs:\n                ans /= factorial(b)\n            return ans\n            \n       \n        sols = []\n        n = sum(balls)//2\n        def generate(sol, s, i):\n            nonlocal sols\n            if s > n:\n                return\n            \n            if i == len(balls):\n                if s == n:\n                    sols += [sol]\n                return\n                \n            for j in range(0,balls[i]+1):\n                generate(sol + [j], s+j, i+1)\n        generate([], 0, 0)\n        \n        count = 0\n        for sol in sols:\n            l1 = sol\n            l2 = [y-x for x,y in zip(l1,balls)]\n            l1 = [num for num in l1 if num > 0]\n            l2 = [num for num in l2 if num > 0]\n            \n            if len(l1) == len(l2):\n                count += calc(l1) * calc(l2)\n                \n        return count / calc(balls)", "# Sep 8, 2020\n# Copied from\n# https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/661723/Struggling-with-probability-problems-Read-this./561118\n# The idea:\n# A permutation is valid if the number of colors in box A is the same as box B.\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        firstHalf, secondHalf = [0 for _ in range(len(balls))], [0 for _ in range(len(balls))]\n\n        valid_permutations = 0\n        all_permutations = 0\n\n        # e.g., given v = 3, compute 3! = 3*2*1\n        mem_factorial = {}\n\n        def factorial(v):\n            if v not in mem_factorial:\n                mem_factorial[v] = v * factorial(v - 1) if v != 0 else 1\n            return mem_factorial[v]\n\n        # e.g., given arr=[1,1,2,3],compute the number of all distinct permutations, such as `1123`, `1132`..\n        def permutation(arr):\n            prod = 1\n            for v in arr:\n                prod *= factorial(v)\n            return factorial(sum(arr)) / prod\n\n        def dfs(i):\n            if i == len(balls):\n                if sum(firstHalf) != sum(secondHalf):\n                    return\n                p1, p2 = permutation(firstHalf), permutation(secondHalf)\n\n                nonlocal valid_permutations, all_permutations\n                all_permutations += p1 * p2\n                valid_permutations += p1 * p2 if sum(v > 0 for v in firstHalf) == sum(v > 0 for v in secondHalf) else 0\n            else:\n                for j in range(balls[i] + 1):\n                    firstHalf[i], secondHalf[i] = j, balls[i] - j\n                    dfs(i + 1)\n                firstHalf[i], secondHalf[i] = 0, 0\n\n        dfs(0)\n        return valid_permutations / all_permutations", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def factorial(k):\n            if k <= 1:\n                return 1\n            return factorial(k-1) * k\n        \n        def calc(balls):\n            bs = [b for b in balls if b > 0]\n            ans = factorial(sum(bs))\n            for b in bs:\n                ans /= factorial(b)\n            return ans\n            \n       \n        sols = []\n        n = sum(balls)//2\n        def generate(sol, s, i):\n            nonlocal sols\n            if s > n:\n                return\n            \n            if i == len(balls):\n                if s == n:\n                    sols += [sol]\n                return\n                \n            for j in range(0,balls[i]+1):\n                generate(sol + [j], s+j, i+1)\n        generate([], 0, 0)\n        \n        count = 0\n        memo = {}\n        for sol in sols:\n            l1 = sol\n            l2 = [y-x for x,y in zip(l1,balls)]\n            l1 = sorted([num for num in l1 if num > 0])\n            l2 = sorted([num for num in l2 if num > 0])\n            if len(l1) == len(l2):\n                l = tuple(l1 + l2)\n                if l not in memo:\n                    memo[l] = calc(l1) * calc(l2)\n                count += calc(l1) * calc(l2)\n                \n        return count / calc(balls)", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        first, second = [0 for _ in range(len(balls))], [0 for _ in range(len(balls))]\n        \n        ret = []\n        total = []\n        self.good = 0\n        self.all = 0\n        mem_factorial = {}\n        def factorial(v):   # e.g., given v = 3, compute 3! = 3*2*1\n            if v not in mem_factorial:\n                mem_factorial[v] = v * factorial(v - 1) if v != 0 else 1\n            return mem_factorial[v]\n\n        def permutation(arr):  # e.g., given arr=[1,1,2,3],compute the number of all distinct permutations, such as `1123`, `1132`..\n            prod = 1\n            for v in arr:\n                prod *= factorial(v)\n            return factorial(sum(arr)) / prod\n        \n        def dfs(i):\n            if i == len(balls):\n                if sum(first) != sum(second):\n                    return\n                p1, p2 = permutation(first), permutation(second)\n                self.all += p1 * p2\n                if sum(v > 0 for v in first) == sum(v > 0 for v in second):\n                    self.good += p1 * p2\n                return\n            for j in range(balls[i]+1):\n                first[i], second[i] = j, balls[i] - j\n                dfs(i+1)\n                first[i], second[i] = 0, 0\n            \n        dfs(0)\n        return self.good/self.all\n\n        \n        \n        \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        first, second = [0 for _ in range(len(balls))], [0 for _ in range(len(balls))]\n        \n        ret = []\n        total = []\n        self.good = 0\n        self.all = 0\n        mem_factorial = {}\n        def factorial(v):   # e.g., given v = 3, compute 3! = 3*2*1\n            if v not in mem_factorial:\n                mem_factorial[v] = v * factorial(v - 1) if v != 0 else 1\n            return mem_factorial[v]\n\n        def permutation(arr):  # e.g., given arr=[1,1,2,3],compute the number of all distinct permutations, such as `1123`, `1132`..\n            prod = 1\n            for v in arr:\n                prod *= factorial(v)\n            return factorial(sum(arr)) / prod\n        \n        def dfs(i):\n            \n            if i == len(balls):\n                if sum(first) != sum(second):\n                    return\n                #total.append((list(first), list(second)))\n                p1, p2 = permutation(first), permutation(second)\n                #print(p1)\n                #print(p2)\n                self.all += p1 * p2\n                if sum(v > 0 for v in first) == sum(v > 0 for v in second):\n                    self.good += p1 * p2\n                return\n            for j in range(balls[i]+1):\n                first[i], second[i] = j, balls[i] - j\n                dfs(i+1)\n                first[i], second[i] = 0, 0\n            \n        dfs(0)\n        return self.good/self.all\n\n        \n        \n        \n        \n", "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        total = 0\n        valid = 0\n        \n        @lru_cache(None)\n        def getFactor(i):\n            ans = 1\n            for i in range(2, i + 1):\n                ans *= i\n            return ans\n        \n        def getComb(nums):\n            a = getFactor(sum(nums.values()))\n            duplicate = 1\n            for val in nums.values():\n                duplicate *= getFactor(val)\n            return a // duplicate\n            \n        \n        def dfs(i, a, b):\n            nonlocal total\n            nonlocal valid\n            if i == len(balls):\n                if sum(a.values()) != sum(b.values()):\n                    return\n                p1, p2 = getComb(a), getComb(b)\n                # print(a, b)\n                # print(p1, p2)\n                total += p1 * p2\n                \n                if len(a) == len(b):\n                    valid += p1 * p2\n            else:\n                for j in range(balls[i] + 1):\n                    a[i] = j\n                    b[i] = balls[i] - j\n                    if a[i] == 0:\n                        del a[i]\n                    if b[i] == 0:\n                        del b[i]\n                    dfs(i + 1, a, b)         \n                    \n        dfs(0, {}, {})\n        return valid / total", "import functools as ft\nimport math\nimport operator\n\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        self.total = 0\n        self.valid = 0\n        self.balls = balls\n        self.k = len(balls)\n        self.n = sum(balls) // 2\n        self.update([])\n        return self.valid / self.total\n    \n    @ft.lru_cache(None)\n    def combination(self, n: int, p: int) -> int:\n        return ft.reduce(operator.mul, range(n, n - p, -1), 1) // math.factorial(p)\n    \n    def count(self, balls: List[int]) -> int:\n        ans = 1\n        remaining = self.n\n        for ball in balls:\n            ans *= self.combination(remaining, ball)\n            remaining -= ball\n        return ans\n    \n    def update(self, left_balls: List[int]) -> None:\n        if len(left_balls) == self.k:\n            if sum(left_balls) != self.n:\n                return\n            right_balls = [total_cnt - left_cnt for left_cnt, total_cnt in zip(left_balls, self.balls)]\n            count = self.count(left_balls) * self.count(right_balls)\n            self.total += count\n            if sum(left_cnt == 0 for left_cnt in left_balls) == sum(right_cnt == 0 for right_cnt in right_balls):\n                self.valid += count\n            return\n        index = len(left_balls)\n        left_total = sum(left_balls)\n        if left_total + sum(self.balls[index :]) < self.n:\n            return\n        if left_total > self.n:\n            return\n        for cnt in range(self.balls[index] + 1):\n            self.update(left_balls + [cnt])"]
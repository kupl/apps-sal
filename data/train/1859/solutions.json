["class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if not matrix[i][j]:\n                    continue\n                if matrix[i][j-1] and matrix[i-1][j] and matrix[i-1][j-1]:\n                    matrix[i][j] = min(matrix[i][j-1], matrix[i-1][j], matrix[i-1][j-1]) + 1\n        \n        total = 0\n        for row in matrix:\n            total += sum(row)\n            \n        return total\n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp=matrix\n        r = len(dp)\n        c = len(dp[0])\n        ans=0\n        for i in range(1,r):\n            for j in range(1,c):\n                if(dp[i][j]==0):\n                    continue\n                if(dp[i-1][j]!=0 and dp[i-1][j-1]!=0 and dp[i][j-1]!=0):\n                    dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1\n        for i in dp:\n            ans+=sum(i)\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        res=0\n        dp=matrix\n        r=len(dp)\n        c=len(dp[0])\n                  \n        for i in range(1,r):\n            for j in range(1,c):\n                if dp[i][j]==0:\n                    continue\n                if dp[i-1][j]!=0 and dp[i-1][j-1]!=0 and dp[i][j-1]!=0:\n                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1\n        for i in dp:\n            res+=sum(i)\n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        count = 0\n        size = 1\n        maxSize = min(len(matrix), len(matrix[0]))\n        prevInd = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 1:\n                    count += 1\n                    prevInd.append([i, j])\n        while size <= maxSize and prevInd:\n            newInd = []\n            for ind in prevInd:\n                row = ind[0]\n                col = ind[1]\n                add = True\n                if row + size < len(matrix) and col + size < len(matrix[0]) :\n                    for r in range(row, row + size + 1):\n                        if not matrix[r][col + size]:\n                            add = False\n                            break\n                    for c in range(col, col + size + 1):\n                        if not matrix[row + size][c]:\n                            add = False\n                            break\n                    if add:\n                        count += 1\n                        newInd.append([row, col])\n            prevInd = newInd\n            size += 1\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        res = 0\n        n = len(matrix); m = len(matrix[0]) if matrix else 0\n        for r in range(n):\n            for c in range(m):\n                if matrix[r][c] == 0: continue\n                if r == 0 or c == 0: res += 1; continue\n                matrix[r][c] = min(matrix[r-1][c-1], matrix[r][c-1], matrix[r-1][c]) + 1\n                res += matrix[r][c]\n        return res\n", "class Solution:\n    def validate_sub_matrix(self, matrix, rstart, cstart, size):\n        for row in range(size + 1):\n            for col in range(size + 1):\n                if matrix[rstart + row][cstart + col] == 0:\n                    return False\n        return True\n                \n    def countSquares(self, matrix: List[List[int]]) -> int:\n        count = 0\n        num_rows = len(matrix)\n        num_cols = len(matrix[0])\n        for row in range(num_rows):\n            for col in range(num_cols):\n                if matrix[row][col] == 0:\n                    continue\n                    \n                s_size = 0\n                while row + s_size < num_rows and col + s_size < num_cols and self.validate_sub_matrix(matrix, row, col, s_size):\n                    #print ((row, col, s_size))\n                    count += 1\n                    s_size += 1\n        return count\n                \n                \n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        M = len(matrix)\n        N = len(matrix[0])\n        \n        ans = 0\n        for i in range(M):\n            for j in range(N):\n                if matrix[i][j] == 1 and i>0 and j>0:\n                    cand = min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1])\n                    matrix[i][j] = (cand + 1)\n                ans += matrix[i][j]\n        return ans", "class Solution:\n    #iterate over every square and then fan out to n x n matrices and increment if all 1\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        ret = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                if matrix[row][col] == 1:\n                    sublen = 1\n                    while row + sublen <= len(matrix) and col + sublen <= len(matrix[0]) and 0 not in [matrix[row+sublen-1][ncol] for ncol in range(col, col+sublen)] and 0 not in [matrix[nrow][col+sublen-1] for nrow in range(row, row+sublen)]:\n                        ret += 1\n                        sublen += 1\n        return ret\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0: continue\n                if i == 0 or j == 0:\n                    res += matrix[i][j]\n                else:\n                    matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1])+1\n                    res += matrix[i][j]\n        return res\n        \n\\\"\\\"\\\"\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        res = 0\n        for i in range(0,len(matrix)):\n            for j in range(0,len(matrix[0])):\n                if matrix[i][j] == 0: continue\n                if i == 0 or j == 0:\n                    res += matrix[i][j]\n                    continue\n                matrix[i][j] = min(matrix[i-1][j-1],matrix[i][j-1],matrix[i-1][j]) + 1\n                #maxS = max(maxS, matrix[i][j])\n                res += matrix[i][j]\n                #print('res:',res)\n        '''\n        res = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                for z in range(maxS):\n                    if matrix[i][j] > z: res += 1\n        '''\n        print(matrix)\n        return res\n\\\"\\\"\\\"\n                \n        ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        res = 0\n        n, m = len(matrix), len(matrix[0])\n        for r in range(n):\n            for c in range(m):\n                if matrix[r][c] == 0: continue\n                if r == 0 or c == 0: res += 1; continue\n                matrix[r][c] = min(matrix[r-1][c-1], matrix[r][c-1], matrix[r-1][c]) + 1\n                res += matrix[r][c]\n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        # for each item we count how many squares there are such that this item is\n        # the bottom right point in the square.\n        # this is equivalent to \\\"what is the largest square containing this item as\n        # its bottom right point\\\"\n        # so we calculate for each item what is the largest square that contains him as the bottom right\n        # point, and then sum the results\n\n        # we calculate this using dynamic programming\n        # for the first row and column, the answer is already there\n        total = sum(matrix[0])\n\n        for i in range(1, len(matrix)):\n            total += matrix[i][0]\n            for j in range(1, len(matrix[i])):\n                if matrix[i][j] == 0:\n                    continue\n                matrix[i][j] = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\n                total += matrix[i][j]\n\n        return total", "class Solution:\n    def countSquares(self, a: List[List[int]]) -> int:\n        d=[]\n        r=len(a)+1\n        c=len(a[0])+1\n        d=[[0 for j in range(c)] for i in range(r)]\n        for i in range(1,r):\n            for j in range(1,c):\n                if(a[i-1][j-1]==1):\n                    d[i][j]=1+min(d[i-1][j],d[i][j-1],d[i-1][j-1])\n        print(d)\n        return sum(map(sum,d))\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n=len(matrix),len(matrix[0])\n        res=0\n       \n        for r in range(m):\n            for c in range(n):\n                if matrix[r][c]==0:\n                    continue\n                if r==0 or c==0:\n                    res+=1\n                else:                \n                    cell_val = min(matrix[r-1][c-1], matrix[r][c-1], matrix[r-1][c]) + matrix[r][c]\n                    res += cell_val\n                    matrix[r][c] = cell_val \n              \n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        for i in range(1,len(matrix)):\n            for j in range(1,len(matrix[0])):\n                if matrix[i][j]==1:\n                    matrix[i][j] = min(matrix[i-1][j],matrix[i][j-1],matrix[i-1][j-1])+1\n        return sum(sum(i) for i in matrix)", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        ans = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                temp = matrix[row][col]\n                ans += matrix[row][col]\n                if(row > 0):\n                    matrix[row][col] += matrix[row-1][col]\n                if(col > 0):\n                    matrix[row][col] += matrix[row][col-1]\n                if(row > 0 and col > 0):\n                    matrix[row][col] -= matrix[row-1][col-1]\n                if not temp: continue\n                side = 1\n                while(row-side >= 0 and col-side >= 0):\n                    s = matrix[row][col]\n                    if(col-side > 0):\n                        s -= matrix[row][col-side-1]\n                    if(row-side > 0):\n                        s -= matrix[row-side-1][col]\n                    if(col-side > 0 and row-side > 0):\n                        s += matrix[row-side-1][col-side-1]\n                    if(s == (side+1)*(side+1)):\n                        ans += 1\n                    else:\n                        break\n                    side += 1\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n = len(matrix), len(matrix[0])\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        result = 0\n        \n        for i in range(m):\n            for j in range(n):\n                dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1] - dp[i][j] + matrix[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                for l in range(1,min(m-i,n-j)+1):\n                    expected_sum = l**2\n                    x,y = i+l, j+l\n                    range_sum = dp[x][y] - dp[x][j] - dp[i][y] + dp[i][j]\n                    # print(i,j,l,x,y)\n                    # print(expected_sum, range_sum)\n                    if expected_sum != range_sum:\n                        break\n                    result += 1\n                        \n        return result", "class Solution:\n    def memoization(self, grid, i, j, memo):\n        if i == len(grid)-1 or j == len(grid[0])-1:\n            return int(grid[i][j] == 1)\n        if memo[i][j] is None:\n            if grid[i][j] == 0:\n                memo[i][j] = 0\n            else:\n                col = self.memoization(grid, i, j+1, memo)\n                row = self.memoization(grid, i+1, j, memo)\n                diag = self.memoization(grid, i+1, j+1, memo)\n                memo[i][j] = min(min(col, row), diag) + 1\n        return memo[i][j]\n                \n    def countSquares(self, matrix: List[List[int]]) -> int:\n        memo = [[None for j in range(len(matrix[0]))] for i in range(len(matrix))]\n        out = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                out += self.memoization(matrix, i, j, memo)\n        return out", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        matrix_sum = [ [0]*(n+1) for _ in range(m+1) ]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                matrix_sum[i][j] = matrix_sum[i][j-1] + matrix[i-1][j-1]\n        \n        for j in range(1, n+1):\n            for i in range(1, m+1):\n                matrix_sum[i][j] = matrix_sum[i][j] + matrix_sum[i-1][j]\n        \n        cnt = 0\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                size = 1\n                while size <= min(i,j):\n                    total = matrix_sum[i][j] + matrix_sum[i-size][j-size] - matrix_sum[i-size][j]\\\\\n                    - matrix_sum[i][j-size]\n                    if total == size*size:\n                        cnt += 1\n                    else:\n                        break\n                    size += 1\n        \n        return cnt\n        \n        ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        ans = 0\n        topleft = [0 for i in matrix[0]]\n        totop = [0 for i in matrix[0]]\n        for i in range(len(matrix)):\n            toleft, nextarea = 0, [0 for i in range(len(matrix[0])+1)]\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 1:\n                    totop[j] += 1\n                    toleft += 1\n                    maxr = min(totop[j], toleft, topleft[j] + 1)\n                    nextarea[j + 1] = maxr\n                    ans += maxr\n                else:\n                    totop[j] = 0\n                    toleft = 0\n                    nextarea[j + 1] = 0\n            topleft = nextarea\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    dp[i+1][j+1] = min(dp[i][j+1], min(dp[i+1][j], dp[i][j])) + 1\n        \n        cnts = [0 for _ in range(min(m, n) + 1)]\n        for i in range(1, min(m, n) + 1):\n            cnts[i] = i ** 2 + cnts[i-1]\n        \n        res = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                res += dp[i][j]\n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        totalRows = len(matrix)\n        totalColumns = len(matrix[0])\n        longestStreak = [[(0,0,0) for i in range(totalColumns)] for j in range(totalRows)]\n        total = 0\n        for i in range(totalRows):\n            for j in range(totalColumns):\n                if(i == 0 and j == 0):\n                    longestStreak[i][j] = (matrix[i][j],matrix[i][j],matrix[i][j])\n                    total += matrix[i][j]\n                else:\n                    if(i == 0):\n                        longestStreak[i][j] = (matrix[i][j]*(longestStreak[i][j-1][0]+1),matrix[i][j],matrix[i][j])\n                        total += matrix[i][j]\n                    elif(j == 0):\n                        longestStreak[i][j] = (matrix[i][j],matrix[i][j]*(longestStreak[i-1][j][1]+1),matrix[i][j])\n                        total += matrix[i][j]\n                    else:\n                        a = matrix[i][j]*(longestStreak[i][j-1][0]+1)\n                        b = matrix[i][j]*(longestStreak[i-1][j][1]+1)\n                        c = matrix[i][j]*(longestStreak[i-1][j-1][2]+1)\n                        longestStreak[i][j] = (a,b,min([a,b,c]))\n                        total += min([a,b,c])\n        return total", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def is_ones(lst, n, i, j):\n            ones = 0\n            for ix in range(i, i + n):\n                for jy in range(j, j + n):\n                    if lst[ix][jy] == 1:\n                        ones += 1\n            return ones == n*n\n        \n        n = len(matrix)\n        m = len(matrix[0])\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 1:\n                    tmp = 1\n                    while (i + tmp <= n) and (j + tmp <= m):\n                        if is_ones(matrix, tmp, i, j):\n                            ans += 1\n                            tmp += 1\n                        else:\n                            break\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        ans=0\n        n=len(matrix)\n        m=len(matrix[0])\n        pre=[[0 for i in range(m+1)] for j in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if matrix[i-1][j-1]==1:\n                    ans+=1\n                pre[i][j]=matrix[i-1][j-1]\n                if i-1>=0:\n                    pre[i][j]+=pre[i-1][j]\n                if j-1>=0:\n                    pre[i][j]+=pre[i][j-1]\n                if i-1>=0 and j-1>=0:\n                    pre[i][j]-=pre[i-1][j-1]\n                c=2\n                while i-c>=0 and j-c>=0:\n                    if pre[i][j]-pre[i][j-c]-pre[i-c][j]+pre[i-c][j-c]==c**2:\n                        ans+=1\n                    else:\n                        break\n                    c+=1\n        return ans\n", "from itertools import accumulate\nfrom typing import List\n\ndef transpose(m):\n    return list(map(list, zip(*m)))\n\ndef prefix_sums(m):\n    return [list(accumulate(r)) for r in m]\n\n\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n\n        bsums = transpose(prefix_sums(transpose(prefix_sums(matrix))))\n        squares = 0\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                k = 0\n                while i + k < m and j + k < n:\n                    s = bsums[i+k][j+k]\n                    if i > 0: s -= bsums[i -1][j + k]\n                    if j > 0: s -= bsums[i + k][j - 1]\n                    if i > 0 and j > 0: s += bsums[i - 1][j - 1]\n                    if s == (k + 1) ** 2:\n                        squares += 1\n                    else:\n                        break\n                    k += 1\n        return squares", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        row, col = len(matrix), len(matrix[0])\n        res = 0\n        #if \n        \n        for r in range(row):\n            for c in range(col):\n                if matrix[r][c] == 1:\n                    if r==0 or c==0:\n                        res+=1\n                    else:\n                        val= min(matrix[r-1][c],matrix[r][c-1],matrix[r-1][c-1])+matrix[r][c]\n                        res+=val\n                        matrix[r][c]=val\n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def countHelper(r: int, c: int, size: int = 0) -> int:\n            if r + size >= rMax or c + size >= cMax:\n                return 0\n            \n            rowOnes = rSums[r + size][c + size]\n            if c > 0:\n                rowOnes -= rSums[r + size][c - 1]\n            colOnes = cSums[c + size][r + size]\n            if r > 0:\n                colOnes -= cSums[c + size][r - 1]\n\n            return 1 + countHelper(r, c, size + 1) if rowOnes == colOnes == size + 1 else 0\n            \n        rMax = len(matrix)\n        cMax = len(matrix[0])\n        \n        rSums = [[0] * cMax for _ in range(rMax)]\n        cSums = [[0] * rMax for _ in range(cMax)]\n        for r, row in enumerate(matrix):\n            for c, sq in enumerate(row):\n                rSums[r][c] = cSums[c][r] = matrix[r][c]\n                if c > 0:\n                    rSums[r][c] += rSums[r][c - 1]\n                if r > 0:\n                    cSums[c][r] += cSums[c][r - 1]\n                    \n        totalSquares = 0\n            \n        for r, row in enumerate(matrix):\n            for c, sq in enumerate(row):\n                if sq == 1:\n                    totalSquares += countHelper(r, c)\n                    \n        return totalSquares\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n        m = len(matrix)\n        n = len(matrix[0])\n        res = 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    dp[i+1][j+1] = min(dp[i+1][j],dp[i][j+1],dp[i][j]) + 1\n                    res += dp[i+1][j+1]\n        return res\n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        memo = {}\n        def recursive(row, col):\n            if 0 <= row < len(matrix) and 0<= col < len(matrix[0]) and matrix[row][col] == 1:\n                nextRow = recursive(row+1, col)\n                nextCol = recursive(row, col+1)\n                nextDiag = recursive(row+1, col+1)\n                return min(nextRow, nextCol, nextDiag) + 1\n            return 0\n        \n        def cached(row, col):\n            pair = (row, col)\n            if pair in memo: return memo[pair]\n            if 0 <= row < len(matrix) and 0 <= col < len(matrix[0]) and matrix[row][col] == 1:\n                nextRow = cached(row+1, col)\n                nextCol = cached(row, col+1)\n                nextDiag = cached(row+1, col+1)\n                memo[pair] = min(nextRow, nextCol, nextDiag)+1\n                return memo[pair]\n            return 0\n            \n        count = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                count += cached(i, j)\n        return count\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        sq = 0\n        m_row = range(len(matrix))\n        m_col = range(len(matrix[0])) \n        \n        def expand_square(row, n, m, p, square=0, count=1):\n            while count > -1:\n                print(count, square)\n                for i in range(count):\n                    if row + i == m:\n                        return square\n                    for j in range(count):\n                        if n + j == p:\n                            return square\n                        elif matrix[row + i][n + j] != 1:\n                            return square                \n                square += 1\n                count += 1\n        \n        for row in m_row:\n            for n in m_col:\n                if matrix[row][n] == 1:\n                    sq += expand_square(row, n, len(matrix), len(matrix[0]))\n\n                                    \n        return sq", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n\n        rownum = len(matrix)\n        if rownum < 1 : return 0\n        colnum = len(matrix[0])\n        if colnum < 1: return 0\n\n        aux3 = defaultdict(lambda : -1)\n        def check(r, c): # (r, c) \ub97c \uae30\uc900\uc73c\ub85c \ud560 \ub54c \uac00\uc7a5 \uae34 \uae38\uc774\ub97c \ubc18\ud658 \n            if r < 0 or r >= rownum or c < 0 or c >= colnum:\n                return 0\n            elif matrix[r][c] == 0:\n                return 0\n            else:\n                if aux3[(r, c)] != -1:\n                    return aux3[(r, c)]\n                else:\n                    c1 = check(r+1, c)                \n                    c2 = check(r, c+1)\n                    c3 = check(r+1, c+1)\n                    aux3[(r, c)] =  min(c1, c2, c3) + 1\n                    return aux3[(r, c)]\n        ret = 0\n        # aux4 =[]\n        for r in range(0, rownum):\n            for c in range(0, colnum):\n                if matrix[r][c] == 1:\n                    max_len = check(r, c)\n                    ret += max_len\n        return ret        ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n, m = len(matrix), len(matrix[0])\n        \n        dp = [matrix[0][j] for j in range(m)]\n        count = sum(dp)\n        \n        for i in range(1, n):\n            new_dp = [matrix[i][j] for j in range(m)]\n            \n            for j in range(1, m):\n                if matrix[i][j] == 1:\n                    new_dp[j] = min(dp[j], new_dp[j-1], dp[j-1]) + 1\n            \n            dp = new_dp\n            count += sum(dp)\n        \n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [0 for i in range(cols + 1)]\n        tot = 0\n        for i in range(rows):\n            for j in range(cols):\n                if not matrix[i][j]:\n                    dp[j + 1] = 0\n                    continue\n                if dp[j + 1] == dp[j]:\n                    dp[j + 1] += 1 if matrix[i - dp[j]][j - dp[j]] else 0 \n                else:    \n                    dp[j + 1] = min(dp[j + 1], dp[j]) + 1\n                tot += dp[j + 1]\n        return tot ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n#         def is_valid_square(start_row, end_row, start_col, end_col, matrix):\n#             for row in range(start_row, end_row + 1):\n#                 for col in range(start_col, end_col + 1):\n#                     if matrix[row][col] != 1:\n#                         return False\n            \n#             return True  \n        \n        result = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                search_space_increase = 0\n                while row + search_space_increase < len(matrix) and col + search_space_increase < len(matrix[0]):\n                    end_row = row + search_space_increase \n                    end_col = col + search_space_increase\n                    \n                    is_valid = True\n                    for start_row in range(row, end_row + 1):\n                        for start_col in range(col, end_col + 1):\n                            if matrix[start_row][start_col] != 1:\n                                is_valid = False\n                                break\n                        if not is_valid:\n                            break\n                    \n                    if not is_valid:\n                        break\n                        \n                    result += 1\n                    search_space_increase += 1\n                        \n        \n        return result", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n            # If matrix is empty: return 0\n        if not matrix:\n            return 0\n\n        # For every '1' encountered, increment count by 1\n\n        # Count the number of '1s' for each row\n        #    Unsure yet: record start, and stop index\n        \n        count = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                if matrix[row][col] == 1:\n                    if row == 0 or col == 0:\n                        count += 1\n                    else:\n                        cell = min(matrix[row-1][col], matrix[row-1][col-1], matrix[row][col-1]) + matrix[row][col]\n                        count += cell\n                        matrix[row][col] = cell\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        res = 0 \n        for i in range(n):\n            for j in range(m):\n                # count the number of square with left-top corner be res[i][j]\n                done = False\n                new_i = i\n                new_j = j\n                \n                while 0 <= new_i < n and 0 <= new_j < m and not done:\n                    area = 0 \n                    for k in range(i,new_i + 1):\n                        area += matrix[k][new_j]\n                    for k in range(j, new_j + 1):\n                        area += matrix[new_i][k]\n                    area -= matrix[new_i][new_j]\n                        \n                    if area == new_j - j + new_i- i + 1:\n                        res += 1\n                        new_i = new_i + 1\n                        new_j = new_j + 1\n                    else:\n                        done = True\n        return res\n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        Brute force, for each position (i,j) calculate the\n        number of square matrices ending at (i,j) and \n        return the total sum of all numbers for all (i,j).\n        \n        This would cost O(m*n*m*n) time complexity. We can speed\n        this up by taking advantage of the fact that such square\n        submatrices ending at (i,j) must build off of previous\n        submatrices. That is if we know the number of square\n        submatrices of ones at (i-1,j-1), (i,j-1) and (i-1,j)\n        then we can compute the number for (i,j).\n        \n        Concretely, the square[i][j] must equal \n            min(\n                square[i-1][j-1],\n                square[i-1][j],\n                square[i][j-1]\n            ) + 1\n        \n        \\\"\\\"\\\"\n        ans = 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        # Cache the number of square submatrices ending at current coordinate\n        dp = [0] * n\n        for i in range(m):\n            squares_at_ij = 0\n            new_dp = [0] * n\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    squares_at_ij = min(\n                        dp[j], dp[j-1] if j > 0 else 0, squares_at_ij\n                    ) + 1\n                else: \n                    squares_at_ij = 0\n                ans += squares_at_ij\n                new_dp[j] = squares_at_ij\n            dp = new_dp\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        res = 0 \n        for i in range(n):\n            for j in range(m):\n                \n                done = False\n                end_i = i\n                end_j = j\n                \n                while 0 <= end_i < n and 0 <= end_j < m and not done:\n                    #  check the squre of [i, new_i] * [j, new_j]\n                    area = 0 \n                    for k in range(i,end_i + 1):\n                        area += matrix[k][end_j]\n                    for k in range(j, end_j + 1):\n                        area += matrix[end_i][k]\n                    area -= matrix[end_i][end_j]\n                        \n                    if area == end_j - j + end_i- i + 1:\n                        res += 1\n                        end_i += 1\n                        end_j += 1\n                    else:\n                        done = True\n        return res\n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix: return 0\n        m, n = len(matrix), len(matrix[0])\n\n        diag = 0\n        mem = [0 for _ in range(n)]\n\n        res = 0\n        for i in range(n):\n            mem[i] = matrix[0][i]\n            res += mem[i]\n\n        for i in range(1,m):\n            for j in range(n):\n                tmp = mem[j]\n                if matrix[i][j] == 0: mem[j] = 0\n                elif j == 0:\n                    mem[j] = matrix[i][j]\n                    res += mem[j]\n                else:\n                    mem[j] = min(diag, mem[j-1], mem[j])+1\n                    res += mem[j]\n                diag = tmp\n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows = len(matrix)\n        if (rows == 0):\n            return 0\n        \n        cols = len(matrix[0])\n        if (cols == 0):\n            return 0\n        \n        self.res = 0\n        \n        for r in range(rows):\n            for c in range(cols):\n                if (matrix[r][c] == 1):\n                    if (r == 0 or c == 0):\n                        self.res += 1\n                    else:\n                        cell_val = min(matrix[r-1][c-1], matrix[r-1][c], matrix[r][c-1]) + 1\n                        self.res += cell_val\n                        matrix[r][c] = cell_val\n                        \n        return self.res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        res = 0 \n        for i in range(n):\n            for j in range(m):\n                \n                done = False\n                new_i = i\n                new_j = j\n                \n                while 0 <= new_i < n and 0 <= new_j < m and not done:\n                    #  check the squre of [i, new_i] * [j, new_j]\n                    area = 0 \n                    for k in range(i,new_i + 1):\n                        area += matrix[k][new_j]\n                    for k in range(j, new_j + 1):\n                        area += matrix[new_i][k]\n                    area -= matrix[new_i][new_j]\n                        \n                    if area == new_j - j + new_i- i + 1:\n                        res += 1\n                        new_i = new_i + 1\n                        new_j = new_j + 1\n                    else:\n                        done = True\n        return res\n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if matrix is None or len(matrix)==0:\n            return 0\n        r=len(matrix)\n        c=len(matrix[0])\n        res=0\n        for i in range(r):\n            for j in range(c):\n                if(matrix[i][j]==1):\n                    if(i==0 or j==0):\n                        res+=1\n                    else:\n                        k=min(matrix[i-1][j-1],matrix[i-1][j],matrix[i][j-1])+matrix[i][j]\n                        res+=k\n                        matrix[i][j]=k\n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [0 for i in range(cols + 1)]\n        tot = 0\n        for i in range(rows):\n            for j in range(cols):\n                if not matrix[i][j]:\n                    dp[j + 1] = 0\n                    continue\n                length = min(dp[j + 1], dp[j]) \n                dp[j + 1] = length + matrix[i - length][j - length]\n                tot += dp[j + 1]\n        return tot ", "class Solution:\n    def countSquares(self, A: List[List[int]]) -> int:\n            \n        for i in range(1, len(A)):\n            for j in range(1, len(A[0])):\n                A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1\n        return sum(map(sum, A))", "class Solution:\n    class Graph:\n        def __init__(self, g):\n            self.r = len(g)\n            self.c = len(g[0])\n            self.graph = g\n        def isSafe(self, r, c, notvisited):\n            return r >=0 and r<self.r and c>=0, c<self.c and notvisited[r][c] and self.graph[r][c] == 1\n\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        r, c = len(matrix), len(matrix[0])\n        dp = [[0]*(c+1) for _ in range(r+1)]\n        cnt = 0\n        for i in range(r):\n            for j in range(c):\n                if matrix[i][j] == 1:\n                    dp[i+1][j+1] = min(dp[i+1][j], dp[i][j], dp[i][j+1]) + 1\n                    cnt +=dp[i+1][j+1]\n        return cnt\n                \n", "class Solution:\n    def countSquares(self, A):\n        for i in range(1, len(A)):\n            for j in range(1, len(A[0])):\n                A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1\n        return sum(map(sum, A))\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n+1) for _ in range(m+1)] # new int[m+1][n+1];\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j]:\n                    dp[i+1][j+1] = min(dp[i][j+1], dp[i+1][j], dp[i][j]) + 1\n                    ans += dp[i+1][j+1]\n        return ans\n        \n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        count = 0\n        for r in range(rows):\n            for c in range(cols):\n                if matrix[r][c] == 1:\n                    print((r,c))\n                    size =  0\n                    notOne = False\n                    while not notOne and r+size <= rows-1 and c+size <= cols-1:\n                        for p in range(size+1):\n                            if matrix[r+p][c+size] != 1 or matrix[r+size][c+p] != 1:\n                                notOne = True\n                                break\n                        if matrix[r+size][c+size] != 1: notOne = True        \n                        if not notOne: count += 1 \n                        size += 1\n                        print (size)\n                        print(count)\n                    \n        return count\n    \n\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def get(i, j):\n            if i < 0 or j < 0:\n                return 0\n            elif i > len(matrix) or j > len(matrix[0]):\n                return 0\n            \n            return matrix[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] != 1:\n                    continue\n                squares = min(get(i-1, j-1), get(i-1, j), get(i, j-1)) + 1\n                matrix[i][j] = squares\n                count += squares\n                \n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        row, col = len(matrix), len(matrix[0])\n        \n        count = 0\n        for i in range(row):\n            for j in range(col):\n                if(matrix[i][j]):\n                    if(i == 0 or j == 0):\n                        count += 1\n                    else:\n                        check_val = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1])\n                        count += check_val+1\n                        matrix[i][j] = check_val+1\n        \n        return count", "class Solution:\n    def countSquares(self, dp):\n        if len(dp)==0 or len(dp[0])==0:\n            return 0\n        for i,row in enumerate(dp):\n            for j,val in enumerate(row):\n                if val==1:\n                    left=dp[i][j-1] if j>0 else 0\n                    up=dp[i-1][j] if i>0 else 0\n                    diag=dp[i-1][j-1] if i>0 and j>0 else 0\n                    dp[i][j]=min((left,up,diag))+1\n                else:\n                    dp[i][j]=0\n        return sum(map(sum,dp))\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        height, width= len(matrix), len(matrix[0])\n        n = 0\n        \n        def n_squares(x, y):\n            \n            length = 0\n            \n            if not matrix[y][x]:\n                return 0\n            \n            while x + length + 1 <= width  and y + length + 1 <= height:\n                \n                content = [row[x: x + length + 1] for row in matrix[y: y + length + 1]]\n                if not all(i for j in content for i in j):\n                    break\n                    \n                length += 1\n                \n            return length\n        \n        for x in range(width):\n            for y in range(height):\n                n += n_squares(x, y)\n        \n        return n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def do_dfs(r,c):\n            \\\"\\\"\\\"Recursive DFS\\\"\\\"\\\"\n            res = float('inf')\n\n            for move in moves:\n                cand_row = r + move[0]\n                cand_col = c + move[1]\n\n                if check_validity(cand_row, cand_col):\n                    res = min(res, do_dfs(cand_row, cand_col))\n                else:\n                    res = 0\n            res += 1 #The square itself is a one-sided sq because it is 1\n            total_squares[0] += res\n            print (r,c, res)\n            return res\n        \n        def check_validity(r,c):\n            \\\"\\\"\\\"Check if r,c is in-bounds and equal to 1 \\\"\\\"\\\"\n\n            if 0<=r<R and 0<=c<C and matrix[r][c]==1 :\n                return True\n\n            return False\n\n        total_squares = [0]\n\n        if not matrix:\n            return total_squares[0]\n\n        moves = ((0,1),(1,1),(1,0))\n\n        R,C = len(matrix), len(matrix[0])\n\n        for r in range(R):\n            for c in range(C):\n                if check_validity(r,c):\n                    do_dfs(r,c)\n\n        return total_squares[0]\n", "class Solution:\n    def countSquares(self, M: List[List[int]]) -> int:\n        if not M:\n            return 0\n        m,n = len(M), len(M[0])\n        \n        rowCounts = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if M[i][j]:\n                    rowCounts[i][j] = 1+rowCounts[i][j-1] if j>0 else 1\n        \n        colCounts = [[0]*n for _ in range(m)]\n        for j in range(n):\n            for i in range(m):\n                if M[i][j]:\n                    colCounts[i][j]=1+colCounts[i-1][j] if i>0 else 1\n               \n        dp = [[0]*n for _ in range(m)]\n        out=0\n        for i in range(m):\n            for j in range(n):\n                if M[i][j]:\n                    if i==0 or j ==0:\n                        dp[i][j] = min(rowCounts[i][j],colCounts[i][j])\n                    else:\n                        dp[i][j] = min(rowCounts[i][j],colCounts[i][j],1+dp[i-1][j-1])\n                    out+=dp[i][j]\n        return out\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        N = len(matrix)\n        M = len(matrix[0])\n        result = [[0 for j in range(M)] for i in range(N)]\n        ss = 0\n        for i in range(N):\n            for j in range(M):\n                if i == 0 or j == 0:\n                    result[i][j] = matrix[i][j]\n                else:\n                    result[i][j] = matrix[i][j] * (1 + min(\n                            min(result[i-1][j],\n                                result[i][j-1]\n                            ),\n                            result[i-1][j-1],\n                    ))\n                ss += result[i][j]\n        return ss", "class Solution:\n    #iterate over every square and then fan out to n x n matrices and increment if all 1\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        ret = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                if matrix[row][col] == 1:\n                    sublen = 1\n                    check = 1\n                    while check == 1 and row + sublen <= len(matrix) and col + sublen <= len(matrix[0]):\n                        for ncol in range(col, col+sublen):\n                            if matrix[row+sublen-1][ncol] == 0:\n                                check = 0\n                                break\n                        for nrow in range(row, row+sublen):\n                            if matrix[nrow][col+sublen-1] == 0:\n                                check = 0\n                                break\n                        sublen += 1\n                        ret += check\n        return ret\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n\n        squares = 0\n        for i in range(m):\n            for j in range(n):\n                if not matrix[i][j]:\n                    continue\n\n                dp[i][j] = 1\n                if i > 0 and j > 0:\n                    dp[i][j] += min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n                squares += dp[i][j]\n\n        return squares", "from itertools import chain as chain\n\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        for i in range(1,len(matrix)):\n            for j in range(1,len(matrix[0])):\n                if matrix[i][j] == 1:\n                    matrix[i][j] = 1+min(matrix[i-1][j],matrix[i][j-1],matrix[i-1][j-1])\n                else:\n                    matrix[i][j] = 0\n                    \n        return sum(chain(*matrix))", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp=[[0 for _ in range(len(matrix[0]))]for _ in range(len(matrix))]\n        summ=0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i==0 or j==0:\n                    dp[i][j]=matrix[i][j]\n                else:\n                    if matrix[i][j]==0:\n                        dp[i][j]=0\n                    else:\n                        dp[i][j]=1+min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])\n                summ+=dp[i][j]\n        return summ\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n=len(matrix)\n        m=len(matrix[0])\n        a=0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]==1:\n                    if i==0 or j==0:\n                        a+=1\n                    else:\n                        t=min(matrix[i-1][j-1],matrix[i-1][j],matrix[i][j-1])+matrix[i][j]\n                        a+=t\n                        matrix[i][j]=t\n        return a\n                        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n,m = len(matrix), len(matrix[0])\n        for i in range(1,n):\n            for j in range(1,m):\n                if matrix[i][j]:\n                    matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1\n        return sum(sum(x) for x in matrix)", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        # we count for each item, how many squares there are such that this item is \n        # the bottom right point in the square\n        # this is equivalent to what is the largest square containing this item as \n        # its bottom right point\n        # so we calculate for each item what is the largest square that contains him as the bottom right\n        # point, and then sum all the results\n        \n        # we calculate this using dynamic programming\n        # for the first row and column, the answer is already there\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[i])):\n                if matrix[i][j] == 0:\n                    continue\n                matrix[i][j] = min(matrix[i - 1][j], matrix[i][j- 1], matrix[i - 1][j- 1]) + 1\n        \n        total = 0\n        for i in range(0, len(matrix)):\n            for j in range(0, len(matrix[i])):\n                total+= matrix[i][j]\n                \n        return total\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        sqrsCnt = 0\n        for y, row in enumerate(matrix):\n            for x, val in enumerate(row):\n                i, j = x, y\n                while True:\n                    if i < 0 or j < 0: break\n                    if any(matrix[j][a] != 1 for a in range(i,x+1)): break\n                    if any(matrix[b][i] != 1 for b in range(j,y+1)): break\n                    if matrix[j][i] != 1: break\n                    sqrsCnt += 1\n                    i, j = i-1, j-1\n        return sqrsCnt", "from collections import defaultdict\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        num_right = defaultdict(lambda: 0)\n        num_below = defaultdict(lambda: 0)\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in reversed(range(m)):\n            for j in reversed(range(n)):\n                if j+1 < n:\n                    num_right[(i,j)] = num_right[(i, j+1)] + 1 if matrix[i][j+1] == 1 else num_right[(i, j+1)]\n                else:\n                    num_right[(i,j)] = 0\n                if i+1 < m:\n                    num_below[(i,j)] = num_below[(i+1, j)] + 1 if matrix[i+1][j] == 1 else num_below[(i+1, j)]\n                else:\n                    num_below[(i,j)] = 0\n                \n        count = 0\n        partial = defaultdict(lambda: 0)\n        for i in reversed(range(m)):\n            for j in reversed(range(n)):\n                if matrix[i][j] == 0:\n                    continue\n                r = num_right[(i,j)]\n                d = num_below[(i,j)]\n                # print('******************')\n                # print('Index', i,j)\n                # print('Counts', r,d)\n                # print(count)\n                # print(partial)\n                if matrix[i][j] == 1:\n                    partial[(i,j,1)] = 1\n                    count += 1\n                diff = min(r,d)\n                flag = True\n                for k in range(2, diff+2):\n                    #print('Checking k=', k)\n                    if partial[(i, j+1, k-1)] == 1 and partial[(i+1, j+1, k-1)] == 1 and partial[(i+1, j, k-1)] == 1:\n                        partial[(i,j,k)] = 1\n                        count += 1\n                    else:\n                        flag = False\n                    if not flag:\n                        break\n                    \n        #print(count)\n        return count       ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        import copy\n        def grow_sqaure(x, y):\n            oriX = copy.copy(x)\n            oriY = copy.copy(y)\n            still_square = False\n            count = 0\n            if matrix[x][y] == 1:\n                still_square = True\n            while x < len(matrix) and y < len(matrix[0]) and still_square:\n                for i in range(oriX, x+1):\n                    if matrix[i][y] != 1:\n                        return count\n\n                for i in range(oriY, y+1):\n                    if matrix[x][i] != 1:\n                        return count\n                count += 1\n                x += 1\n                y += 1\n            return count\n\n        count = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n\n                count += grow_sqaure(i, j)\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        row = len( matrix)\n        col = len(matrix[0])\n        ret =0\n        \n        for r in range(row):\n            for c in range(col):\n                if matrix[r][c] == 1:\n                    if r == 0 or c == 0: ret += 1\n                    else:\n                        matrix[r][c]= min(matrix[r-1][c-1],matrix[r-1][c],matrix[r][c-1]) + 1\n                        ret += matrix[r][c]\n        return ret", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        import copy\n        def grow_sqaure(x, y):\n            oriX = copy.copy(x)\n            oriY = copy.copy(y)\n            \n            count = 0\n            if matrix[x][y] == 1:\n                still_square = True\n            while x < len(matrix) and y < len(matrix[0]):\n                for i in range(oriX, x+1):\n                    if matrix[i][y] != 1:\n                        return count\n\n                for i in range(oriY, y+1):\n                    if matrix[x][i] != 1:\n                        return count\n                count += 1\n                x += 1\n                y += 1\n            return count\n\n        count = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n\n                count += grow_sqaure(i, j)\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp = [[matrix[i][j] for j in range(len(matrix[0]))] for i in range(len(matrix))]\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    continue\n                if dp[i-1][j] != 0 and dp[i][j-1] != 0 and dp[i-1][j-1] != 0:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1\n        count = 0\n        for row in dp:\n            count += sum(row)\n        return count\n", "# 1277. Count Square Submatrices with All Ones\n\ndef make_partial (m, n, matrix):\n    ans = [[0 for __ in range (n + 1)] for _ in range (m + 1)]\n    for i in range (m + 1):\n        for j in range (n + 1):\n            if i == 0 and j == 0:\n                p = 0\n            else:\n                p = matrix[i-1][j-1] + ans[i-1][j] + ans[i][j-1] - ans[i-1][j-1]\n            ans[i][j] = p\n    return ans\n\ndef get_rect (partial, i0, j0, i1, j1):\n    return partial[i1][j1] + partial[i0][j0] - partial[i0][j1] - partial[i1][j0]\n\ndef count_squares (matrix):\n    m, n = len (matrix), len (matrix[0])\n    partial = make_partial (m, n, matrix)\n\n    ans = 0\n    for i in range (0, m):\n        for j in range (0, n):\n            max_w = min (m - i, n - j)\n            for w in range (1, max_w + 1):\n                if get_rect (partial, i, j, i+w, j+w) == w**2:\n                    ans += 1\n                else:\n                    break\n\n    return ans\n\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        return count_squares(matrix)", "class Solution:\n    def dobra(self,x,i,j,red_matrice):\n        for k in range(i, i+red_matrice):\n            for l in range(j, j+red_matrice):\n                if x[k][l] == 0:\n                    return False\n        return True\n        \n        \n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                for red_matrice in range(1, min(m,n)+1):\n                    if i+red_matrice<=m and j+red_matrice<=n:\n                        if self.dobra(matrix,i,j,red_matrice):\n                            res += 1          \n                        else:\n                            break\n        return res", "import copy\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n      #running sum first\n      matrix2 = copy.deepcopy(matrix)\n      for i in range(len(matrix)):\n        start = matrix[i][0]\n        for j in range(1, len(matrix[0])):\n          start += matrix[i][j]\n          matrix2[i][j] = start\n      for j in range(len(matrix[0])):\n        start = matrix2[0][j]\n        for i in range(1, len(matrix)):\n          start += matrix2[i][j]\n          matrix2[i][j] = start\n      #print (matrix)\n      res = 0\n      row = len(matrix)\n      col = len(matrix[0])\n      for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n          if (matrix[i][j] == 1):\n            possible = min(row - i, col-j)\n            for t in range(possible):\n              length = t+1\n              sums = matrix2[i+t][j+t]\n              if i - 1 >= 0: sums -= matrix2[i-1][j+t]\n              if j - 1 >= 0: sums -= matrix2[i+t][j-1]\n              if j - 1 >= 0 and i - 1 >= 0: sums += matrix2[i-1][j-1]\n              #print (i,j,length,sums,res)\n              if sums == length*length: res += 1\n              else: break\n      return res", "from collections import defaultdict\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        num_right = defaultdict(lambda: 0)\n        num_below = defaultdict(lambda: 0)\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in reversed(range(m)):\n            for j in reversed(range(n)):\n                if j+1 < n:\n                    num_right[(i,j)] = num_right[(i, j+1)] + 1 if matrix[i][j+1] == 1 else num_right[(i, j+1)]\n                else:\n                    num_right[(i,j)] = 0\n                if i+1 < m:\n                    num_below[(i,j)] = num_below[(i+1, j)] + 1 if matrix[i+1][j] == 1 else num_below[(i+1, j)]\n                else:\n                    num_below[(i,j)] = 0\n                \n        count = defaultdict(lambda: 0)\n        partial = defaultdict(lambda: 0)\n        for i in reversed(range(m)):\n            for j in reversed(range(n)):\n                if matrix[i][j] == 0:\n                    continue\n                r = num_right[(i,j)]\n                d = num_below[(i,j)]\n                # print('******************')\n                # print('Index', i,j)\n                # print('Counts', r,d)\n                # print(count)\n                # print(partial)\n                if matrix[i][j] == 1:\n                    partial[(i,j,1)] = 1\n                    count[1] += 1\n                diff = min(r,d)\n                flag = True\n                for k in range(2, diff+2):\n                    #print('Checking k=', k)\n                    if partial[(i, j+1, k-1)] == 1 and partial[(i+1, j+1, k-1)] == 1 and partial[(i+1, j, k-1)] == 1:\n                        partial[(i,j,k)] = 1\n                        count[k] += 1\n                    else:\n                        flag = False\n                    if not flag:\n                        break\n                    \n        #print(count)\n        return sum(count.values())        ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if(len(matrix)>0):\n            t = [[0 for i in range(len(matrix[0])+1)] for j in range(len(matrix)+1)]\n            result = 0\n            for i in range(1,len(matrix)+1):\n                for j in range(1, len(matrix[0])+1):\n                    if(matrix[i-1][j-1] == 0):\n                        t[i][j] == 0\n                    else:\n                        t[i][j] = min(t[i-1][j], t[i][j-1], t[i-1][j-1]) + 1\n                        result += t[i][j]\n            for i in t:\n                print(i)\n            return result\n        else:\n            # print(\\\"Ji\\\")\n            return 0", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        import copy\n        def grow_sqaure(x, y):\n            oriX = copy.copy(x)\n            oriY = copy.copy(y)\n            \n            count = 0\n            if matrix[x][y] == 1:\n                still_square = True\n            while x < len(matrix) and y < len(matrix[0]) :\n                for i in range(oriX, x+1):\n                    if matrix[i][y] != 1:\n                        return count\n\n                for i in range(oriY, y+1):\n                    if matrix[x][i] != 1:\n                        return count\n                count += 1\n                x += 1\n                y += 1\n            return count\n\n        count = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n\n                count += grow_sqaure(i, j)\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        num_squares = 0\n        for y in range(len(matrix)):\n            for x in range(len(matrix[0])):\n                num_squares += squaresAt(x,y, matrix)\n        return num_squares\n    \ndef squaresAt(x: int, y: int, matrix: List[List[int]]) -> int:\n    \n    size = 0\n    \n    while True:\n        \n        if y + size >= len(matrix): break\n        if x + size >= len(matrix[0]): break\n        \n        good_row = checkRow(x, x+size, y+size, matrix)\n        good_col = checkCol(x+size, y, y+size, matrix)\n        \n        if good_row and good_col: size += 1\n        else: break\n            \n    return size\n            \ndef checkRow(x1: int, x2: int, y: int, matrix: List[List[int]]) -> bool:  \n    for x in range(x1, x2+1):\n        if matrix[y][x] == 0: return False\n    return True\n\ndef checkCol(x: int, y1: int, y2: int, matrix: List[List[int]]) -> bool:\n    \n    for y in range(y1, y2+1):\n        if matrix[y][x] == 0: return False\n    return True\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m=len(matrix)\n        n=len(matrix[0])\n        dp=[]\n        for i in range(m):\n            temp=[0]*n\n            dp.append(temp)\n        for j in range(n):\n            if(matrix[0][j]==1):\n                dp[0][j]=1\n        for i in range(1,m,1):\n            if(matrix[i][0]==1):\n                dp[i][0]=1\n        for i in range(1,m,1):\n            for j in range(1,n,1):\n                if(matrix[i][j]==1):\n                    dp[i][j]=min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1\n        ans=0\n        for k in range(m):\n            for l in range(n):\n                ans+=dp[k][l]\n        return ans\n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        res = [[0 for _ in range(1+len(matrix[0]))] for _ in range(1+len(matrix))]\n        s = 0\n        m = 0\n        for i in range(1,len(res)):\n            for j in range(1,len(res[i])):\n                \n                if matrix[i-1][j-1] == 1:\n                    res[i][j] = 1 + min(res[i-1][j],res[i][j-1],res[i-1][j-1])\n                else :\n                    res[i][j] = 0\n                    \n                s+= res[i][j]\n                m = res[i][j] if res[i][j] > m else m\n                    \n        # for x in res:\n        #     print(x)\n        \n        \n        # ########### To Find Max Square Matrix size ################### \n        # print(m)\n        # return m\n            \n        return s\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        M = len(matrix)\n        N = len(matrix[0])\n        \n        ans = 0\n        for i in range(M):\n            for j in range(N):\n                if matrix[i][j] > 0 and i>0 and j>0:\n                    cand = min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1])\n                    matrix[i][j] = (cand + 1)\n                ans += matrix[i][j]\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows=len(matrix)\n        cols=len(matrix[0])\n        res=0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j]:\n                    if i==0 or j==0:\n                        res+=1\n                    else:\n                        temp=min(matrix[i][j-1],matrix[i-1][j-1],matrix[i-1][j])+1\n                        res+=temp\n                        matrix[i][j]=temp\n                        \n        return res\n                    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        answer = 0\n        \n        for r in range(len(matrix)) :\n            for c in range(len(matrix[0])) :\n                if r > 0 and c > 0 and matrix[r][c] > 0 : \n                    matrix[r][c] = min(matrix[r][c-1],matrix[r-1][c],matrix[r-1][c-1]) + 1\n                answer += matrix[r][c]\n            \n        return answer\n                    \n                    \n", "from collections import defaultdict\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        num_right = defaultdict(lambda: 0)\n        num_below = defaultdict(lambda: 0)\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in reversed(range(m)):\n            for j in reversed(range(n)):\n                if j+1 < n:\n                    num_right[(i,j)] = num_right[(i, j+1)] + 1 if matrix[i][j+1] == 1 else num_right[(i, j+1)]\n                else:\n                    num_right[(i,j)] = 0\n                if i+1 < m:\n                    num_below[(i,j)] = num_below[(i+1, j)] + 1 if matrix[i+1][j] == 1 else num_below[(i+1, j)]\n                else:\n                    num_below[(i,j)] = 0\n                \n        count = defaultdict(lambda: 0)\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    continue\n                count[1] += 1\n                r = num_right[(i,j)]\n                d = num_below[(i,j)]\n                # print('******************')\n                # print('Index', i,j)\n                # print('Counts', r,d)\n                # print(count)\n                curr = set()\n                if r == 0 and d == 0:\n                    continue\n                flag = True\n                for k in range(2,min(r,d)+2):\n                    #print('Checking k=',k)\n                    for x in range(i, i+k):\n                        for y in range(j, j+k):\n                            curr.add(matrix[x][y])\n                            if matrix[x][y] == 0:\n                                flag = False\n                            if not flag:\n                                break\n                        if not flag:\n                            break\n                    if 0 not in curr and flag:\n                        count[k] += 1\n                    else:\n                        break\n        print(count)\n        return sum(count.values())        ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix: return 0\n        M, N = len(matrix), len(matrix[0])\n        if M == 1 or N == 1: return 1\n        for m in range(1, M):\n            for n in range(1, N):\n                if matrix[m][n] == 1:\n                    if matrix[m-1][n] == matrix[m][n-1] == matrix[m-1][n-1]:\n                        matrix[m][n] = matrix[m-1][n-1] + 1\n                    else:\n                        matrix[m][n] = max(min(matrix[m-1][n], matrix[m][n-1], matrix[m-1][n-1])+1, matrix[m][n]);\n                \n        return sum(sum(matrix, []))\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        import copy\n        def grow_sqaure(x, y):\n            oriX = copy.copy(x)\n            oriY = copy.copy(y)\n            still_square = False\n            count = 0\n            if matrix[x][y] == 1:\n                still_square = True\n            while x < len(matrix) and y < len(matrix[0]) and still_square:\n                for i in range(oriX, x+1):\n                    for j in range(oriY, y+1):\n                        # print(oriX,oriY, x, y)\n                        if matrix[i][j] != 1:\n                            still_square = False\n                            return count\n                count += 1\n                # print(oriX,oriY,x, y, \\\"this was a square\\\")\n                x += 1\n                y += 1\n            return count\n\n        count = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n\n                count += grow_sqaure(i, j)\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        # For every possible size (min(height, length))\n            # For every location of a 1\n                # Check if all 1's (if the remaining array sizes are valid i.e i + size < len(matrix) and j + size < len(matrix[0]))\n                \n                # On the next size check, only continue if the previous step found at least 4. \n        # Error Checking\n        if matrix is None or len(matrix) == 0 or len(matrix[0]) == 0:\n            return 0\n        \n        # General Case\n        height = len(matrix)\n        length = len(matrix[0])\n        one_locations, square_submatrices = self.get_one_locations(matrix)\n        \n        current_count = 0\n        for size in range(2, min(height, length) + 1):\n            if size != 2 and current_count < 4:\n                return square_submatrices\n            \n            # Reset the count\n            current_count = 0\n            \n            for location in one_locations:\n                # Check if it can even be valid before searching\n                h = location[0]\n                l = location[1]\n\n                if (h + size - 1) < len(matrix) and (l + size - 1) < len(matrix[0]):\n                    if self.check_all_ones(matrix, h, l, size):\n                        current_count += 1    \n                        \n            square_submatrices += current_count\n                \n        return square_submatrices\n                \n    def check_all_ones(self, matrix, height, length, square_size):\n        for i in range(height, height + square_size):\n            for j in range(length, length + square_size):\n                if matrix[i][j] != 1:\n                    return False\n                \n        return True\n                \n    def get_one_locations(self, matrix):\n        one_locations = set()\n        one_count = 0\n        \n        for i, j in enumerate(matrix):\n            for m, n in enumerate(matrix[i]):\n                if n == 1:\n                    one_locations.add((i,m))\n                    one_count += 1\n                    \n        return one_locations, one_count\n\n                \n                \n                \n                \n                \n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        nrows = len(matrix)\n        ncols = len(matrix[0])\n        mainDict = {\\\"numBelow\\\":0,\\\"numRight\\\":0}\n        test = [[None for i in range(ncols)] for j in range(nrows)]\n        for r in reversed(range(nrows)):\n            for c in reversed(range(ncols)):\n                if r == nrows-1 and c== ncols-1:\n                    if matrix[r][c]:\n                        temp = {\\\"numBelow\\\":1,\\\"numRight\\\":1}\n                        test[r][c] = temp\n                    else:\n                        test[r][c] = mainDict\n                    continue\n                elif r == nrows-1:\n                    if matrix[r][c]:\n                        numRight = test[r][c+1][\\\"numRight\\\"]+1\n                        temp = {\\\"numBelow\\\":1,\\\"numRight\\\":numRight}\n                        test[r][c] = temp\n                    else:\n                        test[r][c] = mainDict\n                    continue\n                elif c == ncols-1:\n                    if matrix[r][c]:\n                        numBelow = test[r+1][c][\\\"numBelow\\\"]+1\n                        temp = {\\\"numBelow\\\":numBelow,\\\"numRight\\\":1}\n                        test[r][c] = temp\n                    else:\n                        test[r][c] = mainDict\n                else:\n                    if matrix[r][c]:\n                        currNumRight = test[r][c+1][\\\"numRight\\\"]+1\n                        numBelow = test[r+1][c][\\\"numBelow\\\"]+1\n                        temp = {\\\"numBelow\\\":numBelow,\\\"numRight\\\":currNumRight}\n                        test[r][c] = temp\n                    else:\n                        test[r][c] = mainDict\n        \n        count = 0\n        for r in range(nrows):\n            for c in range(ncols):\n                if matrix[r][c]:\n                    print(r,c)\n                    numRight = test[r][c][\\\"numRight\\\"]\n                    numBelow = test[r][c][\\\"numBelow\\\"]\n                    minCount = min(numRight,numBelow)\n                    \n                    temp = 0\n                    for i in reversed(range(minCount)):\n                        check = True\n                        for j in range(i+1):\n                            if test[r+j][c][\\\"numRight\\\"]>=(i+1):\n                                continue\n                            else:\n                                check = False\n                                break\n                        if check:\n                            break\n                    if (i+1)>1:\n                        count+=(i+1)\n                    else:\n                        count+=1\n                    \n                    \n        return count                \n#[\n# [0,1,1,1],\n# [1,1,0,1],\n# [1,1,1,1],\n# [1,0,1,0]]", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        hori = [row[:] for row in matrix]\n        vert = [row[:] for row in matrix]\n        R = len(matrix)\n        C = len(matrix[0])\n        for i in range(R):\n            s = 0\n            for j in range(C):\n                if matrix[i][j]:\n                    s += matrix[i][j]\n                else:\n                    s = 0\n                hori[i][j] = s\n        for j in range(C):\n            s = 0\n            for i in range(R):\n                if matrix[i][j]:\n                    s += matrix[i][j]\n                else:\n                    s = 0\n                vert[i][j] = s\n        out = 0\n        #print(hori)\n        #print(vert)\n        for i in range(R):\n            for j in range(C):\n                if matrix[i][j] == 1:\n                    if i-1<0 or j-1<0:\n                        out+=1\n                        continue\n                    if matrix[i-1][j-1] == 0:\n                        out +=1\n                        continue\n                    x = int(matrix[i-1][j-1]**0.5)\n                    a = min([x, hori[i][j-1], vert[i-1][j]])\n                    out += a+1\n                    #print(i,j, out)\n                    matrix[i][j] = (a+1)**2\n        #print(matrix)\n        return out", "class Solution:\n    def gs(self,matrix,x,y,i,j):\n        ans = matrix[i][j]\n        if y:\n            ans -= matrix[i][y-1]\n        if x:\n            ans -= matrix[x-1][j]\n        if x and y:\n            ans += matrix[x-1][y-1]\n        return ans\n    \n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n:int  = len(matrix)\n        m = 0\n        m = len(matrix[0])\n        for i in range(n):\n            pre = 0\n            for j in range(m):\n                matrix[i][j] += pre\n                pre = matrix[i][j]\n        for i in range(1,n):\n            for j in range(m):\n                matrix[i][j] += matrix[i-1][j]\n            # print(matrix[i])\n        ans = 0\n        for i in range(n):\n            for j in range(m):\n                x,y = i,j\n                l = 1\n                while x >= 0 and y >=0:\n                    # print(x,y,i,j,self.gs(matrix,x,y,i,j))\n                    if l*l == self.gs(matrix,x,y,i,j):\n                        ans+=1\n                    else:\n                        break\n                    x,y,l = x-1,y-1,l+1\n        return ans\n", "from collections import defaultdict\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(matrix)):\n            res += matrix[i][0]\n        \n        for j in range(1,len(matrix[0])):\n            res += matrix[0][j]\n        \n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                matrix[i][j] *= min(matrix[i-1][j-1], matrix[i][j-1], matrix[i-1][j]) + 1\n                res += matrix[i][j]\n        print(matrix)\n        return res\n        \n            \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        # compute prefix square\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                re = 0\n                if i > 0:\n                    re += matrix[i - 1][j]\n                if j > 0:\n                    re += matrix[i][j - 1]\n                if i > 0 and j > 0:\n                    re -= matrix[i - 1][j - 1]\n                matrix[i][j] += re\n        print(matrix)\n        # correct\n        \n        re = 0\n        \n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                # start matching squares at i j\n                l = 0\n                while i + l < len(matrix) and j + l < len(matrix[0]):\n                    # check\n                    # compute a sum area\n                    tmp = matrix[i + l][j + l]\n                    if j > 0:\n                        tmp -= matrix[i + l][j - 1]\n                    if i > 0:\n                        tmp -= matrix[i - 1][j + l]\n                    if i > 0 and j > 0:\n                        tmp += matrix[i - 1][j - 1]\n                    # print('{} {} {} {}'.format(i, j, l, tmp))\n                    \n                    if tmp != (l + 1) ** 2:\n                        break\n                    else:\n                        re += 1\n                    l += 1\n        return re\n                    \n                \n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        @functools.lru_cache(None)\n        def dp(i, j):\n            \n            if matrix[i][j]:\n                if 0 < i and 0 < j:\n                    return min(dp(i-1, j-1), dp(i-1, j), dp(i, j-1)) + 1\n                return 1\n            return 0\n        \n        return sum([dp(i, j) for i in range(m) for j in range(n)])", "from copy import deepcopy\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if matrix == [] or matrix[0] == []:\n            return 0\n        n, m = len(matrix), len(matrix[0])\n        left = deepcopy(matrix)\n        down = deepcopy(matrix)\n        output = deepcopy(matrix)\n        for i in reversed(list(range(n-1))):\n            for j in reversed(list(range(m-1))):\n                if matrix[i][j] == 1:\n                    left[i][j] = left[i][j+1] + 1\n                    down[i][j] = down[i+1][j] + 1\n                    output[i][j] = min(left[i][j], down[i][j], output[i+1][j+1]+1)\n                #print(i, j, output[i][j], left[i][j], down[i][j])\n        return sum(sum(x) for x in output)\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        import copy\n        if not matrix: return 0\n        \n        dp = copy.deepcopy(matrix)\n        \n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][j] == 1:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1\n        \n        total = 0\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                total += dp[i][j]\n                    \n        return total", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        for i in range(1, m):\n            for j in range(1, n):\n                matrix[i][j] *= min(matrix[i-1][j-1], matrix[i][j-1], matrix[i-1][j]) + 1\n        return sum(map(sum, matrix))", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp = []\n        count = 0\n        for i in range(len(matrix)):\n            inner = []\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    inner.append(0)\n                else:\n                    if i == 0 or j == 0:\n                        inner.append(1)\n                        count += 1\n                    else:\n                        c = 1 + min(dp[i-1][j], min(inner[j-1], dp[i-1][j-1]))\n                        inner.append(c)\n                        count += c\n            dp.append(inner)\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        grid = matrix\n        self.dp = [[[0,0] for j in grid[0]] for i in grid]\n        dp = self.dp\n        \n        def ut(r,c):\n            if r>=0 and c>=0:\n                return self.dp[r][c][0]\n            return 0\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c and grid[r][c]:\n                    dp[r][c][1] = min ( dp[r][c-1][1], dp[r-1][c][1] , dp[r-1][c-1][1])\n                    if dp[r][c][1] : dp[r][c][1] +=1\n                    \n                dp[r][c][1] = max(dp[r][c][1] , grid[r][c])\n                dp[r][c][0] += dp[r][c][1]           \n                    \n                dp[r][c][0] += ut(r,c-1) + ut(r-1, c) - ut(r-1, c-1)\n        print(dp)\n                \n        return dp[-1][-1][0]\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def is_valid_square(start_row, end_row, start_col, end_col, matrix):\n            # for row in range(start_row, end_row + 1):\n            #     for col in range(start_col, end_col + 1):\n            #         if matrix[row][col] != 1:\n            #             return False    \n            # return True\n            \n            return not any(matrix[row][col] == 0 for row in range(start_row, end_row + 1) for col in range(start_col, end_col + 1))\n                \n        result = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                search_space_increase = 0\n                while row + search_space_increase < len(matrix) and col + search_space_increase < len(matrix[0]):\n                    if not is_valid_square(row, row + search_space_increase , col, col + search_space_increase, matrix):\n                        break                        \n                    result += 1\n                    search_space_increase += 1\n                        \n        \n        return result", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for x in range(n+1)] for l in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if matrix[i-1][j-1] != 0:\n                    dp[i][j] = matrix[i-1][j-1] + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\n        return sum([sum(x) for x in dp])", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j]:\n                    dp[i+1][j+1] = min(dp[i][j], dp[i][j+1], dp[i+1][j])+1\n                res += dp[i+1][j+1]\n        \n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp=matrix\n        r = len(dp)\n        c = len(dp[0])\n        ans=0\n        for i in range(1,r):\n            for j in range(1,c):\n                if(dp[i][j]==0):\n                    continue\n                if(dp[i-1][j]!=0 and dp[i-1][j-1]!=0 and dp[i][j-1]!=0):\n                    dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1\n        for i in dp:\n            ans+=sum(i)\n        return ans\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix); n = len(matrix[1])\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j]:\n                    if i == 0 or j == 0:\n                        res += 1\n                    else:\n                        matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1],matrix[i-1][j-1])\n                        res += matrix[i][j]\n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        ansmatrix = [[0]*(m + 1) for _ in range(n+1)]\n        count = 0\n        \n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                if matrix[row - 1][col - 1] == 1:\n                    ansmatrix[row][col] = 1 + min(ansmatrix[row][col - 1], ansmatrix[row - 1][col], ansmatrix[row - 1][col - 1])\n                    count += ansmatrix[row][col]\n                    \n        return count\n", "class Solution:\n    def getsum(self,prefix,i,j):\n        if i<0 or j <0:\n            return 0\n        else:\n            return prefix[min(len(prefix),i)][min(len(prefix[0]),j)]\n    def countSquares(self, matrix: List[List[int]]) -> int:\n                \n        m=len(matrix)\n        n=len(matrix[0])\n        dp=[]\n        res=0\n        for i in range(m):\n            dp.append([0]*n)\n        for i in range(m):\n            if matrix[i][0]==1:\n                dp[i][0]=1\n                res=res+1\n        for j in range(1,n):\n            if matrix[0][j]==1:\n                dp[0][j]=1\n                res=res+1\n                \n        print(res)\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][j]>0:\n                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1\n                    res=res+dp[i][j]\n        \n        return res\n                \n        \n        \n        \n       \n\n        \n#         m=len(matrix)\n#         n=len(matrix[0])\n#         sumv=[]\n#         prefixsum=[]\n#         for i in range(m):\n#             sumv.append([0]*n)\n#             prefixsum.append([0]*n)\n        \n#         for j in range(n):\n#             sumv[0][j]=matrix[0][j]\n            \n#         for i in range(m):\n#             for j in range(n):\n#                 sumv[i][j]=matrix[i][j]+sumv[i-1][j]\n \n        \n#         for i in range(m):\n#             prefixsum[i][0]=sumv[i][0]\n            \n            \n#         for i in range(m):\n#             for j in range(n):\n#                 prefixsum[i][j]=sumv[i][j]+prefixsum[i][j-1]\n                \n \n        \n#         res=0\n        \n#         for i in range(m):\n#             for j in range(n):\n#                 if matrix[i][j]!=0:\n#                     for k in range(min(i,j)+2,0,-1):\n\n#                         area=self.getsum(prefixsum,i,j)-self.getsum(prefixsum,i-k,j)-self.getsum(prefixsum,i,j-k)+self.getsum(prefixsum,i-k,j-k)\n\n                        \n#                         if k*k==area:\n                            \n#                             res+=k\n#                             break\n        # return res\n                \n        \n        \n", "class Solution:\n    def getsum(self,prefix,i,j):\n        if i<0 or j <0:\n            return 0\n        else:\n            return prefix[min(len(prefix),i)][min(len(prefix[0]),j)]\n    def countSquares(self, matrix: List[List[int]]) -> int:\n                \n        m=len(matrix)\n        n=len(matrix[0])\n        dp=[]\n        res=0\n        for i in range(m):\n            dp.append([0]*n)\n        for i in range(m):\n            if matrix[i][0]==1:\n                dp[i][0]=1\n                res=res+1\n        for j in range(1,n):\n            if matrix[0][j]==1:\n                dp[0][j]=1\n                res=res+1\n                \n        print(res)\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][j]>0:\n                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1\n                    res=res+dp[i][j]\n        print(dp)\n        return res\n                \n        \n        \n        \n       \n\n        \n#         m=len(matrix)\n#         n=len(matrix[0])\n#         sumv=[]\n#         prefixsum=[]\n#         for i in range(m):\n#             sumv.append([0]*n)\n#             prefixsum.append([0]*n)\n        \n#         for j in range(n):\n#             sumv[0][j]=matrix[0][j]\n            \n#         for i in range(m):\n#             for j in range(n):\n#                 sumv[i][j]=matrix[i][j]+sumv[i-1][j]\n \n        \n#         for i in range(m):\n#             prefixsum[i][0]=sumv[i][0]\n            \n            \n#         for i in range(m):\n#             for j in range(n):\n#                 prefixsum[i][j]=sumv[i][j]+prefixsum[i][j-1]\n                \n \n        \n#         res=0\n        \n#         for i in range(m):\n#             for j in range(n):\n#                 if matrix[i][j]!=0:\n#                     for k in range(min(i,j)+2,0,-1):\n\n#                         area=self.getsum(prefixsum,i,j)-self.getsum(prefixsum,i-k,j)-self.getsum(prefixsum,i,j-k)+self.getsum(prefixsum,i-k,j-k)\n\n                        \n#                         if k*k==area:\n                            \n#                             res+=k\n#                             break\n        # return res\n                \n        \n        \n", "\nclass Solution:\n    \n    def countSquares(self, A):\n        for i in range(1, len(A)):\n            for j in range(1, len(A[0])):\n                A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1\n        return sum(map(sum, A))", "class Solution:\n    def getsum(self,prefix,i,j):\n        if i<0 or j <0:\n            return 0\n        else:\n            return prefix[min(len(prefix),i)][min(len(prefix[0]),j)]\n    def countSquares(self, matrix: List[List[int]]) -> int:\n                \n        m=len(matrix)\n        n=len(matrix[0])\n        dp=[]\n        res=0\n        for i in range(m):\n            dp.append([0]*n)\n        for i in range(m):\n            if matrix[i][0]==1:\n                dp[i][0]=1\n                res=res+1\n        for j in range(1,n):\n            if matrix[0][j]==1:\n                dp[0][j]=1\n                res=res+1\n                \n        print(res)\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][j]>0:\n                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1\n                    res=res+dp[i][j]\n        print(dp)\n        return res\n                \n        \n        \n        \n        for i in range(m):\n            dp\n\n        \n#         m=len(matrix)\n#         n=len(matrix[0])\n#         sumv=[]\n#         prefixsum=[]\n#         for i in range(m):\n#             sumv.append([0]*n)\n#             prefixsum.append([0]*n)\n        \n#         for j in range(n):\n#             sumv[0][j]=matrix[0][j]\n            \n#         for i in range(m):\n#             for j in range(n):\n#                 sumv[i][j]=matrix[i][j]+sumv[i-1][j]\n \n        \n#         for i in range(m):\n#             prefixsum[i][0]=sumv[i][0]\n            \n            \n#         for i in range(m):\n#             for j in range(n):\n#                 prefixsum[i][j]=sumv[i][j]+prefixsum[i][j-1]\n                \n \n        \n#         res=0\n        \n#         for i in range(m):\n#             for j in range(n):\n#                 if matrix[i][j]!=0:\n#                     for k in range(min(i,j)+2,0,-1):\n\n#                         area=self.getsum(prefixsum,i,j)-self.getsum(prefixsum,i-k,j)-self.getsum(prefixsum,i,j-k)+self.getsum(prefixsum,i-k,j-k)\n\n                        \n#                         if k*k==area:\n                            \n#                             res+=k\n#                             break\n        # return res\n                \n        \n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                matrix[i][j] *= min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\n        return sum(map(sum, matrix))", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix) if matrix else 0, len(matrix[0]) if matrix else 0\n        \n        table = [[0]*n for _ in range(m)]\n        ans = 0\n        for i, j in product(list(range(m)), list(range(n))):\n            if matrix[i][j] and j > 0 and i > 0:\n                table[i][j] = min( table[i-1][j], table[i][j-1], table[i-1][j-1]) + 1\n            else:\n                table[i][j] = matrix[i][j]\n                \n            ans += table[i][j]\n        \n        return ans\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        #[0,1,1,1] \n        #[1,1,2,2]\n        #[0,1,2,3] 15\n        \n        #leave the border as-is\n        #using same matrix: O(1) space, O(nm) time\n        for row in range(1,len(matrix)):\n            for col in range(1, len(matrix[0])):\n                if matrix[row][col] == 1: #if 0: ignore\n                    ul = matrix[row-1][col-1]\n                    u = matrix[row-1][col]\n                    l = matrix[row][col-1]\n                    val = min(ul, u, l) + 1\n                    matrix[row][col] = val\n        #print(matrix)\n        total = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                total += matrix[row][col]\n        return total\n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m=len(matrix)\n        n=len(matrix[0])\n        ans=0\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][j]!=0 and matrix[i-1][j]!=0 and matrix[i][j-1]!=0 and matrix[i-1][j-1]!=0:\n                    matrix[i][j]=min(matrix[i-1][j],matrix[i][j-1],matrix[i-1][j-1])+1\n        for i in matrix:\n            ans+=sum(i)\n        return ans\n", "class Solution:\n      def countSquares(self, A):\n        for i in range(1, len(A)):\n            for j in range(1, len(A[0])):\n                A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1\n        return sum(map(sum, A))", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        memo = [[0 for x in range(len(matrix[0]) + 1)] for y in range(len(matrix) + 1)]\n        \n        for i in range(1, len(memo)):\n            for j in range(1, len(memo[0])):\n                \n                if matrix[i-1][j-1] == 0:\n                    memo[i][j] = 0\n                else:\n                    memo[i][j] = min([memo[i-1][j-1], memo[i-1][j], memo[i][j-1]]) + 1\n                \n        tot = 0\n        for i in range(len(memo)):\n            for j in range(len(memo[0])):\n                tot += memo[i][j]\n                \n        return tot\n", "class Solution:\n    def countSquares(self, A: List[List[int]]) -> int:\n        for i in range(1, len(A)):\n            for j in range(1, len(A[0])):\n                A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1\n        return sum(map(sum, A))", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:        \n        M=len(matrix)\n        N=len(matrix[0])\n        dp=[[0 for _ in range(N)]for _ in range(M)]\n        res=0  \n        for bottom in range(M):             \n            for right in range(N):\n                if bottom==0 or right==0:\n                    dp[bottom][right]=1 if matrix[bottom][right]==1 else 0\n                else:\n                    dp[bottom][right]=min(dp[bottom-1][right-1],\\\\\n                                          dp[bottom-1][right],\\\\\n                                          dp[bottom][right-1])+1 \\\\\n                                        if matrix[bottom][right]==1 else 0 \n                res+=dp[bottom][right]\n\n \n                \n        return res\n        ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                matrix[i][j] *= min(matrix[i-1][j-1], matrix[i][j-1], matrix[i-1][j]) + 1\n        \n        return sum(map(sum, matrix))", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        # dp(i, j) = number of squares that have bottom right corner at x1, y1\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for i in range(n)] for j in range(m)]\n        count = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if i-1>=0 and j-1>=0 and matrix[i][j] == 1:\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1\n                elif matrix[i][j] == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n                count += dp[i][j]\n\n        return count\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix or not matrix[0]:\n          return 0\n        res = 0\n        M = len(matrix)\n        N = len(matrix[0])\n        for i in range(M):\n          for j in range(N):\n            if matrix[i][j] == 0:\n              continue\n            if i == 0 or j == 0:\n              res += 1\n            else:\n              add = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1])+1\n              res += add\n              matrix[i][j] = add\n        return res\n          \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        result = 0\n        for r in range(rows):\n            for c in range(cols):\n                if matrix[r][c] == 1:\n                    idx = 1\n                    isTrue = True\n                    while isTrue and (r+idx) != rows and (c+idx) != cols:\n                        for h in range(idx + 1):\n                            if matrix[r + idx][c + h] != 1 or matrix[r + h][c + idx] != 1:\n                                isTrue = False\n                                break\n                        if isTrue:\n                            idx += 1\n                    result += idx\n        return result\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp = [[0 for i in range(len(matrix[0]) + 1)] for j in range(len(matrix) + 1)]\n        total = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 1:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j], dp[i][j + 1], dp[i][j]) + 1\n                    total += min(dp[i + 1][j], dp[i][j + 1], dp[i][j]) + 1\n                \n        return total\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and j > 0:\n                    matrix[i][j] *= min(matrix[i-1][j], matrix[i-1][j-1], matrix[i][j-1])+1\n                ans += matrix[i][j]\n        return ans\n    \n    \n    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        max_y = len(matrix)\n        max_x = len(matrix[0])\n            \n        for y in range(1,max_y):\n            for x in range(1, max_x):\n                if matrix[y][x] and matrix[y][x-1] and matrix[y-1][x] and matrix[y-1][x-1]:\n                    matrix[y][x] = min(matrix[y][x-1], matrix[y-1][x], matrix[y-1][x-1]) + 1 \n                   \n        row_sums = [sum(row) for row in matrix]\n        return sum(row_sums)", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        # dp(i, j) = number of squares that have bottom right corner at x1, y1\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i-1>=0 and j-1>=0 and matrix[i][j] == 1:\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1\n                elif matrix[i][j] == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n                        \n        count = 0\n        for i in range(m):\n            for j in range(n):\n                count += dp[i][j]\n        \n        return count\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and j > 0:\n                    matrix[i][j] *= min(matrix[i-1][j], matrix[i-1][j-1], matrix[i][j-1])+1\n                ans += matrix[i][j]\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                matrix[i][j] = matrix[i][j] * (min({matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]})+1)\n        s = 0\n        for i in matrix:\n            s +=sum(i)\n        return s\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        r,c = len(matrix),len(matrix[0])\n        count = 0 \n        for i in range(r):\n            for j in range(c) :\n                if matrix[i][j] == 1 :\n                    if i == 0 or j == 0:\n                        count += 1\n                    else :\n                        cell_val = min(matrix[i-1][j-1],matrix[i][j-1],matrix[i-1][j]) + matrix[i][j]\n                        count += cell_val\n                        matrix[i][j] = cell_val\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n = len(matrix), len(matrix[0])\n        diag = 0\n        square = [matrix[i][:] for i in range(m)]\n        total = 0\n        r, c = 0, 0\n        while diag < m+n-1:\n            if 0<r<m and 0<c<n and matrix[r][c]>0:\n                square[r][c] += min(square[r][c-1], square[r-1][c], square[r-1][c-1])\n            total += square[r][c]  \n            r += 1\n            c -= 1\n            if (r>m-1) or (c<0):\n                diag += 1\n                r = 0 if diag<n else diag-n+1\n                c = diag - r\n        return total\n                \n                \n                \n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def helper(x, y):\n            temp = 0\n            pre = [[x, y]]\n            side = 1\n            while True:\n                flag = 1\n                nxt = []\n                for i in range(len(pre)):\n                    a, b = pre[i]\n                    if a + 1 >= len(matrix) or b + 1 >= len(matrix[0]) or matrix[a + 1][b + 1] != 1 or matrix[a + 1][b] != 1 or matrix[a][b + 1] != 1:\n                        flag = 0\n                        break\n                    if i - side == -1:\n                        nxt.append([a, b + 1])\n                        nxt.append([a + 1, b + 1])\n                        nxt.append([a + 1, b])\n                    elif i - side >= 0:\n                        nxt.append([a + 1, b])\n                    else:\n                        nxt.append([a, b + 1])\n                if flag == 0:\n                    break\n                temp += 1\n                side += 1\n                pre = nxt\n            return temp\n            \n        res = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    continue\n                res += 1\n                res += helper(i, j)\n        return res\n", "def checkCorners(row_size, col_size, r, c):\n    \n    if (0 <= r-1 < row_size and 0 <= c < col_size) and (0 <= r-1 < row_size and 0 <= c-1 < col_size) and (0 <= r < row_size and 0 <= c-1 < col_size):\n        return True\n    return False\n    \n\nclass Solution:\n    \n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp = matrix[:]\n        r_size = len(matrix)\n        c_size = len(matrix[0])\n        acc = 0\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                if matrix[row][col] == 1 and checkCorners(r_size, c_size, row, col):\n                    dp[row][col] += min(matrix[row][col - 1],\n                                        matrix[row - 1][col],\n                                        matrix[row - 1][col - 1])\n                acc += dp[row][col]\n\n        return acc\n                        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if matrix==[]:\n            return 0\n        maxval=0\n        for i in range(len(matrix[0])):\n            if matrix[0][i]==1:\n                maxval+=1\n                \n        for i in range(1,len(matrix)):\n            if matrix[i][0]==1:\n                maxval+=1\n        print(maxval)\n        for i in range(1,len(matrix)):\n            for j in range(1,len(matrix[0])):\n                if matrix[i][j]:\n                    \n                    matrix[i][j]=min(matrix[i-1][j],matrix[i][j-1],matrix[i-1][j-1])+1\n                    maxval+=matrix[i][j]\n        for j in matrix:\n            print((*j))\n        return maxval\n    \n                    \n               \n       \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        n, m = len(matrix), len(matrix[0])\n        \n        sub_sol = matrix[0][:]\n        row, col = sub_sol[:], [0] * m\n        \n        squares = sum(sub_sol)\n        for i in range(1, n):\n            sol = []\n            for j in range(m):\n                val = matrix[i][j]\n                if j == 0:\n                    col.append(val)\n                else:\n                    if val == 0:\n                        col.append(0)\n                    else:\n                        col.append(col[-1] + 1)\n                \n                if val == 0: row[j] = 0\n                else: row[j] += 1\n                    \n                sol.append(min(col[-1], row[j], (1 + sub_sol[j - 1]) if j > 0 else 1))\n            sub_sol = sol\n            squares += sum(sub_sol)\n            \n        return squares\n                    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def helper(x, y):\n            temp = 0\n            pre = [[x, y]]\n            side = 1\n            while True:\n                flag = 1\n                nxt = []\n                for i in range(len(pre)):\n                    a, b = pre[i]\n                    if a + 1 >= len(matrix) or b + 1 >= len(matrix[0]) or matrix[a + 1][b + 1] != 1 or matrix[a + 1][b] != 1 or matrix[a][b + 1] != 1:\n                        flag = 0\n                        break\n                    if i - side == -1:\n                        nxt.append([a, b + 1])\n                        nxt.append([a + 1, b + 1])\n                        nxt.append([a + 1, b])\n                    elif i - side >= 0:\n                        nxt.append([a + 1, b])\n                    else:\n                        nxt.append([a, b + 1])\n                if flag == 0:\n                    break\n                temp += 1\n                side += 1\n                pre = nxt\n            return temp\n            \n        res = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    continue\n                res += 1\n                res += helper(i, j)\n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n        n = len(matrix)\n        m = len(matrix[0])\n        squares = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                if matrix[i][j] == 1:\n                    squares += self.get_squares(matrix, i, j, n, m)\n        \n        return squares\n    \n    def get_squares(self, matrix, i, j, n, m):\n        count = 1\n        s = 2\n        while i + s <= n and j + s <= m:\n            all_ones = True\n            for k in range(i, i + s):\n                for l in range(j, j + s):\n                    if matrix[k][l] == 0:\n                        return count\n            count += 1\n            s += 1\n\n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n=len(matrix),len(matrix[0])\n        ans=0\n        for sx in range(m):\n            for sy in range(n):\n                if matrix[sx][sy]==1:\n                    ans+=1\n                    for by in range(sy+1,n):\n                        if matrix[sx][by]==1 and sx+(by-sy)<m:\n                            side=by-sy\n                            all_one=True\n                            for x in range(sx,sx+side+1):\n                                if matrix[x][by]!=1:\n                                    all_one=False\n                                    break\n                            if not all_one:\n                                break\n                            for y in range(sy,sy+side+1):\n                                if matrix[sx+side][y]!=1:\n                                    all_one=False\n                                    break                                    \n                            if all_one:\n                                ans+=1\n                                #print(sx,sy,side)\n                            else:\n                                break\n                        else:\n                            break\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n = len(matrix), len(matrix[0])\n        diag = 1\n        square = [matrix[i][:] for i in range(m)]\n        old_rec = [(0,0)] * m\n        new_rec = [(0,0)] * m\n        old_rec[0] = matrix[0][0], matrix[0][0]\n        total = matrix[0][0]\n        r, c = 0, 1\n        while diag < m+n-1:\n            if 0<=r<m and 0<=c<n:\n                if matrix[r][c] == 0: \n                    new_rec[r] = 0,0\n                elif r==0: \n                    new_rec[r] = (old_rec[r][0] + 1, 1)\n                elif c==0:\n                    new_rec[r] = (1, old_rec[r-1][1] + 1)\n                else:\n                    above_h = old_rec[r-1][1]\n                    left_w = old_rec[r][0]\n                    new_rec[r] = left_w + 1, above_h + 1\n                    square[r][c] += min(left_w, above_h, square[r-1][c-1])\n                total += square[r][c]\n                \n            r += 1\n            c -= 1\n            if (r>m) or (c<0): \n                new_rec, old_rec = old_rec, new_rec\n                diag += 1\n                r = 0 if diag<n else diag-n+1\n                c = diag - r\n        return total\n                \n                \n                \n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        squares = {1: set()}\n        max_l = min(len(matrix), len(matrix[0]))\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j]:\n                    squares[1].add((i, j))\n        \n        for l in range(2, max_l+1):\n            squares[l] = set()\n            for s in squares[l-1]:\n                right = (s[0]+1, s[1])\n                down = (s[0], s[1]+1)\n                down_right = (s[0]+1, s[1]+1)\n                if right in squares[l-1] and down in squares[l-1] and down_right in squares[l-1]:\n                    squares[l].add(s)\n                    \n        return sum([len(s) for s in squares.values()])", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        # 1 1 1\n        # 1 2 2\n        # 1 2 3\n        R,C = len(matrix), len(matrix[0])\n        dp = [[0 for i in range(C)]for j in range(R)]\n        ans = 0\n        for i in range(R):\n            dp[i][0] = matrix[i][0]\n            ans += dp[i][0]\n        \n        for j in range(C):\n            dp[0][j] = matrix[0][j]\n            ans += dp[0][j]\n        \n        for i in range(1,R):\n            for j in range(1,C):\n                if matrix[i][j] ==0:\n                    dp[i][j] = 0\n                else:\n            \n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                    ans += dp[i][j]\n                    print(i,j,ans)\n        #print(dp)\n        return ans if dp[0][0] ==0 else ans-1", "from typing import List\n\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        counts = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n\n        def get_val(r, c, m):\n            if 0 <= r < len(m) and 0 <= c < len(m[0]):\n                return m[r][c]\n            return 0\n\n        total = 0\n        for r in range(len(matrix)):\n            for c in range(len(matrix[0])):\n                if matrix[r][c] == 1:\n                    l = get_val(r, c-1, counts)\n                    d = get_val(r-1, c-1, counts)\n                    u = get_val(r-1, c, counts)\n                    counts[r][c] = 1 + min(l, d, u)\n                    total += counts[r][c]\n        return total\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        M = len(matrix)\n        N = len(matrix[0])\n        \n        dp = [[0 for _ in range(N)] for _ in range(M)]\n        \n        dp = matrix[:][:]\n        \n        for i in range(1,M):\n            for j in range(1,N):\n                if matrix[i][j]==1:\n                    dp[i][j] = min([dp[i][j-1],dp[i-1][j],dp[i-1][j-1]])+1\n                \n        res = 0\n        \n        for i in range(M):\n            for j in range(N):\n                if dp[i][j]>0:\n                    for size in range(1,dp[i][j]+1):\n                        res+=1\n                        \n        print(dp)\n                        \n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        cnt = 0\n        rows,cols = len(matrix),len(matrix[0])\n        dp = [[0]*(cols+1) for i in range(rows+1)] # padding with 0\n        for i in range(1,rows+1):\n            for j in range(1,cols+1):\n                if matrix[i-1][j-1] == 1:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1\n                    cnt += dp[i][j]\n        return cnt\n\n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        vertMemo = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        horizMemo = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        diagMemo = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        squareMemo = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        \n        if matrix[0][0] == 1:\n            vertMemo[0][0] = 1\n            diagMemo[0][0] = 1\n            horizMemo[0][0] = 1\n            squareMemo[0][0] = 1\n        \n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 1:\n                vertMemo[0][i] = 1\n                diagMemo[0][i] = 1\n                squareMemo[0][i] = 1\n                horizMemo[0][i] = horizMemo[0][i-1] + 1\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 1:\n                vertMemo[i][0] = vertMemo[i-1][0] + 1\n                diagMemo[i][0] = 1\n                squareMemo[i][0] = 1\n                horizMemo[i][0] = 1\n        for i in range(1,len(matrix)):\n            for j in range(1,len(matrix[0])):\n                if matrix[i][j] == 1:\n                    vertMemo[i][j] = vertMemo[i-1][j] + 1\n                    horizMemo[i][j] = horizMemo[i][j-1] + 1\n                    diagMemo[i][j] = diagMemo[i-1][j-1] + 1\n                    squareMemo[i][j] = min(squareMemo[i-1][j-1]+1, vertMemo[i][j], horizMemo[i][j])\n        #print(vertMemo)\n        #print(horizMemo)\n        #print(diagMemo)\n        print(squareMemo)\n        totSquares = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if squareMemo[i][j] != 0:\n                    totSquares += squareMemo[i][j]\n        return totSquares\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return 0\n        n = len(matrix)\n        m = len(matrix[0])\n        memo = [[0]*m for i in range(n)]\n        memo[0][0] = (matrix[0][0],matrix[0][0])\n        for i in range(1,m):\n            memo[0][i] = (memo[0][i-1][0] + matrix[0][i],matrix[0][i])\n        for i in range(1,n):\n            memo[i][0] = (memo[i-1][0][0] + matrix[i][0],matrix[i][0])\n        for i in range(1,n):\n            for j in range(1,m):\n                # if matrix[i-1][j-1] == 0 or matrix[i][j] == 0:\n                #     memo[i][j] = (memo[i-1][j][0] + memo[i][j-1][0] - memo[i-1][j-1][0] + matrix[i][j], matrix[i][j])\n                # else:\n                if matrix[i][j] == 0:\n                    square_size = 0\n                else:\n                    square_size = min(memo[i-1][j][1],memo[i][j-1][1],memo[i-1][j-1][1])\n                memo[i][j] = (memo[i-1][j][0] + memo[i][j-1][0] - memo[i-1][j-1][0] + (square_size+1)*matrix[i][j], square_size + matrix[i][j])\n        return memo[-1][-1][0]\n        \n        \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        presum = [[0] * (len(matrix[0])+1) for _ in range(len(matrix)+1)]\n        dp = [[0] * (len(matrix[0])+1) for _ in range(len(matrix)+1)]\n        tot = 0\n        for r in range(len(matrix)):\n            cur_row = [0] * (len(matrix[0])+1)\n            for c in range(len(matrix[0])):\n                cur_row[c] = cur_row[c-1] + matrix[r][c]\n                presum[r][c] = presum[r-1][c] + cur_row[c]\n                if matrix[r][c] == 0:\n                    dp[r][c] = 0\n                else:\n                    dp[r][c] = min(dp[r-1][c-1], dp[r-1][c], dp[r][c-1]) + 1\n                    tot += dp[r][c]\n                \n        return tot", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        if m == 1 and n == 1:\n            return matrix[0][0]\n        \n        count = [[[0]*3 for i in range(n+1)] for _ in range(m+1)]\n        res = 0\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if matrix[i-1][j-1]:\n                    count[i][j][0] = count[i-1][j][0] + 1\n                    count[i][j][1] = count[i][j-1][1] + 1\n                    count[i][j][2] = min(count[i-1][j-1][2], count[i-1][j][0], count[i][j-1][1])+1\n                    res += count[i][j][2]\n        return res\n                    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    continue\n                if matrix[i-1][j] > 0 and matrix[i][j-1] > 0 and matrix[i-1][j-1] > 0:\n                    matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1])\n        return sum([sum(v) for v in matrix])", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        M = len(matrix)\n        N = len(matrix[0])\n        \n        dp = [[0 for _ in range(N)] for _ in range(M)]\n        \n        dp = matrix[:][:]\n        \n        for i in range(1,M):\n            for j in range(1,N):\n                if matrix[i][j]==1:\n                    dp[i][j] = min([dp[i][j-1],dp[i-1][j],dp[i-1][j-1]])+1\n                \n        res = 0\n        \n        for i in range(M):\n            for j in range(N):\n                if dp[i][j]>0:\n                    for size in range(1,dp[i][j]+1):\n                        res+=1\n                                        \n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        \n        count = 0\n                \n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                \n                if i > 0 and j > 0 and matrix[i][j] > 0:                    \n                    matrix[i][j] = min(matrix[i-1][j-1], min(matrix[i-1][j], matrix[i][j-1])) + 1\n                \n                if matrix[i][j] > 0:\n                    count += matrix[i][j]\n                    \n                    \n        return count\n    \n\n    \n    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        result = [matrix[0]]\n        \n        for i in range(1, len(matrix)):\n            row = [matrix[i][0]]\n            result.append(row)\n            for j in range(1, len(matrix[i])):\n                if not matrix[i][j]:\n                    row.append(0)\n                else:\n                    row.append(1 + min(result[i-1][j], result[i][j-1], result[i-1][j-1]))\n        return sum(sum(r) for r in result)", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp = copy.deepcopy(matrix)\n        counter = 0\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i == 0 or j == 0 or dp[i][j] == 0:\n                    counter += dp[i][j]\n                    continue\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                    counter += dp[i][j]\n        \n        return counter", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n = len(matrix), len(matrix[0])\n        diag = 1\n        square = [matrix[i][:] for i in range(m)]\n        old_rec = [(0,0)] * m\n        new_rec = [(0,0)] * m\n        old_rec[0] = matrix[0][0], matrix[0][0]\n        total = matrix[0][0]\n        r, c = 0, 1\n        while diag < m+n-1:\n            if 0<=r<m and 0<=c<n:\n                # print('r=', r, ' c=',c)\n                if matrix[r][c] == 0: \n                    new_rec[r] = 0,0\n                elif r==0: \n                    new_rec[r] = (old_rec[r][0] + 1, 1)\n                elif c==0:\n                    new_rec[r] = (1, old_rec[r-1][1] + 1)\n                else:\n                    above_h = old_rec[r-1][1]\n                    left_w = old_rec[r][0]\n                    # print(' left w=',left_w, 'above h=', above_h, ' sq=', square[r-1][c-1])\n                    new_rec[r] = left_w + 1, above_h + 1\n                    square[r][c] += min(left_w, above_h, square[r-1][c-1])\n                total += square[r][c]\n                # print(' number=',new_rec[r], ' total=', total )\n                \n            r += 1\n            c -= 1\n            if (r>m) or (c<0): \n                new_rec, old_rec = old_rec, new_rec\n                diag += 1\n                r = 0\n                c = diag - r\n        return total\n                \n                \n                \n                \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        c = 0\n        dp = matrix\n        for i in range(1, m):\n            for j in range(1, n):\n                if dp[i][j] != 0:\n                    if dp[i-1][j] != 0 and dp[i-1][j-1] != 0 and dp[i][j-1] != 0:\n                        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1])+1\n        \n        for i in dp:\n            c+=sum(i)\n        \n        return c", "class Solution:\n\\tdef countSquares(self, matrix: List[List[int]]) -> int:\n\\t\\tfor r in range(len(matrix)):\n\\t\\t\\tfor c in range(len(matrix[0])):\n\\t\\t\\t\\tif matrix[r][c] == 1:\n\\t\\t\\t\\t\\tif r == 0 or c == 0:\n\\t\\t\\t\\t\\t\\tmatrix[r][c] = 1\n\\t\\t\\t\\t\\telse:\n\\t\\t\\t\\t\\t\\tmatrix[r][c] = 1 + min(matrix[r - 1][c - 1], matrix[r - 1][c], matrix[r][c - 1])\n\n\\t\\treturn sum(sum(matrix, []))", "\n# 1277. Count Square Submatrices with All Ones\n\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        A = matrix\n        for i in range(1, len(A)):\n            for j in range(1, len(A[0])):\n                A[i][j] *= min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1]) + 1\n                \n        # return sum(map(sum, A))\n        return sum([A[i][j] for i in range(len(A)) for j in range(len(A[0]))])\n    \n# 1. class Solution:\n# 2.     def countSquares(self, matrix: List[List[int]]) -> int:\n# 3.         if matrix is None or len(matrix) == 0:\n# 4.             return 0\n# 5.         \n# 6.         rows = len(matrix)\n# 7.         cols = len(matrix[0])\n# 8.         \n# 9.         result = 0\n# 10.         \n# 11.         for r in range(rows):\n# 12.             for c in range(cols):\n# 13.                 if matrix[r][c] == 1:   \n# 14.                     if r == 0 or c == 0: # Cases with first row or first col\n# 15.                         result += 1      # The 1 cells are square on its own               \n# 16.                     else:                # Other cells\n# 17.                         cell_val = min(matrix[r-1][c-1], matrix[r][c-1], matrix[r-1][c]) + matrix[r][c]\n# 18.                         result += cell_val\n# 19.                         matrix[r][c] = cell_val #**memoize the updated result**\n# 20.         return result  \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        def pref(x,y):\n            return 0 if x<0 or y<0 else f[x][y]\n        rows,cols = len(matrix),len(matrix[0]) if matrix else 0\n        res = 0\n        f = [[0 for j in range(cols)] for i in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                f[i][j] = 0 if matrix[i][j] == 0 else min(pref(i-1,j),pref(i,j-1),pref(i-1,j-1))+1\n                res += f[i][j]\n        #print(f)\n        return res\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        '''\n        f[i][j] = \u4ee5(i,j)\u4e3a\u53f3\u4e0b\u89d2\u7684\u6700\u5927square\u8fb9\u957f\n        '''\n        row, col = len(matrix), len(matrix[0])\n        f = [[0] * col for _ in range(row)]\n        for i in range(row):\n            for j in range(col):\n                if matrix[i][j] == 0: \n                    f[i][j] = 0\n                    continue\n                if i == 0 or j == 0:\n                    f[i][j] = matrix[i][j]\n                    continue\n                \n                f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) + 1\n      \n        return sum([sum(f[i]) for i in range(row)])\n                \n", "class Solution:\n    #\n    # Solution 1: DP\n    #\n    def countSquares1(self, grid: List[List[int]]) -> int:\n        n = len(grid); m = len(grid[0]) if grid else 0\n        \n        res = 0\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == 0: continue\n                if r==0 or c==0: res += 1; continue\n                grid[r][c] = min(grid[r-1][c-1], grid[r][c-1], grid[r-1][c]) + 1\n                res += grid[r][c]\n        return res\n    \n    #\n    # Solution 2: Brute Force\n    #\n    def countSquares(self, grid):\n        n = len(grid); m = len(grid[0]) if grid else 0\n        \n        def helper(sr, sc, k):\n            res = 1\n            for i in range(2, k+1):\n                j = i-1\n                er = sr + j \n                ec = sc + j\n                for r in range(sr, er+1):\n                    if r == er: \n                        if any(grid[r][c] == 0 for c in range(sc, sc+i)): return res\n                    else: \n                        if grid[r][ec] == 0: return res\n                res += 1\n            return res\n        \n        res = 0\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == 0: continue\n                res += helper(r, c, min(n-r, m-c))\n        return res\n    \n\\\"\\\"\\\"\n[[0,1,1,1],[1,1,1,1],[0,1,1,1]]\n[[0,1,1,1],[1,1,0,1],[1,1,1,1],[1,0,1,0]]\n\\\"\\\"\\\"    ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        MAXINT = 1 << 30\n        \n        most_recent_zero_to_left_or_here = [[None] * n for _ in range(m)]\n        most_recent_zero_above_or_here = [[None] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    most_recent_zero_to_left_or_here[i][j] = j\n                elif j == 0:\n                    most_recent_zero_to_left_or_here[i][j] = -1\n                else:\n                    most_recent_zero_to_left_or_here[i][j] = most_recent_zero_to_left_or_here[i][j - 1]\n                    \n        for j in range(n):\n            for i in range(m):\n                if matrix[i][j] == 0:\n                    most_recent_zero_above_or_here[i][j] = i\n                elif i == 0:\n                    most_recent_zero_above_or_here[i][j] = -1\n                else:\n                    most_recent_zero_above_or_here[i][j] = most_recent_zero_above_or_here[i - 1][j]\n                    \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = matrix[i][0]\n            \n        for j in range(n):\n            dp[0][j] = matrix[0][j]\n            \n        for i in range(1, m):\n            for j in range(1, n):\n                limit = min(i - most_recent_zero_above_or_here[i][j], j - most_recent_zero_to_left_or_here[i][j])\n                old = dp[i - 1][j - 1]\n                dp[i][j] = min(1 + old, limit)\n                \n        return sum(dp[i][j] for i in range(m) for j in range(n))\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        h, w = len(matrix), len(matrix[0])\n        acc_mat, merge_status_mat = [[0]*w for _ in range(h)], [[0]*w for _ in range(h)]\n        \n        for i in range(h):\n            for j in range(w):\n                \n                # check surounding value and status \n                if j-1 >=0:\n                    left = acc_mat[i][j-1] \n                    left_status = merge_status_mat[i][j-1]\n                else:\n                    left = 0\n                    left_status = 0 \n                \n                if i-1 >= 0:\n                    top = acc_mat[i-1][j] \n                    top_status = merge_status_mat[i-1][j]\n                else:\n                    top = 0\n                    top_status = 0 \n                \n                if  i-1>=0 and j-1>=0: \n                    topLeft = acc_mat[i-1][j-1]\n                    topLeft_status = merge_status_mat[i-1][j-1]\n                else:\n                    topLeft = 0\n                    topLeft_status = 0 \n                \n                # exec\n                merge_status_mat[i][j] = min(topLeft_status, top_status, left_status) + 1 if matrix[i][j]  == 1 else 0\n                # print(i, j, topLeft_status,   merge_status_mat[i-1][j], left_status, merge_status_mat)\n                acc_mat[i][j] = left + top - topLeft + merge_status_mat[i][j]\n                # print(left, top, topLeft, acc_mat)\n            \n        return acc_mat[i][j]\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        sq = 0\n        m_row = range(len(matrix))\n        m_col = range(len(matrix[0])) \n        \n        def expand_square(row, n, m, p, square=0, count=1):\n            while count > -1:\n                for i in range(count):\n                    if row + i == m:\n                        return square\n                    for j in range(count):\n                        if n + j == p:\n                            return square\n                        elif matrix[row + i][n + j] != 1:\n                            return square                \n                square += 1\n                count += 1\n        \n        for row in m_row:\n            for n in m_col:\n                if matrix[row][n] == 1:\n                    sq += expand_square(row, n, len(matrix), len(matrix[0]))\n\n                                    \n        return sq", "class Solution:\n    #\n    # Solution 1: DP\n    #\n    def countSquares1(self, grid: List[List[int]]) -> int:\n        n = len(grid); m = len(grid[0]) if grid else 0\n        \n        res = 0\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == 0: continue\n                if r==0 or c==0: res += 1; continue\n                grid[r][c] = min(grid[r-1][c-1], grid[r][c-1], grid[r-1][c]) + 1\n                res += grid[r][c]\n        return res\n    \n    #\n    # Solution 2: Brute Force\n    #\n    def countSquares(self, grid):\n        n = len(grid); m = len(grid[0]) if grid else 0\n        \n        def helper(sr, sc, k):\n            res = 1\n            for i in range(2, k+1):\n                j = i-1; er = sr+j; c = sc+j\n                for r in range(sr, er+1):\n                    if   r == er and any(grid[r][c] == 0 for c in range(sc, sc+i)): return res\n                    elif r != er and     grid[r][c] == 0: return res\n                res += 1\n            return res\n        \n        res = 0\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == 0: continue\n                res += helper(r, c, min(n-r, m-c))\n        return res\n    \n\\\"\\\"\\\"\n[[0,1,1,1],[1,1,1,1],[0,1,1,1]]\n[[0,1,1,1],[1,1,0,1],[1,1,1,1],[1,0,1,0]]\n\\\"\\\"\\\"    ", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp=[[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        sum=0\n        for i in range(len(dp[0])):\n            dp[0][i]=matrix[0][i]\n            sum+=dp[0][i]\n        print(sum)\n        for j in range(1,len(dp)):\n            dp[j][0]=matrix[j][0]\n            sum+=dp[j][0]\n        print(sum)\n        \n        for i in range(1,len(dp)):\n            for j in range(1,len(dp[0])):\n                if matrix[i][j]==1:\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\n                    sum+=dp[i][j]\n        \n        return sum\n                    \n    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        mat = deepcopy(matrix)\n        for i in range(0, len(mat)):\n            for j in range(0, len(mat[0])):\n                if mat[i][j] == 0:\n                    continue\n                if i - 1 >= 0:\n                    top = mat[i - 1][j]\n                else:\n                    top = 0\n                \n                if j - 1 >= 0:\n                    left = mat[i][j - 1]\n                else:\n                    left = -1\n                    \n                if i - 1 < 0 and j - 1 < 0:\n                    top_left = -1\n                else:\n                    top_left = mat[i - 1][j - 1]\n                \n                if top_left > 0 and left > 0 and top > 0:\n                    mat[i][j] = min(top_left, left, top) + 1\n        ret = 0  \n        for i in range(0, len(mat)):\n            for j in range(0, len(mat[0])):\n                ret += mat[i][j]\n        return ret", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                matrix[i][j] *= min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1\n        return sum(sum(row) for row in matrix)", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        count = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        def invalid_matrix(r, c, s):\n            for i in range(0, s):\n                for j in range(s):\n                    if r + i >= m or c + j >= n:\n                        return True\n                    if r + i < m and c + j < n and matrix[r + i][c + j] == 0:\n                        return True\n                    \n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    count += 1\n                    size = 2\n                    while True:\n                        if invalid_matrix(i, j, size):\n                            break\n                        count += 1\n                        size += 1\n        \n        return count\n        \n", "class Solution:\n    \n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        nrows = len(matrix)\n        ncols = len(matrix[0])\n        dp1 = [0] * ncols\n        dp2 = [0] * ncols\n        ans = 0\n        for row in range(nrows):\n            dp1, dp2 = dp2, [0] * ncols\n            for col in range(ncols):\n                if matrix[row][col] == 0:\n                    continue\n                if row == 0 or col == 0:\n                    dp2[col] = 1\n                else:\n                    dp2[col] = 1 + min(dp1[col], dp1[col - 1], dp2[col - 1])\n                ans += dp2[col]\n        return ans", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n                matrix[i][j] = (min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1) * matrix[i][j]\n        \n        res = sum([sum(r) for r in matrix])\n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m,n, count = len(matrix), len(matrix[0]), 0\n        size_matrix = [[0] * n for j in range(m)]\n        indices = [(-1,-1), (-1,0), (0,-1)]\n        \n        def _in_range(i,j):\n            return i>=0 and i<m and j>=0 and j<n\n        \n        for i in range(0,m):\n            for j in range(0,n):\n                if matrix[i][j] == 1:\n                    if i == 0 or j == 0:\n                        size_matrix[i][j] = matrix[i][j]\n                        if matrix[i][j] == 1:\n                            count += 1\n                    else:\n                        minimum = min([size_matrix[x+i][y+j] for x,y in indices if _in_range(x+i, y+j)])\n                        size_matrix[i][j] = minimum + 1\n                        count += 1 + minimum\n        \n        return count\n                    \n                    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        max_square_size = min(m,n)\n        ones = []\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    ones.append([i,j])\n        # For each one check if there are squares\n        square_count = len(ones)\n        for p in ones:\n            for j in range(1,max_square_size):\n                \n                #print(\\\"--\\\",p,j)\n                found_zero = False\n                for rj in range(j+1):\n                    for cj in range(j+1):\n                        try:\n                            #print(j, p[0]+rj, p[1]+cj, matrix[p[0]+rj][p[1]+cj])\n                            if matrix[p[0]+rj][p[1]+cj] == 0:\n                                found_zero = True\n                                break\n                        except IndexError:\n                            found_zero = True\n                    if found_zero:\n                        break\n                #print(p,j,found_zero)\n                if found_zero:\n                    break\n                else:\n                    #print(p,j)\n                    square_count += 1\n                           \n        return square_count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] != 1:\n                    continue\n                elif i == 0 or j == 0:\n                    count += 1\n                else:\n                    matrix[i][j] = min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]) + 1\n                    count += matrix[i][j]\n                \n        return count", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        dp=matrix\n        r = len(dp)\n        c = len(dp[0])\n        ans=0\n        for i in range(1,r):\n            for j in range(1,c):\n                if(dp[i][j]==0):\n                    continue\n                if(dp[i-1][j]!=0 and dp[i-1][j-1]!=0 and dp[i][j-1]!=0):\n                    dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1\n        print(dp)\n        for i in dp:\n            ans+=sum(i)\n        return ans", "import copy\nclass Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        m, n = len(matrix), len(matrix[0])\n        \n        counter = copy.deepcopy(matrix)\n        \n\n        for i in range(1,m):\n            for j in range(1,n):\n                \n                if counter[i][j] == 1:\n                    counter[i][j] = 1 + min(counter[i-1][j], counter[i-1][j-1],counter[i][j-1])\n        \n        total_count = 0\n        \n        for i in range(m):\n            for j in range(n):\n                total_count += counter[i][j] \n                    \n        return total_count\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        count = 0\n        for r in range(rows):\n            for c in range(cols):\n                if matrix[r][c] and r > 0 and c > 0:\n                    matrix[r][c] = min(matrix[r-1][c],matrix[r][c-1],matrix[r-1][c-1]) + 1\n                count += matrix[r][c]\n        return count\n                    \n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        def traverse_subsquares(i, j):\n            max_size = min(i, j) + 1\n            n_subsquares = 0\n            for i_base in range(i, i - max_size, -1):\n                size = i - i_base + 1\n                # print(f\\\"---------- {i_base, size, max_size} -----------\\\")\n                ip = i_base\n                for jp in range(j, j - size, -1):\n                    # print(ip, jp)\n                    if not matrix[ip][jp]:\n                        return n_subsquares\n                for ip in range(i_base + 1, i_base + size, 1):\n                    # print(ip, jp)\n                    if not matrix[ip][jp]:\n                        return n_subsquares\n                n_subsquares += 1\n                \n            return n_subsquares\n        \n        # print(traverse_subsquares(2, 1))\n        # print(\\\"&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\\\")\n        # print(traverse_subsquares(2, 1))\n        # return\n        \n        total = 0\n        for i in range(rows):\n            for j in range(cols):\n                n = traverse_subsquares(i, j)\n                # print(f\\\"i={i}, j={j}, n={n}\\\")\n                total += n\n                \n        return total", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        def traverse_subsquares(i, j):\n            max_size = min(i, j) + 1\n            n_subsquares = 0\n            for i_base in range(i, i - max_size, -1):\n                size = i - i_base + 1\n                ip = i_base\n                for jp in range(j, j - size, -1):\n                    if not matrix[ip][jp]:\n                        return n_subsquares\n                for ip in range(i_base + 1, i_base + size, 1):\n                    if not matrix[ip][jp]:\n                        return n_subsquares\n                n_subsquares += 1\n                \n            return n_subsquares\n        \n        total = 0\n        for i in range(rows):\n            for j in range(cols):\n                n = traverse_subsquares(i, j)\n                total += n\n                \n        return total", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        res = 0;\n        rows, cols = len(matrix), len(matrix[0])\n        for r in range(rows):\n            for c in range(cols):\n                if matrix[r][c] == 1 and r > 0 and c>0:\n                    matrix[r][c] = min([matrix[r-1][c-1], matrix[r-1][c], matrix[r][c-1]]) + 1\n                res += matrix[r][c]\n        \n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n        rows = len(matrix)\n        cols = len(matrix[0])\n        ret = 0\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 1:\n                    if i == 0 or j == 0:\n                        ret += 1\n                    else:\n                        min_side = min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]) + 1\n                        matrix[i][j] = min_side\n                        ret += min_side\n        return ret", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        ans = [[0]*(n+1) for _ in range(m+1)]\n        \n        count = 0\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if matrix[i-1][j-1] == 1:\n                    ans[i][j] = 1 + min(ans[i-1][j], ans[i-1][j-1], ans[i][j-1])\n                    count += ans[i][j]\n        return count\n        \n        # n = len(matrix)\n        # m = len(matrix[0])\n        # ans_matrix = [[0]*(m+1) for _ in range(n+1)]\n        # print(ans_matrix)\n        # count = 0\n        # for i in range(1,n+1):\n        #     for j in range(1, m+1):\n        #         if matrix[i-1][j-1] == 1:\n        #             ans_matrix[i][j] = min(ans_matrix[i][j-1], ans_matrix[i-1][j], ans_matrix[i-1][j-1]) + 1\n        #             count += ans_matrix[i][j]\n        # return count\n", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        squares = copy.deepcopy(matrix)\n        count = 0\n        ones_in_col = [0] * n\n        \n        for row in range(m):\n            ones_in_row = 0\n            \n            for col in range(n):\n                ones_in_row = ones_in_row + 1 if matrix[row][col] else 0\n                ones_in_col[col] = ones_in_col[col] + 1 if matrix[row][col] else 0\n                top_left_res = 0 if row == 0 or col == 0 else squares[row - 1][col - 1]\n                \n                squares[row][col] = min(ones_in_row, ones_in_col[col], top_left_res + 1)\n                # print('row', row, 'col', col, 'res', ones_in_row, ones_in_col[col], squares[row][col])\n\n                count += squares[row][col]\n        \n        # print(squares)\n        return count\n            \n    \n    \n'''\nBrute-force: try all submatrices. O(n^2 * m^2)\n\n0 1 1 1\n1 1 1 1\n0 1 1 1\n\n0 1 2 3\n1 2 3 4\n0 1 2 3\n\n0 1 1 1\n1 2 2 2\n0 3 3 3\n\nfirst row:\nget: 0 1 2 3\n\n\n\n\n\n\n0 1 1 1 0\n1 1 1 1 1\n1 1 1 1 1\n0 1 1 1 1\n0 1 1 1 0\n\n0 5 5 5 0\n2 4 4 4 3\n1 3 4 3 2\n0 2 2 2 1\n0 1 1 1 0\n\n0 3 2 1 0\n5 4 3 2 1\n5 4 3 2 1\n5 4 3 2 1\n0 3 2 1 0\n\nO(nm)\n\n\n\n#         right = []\n#         for row in matrix:\n#             r = []\n#             count = 0\n#             for x in row:\n#                 count = count + 1 if x else 0\n#                 r.append(count)\n#             right.append(r)\n\n        \n#         for row in range(m):\n#             count = 0\n#\n#             for col in range(n):\n#                 right[row][col] = count = count + 1 if matrix[row][col] else 0\n            \n#         for col in range(n):\n#             count = 0\n#\n#             for row in range(m):\n#                 bottom[row][col] = count = count + 1 if matrix[row][col] else 0\n\n        # for row in range(m):\n        #     for col in range(n):\n        #         count += squares[row][col]\n'''", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        res = 0\n      \n        @lru_cache(None)\n        def search(i, j):\n            nonlocal res \n            if i >= m or i < 0 or j >= n or j < 0:\n                return 0\n            \n            val = (1 + min(search(i - 1, j), search(i, j - 1), search(i - 1, j - 1))) * matrix[i][j]\n            res += val\n            return val\n        \n        search(m - 1, n - 1)\n        return res", "class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        sm = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i - 1 >= 0 and j - 1 >= 0 and matrix[i][j] > 0 and matrix[i][j - 1] > 0 and matrix[i - 1][j] > 0 and  matrix[i - 1][j - 1] > 0:\n                    matrix[i][j] += min(matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1])\n                sm += matrix[i][j]\n        return sm"]
["class Solution:\n    def numPermsDISequence(self, S):\n        dp = [1] * (len(S) + 1)\n        for a, b in zip('I' + S, S):\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\n        return dp[0] % (10**9 + 7)\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        n = len(S) + 1\n        dp = [[0] * (n + 1) for _ in range(n+1)]\n        dp[1][0] = 1\n        MOD = 10**9 + 7\n        for i in range(2,n+1):\n            p = [0] + list(itertools.accumulate(dp[i-1]))\n            \n            for j in range(i):\n                L,R = None,None\n                if S[i-2] == 'D': #decreasing\n                    L = j\n                    R = i - 2\n                \n                else: #increasing\n                    L = 0\n                    R = j - 1\n                \n                dp[i][j] = (p[R+1] - p[L])% MOD\n                dp[i][j] %= MOD\n\n        return sum(dp[n]) % MOD\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        n = len(S) + 1\n        dp = [[0] * (n + 1) for _ in range(n+1)]\n        dp[1][0] = 1\n        MOD = 10**9 + 7\n        for i in range(2,n+1):\n            p = [0] + list(itertools.accumulate(dp[i-1]))\n            \n            for j in range(i):\n                L,R = None,None\n                if S[i-2] == 'D': #decreasing\n                    L = j\n                    R = i - 2\n                \n                else: #increasing\n                    L = 0\n                    R = j - 1\n                \n                dp[i][j] = (p[R+1] - p[L])% MOD\n                dp[i][j] %= MOD\n\n        res = 0\n        for i in dp[n]:\n            res += i\n            res %= MOD\n        return res\n", "from functools import lru_cache\n\nclass Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if not (0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i - 1, j) + dp(i, j + 1)) % MOD\n            else:\n                return (dp(i-1, j - 1) + dp(i, j - 1)) % MOD\n\n        return sum(dp(N, j) for j in range(N+1)) % MOD", "class Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if not(0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i, j+1) + dp(i-1, j)) % MOD\n            else:\n                return (dp(i, j-1) + dp(i-1, j-1)) % MOD\n\n        return sum(dp(N, j) for j in range(N+1)) % MOD", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        from functools import lru_cache\n        MOD = 10**9 + 7\n        N = len(S)\n        \n        @lru_cache(None)\n        def search(i, j):\n            \n            if not 0 <= j <= i:\n                return 0\n            \n            if i == 0:\n                return 1\n            \n            if S[i-1] == 'D':\n                return (search(i, j+1) + search(i-1, j)) % MOD\n            else:\n                return (search(i, j-1) + search(i-1, j-1)) % MOD\n            \n        \n        return sum(search(N, j) for j in range(len(S)+1)) % MOD", "from functools import lru_cache\n\n\nclass Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if not(0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i, j+1) + dp(i-1, j)) % MOD\n            else:\n                return (dp(i, j-1) + dp(i-1, j-1)) % MOD\n\n        return sum(dp(N, j) for j in range(N+1)) % MOD\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10**9 + 7\n        N = len(S)\n        \n        dp = [[0]*(N+1) for _ in range(N+1)]\n        \n        def solve(i, j):\n            if not ( 0 <= j <= i):\n                return 0 \n            \n            if dp[i][j]:\n                return dp[i][j]\n            \n            if i == 0:\n                return 1\n            if S[i-1] == 'D':\n                dp[i][j] = (solve(i, j-1) + solve(i-1, j-1))  % MOD\n            else:\n                dp[i][j] = (solve(i, j+1) + solve(i-1, j)) % MOD  \n            \n            return dp[i][j]\n       \n        return sum(solve(N, j) for j in range(N+1)) % MOD\n            \n            \n            \n         \n        \n        \n        \n", "from functools import lru_cache\n\n\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def presum(n, last):\n            if last == 0:\n                return 0\n            return DP(n, last - 1) + presum(n, last - 1)\n\n        @lru_cache(None)\n        def DP(n, last):\n            if n == 0:\n                return 1\n            if S[n - 1] == 'D':\n                return (presum(n - 1, n) - presum(n - 1, last)) % MOD\n            else:\n                return presum(n - 1, last) % MOD\n\n        return sum(\n            DP(len(S), i)\n            for i in range(len(S) + 1)\n        ) % MOD\n", "from functools import lru_cache\n\n\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def presum(n, last):\n            if last == 0:\n                return 0\n            return DP(n, last - 1) + presum(n, last - 1)\n\n        @lru_cache(None)\n        def DP(n, last):\n            if n == 0:\n                return 1\n            if S[n - 1] == 'D':\n                return (presum(n - 1, n) - presum(n - 1, last)) % MOD\n            else:\n                return presum(n - 1, last) % MOD\n\n        return presum(len(S), len(S) + 1) % MOD\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        dp = [1] * (len(S)+1)\n        \n        for a , b in zip('I'+S, S):\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\n        \n        return dp[0] % (10**9+7)\n", "from functools import lru_cache\n\nclass Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if not(0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i, j+1) + dp(i-1, j)) % MOD\n            else:\n                return (dp(i, j-1) + dp(i-1, j-1)) % MOD\n\n        return sum(dp(N, j) for j in range(N+1)) % MOD", "from functools import lru_cache\n\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if not(0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i, j+1) + dp(i-1, j)) % MOD\n            else:\n                return (dp(i, j-1) + dp(i-1, j-1)) % MOD\n\n        return sum(dp(N, j) for j in range(N+1)) % MOD", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10**9+7\n        n = len(S)\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if not (0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i, j+1)+ dp(i-1, j)) % MOD\n            else:\n                return (dp(i, j-1)+dp(i-1, j-1)) % MOD\n        \n        return sum(dp(n, j) for j in range(n+1)) % MOD\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        n = len(S)\n        MOD = 10 ** 9 + 7\n\n        dp = [[0]*(n+1) for _ in range(n+1)]\n\n        dp[0][0] = 1\n\n        for i in range(1, n+1):\n            for j in range(i+1):\n                if S[i-1] == 'D':\n                    dp[i][j] = sum(dp[i-1][j:i] + [0]) % MOD\n                else:\n                    dp[i][j] = sum(dp[i-1][:j] + [0]) % MOD\n        return sum(dp[-1]) % MOD", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        d = [0] * (len(S) + 1)\n        d[0] = 1\n        for i,c in enumerate(S):\n            if c == 'D':\n                for j in range(i-1,-1,-1):\n                    d[j] += d[j+1]\n            else:\n                for j in range(1,i+1):\n                    d[j] += d[j-1]\n                for j in range(i+1,0,-1):\n                    d[j] = d[j-1]\n                d[0] = 0\n        return sum(d) % 1000000007", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        M = pow(10, 9) + 7\n        N = len(S)\n        S = '#' + S\n        \n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if S[i] == 'D':\n                    for k in range(j, i + 1):\n                        dp[i][j] += dp[i-1][k]\n                else:\n                    # S[i] == 'I'\n                    for k in range(0, j):\n                        dp[i][j] += dp[i-1][k]\n        res = 0\n        for i in range(N + 1):\n            res += dp[N][i]\n        return res % M\n        \n        \n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10**9+7\n        \n        N = len(S)\n        @lru_cache(None)\n        \n        def dp(i,j):\n          if i==0:\n            return 1\n          elif S[i-1] == 'D':\n            return sum(dp(i-1, k) for k in range(j,i)) % MOD\n          else:\n            return sum(dp(i-1,k) for k in range(j)) % MOD\n          \n        \n        return sum(dp(N,j) for j in range(N+1)) % MOD", "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n=len(s)\n        dp=[[0 for i in range(n+1)] for i in range(n+1)]\n        dp[0][0]=1\n        for i in range(1,n+1):\n            for j in range(i+1):\n                if(s[i-1]=='D'):\n                    for k in range(j,i):\n                        dp[i][j]+=dp[i-1][k]\n                else:\n                    for k in range(j):\n                        dp[i][j]+=dp[i-1][k]\n        # print(dp)\n        return sum(dp[n][:])%(pow(10,9)+7)", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        n = len(S)\n        if n <= 1: return 1\n        \n        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        dp[0][0] = 1\n        \n        for idx, s in enumerate(S):\n            for end in range(idx+2):\n                if s == 'D':\n                    for i in range(end, idx+2):\n                        dp[idx+1][end] += dp[idx][i]\n                else:\n                    for i in range(end):\n                        dp[idx+1][end] += dp[idx][i]\n                        \n        # for d in dp: print(d)\n        return sum(dp[-1]) % (10 ** 9 + 7)", "from functools import lru_cache\n\nclass Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return sum(dp(i-1, k) for k in range(j, i)) % MOD\n            else:\n                return sum(dp(i-1, k) for k in range(j)) % MOD\n\n        return sum(dp(N, j) for j in range(N+1)) % MOD", "from functools import lru_cache\n\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        # Dynamic Programming\n        # Time  complexity: O(N^3)\n        # Space complexity: O(N^2)\n        MOD = 10**9 + 7\n        N = len(S)\n\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if i == 0:\n                return 1\n            elif S[i - 1] == 'D':\n                return sum(dp(i - 1, k) for k in range(j, i)) % MOD\n            else:\n                return sum(dp(i - 1, k) for k in range(j))\n\n        return sum(dp(N, j) for j in range(N + 1)) % MOD\n\n", "from functools import lru_cache\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        '''\n        \u8fd9\u9053\u9898\u76ee\u7684\u5173\u952e\u662f\u7b2c\u4e00\u6b65\u770b\u523010**9+7\u77e5\u9053\u7528dp\u65b9\u6cd5\u6765\u505a\n        dp[i]\u8868\u793a\u8303\u56f4[0\uff0ci]\u7684\u5e8f\u5217\u4e2a\u6570\uff0c\u7136\u540e\u53d1\u73b0\u4e0d\u597d\u627e\u9012\u63a8\u5173\u7cfb\n        \u8fd9\u4e2a\u65f6\u5019\u80af\u5b9a\u662f\u9690\u85cf\u7684\u4fe1\u606f\u6ca1\u7528\uff0c\u5916\u9762\u9700\u8981\u901a\u8fc7\u5b9e\u9645\u7684\u4f8b\u5b50\u6765\u603b\u7ed3\u5f71\u54cd\u4e2a\u6570\u7684\u53e6\u5916\u4e00\u4e2a\u53c2\u6570\n        \u5e8f\u5217\u662f\u5347\u8fd8\u662f\u964d\u8ddf\u4ec0\u4e48\u5173\u7cfb\u6700\u5927\uff0c\u90a3\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002DID\u6a21\u5f0f\uff0c\u6211\u4eec\u53ef\u4ee5\u662f1032\uff0c\u90a3\u4e48\u6211\u4eec\u518d\u52a0\u4e2aD\uff0c\u8981\u6c42\u9012\u51cf\n        \u8fd9\u4e2a\u65f6\u5019\u591a\u51fa\u4e86\u4e00\u4e2a4\u6765\uff0c\u6211\u4eec\u5982\u4f55\u6539\u90201032\u5462\uff0c\u76f4\u63a5\u52a04\u662f\u4e0d\u884c\u7684\uff0c\u90a3\u4e48\u52a0\u4e00\u6837\u76842\uff1f\u6539\u621010432\uff0c\u76f8\u5f53\u4e8e3\uff0c2\u90fd+1\n        \u52a01\u5462\uff1f\u6539\u621020431\uff0c\u76f8\u5f53\u4e8e1\uff0c3\uff0c2\u90fd+1\uff0c\u90a3\u4e48\u89c4\u5f8b\u662f\u4ec0\u4e48\u3002\n        \u5982\u679c\u662fD\uff0c\u90a3\u4e48\u53ea\u80fd\u653e<=\u6700\u540e\u4e00\u4e2a\u6570\u7684\u6570\uff0c\u7136\u540e\u628a\u539f\u6765\u6240\u6709>=\u5c3e\u5df4\u7684\u6570\u90fd+1,\u6700\u540e\u4e00\u4e2a\u6570\u5f88\u91cd\u8981\n        \u53cd\u8fc7\u6765\u60f3\uff0c\u5982\u679c\u662fI,\u90a3\u4e48\u53ea\u80fd\u653e>\u6700\u540e\u4e00\u4e2a\u6570\u7684\u6570\uff0c\u7136\u540e\u539f\u6765\u6240\u6709\u7684>=\u65b0\u52a0\u7684\u6570\u90fd+1\n        '''\n        mod = 10 ** 9 + 7\n        n = len(S)\n        \n        @lru_cache(None)\n        def dfs(i, j):  # \u4f4d\u7f6ei\u5904\u6570\u5b57j\u7ed3\u5c3e \u6570\u5b57j\u7684\u8303\u56f4\u662f0-i\n            if i == 0:\n                return 1\n            elif S[i - 1] == 'D':\n                return sum(dfs(i - 1, k) for k in range(j, i)) % mod\n            else:\n                return sum(dfs(i - 1, k) for k in range(j)) % mod\n        return sum(dfs(n, j) for j in range(n + 1)) % mod", "from functools import lru_cache\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10**9+7\n        N = len(S)\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if i==0:\n                return 1\n            elif S[i-1] == 'D':\n                return sum(dp(i-1,k) for k in range(j,i))%MOD\n            else:\n                return sum(dp(i-1,k) for k in range(j))%MOD\n                \n                \n        return sum(dp(N, j) for j in range(N+1))%MOD", "from functools import lru_cache\n\n\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def DP(n, last):\n            if n == 0:\n                return 1\n            if S[n - 1] == 'D':\n                return sum(\n                    DP(n - 1, x - 1)\n                    for x in range(last + 1, n + 1)\n                ) % MOD\n            else:\n                return sum(\n                    DP(n - 1, x)\n                    for x in range(last)\n                ) % MOD\n\n        return sum(\n            DP(len(S), i)\n            for i in range(len(S) + 1)\n        ) % MOD\n", "from functools import lru_cache\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        \n        mod = 10**9+7\n        \n        N = len(S)\n        \n        @lru_cache(None)\n        def dp(i,j):\n            print((i,j))\n            if i==0:\n                return 1\n            elif S[i-1]=='D':\n                return sum(dp(i-1,k) for k in range(j,i))%mod\n            else:\n                return sum(dp(i-1,k) for k in range(j))%mod\n        \n        return sum(dp(N,j) for j in range(N+1))%mod\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        n = len(S)\n        mod = 10**9 + 7\n        # solns[above][below]\n        # if decreasing:\n        # answer = sum solns[above+k][below-k-1]\n        # if increasing:\n        # answer = sum solns[above-k-1][below+k]\n        \n        solns = [[0] * (n+2) for _ in range(n+2)]\n        solns[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(i+1):\n                k = i - j\n                if S[-i] == 'D':\n                    for r in range(0, k):\n                        solns[j][k] += solns[j+r][k-r-1]\n                else:\n                    for r in range(0, j):\n                        solns[j][k] += solns[j-r-1][k+r]\n                solns[j][k] %= mod\n                \n        result = sum(solns[i][n-i] for i in range(n+1))\n        return result % mod\n                \n        \n", "from functools import lru_cache\n\n\nclass Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10 ** 9 + 7\n        \n        def presum(n, last):\n            return sum(\n                DP(n, x)\n                for x in range(last)\n            )\n        \n        @lru_cache(None)\n        def DP(n, last):\n            if n == 0:\n                return 1\n            if S[n - 1] == 'D':\n                return (presum(n - 1, n) - presum(n - 1, last)) % MOD\n            else:\n                return presum(n - 1, last) % MOD\n\n        return sum(\n            DP(len(S), i)\n            for i in range(len(S) + 1)\n        ) % MOD\n", "class Solution:\n    def numPermsDISequence(self, S: str) -> int:\n        MOD = 10**9 + 7\n        N = len(S)\n        \n        dp = [[0]*(N+1) for _ in range(N+1)]\n        \n        def solve(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            if i == 0:\n                return 1\n            if S[i-1] == 'D':\n                dp[i][j] = sum(solve(i-1, k) for k in range(j)) % MOD\n            else:\n                dp[i][j] = sum(solve(i-1, k) for k in range(j, i)) % MOD  \n            \n            return dp[i][j]\n       \n        return sum(solve(N, j) for j in range(N+1)) % MOD\n            \n            \n            \n         \n        \n        \n        \n"]
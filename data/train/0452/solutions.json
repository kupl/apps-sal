["class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if N < d: \n            return -1\n        \n        dp = [jobDifficulty[0]]\n        for j in jobDifficulty[1:]:\n            dp.append(max(dp[-1], j))\n\n        for i in range(1, d):\n            \n            dp_curr = [0] * N\n            \n            stack = []\n            for j in range(i, N):\n                dp_curr[j] = dp[j - 1] + jobDifficulty[j]\n                \n                while stack and jobDifficulty[stack[-1]] <= jobDifficulty[j]:\n                    dp_curr[j] = min(dp_curr[j], dp_curr[stack[-1]] - jobDifficulty[stack[-1]] + jobDifficulty[j])\n                    stack.pop()\n                    \n                if stack:\n                    dp_curr[j] = min(dp_curr[j], dp_curr[stack[-1]]) \n                stack.append(j)\n                \n            dp = dp_curr\n        return dp[-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if N<d: return -1\n        \n        dp = [jobDifficulty[0]]\n        for j in jobDifficulty[1:]:\n            dp.append(max(dp[-1], j))\n\n        for i in range(1, d):\n            stack = []\n            dp2 = [0]*N\n            for j in range(i, N):\n                dp2[j] = dp[j-1]+jobDifficulty[j]\n                while stack and jobDifficulty[stack[-1]]<=jobDifficulty[j]:\n                    dp2[j] = min(dp2[j], dp2[stack[-1]]-jobDifficulty[stack[-1]]+jobDifficulty[j])\n                    # dp2[j] = min(dp2[j], dp[stack[-1]]+jobDifficulty[j])\n                    stack.pop()\n                    \n                if stack:\n                    dp2[j] = min(dp2[j], dp2[stack[-1]])\n                    \n                stack.append(j)\n            dp = dp2\n            # print(dp)\n        return dp[-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        if d == n:\n            return sum(jobDifficulty)\n        \n        dp = {}\n        \n        def moveOnce(d0, difficultyNow, i0):\n            if d0 == d:\n                return max(difficultyNow, max(jobDifficulty[i0:]))\n            if n - i0-1 == d-d0:\n                return max(jobDifficulty[i0], difficultyNow) + sum(jobDifficulty[i0+1:])\n            \n            if (d0, difficultyNow, i0) in dp:\n                return dp[(d0, difficultyNow, i0)]\n            \n            subAns = min(moveOnce(d0, max(jobDifficulty[i0], difficultyNow), i0 + 1), max(jobDifficulty[i0], difficultyNow) + moveOnce(d0+1, jobDifficulty[i0+1], i0+1))\n            \n            dp[(d0, difficultyNow, i0)] = subAns\n            \n            return subAns\n        \n        return moveOnce(1, jobDifficulty[0], 0)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if d > N: return -1\n        memo = [[float('inf')] * (d + 1) for _ in range(N + 1)]\n        memo[0][0] = 0\n        for i in range(1, N + 1):\n            for k in range(1, min(i, d) + 1):\n                maxD = 0\n                for j in range(i - 1, -1, -1):\n                    maxD = max(maxD, jobDifficulty[j])\n                    memo[i][k] = min(memo[i][k], memo[j][k - 1] + maxD)\n        return memo[N][d]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        self.memo = {}\n        self.mxs = []\n        mx = 0\n        for j in jobDifficulty:\n            mx = max(mx, j)\n            self.mxs.append(mx)\n        return self.recurse(jobDifficulty, len(jobDifficulty) - 1, d)\n        \n    def recurse(self, jd, start, remain):\n        # if start == 0:\n        #     return jd[0]\n        if remain == 1:\n            # return max(jd[:start + 1])\n            return self.mxs[start]\n        \n        if (start, remain) in self.memo:\n            return self.memo[(start, remain)]\n        \n        mx = 0\n        mn = float('inf')\n        \n        for j in range(start, 0, -1):\n            curr = jd[j]\n            mx = max(mx, curr)\n            mn = min(mn, mx + self.recurse(jd, j - 1, remain - 1))\n        self.memo[(start, remain)] = mn\n        # print((start, remain), self.memo, mx, mn)\n        return mn", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        n = len(jobDifficulty)\n        \n        n, inf = len(jobDifficulty), float('inf')\n        dp = [[inf] * n + [0] for i in range(d + 1)]\n        for d in range(1, d + 1):\n            for i in range(n - d + 1):\n                maxd = 0\n                for j in range(i, n - d + 1):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\n                \n        return dp[d][0] if dp[d][0] < inf else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n, inf = len(jobDifficulty), float('inf')\n        \n        dp = [[inf] * n + [0] for _ in range(d + 1)]\n        \n        for d in range(1, d + 1):\n            for i in range(n - (d - 1)):\n                maxd = 0\n                for j in range(i, n - (d - 1)):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\n        return dp[d][0] if dp[d][0] < inf else -1", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        n = len(A)\n        \n        if d>n: #more days than job\n            return -1\n        \n        dp = [[math.inf]*(d+1) for _ in range(n)]\n        #dp[i][j] store the ans for jobs i:n with j days remaining\n        \n        for i in range(n-1,-1,-1):\n            for j in range(1,d+1):\n                if n-i<j: #more days than jobs\n                    continue\n                rMax = -math.inf\n                for k in range(i,n-j+1): #if we finish i:k+1 jobs today\n                    rMax=max(rMax,A[k])\n                    if j==1:\n                        dp[i][j]=rMax\n                    else:\n                        dp[i][j] = min(dp[i][j],rMax+dp[k+1][j-1])\n        return dp[0][d]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n     \n        n, inf = len(jobDifficulty), float('inf')\n        dp = [[inf] * n + [0] for i in range(d + 1)]\n        for d in range(1, d + 1):\n            for i in range(n - d + 1):\n                maxd = 0\n                for j in range(i, n - d + 1):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\n        return dp[d][0] if dp[d][0] < inf else -1\n'''\nSolution3: Bottom-up 1D DP\nTime complexity O(nnd)\nSpace complexity O(n)'''", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        # Init the above with padding\n        # dp[k][i] means the min job difficulty when we want to schedule the first i tasks during k days\n        dp = [[float('inf')] * (n + 1) for _ in range(d + 1)]\n        dp[0][0] = 0\n        #max_diff_right = jobDifficulty[n - 1]\n        for k in range(1, d + 1):\n            for i in range(1, n + 1):\n                max_diff_right = 0\n                for j in range(i - 1, k - 2, -1):\n                    # Moving maximum to calculate max in O(1)\n                    max_diff_right = max(max_diff_right, jobDifficulty[j])\n                    dp[k][i] = min(dp[k][i], dp[k - 1][j] + max_diff_right)\n        return dp[d][n]", "# 11:19 - \nclass Solution:\n    def minDifficulty(self, difficulty: List[int], d: int) -> int:\n        # dp[n, d] = dp[n - 1, d - i] + max(n - i, n) \n        if d > len(difficulty):\n            return -1\n        \n        n = len(difficulty)\n        dp = [[float('inf')] * (n + 1) for _ in range(d + 1)]\n        dp[0][0] = 0\n        \n        # dp[i, j]: finish 'j' jobs in 'i' days\n        for i in range(d):\n            for j in range(n):\n                local = float('-inf')\n                for k in range(j, -1, -1):\n                    if k < i:\n                        break\n                    local = max(local, difficulty[k])\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], local + dp[i][k])\n        \n        return dp[d][n] if dp[d][n] != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n: return -1\n        dp = [[float('inf') for _ in range(d+1)] for _ in range(n+1)]\n        dp[0][0] = 0\n        for i in range(1, n+1):  # number of days\n            for k in range(1, d+1):   # number of jobs\n                md = 0\n                for j in range(i-1, k-2, -1):\n                    md = max(md, jobDifficulty[j])\n                    dp[i][k] = min(dp[i][k], dp[j][k-1]+md)\n        return dp[-1][-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty): return -1\n        if not jobDifficulty: return 0\n        dp = [[float('inf') for _ in range(d+1)] for _ in range(len(jobDifficulty)+1)]\n        dp[0][0] = 0                \n        for i in range(1,len(jobDifficulty)+1):\n            for j in range(1,d+1):\n                tmp = 0\n                # k-1 >= j-1\n                for k in range(i,j-1,-1):\n                    tmp = max(tmp,jobDifficulty[k-1])\n                    dp[i][j] = min(dp[i][j], dp[k-1][j-1] + tmp)\n        # print(dp)\n        return dp[-1][-1] if dp[-1][-1] < float('inf') else -1", "# 11:19 - \nclass Solution:\n    def minDifficulty(self, difficulty: List[int], d: int) -> int:\n        # dp[n, d] = dp[n - 1, d - i] + max(n - i, n) \n        if d > len(difficulty):\n            return -1\n        \n        n = len(difficulty)\n        dp = [[float('inf')] * (n + 1) for _ in range(d + 1)]\n        dp[0][0] = 0\n        \n        # dp[i, j]: finish 'j' jobs in 'i' days\n        for i in range(d):\n            for j in range(n):\n                local = float('-inf')\n                for k in range(j, -1, -1):\n                    if k < i:\n                        break\n                    local = max(local, difficulty[k])\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], local + dp[i][k])\n        \n        return dp[d][n]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        cumsum = [0]*len(jobDifficulty)\n        cummax = [[0]*len(jobDifficulty) for _ in range(len(jobDifficulty))]\n        \n        for i in range(len(jobDifficulty)):\n            cumsum[i] = cumsum[i-1] + jobDifficulty[i]\n            for j in range(i, len(jobDifficulty)):\n                cummax[i][j] = max(cummax[i][j-1], jobDifficulty[j])\n                \n        memo = {}\n        \n        @lru_cache        \n        def DFS(s, d):\n            if (s,d) in memo:\n                return memo[s,d]\n            if d > s:\n                memo[s,d] = float('inf')\n            elif d == s:\n                memo[s,d] = cumsum[s-1]\n            elif d == 1:\n                memo[s,d] = cummax[0][s-1]\n            else:\n                memo[s,d] = min(cummax[i][s-1]+DFS(i,d-1) for i in range(1,s))\n            return memo[s,d]\n        \n        res = DFS(len(jobDifficulty), d) \n        return res if res < float('inf') else -1\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jc = len(jobDifficulty)\n        if d > jc: return -1\n        dp = [[-1 for i in range(jc+1)] for i in range(d+1)]\n        dp[1][1] = jobDifficulty[0]\n\n        for i in range(2, jc+1):\n            dp[1][i] = max(dp[1][i-1], jobDifficulty[i-1])\n        \n        for i in range(2, d+1):\n            for j in range(i, jc+1):\n                dp[i][j] = dp[i-1][j-1] + jobDifficulty[j-1]\n                work = jobDifficulty[j-1]\n                for k in range(j-2, i-2, -1):\n                    work = max(jobDifficulty[k], work)\n                    if dp[i-1][k] + work < dp[i][j]:\n                        dp[i][j] = dp[i-1][k] + work\n        return dp[d][jc]\n\n\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        M = 1e6\n        dp = [[M] * (d + 1) for i in range(n + 1)]\n        dp[n][0] = 0\n        dp[n - 1][1] = jobDifficulty[n - 1]\n        for i in range(n - 2, -1, -1):\n            for j in range(1, d + 1):\n                m = -1\n                for k in range(i, n):\n                    m = max(m, jobDifficulty[k])\n                    dp[i][j] = min(dp[i][j], m + dp[k + 1][j - 1])\n        return dp[0][d] if dp[0][d] < M else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        n = len(jobDifficulty)\n        dp = [[float('inf')] * n +[0] for _ in range(d + 1)]\n        \n        for d in range(1, d+1):\n            for i in range(n - d + 1):\n                maxd = 0\n                for j in range(i, n-d+1):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[d][i] = min(dp[d][i], maxd+dp[d-1][j+1])\n        \n        return dp[d][0] if dp[d][0] < float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        cumsum = [0]*len(jobDifficulty)\n        cummax = [[0]*len(jobDifficulty) for _ in range(len(jobDifficulty))]\n        \n        for i in range(len(jobDifficulty)):\n            cumsum[i] = cumsum[i-1] + jobDifficulty[i]\n            for j in range(i, len(jobDifficulty)):\n                cummax[i][j] = max(cummax[i][j-1], jobDifficulty[j])\n                \n        memo = {}\n                \n        \n        \n        @lru_cache()\n        def DFS(s, d):\n            if (s,d) in memo:\n                return memo[s,d]\n            if d > s:\n                memo[s,d] = float('inf')\n            elif d == s:\n                memo[s,d] = cumsum[s-1]\n            elif d == 1:\n                memo[s,d] = cummax[0][s-1]\n            else:\n                memo[s,d] = min(cummax[i][s-1]+DFS(i,d-1) for i in range(1,s))\n            return memo[s,d]\n        \n        res = DFS(len(jobDifficulty), d) \n        return res if res < float('inf') else -1\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        # dp[i][k] means the min job difficulty when we want to schedule the first i tasks during k days\n        dp = [ [float('inf')] * (d + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        # Init the above with padding\n        for i in range(1, n + 1):\n            for k in range(1, d + 1):\n                max_difficulty = 0\n                j = i - 1\n                while j >= k - 1:\n                    #print(max_difficulty)\n                    max_difficulty = max(max_difficulty, jobDifficulty[j])\n                    #print(dp)\n                    dp[i][k] = min(dp[i][k], dp[j][k - 1] + max_difficulty)\n                    j -= 1\n        print(dp)\n        return dp[n][d]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        @lru_cache(maxsize=None)\n        def job_max(i, j):\n            return max(jobDifficulty[i:j])\n        \n        @lru_cache(maxsize=None)\n        def job_sum(i, j):\n            return sum(jobDifficulty[i:j])\n        \n        \n        \n        @lru_cache(maxsize=None)\n        def DFS(s, d):\n            if d > s:\n                return float('inf')\n            if d == s:\n                return job_sum(0, s)\n            if d == 1:\n                return job_max(0, s)\n            \n            return min(job_max(i, s)+DFS(i,d-1) for i in range(1,s))\n        \n        res = DFS(len(jobDifficulty), d) \n        return res if res < float('inf') else -1\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if N < d:\n            return -1\n\n        dp = [[-1] * (d + 1) for _ in range(N)]\n        \n        def dfs(idx, d):\n            if d == 0:\n                if idx == N:\n                    return 0\n                else:\n                    return math.inf\n            \n            if idx == N:\n                return math.inf\n            \n            if dp[idx][d] != -1:\n                return dp[idx][d]\n            \n            res = math.inf\n            day_max = 0\n            \n            for j in range(idx, N):\n                day_max = max(day_max, jobDifficulty[j])\n                res = min(res, day_max + dfs(j + 1, d - 1))\n\n\n            dp[idx][d] = res\n            return res\n        \n        return dfs(0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n\n        self.memo = {}\n        def check(left_days, i):\n            ky = (left_days, i)\n            if ky in self.memo:\n                return self.memo[ky]\n\n            m = n - left_days\n            diff = jobDifficulty[i]\n            mn = float('inf')\n            while i < m:\n                diff = max(diff, jobDifficulty[i])\n                if left_days > 0:\n                    mn = min(mn, diff + check(left_days - 1, i+1))\n                else:\n                    mn = diff\n                i += 1\n            self.memo[ky] = mn\n            return mn\n\n        return check(d-1,0)\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        cumsum = [0]*len(jobDifficulty)\n        cummax = [[0]*len(jobDifficulty) for _ in range(len(jobDifficulty))]\n        \n        for i in range(len(jobDifficulty)):\n            cumsum[i] = cumsum[i-1] + jobDifficulty[i]\n            for j in range(i, len(jobDifficulty)):\n                cummax[i][j] = max(cummax[i][j-1], jobDifficulty[j])\n                \n        \n        @lru_cache(maxsize=None)       \n        def DFS(s, d):\n            if d > s:\n                return float('inf')\n            elif d == s:\n                return cumsum[s-1]\n            elif d == 1:\n                return cummax[0][s-1]\n            else:\n                return min(cummax[i][s-1]+DFS(i,d-1) for i in range(1,s))\n        \n        res = DFS(len(jobDifficulty), d) \n        return res if res < float('inf') else -1\n        \n", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        \n        \n        \n        # my solution ... \n        #  time: O()\n        # space: O()\n        \n        seen = {}\n        def func(sidx, d):  # \u8fd4\u56de\u5728 d \u5929\u5185\u5b8c\u6210 A[sidx:] \u7684\u7ed3\u679c\n            if n-sidx < d:\n                return float('inf')\n            if d == 0:\n                return float('inf') if sidx < n else 0\n            if n-sidx == d:\n                return sum(A[sidx:])\n            if (sidx,d) not in seen:\n                res = float('inf')\n                cmax = A[sidx]\n                for eidx in range(sidx, n):\n                    if cmax < A[eidx]:\n                        cmax = A[eidx]\n                    res = min(res, cmax + func(eidx+1, d-1))\n                seen[sidx,d] = res\n            return seen[sidx,d]\n        n = len(A)\n        if n  < d: return -1\n        if n == d: return sum(A)\n        return func(0, d)\n        \n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        inf = sum(jobDifficulty)\n        mem = {}\n        def dfs(i, d):\n            if (i, d) in mem:\n                return mem[(i, d)]\n            if d == 0:\n                if i == len(jobDifficulty):\n                    mem[(i, d)] = (True, 0)\n                    return True, 0\n                else:\n                    mem[(i, d)] = (False, None)\n                    return False, inf\n            else:\n                success = False\n                min_diff = inf\n                cur_day_diff = 0\n                for end in range(i, len(jobDifficulty)-d+1):\n                    cur_day_diff = max(cur_day_diff, jobDifficulty[end])\n                    next_success, next_diff = dfs(end+1, d-1)\n                    if next_success:\n                        success = True\n                        min_diff = min(min_diff, cur_day_diff+next_diff)\n                mem[(i, d)] = (success, min_diff)\n                return success, min_diff\n        success, min_diff = dfs(0, d)\n        if success:\n            return min_diff\n        else:\n            return -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        '''\n        max_d(i,i+k-1) = \n        \n        dp(i, d_left) = \n        if d_left == 0: \n            return float('inf')\n        if i == len(jobDifficulty)-1:\n            if d_left > 1:\n                return float('inf')\n            else:\n                return jobDifficulty[i]\n        \n        for k in range(1, len(jobDifficulty)-i):\n            res = min(res, dp(i+k, d_left-1) + max_d(i,i+k-1))\n        \n        \n        jobDifficulty = [6,5,4,3,2,1], d = 2\n        '''\n        max_d = [[-1 for _ in range(len(jobDifficulty))] for _ in range(len(jobDifficulty))]\n        for i in range(len(jobDifficulty)):\n            max_d[i][i] = jobDifficulty[i]\n            for j in range(i+1, len(jobDifficulty)):\n                max_d[i][j] = max(jobDifficulty[j], max_d[i][j-1])\n        def dp(i, d_left):\n            if d_left == 0: \n                return float('inf')\n            if d_left == 1: return max_d[i][-1]\n            if i == len(jobDifficulty)-1:\n                if d_left > 1:\n                    return float('inf')\n                else:\n                    return jobDifficulty[i]\n            if (i, d_left) in memo.keys(): return memo[(i, d_left)]\n            res = float('inf')\n            for k in range(1, len(jobDifficulty)-i):\n                res = min(res, dp(i+k, d_left-1) + max_d[i][i+k-1])\n            \n            memo[(i, d_left)] = res\n            return res\n        memo = {}\n        \n        ans = dp(0, d)\n        # print(max_d)\n        # print(memo)\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        dp = [[-1 for _ in range(d+1)] for _ in range(n)]\n        return self.helper(jobDifficulty, n, 0, d, dp)\n    \n    def helper(self, jobDifficulty, n, idx, d, dp):\n        if idx == n and d == 0:\n            return 0\n        if idx == n or d == 0:\n            return float('inf')\n        if dp[idx][d] != -1:\n            return dp[idx][d]\n        minDiff = float('inf')\n        currMax = jobDifficulty[idx]\n        for j in range(idx, n):\n            currMax = max(currMax, jobDifficulty[j])\n            temp = self.helper(jobDifficulty, n, j+1, d-1, dp)\n            minDiff = min(minDiff, temp + currMax)\n        dp[idx][d] = minDiff\n        return minDiff\n", "class Solution:                              \n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        dp = [[float('inf') for _ in range(d+1)] for _ in range(n+1)]\n        dp[0][0] = 0\n        for i in range(1,n+1):\n            for k in range(1,d+1):\n                tmp_max = 0\n                for j in range(i-1,k-2,-1):\n                    tmp_max = max(tmp_max,jobDifficulty[j])\n                    dp[i][k] = min(dp[i][k],dp[j][k-1]+tmp_max)\n        return dp[-1][-1]\n        \n        \n    def minDifficulty_TLE(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(i,n):\n                dp[i][j] = max(jobDifficulty[i:j+1])\n        # print(dp)\n        res = [float('inf')]\n        def search(i,j,val): # i- cut, j - idx\n            if i == d:\n                res[0] = min(res[0],val+(0 if j >= n else dp[j][-1]))\n                return\n            for k in range(j,n):\n                search(i+1,k+1,val+dp[j][k])\n        search(0,0,0)\n        return res[0]\n", "class Solution:\n    def minDifficulty(self, arr: List[int], d: int) -> int:\n        if len(arr)<d:\n            return -1\n        memo = [[None]*(d+1) for _ in range(len(arr)+1)]\n        def dp(jobs, days):\n            if days <0:\n                return -1\n            if memo[jobs][days] is not None:\n                return memo[jobs][days]\n            if jobs < days:\n                memo[jobs][days] = -1\n                return -1\n            if d == 1:\n                memo[jobs][days] = max(arr[:jobs])\n                return max(arr[:jobs])\n            if jobs==days:\n                memo[jobs][days] = sum(arr[:jobs])\n                return sum(arr[:jobs])\n            res = -1\n            rm = arr[jobs-1]\n            for i in range(1, jobs+1):\n                rm = max(rm, arr[jobs-i])\n                temp = dp(jobs-i, days-1)\n                if temp!=-1:\n                    if res == -1:\n                        res = temp + rm\n                    else:\n                        res = min(res, temp+rm)\n            memo[jobs][days] = res\n            return res\n        return dp(len(arr), d)\n    \n#     import functools\n    \n#     def minDifficulty1(self, A, d):\n#         calls = 0\n#         n = len(A)\n#         if n < d: return -1\n\n#         @functools.lru_cache(None)\n#         def dfs(i, d):\n#             nonlocal calls\n#             calls += 1\n#             if d == 1:\n#                 return max(A[i:])\n#             res, maxd = float('inf'), 0\n#             for j in range(i, n - d + 1):\n#                 maxd = max(maxd, A[j])\n#                 res = min(res, maxd + dfs(j + 1, d - 1))\n#             return res\n#         res = dfs(0, d)\n#         print(calls)\n#         return res\n", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        \n        \n        \n        # my solution ... 1272 ms ... 48 % ... 14.8 MB ... 39 %\n        #  time: O(2^n)\n        # space: O(n*d)\n        \n        seen = {}\n        def func(sidx, d):  # \u8fd4\u56de\u5728 d \u5929\u5185\u5b8c\u6210 A[sidx:] \u7684\u7ed3\u679c\n            if sidx == n or d == 0:\n                return 0 if (sidx == n and d == 0) else float('inf')\n            if n-sidx < d:\n                return float('inf')\n            if n-sidx == d:\n                return endsum[sidx]\n            \n            if (sidx, d) not in seen:\n                res = float('inf')\n                curmax = A[sidx]\n                for eidx in range(sidx, n):\n                    if curmax < A[eidx]:\n                        curmax = A[eidx]\n                    res = min(res, curmax + func(eidx+1, d-1))\n                seen[sidx, d] = res\n            return seen[sidx, d]\n        \n        n = len(A)\n        if n  < d: return -1\n        if n == d: return sum(A)\n        endsum = [A[-1]] * n\n        for j in range(n-2, -1, -1):\n            endsum[j] = A[j] + endsum[j+1]\n        return func(0, d)\n        \n        \n", "import functools\nclass Solution:\n\n    def minDifficulty(self, A, d):\n        n = len(A)\n        if n < d: return -1\n\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(A[i:])\n            res, maxd = float('inf'), 0\n            for j in range(i, n - d + 1):\n                maxd = max(maxd, A[j])\n                res = min(res, maxd + dfs(j + 1, d - 1))\n            return res\n        return dfs(0, d)\n\n# class Solution:\n#     def minDifficulty(self, A, d):\n#         \\\"\\\"\\\"\n#         :type jobDifficulty: List[int]\n#         :type d: int\n#         :rtype: int\n#         \\\"\\\"\\\"\n#         self.n = len(A)\n#         self.A = A\n#         if self.n < d: \n#             return -1\n        \n#         return self.dfs(0, d)\n    \n#     @functools.lru_cache(None)\n#     def dfs(self, i, d):\n#         if d == 1:\n#             return max(self.A[i:])\n#         res, maxd = float('inf'), 0\n#         for j in range(i, self.n - d + 1):\n#             maxd = max(maxd, self.A[j])\n#             res = min(res, maxd + self.dfs(j + 1, d - 1))\n#         return res\n\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        elif len(jobDifficulty) == d:\n            return sum(jobDifficulty)\n        \n        matrix = [[0] * len(jobDifficulty) for i in range(len(jobDifficulty))]\n        \n        for i in range(len(jobDifficulty)):\n            for j in range(i,len(jobDifficulty)):\n                if i == j:\n                    matrix[i][j] = jobDifficulty[j]\n                else:\n                    matrix[i][j] = max(matrix[i][j-1], jobDifficulty[j])\n        \n        dp = [[float('inf')] * len(jobDifficulty) for i in range(d)]\n        \n        for i in range(d):\n            for j in range(i,len(jobDifficulty)):\n                if i == 0:\n                    dp[i][j] = matrix[i][j]\n                else:\n                    if j > 0:\n                        dp[i][j] = min([matrix[j-k][j]+dp[i-1][j-k-1] for k in range(0,j)])\n   \n        return dp[-1][-1]", "# 11:19 - \nclass Solution:\n    def minDifficulty(self, difficulty: List[int], d: int) -> int:\n        # dp[n, d] = dp[n - 1, d - i] + max(n - i, n) \n        if d > len(difficulty):\n            return -1\n        \n        n = len(difficulty)\n        dp = [[float('inf')] * (n + 1) for _ in range(2)]\n        dp[1][0] = 0\n        \n        # dp[i, j]: finish 'j' jobs in 'i' days\n        for i in range(d):\n            for j in range(n):\n                dp[i & 1][j + 1] = float('inf')\n                local = float('-inf')\n                for k in range(j, -1, -1):\n                    if k < i:\n                        break\n                    local = max(local, difficulty[k])\n                    dp[i & 1][j + 1] = min(dp[i & 1][j + 1], local + dp[(i + 1) & 1][k])\n        \n        return dp[(d - 1) & 1][-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jD=jobDifficulty\n        day=d\n        self.memo = {}\n        def dp(i,day):\n            if (i,day) not in self.memo:\n                if i < day: self.memo[(i,day)] = float('inf')\n                elif day == 1: self.memo[(i,day)] = max(jD[:i])\n                elif i == day: self.memo[(i,day)] = sum(jD[:i])\n                else:\n                    tmp = jD[i-1]\n                    self.memo[(i,day)] = dp(i-1,day-1) + tmp\n                    for j in range(i-1,day-3,-1):\n                        tmp = max(jD[j-1],tmp)\n                        self.memo[(i,day)] = min(self.memo[(i,day)],dp(j,day-1) + tmp)\n            return self.memo[(i,day)]\n        ans = dp(len(jD),d)\n        return ans if ans!= float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n, inf = len(jobDifficulty), float('inf')\n        \n        dp = [[inf] * n + [0] for _ in range(d + 1)]\n        \n        for d in range(1, d + 1):\n            for i in range(n - (d - 1)):\n                maxd = 0\n                for j in range(i, n - (d - 1)):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\n        print(dp)\n        return dp[d][0] if dp[d][0] < inf else -1", "class Solution:\n    def minDifficulty(self, J: List[int], d: int) -> int:\n        if len(J) < d: return -1\n        \n        dp = {} # (index of day, index of the last finished job)\n        for i,job in enumerate(J):\n            # the base case, all jobs need to be finish in one day\n            dp[0, i] = max(dp.get((0, i-1), 0), job)\n            \n        for i in range(1, d):\n            for j in range(i, len(J)):\n                mx = J[j]\n                for k in range(j, i-1, -1):\n                    mx = max(mx, J[k])\n                    dp[i, j] = min(dp.get((i, j), math.inf), mx + dp[i-1, k-1])\n                \n        return dp[d-1, len(J)-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        dp = {}\n        def helper(i, d):\n            if d == 0 and i == n:\n                return 0\n            if i >= n or d <= 0 or i + d > n:\n                return float('inf')\n            \n            if (i, d) in dp:\n                return dp[(i, d)]\n            \n            cur_max = 0\n            cur_res = float('inf')\n            for j in range(i, n - d + 1):\n                cur_max = max(cur_max, jobDifficulty[j])\n                cur_res = min(cur_res, cur_max + helper(j + 1, d - 1))\n            \n            dp[(i, d)] = cur_res\n            return cur_res\n        \n        res = helper(0, d)\n        return res if res != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jD=jobDifficulty\n        day=d\n        self.memo = {}\n        def dp(i,day):\n            if (i,day) not in self.memo:\n                if i < day: self.memo[(i,day)] = float('inf')\n                elif day == 1: self.memo[(i,day)] = max(jD[:i])\n                elif i == day: self.memo[(i,day)] = sum(jD[:i])\n                else:\n                    tmp = jD[i-1]\n                    self.memo[(i,day)] = dp(i-1,day-1) + tmp\n                    for j in range(i-1,day-3,-1):\n                        tmp = max(jD[j-1],tmp)\n                        self.memo[(i,day)] = min(self.memo[(i,day)],dp(j,day-1) + tmp)\n            return self.memo[(i,day)]\n        return dp(len(jD),d) if dp(len(jD),d) != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        self.memo = {}\n        return self.recurse(jobDifficulty, len(jobDifficulty) - 1, d)\n        \n    def recurse(self, jd, start, remain):\n        # if start == 0:\n        #     return jd[0]\n        if remain == 1:\n            return max(jd[:start + 1])\n        \n        if (start, remain) in self.memo:\n            return self.memo[(start, remain)]\n        \n        mx = 0\n        mn = float('inf')\n        total = float('inf')\n        for j in range(start, 0, -1):\n            curr = jd[j]\n            mx = max(mx, curr)\n            mn = min(mn, mx + self.recurse(jd, j - 1, remain - 1))\n        self.memo[(start, remain)] = mn\n        # print((start, remain), self.memo, mx, mn)\n        return mn", "class Solution:\n    def minDifficulty(self, jD: List[int], d: int) -> int:\n        self.memo = {}\n        def dp(i,day):\n            if (i,day) not in self.memo:\n                if i < day: self.memo[(i,day)] = float('inf')\n                elif day == 1: self.memo[(i,day)] = max(jD[:i])\n                elif i == day: self.memo[(i,day)] = sum(jD[:i])\n                else:\n                    tmp = jD[i-1]\n                    self.memo[(i,day)] = dp(i-1,day-1) + tmp\n                    for j in range(i-1,day-3,-1):\n                        tmp = max(jD[j-1],tmp)\n                        self.memo[(i,day)] = min(self.memo[(i,day)],dp(j,day-1) + tmp)\n            return self.memo[(i,day)]\n        return dp(len(jD),d) if dp(len(jD),d) != float('inf') else -1\n\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        dp = [[-1 for _ in range(d+1)] for _ in range(len(jobDifficulty))]\n        return self.helper(jobDifficulty, 0, d, dp)\n    \n    def helper(self, jobDifficulty, idx, d, dp):\n        if idx == len(jobDifficulty) and d == 0:\n            return 0\n        if idx == len(jobDifficulty) or d == 0:\n            return float('inf')\n        if dp[idx][d] != -1:\n            return dp[idx][d]\n        minDiff = float('inf')\n        currMax = jobDifficulty[idx]\n        for j in range(idx, len(jobDifficulty)):\n            currMax = max(currMax, jobDifficulty[j])\n            temp = self.helper(jobDifficulty, j+1, d-1, dp)\n            minDiff = min(minDiff, temp + currMax)\n        dp[idx][d] = minDiff\n        return minDiff\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        res = [0]\n        dp = {}\n        def helper(i, d):\n            if d == 0 and i == n:\n                return 0\n            if i >= n or d <= 0 or i + d > n:\n                return float('inf')\n            \n            if (i, d) in dp:\n                return dp[(i, d)]\n            \n            cur_max = 0\n            cur_res = float('inf')\n            for j in range(i, n):\n                cur_max = max(cur_max, jobDifficulty[j])\n                cur_res = min(cur_res, cur_max + helper(j + 1, d - 1))\n            \n            dp[(i, d)] = cur_res\n            return cur_res\n        \n        res = helper(0, d)\n        return res if res != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        dp = [[-1 for _ in range(d+1)] for _ in range(n)]\n        return self.helper(jobDifficulty, n, 0, d, dp)\n    \n    def helper(self, jobDifficulty, n, idx, d, dp):\n        if idx == n and d == 0:\n            return 0\n        if idx == n or d == 0:\n            return float('inf')\n        if dp[idx][d] != -1:\n            return dp[idx][d]\n        minDiff = float('inf')\n        currMax = jobDifficulty[idx]\n        for j in range(idx, n):\n            currMax = max(currMax, jobDifficulty[j])\n            temp = self.helper(jobDifficulty, n, j+1, d-1, dp)\n            if temp != float('inf'):\n                minDiff = min(minDiff, temp + currMax)\n        dp[idx][d] = minDiff\n        return minDiff\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        self.memo = {}\n        return self.recurse(jobDifficulty, len(jobDifficulty) - 1, d)\n        \n    def recurse(self, jd, start, remain):\n        # if start == 0:\n        #     return jd[0]\n        if remain == 1:\n            return max(jd[:start + 1])\n        \n        if (start, remain) in self.memo:\n            return self.memo[(start, remain)]\n        \n        mx = 0\n        mn = float('inf')\n        \n        for j in range(start, 0, -1):\n            curr = jd[j]\n            mx = max(mx, curr)\n            mn = min(mn, mx + self.recurse(jd, j - 1, remain - 1))\n        self.memo[(start, remain)] = mn\n        # print((start, remain), self.memo, mx, mn)\n        return mn", "class Solution:\n    def minDifficulty(self, jD: List[int], d: int) -> int:\n        self.memo = {}\n        def dp(i,day):\n            if (i,day) not in self.memo:\n                if i < day: self.memo[(i,day)] = float('inf')\n                elif day == 1: self.memo[(i,day)] = max(jD[:i])\n                elif i == day: self.memo[(i,day)] = sum(jD[:i])\n                else:\n                    tmp = jD[i-1]\n                    self.memo[(i,day)] = dp(i-1,day-1) + tmp\n                    for j in range(i-1,day-3,-1):\n                        tmp = max(jD[j-1],tmp)\n                        self.memo[(i,day)] = min(self.memo[(i,day)],dp(j,day-1) + tmp)\n            return self.memo[(i,day)]\n        return dp(len(jD),d) if dp(len(jD),d) != float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        \n        max_table = [[0]*n for _ in range(n)]\n        for i in range(n):\n            max_table[i][i] = jobDifficulty[i]\n            for j in range(i+1,n):\n                max_table[i][j] = max(max_table[i][j-1], jobDifficulty[j])\n        \n        memo = [[0]*n for _ in range(d)]\n        \n        for j in range(n):\n            memo[0][j] = max_table[0][j]\n        \n        for i in range(1, d):\n            #memo[i][i] = max_table[i][i]\n            for j in range(i,n):\n                memo[i][j] = min(memo[i-1][t] + max_table[t+1][j] for t in range(i-1,j))\n        \n        return memo[-1][-1]\n        \n", "class Solution:\n    def dfs(self, jobDifficulty, start_day, d, memo):\n        if d == 1:\n            return max(jobDifficulty[start_day:])\n\n        if (start_day, d) in memo:\n            return memo[(start_day, d)]\n        \n        min_diff = float('inf')\n        cur_max_diff = 0\n\n        for i in range(start_day, len(jobDifficulty) - d + 1):\n            cur_max_diff = max(cur_max_diff, jobDifficulty[i])\n            min_diff = min(min_diff, cur_max_diff + self.dfs(jobDifficulty, i + 1, d - 1, memo))\n        \n        memo[(start_day, d)] = min_diff\n        return min_diff\n\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n\n        memo = collections.defaultdict(int)\n        return self.dfs(jobDifficulty, 0, d, memo)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        memo = {}\n        def min_difficulty(i, days_left):\n            if (i, days_left) in memo:\n                return memo[i, days_left]\n            \n            if i == len(jobDifficulty):\n                if days_left == 0:\n                    return 0\n                else:\n                    return math.inf\n            if days_left == 1:\n                return max(jobDifficulty[i:])\n            \n            day_cost = 0\n            min_so_far = math.inf\n            for j in range(i, len(jobDifficulty)):\n                day_cost = max(day_cost, jobDifficulty[j])\n                remaining_cost = min_difficulty(j+1, days_left - 1)\n                min_so_far = min(min_so_far, day_cost + remaining_cost)\n                \n            memo[i, days_left] = min_so_far\n            return min_so_far\n        \n        answer = min_difficulty(0, d)\n        if answer == math.inf:\n            return -1\n        else:\n            return answer\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        import functools\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(jobDifficulty[i:])\n            res, maxd = float('inf'), 0\n            for j in range(i, n-d+1):\n                maxd = max(maxd, jobDifficulty[j])\n                res = min(res, maxd + dfs(j+1, d-1))\n            return res\n        return dfs(0, d)", "class Solution:\n    # def minDifficulty(self, A: List[int], d: int) -> int:\n    #     if len(A) < d:\n    #         return -1\n    #     dp = {}\n    #     def diff(i,d,maxVal):\n    #         if i == len(A):\n    #             return 10**9\n    #         if d == 1:\n    #             return max(maxVal, max(A[i:]))\n    #         if (i,d,maxVal) in dp:\n    #             return dp[(i,d,maxVal)]\n    #         maxVal = max(maxVal,A[i])\n    #         dp[(i,d,maxVal)] =  min(diff(i+1,d, maxVal), maxVal+diff(i+1,d-1,0))\n    #         return dp[(i,d,maxVal)]\n    #     return diff(0,d,0)\n    \n    def minDifficulty(self, A: List[int], d: int) -> int:\n        if len(A) < d:\n            return -1\n        dp = {}\n        def dfs(i,d):\n            if d == 1:\n                return max(A[i:])\n            if (i,d) in dp:\n                return dp[(i,d)]\n            minVal = float('inf')\n            maxNow = 0\n            for j in range(i,len(A)-d+1):\n                maxNow = max(maxNow, A[j])\n                minVal = min(minVal,dfs(j+1,d-1)+maxNow)\n            dp[(i,d)] =  minVal\n            return dp[(i,d)]\n        return dfs(0,d)\n    \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        memo = {}\n        def dfs(idx, d):\n            if (idx,d) in memo:\n                return memo[(idx,d)]\n            \n            if d == 1:\n                return max(jobDifficulty[idx:])\n            \n            day_difficulty, total_difficulty = -float('inf'), float('inf')\n            for i in range(idx, len(jobDifficulty) -d + 1):\n                day_difficulty = max(day_difficulty, jobDifficulty[i])\n                total_difficulty = min(total_difficulty, day_difficulty + dfs(i + 1, d - 1))\n            memo[(idx,d)] = total_difficulty\n            return memo[(idx,d)]\n        \n        return dfs(0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        # dp\n        # time: O(n^2 * d)\n        # space: O(nd)\n        \n        # dp[i][j]=min(dp[k][j-1]+max(jobD[k:i]))\n        \n        \n        if len(jobDifficulty)<d:\n            return -1\n        \n        n=len(jobDifficulty)\n        dp=[[float('inf')]*(d+1) for _ in range(n+1)]\n        \n        maxVal={}\n        \n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                maxVal[(i, j)]=max(jobDifficulty[i:j])\n                \n        for i in range(1, n+1):\n            dp[i][1]=max(jobDifficulty[:i])\n            \n        for i in range(1, n+1):\n            for j in range(2, d+1):\n                if i>=j:\n                    for k in range(j-1, i):\n                        dp[i][j]=min(dp[i][j], dp[k][j-1]+maxVal[(k, i)])\n\n        \n        return dp[n][d]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        \n        N = len(jobDifficulty)\n        dp = {}\n        \n        def f(i, n):\n            if N - i == n:\n                return sum(jobDifficulty[i:])\n            \n            if n == 1:\n                return max(jobDifficulty[i:])\n            \n            if (i, n) in dp:\n                return dp[(i, n)]\n            \n            res = None\n            curr = 0\n            \n            for j in range(i, N-n+1):\n                curr = max(curr, jobDifficulty[j])\n                if not res:\n                    res = curr + f(j+1, n-1)\n                else:\n                    res = min(res, curr + f(j+1, n-1))\n            \n            dp[(i, n)] = res\n            return res\n            \n        return f(0, d)", "import functools\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(jobDifficulty[i:])\n            res, maxd = float('inf'), 0\n            for j in range(i, n - d + 1):\n                maxd = max(maxd, jobDifficulty[j])\n                res = min(res, maxd + dfs(j+1, d-1))\n            return res\n        return dfs(0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], D: int) -> int:\n        n = len(jobDifficulty)\n        dp = [[float('inf')]*n+[0] for _ in range(D+1)]\n        for d in range(1,D+1):\n            for i in range(n-d+1):\n                maxd = 0\n                for j in range(i,n-d+1):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[d][i] = min(dp[d][i],maxd+dp[d-1][j+1])\n        return dp[D][0] if dp[D][0]<float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        cache = {}\n        \n        self.helper(jobDifficulty, 0, d, cache)\n        \n        result = cache.get((0, d))\n        return -1 if result is None or result == float('inf') else result\n    \n        \n    def helper(self, jobDifficulty, i, d, cache):\n        if (i, d) in cache:\n            return cache[(i, d)]\n        if i == len(jobDifficulty) and d == 0:\n            return 0\n        if d <= 0 or len(jobDifficulty) - i < d:\n            return float('inf')\n        \n        maxVal = -1\n        cache[(i, d)] = float('inf')\n        for j in range(i, len(jobDifficulty)): \n            maxVal = max(maxVal, jobDifficulty[j])\n            result = maxVal + self.helper(jobDifficulty, j+1, d - 1, cache)\n            cache[(i, d)] = min(cache[(i, d)], result)\n        \n        return cache[(i, d)]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        seen = {}\n\n        def minDifficultyRestOfJobs(start, days_left):\n            \n            if (start, days_left) in seen: return seen[(start, days_left)]\n\n            if len(jobDifficulty[start:]) < days_left:\n                return float('inf')\n\n            if days_left == 1:\n                return max(jobDifficulty[start:])\n            \n            max_difficulty_today, total_difficulty = float('-inf'), float('inf')\n            for job_idx in range(start, len(jobDifficulty)):\n                max_difficulty_today = max(max_difficulty_today, jobDifficulty[job_idx])\n                total_difficulty = min(total_difficulty, max_difficulty_today + minDifficultyRestOfJobs(job_idx+1, days_left-1))\n            \n            seen[(start, days_left)] = total_difficulty\n\n            return total_difficulty\n\n        res = minDifficultyRestOfJobs(0, d)\n        return -1 if res == float('inf') else res   ", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        size = len(jobDifficulty)\n        memoi = [jobDifficulty[0]] * size\n        for i in range(1, size):\n            memoi[i] = max(memoi[i-1], jobDifficulty[i])\n        maxes = {(0, i): memoi[i-1] for i in range(1, size + 1)}\n        def findMax(s, e):\n            if (s, e) in maxes: return maxes[s, e]\n            maxes[s, e] = max(jobDifficulty[s:e])\n            return maxes[s, e]\n        for cut in range(1, d):\n            newMemoi = [float('inf')] * size\n            for end in range(cut, size):\n                for split in range(cut - 1, end):\n                    newMemoi[end] = min(\n                        newMemoi[end],\n                        memoi[split] + findMax(split+1, end+1)\n                    )\n            memoi = newMemoi\n        return memoi[-1] if memoi[-1] != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        \n        def helper(i, d):\n            if i == n and d == 0:\n                return 0\n            if d <= 0 or n - i < d:\n                return float('inf')\n            \n            if (i, d) in memo:\n                return memo[(i, d)]\n            \n            subGroupJobMax = -1\n            memo[(i, d)] = float('inf')\n            for j in range(i, n):\n                subGroupJobMax = max(subGroupJobMax, jobDifficulty[j])\n                result = subGroupJobMax + helper(j+1, d-1)\n                memo[(i, d)] = min(memo[(i, d)], result)\n            return memo[(i, d)]\n            \n        memo = {}\n        ans = helper(0, d)\n        return -1 if ans is None or ans == float('inf') else ans\n            \n", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        n = len(A)\n        \n        if d>n: #more days than job\n            return -1\n        \n        dp = [[math.inf]*(d+1) for _ in range(n)]\n        #dp[i][j] store the ans for jobs i:n with j days remaining\n        \n        for i in range(n-1,-1,-1):\n            for j in range(1,d+1):\n                if n-i<j: #more days than jobs\n                    continue\n                rMax = -math.inf\n                for k in range(i,n-j+1): #if we finish k jobs today\n                    rMax=max(rMax,A[k])\n                    if j==1:\n                        dp[i][j]=rMax\n                    else:\n                        dp[i][j] = min(dp[i][j],rMax+dp[k+1][j-1])\n        return dp[0][d]\n                    \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        @lru_cache(None)\n        def find_schedule(remaining_days, task_start):\n            if remaining_days == 0:\n                return max(jobDifficulty[task_start:])\n            \n            total = float('inf')\n            cur_diff = jobDifficulty[task_start]\n            for i in range(task_start, len(jobDifficulty) - remaining_days):\n                cur_diff = max(cur_diff, jobDifficulty[i])\n                total = min(total, cur_diff + find_schedule(remaining_days - 1, i+1))\n            return total\n        \n        if len(jobDifficulty) < d:\n            return -1\n        return find_schedule(d-1, 0)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        maxTable = [0] * len(jobDifficulty)\n        maxTable[-1] = jobDifficulty[-1]\n        for i in range(len(jobDifficulty)-2,-1,-1):\n            maxTable[i] = max(maxTable[i+1], jobDifficulty[i])\n        \n        def dfs(i, d, visit):\n            if i == len(jobDifficulty):\n                return float('inf')\n            if d == 1:\n                return maxTable[i]\n            if (i, d) in visit:\n                return visit[(i,d)]\n            \n            res = float('inf')\n            cur = 0\n            for j in range(i, len(jobDifficulty)):\n                cur = max(cur, jobDifficulty[j])\n                res = min(res, cur + dfs(j+1, d-1, visit))\n            visit[(i,d)] = res\n            return res\n        return dfs(0,d,{})", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        @lru_cache(None)\n        def dfs(index, days_left, curr_max):\n            if index == N:\n                if days_left == 0:\n                    return curr_max\n                else:\n                    return float('inf')\n            \n            res = float('inf')\n            same_day = dfs(index + 1, days_left, max(curr_max, jobDifficulty[index]))\n            diff_day = dfs(index + 1, days_left - 1, jobDifficulty[index]) + curr_max\n            \n            res = min(same_day, diff_day)\n            \n            return res\n    \n        res = dfs(0, d, 0)\n        \n        if res == float('inf'):\n            return -1\n        else:\n            return res", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        dp = [[float('inf') for _ in range(d + 1)] for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n+1):\n            for k in range(1, d+1):\n                md = 0\n                for j in range(i-1, k-2, -1):\n                    md = max(md, jobDifficulty[j])\n                    dp[i][k] = min(dp[i][k], dp[j][k-1]+md)\n        return dp[n][d]", "class Solution:\n    def minDifficulty(self, jD: List[int], d: int) -> int:\n        if len(jD) < d: return -1\n        memo = {}\n        def dp(memo, jD, i, d): # \u6c42\u89e3mD(jD[i:], d)\n            if len(jD) - i  < d: return -1\n            if d == 1: return max(jD[i:])\n            if (i, d) in memo:\n                return memo[(i, d)]\n            ans, cur = 9999999999, 0\n            for j in range(i, len(jD)): #\u904d\u5386S(D_1)\n                cur = max(cur, jD[j])\n                x = dp(memo, jD, j + 1, d - 1)#\u6838\u5fc3\u4ee3\u7801 md(D_1^{rest}, d-1)\n                if x != -1: \n                    ans = min(ans, cur + x)\n            memo[(i, d)] = ans\n            return ans\n        return dp(memo, jD, 0, d)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        # self.res = sys.maxsize\n        ht = {}\n        res = self.dfs(jobDifficulty, d, ht)\n        if res == sys.maxsize:\n            return -1\n        return res\n    \n    def dfs(self, nums, K, ht):\n        if K == 1:\n            if len(nums) == 0:\n                return sys.maxsize\n            return max(nums)\n        key = (len(nums), K)\n        if key in ht:\n            return ht[key]\n        res = sys.maxsize\n        a = 0\n        for i in range(len(nums)):\n            a = max(a, nums[i])\n            b = self.dfs(nums[i+1:], K-1, ht)\n            if a + b < res:\n                res = a + b\n        ht[key] = res\n        return res\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        MAX = 300 * 1000 * 10\n        N = len(jobDifficulty)\n        cache = {}\n        max_jobDifficulty = []\n        for i in range(0, N):\n            max_ij = [jobDifficulty[i]]\n            for j in range(i+2, N+1):\n                max_ij.append(max(max_ij[-1], jobDifficulty[j-1]))\n            max_jobDifficulty.append(max_ij)\n        def get_max_jobDifficulty(i, j):\n            return max_jobDifficulty[i][j-i-1]\n        def dp(left_days: int, left_jobs_i: int, current_jobs_i: int) -> int:\n            key = (left_days, left_jobs_i, current_jobs_i)\n            if key not in cache:\n                n_left_jobs = N - left_jobs_i\n                if n_left_jobs == 0:\n                    assert left_days > 0\n                    if left_days == 1 and current_jobs_i < left_jobs_i:\n                        cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i)\n                    else:\n                        cost = MAX\n                elif n_left_jobs == left_days:\n                    cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1) + sum(jobDifficulty[(left_jobs_i + 1):])\n                else:\n                    cost = dp(left_days, left_jobs_i + 1, current_jobs_i)\n                    if left_days > 1:\n                        cost = min(cost, dp(left_days - 1, left_jobs_i + 1, left_jobs_i + 1) + get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1))\n                cache[key] = cost\n            return cache[key]\n        ret = dp(d, 0, 0)\n        if ret >= MAX:\n            return -1\n        return ret", "import functools\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d==1:\n                return max(jobDifficulty[i:])\n            res, maxd = float('inf'), 0\n            for j in range(i, n - d + 1):\n                maxd = max(maxd, jobDifficulty[j])\n                res = min(res, maxd + dfs(j + 1, d - 1))\n            return res\n        return dfs(0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        MAX = 300 * 1000 * 10\n        N = len(jobDifficulty)\n        cache = {}\n        max_jobDifficulty = []\n        for i in range(0, N):\n            max_ij = [jobDifficulty[i]]\n            for j in range(i+2, N+1):\n                max_ij.append(max(max_ij[-1], jobDifficulty[j-1]))\n            max_jobDifficulty.append(max_ij)\n        def get_max_jobDifficulty(i, j):\n            return max_jobDifficulty[i][j-i-1]\n        def dp(left_days: int, left_jobs_i: int, current_jobs_i: int) -> int:\n            key = (left_days, left_jobs_i, current_jobs_i)\n            if key not in cache:\n                if left_jobs_i == N:\n                    assert left_days > 0\n                    if left_days == 1 and current_jobs_i < left_jobs_i:\n                        cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i)\n                    else:\n                        cost = MAX\n                else:\n                    cost = dp(left_days, left_jobs_i + 1, current_jobs_i)\n                    if left_days > 1:\n                        cost = min(cost, dp(left_days - 1, left_jobs_i + 1, left_jobs_i + 1) + get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1))\n                cache[key] = cost\n            return cache[key]\n        ret = dp(d, 0, 0)\n        if ret >= MAX:\n            return -1\n        return ret", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        MAX = 300 * 1000 * 10\n        N = len(jobDifficulty)\n        cache = {}\n        max_jobDifficulty = []\n        for i in range(0, N):\n            max_ij = [jobDifficulty[i]]\n            for j in range(i+2, N+1):\n                max_ij.append(max(max_ij[-1], jobDifficulty[j-1]))\n            max_jobDifficulty.append(max_ij)\n        def get_max_jobDifficulty(i, j):\n            return max_jobDifficulty[i][j-i-1]\n        def dp(left_days: int, left_jobs_i: int, current_jobs_i: int) -> int:\n            key = (left_days, left_jobs_i, current_jobs_i)\n            if key not in cache:\n                n_left_jobs = N - left_jobs_i\n                if n_left_jobs == 0:\n                    assert left_days > 0\n                    if left_days == 1 and current_jobs_i < left_jobs_i:\n                        cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i)\n                    else:\n                        cost = MAX\n                elif n_left_jobs == left_days:\n                    cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1) + sum(jobDifficulty[(left_jobs_i + 1):])\n                else:\n                    cost = dp(left_days, left_jobs_i + 1, current_jobs_i)\n                    if left_days > 1:\n                        m = get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1)\n                        if m < cost:\n                            cost = min(cost, dp(left_days - 1, left_jobs_i + 1, left_jobs_i + 1) + m)\n                cache[key] = cost\n            return cache[key]\n        ret = dp(d, 0, 0)\n        if ret >= MAX:\n            return -1\n        return ret", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        MAX = 300 * 1000 * 10\n        N = len(jobDifficulty)\n        cache = {}\n        max_jobDifficulty = []\n        for i in range(0, N):\n            max_ij = [jobDifficulty[i]]\n            for j in range(i+2, N+1):\n                max_ij.append(max(max_ij[-1], jobDifficulty[j-1]))\n            max_jobDifficulty.append(max_ij)\n        def get_max_jobDifficulty(i, j):\n            return max_jobDifficulty[i][j-i-1]\n        def dp(left_days: int, left_jobs_i: int, current_jobs_i: int) -> int:\n            key = (left_days, left_jobs_i, current_jobs_i)\n            if key not in cache:\n                n_left_jobs = N - left_jobs_i\n                if n_left_jobs == 0:\n                    assert left_days > 0\n                    if left_days == 1 and current_jobs_i < left_jobs_i:\n                        cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i)\n                    else:\n                        cost = MAX\n                elif n_left_jobs == left_days:\n                    cost = get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1) + sum(jobDifficulty[(left_jobs_i + 1):])\n                elif n_left_jobs < left_days:\n                    cost = MAX\n                else:\n                    cost = dp(left_days, left_jobs_i + 1, current_jobs_i)\n                    if left_days > 1:\n                        cost = min(cost, dp(left_days - 1, left_jobs_i + 1, left_jobs_i + 1) + get_max_jobDifficulty(current_jobs_i, left_jobs_i + 1))\n                cache[key] = cost\n            return cache[key]\n        ret = dp(d, 0, 0)\n        if ret >= MAX:\n            return -1\n        return ret", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        mem = {}\n        maxMem = {}\n        sumMem = []\n        for i, diff in enumerate(jobDifficulty):\n            if i==0:\n                sumMem.append(diff)\n            else:\n                sumMem.append(sumMem[-1]+diff)\n        \n        def maxHelper(i, j):\n            if (i, j) in maxMem:\n                return maxMem[(i,j)]\n            \n            maxVal = 0\n            for index in range(i, j):\n                if jobDifficulty[index]>maxVal:\n                    maxVal = jobDifficulty[index]\n            maxMem[(i, j)] = maxVal\n            return maxVal\n\n        def helper(jobNum, days):\n            if (jobNum, days) in mem:\n                return mem[(jobNum, days)]\n\n            if jobNum < days:\n                return float('inf')\n\n            elif jobNum == days:\n                minCplx = sumMem[jobNum-1]\n\n            elif days == 1:\n                minCplx = maxHelper(0, jobNum)\n\n            else:\n                minCplx = float('inf')\n                for i in range(days-1, jobNum):\n                    curCplx = helper(i, days-1) + maxHelper(i, jobNum)\n                    if curCplx<minCplx:\n                        minCplx = curCplx\n\n            mem[(jobNum, days)] = minCplx\n            return minCplx\n\n        res = helper(len(jobDifficulty), d)\n        return -1 if res == float('inf') else res\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        mem = {}\n        maxMem = {}\n        \n        def maxHelper(i, j):\n            if (i, j) in maxMem:\n                return maxMem[(i,j)]\n            \n            maxVal = 0\n            for index in range(i, j):\n                if jobDifficulty[index]>maxVal:\n                    maxVal = jobDifficulty[index]\n            maxMem[(i, j)] = maxVal\n            return maxVal\n\n        def helper(jobNum, days):\n            if (jobNum, days) in mem:\n                return mem[(jobNum, days)]\n\n            if jobNum < days:\n                return float('inf')\n\n            elif jobNum == days:\n                minCplx = sum(jobDifficulty[:jobNum])\n\n            elif days == 1:\n                minCplx = maxHelper(0, jobNum)\n\n            else:\n                minCplx = float('inf')\n                for i in range(days-1, jobNum):\n                    curCplx = helper(i, days-1) + maxHelper(i, jobNum)\n                    if curCplx<minCplx:\n                        minCplx = curCplx\n\n            mem[(jobNum, days)] = minCplx\n            return minCplx\n\n        res = helper(len(jobDifficulty), d)\n        return -1 if res == float('inf') else res\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        n = len(jobDifficulty)\n        memo = {}\n        \n        if d > n:\n            return -1\n        if d == n:\n            return sum(jobDifficulty)\n        \n        def dfs(i, diff, days):\n            if i == n:\n                return diff if days == 0 else float('inf')\n            \n            if (i, diff, days) in memo:\n                return memo[(i, diff, days)]\n            \n            max_effort = max(diff, jobDifficulty[i])\n            \n            s1 = max_effort + dfs(i+1, 0, days-1)\n            s2 = dfs(i+1, max_effort, days)\n            \n            memo[(i, diff, days)] = min(s1, s2)\n            \n            return memo[(i, diff, days)]\n        \n        return dfs(0, 0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        dp = {}\n        myIntMax = 10000000\n        \n        def findMinDif(jobIdx, daysLeft):\n            if daysLeft<0:\n                return -1\n            if jobIdx==n and daysLeft>0:\n                return -1\n            if jobIdx==n and daysLeft==0:\n                return 0\n            \n            if str(jobIdx)+str(daysLeft) in dp:\n                return dp[str(jobIdx)+str(daysLeft)]\n            \n            todayDiff = 0 \n            totalDiff = myIntMax\n            \n            for idx in range(jobIdx,n):\n                todayDiff = max(todayDiff, jobDifficulty[idx])\n                nextDiff = findMinDif(idx+1, daysLeft-1)                \n                dp[str(idx+1)+str(daysLeft-1)] = nextDiff\n                \n                if nextDiff != -1:                    \n                    totalDiff = min(totalDiff, todayDiff + nextDiff)\n                else:\n                    break\n                \n            \n            return totalDiff\n        \n        ret = findMinDif(0,d)\n        if ret == myIntMax:\n            return -1\n        else:\n            return ret\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        \n        def dfs(i, d, visit):\n            if i == len(jobDifficulty):\n                return float('inf')\n            if d == 1:\n                return max(jobDifficulty[i:])\n            if (i, d) in visit:\n                return visit[(i,d)]\n            \n            res = float('inf')\n            cur = 0\n            for j in range(i, len(jobDifficulty)):\n                cur = max(cur, jobDifficulty[j])\n                res = min(res, cur + dfs(j+1, d-1, visit))\n            visit[(i,d)] = res\n            return res\n        return dfs(0,d,{})", "from functools import lru_cache\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        \n        dumb = 99999999999\n        lim = len(jobDifficulty)\n        @lru_cache(None)\n        def r(i,day):\n            if day==d-1:return max(jobDifficulty[i:])\n            \n            if i==lim-1 and day<d-1: return dumb\n            \n            else:\n                \n                tmp = []\n                for j in range(i+1,lim):\n                    tmp.append(max(jobDifficulty[i:j])+r(j,day+1))\n\n                return min(tmp)\n        \n        val = r(0,0)\n        if val>dumb:return -1\n        return val", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def helper(st, d):\n            if st == len(jobDifficulty) or d == 0 or len(jobDifficulty) - st < d:\n                return math.inf\n            if d==1:\n                return max(jobDifficulty[st:])\n            mn=float('inf')\n            for i in range(st+1, len(jobDifficulty)-d+2):\n                s = max(jobDifficulty[st:i])+helper(i,d-1)\n                mn = min(s, mn)\n            return mn\n        res = helper(0, d)\n        return res if res!=float('inf') else -1\n                \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        @lru_cache(None)\n        def go(l, day):\n            if l >= n:\n                return math.inf\n            if day == d:\n                return max(jobDifficulty[l:])\n            ans = math.inf\n            for i in range(l, n):\n                ans = min(ans, go(i+1, day+1) + max(jobDifficulty[l:i+1]))\n            return ans\n        return go(0, 1)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def helper(st, d):\n            if d==1:\n                return max(jobDifficulty[st:])\n            mn=float('inf')\n            for i in range(st+1, len(jobDifficulty)-d+2):\n                s = max(jobDifficulty[st:i])+helper(i,d-1)\n                mn = min(s, mn)\n            return mn\n        res = helper(0, d)\n        return res if res!=float('inf') else -1\n                \n", "from functools import lru_cache\nclass Solution:\n    def minDifficulty(self, A, d):\n        # n = len(A)\n        # dp, dp2 = [math.inf] * n, [0] * n\n        # if n < d: return -1\n        # for d in range(d):\n        #     stack = []\n        #     for i in range(d, n):\n        #         dp2[i] = dp[i - 1] + A[i] if i else A[i]\n        #         while stack and A[stack[-1]] <= A[i]:\n        #             j = stack.pop()\n        #             dp2[i] = min(dp2[i], dp2[j] - A[j] + A[i])\n        #         if stack:\n        #             dp2[i] = min(dp2[i], dp2[stack[-1]])\n        #         stack.append(i)\n        #     dp, dp2 = dp2, [0] * n\n        # return dp[-1]\n        \n        n = len(A)\n        if n < d: return -1\n        \n        @lru_cache(None)\n        def dp(n, d):\n\n            if n < d: return math.inf\n            if d == 1: return max(A[:n])          \n            return min(dp(t, d - 1) + max(A[t : n]) for t in range(n))\n        \n        return dp(n, d)\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        @lru_cache(None)\n        def helper(start, d):\n            if len(jobDifficulty) - start < d:\n                return float('inf')\n            if d == 1:\n                return max(jobDifficulty[start:])\n            result = float('inf')\n            for i in range(start, len(jobDifficulty) - d + 1):\n                result = min(result, max(jobDifficulty[start:i+1]) + helper(i+1, d-1))\n            return result\n        result = helper(0, d)\n        return result if result != float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        @lru_cache(None)\n        def helper(i,d):\n            if(d==1):\n                if(len(jobDifficulty)==0):\n                    return float('inf')\n                return max(jobDifficulty[i:])\n            else:\n                m=float('inf')\n                for j in range(i+1,len(jobDifficulty)-d+2):\n                    m=min(max(jobDifficulty[i:j])+helper(j,d-1),m)\n                return m\n        x=helper(0,d)\n        if(x==float('inf')):\n            return -1\n        else:\n            return x\n            \n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        n = len(jobDifficulty)\n        \n        if n < d:\n            return -1\n        \n        dp = [[-1 for i in range(d+1)] for j in range(n)]\n        \n        def helper(i, days):\n\n            nonlocal dp\n\n            if dp[i][days] != -1:\n                return dp[i][days]\n            \n            \n            if days == 1:\n                dp[i][days] = max(jobDifficulty[i:])\n            else:\n                dp[i][days] = min([max(jobDifficulty[i:i+j]) + helper(i+j, days-1) for j in range(1, n-days-i+2)])\n                \n            return dp[i][days]\n        \n        return helper(0, d)\n", "class Solution:\n    def minDifficulty(self, JD: List[int], d: int) -> int:\n        n = len(JD)\n        @lru_cache(None)\n        def dp(i, k):\n            if k == 1 and i!=n: return max(JD[i:])\n            if k == 0 and i == n: return 0\n            if k == 0 or i == n: return math.inf\n            ans = math.inf\n            for j in range(i, n):\n                ans = min(ans, max(JD[i:j+1]) + dp(j+1, k-1))\n            return ans\n        return dp(0, d) if dp(0, d) != math.inf else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        \n        @lru_cache(None)\n        def dp(start, k):\n            \n            if k == 1:\n                return max(jobDifficulty[start:])\n            \n            minvalue = float('inf')\n            for i in range(start+1, n):\n                left = max(jobDifficulty[start:i])\n                right = dp(i, k-1)\n                \n                minvalue = min(minvalue, left+right)\n            \n            return minvalue\n        \n        return dp(0,d)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        mem = {}\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        def get_dp(i, j):\n            if (i, j) not in mem:\n                if j == d:\n                    mem[i, j] = max(jobDifficulty[i:])\n                else:\n                    mem[i, j] = min(max(jobDifficulty[i:i+k]) + get_dp(i+k, j+1) for k in range(1, n-i-d+j+1))\n            return mem[i, j]\n        return get_dp(0, 1)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        def search(jobs: List[int], index: int, d: int) -> int:\n            if len(jobs) - index < d:\n                return -1\n            if (d, index) in memo:\n                return memo[(d, index)]\n            if d == 1:\n                memo[(d, index)] = max(jobs[index:])\n                return memo[(d, index)]\n            result = float('inf')\n            for i in range(index, len(jobs) - d + 1):\n                result = min(result, max(jobs[index: i + 1]) + search(jobs, i + 1, d - 1))\n            memo[(d, index)] = result\n            return result\n        \n        memo = {}\n        return search(jobDifficulty, 0, d)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)        \n        dp=[]\n        for a in range(d+1):\n            dp.append([-1]*(n+1))\n        \n        #print(dp)\n        \n        def helper(jobD, n, d, dp):\n            if n < d:\n                return -1\n            #print(n,d, len(dp))\n            if dp[d][n] != -1:\n                return dp[d][n]\n            if d == n:\n                dp[d][n] = sum(jobD[0:n])\n                return dp[d][n]\n            if d == 1:\n                dp[d][n] = max(jobD[0:n])\n                return dp[d][n]\n            for i in range(1, n):\n                r = helper(jobD, i, d-1, dp)\n                if r != -1:\n                    if dp[d][n] == -1:\n                        dp[d][n] = r + max(jobD[i:n])\n                    else:\n                        dp[d][n] = min(dp[d][n], r + max(jobD[i:n]))\n                    #print(dp[d][n], d, n)\n            return dp[d][n]\n    \n        r =  helper(jobDifficulty, n, d, dp)\n        #print(dp)\n        return r", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1;\n        if d == n:\n            return sum(jobDifficulty)\n        \n        dp=[]\n        for a in range(d+1):\n            dp.append([-1]*(n+1))\n        \n        #print(dp)\n        \n        def helper(jobD, n, d, dp):\n            if n < d:\n                return -1\n            #print(n,d, len(dp))\n            if dp[d][n] != -1:\n                return dp[d][n]\n            if d == n:\n                dp[d][n] = sum(jobD[0:n])\n                return dp[d][n]\n            if d == 1:\n                dp[d][n] = max(jobD[0:n])\n                return dp[d][n]\n            for i in range(1, n):\n                r = helper(jobD, i, d-1, dp)\n                if r != -1:\n                    if dp[d][n] == -1:\n                        dp[d][n] = r + max(jobD[i:n])\n                    else:\n                        dp[d][n] = min(dp[d][n], r + max(jobD[i:n]))\n                    #print(dp[d][n], d, n)\n            return dp[d][n]\n    \n        r =  helper(jobDifficulty, n, d, dp)\n        #print(dp)\n        return r", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        n = len(jobs)\n        dp = [[math.inf] * n for _ in range(d)]\n        \n        max_job = 0\n        for job in range(n):\n            max_job = max(max_job, jobs[job])\n            dp[0][job] = max_job\n        \n        for day in range(1, d):\n            for last_job in range(day, n):\n                dp[day][last_job] = min(\n                    (dp[day - 1][first_job - 1] + max(jobs[first_job:last_job + 1])\n                    for first_job in range(day, last_job + 1)),\n                    default=math.inf\n                )\n        \n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1", "\nimport functools\n\n\nclass Solution:\n\n    def minDifficulty(self, A, d):\n        if len(A) < d:\n            return -1\n\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(A[i:])\n            res = float('inf')\n            max_cost_current_day = 0\n            for j in range(i, len(A) - d + 1):\n                # i'm percorring the array and trying all possibilites\n                # the cost of a day is the max task on it\n                max_cost_current_day = max(max_cost_current_day, A[j])\n                # res = current_day_cost + others_days cost\n                res = min(res, max_cost_current_day + dfs(j + 1, d - 1))\n            return res\n        return dfs(0, d)\n", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        n = len(jobs)\n        dp = [[math.inf] * n for _ in range(d)]\n        \n        max_job = 0\n        for job in range(n):\n            max_job = max(max_job, jobs[job])\n            dp[0][job] = max_job\n        \n        for day in range(1, d):\n            for last_job in range(day, n):\n                dp[day][last_job] = min(\n                    dp[day - 1][first_job - 1] + max(jobs[first_job:last_job + 1])\n                    for first_job in range(day, last_job + 1)\n                )\n        \n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        if n == d:\n            return sum(jobDifficulty)\n        \n        dp = [[float('inf')] * (n + 1) for _ in range(d + 1)]\n        for i in range(1, n + 1):\n            dp[1][i] = max(jobDifficulty[:i])\n            \n        for _d in range(2, d + 1):\n            for i in range(_d, n + 1):\n                for j in range(_d - 1, i):\n                    dp[_d][i] = min(dp[_d][i], dp[_d - 1][j] + max(jobDifficulty[j:i]))\n                    \n        return dp[d][n]", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        n = len(jobs)\n        dp = [[math.inf] * n for _ in range(d)]\n        \n        max_job = 0\n        for job in range(n):\n            max_job = max(max_job, jobs[job])\n            dp[0][job] = max_job\n        \n        for day in range(1, d):\n            for job in range(day, n):\n                cur = math.inf\n                for prev in range(day, job + 1):\n                    max_job = max(jobs[prev:job+1])\n                    cur = min(cur, dp[day - 1][prev - 1] + max_job)\n                dp[day][job] = cur\n        \n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty, d):\n        '''\n        :type jobDifficulty: List[int]\n        :type d: int\n        :rtype: int\n        '''\n        njobs = len(jobDifficulty)\n        if njobs < d: return -1\n\n        dp = [[float('inf')] * njobs for _ in range(d)]\n        # base case - complete first j jobs using 1 day\n        for j in range(njobs):\n            dp[0][j] = max(jobDifficulty[:j+1])\n\n        for i in range(1, d):\n            for j in range(i, njobs):\n                for k in range(i, j+1):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k-1] + max(jobDifficulty[k:j+1]))\n        return dp[d-1][njobs-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        size = len(jobDifficulty)\n        memoi = [jobDifficulty[0]] * size\n        for i in range(1, size):\n            memoi[i] = max(memoi[i-1], jobDifficulty[i])\n        for cut in range(1, d):\n            newMemoi = [float('inf')] * size\n            for end in range(cut, size):\n                for split in range(cut - 1, end):\n                    newMemoi[end] = min(\n                        newMemoi[end],\n                        memoi[split] + max(jobDifficulty[split+1:end+1])\n                    )\n            memoi = newMemoi\n        return memoi[-1] if memoi[-1] != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        # two dimensional dp\n        # dp[m][n]  n<=m   the best solution when there are m+1 jobs in n+1 days\n        # dp[m][n] =min(dp[j][n-1] + max(jobDifficulty[j+1:m+1]))  n-1<= j <= m-1\n        \n        if len(jobDifficulty) < d:\n            return -1\n        dp= [[0 for i in range(d)] for j in range(len(jobDifficulty))]\n        for j in range(len(jobDifficulty)):\n            dp[j][0] = max(jobDifficulty[:j+1])\n        for day in range(1,d):\n            for i in range(day,len(jobDifficulty)):\n                dpValue = sum(jobDifficulty)\n                for j in range(day-1,i):\n                    dpValue  = min(dpValue, dp[j][day-1]+max(jobDifficulty[j+1:i+1]))\n                dp[i][day] = dpValue\n        return dp[len(jobDifficulty)-1][d-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty, d):\n        '''\n        :type jobDifficulty: List[int]\n        :type d: int\n        :rtype: int\n        '''\n        njobs = len(jobDifficulty)\n        if njobs < d: return -1\n\n        dp = [[float('inf')] * njobs for _ in range(d)]\n        # base case\n        for j in range(njobs):\n            dp[0][j] = max(jobDifficulty[:j+1])\n\n        for i in range(1, d):\n            for j in range(i, njobs):\n                for k in range(i, j+1):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k-1] + max(jobDifficulty[k:j+1]))\n        return dp[d-1][njobs-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        #0928\n        #dp(i,k)=\u5230jobDifficulty[i]\u4e3a\u6b62\u7684job\uff08\u5171i+1\u4e2a\uff09\uff0c\u4f7f\u7528k\u5929\u5b8c\u6210\u7684 minimum difficulty \n        if len(jobDifficulty)<d:\n            return -1\n        dp = [[10000]*(d+1) for i in range(len(jobDifficulty ))]\n        dp[0][1]=jobDifficulty[0]\n        for i in range(len(jobDifficulty)):\n            for k in range(1,d+1):\n                # print(\\\"i,\\\",i,\\\"k,\\\",k)\n                if k==1:\n                    dp[i][k]=max(jobDifficulty[:i+1])\n                    continue\n                if k > i+1 or (i==0 and k==1):\n                    # print(\\\"continue\\\")\n                    continue\n                mind=10000\n                for j in range(0, i):\n                    # print(\\\"j=\\\",j,dp[j][k-1])\n                    mind=min(dp[j][k-1]+max(jobDifficulty[j+1:i+1]), mind)\n                    # print(\\\"mind\\\",mind)\n                dp[i][k]=mind\n        print(dp)\n        return dp[-1][-1]\n        \n", "class Solution:\n    def dfs(self, jobDifficulty, start_day, d, memo):\n        if d == 1:\n            return max(jobDifficulty[start_day:])\n\n        if (start_day, d) in memo:\n            return memo[(start_day, d)]\n        \n        min_diff = float('inf')\n\n        for i in range(start_day, len(jobDifficulty) - d + 1):\n            min_diff = min(min_diff, max(jobDifficulty[start_day:i+1]) + self.dfs(jobDifficulty, i + 1, d - 1, memo))\n        \n        memo[(start_day, d)] = min_diff\n        return min_diff\n\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n\n        memo = collections.defaultdict(int)\n        return self.dfs(jobDifficulty, 0, d, memo)", "class Solution:\n    \n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n       \n        llen = len(jobDifficulty)\n        if d>llen:\n            return -1\n        if llen==1:\n            return jobDifficulty[0]\n        dct = [[float('inf') for _ in range(d+1)] for _ in range(llen+1)]\n \n            \n     \n                \n        \n        for i in range(1, llen+1):\n            for j in range(1,d+1):\n                if j == 1:\n                    dct[i][1] = max(jobDifficulty[:i])\n                    continue\n                elif i < j:\n                    continue\n                for k in range(1,i):\n                    dct[i][j] = min(dct[i][j], dct[k][j-1]+max(jobDifficulty[k:i]))\n                    \n        return dct[llen][d]\n                    \n                    \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        \n        self.cache = {}\n        return self.helper(jobDifficulty, d, 0)\n        \n    def helper(self, jobDifficulty: List[int], d: int, start: int) -> int:\n        if d == 1:\n            return max(jobDifficulty[start:])\n        \n        if (d, start) not in self.cache:\n            self.cache[(d, start)] = min(\n                [\n                    max(jobDifficulty[start:end]) + self.helper(jobDifficulty, d-1, end) \n                    for end in range(start+1, len(jobDifficulty)-d+2)\n                ]\n            )\n        \n        return self.cache[(d, start)]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        # @lru_cache(None)\n        # def helper(start, d):\n        #     if len(jobDifficulty) - start < d:\n        #         return float('inf')\n        #     if d == 1:\n        #         return max(jobDifficulty[start:])\n        #     result = float('inf')\n        #     for i in range(start, len(jobDifficulty) - d + 1):\n        #         result = min(result, max(jobDifficulty[start:i+1]) + helper(i+1, d-1))\n        #     return result\n        # result = helper(0, d)\n        # return result if result != float('inf') else -1\n        if len(jobDifficulty) < d:\n            return -1\n        dp = [[float('inf')] * (d + 1) for _ in range(len(jobDifficulty))]\n        tempmax = 0\n        for i, job in enumerate(jobDifficulty):\n            tempmax = max(tempmax, job)\n            dp[i][1] = tempmax\n        for day in range(2, d+1):\n            for j in range(day-1, len(jobDifficulty)+1):\n                result = float('inf')\n                for k in range(j-1):\n                    result = min(result, dp[k][day-1] + max(jobDifficulty[k+1:j]))\n                dp[j-1][day] = result\n        return dp[-1][-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        \n        return self.topdown(jobDifficulty, d, 0, {})\n    \n    def topdown(self, job, d, index, memo):\n        if d <=0:\n            return flot('inf')\n        \n        if d == 1:\n            if index < len(job):\n                return max(job[index:])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d,index)]\n        \n        minDiff = float('inf')\n        \n        for i in range(index, len(job)):\n            minDiff = min(minDiff, self.topdown(job, d-1, i+1, memo) + max(job[index:i+1]))\n        \n        memo[(d, index)] = minDiff\n        \n        return minDiff\n        \n", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        if len(jobs) < d:\n            return -1\n        \n        return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty): return -1\n        m = len(jobDifficulty)\n        dp = [float('inf') for _ in range(m)]\n        dp[0] = jobDifficulty[0]\n        for i in range(1, m): dp[i] = max(dp[i - 1], jobDifficulty[i])\n        for i in range(1, d):\n            for j in range(m - 1, i - 1, -1):\n                dp[j] = float('inf')\n                val = 0\n                for k in range(j, i - 1, -1):\n                    val = max(jobDifficulty[k], val)\n                    dp[j] = min(dp[j], dp[k - 1] + val)\n        # print(dp)\n        return dp[-1]\n", "class Solution:\n    \n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n       \n        llen = len(jobDifficulty)\n        if d>llen:\n            return -1\n        if llen==1:\n            return jobDifficulty[0]\n        dct = [[float('inf') for _ in range(d+1)] for _ in range(llen+1)]\n \n            \n            \n        for i in range(1,llen+1):\n            dct[i][1] = max(jobDifficulty[:i])\n                \n        \n        for i in range(2, llen+1):\n            for j in range(2,d+1):\n                for k in range(1,i):\n                    dct[i][j] = min(dct[i][j], dct[k][j-1]+max(jobDifficulty[k:i]))\n                    \n        return dct[llen][d]\n                    \n                    \n", "class Solution:\n    \n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        l = jobDifficulty\n        llen = len(l)\n        if d>llen:\n            return -1\n        if llen==1:\n            return l[0]\n        dct = [[float('inf') for _ in range(d+1)] for _ in range(llen+1)]\n \n            \n            \n        for i in range(1,llen+1):\n            dct[i][1] = max(l[:i])\n                \n        \n        for i in range(2, llen+1):\n            for j in range(2,d+1):\n                for k in range(1,i):\n                    dct[i][j] = min(dct[i][j], dct[k][j-1]+max(l[k:i]))\n                    \n        return dct[llen][d]\n                    \n                    \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int: \n        if len(jobDifficulty) < d:\n            return -1 \n        return self.top_down(jobDifficulty, d, 0, {})\n    \n    def top_down(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index:])\n            return float('inf')\n        if (d, index) in memo:\n            return memo[(d, index)]\n        min_diff = float('inf')\n        for i in range(index, len(jobs)):\n            min_diff = min(min_diff, self.top_down(jobs, d-1, i+1, memo) + max(jobs[index:i+1]))\n        memo[(d, index)] = min_diff\n        return min_diff", "'''\nTime Complexity : O(n * d) where n = len(jobs)\n'''\nclass Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        if len(jobs) < d:\n            return -1\n        \n        return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        #This should never be the case as we schedule all\n        #the rest of jobs on d = 1\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            #if we still have some jobs on d = 1\n            if index < len(jobs):\n                return max(jobs[index: ])\n            #If left with no job, we violate \\\"atleast a task every day\\\"\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        #Each day allocate jobs from 0-th index to i-th index,so\n        #difficulty for that day is max(jobs[index:i+1]), then\n        #recurse for d-1 days and jobs[i+1:]\n        #Finally, see which combination gives the minimum difficulty\n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        \n        return mindiff\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        dp = [[math.inf for i in range(n)] for j in range(d)]\n        for i in range(n):\n            if i == 0:\n                dp[0][0] = jobDifficulty[i]\n            else:\n                dp[0][i] = max(dp[0][i-1], jobDifficulty[i])\n        for i in range(1,d):\n            for j in range(i,n):\n                for k in range(j):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k]+max(jobDifficulty[k+1:j+1]))\n        #print(dp)\n        return dp[-1][-1]\n                \n#         def go(l, day):\n#             if l >= n:\n#                 return math.inf\n#             if day == d:\n#                 return max(jobDifficulty[l:])\n#             ans = math.inf\n#             for i in range(l, n):\n#                 ans = min(ans, go(i+1, day+1) + max(jobDifficulty[l:i+1]))\n#             return ans\n#         return go(0, 1)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jobs = len(jobDifficulty)\n        if jobs < d:\n            return -1\n        \n        opt = [[float('inf')] * jobs for _ in range(d)]\n        opt[0][0] = jobDifficulty[0]\n        for i in range(1, min(jobs, d)):\n            opt[i][i] = opt[i-1][i-1] + jobDifficulty[i]\n        for i in range(1, jobs):\n            opt[0][i] = max(opt[0][i-1], jobDifficulty[i])\n        \n        for k in range(1, jobs):\n            for i in range(1, d):\n                for x in range(1, k-i+2):  # k-x >= i-1\n                    opt[i][k] = min(opt[i][k], \n                                   opt[i-1][k-x] + max(jobDifficulty[k-x+1: k+1]))\n        return opt[d-1][jobs-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jobs = len(jobDifficulty)\n        if jobs < d:\n            return -1\n        \n        opt = [[float('inf')] * jobs for _ in range(d)]\n        opt[0][0] = jobDifficulty[0]\n        for i in range(1, min(jobs, d)):\n            opt[i][i] = opt[i-1][i-1] + jobDifficulty[i]\n        for i in range(1, jobs):\n            opt[0][i] = max(opt[0][i-1], jobDifficulty[i])\n        print(opt)\n        \n        for k in range(1, jobs):\n            for i in range(1, d):\n                for x in range(1, k-i+2):  # k-x >= i-1\n                    opt[i][k] = min(opt[i][k], \n                                   opt[i-1][k-x] + max(jobDifficulty[k-x+1: k+1]))\n        print(opt)\n        return opt[d-1][jobs-1]", "from typing import List\n\n\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n\n        memo = {}\n\n        def top_down(days_remaining, current_job_index):\n            if days_remaining <= 0:\n                return float('inf')\n            if current_job_index >= len(jobDifficulty):\n                return float('inf')\n            if days_remaining == 1:\n                return max(jobDifficulty[current_job_index:])\n            if (days_remaining, current_job_index) in memo:\n                return memo[(days_remaining, current_job_index)]\n            min_cost = float('inf')\n            for next_job_index in range(current_job_index+1, len(jobDifficulty)):\n                min_cost = min(min_cost, max(\n                    jobDifficulty[current_job_index:next_job_index])+top_down(days_remaining-1, next_job_index))\n            memo[(days_remaining, current_job_index)] = min_cost\n            return min_cost\n\n        min_cost = top_down(d,0)\n        return min_cost if min_cost != float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int: \n        n = len(jobDifficulty)\n        if n < d:\n            return -1 \n        memo = {}\n        \n        def top_down(subsets_remaining, index):\n            nonlocal jobDifficulty, n, memo\n            if subsets_remaining <= 0:\n                return float('inf')\n            if subsets_remaining == 1:\n                if index < n:\n                    return max(jobDifficulty[index:])\n                return float('inf')\n            if (subsets_remaining, index) in memo:\n                return memo[(subsets_remaining, index)]\n            min_difficulty = float('inf')\n            for i in range(index, n):\n                current_max = max(jobDifficulty[index:i+1])\n                remaining_difficulty = top_down(subsets_remaining-1, i+1)\n                min_difficulty = min(min_difficulty, current_max + remaining_difficulty)\n            memo[(subsets_remaining, index)] = min_difficulty\n            return min_difficulty\n    \n        return top_down(d, 0)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        \n        return self.topDown(jobDifficulty, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff\n", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        if len(jobs) < d:\n            return -1\n        \n        return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        \n        return self.topDown(jobDifficulty, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        dp = [[float('inf') for i in range(len(jobDifficulty))] for j in range(d)]\n        for i in range(len(jobDifficulty)):\n            dp[0][i] = max(jobDifficulty[:i+1])\n        for i in range(1,d):\n            for j in range(i,len(jobDifficulty)):\n                for k in range(j):\n                    dp[i][j] = min(dp[i][j],dp[i-1][k]+max(jobDifficulty[k+1:j+1]))\n        return dp[-1][-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return - 1\n        \n        last_day_max_efforts = [[float('inf')] * len(jobDifficulty) for _ in range(d)]\n        \n        last_day_max_efforts[0][0] = jobDifficulty[0]\n        for i in range(1, len(jobDifficulty)):\n            last_day_max_efforts[0][i] = max(last_day_max_efforts[0][i - 1], jobDifficulty[i])\n        \n        for day in range(1, d):\n            for current_split in range(day, len(jobDifficulty)):\n                for last_split in range(current_split):\n                    last_day_max_efforts[day][current_split] = min(last_day_max_efforts[day][current_split], last_day_max_efforts[day - 1][last_split] + max(jobDifficulty[last_split + 1:current_split + 1]))\n        \n        return last_day_max_efforts[d - 1][len(jobDifficulty) - 1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jobs = jobDifficulty\n        \n        if len(jobs) < d:\n            return -1\n        \n        return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff\n", "from queue import PriorityQueue\n#[11, 111, 22,  222, 33,  333,44,444]\nclass Solution:\n    def getminSum(self,jobDifficulty, d,memo,start,end ):\n        #print (d,start,end)\n        if (start,end,d) in memo:\n            return memo[(start,end,d)]\n        if d == 1:\n            return max(jobDifficulty[start:end+1])\n        if end-start + 1 == 1:\n            return -1\n        #one split\n        minSum= -1\n        for i in range(start+1,end+1):\n            part1 = max(jobDifficulty[start:i])\n            \n            part2 = self.getminSum(jobDifficulty,d-1,memo,i,end)\n            if part2 == -1:\n                continue \n            if minSum == -1:\n                minSum = part1 + part2\n            else:\n                minSum = min(minSum, part1+part2)\n        \n        memo[(start,end,d)] = minSum\n        #print(d, memo)\n        return minSum\n        \n    \n    def minDifficulty(self, jobDifficulty, d) -> int:\n        \n        memo = {}\n        start = 0\n        end = len(jobDifficulty)-1\n        result = self.getminSum(jobDifficulty, d,memo, start,end)\n        print (memo)\n        return result\n\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        jobs = jobDifficulty\n        \n        if len(jobs) < d:\n            return -1\n        \n        return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff\n", "import numpy as np\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        dp = np.zeros((n,d+1))\n        if d>n:\n            return -1\n        \n        def rdp(i,j):\n            if dp[i,j]==0:\n                if j <= n-i:\n                    if j==1:\n                            dp[i,j] = max(jobDifficulty[i:])\n                    else:\n                            dp[i,j] = min([max(jobDifficulty[i:k])+rdp(k,j-1) for k in range(i+1,n)])\n                else:\n                    dp[i,j] = float('inf')\n\n            return dp[i,j]\n\n        return  int(rdp(0,d))     \n                    \n", "import numpy as np\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        dp = np.zeros((n,d+1))\n        if d>n:\n            return -1\n        \n        def rdp(i,j):\n            if dp[i,j]==0:\n                if j <= n-i:\n                    if j==1:\n                            dp[i,j] = max(jobDifficulty[i:])\n                    else:\n                            dp[i,j] = min([max(jobDifficulty[i:k])+rdp(k,j-1) for k in range(i+1,n)])\n                else:\n                    dp[i,j] = float('inf')\n            \n            return dp[i,j]\n\n        return  int(rdp(0,d))  \n", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        if d>len(jobs):\n            return -1\n        elif d==len(jobs):\n            summ=0\n            for x in jobs:\n                summ+=x\n            return summ\n        else:\n            return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        # if len(jobs) - index + 1 < d:\n        #     return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        \n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def helper(jobs, d):\n            if d==1:\n                return max(jobs)\n            mn=float('inf')\n            for i in range(1, len(jobs)-d+2):\n                s = max(jobs[:i])+helper(jobs[i:],d-1)\n                mn = min(s, mn)\n            return mn\n        res = helper(tuple(jobDifficulty), d)\n        return res if res!=float('inf') else -1\n                \n", "class Solution:\n    def minDifficulty( self, jobDifficulty: List[ int ], d: int ) -> int:\n        num_jobs = len( jobDifficulty )\n        if num_jobs < d:\n            return -1\n        \n        # The dp cache only keeps the best value up to that point for that number of days\n        # This can be further optimized to only need two arrays since we only look at the previous row\n        dp = [ [ -1 for _ in range( num_jobs ) ] for _ in range( d ) ]\n        \n        # First day everything is just the max up to that point\n        max_so_far = -math.inf\n        for job in range( num_jobs ):\n            max_so_far = max( max_so_far, jobDifficulty[ job ] )\n            dp[ 0 ][ job ] = max_so_far\n        \n        # Now do the rest\n        for day in range( 1, d ):\n            # In order to determine best difficulty, keep monotonic decreasing stack of difficulties\n            # This will retain useful information up to each value and remove the need to loop backwards\n            stack = []\n            for job in range( day, num_jobs ): # Must be at least as many days as jobs\n                # This value on its own plus the best of the previous\n                dp[ day ][ job ] = dp[ day - 1 ][ job - 1 ] + jobDifficulty[ job ]\n                # Keep stack in decreasing order\n                while stack and jobDifficulty[ stack[ -1 ] ] <= jobDifficulty[ job ]:\n                    index = stack.pop() \n                    dp[ day ][ job ] = min( dp[ day ][ job ], dp[ day ][ index ] - jobDifficulty[ index ] + jobDifficulty[ job ] )\n                if stack:\n                    dp[ day ][ job ] = min( dp[ day ][ job ], dp[ day ][ stack[ -1 ] ])\n                \n                stack.append( job )\n\n        return dp[ -1 ][ -1 ]\n        \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if d > N: return -1\n        memo = [[float('inf')] * (d + 1) for _ in range(N + 1)]\n        memo[0][0] = 0\n        for i in range(1, N + 1):\n            for k in range(1, min(i, d) + 1):\n                memo[i][k] = min(memo[j][k - 1] + max(jobDifficulty[j:i]) for j in range(i - 1, -1, -1))\n        return memo[N][d]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        size = len(jobDifficulty)\n        memoi = [jobDifficulty[0]] * size\n        for i in range(1, size):\n            memoi[i] = max(memoi[i-1], jobDifficulty[i])\n        maxes = {(0, i): memoi[i-1] for i in range(1, size + 1)}\n        findMax = lambda s, e: maxes.setdefault((s, e), max(jobDifficulty[s:e]))\n        for cut in range(1, d):\n            newMemoi = [float('inf')] * size\n            for end in range(cut, size):\n                for split in range(cut - 1, end):\n                    newMemoi[end] = min(\n                        newMemoi[end],\n                        memoi[split] + findMax(split+1, end+1)\n                    )\n            memoi = newMemoi\n        return memoi[-1] if memoi[-1] != float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        if len(jobs) < d:\n            return -1\n        \n        return self.topDown(jobs, d, 0, {})\n    \n    def topDown(self, jobs, d, index, memo):\n        \n        if d <= 0:\n            return float('inf')\n        \n        if len(jobs) - index + 1 < d:\n            return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n        if (d, index) in memo:\n            return memo[(d, index)]\n        \n        mindiff = float('inf')\n        \n        for i in range(index, len(jobs)):\n            mindiff = min(mindiff, self.topDown(jobs, d - 1, i + 1, memo) + max(jobs[index : i + 1]))\n        memo[(d, index)] = mindiff\n        return mindiff\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        def f(i,j, cache):\n            if i==0:\n                return 0 if j<0 else float('inf')\n            if j<0: return float('inf')\n            m=float('inf')\n            if (i,j) in cache: return cache[(i,j)]\n            for k in range(j+1):\n                today=max(jobDifficulty[k:j+1])\n                rest=f(i-1,k-1, cache)\n                total=today+rest\n                m=min(m, total)\n            #print(i,j,m)\n            cache[(i,j)] = m\n            return m\n        sol=f(d, len(jobDifficulty)-1, {})\n        return -1 if sol==float('inf') else sol", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        MAX = 300 * 1000 * 10\n        N = len(jobDifficulty)\n        cache = {}\n        def dp(left_days: int, left_jobs_i: int, current_jobs_i: int) -> int:\n            key = (left_days, left_jobs_i, current_jobs_i)\n            if key not in cache:\n                if left_jobs_i == N:\n                    assert left_days > 0\n                    if left_days == 1 and current_jobs_i < left_jobs_i:\n                        cost = max(jobDifficulty[current_jobs_i:left_jobs_i])\n                    else:\n                        cost = MAX\n                else:\n                    cost = dp(left_days, left_jobs_i + 1, current_jobs_i)\n                    if left_days > 1:\n                        cost = min(cost, dp(left_days - 1, left_jobs_i + 1, left_jobs_i + 1) + max(jobDifficulty[current_jobs_i:(left_jobs_i + 1)]))\n                cache[key] = cost\n            return cache[key]\n        ret = dp(d, 0, 0)\n        if ret >= MAX:\n            return -1\n        return ret", "class Solution:\n    def minDifficulty(self, job_dif, d: int) -> int:\n        len_job = len(job_dif)\n        if d > len_job: return -1\n        len_job += 1\n        dp = [[float('inf')] * (d + 1) for _ in range(len_job)]\n        job_dif = [0] + job_dif\n        dp[0][0] = 0\n        \n        for i in range(1, len_job):\n            for k in range(1, min(i+1, d+1)):\n                for j in range(k, i+1):\n                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + max(job_dif[j:i+1]))\n        return dp[-1][-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        dp = [[float('inf')]*(d+1) for _ in range(n+1)]\n        dp[0][0] = 0\n        \n        for i in range(1,n+1):\n            for j in range(1,d+1):\n                for h in range(j-1,i):\n                    dp[i][j] = min(dp[i][j],dp[h][j-1] + max(jobDifficulty[h:i]) )\n        return dp[n][d] if dp[n][d]!=float('inf') else -1\n", "import sys\n\nclass Solution:\n    def minDifficulty(self, complexity: List[int], days: int) -> int:\n        if not complexity:\n           return 0\n        if len(complexity) < days:\n           return -1\n        m = days\n        n = len(complexity)\n        dp = [[sys.maxsize] * (n) for _ in range(m)]\n\n        cur_max = complexity[0]\n        for j in range(n):\n           cur_max = max(complexity[j], cur_max)\n           dp[0][j] = cur_max\n\n        for i in range(1, m):\n           for j in range(0, n):\n               for k in range(0, j):\n                   cur_max = max(complexity[k+1: j+1])\n                   dp[i][j] = min(dp[i][j], dp[i-1][k] + cur_max)\n\n        # print(dp)\n        return dp[-1][-1]\n\n\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty)<d: return -1\n        @lru_cache(None)\n        def dfs(i,d):\n            if d==1: return(max(jobDifficulty[i:]))\n            maxd, res = 0, float('inf')\n            for j in range(i,len(jobDifficulty)-d+1):\n                maxd = max(maxd, jobDifficulty[j])\n                res =  min(res,maxd+dfs(j+1,d-1))\n            return res\n        return dfs(0,d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if d > N: return -1\n        memo = [[float('inf')] * (d + 1) for _ in range(N + 1)]\n        memo[0][0] = 0\n        for i in range(1, N + 1):\n            for k in range(1, min(i, d) + 1):\n                memo[i][k] = min(memo[j][k - 1] + max(jobDifficulty[j:i]) for j in range(i - 1, -1, -1))\n                # maxD = 0\n                # :\n                #     maxD = max(maxD, jobDifficulty[j])\n                #     memo[i][k] = min(memo[i][k], memo[j][k - 1] + maxD)\n        return memo[N][d]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if N<d: return -1\n        dp = [[float('inf')]*(N+1) for _ in range(d+1)]\n        dp[0][0] = 0\n        for i in range(1, d+1):\n            for j in range(i, N+1):\n                for k in range(i-1, j):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k]+max(jobDifficulty[k:j]))\n                    \n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        elif d == n:\n            return sum(jobDifficulty)\n        else:            \n            '''\n                1. can only do job i if job[0] ~ job[i-1] are done\n                2. if cur job is t(i), we can put t(i+1) ~ t(j - 1) into the same day while t(i + 1) ~ t(j - 1) are all smaller than t(i)\n                3. if t(j) >= t(i), then we must make a choice\n                4. should we start from the end of the jobs? \n                    -> should be the same\n                5. this should be a knapsack problem. \n                    -> for each day and each task, should we do it in the cur day? or the next day?                \n                    -> and there will be the same node -> need memo\n                    -> can we do bottom up?\n                    \n                6. \n                    dateIndex = 0 ~ (d - 1)\n                    jobStartIndex = 0 ~ (n - 1)           \n                    \n                    dp[i][j]: the min cost at day i, job j                    \n                    dp[i][j] = min(today's cost + future cost)\n                                = min( \n                                        only do job-j: \n                                            jobDifficulty[j] + dp[i + 1][j + 1]\n                                        do job-j, job-j + 1:\n                                            max(jobDifficulty[j], jobDifficulty[j + 1]) + dp[i + 1][j + 2]                                        \n                                        ...\n                                        \n                                        do max(jobDifficulty[j],..., jobDifficulty[n - 1]) + dp[i + 1][n]                                        \n                                        )\n                    so we need to do i + 1 first and j + 1 first            \n            '''\n            n = len(jobDifficulty)\n            dp = dict()\n            for d in range(0, d + 1):\n                dp[d] = dict()                     \n                for j in range(0, n + 1):\n                    dp[d][j] = float('inf')\n            \n            dp[d][n] = 0\n                            \n            for i in range(d - 1, -1, -1):                                                           \n                for j in range(n - 1, i - 1, -1):                    \n                    for k in range(j, n): #do job j ~ k, k = j ~ n - 1, so the next day start from job k + 1\n                        futureCost = dp[i + 1][k + 1]\n                        todayCost = max(jobDifficulty[j:k + 1])                                       \n                        #print([i, j, k])                                                                                                   \n                        dp[i][j] = min(dp[i][j], todayCost + futureCost)                    \n                                                                    \n            return dp[0][0]\n                    \n", "class Solution:\n    def minDifficulty(self, jobs: List[int], d: int) -> int:\n        if d > len(jobs):\n            return -1\n        memo = {}\n        return self.findjob(jobs, d, 0, memo)\n    def findjob(self, jobs, d, index, memo):\n        if d <= 0:\n            return float('inf')\n        if d == 1:\n            if index < len(jobs):\n                return max(jobs[index: ])\n            return float('inf')\n\n        if (d, index) in memo:\n            return memo[(d, index)]\n\n        mini = float('inf')\n        for i in range(index, len(jobs)):\n            mini = min(mini, self.findjob(jobs, d-1, i+1, memo) + max(jobs[index : i+1]))\n        memo[(d, index)]  = mini\n        return mini\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        dp = [[float('inf')]*(N+1) for _ in range(d+1)]\n        dp[0][0] = 0\n        for i in range(1, d+1):\n            for j in range(i, N+1):\n                for k in range(i-1, j):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k]+max(jobDifficulty[k:j]))\n                    \n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        dp = [[float('inf') for col in range(d+1)] for row in range(n+1)]\n        dp[0][0] = 0\n        for i in range(1, 1+n):\n            for k in range(1, 1+d):\n                for j in range(i, k-1, -1):\n                    dp[i][k] = min(dp[i][k], dp[j-1][k-1]+max(jobDifficulty[j-1:i]))\n        return dp[-1][-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n: return -1\n        dp = [[float('inf') for _ in range(d+1)] for _ in range(n+1)]\n        dp[0][0] = 0\n        for i in range(1, n+1):  # number of jobs, convert to index is i-1\n            for k in range(1, d+1):   # number of days\n                for j in range(i-1, k-2, -1): # j is job index: i-1 -> k-1\n                    dp[i][k] = min(dp[i][k], dp[j][k-1]+max(jobDifficulty[j:i]))\n                    #\u524dj\u4e2ajob, k-1\u5929 + i-j\u4e2ajob\u7684max\n        return dp[-1][-1]\n", "from functools import lru_cache\n\n\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n\n        @lru_cache(None)        \n        def helper(i, d):\n            nonlocal jobDifficulty, n\n            \n            if i >= n and d != 0:\n                return float('inf')\n            if d == 1:\n                return max(jobDifficulty[i:])\n            \n            \n            max_till_now = float('-inf')\n            ans = float('inf')\n\n            for j in range(i, n - d + 1):\n                max_till_now = max(max_till_now, jobDifficulty[j])\n                ans = min(ans, max_till_now + helper(j + 1, d - 1))\n            return ans\n        \n        return helper(0, d)", "class Solution:\n    def minDifficulty(self, jobsd: List[int], d: int) -> int:\n        @lru_cache(maxsize=None)\n        def cut(st, days):\n            if st == len(jobsd) or days == 0 or len(jobsd) - st < days:\n                return math.inf\n            if days == 1:\n                return max(jobsd[st:])\n            maxsofar, res = -math.inf, math.inf\n            for i in range(st, len(jobsd)-1):\n                maxsofar = max(maxsofar, jobsd[i])\n                res = min(res, maxsofar + cut(i+1, days-1))\n            return res\n        res = cut(0, d)\n        return -1 if res == math.inf else res\n", "class Solution:\n    def minDifficulty(self, jobsd: List[int], d: int) -> int:\n        @lru_cache(maxsize=None)\n        def cut(st, days):\n            if st == len(jobsd) or days == 0 or len(jobsd) - st < days:\n                return math.inf\n            if days == 1:\n                return max(jobsd[st:])\n            maxsofar, res = -math.inf, math.inf\n            for i in range(st, len(jobsd)-1):\n                maxsofar = max(maxsofar, jobsd[i])\n                res = min(res, maxsofar + cut(i+1, days-1))\n            return res\n        res = cut(0, d)\n        return -1 if res == math.inf else res\n                \n", "import functools\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d: return -1\n\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(jobDifficulty[i:])\n            res, maxd = float('inf'), 0\n            for j in range(i, n - d + 1):\n                maxd = max(maxd, jobDifficulty[j])\n                res = min(res, maxd + dfs(j + 1, d - 1))\n            return res\n        return dfs(0, d)", "class Solution:\n\n    def minDifficulty(self, jobsd: List[int], d: int) -> int:\n        @lru_cache(maxsize=None)\n        def cut(st, days):\n            if st == len(jobsd) or days == 0 or len(jobsd) - st < days:\n                return math.inf\n            if days == 1:\n                return max(jobsd[st:])\n            maxsofar, res = -math.inf, math.inf\n            for i in range(st, len(jobsd)-1):\n                maxsofar = max(maxsofar, jobsd[i])\n                res = min(res, maxsofar + cut(i+1, days-1))\n            return res\n        res = cut(0, d)\n        return -1 if res == math.inf else res\n", "import functools\nclass Solution:\n\n    def minDifficulty(self, A, d):\n        n = len(A)\n        if n < d: return -1\n\n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(A[i:])\n            res, maxd = float('inf'), 0\n            for j in range(i, n - d + 1):\n                maxd = max(maxd, A[j])\n                res = min(res, maxd + dfs(j + 1, d - 1))\n            return res\n        return dfs(0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        dp = [0]+[float('inf')]*N\n        \n        for i in range(1, d+1):\n            dp2 = [float('inf')]*(N+1)\n            \n            stack = []\n            # print(\\\"\\\")\n            for j in range(i, N+1-d+i):\n                # print(\\\"i:\\\", i, \\\"dp2:\\\", dp2, \\\", stack:\\\", stack)\n                curr_max = jobDifficulty[j-1]\n                if i==1:\n                    dp2[j] = max(jobDifficulty[:j])\n                else:\n                    dp2[j] = dp[j-1]+curr_max\n                    \n                while stack and stack[-1][1]<=curr_max:\n                    dp2[j] = min(dp2[j], dp2[stack[-1][0]]-stack[-1][1]+curr_max)\n                    stack.pop()\n                    \n                if stack and dp2[stack[-1][0]]<dp2[j]:\n                    dp2[j] = dp2[stack[-1][0]]\n                    curr_max = stack[-1][1]\n                \n                stack.append((j, curr_max))\n            dp = dp2\n        return dp[N] if dp[N]!=float('inf') else -1    \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def helper(st, d):\n            if st == len(jobDifficulty) or d == 0 or len(jobDifficulty) - st < d:\n                return math.inf\n            if d==1:\n                return max(jobDifficulty[st:])\n            mn, mx=float('inf'), float('-inf')\n            for i in range(st+1, len(jobDifficulty)-d+2):\n                mx = max(mx, jobDifficulty[i-1])\n                s = mx+helper(i,d-1)\n                mn = min(s, mn)\n            return mn\n        res = helper(0, d)\n        return res if res!=float('inf') else -1\n                \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        # @lru_cache(None)\n        # def helper(start, d):\n        #     if len(jobDifficulty) - start < d:\n        #         return float('inf')\n        #     if d == 1:\n        #         return max(jobDifficulty[start:])\n        #     result = float('inf')\n        #     for i in range(start, len(jobDifficulty) - d + 1):\n        #         result = min(result, max(jobDifficulty[start:i+1]) + helper(i+1, d-1))\n        #     return result\n        # result = helper(0, d)\n        # return result if result != float('inf') else -1\n        if len(jobDifficulty) < d:\n            return -1\n        dp = [[float('inf')] * (d + 1) for _ in range(len(jobDifficulty))]\n        tempmax = 0\n        for i, job in enumerate(jobDifficulty):\n            tempmax = max(tempmax, job)\n            dp[i][1] = tempmax\n        for day in range(2, d+1):\n            for j in range(day-1, len(jobDifficulty)):\n                result = float('inf')\n                tempmax = 0\n                for k in range(j, day-3, -1):\n                    tempmax =  max(tempmax, jobDifficulty[k])\n                    result = min(result, dp[k-1][day-1] + tempmax)\n                dp[j][day] = result\n        # print(dp)\n        return dp[-1][-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if d > n:\n            return -1\n        difficulties = [[0] * n for _ in range(n)]\n        for i in range(n):\n            difficulties[i][i] = jobDifficulty[i]\n            for j in range(i+1,n):\n                difficulties[i][j] = max(difficulties[i][j - 1], jobDifficulty[j])\n        #print(difficulties)\n        dp = [[float('inf')] * (d + 1) for _ in range(n)]\n        for i in range(n):\n            dp[i][1] = difficulties[0][i]\n            for p in range(2, d + 1):\n                for j in range(i):\n                    dp[i][p] = min(dp[i][p], dp[j][p - 1] + difficulties[j+1][i])\n        #print(dp)\n        return dp[n - 1][d]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        memo= {}\n        n = len(jobDifficulty)\n        for i in range(n):\n            for j in range(i,n):\n                if i==j:\n                    memo[(i,j)]=jobDifficulty[i]\n                else:\n                    memo[(i,j)]=max(memo[(i,j-1)],jobDifficulty[j])\n        if n<d:\n            return -1\n        @lru_cache(None)\n        def dfs(i,d):\n            \n            if d == 1:\n                return memo[(i,n-1)]\n            res = float('inf')\n            for j in range(i, n - d + 1):\n                res = min(res, memo[(i,j)]+ dfs(j + 1, d - 1))\n            return res\n        return dfs(0,d)\n                    \n", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def recursive(self, i, k):\n    if k == 1:\n      return max(self.x[i:])\n    m, ans = self.x[i], float('inf')\n    for j in range(i + 1, self.n + 2 - k):\n      ans = min(ans, m + self.recursive(j, k - 1))\n      m = max(m, self.x[j])\n    return ans\n  def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n    # split the array into d subarray, want to minimize sum(max(subarrays))\n    self.x, self.n = jobDifficulty, len(jobDifficulty)\n    if self.n < d:\n      return -1\n    self.recursive.cache_clear()\n    return self.recursive(0, d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        elif len(jobDifficulty) == d:\n            return sum(jobDifficulty)\n        \n        matrix = [[0] * len(jobDifficulty) for i in range(len(jobDifficulty))]\n        \n        for i in range(1,len(jobDifficulty)+1):\n            for j in range(len(jobDifficulty)):\n                if i+j-1 >= len(jobDifficulty):\n                    continue\n                matrix[j][i+j-1] = max(jobDifficulty[i+j-1],matrix[j][i+j-2] if i >1 else 0)\n        \n        dp=[[float('inf')]*(len(jobDifficulty)+1) for i in range(d+1)]\n        \n        for i in range(1,d+1):\n            for j in range(1,len(jobDifficulty)+1):\n                if i==1:\n                    dp[i][j]=matrix[0][j-1]\n                elif j>1:\n                    dp[i][j]=min([dp[i-1][j-k]+matrix[j-k+1-1][j-1] for k in range(1,j)])\n                    \n        return dp[-1][-1]", "class Solution:\n    def _tmp(self):\n        jd = jobDifficulty\n        inf = 1e9\n        l = len(jd)\n        \n        if l < d:\n            return -1\n        \n        @functools.lru_cache(None)\n        def dfs(i, d):\n            if d == 1:\n                return max(jd[i:])\n            mind = inf\n            maxd = 0\n            for j in range(i, l - d + 1):\n                maxd = max(maxd, jd[j])\n                mind = min(mind, maxd + dfs(j + 1, d - 1))\n            return mind\n        \n        return dfs(0, d)\n    \n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jd = jobDifficulty\n        inf = 1e9\n        l = len(jd)\n        if l < d:\n            return -1\n        opt = [[0] * (l - d_) + [inf] * (d_) for d_ in range(d)]\n        \n        #for r in opt:\n        #    print(r)\n        #print()\n        \n        for i in range(d):\n            for j in range(l - i):\n                if i == 0:\n                    opt[i][j] = max(jd[j:])\n                    continue\n                maxc = 0\n                mino = inf\n                for k in range(j, l - i):\n                    maxc = max(maxc, jd[k])\n                    mino = min(mino, maxc + opt[i - 1][k + 1])\n                opt[i][j] = mino\n        \n        #for r in opt:\n        #    print(r)\n        \n        return opt[d - 1][0]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        m=len(jobDifficulty)\n        if m == 0 or d == 0 or d > m:\n            return -1\n        fmax = [[0]*m for _ in range(m)]    #fmax[i][j]: max of [i ~ j], inclusive index\n        fdm = [[None]*m for _ in range(d+1)]    #fdm[di][mi]: di days end on mi_th job, fdm[1][mi] means day one finish on mi_th job \n        for i in range(m):\n            for delta in range(m-i):\n                if delta == 0:\n                    fmax[i][i+delta] = jobDifficulty[i]\n                else:\n                    fmax[i][i+delta] = max(fmax[i][i+delta-1], jobDifficulty[i+delta])\n        \n        for mi in range(m):\n            fdm[1][mi] = fmax[0][mi]    #fdm[1][mi] means day one finish on mi_th job , so it's the max from [0 ~ mi]\n        \n        for di in range(2, d+1):  #deduce next possible minimal, and find fmd(d, m) finally, \n            for mi in range(di-1, m-d+di):\n                for ki in range(di-2, mi):\n                    if not fdm[di][mi]:\n                        fdm[di][mi] = fdm[di-1][ki] + fmax[ki+1][mi]\n                    else:\n                        fdm[di][mi] = min(fdm[di][mi], fdm[di-1][ki] + fmax[ki+1][mi])    # ki range in [di-2 ~ mi)\n\n\n        return fdm[d][m-1]\n", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        n = len(A)\n        dp, dp2 = [float('inf')] * n, [0] * n\n        if n < d: return -1\n        for d in range(d):\n            stack = []\n            for i in range(d, n):\n                dp2[i] = dp[i - 1] + A[i] if i else A[i]\n                while stack and A[stack[-1]] <= A[i]:\n                    j = stack.pop()\n                    dp2[i] = min(dp2[i], dp2[j] - A[j] + A[i])\n                if stack:\n                    dp2[i] = min(dp2[i], dp2[stack[-1]])\n                stack.append(i)\n            dp, dp2 = dp2, [0] * n\n        return dp[-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        if not jobDifficulty or len(jobDifficulty)<d: return -1\n        \n        @lru_cache(None)\n        def dp(start, rem):\n            \n            if rem==0:\n                return 0 if start >= len(jobDifficulty) else math.inf\n            if start >= len(jobDifficulty):\n                return 0 if rem == 0 else math.inf\n            \n            maxDiff = -math.inf\n            minDiff = math.inf\n            \n            for i in range(start, len(jobDifficulty)):\n                maxDiff = max(maxDiff, jobDifficulty[i])\n                minDiff = min(minDiff, maxDiff+dp(i+1, rem-1))\n            \n            return minDiff\n        \n        ans = dp(0, d)\n        return ans if ans != math.inf else -1\n        \n        # [6,5,4,3,2,1] d=2\n", "class Solution:\n    def minDifficulty(self, jd: List[int], d: int) -> int:\n        jd_len = len(jd)\n        if d > jd_len: return -1\n        \n        hidp = [0] * jd_len  \n        hidp[-1] = jd[-1]\n        for i in range(jd_len - 2, -1, -1):\n            hidp[i] = max(jd[i], hidp[i + 1])        \n        \n        dp = [{} for i in range(d)]\n        \n        def find_min(idx:int, _d:int) -> int:\n            cache = dp[_d]\n            if idx in cache: return cache[idx]\n            \n            score = float('inf')\n            if _d == 0:\n                score = hidp[idx]\n            else:    \n                hi = 0\n                for i in range(idx, jd_len - _d):\n                    hi = max(hi,jd[i])                     \n                    score = min(score, hi + find_min(i+1,_d - 1))\n            cache[idx] = score         \n            return score\n        res = find_min(0, d - 1)\n        return res", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty) < d:\n            return -1\n        \n        @lru_cache(None)\n        def dfs(index, d):\n            if index == len(jobDifficulty) and d == 0:\n                return 0\n            \n            if d == 0 and index < len(jobDifficulty):\n                return float('inf')\n            \n            temp = float('inf')\n            curr = 0\n            for i in range(index, len(jobDifficulty)):\n                curr = max(curr, jobDifficulty[i])\n                temp = min(temp, curr + dfs(i + 1, d - 1))\n            \n            return temp\n        \n        return dfs(0, d)", "class Solution:\n    def minDifficulty(self, jd: List[int], d: int) -> int:\n        n = len(jd)\n        if n < d: return -1\n        dp= [[0] * n for _ in range(d)]\n        dp[0][0] = jd[0]\n        for i in range(1, n):\n            dp[0][i] = max(jd[i], dp[0][i-1])\n        for i in range(1, d):\n            for j in range(i, n):\n                dp[i][j] = float('inf')\n                curMax = jd[j]\n                for r in range(j, i-1, -1):\n                    curMax = max(curMax, jd[r])\n                    dp[i][j] = min(dp[i][j], dp[i-1][r-1] + curMax)\n    \n        return dp[d-1][n-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        @lru_cache(maxsize=None)\n        def helper(i, d):\n            if d == 1:\n                return max(jobDifficulty[i::])\n            if len(jobDifficulty)-i < d or d == 0:\n                return -1\n            if len(jobDifficulty)-i == d:\n                return sum(jobDifficulty[i::])\n            tans = 2**64\n            max_d = jobDifficulty[i]\n            for j in range(0, len(jobDifficulty)-i-d+1):\n                max_d = max(max_d, jobDifficulty[i+j])\n                tans = min(helper(i+j+1, d-1)+max_d, tans)\n            return tans                \n        return helper(0, d)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty): return -1\n        m = len(jobDifficulty)\n        dp = [[float('inf') for _ in range(m)] for _ in range(d)]\n        for i in range(0, d):\n            if i == 0:\n                val = jobDifficulty[0]\n                for j in range(m - d + i + 1):\n                    val = max(jobDifficulty[j], val)\n                    dp[i][j] = val\n            else:\n                for j in range(i, m - d + i + 1):\n                    val = jobDifficulty[j]\n                    for k in range(j - 1, i - 2, -1):\n                        val = max(jobDifficulty[k + 1], val)\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + val)\n        # print(dp)\n        return dp[-1][-1]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        grid = [[-1]*n for i in range(d)]\n        M = sum(jobDifficulty)\n        \n        m = 0\n        for i in reversed(range(len(grid[0]))):\n            m = max(jobDifficulty[i], m)\n            grid[0][i] = m\n            \n        for i in range(1, d):\n            for j in reversed(range(len(grid[i-1]))):\n                m = jobDifficulty[j]\n                tmp = M\n                got = False\n                for k in range(j+1, len(grid[i-1])):\n                    # print(i, j, k)\n                    if grid[i-1][k] > -1:\n                        tmp = min(m+grid[i-1][k], tmp)\n                        got = True\n                    m = max(jobDifficulty[k], m)\n                if got:\n                    grid[i][j] = tmp\n\n\n                        \n        # print(grid)\n        \n        return grid[-1][0]                ", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if d > N: return -1\n        memo = [[float('inf')] * (d + 1) for _ in range(N + 1)]\n        memo[0][0] = 0\n        for i in range(1, N + 1):\n            maxD = 0\n            for j in range(i - 1, -1, -1):\n                maxD = max(maxD, jobDifficulty[j])\n                for k in range(1, min(i, d) + 1):\n                    memo[i][k] = min(memo[i][k], memo[j][k - 1] + maxD)\n        return memo[N][d]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        dp = [0]+[float('inf')]*N\n        \n        for i in range(1, d+1):\n            dp2 = [float('inf')]*(N+1)\n            stack = []\n            for j in range(i, N+1-d+i):\n                curr_max = jobDifficulty[j-1]\n                if i==1:\n                    dp2[j] = max(jobDifficulty[:j])\n                else:\n                    dp2[j] = dp[j-1]+curr_max\n                    \n                while stack and stack[-1][1]<=curr_max:\n                    dp2[j] = min(dp2[j], dp2[stack[-1][0]]-stack[-1][1]+curr_max)\n                    stack.pop()\n                    \n                if stack and dp2[stack[-1][0]]<dp2[j]:\n                    dp2[j] = dp2[stack[-1][0]]\n                    curr_max = stack[-1][1]\n                \n                stack.append((j, curr_max))\n            dp = dp2\n        return dp[N] if dp[N]!=float('inf') else -1    \n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if d > len(jobDifficulty):\n            return -1\n        \n        dp = [[0] * (len(jobDifficulty)) for _ in range(d)]\n        \n        dp[0][0] = jobDifficulty[0]\n        for i in range(1,len(jobDifficulty)):\n            dp[0][i] = max(dp[0][i-1], jobDifficulty[i])\n\n        for di in range(1, d):\n            for j in range(di, len(jobDifficulty)):\n                localMax = jobDifficulty[j];\n                dp[di][j] = 10*1000 + 1;\n                for r in range(j, di-1, -1):\n                    localMax = max(localMax, jobDifficulty[r]);\n                    dp[di][j] =  min(dp[di][j], dp[di-1][r-1] + localMax);\n                #dp[di][j] = jobDifficulty[j - 1] + dp[di - 1][j-1]\n        return dp[-1][-1]\n    \n    #int localMax = jobDifficulty[j];\n    #            dp[i][j] = Integer.MAX_VALUE;\n    #            for(int r = j; r >= i; r--){\n    #                localMax = Math.max(localMax,jobDifficulty[r]);\n    #                dp[i][j] =  Math.min(dp[i][j],dp[i-1][r-1] + localMax);\n    #            }class Solution {\n    #public int minDifficulty(int[] jobDifficulty, int d) {\n        \n#\\t\\tint n = jobDifficulty.length; \n #       if(n < d) return -1;\n#        int[][] dp = new int[d][n];\n#        \n#        dp[0][0] = jobDifficulty[0];\n#        for(int i = 1; i < n; i++){\n#            dp[0][i] = Math.max(jobDifficulty[i],dp[0][i-1]);\n#        }\n        \n#        for(int i = 1; i < d; i++){\n#            for(int j = i; j < n; j++){\n#                int localMax = jobDifficulty[j];\n#                dp[i][j] = Integer.MAX_VALUE;\n#                for(int r = j; r >= i; r--){\n#                    localMax = Math.max(localMax,jobDifficulty[r]);\n#                    dp[i][j] =  Math.min(dp[i][j],dp[i-1][r-1] + localMax);\n#                }\n#            }\n#        }\n        \n#        return dp[d-1][n-1];\n#    }\n#}\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        A = jobDifficulty\n        n, inf = len(A), float('inf')\n        if n < d: return -1\n        dp = [inf] * n + [0]\n        for d in range(1, d + 1):\n            for i in range(n - d + 1):\n                maxd, dp[i] = 0, inf\n                for j in range(i, n - d + 1):\n                    maxd = max(maxd, A[j])\n                    dp[i] = min(dp[i], maxd + dp[j + 1])\n        return dp[0]", "# 11:19 - \nclass Solution:\n    def minDifficulty(self, difficulty: List[int], d: int) -> int:\n        # dp[n, d] = dp[n - 1, d - i] + max(n - i, n) \n        if d > len(difficulty):\n            return -1\n        \n        n = len(difficulty)\n        dp = [float('inf')] * n + [0]\n        \n        # dp[i, j]: finish 'j' jobs in 'i' days\n        for i in range(d):\n            for j in range(n - 1, i - 1, -1):\n                dp[j] = float('inf')\n                local = float('-inf')\n                for k in range(j, i - 1, -1):\n                    local = max(local, difficulty[k])\n                    dp[j] = min(dp[j], dp[k - 1] + local)\n        \n        return dp[-2]\n", "from functools import lru_cache\n\n\nclass Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        if len(A) < d:\n            return -1\n        \n        @lru_cache(None)\n        def helper(i, d):\n            if i == len(A):\n                if d == 0:\n                    return 0\n                return float('inf')\n            \n            if d == 0:\n                return float('inf')\n            \n            res = float('inf')\n            local_max = float('-inf')\n            for j in range(i, len(A)):\n                local_max = max(local_max, A[j])\n                res = min(res, local_max + helper(j + 1, d - 1))\n            return res\n        \n        res = helper(0, d)\n        return res if res < float('inf') else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jD = jobDifficulty\n        N = len(jD)\n        if d > N:\n            return -1\n        \n        dp = [[float('inf')] * N for _ in range(d)]\n        dp[0][0] = jD[0]\n        for j in range(1,N):\n            dp[0][j] = 0\n            dp[0][j] = max(dp[0][j-1], jD[j])\n        # dp[i][j] = min(dp[i-1][k] + max(jD[k+1:j])) for k in i-1,j-1\n        for i in range(1,d):\n            for j in range(i, N):\n                # print('i,j = ',i,j)\n                last_dayD = jD[j]\n                for k in range(j-1, i-2, -1):\n                    # print('k = ',k)\n                    last_dayD = max(last_dayD, jD[k+1])\n                    # print('last_dayD = ',last_dayD)\n                    dp[i][j] = min(dp[i][j], dp[i-1][k] + last_dayD)\n        # print(dp)\n        return dp[d-1][N-1]\n    #[7,3,2,3,4,5]\n    # 5\n", "from functools import lru_cache\n\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        @lru_cache(None)\n        def dfs(idx, day):\n            if day == 0:\n                if idx < n:\n                    return float('inf')\n                else:\n                    return 0\n            tmp = 0\n            res = float('inf')\n            for j in range(idx, n):\n                tmp = max(tmp, jobDifficulty[j])\n                res = min(res, tmp + dfs(j + 1, day - 1))\n            return res\n        \n        out = dfs(0, d)\n        if out == float('inf'):\n            return -1\n        return out\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        dp = [0]+[float('inf')]*N\n        \n        for i in range(1, d+1):\n            dp2 = [float('inf')]*(N+1)\n            stack = []\n            for j in range(i, N+1-d+i):\n                max_val = jobDifficulty[j-1]\n                if i==1:\n                    dp2[j] = max(jobDifficulty[:j])\n                else:\n                    dp2[j] = dp[j-1]+max_val\n                    \n                while stack and stack[-1][1]<=max_val:\n                    dp2[j] = min(dp2[j], dp2[stack[-1][0]]-stack[-1][1]+max_val) \n                    stack.pop()\n                    \n                if stack and dp2[stack[-1][0]]<dp2[j]:\n                    dp2[j] = dp2[stack[-1][0]]\n                    max_val = stack[-1][1]\n                \n                stack.append((j, max_val))\n            # print(i, dp2)\n            dp = dp2\n            \n        return dp[N] if dp[N]!=float('inf') else -1", "class Solution:\n    def minDifficulty(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        if d==1: return max(arr)\n        if d>n: return -1\n        if d==n: return sum(arr)\n        dp = [[float('inf') for _ in range(n)] for _ in range(d)]\n        #initialization\n        dp[0][0] = arr[0]\n        for i in range(1,n):\n            dp[0][i] = max(dp[0][i-1], arr[i])\n        for i in range(1,d):\n            for j in range(i, n):\n                diff = 0\n                for k in range(j, i-1, -1):\n                    diff = max(arr[k], diff)\n                    dp[i][j] = min(dp[i][j], dp[i-1][k-1] + diff)\n        return dp[d-1][n-1]", "import functools\nclass Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n, inf = len(jobDifficulty), float('inf')\n        if n < d:\n            return -1\n        dp = [inf]* n + [0]\n        for day in range(1, d + 1):\n            for i in range(n - day + 1):\n                maxd, dp[i] = 0, inf\n                for j in range(i, n - day + 1):\n                    maxd = max(maxd, jobDifficulty[j])\n                    dp[i] = min(dp[i], maxd + dp[j+1])\n        return dp[0]", "import sys\n\nclass Solution:\n    def minDifficulty(self, complexity: List[int], days: int) -> int:\n       num_tasks = len(complexity)\n       if num_tasks < days:\n           return -1\n       dp = [sys.maxsize] * (num_tasks + 1)\n       dp[0] = 0\n\n       for day in range(1, days+1):\n           for i in range(num_tasks, 0, -1):\n               cur_max = 0\n               dp[i] = sys.maxsize if i > day-1 else dp[i]\n               for k in range(i, day-1, -1):\n                   cur_max = max(cur_max, complexity[k-1])\n                   dp[i] = min(dp[i], dp[k-1] + cur_max)\n       print(dp)\n       return dp[-1]\n\n\n\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        dp = [[0] * n] + [[float('inf')] * n for _ in range(d - 1)]\n        dp[0][0] = jobDifficulty[0]\n        for i in range(1, n):\n            dp[0][i] = max(jobDifficulty[i], dp[0][i - 1])\n        for i in range(1, d):\n            for j in range(i, n):\n                max_r = jobDifficulty[j]\n                for r in range(j, i - 1, -1):\n                    max_r = max(max_r, jobDifficulty[r])\n                    dp[i][j] = min(dp[i][j], max_r + dp[i - 1][r - 1])\n        return dp[-1][-1]", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        if len(jobDifficulty)<d:\n            return -1\n        \n        #dp[i][j]\u8868\u793a\u7b2ci\u5929\u4ee5\u7b2cj\u4e2a\u4efb\u52a1\u7ed3\u5c3e\uff0c\u603b\u7684\u6700\u5c0f\u7684difficulty\n        dp=[ [float('inf')]*len(jobDifficulty) for _ in range(d) ] \n        \n        dp[0][0]=jobDifficulty[0]\n        for j in range(1,len(jobDifficulty)):\n            dp[0][j]=max(dp[0][j-1],jobDifficulty[j])\n        \n        for i in range(1,d):\n            for j in range(i,len(jobDifficulty)):\n                maxdif=0\n                for k in range(j-1,-1,-1):\n                    maxdif=max(maxdif,jobDifficulty[k+1])\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+maxdif)\n\n        \n        return dp[-1][-1]\n", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        n = len(A)\n        if(n<d):\n            return -1\n        \n        @lru_cache(None)\n        def helper(i,d):\n            if(d == 0):\n                return 0 if i == n else sum(A[i:])\n            \n            if(i == n):\n                return float('inf')\n            tmp = 0\n            ans = float('inf')\n            for j in range(i,n):\n                tmp = max(tmp,A[j])\n                ans = min(ans, tmp + helper(j+1,d-1))\n            return ans\n        return helper(0,d)", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        M = 1e6\n        dp = [M for i in range(n + 1)]\n        dp[n] = 0\n        for j in range(1, d + 1):\n            for i in range(n):\n                m = -1\n                dp[i] = M\n                for k in range(i, n):\n                    m = max(m, jobDifficulty[k])\n                    dp[i] = min(dp[i], m + dp[k + 1])\n            dp[n] = M\n        return dp[0] if dp[0] < M else -1\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        cache = {}\n        def dfs(start, days):\n            if (start, days) in cache:\n                return cache[(start, days)]\n            if N - start < days or start == N or days < 1:\n                cache[(start, days)] = -1\n            elif days == 1:\n                cache[(start, days)] = max(jobDifficulty[start:])\n            else:\n                max_daily = float('-inf')\n                min_all = float('inf')\n                for end in range(start, N-days+1):\n                    max_daily = max(max_daily, jobDifficulty[end])\n                    min_all = min(min_all, max_daily + dfs(end+1, days-1))\n                cache[(start, days)] = -1 if min_all == float('inf') else min_all\n            return cache[(start, days)]\n        \n        return dfs(0, d)\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \n        n = len(jobDifficulty)\n        if n < d: return -1\n        memo = {}\n        def dp(ii, day):            \n            if (ii, day) not in memo:\n                if n - ii == day: memo[(ii, day)] = sum(jobDifficulty[ii:])\n                elif day == 1: memo[(ii, day)] = max(jobDifficulty[ii:])\n                else:\n                    ans = float('inf')\n                    curr_max = float('-inf')\n                    for jj in range(ii, n-(day-1)):\n                        #print(jj, day)\n                        curr_max = max(curr_max, jobDifficulty[jj])\n                        ans =min(ans, curr_max+dp(jj+1, day-1))\n                    \n                    memo[(ii, day)] = ans\n            return memo[(ii, day)]\n        \n        ans = dp(0, d)\n        #print(memo)\n        return ans", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        memo = {}\n        def helper(start, days):\n            if (start, days) in memo:\n                return memo[(start,days)]\n            if start == N or days < 1 or N - start < days: \n                memo[(start, days)] = -1\n            elif days == 1:\n                memo[(start, days)] = max(jobDifficulty[start:])\n            else:\n                max_diff = float('-inf')\n                min_total = float('inf')\n                for i in range(start, N-days+1):\n                    max_diff = max(max_diff, jobDifficulty[i])\n                    min_total = min(min_total, max_diff + helper(i+1, days-1))\n                memo[(start, days)] = -1 if min_total == float('inf') else min_total\n            return memo[(start, days)]\n        return helper(0, d)", "class Solution:\n    def minDifficulty( self, jobDifficulty: List[ int ], d: int ) -> int:\n        num_jobs = len( jobDifficulty )\n        if num_jobs < d:\n            return -1\n        \n        dp = [ [ -1 for _ in range( num_jobs ) ] for _ in range( d ) ]\n        \n        # First day everything is just the max up to that point\n        max_so_far = -math.inf\n        for job in range( num_jobs ):\n            max_so_far = max( max_so_far, jobDifficulty[ job ] )\n            dp[ 0 ][ job ] = max_so_far\n        \n        # Now do the rest\n        for day in range( 1, d ):\n            for job in range( day, num_jobs ): # Must be at least as many days as jobs\n                # The dp cache only keeps the best value up to that point for that number of days\n                # In order to determine best difficulty, walk backwards while keeping track of max difficulty and determine min total effort\n                max_so_far = -math.inf\n                for backwards_walker in range( job, day - 1, -1 ):\n                    max_so_far = max( max_so_far, jobDifficulty[ backwards_walker ] )\n                    dp[ day ][ job ] = min( dp[ day ][ job ], max_so_far + dp[ day - 1 ][ backwards_walker - 1 ] ) if dp[ day ][ job ] != -1 else max_so_far + dp[ day - 1 ][ job - 1 ]\n        print( dp )\n        return dp[ -1 ][ -1 ]\n", "import sys\n\nclass Solution:\n    def minDifficulty(self, complexity: List[int], days: int) -> int:\n        n = len(complexity)\n        if n < days:\n            return -1\n        dp = [[sys.maxsize] * (days + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n+1):\n            for j in range(1, days+1):\n                cur_max = 0\n                for k in range(i - 1, j - 2, -1):\n                    cur_max = max(cur_max, complexity[k])\n                    dp[i][j] = min(dp[i][j], dp[k][j-1] + cur_max)\n        return dp[-1][-1]\n", "class Solution:\n    def minDifficulty(self, A, d):\n        n, inf = len(A), float('inf')\n        dp = [[inf] * n + [0] for i in range(d + 1)]\n        for d in range(1, d + 1):\n            for i in range(n - d + 1):\n                maxd = 0\n                for j in range(i, n - d + 1):\n                    maxd = max(maxd, A[j])\n                    dp[d][i] = min(dp[d][i], maxd + dp[d - 1][j + 1])\n        return dp[d][0] if dp[d][0] < inf else -1", "class Solution:\n    def minDifficulty(self, A: List[int], d: int) -> int:\n        n = len(A)\n        \n        if d>n: #more days than job\n            return -1\n        \n        dp = [[math.inf]*(d+1) for _ in range(n)]\n        #dp[i][j] store the ans for jobs i:n with j days remaining\n        \n        for i in range(n-1,-1,-1):\n            for j in range(1,d+1):\n                if n-i<j: #more days than jobs\n                    continue\n                rMax = -math.inf\n                for k in range(i,n-j+1): #if we finish i:k+1 jobs today\n                    rMax=max(rMax,A[k])\n                    if j==1:\n                        dp[i][j]=rMax\n                    else:\n                        dp[i][j] = min(dp[i][j],rMax+dp[k+1][j-1])\n        return dp[0][d]\n", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        A = jobDifficulty\n        n = len(A)\n        \n        if d>n: #more days than job\n            return -1\n        \n        dp = [[math.inf]*(d+1) for _ in range(n)]\n        #dp[i][j] store the ans for jobs i:n with j days remaining\n        \n        for i in range(n-1,-1,-1):\n            for j in range(1,d+1):\n                if n-i<j: #more days than jobs\n                    continue\n                rMax = -math.inf\n                for k in range(i,n-j+1): #if we finish i:k+1 jobs today\n                    rMax=max(rMax,A[k])\n                    if j==1:\n                        dp[i][j]=rMax\n                    else:\n                        dp[i][j] = min(dp[i][j],rMax+dp[k+1][j-1])\n        return dp[0][d]    ", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        \n        dp = [[float('inf')] * n + [0] for i in range(d + 1)]\n        for i in range(1, d+1):\n            for j in range(n - i + 1):\n                maxd = 0\n                for x in range(j, n - i + 1):\n                    maxd = max(maxd, jobDifficulty[x])\n                    dp[i][j] = min(dp[i][j], maxd + dp[i - 1][x + 1])\n        return dp[d][0] if dp[d][0] < float('inf') else -1", "class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        # 1 2 3\n      # 6 6\n      # 5 6 11 0 11 10 9\n    # init\n    # dp[j][d+1], if j < d, dp[j][d] = -1, dp[0][0] = 0 \n    # transition\n    # 0 < k < d, dp[j][k] = min[dp[i][k-1] + max(i..j)] \n    # answer dp[n][d]\n    \n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        dp = [[math.inf for _ in range(d + 1)] for _ in range(n+1)]\n        dp[0][0] = 0\n        \n        for j in range(0, n+1):\n            for k in range(1,d+1):\n                dp[j][k] = math.inf\n                mx = 0\n                for i in reversed(range(j)):\n                    mx = max(mx, jobDifficulty[i])\n                    dp[j][k] = min(dp[j][k], dp[i][k-1] + mx)\n        print(dp)\n        return dp[n][d]"]
["class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (mouse, cat, turn) ?\n        def parents(mouse, cat, turn):\n            prev_turn = 3 - turn\n            if prev_turn == MOUSE: \n                for m2 in graph[mouse]:\n                    yield m2, cat, prev_turn\n            else:\n                for c2 in graph[cat]:\n                    if c2:\n                        yield mouse, c2, prev_turn\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        colors = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for mouse in range(N):\n            for cat in range(N):\n                degree[mouse, cat, MOUSE] = len(graph[mouse])\n                degree[mouse, cat, CAT] = len(graph[cat]) - (0 in graph[cat])  # cat can not be at hole 0\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for cat in range(N):\n            for turn in [MOUSE, CAT]:\n                # color MOUSE for all node with mouse=0\n                mouse = 0\n                colors[mouse, cat, turn] = MOUSE\n                queue.append((mouse, cat, turn, MOUSE))\n                # color CAT for all node with mouse = cat !=0, cat can not be at hole 0\n                if cat > 0:\n                    mouse = cat\n                    colors[mouse, cat, turn] = CAT\n                    queue.append((mouse, cat, turn, CAT))\n\n        # percolate\n        while queue:\n            mouse, cat, turn, color = queue.popleft()\n            for prev_mouse, prev_cat, prev_turn in parents(mouse, cat, turn):\n                # if this parent is not colored :\n                if colors[prev_mouse, prev_cat, prev_turn] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if prev_turn == color: # winning move\n                        colors[prev_mouse, prev_cat, prev_turn] = color\n                        queue.append((prev_mouse, prev_cat, prev_turn, color))\n                        if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \n                            return color\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[prev_mouse, prev_cat, prev_turn] -= 1\n                        if degree[prev_mouse, prev_cat, prev_turn] == 0:\n                            colors[prev_mouse, prev_cat, prev_turn] = 3 - prev_turn\n                            queue.append((prev_mouse, prev_cat, prev_turn, 3 - prev_turn))\n                            if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \n                                return color\n\n        return colors[1, 2, 1] # mouse at 1, cat at 2, MOUSE turn", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # For n nodes, the possible longest path in the graph is n. If the cat can win, \n        # its distance to the mouse should decrease, after decease n times if still doesn't \n        # catch the mouse, and mouse haven't reach node 0 yet, means this is a draw\n        \n        # it takes at most n for mouse to get to 0. At 2*n time, it means mouse take a \n        # detour of at least n steps. It means that there should be at least a loop(size n) \n        # or multiple loops of (size < n).\n        \n        n = len(graph)\n        @lru_cache(None)\n        def move(cat, mouse, t):\n            # should be 2n but 0.8n also passes all tests\n            if t > int(0.8 * n):\n                return 0\n            elif mouse == 0:\n                return 1\n            elif cat == mouse:\n                return 2\n            if t % 2 == 0:\n                best_result = 2\n                for pos in graph[mouse]:\n                    result = move(cat, pos, t + 1)\n                    if result == 1:\n                        return 1\n                    if result == 0:\n                        best_result = 0\n            else:\n                best_result = 1\n                for pos in graph[cat]:\n                    if pos == 0:\n                        continue\n                    result = move(pos, mouse, t + 1)\n                    if result == 2:\n                        return 2\n                    if result == 0:\n                        best_result = 0\n            return best_result\n        return move(2, 1, 0)\n        \n        \n        \n#         n = len(graph)\n#         cache = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n#         def move(cat, mouse, t):\n#             if t == 2 * n:\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if cache[cat][mouse][t] == -1:\n#                 mouse_move = (t % 2) == 0\n#                 if mouse_move:\n#                     best_result = 2\n#                     for pos in graph[mouse]:\n#                         result = move(cat, pos, t + 1)\n#                         if result == 1:\n#                             cache[cat][mouse][t] = 1\n#                             return 1\n#                         if result == 0:\n#                             best_result = 0\n#                 else:\n#                     best_result = 1\n#                     for pos in graph[cat]:\n#                         if pos == 0:\n#                             continue\n#                         result = move(pos, mouse, t + 1)\n#                         if result == 2:\n#                             cache[cat][mouse][t] = 2\n#                             return 2\n#                         if result == 0:\n#                             best_result = 0\n#                 cache[cat][mouse][t] = best_result\n#             return cache[cat][mouse][t]\n#         return move(2, 1, 0)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # For n nodes, the possible longest path in the graph is n. If the cat can win, \n        # its distance to the mouse should decrease, after decease n times if still doesn't \n        # catch the mouse, and mouse haven't reach node 0 yet, means this is a draw\n        \n        # it takes at most n for mouse to get to 0. At 2*n time, it means mouse take a \n        # detour of at least n steps. It means that there should be at least a loop(size n) \n        # or multiple loops of (size < n).\n        \n        n = len(graph)\n        @lru_cache(None)\n        def move(cat, mouse, t):\n            if t == n:\n                return 0\n            elif mouse == 0:\n                return 1\n            elif cat == mouse:\n                return 2\n            if t % 2 == 0:\n                best_result = 2\n                for pos in graph[mouse]:\n                    result = move(cat, pos, t + 1)\n                    if result == 1:\n                        return 1\n                    if result == 0:\n                        best_result = 0\n            else:\n                best_result = 1\n                for pos in graph[cat]:\n                    if pos == 0:\n                        continue\n                    result = move(pos, mouse, t + 1)\n                    if result == 2:\n                        return 2\n                    if result == 0:\n                        best_result = 0\n            return best_result\n        return move(2, 1, 0)\n        \n        \n        \n#         n = len(graph)\n#         cache = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n#         def move(cat, mouse, t):\n#             if t == 2 * n:\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if cache[cat][mouse][t] == -1:\n#                 mouse_move = (t % 2) == 0\n#                 if mouse_move:\n#                     best_result = 2\n#                     for pos in graph[mouse]:\n#                         result = move(cat, pos, t + 1)\n#                         if result == 1:\n#                             cache[cat][mouse][t] = 1\n#                             return 1\n#                         if result == 0:\n#                             best_result = 0\n#                 else:\n#                     best_result = 1\n#                     for pos in graph[cat]:\n#                         if pos == 0:\n#                             continue\n#                         result = move(pos, mouse, t + 1)\n#                         if result == 2:\n#                             cache[cat][mouse][t] = 2\n#                             return 2\n#                         if result == 0:\n#                             best_result = 0\n#                 cache[cat][mouse][t] = best_result\n#             return cache[cat][mouse][t]\n#         return move(2, 1, 0)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = 0\n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                n = max(n, graph[i][j])\n        \n        status = [[[0] * 3 for i in range(n + 1)] for j in range(n + 1)] # s[m][c][t]\n        \n        queue = []\n        for i in range(1, n + 1):\n            status[i][i][1] = 2\n            status[i][i][2] = 2\n            status[0][i][1] = 1\n            status[0][i][2] = 1\n            queue.append((i, i, 1))\n            queue.append((i, i, 2))\n            queue.append((0, i, 1))\n            queue.append((0, i, 2))\n        \n        while queue:\n            next_queue = []\n            for element in queue:\n                mouse = element[0]\n                cat = element[1]\n                turn = element[2]\n                if turn == 1:\n                    for cat_pre in graph[cat]:\n                        if cat_pre == 0:\n                            continue\n                        if status[mouse][cat_pre][2] == 0:\n                            status[mouse][cat_pre][2] = 1\n                            for cat_alt in graph[cat_pre]:\n                                if cat_alt == 0:\n                                    continue\n                                if status[mouse][cat_alt][1] == 2:\n                                    status[mouse][cat_pre][2] = 2\n                                    break\n                                elif status[mouse][cat_alt][1] == 0:\n                                    status[mouse][cat_pre][2] = 0\n                            if status[mouse][cat_pre][2] > 0:\n                                next_queue.append((mouse, cat_pre, 2))\n                else:\n                    for mouse_pre in graph[mouse]:\n                        if status[mouse_pre][cat][1] == 0:\n                            status[mouse_pre][cat][1] = 2\n                            for mouse_alt in graph[mouse_pre]:\n                                if status[mouse_alt][cat][2] == 1:\n                                    status[mouse_pre][cat][1] = 1\n                                    break\n                                elif status[mouse_alt][cat][2] == 0:\n                                    status[mouse_pre][cat][1] = 0\n                            if status[mouse_pre][cat][1] > 0:\n                                next_queue.append((mouse_pre, cat, 1))\n            queue = next_queue\n        \n        return status[1][2][1]\n                        \n                            \n                            \n                        \n                        \n                    \n            \n        \n        \n", "class Solution:\n    def catMouseGame(self, graph):\n        CAT, MOUSE, n = 2, 1, len(graph)\n        queue = []          # (cat, mouse, turn, winner)\n        result = {}\n        for i in range(n):\n            for j in range(2):\n                queue.append((i, 0, j, 1))\n                result[(i, 0, j)] = 1\n                if i > 0:\n                    queue.append((i, i, j, 2))\n                    result[(i, i, j)] = 2\n                    queue.append((0, i, j, 1))\n                    result[(0, i, j)] = 1\n\n        cnt = {}\n        for i in range(n):\n            for j in range(n):\n                cnt[(i, j, 0)] = len(graph[j])\n                cnt[(i, j, 1)] = len(graph[i])\n\n        while queue:\n            cat, mouse, turn, winner = queue.pop()\n            if turn == 1:   # cat move for next step, mouse move for last step\n                if winner == 1:\n                    for next_step in graph[mouse]:\n                        if (cat, next_step, 1 - turn) not in result:\n                            result[(cat, next_step, 1 - turn)] = winner\n                            queue.append((cat, next_step, 1 - turn, winner))\n                else:\n                    for next_step in graph[mouse]:\n                        if (cat, next_step, 1 - turn) not in result:\n                            cnt[(cat, next_step, 1 - turn)] -= 1\n                            if cnt[(cat, next_step, 1 - turn)] == 0:\n                                result[(cat, next_step, 1 - turn)] = winner\n                                queue.append((cat, next_step, 1 - turn, winner))\n            else:\n                if winner == 2:\n                    for next_step in graph[cat]:\n                        if next_step == 0:\n                            continue\n                        if (next_step, mouse, 1 - turn) not in result:\n                            result[(next_step, mouse, 1 - turn)] = winner\n                            queue.append((next_step, mouse, 1 - turn, winner))\n                else:\n                    for next_step in graph[cat]:\n                        if next_step == 0:\n                            continue\n                        if (next_step, mouse, 1 - turn) not in result:\n                            cnt[(next_step, mouse, 1 - turn)] -= 1\n                            if cnt[(next_step, mouse, 1 - turn)] == 0:\n                                result[(next_step, mouse, 1 - turn)] = winner\n                                queue.append((next_step, mouse, 1 - turn, winner))\n        if (2, 1, 0) in result:\n            return result[(2, 1, 0)]\n        return 0\n\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # state: [M=0/C=1, Mpos, Cpos]\n        # result: 0-draw, 1-mouse win, 2-cat win\n\n        cache = {}\n        def dfs(s, visited):\n            if s in cache:\n                return cache[s]\n            visited.add(s)\n            if s[0] == 0:\n                ret = dfs_m(s, visited)\n            else:\n                ret = dfs_c(s, visited)\n            visited.remove(s)\n            cache[s] = ret\n            return ret\n\n        def sorted_neighbor(node, dest):\n            nbs = sorted([(n, dist_mat[n][dest]) for n in graph[node]], key=lambda x: x[1])\n            return [t[0] for t in nbs]\n            \n        def dfs_m(s, visited):\n            if 0 in graph[s[1]]:\n                return 1 # mouse-win\n\n            cat_nbs = set([x for x in graph[s[2]] if x != 0])\n            nbs = sorted_neighbor(s[1], 0)\n            hold_move = 0\n            for node in nbs:\n                if node == s[2] or node in cat_nbs: # mouse-lose\n                    continue\n\n                s2 = (1, node, s[2])\n                if s2 in visited:\n                    hold_move += 1\n                    continue\n\n                ret = dfs(s2, visited)\n                if ret == 1:\n                    return 1 # mouse-win\n                if ret == 0:\n                    hold_move += 1\n\n            if hold_move: \n                return 0 # draw\n            else:\n                return 2 # cat-win\n        \n        def dfs_c(s, visited):\n            if s[1] in graph[s[2]]:\n                return 2 # cat-win\n\n            nbs = sorted_neighbor(s[2], s[1])\n            hold_move = 0\n            for node in nbs:\n                if node == 0:\n                    continue\n\n                s2 = (0, s[1], node)\n                if s2 in visited:\n                    hold_move += 1\n                    continue\n                ret = dfs(s2, visited)\n                if ret == 2:\n                    return 2 # cat-win\n                if ret == 0:\n                    hold_move += 1\n\n            if hold_move:\n                return 0 # draw\n            else:\n                return 1 # mouse-win\n\n        INF_DIST = float('inf')\n\n        def floyd_dist_modified():\n            N = len(graph)\n            Mat = [[float('inf')] * N for _ in range(N)]\n            for i in range(N):\n                Mat[i][i] = 0\n                for n in graph[i]:\n                    Mat[i][n] = 1\n\n            for k in range(1, N):\n                for i in range(1, N):\n                    for j in range(1, N):\n                        Mat[i][j] = min(Mat[i][j], Mat[i][k] + Mat[k][j])\n\n            for n in graph[0]:\n                for i in range(1, N):\n                    Mat[0][i] = min(Mat[0][i], Mat[0][n] + Mat[n][i])\n                    Mat[i][0] = Mat[0][i]\n\n            return Mat\n        \n        dist_mat = floyd_dist_modified()\n        visited = set()\n        return dfs((0, 1, 2), visited)\n", "class Solution(object):\n    def catMouseGame(self, graph):\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (m, c, t) ?\n        def parents(m, c, t):\n            if t == 2:\n                for m2 in graph[m]:\n                    yield m2, c, 3-t\n            else:\n                for c2 in graph[c]:\n                    if c2:\n                        yield m, c2, 3-t\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        color = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for m in range(N):\n            for c in range(N):\n                degree[m,c,1] = len(graph[m])\n                degree[m,c,2] = len(graph[c]) - (0 in graph[c])\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for i in range(N):\n            for t in range(1, 3):\n                color[0, i, t] = MOUSE\n                queue.append((0, i, t, MOUSE))\n                if i > 0:\n                    color[i, i, t] = CAT\n                    queue.append((i, i, t, CAT))\n\n        # percolate\n        while queue:\n            # for nodes that are colored :\n            i, j, t, c = queue.popleft()\n            # for every parent of this node i, j, t :\n            for i2, j2, t2 in parents(i, j, t):\n                # if this parent is not colored :\n                if color[i2, j2, t2] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if t2 == c: # winning move\n                        color[i2, j2, t2] = c\n                        queue.append((i2, j2, t2, c))\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[i2, j2, t2] -= 1\n                        if degree[i2, j2, t2] == 0:\n                            color[i2, j2, t2] = 3 - t2\n                            queue.append((i2, j2, t2, 3 - t2))\n\n        return color[1, 2, 1]", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (m, c, t) ?\n        def parents(m, c, t):\n            if t == 2:\n                for m2 in graph[m]:\n                    yield m2, c, 3-t\n            else:\n                for c2 in graph[c]:\n                    if c2:\n                        yield m, c2, 3-t\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        color = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for m in range(N):\n            for c in range(N):\n                degree[m,c,1] = len(graph[m])\n                degree[m,c,2] = len(graph[c]) - (0 in graph[c])\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for i in range(N):\n            for t in range(1, 3):\n                color[0, i, t] = MOUSE\n                queue.append((0, i, t, MOUSE))\n                if i > 0:\n                    color[i, i, t] = CAT\n                    queue.append((i, i, t, CAT))\n\n        # percolate\n        while queue:\n            # for nodes that are colored :\n            i, j, t, c = queue.popleft()\n            # for every parent of this node i, j, t :\n            for i2, j2, t2 in parents(i, j, t):\n                # if this parent is not colored :\n                if color[i2, j2, t2] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if t2 == c: # winning move\n                        color[i2, j2, t2] = c\n                        queue.append((i2, j2, t2, c))\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[i2, j2, t2] -= 1\n                        if degree[i2, j2, t2] == 0:\n                            color[i2, j2, t2] = 3 - t2\n                            queue.append((i2, j2, t2, 3 - t2))\n\n        return color[1, 2, 1]", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (m, c, t) ?\n        def parents(m, c, t):\n            if t == 2:\n                for m2 in graph[m]:\n                    yield m2, c, 3 - t\n            else:\n                for c2 in graph[c]:\n                    if c2:\n                        yield m, c2, 3 - t\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        color = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for m in range(N):\n            for c in range(N):\n                degree[m, c, 1] = len(graph[m])\n                degree[m, c, 2] = len(graph[c]) - (0 in graph[c])\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for i in range(N):\n            for t in range(1, 3):\n                color[0, i, t] = MOUSE\n                queue.append((0, i, t, MOUSE))\n                if i > 0:\n                    color[i, i, t] = CAT\n                    queue.append((i, i, t, CAT))\n\n        # percolate\n        while queue:\n            # for nodes that are colored :\n            i, j, t, c = queue.popleft()\n            # for every parent of this node i, j, t :\n            for i2, j2, t2 in parents(i, j, t):\n                # if this parent is not colored :\n                if color[i2, j2, t2] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if t2 == c: # winning move\n                        color[i2, j2, t2] = c\n                        queue.append((i2, j2, t2, c))\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[i2, j2, t2] -= 1\n                        if degree[i2, j2, t2] == 0:\n                            color[i2, j2, t2] = 3 - t2\n                            queue.append((i2, j2, t2, 3 - t2))\n\n        return color[1, 2, 1]", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n        def parent(m, c, t):\n            if t == 2:\n                for m2 in graph[m]:\n                    yield m2, c, 1\n            else:\n                for c2 in graph[c]:\n                    if c2:\n                        yield m, c2, 2\n        D, M, C = 0, 1, 2\n        color = collections.defaultdict(int)\n        degree = {}\n        for m in range(N):\n            for c in range(N):\n                degree[m, c, 1] = len(graph[m])\n                degree[m, c, 2] = len(graph[c]) - (0 in graph[c])\n                \n        queue = collections.deque([])\n        for i in range(N):\n            for t in [1, 2]:\n                color[0, i, t] = M\n                queue.append((0, i, t, M))\n                if i > 0:\n                    color[i, i, t] = C\n                    queue.append((i, i, t, C))\n                    \n        while queue:\n            i, j, t, w = queue.popleft()\n            for i2, j2, t2 in parent(i, j, t):\n                if color[i2, j2, t2] is D:\n                    if t2 == w:\n                        color[i2, j2, t2] = w\n                        queue.append((i2, j2, t2, w))\n                    else:\n                        degree[i2, j2, t2] -= 1\n                        if degree[i2, j2, t2] == 0:\n                            color[i2, j2, t2] = 3 - t2\n                            queue.append((i2, j2, t2, 3-t2))\n                            \n        return color[1, 2, 1]", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        # observations:\n        # we can represent the game state with the triplet (mouse cat turn).\n        # (_ 0 _) is illegal.\n        # (0 _ _) = 1 (mouse victory).\n        # (x x _) = 2 (cat victory).\n        # if any possible move leads to win, current state is win:\n        # * (m c c) = 1 => (m' c m) = 1 for m' in g[m].\n        # * (m c m) = 2 => (m c' c) = 2 for c' in g[c].\n        # if all possible moves lead to loss, current state is loss.\n        # * (m c m) = 1, for c' in g[c], if all((m c'' m) = 1 for c'' in g[c']) => (m c' c) = 1\n        # * (m c c) = 2, for m' in g[m], if all((m'' c c) = 2 for m'' in g[m']) => (m' c m) = 2\n        # return (1 2 m). return once we know its value.\n\n        n = len(g)\n        s = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n        q = deque()\n\n        def sq(m, c, t, v):\n            if s[m][c][t] == 0:\n                q.append((m, c, t))\n                s[m][c][t] = v\n\n        # approach:\n\n        # set and enqueue initial known states.\n        for m in range(n):\n            for t in range(2):\n                sq(m, 0, t, -1)\n        for c in range(n):\n            for t in range(2):\n                sq(0, c, t, 1)\n        for x in range(n):\n            for t in range(2):\n                sq(x, x, t, 2)\n\n        # while queue:\n        while q:\n            # pop state.\n            m, c, t = state = q.popleft()\n            # apply production rules. for each unencountered resultant state, set and enqueue.\n            if t == 1 and s[m][c][t] == 1:\n                for m_ in g[m]:\n                    sq(m_, c, 0, 1)\n\n            if t == 0 and s[m][c][t] == 2:\n                for c_ in g[c]:\n                    sq(m, c_, 1, 2)\n\n            # if t == 0 and s[m][c][t] == 1 and c not in g[m]:\n            # sq(m, c, 1, 1)\n\n            if t == 0 and s[m][c][t] == 1:\n                for c_ in g[c]:\n                    if all(s[m][c__][0] in (-1, 1) for c__ in g[c_]):\n                        sq(m, c_, 1, 1)\n\n            if t == 1 and s[m][c][t] == 2:\n                for m_ in g[m]:\n                    if all(s[m__][c][1] in (-1, 2) for m__ in g[m_]):\n                        sq(m_, c, 0, 2)\n\n            # if we know state[1,2,m], return it.\n            if s[1][2][0]:\n                return s[1][2][0]\n\n        # everything else is a draw.\n        return 0\n", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        # observations:\n        # we can represent the game state with the triplet (mouse cat turn).\n        # (_ 0 _) is illegal.\n        # (0 _ _) = 1 (mouse victory).\n        # (x x _) = 2 (cat victory).\n        # if any possible move leads to win, current state is win:\n        # * (m c c) = 1 => (m' c m) = 1 for m' in g[m].\n        # * (m c m) = 2 => (m c' c) = 2 for c' in g[c].\n        # if all possible moves lead to loss, current state is loss.\n        # * (m c m) = 1, for c' in g[c], if all((m c'' m) = 1 for c'' in g[c']) => (m c' c) = 1\n        # * (m c c) = 2, for m' in g[m], if all((m'' c c) = 2 for m'' in g[m']) => (m' c m) = 2\n        # return (1 2 m). return once we know its value.\n\n        n = len(g)\n        s = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n        q = deque()\n\n        def sq(m, c, t, v):\n            if s[m][c][t] == 0:\n                q.append((m, c, t))\n                s[m][c][t] = v\n\n        # set and enqueue initial known states.\n        for m in range(n):\n            for t in range(2):\n                sq(m, 0, t, -1)\n        for c in range(n):\n            for t in range(2):\n                sq(0, c, t, 1)\n        for x in range(n):\n            for t in range(2):\n                sq(x, x, t, 2)\n\n        while q:\n            m, c, t = state = q.popleft()\n\n            # apply production rules. for each unencountered resultant state, set and enqueue.\n            if t == 1 and s[m][c][t] == 1:\n                for m_ in g[m]:\n                    sq(m_, c, 0, 1)\n\n            if t == 0 and s[m][c][t] == 2:\n                for c_ in g[c]:\n                    sq(m, c_, 1, 2)\n\n            if t == 0 and s[m][c][t] == 1:\n                for c_ in g[c]:\n                    if all(s[m][c__][0] in (-1, 1) for c__ in g[c_]):\n                        sq(m, c_, 1, 1)\n\n            if t == 1 and s[m][c][t] == 2:\n                for m_ in g[m]:\n                    if all(s[m__][c][1] in (-1, 2) for m__ in g[m_]):\n                        sq(m_, c, 0, 2)\n\n            # once we know state[1,2,m], return it.\n            if s[1][2][0]:\n                return s[1][2][0]\n\n        # everything else is a draw.\n        return 0\n", "class Solution:\n  def catMouseGame(self, graph):\n    TIE           = 0\n    MOUSE_WIN         = 1\n    CAT_WIN         = 2\n    MOUSE_TURN        = 'MOUSE'\n    CAT_TURN        = 'CAT'\n    HOLE_POSITION       = 0\n    MPOS_INIT  = 1\n    CPOS_INIT  = 2\n\n    win_states = {}\n    for m_pos, _ in enumerate(graph):\n      for c_pos, _ in enumerate(graph):\n        for turn in [MOUSE_TURN, CAT_TURN]:\n          key = (m_pos, c_pos, turn)\n          if m_pos == HOLE_POSITION:\n            # If the mouse reaches the hole, the mouse wins.\n            # The cat also isn't allowed to go on the node corresponding\n            # to the hole, so mark the cat doing that as also a win.\n            win_states[key] = MOUSE_WIN\n          elif m_pos == c_pos:\n            win_states[key] = CAT_WIN\n          else:\n            win_states[key] = TIE\n    while True:\n      num_changed = 0\n      turn = MOUSE_TURN\n      for m_pos, _ in enumerate(graph):\n        for c_pos, _ in enumerate(graph):\n          all_cat_win = False\n          if win_states[(m_pos, c_pos, turn)] == TIE:\n            neighbor_states = [win_states[(node, c_pos, CAT_TURN)] for node in graph[m_pos]]\n            if all(win == CAT_WIN for win in neighbor_states):\n              win_states[(m_pos, c_pos, turn)] = CAT_WIN\n              num_changed += 1\n            elif any(win == MOUSE_WIN for win in neighbor_states):\n              win_states[(m_pos, c_pos, turn)] = MOUSE_WIN\n              num_changed += 1\n      turn = CAT_TURN\n      for m_pos, _ in enumerate(graph):\n        for c_pos, _ in enumerate(graph):\n          if win_states[(m_pos, c_pos, turn)] == TIE:\n            neighbor_states = [win_states[(m_pos, node, MOUSE_TURN)] for node in graph[c_pos] if node != HOLE_POSITION]\n            if all(win == MOUSE_WIN for win in neighbor_states):\n              win_states[(m_pos, c_pos, turn)] = MOUSE_WIN\n              num_changed += 1\n            elif any(win == CAT_WIN for win in neighbor_states):\n              win_states[(m_pos, c_pos, turn)] = CAT_WIN\n              num_changed += 1\n      if num_changed == 0:\n        break\n    return win_states[(MPOS_INIT, CPOS_INIT, MOUSE_TURN)]\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        CAT_TURN = CAT_WIN = 2\n        MOUSE_TURN = MOUSE_WIN = 1\n        DRAW = 0\n        outcome = defaultdict(int)\n        degree = {}\n        for cat in range(n):\n            cat_neighbour_has_zero = 1 if 0 in graph[cat] else 0\n            for mouse in range(n):\n                degree[mouse, cat, 1] = len(graph[mouse])\n                degree[mouse, cat, 2] = len(graph[cat]) - cat_neighbour_has_zero\n                \n        queue = deque()\n        for cat in range(n):\n            for turn in [MOUSE_TURN, CAT_TURN]:\n                outcome[0, cat, turn] = MOUSE_WIN\n                queue.append((0, cat, turn, MOUSE_WIN))\n                if cat > 0:\n                    outcome[cat, cat, turn] = CAT_WIN\n                    queue.append((cat, cat, turn, CAT_WIN))\n                    \n        def previous(mouse, cat, turn):\n            if turn == MOUSE_TURN:\n                for prev_cat in graph[cat]:\n                    if prev_cat:\n                        yield mouse, prev_cat, 3 - turn\n            else:\n                for prev_mouse in graph[mouse]:\n                    yield prev_mouse, cat, 3 - turn\n                    \n        while queue:\n            mouse, cat, turn, final_outcome = queue.popleft()\n            for prev_mouse, prev_cat, prev_turn in previous(mouse, cat, turn):\n                if outcome[prev_mouse, prev_cat, prev_turn] == DRAW:\n                    if prev_turn == final_outcome:\n                        outcome[prev_mouse, prev_cat, prev_turn] = final_outcome\n                        queue.append((prev_mouse, prev_cat, prev_turn, final_outcome))\n                    else:\n                        degree[prev_mouse, prev_cat, prev_turn] -= 1\n                        if degree[prev_mouse, prev_cat, prev_turn] == 0:\n                            outcome[prev_mouse, prev_cat, prev_turn] = 3 - prev_turn\n                            queue.append((prev_mouse, prev_cat, prev_turn, 3 - prev_turn))\n        return outcome[1, 2, 1]\n        \n        \n        \n        \n#         # For n nodes, the possible longest path in the graph is n. If the cat can win, \n#         # its distance to the mouse should decrease, after decease n times if still doesn't \n#         # catch the mouse, and mouse haven't reach node 0 yet, means this is a draw\n        \n#         # it takes at most n for mouse to get to 0. At 2*n time, it means mouse take a \n#         # detour of at least n steps. It means that there should be at least a loop(size n) \n#         # or multiple loops of (size < n).\n        \n#         n = len(graph)\n#         @lru_cache(None)\n#         def move(cat, mouse, t):\n#             # should be 2n but 0.8n also passes all tests\n#             if t > int(0.8 * n):\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if t % 2 == 0:\n#                 best_result = 2\n#                 for pos in graph[mouse]:\n#                     result = move(cat, pos, t + 1)\n#                     if result == 1:\n#                         return 1\n#                     if result == 0:\n#                         best_result = 0\n#             else:\n#                 best_result = 1\n#                 for pos in graph[cat]:\n#                     if pos == 0:\n#                         continue\n#                     result = move(pos, mouse, t + 1)\n#                     if result == 2:\n#                         return 2\n#                     if result == 0:\n#                         best_result = 0\n#             return best_result\n#         return move(2, 1, 0)\n        \n        \n        \n        \n#         n = len(graph)\n#         cache = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n#         def move(cat, mouse, t):\n#             if t == 2 * n:\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if cache[cat][mouse][t] == -1:\n#                 mouse_move = (t % 2) == 0\n#                 if mouse_move:\n#                     best_result = 2\n#                     for pos in graph[mouse]:\n#                         result = move(cat, pos, t + 1)\n#                         if result == 1:\n#                             cache[cat][mouse][t] = 1\n#                             return 1\n#                         if result == 0:\n#                             best_result = 0\n#                 else:\n#                     best_result = 1\n#                     for pos in graph[cat]:\n#                         if pos == 0:\n#                             continue\n#                         result = move(pos, mouse, t + 1)\n#                         if result == 2:\n#                             cache[cat][mouse][t] = 2\n#                             return 2\n#                         if result == 0:\n#                             best_result = 0\n#                 cache[cat][mouse][t] = best_result\n#             return cache[cat][mouse][t]\n#         return move(2, 1, 0)\n", "TIE        = 0\nMOUSE_WIN  = 1\nCAT_WIN    = 2\nMOUSE_TURN = 'MOUSE'\nCAT_TURN   = 'CAT'\nGOAL       = 0\nMPOS_INIT  = 1\nCPOS_INIT  = 2\n\nclass Solution:\n  def catMouseGame(self, graph):\n    win_states = {}\n    for mpos, _ in enumerate(graph):\n      for cpos, _ in enumerate(graph):\n        for turn in [MOUSE_TURN, CAT_TURN]:\n          key = (mpos, cpos, turn)\n          if mpos == GOAL:   win_states[key] = MOUSE_WIN\n          elif mpos == cpos: win_states[key] = CAT_WIN\n          else:              win_states[key] = TIE\n    while True:\n      changes = 0\n      turn = MOUSE_TURN\n      for mpos, adj in enumerate(graph):\n        for cpos, _ in enumerate(graph):\n          all_cat_win = False\n          if win_states[(mpos, cpos, turn)] == TIE:\n            adj_wins = [win_states[(node, cpos, CAT_TURN)] for node in adj]\n            if all(win == CAT_WIN for win in adj_wins):\n              win_states[(mpos, cpos, turn)], changes = CAT_WIN, changes + 1\n            elif any(win == MOUSE_WIN for win in adj_wins):\n              win_states[(mpos, cpos, turn)], changes = MOUSE_WIN, changes + 1\n      turn = CAT_TURN\n      for mpos, _ in enumerate(graph):\n        for cpos, adj in enumerate(graph):\n          if win_states[(mpos, cpos, turn)] == TIE:\n            adj_wins = [win_states[(mpos, node, MOUSE_TURN)] for node in adj if node != GOAL]\n            if all(win == MOUSE_WIN for win in adj_wins):\n              win_states[(mpos, cpos, turn)], changes = MOUSE_WIN, changes + 1\n            elif any(win == CAT_WIN for win in adj_wins):\n              win_states[(mpos, cpos, turn)], changes = CAT_WIN, changes + 1\n      if changes == 0:\n        break\n    return win_states[(MPOS_INIT, CPOS_INIT, MOUSE_TURN)]\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # For n nodes, the possible longest path in the graph is n. If the cat can win, \n        # its distance to the mouse should decrease, after decease n times if still doesn't \n        # catch the mouse, and mouse haven't reach node 0 yet, means this is a draw\n        \n        # it takes at most n for mouse to get to 0. At 2*n time, it means mouse take a \n        # detour of at least n steps. It means that there should be at least a loop(size n) \n        # or multiple loops of (size < n).\n        \n        n = len(graph)\n        @lru_cache(None)\n        def move(cat, mouse, t):\n            if t == 2 * n:\n                return 0\n            elif mouse == 0:\n                return 1\n            elif cat == mouse:\n                return 2\n            if t % 2 == 0:\n                best_result = 2\n                for pos in graph[mouse]:\n                    result = move(cat, pos, t + 1)\n                    if result == 1:\n                        return 1\n                    if result == 0:\n                        best_result = 0\n            else:\n                best_result = 1\n                for pos in graph[cat]:\n                    if pos == 0:\n                        continue\n                    result = move(pos, mouse, t + 1)\n                    if result == 2:\n                        return 2\n                    if result == 0:\n                        best_result = 0\n            return best_result\n        return move(2, 1, 0)\n        \n        \n        \n#         n = len(graph)\n#         cache = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n#         def move(cat, mouse, t):\n#             if t == 2 * n:\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if cache[cat][mouse][t] == -1:\n#                 mouse_move = (t % 2) == 0\n#                 if mouse_move:\n#                     best_result = 2\n#                     for pos in graph[mouse]:\n#                         result = move(cat, pos, t + 1)\n#                         if result == 1:\n#                             cache[cat][mouse][t] = 1\n#                             return 1\n#                         if result == 0:\n#                             best_result = 0\n#                 else:\n#                     best_result = 1\n#                     for pos in graph[cat]:\n#                         if pos == 0:\n#                             continue\n#                         result = move(pos, mouse, t + 1)\n#                         if result == 2:\n#                             cache[cat][mouse][t] = 2\n#                             return 2\n#                         if result == 0:\n#                             best_result = 0\n#                 cache[cat][mouse][t] = best_result\n#             return cache[cat][mouse][t]\n#         return move(2, 1, 0)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (mouse, cat, turn) ?\n        def parents(mouse, cat, turn):\n            prev_turn = 3 - turn\n            if prev_turn == MOUSE: \n                for m2 in graph[mouse]:\n                    yield m2, cat, prev_turn\n            else:\n                for c2 in graph[cat]:\n                    if c2:\n                        yield mouse, c2, prev_turn\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        colors = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for mouse in range(N):\n            for cat in range(N):\n                degree[mouse, cat, MOUSE] = len(graph[mouse])\n                degree[mouse, cat, CAT] = len(graph[cat]) - (0 in graph[cat])  # cat can not be at hole 0\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for cat in range(N):\n            for turn in [MOUSE, CAT]:\n                # color MOUSE for all node with mouse=0\n                mouse = 0\n                colors[mouse, cat, turn] = MOUSE\n                queue.append((mouse, cat, turn, MOUSE))\n                # color CAT for all node with mouse = cat !=0, cat can not be at hole 0\n                if cat > 0:\n                    mouse = cat\n                    colors[mouse, cat, turn] = CAT\n                    queue.append((mouse, cat, turn, CAT))\n\n        # percolate\n        while queue:\n            mouse, cat, turn, color = queue.popleft()\n            for prev_mouse, prev_cat, prev_turn in parents(mouse, cat, turn):\n                # if this parent is not colored :\n                if colors[prev_mouse, prev_cat, prev_turn] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if prev_turn == color: # winning move\n                        colors[prev_mouse, prev_cat, prev_turn] = color\n                        queue.append((prev_mouse, prev_cat, prev_turn, color))\n                        if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \n                            return color\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[prev_mouse, prev_cat, prev_turn] -= 1\n                        # if prev_turn != color, and all of its children are of this color\n                        # then prev color should be this color too\n                        if degree[prev_mouse, prev_cat, prev_turn] == 0:\n                            colors[prev_mouse, prev_cat, prev_turn] = color\n                            queue.append((prev_mouse, prev_cat, prev_turn, color))\n                            if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \n                                return color\n\n        return colors[1, 2, 1] # mouse at 1, cat at 2, MOUSE turn", "\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        MOUSE = 1\n        CAT = 2\n        DRAW = 0\n        states = collections.defaultdict(lambda: DRAW)\n        \n        \n        \n        n = len(graph) \n        for i in range(1, n):\n            states[i, i, MOUSE] = CAT\n            states[i, i, CAT] = CAT\n            states[0, i, MOUSE] = MOUSE\n            states[0, i, CAT] = MOUSE\n            \n        draws = dict()\n        for mouse in range(n):\n            for cat in range(1, n):\n                draws[mouse, cat, CAT] = len(graph[cat]) - (0 in graph[cat])\n                draws[mouse, cat, MOUSE] = len(graph[mouse])\n                    \n                    \n                        \n                        \n        def neighbor(mouse, cat, turn):\n            prev_turn = CAT if turn == MOUSE else MOUSE\n            if prev_turn == MOUSE:\n                for prev_mouse in graph[mouse]:\n                    yield prev_mouse, cat, prev_turn\n            else:\n                for prev_cat in graph[cat]:\n                    if prev_cat != 0:\n                        yield mouse, prev_cat, prev_turn\n        \n        queue = collections.deque()\n        for state in states.keys():\n            queue.append(state)\n        \n        while len(queue) > 0:\n            state = queue.popleft()\n            mouse, cat, turn = state\n            win = states[state]\n            \n            for prev_state in neighbor(*state):\n                prev_mouse, prev_cat, prev_turn = prev_state\n                if states[prev_state] != DRAW:\n                    continue\n                elif prev_turn == win:\n                    states[prev_state] = win\n                    queue.append(prev_state)\n                else:\n                    draws[prev_state] -= 1\n                    if draws[prev_state] == 0:\n                        states[prev_state] = turn\n                        queue.append(prev_state)\n                \n        return states[1, 2, MOUSE]", "class Solution:\n    # minimax\n    # https://www.youtube.com/watch?v=WJ7uqznd_4s\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        memo = {}\n\n        def mouse_play(key, cat, mouse, turn):\n            if any(v == 0 for v in graph[mouse]):\n                memo[key] = 1\n                return 1\n            res = 2\n            for nxt in graph[mouse]:\n                # mouse reach 0, mouse wins\n                # mouse would not run int place cat holds now\n                if nxt == cat:\n                    continue\n                tmp = move(cat, nxt, False)\n                # if mouse win, directly break, mouse would always take the optimal solution\n                if tmp == 1:\n                    res = 1\n                    break\n                if tmp == 0:\n                    res = 0\n            memo[key] = res\n\n            return res\n\n        def cat_play(key, cat, mouse, turn):\n            if any(v == mouse for v in graph[cat]):\n                memo[key] = 2\n                return 2\n            res = 1\n            for nxt in graph[cat]:\n                # if nxt == mouse:\n                #     memo[key] = 2\n                #     return 2\n                # cat can not enter hole\n                if nxt == 0:\n                    continue\n                tmp = move(nxt, mouse, True)\n                if tmp == 2:\n                    res = 2\n                    break\n                if tmp == 0:\n                    res = 0\n            memo[key] = res\n\n            return res\n\n        def move(cat, mouse, turn):\n            key = (cat, mouse, turn)\n            if key in memo:\n                return memo[key]\n\n            memo[key] = 0\n\n            if turn:\n                return mouse_play(key, cat, mouse, turn)\n            else:\n                return cat_play(key, cat, mouse, turn)\n\n        return move(2, 1, True)\n\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n        DRAW, MOUSE, CAT = 0, 1, 2\n\n        def parents(m, c, t):\n            if t == MOUSE:\n                for c2 in graph[c]:\n                    if c2:  # cat can not enter 0\n                        yield m, c2, 3 - t\n            if t == CAT:\n                for m2 in graph[m]:\n                    yield m2, c, 3 - t\n\n        color, degree = collections.defaultdict(int), {}\n\n        # (mouse, cat, turn), got the parents/children of this node, [[2,3],...], since the graph is un-directed\n        # you can say 2,3 -> 0 (parents) or 0 -> (2,3) children, here we regard it as parents\n        for m in range(N):\n            for c in range(N):\n                degree[m, c, MOUSE] = len(graph[m])\n                degree[m, c, CAT] = len(graph[c]) - (0 in graph[c])\n\n        que = collections.deque()\n        for i in range(N):\n            for t in range(1, 3):\n                color[0, i, t] = MOUSE\n                que.append((0, i, t))\n                if i > 0:\n                    color[i, i, t] = CAT\n                    que.append((i, i, t))\n\n        while que:\n            m, c, t = que.pop()\n            col = color[m, c, t]\n            # for (m,c,t)'s parents, if\n            for m2, c2, t2 in parents(m, c, t):\n                if color[m2, c2, t2] is DRAW:\n                    if t2 == col:  # mouse 's turn and it goes to MOUSE, or cat's turn, go to CAT\n                        color[m2, c2, t2] = col\n                        que.append((m2, c2, t2))\n                    else:\n                        # (m2,c2,t2) is (m,c,t)'s parent, if cat went to MOUSE, or mouse went to CAT,\n                        # this is a lose situation, degree -=1, which means we have a losing for its\n                        # one children, if all chidren are losing for this parent, ie, degree == 0\n                        # then we add it to queue\n                        degree[m2, c2, t2] -= 1\n                        if not degree[m2, c2, t2]:\n                            color[m2, c2, t2] = 3 - t2\n                            que.append((m2, c2, t2))\n\n        return color[1, 2, 1]\n\n\n", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        # observations:\n        # we can represent the game state with the triplet (mouse cat turn).\n        # (_ 0 _) is illegal.\n        # (0 _ _) = 1 (mouse victory).\n        # (x x _) = 2 (cat victory).\n        # if any possible move leads to win, current state is win:\n        # * (m c c) = 1 => (m' c m) = 1 for m' in g[m].\n        # * (m c m) = 2 => (m c' c) = 2 for c' in g[c].\n        # if all possible moves lead to loss, current state is loss.\n        # * (m c m) = 1, for c' in g[c], if all((m c'' m) = 1 for c'' in g[c']) => (m c' c) = 1\n        # * (m c c) = 2, for m' in g[m], if all((m'' c c) = 2 for m'' in g[m']) => (m' c m) = 2\n        # return (1 2 m). return once we know its value.\n\n        MTURN, CTURN = 0, 1\n        ILLEGAL, UNKNOWN, MWIN, CWIN = -1, 0, 1, 2\n\n        n = len(g)\n        s = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n        q = deque()\n\n        def sq(m, c, t, v):\n            if s[m][c][t] == UNKNOWN:\n                q.append((m, c, t))\n                s[m][c][t] = v\n\n        # set and enqueue initial known states.\n        for t in (MTURN, CTURN):\n            for m in range(n):\n                sq(m, 0, t, ILLEGAL)\n            for c in range(n):\n                sq(0, c, t, MWIN)\n            for x in range(n):\n                sq(x, x, t, CWIN)\n\n        while q:\n            m, c, t = state = q.popleft()\n\n            # apply production rules. for each unencountered resultant state, set and enqueue.\n            if t == CTURN and s[m][c][t] == MWIN:\n                for m_ in g[m]:\n                    sq(m_, c, MTURN, MWIN)\n\n            if t == MTURN and s[m][c][t] == CWIN:\n                for c_ in g[c]:\n                    sq(m, c_, CTURN, CWIN)\n\n            if t == MTURN and s[m][c][t] == MWIN:\n                for c_ in g[c]:\n                    if all(s[m][c__][MTURN] in (ILLEGAL, MWIN) for c__ in g[c_]):\n                        sq(m, c_, CTURN, MWIN)\n\n            if t == CTURN and s[m][c][t] == CWIN:\n                for m_ in g[m]:\n                    if all(s[m__][c][CTURN] in (ILLEGAL, CWIN) for m__ in g[m_]):\n                        sq(m_, c, MTURN, CWIN)\n\n            # once we know state[1,2,m], return it.\n            if s[1][2][MTURN]:\n                return s[1][2][MTURN]\n\n        # everything else is a draw.\n        return 0\n", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        # observations:\n        # we can represent the game state with the triplet (mouse cat turn).\n        # (_ 0 _) is illegal.\n        # (0 _ _) = 1 (mouse victory).\n        # (x x _) = 2 (cat victory).\n        # if any possible move leads to win, current state is win:\n        # * (m c c) = 1 => (m' c m) = 1 for m' in g[m].\n        # * (m c m) = 2 => (m c' c) = 2 for c' in g[c].\n        # if all possible moves lead to loss, current state is loss.\n        # * (m c m) = 1, for c' in g[c], if all((m c'' m) = 1 for c'' in g[c']) => (m c' c) = 1\n        # * (m c c) = 2, for m' in g[m], if all((m'' c c) = 2 for m'' in g[m']) => (m' c m) = 2\n        # return (1 2 m). return once we know its value.\n\n        MTURN, CTURN = 0, 1\n        ILLEGAL, UNKNOWN, MWIN, CWIN = -1, 0, 1, 2\n\n        n = len(g)\n        s = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n        q = deque()\n\n        def sq(m, c, t, v):\n            if s[m][c][t] == UNKNOWN:\n                q.append((m, c, t))\n                s[m][c][t] = v\n\n        # set and enqueue initial known states.\n        for t in (MTURN, CTURN):\n            for x in range(n):\n                sq(x, 0, t, ILLEGAL)\n                sq(0, x, t, MWIN)\n                sq(x, x, t, CWIN)\n\n        while q:\n            m, c, t = state = q.popleft()\n\n            # apply production rules. for each unencountered resultant state, set and enqueue.\n            if t == CTURN and s[m][c][t] == MWIN:\n                for m_ in g[m]:\n                    sq(m_, c, MTURN, MWIN)\n\n            if t == MTURN and s[m][c][t] == CWIN:\n                for c_ in g[c]:\n                    sq(m, c_, CTURN, CWIN)\n\n            if t == MTURN and s[m][c][t] == MWIN:\n                for c_ in g[c]:\n                    if all(s[m][c__][MTURN] in (ILLEGAL, MWIN) for c__ in g[c_]):\n                        sq(m, c_, CTURN, MWIN)\n\n            if t == CTURN and s[m][c][t] == CWIN:\n                for m_ in g[m]:\n                    if all(s[m__][c][CTURN] in (ILLEGAL, CWIN) for m__ in g[m_]):\n                        sq(m_, c, MTURN, CWIN)\n\n            # once we know state[1,2,m], return it.\n            if s[1][2][MTURN]:\n                return s[1][2][MTURN]\n\n        # everything else is a draw.\n        return 0\n", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        # observations:\n        # we can represent the game state with the triplet (mouse cat turn).\n        # (_ 0 _) is illegal.\n        # (0 _ _) = 1 (mouse victory).\n        # (x x _) = 2 (cat victory).\n        # if any possible move leads to win, current state is win:\n        # * (m c c) = 1 => (m' c m) = 1 for m' in g[m].\n        # * (m c m) = 2 => (m c' c) = 2 for c' in g[c].\n        # if all possible moves lead to loss, current state is loss.\n        # * (m c m) = 1, for c' in g[c], if all((m c'' m) = 1 for c'' in g[c']) => (m c' c) = 1\n        # * (m c c) = 2, for m' in g[m], if all((m'' c c) = 2 for m'' in g[m']) => (m' c m) = 2\n        # return (1 2 m). return once we know its value.\n\n        MTURN, CTURN = 0, 1\n        ILLEGAL, UNKNOWN, MWIN, CWIN = -1, 0, 1, 2\n\n        n = len(g)\n        s = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n        q = deque()\n\n        def sq(m, c, t, v):\n            if s[m][c][t] == UNKNOWN:\n                q.append((m, c, t))\n                s[m][c][t] = v\n\n        # set and enqueue initial known states.\n        for t in (MTURN, CTURN):\n            for x in range(n):\n                sq(x, 0, t, ILLEGAL)\n                sq(0, x, t, MWIN)\n                sq(x, x, t, CWIN)\n\n        while q:\n            m, c, t = q.popleft()\n\n            # apply production rules. for each unencountered resultant state, set and enqueue.\n            if t == CTURN and s[m][c][t] == MWIN:\n                for m_ in g[m]:\n                    sq(m_, c, MTURN, MWIN)\n\n            if t == MTURN and s[m][c][t] == CWIN:\n                for c_ in g[c]:\n                    sq(m, c_, CTURN, CWIN)\n\n            if t == MTURN and s[m][c][t] == MWIN:\n                for c_ in g[c]:\n                    if all(s[m][c__][MTURN] in (ILLEGAL, MWIN) for c__ in g[c_]):\n                        sq(m, c_, CTURN, MWIN)\n\n            if t == CTURN and s[m][c][t] == CWIN:\n                for m_ in g[m]:\n                    if all(s[m__][c][CTURN] in (ILLEGAL, CWIN) for m__ in g[m_]):\n                        sq(m_, c, MTURN, CWIN)\n\n            # once we know state[1,2,m], return it.\n            if s[1][2][MTURN]:\n                return s[1][2][MTURN]\n\n        # everything else is a draw.\n        return 0\n", "from functools import lru_cache\n\n\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        MOUSE, CAT, DRAW = 1, 2, 0\n        \n        @lru_cache(None)\n        def winner(mouse, cat, turn):\n            if turn >= len(graph)*2:\n                return DRAW\n            if turn%2 == 0:\n                if 0 in graph[mouse]:\n                    return MOUSE\n                answer = CAT\n                for i in graph[mouse]:\n                    if i == cat:\n                        continue\n                    result = winner(i, cat, turn+1)\n                    if result == MOUSE:\n                        return MOUSE\n                    if result == DRAW:\n                        answer = DRAW\n                return answer\n            else:\n                if mouse in graph[cat]:\n                    return CAT\n                answer = MOUSE\n                for i in graph[cat]:\n                    if i == 0:\n                        continue\n                    result = winner(mouse, i, turn+1)\n                    if result == CAT:\n                        return CAT\n                    if result == DRAW:\n                        answer = DRAW\n                return answer\n        \n        return winner(1, 2, 0)", "from collections import deque, defaultdict\n\n\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        DRAW, MOUSE, CAT = 0, 1, 2\n        \n        def parents(m, c, t):\n            if t == MOUSE:\n                return [(m, x, CAT) for x in graph[c] if x != 0]\n            return [(x, c, MOUSE) for x in graph[m]]\n                    \n        color = defaultdict(int)\n        for t in MOUSE, CAT:\n            for x in range(n):\n                color[0, x, t] = MOUSE\n                if x != 0:\n                    color[x, x, t] = CAT\n                    \n        degree = {}\n        for m in range(n):\n            for c in range(n):\n                degree[m, c, MOUSE] = len(parents(m, c, CAT))\n                degree[m, c, CAT] = len(parents(m, c, MOUSE))\n\n        q = deque()\n        for k, v in color.items():\n            q.append((*k, v))\n        \n        while q:\n            m, c, t, winner = q.popleft()\n            for m2, c2, t2 in parents(m, c, t):\n                if color[m2, c2, t2] != DRAW:\n                    continue\n                \n                if t2 == winner:\n                    color[m2, c2, t2] = winner\n                    q.append((m2, c2, t2, winner))\n                else:\n                    degree[m2, c2, t2] -= 1\n                    if degree[m2, c2, t2] == 0:\n                        color[m2, c2, t2] = t\n                        q.append((m2, c2, t2, t))\n        \n        return color[1, 2, 1]", "from collections import deque, defaultdict\n\n\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        DRAW, MOUSE, CAT = 0, 1, 2\n        \n        def parents(m, c, t):\n            if t == MOUSE:\n                return [(m, x, CAT) for x in graph[c] if x != 0]\n            return [(x, c, MOUSE) for x in graph[m]]\n                    \n        color = defaultdict(int)\n        for t in MOUSE, CAT:\n            for x in range(n):\n                color[0, x, t] = MOUSE\n                if x != 0:\n                    color[x, x, t] = CAT\n                    \n        degree = {}\n        for m in range(n):\n            for c in range(n):\n                degree[m, c, MOUSE] = len(parents(m, c, CAT))\n                degree[m, c, CAT] = len(parents(m, c, MOUSE))\n\n        q = deque()\n        for k, v in color.items():\n            q.append((*k, v))\n        \n        while q:\n            m, c, t, winner = q.popleft()\n            for m2, c2, t2 in parents(m, c, t):\n                if color[m2, c2, t2] != DRAW:\n                    continue\n                \n                if t2 == winner:\n                    color[m2, c2, t2] = winner\n                    q.append((m2, c2, t2, winner))\n                else:\n                    degree[m2, c2, t2] -= 1\n                    if degree[m2, c2, t2] == 0:\n                        color[m2, c2, t2] = winner\n                        q.append((m2, c2, t2, winner))\n        \n        return color[1, 2, 1]", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: \n                return 0\n            if x == y:\n                return 2\n            if x == 0:\n                return 1\n            \n            if (t%2==0):\n                flag = True\n                for i in range(len(graph[x])):\n                    nxt = search(t+1, graph[x][i], y)\n                    if nxt == 1:\n                        return 1\n                    elif nxt!=2:\n                        flag = False\n                if flag:\n                    return 2\n                return 0\n            else:\n                flag = True\n                for i in range(len(graph[y])):\n                    if graph[y][i]!=0:\n                        nxt = search(t + 1, x, graph[y][i])\n                        if nxt ==2:\n                            return 2\n                        elif nxt != 1:\n                            flag=False\n                if flag:\n                    return 1\n                else:\n                    return 0\n        n = len(graph)\n\n        return search(0, 1, 2)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        CAT_TURN = CAT_WIN = 2\n        MOUSE_TURN = MOUSE_WIN = 1\n        DRAW = 0\n        outcome = defaultdict(int)\n        degree = {}\n        for cat in range(n):\n            cat_neighbour_has_zero = 1 if 0 in graph[cat] else 0\n            for mouse in range(n):\n                degree[mouse, cat, 1] = len(graph[mouse])\n                degree[mouse, cat, 2] = len(graph[cat]) - cat_neighbour_has_zero\n                \n        queue = deque()\n        for cat in range(n):\n            for turn in [MOUSE_TURN, CAT_TURN]:\n                outcome[0, cat, turn] = MOUSE_WIN\n                queue.append((0, cat, turn, MOUSE_WIN))\n                if cat > 0:\n                    outcome[cat, cat, turn] = CAT_WIN\n                    queue.append((cat, cat, turn, CAT_WIN))\n                    \n        def previous(mouse, cat, turn):\n            if turn == MOUSE_TURN:\n                for prev_cat in graph[cat]:\n                    if prev_cat:\n                        yield mouse, prev_cat, 3 - turn\n            else:\n                for prev_mouse in graph[mouse]:\n                    yield prev_mouse, cat, 3 - turn\n         \n        target = (1, 2, 1)\n        while queue:\n            mouse, cat, turn, final_outcome = queue.popleft()\n            for prev_mouse, prev_cat, prev_turn in previous(mouse, cat, turn):\n                if outcome[prev_mouse, prev_cat, prev_turn] == DRAW:\n                    if prev_turn == final_outcome:\n                        outcome[prev_mouse, prev_cat, prev_turn] = final_outcome\n                        if (prev_mouse, prev_cat, prev_turn) == target:\n                            return final_outcome\n                        queue.append((prev_mouse, prev_cat, prev_turn, final_outcome))\n                    else:\n                        degree[prev_mouse, prev_cat, prev_turn] -= 1\n                        if degree[prev_mouse, prev_cat, prev_turn] == 0:\n                            if (prev_mouse, prev_cat, prev_turn) == target:\n                                return 3 - prev_turn\n                            outcome[prev_mouse, prev_cat, prev_turn] = 3 - prev_turn\n                            queue.append((prev_mouse, prev_cat, prev_turn, 3 - prev_turn))\n        return outcome[1, 2, 1]\n        \n        \n        \n        \n#         # For n nodes, the possible longest path in the graph is n. If the cat can win, \n#         # its distance to the mouse should decrease, after decease n times if still doesn't \n#         # catch the mouse, and mouse haven't reach node 0 yet, means this is a draw\n        \n#         # it takes at most n for mouse to get to 0. At 2*n time, it means mouse take a \n#         # detour of at least n steps. It means that there should be at least a loop(size n) \n#         # or multiple loops of (size < n).\n        \n#         n = len(graph)\n#         @lru_cache(None)\n#         def move(cat, mouse, t):\n#             # should be 2n but 0.8n also passes all tests\n#             if t > int(0.8 * n):\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if t % 2 == 0:\n#                 best_result = 2\n#                 for pos in graph[mouse]:\n#                     result = move(cat, pos, t + 1)\n#                     if result == 1:\n#                         return 1\n#                     if result == 0:\n#                         best_result = 0\n#             else:\n#                 best_result = 1\n#                 for pos in graph[cat]:\n#                     if pos == 0:\n#                         continue\n#                     result = move(pos, mouse, t + 1)\n#                     if result == 2:\n#                         return 2\n#                     if result == 0:\n#                         best_result = 0\n#             return best_result\n#         return move(2, 1, 0)\n        \n        \n        \n        \n#         n = len(graph)\n#         cache = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n#         def move(cat, mouse, t):\n#             if t == 2 * n:\n#                 return 0\n#             elif mouse == 0:\n#                 return 1\n#             elif cat == mouse:\n#                 return 2\n#             if cache[cat][mouse][t] == -1:\n#                 mouse_move = (t % 2) == 0\n#                 if mouse_move:\n#                     best_result = 2\n#                     for pos in graph[mouse]:\n#                         result = move(cat, pos, t + 1)\n#                         if result == 1:\n#                             cache[cat][mouse][t] = 1\n#                             return 1\n#                         if result == 0:\n#                             best_result = 0\n#                 else:\n#                     best_result = 1\n#                     for pos in graph[cat]:\n#                         if pos == 0:\n#                             continue\n#                         result = move(pos, mouse, t + 1)\n#                         if result == 2:\n#                             cache[cat][mouse][t] = 2\n#                             return 2\n#                         if result == 0:\n#                             best_result = 0\n#                 cache[cat][mouse][t] = best_result\n#             return cache[cat][mouse][t]\n#         return move(2, 1, 0)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n        \n        def parents(m, c, t):\n            if t == 2:\n                for m2 in graph[m]:\n                    yield m2, c, 3-t\n            else:\n                for c2 in graph[c]:\n                    if c2:\n                        yield m, c2, 3-t\n        \n        DRAW, MOUSE, CAT=0,1,2\n        color = collections.defaultdict(int)\n        \n        degree = {}\n        for m in range(N):\n            for c in range(N):\n                degree[m,c,1] = len(graph[m])\n                degree[m,c,2] = len(graph[c]) - (0 in graph[c])\n        \n        queue = collections.deque([])\n        for i in range(N):\n            for t in range(1, 3):\n                color[0,i,t] = MOUSE\n                queue.append((0,i,t,MOUSE))\n                if i > 0:\n                    color[i,i,t] = CAT\n                    queue.append((i,i,t,CAT))\n        \n        while queue:\n            i, j, t, c = queue.popleft()\n            for i2, j2, t2 in parents(i, j, t):\n                # if this parent node is not colored\n                if color[i2,j2,t2] is DRAW:\n                    if t2 == c:#winning move\n                        color[i2,j2,t2] = c\n                        queue.append((i2,j2,t2,c))\n                    else:\n                        degree[i2,j2,t2] -= 1\n                        if degree[i2,j2,t2] == 0:\n                            color[i2,j2,t2] = 3-t2\n                            queue.append((i2,j2,t2,3-t2))\n        return color[1,2,1]\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n        # dp[t][i][j] := game outcome when at time t, mouse at i, cat at j\n        ## 0: draw, 1: mouse wins, 2: cat wins\n        dp = [[[-1]*N for _ in range(N)] for m in range(2*N)]\n        \n        for m in range(2*N):\n            for i in range(N):\n                dp[m][i][i] = 2 # win by cat\n                dp[m][0][i] = 1 # win by mouse\n        # dp = 0 when m==2N\n        \n        def _search(t, x, y):\n            # time, mouse pos, cat pos\n            if t==2*N: return 0\n            if dp[t][x][y]!=-1: return dp[t][x][y]\n            \n            if t%2==0: # mouse's turn\n                winByCat = True\n                for i in graph[x]:\n                    nxt = _search(t+1, i, y)\n                    if nxt==1:\n                        dp[t][x][y] = 1\n                        return 1\n                    if nxt!=2:\n                        winByCat = False\n                if winByCat:\n                    dp[t][x][y] = 2\n                    return 2\n                else:\n                    dp[t][x][y] = 0\n                    return 0\n            else: # cat's turn\n                winByMouse = True\n                for i in graph[y]:\n                    if i!=0: # cat cannot be at the hole -- 0\n                        nxt = _search(t+1, x, i)\n                        if nxt==2:\n                            dp[t][x][y] = 2\n                            return 2\n                        if nxt!=1:\n                            winByMouse = False\n                if winByMouse:\n                    dp[t][x][y] = 1\n                    return 1\n                else:\n                    dp[t][x][y] = 0\n                    return 0\n        \n        \n        return _search(0, 1, 2)", "from functools import lru_cache\nfrom collections import defaultdict\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        adj = defaultdict(list)\n        for i in range(len(graph)):\n            for j in graph[i]:\n                adj[i].append(j)\n                adj[j].append(i)\n        \n        @lru_cache(None)\n        def search(m: int, c: int, turn: int, time: int) -> int:\n            # 1: mouse wins, 2: cat wins, 0: draw\n            if m == 0:\n                return 1\n            elif m == c:\n                return 2\n            elif time >= 50:\n                return 0\n            if turn == 0: # mouse moves\n                can_draw = False\n                for y in adj[m]:\n                    res = search(y, c, 1 - turn, time + 1)\n                    if res == 1:\n                        return 1\n                    elif res == 0:\n                        can_draw = True\n                return 0 if can_draw else 2\n            else:\n                can_draw = False\n                for y in adj[c]:\n                    if y == 0:\n                        continue\n                    res = search(m, y, 1 - turn, time + 1)\n                    if res == 2:\n                        return 2\n                    elif res == 0:\n                        can_draw = True\n                return 0 if can_draw else 1\n        \n        return search(1, 2, 0, 0)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        encode = lambda p, c, m: (c << 7) | (m << 1) | p\n        # encode = lambda p, c, m: (p, c, m)\n        decode = lambda c: (c & 0x1, c >> 7, (c >> 1) & 0x3f)\n        n = len(graph)\n        g = collections.defaultdict(list)\n        outcomes = {}\n        degrees = collections.Counter()\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    status = encode(p, c, m)\n                    if p == 0:\n                        if c == m:\n                            outcomes[status] = 1\n                        elif m == 0:\n                            outcomes[status] = -1\n                    else:\n                        if m == 0:\n                            outcomes[status] = 1\n                        elif c == m:\n                            outcomes[status] = -1\n                    if outcomes.get(status, 0):\n                        continue\n                    if p == 0:\n                        for i in graph[c]:\n                            if i == 0: continue\n                            st = encode((p + 1) % 2, i, m)\n                            g[st].append(status)\n                            degrees[status] += 1\n                    else:\n                        for i in graph[m]:\n                            st = encode((p + 1) % 2, c, i)\n                            g[st].append(status)\n                            degrees[status] += 1\n        # for st, nei in g.items():\n        #     print(st, nei)\n        # print(outcomes)\n        def dfs(status):\n            visited.add(status)\n            if status == initial:\n                return True\n            for st in g[status]:\n                if st not in visited:\n                    if outcomes[status] == -1:\n                        outcomes[st] = 1\n                    else:\n                        degrees[st] -= 1\n                        if degrees[st] == 0:\n                            outcomes[st] = -1\n                        else:\n                            continue\n                    if dfs(st):\n                        return True\n            return False\n        visited = set()\n        initial = encode(1, 2, 1)\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    st = encode(p, c, m)\n                    if outcomes.get(st, 0) and st not in visited:\n                        if dfs(st):\n                            o = outcomes.get(encode(1, 2, 1), 0)\n                            if o == -1:\n                                o = 2\n                            return o\n        return 0\n        \n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        dp = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n        return self.search(graph, dp, 1, 2, 0)\n        \n    def search(self, graph, dp, x, y, z):\n        if z == 2 * len(graph): return 0\n        if dp[x][y][z] == -1:     \n            if x == 0: res = 1\n            elif x == y: res = 2\n            elif z % 2 == 0:\n                draw, res = False, None\n                for nx in graph[x]:\n                    ans = self.search(graph, dp, nx, y, z + 1)\n                    if ans == 1:\n                        res = 1\n                        break\n                    elif ans == 0:\n                        draw = True\n                res = res if res else (0 if draw else 2)\n            else:\n                draw, res = False, None\n                for ny in graph[y]:\n                    if ny == 0: continue\n                    ans = self.search(graph, dp, x, ny, z + 1)\n                    if ans == 2:\n                        res = 2\n                        break\n                    elif ans == 0:\n                        draw = True\n                res = res if res else (0 if draw else 1)\n            dp[x][y][z] = res\n        return dp[x][y][z]", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        cache = [[[-1] * (2 * n) for _ in range(n)] for _ in range(n)]\n        def move(cat, mouse, t):\n            if t == 2 * n:\n                return 0\n            elif mouse == 0:\n                return 1\n            elif cat == mouse:\n                return 2\n            if cache[cat][mouse][t] == -1:\n                mouse_move = (t % 2) == 0\n                if mouse_move:\n                    best_result = 2\n                    for pos in graph[mouse]:\n                        result = move(cat, pos, t + 1)\n                        if result == 1:\n                            cache[cat][mouse][t] = 1\n                            return 1\n                        if result == 0:\n                            best_result = 0\n                else:\n                    best_result = 1\n                    for pos in graph[cat]:\n                        if pos == 0:\n                            continue\n                        result = move(pos, mouse, t + 1)\n                        if result == 2:\n                            cache[cat][mouse][t] = 2\n                            return 2\n                        if result == 0:\n                            best_result = 0\n                cache[cat][mouse][t] = best_result\n            return cache[cat][mouse][t]\n        return move(2, 1, 0)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        def dp(mp, cp, turn):\n            if turn>=N: return 0\n            if mp==0: return 1\n            if mp==cp: return 2\n            \n            if (mp, cp, turn) in memo: return memo[(mp, cp, turn)]\n            \n            res = 0\n            if turn%2==0:\n                if any(dp(nxt, cp, turn+1)==1 for nxt in graph[mp]):\n                    res = 1\n                elif all(dp(nxt, cp, turn+1)==2 for nxt in graph[mp]):\n                    res = 2\n            else:\n                if any(dp(mp, nxt, turn+1)==2 for nxt in graph[cp] if nxt!=0):\n                    res = 2\n                elif all(dp(mp, nxt, turn+1)==1 for nxt in graph[cp] if nxt!=0):\n                    res = 1\n                        \n            memo[(mp, cp, turn)] = res\n            return res\n                    \n        N = len(graph)\n        memo = {}\n        return dp(1, 2, 0)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: \n                return 0\n            if x == y:\n                return 2\n            if x == 0:\n                return 1\n            \n            if (t%2==0):\n                flag = True\n                for i in range(len(graph[x])):\n                    nxt = search(t+1, graph[x][i], y)\n                    if nxt == 1:\n                        return 1\n                    elif nxt!=2:\n                        flag = False\n                if flag:\n                    return 2\n                return 0\n            else:\n                flag = True\n                for i in range(len(graph[y])):\n                    if graph[y][i]!=0:\n                        nxt = search(t + 1, x, graph[y][i])\n                        if nxt ==2:\n                            return 2\n                        elif nxt != 1:\n                            flag=False\n                if flag:\n                    return 1\n                else:\n                    return 0\n        n = len(graph)\n        dp = [ [ [-1 for k in range(n)] for j in range(n)] for i in range(2*n)]\n        return search(0, 1, 2)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n        lim = 2 * N\n        \n        @lru_cache(maxsize=None)\n        def _visit(state: Tuple[int, int, int], t):\n            if t >= lim:\n                return 0\n\n            x, y, p = state\n            if x == 0:\n                return 1\n            elif x == y :\n                return 2\n            \n            if p == 1:\n                it = (_visit((n, y, 2), t+1) for n in graph[x])\n            else:\n                it = (_visit((x, n, 1), t+1) for n in graph[y] if n != 0)\n            \n            update = 1 if p == 2 else 2\n            \n            for v in it:\n                if v == p:\n                    return p\n                elif v == 0:\n                    update = 0\n            \n            return update\n\n        r = _visit((1, 2, 1), 0)\n        return r", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        \n        # status: current_mouse_position, current_cat_position, move_next(0 : mouse, 1 : cat)\n        \n        for i in range(len(g)):\n            g[i] = set(g[i])\n        \n        out_degree = {}\n        for mouse in range(len(g)):\n            for cat in range(1, len(g)):\n                out_degree[(mouse, cat, 0)] = len(g[mouse])\n                out_degree[(mouse, cat, 1)] = len(g[cat]) - (0 in g[cat])\n        \n        \n        visit = set()\n        status_result = deque()\n        for cat in range(1, len(g)):\n            status_result.append([0, cat, 1, 1])\n            status_result.append([0, cat, 0, 1])\n            visit.add((0, cat, 1))\n            visit.add((0, cat, 0))\n            \n        for mouse in range(1, len(g)):\n            status_result.append([mouse, mouse, 0, 2])\n            status_result.append([mouse, mouse, 1, 2])\n            visit.add((mouse, mouse, 0))\n            visit.add((mouse, mouse, 1))\n        \n        idx = 0\n        while len(status_result):\n            idx += 1\n            # print(status_result)\n            mouse, cat, move_next, result = status_result.popleft()\n            if mouse == 1 and cat == 2 and move_next == 0:\n                return result\n            move_prev = 1 - move_next\n            if move_prev == 0:\n                for p in g[mouse]:\n                    if result == 1:\n                        if (p, cat, 0) not in visit:\n                            status_result.append([p, cat, 0, 1])\n                            visit.add((p, cat, 0))\n                    else:\n                        out_degree[(p, cat, 0)] -= 1\n                        if out_degree[(p, cat, 0)] == 0 and (p, cat, 0) not in visit:\n                            status_result.append([p, cat, 0, 2])\n                            visit.add((p, cat, 0))\n            elif move_prev == 1:\n                for p in g[cat]:\n                    if p != 0:\n                        if result == 2:\n                            if (mouse, p, 1) not in visit:\n                                status_result.append([mouse, p, 1, 2])\n                                visit.add((mouse, p, 1))\n                        else:\n                            out_degree[(mouse, p, 1)] -= 1\n                            if out_degree[(mouse, p, 1)] == 0 and (mouse, p, 1) not in visit:\n                                status_result.append([mouse, p, 1, 1])\n                                visit.add((mouse, p, 1))\n        return 0\n                    \n                    \n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        self.dp = [[[-1]*n for _ in range(n)] for _ in range(2*n)]\n        def helper(t, x, y):\n            if t==2*n: return 0\n            if x==y:\n                self.dp[t][x][y]=2\n                return 2\n            if x==0:\n                self.dp[t][x][y]=1\n                return 1\n            if self.dp[t][x][y]!=-1:\n                return self.dp[t][x][y]\n            mouseTurn = t%2==0\n            if mouseTurn:\n                catWins=True\n                for nei in graph[x]:\n                    tmp = helper(t+1, nei, y)\n                    if tmp==1:\n                        self.dp[t][x][y]=1\n                        return 1\n                    if tmp!=2:\n                        catWins=False\n                if catWins:\n                    self.dp[t][x][y]=2\n                    return 2\n                else:\n                    self.dp[t][x][y]=0\n                    return 0\n            else:\n                mouseWins=True\n                for nei in graph[y]:\n                    if nei==0: continue\n                    tmp = helper(t+1, x, nei)\n                    if tmp==2:\n                        self.dp[t][x][y]=2\n                        return 2\n                    if tmp!=1:\n                        mouseWins=False\n                if mouseWins:\n                    self.dp[t][x][y]=1\n                    return 1\n                else:\n                    self.dp[t][x][y]=0\n                    return 0\n            return self.dp[t][x][y]\n        return helper(0, 1, 2)", "class Solution:\n    def catMouseGame(self, graph):\n        TIE                     = 0\n        MOUSE_WIN               = 1\n        CAT_WIN                 = 2\n        MOUSE_TURN              = 'MOUSE'\n        CAT_TURN                = 'CAT'\n        HOLE_POSITION           = 0\n        INITIAL_MOUSE_POSITION  = 1\n        INITIAL_CAT_POSITION    = 2\n\n        win_states = {}\n        for m_pos, _ in enumerate(graph):\n            for c_pos, _ in enumerate(graph):\n                for turn in [MOUSE_TURN, CAT_TURN]:\n                    key = (m_pos, c_pos, turn)\n                    if m_pos == 0 or c_pos == 0:\n                        # If the mouse reaches the hole, the mouse wins.\n                        # The cat also isn't allowed to go on the node corresponding\n                        # to the hole, so mark the cat doing that as also a win.\n                        win_states[key] = MOUSE_WIN\n                    elif m_pos == c_pos:\n                        win_states[key] = CAT_WIN\n                    else:\n                        win_states[key] = TIE\n        for node_id in graph:\n            turn = MOUSE_TURN\n            for m_pos, _ in enumerate(graph):\n                for c_pos, _ in enumerate(graph):\n                    all_cat_win = False\n                    if win_states[(m_pos, c_pos, turn)] == TIE:\n                        neighbor_states = [win_states[(node, c_pos, CAT_TURN)] for node in graph[m_pos]]\n                        if all(win == CAT_WIN for win in neighbor_states):\n                            win_states[(m_pos, c_pos, turn)] = CAT_WIN\n                        elif any(win == MOUSE_WIN for win in neighbor_states):\n                            win_states[(m_pos, c_pos, turn)] = MOUSE_WIN\n            turn = CAT_TURN\n            for m_pos, _ in enumerate(graph):\n                for c_pos, _ in enumerate(graph):\n                    if win_states[(m_pos, c_pos, turn)] == TIE:\n                        neighbor_states = [win_states[(m_pos, node, MOUSE_TURN)] for node in graph[c_pos]]\n                        if all(win == MOUSE_WIN for win in neighbor_states):\n                            win_states[(m_pos, c_pos, turn)] = MOUSE_WIN\n                        elif any(win == CAT_WIN for win in neighbor_states):\n                            win_states[(m_pos, c_pos, turn)] = CAT_WIN\n\n        return win_states[(1, 2, MOUSE_TURN)]\n", "class Solution:\n    # O(n^4) time, O(n^3) space\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        edges = defaultdict(list)\n        for i, nbrs in enumerate(graph):\n            for nbr in nbrs:\n                edges[i].append(nbr)\n                edges[nbr].append(i)\n        \n        # cache = {}\n        @lru_cache(None)\n        def can_win(cat_pos, mouse_pos, remaining_moves, is_cats_turn):\n            # state = cat_pos, mouse_pos, is_cats_turn, remaining_moves\n            # if state in cache:\n            #     return cache[state]\n            if mouse_pos == 0:  # mouse wins\n                if is_cats_turn:\n                    # cache[state] = -1\n                    return -1\n                # cache[state] = 1\n                return 1\n            if cat_pos == mouse_pos:  # cat wins\n                if is_cats_turn:\n                    # cache[state] = 1\n                    return 1\n                # cache[state] = -1\n                return -1\n            if remaining_moves == 0:  # draw\n                # cache[state] = 0\n                return 0\n            \n            opponents_worst_case = 1\n            if is_cats_turn:\n                for nbr in edges[cat_pos]:\n                    if nbr == 0:\n                        continue\n                    opponents_worst_case = min(\n                        opponents_worst_case, can_win(nbr, mouse_pos, remaining_moves - 1, not is_cats_turn)\n                    )\n            else:\n                for nbr in edges[mouse_pos]:\n                    opponents_worst_case = min(\n                        opponents_worst_case, can_win(cat_pos, nbr, remaining_moves - 1, not is_cats_turn)\n                    )\n            \n            # cache[state] = -opponents_worst_case\n            return -opponents_worst_case\n        \n        mouse_outcome = can_win(2, 1, 2 * n, False)\n        if mouse_outcome == 1:\n            return 1\n        if mouse_outcome == -1:\n            return 2\n        return 0\n    \n#     def catMouseGame(self, graph: List[List[int]]) -> int:\n#         n = len(graph)\n#         edges = defaultdict(list)\n#         for i, nbrs in enumerate(graph):\n#             for nbr in nbrs:\n#                 edges[i].append(nbr)\n#                 edges[nbr].append(i)\n        \n#         q = [(1, 2)]\n#         seen = set()\n#         seen.add((1, 2))\n#         step = 0\n#         is_mouses_turn = True\n#         while q:\n#             if step > 2 * n:\n#                 break\n#             # last round is cat's turn\n#             if is_mouses_turn and any(cat_pos == mouse_pos for mouse_pos, cat_pos in q):\n#                 return 2\n#             # last round is mouse's turn\n#             if not is_mouses_turn and any(mouse_pos == 0 for mouse_pos, _ in q):\n#                 return 1\n            \n#             q2 = []\n#             for mouse_pos, cat_pos in q:\n#                 if is_mouses_turn:\n#                     for nbr in edges[mouse_pos]:\n#                         next_state = nbr, cat_pos\n#                         if next_state in seen:\n#                             continue\n#                         q2.append(next_state)\n#                         seen.add(next_state)\n#                 else:\n#                     for nbr in edges[cat_pos]:\n#                         if nbr == 0:\n#                             continue\n#                         next_state = mouse_pos, nbr\n#                         if next_state in seen:\n#                             continue\n#                         q2.append(next_state)\n#                         seen.add(next_state)\n#             q = q2\n#             step += 1\n#             is_mouses_turn = not is_mouses_turn\n            \n#         return 0\n            \n        \n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: return 0\n            if x == y: return 2\n            if x == 0:return 1\n            if (t%2==0):# mouse's turn. Mouse will win if the mouse can find any winable node for the next step. If all the next step is winable for cats, then mouse lose.\n                if any(search(t+1, x_nxt, y)==1 for x_nxt in graph[x]):return 1\n                if all(search(t+1, x_nxt, y)==2 for x_nxt in graph[x]):return 2\n                return 0\n            else:# cat's turn\n                if any(search(t+1, x, y_nxt)==2 for y_nxt in graph[y] if y_nxt!=0):return 2\n                if all(search(t+1, x, y_nxt)==1 for y_nxt in graph[y] if y_nxt!=0):return 1\n                return 0\n        return search(0, 1, 2)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # encode = lambda p, c, m: (c << 7) | (m << 1) | p\n        encode = lambda p, c, m: (p, c, m)\n        decode = lambda c: (c & 0x1, c >> 7, (c >> 1) & 0x3f)\n        n = len(graph)\n        g = collections.defaultdict(list)\n        outcomes = {}\n        degrees = collections.Counter()\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    status = encode(p, c, m)\n                    if p == 0:\n                        if c == m:\n                            outcomes[status] = 1\n                        elif m == 0:\n                            outcomes[status] = -1\n                    else:\n                        if m == 0:\n                            outcomes[status] = 1\n                        elif c == m:\n                            outcomes[status] = -1\n                    if outcomes.get(status, 0):\n                        continue\n                    if p == 0:\n                        for i in graph[c]:\n                            if i == 0: continue\n                            st = encode((p + 1) % 2, i, m)\n                            g[st].append(status)\n                            degrees[status] += 1\n                    else:\n                        for i in graph[m]:\n                            st = encode((p + 1) % 2, c, i)\n                            g[st].append(status)\n                            degrees[status] += 1\n        # for st, nei in g.items():\n        #     print(st, nei)\n        # print(outcomes)\n        def dfs(status):\n            visited.add(status)\n            for st in g[status]:\n                if st not in visited:\n                    if outcomes[status] == -1:\n                        outcomes[st] = 1\n                    else:\n                        degrees[st] -= 1\n                        if degrees[st] == 0:\n                            outcomes[st] = -1\n                        else:\n                            continue\n                    dfs(st)\n        visited = set()\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    st = encode(p, c, m)\n                    if outcomes.get(st, 0) and st not in visited:\n                        dfs(st)\n        \n        o = outcomes.get(encode(1, 2, 1), 0)\n        if o == -1:\n            o = 2\n        return o", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        encode = lambda p, c, m: (c << 7) | (m << 1) | p\n        # encode = lambda p, c, m: (p, c, m)\n        decode = lambda c: (c & 0x1, c >> 7, (c >> 1) & 0x3f)\n        n = len(graph)\n        g = collections.defaultdict(list)\n        outcomes = {}\n        degrees = collections.Counter()\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    status = encode(p, c, m)\n                    if p == 0:\n                        if c == m:\n                            outcomes[status] = 1\n                        elif m == 0:\n                            outcomes[status] = -1\n                    else:\n                        if m == 0:\n                            outcomes[status] = 1\n                        elif c == m:\n                            outcomes[status] = -1\n                    if outcomes.get(status, 0):\n                        continue\n                    if p == 0:\n                        for i in graph[c]:\n                            if i == 0: continue\n                            st = encode((p + 1) % 2, i, m)\n                            g[st].append(status)\n                            degrees[status] += 1\n                    else:\n                        for i in graph[m]:\n                            st = encode((p + 1) % 2, c, i)\n                            g[st].append(status)\n                            degrees[status] += 1\n        # for st, nei in g.items():\n        #     print(st, nei)\n        # print(outcomes)\n        def dfs(status):\n            visited.add(status)\n            for st in g[status]:\n                if st not in visited:\n                    if outcomes[status] == -1:\n                        outcomes[st] = 1\n                    else:\n                        degrees[st] -= 1\n                        if degrees[st] == 0:\n                            outcomes[st] = -1\n                        else:\n                            continue\n                    dfs(st)\n        visited = set()\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    st = encode(p, c, m)\n                    if outcomes.get(st, 0) and st not in visited:\n                        dfs(st)\n        \n        o = outcomes.get(encode(1, 2, 1), 0)\n        if o == -1:\n            o = 2\n        return o", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        def search(t, x, y):\n            if t == len(graph) * 2: return 0\n            if x == y:\n                dp[t][x][y] = 2\n                return 2\n            if x == 0:\n                dp[t][x][y] = 1\n                return 1\n            if dp[t][x][y] != -1:return dp[t][x][y]\n            if (t%2==0):# mouse's turn\n                flag = True\n                for i in range(len(graph[x])):\n                    nxt = search(t+1, graph[x][i], y)\n                    if nxt == 1:\n                        dp[t][x][y] = 1\n                        return 1\n                    elif nxt!=2:\n                        flag = False\n                if flag:\n                    dp[t][x][y] = 2\n                    return 2\n                dp[t][x][y] = 0\n                return 0\n            else:# cat's turn\n                flag = True\n                for i in range(len(graph[y])):\n                    if graph[y][i]!=0:\n                        nxt = search(t + 1, x, graph[y][i])\n                        if nxt ==2:\n                            dp[t][x][y] = 2\n                            return 2\n                        elif nxt != 1:flag=False\n                if flag:\n                    dp[t][x][y] = 1\n                    return 1\n                else:\n                    dp[t][x][y] = 0\n                    return 0\n        n = len(graph)\n        dp = [ [ [-1 for k in range(n)] for j in range(n)] for i in range(2*n)]\n        return search(0, 1, 2)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        encode = lambda p, c, m: (c << 7) | (m << 1) | p\n        # encode = lambda p, c, m: (p, c, m)\n        decode = lambda c: (c & 0x1, c >> 7, (c >> 1) & 0x3f)\n        n = len(graph)\n        g = collections.defaultdict(list)\n        outcomes = {}\n        degrees = collections.Counter()\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    status = encode(p, c, m)\n                    if p == 0:\n                        if c == m:\n                            outcomes[status] = 1\n                        elif m == 0:\n                            outcomes[status] = -1\n                    else:\n                        if m == 0:\n                            outcomes[status] = 1\n                        elif c == m:\n                            outcomes[status] = -1\n                    if outcomes.get(status, 0):\n                        continue\n                    if p == 0:\n                        for i in graph[c]:\n                            if i == 0: continue\n                            st = encode((p + 1) % 2, i, m)\n                            g[st].append(status)\n                            degrees[status] += 1\n                    else:\n                        for i in graph[m]:\n                            st = encode((p + 1) % 2, c, i)\n                            g[st].append(status)\n                            degrees[status] += 1\n        # for st, nei in g.items():\n        #     print(st, nei)\n        # print(outcomes)\n        def dfs(status):\n            visited.add(status)\n            if status == initial:\n                return True\n            for st in g[status]:\n                if st not in visited:\n                    if outcomes[status] == -1:\n                        outcomes[st] = 1\n                    else:\n                        degrees[st] -= 1\n                        if degrees[st] == 0:\n                            outcomes[st] = -1\n                        else:\n                            continue\n                    if dfs(st):\n                        return True\n        visited = set()\n        initial = encode(1, 2, 1)\n        for c in range(1, n):\n            for m in range(n):\n                for p in range(2):\n                    st = encode(p, c, m)\n                    if outcomes.get(st, 0) and st not in visited:\n                        dfs(st)\n        \n        o = outcomes.get(encode(1, 2, 1), 0)\n        if o == -1:\n            o = 2\n        return o", "class Solution:\n    def catMouseGame(self, graph):\n        import functools\n        n=len(graph)\n        \n        @lru_cache(None)\n        def dp(t,x,y):\n            if t==2*n:\n                return 0\n            if x==y:\n                return 2\n            if x==0:\n                return 1\n            if t%2==0:\n                if any(dp(t+1,xn,y)==1 for xn in graph[x]):\n                    return 1\n                if all(dp(t+1,xn,y)==2 for xn in graph[x]):\n                    return 2\n                return 0\n            else:\n                if any(dp(t+1,x,yn)==2 for yn in graph[y] if yn!=0):\n                    return 2\n                if all(dp(t+1,x,yn)==1 for yn in graph[y] if yn!=0):\n                    return 1\n                return 0\n        return dp(0,1,2)", "from functools import lru_cache\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: return 0\n            if x == y: return 2\n            if x == 0:return 1\n            if (t%2==0):# mouse's turn. Mouse will win if the mouse can find any winable node for the next step. If all the next step is winable for cats, then mouse lose.\n                if any(search(t+1, x_nxt, y)==1 for x_nxt in graph[x]):return 1\n                if all(search(t+1, x_nxt, y)==2 for x_nxt in graph[x]):return 2\n                return 0\n            else:# cat's turn\n                if any(search(t+1, x, y_nxt)==2 for y_nxt in graph[y] if y_nxt!=0):return 2\n                if all(search(t+1, x, y_nxt)==1 for y_nxt in graph[y] if y_nxt!=0):return 1\n                return 0\n        return search(0, 1, 2)\n", "class Solution:\n    def catMouseGame(self, graph):\n    \n        from functools import lru_cache\n        N=len(graph)\n        @lru_cache(None)\n        def search(t,x,y):\n            if t==2*N:\n                return 0\n            if x==y:\n                return 2\n            if x==0:\n                return 1\n            if (t%2==0):\n                if any(search(t+1,xn,y)==1 for xn in graph[x]):\n                    return 1\n                if all(search(t+1,xn,y)==2 for xn in graph[x]):\n                    return 2\n                return 0\n            else:\n                if all(search(t+1,x,yn)==1 for yn in graph[y] if yn!=0):\n                    return 1\n                if any(search(t+1,x,yn)==2 for yn in graph[y] if yn!=0):\n                    return 2\n                return 0\n        return search(0,1,2)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        dp = {}\n        n = len(graph)\n\n        def dfs(im, ic, nmove):\n            mouse_move = nmove % 2\n            if im == 0:\n                return 1\n            if im == ic:\n                return 2\n            if nmove >= 2 * n + 1:\n                dp[(im, ic, nmove)] = 0\n                return 0\n            if (im, ic, nmove) in dp:\n                return dp[(im, ic, nmove)]\n                        \n            wins = [0, 0, 0]\n            ret = None\n            if mouse_move:\n                for nxt in graph[im]:    \n                    idx = dfs(nxt, ic, nmove + 1)\n                    wins[idx] += 1\n                    if idx == 1:\n                        break\n                if wins[1] > 0:\n                    ret = 1\n                elif wins[0] > 0:\n                    ret = 0\n                else:\n                    ret = 2\n            else:\n                for nxt in graph[ic]:\n                    if nxt != 0:\n                        idx = dfs(im, nxt, nmove + 1)\n                        wins[idx] += 1\n                        if idx == 2:\n                            break\n                \n                if wins[2] > 0:\n                    ret = 2\n                elif wins[0] > 0:\n                    ret = 0\n                else:\n                    ret = 1\n            dp[(im, ic, nmove)] = ret\n            return ret\n        \n        res = dfs(1, 2, 1)\n        return res\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        def search(t, x, y):\n            if t == len(graph) * 2: return 0\n            if x == y:\n                dp[t][x][y] = 2\n                return 2\n            if x == 0:\n                dp[t][x][y] = 1\n                return 1\n            if dp[t][x][y] != -1:return dp[t][x][y]\n            if (t%2==0):# mouse's turn\n                flag = True\n                for i in range(len(graph[x])):\n                    nxt = search(t+1, graph[x][i], y)\n                    if nxt == 1:\n                        dp[t][x][y] = 1\n                        return 1\n                    elif nxt!=2:\n                        flag = False\n                if flag:\n                    dp[t][x][y] = 2\n                    return 2\n                dp[t][x][y] = 0\n                return 0\n            else:# cat's turn\n                flag = True\n                for i in range(len(graph[y])):\n                    if graph[y][i]!=0:\n                        nxt = search(t + 1, x, graph[y][i])\n                        if nxt ==2:\n                            dp[t][x][y] = 2\n                            return 2\n                        elif nxt != 1:flag=False\n                if flag:\n                    dp[t][x][y] = 1\n                    return 1\n                else:\n                    dp[t][x][y] = 0\n                    return 0\n        n = len(graph)\n        dp = [ [ [-1 for k in range(n)] for j in range(n)] for i in range(2*n)]\n        return search(0, 1, 2)\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n        # dp[t][i][j] := game outcome when at time t, mouse at i, cat at j\n        ## 0: draw, 1: mouse wins, 2: cat wins\n        dp = [[[-1]*N for _ in range(N)] for m in range(2*N)]\n        \n        for m in range(2*N):\n            for i in range(N):\n                dp[m][i][i] = 2 # win by cat\n                dp[m][0][i] = 1 # win by mouse\n        # dp = 0 when m==2N\n        \n        def _search(t, x, y):\n            # time, mouse pos, cat pos\n            if t==2*N: return 0\n            if dp[t][x][y]!=-1: return dp[t][x][y]\n            \n            if t%2==0: # mouse\n                winByCat = True\n                for i in graph[x]:\n                    nxt = _search(t+1, i, y)\n                    if nxt==1:\n                        dp[t][x][y] = 1\n                        return 1\n                    if nxt!=2:\n                        winByCat = False\n                if winByCat:\n                    dp[t][x][y] = 2\n                    return 2\n                else:\n                    dp[t][x][y] = 0\n                    return 0\n            else: # cat\n                winByMouse = True\n                for i in graph[y]:\n                    if i!=0: # cat cannot be at the hole -- 0\n                        nxt = _search(t+1, x, i)\n                        if nxt==2:\n                            dp[t][x][y] = 2\n                            return 2\n                        if nxt!=1:\n                            winByMouse = False\n                if winByMouse:\n                    dp[t][x][y] = 1\n                    return 1\n        \n        \n        return _search(0, 1, 2)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: return 0\n            if x == y: return 2\n            if x == 0:return 1\n            if (t%2==0):# mouse's turn\n                if any(search(t+1, graph[x][i], y)==1 for i in range(len(graph[x]))):\n                    return 1\n                if all(search(t+1, graph[x][i], y)==2 for i in range(len(graph[x]))):\n                    return 2\n                return 0\n            else:# cat's turn\n                if any(search(t+1, x, graph[y][i])==2 for i in range(len(graph[y])) if graph[y][i]!=0):\n                    return 2\n                if all(search(t + 1, x, graph[y][i])==1 for i in range(len(graph[y])) if graph[y][i]!=0): \n                    return 1\n                return 0\n        return search(0, 1, 2)\n", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(1+2*len(graph))] for i in range(1+2*len(graph))] for i in range(2*len(graph))]\n        def storeRet(mouse,cat,turn,value):\n            mem[mouse][cat][turn] = value\n            return mem[mouse][cat][turn]\n        def play(mouse, cat, turn):\n            if mem[mouse][cat][turn]!=-1: return mem[mouse][cat][turn]\n            if turn >= len(graph)*2: return 0\n            if turn % 2:\n                ans = 2\n                for node in graph[mouse]:\n                    if node == cat: continue\n                    if node == 0: return storeRet(mouse,cat,turn,1)\n                    res = play(node, cat, turn+1)\n                    if res == 1: return storeRet(mouse,cat,turn,1)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n            else:\n                ans = 1\n                for node in graph[cat]:\n                    if node == 0: continue\n                    if node == mouse: return storeRet(mouse,cat,turn,2)\n                    res = play(mouse, node, turn+1)\n                    if res == 2: return storeRet(mouse,cat,turn,2)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n        return play(1,2,1)", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(1+2*len(graph))] for i in range(1+2*len(graph))] for i in range(2*len(graph))]\n        def storeRet(mouse,cat,turn,value):\n            mem[mouse][cat][turn] = value\n            return mem[mouse][cat][turn]\n        def play(mouse, cat, turn):\n            #print(f'turn {turn} mouse {mouse} cat {cat}')\n            if mem[mouse][cat][turn]!=-1:\n              #print(f'{mouse} {cat} {turn} already calc: {mem[mouse][cat][turn]}')\n              return mem[mouse][cat][turn]\n            if turn >= len(graph)*2: return 0\n            if turn % 2:\n                #print('mouse turn')\n                ans = 2\n                for node in graph[mouse]:\n                    #print(f'mouse check {node}')\n                    if node == cat: continue\n                    if node == 0: return storeRet(mouse,cat,turn,1)\n                    res = play(node, cat, turn+1)\n                    if res == 1: return storeRet(mouse,cat,turn,1)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n            else:\n                #print('cat turn')\n                ans = 1\n                for node in graph[cat]:\n                    #print(f'cat check {node}')\n                    if node == 0: continue\n                    if node == mouse: return storeRet(mouse,cat,turn,2)\n                    res = play(mouse, node, turn+1)\n                    if res == 2: return storeRet(mouse,cat,turn,2)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n        return play(1,2,1)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        \n        @lru_cache(None)\n        def search(t, x, y):\n            if t == len(graph) * 2: return 0\n            if x == y: return 2\n            if x == 0:return 1\n            if (t%2==0):# mouse's turn. Mouse will win if the mouse can find any winable node for the next step. If all the next step is winable for cats, then mouse lose.\n                if any(search(t+1, x_nxt, y)==1 for x_nxt in graph[x]):return 1\n                if all(search(t+1, x_nxt, y)==2 for x_nxt in graph[x]):return 2\n                return 0\n            else:# cat's turn\n                if any(search(t+1, x, y_nxt)==2 for y_nxt in graph[y] if y_nxt!=0):return 2\n                if all(search(t+1, x, y_nxt)==1 for y_nxt in graph[y] if y_nxt!=0):return 1\n                return 0\n            \n        return search(0, 1, 2)", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(1+2*len(graph))] for i in range(1+2*len(graph))] for i in range(2*len(graph))]\n        def storeRet(mouse,cat,turn,value):\n            mem[mouse][cat][turn] = value\n            return mem[mouse][cat][turn]\n        def play(mouse, cat, turn):\n            if mem[mouse][cat][turn]!=-1: return mem[mouse][cat][turn]\n            if turn >= len(graph)*2: return 0\n            if not turn % 2:\n                ans = 2\n                for node in graph[mouse]:\n                    if node == cat: continue\n                    if node == 0: return storeRet(mouse,cat,turn,1)\n                    res = play(node, cat, turn+1)\n                    if res == 1: return storeRet(mouse,cat,turn,1)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n            else:\n                ans = 1\n                for node in graph[cat]:\n                    if node == 0: continue\n                    if node == mouse: return storeRet(mouse,cat,turn,2)\n                    res = play(mouse, node, turn+1)\n                    if res == 2: return storeRet(mouse,cat,turn,2)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(1+2*len(graph))] for i in range(1+2*len(graph))] for i in range(2*len(graph))]\n        def storeRet(mouse,cat,turn,value):\n            mem[mouse][cat][turn] = value\n            return mem[mouse][cat][turn]\n        mouseWin = lambda m,c,t:storeRet(m,c,t,1)\n        catWin = lambda m,c,t:storeRet(m,c,t,2)\n        def play(mouse, cat, turn):\n            if mem[mouse][cat][turn]!=-1: return mem[mouse][cat][turn]\n            if turn >= len(graph)*2: return 0\n            if not turn % 2:\n                ans = 2\n                for node in graph[mouse]:\n                    if node == 0: return mouseWin(mouse,cat,turn)\n                    if node == cat: continue\n                    res = play(node, cat, turn+1)\n                    if res == 1: return mouseWin(mouse,cat,turn)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n            else:\n                ans = 1\n                for node in graph[cat]:\n                    if node == mouse: return catWin(mouse,cat,turn)\n                    if node == 0: continue\n                    res = play(mouse, node, turn+1)\n                    if res == 2: return catWin(mouse,cat,turn)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, g):\n        mem = [[[-1 for i in range(1+2*len(g))] for i in range(1+2*len(g))] for i in range(2*len(g))]\n        def storeRet(m,c,t,v):\n            mem[m][c][t] = v\n            return mem[m][c][t]\n        draw, mouseWin, catWin = lambda m,c,t:storeRet(m,c,t,0),lambda m,c,t:storeRet(m,c,t,1),lambda m,c,t:storeRet(m,c,t,2)\n        \n        def play(m, c, t):\n            if mem[m][c][t]!=-1: return mem[m][c][t] # already visited this game state\n            if t >= 2*len(g): return 0 # repeated states\n            if not t % 2: # mouse turn\n                drawFound = False\n                for n in g[m]:\n                    if n == 0: return mouseWin(m,c,t)\n                    if n == c: continue\n                    nextTurn = play(n, c, t+1)\n                    if nextTurn == 1: return mouseWin(m,c,t)\n                    if nextTurn == 0: drawFound = True\n                return draw(m,c,t) if drawFound else catWin(m,c,t)\n            else: # cat turn\n                drawFound=False\n                for n in g[c]:\n                    if n == m: return catWin(m,c,t)\n                    if n == 0: continue\n                    nextTurn = play(m, n, t+1)\n                    if nextTurn == 2: return catWin(m,c,t)\n                    if nextTurn == 0: drawFound = True\n                return draw(m,c,t) if drawFound else mouseWin(m,c,t)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(1+2*len(graph))] for i in range(1+2*len(graph))] for i in range(2*len(graph))]\n        def storeRet(mouse,cat,turn,value):\n            mem[mouse][cat][turn] = value\n            return mem[mouse][cat][turn]\n        mouseWin = lambda m,c,t:storeRet(m,c,t,1)\n        catWin = lambda m,c,t:storeRet(m,c,t,2)\n        draw = lambda m,c,t:storeRet(m,c,t,0)\n        def play(mouse, cat, turn):\n            if mem[mouse][cat][turn]!=-1: return mem[mouse][cat][turn]\n            if turn >= len(graph)*2: return 0\n            if not turn % 2:\n                drawFound = False\n                for node in graph[mouse]:\n                    if node == 0: return mouseWin(mouse,cat,turn)\n                    if node == cat: continue\n                    res = play(node, cat, turn+1)\n                    if res == 1: return mouseWin(mouse,cat,turn)\n                    if res == 0: drawFound = True\n                return draw(mouse,cat,turn) if drawFound else catWin(mouse,cat,turn)\n            else:\n                drawFound=False\n                for node in graph[cat]:\n                    if node == mouse: return catWin(mouse,cat,turn)\n                    if node == 0: continue\n                    res = play(mouse, node, turn+1)\n                    if res == 2: return catWin(mouse,cat,turn)\n                    if res == 0: drawFound = True\n                return draw(mouse,cat,turn) if drawFound else mouseWin(mouse,cat,turn)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, g):\n        mem = [[[-1 for i in range(1+2*len(g))] for i in range(1+2*len(g))] for i in range(2*len(g))]\n        def storeRet(m,c,t,v):\n            mem[m][c][t] = v\n            return mem[m][c][t]\n        mouseWin = lambda m,c,t:storeRet(m,c,t,1)\n        catWin = lambda m,c,t:storeRet(m,c,t,2)\n        draw = lambda m,c,t:storeRet(m,c,t,0)\n        \n        def play(m, c, t):\n            if mem[m][c][t]!=-1: return mem[m][c][t] # already visited this game state\n            if t >= 2*len(g): return 0 # repeated states\n            if not t % 2: # mouse turn\n                drawFound = False\n                for n in g[m]:\n                    if n == 0: return mouseWin(m,c,t)\n                    if n == c: continue\n                    nextTurn = play(n, c, t+1)\n                    if nextTurn == 1: return mouseWin(m,c,t)\n                    if nextTurn == 0: drawFound = True\n                return draw(m,c,t) if drawFound else catWin(m,c,t)\n            else: # cat turn\n                drawFound=False\n                for n in g[c]:\n                    if n == m: return catWin(m,c,t)\n                    if n == 0: continue\n                    nextTurn = play(m, n, t+1)\n                    if nextTurn == 2: return catWin(m,c,t)\n                    if nextTurn == 0: drawFound = True\n                return draw(m,c,t) if drawFound else mouseWin(m,c,t)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, g):\n        mem = [[[-1 for i in range(1+2*len(g))] for i in range(1+2*len(g))] for i in range(2*len(g))]\n        def storeRet(m,c,t,v):\n            mem[m][c][t] = v\n            return mem[m][c][t]\n        draw, mouseWin, catWin = lambda m,c,t:storeRet(m,c,t,0),lambda m,c,t:storeRet(m,c,t,1),lambda m,c,t:storeRet(m,c,t,2)\n        HOLE = 0\n        \n        def play(m, c, t):\n            if mem[m][c][t]!=-1: return mem[m][c][t] # return cached\n            if t >= 2*len(g): return 0 # repeated states\n            if not t % 2: # mouse turn\n                drawFound = False\n                for n in g[m]:\n                    if n == HOLE: return mouseWin(m,c,t)\n                    if n == c: continue\n                    nextTurn = play(n, c, t+1)\n                    if nextTurn == 1: return mouseWin(m,c,t)\n                    if nextTurn == 0: drawFound = True\n                return draw(m,c,t) if drawFound else catWin(m,c,t)\n            else: # cat turn\n                drawFound=False\n                for n in g[c]:\n                    if n == m: return catWin(m,c,t)\n                    if n == HOLE: continue\n                    nextTurn = play(m, n, t+1)\n                    if nextTurn == 2: return catWin(m,c,t)\n                    if nextTurn == 0: drawFound = True\n                return draw(m,c,t) if drawFound else mouseWin(m,c,t)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, g):\n        mem = [[[-1 for i in range(1+2*len(g))] for i in range(1+2*len(g))] for i in range(2*len(g))]\n        def storeRet(m,c,t,v):\n            mem[m][c][t] = v\n            return mem[m][c][t]\n        mouseWin = lambda m,c,t:storeRet(m,c,t,1)\n        catWin = lambda m,c,t:storeRet(m,c,t,2)\n        draw = lambda m,c,t:storeRet(m,c,t,0)\n        \n        def play(m, c, t):\n            if mem[m][c][t]!=-1: return mem[m][c][t] # already visited this game state\n            if t >= len(g)*2: return 0 # repeated states\n            if not t % 2: # mouse turn\n                drawFound = False\n                for n in g[m]:\n                    if n == 0: return mouseWin(m,c,t)\n                    if n == c: continue\n                    res = play(n, c, t+1)\n                    if res == 1: return mouseWin(m,c,t)\n                    if res == 0: drawFound = True\n                return draw(m,c,t) if drawFound else catWin(m,c,t)\n            else: # cat turn\n                drawFound=False\n                for n in g[c]:\n                    if n == m: return catWin(m,c,t)\n                    if n == 0: continue\n                    res = play(m, n, t+1)\n                    if res == 2: return catWin(m,c,t)\n                    if res == 0: drawFound = True\n                return draw(m,c,t) if drawFound else mouseWin(m,c,t)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(1+2*len(graph))] for i in range(1+2*len(graph))] for i in range(2*len(graph))]\n        def storeRet(m,c,t,v):\n            mem[m][c][t] = v\n            return mem[m][c][t]\n        mouseWin = lambda m,c,t:storeRet(m,c,t,1)\n        catWin = lambda m,c,t:storeRet(m,c,t,2)\n        draw = lambda m,c,t:storeRet(m,c,t,0)\n        \n        def play(m, c, t):\n            if mem[m][c][t]!=-1: return mem[m][c][t] # already visited this game state\n            if t >= len(graph)*2: return 0 # repeated states\n            if not t % 2: # mouse turn\n                drawFound = False\n                for n in graph[m]:\n                    if n == 0: return mouseWin(m,c,t)\n                    if n == c: continue\n                    res = play(n, c, t+1)\n                    if res == 1: return mouseWin(m,c,t)\n                    if res == 0: drawFound = True\n                return draw(m,c,t) if drawFound else catWin(m,c,t)\n            else: # cat turn\n                drawFound=False\n                for n in graph[c]:\n                    if n == m: return catWin(m,c,t)\n                    if n == 0: continue\n                    res = play(m, n, t+1)\n                    if res == 2: return catWin(m,c,t)\n                    if res == 0: drawFound = True\n                return draw(m,c,t) if drawFound else mouseWin(m,c,t)\n        return play(1,2,0)", "from collections import deque\nclass Solution:\n    def catMouseGame(self, graph):\n      \n        arr = [[[0]*2 for j in range(55)] for i in range(55)]\n        q=deque()\n        for i in range(1,len(graph)):\n            arr[i][i][0],arr[i][i][1]=2,2\n            arr[i][0][0],arr[i][0][1]=1,1\n            q.append((i,0,0))\n            q.append((i,0,1))\n            q.append((i,i,0))\n            q.append((i,i,1))\n        while q:\n            c,m,turn = q.popleft()\n            s = arr[c][m][turn]\n            if turn==0:\n                \n                for pre_move in graph[m]:\n                    if arr[c][pre_move][1]!=0:\n                        continue\n                    if s==1:\n                        arr[c][pre_move][1]=1\n                        q.append((c,pre_move,1))\n                    elif s==2:\n                        cat_win=True\n                        for nex_move in graph[pre_move]:\n                            if arr[c][nex_move][0]!=2:\n                                cat_win=False\n                                break\n                        if cat_win:\n                            arr[c][pre_move][1]=2\n                            q.append((c,pre_move,1))\n            else:\n                for pre_move in graph[c]:\n                    if arr[pre_move][m][0]!=0:\n                        continue\n                    if pre_move!=0:\n                        if s==2:\n                            arr[pre_move][m][0]=2\n                            q.append((pre_move,m,0))\n                        elif s==1:\n                            mouse_win=True\n                            for nex_move in graph[pre_move]:\n                                if nex_move!=0:\n                                    if arr[nex_move][m][1]!=1:\n                                        mouse_win=False\n                                        break\n                            if mouse_win:\n                                arr[pre_move][m][0]=1\n                                q.append((pre_move,m,0))\n        return arr[2][1][1]", "class Solution:\n    def catMouseGame(self, g):\n        mem = [[[-1 for i in range(1+2*len(g))] for i in range(1+2*len(g))] for i in range(2*len(g))]\n        def storeRet(m,c,t,v):\n            mem[m][c][t] = v\n            return mem[m][c][t]\n        HOLE, DRAW, MOUSE_WIN, CAT_WIN = 0, 0, 1, 2\n        draw, mouseWin, catWin = lambda m,c,t:storeRet(m,c,t,DRAW),lambda m,c,t:storeRet(m,c,t,MOUSE_WIN),lambda m,c,t:storeRet(m,c,t,CAT_WIN)\n        \n        def play(m, c, t):\n            if mem[m][c][t]!=-1: return mem[m][c][t] # return cached\n            if t >= 2*len(g): return 0 # repeated states\n            if not t % 2: # mouse turn\n                drawFound = False\n                for n in g[m]:\n                    if n == HOLE: return mouseWin(m,c,t)\n                    if n == c: continue\n                    nextTurn = play(n, c, t+1)\n                    if nextTurn == MOUSE_WIN: return mouseWin(m,c,t)\n                    if nextTurn == DRAW: drawFound = True\n                return draw(m,c,t) if drawFound else catWin(m,c,t)\n            else: # cat turn\n                drawFound=False\n                for n in g[c]:\n                    if n == m: return catWin(m,c,t)\n                    if n == HOLE: continue\n                    nextTurn = play(m, n, t+1)\n                    if nextTurn == CAT_WIN: return catWin(m,c,t)\n                    if nextTurn == DRAW: drawFound = True\n                return draw(m,c,t) if drawFound else mouseWin(m,c,t)\n        return play(1,2,0)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # return 1\n        n = len(graph)\n        states = [[[0, 0] for _ in range(n)] for _ in range(n)]  # [mouse][cat][whose_turn (m/c)]\n        for i in range(1, n):\n            # mosue turn is 0, cat is 1\n            states[0][i][0] = -1\n            states[0][i][1] = -1\n            states[i][i][0] = 1\n            states[i][i][1] = 1\n        \n        # cnt = 0\n        get_updated = False\n        for _ in range(2 * n):\n            \n            get_updated = False\n            \n            for mouse in range(1, n):\n                for cat in range(1, n):\n                    for turn in range(2):\n                        if mouse != cat and mouse != 0:\n                            if turn == 0:\n                                adj = graph[mouse]\n                                res = float('inf')\n                                for node in adj:\n                                    res = min(res, states[node][cat][1])\n                                    # cnt += 1\n                                \n                                if states[mouse][cat][turn] != res:\n                                    get_updated = True\n                                    \n                                states[mouse][cat][turn] = res\n                            else:\n                                adj = graph[cat]\n                                res = float('-inf')\n                                for node in adj:\n                                    if node != 0:\n                                        res = max(res, states[mouse][node][0])\n                                        # cnt += 1\n                                    \n                                if states[mouse][cat][turn] != res:\n                                    get_updated = True\n                                    \n                                    states[mouse][cat][turn] = res\n            if not get_updated:\n                break\n        \n        # print(states[3][3][0])\n        # print(cnt)\n        \n        res = states[1][2][0]\n        # res = self.play(1, 2, 0, graph, states)\n        if res < 0:\n            return 1\n        if res > 0:\n            return 2\n        return 0\n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        # return 1\n        n = len(graph)\n        states = [[[0, 0] for _ in range(n)] for _ in range(n)]  # [mouse][cat][whose_turn (m/c)]\n        for i in range(1, n):\n            # mosue turn is 0, cat is 1\n            states[0][i][0] = -1\n            states[0][i][1] = -1\n            states[i][i][0] = 1\n            states[i][i][1] = 1\n        \n        get_updated = False\n        for _ in range(2 * n):\n            \n            get_updated = False\n            \n            for mouse in range(1, n):\n                for cat in range(1, n):\n                    for turn in range(2):\n                        if mouse != cat and mouse != 0:\n                            if turn == 0:\n                                adj = graph[mouse]\n                                res = float('inf')\n                                for node in adj:\n                                    res = min(res, states[node][cat][1])\n                                \n                                if states[mouse][cat][turn] != res:\n                                    get_updated = True\n                                    \n                                states[mouse][cat][turn] = res\n                            else:\n                                adj = graph[cat]\n                                res = float('-inf')\n                                for node in adj:\n                                    if node != 0:\n                                        res = max(res, states[mouse][node][0])\n                                    \n                                if states[mouse][cat][turn] != res:\n                                    get_updated = True\n                                    \n                                    states[mouse][cat][turn] = res\n            if not get_updated:\n                break\n\n        res = states[1][2][0]\n        if res < 0:\n            return 1\n        if res > 0:\n            return 2\n        return 0\n", "class Solution:\n    def catMouseGame(self, g: List[List[int]]) -> int:\n        # observations:\n        # we can represent the game state with the triplet (mouse cat turn).\n        # (_ 0 _) is illegal.\n        # (0 _ _) = 1 (mouse victory).\n        # (x x _) = 2 (cat victory).\n        # if any possible move leads to win, current state is win:\n        # * (m c c) = 1 => (m' c m) = 1 for m' in g[m].\n        # * (m c m) = 2 => (m c' c) = 2 for c' in g[c].\n        # (m c m) = 1 and c not in g[m] => (m c c) = 1.\n        # if all possible moves lead to loss, current state is loss.\n        # * (m c m) = 1, for c' in g[c], if all((m c'' m) = 1 for c'' in g[c']) => (m c' c) = 1\n        # return (1 2 m). return once we know its value.\n\n        n = len(g)\n        s = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n        q = deque()\n\n        def sq(m, c, t, v):\n            if s[m][c][t] == 0:\n                q.append((m, c, t))\n                s[m][c][t] = v\n\n        # approach:\n\n        # set and enqueue initial known states.\n        for m in range(n):\n            for t in range(2):\n                sq(m, 0, t, -1)\n        for c in range(n):\n            for t in range(2):\n                sq(0, c, t, 1)\n        for x in range(n):\n            for t in range(2):\n                sq(x, x, t, 2)\n\n        # while queue:\n        while q:\n            # pop state.\n            m, c, t = state = q.popleft()\n            # apply production rules. for each unencountered resultant state, set and enqueue.\n            if t == 1 and s[m][c][t] == 1:\n                for m_ in g[m]:\n                    sq(m_, c, 0, 1)\n\n            if t == 0 and s[m][c][t] == 2:\n                for c_ in g[c]:\n                    sq(m, c_, 1, 2)\n\n            # if t == 0 and s[m][c][t] == 1 and c not in g[m]:\n            #     sq(m, c, 1, 1)\n\n            if t == 0 and s[m][c][t] == 1:\n                for c_ in g[c]:\n                    if all(s[m][c__][0] in (-1, 1) for c__ in g[c_]):\n                        sq(m, c_, 1, 1)\n\n            if t == 1 and s[m][c][t] == 2:\n                for m_ in g[m]:\n                    if all(s[m__][c][1] in (-1, 2) for m__ in g[m_]):\n                        sq(m_, c, 0, 2)\n\n        # everything else is a draw.\n\n        # return state[1,2,m].\n        return s[1][2][0]\n", "class Solution:\n    def catMouseGame(self, graph):\n        mem = [[[-1 for i in range(3*len(graph))] for i in range(3*len(graph))] for i in range(2*len(graph))]\n        def storeRet(mouse,cat,turn,value):\n            mem[mouse][cat][turn] = value\n            #print(f'store {value} for {mouse} {cat} {turn}')\n            return mem[mouse][cat][turn]\n        def play(mouse, cat, turn):\n            #print(f'turn {turn} mouse {mouse} cat {cat}')\n            if mem[mouse][cat][turn]!=-1:\n              #print(f'{mouse} {cat} {turn} already calc: {mem[mouse][cat][turn]}')\n              return mem[mouse][cat][turn]\n            if turn >= len(graph)*2: return 0\n            if turn % 2:\n                #print('mouse turn')\n                ans = 2\n                for node in graph[mouse]:\n                    #print(f'mouse check {node}')\n                    if node == cat: continue\n                    if node == 0: return storeRet(mouse,cat,turn,1)\n                    res = play(node, cat, turn+1)\n                    if res == 1: return storeRet(mouse,cat,turn,1)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n            else:\n                #print('cat turn')\n                ans = 1\n                for node in graph[cat]:\n                    #print(f'cat check {node}')\n                    if node == 0: continue\n                    if node == mouse: return storeRet(mouse,cat,turn,2)\n                    res = play(mouse, node, turn+1)\n                    if res == 2: return storeRet(mouse,cat,turn,2)\n                    if res == 0: ans = 0\n                return storeRet(mouse,cat,turn,ans)\n        return play(1,2,1)", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        mouse, cat = 1, 2\n        node = defaultdict(int)\n        graphLen = len(graph)\n        # key = (m0, c0, t)\n        stack = [] \n        for l in graph[0]:\n            for ci in range(1, graphLen):\n                if ci != l:\n                    node[(l, ci, mouse)] = mouse\n                    stack.append((l, ci, mouse, mouse))\n        for i in range(1, graphLen):\n            for j in graph[i]:\n                if j != 0:\n                    node[(i, j, cat)] = cat\n                    stack.append((i, j, cat, cat))\n            node[(i, i, cat)] = cat\n            node[(i, i, mouse)] = cat\n            stack.append((i, i, cat, cat))\n            stack.append((i, i, mouse, cat))\n            \n        degree = {}\n        for i in range(graphLen):\n            for j in range(graphLen):\n                if i != j:\n                    if (i, j, mouse) not in stack:\n                        degree[(i, j, mouse)] = len(graph[i])\n                    if (i, j, cat) not in stack:\n                        degree[(i, j, cat)] = len(graph[j]) - (1 if 0 in graph[j] else 0)\n        \n        while stack:\n            m0, c0, t0, w = stack.pop(0)\n            if t0 == mouse:\n                if w == cat:\n                    for move in graph[c0]:\n                        if move != 0 and (m0, move, cat) not in node:\n                            node[(m0, move, cat)] = cat\n                            stack.append((m0, move, cat, cat))\n                else:\n                    for move in graph[c0]:    \n                        if move != 0 and (m0, move, cat) not in node:\n                            degree[(m0, move, cat)] -= 1\n                            if degree[(m0, move, cat)] == 0:\n                                node[(m0, move, cat)] = mouse\n                                stack.append((m0, move, cat, mouse))\n            else:\n                if w == mouse:\n                    for move in graph[m0]:\n                        if (move, c0, mouse) not in node:\n                            node[(move, c0, mouse)] = mouse\n                            stack.append((move, c0, mouse, mouse))\n                else:\n                    for move in graph[m0]:    \n                        if (move, c0, mouse) not in node:\n                            degree[(move, c0, mouse)] -= 1\n                            if degree[(move, c0, mouse)] == 0:\n                                node[(move, c0, mouse)] = cat\n                                stack.append((move, c0, mouse, cat))\n        # print(node)\n        return node[(1, 2, mouse)]\n                            \n", "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        mouse, cat = 1, 2\n        node = defaultdict(int)\n        graphLen = len(graph)\n        # key = (m0, c0, t)\n        stack = deque([]) \n        for l in graph[0]:\n            for ci in range(1, graphLen):\n                if ci != l:\n                    node[(l, ci, mouse)] = mouse\n                    stack.append((l, ci, mouse, mouse))\n        for i in range(1, graphLen):\n            for j in graph[i]:\n                if j != 0:\n                    node[(i, j, cat)] = cat\n                    stack.append((i, j, cat, cat))\n            node[(i, i, cat)] = cat\n            node[(i, i, mouse)] = cat\n            stack.append((i, i, cat, cat))\n            stack.append((i, i, mouse, cat))\n            \n        degree = {}\n        for i in range(graphLen):\n            for j in range(graphLen):\n                if i != j:\n                    if (i, j, mouse) not in stack:\n                        degree[(i, j, mouse)] = len(graph[i])\n                    if (i, j, cat) not in stack:\n                        degree[(i, j, cat)] = len(graph[j]) - (1 if 0 in graph[j] else 0)\n        \n        while stack:\n            m0, c0, t0, w = stack.popleft()\n            if t0 == mouse:\n                if w == cat:\n                    for move in graph[c0]:\n                        if move != 0 and (m0, move, cat) not in node:\n                            node[(m0, move, cat)] = cat\n                            stack.append((m0, move, cat, cat))\n                else:\n                    for move in graph[c0]:    \n                        if move != 0 and (m0, move, cat) not in node:\n                            degree[(m0, move, cat)] -= 1\n                            if degree[(m0, move, cat)] == 0:\n                                node[(m0, move, cat)] = mouse\n                                stack.append((m0, move, cat, mouse))\n            else:\n                if w == mouse:\n                    for move in graph[m0]:\n                        if (move, c0, mouse) not in node:\n                            node[(move, c0, mouse)] = mouse\n                            stack.append((move, c0, mouse, mouse))\n                else:\n                    for move in graph[m0]:    \n                        if (move, c0, mouse) not in node:\n                            degree[(move, c0, mouse)] -= 1\n                            if degree[(move, c0, mouse)] == 0:\n                                node[(move, c0, mouse)] = cat\n                                stack.append((move, c0, mouse, cat))\n        # print(node)\n        return node[(1, 2, mouse)]\n                            \n"]
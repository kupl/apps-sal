["class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        # DP(a=index of last, b=index of last) = max of:\n        #   DP(a-1, b)\n        #   DP(a-1, i) + nums1[a] * max_or_min(nums2[i+1:b+1])\n        #   same for b\n        \n        INF = int(1e9)\n        n, m = len(nums1), len(nums2)\n\n        DP = [-INF] * (m + 1)\n        NDP = [-INF] * (m + 1)\n        \n        for a in range(n):\n\n            for b in range(m):\n            \n                el = nums1[a] * nums2[b]\n\n                diag = DP[b]\n\n                NDP[b + 1] = max(el, DP[b + 1], NDP[b], diag, diag + el)\n                \n            DP, NDP = NDP, DP\n                \n        return DP[-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        if all(x >= 0 for x in nums1) and all(y <= 0 for y in nums2):\n            return min(nums1) * max(nums2)\n        if all(x <= 0 for x in nums1) and all(y >= 0 for y in nums2):\n            return max(nums1) * min(nums2)\n        accu_max = [0] * (len(nums2) + 1)\n        for i in range(len(nums1)):\n            last_max = [accu_max[j] + nums1[i] * nums2[j] for j in range(len(nums2))]\n            this_accu_max = [0]\n            for j in range(len(nums2)):\n                this_accu_max.append(max(this_accu_max[-1], last_max[j], accu_max[j + 1]))\n            accu_max = this_accu_max\n        return accu_max[-1]\n\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        \n        n1 = len(nums1)\n        n2 = len(nums2)\n        dp = [[0] * (n2+1) for j in range(n1+1)]\n        for i in range(n1):\n            for j in range(n2):\n                dp[i+1][j+1] = max(dp[i][j] + max(0, nums1[i] * nums2[j]), dp[i][j+1], dp[i+1][j])\n        # print(dp)  \n        if dp[-1][-1] != 0:\n            return dp[-1][-1]\n        nums1.sort()\n        nums2.sort()\n        a = nums1[0] if nums1[0] > 0 else nums1[-1]\n        b = nums2[0] if nums2[0] > 0 else nums2[-1]\n        return a * b\n                \n                \n                \n        \n        \n", "import numpy as np\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        # DP(a=index of last, b=index of last) = max of:\n        #   DP(a-1, b)\n        #   DP(a-1, i) + nums1[a] * max_or_min(nums2[i+1:b+1])\n        #   same for b\n        \n        INF = int(1e9)\n        n, m = len(nums1), len(nums2)\n\n        DP = np.ones((n, m), dtype=int) * -INF\n        DP[0, 0] = nums1[0] * nums2[0]\n        \n        for a in range(n):\n            for b in range(m):\n                \n                el = nums1[a] * nums2[b]\n                curr = el\n                \n                if a > 0:\n                    curr = max(curr, DP[a - 1, b])\n                if b > 0:\n                    curr = max(curr, DP[a, b - 1])\n                if a > 0 and b > 0:\n                    prev = DP[a - 1, b - 1]\n                    curr = max(curr, prev, prev + el)\n                    \n                DP[a, b] = curr\n                    \n        return DP[-1, -1]", "from functools import lru_cache\n\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        m = len(nums2)\n\n        @lru_cache(None)\n        def dp(i, j, selected):\n            if i == n or j == m:\n                return 0 if selected else -1000000000\n\n            a = nums1[i] * nums2[j] + dp(i + 1, j + 1, True)\n            b = dp(i, j + 1, selected)\n            c = dp(i + 1, j, selected)\n\n            return max(a, b, c)\n\n        return dp(0, 0, False)\n\n\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        def dp(nums1, nums2, i, j, m, n, dic):\n            \n            if(i+1>=m):\n                maximum = None\n                \n                for p in range(j,n):\n                    if(maximum == None):\n                        maximum = nums1[i] * nums2[p]\n                    \n                    else:\n                        maximum = max(maximum,nums1[i] * nums2[p])\n                \n                return maximum\n            \n            elif(j+1 >= n):\n                maximum = None\n                \n                for p in range(i,m):\n                    if(maximum == None):\n                        maximum = nums1[p] * nums2[j]\n                    \n                    else:\n                        maximum = max(maximum,nums1[p] * nums2[j])\n                \n                return maximum\n            \n            if(dic[i][j] != None):\n                return dic[i][j]\n            \n            dic[i][j] = max(nums1[i] * nums2[j],nums1[i] * nums2[j] + dp(nums1,nums2,i+1,j+1,m,n,dic), dp(nums1,nums2,i,j+1,m,n,dic), dp(nums1,nums2,i+1,j,m,n,dic), dp(nums1,nums2,i+1,j+1,m,n,dic))\n            \n            \n            return dic[i][j]\n        \n        dic = []\n        \n        m = len(nums1)\n        n = len(nums2)\n        \n        for i in range(m):\n            dic.append([None]*n)\n            \n        return dp(nums1,nums2,0,0,m,n,dic)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        @lru_cache(None)\n        def cal(i, j):\n            if i >= len(nums1) or j >= len(nums2):\n                return 0\n            \n            return max(nums1[i]*nums2[j] + cal(i+1, j+1), cal(i, j+1), cal(i+1, j))\n        \n        ans =  cal(0, 0)\n        if ans == 0:\n            return max(min(nums1)*max(nums2), min(nums2)*max(nums1))\n        else:\n            return ans", "import numpy as np\n\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        M = np.zeros((len(nums1), len(nums2)), dtype=np.int)\n\n        M[0][0] = nums1[0]*nums2[0]\n        for i in range(1, len(nums1)):\n            M[i][0] = max(M[i-1][0], nums1[i]*nums2[0])\n        for j in range(1, len(nums2)):\n            M[0][j] = max(M[0][j-1], nums1[0]*nums2[j])\n\n        for i in range(1, len(nums1)):\n            for j in range(1, len(nums2)):\n                M[i][j] = max(M[i-1][j-1]+nums1[i]*nums2[j], M[i][j-1], M[i-1][j], nums1[i]*nums2[j])\n            # print(M)\n        return M[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1, n2 = len(nums1), len(nums2)\n        \n        cache = {}\n        \n        def process(i, j, k):\n            if not (i, j, k) in cache:\n                ans = 0\n                if i == 0 and j == 0:\n                    if k == 0:\n                        ans = nums1[i] * nums2[j]\n                    else:\n                        ans = max(nums1[i] * nums2[j], 0)\n                elif i == 0:\n                    ans = max(nums1[i] * nums2[j], process(i, j-1, k))\n                elif j == 0:\n                    ans = max(nums1[i] * nums2[j], process(i-1, j, k))\n                else:\n                    ans = max(nums1[i] * nums2[j] + process(i-1, j-1, 1), process(i-1, j, k), process(i, j-1, k))\n                cache[(i, j, k)] = ans\n            return cache[(i, j, k)]\n            \n        return process(n1-1, n2-1, 0)", "mi = -100000000000\ndp = [[mi]*(505) for i in range(505)]\ndef steps(i,j,lis1,lis2):\n    best = mi\n    if i<0 or j<0:\n        return 0\n    elif dp[i][j]!=mi:\n        return dp[i][j]\n    if i==0:\n        for _ in range(j+1):\n            best = max(lis1[i]*lis2[_] , best)\n        dp[i][j]=best\n        return dp[i][j]\n    if j==0:\n        for _ in range(i+1):\n            best = max(lis1[_]*lis2[j] , best)\n        dp[i][j]=best\n        return best\n\n    best = max(steps(i-1,j,lis1,lis2) , steps(i,j-1,lis1,lis2) , lis1[i]*lis2[j] + steps(i-1,j-1,lis1,lis2) , lis1[i]*lis2[j])\n    dp[i][j]=best\n    return dp[i][j]\nclass Solution:\n    def maxDotProduct(self, lis1: List[int], lis2: List[int]) -> int:\n        n = len(lis1)\n        m = len(lis2)\n        for i in range(501):\n            for j in range(501):\n                dp[i][j]=mi\n        steps(n-1,m-1,lis1,lis2)\n        return dp[n-1][m-1]\n        \n        \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        # m, n = len(nums1), len(nums2)\n        # dp = [float(\\\"-inf\\\") * (n + 1) for _ in range(m + 1) ]\n        # for i in range(1, m + 1):\n        #     for j in range(1, n + 1):\n        #         dp[i][j] = max(dp[i-1][j], dp[i][j-1], max(0, dp[i-1][j-1]) + nums1[i] * nums2[j])\n        # return dp[m][n]\n        m,n = len(nums1),len(nums2)\n        INF = -100000000\n        dp = [[INF]*(n+1) for _ in range(m+1)]\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                dp[i][j] = nums1[i-1] * nums2[j-1]\n                dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i][j-1], dp[i][j]+dp[i-1][j-1])\n        return dp[m][n]\n\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        def f(nums1, nums2, i, j, D):\n            \n            if i == 0 or j == 0:\n                return 0\n            \n            elif str([i,j]) in D:\n                return D[str([i,j])]\n            \n            res = max(nums1[i-1] * nums2[j-1] + f(nums1, nums2, i-1, j-1, D), f(nums1, nums2, i-1, j, D), f(nums1, nums2, i, j-1, D))\n            \n            D[str([i,j])] = res\n\n            return res\n        \n        D = {}\n        \n        res = f(nums1, nums2, len(nums1), len(nums2), D)\n        \n        if res == 0 and (max(nums1) < 0 and min(nums2) > 0):\n            return max(nums1) * min(nums2)\n        elif res == 0 and (max(nums2) < 0 and min(nums1) > 0):\n            return max(nums2) * min(nums1)\n        \n        return res", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp=[[0]*len(nums2) for _ in nums1]\n        res=-float('inf')\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if i==0 or j==0:\n                    if i==0 and j==0:\n                        dp[i][j]=nums1[i]*nums2[j]\n                    elif i==0:\n                        dp[i][j]=max(dp[i][j-1],nums1[i]*nums2[j])\n                    else:\n                        dp[i][j]=max(dp[i-1][j],nums1[i]*nums2[j])\n                else:\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1],nums1[i]*nums2[j],nums1[i]*nums2[j]+dp[i-1][j-1])\n            res=max(res,dp[i][-1])\n        #print(dp)\n        return res", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1, n2 = len(nums1), len(nums2)\n        M = [[-100000] * (n2 + 1)  for _ in range(n1 + 1)]\n\n        for i in range(n1):\n            for j in range(n2):\n                M[i+1][j+1] = max(M[i][j]+nums1[i]*nums2[j], M[i][j+1], M[i+1][j], nums1[i]*nums2[j])\n        return M[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        max_dot_product = [nums1[0]*num for num in nums2]\n        max_dot_product = list(itertools.accumulate(max_dot_product, max))\n        for num1 in nums1[1:]:\n            max_dot_product_next = []\n            for i, num2 in enumerate(nums2):\n                curr_max = max_dot_product[i]\n                if i > 0:\n                    curr_max = max(curr_max, max(num1*num2+max_dot_product[i-1], max_dot_product_next[i-1]))\n                curr_max = max(curr_max, num1*num2)\n                max_dot_product_next.append(curr_max)\n            max_dot_product = max_dot_product_next\n            #print(num1, max_dot_product)\n        #print(max_dot_product)\n        return max(max_dot_product)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1 = len(nums1)\n        n2 = len(nums2)\n        dp = [[0 for _ in range(n2)] for _ in range(n1)]\n        for i in range(n1):\n            for j in range(n2):\n                curr = nums1[i]*nums2[j]\n                if i==0 and j==0:\n                    dp[i][j] = curr\n                elif i==0:\n                    dp[i][j] = max(curr, dp[i][j-1])\n                elif j==0:\n                    dp[i][j] = max(curr, dp[i-1][j])\n                else:\n                    dp[i][j] = max(curr, curr+dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\n        return dp[n1-1][n2-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        \n        M = len(nums1)\n        N = len(nums2)\n        \n        dp = [[0] * N for _ in range(M)]\n        \n        dp[0][0] = nums1[0] * nums2[0]\n        \n        for i in range(1, M):\n            dp[i][0] = max(dp[i-1][0], nums2[0] * nums1[i])\n            \n        for i in range(1, N):\n            dp[0][i] = max(dp[0][i-1], nums1[0] * nums2[i])\n            \n        \n        for i in range(1, M):\n            for j in range(1, N):\n                \n                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j-1] + nums1[i]*nums2[j], dp[i-1][j], dp[i][j-1], nums1[i]*nums2[j])\n        \n            \n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, a: List[int], b: List[int]) -> int:\n        nums1 = [0] + a\n        nums2 = [0] + b\n        m, n = len(nums1), len(nums2)\n        dp = [[float('-inf')] * m for _ in range(n)]\n\n        for i in range(1, n):\n            for j in range(1, m):\n                if nums1[j] * nums2[i] > 0:\n                    dp[i][j] = max(dp[i-1][j-1] + nums1[j] * nums2[i], dp[i][j-1], dp[i-1][j], nums1[j] * nums2[i])\n                else:\n                    dp[i][j] = max(dp[i][j-1], dp[i-1][j], nums1[j] * nums2[i])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1, nums2) -> int:\n        n, m = len(nums1), len(nums2)\n\n        # dp[i][j] max dot product of nums[:i+1][:j+1]\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n\n        dp[0][0] = nums1[0]*nums2[0]\n\n        for j in range(1, m):\n            dp[0][j] = max(dp[0][j-1], nums1[0]*nums2[j])\n\n        for i in range(1, n):\n            dp[i][0] = max(dp[i-1][0], nums1[i]*nums2[0])\n\n        for i in range(1, n):\n            for j in range(1, m):\n                dp[i][j] = max(nums1[i]*nums2[j],\n                               dp[i-1][j-1] + nums1[i]*nums2[j],\n                               dp[i-1][j],\n                               dp[i][j-1],\n                               dp[i-1][j-1])\n\n        return dp[n-1][m-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1: int = len(nums1)\n        n2: int = len(nums2)\n        dp: List[List[int]] = [[float('-inf') for _ in range(n2 + 1)] for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], max(0, dp[i - 1][j - 1]) + nums1[i - 1] * nums2[j - 1])\n        return dp[n1][n2]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        # dp(x, y) = max([nums1[x]*nums2[y] + dp(x-1, y-1), dp(x-1, y), dp(x, y-1)])\n        dp = [[0 for i in range(len(nums2)+1)] for j in range(len(nums1)+1)]\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                dp[i+1][j+1] = max([dp[i][j] + nums1[i]*nums2[j], dp[i+1][j], dp[i][j+1]])\n                \n        return dp[len(nums1)][len(nums2)] if dp[len(nums1)][len(nums2)] > 0 else max([max(nums1) * max(nums2), min(nums1) * min(nums2), max(nums1) * min(nums2), min(nums1) * max(nums2)])", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[0]*(len(nums2)) for _ in range(len(nums1))]\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if(i == 0 and j == 0):\n                    dp[i][j] = nums1[0]*nums2[0]\n                    continue\n                prod = nums1[i]*nums2[j]\n                if(i == 0):\n                    dp[i][j] = max(dp[i][j-1], prod)\n                    continue\n                if(j == 0):\n                    dp[i][j] = max(dp[i-1][j], prod)\n                    continue\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]+prod, prod)\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        m = len(nums1)\n        n = len(nums2)\n        dp = [[-float('inf')] * (n + 1) for i in range(m+1)]\n        res = -float('inf')\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                dp[i][j] = max(\n                    dp[i-1][j], dp[i][j-1], \n                    dp[i-1][j-1]+nums1[i-1]*nums2[j-1],\n                    nums1[i-1]*nums2[j-1]\n                )\n                    \n        for row in dp:\n            for x in row:\n                res = max(res, x)\n\n        return res", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        m = len(nums1)\n        n = len(nums2)\n        dp = [[0]*n for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = nums1[i] * nums2[j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j-1], nums1[i] * nums2[j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i-1][j], nums1[i] * nums2[j])\n                else:\n                    temp = nums1[i] * nums2[j]\n                    dp[i][j] = max(temp, dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + temp)\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        dp=[[0 for _ in range(len(nums2))] for _ in range(len(nums1))]\n        \n        dp[-1][-1]=nums1[-1]*nums2[-1]\n        for i in range(len(nums1)-2,-1,-1):\n            dp[i][-1]=max(dp[i+1][-1],nums1[i]*nums2[-1])\n        \n        for i in range(len(nums2)-2,-1,-1):\n            dp[-1][i]=max(dp[-1][i+1],nums1[-1]*nums2[i])\n        \n        for i in range(len(nums1)-2,-1,-1):\n            for j in range(len(nums2)-2,-1,-1):\n                dp[i][j]=max(dp[i+1][j+1],dp[i+1][j],dp[i][j+1],dp[i+1][j+1]+(nums1[i]*nums2[j]),nums1[i]*nums2[j])\n        return dp[0][0]\n                \n                \n        \n        \n#         def backtrack(arr,ind,curr,sol):\n#             if curr:\n#                 sol[len(curr)-1].append(curr)\n#             for i in range(ind,len(arr)):\n#                 backtrack(arr,i+1,curr+[arr[i]],sol)\n        \n#         subs1=[[] for _ in range(len(nums1))]\n#         subs2=[[] for _ in range(len(nums2))]\n        \n#         backtrack(nums1,0,[],subs1)\n#         backtrack(nums2,0,[],subs2)\n        \n#         mx=float(\\\"-inf\\\")\n\n#         for i in range(min(len(nums1),len(nums2))):\n#             for j in range(len(subs1[i])):\n#                 for k in range(len(subs2[i])):\n#                     ans=0\n#                     for l in range(i+1):\n#                         ans+=subs1[i][j][l]*subs2[i][k][l]\n#                     mx=max(mx,ans)\n#         return mx\n                        \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        N = len(nums1)\n        M = len(nums2)\n        \n        if max(nums1)<0 and min(nums2)>0:\n            return max(nums1) * min(nums2)\n        \n        if max(nums2)<0 and min(nums1)>0:\n            return min(nums1) * max(nums2)\n        \n        dp = [[0 for i in range(M+1)] for j in range(N+1)]\n        \n        for i in range(N):\n            for j in range(M) :\n                dp[i+1][j+1] = max(dp[i][j]+nums1[i]*nums2[j], dp[i][j+1], dp[i+1][j])\n        return dp[-1][-1]\n    \n    \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[0]*len(nums2) for _ in range(len(nums1))]\n        dp[0][0] = max(0,nums1[0] * nums2[0])\n        \n        for i in range(0,len(nums1)):\n            for j in range(0,len(nums2)):\n                if i>0 and j>0:\n                    dp[i][j] = max(dp[i-1][j-1], dp[i][j-1], dp[i-1][j], dp[i-1][j-1] + nums1[i] * nums2[j])\n                else:\n                    if j>0 and i==0:\n                        dp[i][j] = max(dp[i][j-1], nums1[i] * nums2[j])\n                    if i>0 and j==0:\n                        dp[i][j] = max(dp[i-1][j], nums1[i] * nums2[j])\n                #print(i,j,dp[i][j])\n                \n      #  print(dp)\n      #  print(max(dp))\n            \n        ans = max([max(x) for x in dp])\n        \n        if ans>0:\n            return ans\n        else:\n            best = -9999999\n            for k in nums1:\n                for l in nums2:\n                    best = max(best, k*l)\n                    \n            return best\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1=len(nums1)\n        n2=len(nums2)\n        dp=[[[0,0] for i in range(n2)] for j in range(n1)]\n        \n        for i in range(n1):\n            for j in range(n2):\n                if i==0:\n                    if j==0:\n                        dp[i][j]=nums1[i]*nums2[j]\n                        \n                    else:\n                        dp[i][j]=max(dp[i][j-1],nums1[i]*nums2[j])\n                        \n                elif j==0:\n                    dp[i][j]=max(dp[i-1][j],nums1[i]*nums2[j])\n                    \n                else:\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1],nums1[i]*nums2[j]+dp[i-1][j-1],dp[i-1][j-1],nums1[i]*nums2[j])\n                    \n                    \n        return dp[-1][-1]\n                \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        N = len(nums1)\n        M = len(nums2)\n        dp = [[0] * M for _ in range(N)]\n        \n        dp[0][0] = nums1[0] * nums2[0]\n        res = dp[0][0]\n        \n        big = nums1[0] >= 0\n        acc = nums2[0]\n        for i, x in enumerate(nums2[1:]):\n            if big and x > acc:\n                acc = x\n            elif not big and x < acc:\n                acc = x\n            \n            dp[0][i+1] = acc * nums1[0]\n            res = max(res, dp[0][i+1])\n        \n        big = nums2[0] >= 0\n        acc = nums1[0]\n        for i, x in enumerate(nums1[1:]):\n            if big and x > acc:\n                acc = x\n            elif not big and x < acc:\n                acc = x\n            \n            dp[i+1][0] = acc * nums2[0]\n            res = max(res, dp[i+1][0])\n        \n        for i in range(1, N):\n            for j in range(1, M):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], nums1[i] * nums2[j] + max(0, dp[i-1][j-1]))\n                \n                res = max(res, dp[i][j]) \n        \n        return res", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[-sys.maxsize-1 for i in range(len(nums2)+1)] for j in range(len(nums1)+1)]\n        \n        for i in range(1,len(nums1)+1):\n            for j in range(1,len(nums2)+1):\n                t = nums1[i-1]*nums2[j-1]\n                dp[i][j] = max({dp[i-1][j-1]+t,t,dp[i-1][j], dp[i][j-1]})\n        # print(dp)\n        return dp[-1][-1]\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1, n2 = len(nums1), len(nums2)\n        \n        mem = [[float('-inf')] * (n2+1) for _ in range(n1+1)]\n        mem[0][0] = 0\n        for i in range(1, n1+1):\n            for j in range(1, n2+1):\n                mem[i][j] = max(mem[i][j], max(nums1[i-1]*nums2[j-1] + max(0, mem[i-1][j-1]), mem[i][j-1], mem[i-1][j]))\n        # print(mem)\n        return mem[n1][n2]\n        \n        # mem = [[[[float('-inf')] * n2 for j in range(n2)] for i1 in range(n1)] for i2 in range(n1)]\n        @lru_cache\n        def dp(i1, j1, i2, j2):\n            if i1 > j1 or i2 > j2:\n                return 0\n            if i1 == j1 and i2 == j2:\n                return nums1[i1]*nums2[i2]\n            if mem[i1][j1][i2][j2] != float('-inf'):\n                return mem[i1][j1][i2][j2]\n            ans = float('-inf')\n            for k1 in range(i1, j1+1):\n                for k2 in range(i2, j2+1):\n                    ans = max(ans, max(0, nums1[k1] * nums2[k2]) + dp(i1, k1-1, i2, k2-1) + dp(k1+1, j1, k2+1, j2))\n            mem[i1][j1][i2][j2] = ans\n            return ans\n        \n        return dp(0, n1-1, 0, n2-1)", "class Solution:\n    def maxDotProduct(self, A, B):\n        n, m = len(A), len(B)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = A[i] * B[j]\n                if i and j: dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i: dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, A, B):\n        n, m = len(A), len(B)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = A[i] * B[j]\n                if i and j:\n                    dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        m = len(nums2)\n        dp = [[0] * m for i in range(n)]\n        dp[0][0] = nums1[0] * nums2[0]\n        for j in range(1, m):\n            dp[0][j] = max(dp[0][j - 1], nums1[0] * nums2[j])\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], nums1[i] * nums2[0])\n        for i in range(1, n):\n            for j in range(1, m):\n                prod = nums1[i] * nums2[j]\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + (prod if prod > 0 else 0), prod)\n        # print(dp)\n        return dp[n - 1][m - 1]", "class Solution:\n    def maxDotProduct(self, A: List[int], B: List[int]) -> int:\n        n, m = len(A), len(B)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = A[i] * B[j]\n                if i and j: dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i: dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n1, n2 = len(nums1), len(nums2)\n        d = [[0] * (n2+1) for _ in range(n1+1)]\n        inf = -float('inf')\n        for i in range(n1):\n            for j in range(n2):\n                d[i][j] = max(d[i-1][j] if i else inf,d[i][j-1] if j else inf, nums1[i] * nums2[j] + (d[i-1][j-1] if d[i-1][j-1] > 0 else 0))\n        return d[n1-1][n2-1]", "class Solution:\n    def maxDotProduct(self, A, B):\n        n, m = len(A), len(B)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = A[i] * B[j]\n                if i > 0 and j > 0:\n                    dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]", "from functools import lru_cache\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        l1, l2 = len(nums1), len(nums2)\n        if all([x < 0 for x in nums1]) and all([x > 0 for x in nums2]):\n            return max(nums1) * min(nums2)\n        if all([x > 0 for x in nums1]) and all([x < 0 for x in nums2]):\n            return min(nums1) * max(nums2)\n        \n        @lru_cache(None)\n        def dfs(i1, i2):\n            if i1 == l1 or i2 == l2:\n                return 0\n            return max(dfs(i1 + 1, i2), dfs(i1, i2 + 1), nums1[i1] * nums2[i2] + dfs(i1 + 1, i2 + 1))\n        \n        return dfs(0, 0)\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i,j):\n            if i<0 or j<0:\n                return -float('inf')\n            return max(nums1[i]*nums2[j], nums1[i]*nums2[j]+dp(i-1,j-1), dp(i, j-1), dp(i-1, j))\n        return dp(len(nums1)-1, len(nums2)-1)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[0 for _ in range(len(nums2))] for x in range(len(nums1))]\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                dp[i][j] = nums1[i]*nums2[j]\n                if i and j:\n                    dp[i][j] += max(dp[i-1][j-1], 0)\n                if i:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j])\n                if j:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1])\n                    \n        return dp[-1][-1]\n", "def max_dot_product (A, B):\n    mem = {}\n    for i in range (len (A)):\n        for j in range (len (B)):\n            if i == j == 0:\n                ans = A[i] * B[j]\n            elif i == 0:\n                ans = max (A[i] * B[j], mem[i, j-1])\n            elif j == 0:\n                ans = max (A[i] * B[j], mem[i-1, j])\n            else:\n                ans = max (A[i] * B[j], A[i] * B[j] + mem[i-1, j-1], mem[i, j-1], mem[i-1, j])\n            mem[i, j] = ans\n    return mem[len (A) - 1, len (B) - 1]\n\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        return max_dot_product(nums1, nums2)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n,m = len(nums1),len(nums2)\n        if (max(nums1) < 0 and min(nums2) > 0) or (max(nums2) < 0 and min(nums1) > 0):\n            return max(max(nums1)*min(nums2),max(nums2)*min(nums1))\n        \n        import functools\n        @functools.lru_cache(None)\n        def DP(i,j):\n            if i == n or j == m:\n                return 0\n            if nums1[i] * nums2[j] > 0:\n                return max(nums1[i] * nums2[j]+DP(i+1,j+1),DP(i,j+1),DP(i+1,j))\n            else:\n                return max(DP(i+1,j+1),DP(i,j+1),DP(i+1,j))\n            \n        return DP(0,0)", "class Solution:\n    def maxDotProduct(self, a: List[int], b: List[int]) -> int:\n        nums1 = [0] + a\n        nums2 = [0] + b\n        m, n = len(nums1), len(nums2)\n        dp = [[float('-inf')] * m for _ in range(n)]\n\n        for i in range(1, n):\n            for j in range(1, m):\n                # if nums1[j] * nums2[i] > 0:\n                dp[i][j] = max(dp[i-1][j-1] + nums1[j] * nums2[i], dp[i][j-1], dp[i-1][j], nums1[j] * nums2[i])\n                # else:\n                    # dp[i][j] = max(dp[i][j-1], dp[i-1][j], nums1[j] * nums2[i])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, A, B):\n        n, m = len(A), len(B)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = A[i] * B[j]\n                if i and j: \n                    dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i: \n                    dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j: \n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]\n", "class Solution:\n    def maxDotProduct(self, A: List[int], B: List[int]) -> int:\n        n, m = len(A), len(B)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = A[i] * B[j]\n                if i and j: dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i: dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]", "class Solution:\n  def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n    # TC: O(MN), SC: O(MN), refr. longest common sequence, Q1035\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n      for j in range(n):\n        dp[i][j] = nums1[i] * nums2[j]\n        if i and j:\n          dp[i][j] += max(dp[i - 1][j - 1], 0)\n        if i:\n          dp[i][j] = max(dp[i][j], dp[i - 1][j])\n        if j:\n          dp[i][j] = max(dp[i][j], dp[i][j - 1])\n    return dp[m - 1][n - 1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = []\n        for i in range(len(nums1)):\n            dp.append([])\n            for j in range(len(nums2)):\n                dp[i].append(0)\n                \n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                dp[i][j] = nums1[i]*nums2[j]\n                if i and j:\n                    dp[i][j] += max(dp[i-1][j-1], 0)\n                if i:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j])\n                if j:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1])\n        return dp[-1][-1]\n                \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[0] * len(nums2) for _ in range(len(nums1))]\n        \n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                dp[i][j] = nums1[i] * nums2[j]\n                \n                if i and j:\n                    dp[i][j] += max(0, dp[i-1][j-1])\n                    \n                if i:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j])\n                    \n                if j:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1])\n                    \n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n#         Target: We want to calculate the maximal dot product for nums1[0:i] and nums2[0:j]\n# Base case\n# When i == 0 or j == 0, we return -inf. (Because this is an empty case, which is intolerable)\n# State Transition, for any i > 0 and j > 0, there are 4 possibilities\n# nums1[i - 1] is not selected, dp[i][j] = dp[i - 1][j]\n# nums2[j - 1] is not selected, dp[i][j] = dp[i][j - 1]\n# Neither nums1[i - 1] or nums2[j - 1] is selected, dp[i][j] = dp[i - 1][j - 1]\n# Both nums1[i - 1] and nums2[j - 1] are selected, dp[i][j] = max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]\n# Since we already selected one pair (nums1[i - 1], nums2[j - 1]), we can assume the minimal proceeding value is 0\n        mx, m, n = -math.inf, len(nums1), len(nums2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, num1 in enumerate(nums1):\n            for j, num2 in enumerate(nums2):\n                p = num1 * num2\n                mx = max(p, mx)\n                p = max(p, 0)\n                dp[i + 1][j + 1] = max(dp[i][j] + p, dp[i + 1][j], dp[i][j + 1])\n                \n        return mx if mx <= 0 else dp[m][n]\n             \n        # n, m = len(nums1), len(nums2)\n        # dp = [-math.inf] * (m + 1)\n        # for i in range(1, n + 1):\n        #     dp, old_dp = [-math.inf], dp\n        #     for j in range(1, m + 1):\n        #         dp += max(\n        #             old_dp[j], # not select i\n        #             dp[-1], # not select j\n        #             old_dp[j - 1], # not select either\n        #             max(old_dp[j - 1], 0) + nums1[i - 1] * nums2[j - 1], # select both\n        #         ),\n        # return dp[-1]     \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        if not nums1: \n            return 0\n        cache = [[0 for _ in nums2] for _ in nums1] \n        cache[-1][-1] = nums1[-1] * nums2[-1]\n        for i in range(len(nums1)-2, -1, -1):\n            cache[i][-1] = max(nums1[i]*nums2[-1], cache[i+1][-1]) \n        for i in range(len(nums2)-2, -1, -1):\n            cache[-1][i] = max(nums1[-1]*nums2[i], cache[-1][i+1])\n        for i in range(len(nums1)-2, -1, -1):\n            for j in range(len(nums2)-2, -1, -1):\n                cache[i][j] = max(\n                    nums1[i] * nums2[j] + max(cache[i+1][j+1], 0),\n                    cache[i+1][j],\n                    cache[i][j+1]\n                )\n        return cache[0][0]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n, m = len(nums1), len(nums2)\n        dp = [[0] * (m) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = nums1[i] * nums2[j]\n                if i and j: dp[i][j] += max(dp[i - 1][j - 1], 0)\n                if i: dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = collections.defaultdict(lambda: -math.inf)\n        for (i,j) in product(range(len(nums1)), range(len(nums2))):\n            x, y = nums1[i]*nums2[j], dp[(i-1,j-1)]\n            m = max(x,y) if x<0 and y<0 else max(x,0)+max(y,0)\n            dp[(i,j)] = max(dp[(i-1,j)], dp[(i,j-1)], m)\n        return dp[(len(nums1)-1, len(nums2)-1)]", "# class Solution:\n#     def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n#         # max over three different situations\n#         # use memoization to avoid repeating. subproblems\n\nfrom functools import lru_cache\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        @lru_cache(None)\n        def helper(i, j):\n            if i == 0 or j == 0: return -math.inf\n            return max(helper(i - 1, j - 1), helper(i, j - 1), helper(i - 1, j),\n                       max(helper(i - 1, j - 1), 0) + nums1[i - 1] * nums2[j - 1])\n        return helper(len(nums1), len(nums2))", "# DP\n\nimport sys\n\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        # DP[i][j] -- max-dot-prod(nums1[0:i], nums[0:j])\n        M = len(nums1)\n        N = len(nums2)\n        \n        dp = [[-sys.maxsize] * N for _ in range(M)]\n        \n        max_p = -sys.maxsize\n        for i, num in enumerate(nums2):\n            max_p = max(max_p, nums1[0] * nums2[i])\n            dp[0][i] = max_p\n            \n        max_p = -sys.maxsize\n        for i, num in enumerate(nums1):\n            max_p = max(max_p, nums1[i] * nums2[0])\n            dp[i][0] = max_p\n        \n        for i in range(1, M):\n            for j in range(1, N):\n                x = nums1[i] * nums2[j]\n                dp[i][j] = max(x + max(dp[i - 1][j - 1], 0), dp[i-1][j], dp[i][j-1])\n        \n        return dp[M-1][N-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = []\n        maxes = []\n        for i in range(len(nums1)):\n            dp.append([])\n            maxes.append([])\n            for j in range(len(nums2)):\n                dp[i].append(0)\n                maxes[i].append(0)\n        for i in range(len(nums1)):\n            dp[i][0] = nums1[i] * nums2[0]\n            if i > 0:\n                dp[i][0] = max(dp[i][0], dp[i-1][0])\n        for j in range(len(nums2)):\n            dp[0][j] = nums1[0] * nums2[j]\n            if j > 0:\n                dp[0][j] = max(dp[0][j], dp[0][j-1])\n        for i in range(1, len(nums1)):\n            for j in range(1, len(nums2)):\n                dp[i][j] = max(dp[i-1][j-1] + nums1[i] * nums2[j],\n                               nums1[i] * nums2[j])\n                dp[i][j] = max(dp[i][j], dp[i-1][j])\n                dp[i][j] = max(dp[i][j-1], dp[i][j])\n        return dp[-1][-1]\n#         dp = []\n#         maxes = []\n#         for i in range(len(nums1)):\n#             dp.append([])\n#             maxes.append([])\n#             for j in range(len(nums2)):\n#                 dp[i].append(0)\n#                 maxes[i].append(0)\n        \n#         for i in range(len(nums1)):\n#             dp[i][0] = nums1[i] * nums2[0]\n#             maxes[i][0] = nums1[i] * nums2[0]\n#             if i > 0:\n#                 maxes[i][0] = max(maxes[i-1][0], nums1[i] * nums2[0])\n#         for j in range(len(nums2)):\n#             dp[0][j] = nums1[0] * nums2[j]\n#             maxes[0][j] = nums1[0] * nums2[j]\n#             if j > 0:\n#                 maxes[0][j] = max(maxes[0][j-1], nums1[0] * nums2[j])\n                \n#         for i in range(1, len(nums1)):\n#             for j in range(1, len(nums2)):\n#                 dp[i][j] = max(maxes[i-1][j-1] + nums1[i] * nums2[j],\n#                               nums1[i] * nums2[j])\n#                 maxes[i][j] = max(maxes[i-1][j-1], maxes[i-1][j])\n#                 maxes[i][j] = max(maxes[i][j], maxes[i][j-1])\n#                 maxes[i][j] = max(maxes[i][j], dp[i][j])\n        \n#         return maxes[i][j]\n", "class Solution:\n    def maxDotProduct(self, nums1, nums2):\n        if all(x >= 0 for x in nums1) and all(y <= 0 for y in nums2):\n            return min(nums1) * max(nums2)\n        if all(x <= 0 for x in nums1) and all(y >= 0 for y in nums2):\n            return max(nums1) * min(nums2)\n        a, b = len(nums1), len(nums2)\n        dp = [[0 for _ in range(b)] for _ in range(a)]\n        for i in range(a):\n            for j in range(b):\n                dp[i][j] = nums1[i] * nums2[j]\n                if i: dp[i][j] = max(dp[i][j], dp[i-1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j-1])\n                if i and j: dp[i][j] = max(dp[i][j], nums1[i] * nums2[j] + dp[i-1][j-1])\n        return dp[a-1][b-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        m = len(nums2)\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n        dp[0][0] = nums1[0]*nums2[0]\n        for i in range(1,m):\n            dp[0][i] = max(dp[0][i-1],nums1[0]*nums2[i])\n        for i in range(1,n):\n            dp[i][0] = max(dp[i-1][0],nums2[0]*nums1[i])\n        for i in range(1,n):\n            for j in range(1,m):\n                dp[i][j] = max(dp[i-1][j-1],dp[i][j-1],dp[i-1][j],dp[i-1][j-1]+nums1[i]*nums2[j],nums1[i]*nums2[j])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[0] * len(nums2) for _ in range(len(nums1))]\n        \n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                dp[i][j] = nums1[i] * nums2[j]\n                if i >= 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if j >= 1:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n                if i >= 1 and j >= 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] +  nums1[i] * nums2[j])\n                \n        return dp[len(nums1) - 1][len(nums2) - 1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        a, b = [None] + nums1, [None] + nums2\n        m, n = len(a), len(b)\n        dp = [[-math.inf] * n for _ in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                here = a[i] * b[j]\n                dp[i][j] = max(\n                    here,\n                    dp[i - 1][j - 1] + max(here, 0),\n                    dp[i - 1][j],\n                    dp[i][j - 1],\n                )\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        m, n = len(nums1), len(nums2)\n        dp = [[-math.inf]*(n+1) for _ in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                a = dp[i-1][j]\n                b = dp[i][j-1]\n                c = max(dp[i-1][j-1], nums1[i-1]*nums2[j-1], dp[i-1][j-1]+nums1[i-1]*nums2[j-1])\n                dp[i][j] = max(a, b, c)\n        return dp[-1][-1]\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        arr = [[-math.inf for i in range(len(nums1)+1)] for j in range(len(nums2)+1)]\n        \n        for i in range(len(nums2)+1):\n            arr[i][0] = -math.inf\n            \n        for i in range(len(nums1)+1):\n            arr[0][i] = -math.inf\n        \n        maxc = nums2[0] * nums1[0]\n        \n        for i in range(len(nums2)+1)[1:]:\n            for j in range(len(nums1)+1)[1:]:\n                arr[i][j] = max(arr[i][j], arr[i][j-1])\n                arr[i][j] = max(arr[i][j], arr[i-1][j])\n                arr[i][j] = max(arr[i][j], max(arr[i-1][j-1], 0) + nums2[i-1]*nums1[j-1])\n                if arr[i][j] > maxc:\n                    maxc = arr[i][j]\n        \n        return maxc", "\nimport sys\nfrom typing import List\n\n\nclass Solution:\n  def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n    result = -sys.maxsize\n    len1 = len(nums1)\n    len2 = len(nums2)\n    dp = [[-sys.maxsize for j in range(len2)] for i in range(len1)]\n    for i in range(0, len1):\n      for j in range(0, len2):\n        dp[i][j] = nums1[i] * nums2[j]\n        if i > 0: dp[i][j] = max(dp[i][j], dp[i - 1][j])\n        if j > 0: dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        if i > 0 and j > 0: dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + nums1[i] * nums2[j])\n        result = max(result, dp[i][j])\n        pass\n      pass\n    return result", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        \n        n1 = len(nums1)\n        n2 = len(nums2)\n        dp = [[0] * (n2) for j in range(n1)]\n        for i in range(n1):\n            for j in range(n2):\n                dp[i][j] = nums1[i]*nums2[j]\n                if i and j: dp[i][j] += max(dp[i-1][j-1], 0)\n                if i: dp[i][j] = max(dp[i][j], dp[i-1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j-1])\n        return dp[-1][-1]\n        #         dp[i+1][j+1] = max(dp[i][j] + max(0, nums1[i] * nums2[j]), dp[i][j+1], dp[i+1][j])\n        # # print(dp)  \n        # if dp[-1][-1] != 0:\n        #     return dp[-1][-1]\n        # nums1.sort()\n        # nums2.sort()\n        # a = nums1[0] if nums1[0] > 0 else nums1[-1]\n        # b = nums2[0] if nums2[0] > 0 else nums2[-1]\n        # return a * b\n                \n                \n                \n        \n        \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        m,n=len(nums1),len(nums2)\n        dp=[[0]*n for _ in range(m)]\n        #(i,j)\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u5b50\u5e8f\u5217\u4e58\u79ef\u548c\n        for i in range(m):\n            for j in range(n):\n                dp[i][j]=nums1[i]*nums2[j]   \n                if i>0 and j>0:   #\u6b64\u65f6\u5224\u65ad\u662f\u5426\u4e0e\u524d\u8fb9\u8fde\u63a5\n                    dp[i][j]+=max(0,dp[i-1][j-1])\n                #\u5f53\u524di,j\u53ea\u53d6\u4e00\u4e2a\n                if i>0:\n                    dp[i][j]=max(dp[i][j],dp[i-1][j])\n                if j>0:\n                    dp[i][j]=max(dp[i][j],dp[i][j-1])\n        return dp[-1][-1]\n            \n#\u7c7b\u4f3c\u4e8e72\uff1a\u7f16\u8f91\u8ddd\u79bb\n#dp[i][j]\u4ee3\u8868nums1\u5230i\u4f4d\uff0cnums2\u5230j\u4f4d\u7684\u6700\u5927\u4e58\u79ef\u548c\n#\u7531\u4e8e\u662f\u5b50\u5e8f\u5217\uff0c\u8981\u5224\u65ad\u53d6i\u8fd8\u662f\u53d6j,\u4ee5\u53ca\u524d\u8fb9\u7684\u5b50\u5e8f\u5217\u8981\u4e0d\u8981\u53d6\n", "class Solution:\n    def maxDotProduct(self, nums1, nums2) -> int:\n        n, m = len(nums1), len(nums2)\n\n        dp1 = [[-float('inf')] * (m) for _ in range(n)]\n        dp2 = [[-float('inf')] * (m) for _ in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                dp1[i][j] = nums1[i] * nums2[j]\n                if i != 0 and j != 0:\n                    dp1[i][j] = max(dp1[i][j], dp2[i-1][j-1] + nums1[i] * nums2[j])\n\n                dp2[i][j] = dp1[i][j]\n                if i != 0:\n                    dp2[i][j] = max(dp2[i][j], dp2[i-1][j])\n                if j != 0:\n                    dp2[i][j] = max(dp2[i][j], dp2[i][j-1])\n\n        ans = -float('inf')\n        for i in range(n):\n            for j in range(m):\n                ans = max(ans, dp2[i][j])\n        return ans\n", "import numpy as np\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        # DP(a=index of last, b=index of last) = max of:\n        #   DP(a-1, b)\n        #   DP(a-1, i) + nums1[a] * max_or_min(nums2[i+1:b+1])\n        #   same for b\n        \n        INF = int(1e9)\n        n, m = len(nums1), len(nums2)\n\n        DP = np.ones((n + 1, m + 1), dtype=int) * -INF\n\n        for a in range(n):\n            for b in range(m):\n                \n                el = nums1[a] * nums2[b]\n\n                diag = DP[a, b]\n\n                DP[a + 1, b + 1] = max(el, DP[a, b + 1], DP[a + 1, b], diag, diag + el)\n                    \n        return DP[-1, -1]", "class Solution:\n    def maxDotProduct(self, nums1, nums2):\n        m = len(nums1)\n        n = len(nums2)\n        \n        mem = [[None]*n for i in range(m)]\n\n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                mem[i][j] = nums1[i] * nums2[j]\n        #myPrint(mem)\n\n        for i in range(m-1,-1,-1):\n            #max_ = mem[i+1][n-1] if i<m-1 else -1001\n            for j in range(n-1,-1,-1):\n                #print('i,j : ' ,i,j)\n                #if mem[i][j] < 0 and max_ < 0: \n                #    mem[i][j] = max(mem[i][j], max_)\n                #else:\n                #print('here2 :', max_)\n                #mem[i][j] = max(mem[i][j] + max_, max(mem[i][j], max_))\n                max_ = mem[i+1][j+1] if i+1<m and j+1<n else -1001\n                mem[i][j] = max(mem[i][j] + max_, max(mem[i][j], max_))\n                #print('here : ', mem[i][j])\n                mem[i][j] = max(mem[i][j], \n                                mem[i][j+1] if j<n-1 else -1001)\n                mem[i][j] = max(mem[i][j], \n                                mem[i+1][j] if i<m-1 else -1001)\n                #max_ = max(max_, mem[i+1][j] if i<m-1 else -1001)\n                #myPrint(mem)\n        return mem[0][0]", "MAX_VAL = -10 ** 9 - 7\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        num_rows = len(nums1) + 1\n        num_cols = len(nums2) + 1\n        \n        dp = []\n        for i in range(num_rows):\n            dp.append([MAX_VAL] * num_cols)\n            \n        \n        for i in range(1, num_rows):\n            for j in range(1, num_cols):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i-1] * nums2[j-1], nums1[i-1] * nums2[j-1])\n        return dp[-1][-1]", "class Solution:\n    def maxDotProduct(self, A: List[int], B: List[int]) -> int:\n        n=len(A)\n        m=len(B)\n        dp=[[0]*(m) for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j]=A[i]*B[j]\n                if i and j:\n                    dp[i][j]+=max(dp[i-1][j-1],0)\n                if i:\n                    dp[i][j]=max(dp[i][j],dp[i-1][j])\n                if j:\n                    dp[i][j]=max(dp[i][j],dp[i][j-1])\n        return dp[-1][-1]            \n                \n        \n       \n    '''\n    \n    \n[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n0 0  *  2 3\n[[6, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n0 1  *  2 0\n[[6, 6, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n0 2  *  2 -6\n[[6, 6, 6], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n----------------------\n1 0  *  1 3\n[[6, 6, 6], [6, 0, 0], [0, 0, 0], [0, 0, 0]]\n1 1  *  1 0\n[[6, 6, 6], [6, 6, 0], [0, 0, 0], [0, 0, 0]]\n1 2  *  1 -6\n[[6, 6, 6], [6, 6, 6], [0, 0, 0], [0, 0, 0]]\n----------------------\n2 0  *  -2 3\n[[6, 6, 6], [6, 6, 6], [6, 0, 0], [0, 0, 0]]\n2 1  *  -2 0\n[[6, 6, 6], [6, 6, 6], [6, 6, 0], [0, 0, 0]]\n2 2  *  -2 -6\n[[6, 6, 6], [6, 6, 6], [6, 6, 18], [0, 0, 0]]\n----------------------\n3 0  *  5 3\n[[6, 6, 6], [6, 6, 6], [6, 6, 18], [15, 0, 0]]\n3 1  *  5 0\n[[6, 6, 6], [6, 6, 6], [6, 6, 18], [15, 15, 0]]\n3 2  *  5 -6\n[[6, 6, 6], [6, 6, 6], [6, 6, 18], [15, 15, 18]]\n----------------------\n    \n    \n    \n    \n    \n    \n    \n    [0, 0, 0], \n    [0, 0, 0], \n    [0, 0, 0], \n    [0, 0, 0]\n\n    \n    \n    '''\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        L1=len(nums1)\n        L2=len(nums2)\n        temp=[[u*v for v in nums2] for u in nums1]\n        dic={}\n        dic[(0,0)]=temp[0][0]\n        def search(i,j):\n            if (i,j) in dic:\n                return dic[(i,j)]\n            if i==0:\n                dic[(0,j)]=max(search(0,j-1),temp[0][j])\n                return dic[(i,j)]\n            elif j==0:\n                dic[(i,0)]=max(search(i-1,0),temp[i][0])\n                return dic[(i,0)]\n            else:\n                dic[(i,j)]=max(search(i-1,j), search(i,j-1), temp[i][j]+search(i-1,j-1), temp[i][j])\n                return dic[(i,j)]\n        return search(L1-1,L2-1)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        L1=len(nums1)\n        L2=len(nums2)\n        temp=[[u*v for v in nums2] for u in nums1]\n        dic={}\n        dic[(0,0)]=temp[0][0]\n        def search(i,j):\n            a=temp[i][j]\n            if (i,j) in dic:\n                return dic[(i,j)]\n            if i==0:\n                dic[(0,j)]=max(search(0,j-1),a)\n                return dic[(i,j)]\n            elif j==0:\n                dic[(i,0)]=max(search(i-1,0),a)\n                return dic[(i,0)]\n            else:\n                dic[(i,j)]=max(search(i-1,j), search(i,j-1), a+search(i-1,j-1), a)\n                return dic[(i,j)]\n        return search(L1-1,L2-1)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        # fuck!!! I finally did a DP problem!!! CRYING\n        n1 = len(nums1)\n        n2 = len(nums2)\n        dp = [[0] * (n2) for j in range(n1)]\n        for i in range(n1):\n            for j in range(n2):\n                dp[i][j] = nums1[i]*nums2[j]\n                if i and j: dp[i][j] += max(dp[i-1][j-1], 0)\n                if i: dp[i][j] = max(dp[i][j], dp[i-1][j])\n                if j: dp[i][j] = max(dp[i][j], dp[i][j-1])\n        return dp[-1][-1]\n        #         dp[i+1][j+1] = max(dp[i][j] + max(0, nums1[i] * nums2[j]), dp[i][j+1], dp[i+1][j])\n        # # print(dp)  \n        # if dp[-1][-1] != 0:\n        #     return dp[-1][-1]\n        # nums1.sort()\n        # nums2.sort()\n        # a = nums1[0] if nums1[0] > 0 else nums1[-1]\n        # b = nums2[0] if nums2[0] > 0 else nums2[-1]\n        # return a * b\n                \n                \n                \n        \n        \n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        N, M = len(nums1), len(nums2)\n        dp = [[None] * M for _ in range(N)]\n        def solve(i, j):\n            if i >= N or j >= M: return 0\n            if dp[i][j] is None:\n                dp[i][j] = max(nums1[i] * nums2[j] + solve(i+1, j+1), solve(i+1, j), solve(i, j+1), solve(i+1, j+1))\n            return dp[i][j]\n        result = solve(0, 0)\n        if result == 0 and 0 not in nums1 + nums2:\n            if nums1[0] < 0:\n                return max(nums1) * min(nums2)\n            else:\n                return min(nums1) * max(nums2)\n        else:\n            return result", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[-sys.maxsize-1 for i in range(len(nums2)+1)] for j in range(len(nums1)+1)]\n        \n        for i in range(1,len(nums1)+1):\n            for j in range(1,len(nums2)+1):\n                t = nums1[i-1]*nums2[j-1]\n                if dp[i-1][j-1] == -sys.maxsize-1:\n                    dp[i][j] = max(t,max(dp[i-1][j], dp[i][j-1]))\n                else:\n                    dp[i][j] = max(dp[i-1][j-1]+t,max(dp[i-1][j], dp[i][j-1]))\n                    dp[i][j] = max(t,dp[i][j])\n        # print(dp)\n        return dp[-1][-1]\n", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dic={}\n        dic[(0,0)]=nums1[0]*nums2[0]\n        def search(i,j):\n            a=nums1[i]*nums2[j]\n            if (i,j) in dic:\n                return dic[(i,j)]\n            if i==0:\n                dic[(0,j)]=max(search(0,j-1),a)\n                return dic[(i,j)]\n            elif j==0:\n                dic[(i,0)]=max(search(i-1,0),a)\n                return dic[(i,0)]\n            else:\n                dic[(i,j)]=max(search(i-1,j), search(i,j-1), a+search(i-1,j-1), a)\n                return dic[(i,j)]\n        return search(len(nums1)-1,len(nums2)-1)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        dp = [[0 for j in range(len(nums2))] for i in range(len(nums1))]\n        dp[0][0] = nums1[0] * nums2[0]\n        for j in range(1, len(nums2)):\n            dp[0][j] = max(dp[0][j-1], nums1[0] * nums2[j])\n        for i in range(1, len(nums1)):\n            dp[i][0] = max(dp[i - 1][0], nums1[i] * nums2[0])\n        for i in range(1, len(nums1)):\n            for j in range(1, len(nums2)):\n                dp[i][j] = max(max(dp[i-1][j - 1], 0) + (nums1[i] * nums2[j]), dp[i-1][j], dp[i][j-1])\n        \n        return dp[len(nums1) - 1][len(nums2) - 1]", "from functools import lru_cache\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        @lru_cache(None)\n        def dot(i, j):\n            if i == N1 or j == N2: return -sys.maxsize\n            ans = nums1[i]*nums2[j]\n            ans = max(ans,\n                      ans + dot(i + 1, j + 1),\n                      dot(i, j + 1),\n                      dot(i + 1, j),\n                      dot(i + 1, j + 1)\n                     )\n            return ans\n        N1, N2 = len(nums1), len(nums2)\n        return dot(0, 0)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        m = len(nums1)\n        n = len(nums2)\n        dp = [[-math.inf] * (n) for _ in range(m)]\n        \n        \n        for i in range(0, m):\n            for j in range(0, n):\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j])\n                if j > 0:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1])\n                dp[i][j] = max(dp[i][j], nums1[i] * nums2[j])\n                if i > 0 and j>0 and dp[i-1][j-1] > 0:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + nums1[i] * nums2[j])                    \n                                    \n        return dp[m-1][n-1]\n                    \n                    \n                \n", "def maxsub(a,b):\n    dp = [[0 for x in range(len(b))] for x in range(len(a))]\n    \n    for i in range(len(a)):\n        for j in range(len(b)):\n            dp[i][j] = a[i]*b[j]\n            if i-1>=0:\n                dp[i][j] = max(dp[i][j],dp[i-1][j] )\n            if j-1>=0:\n                dp[i][j] = max(dp[i][j],dp[i][j-1] )\n            if i-1>=0 and j-1>=0:\n                dp[i][j] = max(dp[i][j],dp[i-1][j-1]+a[i]*b[j] )\n    return dp[-1][-1]\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        return maxsub(nums1, nums2)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n      return dp_with_recursion(nums1, nums2)\ndef dp_with_recursion(a, b):\n  @lru_cache(maxsize=None)\n  def recursion(i,j, is_empty=True):\n    if i < 0 or j < 0: return float('-inf') if is_empty else 0\n    # BUG, BUG!\n    #return max(recursion(i, j-1), recursion(i-1,j), recursion(i-1,j-1) + max(0, a[i]*b[j]))\n    #return max(recursion(i, j-1), recursion(i-1,j), recursion(i-1, j-1, False) + a[i]*b[j])\n    return max(recursion(i, j-1, is_empty), recursion(i-1,j, is_empty), recursion(i-1, j-1, False) + a[i]*b[j])\n  return recursion(len(a)-1, len(b)-1)", "class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        a =[[-1 for _ in range(len(nums2))] for _ in range(len(nums1))]\n        def dp(x, y):\n            if len(nums1) ==x or len(nums2) ==y:\n                return -float('inf')\n            if a[x][y] != -1:\n                return a[x][y]\n            else:\n                a[x][y] = max(dp(x+1, y), dp(x, y+1), dp(x+1, y+1) + nums1[x]*nums2[y], nums1[x]*nums2[y])\n                return a[x][y]\n        \n        return  dp(0,0)\n        \n        \n", "from functools import lru_cache\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        @lru_cache(None)\n        def solve(i, j, c):\n            if i == len(nums1) or j == len(nums2):\n                if c:\n                    return 0\n                return float('-inf')\n            return max(solve(i+1, j, c), solve(i, j+1, c), nums1[i]*nums2[j] + solve(i+1, j+1, True))\n        return solve(0, 0, False)"]
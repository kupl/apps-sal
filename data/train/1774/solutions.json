["class Funnel(object):\n    \n    SIZE = 5\n    \n    def __init__(self):\n        self.fun = [ [None] * (x+1) for x in range(self.SIZE) ]\n        \n    \n    def fill(self, *args):\n        genBlanks = ((x,y) for x,r in enumerate(self.fun) for y,v in enumerate(r) if v is None)\n        \n        for v,(x,y) in zip(args, genBlanks): \n            self.fun[x][y] = v\n    \n    \n    def drip(self):\n        y,cnt = 0, sum(v is not None for row in self.fun for v in row)\n        drop  = self.fun[0][0]\n        \n        for x in range(self.SIZE-1):\n            left  = cnt - sum( self.fun[xx][y+xx-x] is not None for xx in range(x,self.SIZE))\n            right = cnt - sum( self.fun[xx][y] is not None      for xx in range(x,self.SIZE))\n            \n            ySwp, cnt      = (y,left) if left >= right else (y+1,right)\n            self.fun[x][y] = self.fun[x+1][ySwp]\n            y = ySwp\n            if not cnt: break\n        \n        self.fun[x+1][y] = None\n        return drop\n        \n    \n    def __str__(self):\n        return '\\n'.join( f'{\" \"*x}\\\\{\" \".join( \" \" if v is None else str(v) for v in r)}/'\n                          for x,r in enumerate(reversed(self.fun)) )\n", "class Funnel(object):\n    above = ((1, 2), (3, 4), (4, 5), (6, 7), (7, 8), (8, 9), (10, 11), (11, 12), (12, 13), (13, 14))\n    weight = (None, (3, 4, 6, 7, 8, 10, 11, 12, 13), (4, 5, 7, 8, 9, 11, 12, 13, 14), (6, 7, 10, 11, 12), (7, 8, 11, 12, 13), (8, 9, 12, 13, 14), (10, 11), (11, 12), (12, 13), (13, 14))\n    \n    def __init__(self):\n        self.f = [\" \"]*15\n    \n    def fill(self, *args):\n        i = 0\n        for x in args:\n            while i < 15 and self.f[i] != \" \": i += 1\n            if i == 15: break\n            self.f[i] = x\n    \n    def drip(self):\n        if self.f[0] == \" \": return\n        helper = lambda i: (self.f[i] != \" \", i < 10 and sum(self.f[j] != \" \" for j in Funnel.weight[i])+1)\n        res, self.f[0] = self.f[0], \" \"\n        def rec(i=0):\n            if i < 10 and self.f[i] == \" \":\n                j = max(Funnel.above[i], key=helper)\n                self.f[i], self.f[j] = self.f[j], \" \"\n                rec(j)\n        return rec() or res\n    \n    def __str__(self):\n        return \"\\\\{10} {11} {12} {13} {14}/\\n \\\\{6} {7} {8} {9}/\\n  \\\\{3} {4} {5}/\\n   \\\\{1} {2}/\\n    \\\\{0}/\".format(*self.f)", "class Funnel():\n    \n    def __init__(self):\n        self.funnel = [[\" \" for j in range(i+1)] for i in range(5)]\n        self.data = 0\n\n    def fill(self, *args):\n        for arg in args:\n            if self.data<15:\n                for indexi, i in enumerate(self.funnel):\n                    if \" \" in i:\n                        self.funnel[indexi][i.index(\" \")] = str(arg)\n                        self.data += 1\n                        break\n                        \n                    \n                \n    def count_weight_left(self,row, index):\n        if self.funnel[row][index] != \" \":\n            if row <4:\n                return 1 + self.count_weight_left(row+1, index)\n            else:\n                return 1\n        return 0\n\n    def count_weight_both(self, row, index):\n        if self.funnel[row][index] != \" \":\n            if row < 4:\n                return 1 + self.count_weight_left(row+1, index) + self.count_weight_both(row+1, index+1)\n            else:\n                return 1\n        return 0\n\n    def drip(self):\n        if not self.data:\n            return None\n        self.data-= 1\n        value = int(self.funnel[0][0])\n        index = 0\n\n        for row in range(1,5):\n            if self.count_weight_both(row ,index)>= self.count_weight_both(row, index + 1):\n                self.funnel[row-1][index] = self.funnel[row][index]\n                self.funnel[row][index] = \" \"\n            else:\n                self.funnel[row-1][index] = self.funnel[row][index+1]\n                index += 1\n                self.funnel[row][index] = \" \"\n        \n\n        return value    \n\n    def __str__(self):\n        string=\"\"\n        for index, i in enumerate(reversed(self.funnel)):\n            string+= \" \"*index + \"\\\\\" + \" \".join(i) + \"/\\n\"\n        return string[:-1]\n", "class Funnel():\n\n    def __init__(self, levels_count=5):\n\n        self.levels_count = levels_count\n\n        self.__levels = [[[] for _ in range(i)] for i in range(1, self.levels_count+1)]\n\n        self.__curr = [0,0]\n\n    def __fill_one(self, d):\n\n        curr = self.__get_curr()\n        levels = self.__levels\n        N = self.levels_count\n\n        if not curr:\n            return\n\n        levels[curr[0]][curr[1]] = [d]\n\n    def __get_curr(self):\n\n        curr = None\n\n        for k, level in enumerate(self.__levels):\n            if [] in level:\n                curr = [k, level.index([])]\n                break\n\n        return curr\n\n    def fill(self, *args):\n        for d in args:\n            self.__fill_one(d)\n\n    def drip(self):\n\n        if not self.__levels[0][0]:\n            return None\n\n        r = self.__levels[0][0][0]\n\n        self.__levels[0][0] = []\n\n        N = self.levels_count\n\n        hole = [0, 0]\n\n        while hole:\n\n            if hole[0] + 1 >= N:\n                break\n\n            a = [hole[0] + 1, hole[1]]\n            b = [hole[0] + 1, hole[1] + 1]\n\n            if self.__levels[a[0]][a[1]] == [] and self.__levels[b[0]][b[1]] == []:\n                break\n\n            c = max(a, b, key=lambda x: len(self.__get_childs(x[0], x[1])))\n\n            self.__levels[hole[0]][hole[1]] = self.__levels[c[0]][c[1]]\n\n            hole = c\n\n            self.__levels[hole[0]][hole[1]] = []\n\n            self.__curr = hole\n\n        return r\n\n\n    def __get_childs(self, level_i, list_j):\n\n        N = self.levels_count\n\n        delta = N - level_i\n\n        r = [self.__levels[level_i][list_j]] + [self.__levels[level_i+k][list_j:list_j+k+1] for k in range(1, delta)]\n\n        r = [v2 for v1 in r for v2 in v1 if v2 != []]\n        \n        return r\n\n    def __str__(self):\n\n        N = self.levels_count\n\n        pr = []\n\n        for l in self.__levels:\n            t = \" \".join([str(e[0]) if len(e)==1 else \" \" for e in l])\n            n = (2 * N - 1 - len(t))//2\n            t = \" \" * n + \"\\\\\" + t + \"/\"\n            pr.append(t)\n\n        return \"\\n\".join(pr[::-1])", "def check(lst, row, col):\n    rows = [i for i in [-1,-2,-3,-4,-5] if i<row-1]\n    idx1 = (row-1, col)\n    val1 = lst[row-1][col]\n    try:\n        idx2 = (row-1, col+1)\n        val2 = lst[row-1][col+1]\n    except:\n        return idx1\n    c1, w = 0, 2\n    for i in rows:\n        for j in range(col, col+w):\n            try:\n                if lst[i][j] != \" \":\n                    c1 += 1\n            except:\n                pass\n        w += 1        \n    c2, w = 0, 2\n    for i in rows:\n        for j in range(col+1, col+1+w):\n            try:\n                if lst[i][j] != \" \":\n                    c2 += 1\n            except:\n                pass\n        w += 1\n    if val1 == \" \" and val2 != \" \": return idx2\n    if val1 != \" \" and val2 == \" \": return idx1\n    if val1 != \" \" and val2 == \" \": return idx1\n    if c1 >= c2: return idx1\n    if c2 > c1: return idx2\n\nclass Funnel(object):\n    def __init__(self):\n        self.lst = [[\" \",\" \",\" \",\" \",\" \"],\n                    [\" \",\" \",\" \",\" \"],\n                    [\" \",\" \",\" \"],\n                    [\" \",\" \"],\n                    [\" \"]]\n    def fill(self, *args):\n        args = list(args)\n        if args != []:\n            for i in [-1,-2,-3,-4,-5]:\n                c = abs(i)\n                x = self.lst[i]\n                f = False\n                for j in range(c):\n                    if x[j] == \" \":\n                        x[j] = args.pop(0)\n                        if args == []:\n                            f = True\n                            break\n                self.lst[i] = x\n                if f == True:\n                    break\n            return self.lst\n        return self.lst\n\n    def drip(self):\n        if self.lst[-1][-1] != \" \":\n            val = self.lst[-1][-1]\n            self.lst[-1][-1] = \" \"\n            idx = 0\n            for i in [-1,-2,-3,-4]:\n                res = check(self.lst, i, idx)\n                self.lst[i][idx] = self.lst[res[0]][res[1]]\n                self.lst[res[0]][res[1]] = \" \"\n                idx = res[1]\n            return val        \n               \n    def __str__(self):\n        res = [\" \"*(i)+\"\\\\\"+' '.join(list(map(str, e)))+\"/\" for i, e in enumerate(self.lst)]\n        return '\\n'.join(res)", "class Funnel(object):\n    # Coding and coding...\n    \n    def __init__(self): \n        self.data = [[None]*i for i in range(1,6)]\n        self.number_elements = 0\n    \n    def fill(self, *args):\n        for new_elem in args:\n            added = False\n            if self.number_elements < 15:\n                for row in self.data:\n                    for i in range(len(row)):\n                        if row[i] is None and not added:\n                            row[i] = new_elem\n                            added = True\n                            self.number_elements += 1          \n    \n     \n    def get_elem_above(self,row,idx):\n        if row >= 5 or self.data[row][idx] is None:\n            return []\n        return [(row,idx)] + self.get_elem_above(row+1,idx) + self.get_elem_above(row+1,idx+1)\n    \n    def get_number_above(self,row,idx):\n        return len(set(self.get_elem_above(row,idx)))\n    \n    def drip(self): \n        node = self.data[0][0]\n        self.number_elements -= 1\n        current_row = 0\n        current_idx = 0\n        while current_row <= 4 and self.data[current_row][current_idx] is not None:\n            print(self.get_number_above(current_row+1,current_idx))\n            print(self.get_number_above(current_row+1,current_idx+1))\n            print(current_row,current_idx)\n            if self.get_number_above(current_row+1,current_idx) >= self.get_number_above(current_row+1,current_idx+1):\n                self.data[current_row][current_idx] = None if current_row == 4 else self.data[current_row+1][current_idx]\n                current_row += 1\n            else:\n                self.data[current_row][current_idx] = None if current_row == 4 else self.data[current_row+1][current_idx+1]\n                current_row += 1\n                current_idx += 1\n\n        return node\n    \n    def __str__(self): \n        res = \"\"\n        for i,row in enumerate(self.data[::-1]):\n            res += (\" \" * i + \"\\\\\" + \" \".join([str(elem) if elem is not None else \" \" for elem in row]) + \"/\\n\")\n        return res[:-1]", "from typing import Tuple\n\n\nclass Funnel:\n    def __init__(self):\n        self.levels = [[None] * (i + 1) for i in reversed(range(5))]\n\n    def __getitem__(self, indexes: Tuple[int, int]):\n        r, c = indexes\n        if 0 <= r < 5 and 0 <= c < (5 - r):\n            return self.levels[r][c]\n\n    def fill(self, *args):\n        free = ((x, y) for x, row in reversed([*enumerate(self.levels)]) for y, a in enumerate(row) if a is None)\n        for (x, y), val in zip(free, args):\n            self.levels[x][y] = val\n\n    def above(self, r: int, c: int):\n        if r >= 0 and c >= 0 and self[r, c] is not None:\n            yield r, c\n\n            for d in range(2):\n                if self[r - 1, c + d] is not None:\n                    yield r - 1, c + d\n                    yield from self.above(r - 1, c + d)\n\n    def drip(self, row: int = 4, col: int = 0):\n        if row >= 0:\n            left, right = (len({*self.above(row - 1, col + d)}) for d in range(2))\n            self.levels[row][col], val = self.drip(row - 1, col + (right > left)), self.levels[row][col]\n            return val\n\n    def __str__(self):\n        return '\\n'.join(\n            fr\"{' ' * i}\\{' '.join(' ' if x is None else str(x) for x in row)}/\"\n            for i, row in enumerate(self.levels)\n        )", "from typing import Tuple\n\n\nclass Funnel:\n    def __init__(self):\n        self.arr = [[None] * (i + 1) for i in reversed(list(range(5)))]\n\n    def __getitem__(self, indexes: Tuple[int, int]):\n        r, c = indexes\n        if 0 <= r < 5 and 0 <= c < (5 - r):\n            return self.arr[r][c]\n\n    def fill(self, *args):\n        args = [*args]\n        for row in reversed(self.arr):\n            for i, x in enumerate(row):\n                if args and x is None:\n                    row[i] = args.pop(0)\n\n    def above(self, r: int, c: int):\n        if r >= 0 and c >= 0 and self[r, c] is not None:\n            yield r, c\n\n            for d in range(2):\n                if self[r - 1, c + d] is not None:\n                    yield r - 1, c + d\n                    yield from self.above(r - 1, c + d)\n\n    def drip(self, row: int = 4, col: int = 0):\n        if row >= 0:\n            left, right = (len({*self.above(row - 1, col + d)}) for d in range(2))\n            self.arr[row][col], val = self.drip(row - 1, col + (right > left)), self.arr[row][col]\n            return val\n\n    def __str__(self):\n        return '\\n'.join(\n            ' ' * i + fr\"\\{' '.join(' ' if x is None else str(x) for x in row)}/\"\n            for i, row in enumerate(self.arr)\n        )\n", "\nclass Node(object):\n    def __init__(self, value=None, left_child=None, right_child=None):\n        self.value = None if value is None else str(value)\n        self.left_child = left_child\n        self.right_child = right_child\n        self.visited = False\n\n    def is_empty(self):\n        return self.value is None\n\n    def has_value(self):\n        return self.value is not None\n\n    def is_top_level(self):\n        return self.left_child is None\n\n    def is_leaf(self):\n        return self.is_top_level() or not (self.left_child.has_value() or self.right_child.has_value())\n\n    def num_children_recursive(self):\n        if self.is_empty():\n            return 0\n\n        if self.is_top_level():\n            return 1\n\n        children = [p for p in [self.left_child, self.right_child] if p.has_value() and not p.visited]\n        for child in children:\n            child.visited = True\n        return (1 if self.has_value() else 0) + sum(p.num_children_recursive() for p in children)\n\n    def drip(self):\n        original_value = self.value\n\n        if self.is_empty() or self.is_top_level():\n            self.value = None\n        else:\n            num_children_left = self.left_child.num_children_recursive()\n            self.reset_visited_recursive()\n            num_children_right = self.right_child.num_children_recursive()\n            self.reset_visited_recursive()\n\n            if num_children_left >= num_children_right:\n                self.value = self.left_child.drip()\n            else:\n                self.value = self.right_child.drip()\n\n        return original_value\n\n    def reset_visited_recursive(self):\n        self.visited = False\n\n        if not self.is_top_level():\n            self.left_child.reset_visited_recursive()\n            self.right_child.reset_visited_recursive()\n\n    def __str__(self):\n        return str(self.value) if self.has_value() else ' '\n\n\nclass Funnel(object):\n    def __init__(self):\n        self.count = 0\n        # create and link up nodes for each funnel value space\n        prev_level = [Node() for _ in range(5)]\n        for i in range(4, 0, -1):\n            level = [Node() for _ in range(i)]\n\n            for j, parent in enumerate(level):\n                parent.left_child = prev_level[j]\n                parent.right_child = prev_level[j + 1]\n\n            prev_level = level\n\n        self.root = prev_level[0]\n\n    def fill(self, *args):\n        for value in args:\n            self.fill_one(value)\n\n    def fill_one(self, value):\n        if self.count < 15:\n            if self.root.is_empty():\n                self.root.value = value\n            else:\n                pool = [self.root]\n                space_found = False\n\n                while not space_found:\n                    for i, node in enumerate(pool):\n                        if node.left_child.is_empty():\n                            node.left_child.value = value\n                            space_found = True\n                            break\n                        elif node.right_child.is_empty():\n                            node.right_child.value = value\n                            space_found = True\n                            break\n\n                    children = [n.left_child for n in pool] + [pool[-1].right_child]\n                    pool = children\n\n            self.count += 1\n\n    def drip(self):\n        if self.count == 0:\n            return None\n\n        self.count -= 1\n        return self.root.drip()\n\n    def get_levels(self):\n        pool = [self.root]\n        levels = []\n\n        levels.insert(0, pool)\n        for i in range(4):\n            pool = [n.left_child for n in pool] + [pool[-1].right_child]\n            levels.insert(0, pool)\n\n        return levels\n\n    def __str__(self):\n        s = ''\n\n        for i, level in enumerate(self.get_levels()):\n            s += (' ' * i) + '\\\\' + ' '.join([str(n) for n in level]) + '/\\n'\n\n        # exclude final newline\n        return s[:-1]\n", "class Funnel(object):\n    # Coding and coding...\n    \n    def __init__(self):\n        self.data = [[None for _ in range(row+1)] for row in range(5)]\n    \n    def fill(self, *args):\n        if args:\n            for row in self.data:\n                for i, val in enumerate(row):\n                    if val == None:\n                        row[i], args = args[0], args[1:]\n                        if not args:\n                            return\n    \n    def __weight(self, pos, hist):\n        if pos in hist:\n            return 0\n        y,x = pos\n        if not (0<=y<len(self.data) and 0<=x<len(self.data[y])):\n            return 0\n        hist.append(pos)\n        return 0 if self.data[y][x]==None else 1 + sum(self.__weight(p,hist) for p in ((y+1,x),(y+1,x+1)))\n    \n    def drip(self):\n        ret = self.data[0][0]\n        pos = (0,0)\n        top = [(1,0),(1,1)]\n        while True:\n            top = [(pos[0]+1,pos[1]+i) for i in range(2)]\n            \n            top = [(x, self.__weight(x,[])) for x in top]\n            \n            top = list([x for x in top if x[1]!=0])\n            if not top:\n                if pos == (0,0):\n                    self.data[pos[0]][pos[1]]=None\n                return ret\n            top.sort(key=lambda x: x[1], reverse=True)\n            t_pos = top[0][0]\n            \n            self.data[pos[0]][pos[1]] = self.data[t_pos[0]][t_pos[1]]\n            self.data[t_pos[0]][t_pos[1]] = None\n            pos = t_pos\n    \n    def __str__(self):\n        str_row = lambda r: str(r).replace('[' , '\\\\').replace(']','/').replace(',','').replace('None', ' ').replace(\"'\",\"\").center(11,' ').rstrip()\n        return '\\n'.join(str_row(row) for row in self.data[::-1])\n"]
["def collatz_steps(n, steps):\n    while True:\n        str = ''\n        result = n\n    \n        while bool(str != steps) ^ bool(str != steps[:len(str)]):\n            if result % 2 == 0:\n                result = result/2\n                str += 'D'\n            else:\n                result = (3*result + 1)/2\n                str += 'U'\n            \n        if str != steps: \n              n += 2**(len(str)-1)\n        else: \n              return n", "def collatz_steps(n, steps):\n    a,b,m=1,0,1\n    for c in steps:\n        if 'U'==c:\n            b=3*b+m\n            a*=3\n        m*=2\n    ret=-b*pow(a,m//2-1,m)\n    ret+=(n+m-1-ret)//m*m\n    return ret\n", "# both approaches work because a and m are relatively prime:\n# a is a power of 3 while m is a power of 2\n\n# Since a and m are coprime, a^(phi(m)) = 1 (mod m), where phi(m) is the Euler totient function\n# if m is a power of 2, phi(m) = m/2\n# then, diving the above equation by a we get: a^(-1) = a^(phi(m)-1) (mod m),\n# which is our multiplicative inverse\ndef ModInv(a, m):\n    return pow(a, (m>>1)-1, m)\n\ndef Ext_Euclid_Alg(a, m):\n    old_r, r = a, m\n    old_s, s = 1, 0\n    \n    while r:\n        q = old_r // r\n        old_r, r = r, old_r - q * r\n        old_s, s = s, old_s - q * s\n    \n    return old_s if old_s > 0 else old_s + m\n\n\ndef collatz_steps(n, steps):\n    # The fraction we get after applying all the steps is of the form\n    # (a*x + b)/m, where x is a number such that the later division results in\n    # an integer, a = 3^(#'U'), m = 2^(len(steps)) and b[i] = b[i-1] if 'D' else 3*b[i-1] + 2^i\n    a, b, m = 1, 0, 1\n    for i, s in enumerate(steps):\n        m *= 2\n        if s == 'U':\n            a *= 3\n            b = 3*b + 2**i\n    \n    # a*x + b = 0 (mod m) (=) a*x = -b (mod m) (=) x = a^(-1)*(-b) (mod m)\n    # a^(-1) is the modular multiplicative inverse of a mod m: it is the number y such that\n    # a*y = 1 (mod m)\n    # It will be calculated using the Extend Euclid's Algorithm\n    x = (-b * ModInv(a, m)) % m\n    # So the number is between n-m and n+m:\n    x += m * (n//m)\n    # So the number is greater than n:\n    return x + m if x < n else x", "def collatz_steps(n, steps):\n    i = 0\n    exp_2, exp_3 = 1, 1\n    ind, flag = 0, 0\n    \n    for i in range(0,len(steps)):\n        if(i == 0 and steps[0] == 'U'):\n            exp_3 = exp_3*3\n            ind = 1\n            exp_2 = exp_2*2\n        else:\n            if(steps[i] == 'U'):\n                exp_3 = exp_3*3\n                ind = ind*3 + exp_2\n                exp_2 = exp_2*2\n            elif(steps[i] == 'D'):\n                exp_2 = exp_2*2\n    \n    i = (exp_3*n + ind)//exp_2\n    while(flag == 0):\n        if((exp_2*i - ind)%exp_3 == 0):\n            flag = 1\n        else:\n            i = i + 1\n            \n            \n    return (exp_2*i - ind)//exp_3\n        \n", "def modinv(a, m):\n    return pow(a, (m>>1)-1, m)\n\n\ndef c(string):\n    x, y, z = 1, 0, 1\n    for char in string:\n        x, y, z = (x+(x<<1), y+(y<<1)+z, z<<1) if char == 'U' else (x, y, z<<1)\n    return x, y, z\n\n\ndef collatz_steps(n, steps):\n    x, y, z = c(steps)\n    p = (modinv(x, z) * -y) % z\n    p += ((n-p) // z) * z\n    while p < n:\n        p += z\n    return p\n", "def egcd(a, b):\n    if a == 0:\n        return 0, 1\n    y, x = egcd(b % a, a)\n    return x - (b//a) * y, y\n    \n\ndef modinv(a, m):\n    x, y = egcd(a, m)\n    return x & (m-1)\n\n\ndef c(string):\n    x, y, z = 1, 0, 1\n    for char in string:\n        x, y, z = (x+(x<<1), y+(y<<1)+z, z<<1) if char == 'U' else (x, y, z<<1)\n    return x, y, z\n\ndef collatz_steps(n, steps):\n    x, y, z = c(steps)\n    p = (modinv(x, z) * -y) % z\n    while p < n:\n        p += z\n    return p\n", "import math\n\ndef ModularInverse(a, b):\n  #Use Euclidean algorithm, storing coefficients of each step\n  coeffs = []\n  while b > 0:\n    coeffs.append(math.floor(a/b))\n    a, b = b, a % b\n  #Iterate back through all coefficients to construct coefficients for initial a and b\n  c1 = 1\n  c2 = 0\n  for co in coeffs[::-1]:\n    c1, c2 = c2, c1-co*c2\n  return c2\n\ndef collatz_steps(n, steps):\n  # Applying all U/D steps and simplifying results in...\n  # (ax + b)/m is an integer, where \n  # a = 3 ^ (# of U in steps)\n  # b = f(#steps-1) where\n  #   f(-1) = 0\n  #   f(i)=3f(i-1)+2^i when steps[i]==U\n  #   f(i)=f(i-1)      when steps[i]==D\n  # m = 2 ^ (#steps)\n  a = 1\n  b = 0\n  m = 1\n  for i in range(len(steps)):\n    m = m * 2\n    if steps[i] == 'U':\n      a = a * 3\n      b = 3*b + 2**i\n  # Thus,\n  # ax = -b mod m\n  #  x = -ba^-1 mod m\n  #  x = -ba^-1 + mC\n  # Choose C such that n-m < x < n+m\n  x = ((-b)*ModularInverse(m, a))%m + m*math.floor(n/m)\n  if (x < n):\n    x = x + m\n  return x\n", "import math\n\ndef collatz_steps(n, steps):\n  # ax = b mod m\n  # a = 3 ^ (# of U in steps)\n  # b = -f(#steps-1) where\n  #   f(-1) = 0\n  #   f(i)=3f(i-1)+2^i when steps[i]==U\n  #   f(i)=f(i-1)      when steps[i]==D\n  # m = 2 ^ (#steps)\n  a = 1\n  b = 0\n  m = 1\n  for i in range(len(steps)):\n    m = m * 2\n    if steps[i] == 'U':\n      a = a * 3\n      b = 3*b + 2**i\n  b = m - (b%m)\n  # ax = b mod m\n  a = a % m\n  #  x = ba^-1 mod m\n  coeffs = []\n  ae = m\n  be = a\n  while be > 0:\n    coeffs.append(math.floor(ae/be))\n    ae, be = be, ae % be\n  xe = 0\n  ye = 1\n  for co in coeffs[::-1]:\n    xe, ye = ye-co*xe, xe\n  ai = xe%m\n  x = (b*ai)%m\n  # x = ba^-1 + mC\n  x = x + m*math.floor(n/m)\n  if (x < n):\n    x = x + m\n  return x\n", "from math import ceil\n\ndef collatz_steps(min_number, steps):\n    start, interval = start_and_interval(steps)\n    n_intervals = ceil((min_number - start) / interval)\n    return start + n_intervals * interval\n    \n    \ndef start_and_interval(steps):    \n    \"\"\"\n    The numbers of the kind N = start + k * interval_start are the numbers N which generate the\n    sequence :steps: when used as start for the collatz sequence.    \n    The numbers of the kind N = end + K * interval_end are the numbers N which result of applying\n    the collatz sequence after some steps of :steps:.\n    \"\"\"\n    start = 1\n    interval_start = 1\n    end = 1\n    interval_end = 1    \n    \n    for step in steps:        \n        if end % 2 == 0:\n            expected_next = \"D\"\n        else:\n            expected_next = \"U\"\n        \n        if step != expected_next:\n            start += interval_start\n            end += interval_end\n            \n        if step == \"D\":\n            end //= 2\n        else:\n            end = (end * 3 + 1) // 2\n            interval_end *= 3\n            \n        interval_start *= 2\n    \n    return start, interval_start    ", "def collatz_steps(n, s):\n    while True:\n        x = n\n        ans = ''\n        flag = True\n        for j in range(len(s)):\n            if x%2 == 0:\n                x = x//2\n                ans += 'D'\n            else:\n                x = (x*3+1)//2\n                ans += 'U'\n            if ans[j] != s[j]:\n                flag = False\n                break\n        if flag == True:\n            return n\n        else:\n            n += 2**(len(ans)-1)"]
["MOD = 1000000007\n\nn = int(input())\np = [int(x) for x in input().split()]\nx = [int(x) for x in input().split()]\n\nchildren = [[] for x in range(n)]\n\nfor i in range(1,n):\n    children[p[i-1]].append(i)\n\n#print(children)\n\ncount = [(0,0) for i in range(n)]\nfor i in reversed(list(range(n))):\n    prod = 1\n    for ch in children[i]:\n        prod *= count[ch][0]+count[ch][1]\n    if x[i]:\n        count[i] = (0,prod % MOD)\n    else:\n        tot = 0\n        for ch in children[i]:\n            cur = count[ch][1]*prod // (count[ch][0]+count[ch][1])\n            tot += cur\n        count[i] = (prod % MOD, tot % MOD)\n\nprint(count[0][1])\n", "from collections import UserDict\n\n\nclass Tree(UserDict):\n    def __init__(self, g):\n        super().__init__()\n        for name, value in enumerate(g, 1):\n            self[value] = name\n\n    def __setitem__(self, name, value):\n        if name in self:\n            if value is not None:\n                self[name].add(value)\n                self[value] = None\n        else:\n            if value is None:\n                super().__setitem__(name, set())\n            else:\n                super().__setitem__(name, {value})\n                self[value] = None\n\n\ndef __starting_point():\n    n = int(input())\n\n    tree = Tree(int(i) for i in input().split())\n    colors = [int(i) for i in input().split()]\n    t = [()] * n\n\n    def dfs(v):\n        stack = [v]\n        visited = set()\n\n        while stack:\n            v = stack.pop()\n            if v not in visited:\n                visited.add(v)\n                stack.append(v)\n                stack.extend(tree[v])\n            else:\n                t[v] = (1, colors[v])\n                for u in tree[v]:\n                    t[v] = (\n                        (t[v][0] * t[u][1] + t[v][0] * t[u][0] * (not colors[u])) % (10**9 + 7),\n                        (t[v][1] * t[u][1] + t[v][0] * t[u][1] * (not colors[v])\n                                           + t[v][1] * t[u][0] * (not colors[u])) % (10**9 + 7)\n                    )\n\n                \n    dfs(0)\n\n    print(t[0][1])\n\n\n\n    \n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "MOD = 10**9 + 7\n\n\ndef topo_compute(childrens, colors, parents):\n    def f(node, connected_to_black):\n        if colors[node] == 1 and connected_to_black:\n            return 0\n\n        children = childrens[node]\n        if colors[node] == 1 or connected_to_black:\n            ret = 1\n\n            for child in children:\n                x = dp_conn[child] + dp_not_conn[child]\n                x %= MOD\n\n                ret *= x\n                ret %= MOD\n\n            return ret\n\n        s = 1\n        prefix_prod = []\n        for child in children:\n            x = dp_conn[child] + dp_not_conn[child]\n            x %= MOD\n            s *= x\n            s %= MOD\n            prefix_prod.append(s)\n\n        s = 1\n        suffix_prod = []\n        for child in reversed(children):\n            x = dp_conn[child] + dp_not_conn[child]\n            x %= MOD\n            s *= x\n            s %= MOD\n            suffix_prod.append(s)\n\n        suffix_prod = list(reversed(suffix_prod))\n\n        ret = 0\n\n        for i in range(len(children)):\n            pre = prefix_prod[i - 1] if i > 0 else 1\n            suf = suffix_prod[i + 1] if i + 1 < len(suffix_prod) else 1\n\n            x = pre * suf\n            x %= MOD\n\n            x *= dp_not_conn[children[i]]\n            x %= MOD\n\n            ret += x\n            ret %= MOD\n\n        return ret\n\n    ########################\n\n    num_childrens = [len(x) for x in childrens]\n    N = len(childrens)\n    dp_conn = [None] * N\n    dp_not_conn = [None] * N\n\n    stack = [i for i in range(N) if num_childrens[i] == 0]\n\n    while True:\n        node = stack.pop()\n\n        dp_conn[node] = f(node, True)\n        dp_not_conn[node] = f(node, False)\n\n        parent = parents[node]\n\n        if parent is None:\n            return dp_not_conn[node]\n\n        num_childrens[parent] -= 1\n        if num_childrens[parent] == 0:\n            stack.append(parent)\n\n\ndef build_tree(d, root):\n    childrens = [None] * len(d)\n    parents = [None] * len(d)\n\n    stack = [(root, None)]\n\n    while len(stack) > 0:\n        node, parent = stack.pop()\n\n        children = [x for x in d[node] if x != parent]\n\n        childrens[node] = children\n        parents[node] = parent\n\n        for child in children:\n            stack.append((child, node))\n\n    return childrens, parents\n\n\ndef main():\n    import sys\n\n    n = sys.stdin.readline()\n    n = int(n)\n\n    p = list(map(int, sys.stdin.readline().split(\" \")))\n\n    d = {}\n\n    for i in range(n):\n        d[i] = []\n\n    for i, b in enumerate(p):\n        a = i + 1\n        d[a].append(b)\n        d[b].append(a)\n\n    colors = list(map(int, sys.stdin.readline().split(\" \")))\n    colors = list(colors)\n\n    for i in range(n - 1):\n        line = sys.stdin.readline()\n        if line == \"\":\n            break\n\n        a, b = list(map(int, line.split(\" \")))\n\n        d[a].append(b)\n        d[b].append(a)\n\n    childrens, parents = build_tree(d, 0)\n\n    ans = topo_compute(childrens, colors, parents)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n = len(grid)\n        m = len(grid[0])\n        \n        F = [i for i in range(m * n)]\n        def find(x):\n            if x == F[x]:\n                return x\n            else:\n                F[x] = find(F[x])\n                return F[x]\n            \n        for i in range(n):\n            for j in range(m):\n                if i > 0 and grid[i-1][j] == grid[i][j]:\n                    f1 = find((i-1)*m+j)\n                    f2 = find((i)*m+j)\n                    if f1 == f2:\n                        return True\n                    F[f1] = f2\n                if j > 0 and grid[i][j-1] == grid[i][j]:\n                    f1 = find((i)*m+j-1)\n                    f2 = find((i)*m+j)\n                    if f1 == f2:\n                        return True\n                    F[f1] = f2\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        m = len(grid)\n        if m==1: return False\n        n = len(grid[0])\n        dirs = [(0,-1),(-1,0),(0,1),(1,0)]\n        def dfs(prev, curr):\n            if curr in visited: return True\n            visited.add(curr)\n            for dirn in dirs:\n                nei = (dirn[0]+curr[0], dirn[1]+curr[1])\n                if 0<=nei[0]<m and 0<=nei[1]<n and nei != prev and grid[nei[0]][nei[1]] == grid[curr[0]][curr[1]]:\n                    if dfs(curr, nei): return True\n            return False\n        for i in range(m):\n            for j in range(n):\n                if (i,j) not in visited:\n                    if dfs(None, (i,j)): return True\n        return False\n", "\n\nimport collections\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[parent2] > ranks[parent1]:\n                    parents[parent1] = parent2\n                else:\n                    parents[parent2] = parent1\n                    if ranks[parent1] == ranks[parent2]:\n                        ranks[parent1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[parent2] > ranks[parent1]:\n                    parents[parent1] = parent2\n                else:\n                    parents[parent2] = parent1\n                    if ranks[parent1] == ranks[parent2]:\n                        ranks[parent1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False", "class UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.size = [1]*n\n    def find(self,A):\n        root=A\n        while root!=self.parent[root]:\n            root=self.parent[root]\n            \n        while A!=root:\n            old_parent=self.parent[A]\n            self.parent[A]=root\n            A=old_parent\n        return(root)\n    \n    def union(self,A,B):\n        root_A = self.find(A)\n        root_B = self.find(B)\n        if root_A==root_B:\n            return(False)\n        \n        if self.size[root_A]<self.size[root_B]:\n            self.parent[root_A]=root_B\n            self.size[root_B]+=self.size[root_A]\n        else:\n            self.parent[root_B]=root_A\n            self.size[root_A]+=self.size[root_B]\n            \n        return(True)\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        R = len(grid) ; C = len(grid[0])\n        dsu = UnionFind(R*C)\n        def encode(r,c):\n            return(r*C+c)\n        \n        for r in range(R):\n            for c in range(C):\n                if c+1<C and grid[r][c]==grid[r][c+1]:\n                    if not dsu.union( encode(r,c),encode(r,c+1) ):\n                        return(True)\n                if r+1<R and grid[r][c]==grid[r+1][c]:\n                    if not dsu.union( encode(r,c),encode(r+1,c) ):\n                        return(True)\n                    \n        return(False)\n    \n                    \n            \n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        vis = [[False for i in range(len(grid[0]))] for j in range(len(grid))] \n        \n        dirx = [0,0,-1,+1]\n        diry = [-1,+1, 0,0]\n        \n        def check(i,j):\n            if 0<= i < len(grid) and 0<= j< len(grid[0]): return True\n            return False\n        \n        def dfs(r,c,pr,pc, no):\n            flag = False\n            vis[r][c] = True\n            for i in range(4):\n                nr,nc = r+dirx[i], c+diry[i]\n                if not (nr == pr and nc == pc) and check(nr,nc) and grid[nr][nc] == grid[r][c]:\n                    if vis[nr][nc] : print((nr,nc)); return True\n                    if dfs(nr,nc,r,c,no+1): return True\n            return False\n                    \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if not vis[i][j]:\n                    if(dfs(i,j, -1,-1, 0)):\n                        return True\n        return False\n", "class UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)] # i is the parent of i , initially\n        self.size = [1 for i in range(n)]\n    \n    def find(self,A):\n        root = A\n        while root!=self.parent[root]:\n            root = self.parent[root]\n            \n        while A!=root:\n            old_parent = self.parent[A]\n            self.parent[A]=root\n            A = old_parent    \n        return(root)\n    \n    def union(self,A,B):\n        root_A = self.find(A)\n        root_B = self.find(B)\n        \n        if root_A == root_B:\n            return(False)\n        if self.size[root_A] < self.size[root_B]:\n            self.parent[A]= root_B\n            self.size[root_B]+=self.size[root_A]\n        else:\n            self.parent[B]= root_A\n            self.size[root_A]+=self.size[root_B]\n        return(True)\n            \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        R = len(grid) ; C = len(grid[0])\n        dsu = UnionFind(R*C)\n        def encode(r,c):\n            return(r*C+c)\n        \n        for r in range(R):\n            for c in range(C):\n                if c+1<C and grid[r][c]==grid[r][c+1]:\n                    if not dsu.union( encode(r,c),encode(r,c+1) ):\n                        return(True)\n                if r+1<R and grid[r][c]==grid[r+1][c]:\n                    if not dsu.union( encode(r,c),encode(r+1,c) ):\n                        return(True)\n                    \n        return(False)\n    \n                    \n            \n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        disjoint = {}\n        def find(x):\n            while disjoint[x] != x:\n                x = disjoint[x]\n            return disjoint[x]\n        def union(x, y):\n            disjoint[find(y)] = find(x)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                disjoint[(i, j)] = (i, j)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                for di, dj in [[0, 1], [1, 0]]:\n                    if 0 <= i + di < len(grid) and 0 <= j + dj < len(grid[0]) and grid[i][j] == grid[i + di][j + dj]:\n                        if find((i, j)) == find((i + di, j + dj)):\n                            return True\n                        union((i, j), (i + di, j + dj))\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        m = len(grid)\n        n = len(grid[0])\n        if m == 1 or n == 1:\n            return False\n       \n        dir = [(0,-1), (-1,0), (0,1), (1,0)]\n        \n        def dfs(prev, curr):\n            if (curr in visited):\n                return True\n            visited.add(curr)\n            for d in dir:\n                x = (curr[0] + d[0], curr[1] + d[1])\n                if (x != prev and 0<= x[0] < m and 0<=x[1]<n and grid[x[0]][x[1]] == grid[curr[0]][curr[1]]):\n                    if dfs(curr, x):\n                        return True\n            else:\n                return False\n            \n            \n            \n            \n            \n        for i in range(m):\n            for j in range(n):\n                node = (i,j)\n                if node not in visited:\n                    if dfs(None, node) == True:\n                        return True\n        return False\n                \n                \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        m = len(grid)\n        if m==1: return False\n        n = len(grid[0])\n        dirs = [(0,-1),(-1,0),(0,1),(1,0)]\n        def dfs(prev, curr):\n            if curr in visited: return True\n            visited.add(curr)\n            for dirn in dirs:\n                nei = (dirn[0]+curr[0], dirn[1]+curr[1])\n                if 0<=nei[0]<m and 0<=nei[1]<n and nei != prev and grid[nei[0]][nei[1]] == grid[curr[0]][curr[1]]:\n                    if dfs(curr, nei): return True\n            return False\n        for i in range(m):\n            for j in range(n):\n                if (i,j) not in visited:\n                    if dfs(None, (i,j)): return True\n        return False\n        \n#     for each cell, if not in visited, do a DFS\n    \n#     DFS (prev->(x,y), curx, cury, visited):\n#         if cur is visited: return True\n#         for each cell, \n#             if nei is not prev and nei == cur: \n#                 if (DFS on the nei) return True\n#         return False\n", "class UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n    def find(self,A):\n        root = A\n        while root !=self.parent[root]:\n            root = self.parent[root]\n        \n        while A!=root:\n            old_parent = self.parent[A]\n            self.parent[A]=root\n            A=old_parent\n        return(root)\n    def union(self,A,B):\n        root_A= self.find(A)\n        root_B= self.find(B)\n        if root_A==root_B:\n            return(False)\n        \n        if self.size[root_A]<self.size[root_B]:\n            self.parent[root_A] = root_B\n            self.size[root_B]+=self.size[root_A]\n        else:\n            self.parent[root_B]=root_A\n            self.size[root_A]+=self.size[root_B]\n        return(True)\n            \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        R = len(grid) ; C = len(grid[0])\n        dsu = UnionFind(R*C)\n        def encode(r,c):\n            return(r*C+c)\n        \n        for r in range(R):\n            for c in range(C):\n                if c+1<C and grid[r][c]==grid[r][c+1]:\n                    if not dsu.union( encode(r,c),encode(r,c+1) ):\n                        return(True)\n                if r+1<R and grid[r][c]==grid[r+1][c]:\n                    if not dsu.union( encode(r,c),encode(r+1,c) ):\n                        return(True)\n                    \n        return(False)\n    \n                    \n            \n        \n", "class UnionFind:\n    def __init__(self, row_size, col_size):\n        self.roots = [[(i, j) for j in range(col_size)]\n                      for i in range(row_size)]\n\n    def get_rank(self, node):\n        return -node[0] * len(self.roots[0]) - node[1]\n\n    def union(self, node1, node2):\n        root1 = self.find(node1)\n        root2 = self.find(node2)\n        if root1 != root2:\n            if self.get_rank(root1) > self.get_rank(root2):\n                self.roots[root2[0]][root2[1]] = root1\n            else:\n                self.roots[root1[0]][root1[1]] = root2\n\n    def find(self, node):\n        if self.roots[node[0]][node[1]] != node:\n            self.roots[node[0]][node[1]] = self.find(self.roots[node[0]][node[1]])\n        return self.roots[node[0]][node[1]]\n\n\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        row_size, col_size = len(grid), len(grid[0])\n        uf = UnionFind(row_size, col_size)\n        for i in range(row_size):\n            for j in range(col_size):\n                for (x, y) in [(i - 1, j), (i, j - 1)]:\n                    if x >= 0 and y >= 0 and grid[x][y] == grid[i][j]:\n                        if uf.find((i, j)) == uf.find((x, y)):\n                            return True\n                        uf.union((i, j), (x, y))\n        return False\n                        \n            \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        parent = {}\n\n        def find(u):\n            parent.setdefault(u, u)\n            if parent[u] != u:\n                parent[u] = find(parent[u])\n            return parent[u]\n\n        def union(u, v):\n            x, y = find(u), find(v)\n            if x != y:\n                parent[y] = x \n            return x != y\n\n        m, n = len(grid), len(grid[0])\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if i + 1 < m and grid[i][j] == grid[i + 1][j]:\n                    if not union((i, j), (i + 1, j)):\n                        return True\n                if j + 1 < n and grid[i][j] == grid[i][j + 1]:\n                    if not union((i, j), (i, j + 1)):\n                        return True \n        return False", "class DSU:\n    def __init__(self,m,n):\n        self.par = {(i,j):(i,j) for i in range(m) for j in range(n)}\n    \n    def find(self,x):\n        if self.par[x]!=x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self,x,y):\n        xp,yp = self.find(x),self.find(y)\n        if xp == yp:\n            return False\n        self.par[xp] = yp\n        return True\n\ndirs = [(0,1),(1,0)]\nclass Solution:\n    def containsCycle(self, grid):\n        R,C = len(grid),len(grid[0])\n        dsu = DSU(R,C)        \n        for r in range(R):\n            for c in range(C):\n                for x,y in dirs:\n                    nr,nc = r+x,c+y\n                    if 0<=nr<R and 0<=nc<C and grid[r][c] == grid[nr][nc]:\n                        if dsu.union((r,c),(nr,nc)) == False:\n                            return True\n        return False\n                \n                \n                        \n", "class Solution:\n    x = [0,0,-1,1]\n    y = [-1,1,0,0]\n    def findCycle(self,grid,i,j,li,lj,path,vis):\n        \n        if vis[i][j]:\n            return False\n        \n        for k in range(4):\n            nx = i + Solution.x[k]\n            ny = j + Solution.y[k]\n            if nx == li and ny == lj:\n                continue\n            if nx < 0 or ny < 0 or nx >= len(grid) or ny >= len(grid[0]):\n                continue\n            if (nx,ny) in path and path[(nx,ny)] == 1:\n                vis[i][j] = 1\n                return True\n            if grid[nx][ny] == grid[i][j]:\n                path[(nx,ny)] = 1\n                isfind = self.findCycle(grid,nx,ny,i,j,path,vis)\n                if isfind:\n                    vis[i][j] = 1\n                    return True\n                path[(nx,ny)] = 0\n        vis[i][j] = 1\n        return False\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        h = len(grid)\n        if h == 0:\n            return False\n        w = len(grid[0])\n        vis = [ [0 for i in range(w)] for j in range(h)]\n        path = {}\n        for i in range(h):\n            for j in range(w):\n                if not vis[i][j]:\n                    isfind = self.findCycle(grid,i,j,-1,-1,path,vis)\n                    if isfind:\n                        return True\n        return False", "class DSU:\n  def __init__(self):\n    # representer\n    self.reps = {}\n  def add(self, x):\n    self.reps[x] = x\n  def find(self, x):\n    if not x == self.reps[x]:\n      self.reps[x] = self.find(self.reps[x])\n    return self.reps[x]\n  def union(self, x, y):\n    self.reps[self.find(y)] = self.find(x)\n\nclass Solution:\n  def containsCycle(self, grid: List[List[str]]) -> bool:\n    # detect cycle, often dfs, but use dsu in this problem due to its special graph structure.\n    m, n = len(grid), len(grid[0])\n    dsu = DSU()\n    for i in range(m):\n      for j in range(n):\n        dsu.add((i, j))\n        if i - 1 >= 0 and j - 1 >= 0 and grid[i - 1][j] == grid[i][j - 1] == grid[i][j] and dsu.find((i - 1, j)) == dsu.find((i, j - 1)):\n          return True\n        if i - 1 >= 0 and grid[i - 1][j] == grid[i][j]:\n          dsu.union((i - 1, j), (i, j))\n        if j - 1 >= 0 and grid[i][j - 1] == grid[i][j]:\n          dsu.union((i, j - 1), (i, j))\n    return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = {}\n        \n        def dfs(i, j, k):\n            c = i * n + j\n            if c in visited:\n                return k - visited[c] >= 4\n            visited[c] = k\n            a = grid[i][j]\n            for di, dj in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                ii = i + di\n                jj =j + dj\n                if not (0 <= ii < m and 0 <= jj < n) or grid[ii][jj] != a:\n                    continue\n                if dfs(ii, jj, k + 1):\n                    return True\n            return False\n                \n                \n        for i in range(m):\n            for j in range(n):\n                c = i * n + j\n                if c in visited:\n                    continue\n                if dfs(i, j, 0):\n                    return True\n        return False\n", "import collections\n\nclass Solution:\n    def containsCycle(self, grid):\n        if not grid:\n            return False\n        \n        M = len(grid)\n        N = len(grid[0])\n        parent = {}\n        \n        def find(x, y):\n            if parent[(x, y)] != (x, y):\n                parent[(x, y)] = find(parent[(x, y)][0], parent[(x, y)][1])\n            return parent[(x, y)]\n            \n        def union(x1, y1, x2, y2):\n            p1 = find(x1, y1)\n            p2 = find(x2, y2)\n            \n            if p1 == p2:\n                return True\n            \n            parent[p1] = p2\n            return False\n        \n        def move(x, y, grid):\n            for i, j in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\n                if 0 <= i < M and 0 <= j < N:\n                    yield i, j\n        \n        seen = set()\n        for i in range(M):\n            for j in range(N):\n                seen.add((i, j))\n                for x1, y1 in move(i, j, grid):\n                    if (i, j) not in parent:\n                        parent[(i, j)] = (i, j)\n                    if (x1, y1) not in parent:\n                        parent[(x1, y1)] = (x1, y1)\n\n                    if grid[i][j] == grid[x1][y1] and (x1, y1) not in seen:\n                        if union(i, j, x1, y1):\n                            return True\n        return False\n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        \n        \n        # public solution ... 3384 ms ... 0 % ... 216 MB ... 0 %\n        #  time: O(n*m)\n        # space: O(n*m)\n        \n        def dfs(pi, pj, i, j):\n            visited[i][j] = True\n            for ni, nj in [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]:\n                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == grid[i][j]:\n                    if visited[ni][nj]:\n                        if (ni,nj) != (pi,pj):\n                            return True\n                    else:\n                        if dfs(i, j, ni, nj):\n                            return True\n            return False\n        \n        n, m = len(grid), len(grid[0])\n        if n < 2 or m < 2:\n            return False\n        visited = [[False]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if not visited[i][j] and dfs(-1, -1, i, j):\n                    return True\n        return False\n        \n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [[0,-1], [0,1], [-1,0], [1,0]]\n        visited = [[False]*n for i in range(m)]\n\n        def dfs(y, x, py, px, c):\n\n            visited[y][x] = True\n            for d in dirs:\n                ny, nx = y+d[0], x+d[1]\n                if ny < 0 or ny >= m or nx < 0 or nx >= n or (ny == py and nx == px) or grid[ny][nx] != c:\n                    continue\n                if visited[ny][nx] or dfs(ny, nx, y, x, c):\n                    return True\n            \n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j] and dfs(i, j, -1, -1, grid[i][j]):\n                    return True\n\n        return False", "sys.setrecursionlimit(10000000)\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        m = len(grid)\n        if m==1: return False\n        n = len(grid[0])\n        dirs = [(0,-1),(-1,0),(0,1),(1,0)]\n        def dfs(prev, curr):\n            if curr in visited: return True\n            visited.add(curr)\n            for dirn in dirs:\n                nei = (dirn[0]+curr[0], dirn[1]+curr[1])\n                if 0<=nei[0]<m and 0<=nei[1]<n and nei != prev and grid[nei[0]][nei[1]] == grid[curr[0]][curr[1]]:\n                    if dfs(curr, nei): return True\n            return False\n        for i in range(m):\n            for j in range(n):\n                if (i,j) not in visited:\n                    if dfs(None, (i,j)): return True\n        return False", "#from collections import deque\n#from random import randint\n\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        h, w = len(grid), len(grid[0])\n        \n        #------------------------------------------\n        \n        def in_range(x, y):\n            \n            return (0 <= x < w) and (0 <= y < h) \n        \n        #------------------------------------------\n        \n        def four_neighbors(x, y):\n            \n            for dx, dy in {(+1, 0), (-1, 0), (0, +1), (0, -1)}:\n                \n                next_x, next_y = x + dx, y + dy\n                \n                if in_range(next_x, next_y):\n                    yield (next_x, next_y)\n            \n\n        \n        #------------------------------------------\n        \n        def dfs(x, y, prev_x, prev_y, grid):\n            \n            if grid[y][x] == dfs.cur_symbol:\n                # this grid has a cycle with current symbol\n                return True\n            \n            \n            # mark to uppercase letter as visited\n            grid[y][x] = dfs.cur_symbol\n            \n            \n            for next_x, next_y in four_neighbors(x, y):\n                \n                if (next_x, next_y) == (prev_x, prev_y):\n                    # avoid backward visit\n                    continue\n                    \n                elif grid[next_y][next_x].upper() != dfs.cur_symbol:\n                    # different symbol\n                    continue\n                    \n                if dfs(next_x, next_y, x, y, grid): return True\n            \n            #print(f'terminate with {x} {y} {grid[y][x]}')\n            return False\n            \n        \n        #------------------------------------------\n        \n        failed_symbol = set()\n        \n        for y in range(h):\n            for x in range(w):\n                \n                dfs.cur_symbol = grid[y][x]\n                \n                if dfs.cur_symbol in failed_symbol:\n                    # skip search on failed symbol\n                    continue\n                \n                dfs.cur_symbol = grid[y][x].upper()\n                \n                if dfs(x,y,-1,-1, grid):\n                    return True\n                else:\n                    failed_symbol.add( dfs.cur_symbol )\n        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = [[0] * n for i in range(m)]\n        \n        def dfs(i, j, k):\n            if visited[i][j]:\n                return k - visited[i][j] >= 4\n            visited[i][j] = k\n            a = grid[i][j]\n            for di, dj in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                ii = i + di\n                jj =j + dj\n                if not (0 <= ii < m and 0 <= jj < n) or grid[ii][jj] != a:\n                    continue\n                if dfs(ii, jj, k + 1):\n                    return True\n            return False\n                \n                \n        for i in range(m):\n            for j in range(n):\n                if visited[i][j]:\n                    continue\n                if dfs(i, j, 1):\n                    return True\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        m, n = len(grid), len(grid[0])\n        root = {}\n        size = {}\n        \n        def find(t):\n            if root[t] != t:\n                root[t] = find(root[t])\n            return root[t]\n        \n        for i in range(m):\n            for j in range(n):\n                root[(i,j)] = (i,j)\n                size[(i,j)] = 1\n                \n                if 0<=i-1 and grid[i-1][j] == grid[i][j]:\n                    top = (i-1, j)\n                    rt = find(top)\n                    root[(i,j)] = rt\n                    size[rt] += 1\n                if 0<=j-1 and grid[i][j-1] == grid[i][j]:\n                    left = (i, j-1)\n                    rl = find(left)\n                    root[(i,j)] = rl\n                    size[rl] += 1\n                if 0<=i-1 and 0<=j-1 and grid[i-1][j] == grid[i][j] and grid[i][j-1] == grid[i][j]:\n                    rl = root[(i,j-1)]\n                    rt = root[(i-1,j)]\n                    if rl == rt:\n                        return True\n                    if size[rt] >= size[rl]:\n                        root[rl] = rt\n                        size[rt] += size[rl]\n                    else:\n                        root[rt] = rl\n                        size[rl] += size[rt]\n        #print(root)\n        return False\n                    \n                    \n                        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        for x, row in enumerate(grid):\n            for y,num in enumerate(row):\n                if self.containsCycleInComponent(grid, (x,y)):\n                    return True\n        \n        return False\n    \n    def adjCells(self, x, y):\n        yield x-1, y\n        yield x+1, y\n        yield x, y-1\n        yield x, y+1\n    \n    def containsCycleInComponent(self, grid, startPoint):\n        # startPoint is the position (x,y)\n        startX,startY = startPoint\n        value = grid[startX][startY]\n        if value is None:\n            return False\n        \n        checkedPoints = set()\n        uncheckedPoints = [startPoint]\n        \n        while uncheckedPoints:\n            point = uncheckedPoints.pop()\n            checkedPoints.add(point)\n            \n            x,y = point\n            grid[x][y] = None\n            adjKnownPoints = 0\n            for nextPoint in self.adjCells(x,y):\n                if nextPoint in checkedPoints or self.hasValue(grid, nextPoint, value):\n                    if nextPoint not in checkedPoints:\n                        uncheckedPoints.append(nextPoint)\n                    else:\n                        adjKnownPoints += 1\n            if adjKnownPoints > 1:\n                return True\n            \n        return False\n            \n    \n    def hasValue(self, grid, point, value):\n        x, y = point\n        return 0<=x<len(grid) and 0<=y<len(grid[x]) and grid[x][y]==value\n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        R = len(grid)\n        C = len(grid[0])\n        N = R * C\n        parents = [i for i in range(N)]\n        \n        def ufind(a):\n            if parents[a] == a:\n                return a\n            parents[a] = ufind(parents[a])\n            return parents[a]\n        \n        def uunion(a, b):\n            aa = ufind(a)\n            bb = ufind(b)\n            if aa == bb:\n                return False\n            parents[bb] = aa\n            return True\n        \n        def decode(row, col):\n            return row * C + col\n        \n        for row in range(R):\n            for col in range(C):\n                if row + 1 < R and grid[row + 1][col] == grid[row][col]:\n                    if not uunion(decode(row, col), decode(row + 1, col)):\n                        return True\n                if col + 1 < C and grid[row][col + 1] == grid[row][col]:\n                    if not uunion(decode(row, col), decode(row, col + 1)):\n                        return True\n                    \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = [[0] * n for i in range(m)]\n        \n        def dfs(i, j, pi, pj):\n            if visited[i][j]:\n                return True\n            visited[i][j] = 1\n            a = grid[i][j]\n            for di, dj in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                ii = i + di\n                jj =j + dj\n                if not (0 <= ii < m and 0 <= jj < n) or grid[ii][jj] != a or (ii == pi and jj == pj):\n                    continue\n                if dfs(ii, jj, i, j):\n                    return True\n            return False\n                \n                \n        for i in range(m):\n            for j in range(n):\n                if visited[i][j]:\n                    continue\n                if dfs(i, j, -1, -1):\n                    return True\n        return False\n", "class Solution:\n    def containsCycle(self, g: List[List[str]]) -> bool:            \n        def find(u):\n            if u != UF[u]: u = find(UF[u])\n            return UF[u]        \n        UF, m, n = {}, len(g), len(g[0])                \n        for i in range(m):\n            for j in range(n):\n                u = (i, j); UF.setdefault(u, u)\n                for x, y in [(i, j-1), (i-1, j)]:                    \n                    if not (0 <= x < m and 0 <= y < n): continue                    \n                    if g[x][y] == g[i][j]:                      \n                        v = (x, y)\n                        UF.setdefault(v, v)\n                        pu, pv = find(u), find(v)                            \n                        if pu != pv: UF[pv] = pu\n                        else: return True\n        return False                ", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        \n        \n        # public solution ... \n        \n        def dfs(pi, pj, i, j):\n            visited[i][j] = True\n            for ni, nj in [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]:\n                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == grid[i][j]:\n                    if visited[ni][nj]:\n                        if (ni,nj) != (pi,pj):\n                            return True\n                    else:\n                        if dfs(i, j, ni, nj):\n                            return True\n            return False\n        \n        n, m = len(grid), len(grid[0])\n        if n < 2 or m < 2:\n            return False\n        visited = [[False]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if not visited[i][j] and dfs(-1, -1, i, j):\n                    return True\n        return False\n        \n        \n", "import collections\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[parent1] > ranks[parent2]:\n                    parents[parent2] = parent1\n                else:\n                    parents[parent1] = parent2\n                    if ranks[parent1] == ranks[parent2]:\n                        ranks[parent1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False\n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\nclass Solution:\n    def containsCycle(self, A: List[List[str]]) -> bool:\n        R, C = len(A), len(A[0])\n        def encode(r, c):\n            return r * C + c\n        \n        dsu = DSU(R * C)\n        for r in range(R):\n            for c in range(C):\n                if c + 1 < C and A[r][c] == A[r][c+1]:\n                    if not dsu.union(encode(r, c), encode(r, c + 1)):\n                        return True\n                if r + 1 < R and A[r][c] == A[r+1][c]:\n                    if not dsu.union(encode(r, c), encode(r + 1, c)):\n                        return True\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[parent2] > ranks[parent1]:\n                    parents[parent1] = parent2\n                else:\n                    parents[parent2] = parent1\n                    if ranks[parent1] == ranks[parent2]:\n                        ranks[parent1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         def dfs(node, parent):\n#             if node in visited: return True\n#             visited.add(node)\n#             nx,ny = node\n#             childs = [(cx,cy) for cx,cy in [[nx+1,ny],[nx-1, ny],[nx,ny+1],[nx,ny-1]] \n#                       if 0 <= cx < m and 0 <= cy < n \n#                       and grid[cx][cy] == grid[nx][ny] and (cx,cy) != parent]\n#             for x in childs:\n#                 if dfs(x, node): return True \n#             return False  \n    \n#         m, n = len(grid), len(grid[0])\n#         visited = set()\n#         for i in range(m):\n#             for j in range(n):\n#                 if (i,j) in visited: continue \n#                 if dfs((i,j), None): return True\n#         return False \n", "class Solution:\n    def containsCycle(self, grid) -> bool:\n        if not grid or not grid[0]: return False\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited=[[False] * len(grid[i]) for i in range(len(grid))]\n                \n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if not visited[i][j]:\n                    stack = [(i, j, 0, 0)]\n                    visited[i][j] = True\n                    symbol = grid[i][j]\n                    \n                    while stack:\n                        row, col, prev_row, prev_col = stack.pop()\n\n                        for direction in directions:\n                            nr = row + direction[0]\n                            nc = col + direction[1]\n\n                            if nr == prev_row and nc == prev_col:\n                                continue\n                            if len(grid) > nr >= 0 and len(grid[nr]) > nc >= 0 and grid[nr][nc] == symbol:\n                                if visited[nr][nc]:\n                                    return True\n                                else:\n                                    visited[nr][nc] = True\n                                    stack.append((nr, nc, row, col))\n                      \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        for x, row in enumerate(grid):\n            for y,num in enumerate(row):\n                if self.containsCycleInComponent(grid, (x,y)):\n                    return True\n                else:\n                    self.eraseComponent(grid, (x,y))\n        \n        return False\n    \n    def eraseComponent(self, grid, startPoint):\n        # startPoint is the position (x,y)\n        startX,startY = startPoint\n        value = grid[startX][startY]\n        if value is None:\n            return\n        \n        pointsToErase = [startPoint]\n        while pointsToErase:\n            point = pointsToErase.pop()\n            x,y = point\n            grid[x][y] = None\n            for nextPoint in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)]:\n                if self.hasValue(grid, nextPoint, value):\n                    pointsToErase.append(nextPoint)\n    \n    def containsCycleInComponent(self, grid, startPoint):\n        # startPoint is the position (x,y)\n        startX,startY = startPoint\n        value = grid[startX][startY]\n        if value is None:\n            return False\n        \n        checkedPoints = set()\n        uncheckedPoints = [startPoint]\n        componentPointsCount = 0\n        componentEdgesDoubleCount = 0\n        \n        while uncheckedPoints:\n            point = uncheckedPoints.pop()\n            componentPointsCount += 1\n            checkedPoints.add(point)\n            \n            x,y = point\n            for nextPoint in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)]:\n                if self.hasValue(grid, nextPoint, value):\n                    componentEdgesDoubleCount += 1\n                    if nextPoint not in checkedPoints:\n                        uncheckedPoints.append(nextPoint)\n        \n            \n        return componentPointsCount <= componentEdgesDoubleCount // 2\n                    \n            \n    \n    def hasValue(self, grid, point, value):\n        x, y = point\n        return 0<=x<len(grid) and 0<=y<len(grid[x]) and grid[x][y]==value\n        \n", "import sys\ninput = sys.stdin.readline\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        r = x\n        \n        while not self.par[r]<0:\n            r = self.par[r]\n        \n        t = x\n        \n        while t!=r:\n            tmp = t\n            t = self.par[t]\n            self.par[tmp] = r\n        \n        return r\n    \n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        \n        if rx==ry:\n            return\n        \n        if self.rank[rx]<=self.rank[ry]:\n            self.par[ry] += self.par[rx]\n            self.par[rx] = ry\n            \n            if self.rank[rx]==self.rank[ry]:\n                self.rank[ry] += 1\n        else:\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n = len(grid)\n        m = len(grid[0])\n        uf = Unionfind(n*m)\n        \n        for i in range(n):\n            for j in range(m):\n                if i+1<n and grid[i][j]==grid[i+1][j]:\n                    if uf.is_same(m*i+j, m*(i+1)+j):\n                        return True\n                    \n                    uf.unite(m*i+j, m*(i+1)+j)\n                \n                if j+1<m and grid[i][j]==grid[i][j+1]:\n                    if uf.is_same(m*i+j, m*i+j+1):\n                        return True\n                    \n                    uf.unite(m*i+j, m*i+j+1)\n        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        visited = set()\n        \n        def dfs(i, j, pi, pj):\n            k = i * n + j\n            if k in visited:\n                return True\n            visited.add(k)\n            a = grid[i][j]\n            for di, dj in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                ii = i + di\n                jj =j + dj\n                if not (0 <= ii < m and 0 <= jj < n) or grid[ii][jj] != a or (ii == pi and jj == pj):\n                    continue\n                if dfs(ii, jj, i, j):\n                    return True\n            return False\n                \n                \n        for i in range(m):\n            for j in range(n):\n                if (i * n + j) in visited:\n                    continue\n                if dfs(i, j, -1, -1):\n                    return True\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(coords):\n            if coords != parents[coords]:\n                parents[coords] = find(parents[coords])\n            return parents[coords]\n        \n        def union(point_one, point_two):\n            parx, pary = find(point_one), find(point_two)\n            if parx != pary:\n                if rank[parx] > rank[pary]:\n                    parents[pary] = parx\n                else:\n                    parents[parx] = pary\n                    if rank[parx] == rank[pary]:\n                        rank[parx] += 1\n\n        if not grid or not grid[0]:\n            return False\n        m, n = len(grid), len(grid[0])\n        \n        parents = {(i, j): (i, j) for i in range(m) for j in range(n)}\n        rank = collections.Counter()\n        \n        for i in range(m):\n            for j in range(n):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == grid[i][j] and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i-1, j), (i, j-1):\n                    if r >= 0 and c >= 0 and grid[r][c] == grid[i][j]:\n                        union((r, c), (i, j))\n                        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        def dfs(i, j, pre_i, pre_j):\n            visited.add((i, j))\n            for x, y in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                if 0 <= x + i < len(grid) and 0 <= y + j < len(grid[0]) and grid[i][j] == grid[i + x][j + y] and (i + x != pre_i or j + y != pre_j):\n                    if (i + x, j + y) in visited or dfs(i + x, j + y, i, j):\n                        return True\n            return False\n    \n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if (i, j) not in visited:\n                    if dfs(i, j, -1, -1):\n                        return True\n        return False", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        \n    def find(self, i):\n        if self.parents[i] == i:\n            return i\n        self.parents[i] = self.find(self.parents[i])\n        return self.parents[i]\n    def unite(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        self.parents[pb] = pa\n        return\n    def same(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        return pa==pb\n    \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        dx = [ 1, 0]\n        dy = [ 0, 1]\n        N = len(grid)\n        M = len(grid[0])\n        ALL = N*M\n        # print(\\\"size\\\", N, M, ALL)\n        tree = UnionFind(ALL)\n        for i in range(N):\n            for j in range(M):\n                for k in range(2):\n                    if 0<=i +dx[k] <N and 0<= j+dy[k]<M:\n                        if grid[i][j] == grid[i+dx[k]][j+dy[k]]:\n                            # print(i, j, k)\n                            # print((i+dx[k])*M+j+dy[k])\n                            if tree.same(i*M+j, (i+dx[k])*M+j+dy[k]):\n                                return True\n                            tree.unite(i*M+j, (i+dx[k])*M+j+dy[k])\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        '''\n        [[\\\"a\\\",\\\"b\\\",\\\"b\\\"],\n         [\\\"b\\\",\\\"z\\\",\\\"b\\\"],\n         [\\\"b\\\",\\\"b\\\",\\\"a\\\"]]\n        \n        [[\\\"a\\\",\\\"b\\\",\\\"b\\\"],\n         [\\\"b\\\",\\\"b\\\",\\\"b\\\"],\n         [\\\"b\\\",\\\"b\\\",\\\"a\\\"]]\n        \n        dfs(pre_i,pre_j, i,j):-> bool: hasLoop\n        '''\n        label = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        \n        def dfs(pre_i,pre_j, i,j):\n            if label[i][j] == 1: # is being visited\n                return True\n            if label[i][j] == -1:# visited\n                return False\n            label[i][j] = 1\n            for ii, jj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n                if 0<=ii<len(grid) and 0<=jj<len(grid[ii]):\n                    if grid[ii][jj] == grid[i][j] and (not (ii==pre_i and jj==pre_j)):\n                        if dfs(i,j,ii,jj): return True\n            label[i][j] = -1\n            return False\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if dfs(-1,-1, i,j): return True\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n        def dfs(m, n, pm, pn):\n            if m < 0 or m >= len(grid) or n < 0 or n >= len(grid[m]):\n                return False\n            if grid[m][n].lower() != grid[pm][pn].lower():\n                return False\n            if grid[m][n].isupper():\n                return True\n            grid[m][n] = grid[m][n].upper()\n            for dir in dirs:\n                if m + dir[0] != pm or n + dir[1] != pn:\n                    if (dfs(m + dir[0], n + dir[1], m, n)):\n                        return True\n            return False\n        for m in range(len(grid)):\n            for n in range(len(grid[m])):\n                if grid[m][n].islower():\n                    if dfs(m, n, m, n):\n                        return True\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        if not grid:\n            return(False)\n        visited = [[0 for i in grid[0]] for j in grid]\n \n        def ExplorePath(rowIn,colIn, value, previous):\n            current = [rowIn, colIn] \n            #print(rowIn,colIn)\n            if visited[rowIn][colIn]==1:\n                return(True)\n                #print('hi')\n    \n            else:\n                \n                visited [rowIn][colIn] =1\n                \n                #print(temp1[0][0])\n                output = False\n                if rowIn<len(grid)-1 and previous != [rowIn+1,colIn] and grid[rowIn+1][colIn]==value:\n                    output = ExplorePath(rowIn+1,colIn,value, current)\n                if colIn<len(grid[0])-1 and previous != [rowIn,colIn+1] and grid[rowIn][colIn+1]==value:\n                    output = output or ExplorePath(rowIn,colIn+1, value, current) \n                if rowIn>0 and previous != [rowIn-1,colIn] and grid[rowIn-1][colIn]==value:\n                    output = output or ExplorePath(rowIn-1,colIn,  value, current)\n                if colIn>0 and previous != [rowIn,colIn-1] and grid[rowIn][colIn-1]==value:\n                    output = output or ExplorePath(rowIn,colIn-1, value, current) \n                    \n            return(output)\n            \n\n        \n        for rowIn in range(len(grid)-1):\n            for colIn in range(len(grid[0])-1):\n                if grid[rowIn+1][colIn]== grid[rowIn][colIn]:\n                    if grid[rowIn+1][colIn+1]== grid[rowIn][colIn]:\n                        if grid[rowIn][colIn+1]== grid[rowIn][colIn]:\n                            #print(rowIn,colIn)\n                            return(True) \n        for rowIn in range(len(grid)):\n            for colIn in range(len(grid[0])):\n                \n                if visited[rowIn][colIn]==0:\n                    #print(grid[rowIn][colIn])\n                    tempVisited = []\n                    #print(tempVisited[0][0])\n                    length = 0\n                    if (ExplorePath(rowIn,colIn, grid[rowIn][colIn], [rowIn,colIn])):\n                        return(True)\n                    \n        return(False)\n    \n    def containsCycle2(self, grid: List[List[str]]) -> bool:\n        if not grid:\n            return(False)\n        visited = [[0 for i in grid[0]] for j in grid]\n \n        def ExplorePath(rowIn,colIn, length, tempV, value, previous):\n            current = [rowIn, colIn] \n            #print(rowIn,colIn)\n            if grid[rowIn][colIn] != value:\n                return(False)\n            if [rowIn,colIn] in tempV:\n                #print('hi')\n                if length >= 3:\n                    return(True)\n                else:\n                    return(False)\n            else:\n                tempV.append([rowIn,colIn])\n                visited [rowIn][colIn] =1\n                temp1, temp2, temp3, temp4 = deepcopy(tempV), deepcopy(tempV), deepcopy(tempV), deepcopy(tempV)\n                #print(temp1[0][0])\n                output = False\n                if rowIn<len(grid)-1 and previous != [rowIn+1,colIn]:\n                    output = ExplorePath(rowIn+1,colIn, length+1, temp1, value, current)\n                if colIn<len(grid[0])-1 and previous != [rowIn,colIn+1]:\n                    output = output or ExplorePath(rowIn,colIn+1, length+1, temp2, value, current) \n                if rowIn>0 and previous != [rowIn-1,colIn]:\n                    output = output or ExplorePath(rowIn-1,colIn, length+1, temp3, value, current)\n                if colIn>0 and previous != [rowIn,colIn-1]:\n                    output = output or ExplorePath(rowIn,colIn-1, length+1, temp4, value, current) \n                    \n            return(output)\n            \n\n        \n        for rowIn in range(len(grid)-1):\n            for colIn in range(len(grid[0])-1):\n                if grid[rowIn+1][colIn]== grid[rowIn][colIn]:\n                    if grid[rowIn+1][colIn+1]== grid[rowIn][colIn]:\n                        if grid[rowIn][colIn+1]== grid[rowIn][colIn]:\n                            #print(rowIn,colIn)\n                            return(True) \n        for rowIn in range(len(grid)):\n            for colIn in range(len(grid[0])):\n                \n                if visited[rowIn][colIn]==0:\n                    #print(grid[rowIn][colIn])\n                    tempVisited = []\n                    #print(tempVisited[0][0])\n                    length = 0\n                    if (ExplorePath(rowIn,colIn, length, tempVisited, grid[rowIn][colIn], [rowIn,colIn])):\n                        return(True)\n                    \n        return(False)\n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\nclass Solution:\n    def containsCycle(self, A):\n        R, C = len(A), len(A[0])\n        def encode(r, c):\n            return r * C + c\n        \n        dsu = DSU(R * C)\n        for r in range(R):\n            for c in range(C):\n                if c + 1 < C and A[r][c] == A[r][c+1]:\n                    if not dsu.union(encode(r, c), encode(r, c + 1)):\n                        if dsu.size(encode(r, c)) >= 4:\n                            return True\n                if r + 1 < R and A[r][c] == A[r+1][c]:\n                    if not dsu.union(encode(r, c), encode(r + 1, c)):\n                        if dsu.size(encode(r, c)) >= 4:\n                            return True\n        return False\n\n# bac\n# cac\n# ddc\n# bcc\n", "class UF:\n    def __init__(self, m, n):    \n        self.p = {(i, j): (i, j) for i in range(m) for j in range(n)}\n        \n    def union(self, ti, tj):\n        pi, pj = self.find(*ti), self.find(*tj)\n        if pi != pj:\n            self.p[pj] = pi\n            return False\n        return True\n            \n    def find(self, i, j):\n        if (i, j) != self.p[i,j]:  \n            self.p[i,j] = self.find(*self.p[i,j])\n        return self.p[i,j]    \n                \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        # \u5982\u4f55\u5b9a\u4e49cycle\uff1a\u540c\u4e00\u4e2a\u70b9\u7684\u4e24\u4e2a\u4e0d\u540c\u65b9\u5411\u7684path\uff0c\u6700\u7ec8\u6c47\u805a\u5230\u975e\u81ea\u8eab\u7684\u540c\u4e00\u70b9\n        m, n = len(grid), len(grid[0])\n        uf = UF(m, n)\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    uf.union((i-1, j), (i, j))\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    if uf.union((i, j-1), (i, j)): return True\n        return False            ", "class Solution:\n    def containsCycle(self, grid) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[parent2] > ranks[parent1]:\n                    parents[parent1] = parent2\n                else:\n                    parents[parent2] = parent1\n                    if ranks[parent1] == ranks[parent2]:\n                        ranks[parent1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if r >= 0 and c >= 0 and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        M, N = len(grid), len(grid[0])\n        dp = [[set() for j in range(N)] for i in range(M)]\n        dv = [(0,-1),(-1,0)]\n        for i in range(M):\n            for j in range(N): \n                for x,y in dv:\n                    if 0 <= i+x < M and 0 <= j+y < N:\n                        if grid[i][j] == grid[i+x][j+y]:\n                            if not dp[i+x][j+y]:\n                                dp[i][j].add(((i+x,j+y),1))\n                            else:\n                                for entry in dp[i+x][j+y]:\n                                    prnt, dist = entry\n                                    if (prnt, dist+1) in dp[i][j] and dist+1 >= 2:\n                                        return True\n                                    dp[i][j].add((prnt, dist+1))\n                                    #print(i,j, prnt, dist, dp[i][j])\n        return False\n\n    \n", "class Solution:\n    def containsCycle(self, grid) -> bool:\n        if not grid or not grid[0]: return False\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited=[[False] * len(grid[i]) for i in range(len(grid))]\n\n        def dfs(grid, symbol, row, col, prev_row, prev_col):\n            nonlocal directions\n            nonlocal visited\n            \n            visited[row][col] = True\n            \n            for direction in directions:\n                nr = row + direction[0]\n                nc = col + direction[1]\n\n                if nr == prev_row and nc == prev_col:\n                    continue\n                if len(grid) > nr >= 0 and len(grid[nr]) > nc >= 0:\n                    if grid[nr][nc] == symbol and (visited[nr][nc] or dfs(grid, symbol, nr, nc, row , col)):\n                        return True            \n            return False\n                \n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if not visited[i][j]:\n                    if dfs(grid, grid[i][j], i, j, 0, 0):\n                        return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n\n        class roots():\n            def __init__(self, val):\n                self.val = val\n                self.par = None\n            def root(self):\n                if self.par == None: return self.val\n                return self.par.root()\n\n        chains = {}\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and grid[i-1][j] == grid[i][j]:\n                    chains[(i,j)]=roots((i,j))\n                    chains[(i,j)].par = chains[(i-1,j)]\n\n                if j > 0 and grid[i][j-1] == grid[i][j]:\n                    if (i,j) in chains:\n                        if chains[(i,j)].root() == chains[(i,j-1)].root(): return True\n                        else: chains[chains[(i,j-1)].root()].par = chains[(i,j)]\n                    else:\n                        chains[(i,j)]=roots((i,j))\n                        chains[(i,j)].par = chains[(i,j-1)]\n                if (i,j) not in chains:\n                    chains[(i,j)]=roots((i,j))\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n,m = len(grid),len(grid[0])\n        root = {(i,j):(i,j) for i in range(n) for j in range(m)}   \n        rank = collections.defaultdict(int)\n        def find(x):\n            if root[x]==x:\n                return x\n            root[x] == find(root[x])\n            return root[x]\n        \n        def union(a,b):\n            ra,rb = find(a),find(b)\n            if ra!=rb:\n                if rank[rb]>rank[ra]:\n                    root[ra] = rb\n                else:\n                    root[rb] = ra\n                    if rank[ra]==rank[rb]:\n                        rank[ra]+=1\n                \n                \n        \n        for i in range(n):\n            for j in range(m):\n                #print(i,j)\n                val = grid[i][j]\n                # parent: i-1,j and i,j-1\n                if i>0 and j>0 and grid[i-1][j] == grid[i][j-1]==val and find((i-1,j))==find((i,j-1)):\n                    #print(find((i-1,j)),find((i,j-1)))\n                    return True\n                for ni,nj in [(i-1,j),(i,j-1)]:\n                    if 0<=ni<n and 0<=nj<m and grid[ni][nj]==val:\n                        #print((i,j),(ni,nj),val,grid[ni][nj])\n                        union((i,j),(ni,nj))\n                        #print(find((ni,nj)))\n                \n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        row , col = len(grid), len(grid[0])\n        \n        \n        track = {}\n        dx, dy = [0,0,-1,1], [-1,1,0,0]\n        def check(i,j, parent):\n            \n            # print('outside',i,j)\n            \n            for k in range(4):\n                xx, yy = dx[k] + i, dy[k] + j\n                if xx in range(row) and yy in range(col) and parent!=(xx,yy) and grid[i][j]== grid[xx][yy] and grid[i][j]!='checked':\n                    if (xx,yy) in track:\n                        return True\n                    track[(xx,yy)] = True\n                    if check(xx,yy,(i,j)): return True\n                    grid[xx][yy]='checked'\n            return False\n            \n            \n            \n            \n            \n        for i in range(row):\n            for j in range(col):\n                track[(i,j)] = True\n                if check(i,j,None): return True\n                grid[i][j] = 'checked'\n        return False", "class Solution:\n    def find(self, n1):\n        if n1 == self.par[n1[0]][n1[1]]:\n            return n1\n        else:\n            return self.find(self.par[n1[0]][n1[1]])\n        \n    def union(self, n1, n2):\n        p1 = self.find(n1)\n        p2 = self.find(n2)\n        self.par[p1[0]][p1[1]] = p2\n        \n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n_row, n_col = len(grid), len(grid[0])\n        self.par = []\n        for r in range(n_row):\n            self.par.append([(r,c) for c in range(n_col)])\n            \n        for r in range(n_row):\n            for c in range(n_col):\n                # check right\n                if r+1 < n_row and grid[r][c]==grid[r+1][c]:\n                    if self.find((r,c)) == self.find((r+1,c)):\n                        return True\n                    self.union((r,c), (r+1,c))\n                # check down\n                if c+1 < n_col and grid[r][c]==grid[r][c+1]:\n                    if self.find((r,c)) == self.find((r,c+1)):\n                        return True\n                    self.union((r,c), (r,c+1))\n            \n       \n        return False\n            \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                parents[parent2] = parent1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False\n    \n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(coords):\n            if coords != parents[coords]:\n                parents[coords] = find(parents[coords])\n            return parents[coords]\n        \n        def union(point_one, point_two):\n            parx, pary = find(point_one), find(point_two)\n            if parx != pary:\n                if rank[parx] > rank[pary]:\n                    parents[pary] = parx\n                else:\n                    parents[parx] = pary\n                    if rank[parx] == rank[pary]:\n                        rank[parx] += 1\n                # elif rank[parx] < rank[pary]:\n                #     parents[parx] = pary\n                # else:\n                #     parents[parx] = pary\n                #     rank[pary] += 1\n\n        if not grid or not grid[0]:\n            return False\n        m, n = len(grid), len(grid[0])\n        \n        parents = {(i, j): (i, j) for i in range(m) for j in range(n)}\n        rank = collections.Counter()\n        \n        for i in range(m):\n            for j in range(n):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == grid[i][j] and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i-1, j), (i, j-1):\n                    if r >= 0 and c >= 0 and grid[r][c] == grid[i][j]:\n                        union((r, c), (i, j))\n                        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        \n        \n        # public solution ... 3020 ms ... 0 % ... 215 MB ... 0 %\n        #  time: O(n*m)\n        # space: O(n*m)\n        \n        def dfs(pi, pj, i, j):\n            visited[i][j] = True\n            for ni, nj in [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]:\n                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == grid[i][j]:\n                    if visited[ni][nj]:\n                        if (ni,nj) != (pi,pj):\n                            return True\n                    else:\n                        if dfs(i, j, ni, nj):\n                            return True\n            return False\n        \n        n, m = len(grid), len(grid[0])\n        if n < 2 or m < 2:\n            return False\n        visited = [[False]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if not visited[i][j] and dfs(-1, -1, i, j):\n                    return True\n        return False\n        \n        \n", "class Solution:\n    \n    def detect_cycle(self, grid, visited, rec_stack, i, j, M, N, prev):\n        visited[i][j] = True\n        rec_stack.append([i, j])\n        for k, l in [[i, j-1], [i-1, j], [i, j+1], [i+1, j]]:\n            if k >= 0 and l >= 0 and k < M and l < N and grid[i][j] == grid[k][l] and [k, l] != prev:\n                if not visited[k][l]:\n                    if self.detect_cycle(grid, visited, rec_stack, k, l, M, N, [i, j]) == True:\n                        return True\n                elif [k, l] in rec_stack:\n                    return True\n        rec_stack.pop()\n        \n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        M, N = len(grid), len(grid[0])\n        visited = [[False]*N for _ in range(M)]\n        rec_stack = []\n        for i in range(M):\n            for j in range(N):\n                if not visited[i][j]:\n                    if self.detect_cycle(grid, visited, rec_stack, i, j, M, N, [i, j]) == True:\n                        return True\n        return False\n", "\n\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n,m = len(grid),len(grid[0])\n        root = {(i,j):(i,j) for i in range(n) for j in range(m)}   \n\n        def find(x):\n            i,j = x\n            if root[i,j]==x:\n                return x\n            root[i,j] = find(root[i,j])\n            return root[i,j]\n        \n        def union(a,b):\n            ra,rb = find(a),find(b)\n            if ra!=rb:\n                root[rb] = ra\n                return False\n            return True\n        \n        for i in range(n):\n            for j in range(m):\n                val = grid[i][j]\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    union((i-1, j), (i, j))\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    if union((i, j-1), (i, j)): \n                        return True                \n        return False\n", "from collections import defaultdict\nclass Solution:\n    DELTA = [(0,-1),(0,1),(-1,0),(1,0)]\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def dfsCycle(grid, R, C, p_r, p_c, r, c, visited, grp, grp_num):\n            if (r, c) in grp[grp_num]:\n                return True\n            \n            # check 4 directions\n            visited.add((r,c))\n            grp[grp_num].add((r,c))\n            result = False\n            for d in Solution.DELTA:\n                n_r = r + d[0]\n                n_c = c + d[1]\n                if 0 <= n_r < R and 0 <= n_c < C and not (p_r == n_r and p_c == n_c) and grid[n_r][n_c] == grid[r][c]:\n                    result |= dfsCycle(grid, R, C, r, c, n_r, n_c, visited, grp, grp_num)\n                    if result:\n                        break\n                    \n            return result\n            \n        R = len(grid)\n        C = len(grid[0])\n        visited = set()\n        grp_num = 0\n        grp = defaultdict(set)\n        for r in range(R):\n            for c in range(C):\n                if (r,c) not in visited:\n                    grp_num += 1\n                    if dfsCycle(grid, R, C, r, c, r, c, visited, grp, grp_num):\n                        return True\n                    \n        return False", "\n\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n,m = len(grid),len(grid[0])\n        root = {(i,j):(i,j) for i in range(n) for j in range(m)}\n        \n        def find(x):\n            if root[x]==x:\n                return x\n            root[x] = find(root[x])\n            return root[x]\n        \n        def union(a,b):\n            ra,rb = find(a),find(b)\n            if ra!=rb:\n                root[ra] = rb\n                return False\n            return True\n        \n        for i in range(n):\n            for j in range(m):\n                val = grid[i][j]\n                for ni,nj in [(i+1,j),(i,j+1)]:\n                    if ni<n and nj<m and grid[ni][nj]==val:\n                        t = union((ni,nj),(i,j))\n                        if t:\n                            return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def ff(grid,i,j,n,c):\n            grid[i][j]=c\n            c+=1\n            if i>0 :\n                    #print(grid)\n                    if type(grid[i-1][j])==int and c-grid[i-1][j]>2 and c//250000==grid[i-1][j]//250000:\n                        return True\n                    elif type(grid[i-1][j])==str and grid[i-1][j]==n:\n                        \n                        #print(grid)\n                        if ff(grid,i-1,j,n,c):\n                            return True\n            if j<len(grid[i])-1: \n                    #print(grid)\n                    if type(grid[i][j+1])==int and c-grid[i][j+1]>2 and c//250000==grid[i][j+1]//250000:\n                        return True\n                    elif type(grid[i][j+1])==str and grid[i][j+1]==n:\n                        \n                        if ff(grid,i,j+1,n,c):\n                            return True\n            if j>0:\n                    #print(grid,n)\n                    if type(grid[i][j-1])==int and c-grid[i][j-1]>2 and c//250000==grid[i][j-1]//250000:\n                        return True\n                    elif type(grid[i][j-1])==str and grid[i][j-1]==n:\n                        \n                        if ff(grid,i,j-1,n,c):\n                            return True\n            if i<len(grid)-1  :\n                    #print(grid,n)\n                    \n                    if type(grid[i+1][j])==int and c-grid[i+1][j]>2 and c//250000==grid[i+1][j]//250000:\n                        return True\n                    elif type(grid[i+1][j])==str and grid[i+1][j]==n:\n                        #print(grid)\n                        \n                        if ff(grid,i+1,j,n,c):\n                            return True\n            return False\n        cc=0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if type(grid[i][j])!=int:\n                    cc+=1\n                    if ff(grid,i,j,grid[i][j],cc*250000):\n                        return True\n        return False\n", "import collections\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[parent2] > ranks[parent1]:\n                    parents[parent1] = parent2\n                else:\n                    parents[parent2] = parent1\n                    if ranks[parent1] == ranks[parent2]:\n                        ranks[parent1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False", "class UnionFindSet:\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.ranks = [1] * n\n        \n    def find(self, u):\n        if u != self.parents[u]:\n            self.parents[u] = self.find(self.parents[u])\n        return self.parents[u]\n    \n    def union(self, u, v):\n        pu, pv = self.find(u), self.find(v)\n        if pu == pv:\n            return False\n        if self.ranks[pu] > self.ranks[pv]:\n            self.parents[pv] = pu\n        elif self.ranks[pv] > self.ranks[pu]:\n            self.parents[pu] = pv\n        else:\n            self.parents[pu] = pv\n            self.ranks[pv] += 1\n        return True\n    \n    \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n        uf = UnionFindSet(m*n)\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and grid[i][j] == grid[i-1][j] and not uf.union(i*n+j, (i-1)*n+j):\n                    return True\n                if j > 0 and grid[i][j] == grid[i][j-1] and not uf.union(i*n+j, i*n+j-1):\n                    return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        parents = {}\n        def find(p):\n            if p not in parents:\n                parents[p] = p\n            if parents[p] != p:\n                parents[p] = find(parents[p])\n            return parents[p]\n        def is_connected(p, q):\n            return find(p) == find(q)\n        def union(p, q):\n            i, j = find(p), find(q)\n            parents[j] = i\n            \n        R, C = len(grid), len(grid[0])\n        \n        for r in range(R):\n            for c in range(C):\n                for nr, nc in [r+1, c], [r, c+1]:\n                    if nr < R and nc < C and grid[r][c] == grid[nr][nc]:\n                        if is_connected((r, c), (nr, nc)):\n                            return True\n                        union((r, c), (nr, nc))\n        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        visited = {}\n        \n        def dfs(x, y, u, v):\n            \n            if not 0 <= x < len(grid): return False\n            \n            if not 0 <= y < len(grid[x]): return False\n            \n            if grid[x][y] != grid[u][v]: return False \n            \n            if (x,y) in visited:\n                return True\n            \n            visited[(x,y)] = True\n            \n            if (x, y+1) != (u,v) and dfs(x, y+1,x,y):\n                return True\n                \n            if (x-1, y) != (u,v) and dfs(x-1, y,x,y):\n                return True\n            \n            if (x+1, y) != (u,v) and dfs(x+1, y, x, y):\n                return True\n                \n            if (x, y-1) != (u,v) and dfs(x, y-1, x, y):\n                return True\n            \n            return False\n            \n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if (i,j) not in visited and dfs(i,j,i,j):\n                    return True\n                \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        if not grid: return False\n        m, n = len(grid), len(grid[0])\n        \n        nbrs = [(-1,0), (0,1),(0,-1),(1, 0)]\n        def isValid(x,y):\n            return x>=0 and x<m and y>=0 and y<n\n        \n        def hasCycle(x, y, vis, parentX, parentY):\n            vis.add((x,y))\n            for nbr in nbrs:\n                newX, newY = x + nbr[0], y+nbr[1]\n                if isValid(newX, newY) and grid[newX][newY] == grid[x][y] and not(parentX == newX and parentY == newY):\n                    if (newX, newY) in vis:\n                        return True\n                    else:\n                        if hasCycle(newX, newY, vis,x,y):\n                            return True\n            return False\n        vis = set()\n        for i in range(m):\n            for j in range(n):\n                if (i,j) not in vis:\n                    ans = hasCycle(i,j, vis, -1, -1)\n                if ans: return True\n        \n        return False\n", "class Solution:\n    def containsCycle(self, grid) -> bool:\n        if not grid or not grid[0]: return False\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n                \n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if '#' not in grid[i][j]:\n                    stack = [(i, j, 0, 0)]\n                    symbol = grid[i][j]\n                    grid[i][j] = '#' + symbol\n                    \n                    while stack:\n                        row, col, prev_row, prev_col = stack.pop()\n\n                        for direction in directions:\n                            nr = row + direction[0]\n                            nc = col + direction[1]\n\n                            if nr == prev_row and nc == prev_col:\n                                continue\n                            if len(grid) > nr >= 0 and len(grid[nr]) > nc >= 0 and symbol in grid[nr][nc]:\n                                if '#' in grid[nr][nc]:\n                                    return True\n                                else:\n                                    grid[nr][nc] = '#' + symbol\n                                    stack.append((nr, nc, row, col))\n                      \n        return False", "class Solution:\n    def find(self, n):\n        if n == self.par[n[0]][n[1]]:\n            return n\n        else:\n            p = self.find(self.par[n[0]][n[1]])\n            # path compression\n            self.par[n[0]][n[1]] = p\n            return p\n        \n    def union(self, n1, n2):\n        p1 = self.find(n1)\n        p2 = self.find(n2)\n        \n        # union by rank\n        if self.rank[p1[0]][p1[1]] > self.rank[p2[0]][p2[1]]:\n            self.par[p2[0]][p2[1]] = p1\n        else:\n            self.par[p1[0]][p1[1]] = p2\n            self.rank[p1[0]][p1[1]] += 1\n        \n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n_row, n_col = len(grid), len(grid[0])\n\n        self.rank = [[1]*n_col for _ in range(n_row)]\n        \n        self.par = []\n        for r in range(n_row):\n            self.par.append([(r,c) for c in range(n_col)])\n            \n        for r in range(n_row):\n            for c in range(n_col):\n                # check right\n                if r+1 < n_row and grid[r][c]==grid[r+1][c]:\n                    if self.find((r,c)) == self.find((r+1,c)):\n                        return True\n                    self.union((r,c), (r+1,c))\n                # check down\n                if c+1 < n_col and grid[r][c]==grid[r][c+1]:\n                    if self.find((r,c)) == self.find((r,c+1)):\n                        return True\n                    self.union((r,c), (r,c+1))\n            \n       \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        dsu = DSU()\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if i != 0 and grid[i - 1][j] == grid[i][j]:\n                    dsu.union((i - 1, j), (i, j))\n                if grid[i][j - 1] == grid[i][j]:\n                    if dsu.find((i, j - 1)) == dsu.find((i, j)):\n                        return True\n                    dsu.union((i, j - 1), (i, j))\n        return False\n        \nclass DSU:\n    def __init__(self):\n        self.father = {}\n    \n    def find(self, a):\n        self.father.setdefault(a, a)\n        if a != self.father[a]:\n            self.father[a] = self.find(self.father[a])\n        return self.father[a]\n    \n    def union(self, a, b):\n        _a = self.find(a)\n        _b = self.find(b)\n        if _a != _b:\n            self.father[_a] = self.father[_b]", "class Solution:\n    def isCycle(self, grid, r, c, visited, pr, pc):\n        nrow, ncol = len(grid), len(grid[0])\n        direcs = [(0,1),(0,-1),(-1,0),(1,0)]\n        visited.add((r, c))\n        for dr, dc in direcs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < nrow and 0 <= nc < ncol and grid[nr][nc] == grid[r][c] and not (pr==nr and pc==nc):\n                if (nr, nc) in visited:\n                    return True\n                if self.isCycle(grid, nr, nc, visited, r, c):\n                    return True\n                \n        return False\n            \n        \n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        nrow, ncol = len(grid), len(grid[0])\n        visited = set()\n        for r in range(nrow):\n            for c in range(ncol):\n                if (r, c) in visited:\n                    continue\n                if self.isCycle(grid, r, c, visited, -1, -1):\n                    return True\n        return False", "class UF:\n    def __init__(self, m, n):    \n        self.p = {(i, j): (i, j) for i in range(m) for j in range(n)}\n        \n    def union(self, ti, tj):\n        pi, pj = self.find(*ti), self.find(*tj)\n        if pi != pj:\n            self.p[pj] = pi\n            return False\n        return True\n            \n    def find(self, i, j):\n        if (i, j) != self.p[i,j]:  \n            self.p[i,j] = self.find(*self.p[i,j])\n        return self.p[i,j]    \n                \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        # \u5982\u4f55\u5b9a\u4e49cycle\uff1a\u540c\u4e00\u4e2a\u70b9\u7684\u4e24\u4e2a\u4e0d\u540c\u65b9\u5411\u7684path\uff0c\u6700\u7ec8\u6c47\u805a\u5230\u975e\u81ea\u8eab\u7684\u540c\u4e00\u70b9\n        m, n = len(grid), len(grid[0])\n        uf = UF(m, n)\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    if uf.union(tuple([i-1, j]), tuple([i, j])): return True\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    if uf.union(tuple([i, j-1]), tuple([i, j])): return True\n        return False            ", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\nclass Solution:\n    def containsCycle(self, A):\n        R, C = len(A), len(A[0])\n        def encode(r, c):\n            return r * C + c\n        \n        dsu = DSU(R * C)\n        for r in range(R):\n            for c in range(C):\n                if c + 1 < C and A[r][c] == A[r][c+1]:\n                    if not dsu.union(encode(r, c), encode(r, c + 1)):\n                        return True\n                if r + 1 < R and A[r][c] == A[r+1][c]:\n                    if not dsu.union(encode(r, c), encode(r + 1, c)):\n                        return True\n        return False\n", "import collections\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def find(pos):\n            if parents[pos] != pos:\n                parents[pos] = find(parents[pos])\n            return parents[pos]\n\n        def union(pos1, pos2):\n            parent1, parent2 = find(pos1), find(pos2)\n            if parent1 != parent2:\n                if ranks[pos1] > ranks[pos2]:\n                    parents[pos2] = pos1\n                else:\n                    parents[pos1] = pos2\n                    if ranks[pos1] == ranks[pos2]:\n                        ranks[pos1] += 1\n\n        rows, cols = len(grid), len(grid[0])\n        parents = {(i, j): (i, j) for i in range(rows) for j in range(cols)}\n        ranks = collections.Counter()\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if i > 0 and j > 0 and grid[i-1][j] == grid[i][j-1] == letter and find((i-1, j)) == find((i, j-1)):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r < rows and 0 <= c < cols and grid[r][c] == letter:\n                        union((i, j), (r, c))\n        return False\n", "class Solution:\n    def rec(self,i,j,char,prev):\n        if self.grid[i][j] != char:\n            return False\n        if self.matrix[i][j]:\n            return True\n        else:\n            self.matrix[i][j] = True\n            \n        l = (i,j-1)\n        r = (i,j+1)\n        u = (i-1,j)\n        d = (i+1,j)\n        \n        for c in [l,r,u,d]:\n            if 0<=c[0]<self.row and 0<=c[1]<self.col and c != prev:\n                if self.rec(c[0],c[1], char, (i,j)):\n                    return True\n        return False\n            \n\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        self.grid = grid\n        self.row = len(grid)\n        self.col = len(grid[0])\n\n        self.matrix = [ [False for i in range(self.col)] for j in range(self.row)  ]\n\n        for i in range(self.row):\n            for j in range(self.col):\n                if not self.matrix[i][j]:\n                    if self.rec(i,j, grid[i][j],0):\n                        return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dsu = DUS()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if j != 0 and grid[i][j] == grid[i][j - 1]:\n                    dsu.union((i, j), (i, j - 1))\n                    \n                if i != 0 and grid[i][j] == grid[i - 1][j]:\n                    if dsu.find((i,j)) == dsu.find((i - 1, j)):\n                        return True\n                    dsu.union((i, j), (i - 1, j))\n        return False\n        \nclass DUS:\n    def __init__(self):\n        self.father = {}\n    \n    def find(self, a):\n        self.father.setdefault(a, a)\n        if a != self.father[a]:\n            self.father[a] = self.find(self.father[a])\n        return self.father[a]\n    \n    def union(self, a, b):\n        _a = self.find(a)\n        _b = self.find(b)\n        if _a != _b:\n            self.father[_a] = _b", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        uf = {(i, j): (i, j) for i in range(m) for j in range(n)}\n        \n        def find(pos):\n            if pos != uf[pos]:\n                uf[pos] = find(uf[pos])\n            return uf[pos]\n        \n        def union(pos1, pos2):\n            root1 = find(pos1)\n            root2 = find(pos2)\n            if root1 != root2:\n                uf[root1] = root2\n            \n        for i in range(m):\n            for j in range(n):\n                if i > 0 and j > 0 and find((i - 1, j)) == find((i, j - 1)) and grid[i][j] == grid[i-1][j] == grid[i][j-1]:\n                    return True\n                if i > 0 and grid[i][j] == grid[i-1][j]:\n                    union((i, j), (i - 1, j))\n                if j > 0 and grid[i][j] == grid[i][j-1]:\n                    union((i, j), (i, j - 1))\n        return False", "class UnionFind:\n    def __init__(self, m: int, n: int):\n        self.rank = collections.Counter()\n        self.parent = {(i, j): (i, j) for i in range(m) for j in range(n)}\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.rank[py] > self.rank[px]:\n            px, py = py, px\n        if self.rank[py] == self.rank[px]:\n            self.rank[px] += 1\n        self.parent[py] = px\n        \nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        rows, cols = len(grid), len(grid[0])\n        uf = UnionFind(rows, cols)\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if (i > 0 and j > 0 and\n                        grid[i - 1][j] == grid[i][j - 1] == letter and\n                        uf.find((i - 1, j)) == uf.find((i, j - 1))):\n                    return True\n                for r, c in (i - 1, j), (i, j - 1):\n                    if 0 <= r and 0 <= c and grid[r][c] == letter:\n                        uf.union((i, j), (r, c))\n        return False\n\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        # dfs, remember parent\n        self.m, self.n = len(grid), len(grid[0])\n        nei = [(0, 1), (0, -1),(-1, 0), (1, 0)]\n        memo = set()\n        def dfs(i, j, p):\n            # print(i, j, p, memo)\n            if (i, j) in memo: return True\n            memo.add((i, j))\n            for ne in nei:\n                x, y = i + ne[0], j + ne[1]\n                if 0 <= x < self.m and 0 <= y < self.n and (x, y) != p and grid[i][j] == grid[x][y]:\n                    if dfs(x, y, (i, j)): return True\n            return False\n            \n        for i in range(self.m):\n            for j in range(self.n):\n                if (i, j) not in memo:\n                    if dfs(i, j, (-1, -1)): return True\n        return False\n", "from collections import defaultdict\nclass Solution:\n    DELTA = [(0,-1),(0,1),(-1,0),(1,0)]\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        def dfsCycle(grid, R, C, p_r, p_c, r, c, visited, grp, grp_num):\n            if (r, c) in grp[grp_num]:\n                return True\n            # print('p_r=', p_r, 'p_c=', p_c)\n            \n            # check 4 directions\n            visited.add((r,c))\n            grp[grp_num].add((r,c))\n            result = False\n            for d in Solution.DELTA:\n                n_r = r + d[0]\n                n_c = c + d[1]\n                # print('n_r=', n_r, 'n_c=', n_c)\n                if 0 <= n_r < R and 0 <= n_c < C and not (p_r == n_r and p_c == n_c) and grid[n_r][n_c] == grid[r][c]:\n                    result |= dfsCycle(grid, R, C, r, c, n_r, n_c, visited, grp, grp_num)\n                    if result:\n                        break\n                    \n            return result\n            \n        R = len(grid)\n        C = len(grid[0])\n        visited = set()\n        grp_num = 0\n        grp = defaultdict(set)\n        for r in range(R):\n            for c in range(C):\n                if (r,c) not in visited:\n                    grp_num += 1\n                    # print('r=', r, 'c=', c, grid[r][c])\n                    if dfsCycle(grid, R, C, r, c, r, c, visited, grp, grp_num):\n                        return True\n                    # print(grid)\n                    \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        h, w = len(grid), len(grid[0])\n        \n        #------------------------------------------\n        \n        def in_range(x, y):\n            \n            return (0 <= x < w) and (0 <= y < h) \n        \n        #------------------------------------------\n        \n        def four_neighbors(x, y):\n            \n            for dx, dy in {(+1, 0), (-1, 0), (0, +1), (0, -1)}:\n                \n                next_x, next_y = x + dx, y + dy\n                \n                if in_range(next_x, next_y):\n                    yield (next_x, next_y)\n            \n        #------------------------------------------\n        \n        def dfs(x, y, prev_x, prev_y, grid):\n            \n            if grid[y][x] == dfs.cur_symbol:\n                # this grid has a cycle with current symbol\n                return True\n            \n            \n            # mark to uppercase letter as visited\n            grid[y][x] = dfs.cur_symbol\n            \n            \n            for next_x, next_y in four_neighbors(x, y):\n                \n                if (next_x, next_y) == (prev_x, prev_y):\n                    # avoid backward visit\n                    continue\n                    \n                elif grid[next_y][next_x].upper() != dfs.cur_symbol:\n                    # different symbol\n                    continue\n                    \n                if dfs(next_x, next_y, x, y, grid): return True\n            \n            #print(f'terminate with {x} {y} {grid[y][x]}')\n            return False\n            \n        \n        #------------------------------------------\n        \n        failed_symbol = set()\n        \n        for y in range(h):\n        #for y in reversed(range(h)):\n            for x in range(w):\n            #for x in reversed(range(w)):\n                \n                dfs.cur_symbol = grid[y][x]\n                \n                if dfs.cur_symbol in failed_symbol:\n                    # skip search on failed symbol\n                    continue\n                \n                dfs.cur_symbol = grid[y][x].upper()\n                \n                if dfs(x,y,-1,-1, grid):\n                    return True\n                \n                else:\n                    failed_symbol.add( dfs.cur_symbol )\n        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        ve = collections.defaultdict(set)\n        for i, row in enumerate(grid):\n            for j, val in enumerate(row):\n                ve[val].add((i,j))\n                \n        # print(ve)\n        dxy = [(-1,0), (1,0), (0,-1), (0,1)]\n                \n        def check(k):\n            visiting = set()\n            visited = set()\n            v = ve[k]\n            def dfs(curr, prev):\n                if curr in visiting: return True\n                visiting.add(curr)\n                x,y = curr\n                for dx, dy in dxy:\n                    x2,y2 = x+dx, y+dy\n                    if 0 <= x2 < m and 0 <= y2 < n and (x2,y2) != prev and (x2,y2) in v:\n                        # print((x2,y2), curr)\n                        if dfs((x2,y2), curr): return True\n                visiting.remove(curr)\n                visited.add(curr)\n                return False\n                \n            for a in v:\n                if a not in visited:\n                    if dfs(a, None): return True\n            return False\n        \n        for k in ve:\n            if check(k): return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        visited = set()\n        def dfs(x, y, parent):\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n            c = grid[x][y]\n            for dx, dy in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                nx, ny = dx + x, dy + y\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == c and [nx, ny] != parent:\n                    if dfs(nx, ny, [x, y]):\n                        return True\n            return False\n        \n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                if (x, y) not in visited and dfs(x, y, [-1, -1]):\n                    return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        n, m = len(grid), len(grid[0])\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(i, j, pre_i, pre_j):\n            visited.add((i, j))\n            for x, y in directions:\n                if 0 <= x + i < n and 0 <= y + j < m and grid[i][j] == grid[i + x][j + y] and (i + x != pre_i or j + y != pre_j):\n                    if (i + x, j + y) in visited or dfs(i + x, j + y, i, j):\n                        return True\n            return False\n    \n        for i in range(n):\n            for j in range(m):\n                if (i, j) not in visited:\n                    if dfs(i, j, -1, -1):\n                        return True\n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n = len(grid)\n        m = len(grid[0])\n        \n        node_par = {}\n        for i in range(n):\n            for j in range(m):\n                node_par[(i, j)] = (i, j)\n                \n        dxdys = ((0, 1), (0, -1), (1, 0), (-1, 0))\n        \n        def find_par(par):\n            path = []\n            while node_par[par] != par:\n                path.append(par)\n                par = node_par[par]\n            for tmp in path:\n                node_par[tmp] = par\n            return par\n        \n        for x in range(n):\n            for y in range(m):\n                if (x + y) % 2:\n                    continue\n                    \n                for dx, dy in dxdys:\n                    x_new, y_new = x + dx, y + dy\n                    if not (0 <= x_new < n and 0 <= y_new < m) or grid[x_new][y_new] != grid[x][y]:\n                        continue\n                    \n                    curr_par = find_par((x, y))\n                    new_par = find_par((x_new, y_new))\n                    if curr_par == new_par:\n                        return True\n                    node_par[curr_par] = new_par\n                    \n        return False\n", "from collections import deque\nclass Solution:\n    \n    def __init__(self):\n        self.locs = defaultdict(set)\n        self.grid = []\n        \n    def isValid(self, i, j):\n        return i >= 0 and i < len(self.grid) and j >= 0 and j < len(self.grid[i])\n    \n    def hasCycle(self, l):\n        seen = set()\n        todo = deque([])\n        around = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        for x in l:\n            if x not in seen:\n                todo.append([(-1, -1), x])\n                while todo:\n                    node = todo.popleft()\n                    cur = node[1]\n                    fr = node[0]\n                    if cur in seen:\n                        \n                        return True\n                    seen.add(cur)\n                    for x in around:\n                        test = (cur[0] + x[0], cur[1] + x[1])\n                        if self.isValid(test[0], test[1]) and test in l and not test == fr:\n                           \n                            todo.append([cur, test])\n        return False\n                    \n        \n        \n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        self.grid = grid\n        for x in range(len(grid)):\n            for y in range(len(grid[x])):\n                self.locs[grid[x][y]].add((x, y))\n        for x in list(self.locs.keys()):\n            if self.hasCycle(self.locs[x]):\n                return True\n        return False\n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        # union find\n        W, H = len(grid[0]), len(grid)\n        \n        parent = list(range(W * H))\n        rank = [0] * (W * H)\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                if rank[px] > rank[py]:\n                    parent[py] = px\n                elif rank[px] < rank[py]:\n                    parent[px] = py\n                else:\n                    parent[px] = py\n                    rank[py] += 1\n        \n        for x in range(H):\n            for y in range(W):\n                if x and y and grid[x][y] == grid[x - 1][y] == grid[x][y - 1] and find((x - 1) * W + y) == find(x * W + y - 1):\n                    return True\n                \n                for dx, dy in [(0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == grid[x][y]:\n                        union(x * W + y, nx * W + ny)\n        \n        return False\n        \n    def containsCycle_dfs(self, grid: List[List[str]]) -> bool:\n        W, H = len(grid[0]), len(grid)\n        \n        visited = [[0] * W for _ in range(H)]\n        def search(x, y, target, px, py):\n            nonlocal grid, W, H, visited\n            \n            visited[x][y] = 1\n            \n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == target:\n                    \n                    if visited[nx][ny]:\n                        if nx == px and ny == py:\n                            continue\n                        return True\n\n                    if search(nx, ny, target, x, y):\n                        return True\n            \n            return False\n        \n        for x in range(H):\n            for y in range(W):\n                if not visited[x][y]:\n                    if search(x, y, grid[x][y], None, None):\n                        return True\n        \n        return False", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        visited = set()\n        m = len(grid)\n        if m==1: return False\n        n = len(grid[0])\n        dirs = [(0,-1),(-1,0),(0,1),(1,0)]\n        def dfs(prev, curr):\n            if curr in visited: return True\n            visited.add(curr)\n            for dirn in dirs:\n                nei = (dirn[0]+curr[0], dirn[1]+curr[1])\n                if 0<=nei[0]<m and 0<=nei[1]<n and nei != prev and grid[nei[0]][nei[1]] == grid[curr[0]][curr[1]]:\n                    if dfs(curr, nei): return True\n            return False\n        for i in range(m):\n            for j in range(n):\n                if (i,j) not in visited:\n                    if dfs(None, (i,j)): return True\n        return False", "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.count = [1]*n\n    \n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    \n    def union(self, u, v):\n        p1, p2 = self.find(u), self.find(v)\n        if p1 == p2:\n            return False\n        \n        if self.count[p1] < self.count[p2]:\n            p1, p2 = p2, p1\n        \n        self.count[p1] += self.count[p2]\n        self.count[p2] = self.count[p1]\n        self.par[p2] = p1\n        return True\n    \n\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        # dsu for each cell\n        m, n = len(grid), len(grid[0])\n        dsu = DSU(m*n)\n        \n        for i in range(m):\n            for j in range(n):\n                for p,q in [(i+1,j), (i,j+1)]:\n                    if 0 <= p < m and 0 <= q < n and grid[i][j] == grid[p][q]:\n                        if not dsu.union(i*n+j, p*n+q):\n                            return True\n        \n        print((dsu.count))\n        return False\n        \n                            \n                        \n                \n", "class Solution:\n    \n    def search_cycle(self, grid, i, j, parents):\n        key = grid[i][j]\n        parents[i, j] = (None, None)\n        nodes = [(i, j)]\n        visited = set()\n        while len(nodes):\n            i, j = nodes.pop()\n            visited.add((i, j))\n            pi, pj = parents[i, j]\n            for ci, cj in [\n                (i+1, j),\n                (i-1, j),\n                (i, j+1),\n                (i, j-1),\n            ]:\n                in_range = 0<=ci<len(grid) and 0<=cj<len(grid[ci])\n                is_same_key = in_range and grid[ci][cj] == key\n                if ci == pi and cj == pj:\n                    continue\n                if in_range and is_same_key:\n                    if (ci, cj) in visited:\n                        return True\n                    parents[ci, cj] = (i, j)\n                    nodes.append((ci, cj))\n        return False\n        \n                \n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        parents = {}\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if (i, j) in parents:\n                    continue\n                is_cycle = self.search_cycle(grid, i, j, parents)\n                if is_cycle:\n                    return True\n        return False", "class Solution:\n    def containsCycle(self, g: List[List[str]]) -> bool:\n        r = len(g)\n        c = len(g[0])\n        \n        cc = {}\n        \n        def root(x):\n            if cc[x] != x:\n                cc[x] = root(cc[x])\n            return cc[x]\n        \n        def join(x, y):\n            rx = root(x)\n            ry = root(y)\n            if rx != ry:\n                cc[rx] = ry\n            return rx != ry\n        \n        for i in range(r):\n            for j in range(c):\n                cc[i,j] = (i,j)\n                \n        for i in range(r):\n            for j in range(c):\n                for di, dj in [[0,1], [1,0]]:\n                    ni,nj = i + di, j + dj\n                    if 0 <= ni < r and 0 <= nj < c and g[i][j] == g[ni][nj]:\n                        if not join((i,j), (ni,nj)):\n                            return True\n        return False\n                        \n                        \n        \n", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        R, C = len(grid), len(grid[0])\n        UF = {}\n        def find(u):\n            if UF[u] != u:\n                UF[u] = find(UF[u])\n            return UF[u]\n        \n        def union(u, v):\n            UF.setdefault(u, u)\n            UF.setdefault(v, v)\n            UF[find(u)] = find(v)\n        \n        for i in range(R):\n            for j in range(C):\n                if i > 0 and grid[i][j] == grid[i - 1][j]:\n                    if (i, j) in UF and (i - 1, j) in UF and find((i, j)) == find((i - 1, j)): return True\n                    union((i, j), (i - 1, j))\n                if j > 0 and grid[i][j] == grid[i][j - 1]:\n                    if (i, j) in UF and (i, j - 1) in UF and find((i, j)) == find((i, j - 1)): return True\n                    union((i, j), (i, j - 1))\n        return False", "import sys\nsys.setrecursionlimit(250000)\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        \n        def valid(x, y):\n            if x < m and x >= 0 and y < n and y >= 0:\n                return True\n            else:\n                return False\n        \n        def dfs(x, y, parent_x, parent_y):\n            visit[x][y] = 1\n            \n            for d in ((0, 1), (0, -1), (-1, 0), (1, 0)):\n                new_x = x + d[0]\n                new_y = y + d[1]\n                if valid(new_x, new_y) and grid[new_x][new_y] == grid[x][y] and (not (parent_x == new_x and parent_y == new_y)):\n                    if visit[new_x][new_y] == 1:\n                        return True\n                    else:\n                        cur = dfs(new_x, new_y, x, y)\n                        if cur:\n                            return True\n            \n            return False\n        \n        visit = [[0 for _ in range(n)] for _ in range(m)]\n        \n        res = False\n        \n        for i in range(m):\n            if res:\n                return True\n            \n            for j in range(n):\n                if visit[i][j] == 0:\n                    res = dfs(i, j, -1, -1)\n                \n                if res:\n                    return True\n        \n        return False", "import collections\nclass Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        '''\n        # dfs, TLE. I think bfs will leads to TLE as well.\n        rows, cols = len(grid), len(grid[0])\n        def dfs(ch, s_r, s_c, row, col, seen, leng):\n            for dr, dc in [[1, 0],[0, -1], [0, 1], [-1, 0]]:\n                r, c = row + dr, col + dc\n                if leng >= 4 and (r, c) == (s_r, s_c):\n                    return True\n                if 0 <= r < rows and 0 <= c < cols and grid[r][c] == ch and (r, c) not in seen and dfs(ch, s_r, s_c, r, c, seen | set([(r, c)]), leng + 1):\n                    return True\n            return False\n                    \n        for r in range(rows - 1):\n            for c in range(cols - 1):\n                if grid[r][c] == grid[r + 1][c] == grid[r][c + 1]:\n                    if dfs(grid[r][c], r, c, r, c, set([(r, c)]), 1):\n                        return True\n        return False\n        '''\n        # Union Find, when you reach a char which is the same as current char and the two share the same\n        # ancestor, then there is a ring\n        rows, cols = len(grid), len(grid[0])\n        seen = set()\n        ancestors = dict()\n        for r in range(rows):\n            for c in range(cols):\n                ancestors[(r, c)] = (r, c)\n        def find(x, y):\n            if ancestors[(x, y)] != (x, y):\n                xx, yy = ancestors[(x, y)] \n                ancestors[(x, y)] = find(xx, yy)\n            return ancestors[(x, y)]\n        \n        def union(x1, y1, x2, y2):\n            # (x2, y2) is the new char that should be added to the group that (x1, y1) belongs to\n            ancestors[find(x2, y2)] = find(x1, y1)\n            \n        for r in range(rows):\n            for c in range(cols):\n                if r == 0 and c == 0:\n                    continue\n                if r > 0 and c > 0 and grid[r - 1][c] == grid[r][c - 1] == grid[r][c] and find(r - 1, c) == find(r, c - 1):\n                    return True\n                if c > 0 and grid[r][c - 1] == grid[r][c]:\n                    union(r, c - 1, r, c)\n                if r > 0 and grid[r - 1][c] == grid[r][c]:\n                    union(r, c, r - 1, c)\n        return False        \n                        \n        \n'''\n[[\\\"a\\\",\\\"a\\\",\\\"a\\\",\\\"a\\\"],[\\\"a\\\",\\\"b\\\",\\\"b\\\",\\\"a\\\"],[\\\"a\\\",\\\"b\\\",\\\"b\\\",\\\"a\\\"],[\\\"a\\\",\\\"a\\\",\\\"a\\\",\\\"a\\\"]]\n[[\\\"c\\\",\\\"c\\\",\\\"c\\\",\\\"a\\\"],[\\\"c\\\",\\\"d\\\",\\\"c\\\",\\\"c\\\"],[\\\"c\\\",\\\"c\\\",\\\"e\\\",\\\"c\\\"],[\\\"f\\\",\\\"c\\\",\\\"c\\\",\\\"c\\\"]]\n[[\\\"a\\\",\\\"b\\\",\\\"b\\\"],[\\\"b\\\",\\\"z\\\",\\\"b\\\"],[\\\"b\\\",\\\"b\\\",\\\"a\\\"]]\n[[\\\"d\\\",\\\"b\\\",\\\"b\\\"],[\\\"c\\\",\\\"a\\\",\\\"a\\\"],[\\\"b\\\",\\\"a\\\",\\\"c\\\"],[\\\"c\\\",\\\"c\\\",\\\"c\\\"],[\\\"d\\\",\\\"d\\\",\\\"a\\\"]]\n'''", "class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \n        return self.unionfind(grid)\n        \n        '''\n        self.grid = grid\n        self.m = len(grid)\n        self.n = len(grid[0])\n        self.visited = set()\n        \n        for i in range(self.m):\n            for j in range(self.n):\n                \n                if (i,j) not in self.visited:\n                    if self.bfs((i,j), (-1,-1)):\n                        return True\n        return False\n\n        '''\n                \n    def find(self, node):\n        if self.parent[node[0]][node[1]] == node:\n            return node\n        else:\n            p = self.find(self.parent[node[0]][node[1]])\n            self.parent[node[0]][node[1]] = p\n            return(p)\n    \n    def union(self, node1, node2):\n        \n        p1 = self.find(node1)\n        p2 = self.find(node2)\n        \n        if self.rank[p1[0]][p1[1]] > self.rank[p2[0]][p2[1]]:\n            self.parent[p2[0]][p2[1]] = p1\n        elif self.rank[p2[0]][p2[1]] > self.rank[p1[0]][p1[1]]:\n            self.parent[p1[0]][p1[1]] = p2\n        else:\n            self.parent[p1[0]][p1[1]] = p2\n            self.rank[p2[0]][p2[1]] += 1\n    \n    def unionfind(self,g):\n        \n        nrow, ncol = len(g), len(g[0])\n        \n        self.parent = []\n        self.rank = [[1]*ncol for _ in range(nrow)]\n        \n        for i in range(nrow):\n                self.parent.append([(i,j) for j in range(ncol)])\n        \n        for i in range(nrow):\n            for j in range(ncol):\n                \n                if i+1 < nrow and g[i][j] == g[i+1][j]:\n                    \n                    if self.find((i,j)) == self.find((i+1, j)):\n                        return True\n                    self.union((i,j), (i+1, j))\n                \n                if j+1 < ncol and g[i][j] == g[i][j+1]:\n                    if self.find((i,j)) == self.find((i, j+1)):\n                        return True\n                    self.union((i,j), (i, j+1))\n        return False\n        \n    \n    def cycle(self, current, parent):\n        \n        if current in self.visited:\n            return True\n        \n        self.visited.add(current)\n        i,j = current\n        neb = [(i+1,j), (i-1,j), (i, j+1), (i, j-1)]\n        \n        for ne in neb:\n            ni, nj = ne\n            if ne != parent and ni >= 0 and ni < self.m  and nj >=0 and nj < self.n and self.grid[ni][nj] == self.grid[i][j]:\n                #print(ne)\n                if self.cycle((ni, nj), current):\n                    return True\n        return False\n                \n    \n    def bfs(self, current, parent):\n        \n        if current in self.visited:\n            return True\n        \n        q = []\n        q.append((current, parent))\n        self.visited.add(current)\n        \n        while q:\n            \n            node, par = q.pop()\n            #print(node)\n            #print(par)\n            i,j = node\n            neb = [(i+1,j),(i-1,j), (i, j+1), (i,j-1)]\n            \n            for ni,nj in neb:\n                if ni >= 0 and ni < self.m and nj >=0 and nj < self.n and self.grid[ni][nj] == self.grid[i][j] and (ni, nj) != par:\n                    \n                    if (ni, nj) in self.visited:\n                        return True\n                    q.append(((ni,nj), (i,j)))\n                    self.visited.add((ni,nj))\n        return False\n                        \n            \n            \n            \n        \n                \n"]
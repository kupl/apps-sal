["class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         \n         dic = {}\n         numSum = 0\n         dic[0] = 1\n         ans = 0\n         for i in range(len(nums)):\n             numSum += nums[i]\n             if (numSum - k) in dic:\n                 ans += dic[numSum - k]\n             if numSum in dic:\n                 dic[numSum] += 1\n             else:\n                 dic[numSum] = 1\n         return ans", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         cum_sum_dict = {}\n         cum_sum_dict[0] = 1\n         left_sum = 0\n         count = 0\n         for t in nums:\n             left_sum = left_sum + t\n             if (left_sum - k) in cum_sum_dict:\n                 count = count + cum_sum_dict[left_sum - k]\n             if left_sum in cum_sum_dict:\n                 cum_sum_dict[left_sum] = cum_sum_dict[left_sum] + 1\n             else:\n                 cum_sum_dict[left_sum] = 1\n         \n         return count", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         l_nums = len(nums)\n         c = 0\n         state = dict()\n         state[0] = 1\n         sum = 0\n         \n         for idx in range(0, l_nums):\n             sum += nums[idx]\n             if((sum - k) in state):\n                 c += state[sum - k]\n             state[sum] = (state[sum] if sum in state else 0) + 1\n         return c\n     \n", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count, current, solution = {0: 1}, 0, 0\n         for num in nums:\n             current += num\n             solution += count.get(current - k, 0)\n             count[current] = count.get(current, 0) + 1\n         return solution", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         sum_map = {0:1}\n         count = 0\n         total_sum = 0\n         total = 0\n         for numb in nums:\n             total += numb\n             count += sum_map.get(total-k, 0)\n             sum_map[total] = sum_map.get(total, 0) +1\n         return count", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count, cur, res = {0: 1}, 0, 0\n         for v in nums:\n             cur += v\n             res += count.get(cur - k, 0)\n             count[cur] = count.get(cur, 0) + 1\n         return res", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count, current, solution = {0: 1}, 0, 0\n         for num in nums:\n             current += num\n             solution += count.get(current - k, 0)\n             count.update({current: count.get(current, 0) + 1})\n         return solution", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count, current, solution = {0: 1}, 0, 0\n         for num in nums:\n             current += num\n             solution += count.get(current - k, 0)\n             count.update({current: count.get(current, 0) + 1})\n         return solution", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count, current, solution = {0: 1}, 0, 0\n         for num in nums:\n             current += num\n             solution += count.get(current - k, 0)\n             count.update({current: count.get(current, 0) + 1})\n         return solution", "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         # count = 0\n         # for i in range(len(nums)):\n         #     for j in range(i,len(nums)):\n         #         if sum(nums[i:j+1]) == k:\n         #             count += 1\n         # return count\n         \n #         count = 0\n #         s = 0\n #         cum_sum = []\n #         for x in nums:\n #             s += x\n #             cum_sum.append(s)\n #             if s == k:\n #                 count += 1\n         \n #         for i,x in enumerate(cum_sum):\n #             for y in cum_sum[i+1:]:\n #                 if y - x == k:\n #                     count += 1\n #         return count\n \n         # good answer @awice\n         # time: O(n) space: O(1)\n         # idea:count[V] is the number of previous prefix sums with value V. If our newest prefix sum has value W, and W-V == K,\n         #   then we add count[V] to our answer.This is because at time t, A[0] + A[1] + ... + A[t-1] = W, \n         #   and there are count[V] indices j with j < t-1 and A[0] + A[1] + ... + A[j] = V. \n         #   Thus, there are count[V] subarrays A[j+1] + A[j+2] + ... + A[t-1] = K.\n         count = collections.Counter()\n         count[0] = 1\n         ans = su = 0\n         for x in nums:\n             su += x\n             ans += count[su-k]\n             count[su] += 1\n         return ans\n"]
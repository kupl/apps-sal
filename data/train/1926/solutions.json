["import collections\nimport itertools\n\n\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n /= i\n            yield i\n        else:\n            i += 1\n\n    if n > 1:\n        yield n\n\n\ndef prod(iterable):\n    result = 1\n    for i in iterable:\n        result *= i\n    return result\n\n\ndef get_divisors(n):\n    pf = prime_factors(n)\n\n    pf_with_multiplicity = collections.Counter(pf)\n\n    powers = [\n        [factor ** i for i in range(count + 1)]\n        for factor, count in list(pf_with_multiplicity.items())\n    ]\n\n    for prime_power_combo in itertools.product(*powers):\n        yield prod(prime_power_combo)\n\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        d1 = sorted(list(get_divisors(num+1)))\n        d2 = sorted(list(get_divisors(num+2)))\n        \n        if len(d1) % 2 == 1:\n            mid = d1[int((len(d1) - 1)/2)]\n            return [int(mid), int(mid)]\n        \n        if len(d2) % 2 == 1:\n            mid = d2[int((len(d2) - 1)/2)]\n            return [int(mid), int(mid)]\n        \n        l1, r1 = d1[int(len(d1)/2)],d1[int(len(d1)/2)-1]\n        l2, r2 = d2[int(len(d2)/2)],d2[int(len(d2)/2)-1]\n        \n        if abs(l1-r1) < abs(l2-r2):\n            return [int(l1),int(r1)]\n        else:\n            return [int(l2),int(r2)]\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        num+=2 #so values are num and num-1\n        i = int(math.sqrt(num))\n        while i>1:\n            r = num%i\n            if r<=1:\n                return [i,(num-r)//i]\n            i-=1\n        return [1, num-1]", "\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        def divisors(n):\n            for i in range(int((n+2)**0.5), 0, -1):\n                if (n+1) % i == 0:\n                    return [i, (n+1)//i]\n                if (n+2) % i == 0:\n                    return [i, (n+2)//i]\n            return [1, n+1]\n\n        return divisors(num)\n\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        divisor_dict = {}\n        \n        def get_divisors(num):\n            all_divisors = []\n            divisor_set = set()\n            for divisor_one in range(int(num**0.5),0,-1):\n                divisor_two = int(num / divisor_one)\n                if divisor_one in divisor_set or divisor_two in divisor_set:\n                        continue\n                if num % divisor_one == 0:\n                    divisor_set.add(divisor_one)\n                    divisor_set.add(divisor_two)\n                    all_divisors.append((divisor_one, divisor_two))\n            return all_divisors\n\n        closest_divisor = num * 2\n        \n        all_divisors = []\n        for divisor in get_divisors(num+1):\n            all_divisors.append(divisor)\n        for divisor in get_divisors(num+2):\n            all_divisors.append(divisor)\n        \n        print(all_divisors)\n        return_divisor_pair = None\n        for divisor in all_divisors:\n            difference = divisor[0] - divisor[1]\n            if difference < 0:\n                difference *= -1\n            if difference < closest_divisor:\n                closest_divisor = difference\n                return_divisor_pair = divisor\n        \n        return list(return_divisor_pair)\n            \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        i = 1\n        while i < (num+2)**0.5+1:\n            if ((num+1)%i) == 0:\n                res = [i,(num+1)//i]\n             \n            if ((num+2)%i) == 0:\n                temp = [i,(num+2)//i]\n                if abs(temp[0]-temp[1]) < abs(res[0] - res[1]):\n                    res = temp\n            i += 1\n        return res", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        i = 1\n        while i < (num+2)**0.5+1:\n            if ((num+1)%i) == 0:\n                res = [i,(num+1)//i]\n             \n            if ((num+2)%i) == 0:\n                if abs(i-(num+2)//i) < abs(res[0] - res[1]):\n                    res = [i, (num+2)//i]\n            i += 1\n        return res", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        result = [None, None]\n        i = 1\n        while i*i<=num+2:\n            if not (num+1)%i:\n                result = [i, (num+1)//i]\n            elif not (num+2)%i:\n                result = [i, (num+2)//i]\n            i += 1\n        return result", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for d in range(int((num+2)**0.5), 0, -1):\n            if (num + 1)% d == 0:\n                return [d, (num+1)//d]\n            if (num+2)%d == 0:\n                return [d, (num+2)//d]\n", "class Solution(object):\n    def closestDivisors(self, num):\n        def fun(n):\n            for i in range(int(n**.5),0,-1):\n                if n%i==0:\n                    return [n//i,i]\n        \n        n1=fun(num+1)\n        n2=fun(num+2)\n        if abs(n2[1]-n2[0])>abs(n1[1]-n1[0]):\n            return n1\n        return n2\n", "class Solution:\n    def closestDivisors(self, n: int) -> List[int]:\n        def myfunc(n):\n            for i in range(int(n**0.5),0,-1):\n                if n%i == 0:\n                    return [i,n//i]\n        x,y=myfunc(n+1),myfunc(n+2)\n        return x if abs(x[1]-x[0]) < abs(y[0]-y[1]) else y", "\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        x = num + 1\n        y = num + 2\n        a = []\n        for i in range(int(x ** 0.5)+1, -1, -1):\n            if x % i == 0:\n                a.append([i, x // i])\n                break\n                \n        for j in range(int(y ** 0.5)+1, -1, -1):\n            if y % j == 0:\n                a.append([j, y // j])\n                break\n        print(a)\n        if abs(a[0][0] - a[0][1]) < abs(a[1][0] - a[1][1]):\n            return a[0]\n        return a[1]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        def helper(k):\n            for i in range(int(math.sqrt(k)),0,-1):\n                if k % i == 0:\n                    return [i, k//i]\n        return sorted([helper(num+1), helper(num+2)], key=lambda c: abs(c[0]-c[1]))[0]\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        l1,r1 = self.cldv(num+1)\n        l2,r2 = self.cldv(num+2)\n        d1=r1-l1\n        d2=r2-l2\n        if d1<d2:\n            return [l1,r1]\n        else:\n            return [l2,r2]\n\n    def cldv(self, n):\n        s = int(n**0.5)\n        while n%s!=0:\n            s-=1\n        return s,n//s", "def f(n):\n    for i in range(int(n**.5),0,-1):\n        if n%i==0:return [i,n//i]\nclass Solution:\n    def closestDivisors(self, n: int) -> List[int]:\n        a,b=f(n+1),f(n+2)\n        return a if abs(a[1]-a[0])<abs(b[0]-b[1]) else b", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        def find(n):\n            for i in range(int(n**(0.5)),0,-1):\n                if n % i == 0:\n                    return (i, n//i)\n            return None, None\n        \n        a,b = find(num+1)\n        c,d = find(num+2)\n        return [a,b] if b - a < d  - c else [c,d]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n#         If I have 8, I will check for 9 also. For checking 9, I will check till half value of the number. so that i can #confirm that, its not a prime number, if it gor divided by any number. \n# In case of 10, first, I divide with 2, so the quotient will be 5. My limit will be set between 2 and 5. If there is #another couple of factors exist in between. I will take them. I will follow these steps, till divisor is less than #quotient. If I didnt get a suiatble pair, I will jump to num+2 and follow the same steps.\n\n#         N = num+1 \n#         dvsr = 2\n#         quo = N\n#         flag = 0\n#         while(dvsr < quo and dvsr < N // 2):\n#             if N % dvsr == 0:\n#                 quo = int(N / dvsr)\n#                 flag = 1\n#             else:\n#                 dvsr += 1\n        \n#         if flag == 1:\n#             return [dvsr, quo]\n        \n#         N = num+2 \n#         dvsr = 2\n#         quo = N\n#         while(dvsr < quo and dvsr < N // 2):\n#             if N % dvsr == 0:\n#                 quo = int(N / dvsr)\n#             else:\n#                 dvsr += 1\n        \n\n#         return [dvsr, quo]\n\n# This approch is tedious, so, lets get the sqrt of the num+1 and num+2. If tehre exists a perfect square root, return that. Else, keep on decreasing the valaue unless you find one\n\n        N1 = num + 1\n        N2 = num + 2\n        sqrt1 = int(N1**0.5)+1\n        sqrt2 = int((N2)**0.5)+1\n        \n        while sqrt1 >= 2 or sqrt2 >= 2:\n            if (N2) % sqrt2 == 0:\n                return [sqrt2, int(N2/sqrt2)]\n            if N1 % sqrt1 == 0:\n                return [sqrt1, int(N1/sqrt1)]\n            else:\n                sqrt1 -= 1\n                sqrt2 -= 1\n        \n        return [1, sqrt1]\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        def maxFactor(n):\n            if n < 3:\n                return n\n            for i in range(int(math.sqrt(n)), 0, -1):\n                if not n % i:\n                    return i\n            return 1\n        res = [] \n        for n in [num + 1, num + 2]:\n            a = maxFactor(n)\n            b = n // a\n            res.append((abs(a - b), [a, b]))\n        return min(res, key = lambda x:x[0])[1]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for k in range(int(math.sqrt(num+2)), 0, -1):\n            for x in (num+1, num+2):\n                if not x % k:\n                    return x // k, k", "class Solution:\n    def closestDivisors(self, x: int) -> List[int]:\n        for a in range(int((x+2) ** 0.5), 0, -1):\n            if (x + 1) % a == 0:\n                return [a, (x + 1) // a]\n            if (x + 2) % a == 0:\n                return [a, (x + 2) // a]\n        \n        return []", "import math\nclass Solution:\n    def helper(self, num):\n        sqrt = int(math.sqrt(num))\n        gmin = float('inf')\n        ans = None\n        for i in range(1, sqrt + 1):\n            if num % i == 0 and abs(i - num/i) < gmin:\n                gmin = abs(i - num/i)\n                ans = [i, int(num/i)]\n        return ans\n        \n    def closestDivisors(self, num: int) -> List[int]:\n        ans1 = self.helper(num + 1)\n        ans2 = self.helper(num + 2)\n        if ans1 == None:\n            return ans2\n        elif ans2 == None:\n            return ans1\n        if abs(ans1[0] - ans1[1]) < abs(ans2[0] - ans2[1]):\n            return ans1\n        return ans2", "class Solution:\n    def divizor(self, num):\n        for i in range( int(math.sqrt(num)), 0, -1):\n            n1 = num / i\n            if n1.is_integer():\n                return [int(n1), int(num / n1)]\n\n    def closestDivisors(self, num: int) -> List[int]:\n        r = []\n        diff = None\n        for i in [num + 1, num + 2]:\n            d = self.divizor(i)\n            if not d:\n                continue\n            abs_diff = abs(d[0] - d[1])\n            if diff == None or abs_diff < diff:\n                diff = abs_diff\n                r = d\n        return r\n", "from math import sqrt, ceil\n\nclass Solution:\n    def closestDivisors(self, num):\n        closeDivs = []\n        closeDivDiff = 10000000000\n\n        if int(sqrt(num+1)) == sqrt(num+1):\n            sqrtNum = int(sqrt(num+1))\n            return [sqrtNum, sqrtNum]\n        elif int(sqrt(num+2)) == sqrt(num+2):\n            sqrtNum = int(sqrt(num+2))\n            return [sqrtNum, sqrtNum]\n\n        num += 1\n        for i in range(1, ceil(sqrt(num))):\n            if num % i == 0 and int(num/i) - i < closeDivDiff:\n                closeDivDiff = int(num/i) - i\n                closeDivs = [i, int(num/i)]\n\n        num += 1\n        for i in range(1, ceil(sqrt(num))):\n            if num % i == 0 and int(num/i) - i < closeDivDiff:\n                closeDivDiff = int(num/i)\n                closeDivs = [i, int(num / i)]\n\n        return closeDivs", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        return min([divs(num+1), divs(num+2)], key = lambda t: t[1]-t[0])   \n\ndef divs(n):\n    ans = []\n    for i in range(1,1+int(n**.5)):\n        if n%i==0:\n            ans = [i,n//i]\n    return ans", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for i in range(int((num+2) ** (0.5)), 0, -1):\n            if not (num + 1) % i:\n                return [i, (num + 1) // i]\n            if not (num + 2) % i:\n                return [i, (num + 2) // i]\n        return []", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        n=num+1\n        m=num+2\n        size=int(math.sqrt(m)+1)\n        holder = m\n        result = [0]*2\n        \n        for i in range(1, size):\n            if n%i == 0:\n                temp = n//i\n                if holder>abs(temp-i):\n                    holder = abs(temp-i)\n                    result[0]=temp\n                    result[1]=i\n            if m%i == 0:\n                temp = m//i\n                if holder>abs(temp-i):\n                    holder=abs(temp-i)\n                    result[0]=temp\n                    result[1]=i\n        return result", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        n = int((num+2)**0.5+1)\n        d = num\n        res = [1, num]\n        for i in range(n, 0, -1):\n            if not (num+1)%i: \n                if d>=abs(i - (num+1)//i):\n                    res[0], res[1] = i, (num+1)//i\n                    d = abs(i - (num+1)//i)\n            \n            if not (num+2)%i:\n                if d>=abs(i - (num+2)//i):\n                    res[0], res[1] = i, (num+2)//i\n                    d = abs(i - (num+2)//i)\n        return res", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        num1,num2=num+1,num+2\n        i=int(math.sqrt(num1))\n        m=int(math.sqrt(num2))\n        while i>0:\n            if num1%i==0:\n                j=num1//i\n                res1=j-i\n                break\n            else:\n                i-=1\n        while m>0:\n            if num2%m==0:\n                n=num2//m\n                res2=n-m\n                break\n            else:\n                m-=1\n        if res1<res2:\n            return [i,j]\n        else:\n            return [m,n]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        if num==1: return [1,2]\n        a=num+1\n        b=num+2\n        adiv=[]\n        bdiv=[]\n        for i in range(1,int(math.sqrt(b)+1)):\n            if a%i==0:\n                min_a=abs(a//i-i)\n                adiv.append([min_a,b//i,i])\n            if b%i==0:\n                min_b=abs(b//i-i)\n                adiv.append([min_b,b//i,i])\n\n        m=min(adiv)\n        return [m[1],m[2]]", "from math import sqrt, ceil\n\nclass Solution:\n    def closestDivisors(self, num):\n        closeDivs = []\n        closeDivDiff = 10000000000\n\n        if int(sqrt(num+1)) == sqrt(num+1):\n            sqrtNum = int(sqrt(num+1))\n            return [sqrtNum, sqrtNum]\n        elif int(sqrt(num+2)) == sqrt(num+2):\n            sqrtNum = int(sqrt(num+2))\n            return [sqrtNum, sqrtNum]\n\n        num += 1\n        for i in range(1, ceil(sqrt(num))):\n            if num % i == 0 and int(num/i) - i < closeDivDiff:\n                closeDivDiff = int(num/i) - i\n                closeDivs = [i, int(num/i)]\n\n        num += 1\n        for i in range(1, ceil(sqrt(num))):\n            if i == 19284:\n                print('Yes')\n            if num % i == 0 and int(num/i) - i < closeDivDiff:\n                closeDivDiff = int(num/i)\n                closeDivs = [i, int(num / i)]\n\n        return closeDivs", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        n1=num+1\n        n2=num+2\n        h1=int(n1**0.5)\n        h2=int(n2**0.5)\n        stack=[]\n        def run(n1,h1):\n            for i in range(h1,0,-1):\n                if n1%i==0:\n                    tmp=n1//i\n##                    print(i)\n                    stack.append((abs(i-tmp),i,tmp))\n        run(n1,h1)\n        run(n2,h2)\n        stack.sort(key=lambda x:x[0])\n        return [stack[0][1],stack[0][2]]\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        need1=num+1\n        need2=num+2\n        \n        def factors(num):\n            mi=float('inf')\n            ans=[]\n            for i in range(1,int(num**(0.5))+1):\n                if(num%i==0):\n                    if(num//i-i<mi):\n                        ans=[i,num//i]\n                        \n            return ans\n        \n        ls1=factors(need1)\n        ls2=factors(need2)\n        print((ls1,ls2))\n        if(ls1[1]-ls1[0]<ls2[1]-ls2[0]):\n            return ls1\n        else:\n            return ls2\n        \n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        res = [-math.inf, math.inf]\n        min_dist = math.inf\n        for i in range(1, int(math.sqrt(num+1))+2):\n            if (num+1) % i == 0:\n                if ((num+1)//i) - i < min_dist:\n                    res = [i, (num+1)//i]\n                    min_dist = (num+2)//i - i\n        for i in range(1, int(math.sqrt(num+2))+2):\n            if (num+2) % i == 0:\n                if ((num+2)//i) - i < min_dist:\n                    res = [i, (num+2)//i]\n                    min_dist = (num+2)//i - i\n        return res", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for i in range(int((num+2) ** (0.5)), 0, -1):  # only check sqrt, reduce the time complexity\n            if not (num+1) % i: return [i, (num+1)//i] # check if `i` is divisible by num+1\n            if not (num+2) % i: return [i, (num+2)//i] # check if `i` is divisible by num+2\n        return []", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for i in range(int((num + 2)**0.5), 0, -1):\n            if (num + 1) % i == 0:\n                return [i, int((num + 1) / i)]\n            \n            if (num + 2) % i == 0:\n                return [i, int((num + 2) / i)]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        x, y = self.get_factors(num+1)\n        z, t = self.get_factors(num+2)\n        return [x, y] if abs(x-y) <= abs(z-t) else [z, t]\n    \n    def get_factors(self, n):\n        y = n\n        for x in range(1, int(sqrt(n))+1):\n            # y = int(n/x) if (n/float(x)).is_integer() else y\n            # alternatively:\n            y = int(n/x) if n % x == 0 else y\n\n        return int(n/y), y", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        vals = (num + 1, num + 2)\n        for lo in itertools.count(int((num + 2) ** 0.5), -1):\n            for val in vals:\n                if val % lo == 0:\n                    return lo, val // lo\n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        def find_closest(cur):\n            nonlocal mini\n            nonlocal ans\n            \n            y = int(sqrt(cur+2))\n            flag = False\n            while y*y >= 1:\n                mod = cur%y\n                if(not mod):\n                    other = cur//y\n                    if((other - y) < mini):\n                        mini = other - y\n                        ans = [y, other]\n                        flag = True\n                elif((mod + 1) == y):\n                    other = (cur+1)//y\n                    if((other - y) < mini):\n                        mini = other - y\n                        ans = [y, other]\n                        flag = True\n                y -= 1\n                if(flag):\n                    break\n        mini = float('inf')\n        ans = None\n        \n        find_closest(num+1)\n\n        return ans", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        a,b = None,None\n        minDiff = float('inf')\n        for i in range(1,int(num**(1/2))+10):\n            if (num+1) % i == 0:\n                cand1 = i\n                cand2 = (num+1) // i\n                if abs(cand1-cand2) < minDiff:\n                    a,b = cand1,cand2\n                    minDiff = abs(cand1-cand2)\n            if (num+2) % i == 0:\n                cand1 = i\n                cand2 = (num+2) // i\n                if abs(cand1-cand2) < minDiff:\n                    a,b = cand1,cand2\n                    minDiff = abs(cand1-cand2)\n        return [a,b]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        ans = num + 1\n        val = None\n        for i in range(1, ceil(sqrt(num+3))):\n            if (num + 1) % i == 0:\n                j = (num + 1) // i\n                if abs(i-j) <= ans:\n                    ans = abs(i-j)\n                    val = [i, j]\n            if (num + 2) % i == 0:\n                j = (num + 2) // i\n                if abs(i-j) <= ans:\n                    ans = abs(i-j)\n                    val = [i, j]\n        return val\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        result = []\n        difference = float(\\\"inf\\\")\n        for i in range(int((num + 2)**0.5) + 1, 0, -1):\n            if (num + 1) % i == 0:\n                a = i\n                b = (num + 1) // a\n                if abs(a - b) < difference:\n                    difference = abs(a - b)\n                    result = [a, b]\n            if (num + 2) % i == 0:\n                a = i\n                b = (num + 2) // a\n                if abs(a - b) < difference:\n                    difference = abs(a - b)\n                    result = [a, b]\n        return result", "#\n# @lc app=leetcode id=1362 lang=python3\n#\n# [1362] Closest Divisors\n#\n# https://leetcode.com/problems/closest-divisors/description/\n#\n# algorithms\n# Medium (55.74%)\n# Total Accepted:    10.2K\n# Total Submissions: 17.9K\n# Testcase Example:  '8'\n#\n# Given an integer num, find the closest two integers in absolute difference\n# whose product equals num + 1 or num + 2.\n#\n# Return the two integers in any order.\n#\n#\n# Example 1:\n#\n#\n# Input: num = 8\n# Output: [3,3]\n# Explanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 =\n# 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.\n#\n#\n# Example 2:\n#\n#\n# Input: num = 123\n# Output: [5,25]\n#\n#\n# Example 3:\n#\n#\n# Input: num = 999\n# Output: [40,25]\n#\n#\n#\n# Constraints:\n#\n#\n# 1 <= num <= 10^9\n#\n#\n#\nfrom math import sqrt\nfrom typing import List\nfrom bisect import bisect_left\n\ndef insert(collector, solution):\n    insertion_point = bisect_left(collector, abs(solution[0] - solution[1]))\n    collector.insert(insertion_point, solution)\n\nclass Solution:\n    \\\"\\\"\\\"\n    >>> Solution().closestDivisors(0)\n    [1, 1]\n\n    >>> Solution().closestDivisors(1)\n    [1, 2]\n\n    >>> Solution().closestDivisors(8)\n    [3, 3]\n\n    >>> Solution().closestDivisors(123)\n    [5, 25]\n\n    >>> Solution().closestDivisors(999)\n    [25, 40]\n\n    \\\"\\\"\\\"\n    def closestDivisors(self, num: int) -> List[int]:\n        found_solutions = []\n        ref_table = {}\n        for i in range(1, int((sqrt(num + 2))) + 1):\n            if (num + 1) % i == 0:\n                distance = abs(i - (num + 1) // i)\n                insertion_point = bisect_left(found_solutions, distance)\n                found_solutions.insert(insertion_point, distance)\n                ref_table[distance] = (i, (num + 1) // i)\n            if (num + 2) % i == 0:\n                distance = abs(i - (num + 2) // i)\n                insertion_point = bisect_left(found_solutions, distance)\n                found_solutions.insert(insertion_point, distance)\n                ref_table[distance] = (i, (num + 2) // i)\n        return list(ref_table[found_solutions[0]])\n\n\n\n", "import math\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        d=int(math.pow(num+1,0.5))\n        e=int(math.pow(num+2,0.5))\n        if (num==1):\n            return ([1,2])\n        ans=24839749234923385\n        ll=[-1,-1]\n        for i in range(2,d+1):\n            if((num+1)%i==0):\n                if (ans>((num+1)//i - i)):\n                    ans=(num+1)//i - i\n                    ll=[i,(num+1)//i]\n        for i in range(2,e+1):\n            if((num+2)%i==0):\n                if (ans>((num+2)//i - i)):\n                    ans=(num+2)//i - i\n                    ll=[i,(num+2)//i]\n        \n        return (ll)\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        n1 = {}\n        n2 = {}\n        n1[tuple([1, num + 1])] = abs((num + 1) - 1)\n        for i in range(2, int(sqrt(num + 1)) + 1):\n            if (num + 1) % i == 0:\n                n1[tuple([i, int((num + 1) / i)])] = abs(int((num + 1) / i) - i)\n        n2[tuple([1, num + 2])] = abs((num + 2) - 1)\n        for i in range(2, int(sqrt(num + 2)) + 1):\n            if (num + 2) % i == 0:\n                n2[tuple([i, int((num + 2) / i)])] = abs(int((num + 2) / i) - i)\n        r1 = sorted(n1.items(), key=lambda x: x[1])\n        r2 = sorted(n2.items(), key=lambda x: x[1])\n        if r1[0][1] < r2[0][1]:\n            return list(r1[0][0])\n        return list(r2[0][0])     ", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        diff=num+1\n        for i in range(1,int((num+1)**0.5)+1):\n            if (num+1)%i==0:\n                    num1_,num1__=i,(num+1)//i\n        diff=num+2\n        for i in range(1,int((num+2)**0.5)+1):\n            if (num+2)%i==0:\n                    num2_,num2__=i,(num+2)//i\n        diff1=num1__-num1_\n        diff2=num2__-num2_\n        return [num1_,num1__] if diff1<diff2 else [num2_,num2__]\n                \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        fpairs1, fpairs2 = [], []\n        for i in range(1, int((num+1)**0.5) + 1):\n            if (num+1)%i == 0:\n                fpairs1.append([i, int((num+1)/i)])\n        for i in range(1, int((num+2)**0.5) + 1):\n            if (num+2)%i == 0:\n                fpairs2.append([i, int((num+2)/i)])\n\n        return fpairs1[-1] if abs(fpairs1[-1][0] - fpairs1[-1][1]) < abs(fpairs2[-1][0] - fpairs2[-1][1]) else fpairs2[-1]\n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        if num == 1:\n            return [1,2]\n        \n        if num == 2:\n            return [2,2]\n        \n        def getClose(val):\n            yuh = set()\n            for i in range (1, int(val**0.5)+1):\n                if val % i == 0 and ((val//i, i) not in yuh or (i, val//i) not in yuh):\n                    yuh.add((val//i, i))\n            \n            m = 10**9\n            e = (-1,-1)\n            for elem in yuh:\n                if abs(elem[0]-elem[1]) < m:\n                    e = elem \n                    m = abs(elem[0]-elem[1])\n            return e\n        \n        a = getClose(num+1)\n        b = getClose(num+2)\n        \n        if abs(a[0]-a[1]) < abs(b[0]-b[1]):\n            return list(a)\n        \n        return list(b)\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        diff = math.inf\n        ans = []\n        n = num\n        num = n+1\n        \n        def func(num):\n            nonlocal diff, ans\n            \n            for i in range(1, math.ceil(math.sqrt(num))+1):\n                if num%i == 0:\n                    j = num//i\n                    if abs(i - j) < diff:\n                        diff = abs(i - j)\n                        ans = [i, j]\n            return ans\n        \n        func(n + 1)\n        func(n + 2)\n        \n        return ans", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        fpairs1, fpairs2 = [], []\n        for i in range(1, int((num+1)**0.5) + 1):\n            if (num+1)%i == 0:\n                fpairs1.append([i, int((num+1)/i)])\n        for i in range(1, int((num+2)**0.5) + 1):\n            if (num+2)%i == 0:\n                fpairs2.append([i, int((num+2)/i)])\n\n        if abs(fpairs1[-1][0] - fpairs1[-1][1]) < abs(fpairs2[-1][0] - fpairs2[-1][1]):\n            return fpairs1[-1]\n        else:\n            return fpairs2[-1]   \n\n", "import math\n\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n\n        n1 = num+1\n        n2 = num+2 \n        \n        \n        def helper ( n ): \n            res = [1,n] \n            curr_diff = abs(res[0] - res[1])\n            \n            mid  = max ( int ( math.sqrt ( n )//1 ) ,1 ) \n            for i in range ( mid, 0,-1):\n                if n % i ==0 : \n                    if abs ( i - (n//i) ) < curr_diff: \n                        res = [i,n//i]\n                        curr_diff = abs ( i - (n//i) ) \n            \n            return res\n        \n        \n        n1_D = helper ( n1 )\n        n2_D = helper ( n2 )\n        #print(n1_D, n2_D )\n        n1_D_diff =  abs ( n1_D [0] -  n1_D [1] ) \n        n2_D_diff =  abs ( n2_D [0] -  n2_D [1] )\n        \n        if n1_D_diff > n2_D_diff : return n2_D\n        return n1_D", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        add1 = num + 1\n        add2 = num + 2\n        \n        start = floor(sqrt(add2))\n        \n        for i in range(start, 0, -1):\n            x1, r1 = divmod(add1, i)\n            x2, r2 = divmod(add2, i)\n            \n            if r1 == 0:\n                return i, x1\n            if r2 == 0:\n                return i, x2\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        vals = [num + 1, num + 2]\n        sqrt = int((num + 2) ** 0.5)\n        for lo in itertools.count(sqrt, -1):\n            for val in vals:\n                if val % lo == 0:\n                    return lo, val // lo\n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n \n        mini = float('inf')\n        ans = None\n        \n        cur = num+1\n        \n        y = int(sqrt(cur+2))\n        flag = False\n        while y*y >= 1:\n            mod = cur%y\n            if(not mod):\n                other = cur//y\n                if((other - y) < mini):\n                    mini = other - y\n                    ans = [y, other]\n                    flag = True\n            elif((mod + 1) == y):\n                other = (cur+1)//y\n                if((other - y) < mini):\n                    mini = other - y\n                    ans = [y, other]\n                    flag = True\n            y -= 1\n            if(flag):\n                break\n\n        return ans", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        x, y = self.get_factors(num+1)\n        z, t = self.get_factors(num+2)\n        return [x, y] if abs(x-y) <= abs(z-t) else [z, t]\n    \n    def get_factors(self, n):\n        y = n\n        for x in range(1, int(sqrt(n))+1):\n            # y = int(n/x) if (n/float(x)).is_integer() else y\n            # alternatively, using mod is faster than direct division:\n            y = int(n/x) if n % x == 0 else y\n\n        return int(n/y), y", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for i in range(int((num+2) ** (0.5)), 0, -1):  # only check sqrt, reduce the time complexity\n            if not (num+1) % i: return [i, (num+1)//i] # check if `i` is divisible by num+1\n            if not (num+2) % i: return [i, (num+2)//i] # check if `i` is divisible by num+2\n        return []\n", "import math\n\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        for x in range(int(math.sqrt(num + 2)), 0, -1):\n            if (num + 1) % x == 0:\n                return [x, (num + 1) // x]\n            if (num + 2) % x == 0:\n                return [x, (num + 2) // x]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        n = int (math.sqrt(num+2))\n        max_ = 0\n        check = False\n        for i in range(1,n+1):\n            if (num + 1) % i == 0:\n                max_ = i\n                check = False\n            elif (num + 2) % i == 0:\n                print(i)\n                max_ = i\n                check = True\n        \n        if check: return max_, int ((num+2)/max_)\n        else: return max_, int ((num+1)/max_)\n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:     \n        \n        num += 1\n        for factor in range(int((num)**0.5), 0, -1):\n            if num % factor == 0:\n                num_1 = [factor, num//factor]\n                break\n        \n        num += 1\n        for factor in range(int((num)**0.5), 0, -1):\n            if num % factor == 0:\n                num_2 = [factor, num//factor]\n                break\n                \n        return min(num_1, num_2, key=lambda x: abs(x[0]-x[1]))", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        num1, num2 = num + 1, num + 2\n        def findDivisors(num):\n            start = int(num ** 0.5)\n            for i in range(start, 0, -1):\n                if num % i == 0:\n                    return [i, num // i]\n        div1 = findDivisors(num1)\n        div2 = findDivisors(num2)\n        div_pairs = [div1, div2]\n        res = min(div_pairs, key = lambda x : abs(x[0] - x[1]))\n        return res", "from math import sqrt\nfrom typing import List\n\n\nclass Solution:\n    def findDivisor(self, num):\n        min_gap = num\n        min_gap_saved = []\n        # for i in range(int(sqrt(num)), 0, -1):\n        for i in range(1, int(sqrt(num)) + 1):\n            if num % i == 0:\n                gap = abs(i - num // i)\n                if gap < min_gap:\n                    min_gap = gap\n                    min_gap_saved = sorted([i, num // i])\n        return min_gap_saved\n\n    def closestDivisors(self, num: int) -> List[int]:\n        a, b = self.findDivisor(num + 1)\n        c, d = self.findDivisor(num + 2)\n        if b - a > d - c:\n            return [c, d]\n        else:\n            return [a, b]\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        def compute(n):\n            diff = float(\\\"inf\\\")\n            res = []\n            for i in range(1, 1+int(n**0.5)):\n                if n % i == 0:\n                    if abs(n//i - i) < diff:\n                        diff = abs(n//i - i)\n                        res = [n//i, i]\n            return [diff, res]\n        d1, r1 = compute(num+1)\n        d2, r2 = compute(num+2)\n        return r1 if d1 < d2 else r2", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        x, y = self.get_factors(num+1)\n        z, t = self.get_factors(num+2)\n        return [x, y] if abs(x-y) <= abs(z-t) else [z, t]\n    \n    def get_factors(self, n):\n        y = n\n        for x in range(1, int(sqrt(n))+1):\n            # y = int(n/x) if (n/float(x)).is_integer() else y\n            # alternatively, using mod is faster than direct division:\n            y = int(n/x) if n % x == 0 else y\n\n        return int(n/y), y\n    \n# use n % x to check whether x divides n\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        r = int(math.sqrt(num+2))\n        d, ans = inf, [1, num+1]\n        for x in range(r, 1, -1):\n            for y in [num + 1, num + 2]:\n                if y % x == 0:\n                    diff = abs(x - y // x)\n                    if d > diff:\n                        d = diff\n                        ans = [x, y // x]\n        return ans\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        x = int((num+2)**0.5)\n        best = [float('inf'), -float('inf')]\n        for y in range(x, 0, -1):\n            for z in ((num+1, num+2)):\n                if z % y == 0:\n                    if abs(y - z//y) < abs(best[0] - best[1]):\n                        best = [y, z//y]\n        return best\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        minimum = float(\\\"Inf\\\")\n        upper_bound = int((num + 2) ** 0.5) + 1\n        a,b = -1,-1\n        for i in range(upper_bound+1 , 0,-1):\n            if (num+1) % i == 0:\n                first = i\n                last = (num+1)// first\n                if minimum > abs(first-last):\n                    a = first\n                    b = last\n                    minimum = abs(a-b)\n            if (num+2) % i == 0:\n                first = i\n                last = (num+2) // first\n                if minimum > abs(first-last):\n                    a = first\n                    b = last\n                    minimum = abs(a-b)\n        return [a,b]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        if not num:\n            return []\n        \n        for i in range(int(sqrt(num+2)), 0, -1):\n            \n            if not (num+1) % i:\n                return([i, (num+1)//i])\n            \n            if not(num+2) % i:\n                return([i, (num+2)//i])", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        sqrt = int(num ** (0.5))+1\n        for i in range(sqrt, 0, -1):\n            j1 = (num+1) // i\n            j2 = (num+2) // i\n            d1 = d2 = sys.maxsize\n            if j1 * i == num+1:\n                d1 = abs(j1-i)\n            if j2 * i == num+2:\n                d2 = abs(j2-i)\n            if d1 != sys.maxsize or d2 != sys.maxsize:\n                return [j1, i] if d1 < d2 else [j2, i]\n        return []            \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        # for num\n        a = floor((num+2)**0.5)\n        while a > 0:\n            n = 0\n            a2 = a**2\n            if mod(num+1-a2,a)==0:\n                return [a, a + int((num+1-a2)/a)]\n            if mod(num+2-a2,a)==0:\n                return [a, a + int((num+2-a2)/a)]\n            #print(a,n1)\n            a -= 1\n            \n        \n", "import math\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        d=num\n        s = math.ceil(math.sqrt(num))\n        while s>0:\n            if s*(num//s)==num+1 or s*(num//s)==num+2:\n                return [s,num//s]\n            elif s*(num//s +1)==num+1 or s*(num//s +1)==num+2:\n                return [s,num//s+1]\n            s-=1\n        return [1,num]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        # for num\n        a = floor((num+2)**0.5)\n        n1 = None\n        while a > 0:\n            n = 0\n            a2 = a**2\n            if mod(num+1-a2,a)==0:\n                return [a, a + int((num+1-a2)/a)]\n            if mod(num+2-a2,a)==0:\n                return [a, a + int((num+2-a2)/a)]\n            #print(a,n1)\n            a -= 1\n            \n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        def getDiv(n):\n            d1s = 1\n            d2s = n\n            s = n - 1\n            \n            d1 = 1\n            d2 = n\n            \n            while d1 <= d2:\n                d1 += 1\n                if n % d1 == 0:\n                    d1s = d1\n                    d2s = n // d1\n                d2 = n / d1\n            \n            return (d1s,d2s)\n        \n        v1,v2 = getDiv(num+1)\n        z1,z2 = getDiv(num+2)\n        \n        vdif = v2 - v1\n        zdif = z2 - z1\n        \n        print((v1,v2,z1,z2))\n        print((vdif,zdif))\n        \n        if vdif > zdif:\n            return [z1,z2]\n        else:\n            return [v1,v2]\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        cd1 = self.closestDivisorWithProduct(num+1)\n        cd2 = self.closestDivisorWithProduct(num+2)\n        if cd1 == None:\n            return cd2\n        elif cd2 == None:\n            return cd1\n        if abs(cd1[0]-cd1[1]) < abs(cd2[0]-cd2[1]):\n            return cd1\n        else:\n            return cd2\n        \n    def closestDivisorWithProduct(self, num):\n        divisors = [(i, num // i) for i in range(1, int(num**0.5)+1) if num % i == 0]\n        minPair = None\n        minDiff = num\n        for a, b in divisors:\n            if a * b != num:\n                continue\n            if abs(a-b) < minDiff:\n                minPair = (a,b)\n                minDiff = abs(a-b)\n        return minPair", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        nums = [num + 1, num + 2]\n        pair = (1, num+1)\n        seen = collections.defaultdict(bool)\n\n        for i,num in enumerate(nums):\n            for j in range(1, int(sqrt(num))+1):\n                if seen[j]:\n                    continue\n\n                if num % j == 0:\n                    seen[num // j] = True\n                    if abs(pair[0] - pair[1]) > abs(j - num // j):\n                        pair = (j, num // j)\n        return pair", "class Solution:\n\\tdef closestDivisors(self, num: int) -> List[int]:\n\\t\\tfrom math import sqrt\n\\t\\tdef factor(n):\n\\t\\t\\td = int(sqrt(n))\n\\t\\t\\tif d*d == n:\n\\t\\t\\t\\treturn [d, d]\n\\t\\t\\tdefault = [1, n]\n\\t\\t\\tfor i in range(2, d+1):\n\\t\\t\\t\\tx, m = divmod(n, i)\n\\t\\t\\t\\tif not m:\n\\t\\t\\t\\t\\tdefault = [i, x]\n\\t\\t\\treturn default\n\\t\\tx = factor(num+1)\n\\t\\ty = factor(num+2)\n\\t\\tif abs(x[0] - x[1]) < abs(y[0] - y[1]):\n\\t\\t\\treturn x\n\\t\\treturn y\n\n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        def get_best_divisors(num):\n            ans = [1, num]\n\n            i = 2\n            while i*i <= num:\n                if num % i == 0:\n                    divisor = num // i\n                    if (divisor-i) < ans[1]-ans[0]:\n                        ans = [i, divisor]\n                i += 1\n            return ans\n\n        n_plus1_cand = get_best_divisors(num+1)\n        diff1 = n_plus1_cand[1] - n_plus1_cand[0]\n        if diff1 == 0:\n            return n_plus1_cand\n\n        n_plus2_cand = get_best_divisors(num+2)\n        diff2 = n_plus2_cand[1] - n_plus2_cand[0]\n        if diff2 < diff1:\n            return n_plus2_cand\n        return n_plus1_cand", "import math\nclass Solution:\n    def get_closest(self, num):\n        for val in range(int(math.sqrt(num)), 0, -1):\n            if not num % val:\n                return [val, num // val]\n        return [1, num]\n            \n    def closestDivisors(self, num: int) -> List[int]:\n        temp1, temp2 = self.get_closest(num + 1), self.get_closest(num + 2)\n        return temp1 if (abs(temp1[0] - temp1[1]) < abs(temp2[0] - temp2[1])) else temp2", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        def find_closest(cur):\n            nonlocal mini\n            nonlocal ans\n            \n            y = 1\n            while y*y <= (cur+2):\n                mod = cur%y\n                if(not mod):\n                    other = cur//y\n                    if((other - y) < mini):\n                        mini = other - y\n                        ans = [y, other]\n                elif((mod + 1) == y):\n                    other = (cur+1)//y\n                    if((other - y) < mini):\n                        mini = other - y\n                        ans = [y, other]\n                y += 1\n        \n        mini = float('inf')\n        ans = None\n        \n        find_closest(num+1)\n\n        return ans", "from math import sqrt\nfrom typing import List\n\n\nclass Solution:\n    def findDivisor(self, num):\n        min_gap = num\n        min_gap_saved = []\n        for i in range(int(sqrt(num)), 0, -1):\n            if num % i == 0:\n                gap = abs(i - num // i)\n                if gap < min_gap:\n                    min_gap = gap\n                    min_gap_saved = sorted([i, num // i])\n        return min_gap_saved\n\n    def closestDivisors(self, num: int) -> List[int]:\n        a, b = self.findDivisor(num + 1)\n        c, d = self.findDivisor(num + 2)\n        if b - a > d - c:\n            return [c, d]\n        else:\n            return [a, b]\n\n\ns = Solution()\nprint((s.closestDivisors(8)))\nprint((s.closestDivisors(123)))\nprint((s.closestDivisors(999)))\nprint((s.closestDivisors(170967091)))\n", "class Solution:\n    def solve(self,x):\n        a = max(1, int(math.sqrt(x)) )\n        while (a*(x//a))!=x:\n            a = max(1, a-1 )\n        return [a,x//a]\n    def closestDivisors(self, x):\n        a,b = self.solve(x+1)\n        if a==b:\n            return [a,b]\n        c,d = self.solve(x+2)\n        return [a,b] if (b-a)<=(d-c) else [c,d]", "class Solution:\n    def solve(self,x):\n        a = max(1, int(math.sqrt(x)) )\n        while (a*(x//a))!=x:\n            a = max(1, a-1 )\n        return [a,x//a]\n    def closestDivisors(self, x):\n        a,b = self.solve(x+1)\n        c,d = self.solve(x+2)\n        return [a,b] if (b-a)<=(d-c) else [c,d]", "class Solution:\n    def solve(self,x):\n        a = max(1, int(math.sqrt(x)) )\n        b = x//a\n        while (a*b)!=x:\n            a = max(1, a-1 )\n            b = x//a\n        return [a,b]\n    def closestDivisors(self, x):\n        a,b = self.solve(x+1)\n        c,d = self.solve(x+2)\n        return [a,b] if (b-a)<=(d-c) else [c,d]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        x, y = self.get_factors(num+1)\n        z, t = self.get_factors(num+2)\n        return [x, y] if abs(x-y) <= abs(z-t) else [z, t]\n    \n    def get_factors(self, n):\n        y = n\n        for x in range(1, int(sqrt(n))+1):\n            y = int(n/x) if (n/float(x)).is_integer() else y\n\n        return int(n/y), y", "import math\ndef difun(num):\n    ans=num\n    n1=0\n    n2=0\n    for i in range(int(math.sqrt(num)),0,-1):\n        abc=abs(i-(num//i))\n        if(num%i==0 and abc<ans):\n            ans=abc\n            n1=i\n            n2=num//i\n    return ans,n1,n2\nclass Solution:\n    \n    def closestDivisors(self, num: int) -> List[int]:\n        a,b,c=difun(num+1)\n        print(a,b,c)\n        d,e,f=difun(num+2)\n        print(d,e,f)\n        if(a<d):return [b,c]\n        return [e,f]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        closestOne = self.findClosestProduct(num+1)\n        closestTwo = self.findClosestProduct(num+2)\n        differenceOne = abs(closestOne[0]-closestOne[1])\n        differenceTwo = abs(closestTwo[0]-closestTwo[1])\n        if differenceOne > differenceTwo:\n            return closestTwo\n        else:\n            return closestOne\n    def findClosestProduct(self,num):\n        ##we start from floor of sqrt(num) and go down.\n        for i in range(int(math.sqrt(num)),0,-1):\n            if num%i == 0:\n                return [i,num//i]\n", "def findDivisors(n):\n    res = []\n    i = 1\n    while i <= sqrt(n):\n        if n % i == 0:\n            res.append([i, n//i])\n        i = i + 1\n    return res\n\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        A = findDivisors(num + 1)\n        B = findDivisors(num + 2)\n\n        return A[-1] if abs(A[-1][0] - A[-1][1]) < abs(B[-1][0] - B[-1][1]) else B[-1]", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        # primes = self.get_prime_numbers_below(num+3)\n        x, y = self.get_factors(num+1)\n        z, t = self.get_factors(num+2)\n        print((x, y), (z, t))\n        return [x, y] if abs(x-y) <= abs(z-t) else [z, t]\n        \n    def get_prime_numbers_below(self, n):\n        numbers = set([i for i in range(2, n)])\n        for i in range(2, int(sqrt(n))+1):\n            j = max(2, i)\n            while(i*j < n):\n                if i*j in numbers: numbers.remove(i*j)\n                j += 1\n        return list(numbers)\n    \n    def get_factors(self, n):\n        y = n\n        for x in range(1, int(sqrt(n))+1):\n            y = int(n/x) if (n/float(x)).is_integer() else y\n\n        return int(n/y), y", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        cd1 = self.closestDivisorWithProduct(num+1)\n        cd2 = self.closestDivisorWithProduct(num+2)\n        if abs(cd1[0]-cd1[1]) < abs(cd2[0]-cd2[1]):\n            return cd1\n        else:\n            return cd2\n        \n    def closestDivisorWithProduct(self, num):\n        divisors = [(i, num // i) for i in range(1, int(num**0.5)+1) if num % i == 0]\n        minPair = None\n        minDiff = num\n        for a, b in divisors:\n            if a * b != num:\n                continue\n            if abs(a-b) < minDiff:\n                minPair = (a,b)\n                minDiff = abs(a-b)\n        return minPair", "import math\n\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        num1 = num + 1\n        num2 = num + 2\n        divisor = []\n        divisor = self.find_divisors(num1, 1000000001, divisor)\n        divisor = self.find_divisors(num2, abs(divisor[0] - divisor[1]), divisor)\n        return divisor\n        \n    def find_divisors(self, num, difference, divisors):\n        i = 1\n        while i <= math.sqrt(num):\n            if num % i == 0:\n                second = num // i\n                diff = abs(second - i)\n                if diff < difference:\n                    divisors = [i, second]\n            i += 1\n        return divisors\n        \n", "class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \n        def find_closest(cur):\n            nonlocal mini\n            nonlocal ans\n            \n            y = 1\n            while y*y <= cur:\n                if(not cur%y):\n                    other = cur//y\n                    if((other - y) < mini):\n                        mini = other - y\n                        ans = [y, other]\n                y += 1\n        \n        mini = float('inf')\n        ans = None\n        \n        find_closest(num+1)\n        find_closest(num+2)\n\n        return ans"]
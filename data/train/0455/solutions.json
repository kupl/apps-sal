["from collections import deque\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        grids = targetGrid\n        num_to_range = dict()\n        for i, row in enumerate(targetGrid):\n            for j, val in enumerate(row):\n                if val not in num_to_range:\n                    # up, down, left, right\n                    num_to_range[val] = [i, i, j, j]\n                num_to_range[val][0] = min(num_to_range[val][0], i)\n                num_to_range[val][1] = max(num_to_range[val][1], i)\n                num_to_range[val][2] = min(num_to_range[val][2], j)\n                num_to_range[val][3] = max(num_to_range[val][3], j)\n        #print(num_to_range)\n        \n        m = len(grids)\n        n = len(grids[0])\n        grid_list = [[list() for j in range(n)] for i in range(m)]\n        for num, val in list(num_to_range.items()):\n            for i in range(val[0], val[1]+1):\n                for j in range(val[2], val[3]+1):\n                    grid_list[i][j].append(num)\n\n        paths = {val: set() for val in list(num_to_range)}\n        for i, row in enumerate(targetGrid):\n            for j, val in enumerate(row):\n                for parent in grid_list[i][j]:\n                    if parent != val:\n                        paths[parent].add(val)\n                    \n        parent_counter = {val: 0 for val in list(num_to_range)}\n        for parent, childs in list(paths.items()):\n            for child in childs:\n                parent_counter[child] += 1\n        \n        queue = deque()\n        for child, cnt in list(parent_counter.items()):\n            if cnt == 0:\n                queue.append(child)\n        \n        seen = set()\n        while queue:\n            parent = queue.popleft()\n            seen.add(parent)\n            for child in paths[parent]:\n                parent_counter[child] -= 1\n                if parent_counter[child] == 0:\n                    queue.append(child)\n                \n        \n        \n        return len(seen) == len(num_to_range)\n                \n", "SIDE_LEFT = 'left'\nSIDE_RIGHT = 'right'\nSIDE_TOP = 'top'\nSIDE_BOTTOM = 'bottom'\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        \n        # Step 1: Get the set of the different colours being used\n        colour_set = set()\n        for row in targetGrid:\n            for cell in row:\n                colour_set.add(cell)\n        \n        # Step 2: Determine the size of each rectangle and the colours that overlap\n        colour_overlap_info = self.get_colour_boundaries_and_overlap(targetGrid, colour_set)\n        #print(colour_set, colour_overlap_info)\n\n        # Step 3: Loop over the overlapping info. With each pass, print from the last colours downward. In this way, we'll determine\n        # which colours we will print going backwards. If we can't print a colour underneath in an iteration, we've failed\n        remaining_colours = colour_set.copy()\n        untangled_colours = set()\n        while remaining_colours:\n            new_untangled_colours = set()\n            for colour in remaining_colours:\n                # Remove any colours that have been untangled\n                colour_overlap_info[colour] -= untangled_colours\n                if len(colour_overlap_info[colour]) == 0:\n                    # We just untangled this one!\n                    new_untangled_colours.add(colour)\n            \n            # Check if we've untangled anything new. If not, exit\n            #print(new_untangled_colours)\n            if new_untangled_colours:\n                untangled_colours |= new_untangled_colours  # Add them to the full set\n                remaining_colours -= new_untangled_colours  # Remove them from the full list\n            else:\n                break\n        \n        return len(remaining_colours) == 0  # If we've untangled everything, there are no remaining colours and it can be printed\n                    \n        \n    def get_colour_boundaries_and_overlap(self, targetGrid, colour_set):\n        # Determine the size of each rectangle and the colours that overlap\n        colours_info = {}\n        for colour in colour_set:\n            \n            # Get the boundaries\n            boundaries = {}\n            for row_index, row in enumerate(targetGrid):\n                for col_index, cell in enumerate(row):\n                    if cell == colour:\n                        # Update the boundaries\n                        if not boundaries:\n                            # Initialize\n                            boundaries = {\n                                SIDE_LEFT: col_index,\n                                SIDE_RIGHT: col_index,\n                                SIDE_TOP: row_index,\n                                SIDE_BOTTOM: row_index\n                            }\n                        else:\n                            # Update the boundaries. Note that top can't move but left can\n                            if boundaries[SIDE_LEFT] > col_index:\n                                boundaries[SIDE_LEFT] = col_index\n                            if boundaries[SIDE_RIGHT] < col_index:\n                                boundaries[SIDE_RIGHT] = col_index\n                            if boundaries[SIDE_BOTTOM] < row_index:\n                                boundaries[SIDE_BOTTOM] = row_index\n            #print(colour, boundaries)\n            \n            # Now that we have the boundaries, get the colours inside them\n            overlapping_colours = set()\n            for row_index in range(boundaries[SIDE_TOP], boundaries[SIDE_BOTTOM] + 1):\n                for col_index in range(boundaries[SIDE_LEFT], boundaries[SIDE_RIGHT] + 1):\n                    cell = targetGrid[row_index][col_index]\n                    if cell != colour:\n                        overlapping_colours.add(cell)\n            \n            # Save the data\n            colours_info[colour] = overlapping_colours\n        \n        return colours_info\n        \n", "class Solution:\n    from collections import defaultdict, Counter\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        shapes = {}  # color: [min_r, max_r, min_c, max_c]\n        \n        for i, row in enumerate(targetGrid):\n            for j, color in enumerate(row):\n                if color not in shapes:\n                    shapes[color] = [i, i, j, j]\n                else:\n                    shapes[color][0] = min(shapes[color][0], i)\n                    shapes[color][1] = max(shapes[color][1], i)\n                    shapes[color][2] = min(shapes[color][2], j)\n                    shapes[color][3] = max(shapes[color][3], j)\n                    \n        edges = defaultdict(set)\n        \n        for color, [min_r, max_r, min_c, max_c] in list(shapes.items()):\n            for r in range(min_r, max_r + 1):\n                for c in range(min_c, max_c + 1):\n                    if targetGrid[r][c] != color:\n                        edges[color].add(targetGrid[r][c])\n                        \n        deps = Counter()\n        for _, ts in list(edges.items()):\n            for c in ts:\n                deps[c] += 1\n                \n        layer = [c for c in list(shapes.keys()) if not deps[c]]\n        while layer:\n            new_layer = []\n            for c in layer:\n                for t in edges[c]:\n                    deps[t] -= 1\n                    if not deps[t]:\n                        new_layer.append(t)\n            layer = new_layer\n        \n        return all(not v for c, v in list(deps.items()))\n                \n", "class Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        a = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\n        source = [[0] * len(targetGrid[0]) for _ in targetGrid]\n        for i in range(len(targetGrid)):\n            for j in range(len(targetGrid[i])):\n                a[targetGrid[i][j]] = (min(a[targetGrid[i][j]][0], j), min(a[targetGrid[i][j]][1], i), max(a[targetGrid[i][j]][2], j), max(a[targetGrid[i][j]][3], i))\n        gr = defaultdict(set)\n        for p in range(len(a)):\n            x, y, z, t = a[p]\n            if x != math.inf:\n                for i in range(y, t + 1):\n                    for j in range(x, z + 1):\n                        if targetGrid[i][j] != p:\n                            gr[p].add(targetGrid[i][j])\n        visited = set()\n        inp = set()\n        def dfs(k):\n            inp.add(k)\n            for x in gr[k]:\n                if x in inp:\n                    return False\n                elif x not in visited and not dfs(x):\n                    return False\n            inp.remove(k)\n            visited.add(k)\n            return True\n        for i in range(61):\n            if i not in visited and not dfs(i):\n                return False\n        return True\n", "class Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        \n        top = defaultdict(lambda: float('inf'))\n        bottom = defaultdict(lambda: -1)\n        \n        left = defaultdict(lambda: float('inf'))\n        right = defaultdict(lambda: -1)\n        \n        for row in range(len(targetGrid)):\n            for col in range(len(targetGrid[row])):\n                color = targetGrid[row][col]\n                \n                top[color] = min(top[color], row)\n                bottom[color] = max(bottom[color], row)\n                \n                left[color] = min(left[color], col)\n                right[color] = max(right[color], col)\n                \n        edges = defaultdict(list)\n        \n        for row in range(len(targetGrid)):\n            for col in range(len(targetGrid[row])):\n                color = targetGrid[row][col]\n                \n                for otherColor in top:\n                    if color != otherColor and top[otherColor] <= row <= bottom[otherColor] and left[otherColor] <= col <= right[otherColor]:\n                        edges[otherColor].append(color)\n        \n        # detect if there's a cycle in directed graph\n        nodestates = [0 for _ in range(61)] # 0 not visited, 1 being visited, 2 done\n        \n        def dfs(current):\n            nodestates[current] = 1\n            \n            for neighbor in edges[current]:\n                if nodestates[neighbor] == 1:\n                    # detect an edge\n                    return True\n                elif nodestates[neighbor] == 0:\n                    dfs(neighbor)\n            \n            nodestates[current] = 2\n        \n        cycleDetected = False\n        for node in top:\n            if nodestates[node] == 0:\n                if dfs(node):\n                    cycleDetected = True\n                    break\n        \n        return not cycleDetected\n        \n        \n                        \n", "class Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        # FIND RECTANGLE BOUNDARIES FOR EACH COLOR\n        boundaries = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\n        for i in range(len(targetGrid)):\n            for j in range(len(targetGrid[i])):\n                color = targetGrid[i][j]\n                min_i, min_j, max_i, max_j = boundaries[color]\n                boundaries[color] = (min(min_i, i), min(min_j, j), max(max_i, i), max(max_j, j))\n\n        # BUILD GRAPH\n        graph = defaultdict(set)\n        for color in range(len(boundaries)):\n            min_i, min_j, max_i, max_j = boundaries[color]\n            if min_i != math.inf:\n                for i in range(min_i, max_i + 1):\n                    for j in range(min_j, max_j + 1):\n                        if targetGrid[i][j] != color:\n                            graph[color].add(targetGrid[i][j])\n\n        # DETECT CYCLES IN GRAPH\n        visited = set()\n        in_progress = set()\n        def dfs(source):\n            in_progress.add(source)\n            for vertex in graph[source]:\n                if (vertex in in_progress) or (vertex not in visited and not dfs(vertex)):\n                    return False\n            in_progress.remove(source)\n            visited.add(source)\n            return True\n\n        for color in range(61):\n            if color not in visited and not dfs(color):\n                return False\n        return True", "# 1591. Strange Printer II\n\ndef walk (grid):\n    for i, row in enumerate (grid):\n        for j, elem in enumerate (row):\n            yield ((i, j), elem)\n\ndef extend (bound, ij):\n    i, j = ij\n    if bound is None:\n        return (ij, ij)\n    else:\n        ((i0, j0), (i1, j1)) = bound\n        return (\n            (min (i0, i), min (j0, j)),\n            (max (i1, i), max (j1, j)),\n        )\n\ndef contains (bound, ij):\n    i, j = ij\n    ((i0, j0), (i1, j1)) = bound\n    return i0 <= i <= i1 and j0 <= j <= j1\n\ndef has_toposort (prereq):\n    roots = [x for x in prereq if not prereq[x]]\n    while roots:\n        r = roots.pop ()\n        del prereq[r]\n        for c in prereq:\n            if r in prereq[c]:\n                prereq[c].remove (r)\n                if not prereq[c]:\n                    roots.append (c)\n    return not prereq\n\ndef printable (grid):\n    m, n = len (grid), len (grid[0])\n    assert m >= 1 and n >= 1\n\n    colors = {c for row in grid for c in row}\n    bounds = {c: None for c in colors}\n\n    for ((i, j), c) in walk (grid):\n        bounds[c] = extend (bounds[c], (i, j))\n\n    prereq = {c: set() for c in colors}\n    for ((i, j), c) in walk (grid):\n        for c2 in colors:\n            if c2 == c: continue\n            if contains (bounds[c2], (i, j)):\n                prereq[c].add (c2)\n\n    return has_toposort (prereq)\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        return printable(targetGrid)", "from collections import defaultdict\nclass Solution:\n    def all_same(self, left, right, bottom, top, color):\n        for i in range(bottom, top+1):\n            for j in range(left, right+1):\n                if self.grid[i][j] and self.grid[i][j] != color:\n                    return False\n        return True\n    \n    def fill(self, left, right, bottom, top):\n        for i in range(bottom, top+1):\n            for j in range(left, right+1):\n                self.grid[i][j] = 0\n                \n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        self.rect = defaultdict(lambda : [10**9, -10**9, 10**9, -10**9])\n        for i, row in enumerate(targetGrid):\n            for j, color in enumerate(row):\n                self.rect[color][0] = min(self.rect[color][0], j)\n                self.rect[color][1] = max(self.rect[color][1], j)\n                self.rect[color][2] = min(self.rect[color][2], i)\n                self.rect[color][3] = max(self.rect[color][3], i)\n        self.grid = targetGrid\n        while self.rect:\n            for color in self.rect:\n                left, right, bottom, top = self.rect[color]\n                if self.all_same(left, right, bottom, top, color):\n                    self.fill(left, right, bottom, top)\n                    self.rect.pop(color)\n                    break\n            else:         \n                return False\n        return True", "class Solution:\n    def isPrintable(self, A: List[List[int]]) -> bool:\n        m, n = len(A), len(A[0])\n        \n        c = collections.Counter()\n        dic = collections.defaultdict(lambda: [m+n, -1, m + n, -1, 0])\n        seen = set()\n        removed = set()\n        for i, row in enumerate(A):\n            for j, x in enumerate(row):\n                dic[x][0] = min(dic[x][0], i)\n                dic[x][2] = min(dic[x][2], j)\n                dic[x][1] = max(dic[x][1], i)\n                dic[x][3] = max(dic[x][3], j)\n                dic[x][4] += 1\n                seen.add(x)\n        #print(dic)\n        def helper(x):\n            return abs((dic[x][1] - dic[x][0] + 1)*(dic[x][3] - dic[x][2] + 1) - dic[x][4])\n        \n        temp = sorted(seen, key = helper)\n        \n        #print(temp)\n        \n        k = 0\n        #flag = True\n        while len(temp) != len(removed):\n            #flag= False \n            for t in temp:\n                if t in removed: continue\n                if helper(t) == 0:\n                    removed.add(t)\n                    break\n                else:\n                    a, b, c, d, total = dic[t]\n                    flag = True\n                    for i in  range(a, b + 1):\n                        for j in range(c, d + 1):\n                            if A[i][j]!= t and A[i][j] not in removed:\n                                flag = False\n                                break\n                        if not flag:\n                            break\n                    #print(t, flag)\n                    if flag:\n                        removed.add(t)\n                        break\n            else:\n                break\n        return len(temp) == len(removed)\n                        \n\n", "\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        coverage = dict()\n        for y in range(len(targetGrid)):\n            for x in range(len(targetGrid[y])):\n                val = targetGrid[y][x]\n                if val not in coverage:\n                    coverage[val] = (y,x,y,x)\n                else:\n                    asdf = coverage[val]\n                    asdf = ( min(asdf[0],y), min(asdf[1],x), max(asdf[2],y), max(asdf[3],x) )\n                    coverage[val] = asdf\n        print(coverage)\n        before = dict()\n        done = set()\n        for color in coverage:\n            asdf = coverage[color]\n            s = set()\n            for y in range(asdf[0], asdf[2]+1):\n                for x in range(asdf[1] ,asdf[3]+1):\n                    s.add(targetGrid[y][x])\n                if color in s:\n                    s.remove(color)\n            before[color] = s\n        print(before)\n        \n        while len(before) > 0:\n            gotOne = False\n            for color in list(before.keys()):\n                dependencies = before[color]\n                dependencies = dependencies - done\n                if len(dependencies) == 0:\n                    before.pop(color)\n                    done.add(color)\n                    gotOne = True\n                else:\n                    before[color] = dependencies\n            if gotOne == False:\n                return False\n        return True", "import queue\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        color_bounds = {}\n        for i, row in enumerate(targetGrid):\n            for j, color in enumerate(row):\n                if not color in color_bounds:\n                    color_bounds[color] = {'row': [1e6,-1e6], 'col': [1e6,-1e6]}\n                color_bounds[color]['row'][0] = min(color_bounds[color]['row'][0], i)\n                color_bounds[color]['row'][1] = max(color_bounds[color]['row'][1], i)\n                color_bounds[color]['col'][0] = min(color_bounds[color]['col'][0], j)\n                color_bounds[color]['col'][1] = max(color_bounds[color]['col'][1], j)\n        graph = collections.defaultdict(list)\n        degree = Counter()\n        for color, bounds in list(color_bounds.items()):\n            seen = set()\n            for i in range(bounds['row'][0], bounds['row'][1] + 1):\n                for j in range(bounds['col'][0], bounds['col'][1] + 1):\n                    other_color = targetGrid[i][j]\n                    if other_color != color and other_color not in seen:\n                        seen.add(other_color)\n                        graph[other_color].append(color)\n                        degree[color] += 1\n        q = queue.Queue()\n        for color in list(color_bounds.keys()):\n            if degree[color] == 0:\n                q.put(color)\n        processed_nodes = 0\n        while not q.empty():\n            color = q.get()\n            processed_nodes += 1\n            for next_color in graph[color]:\n                degree[next_color] -= 1\n                if degree[next_color] == 0:\n                    q.put(next_color)\n        return processed_nodes == len(color_bounds)\n            \n", "class Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        R = len(targetGrid)\n        C = len(targetGrid[0])\n        WHITE = 0\n        GRAY = 1\n        BLACK = 2\n        boxes = collections.defaultdict(lambda: [61, 61, -1, -1])\n        \n        for r, row in enumerate(targetGrid):\n            for c, v in enumerate(row):\n                boxes[v][0] = min(boxes[v][0], r)\n                boxes[v][1] = min(boxes[v][1], c)\n                boxes[v][2] = max(boxes[v][2], r)\n                boxes[v][3] = max(boxes[v][3], c)\n                \n        graph = { color: set() for color in boxes }\n        \n        for color, (r1, c1, r2, c2) in boxes.items():\n            for r in range(r1, r2 + 1):\n                for c in range(c1, c2 + 1):\n                    if targetGrid[r][c] != color:\n                        graph[color].add(targetGrid[r][c])\n                 \n        state = collections.defaultdict(int)\n        \n        def dfs(u):\n            state[u] = GRAY\n            \n            for v in graph[u]:\n                if state[v] == WHITE:\n                    if not dfs(v):\n                        return False\n                elif state[v] == GRAY:\n                    return False\n                \n            state[u] = BLACK\n            return True\n        \n        for s in graph:\n            if state[s] == WHITE:\n                if not dfs(s):\n                    return False\n                \n        return True", "class Solution:\n    def isPrintable(self,M: List[List[int]]) -> bool:\n        colorA =collections.defaultdict(lambda:[61,61,-1,-1]) # (top, left, bottom, right)\n        for r, row in enumerate(M):\n            for c, color in enumerate(row):\n                colorA[color][0] = min(colorA[color][0], r)\n                colorA[color][1] = min(colorA[color][1], c)\n                colorA[color][2] = max(colorA[color][2], r)\n                colorA[color][3] = max(colorA[color][3], c)\n        graph={color:set() for color in colorA}\n        for color,(top, left, bottom, right) in list(colorA.items()):\n            for r in range(top, bottom + 1):\n                for c in range(left, right+ 1):\n                    if M[r][c] != color:\n                        graph[color].add(M[r][c])\n        W, G, B = 0, 1, 2\n        state = collections.defaultdict(int)\n        def check(node):\n            state[node] = G\n            for nei in graph[node]:\n                if state[nei] == W:\n                    if not check(nei):\n                        return False\n                if state[nei]== G:\n                    return False\n            state[node] = B\n            return True\n        for node in graph:\n            if state[node] == W:\n                if not check(node):\n                    return False\n        return True\n                \n", "class Solution:\n    def isPrintable(self,M: List[List[int]]) -> bool:\n        colorAreas=collections.defaultdict(lambda:[61,61,-1,-1]) #(top, left, bottom, right)\n        for r, row in enumerate(M):\n            for c, color in enumerate(row):\n                colorAreas[color][0] = min(colorAreas[color][0] , r)\n                colorAreas[color][1] = min(colorAreas[color][1] , c)\n                colorAreas[color][2] = max(colorAreas[color][2] , r)\n                colorAreas[color][3] = max(colorAreas[color][3] , c)\n        graph = {color:set() for color in colorAreas}\n        for color, (top, left, bottom, right) in list(colorAreas.items()):\n            for r in range(top, bottom+1):\n                for c in range(left, right+1):\n                    if M[r][c] != color:\n                        graph[color].add(M[r][c])\n        W, G, B  =0, 1, 2\n        state = collections.defaultdict(int)\n        def check(node):\n            state[node] = G\n            for nei in graph[node]:\n                if state[nei]==W:\n                    if not check(nei):\n                        return False\n                if state[nei] == G:\n                    return False\n            state[node] = B\n            return True\n        for node in graph:\n            if state[node] == W:\n                if not check(node):\n                    return False\n        return True\n        \n", "class Grid(object):\n    def __init__(self):\n        self.ps = set()\n        self.lx = 100\n        self.ly = 100\n        self.rx = 0\n        self.ry = 0\n    def add(self, x, y):\n        self.ps.add((x, y))\n        self.lx = min(self.lx, x)\n        self.ly = min(self.ly, y)\n        \n        self.rx = max(self.rx, x)\n        self.ry = max(self.ry, y)\n    \n    def is_full(self):\n        return len(self.ps) == (self.rx-self.lx+1)*(self.ry-self.ly+1)\n    \n    def overlap(self, grid):\n        # self on the left grid\n        flag = self.rx < grid.lx\n        # self on the upper grid\n        flag = flag and self.ry > grid.ly\n        # self on the right grid\n        flag = flag and self.lx > grid.rx\n        # self on the bottom grid\n        flag = flag and self.ly < grid.ry\n        return not flag\n    \n    def contain(self, grid):\n        if not self.overlap(grid): return False\n        for (x, y) in grid.ps:\n            if self.lx <= x <= self.rx and self.ly <= y <= self.ry: return True\n        return False\n    \n        \n    def __str__(self):\n        return '({0.lx}, {0.ly}), ({0.rx}, {0.ry})'.format(self)\n    \nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        grids = defaultdict(Grid)\n        for x, row in enumerate(targetGrid):\n            for y, c in enumerate(row):\n                grids[c].add(x, y)\n                \n        colors = grids.keys()\n\n        graph, degree = defaultdict(set), defaultdict(int)\n        vis = set()\n        for c1 in colors:\n            for c2 in colors:\n                if c1 == c2 or (c1, c2) in vis: continue\n                vis.add((c1, c2))\n                if grids[c1].contain(grids[c2]):\n                    graph[c1].add(c2)\n                    degree[c2] += 1\n              \n       \n        # for c in colors:\n#             print(c, grids[c])         \n#         print(graph)\n#         print(degree)\n        \n        q = []\n        for c in colors: \n            if degree[c] == 0: \n                q.append(c)\n        \n        vis = []\n        while q:\n            c1 = q.pop()\n            vis.append(c1)\n            for c2 in graph[c1]:\n                degree[c2] -= 1\n                if degree[c2] == 0: q.append(c2)\n        \n        # print(vis)\n        return len(vis) == len(colors)", "class Solution:\n    def isPrintable(self, target: List[List[int]]) -> bool:\n        TOP, LEFT, BOTTOM, RIGHT = 0, 1, 2, 3\n        M, N = len(target), len(target[0])\n        boxes = defaultdict(lambda: [math.inf, math.inf, -math.inf, -math.inf])\n        for i, row in enumerate(target):\n            for j, x in enumerate(row):\n                boxes[x][TOP] = min(boxes[x][TOP], i)\n                boxes[x][LEFT] = min(boxes[x][LEFT], j)\n                boxes[x][BOTTOM] = max(boxes[x][BOTTOM], i)\n                boxes[x][RIGHT] = max(boxes[x][RIGHT], j)\n        graph = {color: set() for color in boxes}\n        for color, (i1, j1, i2, j2) in boxes.items():\n            for i in range(i1, i2 + 1):\n                for j in range(j1, j2 + 1):\n                    if target[i][j] != color:\n                        graph[color].add(target[i][j])\n        WHITE, GRAY, BLACK = 0, 1, 2\n        color = defaultdict(int)\n\n        def dfs(u):\n            color[u] = GRAY\n            for v in graph[u]:\n                if color[v] == GRAY:\n                    return False\n                elif color[v] == WHITE and not dfs(v):\n                    return False\n            color[u] = BLACK\n            return True\n\n        return all(color[u] == BLACK or dfs(u) for u in graph)", "class Component:\n    def __init__(self, color):\n        self.cells = set()\n        self.color = color\n        self.min_row = float('inf')\n        self.max_row = float('-inf')\n        self.min_col = float('inf')\n        self.max_col = float('-inf')\n        \n    def add_cell(self, u):\n        self.cells.add(u)\n        self.min_row = min(self.min_row, u[0])\n        self.max_row = max(self.max_row, u[0])\n        self.min_col = min(self.min_col, u[1])\n        self.max_col = max(self.max_col, u[1])\n\n    def remove_cell(self, u):\n        self.cells.remove(u)\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        grid = targetGrid\n        \n        def discover_components():\n            components = {}\n            for i in range(len(grid)):\n                for j in range(len(grid[i])):\n                    color = grid[i][j]\n                    if color not in components:\n                        components[color] = Component(color)\n                    components[color].add_cell((i, j))\n            return components\n        \n        def is_rectangular(c):\n            for i in range(c.min_row, c.max_row + 1):\n                for j in range(c.min_col, c.max_col + 1):\n                    if grid[i][j] != c.color:\n                        return False\n            return True\n        \n        def replace_holes(cx, marked_for_removal):\n            # Go through cells from components marked for removal and see if the\n            # holes in cx could be replaced with the cells that we will remove\n            for i in range(cx.min_row, cx.max_row + 1):\n                hole_colors = set()\n                for j in range(cx.min_col, cx.max_col + 1):\n                    if grid[i][j] == cx.color:\n                        continue\n                    if grid[i][j] not in marked_for_removal:\n                        return\n\n            for i in range(cx.min_row, cx.max_row + 1):\n                for j in range(cx.min_col, cx.max_col + 1):\n                    if grid[i][j] != cx.color:\n                        cx.add_cell((i, j))\n                        hc = grid[i][j]\n                        marked_for_removal[hc].remove_cell((i, j))\n                        if len(marked_for_removal[hc].cells) == 0:\n                            del(marked_for_removal[hc])\n                        grid[i][j] = cx.color\n\n        components = discover_components()\n        marked_for_removal = {}\n        while len(components) > 0:\n            found_new_comp_to_remove = False\n            for c in components:\n                if is_rectangular(components[c]):\n                    marked_for_removal[c] = components[c]\n                    del(components[c])\n                    found_new_comp_to_remove = True\n                    break\n            if not found_new_comp_to_remove:\n                return False\n            \n            for c in list(components.keys()):\n                replace_holes(components[c], marked_for_removal)\n\n        return True\n", "class Component:\n    def __init__(self, color):\n        self.cells = set()\n        self.color = color\n        self.min_row = float('inf')\n        self.max_row = float('-inf')\n        self.min_col = float('inf')\n        self.max_col = float('-inf')\n        \n    def add_cell(self, u):\n        self.cells.add(u)\n        self.min_row = min(self.min_row, u[0])\n        self.max_row = max(self.max_row, u[0])\n        self.min_col = min(self.min_col, u[1])\n        self.max_col = max(self.max_col, u[1])\n\n    def remove_cell(self, u):\n        self.cells.remove(u)\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        grid = targetGrid\n        \n        def discover_components():\n            components = {}\n            for i in range(len(grid)):\n                for j in range(len(grid[i])):\n                    color = grid[i][j]\n                    if color not in components:\n                        components[color] = Component(color)\n                    components[color].add_cell((i, j))\n            return components\n        \n        def is_complete_rect(c):\n            for i in range(c.min_row, c.max_row + 1):\n                for j in range(c.min_col, c.max_col + 1):\n                    if grid[i][j] != c.color:\n                        return False\n            return True\n        \n        def replace_holes(cx, marked_for_removal):\n            # Go through cells from components marked for removal and see if the\n            # holes in cx could be replaced with the cells that we will remove\n            for i in range(cx.min_row, cx.max_row + 1):\n                hole_colors = set()\n                for j in range(cx.min_col, cx.max_col + 1):\n                    if grid[i][j] == cx.color:\n                        continue\n                    if grid[i][j] not in marked_for_removal:\n                        return\n\n            for i in range(cx.min_row, cx.max_row + 1):\n                for j in range(cx.min_col, cx.max_col + 1):\n                    if grid[i][j] != cx.color:\n                        cx.add_cell((i, j))\n                        hc = grid[i][j]\n                        marked_for_removal[hc].remove_cell((i, j))\n                        if len(marked_for_removal[hc].cells) == 0:\n                            del(marked_for_removal[hc])\n                        grid[i][j] = cx.color\n\n        components = discover_components()\n        marked_for_removal = {}\n        while len(components) > 0:\n            found_new_comp_to_remove = False\n            for c in components:\n                if is_complete_rect(components[c]):\n                    marked_for_removal[c] = components[c]\n                    del(components[c])\n                    found_new_comp_to_remove = True\n                    break\n            if not found_new_comp_to_remove:\n                return False\n            \n            for c in list(components.keys()):\n                replace_holes(components[c], marked_for_removal)\n\n        return True\n", "class Component:\n    def __init__(self, color):\n        self.cells = set()\n        self.color = color\n        self.min_row = float('inf')\n        self.max_row = float('-inf')\n        self.min_col = float('inf')\n        self.max_col = float('-inf')\n        \n    def add_cell(self, u):\n        self.cells.add(u)\n        self.min_row = min(self.min_row, u[0])\n        self.max_row = max(self.max_row, u[0])\n        self.min_col = min(self.min_col, u[1])\n        self.max_col = max(self.max_col, u[1])\n\n    def remove_cell(self, u):\n        self.cells.remove(u)\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        grid = targetGrid\n        \n        def discover_components():\n            components = {}\n            for i in range(len(grid)):\n                for j in range(len(grid[i])):\n                    color = grid[i][j]\n                    if color not in components:\n                        components[color] = Component(color)\n                    components[color].add_cell((i, j))\n            return components\n        \n        def is_complete_rect(c):\n            for i in range(c.min_row, c.max_row + 1):\n                for j in range(c.min_col, c.max_col + 1):\n                    if grid[i][j] != c.color:\n                        return False\n            return True\n        \n        def replace_holes(cx, marked_for_removal):\n            # Go through cells from components marked for removal and see if the\n            # holes in cx could be replaced with the cells that we will remove\n            for i in range(cx.min_row, cx.max_row + 1):\n                hole_colors = set()\n                for j in range(cx.min_col, cx.max_col + 1):\n                    if grid[i][j] == cx.color:\n                        continue\n                    if grid[i][j] not in marked_for_removal:\n                        return\n\n            for i in range(cx.min_row, cx.max_row + 1):\n                for j in range(cx.min_col, cx.max_col + 1):\n                    if grid[i][j] != cx.color:\n                        cx.add_cell((i, j))\n                        hc = grid[i][j]\n                        marked_for_removal[hc].remove_cell((i, j))\n                        if len(marked_for_removal[hc].cells) == 0:\n                            del(marked_for_removal[hc])\n                        grid[i][j] = cx.color\n\n        components = discover_components()\n        marked_for_removal = {}\n        while len(components) > 0:\n            found_rect_to_remove = False\n            for c in components:\n                if is_complete_rect(components[c]):\n                    marked_for_removal[c] = components[c]\n                    del(components[c])\n                    found_rect_to_remove = True\n                    break\n            if not found_rect_to_remove:\n                return False\n            \n            for c in list(components.keys()):\n                replace_holes(components[c], marked_for_removal)\n\n        return True\n"]
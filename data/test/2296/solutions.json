["import math;\n#\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u043a\u0438 \u043f\u043e \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c \u0446\u0435\u043d\u0442\u0440\u0430, \u0443\u0433\u043b\u0443, \u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0446\u0435\u043d\u0442\u0440\u0430\ndef getCoordinate(gx, gy, alpha, x, y):\n    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);\n    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);\n    return x1, y1\n#\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0443\u0433\u043b\u0430, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0434\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0442\u043e\u0447\u043a\u0443 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438 x, y,\n#\u0447\u0442\u043e\u0431\u044b \u043e\u043d\u0430 \u043e\u043a\u0430\u0437\u0430\u043b\u0430\u0441\u044c \u043f\u0440\u044f\u043c\u043e \u043d\u0430\u0434 gx, gy\ndef getAngle(gx, gy, x, y):\n    x=x-gx;\n    y=y-gy;\n    cos=x/math.sqrt(x**2+y**2);\n    alpha=math.acos(cos);\n    if y<0:\n        alpha=-alpha;\n    return math.pi/2-alpha;\nn, q = list(map(int, input().split(' ')));\nx=[0]*n;\ny=[0]*n;\nfor i in range(n):\n    x[i], y[i]=list(map(int, input().split(' ')));\nr=[0]*q;\nf=[0]*q;\nt=[0]*q;\nv=[0]*q;\nfor i in range(q):\n    l=list(map(int, input().split(' ')));\n    r[i]=l[0];\n    if r[i]==1:\n        f[i]=l[1]-1;\n        t[i]=l[2]-1;\n    else:\n        v[i]=l[1]-1;\ngx=0;\ngy=0;\ns=0;\nfor i in range(n):\n    ip=i+1;\n    if ip==n:\n        ip=0;\n    ds=x[i]*y[ip]-x[ip]*y[i];\n    s+=ds;\n    gx+=(x[i]+x[ip])*ds;\n    gy+=(y[i]+y[ip])*ds;\ns/=2;\ngx/=6*s;\ngy/=6*s;\nangles=[0]*n;\nfor i in range(n):\n    angles[i]=getAngle(gx, gy, x[i], y[i]);\nfor i in range(n):\n    x[i]-=gx;\n    y[i]-=gy;\nalpha=0;\n#print('pos',gx, gy, alpha);\n#\u0412\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u0435\u043a \u0431\u0443\u0434\u0435\u043c \u043f\u043e \u0446\u0435\u043d\u0442\u0440\u0443 \u043c\u0430\u0441\u0441 \u0438 \u0443\u0433\u043b\u0443\n#\u0423\u0433\u043e\u043b - \u043f\u043e\u0432\u043e\u0440\u043e\u0442 \u043f\u0440\u043e\u0442\u0438\u0432 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u0432\u043e\u043a\u0440\u0443\u0433 \u0446\u0435\u043d\u0442\u0440\u0430 \u043c\u0430\u0441\u0441\nfix={0, 1}\nfor i in range(q):\n    if r[i]==2:\n        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);\n        print(\"%.6f %.6f\"%(currX, currY))\n    else:\n        if len(fix)==2:\n            fix.remove(f[i]);\n        #print('remove',f[i])\n        #j - \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0432 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0435\n        for j in fix:\n            #print(j);\n            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);\n            #print('fix:', currX, currY)\n            #dalpha=getAngle(gx, gy, currX, currY);\n            #alpha+=dalpha;\n            alpha=angles[j];\n            #\u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b g, \u043d\u0443\u043d\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0435\u0435 \u043d\u0430 \u0443\u0433\u043e\u043b\n            #dalpha \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e currX, currY\n            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);\n            \n            #print('pos',gx, gy, alpha/math.pi)\n        fix.add(t[i]);\n        \n", "#!/usr/bin/env python3\n\n\nfrom math import hypot\n\n[n, q] = list(map(int, input().strip().split()))\nxys = [tuple(map(int, input().strip().split())) for _ in range(n)]\nqis = [tuple(map(int, input().strip().split())) for _ in range(q)]\n\ndxys = [(xys[(i + 1) % n][0] - xys[i][0], xys[(i + 1) % n][1] - xys[i][1]) for i in range(n)]\n\nS = 3 * sum((x*dy - y*dx) for (x, y), (dx, dy) in zip(xys, dxys))\nSx = sum((dx + 2*x) * (x*dy - y*dx) for (x, y), (dx, dy) in zip(xys, dxys))\nSy = sum((dy + 2*y) * (x*dy - y*dx) for (x, y), (dx, dy) in zip(xys, dxys))\n#Sy = sum((2*dx*dy + 3*x*dx + 3*x*dy + 6*x*y)*dy for (x, y), (dx, dy) in zip(xys, dxys))\nfor p in [2, 3]:\n\twhile S % p == Sx % p == Sy % p == 0:\n\t\tS //= p\n\t\tSx //= p\n\t\tSy //= p\n\nxyms = [(S*x - Sx, S*y - Sy) for x, y in xys]\nhs = [hypot(x, y) for x, y in xyms]\n\ndef to_coord(x, y):\n\treturn (x + Sx) / S, (y + Sy) / S\n\nhangs = (0, 1)\nhang_on = None\ncx, cy = 0.0, 0.0\n\n# hang on u\ndef get_v(v):\n\tif hang_on is None:\n\t\treturn xyms[v]\n\telse:\n\t\tux, uy = xyms[hang_on]\n\t\tvx, vy = xyms[v]\n\t\th = hs[hang_on]\n\t\treturn ((uy * vx - ux * vy) / h, (ux * vx + uy * vy) / h)\n\n#def ss(v1, v2):\n#\treturn tuple(vi + vj for vi, vj in zip(v1, v2))\n\n#def disp():\n#\tprint ('hangs on', hang_on, 'of', hangs)\n#\tprint ('center', to_coord(cx, cy))\n#\tprint ({i: to_coord(*ss(get_v(i), (cx, cy))) for i in range(n)})\n\t\n#disp()\nfor qi in qis:\n\tif qi[0] == 1:\n\t\t_, f, t = qi  # 1-indexation\n\t\ts = hangs[1 - hangs.index(f - 1)]\n\t\tdx, dy = get_v(s)\n\t\tcx += dx\n\t\tcy += dy - hs[s]\n\t\thang_on = s\n\t\thangs = (s, t - 1)\n#\t\tprint ('{} --> {}'.format(f - 1, t - 1))\n#\t\tdisp()\n\telse:\n\t\t_, v = qi  # 1-indexation\n\t\tdx, dy = get_v(v - 1)\n\t\tprint(*to_coord(cx + dx, cy + dy))\n"]
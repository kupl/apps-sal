["seq = input()\na = []\nfl = True\nz = 0\nfor i in seq:\n    if i == '<' or i == '[' or i == '{' or i == '(':\n        a.append(i)\n    elif i == '>':\n        if len(a) and a[-1] == '<': a.pop()\n        elif len(a) and a[-1] != '<':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\n    elif i == ')':\n        if len(a) and a[-1] == '(': a.pop()\n        elif len(a) and a[-1] != '(':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\n    elif i == ']':\n        if len(a) and a[-1] == '[': a.pop()\n        elif len(a) and a[-1] != '[':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\n    elif i == '}':\n        if len(a) and a[-1] == '{': a.pop()\n        elif len(a) and a[-1] != '{':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\nif len(a): fl = False\nif fl: print(z)\nelse: print('Impossible')", "s = input()\nd = []\nans = 0\nfor f in s:\n    if f in '{[<(':\n        d.append(f)\n    elif f == ')' and d and d[-1] == '(':\n        d.pop()\n    elif f == '}' and d and d[-1] == '{':\n        d.pop()\n    elif f == ']' and d and d[-1] == '[':\n        d.pop()\n    elif f == '>' and d and d[-1] == '<':\n        d.pop()\n    elif not d:\n        print('Impossible')\n        break\n    else:\n        ans += 1\n        d.pop()\nelse:\n    if not d:\n        print(ans)\n    else:\n        print('Impossible')", "s = input()\n\nopen = '[<({'\nclose = ']>)}'\n\nclopen = { ']': '[', '}': '{', '>': '<', ')': '(' }\npopen = []\nc = 0\nfor i in range(len(s)):\n    if s[i] in open:\n        popen.append(s[i])\n    else:\n        if len(popen) == 0:\n            print('Impossible')\n            return\n        p = popen.pop()\n        if clopen[s[i]] != p:\n            c += 1\n\nprint(c if len(popen) == 0 else 'Impossible')\n", "import math\n\ns = input().rstrip()\nn = len(s)\nstack = []\nk = 0\nD = {'(' : 0, '{' : 2, '[' : 4, '<' : 6,\n     ')' : 1, '}' : 3, ']' : 5, '>' : 7}\nfor i in range(n):\n    c = s[i]\n    if D[c]%2 == 0:\n        stack.append(c)\n    elif len(stack) == 0 or D[stack[-1]]%2:\n        print('Impossible')\n        break\n    else:\n        k += (D[c] - D[stack[-1]] != 1)\n        stack.pop()\nelse:\n    print(k if len(stack) == 0 else 'Impossible')\n        \n", "s = input()\nopen = '<', '(', '[', '{'\nclose = '>', ')', ']', '}'\nresp = {close[i]: open[i] for i in (0, 1, 2, 3)}\ncnt = 0\nst = []\nflag = True\nfor c in s:\n    if c in open:\n        st.append(c)\n    elif st and st[-1] == resp[c]:\n        st.pop()\n    elif st:\n        st.pop()\n        cnt += 1\n    else:\n        flag = False\n        break\nif st: flag = False\nprint(cnt if flag else 'Impossible')\n    \n\n", "def solve():\n    S = input()\n\n    P = {\n        '>': '<',\n        ']': '[',\n        ')': '(',\n        '}': '{',\n    }\n\n    stack = []\n    n = 0\n    ans = 0\n    for i, c in enumerate(S):\n        if c in '<[{(':\n            n += 1\n            stack.append(c)\n        else:\n            n -= 1\n            if len(stack) == 0:\n                print('Impossible')\n                return\n            x = stack.pop()\n            if x != P[c]:\n                ans += 1\n\n    if n != 0:\n        print('Impossible')\n        return\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "s2=input()\ndic={'{':1,'}':-1,'<':2,'>':-2,'[':3,']':-3,'(':4,')':-4}\nstack=[]\ncount=0\nn=0\nfor x in s2:\n    if dic[x]<0:\n        if n==0:\n            print(\"Impossible\")\n            quit()\n        if dic[stack[n-1]]+dic[x]!=0:\n            count+=1\n        stack.pop()\n        n=n-1\n    else:\n        stack.append(x)\n        n=n+1\nif n!=0:\n    print(\"Impossible\")\nelse:\n    print(count)\n", "from functools import reduce\nfrom operator import *\nfrom math import *\nfrom sys import *\nfrom string import *\nfrom collections import *\nsetrecursionlimit(10**7)\ndX= [-1, 1, 0, 0,-1, 1,-1, 1]\ndY= [ 0, 0,-1, 1, 1,-1,-1, 1]\nRI=lambda: list(map(int,input().split()))\nRS=lambda: input().rstrip().split()\n#################################################\nval={'<':1, '>':2, '[':1, ']':2, '(':1, ')':2, '{':1, '}':2}\npairs={'<':'>', '[':']','(':')','{':'}'}\ns=input()\nst=[]\nans=0\nfor i in s:\n    if len(st) and val[st[-1]]==val[i]-1:\n        if pairs[st[-1]]!=i:\n            ans+=1\n        st.pop()\n    else:\n        st.append(i)\nprint([ans,\"Impossible\"][len(st)>0])\n", "BRACKETS = \"{ }, [ ], < >, ( )\"\nopeners = dict()\nclosers = dict()\nfor opener, closer in [x.split() for x in BRACKETS.split(\",\")]:\n    openers[opener] = closer\n    closers[closer] = opener\nstack = list()\nimpossible = False\nres = 0\nfor char in input():\n    if char in openers:\n        stack.append(char)\n    else:\n        if not stack:\n            impossible = True\n            break\n        elif stack[-1] != closers[char]:\n            res += 1\n        stack.pop()\nimpossible |= len(stack) > 0\nif impossible:\n    print(\"Impossible\")\nelse:\n    print(res)\n", "stack = []\n\ndef main():\n    s = str(input())\n    open = list(\"<{[(\")\n    close = list(\">}])\")\n\n    answer = 0\n\n    for e in s:\n        if len(stack) == 0:\n            if e in open:\n                stack.append(e)\n            else:\n                print(\"Impossible\")\n                return\n        else:\n            top = len(stack) - 1\n            if e in open:\n                if stack[top] in close:\n                    if open.index(e) != close.index(stack[top]):\n                        answer += 1\n\n                    stack.pop(top)\n                else:\n                    stack.append(e)\n            else:\n                if stack[top] in close:\n                    stack.append(e)\n                else:\n                    if close.index(e) != open.index(stack[top]):\n                        answer += 1\n\n                    stack.pop(top)\n\n    if len(stack) != 0:\n        print(\"Impossible\")\n    else:\n        print(answer)\n\ndef __starting_point():\n    main()\n__starting_point()", "stack = []\n\ndef main():\n    s = str(input())\n    open = list(\"<{[(\")\n    close = list(\">}])\")\n\n    answer = 0\n\n    for e in s:\n        if len(stack) == 0:\n            if e in open:\n                stack.append(e)\n            else:\n                print(\"Impossible\")\n                return\n        else:\n            top = len(stack) - 1\n            if e in open:\n                if stack[top] in close:\n                    if open.index(e) != close.index(stack[top]):\n                        answer += 1\n\n                    stack.pop(top)\n                else:\n                    stack.append(e)\n            else:\n                if stack[top] in close:\n                    stack.append(e)\n                else:\n                    if close.index(e) != open.index(stack[top]):\n                        answer += 1\n\n                    stack.pop(top)\n\n    if len(stack) != 0:\n        print(\"Impossible\")\n    else:\n        print(answer)\n\ndef __starting_point():\n    main()\n__starting_point()", "s = input()\n\nstack = []\nanswer = 0\ncorrects = ('[]', '{}', '<>', '()')\nfor i in s:\n    if i == '[' or i == '{' or i == '<' or i == '(':\n        stack.append(i)\n    else:\n        if len(stack) == 0:\n            print('Impossible')\n            return\n        else:\n            top = stack.pop()\n            if top + i not in corrects:\n                answer += 1\n\nprint(answer if len(stack) == 0 else 'Impossible')\n", "stack = []\ncounter = 0\npossible = True\nfor b in input():\n    if b in \"{<([\":\n        stack.append(b)\n    else:\n        if not stack:\n            possible = False\n            break\n        popped = stack.pop()\n        if  (b == \"}\" and popped != \"{\") or \\\n            (b == \">\" and popped != \"<\") or \\\n            (b == \")\" and popped != \"(\") or \\\n            (b == \"]\" and popped != \"[\"):\n            counter += 1\n\nif possible and not stack:\n    print(counter)\nelse:\n    print(\"Impossible\")", "s = input()\nopen = \"({<[\"\nclose = \")}>]\"\nclopen = {']': '[', '}': '{', '>': '<', ')': '('}\nir2 = 0\nir = 0\nif len(s) % 2 == 1:\n    print(\"Impossible\")\n    return\nelse:\n    l = []\n    for i in range(len(s)):\n        if s[i] in open:\n            ir += 1\n            l.append(s[i])\n        else:\n            ir -= 1\n            if ir == -1:\n                print(\"Impossible\")\n                return\n            p = l.pop()\n            if clopen[s[i]] != p:\n                ir2 += 1\nif ir != 0:\n    print(\"Impossible\")\n    return\nelse:\n    print(ir2)\n", "opens = ['(', '{', '<', '[']\ncloses = [')', '}', '>', ']']\n\ndef solve(inp):\n    stack = []\n    res = 0\n    for i, x in enumerate(inp):\n        if x in opens:\n            stack.append((i,x))\n        if x in closes:\n            if not stack:\n                return 'Impossible'\n            ii, xx = stack.pop()\n            if closes.index(x) != opens.index(xx):\n                res += 1\n    if stack:\n        return 'Impossible'\n    return res\n\nprint(solve(input()))\n", "from collections import deque \nimport sys\n\nstrv = list(input())\n\nif len(strv) % 2 != 0:\n    print (\"Impossible\")\n    return\n\nopenQ = deque([])\n\ny=0\n\nfor brk in strv:\n    if brk in ['[','{','(', '<']:\n        openQ.append(brk) \n    else: \n        if len(openQ) >= 1:\n            lastIn = openQ.pop() \n            if brk==\"}\":\n                if lastIn != \"{\":\n                    y=y+1\n            elif brk==\"]\":\n                if lastIn != \"[\":\n                        y=y+1\n            elif brk==\")\":\n                if lastIn != \"(\":\n                        y=y+1\n            elif brk==\">\":\n                if lastIn != \"<\":\n                        y=y+1\n        else:\n            y=\"Impossible\"\n            break\n\nif len(openQ) == 0 :\n    print(y)\nelse:\n    print(\"Impossible\")\n", "word = input()\n\nBRACKETS = [\n    ('<', '>'),\n    ('{', '}'),\n    ('[', ']'),\n    ('(', ')'),\n]\n\nOPENING = [b[0] for b in BRACKETS]\n\nMATCH = dict(BRACKETS)\n\nIMPOSSIBLE = 'Impossible'\n\ndef is_opening(w):\n    return w in OPENING\n\ndef same_kind(wo, wc):\n    return MATCH[wo] == wc\n\ndef solve(word):\n    temp = []\n    result = 0\n    for w in word:\n        if is_opening(w):\n            temp.append(w)\n        else:\n            if len(temp) == 0:\n                return IMPOSSIBLE\n            wo = temp.pop()\n            if not is_opening(wo):\n                return IMPOSSIBLE\n            if not same_kind(wo, w):\n                result += 1\n    if len(temp) != 0:\n        return IMPOSSIBLE\n    return result\n                \nprint(solve(word))\n", "# -*- coding: utf-8 -*-\nimport sys\n\ndef fun():\n    try:\n        str = input()\n    except ValueError:\n        print('Invalid number')\n        return\n    S = {\"}\": \"{\",\")\": \"(\",\">\": \"<\",\"]\":\"[\"}\n    L = []\n    ans = 0\n    for c in str:\n        if c in S.values():\n            L.append(c)\n            pass\n        else:\n            if(len(L) >0 ):\n                ans += 0 if S[c] == L.pop() else 1\n            else:\n                ans = -1\n                break\n            pass\n    if( len(L)> 0 or ans <0):\n        print('Impossible')\n    else:\n        print(ans)\n    pass\n\ndef __starting_point():\n    fun()\n    '''\n    for i,v in enumerate(map(int,input().split())):\n        print(i,v)\n    '''\n__starting_point()", "def solution(s):\n    st = []\n    ans = 0\n    for i, j in enumerate(s):\n        if j in open:\n            st.append((i,j))\n        if j in close:\n            if not st:\n                return (\"Impossible\")\n            q,w = st.pop()\n            if close.index(j) != open.index(w):\n                ans += 1\n    if st:\n        return (\"Impossible\")\n    return ans\ns=str(input())\nopen = ['(', '{', '<', '[']\nclose = [')', '}', '>', ']']\nprint(solution(s))", "#!/usr/bin/env python3\n\nimport sys\n\ns = input()\nOPENING = ('<', '{', '[', '(')\nCLOSING = ('>', '}', ']', ')')\nresult = 0\nstack = []\n\nfor c in s:\n    if c in OPENING:\n        stack.append(c)\n    else:\n        if stack:\n            last_br = stack.pop()\n            if c != CLOSING[OPENING.index(last_br)]:\n                result += 1\n        else:\n            print(\"Impossible\")\n            return\nprint(\"Impossible\" if stack else result)\n", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2016 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\nopening = {\n        \"[\": \"]\",\n        \"<\": \">\",\n        \"{\": \"}\",\n        \"(\": \")\",\n}\n\nclosing = {\n        \"]\": \"[\",\n        \">\": \"<\",\n        \"}\": \"{\",\n        \")\": \"(\",\n}\n\ns = input()\n\nstack = []\n\nansw = 0\n\nfor c in s:\n    if c in opening:\n        stack.append(c)\n    else:\n        if len(stack) == 0:\n            print(\"Impossible\")\n            return\n\n        op = stack.pop()\n\n        if c != opening[op]:\n            answ += 1\n\nif len(stack) != 0:\n    print(\"Impossible\")\n    return\nprint(answ)\n", "s = input()\ncnt = 0\nst = []\nfor elem in s:\n    if elem in '([{<':\n        st.append(elem)\n    else:\n        if len(st) == 0:\n            print('Impossible')\n            break\n        elem2 = st.pop()\n        if elem2 + elem not in '()[]{}<>':\n            cnt += 1\nelse:\n    if len(st) == 0:\n        print(cnt)\n    else:\n        print('Impossible')", "from collections import deque\n\ndef f(s1):\n    return s1 in \"<{[(\"\n\ns = list(input())\n\nd = deque([])\nans = 0\nfor i in s:\n    if f(i):\n        d.append(i)\n    else:\n        if len(d) == 0:\n            print(\"Impossible\")\n            return\n        elif ord(d[-1]) + 2 == ord(i) or ord(d[-1]) + 1 == ord(i):\n            d.pop()\n        else:\n            d.pop()\n            ans += 1\nif len(d) > 0:\n    print(\"Impossible\")\n    return\nprint(ans)", "a=input()\nb=0\nc='([{<'\nd=')]}>'\ne=[]\nf=False\nfor i in a:\n    if i in c:e+=[i]\n    else:\n        if not e:\n            print('Impossible')\n            f=True\n            break\n        if d.index(i)!=c.index(e[-1]):b+=1\n        e.pop()\nif e:print('Impossible')\nelif not f:print(b)\n", "s = input()\nopen = {'(', '{', '[', '<'}\nres = 0\nour = []\nfor elem in s:\n    if elem in open:\n        our.append(elem)\n    else:\n        if our:\n            res += (abs(ord(elem) - ord(our[-1])) > 2)\n            our.pop()\n        else:\n            print('Impossible')\n            return\nif our:\n    print('Impossible')\nelse:\n    print(res)"]
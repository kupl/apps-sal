["import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\nimport itertools\n\nP = int(input())\nA = [int(x) for x in input().split()]\n\n# k,i -> i^k\npower = np.ones((P,P),dtype = np.int64)\nfor k in range(1,P):\n    power[k] = power[k-1] * np.arange(P,dtype=np.int64) % P\n\nf = np.zeros(P,dtype=np.int64)\nfor i,a in enumerate(A):\n    if a == 1:\n        f[0] += 1\n        f -= power[:,i][::-1]\nf %= P\n\nf %= P\nprint((*f))\n\n", "import numpy as np\n\np = int(input())\naaa = list(map(int, input().split()))\n\nbins = [1]\nfor i in range(1, p):\n    bins.append(bins[-1] * (p - i) * pow(i, p - 2, p) % p)\nbins = np.array(bins, dtype=np.int32)\n\npows_base = -np.arange(p, dtype=np.int32)\npows = np.zeros((p, p), dtype=np.int32)\npows[:, p - 1] = 1\nfor i in range(p - 2, -1, -1):\n    pows[:, i] = pows[:, i + 1] * pows_base % p\n\ncoefs = np.zeros(p, dtype=np.int32)\n\nfor i, a in enumerate(aaa):\n    if a == 0:\n        continue\n\n    coefs[0] += 1\n    coefs = (coefs - bins * pows[i]) % p\n\nprint((*coefs))\n", "def solve():\n    p = int(input())\n    *A, = map(int, input().split())\n\n    L = p-1\n    fact = [1]*(L+1)\n    rfact = [1]*(L+1)\n    r = 1\n    for i in range(1, L+1):\n        fact[i] = r = r * i % p\n    rfact[L] = r = pow(r, p-2, p)\n    for i in range(L, 0, -1):\n        rfact[i-1] = r = r * i % p\n    V = [(-fact[p-1] * rfact[k] * rfact[p-1-k]) % p for k in range(p)]\n\n    R = [0]*p\n    I = [i for i, a in enumerate(A) if a]\n    C = [a for a in A]\n\n    for k in range(p):\n        R[k] = V[k] * sum(C) % p\n\n        for i in I:\n            C[i] = C[i] * -i % p\n    R[-1] = (R[-1] + len(I)) % p\n    R.reverse()\n    print(*R)\nsolve()", "p = int(input())\nb_list = [0 for _ in range(p-1)]\na_list = list(map(int,input().split()))\ndef frac(n):\n    if a_list[n] == 1:\n        t = 1\n        for j in range(p-1):\n            b_list[j] -= t\n            t = (t*n)%p\nif a_list[0] == 1:\n    b_list[0] -= 1\nfor i in range(p-1):\n    frac(i+1)\nb_list.reverse()\nprint(a_list[0],end = ' ')\nfor j in b_list:\n    print(j % p,end = ' ')\n", "# -*- coding: utf-8 -*-\nfrom sys import stdin\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n# import time\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list([int(x)-1 for x in stdin.readline().split()])\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\n\n\np = _i()\na_list = np.array(_li())\n\nfactorial_invs = {0: 1, 1: 1}\nfor i in range(2, p):\n    factorial_invs[i] = (factorial_invs[i-1] * pow(i, p-2, p)) % p\nnp_fact_invs = np.tile(np.array(list(factorial_invs.values()))\n                       .reshape(1, -1), (p, 1))\n\npow_table = np.ones((p, p), dtype=int)\npow_table[1, :] = np.arange(p)\nfor i in range(2, p):\n    pow_table[i] = (pow_table[i-1] * pow_table[1]) % p\npow_table = pow_table.T\n\nfact_pminus1 = pow(factorial_invs[p-1], p-2, p)\n\ncoefs = np.zeros(p, dtype=int)\n# for i, a in enumerate(a_list):\n#     if a == 1:\n#         for k in range(1, p):\n#             coefs[k] = coefs[k] - (-1)**(k % 2) * pow(i, p-1-k, p)\\\n#                     * fact_pminus1\\\n#                     * factorial_invs[k]\\\n#                     * factorial_invs[p-1-k]\n#             coefs[k] %= p\n\ncoefs[0] = a_list[0]\nsign_array = np.tile(((-1) ** (np.arange(1, p) % 2)).reshape(1, -1), (p, 1))\ncoefs[1:] = - ((((sign_array[a_list == 1, :]\n                  * pow_table[a_list == 1, :-1][:, ::-1]\n                  * fact_pminus1) % p\n                 * np_fact_invs[a_list == 1, 1:]) % p\n                * np_fact_invs[a_list == 1, :-1][:, ::-1]\n                ) % p).sum(axis=0)\ncoefs %= p\n\nprint((*coefs))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\nfrom numpy.fft import rfft, irfft\nimport itertools\n\nP = int(input())\nA = [int(x) for x in input().split()]\n\nfft_len = 6144\ndef fft_convolve(A,B):\n    C = irfft(rfft(A,fft_len) * rfft(B,fft_len))\n    C = (C + .5).astype(np.int64)\n    C[:P] += C[P:P+P]\n    return C[:P] % P\n  \none = np.array([1], dtype=np.int64)\narr = [np.array([(-x)%P,1],dtype=np.int64) for x in range(P)]\nL = [one] + list(itertools.accumulate(arr[:-1],lambda a,b: np.convolve(a,b) % P))\nR = ([one] + list(itertools.accumulate(arr[1:][::-1],lambda a,b: np.convolve(a,b) % P)))[::-1]\nX = [fft_convolve(A,B) % P for A,B in zip(L,R)]\n\nf = np.zeros(P,dtype=np.int64)\nfor a,x in zip(A,X):\n    if a == 1:\n        f -= x\n\nf %= P\nprint((*f))\n", "def solve():\n    p = int(input())\n    *A, = map(int, input().split())\n\n    L = p-1\n    fact = [1]*(L+1)\n    rfact = [1]*(L+1)\n    r = 1\n    for i in range(1, L+1):\n        fact[i] = r = r * i % p\n    rfact[L] = r = pow(r, p-2, p)\n    for i in range(L, 0, -1):\n        rfact[i-1] = r = r * i % p\n    V = [(-fact[p-1] * rfact[k] * rfact[p-1-k]) % p for k in range(p)]\n\n    B = [-i for i in range(p)]\n    R = [0]*p\n    I = [i for i, a in enumerate(A) if a]\n    C = [a for a in A]\n\n    for k in range(p):\n        r = 0\n        R[k] = V[k] * sum(C) % p\n\n        for i in I:\n            C[i] = C[i] * B[i] % p\n    R[-1] += len(I)\n    for k in range(p):\n        R[k] %= p\n    R.reverse()\n    print(*R)\nsolve()", "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\n\n\n# MOD = 10 ** 9 + 7\n\n\n# MOD = 998244353\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    \u968e\u4e57 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    \u9006\u5143\u306e\u30ea\u30b9\u30c8 0 \u304b\u3089 max \u307e\u3067\n    :param int max:\n    :param int mod:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\ndef factorial_invs(max, mod):\n    \"\"\"\n    \u968e\u4e57 0!, 1!, 2!, ..., max! \u306e\u9006\u5143\n    :param int max:\n    :param int mod:\n    \"\"\"\n    ret = []\n    r = 1\n    for inv in mod_invs(max, mod):\n        r = r * inv % mod\n        ret.append(r)\n    return ret\n\n\nclass Combination:\n    def __init__(self, max, mod):\n        \"\"\"\n        :param int max:\n        :param int mod: 3 \u4ee5\u4e0a\u306e\u7d20\u6570\u3067\u3042\u308b\u3053\u3068\n        \"\"\"\n        self._factorials = get_factorials(max, mod)\n        self._finvs = factorial_invs(max, mod)\n        self._mod = mod\n\n    def ncr(self, n, r):\n        \"\"\"\n        :param int n:\n        :param int r:\n        :rtype: int\n        \"\"\"\n        if n < r:\n            return 0\n        return (\n                self._factorials[n]\n                * self._finvs[r]\n                % self._mod\n                * self._finvs[n - r]\n                % self._mod\n        )\n\n\nP = int(sys.stdin.readline())\nA = list(map(int, sys.stdin.readline().split()))\n\n\n# A = np.array(A, dtype=int)\n# vpow = np.vectorize(lambda a, b: pow(a, b, P))\n# mat = []\n# for i in range(P):\n#     mat.append(vpow(i, np.arange(P)))\n# print(np.array(mat).sum(axis=1) % P)\n# print(np.array(mat).sum(axis=0) % P)\n# mat = np.hstack((mat, [[a] for a in A]))\n#\n# print(mat)\n#\n\n\ndef power_table():\n    ret = np.ones((P, P), dtype=int)\n    row = -np.arange(P, dtype=int)\n    for i in range(1, P):\n        ret[i] = ret[i - 1] * row % P\n    return ret\n\n\n# \u89e3\u8aacAC\n# f(x) = 1\u2212(x - j)^(P - 1) \u306f\u3001x == j \u306e\u3068\u304d1\u3001\u305d\u308c\u4ee5\u5916\u306e\u3068\u304d0\n# A[j] == 1 \u3067\u3042\u308b j \u306b\u3064\u3044\u3066\u4e0a\u8a18\u306e\u5f0f\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\ncomb = Combination(max=P - 1, mod=P)\nncr = np.array([comb.ncr(P - 1, i) for i in range(P)])\n# power[i][j]: (-j)^i\npower = power_table()\n\nB = np.zeros(P, dtype=int)\nfor j, a in enumerate(A):\n    if a == 0:\n        continue\n    B -= power[:, j] * ncr % P\n    B[-1] += 1\n    B %= P\nprint((*B[::-1]))\n", "import numpy as np\nmod = 998244353\n\ndef poly_mul(f, g):\n    # \u53c2\u8003: https://judge.yosupo.jp/submission/2380\n    Lf = len(f); Lg = len(g); L = Lf + Lg - 1\n    if Lf <= 16 or Lg <= 16:\n        if Lf == 0 or Lg == 0:\n            return np.zeros((0,), dtype=np.int64)\n        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)\n    fft = np.fft.rfft; ifft = np.fft.irfft\n    fft_len = 1 << L.bit_length()\n    fl = f & (1 << 15) - 1; fh = f >> 15\n    gl = g & (1 << 15) - 1; gh = g >> 15\n    x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    return (x + ((y - x - z) << 15) + (z << 30)) % mod\n\ndef poly_inv(fps, n=None):\n    assert fps[0] != 0\n    if n is None:\n        n = len(fps)\n    res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)\n    res[0] = pow(int(fps[0]), mod-2, mod)\n    i = 1\n    while i < n:\n        i <<= 1\n        res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod\n    return res[:n]\n\ndef poly_div(fps1, fps2):\n    n1, n2 = len(fps1), len(fps2)\n    if n1 < n2:\n        return np.zeros((0,), dtype=np.int64)\n    n = n1 - n2 + 1\n    res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]\n    return res\n\ndef poly_mod(fps1, fps2):\n    n1, n2 = len(fps1), len(fps2)\n    if n1 < n2:\n        return fps1\n    res = fps1[:n2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:n2-1]\n    return res % mod\n\ndef multipoint_evaluation(fps, xs):\n    threshold = 8\n    n_xs = len(xs)\n    bit = (n_xs-1).bit_length()\n    if bit <= threshold:\n        res = np.zeros_like(xs)\n        xs_cumprod = np.ones_like(xs)\n        for coef in fps:\n            res += xs_cumprod * coef\n            xs_cumprod *= xs\n            xs_cumprod %= mod\n        return res\n    k = 1<<bit\n    fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)\n    fpss[0, :n_xs] = -xs % mod\n    fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod\n    fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod\n    for i in range(1, bit):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, k, step):\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            f = poly_mul(f1, f2)\n            fpss[i+1, j:j+step] = f[:-1]\n    f = poly_mod(fps, f)\n    fpss[-1, :len(f)] = f\n    fpss[-1, len(f):] = 0\n    for i in range(bit-1, threshold-1, -1):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, k, step):\n            f = fpss[i+1, j:j+step]\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss[i, j:j+half] = poly_mod(f, f1)\n            fpss[i, j+half:j+step] = poly_mod(f, f2)\n    xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)\n    xs_cumprod = np.ones_like(xs)\n    res = np.zeros_like(xs)\n    for i in range(1<<threshold):\n        res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod\n        xs_cumprod *= xs\n        xs_cumprod %= mod\n    return res.reshape(-1)[:n_xs] % mod\n\ndef poly_differential(fps):\n    return fps[1:] * np.arange(1, len(fps)) % mod\n\ndef lagrange_interpolation(X, Y, mod):\n    # old\n    n = len(X)\n    g = [0]*(n+1)\n    g[0] = 1\n    for i, x in enumerate(X):\n        for j in range(i, -1, -1):\n            g[j+1] += g[j] * (-x) % mod\n    res = [0]*n\n    for x, y in zip(X, Y):\n        f = g[:]\n        denom = 0\n        v = 1\n        pow_x = [1]  # x \u306e idx \u4e57\n        for _ in range(n-1):\n            v = v * x % mod\n            pow_x.append(v)\n        pow_x.reverse()  # n-1 \u4e57 ~ 0 \u4e57\n        for i, po in enumerate(pow_x):\n            f_i = f[i]\n            f[i+1] += f_i * x % mod  # f = g / (x - x_i) \u3092\u7d44\u7acb\u9664\u6cd5\u3067\u6c42\u3081\u308b\n            denom = (denom + f_i * po) % mod\n        denom_inv = pow(denom, mod-2, mod)\n        for i, f_i in enumerate(f[:n]):\n            res[i] += (f_i * y * denom_inv)# % mod  # mod \u304c\u5927\u304d\u3044\u3068 64bit \u306b\u53ce\u307e\u3089\u306a\u304f\u306a\u308b\u306e\u3067\u3072\u3068\u3064\u305a\u3064 mod \u53d6\u3063\u305f\u65b9\u304c\u3044\u3044\u304b\uff1f\n    return [v % mod for v in res]\n\ndef polynomial_interpolation(xs, ys):\n    # \u53c2\u8003: https://rsk0315.hatenablog.com/entry/2020/04/05/203210\n    assert len(xs) == len(ys)\n    threshold = 8\n    as_strided = np.lib.stride_tricks.as_strided\n    n = len(xs)\n    if n==1:\n        return ys.copy()\n    bit = (n-1).bit_length()\n    if bit <= threshold:\n        res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)\n        return np.array(res[::-1], dtype=np.int64)\n    k = 1<<bit\n    fpss = np.zeros((bit+1, n+1), dtype=np.int64)\n    fpss[0, :n] = -xs % mod\n    for i in range(bit):\n        step = 2 << i\n        half = step >> 1\n        for j in range(0, n, step):\n            if j+half >= n:\n                fpss[i+1, j:n] = fpss[i, j:n]\n                continue\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            f = poly_mul(f1, f2)\n            fpss[i+1, j:j+len(f)-1] = f[:-1]\n    fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)\n    fpss2[bit, :n] = poly_differential(f)\n    for i in range(bit-1, threshold-1, -1):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, n, step):\n            if j+half >= n:\n                fpss2[i, j:n] = fpss2[i+1, j:n]\n                continue\n            f = fpss2[i+1, j:min(j+step, n)]\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:min(j+step, n)+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss2[i, j:j+half] = poly_mod(f, f1)\n            fpss2[i, j+half:min(j+step, n)] = poly_mod(f, f2)\n    xs = as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))\n    xs_cumprod = np.ones_like(xs)\n    f = np.zeros_like(xs)\n    for i in range(1<<threshold):\n        f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod\n        xs_cumprod *= xs\n        xs_cumprod %= mod\n    f = f.ravel()\n    for j in range(n):\n        fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod\n    for i in range(bit):\n        step = 2 << i\n        half = step >> 1\n        for j in range(0, k, step):\n            if j+half >= n:\n                fpss2[i+1, j:n] = fpss2[i, j:n]\n                continue\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss2[i+1, j:min(j+step, n)] = (\n                poly_mul(fpss2[i, j:j+half], f2)\n                + poly_mul(fpss2[i, j+half:min(j+step, n)], f1)\n            ) % mod\n    return fpss2[bit, :n]\n\nmod = int(input())\nA = np.array(input().split(), dtype=np.int64)\nX = np.arange(mod, dtype=np.int64)\nAns = polynomial_interpolation(X, A)\nprint((\" \".join(map(str, Ans.tolist()))))\n"]
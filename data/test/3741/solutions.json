["from collections import deque\nbits = [0] * 64\nn = int(input())\ndata = list([x for x in map(int, input().split()) if x != 0])\nn = len(data)\nif n == 0:\n    print(-1)\n    return\nfor v in data:\n    i = 0\n    while v != 0:\n        bits[i] += v & 1\n        i += 1\n        v >>= 1\nfor i in range(64):\n    if bits[i] > 2:\n        print(3)\n        return\ngraph = [[] for _ in range(n)]\nfor u in range(n):\n    for v in range(u):\n        if (data[u] & data[v]) != 0 and u != v:\n            graph[v].append(u)\n            graph[u].append(v)\n\n\ndef bfs(start):\n    group = [-1] * n\n    depth = [0] + [-1] * (n - 1)\n    for j in range(len(graph[start])):\n        to = graph[start][j]\n        group[to] = j\n        depth[to] = 1\n    bfsQ = deque(graph[start])\n    minlen = 999999999\n    while len(bfsQ) > 0:\n        u = bfsQ[0]\n        bfsQ.popleft()\n        for v in graph[u]:\n            if v == start:\n                if depth[u] < 2:\n                    continue\n                return depth[u] + 1\n            if group[v] == -1:\n                group[v] = group[u]\n                depth[v] = depth[u] + 1\n                bfsQ.append(v)\n            elif group[v] != group[u]:\n                newlen = depth[u] + depth[v] + 1\n                if newlen < minlen:\n                    minlen = newlen\n    return minlen\n\n\nanswer = min(list(map(bfs, list(range(n)))))\nprint(answer if answer <= n else -1)\n", "from collections import Counter, deque\n\nn = int(input())\narr = list([x for x in map(int, input().strip().split()) if x != 0])\n\n'''\nfor i, a in enumerate(arr):\n    for j, b in enumerate(arr):\n        if a & b != 0 and i != j:\n            print(i,j,a,b)\nreturn\n'''\n\nc = Counter()\n\nfor each in arr:\n    for b in range(0, 64):\n        if (1 << b) & each != 0:\n            c[b] += 1\n            if c[b] >= 3:\n                print(3)\n                return\n\nans = 1234567\n\nfor idx, st in enumerate(arr):\n    dists = {}\n    q = deque()\n    q.append((idx, -1))\n    dists[idx] = 0\n\n    while q:\n        node, par = q[0]\n        dist = dists[node]\n        q.popleft()\n        for idx2, v in enumerate(arr):\n            if idx2 == par:\n                continue\n            if idx2 == node or (v & arr[node]) == 0:\n                continue\n            if idx2 in dists:\n                candidate = dists[idx2] + dist + 1\n                if candidate != 2:\n                    ans = min(ans, candidate)\n                continue\n            dists[idx2] = dist + 1\n            q.append((idx2, node))\n\n\nif ans == 1234567:\n    print(-1)\nelse:\n    print(ans)\n", "import sys\nn=int(input())\na=[]\n\nfor x in input().split():\n    if(int(x)!=int(0)):\n        a.append(int(x))\n\nif(len(a)>500):\n    print(3)\n    return\n\nn=len(a)\n\n#print(n)\n\ng=[]\nfor i in range(n):\n   g.append([])\n\nfor i in range(n):\n    for j in range(n):\n        g[i].append(1000000000)\n\nfor i in range(n):\n    for j in range(n):\n        if(i!=j and (a[i]&a[j])!=0):\n            g[i][j]=1\n\n\nans=int(10000000000)\n\ndis=[]\nfor i in range(n):\n    dis.append([])\n\nfor i in range(n):\n    for j in range(n):\n        dis[i].append(g[i][j])\n\nfor  k in range(n):\n    for i in range(k):\n        for j in range(i+1,k):\n            ans=min(ans,dis[i][j]+g[i][k]+g[k][j])\n    for i in range(n):\n        for j in range(n):\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])\n\n\n\nif(ans>1000):\n    print(-1)\nelse:\n    print(ans)\n", "import sys\nfrom collections import deque\n\nn = int(input())\na = list(map(int, input().split()))\nna = list()\nfor x in a:\n    if (x):\n        na.append(x)\na = na\nn = len(a)\nfor b in range(60):\n    cnt = 0\n    for x in a:\n        if (x >> b & 1):\n            cnt += 1\n    if (cnt >= 3) :\n        print(3)\n        return\ng = [list() for x in range(n)]\nfor i in range(n):\n    for j in range (n):\n        if (i != j and (a[i] & a[j])):\n            g[i].append(j)\nans = 200\ndef go(r):\n    nonlocal ans\n    d = [-1 for x in range(n)]\n    q = deque()\n    d[r] = 0\n    q.append(r)\n    while (len(q)):\n        v = q.popleft()\n        for u in g[v]:\n            if (d[u] == -1):\n                d[u] = d[v] + 1\n                q.append(u)\n            elif (d[u] >= d[v]):\n                ans = min(ans, d[v] + d[u] + 1)\nfor r in range(n):\n    go(r)\nif (ans > n) :\n    ans = -1\nprint(ans)", "from collections import defaultdict\n\nn = int(input())\n\narr = list(map(int, input().split()))\n\nd = defaultdict(list)\ndd = defaultdict(list)\n\nfor i, el in enumerate(arr):\n    b = '{0:b}'.format(el)[::-1]\n    for j, digit in enumerate(b):\n        if digit == '1':\n            for i2 in d[j]:\n                dd[i].append(i2)\n                dd[i2].append(i)\n            d[j].append(i)\n        if len(d[j]) == 3:\n            print(3)\n            return\n\ncolors = {i: [] for i in range(len(arr))}\n\nmin_cycle = float('+inf')\n\nfor i in range(len(arr)):\n    if colors[i]:\n        continue\n    tier = [(i, [])]\n    next_tier = []\n    while tier:\n        for t, way in tier:\n            if colors[t]:\n                c = 0\n                while len(way) > c and len(colors[t]) > c and way[c] == \\\n                        colors[t][c]:\n                    c += 1\n                min_cycle = min(len(colors[t]) + len(way) - 2 * c + 1,\n                                min_cycle)\n                continue\n            colors[t] = way + [t]\n            for k in dd[t]:\n                if (not way or k != way[-1]) and (k, colors[t]) not in next_tier:\n                    next_tier.append((k, colors[t]))\n        tier = next_tier\n        next_tier = []\n\nif min_cycle < 1e9:\n    print(min_cycle)\nelse:\n    print(-1)\n\npass", "# 1205B\ndef do():\n    n = int(input())\n    nums = [int(c) for c in input().split(\" \")]\n    valid = set()\n    for i in range(64):\n        count = []\n        for j in range(n):\n            if (1 << i) & nums[j]:\n                count.append(nums[j])\n            if len(count) == 3:\n                return 3\n        if len(count) == 2:\n            valid.add(count[0])\n            valid.add(count[1])\n    # valid won't be that large hahaha at most 64*2\n    nv = len(valid)\n    valid = list(valid)\n    dis = [[float('inf')] * nv for _ in range(nv)]\n    for i in range(nv):\n        for j in range(nv):\n            if i == j:\n                dis[i][j] = 0\n            elif valid[i] & valid[j]:\n                dis[i][j] = 1\n    mp = [[_ for _ in dis[i]] for i in range(len(dis))]\n    res = nv + 1\n    for k in range(nv):\n        for i in range(nv):\n            if k != i:\n                for j in range(nv):\n                    if k != j and i != j:\n                        res = min(res, dis[i][j] + mp[j][k] + mp[k][i])\n        for i in range(nv):\n            if k != i:\n                for j in range(nv):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n    return res if res <= nv else -1\n\nprint(do())\n\n\n\n\n\n", "# 1205B\ndef do():\n    n = int(input())\n    nums = [int(c) for c in input().split(\" \")]\n    valid = set()\n    for i in range(64):\n        count = []\n        for j in range(n):\n            if (1 << i) & nums[j]:\n                count.append(nums[j])\n            if len(count) == 3:\n                return 3\n        if len(count) == 2:\n            valid.add(count[0])\n            valid.add(count[1])\n    # valid won't be that large hahaha at most 64*2\n    nv = len(valid)\n    valid = list(valid)\n    dis = [[float('inf')] * nv for _ in range(nv)]\n    for i in range(nv):\n        for j in range(nv):\n            if i == j:\n                dis[i][j] = 0\n            elif valid[i] & valid[j]:\n                dis[i][j] = 1\n    mp = [[_ for _ in dis[i]] for i in range(len(dis))]\n    res = nv + 1\n    for k in range(nv):\n        for i in range(k):\n            for j in range(k):\n                if i != j:\n                    res = min(res, dis[i][j] + mp[j][k] + mp[k][i])\n        for i in range(nv):\n            if k != i:\n                for j in range(nv):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n    return res if res <= nv else -1\n\nprint(do())\n\n\n\n\n\n", "from collections import deque\n\nn=int(input())\ns=[int(x) for x in input().split()]\nb=[]\nmx=-1\nfor i in range(0,len(s)):\n    t=bin(s[i])\n    t=t[2:]\n    b.append(t)\n    mx=max(mx,len(t))\n\nfor i in range(0,len(b)):\n    b[i]='0'*(mx-len(b[i]))+b[i]\n\nflag=0\nL=[]\nkk=dict()\nfor i in range(0,mx):\n    c=0\n    h=[]\n    for j in range(0,len(b)):\n        if(b[j][i]=='1'):\n            c+=1\n            h.append(j)\n    if(len(h)==2 and kk.get(tuple(h))==None):\n        h=tuple(h)\n        L.append(h)\n        kk[h]=1\n    if(c>2):\n        flag=1\n        break\n#print(L)\n\nif(flag==1):\n    print(3)\nelse:\n    temp=1000000007\n    for i in range(0,len(L)):\n\n        arr=[]\n        for j in range(n):\n            s1=[]\n            arr.append(s1)\n\n        for j in range(0,len(L)):\n            if(j==i):\n                src=L[j][0]\n                dst=L[j][1]\n\n            else:\n                arr[L[j][0]].append(L[j][1])\n                arr[L[j][1]].append(L[j][0])\n\n        q=deque()\n        q.append((src,0))\n        visited=[False]*n\n        visited[src]=True\n\n        while(q):\n\n            r=q.popleft()\n\n            visited[r[0]]=True\n            if(r[0]==dst):\n                temp=min(temp,r[1]+1)\n                break\n\n            for j in arr[r[0]]:\n                if(visited[j]==False):\n                    q.append((j,r[1]+1))\n\n\n    if(temp==1000000007):\n        print(-1)\n    else:\n        print(temp)\n\n        \n\n        \n                \n    \n", "\nclass node():\n\tdef __init__(self, v, edges):\n\t\tself.value = v\n\t\tself.edges = edges\n \nn = int(input())\na = [int(i) for i in input().split(\" \")]\n \n \ndef fun(a):\n\tnodes = {}\n\tfor i in range(60):\n\t\tk = 0\n\t\tvalue = 1 << i\n\t\ti_edges = set()\n\t\tfor j in a:\n\t\t\tif value&j > 0:\n#                 print(i+1)\n\t\t\t\tk += 1\n\t\t\t\tif k > 2:\n\t\t\t\t\tdel i_edges\n\t\t\t\t\tdel nodes\n\t\t\t\t\treturn 3\n\t\t\t\ti_edges.add(j)\n\t\tfor j in i_edges:\n\t\t\tif j not in nodes:\n\t\t\t\tif (i_edges.difference({j})) != 0:\n\t\t\t\t\tnodes[j] = node(j,i_edges.difference({j}))\n\t\t\telse:\n\t\t\t\tnodes[j].edges = nodes[j].edges.union(i_edges.difference({j}))\n\treturn nodes\n \ndef find_short_path(v1, v2):\n\tlength = 0\n\tv2 = {v2}\n\tsetic = set()\n\tset_was = set()\n\twhile (v1 not in setic):\n\t\tdel setic\n\t\tsetic = set()\n\t\tfor i in v2:\n\t\t\tsetic = setic.union(nodes[i].edges.difference(set_was))\n\t\tset_was = set_was.union(setic)\n\t\tif len(setic) == 0:\n\t\t\tdel v2\n\t\t\treturn 0\n\t\tlength += 1\n\t\tdel v2\n\t\tv2 = setic.copy()\n\tdel set_was\n\tdel setic\n\treturn length\n \n \nnodes = fun(a)\nif type(nodes) == int:\n\tprint(3)\nelse:\n\tmass = []\n\twhile len(nodes.keys()) != 0:\n\t\t# print(type(nodes.keys()))\n\t\ti = list(nodes.keys())[0]\n\t\tif len(nodes[i].edges) != 0:\n\t\t\t\n\t\t\tfirst_v = i\n\t\t\tsecond_v = nodes[first_v].edges.pop()\n\t\t\tnodes[second_v].edges.remove(first_v)\n\t\t\tlength = 0\n\t\t\tif len(nodes[first_v].edges) == 0:\n\t\t\t\tnodes.pop(first_v)\n\t\t\telif len(nodes[second_v].edges) == 0:\n\t\t\t\tnodes.pop(second_v)\n\t\t\telse:\n\t\t\t\tlength = find_short_path(first_v, second_v)\n\t\n\t\t\tif length:\n\t\t\t\tmass.append(length + 1)\n\t\telse:\n\t\t\tnodes.pop(i)\n\t\t\t\n\tif len(mass) != 0:\n\t\tprint(min(mass))\n\telse:\n\t\tprint(-1)", "\nfrom sys import stdin\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\n\n\n# sys.stdout = BytesIO()\n# register(lambda: os.write(1, sys.stdout.getvalue()))\n#\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# if sys.version_info[0] < 3:\n#     range = xrange\n#     filter = itertools.ifilter\n#     map = itertools.imap\n#     zip = itertools.izip\n\n\ndef bfs(src, dest, adj):\n    visited = [False for _ in range(len(adj))]\n    visited[src] = True\n    queue = [src]\n    i = 1\n    while len(queue)>0:\n        newq = []\n        i += 1\n        for node in queue:\n            for vertex in adj[node]:\n                if node==src and vertex==dest: continue\n                if not visited[vertex]:\n                    newq.append(vertex)\n                    visited[vertex] = True\n                    if vertex==dest:\n                        return i\n        queue = newq\n    return -1\n\n\ndef main():\n    n = int(input())\n    li = list(map(int, input().split()))\n    binaries = [0]*n\n    adj = [set() for _ in range(n)]\n    for index, i in enumerate(li):\n        binaries[index] = (bin(i)[2:].zfill(60))\n    edges = set()\n    #print(\"Pass 0\")\n    for j in range(60):\n        indexes = []\n        for i in range(n):\n            if binaries[i][j] == '1':\n                indexes.append(i)\n                if len(indexes) == 3:\n                    print(3)\n                    return\n        if len(indexes)==2:\n            indexes.sort()\n            edges.add(tuple(indexes))\n            adj[indexes[0]].add(indexes[1])\n            adj[indexes[1]].add(indexes[0])\n    #print(edges, adj)\n    min_cycle = -1\n    for li in edges:\n        le = bfs(li[0], li[1], adj)\n        #print(li, le, min_cycle)\n        if min_cycle==-1:\n            min_cycle = le\n        elif le>-1:\n            min_cycle = min(min_cycle, le)\n    print(min_cycle)\n\nmain()\n", "from collections import defaultdict, deque\nimport sys\n\nn = int(input())\na = [int(val) for val in input().split()]\na = [val for val in a if val > 0]\nn = len(a)\n\ncount = defaultdict(list)\nfor i, val in enumerate(a):\n    power = 0\n    while val > 0:\n        if val % 2 == 1:\n            count[power].append(i)\n        power +=1\n        val = val >> 1\n\nfor power, val in list(count.items()):\n    if len(val) >= 3:\n        print(3)\n        return\n\nG = defaultdict(list)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        if a[i] & a[j] > 0:\n            G[i].append(j) \n            G[j].append(i) \n\nmin_cycle = n + 1\nfor key, _ in list(G.items()):\n    qu = deque()\n    qu.append((key, 0, None))\n    visited = {}\n    while len(qu) > 0:\n        node = qu.popleft()\n        visited[node[0]] = node[1]\n        for child in G[node[0]]:\n            if child not in visited:\n                 qu.append((child, node[1] + 1, node[0]))\n            else:\n                if node[2] != child:\n                    min_cycle = min(min_cycle, visited[child] + node[1] + 1)\nif min_cycle == n + 1:\n    print(-1)\nelse:\n    print(min_cycle)\n\n", "import sys\ninput=sys.stdin.readline\nimport collections\nfrom collections import defaultdict\n\nvisited=set()\nmem=[]\nG=defaultdict(list)\nn=int(input())\nl=[int(i) for i  in input().split()]\nl=[i for i in l if i>0]\n\nif len(l)>=128 :\n    print(3)\nelif len(l)<3:\n    print(-1)\nelse:\n    for i in range(1,len(l)):\n        for j in range(0,i):\n            if l[i]&l[j]!=0:\n                G[i].append(j)\n                G[j].append(i)\n    #print(G)\n    min_cycle = n + 1\n    for key, _ in list(G.items()):\n        #print(key,_)\n        qu = collections.deque()\n        qu.append((key, 0, None))\n        visited = {}\n        while len(qu) > 0:\n            #print(qu,visited)\n            node = qu.popleft()\n            visited[node[0]] = node[1]\n            for child in G[node[0]]:\n                if child not in visited:\n                     qu.append((child, node[1] + 1, node[0]))\n                     #print(qu)\n                else:\n                    if node[2] != child:\n                        min_cycle = min(min_cycle, visited[child] + node[1] + 1)\n                        #print(min_cycle,visited[child],node[1])\n    if min_cycle == n + 1:\n        print(-1)\n    else:\n        print(min_cycle)\n\n    \n", "from collections import deque\n\n\ninput()\nh = [list(bin(int(i)))[2:] for i in input().split()]\nsas = min(list(map(len, h)))\nans = 1e9\ngraf = [[] for _ in range(100000)]\nrebra = []\ndef bfs(assx, sasx):\n    q = deque()\n    q.append(assx)\n    metka = [1 for _ in range(100000)]\n    metka[assx] = 0\n    dis = [0 for _ in range(100000)]\n    while q:\n        x = q.popleft()\n        for i in graf[x]:\n            if i == sasx and x != assx:\n                return dis[x] + 2\n            if metka[i] and (i != sasx or x != assx):\n                metka[i] = 0\n                dis[i] = dis[x] + 1\n                q.append(i)\n    return 0\nfor i in range(len(h)):\n    h[i].reverse()\nfor i in range(60):\n    r = 0\n    ass = []\n    for j in range(len(h)):\n        if len(h[j]) <= i:\n            continue\n        if int(h[j][i]):\n            r += 1\n            ass.append(j)\n    if r >= 3:\n        print(3)\n        return\n    if len(ass) > 1:\n        graf[ass[0]].append(ass[1])\n        graf[ass[1]].append(ass[0])\n        rebra.append(ass)\nfor i in rebra:\n    g = bfs(i[0], i[1])\n    if g:\n        ans = min(ans, g)\nprint(ans if ans != 1e9 else -1)\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/10 01:32\n\n\"\"\"\n\n\ndef shortest_path(u, v, g):\n    q = [w for w in g[u] if w != v]\n    vis = set(q) | {u}\n    d = 0\n    while q:\n        d += 1\n        nq = []\n        for w in q:\n            if w == v:\n                return d\n            for x in g[w]:\n                if x not in vis:\n                    vis.add(x)\n                    nq.append(x)\n        q = nq\n\n    return float('inf')\n\n\ndef solve(N, A):\n    b = 1\n    g = collections.defaultdict(list)\n    edges = []\n    for i in range(64):\n        connected = [i for i, v in enumerate(A) if v & b > 0]\n        if len(connected) >= 3:\n            return 3\n        for u in connected:\n            for v in connected:\n                if u != v:\n                    g[u].append(v)\n                    edges.append((u, v))\n        b <<= 1\n\n    # print(g)\n    ans = float('inf')\n    for u, v in edges:\n        # remove edge u, v\n        # print(u, v, shortest_path(u, v, g))\n        ans = min(ans, 1 + shortest_path(u, v, g))\n\n    return ans if ans < float('inf') else -1\n\n\nN = int(input())\nA = [int(x) for x in input().split()]\nprint(solve(N, A))", "from collections import deque\ninf = int(1e6)\n\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.adj = [[] for i in range(n)]\n        self.loop = inf\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def find_loop(self):\n        for i in range(n):\n            q = deque()\n            q.append(i)\n            depth = [-1] * n\n            depth[i] = 0\n            while len(q) > 0:\n                u = q.popleft()\n                for v in self.adj[u]:\n                    if depth[v] >= depth[u]:\n                        self.loop = min(self.loop, depth[u] + depth[v] + 1)\n                    if depth[v] == -1:\n                        depth[v] = depth[u] + 1\n                        q.append(v)\n        return -1 if self.loop == inf else self.loop\n\n\ninput()\na = list([x for x in map(int, input().split(' ')) if x != 0])\nn = len(a)\ngroups = [0] * 64\nfor num in a:\n    t = '{0:b}'.format(num)\n    l = len(t)\n    curr = 0\n    for i in range(l):\n        if t[l - i - 1] == '1':\n            groups[i] += 1\n\nloop = -1\nfor cnt in groups:\n    if cnt >= 3:\n        loop = 3\n        break\nif loop == 3:\n    print(3)\nelse:\n    g = Graph(n)\n    for i in range(n-1):\n        for j in range(i + 1, n):\n            if a[i] & a[j] != 0:\n                g.add_edge(i, j)\n    print(g.find_loop())\n", "import sys\nimport math\nfrom collections import defaultdict\n\ndef print_graph(graph):\n    for key, values in graph.items():\n        [print(key,nodo) for nodo in values]\n\ndef BFS(graph, n, start, end):\n    #print(\"==================\")\n    #print(\"Partiendo BFS:\")\n    #print(\"Nodo Start:\", start)\n    #print(\"Nodo end:\", end)\n    q = [ (start,0) ]\n    visited = [False for x in range(n)]\n    visited[start] = True\n    while (len(q) >0):\n        aux = q.pop(0)\n        actual = aux[0]\n        peso = aux[1]+1\n        #print(\"===========\")\n        #print(\"Nodo Actual:\",actual)\n        for vecino in graph[actual]:\n            \n            #saltamos el arco base\n            if not visited[vecino] and not ((actual == start and end == vecino) or (vecino == start and end == actual)):\n                #print(\"Vecino:\",vecino)\n                q.append( (vecino, peso) )\n                visited[vecino] = True\n                if vecino == end:\n                    peso+=1\n                    #print(\"PESO FINAL:\", peso)\n                    return peso\n        \n        #print(\"peso hasta el momento:\", peso)\n    return -1    \n \nlines = sys.stdin.read().split(\"\\n\")\nlines.pop(-1)\n#lines = [\"50\", \"65600 17825792 0 288230376285929472 16392 0 0 16896 0 0 10486272 140737488355330 65537 171798691840 571746046443520 0 0 33024 0 2052 36028797155278848 36028805608898560 0 0 562967133290496 0 0 0 146028888064 281474976710660 0 288230376151711746 8388864 0 17180393472 0 0 0 68719476737 34376515584 0 299067162755072 68719478784 0 9007199255789568 140737488879616 9007199254773760 8796093022272 4294967304 17596481011712\"]\n#lines = [\"4\", \"3 6 28 9\"]\nn = int(lines[0].strip())\n#nodos_int = [  int(x) for x in lines[1].strip().split(\" \")]\nnodos = [  \"{0:b}\".format(int(x)).zfill(60) for x in lines[1].strip().split(\" \")]\ngraph = dict()\nvertex = []\n \nfor i in range(n):\n    graph[i] = []\n    \nfor bit in range(60):\n    count = 0\n    q = []\n    for index in range(n):\n        if nodos[index][bit] =='1':\n            count+=1\n            q.append(index)\n    if count==2:\n        graph[q[0]] += [q[1]]\n        graph[q[1]] += [q[0]]\n        vertex.append([q[0],q[1]])\n    if count>2:\n        print(3)\n        return\n \n##print(vertex)\n##print(graph)\n        \nminimo = -1\nfor index in range(n):\n    while len(vertex) > 0:\n        a,b = vertex.pop(0)\n        peso = BFS(graph, n ,a,b)\n        if (peso > 0):\n            if minimo == -1:\n                minimo = peso\n            elif peso<minimo:\n                minimo = peso\n        \nprint(minimo)\n#print_graph(graph)\n", "n=int(input())\nlinea = input()\nsep = linea.split()\nnodos = list(map(int, sep))\n\nconexiones=[list() for i in range(n)]\nlista_bits = [list() for i in range(64)]\nj = 0\nfor caquita in nodos:\n    if caquita != 0:\n        for z in range(64):\n            if not (caquita >> z):\n                break\n            bit = (caquita >> z) & 1\n            if bit == 1:\n                lista_bits[z].append(j)\n    else:\n        j -= 1\n        n -= 1\n    j += 1\n\n\n# Python3 implementation of the approach \nfrom sys import maxsize as INT_MAX \nfrom collections import deque \n  \ngr = conexiones\n  \n# Function to find the length of \n# the shortest cycle in the graph \ndef shortest_cycle(n: int) -> int: \n  \n    # To store length of the shortest cycle \n    ans = INT_MAX \n  \n    # For all vertices \n    for i in range(n): \n  \n        # Make distance maximum \n        dist = [int(1e9)] * n \n  \n        # Take a imaginary parent \n        par = [-1] * n \n  \n        # Distance of source to source is 0 \n        dist[i] = 0\n        q = deque() \n  \n        # Push the source element \n        q.append(i) \n  \n        # Continue until queue is not empty \n        while q: \n  \n            # Take the first element \n            x = q[0] \n            q.popleft() \n  \n            # Traverse for all it's childs \n            for child in gr[x]: \n  \n                # If it is not visited yet \n                if dist[child] == int(1e9): \n  \n                    # Increase distance by 1 \n                    dist[child] = 1 + dist[x] \n  \n                    # Change parent \n                    par[child] = x \n  \n                    # Push into the queue \n                    q.append(child) \n  \n                # If it is already visited \n                elif par[x] != child and par[child] != x: \n                    ans = min(ans, dist[x] + \n                                   dist[child] + 1) \n  \n    # If graph contains no cycle \n    if ans == INT_MAX: \n        return -1\n  \n    # If graph contains cycle \n    else: \n        return ans \n\nal_menos_tres = False\nson_2 = False\nfor listita in lista_bits:\n    if len(listita) >= 3:\n        al_menos_tres = True\n        break\n    elif len(listita) == 2:\n        son_2 = True\n        x = listita[0]\n        y = listita[1]\n        gr[x].append(y)\n        gr[y].append(x)\n\nif al_menos_tres:\n    print(3)\nelif not son_2:\n    print(-1)\nelse:\n    print(shortest_cycle(n)) \n\n# This code is contributed by \n# sanjeev2552 \n\n", "from sys import maxsize as INT_MAX \nfrom collections import deque \n  \nn=int(input())\nlinea = input()\nsep = linea.split()\nnodos = list(map(int, sep))\nbits= [list() for i in range (64)]\nj=0\nfor s in nodos:\n    if s!=0:\n        for i in range(64):\n            bit=(s >> i) & 1\n            if bit==1:\n                bits[i].append(j)\n    else:\n        j-=1\n        n-=1\n    j+=1\ndos= False\nejecucion= True\ngr=[list() for i in range (n)]\nfor k in bits:\n    if len(k)==2:\n        dos=True\n        x= k[0]\n        y= k[1]\n        gr[x].append(y)\n        gr[y].append(x)\n    elif len(k) >= 3:\n        ejecucion= False\n        break\nif ejecucion==False: \n    print(3)\nelif not dos:\n    print(-1)\nelse:\n    # Python3 implementation of the approach \n      \n    # Function to find the length of \n    # the shortest cycle in the graph \n    def shortest_cycle(n: int) -> int: \n      \n        # To store length of the shortest cycle \n        ans = INT_MAX \n      \n        # For all vertices \n        for i in range(n): \n      \n            # Make distance maximum \n            dist = [int(1e9)] * n \n      \n            # Take a imaginary parent \n            par = [-1] * n \n      \n            # Distance of source to source is 0 \n            dist[i] = 0\n            q = deque() \n      \n            # Push the source element \n            q.append(i) \n      \n            # Continue until queue is not empty \n            while q: \n      \n                # Take the first element \n                x = q[0] \n                q.popleft() \n      \n                # Traverse for all it's childs \n                for child in gr[x]: \n      \n                    # If it is not visited yet \n                    if dist[child] == int(1e9): \n      \n                        # Increase distance by 1 \n                        dist[child] = 1 + dist[x] \n      \n                        # Change parent \n                        par[child] = x \n      \n                        # Push into the queue \n                        q.append(child) \n      \n                    # If it is already visited \n                    elif par[x] != child and par[child] != x: \n                        ans = min(ans, dist[x] + \n                                       dist[child] + 1) \n      \n        # If graph contains no cycle \n        if ans == INT_MAX: \n            return -1\n      \n        # If graph contains cycle \n        else: \n            return ans \n      \n      \n    # Function call \n    print(shortest_cycle(n)) \n      \n    # This code is contributed by \n    # sanjeev2552 \n\n", "import sys\ninput=sys.stdin.readline\nimport collections\nfrom collections import defaultdict\n\nvisited=set()\nmem=[]\nG=defaultdict(list)\nn=int(input())\nl=[int(i) for i  in input().split()]\nl=[i for i in l if i>0]\n\nif len(l)>=121 :\n    print(3)\nelif len(l)<3:\n    print(-1)\nelse:\n    for i in range(1,len(l)):\n        for j in range(0,i):\n            if l[i]&l[j]!=0:\n                G[i].append(j)\n                G[j].append(i)\n    #print(G)\n    min_cycle = n + 1\n    for key, _ in list(G.items()):\n        #print(key,_)\n        qu = collections.deque()\n        qu.append((key, 0, None))\n        visited = {}\n        while len(qu) > 0:\n            #print(qu,visited)\n            node = qu.popleft()\n            visited[node[0]] = node[1]\n            for child in G[node[0]]:\n                if child not in visited:\n                     qu.append((child, node[1] + 1, node[0]))\n                     #print(qu)\n                else:\n                    if node[2] != child:\n                        min_cycle = min(min_cycle, visited[child] + node[1] + 1)\n                        #print(min_cycle,visited[child],node[1])\n    if min_cycle == n + 1:\n        print(-1)\n    else:\n        print(min_cycle)\n\n    \n", "from sys import stdin\nfrom collections import deque\n\n\nINT_MAX = float('inf')\ndef shortest_cycle(gr): \n  \n    # To store length of the shortest cycle \n    ans = INT_MAX \n  \n    # For all vertices \n    for i in gr: \n  \n        # Make distance maximum \n        dist = {x:int(1e9) for x in gr}\n  \n        # Take a imaginary parent \n        par = {x:-1 for x in gr} \n  \n        # Distance of source to source is 0 \n        dist[i] = 0\n        q = deque() \n  \n        # Push the source element \n        q.append(i) \n  \n        # Continue until queue is not empty \n        while q: \n  \n            # Take the first element \n            x = q.popleft() \n  \n            # Traverse for all it's childs \n            for child in gr[x]: \n  \n                # If it is not visited yet \n                if dist[child] == int(1e9): \n  \n                    # Increase distance by 1 \n                    dist[child] = 1 + dist[x] \n  \n                    # Change parent \n                    par[child] = x \n  \n                    # Push into the queue \n                    q.append(child) \n  \n                # If it is already visited \n                elif par[x] != child and par[child] != x: \n                    ans = min(ans, dist[x] + \n                                   dist[child] + 1) \n  \n    # If graph contains no cycle \n    if ans == INT_MAX: \n        return -1\n  \n    # If graph contains cycle \n    else: \n        return ans\n    \nn = int(stdin.readline())\na = sorted([int(x) for x in stdin.readline().split()])\n\nif n-a.count(0) > 128:\n    print(3)\n\nelse:\n\n    l = [[] for x in range(64)]\n\n    mini = False\n    for x in a:\n        c = 1\n        for y in range(64):\n            if x & c:\n                l[y].append(x)\n                if len(l[y]) > 2:\n                    mini = True\n            c <<= 1\n\n    if mini:\n        print(3)\n    else:\n        minC = float('inf')\n        minX = -1\n        flatL = set()\n        for x in l:\n            for y in x:\n                flatL.add(y)\n        graph = {}\n        for x in flatL:\n            graph[x] = set()\n            for y in flatL:\n                if y != x and y&x:\n                    graph[x].add(y)\n        print(shortest_cycle(graph))\n        '''for x in graph:\n            visited = {}\n            q = deque()\n            q.append((x,x,0))\n            valid = False\n            while q and not valid:\n                n,p,d = q.popleft()\n                if not n in visited:\n                    visited[n] = d\n                    for y in graph[n]:\n                        if y != p:\n                            if y in visited:\n                                valid = d+visited[y]\n                                break\n                            else:\n                                q.append((y,n,d+1))\n            if valid:\n                minC = min(minC,valid)\n                minX = x\n        if minC != float('inf'):\n            print(minC+1)\n        else:\n            print(-1)'''\n        #print(minX)\n", "def solve(n,a):\n\tB = 60\n\tbits = [[] for i in range(B)]\n\tfor i in range(n):\n\t\tfor j in range(B):\n\t\t\tif a[i]&(1<<j):\n\t\t\t\tbits[j].append(i)\n\n\tadj = [[] for i in range(n)]\n\tfor shared in bits:\n\t\tif len(shared) >= 3:\n\t\t\treturn 3\n\t\telif len(shared)==2:\n\t\t\tu, v = shared\n\t\t\tadj[u].append(v)\n\t\t\tadj[v].append(u)\n\n\tvis = [False for u in range(n)]\n\tdist = [-1 for u in range(n)]\n\tdef shortest_cycle(n,adj,s):\n\t\tfrontier = [(s,-1)]\n\t\tdist[s] = 0\n\t\tptr = 0\n\n\t\twhile ptr < len(frontier):\n\t\t\tu, p = frontier[ptr]\n\t\t\tif not vis[u]:\n\t\t\t\tvis[u] = True\n\t\t\t\tfor v in adj[u]:\n\t\t\t\t\tif vis[v] and v != p:\n\t\t\t\t\t\tans = dist[u]+dist[v]+1\n\t\t\t\t\t\tfor u, p in frontier:\n\t\t\t\t\t\t\tvis[u] = False\n\t\t\t\t\t\t\tdist[u] = -1\n\t\t\t\t\t\treturn ans\n\t\t\t\t\tif dist[v]==-1:\n\t\t\t\t\t\tdist[v] = dist[u] + 1\n\t\t\t\t\t\tfrontier.append((v,u))\t\n\t\t\tptr += 1\n\n\t\treturn 10**18 #INF\n\n\tans = min([shortest_cycle(n,adj,i) for i in range(n)])\n\tif ans==10**18:\n\t\tans = -1\n\n\treturn ans\n\nprint(solve(int(input()),list(map(int,input().split()))))\n\n"]
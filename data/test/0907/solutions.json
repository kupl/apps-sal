["from copy import copy\nn, m = map(int, input().split())\nP = []\nz = set()\nfor i in range(1, n + 1):\n    z.add(i)\nfor i in range(m):\n    P.append(list(map(int, input().split())))\nfor x in P[0][0], P[0][1]:\n    s = copy(z)\n    for i in range(1, m):\n        a, b = P[i]\n        if a != x and b != x:\n            s.intersection_update({a, b})\n    if len(s):\n        print('YES')\n        return\nprint('NO')", "import sys\n# gcd\n# from fractions import gcd\n# from math import ceil, floor\n# from copy import deepcopy\n# from itertools import accumulate\n# l = ['a', 'b', 'b', 'c', 'b', 'a', 'c', 'c', 'b', 'c', 'b', 'a']\n# print(S.most_common(2))  # [('b', 5), ('c', 4)]\n# print(S.keys())  # dict_keys(['a', 'b', 'c'])\n# print(S.values())  # dict_values([3, 5, 4])\n# print(S.items())  # dict_items([('a', 3), ('b', 5), ('c', 4)])\n# from collections import Counter\n# import math\n# from functools import reduce\n#\n# fin = open('in_1.txt', 'r')\n# sys.stdin = fin\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().rstrip().split()))\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n\ndef __starting_point():\n\n    # write code\n    n, m = mi()\n    l = [0]*m\n    r = [0]*m\n    for i in range(m):\n        l[i], r[i] = mi()\n    lf = l[0]\n    rf = r[0]\n    flag = True\n    for i in range(m):\n        if l[i] != lf and r[i] != lf:\n            if l[i] != rf and r[i] != rf:\n                lf2 = l[i]\n                rf2 = r[i]\n                flag = False\n                break\n    if flag:\n        print('YES')\n        return\n    Lis = [lf, rf, lf2, rf2]\n    for i in range(3):\n        for j in range(i + 1, 4):\n            left = Lis[i]\n            right = Lis[j]\n            for cnt in range(m):\n                if l[cnt] != left and r[cnt] != left:\n                    if l[cnt] != right and r[cnt] != right:\n                        break\n            else:\n                print('YES')\n                return\n    print('NO')\n\n__starting_point()", "def main():\n    def check(x, y):\n        for a, b in mas:\n            if not((a == x or a == y) or (b == x or b == y)):\n                return [a, b]\n        return [-1, -1]\n    def check1(x, y):\n        for a, b in mas:\n            if not((a == x or a == y) or (b == x or b == y)):\n                return False\n        return True\n    n, m = list(map(int, input().split()))\n    mas = []\n    ans = False\n    for i in range(m):\n        mas.append(sorted(list(map(int, input().split()))))\n    k = check(*mas[0])\n    if k == [-1, -1]:\n        print('YES')\n    else:\n        ans = check1(mas[0][0], k[0]) or check1(mas[0][0], k[1]) or check1(mas[0][1], k[0]) or check1(mas[0][1], k[1])\n        if ans:\n            print('YES')\n        else:\n            print('NO')\nmain()", "from sys import stdin\n# stdin=open('input.txt')\n\ndef input():\n\treturn stdin.readline().strip()\n\n\n# from sys import stdout\n# stdout=open('input.txt',mode='w+')\n\n# def print1(x, end='\\n'):\n# \tstdout.write(str(x) +end)\n\n\n# a, b = map(int, input().split())\n\n# l = list(map(int, input().split()))\n\n\n# # CODE BEGINS HERE.................\nfrom itertools import permutations, combinations\n\n\nm, n = list(map(int, input().split()))\n\npairs = []\nfor i in range(n):\n\ta, b = list(map(int, input().split()))\n\tpairs.append((a, b))\n\nif n == 1:\n\tprint('YES')\nelse:\n\tpossible = set([pairs[0][0], pairs[0][1]])\n\tflag = True\n\tfor i in range(n):\n\t\tif pairs[i][0] in possible or pairs[i][1] in possible:\n\t\t\tcontinue\n\t\telse:\n\t\t\tif len(possible) == 4:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tpossible.add(pairs[i][0])\n\t\t\t\tpossible.add(pairs[i][1])\n\tif flag:\n\t\tpossible = list(possible)\n\t\tx_y = list(combinations(possible, 2))\n\t\tfor x, y in x_y:\n\t\t\tx_y_ = set([x, y])\n\t\t\tflag = True\n\t\t\tfor i in range(n):\n\t\t\t\tif pairs[i][0] in x_y_ or pairs[i][1] in x_y_:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tflag = False\n\t\t\t\t\tbreak\t\n\t\t\tif flag:\n\t\t\t\tbreak\n\n\tif flag:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\n# # CODE ENDS HERE....................\n# stdout.close()\n\n", "n,m=list(map(int, input().split()))\npairs=[tuple(int(x) for x in input().split()) for _ in range(m)]\n\n# print(pairs)\npossible={pairs[0], (pairs[0][0], None), (pairs[0][1], None)}\n# print(pairs[0], possible)\nfor p in pairs[1:]:\n    add=set()\n    remove=set()\n    for o in possible:\n        if p[0] in o or p[1] in o:\n            continue\n        remove.add(o)\n        if o[1] is None:\n            add.add((o[0], p[0]))\n            add.add((o[0], p[1]))\n    possible = (possible - remove) | add\n    # print(p, possible)\n    if not possible:\n        break\n\nif not possible:\n    print('NO')\nelse:\n    print('YES')\n", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \n# INF = 100_000_000\n\n# from heapq import heappush, heappop\n# from collections import defaultdict\n# from math import sqrt\n\nt = 1#int(input())\n\nfor test in range(t):\n    # n = int(input())\n    ans = \"NO\"\n    n,m = (((list(map(int, input().split())))))\n    arr = []\n    for i in range(m):\n        a,b = (((list(map(int, input().split())))))\n        tmp = [a,b]\n        arr.append(tmp)\n\n    x = arr[0][0]\n    y = [i for i in range(n+1)]\n    y = set(y)\n    for pair in arr:\n        if x not in pair:\n            y = y.intersection(set(pair))\n    if len(y)>0:\n        ans=\"YES\"\n\n    x = arr[0][1]\n    y = [i for i in range(n+1)]\n    y = set(y)\n    for pair in arr:\n        if x not in pair:\n            y = y.intersection(set(pair))\n    if len(y)>0:\n        ans=\"YES\"\n\n    print(ans)\n        \n        \n        \n\n\n\n", "n,m=list(map(int,input().split()))\nms=[]\ncnt={}\ndef cd(x):\n    if x in cnt:\n        cnt[x]+=1\n    else:\n        cnt[x]=1\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    ms.append((x,y))\n    cd(x)\n    cd(y)\nans=[]\nfor k,v in list(cnt.items()):\n    if v>=m//2:\n        ans.append(k)\ndef check_one(c):\n    for i in range(m):\n        x,y=ms[i]\n        if x==c or y==c:\n            continue\n        if check_two(c,x,i):\n            return True\n        if check_two(c,y,i):\n            return True\n        return False\n    return True\n\ndef check_two(c1,c2,s):\n    for i in range(s,m):\n        x,y=ms[i]\n        if x==c1 or x==c2 or y==c1 or y==c2:\n            continue\n        else:\n            return False\n    return True\n\nfor a in ans:\n    if check_one(a):\n        print('YES')\n        quit()\n\nprint('NO')\n", "import sys\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\n\nnumber = [list(map(int, input().split())) for _ in range(m)]\na = number[0][0]\nb = number[0][1]\nif a > n and b > n:\n    print(\"NO\")\nelse:\n    flaga1 = 1\n    flaga2 = 1\n    flagb1 = 1\n    flagb2 = 1\n    count = 0\n    if a <= n:\n        c = a\n        d = a\n        for i in number:\n            if a not in i:\n                c = i[0]\n                d = i[1]\n                break\n\n        for i in number:\n            if a not in i and d not in i:\n                flaga1 = 0\n                break\n\n\n        for i in number:\n            if a not in i and c not in i:\n                flaga2 = 0\n                break\n\n\n\n\n    if b <= n:\n        c = b\n        d = b\n        for i in number:\n            if b not in i:\n                c = i[0]\n                d = i[1]\n                break\n\n        for i in number:\n            if b not in i and d not in i:\n                flagb1 = 0\n                break\n\n\n        for i in number:\n            if b not in i and c not in i:\n                flagb2 = 0\n                break\n\n\n    if flaga1 == 0 and flaga2 == 0 and flagb1 == 0 and flagb2 == 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n", "from collections import Counter\nfrom itertools import chain\nab = tuple((tuple(map(int, input().split())) for _ in range(int(input().split()[[2, 1][1]]))))\nfor x_ in Counter(chain(*ab)).most_common(4):\n    x = x_[0]\n    ab2 = (abi for abi in ab if x not in abi)\n    try:\n        try:\n            ys = set(next(ab2))\n        except StopIteration:\n            pass\n        else:\n            for abi2 in ab2:\n                ys.intersection_update(abi2)\n            assert ys\n        print(\"YES\")\n        break\n    except AssertionError:\n        pass\nelse:\n    print(\"NO\")\n", "n, m = map(int, input().split())\nres = [set(map(int, input().split())) for _ in range(m)]\na = res[0]\nhas = False\nfor i in range(m):\n    if not res[i] & a:\n        b = res[i]\n        has = True\nif not has:\n    print(\"YES\")\n    return\nfor x in a:\n    for y in b:\n        fail = False\n        for _ in res:\n            if x not in _ and y not in _:\n                fail = True\n        if not fail:\n            print(\"YES\")\n            return\nprint(\"NO\")", "n,m = map(int, input().strip().split())\ncan = False\npairs = []\nfor i in range (m):\n    a,b = map(int, input().strip().split())\n    pairs.append([a,b])\nfirst = pairs[0][0]\nmissed = []\nfor i in range(m):\n    if pairs[i][0] != first and pairs[i][1] != first:\n        missed.append(i)\nif missed != []:\n    ind = missed[0]\n    second = pairs[ind][0]\n    test = True\n    for i in range(len(missed)):\n        if second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n            test = False\n            break\n    if test == True:\n        can = True\n    second = pairs[ind][1]\n    test = True\n    for i in range(len(missed)):\n        if second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n            test = False\n            break\n    if test == True:\n        can = True\nelse:\n    can = True\n# second half\nfirst = pairs[0][1]\nmissed = []\nfor i in range(m):\n    if pairs[i][0] != first and pairs[i][1] != first:\n        missed.append(i)\nif missed != []:\n    ind = missed[0]\n    second = pairs[ind][0]\n    test = True\n    for i in range(len(missed)):\n        if second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n            test = False\n            break\n    if test == True:\n        can = True\n    second = pairs[ind][1]\n    test = True\n    for i in range(len(missed)):\n        if second != pairs[missed[i]][0] and second != pairs[missed[i]][1]:\n            test = False\n            break\n    if test == True:\n        can = True\nelse:\n    can = True\nif can ==  True:\n    print ('YES')\nelse:\n    print ('NO')", "from itertools import combinations\n\nn,m=list(map(int,input().split()))\nc=[[] for i in range(n+1)]\np=[]\nfor i in range(m):\n\tx,y=list(map(int,input().split()))\n\tp.append([x,y])\n\n\nx=p[0]\narr=[x[0],x[1]]\nfor i in p:\n\tif len(set(x).intersection(set(i)))==0:\n\t\tarr.append(i[0])\n\t\tarr.append(i[1])\n\t\tbreak\n\nfor i in range(m):\n\tfor j in arr:\n\t\tif j in p[i]:\n\t\t\tc[j].append(i)\n\n\nx=list(combinations(arr,2))\nreq=[i for i in range(m)]\n\nfor i in x:\n\tn1=i[0]\n\tn2=i[1]\n\tif list(set(c[n1]+c[n2]))==req:\n\t\tprint(\"YES\")\n\t\treturn\n\nprint(\"NO\")\n", "#!/usr/bin/env python3\n\n(n, m) = tuple(map(int, input().split()))\n\nx = []\nfor i in range(m):\n    pair = tuple(map(int, input().split()))\n    x.append(pair)\n\nif m == 1:\n    print('YES')\n    return\n\ns = None\ntop = x[0][0]\nfor i in range(1, m):\n    if x[i][0] != top and x[i][1] != top:\n        if s is None:\n            s = set(x[i])\n        else:\n            s &= set(x[i])\nif s is None or len(s) != 0:\n    print('YES')\n    return\n\ns = None\ntop = x[0][1]\nfor i in range(1, m):\n    if x[i][0] != top and x[i][1] != top:\n        if s is None:\n            s = set(x[i])\n        else:\n            s &= set(x[i])\nif s is None or len(s) != 0:\n    print('YES')\n    return\n\nprint('NO')\n", "\n\n\n\n\n\n\n\n\n\n\nure, nre = list(map(int, input().split()))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlolly = [list(map(int, input().split())) for i in range(nre)]\n\n\n\n\n\nimport sys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxre = lolly[0][0]\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor i in range(nre):\n\t\n\t\n\t\n\t\n\t\n\t\n\tif( xre not in lolly[i]):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tyre = lolly[i][0]\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tzre = lolly[i][1]\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tj = i\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tbreak\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif( i == nre-1):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tprint(\"YES\")\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\treturn\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nkre1 = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nkre2 = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor i in range(j, nre):\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif( xre not in lolly[i] and yre not in lolly[i]):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tkre1 = 0\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbreak\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor i in range(j, nre):\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif (xre not in lolly[i] and zre not in lolly[i]):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tkre2 = 0\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbreak\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif( kre1==1 or kre2==1):\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tprint(\"YES\")\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\treturn\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nxre = lolly[0][1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor i in range(nre):\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif( xre not in lolly[i]):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tyre = lolly[i][0]\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tzre = lolly[i][1]\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tj = i\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbreak\n\n\n\n\n\n\n\n\n\n\n\n\n\nkre1 = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nkre2 = 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor i in range(j, nre):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tif (xre not in lolly[i] and yre not in lolly[i]):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tkre1 = 0\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbreak\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor i in range(j, nre):\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif (xre not in lolly[i] and zre not in lolly[i]):\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tkre2 = 0\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbreak\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif( kre1==1 or kre2==1):\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tprint(\"YES\")\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\treturn\n\n\n\nprint(\"NO\")", "from sys import stdin\n\"\"\"\nn=int(stdin.readline().strip())\nn,m=map(int,stdin.readline().strip().split())\ns=list(map(int,stdin.readline().strip().split()))\n\"\"\"\nn,m=list(map(int,stdin.readline().strip().split()))\ns=[list(map(int,stdin.readline().strip().split())) for i in range(m)]\na,b=s[0][0],s[0][1]\ns1=[]\nflag=False\nfor i in range(len(s)):\n    if s[i][0]!=a and s[i][1]!=a:\n        s1.append(s[i])\na1=0\nb1=0\nfor i in range(len(s1)):\n    if i==0:\n        a1,b1=s1[0][0],s1[0][1]\n\n        continue\n    if a1!=s1[i][1] and a1!=s1[i][0]:\n        a1=-1\n    if b1!=s1[i][1] and b1!=s1[i][0]:\n        b1=-1\n\nif b1!=-1 or a1!=-1:\n    flag=True\ns1=[]\nfor i in range(len(s)):\n    if s[i][0]!=b and s[i][1]!=b:\n        s1.append(s[i])\na1=0\nb1=0\nfor i in range(len(s1)):\n    if i==0:\n        a1,b1=s1[0][0],s1[0][1]\n        continue\n    if a1!=s1[i][1] and a1!=s1[i][0]:\n        a1=-1\n    if b1!=s1[i][1] and b1!=s1[i][0]:\n        b1=-1\n     \nif b1!=-1 or a1!=-1:\n    flag=True   \n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "n, m = list(map(int, input().split()))\nif m <= 2:\n    print('YES')\n    return\na = list({frozenset(list(map(int, input().split()))) for q in range(m)})\nx = list(a[0])[0]\ny = list(a[0]-{x})[0]\ns = set()\nfor q in a:\n    if x not in q:\n        s.add(q)\nif len(s) < 2:\n    print('YES')\n    return\ns = iter(s)\nx = set(next(s)) & next(s)\nif len(x) != 0:\n    x = list(x)[0]\n    for q in s:\n        if x not in q:\n            break\n    else:\n        print('YES')\n        return\ns = set()\nfor q in a:\n    if y not in q:\n        s.add(q)\nif len(s) < 2:\n    print('YES')\n    return\ns = iter(s)\ny = set(next(s)) & next(s)\nif len(y) == 0:\n    print('NO')\n    return\ny = list(y)[0]\nfor q in s:\n    if y not in q:\n        print('NO')\n        break\nelse:\n    print('YES')\n", "from collections import Counter\nn, m = list(map(int, input().split()))\ncp = []\nfor i in range(m):\n    cp.append(list(map(int, input().split())))\nv1, v2 = cp[0][0], cp[0][1]\nm1, m2 = [], []\nfor i in range(1, m):\n    if v1 not in cp[i]:\n        m1.append(cp[i])\n    if v2 not in cp[i]:\n        m2.append(cp[i])\nused = [[], [], [], []]\nif (len(m1) < 2) | (len(m2) < 2):\n    print('YES')\nelse:\n    v1, v2 = m1[0][0], m1[0][1]\n    for i in range(1, len(m1)):\n        if v1 not in m1[i]:\n            used[0].append(0)\n        else:\n            used[0].append(1)\n        if v2 not in m1[i]:\n            used[1].append(0)\n        else:\n            used[1].append(1)\n\n    v1, v2 = m2[0][0], m2[0][1]\n    for i in range(1, len(m2)):\n        if v1 not in m2[i]:\n            used[2].append(0)\n        else:\n            used[2].append(1)\n        if v2 not in m2[i]:\n            used[3].append(0)\n        else:\n            used[3].append(1)\n    b = False\n    for i in range(4):\n        if Counter(used[i])[0] == 0:\n            b = True\n            break\n    if b:\n        print('YES')\n    else:\n        print('NO')\n", "import sys\n\nn, m = list(map(int, input().split()))\na, b = list(map(int, input().split()))\npool = [a, b]\npairs = [(a,b)]\nfor _ in range(m-1):\n    a, b = list(map(int, input().split()))\n    if a not in pool and b not in pool:\n        pool.append(a)\n        pool.append(b)\n    pairs.append((a, b))\n    if len(pool) >= 5:\n        print(\"NO\")\n        return\ncount = 0\nfor i in range(len(pool) - 1):\n    for j in range(i+1, len(pool)):\n        x = [pool[i], pool[j]]\n        for k in pairs:\n            if k[0] != x[0] and k[0] != x[1] and k[1] != x[0] and k[1] != x[1]:\n                count += 1\n                break\n\nif count != len(pool) * (len(pool) - 1) // 2:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "n, m = list(map(int, input().split()))\n\na, b = list(map(int, input().split()))\nar1 = [a]\nar2 = [b]\n\nlst = [[a, b]]\nfor i in range(m - 1):\n    lst.append(list(map(int, input().split())))\n\nar3 = [0, 0]\nar4 = [0, 0]\nfor a, b in lst:\n    if len(ar1) == len(ar2) == 2:\n        break\n    if len(ar1) != 2 and a not in ar1 and b not in ar1:\n        ar1.append(a)\n        ar3 = [ar1[0], b]\n    if len(ar2) != 2 and a not in ar2 and b not in ar2:\n        ar2.append(a)\n        ar4 = [ar2[0], b]\n\nans = 'NO'\nflag1, flag2, flag3, flag4 = 0, 0, 0, 0\nfor a, b in lst:\n    if a not in ar1 and b not in ar1:\n        flag1 = 1\n    if a not in ar2 and b not in ar2:\n        flag2 = 1\n    if a not in ar3 and b not in ar3:\n        flag3 = 1\n    if a not in ar4 and b not in ar4:\n        flag4 = 1\n\nif flag1 == 0 or flag2 == 0 or flag3 == 0 or flag4 == 0:\n    ans = 'YES'\nprint(ans)\n", "n,m=[int(x) for x in input().split()]\npairs=[]\nfor i in range(m):\n    a=([int(x) for x in input().split()])\n    pairs.append(a)\nx,y=pairs[0][0],pairs[0][1]\nfor item in pairs:\n    if item[0]!=x and item[0]!=y and item[1]!=x and item[1]!=y:\n        a,b,c,d=x,y,item[0],item[1]\n        break\nelse:\n    a,b,c,d=x,y,x,y\nfor x,y in (a,b),(a,c),(b,d),(c,d),(a,d),(b,c):\n    for item in pairs:\n        if item[0]!=x and item[1]!=x and item[0]!=y and item[1]!=y:\n            break\n    else:\n        print('YES')\n        break\nelse:\n    print('NO')\n", "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\n\nclass Problem:\n    def __init__(self):\n        pass\n\n    def solve(self):\n        print(self._solve())\n\n    def _solve(self):\n        n, m = [int(item) for item in input().split()]\n        pairs = []\n        cnt = {}\n        mp = defaultdict(int)\n        for i in range(m):\n            pair = sorted([int(item) for item in input().split()])\n            pairs.append(pair)\n            mp[pair[0]] += 1\n            mp[pair[1]] += 1\n            pair = tuple(pair)\n            if pair in cnt:\n                cnt[pair] += 1\n            else:\n                cnt[pair] = 1\n\n        res = []\n\n        for x in mp:\n            res.append([mp[x], x])\n        res.sort()\n        for i in range(len(res) - 1, -1, -1):\n            for j in range(len(res) - 1, i, -1):\n                if res[i][0] + res[j][0] < m:\n                    break\n                pair = tuple(sorted([res[i][1], res[j][1]]))\n                if pair[0] == pair[1]:\n                    continue\n                if not pair in cnt:\n                    occs = 0\n                else:\n                    occs = cnt[pair]\n                # print(pair, res[i][0], res[j][0], occs)\n                if res[i][0] + res[j][0] - occs == m:\n                    # return ' '.join(str(x) for x in sorted([res[i][1], res[j][1]]))\n                    return \"YES\"\n        return \"NO\"\n\n\ndef main():\n    problem = Problem()\n    problem.solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nN, M = map(int, input().split())\nP = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n#P = [list(map(int, input().split())) for _ in range(M)]\nidx = P[0][0]\nS = set()\nfor i, (a, b) in enumerate(P):\n    if a == idx or b == idx:\n        continue\n    break\nelse:\n    print('YES')\n    return\nS = set([P[i][0], P[i][1]])\nfor a, b in P[i:]:\n    if a == idx or b == idx:\n        continue\n    S.intersection_update(set([a, b]))\n    if not S:\n        break\nelse:\n    print('YES')\n    return\nidx = P[0][1]\nS = set()\nfor i, (a, b) in enumerate(P):\n    if a == idx or b == idx:\n        continue\n    break\nelse:\n    print('YES')\n    return\nS = set([P[i][0], P[i][1]])\nfor a, b in P[i:]:\n    if a == idx or b == idx:\n        continue\n    S.intersection_update(set([a, b]))\n    if not S:\n        break\nelse:\n    print('YES')\n    return\nprint('NO')", "from sys import stdin\ninput=stdin.readline\nn,m=map(int,input().split())\nd = []\nfor i in range(m):\n    d.append(list(map(int,input().split())))\nx=d[0][0]\ny=d[0][1]\nc=[]\ne=[]\ng=[]\nfor i in d:\n    if x in i:\n        c.append(i)\n    if y in i:\n        e.append(i)\n    if x not in i and y not in i:\n        g.append(i)\nif len(g)==0:\n    print('YES');return\ns=set(g[0])\nfor i in g:\n    s=s.intersection(set(i))\nif len(s)==0:\n    print('NO');return\nk=list(s)\nfor s in k:\n    fl1=fl2=1\n    for i in c:\n        if s not in i and y not in i:\n            fl1=0\n            break\n    for i in e:\n        if s not in i and x not in i:\n            fl2=0\n            break\n    if fl1 or fl2:\n        print('YES');return\nprint('NO')\n", "n, m = list(map(int, input().split()))\na = []\nb = []\ny = -1\nfor i in range(m):\n    a.append(list(map(int, input().split())))\n    b.append(set(a[-1]))\n    if i >= 1 and y == -1:\n        if not b[0]&b[-1]:\n            y = i\nif m <= 2 or y == -1:\n    print('YES')\nelse:\n    c, d, e, f = *a[0], *a[y]\n    #print(c, d, e, f, a[0], a[y], y)\n    x = [{c, e}, {c, f}, {d, e}, {d, f}]\n    z = [True, True, True, True]\n    for pair in b:\n        for zp in [0,1,2,3]:\n            z[zp] = z[zp] if pair&x[zp] else False\n            #print(zp, z, x, pair, pair&x[zp])\n    if z[0] or z[1] or z[2] or z[3]:\n        print('YES')\n    else:\n        print('NO')\n"]